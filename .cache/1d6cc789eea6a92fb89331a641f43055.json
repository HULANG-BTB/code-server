{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/charCode\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\", \"vs/editor/common/model\", \"vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase\", \"vs/editor/common/model/textModelSearch\"], function (require, exports, charCode_1, position_1, range_1, model_1, rbTreeBase_1, textModelSearch_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\n    exports.AverageBufferSize = 65535;\n    function createUintArray(arr) {\n        let r;\n        if (arr[arr.length - 1] < 65536) {\n            r = new Uint16Array(arr.length);\n        }\n        else {\n            r = new Uint32Array(arr.length);\n        }\n        r.set(arr, 0);\n        return r;\n    }\n    exports.createUintArray = createUintArray;\n    class LineStarts {\n        constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n            this.lineStarts = lineStarts;\n            this.cr = cr;\n            this.lf = lf;\n            this.crlf = crlf;\n            this.isBasicASCII = isBasicASCII;\n        }\n    }\n    exports.LineStarts = LineStarts;\n    function createLineStartsFast(str, readonly = true) {\n        let r = [0], rLength = 1;\n        for (let i = 0, len = str.length; i < len; i++) {\n            const chr = str.charCodeAt(i);\n            if (chr === charCode_1.CharCode.CarriageReturn) {\n                if (i + 1 < len && str.charCodeAt(i + 1) === charCode_1.CharCode.LineFeed) {\n                    // \\r\\n... case\n                    r[rLength++] = i + 2;\n                    i++; // skip \\n\n                }\n                else {\n                    // \\r... case\n                    r[rLength++] = i + 1;\n                }\n            }\n            else if (chr === charCode_1.CharCode.LineFeed) {\n                r[rLength++] = i + 1;\n            }\n        }\n        if (readonly) {\n            return createUintArray(r);\n        }\n        else {\n            return r;\n        }\n    }\n    exports.createLineStartsFast = createLineStartsFast;\n    function createLineStarts(r, str) {\n        r.length = 0;\n        r[0] = 0;\n        let rLength = 1;\n        let cr = 0, lf = 0, crlf = 0;\n        let isBasicASCII = true;\n        for (let i = 0, len = str.length; i < len; i++) {\n            const chr = str.charCodeAt(i);\n            if (chr === charCode_1.CharCode.CarriageReturn) {\n                if (i + 1 < len && str.charCodeAt(i + 1) === charCode_1.CharCode.LineFeed) {\n                    // \\r\\n... case\n                    crlf++;\n                    r[rLength++] = i + 2;\n                    i++; // skip \\n\n                }\n                else {\n                    cr++;\n                    // \\r... case\n                    r[rLength++] = i + 1;\n                }\n            }\n            else if (chr === charCode_1.CharCode.LineFeed) {\n                lf++;\n                r[rLength++] = i + 1;\n            }\n            else {\n                if (isBasicASCII) {\n                    if (chr !== charCode_1.CharCode.Tab && (chr < 32 || chr > 126)) {\n                        isBasicASCII = false;\n                    }\n                }\n            }\n        }\n        const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n        r.length = 0;\n        return result;\n    }\n    exports.createLineStarts = createLineStarts;\n    class Piece {\n        constructor(bufferIndex, start, end, lineFeedCnt, length) {\n            this.bufferIndex = bufferIndex;\n            this.start = start;\n            this.end = end;\n            this.lineFeedCnt = lineFeedCnt;\n            this.length = length;\n        }\n    }\n    exports.Piece = Piece;\n    class StringBuffer {\n        constructor(buffer, lineStarts) {\n            this.buffer = buffer;\n            this.lineStarts = lineStarts;\n        }\n    }\n    exports.StringBuffer = StringBuffer;\n    /**\n     * Readonly snapshot for piece tree.\n     * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n     * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n     * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n     */\n    class PieceTreeSnapshot {\n        constructor(tree, BOM) {\n            this._pieces = [];\n            this._tree = tree;\n            this._BOM = BOM;\n            this._index = 0;\n            if (tree.root !== rbTreeBase_1.SENTINEL) {\n                tree.iterate(tree.root, node => {\n                    if (node !== rbTreeBase_1.SENTINEL) {\n                        this._pieces.push(node.piece);\n                    }\n                    return true;\n                });\n            }\n        }\n        read() {\n            if (this._pieces.length === 0) {\n                if (this._index === 0) {\n                    this._index++;\n                    return this._BOM;\n                }\n                else {\n                    return null;\n                }\n            }\n            if (this._index > this._pieces.length - 1) {\n                return null;\n            }\n            if (this._index === 0) {\n                return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n            }\n            return this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n    }\n    class PieceTreeSearchCache {\n        constructor(limit) {\n            this._limit = limit;\n            this._cache = [];\n        }\n        get(offset) {\n            for (let i = this._cache.length - 1; i >= 0; i--) {\n                let nodePos = this._cache[i];\n                if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                    return nodePos;\n                }\n            }\n            return null;\n        }\n        get2(lineNumber) {\n            for (let i = this._cache.length - 1; i >= 0; i--) {\n                let nodePos = this._cache[i];\n                if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                    return nodePos;\n                }\n            }\n            return null;\n        }\n        set(nodePosition) {\n            if (this._cache.length >= this._limit) {\n                this._cache.shift();\n            }\n            this._cache.push(nodePosition);\n        }\n        valdiate(offset) {\n            let hasInvalidVal = false;\n            let tmp = this._cache;\n            for (let i = 0; i < tmp.length; i++) {\n                let nodePos = tmp[i];\n                if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                    tmp[i] = null;\n                    hasInvalidVal = true;\n                    continue;\n                }\n            }\n            if (hasInvalidVal) {\n                let newArr = [];\n                for (const entry of tmp) {\n                    if (entry !== null) {\n                        newArr.push(entry);\n                    }\n                }\n                this._cache = newArr;\n            }\n        }\n    }\n    class PieceTreeBase {\n        constructor(chunks, eol, eolNormalized) {\n            this.create(chunks, eol, eolNormalized);\n        }\n        create(chunks, eol, eolNormalized) {\n            this._buffers = [\n                new StringBuffer('', [0])\n            ];\n            this._lastChangeBufferPos = { line: 0, column: 0 };\n            this.root = rbTreeBase_1.SENTINEL;\n            this._lineCnt = 1;\n            this._length = 0;\n            this._EOL = eol;\n            this._EOLLength = eol.length;\n            this._EOLNormalized = eolNormalized;\n            let lastNode = null;\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                if (chunks[i].buffer.length > 0) {\n                    if (!chunks[i].lineStarts) {\n                        chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                    }\n                    let piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                    this._buffers.push(chunks[i]);\n                    lastNode = this.rbInsertRight(lastNode, piece);\n                }\n            }\n            this._searchCache = new PieceTreeSearchCache(1);\n            this._lastVisitedLine = { lineNumber: 0, value: '' };\n            this.computeBufferMetadata();\n        }\n        normalizeEOL(eol) {\n            let averageBufferSize = exports.AverageBufferSize;\n            let min = averageBufferSize - Math.floor(averageBufferSize / 3);\n            let max = min * 2;\n            let tempChunk = '';\n            let tempChunkLen = 0;\n            let chunks = [];\n            this.iterate(this.root, node => {\n                let str = this.getNodeContent(node);\n                let len = str.length;\n                if (tempChunkLen <= min || tempChunkLen + len < max) {\n                    tempChunk += str;\n                    tempChunkLen += len;\n                    return true;\n                }\n                // flush anyways\n                let text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n                chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n                tempChunk = str;\n                tempChunkLen = len;\n                return true;\n            });\n            if (tempChunkLen > 0) {\n                let text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n                chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            }\n            this.create(chunks, eol, true);\n        }\n        // #region Buffer API\n        getEOL() {\n            return this._EOL;\n        }\n        setEOL(newEOL) {\n            this._EOL = newEOL;\n            this._EOLLength = this._EOL.length;\n            this.normalizeEOL(newEOL);\n        }\n        createSnapshot(BOM) {\n            return new PieceTreeSnapshot(this, BOM);\n        }\n        equal(other) {\n            if (this.getLength() !== other.getLength()) {\n                return false;\n            }\n            if (this.getLineCount() !== other.getLineCount()) {\n                return false;\n            }\n            let offset = 0;\n            let ret = this.iterate(this.root, node => {\n                if (node === rbTreeBase_1.SENTINEL) {\n                    return true;\n                }\n                let str = this.getNodeContent(node);\n                let len = str.length;\n                let startPosition = other.nodeAt(offset);\n                let endPosition = other.nodeAt(offset + len);\n                let val = other.getValueInRange2(startPosition, endPosition);\n                return str === val;\n            });\n            return ret;\n        }\n        getOffsetAt(lineNumber, column) {\n            let leftLen = 0; // inorder\n            let x = this.root;\n            while (x !== rbTreeBase_1.SENTINEL) {\n                if (x.left !== rbTreeBase_1.SENTINEL && x.lf_left + 1 >= lineNumber) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                    leftLen += x.size_left;\n                    // lineNumber >= 2\n                    let accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    return leftLen += accumualtedValInCurrentIndex + column - 1;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    leftLen += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n            return leftLen;\n        }\n        getPositionAt(offset) {\n            offset = Math.floor(offset);\n            offset = Math.max(0, offset);\n            let x = this.root;\n            let lfCnt = 0;\n            let originalOffset = offset;\n            while (x !== rbTreeBase_1.SENTINEL) {\n                if (x.size_left !== 0 && x.size_left >= offset) {\n                    x = x.left;\n                }\n                else if (x.size_left + x.piece.length >= offset) {\n                    let out = this.getIndexOf(x, offset - x.size_left);\n                    lfCnt += x.lf_left + out.index;\n                    if (out.index === 0) {\n                        let lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                        let column = originalOffset - lineStartOffset;\n                        return new position_1.Position(lfCnt + 1, column + 1);\n                    }\n                    return new position_1.Position(lfCnt + 1, out.remainder + 1);\n                }\n                else {\n                    offset -= x.size_left + x.piece.length;\n                    lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                    if (x.right === rbTreeBase_1.SENTINEL) {\n                        // last node\n                        let lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                        let column = originalOffset - offset - lineStartOffset;\n                        return new position_1.Position(lfCnt + 1, column + 1);\n                    }\n                    else {\n                        x = x.right;\n                    }\n                }\n            }\n            return new position_1.Position(1, 1);\n        }\n        getValueInRange(range, eol) {\n            if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n                return '';\n            }\n            let startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n            let endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n            let value = this.getValueInRange2(startPosition, endPosition);\n            if (eol) {\n                if (eol !== this._EOL || !this._EOLNormalized) {\n                    return value.replace(/\\r\\n|\\r|\\n/g, eol);\n                }\n                if (eol === this.getEOL() && this._EOLNormalized) {\n                    if (eol === '\\r\\n') {\n                    }\n                    return value;\n                }\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            return value;\n        }\n        getValueInRange2(startPosition, endPosition) {\n            if (startPosition.node === endPosition.node) {\n                let node = startPosition.node;\n                let buffer = this._buffers[node.piece.bufferIndex].buffer;\n                let startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n                return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n            }\n            let x = startPosition.node;\n            let buffer = this._buffers[x.piece.bufferIndex].buffer;\n            let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n            x = x.next();\n            while (x !== rbTreeBase_1.SENTINEL) {\n                let buffer = this._buffers[x.piece.bufferIndex].buffer;\n                let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                if (x === endPosition.node) {\n                    ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                    break;\n                }\n                else {\n                    ret += buffer.substr(startOffset, x.piece.length);\n                }\n                x = x.next();\n            }\n            return ret;\n        }\n        getLinesContent() {\n            return this.getContentOfSubTree(this.root).split(/\\r\\n|\\r|\\n/);\n        }\n        getLength() {\n            return this._length;\n        }\n        getLineCount() {\n            return this._lineCnt;\n        }\n        getLineContent(lineNumber) {\n            if (this._lastVisitedLine.lineNumber === lineNumber) {\n                return this._lastVisitedLine.value;\n            }\n            this._lastVisitedLine.lineNumber = lineNumber;\n            if (lineNumber === this._lineCnt) {\n                this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n            }\n            else if (this._EOLNormalized) {\n                this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n            }\n            else {\n                this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n            }\n            return this._lastVisitedLine.value;\n        }\n        getLineCharCode(lineNumber, index) {\n            let nodePos = this.nodeAt2(lineNumber, index + 1);\n            if (nodePos.remainder === nodePos.node.piece.length) {\n                // the char we want to fetch is at the head of next node.\n                let matchingNode = nodePos.node.next();\n                if (!matchingNode) {\n                    return 0;\n                }\n                let buffer = this._buffers[matchingNode.piece.bufferIndex];\n                let startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n                return buffer.buffer.charCodeAt(startOffset);\n            }\n            else {\n                let buffer = this._buffers[nodePos.node.piece.bufferIndex];\n                let startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n                let targetOffset = startOffset + nodePos.remainder;\n                return buffer.buffer.charCodeAt(targetOffset);\n            }\n        }\n        getLineLength(lineNumber) {\n            if (lineNumber === this.getLineCount()) {\n                let startOffset = this.getOffsetAt(lineNumber, 1);\n                return this.getLength() - startOffset;\n            }\n            return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n        }\n        findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n            let buffer = this._buffers[node.piece.bufferIndex];\n            let startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            let start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n            let end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n            let m;\n            // Reset regex to search from the beginning\n            searcher.reset(start);\n            let ret = { line: 0, column: 0 };\n            do {\n                m = searcher.next(buffer.buffer);\n                if (m) {\n                    if (m.index >= end) {\n                        return resultLen;\n                    }\n                    this.positionInBuffer(node, m.index - startOffsetInBuffer, ret);\n                    let lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                    let retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                    let retEndColumn = retStartColumn + m[0].length;\n                    result[resultLen++] = textModelSearch_1.createFindMatch(new range_1.Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                    if (m.index + m[0].length >= end) {\n                        return resultLen;\n                    }\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            } while (m);\n            return resultLen;\n        }\n        findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n            const result = [];\n            let resultLen = 0;\n            const searcher = new textModelSearch_1.Searcher(searchData.wordSeparators, searchData.regex);\n            let startPostion = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n            if (startPostion === null) {\n                return [];\n            }\n            let endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n            if (endPosition === null) {\n                return [];\n            }\n            let start = this.positionInBuffer(startPostion.node, startPostion.remainder);\n            let end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n            if (startPostion.node === endPosition.node) {\n                this.findMatchesInNode(startPostion.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n                return result;\n            }\n            let startLineNumber = searchRange.startLineNumber;\n            let currentNode = startPostion.node;\n            while (currentNode !== endPosition.node) {\n                let lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n                if (lineBreakCnt >= 1) {\n                    // last line break position\n                    let lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                    let startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                    let nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                    let startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                    resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                    if (resultLen >= limitResultCount) {\n                        return result;\n                    }\n                    startLineNumber += lineBreakCnt;\n                }\n                let startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n                // search for the remaining content\n                if (startLineNumber === searchRange.endLineNumber) {\n                    const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                    resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                    return result;\n                }\n                resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber++;\n                startPostion = this.nodeAt2(startLineNumber, 1);\n                currentNode = startPostion.node;\n                start = this.positionInBuffer(startPostion.node, startPostion.remainder);\n            }\n            if (startLineNumber === searchRange.endLineNumber) {\n                let startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            let startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n            resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n            const wordSeparators = searchData.wordSeparators;\n            if (!captureMatches && searchData.simpleSearch) {\n                const searchString = searchData.simpleSearch;\n                const searchStringLen = searchString.length;\n                const textLength = text.length;\n                let lastMatchIndex = -searchStringLen;\n                while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                    if (!wordSeparators || textModelSearch_1.isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                        result[resultLen++] = new model_1.FindMatch(new range_1.Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                        if (resultLen >= limitResultCount) {\n                            return resultLen;\n                        }\n                    }\n                }\n                return resultLen;\n            }\n            let m;\n            // Reset regex to search from the beginning\n            searcher.reset(0);\n            do {\n                m = searcher.next(text);\n                if (m) {\n                    result[resultLen++] = textModelSearch_1.createFindMatch(new range_1.Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            } while (m);\n            return resultLen;\n        }\n        // #endregion\n        // #region Piece Table\n        insert(offset, value, eolNormalized = false) {\n            this._EOLNormalized = this._EOLNormalized && eolNormalized;\n            this._lastVisitedLine.lineNumber = 0;\n            this._lastVisitedLine.value = '';\n            if (this.root !== rbTreeBase_1.SENTINEL) {\n                let { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n                let piece = node.piece;\n                let bufferIndex = piece.bufferIndex;\n                let insertPosInBuffer = this.positionInBuffer(node, remainder);\n                if (node.piece.bufferIndex === 0 &&\n                    piece.end.line === this._lastChangeBufferPos.line &&\n                    piece.end.column === this._lastChangeBufferPos.column &&\n                    (nodeStartOffset + piece.length === offset) &&\n                    value.length < exports.AverageBufferSize) {\n                    // changed buffer\n                    this.appendToNode(node, value);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                if (nodeStartOffset === offset) {\n                    this.insertContentToNodeLeft(value, node);\n                    this._searchCache.valdiate(offset);\n                }\n                else if (nodeStartOffset + node.piece.length > offset) {\n                    // we are inserting into the middle of a node.\n                    let nodesToDel = [];\n                    let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                    if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                        let headOfRight = this.nodeCharCodeAt(node, remainder);\n                        if (headOfRight === 10 /** \\n */) {\n                            let newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                            newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                            value += '\\n';\n                        }\n                    }\n                    // reuse node for content before insertion point.\n                    if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                        let tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                        if (tailOfLeft === 13 /** \\r */) {\n                            let previousPos = this.positionInBuffer(node, remainder - 1);\n                            this.deleteNodeTail(node, previousPos);\n                            value = '\\r' + value;\n                            if (node.piece.length === 0) {\n                                nodesToDel.push(node);\n                            }\n                        }\n                        else {\n                            this.deleteNodeTail(node, insertPosInBuffer);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                    let newPieces = this.createNewPieces(value);\n                    if (newRightPiece.length > 0) {\n                        this.rbInsertRight(node, newRightPiece);\n                    }\n                    let tmpNode = node;\n                    for (let k = 0; k < newPieces.length; k++) {\n                        tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                    }\n                    this.deleteNodes(nodesToDel);\n                }\n                else {\n                    this.insertContentToNodeRight(value, node);\n                }\n            }\n            else {\n                // insert new node\n                let pieces = this.createNewPieces(value);\n                let node = this.rbInsertLeft(null, pieces[0]);\n                for (let k = 1; k < pieces.length; k++) {\n                    node = this.rbInsertRight(node, pieces[k]);\n                }\n            }\n            // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n            this.computeBufferMetadata();\n        }\n        delete(offset, cnt) {\n            this._lastVisitedLine.lineNumber = 0;\n            this._lastVisitedLine.value = '';\n            if (cnt <= 0 || this.root === rbTreeBase_1.SENTINEL) {\n                return;\n            }\n            let startPosition = this.nodeAt(offset);\n            let endPosition = this.nodeAt(offset + cnt);\n            let startNode = startPosition.node;\n            let endNode = endPosition.node;\n            if (startNode === endNode) {\n                let startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n                let endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n                if (startPosition.nodeStartOffset === offset) {\n                    if (cnt === startNode.piece.length) { // delete node\n                        let next = startNode.next();\n                        rbTreeBase_1.rbDelete(this, startNode);\n                        this.validateCRLFWithPrevNode(next);\n                        this.computeBufferMetadata();\n                        return;\n                    }\n                    this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                    this._searchCache.valdiate(offset);\n                    this.validateCRLFWithPrevNode(startNode);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                    this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                    this.validateCRLFWithNextNode(startNode);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                // delete content in the middle, this node will be splitted to nodes\n                this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n                this.computeBufferMetadata();\n                return;\n            }\n            let nodesToDel = [];\n            let startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            this.deleteNodeTail(startNode, startSplitPosInBuffer);\n            this._searchCache.valdiate(offset);\n            if (startNode.piece.length === 0) {\n                nodesToDel.push(startNode);\n            }\n            // update last touched node\n            let endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n            this.deleteNodeHead(endNode, endSplitPosInBuffer);\n            if (endNode.piece.length === 0) {\n                nodesToDel.push(endNode);\n            }\n            // delete nodes in between\n            let secondNode = startNode.next();\n            for (let node = secondNode; node !== rbTreeBase_1.SENTINEL && node !== endNode; node = node.next()) {\n                nodesToDel.push(node);\n            }\n            let prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n            this.deleteNodes(nodesToDel);\n            this.validateCRLFWithNextNode(prev);\n            this.computeBufferMetadata();\n        }\n        insertContentToNodeLeft(value, node) {\n            // we are inserting content to the beginning of node\n            let nodesToDel = [];\n            if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n                // move `\\n` to new node.\n                let piece = node.piece;\n                let newStart = { line: piece.start.line + 1, column: 0 };\n                let nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n                node.piece = nPiece;\n                value += '\\n';\n                rbTreeBase_1.updateTreeMetadata(this, node, -1, -1);\n                if (node.piece.length === 0) {\n                    nodesToDel.push(node);\n                }\n            }\n            let newPieces = this.createNewPieces(value);\n            let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n            for (let k = newPieces.length - 2; k >= 0; k--) {\n                newNode = this.rbInsertLeft(newNode, newPieces[k]);\n            }\n            this.validateCRLFWithPrevNode(newNode);\n            this.deleteNodes(nodesToDel);\n        }\n        insertContentToNodeRight(value, node) {\n            // we are inserting to the right of this node.\n            if (this.adjustCarriageReturnFromNext(value, node)) {\n                // move \\n to the new node.\n                value += '\\n';\n            }\n            let newPieces = this.createNewPieces(value);\n            let newNode = this.rbInsertRight(node, newPieces[0]);\n            let tmpNode = newNode;\n            for (let k = 1; k < newPieces.length; k++) {\n                tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n            }\n            this.validateCRLFWithPrevNode(newNode);\n        }\n        positionInBuffer(node, remainder, ret) {\n            let piece = node.piece;\n            let bufferIndex = node.piece.bufferIndex;\n            let lineStarts = this._buffers[bufferIndex].lineStarts;\n            let startOffset = lineStarts[piece.start.line] + piece.start.column;\n            let offset = startOffset + remainder;\n            // binary search offset between startOffset and endOffset\n            let low = piece.start.line;\n            let high = piece.end.line;\n            let mid = 0;\n            let midStop = 0;\n            let midStart = 0;\n            while (low <= high) {\n                mid = low + ((high - low) / 2) | 0;\n                midStart = lineStarts[mid];\n                if (mid === high) {\n                    break;\n                }\n                midStop = lineStarts[mid + 1];\n                if (offset < midStart) {\n                    high = mid - 1;\n                }\n                else if (offset >= midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n            if (ret) {\n                ret.line = mid;\n                ret.column = offset - midStart;\n                return null;\n            }\n            return {\n                line: mid,\n                column: offset - midStart\n            };\n        }\n        getLineFeedCnt(bufferIndex, start, end) {\n            // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n            // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n            if (end.column === 0) {\n                return end.line - start.line;\n            }\n            let lineStarts = this._buffers[bufferIndex].lineStarts;\n            if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n                return end.line - start.line;\n            }\n            let nextLineStartOffset = lineStarts[end.line + 1];\n            let endOffset = lineStarts[end.line] + end.column;\n            if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n                return end.line - start.line;\n            }\n            // endOffset + 1 === nextLineStartOffset\n            // character at endOffset is \\n, so we check the character before first\n            // if character at endOffset is \\r, end.column is 0 and we can't get here.\n            let previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n            let buffer = this._buffers[bufferIndex].buffer;\n            if (buffer.charCodeAt(previousCharOffset) === 13) {\n                return end.line - start.line + 1;\n            }\n            else {\n                return end.line - start.line;\n            }\n        }\n        offsetInBuffer(bufferIndex, cursor) {\n            let lineStarts = this._buffers[bufferIndex].lineStarts;\n            return lineStarts[cursor.line] + cursor.column;\n        }\n        deleteNodes(nodes) {\n            for (let i = 0; i < nodes.length; i++) {\n                rbTreeBase_1.rbDelete(this, nodes[i]);\n            }\n        }\n        createNewPieces(text) {\n            if (text.length > exports.AverageBufferSize) {\n                // the content is large, operations like substring, charCode becomes slow\n                // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n                let newPieces = [];\n                while (text.length > exports.AverageBufferSize) {\n                    const lastChar = text.charCodeAt(exports.AverageBufferSize - 1);\n                    let splitText;\n                    if (lastChar === charCode_1.CharCode.CarriageReturn || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                        // last character is \\r or a high surrogate => keep it back\n                        splitText = text.substring(0, exports.AverageBufferSize - 1);\n                        text = text.substring(exports.AverageBufferSize - 1);\n                    }\n                    else {\n                        splitText = text.substring(0, exports.AverageBufferSize);\n                        text = text.substring(exports.AverageBufferSize);\n                    }\n                    let lineStarts = createLineStartsFast(splitText);\n                    newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                    this._buffers.push(new StringBuffer(splitText, lineStarts));\n                }\n                let lineStarts = createLineStartsFast(text);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n                this._buffers.push(new StringBuffer(text, lineStarts));\n                return newPieces;\n            }\n            let startOffset = this._buffers[0].buffer.length;\n            const lineStarts = createLineStartsFast(text, false);\n            let start = this._lastChangeBufferPos;\n            if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n                && startOffset !== 0\n                && this.startWithLF(text)\n                && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n            ) {\n                this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n                start = this._lastChangeBufferPos;\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset + 1;\n                }\n                this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n                this._buffers[0].buffer += '_' + text;\n                startOffset += 1;\n            }\n            else {\n                if (startOffset !== 0) {\n                    for (let i = 0; i < lineStarts.length; i++) {\n                        lineStarts[i] += startOffset;\n                    }\n                }\n                this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n                this._buffers[0].buffer += text;\n            }\n            const endOffset = this._buffers[0].buffer.length;\n            let endIndex = this._buffers[0].lineStarts.length - 1;\n            let endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n            let endPos = { line: endIndex, column: endColumn };\n            let newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n            this._lastChangeBufferPos = endPos;\n            return [newPiece];\n        }\n        getLinesRawContent() {\n            return this.getContentOfSubTree(this.root);\n        }\n        getLineRawContent(lineNumber, endOffset = 0) {\n            let x = this.root;\n            let ret = '';\n            let cache = this._searchCache.get2(lineNumber);\n            if (cache) {\n                x = cache.node;\n                let prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n                let buffer = this._buffers[x.piece.bufferIndex].buffer;\n                let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                    ret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);\n                }\n                else {\n                    let accumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                    return buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);\n                }\n            }\n            else {\n                let nodeStartOffset = 0;\n                const originalLineNumber = lineNumber;\n                while (x !== rbTreeBase_1.SENTINEL) {\n                    if (x.left !== rbTreeBase_1.SENTINEL && x.lf_left >= lineNumber - 1) {\n                        x = x.left;\n                    }\n                    else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                        let prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                        let accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                        let buffer = this._buffers[x.piece.bufferIndex].buffer;\n                        let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                        nodeStartOffset += x.size_left;\n                        this._searchCache.set({\n                            node: x,\n                            nodeStartOffset,\n                            nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                        });\n                        return buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);\n                    }\n                    else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                        let prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                        let buffer = this._buffers[x.piece.bufferIndex].buffer;\n                        let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                        ret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);\n                        break;\n                    }\n                    else {\n                        lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                        nodeStartOffset += x.size_left + x.piece.length;\n                        x = x.right;\n                    }\n                }\n            }\n            // search in order, to find the node contains end column\n            x = x.next();\n            while (x !== rbTreeBase_1.SENTINEL) {\n                let buffer = this._buffers[x.piece.bufferIndex].buffer;\n                if (x.piece.lineFeedCnt > 0) {\n                    let accumualtedValue = this.getAccumulatedValue(x, 0);\n                    let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret += buffer.substring(startOffset, startOffset + accumualtedValue - endOffset);\n                    return ret;\n                }\n                else {\n                    let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret += buffer.substr(startOffset, x.piece.length);\n                }\n                x = x.next();\n            }\n            return ret;\n        }\n        computeBufferMetadata() {\n            let x = this.root;\n            let lfCnt = 1;\n            let len = 0;\n            while (x !== rbTreeBase_1.SENTINEL) {\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                len += x.size_left + x.piece.length;\n                x = x.right;\n            }\n            this._lineCnt = lfCnt;\n            this._length = len;\n            this._searchCache.valdiate(this._length);\n        }\n        // #region node operations\n        getIndexOf(node, accumulatedValue) {\n            let piece = node.piece;\n            let pos = this.positionInBuffer(node, accumulatedValue);\n            let lineCnt = pos.line - piece.start.line;\n            if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n                // we are checking the end of this node, so a CRLF check is necessary.\n                let realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n                if (realLineCnt !== lineCnt) {\n                    // aha yes, CRLF\n                    return { index: realLineCnt, remainder: 0 };\n                }\n            }\n            return { index: lineCnt, remainder: pos.column };\n        }\n        getAccumulatedValue(node, index) {\n            if (index < 0) {\n                return 0;\n            }\n            let piece = node.piece;\n            let lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            let expectedLineStartIndex = piece.start.line + index + 1;\n            if (expectedLineStartIndex > piece.end.line) {\n                return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n            }\n            else {\n                return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n            }\n        }\n        deleteNodeTail(node, pos) {\n            const piece = node.piece;\n            const originalLFCnt = piece.lineFeedCnt;\n            const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n            const newEnd = pos;\n            const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n            const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n            const lf_delta = newLineFeedCnt - originalLFCnt;\n            const size_delta = newEndOffset - originalEndOffset;\n            const newLength = piece.length + size_delta;\n            node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n            rbTreeBase_1.updateTreeMetadata(this, node, size_delta, lf_delta);\n        }\n        deleteNodeHead(node, pos) {\n            const piece = node.piece;\n            const originalLFCnt = piece.lineFeedCnt;\n            const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n            const newStart = pos;\n            const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n            const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n            const lf_delta = newLineFeedCnt - originalLFCnt;\n            const size_delta = originalStartOffset - newStartOffset;\n            const newLength = piece.length + size_delta;\n            node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n            rbTreeBase_1.updateTreeMetadata(this, node, size_delta, lf_delta);\n        }\n        shrinkNode(node, start, end) {\n            const piece = node.piece;\n            const originalStartPos = piece.start;\n            const originalEndPos = piece.end;\n            // old piece, originalStartPos, start\n            const oldLength = piece.length;\n            const oldLFCnt = piece.lineFeedCnt;\n            const newEnd = start;\n            const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n            const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n            node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n            rbTreeBase_1.updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n            // new right piece, end, originalEndPos\n            let newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n            let newNode = this.rbInsertRight(node, newPiece);\n            this.validateCRLFWithPrevNode(newNode);\n        }\n        appendToNode(node, value) {\n            if (this.adjustCarriageReturnFromNext(value, node)) {\n                value += '\\n';\n            }\n            const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n            const startOffset = this._buffers[0].buffer.length;\n            this._buffers[0].buffer += value;\n            const lineStarts = createLineStartsFast(value, false);\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset;\n            }\n            if (hitCRLF) {\n                let prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n                this._buffers[0].lineStarts.pop();\n                // _lastChangeBufferPos is already wrong\n                this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            const endIndex = this._buffers[0].lineStarts.length - 1;\n            const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n            const newEnd = { line: endIndex, column: endColumn };\n            const newLength = node.piece.length + value.length;\n            const oldLineFeedCnt = node.piece.lineFeedCnt;\n            const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n            const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n            node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n            this._lastChangeBufferPos = newEnd;\n            rbTreeBase_1.updateTreeMetadata(this, node, value.length, lf_delta);\n        }\n        nodeAt(offset) {\n            let x = this.root;\n            let cache = this._searchCache.get(offset);\n            if (cache) {\n                return {\n                    node: cache.node,\n                    nodeStartOffset: cache.nodeStartOffset,\n                    remainder: offset - cache.nodeStartOffset\n                };\n            }\n            let nodeStartOffset = 0;\n            while (x !== rbTreeBase_1.SENTINEL) {\n                if (x.size_left > offset) {\n                    x = x.left;\n                }\n                else if (x.size_left + x.piece.length >= offset) {\n                    nodeStartOffset += x.size_left;\n                    let ret = {\n                        node: x,\n                        remainder: offset - x.size_left,\n                        nodeStartOffset\n                    };\n                    this._searchCache.set(ret);\n                    return ret;\n                }\n                else {\n                    offset -= x.size_left + x.piece.length;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n            return null;\n        }\n        nodeAt2(lineNumber, column) {\n            let x = this.root;\n            let nodeStartOffset = 0;\n            while (x !== rbTreeBase_1.SENTINEL) {\n                if (x.left !== rbTreeBase_1.SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    let prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    let accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    nodeStartOffset += x.size_left;\n                    return {\n                        node: x,\n                        remainder: Math.min(prevAccumualtedValue + column - 1, accumualtedValue),\n                        nodeStartOffset\n                    };\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    let prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                        return {\n                            node: x,\n                            remainder: prevAccumualtedValue + column - 1,\n                            nodeStartOffset\n                        };\n                    }\n                    else {\n                        column -= x.piece.length - prevAccumualtedValue;\n                        break;\n                    }\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n            // search in order, to find the node contains position.column\n            x = x.next();\n            while (x !== rbTreeBase_1.SENTINEL) {\n                if (x.piece.lineFeedCnt > 0) {\n                    let accumualtedValue = this.getAccumulatedValue(x, 0);\n                    let nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: Math.min(column - 1, accumualtedValue),\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    if (x.piece.length >= column - 1) {\n                        let nodeStartOffset = this.offsetOfNode(x);\n                        return {\n                            node: x,\n                            remainder: column - 1,\n                            nodeStartOffset\n                        };\n                    }\n                    else {\n                        column -= x.piece.length;\n                    }\n                }\n                x = x.next();\n            }\n            return null;\n        }\n        nodeCharCodeAt(node, offset) {\n            if (node.piece.lineFeedCnt < 1) {\n                return -1;\n            }\n            let buffer = this._buffers[node.piece.bufferIndex];\n            let newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n            return buffer.buffer.charCodeAt(newOffset);\n        }\n        offsetOfNode(node) {\n            if (!node) {\n                return 0;\n            }\n            let pos = node.size_left;\n            while (node !== this.root) {\n                if (node.parent.right === node) {\n                    pos += node.parent.size_left + node.parent.piece.length;\n                }\n                node = node.parent;\n            }\n            return pos;\n        }\n        // #endregion\n        // #region CRLF\n        shouldCheckCRLF() {\n            return !(this._EOLNormalized && this._EOL === '\\n');\n        }\n        startWithLF(val) {\n            if (typeof val === 'string') {\n                return val.charCodeAt(0) === 10;\n            }\n            if (val === rbTreeBase_1.SENTINEL || val.piece.lineFeedCnt === 0) {\n                return false;\n            }\n            let piece = val.piece;\n            let lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            let line = piece.start.line;\n            let startOffset = lineStarts[line] + piece.start.column;\n            if (line === lineStarts.length - 1) {\n                // last line, so there is no line feed at the end of this line\n                return false;\n            }\n            let nextLineOffset = lineStarts[line + 1];\n            if (nextLineOffset > startOffset + 1) {\n                return false;\n            }\n            return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n        }\n        endWithCR(val) {\n            if (typeof val === 'string') {\n                return val.charCodeAt(val.length - 1) === 13;\n            }\n            if (val === rbTreeBase_1.SENTINEL || val.piece.lineFeedCnt === 0) {\n                return false;\n            }\n            return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n        }\n        validateCRLFWithPrevNode(nextNode) {\n            if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n                let node = nextNode.prev();\n                if (this.endWithCR(node)) {\n                    this.fixCRLF(node, nextNode);\n                }\n            }\n        }\n        validateCRLFWithNextNode(node) {\n            if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n                let nextNode = node.next();\n                if (this.startWithLF(nextNode)) {\n                    this.fixCRLF(node, nextNode);\n                }\n            }\n        }\n        fixCRLF(prev, next) {\n            let nodesToDel = [];\n            // update node\n            let lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n            let newEnd;\n            if (prev.piece.end.column === 0) {\n                // it means, last line ends with \\r, not \\r\\n\n                newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n            }\n            else {\n                // \\r\\n\n                newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n            }\n            const prevNewLength = prev.piece.length - 1;\n            const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n            prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n            rbTreeBase_1.updateTreeMetadata(this, prev, -1, -1);\n            if (prev.piece.length === 0) {\n                nodesToDel.push(prev);\n            }\n            // update nextNode\n            let newStart = { line: next.piece.start.line + 1, column: 0 };\n            const newLength = next.piece.length - 1;\n            const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n            next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n            rbTreeBase_1.updateTreeMetadata(this, next, -1, -1);\n            if (next.piece.length === 0) {\n                nodesToDel.push(next);\n            }\n            // create new piece which contains \\r\\n\n            let pieces = this.createNewPieces('\\r\\n');\n            this.rbInsertRight(prev, pieces[0]);\n            // delete empty nodes\n            for (let i = 0; i < nodesToDel.length; i++) {\n                rbTreeBase_1.rbDelete(this, nodesToDel[i]);\n            }\n        }\n        adjustCarriageReturnFromNext(value, node) {\n            if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                let nextNode = node.next();\n                if (this.startWithLF(nextNode)) {\n                    // move `\\n` forward\n                    value += '\\n';\n                    if (nextNode.piece.length === 1) {\n                        rbTreeBase_1.rbDelete(this, nextNode);\n                    }\n                    else {\n                        const piece = nextNode.piece;\n                        const newStart = { line: piece.start.line + 1, column: 0 };\n                        const newLength = piece.length - 1;\n                        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                        nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                        rbTreeBase_1.updateTreeMetadata(this, nextNode, -1, -1);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n        // #endregion\n        // #endregion\n        // #region Tree operations\n        iterate(node, callback) {\n            if (node === rbTreeBase_1.SENTINEL) {\n                return callback(rbTreeBase_1.SENTINEL);\n            }\n            let leftRet = this.iterate(node.left, callback);\n            if (!leftRet) {\n                return leftRet;\n            }\n            return callback(node) && this.iterate(node.right, callback);\n        }\n        getNodeContent(node) {\n            if (node === rbTreeBase_1.SENTINEL) {\n                return '';\n            }\n            let buffer = this._buffers[node.piece.bufferIndex];\n            let currentContent;\n            let piece = node.piece;\n            let startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n            let endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n            currentContent = buffer.buffer.substring(startOffset, endOffset);\n            return currentContent;\n        }\n        getPieceContent(piece) {\n            let buffer = this._buffers[piece.bufferIndex];\n            let startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n            let endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n            let currentContent = buffer.buffer.substring(startOffset, endOffset);\n            return currentContent;\n        }\n        /**\n         *      node              node\n         *     /  \\              /  \\\n         *    a   b    <----   a    b\n         *                         /\n         *                        z\n         */\n        rbInsertRight(node, p) {\n            let z = new rbTreeBase_1.TreeNode(p, rbTreeBase_1.NodeColor.Red);\n            z.left = rbTreeBase_1.SENTINEL;\n            z.right = rbTreeBase_1.SENTINEL;\n            z.parent = rbTreeBase_1.SENTINEL;\n            z.size_left = 0;\n            z.lf_left = 0;\n            let x = this.root;\n            if (x === rbTreeBase_1.SENTINEL) {\n                this.root = z;\n                z.color = rbTreeBase_1.NodeColor.Black;\n            }\n            else if (node.right === rbTreeBase_1.SENTINEL) {\n                node.right = z;\n                z.parent = node;\n            }\n            else {\n                let nextNode = rbTreeBase_1.leftest(node.right);\n                nextNode.left = z;\n                z.parent = nextNode;\n            }\n            rbTreeBase_1.fixInsert(this, z);\n            return z;\n        }\n        /**\n         *      node              node\n         *     /  \\              /  \\\n         *    a   b     ---->   a    b\n         *                       \\\n         *                        z\n         */\n        rbInsertLeft(node, p) {\n            let z = new rbTreeBase_1.TreeNode(p, rbTreeBase_1.NodeColor.Red);\n            z.left = rbTreeBase_1.SENTINEL;\n            z.right = rbTreeBase_1.SENTINEL;\n            z.parent = rbTreeBase_1.SENTINEL;\n            z.size_left = 0;\n            z.lf_left = 0;\n            if (this.root === rbTreeBase_1.SENTINEL) {\n                this.root = z;\n                z.color = rbTreeBase_1.NodeColor.Black;\n            }\n            else if (node.left === rbTreeBase_1.SENTINEL) {\n                node.left = z;\n                z.parent = node;\n            }\n            else {\n                let prevNode = rbTreeBase_1.righttest(node.left); // a\n                prevNode.right = z;\n                z.parent = prevNode;\n            }\n            rbTreeBase_1.fixInsert(this, z);\n            return z;\n        }\n        getContentOfSubTree(node) {\n            let str = '';\n            this.iterate(node, node => {\n                str += this.getNodeContent(node);\n                return true;\n            });\n            return str;\n        }\n    }\n    exports.PieceTreeBase = PieceTreeBase;\n});\n",null]}