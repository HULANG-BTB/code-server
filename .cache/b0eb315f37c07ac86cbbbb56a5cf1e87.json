{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/packages/protocol/src/common/proxy.ts","dependencies":[{"path":"/home/coding/workspace/packages/protocol/src/common/proxy.ts","mtime":1555841535686},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"events\", \"./util\"], function (require, exports, events_1, util_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // tslint:disable no-any\n    /**\n     * Allow using a proxy like it's returned synchronously. This only works because\n     * all proxy methods return promises.\n     */\n    const unpromisify = (proxyPromise) => {\n        return new Proxy({}, {\n            get: (target, name) => {\n                if (typeof target[name] === \"undefined\") {\n                    target[name] = (...args) => __awaiter(this, void 0, void 0, function* () {\n                        const proxy = yield proxyPromise;\n                        return proxy ? proxy[name](...args) : undefined;\n                    });\n                }\n                return target[name];\n            },\n        });\n    };\n    /**\n     * Client-side emitter that just forwards proxy events to its own emitter.\n     * It also turns a promisified proxy into a non-promisified proxy so we don't\n     * need a bunch of `then` calls everywhere.\n     */\n    class ClientProxy extends events_1.EventEmitter {\n        /**\n         * You can specify not to bind events in order to avoid emitting twice for\n         * duplex streams.\n         */\n        constructor(proxyPromise, bindEvents = true) {\n            super();\n            this.bindEvents = bindEvents;\n            this.initialize(proxyPromise);\n            if (this.bindEvents) {\n                this.on(\"disconnected\", (error) => {\n                    try {\n                        this.emit(\"error\", error);\n                    }\n                    catch (error) {\n                        // If nothing is listening, EventEmitter will throw an error.\n                    }\n                    this.handleDisconnect();\n                });\n            }\n        }\n        /**\n         * Remove an event listener.\n         */\n        off(event, cb) {\n            // Fill it here because the fill we're using to provide EventEmitter for the\n            // browser doesn't appear to include `off`.\n            this.removeListener(event, cb);\n            return this;\n        }\n        get proxy() {\n            if (!this._proxy) {\n                throw new Error(\"not initialized\");\n            }\n            return this._proxy;\n        }\n        /**\n         * Initialize the proxy by unpromisifying if necessary and binding to its\n         * events.\n         */\n        initialize(proxyPromise) {\n            this._proxy = util_1.isPromise(proxyPromise) ? unpromisify(proxyPromise) : proxyPromise;\n            if (this.bindEvents) {\n                this.catch(this.proxy.onEvent((event, ...args) => {\n                    this.emit(event, ...args);\n                }));\n            }\n        }\n        /**\n         * Emit an error event if the promise errors.\n         */\n        catch(promise) {\n            if (promise) {\n                promise.catch((e) => this.emit(\"error\", e));\n            }\n            return this;\n        }\n    }\n    exports.ClientProxy = ClientProxy;\n    /**\n     * Supported top-level module proxies.\n     */\n    var Module;\n    (function (Module) {\n        Module[\"Fs\"] = \"fs\";\n        Module[\"ChildProcess\"] = \"child_process\";\n        Module[\"Net\"] = \"net\";\n        Module[\"Spdlog\"] = \"spdlog\";\n        Module[\"NodePty\"] = \"node-pty\";\n        Module[\"Trash\"] = \"trash\";\n    })(Module = exports.Module || (exports.Module = {}));\n    /**\n     * Batch remote calls.\n     */\n    class Batch {\n        constructor(\n        /**\n         * Flush after reaching this amount of time.\n         */\n        maxTime = 1000, \n        /**\n         * Flush after reaching this count.\n         */\n        maxCount = 100, \n        /**\n         * Flush after not receiving more requests for this amount of time.\n         * This is pretty low by default so essentially we just end up batching\n         * requests that are all made at the same time.\n         */\n        idleTime = 1) {\n            this.maxTime = maxTime;\n            this.maxCount = maxCount;\n            this.idleTime = idleTime;\n            this.batch = [];\n            this.add = (args) => {\n                return new Promise((resolve, reject) => {\n                    this.batch.push({\n                        args,\n                        resolve,\n                        reject,\n                    });\n                    if (this.batch.length >= this.maxCount) {\n                        this.flush();\n                    }\n                    else {\n                        clearTimeout(this.idleTimeout);\n                        this.idleTimeout = setTimeout(this.flush, this.idleTime);\n                        if (typeof this.maxTimeout === \"undefined\") {\n                            this.maxTimeout = setTimeout(this.flush, this.maxTime);\n                        }\n                    }\n                });\n            };\n            /**\n             * Flush out the current batch.\n             */\n            this.flush = () => {\n                clearTimeout(this.idleTimeout);\n                clearTimeout(this.maxTimeout);\n                this.maxTimeout = undefined;\n                const batch = this.batch;\n                this.batch = [];\n                this.remoteCall(batch.map((q) => q.args)).then((results) => {\n                    batch.forEach((item, i) => {\n                        const result = results[i];\n                        if (result && result instanceof Error) {\n                            item.reject(result);\n                        }\n                        else {\n                            item.resolve(result);\n                        }\n                    });\n                }).catch((error) => batch.forEach((item) => item.reject(error)));\n            };\n        }\n    }\n    exports.Batch = Batch;\n});\n",null]}