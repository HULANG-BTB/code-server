{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/textMate/electron-browser/textMateService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/textMate/electron-browser/textMateService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/browser/dom\", \"vs/base/common/color\", \"vs/base/common/errors\", \"vs/base/common/event\", \"vs/base/common/resources\", \"vs/base/common/types\", \"vs/editor/common/core/token\", \"vs/editor/common/modes\", \"vs/editor/common/modes/nullMode\", \"vs/editor/common/modes/supports/tokenization\", \"vs/editor/common/services/modeService\", \"vs/platform/files/common/files\", \"vs/platform/log/common/log\", \"vs/platform/notification/common/notification\", \"vs/workbench/services/textMate/common/TMGrammars\", \"vs/workbench/services/textMate/common/textMateService\", \"vs/workbench/services/themes/common/workbenchThemeService\", \"vscode-textmate\", \"vs/base/common/lifecycle\", \"vs/platform/configuration/common/configuration\", \"vs/platform/instantiation/common/extensions\"], function (require, exports, nls, dom, color_1, errors_1, event_1, resources, types, token_1, modes_1, nullMode_1, tokenization_1, modeService_1, files_1, log_1, notification_1, TMGrammars_1, textMateService_1, workbenchThemeService_1, vscode_textmate_1, lifecycle_1, configuration_1, extensions_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class TMScopeRegistry {\n        constructor() {\n            this._onDidEncounterLanguage = new event_1.Emitter();\n            this.onDidEncounterLanguage = this._onDidEncounterLanguage.event;\n            this.reset();\n        }\n        reset() {\n            this._scopeNameToLanguageRegistration = Object.create(null);\n            this._encounteredLanguages = [];\n        }\n        register(scopeName, grammarLocation, embeddedLanguages, tokenTypes) {\n            if (this._scopeNameToLanguageRegistration[scopeName]) {\n                const existingRegistration = this._scopeNameToLanguageRegistration[scopeName];\n                if (!resources.isEqual(existingRegistration.grammarLocation, grammarLocation)) {\n                    console.warn(`Overwriting grammar scope name to file mapping for scope ${scopeName}.\\n` +\n                        `Old grammar file: ${existingRegistration.grammarLocation.toString()}.\\n` +\n                        `New grammar file: ${grammarLocation.toString()}`);\n                }\n            }\n            this._scopeNameToLanguageRegistration[scopeName] = new TMLanguageRegistration(scopeName, grammarLocation, embeddedLanguages, tokenTypes);\n        }\n        getLanguageRegistration(scopeName) {\n            return this._scopeNameToLanguageRegistration[scopeName] || null;\n        }\n        getGrammarLocation(scopeName) {\n            let data = this.getLanguageRegistration(scopeName);\n            return data ? data.grammarLocation : null;\n        }\n        /**\n         * To be called when tokenization found/hit an embedded language.\n         */\n        onEncounteredLanguage(languageId) {\n            if (!this._encounteredLanguages[languageId]) {\n                this._encounteredLanguages[languageId] = true;\n                this._onDidEncounterLanguage.fire(languageId);\n            }\n        }\n    }\n    exports.TMScopeRegistry = TMScopeRegistry;\n    class TMLanguageRegistration {\n        constructor(scopeName, grammarLocation, embeddedLanguages, tokenTypes) {\n            this.scopeName = scopeName;\n            this.grammarLocation = grammarLocation;\n            // embeddedLanguages handling\n            this.embeddedLanguages = Object.create(null);\n            if (embeddedLanguages) {\n                // If embeddedLanguages are configured, fill in `this._embeddedLanguages`\n                let scopes = Object.keys(embeddedLanguages);\n                for (let i = 0, len = scopes.length; i < len; i++) {\n                    let scope = scopes[i];\n                    let language = embeddedLanguages[scope];\n                    if (typeof language !== 'string') {\n                        // never hurts to be too careful\n                        continue;\n                    }\n                    this.embeddedLanguages[scope] = language;\n                }\n            }\n            this.tokenTypes = Object.create(null);\n            if (tokenTypes) {\n                // If tokenTypes is configured, fill in `this._tokenTypes`\n                const scopes = Object.keys(tokenTypes);\n                for (const scope of scopes) {\n                    const tokenType = tokenTypes[scope];\n                    switch (tokenType) {\n                        case 'string':\n                            this.tokenTypes[scope] = vscode_textmate_1.StandardTokenType.String;\n                            break;\n                        case 'other':\n                            this.tokenTypes[scope] = vscode_textmate_1.StandardTokenType.Other;\n                            break;\n                        case 'comment':\n                            this.tokenTypes[scope] = vscode_textmate_1.StandardTokenType.Comment;\n                            break;\n                    }\n                }\n            }\n        }\n    }\n    exports.TMLanguageRegistration = TMLanguageRegistration;\n    let TextMateService = class TextMateService extends lifecycle_1.Disposable {\n        constructor(_modeService, _themeService, _fileService, _notificationService, _logService, _configurationService) {\n            super();\n            this._modeService = _modeService;\n            this._themeService = _themeService;\n            this._fileService = _fileService;\n            this._notificationService = _notificationService;\n            this._logService = _logService;\n            this._configurationService = _configurationService;\n            this._onDidEncounterLanguage = this._register(new event_1.Emitter());\n            this.onDidEncounterLanguage = this._onDidEncounterLanguage.event;\n            this._styleElement = dom.createStyleSheet();\n            this._styleElement.className = 'vscode-tokens-styles';\n            this._createdModes = [];\n            this._scopeRegistry = new TMScopeRegistry();\n            this._scopeRegistry.onDidEncounterLanguage((language) => this._onDidEncounterLanguage.fire(language));\n            this._injections = {};\n            this._injectedEmbeddedLanguages = {};\n            this._languageToScope = new Map();\n            this._grammarRegistry = null;\n            this._tokenizersRegistrations = [];\n            this._currentTokenColors = null;\n            this._themeListener = null;\n            TMGrammars_1.grammarsExtPoint.setHandler((extensions) => {\n                this._scopeRegistry.reset();\n                this._injections = {};\n                this._injectedEmbeddedLanguages = {};\n                this._languageToScope = new Map();\n                this._grammarRegistry = null;\n                this._tokenizersRegistrations = lifecycle_1.dispose(this._tokenizersRegistrations);\n                this._currentTokenColors = null;\n                if (this._themeListener) {\n                    this._themeListener.dispose();\n                    this._themeListener = null;\n                }\n                for (const extension of extensions) {\n                    let grammars = extension.value;\n                    for (const grammar of grammars) {\n                        this._handleGrammarExtensionPointUser(extension.description.extensionLocation, grammar, extension.collector);\n                    }\n                }\n                for (const createMode of this._createdModes) {\n                    this._registerDefinitionIfAvailable(createMode);\n                }\n            });\n            // Generate some color map until the grammar registry is loaded\n            let colorTheme = this._themeService.getColorTheme();\n            let defaultForeground = color_1.Color.transparent;\n            let defaultBackground = color_1.Color.transparent;\n            for (let i = 0, len = colorTheme.tokenColors.length; i < len; i++) {\n                let rule = colorTheme.tokenColors[i];\n                if (!rule.scope && rule.settings) {\n                    if (rule.settings.foreground) {\n                        defaultForeground = color_1.Color.fromHex(rule.settings.foreground);\n                    }\n                    if (rule.settings.background) {\n                        defaultBackground = color_1.Color.fromHex(rule.settings.background);\n                    }\n                }\n            }\n            modes_1.TokenizationRegistry.setColorMap([null, defaultForeground, defaultBackground]);\n            this._modeService.onDidCreateMode((mode) => {\n                let modeId = mode.getId();\n                this._createdModes.push(modeId);\n                this._registerDefinitionIfAvailable(modeId);\n            });\n        }\n        _registerDefinitionIfAvailable(modeId) {\n            if (this._languageToScope.has(modeId)) {\n                const promise = this._createGrammar(modeId).then((r) => {\n                    return new TMTokenization(this._scopeRegistry, r.languageId, r.grammar, r.initialState, r.containsEmbeddedLanguages, this._notificationService, this._configurationService);\n                }, e => {\n                    errors_1.onUnexpectedError(e);\n                    return null;\n                });\n                this._tokenizersRegistrations.push(modes_1.TokenizationRegistry.registerPromise(modeId, promise));\n            }\n        }\n        _createGrammarRegistry() {\n            return __awaiter(this, void 0, void 0, function* () {\n                const { Registry, INITIAL, parseRawGrammar } = yield new Promise((resolve_1, reject_1) => { require(['vscode-textmate'], resolve_1, reject_1); });\n                const grammarRegistry = new Registry({\n                    loadGrammar: (scopeName) => __awaiter(this, void 0, void 0, function* () {\n                        const location = this._scopeRegistry.getGrammarLocation(scopeName);\n                        if (!location) {\n                            this._logService.trace(`No grammar found for scope ${scopeName}`);\n                            return null;\n                        }\n                        try {\n                            const content = yield this._fileService.resolveContent(location, { encoding: 'utf8' });\n                            return parseRawGrammar(content.value, location.path);\n                        }\n                        catch (e) {\n                            this._logService.error(`Unable to load and parse grammar for scope ${scopeName} from ${location}`, e);\n                            return null;\n                        }\n                    }),\n                    getInjections: (scopeName) => {\n                        const scopeParts = scopeName.split('.');\n                        let injections = [];\n                        for (let i = 1; i <= scopeParts.length; i++) {\n                            const subScopeName = scopeParts.slice(0, i).join('.');\n                            injections = [...injections, ...(this._injections[subScopeName] || [])];\n                        }\n                        return injections;\n                    }\n                });\n                this._updateTheme(grammarRegistry);\n                this._themeListener = this._themeService.onDidColorThemeChange((e) => this._updateTheme(grammarRegistry));\n                return [grammarRegistry, INITIAL];\n            });\n        }\n        _getOrCreateGrammarRegistry() {\n            if (!this._grammarRegistry) {\n                this._grammarRegistry = this._createGrammarRegistry();\n            }\n            return this._grammarRegistry;\n        }\n        static _toColorMap(colorMap) {\n            let result = [null];\n            for (let i = 1, len = colorMap.length; i < len; i++) {\n                result[i] = color_1.Color.fromHex(colorMap[i]);\n            }\n            return result;\n        }\n        _updateTheme(grammarRegistry) {\n            let colorTheme = this._themeService.getColorTheme();\n            if (!this.compareTokenRules(colorTheme.tokenColors)) {\n                return;\n            }\n            grammarRegistry.setTheme({ name: colorTheme.label, settings: colorTheme.tokenColors });\n            let colorMap = TextMateService._toColorMap(grammarRegistry.getColorMap());\n            let cssRules = tokenization_1.generateTokensCSSForColorMap(colorMap);\n            this._styleElement.innerHTML = cssRules;\n            modes_1.TokenizationRegistry.setColorMap(colorMap);\n        }\n        compareTokenRules(newRules) {\n            let currRules = this._currentTokenColors;\n            this._currentTokenColors = newRules;\n            if (!newRules || !currRules || newRules.length !== currRules.length) {\n                return true;\n            }\n            for (let i = newRules.length - 1; i >= 0; i--) {\n                let r1 = newRules[i];\n                let r2 = currRules[i];\n                if (r1.scope !== r2.scope) {\n                    return true;\n                }\n                let s1 = r1.settings;\n                let s2 = r2.settings;\n                if (s1 && s2) {\n                    if (s1.fontStyle !== s2.fontStyle || s1.foreground !== s2.foreground || s1.background !== s2.background) {\n                        return true;\n                    }\n                }\n                else if (!s1 || !s2) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        _handleGrammarExtensionPointUser(extensionLocation, syntax, collector) {\n            if (syntax.language && ((typeof syntax.language !== 'string') || !this._modeService.isRegisteredMode(syntax.language))) {\n                collector.error(nls.localize('invalid.language', \"Unknown language in `contributes.{0}.language`. Provided value: {1}\", TMGrammars_1.grammarsExtPoint.name, String(syntax.language)));\n                return;\n            }\n            if (!syntax.scopeName || (typeof syntax.scopeName !== 'string')) {\n                collector.error(nls.localize('invalid.scopeName', \"Expected string in `contributes.{0}.scopeName`. Provided value: {1}\", TMGrammars_1.grammarsExtPoint.name, String(syntax.scopeName)));\n                return;\n            }\n            if (!syntax.path || (typeof syntax.path !== 'string')) {\n                collector.error(nls.localize('invalid.path.0', \"Expected string in `contributes.{0}.path`. Provided value: {1}\", TMGrammars_1.grammarsExtPoint.name, String(syntax.path)));\n                return;\n            }\n            if (syntax.injectTo && (!Array.isArray(syntax.injectTo) || syntax.injectTo.some(scope => typeof scope !== 'string'))) {\n                collector.error(nls.localize('invalid.injectTo', \"Invalid value in `contributes.{0}.injectTo`. Must be an array of language scope names. Provided value: {1}\", TMGrammars_1.grammarsExtPoint.name, JSON.stringify(syntax.injectTo)));\n                return;\n            }\n            if (syntax.embeddedLanguages && !types.isObject(syntax.embeddedLanguages)) {\n                collector.error(nls.localize('invalid.embeddedLanguages', \"Invalid value in `contributes.{0}.embeddedLanguages`. Must be an object map from scope name to language. Provided value: {1}\", TMGrammars_1.grammarsExtPoint.name, JSON.stringify(syntax.embeddedLanguages)));\n                return;\n            }\n            if (syntax.tokenTypes && !types.isObject(syntax.tokenTypes)) {\n                collector.error(nls.localize('invalid.tokenTypes', \"Invalid value in `contributes.{0}.tokenTypes`. Must be an object map from scope name to token type. Provided value: {1}\", TMGrammars_1.grammarsExtPoint.name, JSON.stringify(syntax.tokenTypes)));\n                return;\n            }\n            const grammarLocation = resources.joinPath(extensionLocation, syntax.path);\n            if (!resources.isEqualOrParent(grammarLocation, extensionLocation)) {\n                collector.warn(nls.localize('invalid.path.1', \"Expected `contributes.{0}.path` ({1}) to be included inside extension's folder ({2}). This might make the extension non-portable.\", TMGrammars_1.grammarsExtPoint.name, grammarLocation.path, extensionLocation.path));\n            }\n            this._scopeRegistry.register(syntax.scopeName, grammarLocation, syntax.embeddedLanguages, syntax.tokenTypes);\n            if (syntax.injectTo) {\n                for (let injectScope of syntax.injectTo) {\n                    let injections = this._injections[injectScope];\n                    if (!injections) {\n                        this._injections[injectScope] = injections = [];\n                    }\n                    injections.push(syntax.scopeName);\n                }\n                if (syntax.embeddedLanguages) {\n                    for (let injectScope of syntax.injectTo) {\n                        let injectedEmbeddedLanguages = this._injectedEmbeddedLanguages[injectScope];\n                        if (!injectedEmbeddedLanguages) {\n                            this._injectedEmbeddedLanguages[injectScope] = injectedEmbeddedLanguages = [];\n                        }\n                        injectedEmbeddedLanguages.push(syntax.embeddedLanguages);\n                    }\n                }\n            }\n            let modeId = syntax.language;\n            if (modeId) {\n                this._languageToScope.set(modeId, syntax.scopeName);\n            }\n        }\n        _resolveEmbeddedLanguages(embeddedLanguages) {\n            let scopes = Object.keys(embeddedLanguages);\n            let result = Object.create(null);\n            for (let i = 0, len = scopes.length; i < len; i++) {\n                let scope = scopes[i];\n                let language = embeddedLanguages[scope];\n                let languageIdentifier = this._modeService.getLanguageIdentifier(language);\n                if (languageIdentifier) {\n                    result[scope] = languageIdentifier.id;\n                }\n            }\n            return result;\n        }\n        createGrammar(modeId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const { grammar } = yield this._createGrammar(modeId);\n                return grammar;\n            });\n        }\n        _createGrammar(modeId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const scopeName = this._languageToScope.get(modeId);\n                if (typeof scopeName !== 'string') {\n                    // No TM grammar defined\n                    return Promise.reject(new Error(nls.localize('no-tm-grammar', \"No TM Grammar registered for this language.\")));\n                }\n                const languageRegistration = this._scopeRegistry.getLanguageRegistration(scopeName);\n                if (!languageRegistration) {\n                    // No TM grammar defined\n                    return Promise.reject(new Error(nls.localize('no-tm-grammar', \"No TM Grammar registered for this language.\")));\n                }\n                let embeddedLanguages = this._resolveEmbeddedLanguages(languageRegistration.embeddedLanguages);\n                let rawInjectedEmbeddedLanguages = this._injectedEmbeddedLanguages[scopeName];\n                if (rawInjectedEmbeddedLanguages) {\n                    let injectedEmbeddedLanguages = rawInjectedEmbeddedLanguages.map(this._resolveEmbeddedLanguages.bind(this));\n                    for (const injected of injectedEmbeddedLanguages) {\n                        for (const scope of Object.keys(injected)) {\n                            embeddedLanguages[scope] = injected[scope];\n                        }\n                    }\n                }\n                let languageId = this._modeService.getLanguageIdentifier(modeId).id;\n                let containsEmbeddedLanguages = (Object.keys(embeddedLanguages).length > 0);\n                const [grammarRegistry, initialState] = yield this._getOrCreateGrammarRegistry();\n                const grammar = yield grammarRegistry.loadGrammarWithConfiguration(scopeName, languageId, { embeddedLanguages, tokenTypes: languageRegistration.tokenTypes });\n                return {\n                    languageId: languageId,\n                    grammar: grammar,\n                    initialState: initialState,\n                    containsEmbeddedLanguages: containsEmbeddedLanguages\n                };\n            });\n        }\n    };\n    TextMateService = __decorate([\n        __param(0, modeService_1.IModeService),\n        __param(1, workbenchThemeService_1.IWorkbenchThemeService),\n        __param(2, files_1.IFileService),\n        __param(3, notification_1.INotificationService),\n        __param(4, log_1.ILogService),\n        __param(5, configuration_1.IConfigurationService)\n    ], TextMateService);\n    exports.TextMateService = TextMateService;\n    let TMTokenization = class TMTokenization {\n        constructor(scopeRegistry, languageId, grammar, initialState, containsEmbeddedLanguages, notificationService, configurationService) {\n            this.notificationService = notificationService;\n            this.configurationService = configurationService;\n            this._scopeRegistry = scopeRegistry;\n            this._languageId = languageId;\n            this._grammar = grammar;\n            this._initialState = initialState;\n            this._containsEmbeddedLanguages = containsEmbeddedLanguages;\n            this._seenLanguages = [];\n            this._maxTokenizationLineLength = configurationService.getValue('editor.maxTokenizationLineLength');\n        }\n        getInitialState() {\n            return this._initialState;\n        }\n        tokenize(line, state, offsetDelta) {\n            throw new Error('Not supported!');\n        }\n        tokenize2(line, state, offsetDelta) {\n            if (offsetDelta !== 0) {\n                throw new Error('Unexpected: offsetDelta should be 0.');\n            }\n            // Do not attempt to tokenize if a line is too long\n            if (line.length >= this._maxTokenizationLineLength) {\n                if (!this._tokenizationWarningAlreadyShown) {\n                    this._tokenizationWarningAlreadyShown = true;\n                    this.notificationService.warn(nls.localize('too many characters', \"Tokenization is skipped for long lines for performance reasons. The length of a long line can be configured via `editor.maxTokenizationLineLength`.\"));\n                }\n                console.log(`Line (${line.substr(0, 15)}...): longer than ${this._maxTokenizationLineLength} characters, tokenization skipped.`);\n                return nullMode_1.nullTokenize2(this._languageId, line, state, offsetDelta);\n            }\n            let textMateResult = this._grammar.tokenizeLine2(line, state);\n            if (this._containsEmbeddedLanguages) {\n                let seenLanguages = this._seenLanguages;\n                let tokens = textMateResult.tokens;\n                // Must check if any of the embedded languages was hit\n                for (let i = 0, len = (tokens.length >>> 1); i < len; i++) {\n                    let metadata = tokens[(i << 1) + 1];\n                    let languageId = modes_1.TokenMetadata.getLanguageId(metadata);\n                    if (!seenLanguages[languageId]) {\n                        seenLanguages[languageId] = true;\n                        this._scopeRegistry.onEncounteredLanguage(languageId);\n                    }\n                }\n            }\n            let endState;\n            // try to save an object if possible\n            if (state.equals(textMateResult.ruleStack)) {\n                endState = state;\n            }\n            else {\n                endState = textMateResult.ruleStack;\n            }\n            return new token_1.TokenizationResult2(textMateResult.tokens, endState);\n        }\n    };\n    TMTokenization = __decorate([\n        __param(5, notification_1.INotificationService), __param(6, configuration_1.IConfigurationService)\n    ], TMTokenization);\n    extensions_1.registerSingleton(textMateService_1.ITextMateService, TextMateService);\n});\n",null]}