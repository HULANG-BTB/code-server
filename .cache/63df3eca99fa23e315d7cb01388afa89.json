{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/model/textModelTokens.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/textModelTokens.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrays = require(\"vs/base/common/arrays\");\nvar errors_1 = require(\"vs/base/common/errors\");\nvar lineTokens_1 = require(\"vs/editor/common/core/lineTokens\");\nvar position_1 = require(\"vs/editor/common/core/position\");\nvar modes_1 = require(\"vs/editor/common/modes\");\nvar nullMode_1 = require(\"vs/editor/common/modes/nullMode\");\nfunction getDefaultMetadata(topLevelLanguageId) {\n    return ((topLevelLanguageId << modes_1.MetadataConsts.LANGUAGEID_OFFSET)\n        | (modes_1.StandardTokenType.Other << modes_1.MetadataConsts.TOKEN_TYPE_OFFSET)\n        | (modes_1.FontStyle.None << modes_1.MetadataConsts.FONT_STYLE_OFFSET)\n        | (modes_1.ColorId.DefaultForeground << modes_1.MetadataConsts.FOREGROUND_OFFSET)\n        | (modes_1.ColorId.DefaultBackground << modes_1.MetadataConsts.BACKGROUND_OFFSET)) >>> 0;\n}\nvar EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\nvar ModelLineTokens = /** @class */ (function () {\n    function ModelLineTokens(state) {\n        this._state = state;\n        this._lineTokens = null;\n        this._invalid = true;\n    }\n    ModelLineTokens.prototype.deleteBeginning = function (toChIndex) {\n        if (this._lineTokens === null || this._lineTokens === EMPTY_LINE_TOKENS) {\n            return;\n        }\n        this.delete(0, toChIndex);\n    };\n    ModelLineTokens.prototype.deleteEnding = function (fromChIndex) {\n        if (this._lineTokens === null || this._lineTokens === EMPTY_LINE_TOKENS) {\n            return;\n        }\n        var tokens = new Uint32Array(this._lineTokens);\n        var lineTextLength = tokens[tokens.length - 2];\n        this.delete(fromChIndex, lineTextLength);\n    };\n    ModelLineTokens.prototype.delete = function (fromChIndex, toChIndex) {\n        if (this._lineTokens === null || this._lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n            return;\n        }\n        var tokens = new Uint32Array(this._lineTokens);\n        var tokensCount = (tokens.length >>> 1);\n        // special case: deleting everything\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n            this._lineTokens = EMPTY_LINE_TOKENS;\n            return;\n        }\n        var fromTokenIndex = lineTokens_1.LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n        var fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n        var fromTokenEndOffset = tokens[fromTokenIndex << 1];\n        if (toChIndex < fromTokenEndOffset) {\n            // the delete range is inside a single token\n            var delta_1 = (toChIndex - fromChIndex);\n            for (var i = fromTokenIndex; i < tokensCount; i++) {\n                tokens[i << 1] -= delta_1;\n            }\n            return;\n        }\n        var dest;\n        var lastEnd;\n        if (fromTokenStartOffset !== fromChIndex) {\n            tokens[fromTokenIndex << 1] = fromChIndex;\n            dest = ((fromTokenIndex + 1) << 1);\n            lastEnd = fromChIndex;\n        }\n        else {\n            dest = (fromTokenIndex << 1);\n            lastEnd = fromTokenStartOffset;\n        }\n        var delta = (toChIndex - fromChIndex);\n        for (var tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n            var tokenEndOffset = tokens[tokenIndex << 1] - delta;\n            if (tokenEndOffset > lastEnd) {\n                tokens[dest++] = tokenEndOffset;\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n                lastEnd = tokenEndOffset;\n            }\n        }\n        if (dest === tokens.length) {\n            // nothing to trim\n            return;\n        }\n        var tmp = new Uint32Array(dest);\n        tmp.set(tokens.subarray(0, dest), 0);\n        this._lineTokens = tmp.buffer;\n    };\n    ModelLineTokens.prototype.append = function (_otherTokens) {\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\n            return;\n        }\n        if (this._lineTokens === EMPTY_LINE_TOKENS) {\n            this._lineTokens = _otherTokens;\n            return;\n        }\n        if (this._lineTokens === null) {\n            return;\n        }\n        if (_otherTokens === null) {\n            // cannot determine combined line length...\n            this._lineTokens = null;\n            return;\n        }\n        var myTokens = new Uint32Array(this._lineTokens);\n        var otherTokens = new Uint32Array(_otherTokens);\n        var otherTokensCount = (otherTokens.length >>> 1);\n        var result = new Uint32Array(myTokens.length + otherTokens.length);\n        result.set(myTokens, 0);\n        var dest = myTokens.length;\n        var delta = myTokens[myTokens.length - 2];\n        for (var i = 0; i < otherTokensCount; i++) {\n            result[dest++] = otherTokens[(i << 1)] + delta;\n            result[dest++] = otherTokens[(i << 1) + 1];\n        }\n        this._lineTokens = result.buffer;\n    };\n    ModelLineTokens.prototype.insert = function (chIndex, textLength) {\n        if (!this._lineTokens) {\n            // nothing to do\n            return;\n        }\n        var tokens = new Uint32Array(this._lineTokens);\n        var tokensCount = (tokens.length >>> 1);\n        var fromTokenIndex = lineTokens_1.LineTokens.findIndexInTokensArray(tokens, chIndex);\n        if (fromTokenIndex > 0) {\n            var fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n            if (fromTokenStartOffset === chIndex) {\n                fromTokenIndex--;\n            }\n        }\n        for (var tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n            tokens[tokenIndex << 1] += textLength;\n        }\n    };\n    return ModelLineTokens;\n}());\nvar ModelLinesTokens = /** @class */ (function () {\n    function ModelLinesTokens(languageIdentifier, tokenizationSupport) {\n        this.languageIdentifier = languageIdentifier;\n        this.tokenizationSupport = tokenizationSupport;\n        this._tokens = [];\n        if (this.tokenizationSupport) {\n            var initialState = null;\n            try {\n                initialState = this.tokenizationSupport.getInitialState();\n            }\n            catch (e) {\n                errors_1.onUnexpectedError(e);\n                this.tokenizationSupport = null;\n            }\n            if (initialState) {\n                this._tokens[0] = new ModelLineTokens(initialState);\n            }\n        }\n        this._invalidLineStartIndex = 0;\n        this._lastState = null;\n    }\n    Object.defineProperty(ModelLinesTokens.prototype, \"inValidLineStartIndex\", {\n        get: function () {\n            return this._invalidLineStartIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ModelLinesTokens.prototype.getTokens = function (topLevelLanguageId, lineIndex, lineText) {\n        var rawLineTokens = null;\n        if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {\n            rawLineTokens = this._tokens[lineIndex]._lineTokens;\n        }\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n            return new lineTokens_1.LineTokens(new Uint32Array(rawLineTokens), lineText);\n        }\n        var lineTokens = new Uint32Array(2);\n        lineTokens[0] = lineText.length;\n        lineTokens[1] = getDefaultMetadata(topLevelLanguageId);\n        return new lineTokens_1.LineTokens(lineTokens, lineText);\n    };\n    ModelLinesTokens.prototype.isCheapToTokenize = function (lineNumber) {\n        var firstInvalidLineNumber = this._invalidLineStartIndex + 1;\n        return (firstInvalidLineNumber >= lineNumber);\n    };\n    ModelLinesTokens.prototype.hasLinesToTokenize = function (buffer) {\n        return (this._invalidLineStartIndex < buffer.getLineCount());\n    };\n    ModelLinesTokens.prototype.invalidateLine = function (lineIndex) {\n        this._setIsInvalid(lineIndex, true);\n        if (lineIndex < this._invalidLineStartIndex) {\n            this._setIsInvalid(this._invalidLineStartIndex, true);\n            this._invalidLineStartIndex = lineIndex;\n        }\n    };\n    ModelLinesTokens.prototype._setIsInvalid = function (lineIndex, invalid) {\n        if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {\n            this._tokens[lineIndex]._invalid = invalid;\n        }\n    };\n    ModelLinesTokens.prototype._isInvalid = function (lineIndex) {\n        if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {\n            return this._tokens[lineIndex]._invalid;\n        }\n        return true;\n    };\n    ModelLinesTokens.prototype._getState = function (lineIndex) {\n        if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {\n            return this._tokens[lineIndex]._state;\n        }\n        return null;\n    };\n    ModelLinesTokens.prototype._setTokens = function (topLevelLanguageId, lineIndex, lineTextLength, tokens) {\n        var target;\n        if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {\n            target = this._tokens[lineIndex];\n        }\n        else {\n            target = new ModelLineTokens(null);\n            this._tokens[lineIndex] = target;\n        }\n        if (lineTextLength === 0) {\n            var hasDifferentLanguageId = false;\n            if (tokens && tokens.length > 1) {\n                hasDifferentLanguageId = (modes_1.TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n            }\n            if (!hasDifferentLanguageId) {\n                target._lineTokens = EMPTY_LINE_TOKENS;\n                return;\n            }\n        }\n        if (!tokens || tokens.length === 0) {\n            tokens = new Uint32Array(2);\n            tokens[0] = 0;\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\n        }\n        lineTokens_1.LineTokens.convertToEndOffset(tokens, lineTextLength);\n        target._lineTokens = tokens.buffer;\n    };\n    ModelLinesTokens.prototype._setState = function (lineIndex, state) {\n        if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {\n            this._tokens[lineIndex]._state = state;\n        }\n        else {\n            var tmp = new ModelLineTokens(state);\n            this._tokens[lineIndex] = tmp;\n        }\n    };\n    //#region Editing\n    ModelLinesTokens.prototype.applyEdits = function (range, eolCount, firstLineLength) {\n        var deletingLinesCnt = range.endLineNumber - range.startLineNumber;\n        var insertingLinesCnt = eolCount;\n        var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n        for (var j = editingLinesCnt; j >= 0; j--) {\n            this.invalidateLine(range.startLineNumber + j - 1);\n        }\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new position_1.Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    };\n    ModelLinesTokens.prototype._acceptDeleteRange = function (range) {\n        var firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._tokens.length) {\n            return;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            this._tokens[firstLineIndex].delete(range.startColumn - 1, range.endColumn - 1);\n            return;\n        }\n        var firstLine = this._tokens[firstLineIndex];\n        firstLine.deleteEnding(range.startColumn - 1);\n        var lastLineIndex = range.endLineNumber - 1;\n        var lastLineTokens = null;\n        if (lastLineIndex < this._tokens.length) {\n            var lastLine = this._tokens[lastLineIndex];\n            lastLine.deleteBeginning(range.endColumn - 1);\n            lastLineTokens = lastLine._lineTokens;\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        firstLine.append(lastLineTokens);\n        // Delete middle lines\n        this._tokens.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    };\n    ModelLinesTokens.prototype._acceptInsertText = function (position, eolCount, firstLineLength) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        var lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._tokens.length) {\n            return;\n        }\n        if (eolCount === 0) {\n            // Inserting text on one line\n            this._tokens[lineIndex].insert(position.column - 1, firstLineLength);\n            return;\n        }\n        var line = this._tokens[lineIndex];\n        line.deleteEnding(position.column - 1);\n        line.insert(position.column - 1, firstLineLength);\n        var insert = new Array(eolCount);\n        for (var i = eolCount - 1; i >= 0; i--) {\n            insert[i] = new ModelLineTokens(null);\n        }\n        this._tokens = arrays.arrayInsert(this._tokens, position.lineNumber, insert);\n    };\n    //#endregion\n    //#region Tokenization\n    ModelLinesTokens.prototype._tokenizeOneLine = function (buffer, eventBuilder) {\n        if (!this.hasLinesToTokenize(buffer)) {\n            return buffer.getLineCount() + 1;\n        }\n        var lineNumber = this._invalidLineStartIndex + 1;\n        this._updateTokensUntilLine(buffer, eventBuilder, lineNumber);\n        return lineNumber;\n    };\n    ModelLinesTokens.prototype._tokenizeText = function (buffer, text, state) {\n        var r = null;\n        if (this.tokenizationSupport) {\n            try {\n                r = this.tokenizationSupport.tokenize2(text, state, 0);\n            }\n            catch (e) {\n                errors_1.onUnexpectedError(e);\n            }\n        }\n        if (!r) {\n            r = nullMode_1.nullTokenize2(this.languageIdentifier.id, text, state, 0);\n        }\n        return r;\n    };\n    ModelLinesTokens.prototype._updateTokensUntilLine = function (buffer, eventBuilder, lineNumber) {\n        if (!this.tokenizationSupport) {\n            this._invalidLineStartIndex = buffer.getLineCount();\n            return;\n        }\n        var linesLength = buffer.getLineCount();\n        var endLineIndex = lineNumber - 1;\n        // Validate all states up to and including endLineIndex\n        for (var lineIndex = this._invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {\n            var endStateIndex = lineIndex + 1;\n            var text = buffer.getLineContent(lineIndex + 1);\n            var lineStartState = this._getState(lineIndex);\n            var r = null;\n            try {\n                // Tokenize only the first X characters\n                var freshState = lineStartState.clone();\n                r = this.tokenizationSupport.tokenize2(text, freshState, 0);\n            }\n            catch (e) {\n                errors_1.onUnexpectedError(e);\n            }\n            if (!r) {\n                r = nullMode_1.nullTokenize2(this.languageIdentifier.id, text, lineStartState, 0);\n            }\n            this._setTokens(this.languageIdentifier.id, lineIndex, text.length, r.tokens);\n            eventBuilder.registerChangedTokens(lineIndex + 1);\n            this._setIsInvalid(lineIndex, false);\n            if (endStateIndex < linesLength) {\n                var previousEndState = this._getState(endStateIndex);\n                if (previousEndState !== null && r.endState.equals(previousEndState)) {\n                    // The end state of this line remains the same\n                    var nextInvalidLineIndex = lineIndex + 1;\n                    while (nextInvalidLineIndex < linesLength) {\n                        if (this._isInvalid(nextInvalidLineIndex)) {\n                            break;\n                        }\n                        if (nextInvalidLineIndex + 1 < linesLength) {\n                            if (this._getState(nextInvalidLineIndex + 1) === null) {\n                                break;\n                            }\n                        }\n                        else {\n                            if (this._lastState === null) {\n                                break;\n                            }\n                        }\n                        nextInvalidLineIndex++;\n                    }\n                    this._invalidLineStartIndex = Math.max(this._invalidLineStartIndex, nextInvalidLineIndex);\n                    lineIndex = nextInvalidLineIndex - 1; // -1 because the outer loop increments it\n                }\n                else {\n                    this._setState(endStateIndex, r.endState);\n                }\n            }\n            else {\n                this._lastState = r.endState;\n            }\n        }\n        this._invalidLineStartIndex = Math.max(this._invalidLineStartIndex, endLineIndex + 1);\n    };\n    return ModelLinesTokens;\n}());\nexports.ModelLinesTokens = ModelLinesTokens;\nvar ModelTokensChangedEventBuilder = /** @class */ (function () {\n    function ModelTokensChangedEventBuilder() {\n        this._ranges = [];\n    }\n    ModelTokensChangedEventBuilder.prototype.registerChangedTokens = function (lineNumber) {\n        var ranges = this._ranges;\n        var rangesLength = ranges.length;\n        var previousRange = rangesLength > 0 ? ranges[rangesLength - 1] : null;\n        if (previousRange && previousRange.toLineNumber === lineNumber - 1) {\n            // extend previous range\n            previousRange.toLineNumber++;\n        }\n        else {\n            // insert new range\n            ranges[rangesLength] = {\n                fromLineNumber: lineNumber,\n                toLineNumber: lineNumber\n            };\n        }\n    };\n    ModelTokensChangedEventBuilder.prototype.build = function () {\n        if (this._ranges.length === 0) {\n            return null;\n        }\n        return {\n            tokenizationSupportChanged: false,\n            ranges: this._ranges\n        };\n    };\n    return ModelTokensChangedEventBuilder;\n}());\nexports.ModelTokensChangedEventBuilder = ModelTokensChangedEventBuilder;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/textModelTokens.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/model/textModelTokens.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from 'vs/base/common/arrays';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { LineTokens } from 'vs/editor/common/core/lineTokens';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { TokenizationResult2 } from 'vs/editor/common/core/token';\nimport { ITextBuffer } from 'vs/editor/common/model';\nimport { IModelTokensChangedEvent } from 'vs/editor/common/model/textModelEvents';\nimport { ColorId, FontStyle, IState, ITokenizationSupport, LanguageId, LanguageIdentifier, MetadataConsts, StandardTokenType, TokenMetadata } from 'vs/editor/common/modes';\nimport { nullTokenize2 } from 'vs/editor/common/modes/nullMode';\n\nfunction getDefaultMetadata(topLevelLanguageId: LanguageId): number {\n\treturn (\n\t\t(topLevelLanguageId << MetadataConsts.LANGUAGEID_OFFSET)\n\t\t| (StandardTokenType.Other << MetadataConsts.TOKEN_TYPE_OFFSET)\n\t\t| (FontStyle.None << MetadataConsts.FONT_STYLE_OFFSET)\n\t\t| (ColorId.DefaultForeground << MetadataConsts.FOREGROUND_OFFSET)\n\t\t| (ColorId.DefaultBackground << MetadataConsts.BACKGROUND_OFFSET)\n\t) >>> 0;\n}\n\nconst EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\n\nclass ModelLineTokens {\n\t_state: IState | null;\n\t_lineTokens: ArrayBuffer | null;\n\t_invalid: boolean;\n\n\tconstructor(state: IState | null) {\n\t\tthis._state = state;\n\t\tthis._lineTokens = null;\n\t\tthis._invalid = true;\n\t}\n\n\tpublic deleteBeginning(toChIndex: number): void {\n\t\tif (this._lineTokens === null || this._lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn;\n\t\t}\n\t\tthis.delete(0, toChIndex);\n\t}\n\n\tpublic deleteEnding(fromChIndex: number): void {\n\t\tif (this._lineTokens === null || this._lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst tokens = new Uint32Array(this._lineTokens);\n\t\tconst lineTextLength = tokens[tokens.length - 2];\n\t\tthis.delete(fromChIndex, lineTextLength);\n\t}\n\n\tpublic delete(fromChIndex: number, toChIndex: number): void {\n\t\tif (this._lineTokens === null || this._lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst tokens = new Uint32Array(this._lineTokens);\n\t\tconst tokensCount = (tokens.length >>> 1);\n\n\t\t// special case: deleting everything\n\t\tif (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n\t\t\tthis._lineTokens = EMPTY_LINE_TOKENS;\n\t\t\treturn;\n\t\t}\n\n\t\tconst fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n\t\tconst fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n\t\tconst fromTokenEndOffset = tokens[fromTokenIndex << 1];\n\n\t\tif (toChIndex < fromTokenEndOffset) {\n\t\t\t// the delete range is inside a single token\n\t\t\tconst delta = (toChIndex - fromChIndex);\n\t\t\tfor (let i = fromTokenIndex; i < tokensCount; i++) {\n\t\t\t\ttokens[i << 1] -= delta;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tlet dest: number;\n\t\tlet lastEnd: number;\n\t\tif (fromTokenStartOffset !== fromChIndex) {\n\t\t\ttokens[fromTokenIndex << 1] = fromChIndex;\n\t\t\tdest = ((fromTokenIndex + 1) << 1);\n\t\t\tlastEnd = fromChIndex;\n\t\t} else {\n\t\t\tdest = (fromTokenIndex << 1);\n\t\t\tlastEnd = fromTokenStartOffset;\n\t\t}\n\n\t\tconst delta = (toChIndex - fromChIndex);\n\t\tfor (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n\t\t\tconst tokenEndOffset = tokens[tokenIndex << 1] - delta;\n\t\t\tif (tokenEndOffset > lastEnd) {\n\t\t\t\ttokens[dest++] = tokenEndOffset;\n\t\t\t\ttokens[dest++] = tokens[(tokenIndex << 1) + 1];\n\t\t\t\tlastEnd = tokenEndOffset;\n\t\t\t}\n\t\t}\n\n\t\tif (dest === tokens.length) {\n\t\t\t// nothing to trim\n\t\t\treturn;\n\t\t}\n\n\t\tlet tmp = new Uint32Array(dest);\n\t\ttmp.set(tokens.subarray(0, dest), 0);\n\t\tthis._lineTokens = tmp.buffer;\n\t}\n\n\tpublic append(_otherTokens: ArrayBuffer | null): void {\n\t\tif (_otherTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\tthis._lineTokens = _otherTokens;\n\t\t\treturn;\n\t\t}\n\t\tif (this._lineTokens === null) {\n\t\t\treturn;\n\t\t}\n\t\tif (_otherTokens === null) {\n\t\t\t// cannot determine combined line length...\n\t\t\tthis._lineTokens = null;\n\t\t\treturn;\n\t\t}\n\t\tconst myTokens = new Uint32Array(this._lineTokens);\n\t\tconst otherTokens = new Uint32Array(_otherTokens);\n\t\tconst otherTokensCount = (otherTokens.length >>> 1);\n\n\t\tlet result = new Uint32Array(myTokens.length + otherTokens.length);\n\t\tresult.set(myTokens, 0);\n\t\tlet dest = myTokens.length;\n\t\tconst delta = myTokens[myTokens.length - 2];\n\t\tfor (let i = 0; i < otherTokensCount; i++) {\n\t\t\tresult[dest++] = otherTokens[(i << 1)] + delta;\n\t\t\tresult[dest++] = otherTokens[(i << 1) + 1];\n\t\t}\n\t\tthis._lineTokens = result.buffer;\n\t}\n\n\tpublic insert(chIndex: number, textLength: number): void {\n\t\tif (!this._lineTokens) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tconst tokens = new Uint32Array(this._lineTokens);\n\t\tconst tokensCount = (tokens.length >>> 1);\n\n\t\tlet fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n\t\tif (fromTokenIndex > 0) {\n\t\t\tconst fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n\t\t\tif (fromTokenStartOffset === chIndex) {\n\t\t\t\tfromTokenIndex--;\n\t\t\t}\n\t\t}\n\t\tfor (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n\t\t\ttokens[tokenIndex << 1] += textLength;\n\t\t}\n\t}\n}\n\nexport class ModelLinesTokens {\n\n\tpublic readonly languageIdentifier: LanguageIdentifier;\n\tpublic readonly tokenizationSupport: ITokenizationSupport | null;\n\tprivate _tokens: ModelLineTokens[];\n\tprivate _invalidLineStartIndex: number;\n\tprivate _lastState: IState | null;\n\n\tconstructor(languageIdentifier: LanguageIdentifier, tokenizationSupport: ITokenizationSupport | null) {\n\t\tthis.languageIdentifier = languageIdentifier;\n\t\tthis.tokenizationSupport = tokenizationSupport;\n\t\tthis._tokens = [];\n\t\tif (this.tokenizationSupport) {\n\t\t\tlet initialState: IState | null = null;\n\t\t\ttry {\n\t\t\t\tinitialState = this.tokenizationSupport.getInitialState();\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\tthis.tokenizationSupport = null;\n\t\t\t}\n\n\t\t\tif (initialState) {\n\t\t\t\tthis._tokens[0] = new ModelLineTokens(initialState);\n\t\t\t}\n\t\t}\n\n\t\tthis._invalidLineStartIndex = 0;\n\t\tthis._lastState = null;\n\t}\n\n\tpublic get inValidLineStartIndex() {\n\t\treturn this._invalidLineStartIndex;\n\t}\n\n\tpublic getTokens(topLevelLanguageId: LanguageId, lineIndex: number, lineText: string): LineTokens {\n\t\tlet rawLineTokens: ArrayBuffer | null = null;\n\t\tif (lineIndex < this._tokens.length && this._tokens[lineIndex]) {\n\t\t\trawLineTokens = this._tokens[lineIndex]._lineTokens;\n\t\t}\n\n\t\tif (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n\t\t\treturn new LineTokens(new Uint32Array(rawLineTokens), lineText);\n\t\t}\n\n\t\tlet lineTokens = new Uint32Array(2);\n\t\tlineTokens[0] = lineText.length;\n\t\tlineTokens[1] = getDefaultMetadata(topLevelLanguageId);\n\t\treturn new LineTokens(lineTokens, lineText);\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tconst firstInvalidLineNumber = this._invalidLineStartIndex + 1;\n\t\treturn (firstInvalidLineNumber >= lineNumber);\n\t}\n\n\tpublic hasLinesToTokenize(buffer: ITextBuffer): boolean {\n\t\treturn (this._invalidLineStartIndex < buffer.getLineCount());\n\t}\n\n\tpublic invalidateLine(lineIndex: number): void {\n\t\tthis._setIsInvalid(lineIndex, true);\n\t\tif (lineIndex < this._invalidLineStartIndex) {\n\t\t\tthis._setIsInvalid(this._invalidLineStartIndex, true);\n\t\t\tthis._invalidLineStartIndex = lineIndex;\n\t\t}\n\t}\n\n\t_setIsInvalid(lineIndex: number, invalid: boolean): void {\n\t\tif (lineIndex < this._tokens.length && this._tokens[lineIndex]) {\n\t\t\tthis._tokens[lineIndex]._invalid = invalid;\n\t\t}\n\t}\n\n\t_isInvalid(lineIndex: number): boolean {\n\t\tif (lineIndex < this._tokens.length && this._tokens[lineIndex]) {\n\t\t\treturn this._tokens[lineIndex]._invalid;\n\t\t}\n\t\treturn true;\n\t}\n\n\t_getState(lineIndex: number): IState | null {\n\t\tif (lineIndex < this._tokens.length && this._tokens[lineIndex]) {\n\t\t\treturn this._tokens[lineIndex]._state;\n\t\t}\n\t\treturn null;\n\t}\n\n\t_setTokens(topLevelLanguageId: LanguageId, lineIndex: number, lineTextLength: number, tokens: Uint32Array): void {\n\t\tlet target: ModelLineTokens;\n\t\tif (lineIndex < this._tokens.length && this._tokens[lineIndex]) {\n\t\t\ttarget = this._tokens[lineIndex];\n\t\t} else {\n\t\t\ttarget = new ModelLineTokens(null);\n\t\t\tthis._tokens[lineIndex] = target;\n\t\t}\n\n\t\tif (lineTextLength === 0) {\n\t\t\tlet hasDifferentLanguageId = false;\n\t\t\tif (tokens && tokens.length > 1) {\n\t\t\t\thasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n\t\t\t}\n\n\t\t\tif (!hasDifferentLanguageId) {\n\t\t\t\ttarget._lineTokens = EMPTY_LINE_TOKENS;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (!tokens || tokens.length === 0) {\n\t\t\ttokens = new Uint32Array(2);\n\t\t\ttokens[0] = 0;\n\t\t\ttokens[1] = getDefaultMetadata(topLevelLanguageId);\n\t\t}\n\n\t\tLineTokens.convertToEndOffset(tokens, lineTextLength);\n\n\t\ttarget._lineTokens = tokens.buffer;\n\t}\n\n\t_setState(lineIndex: number, state: IState): void {\n\t\tif (lineIndex < this._tokens.length && this._tokens[lineIndex]) {\n\t\t\tthis._tokens[lineIndex]._state = state;\n\t\t} else {\n\t\t\tconst tmp = new ModelLineTokens(state);\n\t\t\tthis._tokens[lineIndex] = tmp;\n\t\t}\n\t}\n\n\t//#region Editing\n\n\tpublic applyEdits(range: Range, eolCount: number, firstLineLength: number): void {\n\n\t\tconst deletingLinesCnt = range.endLineNumber - range.startLineNumber;\n\t\tconst insertingLinesCnt = eolCount;\n\t\tconst editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n\n\t\tfor (let j = editingLinesCnt; j >= 0; j--) {\n\t\t\tthis.invalidateLine(range.startLineNumber + j - 1);\n\t\t}\n\n\t\tthis._acceptDeleteRange(range);\n\t\tthis._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n\t}\n\n\tprivate _acceptDeleteRange(range: Range): void {\n\n\t\tconst firstLineIndex = range.startLineNumber - 1;\n\t\tif (firstLineIndex >= this._tokens.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\tif (range.startColumn === range.endColumn) {\n\t\t\t\t// Nothing to delete\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._tokens[firstLineIndex].delete(range.startColumn - 1, range.endColumn - 1);\n\t\t\treturn;\n\t\t}\n\n\t\tconst firstLine = this._tokens[firstLineIndex];\n\t\tfirstLine.deleteEnding(range.startColumn - 1);\n\n\t\tconst lastLineIndex = range.endLineNumber - 1;\n\t\tlet lastLineTokens: ArrayBuffer | null = null;\n\t\tif (lastLineIndex < this._tokens.length) {\n\t\t\tconst lastLine = this._tokens[lastLineIndex];\n\t\t\tlastLine.deleteBeginning(range.endColumn - 1);\n\t\t\tlastLineTokens = lastLine._lineTokens;\n\t\t}\n\n\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\tfirstLine.append(lastLineTokens);\n\n\t\t// Delete middle lines\n\t\tthis._tokens.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\t}\n\n\tprivate _acceptInsertText(position: Position, eolCount: number, firstLineLength: number): void {\n\n\t\tif (eolCount === 0 && firstLineLength === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\n\t\tconst lineIndex = position.lineNumber - 1;\n\t\tif (lineIndex >= this._tokens.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (eolCount === 0) {\n\t\t\t// Inserting text on one line\n\t\t\tthis._tokens[lineIndex].insert(position.column - 1, firstLineLength);\n\t\t\treturn;\n\t\t}\n\n\t\tconst line = this._tokens[lineIndex];\n\t\tline.deleteEnding(position.column - 1);\n\t\tline.insert(position.column - 1, firstLineLength);\n\n\t\tlet insert: ModelLineTokens[] = new Array<ModelLineTokens>(eolCount);\n\t\tfor (let i = eolCount - 1; i >= 0; i--) {\n\t\t\tinsert[i] = new ModelLineTokens(null);\n\t\t}\n\t\tthis._tokens = arrays.arrayInsert(this._tokens, position.lineNumber, insert);\n\t}\n\n\t//#endregion\n\n\t//#region Tokenization\n\n\tpublic _tokenizeOneLine(buffer: ITextBuffer, eventBuilder: ModelTokensChangedEventBuilder): number {\n\t\tif (!this.hasLinesToTokenize(buffer)) {\n\t\t\treturn buffer.getLineCount() + 1;\n\t\t}\n\t\tconst lineNumber = this._invalidLineStartIndex + 1;\n\t\tthis._updateTokensUntilLine(buffer, eventBuilder, lineNumber);\n\t\treturn lineNumber;\n\t}\n\n\tpublic _tokenizeText(buffer: ITextBuffer, text: string, state: IState): TokenizationResult2 {\n\t\tlet r: TokenizationResult2 | null = null;\n\n\t\tif (this.tokenizationSupport) {\n\t\t\ttry {\n\t\t\t\tr = this.tokenizationSupport.tokenize2(text, state, 0);\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t}\n\t\t}\n\n\t\tif (!r) {\n\t\t\tr = nullTokenize2(this.languageIdentifier.id, text, state, 0);\n\t\t}\n\t\treturn r;\n\t}\n\n\tpublic _updateTokensUntilLine(buffer: ITextBuffer, eventBuilder: ModelTokensChangedEventBuilder, lineNumber: number): void {\n\t\tif (!this.tokenizationSupport) {\n\t\t\tthis._invalidLineStartIndex = buffer.getLineCount();\n\t\t\treturn;\n\t\t}\n\n\t\tconst linesLength = buffer.getLineCount();\n\t\tconst endLineIndex = lineNumber - 1;\n\n\t\t// Validate all states up to and including endLineIndex\n\t\tfor (let lineIndex = this._invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {\n\t\t\tconst endStateIndex = lineIndex + 1;\n\t\t\tconst text = buffer.getLineContent(lineIndex + 1);\n\t\t\tconst lineStartState = this._getState(lineIndex);\n\n\t\t\tlet r: TokenizationResult2 | null = null;\n\n\t\t\ttry {\n\t\t\t\t// Tokenize only the first X characters\n\t\t\t\tlet freshState = lineStartState!.clone();\n\t\t\t\tr = this.tokenizationSupport.tokenize2(text, freshState, 0);\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t}\n\n\t\t\tif (!r) {\n\t\t\t\tr = nullTokenize2(this.languageIdentifier.id, text, lineStartState, 0);\n\t\t\t}\n\t\t\tthis._setTokens(this.languageIdentifier.id, lineIndex, text.length, r.tokens);\n\t\t\teventBuilder.registerChangedTokens(lineIndex + 1);\n\t\t\tthis._setIsInvalid(lineIndex, false);\n\n\t\t\tif (endStateIndex < linesLength) {\n\t\t\t\tconst previousEndState = this._getState(endStateIndex);\n\t\t\t\tif (previousEndState !== null && r.endState.equals(previousEndState)) {\n\t\t\t\t\t// The end state of this line remains the same\n\t\t\t\t\tlet nextInvalidLineIndex = lineIndex + 1;\n\t\t\t\t\twhile (nextInvalidLineIndex < linesLength) {\n\t\t\t\t\t\tif (this._isInvalid(nextInvalidLineIndex)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nextInvalidLineIndex + 1 < linesLength) {\n\t\t\t\t\t\t\tif (this._getState(nextInvalidLineIndex + 1) === null) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (this._lastState === null) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextInvalidLineIndex++;\n\t\t\t\t\t}\n\t\t\t\t\tthis._invalidLineStartIndex = Math.max(this._invalidLineStartIndex, nextInvalidLineIndex);\n\t\t\t\t\tlineIndex = nextInvalidLineIndex - 1; // -1 because the outer loop increments it\n\t\t\t\t} else {\n\t\t\t\t\tthis._setState(endStateIndex, r.endState);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._lastState = r.endState;\n\t\t\t}\n\t\t}\n\t\tthis._invalidLineStartIndex = Math.max(this._invalidLineStartIndex, endLineIndex + 1);\n\t}\n\n\t// #endregion\n}\n\nexport class ModelTokensChangedEventBuilder {\n\n\tprivate readonly _ranges: { fromLineNumber: number; toLineNumber: number; }[];\n\n\tconstructor() {\n\t\tthis._ranges = [];\n\t}\n\n\tpublic registerChangedTokens(lineNumber: number): void {\n\t\tconst ranges = this._ranges;\n\t\tconst rangesLength = ranges.length;\n\t\tconst previousRange = rangesLength > 0 ? ranges[rangesLength - 1] : null;\n\n\t\tif (previousRange && previousRange.toLineNumber === lineNumber - 1) {\n\t\t\t// extend previous range\n\t\t\tpreviousRange.toLineNumber++;\n\t\t} else {\n\t\t\t// insert new range\n\t\t\tranges[rangesLength] = {\n\t\t\t\tfromLineNumber: lineNumber,\n\t\t\t\ttoLineNumber: lineNumber\n\t\t\t};\n\t\t}\n\t}\n\n\tpublic build(): IModelTokensChangedEvent | null {\n\t\tif (this._ranges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn {\n\t\t\ttokenizationSupportChanged: false,\n\t\t\tranges: this._ranges\n\t\t};\n\t}\n}\n"]}]}