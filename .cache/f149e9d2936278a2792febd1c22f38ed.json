{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/electron-browser/debugService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/electron-browser/debugService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/event\", \"vs/base/common/uri\", \"vs/base/common/arrays\", \"vs/base/common/errors\", \"vs/base/common/severity\", \"vs/base/browser/ui/aria/aria\", \"vs/platform/contextkey/common/contextkey\", \"vs/platform/markers/common/markers\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/workbench/services/extensions/common/extensions\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/files/common/files\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/storage/common/storage\", \"vs/workbench/contrib/debug/common/debugModel\", \"vs/workbench/contrib/debug/common/debugViewModel\", \"vs/workbench/contrib/debug/browser/debugActions\", \"vs/workbench/contrib/debug/electron-browser/debugConfigurationManager\", \"vs/workbench/contrib/markers/browser/constants\", \"vs/workbench/contrib/tasks/common/taskService\", \"vs/workbench/contrib/files/common/files\", \"vs/workbench/services/viewlet/browser/viewlet\", \"vs/workbench/services/panel/common/panelService\", \"vs/workbench/services/layout/browser/layoutService\", \"vs/workbench/services/textfile/common/textfiles\", \"vs/platform/configuration/common/configuration\", \"vs/platform/workspace/common/workspace\", \"vs/workbench/services/editor/common/editorService\", \"vs/platform/extensions/common/extensionHost\", \"vs/workbench/services/broadcast/common/broadcast\", \"vs/base/common/console\", \"vs/workbench/contrib/tasks/common/tasks\", \"vs/platform/dialogs/common/dialogs\", \"vs/platform/notification/common/notification\", \"vs/base/common/actions\", \"vs/base/common/objects\", \"vs/workbench/contrib/debug/electron-browser/debugSession\", \"vs/base/common/lifecycle\", \"vs/workbench/contrib/debug/common/debug\", \"vs/workbench/contrib/debug/common/debugUtils\", \"vs/base/common/errorsWithActions\", \"vs/base/common/async\"], function (require, exports, nls, event_1, uri_1, arrays_1, errors, severity_1, aria, contextkey_1, markers_1, lifecycle_1, extensions_1, instantiation_1, files_1, telemetry_1, storage_1, debugModel_1, debugViewModel_1, debugactions, debugConfigurationManager_1, constants_1, taskService_1, files_2, viewlet_1, panelService_1, layoutService_1, textfiles_1, configuration_1, workspace_1, editorService_1, extensionHost_1, broadcast_1, console_1, tasks_1, dialogs_1, notification_1, actions_1, objects_1, debugSession_1, lifecycle_2, debug_1, debugUtils_1, errorsWithActions_1, async_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const DEBUG_BREAKPOINTS_KEY = 'debug.breakpoint';\n    const DEBUG_BREAKPOINTS_ACTIVATED_KEY = 'debug.breakpointactivated';\n    const DEBUG_FUNCTION_BREAKPOINTS_KEY = 'debug.functionbreakpoint';\n    const DEBUG_EXCEPTION_BREAKPOINTS_KEY = 'debug.exceptionbreakpoint';\n    const DEBUG_WATCH_EXPRESSIONS_KEY = 'debug.watchexpressions';\n    function once(match, event) {\n        return (listener, thisArgs = null, disposables) => {\n            const result = event(e => {\n                if (match(e)) {\n                    result.dispose();\n                    return listener.call(thisArgs, e);\n                }\n            }, null, disposables);\n            return result;\n        };\n    }\n    var TaskRunResult;\n    (function (TaskRunResult) {\n        TaskRunResult[TaskRunResult[\"Failure\"] = 0] = \"Failure\";\n        TaskRunResult[TaskRunResult[\"Success\"] = 1] = \"Success\";\n    })(TaskRunResult || (TaskRunResult = {}));\n    let DebugService = class DebugService {\n        constructor(storageService, editorService, textFileService, viewletService, panelService, notificationService, dialogService, layoutService, broadcastService, telemetryService, contextService, contextKeyService, lifecycleService, instantiationService, extensionService, markerService, taskService, fileService, configurationService) {\n            this.storageService = storageService;\n            this.editorService = editorService;\n            this.textFileService = textFileService;\n            this.viewletService = viewletService;\n            this.panelService = panelService;\n            this.notificationService = notificationService;\n            this.dialogService = dialogService;\n            this.layoutService = layoutService;\n            this.broadcastService = broadcastService;\n            this.telemetryService = telemetryService;\n            this.contextService = contextService;\n            this.lifecycleService = lifecycleService;\n            this.instantiationService = instantiationService;\n            this.extensionService = extensionService;\n            this.markerService = markerService;\n            this.taskService = taskService;\n            this.fileService = fileService;\n            this.configurationService = configurationService;\n            this.initializing = false;\n            this.toDispose = [];\n            this.breakpointsToSendOnResourceSaved = new Set();\n            this._onDidChangeState = new event_1.Emitter();\n            this._onDidNewSession = new event_1.Emitter();\n            this._onWillNewSession = new event_1.Emitter();\n            this._onDidEndSession = new event_1.Emitter();\n            this.configurationManager = this.instantiationService.createInstance(debugConfigurationManager_1.ConfigurationManager, this);\n            this.toDispose.push(this.configurationManager);\n            this.debugType = debug_1.CONTEXT_DEBUG_TYPE.bindTo(contextKeyService);\n            this.debugState = debug_1.CONTEXT_DEBUG_STATE.bindTo(contextKeyService);\n            this.inDebugMode = debug_1.CONTEXT_IN_DEBUG_MODE.bindTo(contextKeyService);\n            this.model = new debugModel_1.DebugModel(this.loadBreakpoints(), this.storageService.getBoolean(DEBUG_BREAKPOINTS_ACTIVATED_KEY, storage_1.StorageScope.WORKSPACE, true), this.loadFunctionBreakpoints(), this.loadExceptionBreakpoints(), this.loadWatchExpressions(), this.textFileService);\n            this.toDispose.push(this.model);\n            this.viewModel = new debugViewModel_1.ViewModel(contextKeyService);\n            this.toDispose.push(this.fileService.onFileChanges(e => this.onFileChanges(e)));\n            this.toDispose.push(this.storageService.onWillSaveState(this.saveState, this));\n            this.lifecycleService.onShutdown(this.dispose, this);\n            this.toDispose.push(this.broadcastService.onBroadcast(broadcast => {\n                const session = this.model.getSession(broadcast.payload.debugId, true);\n                if (session) {\n                    switch (broadcast.channel) {\n                        case extensionHost_1.EXTENSION_ATTACH_BROADCAST_CHANNEL:\n                            // EH was started in debug mode -> attach to it\n                            session.configuration.request = 'attach';\n                            session.configuration.port = broadcast.payload.port;\n                            this.launchOrAttachToSession(session);\n                            break;\n                        case extensionHost_1.EXTENSION_TERMINATE_BROADCAST_CHANNEL:\n                            // EH was terminated\n                            session.disconnect();\n                            break;\n                        case extensionHost_1.EXTENSION_LOG_BROADCAST_CHANNEL:\n                            // extension logged output -> show it in REPL\n                            const extensionOutput = broadcast.payload.logEntry;\n                            const sev = extensionOutput.severity === 'warn' ? severity_1.default.Warning : extensionOutput.severity === 'error' ? severity_1.default.Error : severity_1.default.Info;\n                            const { args, stack } = console_1.parse(extensionOutput);\n                            const frame = !!stack ? console_1.getFirstFrame(stack) : undefined;\n                            session.logToRepl(sev, args, frame);\n                            break;\n                    }\n                }\n            }, this));\n            this.toDispose.push(this.viewModel.onDidFocusStackFrame(() => {\n                this.onStateChange();\n            }));\n            this.toDispose.push(this.viewModel.onDidFocusSession(session => {\n                const id = session ? session.getId() : undefined;\n                this.model.setBreakpointsSessionId(id);\n                this.onStateChange();\n            }));\n        }\n        getModel() {\n            return this.model;\n        }\n        getViewModel() {\n            return this.viewModel;\n        }\n        getConfigurationManager() {\n            return this.configurationManager;\n        }\n        sourceIsNotAvailable(uri) {\n            this.model.sourceIsNotAvailable(uri);\n        }\n        dispose() {\n            this.toDispose = lifecycle_2.dispose(this.toDispose);\n        }\n        //---- state management\n        get state() {\n            const focusedSession = this.viewModel.focusedSession;\n            if (focusedSession) {\n                return focusedSession.state;\n            }\n            return this.initializing ? debug_1.State.Initializing : debug_1.State.Inactive;\n        }\n        startInitializingState() {\n            if (!this.initializing) {\n                this.initializing = true;\n                this.onStateChange();\n            }\n        }\n        endInitializingState() {\n            if (this.initializing) {\n                this.initializing = false;\n                this.onStateChange();\n            }\n        }\n        onStateChange() {\n            const state = this.state;\n            if (this.previousState !== state) {\n                this.debugState.set(debug_1.getStateLabel(state));\n                this.inDebugMode.set(state !== debug_1.State.Inactive);\n                this.previousState = state;\n                this._onDidChangeState.fire(state);\n            }\n        }\n        get onDidChangeState() {\n            return this._onDidChangeState.event;\n        }\n        get onDidNewSession() {\n            return this._onDidNewSession.event;\n        }\n        get onWillNewSession() {\n            return this._onWillNewSession.event;\n        }\n        get onDidEndSession() {\n            return this._onDidEndSession.event;\n        }\n        //---- life cycle management\n        /**\n         * main entry point\n         * properly manages compounds, checks for errors and handles the initializing state.\n         */\n        startDebugging(launch, configOrName, noDebug = false, parentSession) {\n            this.startInitializingState();\n            // make sure to save all files and that the configuration is up to date\n            return this.extensionService.activateByEvent('onDebug').then(() => {\n                return this.textFileService.saveAll().then(() => this.configurationService.reloadConfiguration(launch ? launch.workspace : undefined).then(() => {\n                    return this.extensionService.whenInstalledExtensionsRegistered().then(() => {\n                        let config;\n                        let compound;\n                        if (!configOrName) {\n                            configOrName = this.configurationManager.selectedConfiguration.name;\n                        }\n                        if (typeof configOrName === 'string' && launch) {\n                            config = launch.getConfiguration(configOrName);\n                            compound = launch.getCompound(configOrName);\n                            const sessions = this.model.getSessions();\n                            const alreadyRunningMessage = nls.localize('configurationAlreadyRunning', \"There is already a debug configuration \\\"{0}\\\" running.\", configOrName);\n                            if (sessions.some(s => s.configuration.name === configOrName && (!launch || !launch.workspace || !s.root || s.root.uri.toString() === launch.workspace.uri.toString()))) {\n                                return Promise.reject(new Error(alreadyRunningMessage));\n                            }\n                            if (compound && compound.configurations && sessions.some(p => compound.configurations.indexOf(p.configuration.name) !== -1)) {\n                                return Promise.reject(new Error(alreadyRunningMessage));\n                            }\n                        }\n                        else if (typeof configOrName !== 'string') {\n                            config = configOrName;\n                        }\n                        if (compound) {\n                            // we are starting a compound debug, first do some error checking and than start each configuration in the compound\n                            if (!compound.configurations) {\n                                return Promise.reject(new Error(nls.localize({ key: 'compoundMustHaveConfigurations', comment: ['compound indicates a \"compounds\" configuration item', '\"configurations\" is an attribute and should not be localized'] }, \"Compound must have \\\"configurations\\\" attribute set in order to start multiple configurations.\")));\n                            }\n                            return Promise.all(compound.configurations.map(configData => {\n                                const name = typeof configData === 'string' ? configData : configData.name;\n                                if (name === compound.name) {\n                                    return Promise.resolve(false);\n                                }\n                                let launchForName;\n                                if (typeof configData === 'string') {\n                                    const launchesContainingName = this.configurationManager.getLaunches().filter(l => !!l.getConfiguration(name));\n                                    if (launchesContainingName.length === 1) {\n                                        launchForName = launchesContainingName[0];\n                                    }\n                                    else if (launch && launchesContainingName.length > 1 && launchesContainingName.indexOf(launch) >= 0) {\n                                        // If there are multiple launches containing the configuration give priority to the configuration in the current launch\n                                        launchForName = launch;\n                                    }\n                                    else {\n                                        return Promise.reject(new Error(launchesContainingName.length === 0 ? nls.localize('noConfigurationNameInWorkspace', \"Could not find launch configuration '{0}' in the workspace.\", name)\n                                            : nls.localize('multipleConfigurationNamesInWorkspace', \"There are multiple launch configurations '{0}' in the workspace. Use folder name to qualify the configuration.\", name)));\n                                    }\n                                }\n                                else if (configData.folder) {\n                                    const launchesMatchingConfigData = this.configurationManager.getLaunches().filter(l => l.workspace && l.workspace.name === configData.folder && !!l.getConfiguration(configData.name));\n                                    if (launchesMatchingConfigData.length === 1) {\n                                        launchForName = launchesMatchingConfigData[0];\n                                    }\n                                    else {\n                                        return Promise.reject(new Error(nls.localize('noFolderWithName', \"Can not find folder with name '{0}' for configuration '{1}' in compound '{2}'.\", configData.folder, configData.name, compound.name)));\n                                    }\n                                }\n                                return this.createSession(launchForName, launchForName.getConfiguration(name), noDebug, parentSession);\n                            })).then(values => values.every(success => !!success)); // Compound launch is a success only if each configuration launched successfully\n                        }\n                        if (configOrName && !config) {\n                            const message = !!launch ? nls.localize('configMissing', \"Configuration '{0}' is missing in 'launch.json'.\", typeof configOrName === 'string' ? configOrName : JSON.stringify(configOrName)) :\n                                nls.localize('launchJsonDoesNotExist', \"'launch.json' does not exist.\");\n                            return Promise.reject(new Error(message));\n                        }\n                        return this.createSession(launch, config, noDebug, parentSession);\n                    });\n                }));\n            }).then(success => {\n                // make sure to get out of initializing state, and propagate the result\n                this.endInitializingState();\n                return success;\n            }, err => {\n                this.endInitializingState();\n                return Promise.reject(err);\n            });\n        }\n        /**\n         * gets the debugger for the type, resolves configurations by providers, substitutes variables and runs prelaunch tasks\n         */\n        createSession(launch, config, noDebug, parentSession) {\n            // We keep the debug type in a separate variable 'type' so that a no-folder config has no attributes.\n            // Storing the type in the config would break extensions that assume that the no-folder case is indicated by an empty config.\n            let type;\n            if (config) {\n                type = config.type;\n            }\n            else {\n                // a no-folder workspace has no launch.config\n                config = Object.create(null);\n            }\n            const unresolvedConfig = objects_1.deepClone(config);\n            if (noDebug) {\n                config.noDebug = true;\n            }\n            const debuggerThenable = type ? Promise.resolve() : this.configurationManager.guessDebugger().then(dbgr => { type = dbgr && dbgr.type; });\n            return debuggerThenable.then(() => this.configurationManager.resolveConfigurationByProviders(launch && launch.workspace ? launch.workspace.uri : undefined, type, config).then(config => {\n                // a falsy config indicates an aborted launch\n                if (config && config.type) {\n                    return this.substituteVariables(launch, config).then(resolvedConfig => {\n                        if (!resolvedConfig) {\n                            // User canceled resolving of interactive variables, silently return\n                            return false;\n                        }\n                        if (!this.configurationManager.getDebugger(resolvedConfig.type) || (config.request !== 'attach' && config.request !== 'launch')) {\n                            let message;\n                            if (config.request !== 'attach' && config.request !== 'launch') {\n                                message = config.request ? nls.localize('debugRequestNotSupported', \"Attribute '{0}' has an unsupported value '{1}' in the chosen debug configuration.\", 'request', config.request)\n                                    : nls.localize('debugRequesMissing', \"Attribute '{0}' is missing from the chosen debug configuration.\", 'request');\n                            }\n                            else {\n                                message = resolvedConfig.type ? nls.localize('debugTypeNotSupported', \"Configured debug type '{0}' is not supported.\", resolvedConfig.type) :\n                                    nls.localize('debugTypeMissing', \"Missing property 'type' for the chosen launch configuration.\");\n                            }\n                            return this.showError(message).then(() => false);\n                        }\n                        const workspace = launch ? launch.workspace : undefined;\n                        return this.runTaskAndCheckErrors(workspace, resolvedConfig.preLaunchTask).then(result => {\n                            if (result === TaskRunResult.Success) {\n                                return this.doCreateSession(workspace, { resolved: resolvedConfig, unresolved: unresolvedConfig }, parentSession);\n                            }\n                            return false;\n                        });\n                    }, err => {\n                        if (err && err.message) {\n                            return this.showError(err.message).then(() => false);\n                        }\n                        if (this.contextService.getWorkbenchState() === workspace_1.WorkbenchState.EMPTY) {\n                            return this.showError(nls.localize('noFolderWorkspaceDebugError', \"The active file can not be debugged. Make sure it is saved on disk and that you have a debug extension installed for that file type.\"))\n                                .then(() => false);\n                        }\n                        return launch && launch.openConfigFile(false, true).then(() => false);\n                    });\n                }\n                if (launch && type && config === null) { // show launch.json only for \"config\" being \"null\".\n                    return launch.openConfigFile(false, true, type).then(() => false);\n                }\n                return false;\n            }));\n        }\n        /**\n         * instantiates the new session, initializes the session, registers session listeners and reports telemetry\n         */\n        doCreateSession(root, configuration, parentSession) {\n            const session = this.instantiationService.createInstance(debugSession_1.DebugSession, configuration, root, this.model, parentSession);\n            this.model.addSession(session);\n            // register listeners as the very first thing!\n            this.registerSessionListeners(session);\n            // since the Session is now properly registered under its ID and hooked, we can announce it\n            // this event doesn't go to extensions\n            this._onWillNewSession.fire(session);\n            const openDebug = this.configurationService.getValue('debug').openDebug;\n            // Open debug viewlet based on the visibility of the side bar and openDebug setting. Do not open for 'run without debug'\n            if (!configuration.resolved.noDebug && (openDebug === 'openOnSessionStart' || (openDebug === 'openOnFirstSessionStart' && this.viewModel.firstSessionStart))) {\n                this.viewletService.openViewlet(debug_1.VIEWLET_ID).then(undefined, errors.onUnexpectedError);\n            }\n            return this.launchOrAttachToSession(session).then(() => {\n                // since the initialized response has arrived announce the new Session (including extensions)\n                this._onDidNewSession.fire(session);\n                const internalConsoleOptions = session.configuration.internalConsoleOptions || this.configurationService.getValue('debug').internalConsoleOptions;\n                if (internalConsoleOptions === 'openOnSessionStart' || (this.viewModel.firstSessionStart && internalConsoleOptions === 'openOnFirstSessionStart')) {\n                    this.panelService.openPanel(debug_1.REPL_ID, false);\n                }\n                this.viewModel.firstSessionStart = false;\n                if (this.model.getSessions().length > 1) {\n                    this.viewModel.setMultiSessionView(true);\n                }\n                return this.telemetryDebugSessionStart(root, session.configuration.type);\n            }).then(() => true, (error) => {\n                if (errors.isPromiseCanceledError(error)) {\n                    // don't show 'canceled' error messages to the user #7906\n                    return Promise.resolve(false);\n                }\n                // Show the repl if some error got logged there #5870\n                if (session && session.getReplElements().length > 0) {\n                    this.panelService.openPanel(debug_1.REPL_ID, false);\n                }\n                if (session.configuration && session.configuration.request === 'attach' && session.configuration.__autoAttach) {\n                    // ignore attach timeouts in auto attach mode\n                    return Promise.resolve(false);\n                }\n                const errorMessage = error instanceof Error ? error.message : error;\n                this.telemetryDebugMisconfiguration(session.configuration ? session.configuration.type : undefined, errorMessage);\n                return this.showError(errorMessage, errorsWithActions_1.isErrorWithActions(error) ? error.actions : []).then(() => false);\n            });\n        }\n        launchOrAttachToSession(session, focus = true) {\n            const dbgr = this.configurationManager.getDebugger(session.configuration.type);\n            return session.initialize(dbgr).then(() => {\n                return session.launchOrAttach(session.configuration).then(() => {\n                    if (focus) {\n                        this.focusStackFrame(undefined, undefined, session);\n                    }\n                });\n            }).then(undefined, err => {\n                session.shutdown();\n                return Promise.reject(err);\n            });\n        }\n        registerSessionListeners(session) {\n            const sessionRunningScheduler = new async_1.RunOnceScheduler(() => {\n                // Do not immediatly defocus the stack frame if the session is running\n                if (session.state === debug_1.State.Running && this.viewModel.focusedSession === session) {\n                    this.viewModel.setFocus(undefined, this.viewModel.focusedThread, session, false);\n                }\n            }, 200);\n            this.toDispose.push(session.onDidChangeState(() => {\n                if (session.state === debug_1.State.Running && this.viewModel.focusedSession === session) {\n                    sessionRunningScheduler.schedule();\n                }\n                if (session === this.viewModel.focusedSession) {\n                    this.onStateChange();\n                }\n            }));\n            this.toDispose.push(session.onDidEndAdapter(adapterExitEvent => {\n                if (adapterExitEvent.error) {\n                    this.notificationService.error(nls.localize('debugAdapterCrash', \"Debug adapter process has terminated unexpectedly ({0})\", adapterExitEvent.error.message || adapterExitEvent.error.toString()));\n                }\n                // 'Run without debugging' mode VSCode must terminate the extension host. More details: #3905\n                if (debugUtils_1.isExtensionHostDebugging(session.configuration) && session.state === debug_1.State.Running && session.configuration.noDebug) {\n                    this.broadcastService.broadcast({\n                        channel: extensionHost_1.EXTENSION_CLOSE_EXTHOST_BROADCAST_CHANNEL,\n                        payload: [session.root.uri.toString()]\n                    });\n                }\n                this.telemetryDebugSessionStop(session, adapterExitEvent);\n                if (session.configuration.postDebugTask) {\n                    this.runTask(session.root, session.configuration.postDebugTask).then(undefined, err => this.notificationService.error(err));\n                }\n                session.shutdown();\n                this.endInitializingState();\n                this._onDidEndSession.fire(session);\n                const focusedSession = this.viewModel.focusedSession;\n                if (focusedSession && focusedSession.getId() === session.getId()) {\n                    this.focusStackFrame(undefined);\n                }\n                if (this.model.getSessions().length === 0) {\n                    this.viewModel.setMultiSessionView(false);\n                    if (this.layoutService.isVisible(layoutService_1.Parts.SIDEBAR_PART) && this.configurationService.getValue('debug').openExplorerOnEnd) {\n                        this.viewletService.openViewlet(files_2.VIEWLET_ID);\n                    }\n                }\n            }));\n        }\n        restartSession(session, restartData) {\n            return this.textFileService.saveAll().then(() => {\n                const isAutoRestart = !!restartData;\n                const runTasks = () => {\n                    if (isAutoRestart) {\n                        // Do not run preLaunch and postDebug tasks for automatic restarts\n                        return Promise.resolve(TaskRunResult.Success);\n                    }\n                    return this.runTask(session.root, session.configuration.postDebugTask)\n                        .then(() => this.runTaskAndCheckErrors(session.root, session.configuration.preLaunchTask));\n                };\n                if (session.capabilities.supportsRestartRequest) {\n                    return runTasks().then(taskResult => taskResult === TaskRunResult.Success ? session.restart() : undefined);\n                }\n                if (debugUtils_1.isExtensionHostDebugging(session.configuration) && session.root) {\n                    return runTasks().then(taskResult => taskResult === TaskRunResult.Success ? this.broadcastService.broadcast({\n                        channel: extensionHost_1.EXTENSION_RELOAD_BROADCAST_CHANNEL,\n                        payload: [session.root.uri.toString()]\n                    }) : undefined);\n                }\n                const shouldFocus = this.viewModel.focusedSession && session.getId() === this.viewModel.focusedSession.getId();\n                // If the restart is automatic  -> disconnect, otherwise -> terminate #55064\n                return (isAutoRestart ? session.disconnect(true) : session.terminate(true)).then(() => {\n                    return new Promise((c, e) => {\n                        setTimeout(() => {\n                            runTasks().then(taskResult => {\n                                if (taskResult !== TaskRunResult.Success) {\n                                    return;\n                                }\n                                // Read the configuration again if a launch.json has been changed, if not just use the inmemory configuration\n                                let needsToSubstitute = false;\n                                let unresolved;\n                                const launch = session.root ? this.configurationManager.getLaunch(session.root.uri) : undefined;\n                                if (launch) {\n                                    unresolved = launch.getConfiguration(session.configuration.name);\n                                    if (unresolved && !objects_1.equals(unresolved, session.unresolvedConfiguration)) {\n                                        // Take the type from the session since the debug extension might overwrite it #21316\n                                        unresolved.type = session.configuration.type;\n                                        unresolved.noDebug = session.configuration.noDebug;\n                                        needsToSubstitute = true;\n                                    }\n                                }\n                                let substitutionThenable = Promise.resolve(session.configuration);\n                                if (launch && needsToSubstitute && unresolved) {\n                                    substitutionThenable = this.configurationManager.resolveConfigurationByProviders(launch.workspace ? launch.workspace.uri : undefined, unresolved.type, unresolved)\n                                        .then(resolved => {\n                                        if (resolved) {\n                                            // start debugging\n                                            return this.substituteVariables(launch, resolved);\n                                        }\n                                        else if (resolved === null) {\n                                            // abort debugging silently and open launch.json\n                                            return Promise.resolve(null);\n                                        }\n                                        else {\n                                            // abort debugging silently\n                                            return Promise.resolve(undefined);\n                                        }\n                                    });\n                                }\n                                substitutionThenable.then(resolved => {\n                                    if (!resolved) {\n                                        return c(undefined);\n                                    }\n                                    session.setConfiguration({ resolved, unresolved });\n                                    session.configuration.__restart = restartData;\n                                    this.launchOrAttachToSession(session, shouldFocus).then(() => {\n                                        this._onDidNewSession.fire(session);\n                                        c(undefined);\n                                    }, err => e(err));\n                                });\n                            });\n                        }, 300);\n                    });\n                });\n            });\n        }\n        stopSession(session) {\n            if (session) {\n                return session.terminate();\n            }\n            const sessions = this.model.getSessions();\n            if (sessions.length === 0) {\n                this.endInitializingState();\n            }\n            return Promise.all(sessions.map(s => s.terminate()));\n        }\n        substituteVariables(launch, config) {\n            const dbg = this.configurationManager.getDebugger(config.type);\n            if (dbg) {\n                let folder = undefined;\n                if (launch && launch.workspace) {\n                    folder = launch.workspace;\n                }\n                else {\n                    const folders = this.contextService.getWorkspace().folders;\n                    if (folders.length === 1) {\n                        folder = folders[0];\n                    }\n                }\n                return dbg.substituteVariables(folder, config).then(config => {\n                    return config;\n                }, (err) => {\n                    this.showError(err.message);\n                    return undefined; // bail out\n                });\n            }\n            return Promise.resolve(config);\n        }\n        showError(message, actions = []) {\n            const configureAction = this.instantiationService.createInstance(debugactions.ConfigureAction, debugactions.ConfigureAction.ID, debugactions.ConfigureAction.LABEL);\n            actions.push(configureAction);\n            return this.dialogService.show(severity_1.default.Error, message, actions.map(a => a.label).concat(nls.localize('cancel', \"Cancel\")), { cancelId: actions.length }).then(choice => {\n                if (choice < actions.length) {\n                    return actions[choice].run();\n                }\n                return undefined;\n            });\n        }\n        //---- task management\n        runTaskAndCheckErrors(root, taskId) {\n            const debugAnywayAction = new actions_1.Action('debug.debugAnyway', nls.localize('debugAnyway', \"Debug Anyway\"), undefined, true, () => Promise.resolve(TaskRunResult.Success));\n            return this.runTask(root, taskId).then((taskSummary) => {\n                const errorCount = taskId ? this.markerService.getStatistics().errors : 0;\n                const successExitCode = taskSummary && taskSummary.exitCode === 0;\n                const failureExitCode = taskSummary && taskSummary.exitCode !== undefined && taskSummary.exitCode !== 0;\n                if (successExitCode || (errorCount === 0 && !failureExitCode)) {\n                    return TaskRunResult.Success;\n                }\n                const taskLabel = typeof taskId === 'string' ? taskId : taskId ? taskId.name : '';\n                const message = errorCount > 1\n                    ? nls.localize('preLaunchTaskErrors', \"Errors exist after running preLaunchTask '{0}'.\", taskLabel)\n                    : errorCount === 1\n                        ? nls.localize('preLaunchTaskError', \"Error exists after running preLaunchTask '{0}'.\", taskLabel)\n                        : nls.localize('preLaunchTaskExitCode', \"The preLaunchTask '{0}' terminated with exit code {1}.\", taskLabel, taskSummary.exitCode);\n                const showErrorsAction = new actions_1.Action('debug.showErrors', nls.localize('showErrors', \"Show Errors\"), undefined, true, () => {\n                    this.panelService.openPanel(constants_1.default.MARKERS_PANEL_ID);\n                    return Promise.resolve(TaskRunResult.Failure);\n                });\n                return this.showError(message, [debugAnywayAction, showErrorsAction]);\n            }, (err) => {\n                return this.showError(err.message, [debugAnywayAction, this.taskService.configureAction()]);\n            });\n        }\n        runTask(root, taskId) {\n            if (!taskId) {\n                return Promise.resolve(null);\n            }\n            if (!root) {\n                return Promise.reject(new Error(nls.localize('invalidTaskReference', \"Task '{0}' can not be referenced from a launch configuration that is in a different workspace folder.\", typeof taskId === 'string' ? taskId : taskId.type)));\n            }\n            // run a task before starting a debug session\n            return this.taskService.getTask(root, taskId).then(task => {\n                if (!task) {\n                    const errorMessage = typeof taskId === 'string'\n                        ? nls.localize('DebugTaskNotFoundWithTaskId', \"Could not find the task '{0}'.\", taskId)\n                        : nls.localize('DebugTaskNotFound', \"Could not find the specified task.\");\n                    return Promise.reject(errorsWithActions_1.createErrorWithActions(errorMessage));\n                }\n                // If a task is missing the problem matcher the promise will never complete, so we need to have a workaround #35340\n                let taskStarted = false;\n                const promise = this.taskService.getActiveTasks().then(tasks => {\n                    if (tasks.filter(t => t._id === task._id).length) {\n                        // task is already running - nothing to do.\n                        return Promise.resolve(null);\n                    }\n                    once(e => ((e.kind === tasks_1.TaskEventKind.Active) || (e.kind === tasks_1.TaskEventKind.DependsOnStarted)) && e.taskId === task._id, this.taskService.onDidStateChange)(() => {\n                        // Task is active, so everything seems to be fine, no need to prompt after 10 seconds\n                        // Use case being a slow running task should not be prompted even though it takes more than 10 seconds\n                        taskStarted = true;\n                    });\n                    const taskPromise = this.taskService.run(task);\n                    if (task.configurationProperties.isBackground) {\n                        return new Promise((c, e) => once(e => e.kind === tasks_1.TaskEventKind.Inactive && e.taskId === task._id, this.taskService.onDidStateChange)(() => {\n                            taskStarted = true;\n                            c(undefined);\n                        }));\n                    }\n                    return taskPromise;\n                });\n                return new Promise((c, e) => {\n                    promise.then(result => {\n                        taskStarted = true;\n                        c(result);\n                    }, error => e(error));\n                    setTimeout(() => {\n                        if (!taskStarted) {\n                            const errorMessage = typeof taskId === 'string'\n                                ? nls.localize('taskNotTrackedWithTaskId', \"The specified task cannot be tracked.\")\n                                : nls.localize('taskNotTracked', \"The task '{0}' cannot be tracked.\", JSON.stringify(taskId));\n                            e({ severity: severity_1.default.Error, message: errorMessage });\n                        }\n                    }, 10000);\n                });\n            });\n        }\n        //---- focus management\n        focusStackFrame(stackFrame, thread, session, explicit) {\n            if (!session) {\n                if (stackFrame || thread) {\n                    session = stackFrame ? stackFrame.thread.session : thread.session;\n                }\n                else {\n                    const sessions = this.model.getSessions();\n                    const stoppedSession = sessions.filter(s => s.state === debug_1.State.Stopped).shift();\n                    session = stoppedSession || (sessions.length ? sessions[0] : undefined);\n                }\n            }\n            if (!thread) {\n                if (stackFrame) {\n                    thread = stackFrame.thread;\n                }\n                else {\n                    const threads = session ? session.getAllThreads() : undefined;\n                    const stoppedThread = threads && threads.filter(t => t.stopped).shift();\n                    thread = stoppedThread || (threads && threads.length ? threads[0] : undefined);\n                }\n            }\n            if (!stackFrame) {\n                if (thread) {\n                    const callStack = thread.getCallStack();\n                    stackFrame = arrays_1.first(callStack, sf => !!(sf && sf.source && sf.source.available && sf.source.presentationHint !== 'deemphasize'), undefined);\n                }\n            }\n            if (stackFrame) {\n                stackFrame.openInEditor(this.editorService, true);\n                aria.alert(nls.localize('debuggingPaused', \"Debugging paused {0}, {1} {2}\", thread && thread.stoppedDetails ? `, reason ${thread.stoppedDetails.reason}` : '', stackFrame.source ? stackFrame.source.name : '', stackFrame.range.startLineNumber));\n            }\n            if (session) {\n                this.debugType.set(session.configuration.type);\n            }\n            else {\n                this.debugType.reset();\n            }\n            this.viewModel.setFocus(stackFrame, thread, session, !!explicit);\n        }\n        //---- watches\n        addWatchExpression(name) {\n            const we = this.model.addWatchExpression(name);\n            this.viewModel.setSelectedExpression(we);\n        }\n        renameWatchExpression(id, newName) {\n            return this.model.renameWatchExpression(id, newName);\n        }\n        moveWatchExpression(id, position) {\n            this.model.moveWatchExpression(id, position);\n        }\n        removeWatchExpressions(id) {\n            this.model.removeWatchExpressions(id);\n        }\n        //---- breakpoints\n        enableOrDisableBreakpoints(enable, breakpoint) {\n            if (breakpoint) {\n                this.model.setEnablement(breakpoint, enable);\n                if (breakpoint instanceof debugModel_1.Breakpoint) {\n                    return this.sendBreakpoints(breakpoint.uri);\n                }\n                else if (breakpoint instanceof debugModel_1.FunctionBreakpoint) {\n                    return this.sendFunctionBreakpoints();\n                }\n                return this.sendExceptionBreakpoints();\n            }\n            this.model.enableOrDisableAllBreakpoints(enable);\n            return this.sendAllBreakpoints();\n        }\n        addBreakpoints(uri, rawBreakpoints, context) {\n            const breakpoints = this.model.addBreakpoints(uri, rawBreakpoints);\n            breakpoints.forEach(bp => aria.status(nls.localize('breakpointAdded', \"Added breakpoint, line {0}, file {1}\", bp.lineNumber, uri.fsPath)));\n            breakpoints.forEach(bp => this.telemetryDebugAddBreakpoint(bp, context));\n            return this.sendBreakpoints(uri).then(() => breakpoints);\n        }\n        updateBreakpoints(uri, data, sendOnResourceSaved) {\n            this.model.updateBreakpoints(data);\n            if (sendOnResourceSaved) {\n                this.breakpointsToSendOnResourceSaved.add(uri.toString());\n            }\n            else {\n                this.sendBreakpoints(uri);\n            }\n        }\n        removeBreakpoints(id) {\n            const toRemove = this.model.getBreakpoints().filter(bp => !id || bp.getId() === id);\n            toRemove.forEach(bp => aria.status(nls.localize('breakpointRemoved', \"Removed breakpoint, line {0}, file {1}\", bp.lineNumber, bp.uri.fsPath)));\n            const urisToClear = arrays_1.distinct(toRemove, bp => bp.uri.toString()).map(bp => bp.uri);\n            this.model.removeBreakpoints(toRemove);\n            return Promise.all(urisToClear.map(uri => this.sendBreakpoints(uri)));\n        }\n        setBreakpointsActivated(activated) {\n            this.model.setBreakpointsActivated(activated);\n            return this.sendAllBreakpoints();\n        }\n        addFunctionBreakpoint(name, id) {\n            const newFunctionBreakpoint = this.model.addFunctionBreakpoint(name || '', id);\n            this.viewModel.setSelectedFunctionBreakpoint(newFunctionBreakpoint);\n        }\n        renameFunctionBreakpoint(id, newFunctionName) {\n            this.model.renameFunctionBreakpoint(id, newFunctionName);\n            return this.sendFunctionBreakpoints();\n        }\n        removeFunctionBreakpoints(id) {\n            this.model.removeFunctionBreakpoints(id);\n            return this.sendFunctionBreakpoints();\n        }\n        sendAllBreakpoints(session) {\n            return Promise.all(arrays_1.distinct(this.model.getBreakpoints(), bp => bp.uri.toString()).map(bp => this.sendBreakpoints(bp.uri, false, session)))\n                .then(() => this.sendFunctionBreakpoints(session))\n                // send exception breakpoints at the end since some debug adapters rely on the order\n                .then(() => this.sendExceptionBreakpoints(session));\n        }\n        sendBreakpoints(modelUri, sourceModified = false, session) {\n            const breakpointsToSend = this.model.getBreakpoints({ uri: modelUri, enabledOnly: true });\n            return this.sendToOneOrAllSessions(session, s => s.sendBreakpoints(modelUri, breakpointsToSend, sourceModified));\n        }\n        sendFunctionBreakpoints(session) {\n            const breakpointsToSend = this.model.getFunctionBreakpoints().filter(fbp => fbp.enabled && this.model.areBreakpointsActivated());\n            return this.sendToOneOrAllSessions(session, s => {\n                return s.capabilities.supportsFunctionBreakpoints ? s.sendFunctionBreakpoints(breakpointsToSend) : Promise.resolve(undefined);\n            });\n        }\n        sendExceptionBreakpoints(session) {\n            const enabledExceptionBps = this.model.getExceptionBreakpoints().filter(exb => exb.enabled);\n            return this.sendToOneOrAllSessions(session, s => {\n                return s.sendExceptionBreakpoints(enabledExceptionBps);\n            });\n        }\n        sendToOneOrAllSessions(session, send) {\n            if (session) {\n                return send(session);\n            }\n            return Promise.all(this.model.getSessions().map(s => send(s))).then(() => undefined);\n        }\n        onFileChanges(fileChangesEvent) {\n            const toRemove = this.model.getBreakpoints().filter(bp => fileChangesEvent.contains(bp.uri, files_1.FileChangeType.DELETED));\n            if (toRemove.length) {\n                this.model.removeBreakpoints(toRemove);\n            }\n            fileChangesEvent.getUpdated().forEach(event => {\n                if (this.breakpointsToSendOnResourceSaved.delete(event.resource.toString())) {\n                    this.sendBreakpoints(event.resource, true);\n                }\n            });\n        }\n        loadBreakpoints() {\n            let result;\n            try {\n                result = JSON.parse(this.storageService.get(DEBUG_BREAKPOINTS_KEY, storage_1.StorageScope.WORKSPACE, '[]')).map((breakpoint) => {\n                    return new debugModel_1.Breakpoint(uri_1.URI.parse(breakpoint.uri.external || breakpoint.source.uri.external), breakpoint.lineNumber, breakpoint.column, breakpoint.enabled, breakpoint.condition, breakpoint.hitCondition, breakpoint.logMessage, breakpoint.adapterData, this.textFileService);\n                });\n            }\n            catch (e) { }\n            return result || [];\n        }\n        loadFunctionBreakpoints() {\n            let result;\n            try {\n                result = JSON.parse(this.storageService.get(DEBUG_FUNCTION_BREAKPOINTS_KEY, storage_1.StorageScope.WORKSPACE, '[]')).map((fb) => {\n                    return new debugModel_1.FunctionBreakpoint(fb.name, fb.enabled, fb.hitCondition, fb.condition, fb.logMessage);\n                });\n            }\n            catch (e) { }\n            return result || [];\n        }\n        loadExceptionBreakpoints() {\n            let result;\n            try {\n                result = JSON.parse(this.storageService.get(DEBUG_EXCEPTION_BREAKPOINTS_KEY, storage_1.StorageScope.WORKSPACE, '[]')).map((exBreakpoint) => {\n                    return new debugModel_1.ExceptionBreakpoint(exBreakpoint.filter, exBreakpoint.label, exBreakpoint.enabled);\n                });\n            }\n            catch (e) { }\n            return result || [];\n        }\n        loadWatchExpressions() {\n            let result;\n            try {\n                result = JSON.parse(this.storageService.get(DEBUG_WATCH_EXPRESSIONS_KEY, storage_1.StorageScope.WORKSPACE, '[]')).map((watchStoredData) => {\n                    return new debugModel_1.Expression(watchStoredData.name, watchStoredData.id);\n                });\n            }\n            catch (e) { }\n            return result || [];\n        }\n        saveState() {\n            const breakpoints = this.model.getBreakpoints();\n            if (breakpoints.length) {\n                this.storageService.store(DEBUG_BREAKPOINTS_KEY, JSON.stringify(breakpoints), storage_1.StorageScope.WORKSPACE);\n            }\n            else {\n                this.storageService.remove(DEBUG_BREAKPOINTS_KEY, storage_1.StorageScope.WORKSPACE);\n            }\n            if (!this.model.areBreakpointsActivated()) {\n                this.storageService.store(DEBUG_BREAKPOINTS_ACTIVATED_KEY, 'false', storage_1.StorageScope.WORKSPACE);\n            }\n            else {\n                this.storageService.remove(DEBUG_BREAKPOINTS_ACTIVATED_KEY, storage_1.StorageScope.WORKSPACE);\n            }\n            const functionBreakpoints = this.model.getFunctionBreakpoints();\n            if (functionBreakpoints.length) {\n                this.storageService.store(DEBUG_FUNCTION_BREAKPOINTS_KEY, JSON.stringify(functionBreakpoints), storage_1.StorageScope.WORKSPACE);\n            }\n            else {\n                this.storageService.remove(DEBUG_FUNCTION_BREAKPOINTS_KEY, storage_1.StorageScope.WORKSPACE);\n            }\n            const exceptionBreakpoints = this.model.getExceptionBreakpoints();\n            if (exceptionBreakpoints.length) {\n                this.storageService.store(DEBUG_EXCEPTION_BREAKPOINTS_KEY, JSON.stringify(exceptionBreakpoints), storage_1.StorageScope.WORKSPACE);\n            }\n            else {\n                this.storageService.remove(DEBUG_EXCEPTION_BREAKPOINTS_KEY, storage_1.StorageScope.WORKSPACE);\n            }\n            const watchExpressions = this.model.getWatchExpressions();\n            if (watchExpressions.length) {\n                this.storageService.store(DEBUG_WATCH_EXPRESSIONS_KEY, JSON.stringify(watchExpressions.map(we => ({ name: we.name, id: we.getId() }))), storage_1.StorageScope.WORKSPACE);\n            }\n            else {\n                this.storageService.remove(DEBUG_WATCH_EXPRESSIONS_KEY, storage_1.StorageScope.WORKSPACE);\n            }\n        }\n        //---- telemetry\n        telemetryDebugSessionStart(root, type) {\n            const dbgr = this.configurationManager.getDebugger(type);\n            if (!dbgr) {\n                return Promise.resolve();\n            }\n            const extension = dbgr.getMainExtensionDescriptor();\n            /* __GDPR__\n                \"debugSessionStart\" : {\n                    \"type\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                    \"breakpointCount\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                    \"exceptionBreakpoints\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                    \"watchExpressionsCount\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                    \"extensionName\": { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" },\n                    \"isBuiltin\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true},\n                    \"launchJsonExists\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n                }\n            */\n            return this.telemetryService.publicLog('debugSessionStart', {\n                type: type,\n                breakpointCount: this.model.getBreakpoints().length,\n                exceptionBreakpoints: this.model.getExceptionBreakpoints(),\n                watchExpressionsCount: this.model.getWatchExpressions().length,\n                extensionName: extension.identifier.value,\n                isBuiltin: extension.isBuiltin,\n                launchJsonExists: root && !!this.configurationService.getValue('launch', { resource: root.uri })\n            });\n        }\n        telemetryDebugSessionStop(session, adapterExitEvent) {\n            const breakpoints = this.model.getBreakpoints();\n            /* __GDPR__\n                \"debugSessionStop\" : {\n                    \"type\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                    \"success\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                    \"sessionLengthInSeconds\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                    \"breakpointCount\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                    \"watchExpressionsCount\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n                }\n            */\n            return this.telemetryService.publicLog('debugSessionStop', {\n                type: session && session.configuration.type,\n                success: adapterExitEvent.emittedStopped || breakpoints.length === 0,\n                sessionLengthInSeconds: adapterExitEvent.sessionLengthInSeconds,\n                breakpointCount: breakpoints.length,\n                watchExpressionsCount: this.model.getWatchExpressions().length\n            });\n        }\n        telemetryDebugMisconfiguration(debugType, message) {\n            /* __GDPR__\n                \"debugMisconfiguration\" : {\n                    \"type\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                    \"error\": { \"classification\": \"CallstackOrException\", \"purpose\": \"FeatureInsight\" }\n                }\n            */\n            return this.telemetryService.publicLog('debugMisconfiguration', {\n                type: debugType,\n                error: message\n            });\n        }\n        telemetryDebugAddBreakpoint(breakpoint, context) {\n            /* __GDPR__\n                \"debugAddBreakpoint\" : {\n                    \"context\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                    \"hasCondition\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                    \"hasHitCondition\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                    \"hasLogMessage\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n                }\n            */\n            return this.telemetryService.publicLog('debugAddBreakpoint', {\n                context: context,\n                hasCondition: !!breakpoint.condition,\n                hasHitCondition: !!breakpoint.hitCondition,\n                hasLogMessage: !!breakpoint.logMessage\n            });\n        }\n    };\n    DebugService = __decorate([\n        __param(0, storage_1.IStorageService),\n        __param(1, editorService_1.IEditorService),\n        __param(2, textfiles_1.ITextFileService),\n        __param(3, viewlet_1.IViewletService),\n        __param(4, panelService_1.IPanelService),\n        __param(5, notification_1.INotificationService),\n        __param(6, dialogs_1.IDialogService),\n        __param(7, layoutService_1.IWorkbenchLayoutService),\n        __param(8, broadcast_1.IBroadcastService),\n        __param(9, telemetry_1.ITelemetryService),\n        __param(10, workspace_1.IWorkspaceContextService),\n        __param(11, contextkey_1.IContextKeyService),\n        __param(12, lifecycle_1.ILifecycleService),\n        __param(13, instantiation_1.IInstantiationService),\n        __param(14, extensions_1.IExtensionService),\n        __param(15, markers_1.IMarkerService),\n        __param(16, taskService_1.ITaskService),\n        __param(17, files_1.IFileService),\n        __param(18, configuration_1.IConfigurationService)\n    ], DebugService);\n    exports.DebugService = DebugService;\n});\n",null]}