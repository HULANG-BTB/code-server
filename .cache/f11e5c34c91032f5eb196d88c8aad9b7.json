{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/common/diff/diff.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/diff/diff.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar diffChange_1 = require(\"vs/base/common/diff/diffChange\");\nfunction createStringSequence(a) {\n    return {\n        getLength: function () { return a.length; },\n        getElementAtIndex: function (pos) { return a.charCodeAt(pos); }\n    };\n}\nfunction stringDiff(original, modified, pretty) {\n    return new LcsDiff(createStringSequence(original), createStringSequence(modified)).ComputeDiff(pretty);\n}\nexports.stringDiff = stringDiff;\n//\n// The code below has been ported from a C# implementation in VS\n//\nvar Debug = /** @class */ (function () {\n    function Debug() {\n    }\n    Debug.Assert = function (condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    };\n    return Debug;\n}());\nexports.Debug = Debug;\nvar MyArray = /** @class */ (function () {\n    function MyArray() {\n    }\n    /**\n     * Copies a range of elements from an Array starting at the specified source index and pastes\n     * them to another Array starting at the specified destination index. The length and the indexes\n     * are specified as 64-bit integers.\n     * sourceArray:\n     *\t\tThe Array that contains the data to copy.\n     * sourceIndex:\n     *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n     * destinationArray:\n     *\t\tThe Array that receives the data.\n     * destinationIndex:\n     *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n     * length:\n     *\t\tA 64-bit integer that represents the number of elements to copy.\n     */\n    MyArray.Copy = function (sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n        for (var i = 0; i < length; i++) {\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n        }\n    };\n    return MyArray;\n}());\nexports.MyArray = MyArray;\n//*****************************************************************************\n// LcsDiff.cs\n//\n// An implementation of the difference algorithm described in\n// \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n//\n// Copyright (C) 2008 Microsoft Corporation @minifier_do_not_preserve\n//*****************************************************************************\n// Our total memory usage for storing history is (worst-case):\n// 2 * [(MaxDifferencesHistory + 1) * (MaxDifferencesHistory + 1) - 1] * sizeof(int)\n// 2 * [1448*1448 - 1] * 4 = 16773624 = 16MB\nvar MaxDifferencesHistory = 1447;\n//let MaxDifferencesHistory = 100;\n/**\n * A utility class which helps to create the set of DiffChanges from\n * a difference operation. This class accepts original DiffElements and\n * modified DiffElements that are involved in a particular change. The\n * MarktNextChange() method can be called to mark the separation between\n * distinct changes. At the end, the Changes property can be called to retrieve\n * the constructed changes.\n */\nvar DiffChangeHelper = /** @class */ (function () {\n    /**\n     * Constructs a new DiffChangeHelper for the given DiffSequences.\n     */\n    function DiffChangeHelper() {\n        this.m_changes = [];\n        this.m_originalStart = Number.MAX_VALUE;\n        this.m_modifiedStart = Number.MAX_VALUE;\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n    }\n    /**\n     * Marks the beginning of the next change in the set of differences.\n     */\n    DiffChangeHelper.prototype.MarkNextChange = function () {\n        // Only add to the list if there is something to add\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Add the new change to our list\n            this.m_changes.push(new diffChange_1.DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\n        }\n        // Reset for the next change\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n        this.m_originalStart = Number.MAX_VALUE;\n        this.m_modifiedStart = Number.MAX_VALUE;\n    };\n    /**\n     * Adds the original element at the given position to the elements\n     * affected by the current change. The modified index gives context\n     * to the change position with respect to the original sequence.\n     * @param originalIndex The index of the original element to add.\n     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n     */\n    DiffChangeHelper.prototype.AddOriginalElement = function (originalIndex, modifiedIndex) {\n        // The 'true' start index is the smallest of the ones we've seen\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_originalCount++;\n    };\n    /**\n     * Adds the modified element at the given position to the elements\n     * affected by the current change. The original index gives context\n     * to the change position with respect to the modified sequence.\n     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n     * @param modifiedIndex The index of the modified element to add.\n     */\n    DiffChangeHelper.prototype.AddModifiedElement = function (originalIndex, modifiedIndex) {\n        // The 'true' start index is the smallest of the ones we've seen\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_modifiedCount++;\n    };\n    /**\n     * Retrieves all of the changes marked by the class.\n     */\n    DiffChangeHelper.prototype.getChanges = function () {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Finish up on whatever is left\n            this.MarkNextChange();\n        }\n        return this.m_changes;\n    };\n    /**\n     * Retrieves all of the changes marked by the class in the reverse order\n     */\n    DiffChangeHelper.prototype.getReverseChanges = function () {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Finish up on whatever is left\n            this.MarkNextChange();\n        }\n        this.m_changes.reverse();\n        return this.m_changes;\n    };\n    return DiffChangeHelper;\n}());\n/**\n * An implementation of the difference algorithm described in\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n */\nvar LcsDiff = /** @class */ (function () {\n    /**\n     * Constructs the DiffFinder\n     */\n    function LcsDiff(originalSequence, newSequence, continueProcessingPredicate) {\n        if (continueProcessingPredicate === void 0) { continueProcessingPredicate = null; }\n        this.OriginalSequence = originalSequence;\n        this.ModifiedSequence = newSequence;\n        this.ContinueProcessingPredicate = continueProcessingPredicate;\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n    }\n    LcsDiff.prototype.ElementsAreEqual = function (originalIndex, newIndex) {\n        return (this.OriginalSequence.getElementAtIndex(originalIndex) === this.ModifiedSequence.getElementAtIndex(newIndex));\n    };\n    LcsDiff.prototype.OriginalElementsAreEqual = function (index1, index2) {\n        return (this.OriginalSequence.getElementAtIndex(index1) === this.OriginalSequence.getElementAtIndex(index2));\n    };\n    LcsDiff.prototype.ModifiedElementsAreEqual = function (index1, index2) {\n        return (this.ModifiedSequence.getElementAtIndex(index1) === this.ModifiedSequence.getElementAtIndex(index2));\n    };\n    LcsDiff.prototype.ComputeDiff = function (pretty) {\n        return this._ComputeDiff(0, this.OriginalSequence.getLength() - 1, 0, this.ModifiedSequence.getLength() - 1, pretty);\n    };\n    /**\n     * Computes the differences between the original and modified input\n     * sequences on the bounded range.\n     * @returns An array of the differences between the two input sequences.\n     */\n    LcsDiff.prototype._ComputeDiff = function (originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\n        var quitEarlyArr = [false];\n        var changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n        if (pretty) {\n            // We have to clean up the computed diff to be more intuitive\n            // but it turns out this cannot be done correctly until the entire set\n            // of diffs have been computed\n            return this.PrettifyChanges(changes);\n        }\n        return changes;\n    };\n    /**\n     * Private helper method which computes the differences on the bounded range\n     * recursively.\n     * @returns An array of the differences between the two input sequences.\n     */\n    LcsDiff.prototype.ComputeDiffRecursive = function (originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\n        quitEarlyArr[0] = false;\n        // Find the start of the differences\n        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n            originalStart++;\n            modifiedStart++;\n        }\n        // Find the end of the differences\n        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n            originalEnd--;\n            modifiedEnd--;\n        }\n        // In the special case where we either have all insertions or all deletions or the sequences are identical\n        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n            var changes = void 0;\n            if (modifiedStart <= modifiedEnd) {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                // All insertions\n                changes = [\n                    new diffChange_1.DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\n                ];\n            }\n            else if (originalStart <= originalEnd) {\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                // All deletions\n                changes = [\n                    new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\n                ];\n            }\n            else {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                // Identical sequences - No differences\n                changes = [];\n            }\n            return changes;\n        }\n        // This problem can be solved using the Divide-And-Conquer technique.\n        var midOriginalArr = [0], midModifiedArr = [0];\n        var result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n        var midOriginal = midOriginalArr[0];\n        var midModified = midModifiedArr[0];\n        if (result !== null) {\n            // Result is not-null when there was enough memory to compute the changes while\n            // searching for the recursion point\n            return result;\n        }\n        else if (!quitEarlyArr[0]) {\n            // We can break the problem down recursively by finding the changes in the\n            // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n            // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n            // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n            var leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n            var rightChanges = [];\n            if (!quitEarlyArr[0]) {\n                rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n            }\n            else {\n                // We did't have time to finish the first half, so we don't have time to compute this half.\n                // Consider the entire rest of the sequence different.\n                rightChanges = [\n                    new diffChange_1.DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\n                ];\n            }\n            return this.ConcatenateChanges(leftChanges, rightChanges);\n        }\n        // If we hit here, we quit early, and so can't return anything meaningful\n        return [\n            new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n        ];\n    };\n    LcsDiff.prototype.WALKTRACE = function (diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\n        var forwardChanges = null, reverseChanges = null;\n        // First, walk backward through the forward diagonals history\n        var changeHelper = new DiffChangeHelper();\n        var diagonalMin = diagonalForwardStart;\n        var diagonalMax = diagonalForwardEnd;\n        var diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\n        var lastOriginalIndex = Number.MIN_VALUE;\n        var historyIndex = this.m_forwardHistory.length - 1;\n        var diagonal;\n        do {\n            // Get the diagonal index from the relative diagonal number\n            diagonal = diagonalRelative + diagonalForwardBase;\n            // Figure out where we came from\n            if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                // Vertical line (the element is an insert)\n                originalIndex = forwardPoints[diagonal + 1];\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex;\n                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n                diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\n            }\n            else {\n                // Horizontal line (the element is a deletion)\n                originalIndex = forwardPoints[diagonal - 1] + 1;\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex - 1;\n                changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n                diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\n            }\n            if (historyIndex >= 0) {\n                forwardPoints = this.m_forwardHistory[historyIndex];\n                diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n                diagonalMin = 1;\n                diagonalMax = forwardPoints.length - 1;\n            }\n        } while (--historyIndex >= -1);\n        // Ironically, we get the forward changes as the reverse of the\n        // order we added them since we technically added them backwards\n        forwardChanges = changeHelper.getReverseChanges();\n        if (quitEarlyArr[0]) {\n            // TODO: Calculate a partial from the reverse diagonals.\n            //       For now, just assume everything after the midOriginal/midModified point is a diff\n            var originalStartPoint = midOriginalArr[0] + 1;\n            var modifiedStartPoint = midModifiedArr[0] + 1;\n            if (forwardChanges !== null && forwardChanges.length > 0) {\n                var lastForwardChange = forwardChanges[forwardChanges.length - 1];\n                originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n                modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n            }\n            reverseChanges = [\n                new diffChange_1.DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\n            ];\n        }\n        else {\n            // Now walk backward through the reverse diagonals history\n            changeHelper = new DiffChangeHelper();\n            diagonalMin = diagonalReverseStart;\n            diagonalMax = diagonalReverseEnd;\n            diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\n            lastOriginalIndex = Number.MAX_VALUE;\n            historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n            do {\n                // Get the diagonal index from the relative diagonal number\n                diagonal = diagonalRelative + diagonalReverseBase;\n                // Figure out where we came from\n                if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    // Horizontal line (the element is a deletion))\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex + 1;\n                    changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\n                }\n                else {\n                    // Vertical line (the element is an insertion)\n                    originalIndex = reversePoints[diagonal - 1];\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex;\n                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\n                }\n                if (historyIndex >= 0) {\n                    reversePoints = this.m_reverseHistory[historyIndex];\n                    diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n                    diagonalMin = 1;\n                    diagonalMax = reversePoints.length - 1;\n                }\n            } while (--historyIndex >= -1);\n            // There are cases where the reverse history will find diffs that\n            // are correct, but not intuitive, so we need shift them.\n            reverseChanges = changeHelper.getChanges();\n        }\n        return this.ConcatenateChanges(forwardChanges, reverseChanges);\n    };\n    /**\n     * Given the range to compute the diff on, this method finds the point:\n     * (midOriginal, midModified)\n     * that exists in the middle of the LCS of the two sequences and\n     * is the point at which the LCS problem may be broken down recursively.\n     * This method will try to keep the LCS trace in memory. If the LCS recursion\n     * point is calculated and the full trace is available in memory, then this method\n     * will return the change list.\n     * @param originalStart The start bound of the original sequence range\n     * @param originalEnd The end bound of the original sequence range\n     * @param modifiedStart The start bound of the modified sequence range\n     * @param modifiedEnd The end bound of the modified sequence range\n     * @param midOriginal The middle point of the original sequence range\n     * @param midModified The middle point of the modified sequence range\n     * @returns The diff changes, if available, otherwise null\n     */\n    LcsDiff.prototype.ComputeRecursionPoint = function (originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\n        var originalIndex = 0, modifiedIndex = 0;\n        var diagonalForwardStart = 0, diagonalForwardEnd = 0;\n        var diagonalReverseStart = 0, diagonalReverseEnd = 0;\n        var numDifferences;\n        // To traverse the edit graph and produce the proper LCS, our actual\n        // start position is just outside the given boundary\n        originalStart--;\n        modifiedStart--;\n        // We set these up to make the compiler happy, but they will\n        // be replaced before we return with the actual recursion point\n        midOriginalArr[0] = 0;\n        midModifiedArr[0] = 0;\n        // Clear out the history\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n        // Each cell in the two arrays corresponds to a diagonal in the edit graph.\n        // The integer value in the cell represents the originalIndex of the furthest\n        // reaching point found so far that ends in that diagonal.\n        // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n        var maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\n        var numDiagonals = maxDifferences + 1;\n        var forwardPoints = new Array(numDiagonals);\n        var reversePoints = new Array(numDiagonals);\n        // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n        // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n        var diagonalForwardBase = (modifiedEnd - modifiedStart);\n        var diagonalReverseBase = (originalEnd - originalStart);\n        // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n        //    diagonal number (relative to diagonalForwardBase)\n        // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n        //    diagonal number (relative to diagonalReverseBase)\n        var diagonalForwardOffset = (originalStart - modifiedStart);\n        var diagonalReverseOffset = (originalEnd - modifiedEnd);\n        // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n        //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n        // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n        var delta = diagonalReverseBase - diagonalForwardBase;\n        var deltaIsEven = (delta % 2 === 0);\n        // Here we set up the start and end points as the furthest points found so far\n        // in both the forward and reverse directions, respectively\n        forwardPoints[diagonalForwardBase] = originalStart;\n        reversePoints[diagonalReverseBase] = originalEnd;\n        // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n        quitEarlyArr[0] = false;\n        // A couple of points:\n        // --With this method, we iterate on the number of differences between the two sequences.\n        //   The more differences there actually are, the longer this will take.\n        // --Also, as the number of differences increases, we have to search on diagonals further\n        //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n        // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n        //   is even and odd diagonals only when numDifferences is odd.\n        var diagonal, tempOriginalIndex;\n        for (numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\n            var furthestOriginalIndex = 0;\n            var furthestModifiedIndex = 0;\n            // Run the algorithm in the forward direction\n            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            for (diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n                // STEP 1: We extend the furthest reaching point in the present diagonal\n                // by looking at the diagonals above and below and picking the one whose point\n                // is further away from the start point (originalStart, modifiedStart)\n                if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                    originalIndex = forwardPoints[diagonal + 1];\n                }\n                else {\n                    originalIndex = forwardPoints[diagonal - 1] + 1;\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n                // Save the current originalIndex so we can test for false overlap in step 3\n                tempOriginalIndex = originalIndex;\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n                // so long as the elements are equal.\n                while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n                    originalIndex++;\n                    modifiedIndex++;\n                }\n                forwardPoints[diagonal] = originalIndex;\n                if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n                    furthestOriginalIndex = originalIndex;\n                    furthestModifiedIndex = modifiedIndex;\n                }\n                // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n                // and diagonal is in the range of reverse diagonals computed for numDifferences-1\n                // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n                // then check for overlap.\n                if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\n                    if (originalIndex >= reversePoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex <= reversePoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\n                            // BINGO! We overlapped, and we have the full trace in memory!\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            // Either false overlap, or we didn't have enough memory for the full trace\n                            // Just return the recursion point\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Check to see if we should be quitting early, before moving on to the next iteration.\n            var matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, this.OriginalSequence, matchLengthOfLongest)) {\n                // We can't finish, so skip ahead to generating a result from what we have.\n                quitEarlyArr[0] = true;\n                // Use the furthest distance we got in the forward direction.\n                midOriginalArr[0] = furthestOriginalIndex;\n                midModifiedArr[0] = furthestModifiedIndex;\n                if (matchLengthOfLongest > 0 && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\n                    // Enough of the history is in memory to walk it backwards\n                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                }\n                else {\n                    // We didn't actually remember enough of the history.\n                    //Since we are quiting the diff early, we need to shift back the originalStart and modified start\n                    //back into the boundary limits since we decremented their value above beyond the boundary limit.\n                    originalStart++;\n                    modifiedStart++;\n                    return [\n                        new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n                    ];\n                }\n            }\n            // Run the algorithm in the reverse direction\n            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            for (diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n                // STEP 1: We extend the furthest reaching point in the present diagonal\n                // by looking at the diagonals above and below and picking the one whose point\n                // is further away from the start point (originalEnd, modifiedEnd)\n                if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                }\n                else {\n                    originalIndex = reversePoints[diagonal - 1];\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n                // Save the current originalIndex so we can test for false overlap\n                tempOriginalIndex = originalIndex;\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n                // as long as the elements are equal.\n                while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n                    originalIndex--;\n                    modifiedIndex--;\n                }\n                reversePoints[diagonal] = originalIndex;\n                // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n                // and diagonal is in the range of forward diagonals computed for numDifferences\n                // then check for overlap.\n                if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n                    if (originalIndex <= forwardPoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex >= forwardPoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\n                            // BINGO! We overlapped, and we have the full trace in memory!\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            // Either false overlap, or we didn't have enough memory for the full trace\n                            // Just return the recursion point\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Save current vectors to history before the next iteration\n            if (numDifferences <= MaxDifferencesHistory) {\n                // We are allocating space for one extra int, which we fill with\n                // the index of the diagonal base index\n                var temp = new Array(diagonalForwardEnd - diagonalForwardStart + 2);\n                temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n                MyArray.Copy(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n                this.m_forwardHistory.push(temp);\n                temp = new Array(diagonalReverseEnd - diagonalReverseStart + 2);\n                temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n                MyArray.Copy(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n                this.m_reverseHistory.push(temp);\n            }\n        }\n        // If we got here, then we have the full trace in history. We just have to convert it to a change list\n        // NOTE: This part is a bit messy\n        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n    };\n    /**\n     * Shifts the given changes to provide a more intuitive diff.\n     * While the first element in a diff matches the first element after the diff,\n     * we shift the diff down.\n     *\n     * @param changes The list of changes to shift\n     * @returns The shifted changes\n     */\n    LcsDiff.prototype.PrettifyChanges = function (changes) {\n        // Shift all the changes down first\n        for (var i = 0; i < changes.length; i++) {\n            var change = changes[i];\n            var originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this.OriginalSequence.getLength();\n            var modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this.ModifiedSequence.getLength();\n            var checkOriginal = change.originalLength > 0;\n            var checkModified = change.modifiedLength > 0;\n            while (change.originalStart + change.originalLength < originalStop &&\n                change.modifiedStart + change.modifiedLength < modifiedStop &&\n                (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) &&\n                (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\n                change.originalStart++;\n                change.modifiedStart++;\n            }\n            var mergedChangeArr = [null];\n            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n                changes[i] = mergedChangeArr[0];\n                changes.splice(i + 1, 1);\n                i--;\n                continue;\n            }\n        }\n        // Shift changes back up until we hit empty or whitespace-only lines\n        for (var i = changes.length - 1; i >= 0; i--) {\n            var change = changes[i];\n            var originalStop = 0;\n            var modifiedStop = 0;\n            if (i > 0) {\n                var prevChange = changes[i - 1];\n                if (prevChange.originalLength > 0) {\n                    originalStop = prevChange.originalStart + prevChange.originalLength;\n                }\n                if (prevChange.modifiedLength > 0) {\n                    modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n                }\n            }\n            var checkOriginal = change.originalLength > 0;\n            var checkModified = change.modifiedLength > 0;\n            var bestDelta = 0;\n            var bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n            for (var delta = 1;; delta++) {\n                var originalStart = change.originalStart - delta;\n                var modifiedStart = change.modifiedStart - delta;\n                if (originalStart < originalStop || modifiedStart < modifiedStop) {\n                    break;\n                }\n                if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n                    break;\n                }\n                if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n                    break;\n                }\n                var score = this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestDelta = delta;\n                }\n            }\n            change.originalStart -= bestDelta;\n            change.modifiedStart -= bestDelta;\n        }\n        return changes;\n    };\n    LcsDiff.prototype._OriginalIsBoundary = function (index) {\n        if (index <= 0 || index >= this.OriginalSequence.getLength() - 1) {\n            return true;\n        }\n        var element = this.OriginalSequence.getElementAtIndex(index);\n        return (typeof element === 'string' && /^\\s*$/.test(element));\n    };\n    LcsDiff.prototype._OriginalRegionIsBoundary = function (originalStart, originalLength) {\n        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n            return true;\n        }\n        if (originalLength > 0) {\n            var originalEnd = originalStart + originalLength;\n            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    LcsDiff.prototype._ModifiedIsBoundary = function (index) {\n        if (index <= 0 || index >= this.ModifiedSequence.getLength() - 1) {\n            return true;\n        }\n        var element = this.ModifiedSequence.getElementAtIndex(index);\n        return (typeof element === 'string' && /^\\s*$/.test(element));\n    };\n    LcsDiff.prototype._ModifiedRegionIsBoundary = function (modifiedStart, modifiedLength) {\n        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n            return true;\n        }\n        if (modifiedLength > 0) {\n            var modifiedEnd = modifiedStart + modifiedLength;\n            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    LcsDiff.prototype._boundaryScore = function (originalStart, originalLength, modifiedStart, modifiedLength) {\n        var originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);\n        var modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);\n        return (originalScore + modifiedScore);\n    };\n    /**\n     * Concatenates the two input DiffChange lists and returns the resulting\n     * list.\n     * @param The left changes\n     * @param The right changes\n     * @returns The concatenated list\n     */\n    LcsDiff.prototype.ConcatenateChanges = function (left, right) {\n        var mergedChangeArr = [];\n        if (left.length === 0 || right.length === 0) {\n            return (right.length > 0) ? right : left;\n        }\n        else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n            // Since we break the problem down recursively, it is possible that we\n            // might recurse in the middle of a change thereby splitting it into\n            // two changes. Here in the combining stage, we detect and fuse those\n            // changes back together\n            var result = new Array(left.length + right.length - 1);\n            MyArray.Copy(left, 0, result, 0, left.length - 1);\n            result[left.length - 1] = mergedChangeArr[0];\n            MyArray.Copy(right, 1, result, left.length, right.length - 1);\n            return result;\n        }\n        else {\n            var result = new Array(left.length + right.length);\n            MyArray.Copy(left, 0, result, 0, left.length);\n            MyArray.Copy(right, 0, result, left.length, right.length);\n            return result;\n        }\n    };\n    /**\n     * Returns true if the two changes overlap and can be merged into a single\n     * change\n     * @param left The left change\n     * @param right The right change\n     * @param mergedChange The merged change if the two overlap, null otherwise\n     * @returns True if the two changes overlap\n     */\n    LcsDiff.prototype.ChangesOverlap = function (left, right, mergedChangeArr) {\n        Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n        Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n            var originalStart = left.originalStart;\n            var originalLength = left.originalLength;\n            var modifiedStart = left.modifiedStart;\n            var modifiedLength = left.modifiedLength;\n            if (left.originalStart + left.originalLength >= right.originalStart) {\n                originalLength = right.originalStart + right.originalLength - left.originalStart;\n            }\n            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n                modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n            }\n            mergedChangeArr[0] = new diffChange_1.DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n            return true;\n        }\n        else {\n            mergedChangeArr[0] = null;\n            return false;\n        }\n    };\n    /**\n     * Helper method used to clip a diagonal index to the range of valid\n     * diagonals. This also decides whether or not the diagonal index,\n     * if it exceeds the boundary, should be clipped to the boundary or clipped\n     * one inside the boundary depending on the Even/Odd status of the boundary\n     * and numDifferences.\n     * @param diagonal The index of the diagonal to clip.\n     * @param numDifferences The current number of differences being iterated upon.\n     * @param diagonalBaseIndex The base reference diagonal.\n     * @param numDiagonals The total number of diagonals.\n     * @returns The clipped diagonal index.\n     */\n    LcsDiff.prototype.ClipDiagonalBound = function (diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\n        if (diagonal >= 0 && diagonal < numDiagonals) {\n            // Nothing to clip, its in range\n            return diagonal;\n        }\n        // diagonalsBelow: The number of diagonals below the reference diagonal\n        // diagonalsAbove: The number of diagonals above the reference diagonal\n        var diagonalsBelow = diagonalBaseIndex;\n        var diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n        var diffEven = (numDifferences % 2 === 0);\n        if (diagonal < 0) {\n            var lowerBoundEven = (diagonalsBelow % 2 === 0);\n            return (diffEven === lowerBoundEven) ? 0 : 1;\n        }\n        else {\n            var upperBoundEven = (diagonalsAbove % 2 === 0);\n            return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\n        }\n    };\n    return LcsDiff;\n}());\nexports.LcsDiff = LcsDiff;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/common/diff/diff.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/common/diff/diff.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DiffChange } from 'vs/base/common/diff/diffChange';\n\nfunction createStringSequence(a: string): ISequence {\n\treturn {\n\t\tgetLength() { return a.length; },\n\t\tgetElementAtIndex(pos: number) { return a.charCodeAt(pos); }\n\t};\n}\n\nexport function stringDiff(original: string, modified: string, pretty: boolean): IDiffChange[] {\n\treturn new LcsDiff(createStringSequence(original), createStringSequence(modified)).ComputeDiff(pretty);\n}\n\n\nexport interface ISequence {\n\tgetLength(): number;\n\tgetElementAtIndex(index: number): number | string;\n}\n\nexport interface IDiffChange {\n\t/**\n\t * The position of the first element in the original sequence which\n\t * this change affects.\n\t */\n\toriginalStart: number;\n\n\t/**\n\t * The number of elements from the original sequence which were\n\t * affected.\n\t */\n\toriginalLength: number;\n\n\t/**\n\t * The position of the first element in the modified sequence which\n\t * this change affects.\n\t */\n\tmodifiedStart: number;\n\n\t/**\n\t * The number of elements from the modified sequence which were\n\t * affected (added).\n\t */\n\tmodifiedLength: number;\n}\n\nexport interface IContinueProcessingPredicate {\n\t(furthestOriginalIndex: number, originalSequence: ISequence, matchLengthOfLongest: number): boolean;\n}\n\n//\n// The code below has been ported from a C# implementation in VS\n//\n\nexport class Debug {\n\n\tpublic static Assert(condition: boolean, message: string): void {\n\t\tif (!condition) {\n\t\t\tthrow new Error(message);\n\t\t}\n\t}\n}\n\nexport class MyArray {\n\t/**\n\t * Copies a range of elements from an Array starting at the specified source index and pastes\n\t * them to another Array starting at the specified destination index. The length and the indexes\n\t * are specified as 64-bit integers.\n\t * sourceArray:\n\t *\t\tThe Array that contains the data to copy.\n\t * sourceIndex:\n\t *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n\t * destinationArray:\n\t *\t\tThe Array that receives the data.\n\t * destinationIndex:\n\t *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n\t * length:\n\t *\t\tA 64-bit integer that represents the number of elements to copy.\n\t */\n\tpublic static Copy(sourceArray: any[], sourceIndex: number, destinationArray: any[], destinationIndex: number, length: number) {\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdestinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n\t\t}\n\t}\n}\n\n//*****************************************************************************\n// LcsDiff.cs\n//\n// An implementation of the difference algorithm described in\n// \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n//\n// Copyright (C) 2008 Microsoft Corporation @minifier_do_not_preserve\n//*****************************************************************************\n\n// Our total memory usage for storing history is (worst-case):\n// 2 * [(MaxDifferencesHistory + 1) * (MaxDifferencesHistory + 1) - 1] * sizeof(int)\n// 2 * [1448*1448 - 1] * 4 = 16773624 = 16MB\nlet MaxDifferencesHistory = 1447;\n//let MaxDifferencesHistory = 100;\n\n\n\n\n/**\n * A utility class which helps to create the set of DiffChanges from\n * a difference operation. This class accepts original DiffElements and\n * modified DiffElements that are involved in a particular change. The\n * MarktNextChange() method can be called to mark the separation between\n * distinct changes. At the end, the Changes property can be called to retrieve\n * the constructed changes.\n */\nclass DiffChangeHelper {\n\n\tprivate m_changes: DiffChange[];\n\tprivate m_originalStart: number;\n\tprivate m_modifiedStart: number;\n\tprivate m_originalCount: number;\n\tprivate m_modifiedCount: number;\n\n\t/**\n\t * Constructs a new DiffChangeHelper for the given DiffSequences.\n\t */\n\tconstructor() {\n\t\tthis.m_changes = [];\n\t\tthis.m_originalStart = Number.MAX_VALUE;\n\t\tthis.m_modifiedStart = Number.MAX_VALUE;\n\t\tthis.m_originalCount = 0;\n\t\tthis.m_modifiedCount = 0;\n\t}\n\n\t/**\n\t * Marks the beginning of the next change in the set of differences.\n\t */\n\tpublic MarkNextChange(): void {\n\t\t// Only add to the list if there is something to add\n\t\tif (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n\t\t\t// Add the new change to our list\n\t\t\tthis.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount,\n\t\t\t\tthis.m_modifiedStart, this.m_modifiedCount));\n\t\t}\n\n\t\t// Reset for the next change\n\t\tthis.m_originalCount = 0;\n\t\tthis.m_modifiedCount = 0;\n\t\tthis.m_originalStart = Number.MAX_VALUE;\n\t\tthis.m_modifiedStart = Number.MAX_VALUE;\n\t}\n\n\t/**\n\t * Adds the original element at the given position to the elements\n\t * affected by the current change. The modified index gives context\n\t * to the change position with respect to the original sequence.\n\t * @param originalIndex The index of the original element to add.\n\t * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n\t */\n\tpublic AddOriginalElement(originalIndex: number, modifiedIndex: number) {\n\t\t// The 'true' start index is the smallest of the ones we've seen\n\t\tthis.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n\t\tthis.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n\n\t\tthis.m_originalCount++;\n\t}\n\n\t/**\n\t * Adds the modified element at the given position to the elements\n\t * affected by the current change. The original index gives context\n\t * to the change position with respect to the modified sequence.\n\t * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n\t * @param modifiedIndex The index of the modified element to add.\n\t */\n\tpublic AddModifiedElement(originalIndex: number, modifiedIndex: number): void {\n\t\t// The 'true' start index is the smallest of the ones we've seen\n\t\tthis.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n\t\tthis.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n\n\t\tthis.m_modifiedCount++;\n\t}\n\n\t/**\n\t * Retrieves all of the changes marked by the class.\n\t */\n\tpublic getChanges(): DiffChange[] {\n\t\tif (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n\t\t\t// Finish up on whatever is left\n\t\t\tthis.MarkNextChange();\n\t\t}\n\n\t\treturn this.m_changes;\n\t}\n\n\t/**\n\t * Retrieves all of the changes marked by the class in the reverse order\n\t */\n\tpublic getReverseChanges(): DiffChange[] {\n\t\tif (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n\t\t\t// Finish up on whatever is left\n\t\t\tthis.MarkNextChange();\n\t\t}\n\n\t\tthis.m_changes.reverse();\n\t\treturn this.m_changes;\n\t}\n\n}\n\n/**\n * An implementation of the difference algorithm described in\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n */\nexport class LcsDiff {\n\n\tprivate OriginalSequence: ISequence;\n\tprivate ModifiedSequence: ISequence;\n\tprivate ContinueProcessingPredicate: IContinueProcessingPredicate | null;\n\n\tprivate m_forwardHistory: number[][];\n\tprivate m_reverseHistory: number[][];\n\n\t/**\n\t * Constructs the DiffFinder\n\t */\n\tconstructor(originalSequence: ISequence, newSequence: ISequence, continueProcessingPredicate: IContinueProcessingPredicate | null = null) {\n\t\tthis.OriginalSequence = originalSequence;\n\t\tthis.ModifiedSequence = newSequence;\n\t\tthis.ContinueProcessingPredicate = continueProcessingPredicate;\n\n\t\tthis.m_forwardHistory = [];\n\t\tthis.m_reverseHistory = [];\n\t}\n\n\tprivate ElementsAreEqual(originalIndex: number, newIndex: number): boolean {\n\t\treturn (this.OriginalSequence.getElementAtIndex(originalIndex) === this.ModifiedSequence.getElementAtIndex(newIndex));\n\t}\n\n\tprivate OriginalElementsAreEqual(index1: number, index2: number): boolean {\n\t\treturn (this.OriginalSequence.getElementAtIndex(index1) === this.OriginalSequence.getElementAtIndex(index2));\n\t}\n\n\tprivate ModifiedElementsAreEqual(index1: number, index2: number): boolean {\n\t\treturn (this.ModifiedSequence.getElementAtIndex(index1) === this.ModifiedSequence.getElementAtIndex(index2));\n\t}\n\n\tpublic ComputeDiff(pretty: boolean): IDiffChange[] {\n\t\treturn this._ComputeDiff(0, this.OriginalSequence.getLength() - 1, 0, this.ModifiedSequence.getLength() - 1, pretty);\n\t}\n\n\t/**\n\t * Computes the differences between the original and modified input\n\t * sequences on the bounded range.\n\t * @returns An array of the differences between the two input sequences.\n\t */\n\tprivate _ComputeDiff(originalStart: number, originalEnd: number, modifiedStart: number, modifiedEnd: number, pretty: boolean): DiffChange[] {\n\t\tlet quitEarlyArr = [false];\n\t\tlet changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n\n\t\tif (pretty) {\n\t\t\t// We have to clean up the computed diff to be more intuitive\n\t\t\t// but it turns out this cannot be done correctly until the entire set\n\t\t\t// of diffs have been computed\n\t\t\treturn this.PrettifyChanges(changes);\n\t\t}\n\n\t\treturn changes;\n\t}\n\n\t/**\n\t * Private helper method which computes the differences on the bounded range\n\t * recursively.\n\t * @returns An array of the differences between the two input sequences.\n\t */\n\tprivate ComputeDiffRecursive(originalStart: number, originalEnd: number, modifiedStart: number, modifiedEnd: number, quitEarlyArr: boolean[]): DiffChange[] {\n\t\tquitEarlyArr[0] = false;\n\n\t\t// Find the start of the differences\n\t\twhile (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n\t\t\toriginalStart++;\n\t\t\tmodifiedStart++;\n\t\t}\n\n\t\t// Find the end of the differences\n\t\twhile (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n\t\t\toriginalEnd--;\n\t\t\tmodifiedEnd--;\n\t\t}\n\n\t\t// In the special case where we either have all insertions or all deletions or the sequences are identical\n\t\tif (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n\t\t\tlet changes: DiffChange[];\n\n\t\t\tif (modifiedStart <= modifiedEnd) {\n\t\t\t\tDebug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n\n\t\t\t\t// All insertions\n\t\t\t\tchanges = [\n\t\t\t\t\tnew DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\n\t\t\t\t];\n\t\t\t} else if (originalStart <= originalEnd) {\n\t\t\t\tDebug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n\n\t\t\t\t// All deletions\n\t\t\t\tchanges = [\n\t\t\t\t\tnew DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tDebug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n\t\t\t\tDebug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n\n\t\t\t\t// Identical sequences - No differences\n\t\t\t\tchanges = [];\n\t\t\t}\n\n\t\t\treturn changes;\n\t\t}\n\n\t\t// This problem can be solved using the Divide-And-Conquer technique.\n\t\tlet midOriginalArr = [0], midModifiedArr = [0];\n\t\tlet result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n\n\t\tlet midOriginal = midOriginalArr[0];\n\t\tlet midModified = midModifiedArr[0];\n\n\t\tif (result !== null) {\n\t\t\t// Result is not-null when there was enough memory to compute the changes while\n\t\t\t// searching for the recursion point\n\t\t\treturn result;\n\t\t} else if (!quitEarlyArr[0]) {\n\t\t\t// We can break the problem down recursively by finding the changes in the\n\t\t\t// First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n\t\t\t// Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n\t\t\t// NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n\n\t\t\tlet leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n\t\t\tlet rightChanges: DiffChange[] = [];\n\n\t\t\tif (!quitEarlyArr[0]) {\n\t\t\t\trightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n\t\t\t} else {\n\t\t\t\t// We did't have time to finish the first half, so we don't have time to compute this half.\n\t\t\t\t// Consider the entire rest of the sequence different.\n\t\t\t\trightChanges = [\n\t\t\t\t\tnew DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\n\t\t\t\t];\n\t\t\t}\n\n\t\t\treturn this.ConcatenateChanges(leftChanges, rightChanges);\n\t\t}\n\n\t\t// If we hit here, we quit early, and so can't return anything meaningful\n\t\treturn [\n\t\t\tnew DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n\t\t];\n\t}\n\n\tprivate WALKTRACE(diagonalForwardBase: number, diagonalForwardStart: number, diagonalForwardEnd: number, diagonalForwardOffset: number,\n\t\tdiagonalReverseBase: number, diagonalReverseStart: number, diagonalReverseEnd: number, diagonalReverseOffset: number,\n\t\tforwardPoints: number[], reversePoints: number[],\n\t\toriginalIndex: number, originalEnd: number, midOriginalArr: number[],\n\t\tmodifiedIndex: number, modifiedEnd: number, midModifiedArr: number[],\n\t\tdeltaIsEven: boolean, quitEarlyArr: boolean[]): DiffChange[] {\n\t\tlet forwardChanges: DiffChange[] | null = null, reverseChanges: DiffChange[] | null = null;\n\n\t\t// First, walk backward through the forward diagonals history\n\t\tlet changeHelper = new DiffChangeHelper();\n\t\tlet diagonalMin = diagonalForwardStart;\n\t\tlet diagonalMax = diagonalForwardEnd;\n\t\tlet diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\n\t\tlet lastOriginalIndex = Number.MIN_VALUE;\n\t\tlet historyIndex = this.m_forwardHistory.length - 1;\n\t\tlet diagonal: number;\n\n\t\tdo {\n\t\t\t// Get the diagonal index from the relative diagonal number\n\t\t\tdiagonal = diagonalRelative + diagonalForwardBase;\n\n\t\t\t// Figure out where we came from\n\t\t\tif (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n\t\t\t\t// Vertical line (the element is an insert)\n\t\t\t\toriginalIndex = forwardPoints[diagonal + 1];\n\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n\t\t\t\tif (originalIndex < lastOriginalIndex) {\n\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t}\n\t\t\t\tlastOriginalIndex = originalIndex;\n\t\t\t\tchangeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n\t\t\t\tdiagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\n\t\t\t} else {\n\t\t\t\t// Horizontal line (the element is a deletion)\n\t\t\t\toriginalIndex = forwardPoints[diagonal - 1] + 1;\n\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n\t\t\t\tif (originalIndex < lastOriginalIndex) {\n\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t}\n\t\t\t\tlastOriginalIndex = originalIndex - 1;\n\t\t\t\tchangeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n\t\t\t\tdiagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\n\t\t\t}\n\n\t\t\tif (historyIndex >= 0) {\n\t\t\t\tforwardPoints = this.m_forwardHistory[historyIndex];\n\t\t\t\tdiagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n\t\t\t\tdiagonalMin = 1;\n\t\t\t\tdiagonalMax = forwardPoints.length - 1;\n\t\t\t}\n\t\t} while (--historyIndex >= -1);\n\n\t\t// Ironically, we get the forward changes as the reverse of the\n\t\t// order we added them since we technically added them backwards\n\t\tforwardChanges = changeHelper.getReverseChanges();\n\n\t\tif (quitEarlyArr[0]) {\n\t\t\t// TODO: Calculate a partial from the reverse diagonals.\n\t\t\t//       For now, just assume everything after the midOriginal/midModified point is a diff\n\n\t\t\tlet originalStartPoint = midOriginalArr[0] + 1;\n\t\t\tlet modifiedStartPoint = midModifiedArr[0] + 1;\n\n\t\t\tif (forwardChanges !== null && forwardChanges.length > 0) {\n\t\t\t\tlet lastForwardChange = forwardChanges[forwardChanges.length - 1];\n\t\t\t\toriginalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n\t\t\t\tmodifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n\t\t\t}\n\n\t\t\treverseChanges = [\n\t\t\t\tnew DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1,\n\t\t\t\t\tmodifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\n\t\t\t];\n\t\t} else {\n\t\t\t// Now walk backward through the reverse diagonals history\n\t\t\tchangeHelper = new DiffChangeHelper();\n\t\t\tdiagonalMin = diagonalReverseStart;\n\t\t\tdiagonalMax = diagonalReverseEnd;\n\t\t\tdiagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\n\t\t\tlastOriginalIndex = Number.MAX_VALUE;\n\t\t\thistoryIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n\n\t\t\tdo {\n\t\t\t\t// Get the diagonal index from the relative diagonal number\n\t\t\t\tdiagonal = diagonalRelative + diagonalReverseBase;\n\n\t\t\t\t// Figure out where we came from\n\t\t\t\tif (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n\t\t\t\t\t// Horizontal line (the element is a deletion))\n\t\t\t\t\toriginalIndex = reversePoints[diagonal + 1] - 1;\n\t\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n\t\t\t\t\tif (originalIndex > lastOriginalIndex) {\n\t\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t\t}\n\t\t\t\t\tlastOriginalIndex = originalIndex + 1;\n\t\t\t\t\tchangeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n\t\t\t\t\tdiagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\n\t\t\t\t} else {\n\t\t\t\t\t// Vertical line (the element is an insertion)\n\t\t\t\t\toriginalIndex = reversePoints[diagonal - 1];\n\t\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n\t\t\t\t\tif (originalIndex > lastOriginalIndex) {\n\t\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t\t}\n\t\t\t\t\tlastOriginalIndex = originalIndex;\n\t\t\t\t\tchangeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n\t\t\t\t\tdiagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\n\t\t\t\t}\n\n\t\t\t\tif (historyIndex >= 0) {\n\t\t\t\t\treversePoints = this.m_reverseHistory[historyIndex];\n\t\t\t\t\tdiagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n\t\t\t\t\tdiagonalMin = 1;\n\t\t\t\t\tdiagonalMax = reversePoints.length - 1;\n\t\t\t\t}\n\t\t\t} while (--historyIndex >= -1);\n\n\t\t\t// There are cases where the reverse history will find diffs that\n\t\t\t// are correct, but not intuitive, so we need shift them.\n\t\t\treverseChanges = changeHelper.getChanges();\n\t\t}\n\n\t\treturn this.ConcatenateChanges(forwardChanges, reverseChanges);\n\t}\n\n\t/**\n\t * Given the range to compute the diff on, this method finds the point:\n\t * (midOriginal, midModified)\n\t * that exists in the middle of the LCS of the two sequences and\n\t * is the point at which the LCS problem may be broken down recursively.\n\t * This method will try to keep the LCS trace in memory. If the LCS recursion\n\t * point is calculated and the full trace is available in memory, then this method\n\t * will return the change list.\n\t * @param originalStart The start bound of the original sequence range\n\t * @param originalEnd The end bound of the original sequence range\n\t * @param modifiedStart The start bound of the modified sequence range\n\t * @param modifiedEnd The end bound of the modified sequence range\n\t * @param midOriginal The middle point of the original sequence range\n\t * @param midModified The middle point of the modified sequence range\n\t * @returns The diff changes, if available, otherwise null\n\t */\n\tprivate ComputeRecursionPoint(originalStart: number, originalEnd: number, modifiedStart: number, modifiedEnd: number, midOriginalArr: number[], midModifiedArr: number[], quitEarlyArr: boolean[]) {\n\t\tlet originalIndex = 0, modifiedIndex = 0;\n\t\tlet diagonalForwardStart = 0, diagonalForwardEnd = 0;\n\t\tlet diagonalReverseStart = 0, diagonalReverseEnd = 0;\n\t\tlet numDifferences: number;\n\n\t\t// To traverse the edit graph and produce the proper LCS, our actual\n\t\t// start position is just outside the given boundary\n\t\toriginalStart--;\n\t\tmodifiedStart--;\n\n\t\t// We set these up to make the compiler happy, but they will\n\t\t// be replaced before we return with the actual recursion point\n\t\tmidOriginalArr[0] = 0;\n\t\tmidModifiedArr[0] = 0;\n\n\t\t// Clear out the history\n\t\tthis.m_forwardHistory = [];\n\t\tthis.m_reverseHistory = [];\n\n\t\t// Each cell in the two arrays corresponds to a diagonal in the edit graph.\n\t\t// The integer value in the cell represents the originalIndex of the furthest\n\t\t// reaching point found so far that ends in that diagonal.\n\t\t// The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n\t\tlet maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\n\t\tlet numDiagonals = maxDifferences + 1;\n\t\tlet forwardPoints: number[] = new Array<number>(numDiagonals);\n\t\tlet reversePoints: number[] = new Array<number>(numDiagonals);\n\t\t// diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n\t\t// diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n\t\tlet diagonalForwardBase = (modifiedEnd - modifiedStart);\n\t\tlet diagonalReverseBase = (originalEnd - originalStart);\n\t\t// diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n\t\t//    diagonal number (relative to diagonalForwardBase)\n\t\t// diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n\t\t//    diagonal number (relative to diagonalReverseBase)\n\t\tlet diagonalForwardOffset = (originalStart - modifiedStart);\n\t\tlet diagonalReverseOffset = (originalEnd - modifiedEnd);\n\n\t\t// delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n\t\t//   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n\t\t// The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n\t\tlet delta = diagonalReverseBase - diagonalForwardBase;\n\t\tlet deltaIsEven = (delta % 2 === 0);\n\n\t\t// Here we set up the start and end points as the furthest points found so far\n\t\t// in both the forward and reverse directions, respectively\n\t\tforwardPoints[diagonalForwardBase] = originalStart;\n\t\treversePoints[diagonalReverseBase] = originalEnd;\n\n\t\t// Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n\t\tquitEarlyArr[0] = false;\n\n\n\n\t\t// A couple of points:\n\t\t// --With this method, we iterate on the number of differences between the two sequences.\n\t\t//   The more differences there actually are, the longer this will take.\n\t\t// --Also, as the number of differences increases, we have to search on diagonals further\n\t\t//   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n\t\t// --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n\t\t//   is even and odd diagonals only when numDifferences is odd.\n\t\tlet diagonal: number, tempOriginalIndex: number;\n\t\tfor (numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\n\t\t\tlet furthestOriginalIndex = 0;\n\t\t\tlet furthestModifiedIndex = 0;\n\n\t\t\t// Run the algorithm in the forward direction\n\t\t\tdiagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n\t\t\tdiagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n\t\t\tfor (diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n\t\t\t\t// STEP 1: We extend the furthest reaching point in the present diagonal\n\t\t\t\t// by looking at the diagonals above and below and picking the one whose point\n\t\t\t\t// is further away from the start point (originalStart, modifiedStart)\n\t\t\t\tif (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n\t\t\t\t\toriginalIndex = forwardPoints[diagonal + 1];\n\t\t\t\t} else {\n\t\t\t\t\toriginalIndex = forwardPoints[diagonal - 1] + 1;\n\t\t\t\t}\n\t\t\t\tmodifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n\n\t\t\t\t// Save the current originalIndex so we can test for false overlap in step 3\n\t\t\t\ttempOriginalIndex = originalIndex;\n\n\t\t\t\t// STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n\t\t\t\t// so long as the elements are equal.\n\t\t\t\twhile (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n\t\t\t\t\toriginalIndex++;\n\t\t\t\t\tmodifiedIndex++;\n\t\t\t\t}\n\t\t\t\tforwardPoints[diagonal] = originalIndex;\n\n\t\t\t\tif (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n\t\t\t\t\tfurthestOriginalIndex = originalIndex;\n\t\t\t\t\tfurthestModifiedIndex = modifiedIndex;\n\t\t\t\t}\n\n\t\t\t\t// STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n\t\t\t\t// and diagonal is in the range of reverse diagonals computed for numDifferences-1\n\t\t\t\t// (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n\t\t\t\t// then check for overlap.\n\t\t\t\tif (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\n\t\t\t\t\tif (originalIndex >= reversePoints[diagonal]) {\n\t\t\t\t\t\tmidOriginalArr[0] = originalIndex;\n\t\t\t\t\t\tmidModifiedArr[0] = modifiedIndex;\n\n\t\t\t\t\t\tif (tempOriginalIndex <= reversePoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\n\t\t\t\t\t\t\t// BINGO! We overlapped, and we have the full trace in memory!\n\t\t\t\t\t\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\t\t\t\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\t\t\t\t\t\tforwardPoints, reversePoints,\n\t\t\t\t\t\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\t\t\t\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\t\t\t\t\t\tdeltaIsEven, quitEarlyArr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Either false overlap, or we didn't have enough memory for the full trace\n\t\t\t\t\t\t\t// Just return the recursion point\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check to see if we should be quitting early, before moving on to the next iteration.\n\t\t\tlet matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n\n\t\t\tif (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, this.OriginalSequence, matchLengthOfLongest)) {\n\t\t\t\t// We can't finish, so skip ahead to generating a result from what we have.\n\t\t\t\tquitEarlyArr[0] = true;\n\n\t\t\t\t// Use the furthest distance we got in the forward direction.\n\t\t\t\tmidOriginalArr[0] = furthestOriginalIndex;\n\t\t\t\tmidModifiedArr[0] = furthestModifiedIndex;\n\n\t\t\t\tif (matchLengthOfLongest > 0 && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\n\t\t\t\t\t// Enough of the history is in memory to walk it backwards\n\t\t\t\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\t\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\t\t\t\tforwardPoints, reversePoints,\n\t\t\t\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\t\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\t\t\t\tdeltaIsEven, quitEarlyArr\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// We didn't actually remember enough of the history.\n\n\t\t\t\t\t//Since we are quiting the diff early, we need to shift back the originalStart and modified start\n\t\t\t\t\t//back into the boundary limits since we decremented their value above beyond the boundary limit.\n\t\t\t\t\toriginalStart++;\n\t\t\t\t\tmodifiedStart++;\n\n\t\t\t\t\treturn [\n\t\t\t\t\t\tnew DiffChange(originalStart, originalEnd - originalStart + 1,\n\t\t\t\t\t\t\tmodifiedStart, modifiedEnd - modifiedStart + 1)\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Run the algorithm in the reverse direction\n\t\t\tdiagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n\t\t\tdiagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n\t\t\tfor (diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n\t\t\t\t// STEP 1: We extend the furthest reaching point in the present diagonal\n\t\t\t\t// by looking at the diagonals above and below and picking the one whose point\n\t\t\t\t// is further away from the start point (originalEnd, modifiedEnd)\n\t\t\t\tif (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n\t\t\t\t\toriginalIndex = reversePoints[diagonal + 1] - 1;\n\t\t\t\t} else {\n\t\t\t\t\toriginalIndex = reversePoints[diagonal - 1];\n\t\t\t\t}\n\t\t\t\tmodifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n\n\t\t\t\t// Save the current originalIndex so we can test for false overlap\n\t\t\t\ttempOriginalIndex = originalIndex;\n\n\t\t\t\t// STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n\t\t\t\t// as long as the elements are equal.\n\t\t\t\twhile (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n\t\t\t\t\toriginalIndex--;\n\t\t\t\t\tmodifiedIndex--;\n\t\t\t\t}\n\t\t\t\treversePoints[diagonal] = originalIndex;\n\n\t\t\t\t// STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n\t\t\t\t// and diagonal is in the range of forward diagonals computed for numDifferences\n\t\t\t\t// then check for overlap.\n\t\t\t\tif (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n\t\t\t\t\tif (originalIndex <= forwardPoints[diagonal]) {\n\t\t\t\t\t\tmidOriginalArr[0] = originalIndex;\n\t\t\t\t\t\tmidModifiedArr[0] = modifiedIndex;\n\n\t\t\t\t\t\tif (tempOriginalIndex >= forwardPoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\n\t\t\t\t\t\t\t// BINGO! We overlapped, and we have the full trace in memory!\n\t\t\t\t\t\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\t\t\t\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\t\t\t\t\t\tforwardPoints, reversePoints,\n\t\t\t\t\t\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\t\t\t\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\t\t\t\t\t\tdeltaIsEven, quitEarlyArr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Either false overlap, or we didn't have enough memory for the full trace\n\t\t\t\t\t\t\t// Just return the recursion point\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Save current vectors to history before the next iteration\n\t\t\tif (numDifferences <= MaxDifferencesHistory) {\n\t\t\t\t// We are allocating space for one extra int, which we fill with\n\t\t\t\t// the index of the diagonal base index\n\t\t\t\tlet temp: number[] = new Array<number>(diagonalForwardEnd - diagonalForwardStart + 2);\n\t\t\t\ttemp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n\t\t\t\tMyArray.Copy(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n\t\t\t\tthis.m_forwardHistory.push(temp);\n\n\t\t\t\ttemp = new Array<number>(diagonalReverseEnd - diagonalReverseStart + 2);\n\t\t\t\ttemp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n\t\t\t\tMyArray.Copy(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n\t\t\t\tthis.m_reverseHistory.push(temp);\n\t\t\t}\n\n\t\t}\n\n\n\n\t\t// If we got here, then we have the full trace in history. We just have to convert it to a change list\n\t\t// NOTE: This part is a bit messy\n\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\tforwardPoints, reversePoints,\n\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\tdeltaIsEven, quitEarlyArr\n\t\t);\n\t}\n\n\t/**\n\t * Shifts the given changes to provide a more intuitive diff.\n\t * While the first element in a diff matches the first element after the diff,\n\t * we shift the diff down.\n\t *\n\t * @param changes The list of changes to shift\n\t * @returns The shifted changes\n\t */\n\tprivate PrettifyChanges(changes: DiffChange[]): DiffChange[] {\n\n\t\t// Shift all the changes down first\n\t\tfor (let i = 0; i < changes.length; i++) {\n\t\t\tconst change = changes[i];\n\t\t\tconst originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this.OriginalSequence.getLength();\n\t\t\tconst modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this.ModifiedSequence.getLength();\n\t\t\tconst checkOriginal = change.originalLength > 0;\n\t\t\tconst checkModified = change.modifiedLength > 0;\n\n\t\t\twhile (change.originalStart + change.originalLength < originalStop &&\n\t\t\t\tchange.modifiedStart + change.modifiedLength < modifiedStop &&\n\t\t\t\t(!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) &&\n\t\t\t\t(!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\n\t\t\t\tchange.originalStart++;\n\t\t\t\tchange.modifiedStart++;\n\t\t\t}\n\n\t\t\tlet mergedChangeArr: Array<DiffChange | null> = [null];\n\t\t\tif (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n\t\t\t\tchanges[i] = mergedChangeArr[0]!;\n\t\t\t\tchanges.splice(i + 1, 1);\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// Shift changes back up until we hit empty or whitespace-only lines\n\t\tfor (let i = changes.length - 1; i >= 0; i--) {\n\t\t\tconst change = changes[i];\n\n\t\t\tlet originalStop = 0;\n\t\t\tlet modifiedStop = 0;\n\t\t\tif (i > 0) {\n\t\t\t\tconst prevChange = changes[i - 1];\n\t\t\t\tif (prevChange.originalLength > 0) {\n\t\t\t\t\toriginalStop = prevChange.originalStart + prevChange.originalLength;\n\t\t\t\t}\n\t\t\t\tif (prevChange.modifiedLength > 0) {\n\t\t\t\t\tmodifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst checkOriginal = change.originalLength > 0;\n\t\t\tconst checkModified = change.modifiedLength > 0;\n\n\t\t\tlet bestDelta = 0;\n\t\t\tlet bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n\n\t\t\tfor (let delta = 1; ; delta++) {\n\t\t\t\tlet originalStart = change.originalStart - delta;\n\t\t\t\tlet modifiedStart = change.modifiedStart - delta;\n\n\t\t\t\tif (originalStart < originalStop || modifiedStart < modifiedStop) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlet score = this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);\n\n\t\t\t\tif (score > bestScore) {\n\t\t\t\t\tbestScore = score;\n\t\t\t\t\tbestDelta = delta;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchange.originalStart -= bestDelta;\n\t\t\tchange.modifiedStart -= bestDelta;\n\t\t}\n\n\t\treturn changes;\n\t}\n\n\tprivate _OriginalIsBoundary(index: number): boolean {\n\t\tif (index <= 0 || index >= this.OriginalSequence.getLength() - 1) {\n\t\t\treturn true;\n\t\t}\n\t\tconst element = this.OriginalSequence.getElementAtIndex(index);\n\t\treturn (typeof element === 'string' && /^\\s*$/.test(element));\n\t}\n\n\tprivate _OriginalRegionIsBoundary(originalStart: number, originalLength: number): boolean {\n\t\tif (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (originalLength > 0) {\n\t\t\tlet originalEnd = originalStart + originalLength;\n\t\t\tif (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate _ModifiedIsBoundary(index: number): boolean {\n\t\tif (index <= 0 || index >= this.ModifiedSequence.getLength() - 1) {\n\t\t\treturn true;\n\t\t}\n\t\tconst element = this.ModifiedSequence.getElementAtIndex(index);\n\t\treturn (typeof element === 'string' && /^\\s*$/.test(element));\n\t}\n\n\tprivate _ModifiedRegionIsBoundary(modifiedStart: number, modifiedLength: number): boolean {\n\t\tif (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (modifiedLength > 0) {\n\t\t\tlet modifiedEnd = modifiedStart + modifiedLength;\n\t\t\tif (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate _boundaryScore(originalStart: number, originalLength: number, modifiedStart: number, modifiedLength: number): number {\n\t\tlet originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);\n\t\tlet modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);\n\t\treturn (originalScore + modifiedScore);\n\t}\n\n\t/**\n\t * Concatenates the two input DiffChange lists and returns the resulting\n\t * list.\n\t * @param The left changes\n\t * @param The right changes\n\t * @returns The concatenated list\n\t */\n\tprivate ConcatenateChanges(left: DiffChange[], right: DiffChange[]): DiffChange[] {\n\t\tlet mergedChangeArr: DiffChange[] = [];\n\n\t\tif (left.length === 0 || right.length === 0) {\n\t\t\treturn (right.length > 0) ? right : left;\n\t\t} else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n\t\t\t// Since we break the problem down recursively, it is possible that we\n\t\t\t// might recurse in the middle of a change thereby splitting it into\n\t\t\t// two changes. Here in the combining stage, we detect and fuse those\n\t\t\t// changes back together\n\t\t\tlet result = new Array<DiffChange>(left.length + right.length - 1);\n\t\t\tMyArray.Copy(left, 0, result, 0, left.length - 1);\n\t\t\tresult[left.length - 1] = mergedChangeArr[0];\n\t\t\tMyArray.Copy(right, 1, result, left.length, right.length - 1);\n\n\t\t\treturn result;\n\t\t} else {\n\t\t\tlet result = new Array<DiffChange>(left.length + right.length);\n\t\t\tMyArray.Copy(left, 0, result, 0, left.length);\n\t\t\tMyArray.Copy(right, 0, result, left.length, right.length);\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the two changes overlap and can be merged into a single\n\t * change\n\t * @param left The left change\n\t * @param right The right change\n\t * @param mergedChange The merged change if the two overlap, null otherwise\n\t * @returns True if the two changes overlap\n\t */\n\tprivate ChangesOverlap(left: DiffChange, right: DiffChange, mergedChangeArr: Array<DiffChange | null>): boolean {\n\t\tDebug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n\t\tDebug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n\n\t\tif (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n\t\t\tlet originalStart = left.originalStart;\n\t\t\tlet originalLength = left.originalLength;\n\t\t\tlet modifiedStart = left.modifiedStart;\n\t\t\tlet modifiedLength = left.modifiedLength;\n\n\t\t\tif (left.originalStart + left.originalLength >= right.originalStart) {\n\t\t\t\toriginalLength = right.originalStart + right.originalLength - left.originalStart;\n\t\t\t}\n\t\t\tif (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n\t\t\t\tmodifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n\t\t\t}\n\n\t\t\tmergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tmergedChangeArr[0] = null;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Helper method used to clip a diagonal index to the range of valid\n\t * diagonals. This also decides whether or not the diagonal index,\n\t * if it exceeds the boundary, should be clipped to the boundary or clipped\n\t * one inside the boundary depending on the Even/Odd status of the boundary\n\t * and numDifferences.\n\t * @param diagonal The index of the diagonal to clip.\n\t * @param numDifferences The current number of differences being iterated upon.\n\t * @param diagonalBaseIndex The base reference diagonal.\n\t * @param numDiagonals The total number of diagonals.\n\t * @returns The clipped diagonal index.\n\t */\n\tprivate ClipDiagonalBound(diagonal: number, numDifferences: number, diagonalBaseIndex: number, numDiagonals: number): number {\n\t\tif (diagonal >= 0 && diagonal < numDiagonals) {\n\t\t\t// Nothing to clip, its in range\n\t\t\treturn diagonal;\n\t\t}\n\n\t\t// diagonalsBelow: The number of diagonals below the reference diagonal\n\t\t// diagonalsAbove: The number of diagonals above the reference diagonal\n\t\tlet diagonalsBelow = diagonalBaseIndex;\n\t\tlet diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n\t\tlet diffEven = (numDifferences % 2 === 0);\n\n\t\tif (diagonal < 0) {\n\t\t\tlet lowerBoundEven = (diagonalsBelow % 2 === 0);\n\t\t\treturn (diffEven === lowerBoundEven) ? 0 : 1;\n\t\t} else {\n\t\t\tlet upperBoundEven = (diagonalsAbove % 2 === 0);\n\t\t\treturn (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\n\t\t}\n\t}\n}\n"]}]}