{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/platform/keybinding/common/keybindingResolver.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/keybinding/common/keybindingResolver.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrays_1 = require(\"vs/base/common/arrays\");\nvar actions_1 = require(\"vs/platform/actions/common/actions\");\nvar commands_1 = require(\"vs/platform/commands/common/commands\");\nvar contextkey_1 = require(\"vs/platform/contextkey/common/contextkey\");\nvar KeybindingResolver = /** @class */ (function () {\n    function KeybindingResolver(defaultKeybindings, overrides) {\n        this._defaultKeybindings = defaultKeybindings;\n        this._defaultBoundCommands = new Map();\n        for (var i = 0, len = defaultKeybindings.length; i < len; i++) {\n            var command = defaultKeybindings[i].command;\n            if (command) {\n                this._defaultBoundCommands.set(command, true);\n            }\n        }\n        this._map = new Map();\n        this._lookupMap = new Map();\n        this._keybindings = KeybindingResolver.combine(defaultKeybindings, overrides);\n        for (var i = 0, len = this._keybindings.length; i < len; i++) {\n            var k = this._keybindings[i];\n            if (k.keypressParts.length === 0) {\n                // unbound\n                continue;\n            }\n            // TODO@chords\n            this._addKeyPress(k.keypressParts[0], k);\n        }\n    }\n    KeybindingResolver._isTargetedForRemoval = function (defaultKb, keypressFirstPart, keypressChordPart, command, when) {\n        if (defaultKb.command !== command) {\n            return false;\n        }\n        // TODO@chords\n        if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {\n            return false;\n        }\n        // TODO@chords\n        if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {\n            return false;\n        }\n        if (when) {\n            if (!defaultKb.when) {\n                return false;\n            }\n            if (!when.equals(defaultKb.when)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Looks for rules containing -command in `overrides` and removes them directly from `defaults`.\n     */\n    KeybindingResolver.combine = function (defaults, rawOverrides) {\n        defaults = defaults.slice(0);\n        var overrides = [];\n        for (var _i = 0, rawOverrides_1 = rawOverrides; _i < rawOverrides_1.length; _i++) {\n            var override = rawOverrides_1[_i];\n            if (!override.command || override.command.length === 0 || override.command.charAt(0) !== '-') {\n                overrides.push(override);\n                continue;\n            }\n            var command = override.command.substr(1);\n            // TODO@chords\n            var keypressFirstPart = override.keypressParts[0];\n            var keypressChordPart = override.keypressParts[1];\n            var when = override.when;\n            for (var j = defaults.length - 1; j >= 0; j--) {\n                if (this._isTargetedForRemoval(defaults[j], keypressFirstPart, keypressChordPart, command, when)) {\n                    defaults.splice(j, 1);\n                }\n            }\n        }\n        return defaults.concat(overrides);\n    };\n    KeybindingResolver.prototype._addKeyPress = function (keypress, item) {\n        var conflicts = this._map.get(keypress);\n        if (typeof conflicts === 'undefined') {\n            // There is no conflict so far\n            this._map.set(keypress, [item]);\n            this._addToLookupMap(item);\n            return;\n        }\n        for (var i = conflicts.length - 1; i >= 0; i--) {\n            var conflict = conflicts[i];\n            if (conflict.command === item.command) {\n                continue;\n            }\n            var conflictIsChord = (conflict.keypressParts.length > 1);\n            var itemIsChord = (item.keypressParts.length > 1);\n            // TODO@chords\n            if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {\n                // The conflict only shares the chord start with this command\n                continue;\n            }\n            if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n                // `item` completely overwrites `conflict`\n                // Remove conflict from the lookupMap\n                this._removeFromLookupMap(conflict);\n            }\n        }\n        conflicts.push(item);\n        this._addToLookupMap(item);\n    };\n    KeybindingResolver.prototype._addToLookupMap = function (item) {\n        if (!item.command) {\n            return;\n        }\n        var arr = this._lookupMap.get(item.command);\n        if (typeof arr === 'undefined') {\n            arr = [item];\n            this._lookupMap.set(item.command, arr);\n        }\n        else {\n            arr.push(item);\n        }\n    };\n    KeybindingResolver.prototype._removeFromLookupMap = function (item) {\n        if (!item.command) {\n            return;\n        }\n        var arr = this._lookupMap.get(item.command);\n        if (typeof arr === 'undefined') {\n            return;\n        }\n        for (var i = 0, len = arr.length; i < len; i++) {\n            if (arr[i] === item) {\n                arr.splice(i, 1);\n                return;\n            }\n        }\n    };\n    /**\n     * Returns true if it is provable `a` implies `b`.\n     * **Precondition**: Assumes `a` and `b` are normalized!\n     */\n    KeybindingResolver.whenIsEntirelyIncluded = function (a, b) {\n        if (!b) {\n            return true;\n        }\n        if (!a) {\n            return false;\n        }\n        var aExpressions = ((a instanceof contextkey_1.ContextKeyAndExpr) ? a.expr : [a]);\n        var bExpressions = ((b instanceof contextkey_1.ContextKeyAndExpr) ? b.expr : [b]);\n        var aIndex = 0;\n        for (var _i = 0, bExpressions_1 = bExpressions; _i < bExpressions_1.length; _i++) {\n            var bExpr = bExpressions_1[_i];\n            var bExprMatched = false;\n            while (!bExprMatched && aIndex < aExpressions.length) {\n                var aExpr = aExpressions[aIndex];\n                if (aExpr.equals(bExpr)) {\n                    bExprMatched = true;\n                }\n                aIndex++;\n            }\n            if (!bExprMatched) {\n                return false;\n            }\n        }\n        return true;\n    };\n    KeybindingResolver.prototype.getDefaultBoundCommands = function () {\n        return this._defaultBoundCommands;\n    };\n    KeybindingResolver.prototype.getDefaultKeybindings = function () {\n        return this._defaultKeybindings;\n    };\n    KeybindingResolver.prototype.getKeybindings = function () {\n        return this._keybindings;\n    };\n    KeybindingResolver.prototype.lookupKeybindings = function (commandId) {\n        var items = this._lookupMap.get(commandId);\n        if (typeof items === 'undefined' || items.length === 0) {\n            return [];\n        }\n        // Reverse to get the most specific item first\n        var result = [], resultLen = 0;\n        for (var i = items.length - 1; i >= 0; i--) {\n            result[resultLen++] = items[i];\n        }\n        return result;\n    };\n    KeybindingResolver.prototype.lookupPrimaryKeybinding = function (commandId) {\n        var items = this._lookupMap.get(commandId);\n        if (typeof items === 'undefined' || items.length === 0) {\n            return null;\n        }\n        return items[items.length - 1];\n    };\n    KeybindingResolver.prototype.resolve = function (context, currentChord, keypress) {\n        var lookupMap = null;\n        if (currentChord !== null) {\n            // Fetch all chord bindings for `currentChord`\n            var candidates = this._map.get(currentChord);\n            if (typeof candidates === 'undefined') {\n                // No chords starting with `currentChord`\n                return null;\n            }\n            lookupMap = [];\n            for (var i = 0, len = candidates.length; i < len; i++) {\n                var candidate = candidates[i];\n                // TODO@chords\n                if (candidate.keypressParts[1] === keypress) {\n                    lookupMap.push(candidate);\n                }\n            }\n        }\n        else {\n            var candidates = this._map.get(keypress);\n            if (typeof candidates === 'undefined') {\n                // No bindings with `keypress`\n                return null;\n            }\n            lookupMap = candidates;\n        }\n        var result = this._findCommand(context, lookupMap);\n        if (!result) {\n            return null;\n        }\n        // TODO@chords\n        if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {\n            return {\n                enterChord: true,\n                commandId: null,\n                commandArgs: null,\n                bubble: false\n            };\n        }\n        return {\n            enterChord: false,\n            commandId: result.command,\n            commandArgs: result.commandArgs,\n            bubble: result.bubble\n        };\n    };\n    KeybindingResolver.prototype._findCommand = function (context, matches) {\n        for (var i = matches.length - 1; i >= 0; i--) {\n            var k = matches[i];\n            if (!KeybindingResolver.contextMatchesRules(context, k.when)) {\n                continue;\n            }\n            return k;\n        }\n        return null;\n    };\n    KeybindingResolver.contextMatchesRules = function (context, rules) {\n        if (!rules) {\n            return true;\n        }\n        return rules.evaluate(context);\n    };\n    KeybindingResolver.getAllUnboundCommands = function (boundCommands) {\n        var unboundCommands = [];\n        var seenMap = new Map();\n        var addCommand = function (id, includeCommandWithArgs) {\n            if (seenMap.has(id)) {\n                return;\n            }\n            seenMap.set(id, true);\n            if (id[0] === '_' || id.indexOf('vscode.') === 0) { // private command\n                return;\n            }\n            if (boundCommands.get(id) === true) {\n                return;\n            }\n            if (!includeCommandWithArgs) {\n                var command = commands_1.CommandsRegistry.getCommand(id);\n                if (command && typeof command.description === 'object'\n                    && arrays_1.isNonEmptyArray(command.description.args)) { // command with args\n                    return;\n                }\n            }\n            unboundCommands.push(id);\n        };\n        for (var id in actions_1.MenuRegistry.getCommands()) {\n            addCommand(id, true);\n        }\n        for (var id in commands_1.CommandsRegistry.getCommands()) {\n            addCommand(id, false);\n        }\n        return unboundCommands;\n    };\n    return KeybindingResolver;\n}());\nexports.KeybindingResolver = KeybindingResolver;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/platform/keybinding/common/keybindingResolver.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/platform/keybinding/common/keybindingResolver.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isNonEmptyArray } from 'vs/base/common/arrays';\nimport { MenuRegistry } from 'vs/platform/actions/common/actions';\nimport { CommandsRegistry, ICommandHandlerDescription } from 'vs/platform/commands/common/commands';\nimport { ContextKeyAndExpr, ContextKeyExpr, IContext } from 'vs/platform/contextkey/common/contextkey';\nimport { ResolvedKeybindingItem } from 'vs/platform/keybinding/common/resolvedKeybindingItem';\n\nexport interface IResolveResult {\n\tenterChord: boolean;\n\tcommandId: string | null;\n\tcommandArgs: any;\n\tbubble: boolean;\n}\n\nexport class KeybindingResolver {\n\tprivate readonly _defaultKeybindings: ResolvedKeybindingItem[];\n\tprivate readonly _keybindings: ResolvedKeybindingItem[];\n\tprivate readonly _defaultBoundCommands: Map<string, boolean>;\n\tprivate readonly _map: Map<string, ResolvedKeybindingItem[]>;\n\tprivate readonly _lookupMap: Map<string, ResolvedKeybindingItem[]>;\n\n\tconstructor(defaultKeybindings: ResolvedKeybindingItem[], overrides: ResolvedKeybindingItem[]) {\n\t\tthis._defaultKeybindings = defaultKeybindings;\n\n\t\tthis._defaultBoundCommands = new Map<string, boolean>();\n\t\tfor (let i = 0, len = defaultKeybindings.length; i < len; i++) {\n\t\t\tconst command = defaultKeybindings[i].command;\n\t\t\tif (command) {\n\t\t\t\tthis._defaultBoundCommands.set(command, true);\n\t\t\t}\n\t\t}\n\n\t\tthis._map = new Map<string, ResolvedKeybindingItem[]>();\n\t\tthis._lookupMap = new Map<string, ResolvedKeybindingItem[]>();\n\n\t\tthis._keybindings = KeybindingResolver.combine(defaultKeybindings, overrides);\n\t\tfor (let i = 0, len = this._keybindings.length; i < len; i++) {\n\t\t\tlet k = this._keybindings[i];\n\t\t\tif (k.keypressParts.length === 0) {\n\t\t\t\t// unbound\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// TODO@chords\n\t\t\tthis._addKeyPress(k.keypressParts[0], k);\n\t\t}\n\t}\n\n\tprivate static _isTargetedForRemoval(defaultKb: ResolvedKeybindingItem, keypressFirstPart: string | null, keypressChordPart: string | null, command: string, when: ContextKeyExpr | undefined): boolean {\n\t\tif (defaultKb.command !== command) {\n\t\t\treturn false;\n\t\t}\n\t\t// TODO@chords\n\t\tif (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {\n\t\t\treturn false;\n\t\t}\n\t\t// TODO@chords\n\t\tif (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {\n\t\t\treturn false;\n\t\t}\n\t\tif (when) {\n\t\t\tif (!defaultKb.when) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!when.equals(defaultKb.when)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Looks for rules containing -command in `overrides` and removes them directly from `defaults`.\n\t */\n\tpublic static combine(defaults: ResolvedKeybindingItem[], rawOverrides: ResolvedKeybindingItem[]): ResolvedKeybindingItem[] {\n\t\tdefaults = defaults.slice(0);\n\t\tlet overrides: ResolvedKeybindingItem[] = [];\n\t\tfor (const override of rawOverrides) {\n\t\t\tif (!override.command || override.command.length === 0 || override.command.charAt(0) !== '-') {\n\t\t\t\toverrides.push(override);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst command = override.command.substr(1);\n\t\t\t// TODO@chords\n\t\t\tconst keypressFirstPart = override.keypressParts[0];\n\t\t\tconst keypressChordPart = override.keypressParts[1];\n\t\t\tconst when = override.when;\n\t\t\tfor (let j = defaults.length - 1; j >= 0; j--) {\n\t\t\t\tif (this._isTargetedForRemoval(defaults[j], keypressFirstPart, keypressChordPart, command, when)) {\n\t\t\t\t\tdefaults.splice(j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn defaults.concat(overrides);\n\t}\n\n\tprivate _addKeyPress(keypress: string, item: ResolvedKeybindingItem): void {\n\n\t\tconst conflicts = this._map.get(keypress);\n\n\t\tif (typeof conflicts === 'undefined') {\n\t\t\t// There is no conflict so far\n\t\t\tthis._map.set(keypress, [item]);\n\t\t\tthis._addToLookupMap(item);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = conflicts.length - 1; i >= 0; i--) {\n\t\t\tlet conflict = conflicts[i];\n\n\t\t\tif (conflict.command === item.command) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst conflictIsChord = (conflict.keypressParts.length > 1);\n\t\t\tconst itemIsChord = (item.keypressParts.length > 1);\n\n\t\t\t// TODO@chords\n\t\t\tif (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {\n\t\t\t\t// The conflict only shares the chord start with this command\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n\t\t\t\t// `item` completely overwrites `conflict`\n\t\t\t\t// Remove conflict from the lookupMap\n\t\t\t\tthis._removeFromLookupMap(conflict);\n\t\t\t}\n\t\t}\n\n\t\tconflicts.push(item);\n\t\tthis._addToLookupMap(item);\n\t}\n\n\tprivate _addToLookupMap(item: ResolvedKeybindingItem): void {\n\t\tif (!item.command) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet arr = this._lookupMap.get(item.command);\n\t\tif (typeof arr === 'undefined') {\n\t\t\tarr = [item];\n\t\t\tthis._lookupMap.set(item.command, arr);\n\t\t} else {\n\t\t\tarr.push(item);\n\t\t}\n\t}\n\n\tprivate _removeFromLookupMap(item: ResolvedKeybindingItem): void {\n\t\tif (!item.command) {\n\t\t\treturn;\n\t\t}\n\t\tlet arr = this._lookupMap.get(item.command);\n\t\tif (typeof arr === 'undefined') {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\t\tif (arr[i] === item) {\n\t\t\t\tarr.splice(i, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if it is provable `a` implies `b`.\n\t * **Precondition**: Assumes `a` and `b` are normalized!\n\t */\n\tpublic static whenIsEntirelyIncluded(a: ContextKeyExpr | null | undefined, b: ContextKeyExpr | null | undefined): boolean {\n\t\tif (!b) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!a) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst aExpressions: ContextKeyExpr[] = ((a instanceof ContextKeyAndExpr) ? a.expr : [a]);\n\t\tconst bExpressions: ContextKeyExpr[] = ((b instanceof ContextKeyAndExpr) ? b.expr : [b]);\n\n\t\tlet aIndex = 0;\n\t\tfor (const bExpr of bExpressions) {\n\t\t\tlet bExprMatched = false;\n\t\t\twhile (!bExprMatched && aIndex < aExpressions.length) {\n\t\t\t\tlet aExpr = aExpressions[aIndex];\n\t\t\t\tif (aExpr.equals(bExpr)) {\n\t\t\t\t\tbExprMatched = true;\n\t\t\t\t}\n\t\t\t\taIndex++;\n\t\t\t}\n\n\t\t\tif (!bExprMatched) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic getDefaultBoundCommands(): Map<string, boolean> {\n\t\treturn this._defaultBoundCommands;\n\t}\n\n\tpublic getDefaultKeybindings(): ResolvedKeybindingItem[] {\n\t\treturn this._defaultKeybindings;\n\t}\n\n\tpublic getKeybindings(): ResolvedKeybindingItem[] {\n\t\treturn this._keybindings;\n\t}\n\n\tpublic lookupKeybindings(commandId: string): ResolvedKeybindingItem[] {\n\t\tlet items = this._lookupMap.get(commandId);\n\t\tif (typeof items === 'undefined' || items.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Reverse to get the most specific item first\n\t\tlet result: ResolvedKeybindingItem[] = [], resultLen = 0;\n\t\tfor (let i = items.length - 1; i >= 0; i--) {\n\t\t\tresult[resultLen++] = items[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic lookupPrimaryKeybinding(commandId: string): ResolvedKeybindingItem | null {\n\t\tlet items = this._lookupMap.get(commandId);\n\t\tif (typeof items === 'undefined' || items.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn items[items.length - 1];\n\t}\n\n\tpublic resolve(context: IContext, currentChord: string | null, keypress: string): IResolveResult | null {\n\t\tlet lookupMap: ResolvedKeybindingItem[] | null = null;\n\n\t\tif (currentChord !== null) {\n\t\t\t// Fetch all chord bindings for `currentChord`\n\n\t\t\tconst candidates = this._map.get(currentChord);\n\t\t\tif (typeof candidates === 'undefined') {\n\t\t\t\t// No chords starting with `currentChord`\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlookupMap = [];\n\t\t\tfor (let i = 0, len = candidates.length; i < len; i++) {\n\t\t\t\tlet candidate = candidates[i];\n\t\t\t\t// TODO@chords\n\t\t\t\tif (candidate.keypressParts[1] === keypress) {\n\t\t\t\t\tlookupMap.push(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst candidates = this._map.get(keypress);\n\t\t\tif (typeof candidates === 'undefined') {\n\t\t\t\t// No bindings with `keypress`\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlookupMap = candidates;\n\t\t}\n\n\t\tlet result = this._findCommand(context, lookupMap);\n\t\tif (!result) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// TODO@chords\n\t\tif (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {\n\t\t\treturn {\n\t\t\t\tenterChord: true,\n\t\t\t\tcommandId: null,\n\t\t\t\tcommandArgs: null,\n\t\t\t\tbubble: false\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tenterChord: false,\n\t\t\tcommandId: result.command,\n\t\t\tcommandArgs: result.commandArgs,\n\t\t\tbubble: result.bubble\n\t\t};\n\t}\n\n\tprivate _findCommand(context: IContext, matches: ResolvedKeybindingItem[]): ResolvedKeybindingItem | null {\n\t\tfor (let i = matches.length - 1; i >= 0; i--) {\n\t\t\tlet k = matches[i];\n\n\t\t\tif (!KeybindingResolver.contextMatchesRules(context, k.when)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn k;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic static contextMatchesRules(context: IContext, rules: ContextKeyExpr | null | undefined): boolean {\n\t\tif (!rules) {\n\t\t\treturn true;\n\t\t}\n\t\treturn rules.evaluate(context);\n\t}\n\n\tpublic static getAllUnboundCommands(boundCommands: Map<string, boolean>): string[] {\n\t\tconst unboundCommands: string[] = [];\n\t\tconst seenMap: Map<string, boolean> = new Map<string, boolean>();\n\t\tconst addCommand = (id: string, includeCommandWithArgs: boolean) => {\n\t\t\tif (seenMap.has(id)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tseenMap.set(id, true);\n\t\t\tif (id[0] === '_' || id.indexOf('vscode.') === 0) { // private command\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (boundCommands.get(id) === true) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!includeCommandWithArgs) {\n\t\t\t\tconst command = CommandsRegistry.getCommand(id);\n\t\t\t\tif (command && typeof command.description === 'object'\n\t\t\t\t\t&& isNonEmptyArray((<ICommandHandlerDescription>command.description).args)) { // command with args\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunboundCommands.push(id);\n\t\t};\n\t\tfor (const id in MenuRegistry.getCommands()) {\n\t\t\taddCommand(id, true);\n\t\t}\n\t\tfor (const id in CommandsRegistry.getCommands()) {\n\t\t\taddCommand(id, false);\n\t\t}\n\n\t\treturn unboundCommands;\n\t}\n}\n"]}]}