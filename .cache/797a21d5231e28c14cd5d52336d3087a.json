{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/backup/node/backupFileService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/backup/node/backupFileService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/path\", \"crypto\", \"vs/base/node/pfs\", \"vs/base/common/uri\", \"vs/base/common/async\", \"vs/workbench/services/backup/common/backup\", \"vs/platform/files/common/files\", \"vs/base/node/stream\", \"vs/editor/common/model/textModel\", \"vs/base/common/map\", \"vs/base/common/network\", \"vs/platform/windows/common/windows\", \"vs/platform/instantiation/common/extensions\"], function (require, exports, path, crypto, pfs, uri_1, async_1, backup_1, files_1, stream_1, textModel_1, map_1, network_1, windows_1, extensions_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class BackupSnapshot {\n        constructor(snapshot, preamble) {\n            this.snapshot = snapshot;\n            this.preamble = preamble;\n        }\n        read() {\n            let value = this.snapshot.read();\n            if (!this.preambleHandled) {\n                this.preambleHandled = true;\n                if (typeof value === 'string') {\n                    value = this.preamble + value;\n                }\n                else {\n                    value = this.preamble;\n                }\n            }\n            return value;\n        }\n    }\n    exports.BackupSnapshot = BackupSnapshot;\n    class BackupFilesModel {\n        constructor() {\n            this.cache = Object.create(null);\n        }\n        resolve(backupRoot) {\n            return pfs.readDirsInDir(backupRoot).then(backupSchemas => {\n                // For all supported schemas\n                return Promise.all(backupSchemas.map(backupSchema => {\n                    // Read backup directory for backups\n                    const backupSchemaPath = path.join(backupRoot, backupSchema);\n                    return pfs.readdir(backupSchemaPath).then(backupHashes => {\n                        // Remember known backups in our caches\n                        backupHashes.forEach(backupHash => {\n                            const backupResource = uri_1.URI.file(path.join(backupSchemaPath, backupHash));\n                            this.add(backupResource);\n                        });\n                    });\n                }));\n            }).then(() => this, error => this);\n        }\n        add(resource, versionId = 0) {\n            this.cache[resource.toString()] = versionId;\n        }\n        count() {\n            return Object.keys(this.cache).length;\n        }\n        has(resource, versionId) {\n            const cachedVersionId = this.cache[resource.toString()];\n            if (typeof cachedVersionId !== 'number') {\n                return false; // unknown resource\n            }\n            if (typeof versionId === 'number') {\n                return versionId === cachedVersionId; // if we are asked with a specific version ID, make sure to test for it\n            }\n            return true;\n        }\n        get() {\n            return Object.keys(this.cache).map(k => uri_1.URI.parse(k));\n        }\n        remove(resource) {\n            delete this.cache[resource.toString()];\n        }\n        clear() {\n            this.cache = Object.create(null);\n        }\n    }\n    exports.BackupFilesModel = BackupFilesModel;\n    let BackupFileService = class BackupFileService {\n        constructor(windowService, fileService) {\n            const backupWorkspacePath = windowService.getConfiguration().backupPath;\n            if (backupWorkspacePath) {\n                this.impl = new BackupFileServiceImpl(backupWorkspacePath, fileService);\n            }\n            else {\n                this.impl = new InMemoryBackupFileService();\n            }\n        }\n        initialize(backupWorkspacePath) {\n            if (this.impl instanceof BackupFileServiceImpl) {\n                this.impl.initialize(backupWorkspacePath);\n            }\n        }\n        hasBackups() {\n            return this.impl.hasBackups();\n        }\n        loadBackupResource(resource) {\n            return this.impl.loadBackupResource(resource);\n        }\n        backupResource(resource, content, versionId) {\n            return this.impl.backupResource(resource, content, versionId);\n        }\n        discardResourceBackup(resource) {\n            return this.impl.discardResourceBackup(resource);\n        }\n        discardAllWorkspaceBackups() {\n            return this.impl.discardAllWorkspaceBackups();\n        }\n        getWorkspaceFileBackups() {\n            return this.impl.getWorkspaceFileBackups();\n        }\n        resolveBackupContent(backup) {\n            return this.impl.resolveBackupContent(backup);\n        }\n        toBackupResource(resource) {\n            return this.impl.toBackupResource(resource);\n        }\n    };\n    BackupFileService = __decorate([\n        __param(0, windows_1.IWindowService),\n        __param(1, files_1.IFileService)\n    ], BackupFileService);\n    exports.BackupFileService = BackupFileService;\n    let BackupFileServiceImpl = class BackupFileServiceImpl {\n        constructor(backupWorkspacePath, fileService) {\n            this.fileService = fileService;\n            this.isShuttingDown = false;\n            this.ioOperationQueues = new async_1.ResourceQueue();\n            this.initialize(backupWorkspacePath);\n        }\n        initialize(backupWorkspacePath) {\n            this.backupWorkspacePath = backupWorkspacePath;\n            this.ready = this.init();\n        }\n        init() {\n            const model = new BackupFilesModel();\n            return model.resolve(this.backupWorkspacePath);\n        }\n        hasBackups() {\n            return this.ready.then(model => {\n                return model.count() > 0;\n            });\n        }\n        loadBackupResource(resource) {\n            return this.ready.then(model => {\n                // Return directly if we have a known backup with that resource\n                const backupResource = this.toBackupResource(resource);\n                if (model.has(backupResource)) {\n                    return backupResource;\n                }\n                return undefined;\n            });\n        }\n        backupResource(resource, content, versionId) {\n            if (this.isShuttingDown) {\n                return Promise.resolve();\n            }\n            return this.ready.then(model => {\n                const backupResource = this.toBackupResource(resource);\n                if (model.has(backupResource, versionId)) {\n                    return undefined; // return early if backup version id matches requested one\n                }\n                return this.ioOperationQueues.queueFor(backupResource).queue(() => {\n                    const preamble = `${resource.toString()}${BackupFileServiceImpl.META_MARKER}`;\n                    // Update content with value\n                    return this.fileService.updateContent(backupResource, new BackupSnapshot(content, preamble), backup_1.BACKUP_FILE_UPDATE_OPTIONS).then(() => model.add(backupResource, versionId));\n                });\n            });\n        }\n        discardResourceBackup(resource) {\n            return this.ready.then(model => {\n                const backupResource = this.toBackupResource(resource);\n                return this.ioOperationQueues.queueFor(backupResource).queue(() => {\n                    return pfs.del(backupResource.fsPath).then(() => model.remove(backupResource));\n                });\n            });\n        }\n        discardAllWorkspaceBackups() {\n            this.isShuttingDown = true;\n            return this.ready.then(model => {\n                return pfs.del(this.backupWorkspacePath).then(() => model.clear());\n            });\n        }\n        getWorkspaceFileBackups() {\n            return this.ready.then(model => {\n                const readPromises = [];\n                model.get().forEach(fileBackup => {\n                    readPromises.push(stream_1.readToMatchingString(fileBackup.fsPath, BackupFileServiceImpl.META_MARKER, 2000, 10000).then(uri_1.URI.parse));\n                });\n                return Promise.all(readPromises);\n            });\n        }\n        resolveBackupContent(backup) {\n            return this.fileService.resolveStreamContent(backup, backup_1.BACKUP_FILE_RESOLVE_OPTIONS).then(content => {\n                // Add a filter method to filter out everything until the meta marker\n                let metaFound = false;\n                const metaPreambleFilter = (chunk) => {\n                    if (!metaFound && chunk) {\n                        const metaIndex = chunk.indexOf(BackupFileServiceImpl.META_MARKER);\n                        if (metaIndex === -1) {\n                            return ''; // meta not yet found, return empty string\n                        }\n                        metaFound = true;\n                        return chunk.substr(metaIndex + 1); // meta found, return everything after\n                    }\n                    return chunk;\n                };\n                return textModel_1.createTextBufferFactoryFromStream(content.value, metaPreambleFilter);\n            });\n        }\n        toBackupResource(resource) {\n            return uri_1.URI.file(path.join(this.backupWorkspacePath, resource.scheme, hashPath(resource)));\n        }\n    };\n    BackupFileServiceImpl.META_MARKER = '\\n';\n    BackupFileServiceImpl = __decorate([\n        __param(1, files_1.IFileService)\n    ], BackupFileServiceImpl);\n    class InMemoryBackupFileService {\n        constructor() {\n            this.backups = new Map();\n        }\n        hasBackups() {\n            return Promise.resolve(this.backups.size > 0);\n        }\n        loadBackupResource(resource) {\n            const backupResource = this.toBackupResource(resource);\n            if (this.backups.has(backupResource.toString())) {\n                return Promise.resolve(backupResource);\n            }\n            return Promise.resolve(undefined);\n        }\n        backupResource(resource, content, versionId) {\n            const backupResource = this.toBackupResource(resource);\n            this.backups.set(backupResource.toString(), content);\n            return Promise.resolve();\n        }\n        resolveBackupContent(backupResource) {\n            const snapshot = this.backups.get(backupResource.toString());\n            if (snapshot) {\n                return Promise.resolve(textModel_1.createTextBufferFactoryFromSnapshot(snapshot));\n            }\n            return Promise.resolve(undefined);\n        }\n        getWorkspaceFileBackups() {\n            return Promise.resolve(map_1.keys(this.backups).map(key => uri_1.URI.parse(key)));\n        }\n        discardResourceBackup(resource) {\n            this.backups.delete(this.toBackupResource(resource).toString());\n            return Promise.resolve();\n        }\n        discardAllWorkspaceBackups() {\n            this.backups.clear();\n            return Promise.resolve();\n        }\n        toBackupResource(resource) {\n            return uri_1.URI.file(path.join(resource.scheme, hashPath(resource)));\n        }\n    }\n    exports.InMemoryBackupFileService = InMemoryBackupFileService;\n    /*\n     * Exported only for testing\n     */\n    function hashPath(resource) {\n        const str = resource.scheme === network_1.Schemas.file || resource.scheme === network_1.Schemas.untitled ? resource.fsPath : resource.toString();\n        return crypto.createHash('md5').update(str).digest('hex');\n    }\n    exports.hashPath = hashPath;\n    extensions_1.registerSingleton(backup_1.IBackupFileService, BackupFileService);\n});\n",null]}