{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/textfile/common/textFileEditorModelManager.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/textfile/common/textFileEditorModelManager.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/event\", \"vs/workbench/services/textfile/common/textFileEditorModel\", \"vs/base/common/lifecycle\", \"vs/workbench/services/textfile/common/textfiles\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/platform/instantiation/common/instantiation\", \"vs/base/common/map\"], function (require, exports, event_1, textFileEditorModel_1, lifecycle_1, textfiles_1, lifecycle_2, instantiation_1, map_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let TextFileEditorModelManager = class TextFileEditorModelManager extends lifecycle_1.Disposable {\n        constructor(lifecycleService, instantiationService) {\n            super();\n            this.lifecycleService = lifecycleService;\n            this.instantiationService = instantiationService;\n            this._onModelDisposed = this._register(new event_1.Emitter());\n            this._onModelContentChanged = this._register(new event_1.Emitter());\n            this._onModelDirty = this._register(new event_1.Emitter());\n            this._onModelSaveError = this._register(new event_1.Emitter());\n            this._onModelSaved = this._register(new event_1.Emitter());\n            this._onModelReverted = this._register(new event_1.Emitter());\n            this._onModelEncodingChanged = this._register(new event_1.Emitter());\n            this._onModelOrphanedChanged = this._register(new event_1.Emitter());\n            this.mapResourceToModel = new map_1.ResourceMap();\n            this.mapResourceToDisposeListener = new map_1.ResourceMap();\n            this.mapResourceToStateChangeListener = new map_1.ResourceMap();\n            this.mapResourceToModelContentChangeListener = new map_1.ResourceMap();\n            this.mapResourceToPendingModelLoaders = new map_1.ResourceMap();\n            this.registerListeners();\n        }\n        get onModelDisposed() { return this._onModelDisposed.event; }\n        get onModelContentChanged() { return this._onModelContentChanged.event; }\n        get onModelDirty() { return this._onModelDirty.event; }\n        get onModelSaveError() { return this._onModelSaveError.event; }\n        get onModelSaved() { return this._onModelSaved.event; }\n        get onModelReverted() { return this._onModelReverted.event; }\n        get onModelEncodingChanged() { return this._onModelEncodingChanged.event; }\n        get onModelOrphanedChanged() { return this._onModelOrphanedChanged.event; }\n        registerListeners() {\n            // Lifecycle\n            this.lifecycleService.onShutdown(this.dispose, this);\n        }\n        get onModelsDirty() {\n            if (!this._onModelsDirtyEvent) {\n                this._onModelsDirtyEvent = this.debounce(this.onModelDirty);\n            }\n            return this._onModelsDirtyEvent;\n        }\n        get onModelsSaveError() {\n            if (!this._onModelsSaveError) {\n                this._onModelsSaveError = this.debounce(this.onModelSaveError);\n            }\n            return this._onModelsSaveError;\n        }\n        get onModelsSaved() {\n            if (!this._onModelsSaved) {\n                this._onModelsSaved = this.debounce(this.onModelSaved);\n            }\n            return this._onModelsSaved;\n        }\n        get onModelsReverted() {\n            if (!this._onModelsReverted) {\n                this._onModelsReverted = this.debounce(this.onModelReverted);\n            }\n            return this._onModelsReverted;\n        }\n        debounce(event) {\n            return event_1.Event.debounce(event, (prev, cur) => {\n                if (!prev) {\n                    prev = [cur];\n                }\n                else {\n                    prev.push(cur);\n                }\n                return prev;\n            }, this.debounceDelay());\n        }\n        debounceDelay() {\n            return 250;\n        }\n        get(resource) {\n            return this.mapResourceToModel.get(resource);\n        }\n        loadOrCreate(resource, options) {\n            // Return early if model is currently being loaded\n            const pendingLoad = this.mapResourceToPendingModelLoaders.get(resource);\n            if (pendingLoad) {\n                return pendingLoad;\n            }\n            let modelPromise;\n            // Model exists\n            let model = this.get(resource);\n            if (model) {\n                if (options && options.reload) {\n                    // async reload: trigger a reload but return immediately\n                    if (options.reload.async) {\n                        modelPromise = Promise.resolve(model);\n                        model.load(options);\n                    }\n                    // sync reload: do not return until model reloaded\n                    else {\n                        modelPromise = model.load(options);\n                    }\n                }\n                else {\n                    modelPromise = Promise.resolve(model);\n                }\n            }\n            // Model does not exist\n            else {\n                const newModel = model = this.instantiationService.createInstance(textFileEditorModel_1.TextFileEditorModel, resource, options ? options.encoding : undefined);\n                modelPromise = model.load(options);\n                // Install state change listener\n                this.mapResourceToStateChangeListener.set(resource, model.onDidStateChange(state => {\n                    const event = new textfiles_1.TextFileModelChangeEvent(newModel, state);\n                    switch (state) {\n                        case textfiles_1.StateChange.DIRTY:\n                            this._onModelDirty.fire(event);\n                            break;\n                        case textfiles_1.StateChange.SAVE_ERROR:\n                            this._onModelSaveError.fire(event);\n                            break;\n                        case textfiles_1.StateChange.SAVED:\n                            this._onModelSaved.fire(event);\n                            break;\n                        case textfiles_1.StateChange.REVERTED:\n                            this._onModelReverted.fire(event);\n                            break;\n                        case textfiles_1.StateChange.ENCODING:\n                            this._onModelEncodingChanged.fire(event);\n                            break;\n                        case textfiles_1.StateChange.ORPHANED_CHANGE:\n                            this._onModelOrphanedChanged.fire(event);\n                            break;\n                    }\n                }));\n                // Install model content change listener\n                this.mapResourceToModelContentChangeListener.set(resource, model.onDidContentChange(e => {\n                    this._onModelContentChanged.fire(new textfiles_1.TextFileModelChangeEvent(newModel, e));\n                }));\n            }\n            // Store pending loads to avoid race conditions\n            this.mapResourceToPendingModelLoaders.set(resource, modelPromise);\n            return modelPromise.then(model => {\n                // Make known to manager (if not already known)\n                this.add(resource, model);\n                // Model can be dirty if a backup was restored, so we make sure to have this event delivered\n                if (model.isDirty()) {\n                    this._onModelDirty.fire(new textfiles_1.TextFileModelChangeEvent(model, textfiles_1.StateChange.DIRTY));\n                }\n                // Remove from pending loads\n                this.mapResourceToPendingModelLoaders.delete(resource);\n                return model;\n            }, error => {\n                // Free resources of this invalid model\n                if (model) {\n                    model.dispose();\n                }\n                // Remove from pending loads\n                this.mapResourceToPendingModelLoaders.delete(resource);\n                return Promise.reject(error);\n            });\n        }\n        getAll(resource, filter) {\n            if (resource) {\n                const res = this.mapResourceToModel.get(resource);\n                return res ? [res] : [];\n            }\n            const res = [];\n            this.mapResourceToModel.forEach(model => {\n                if (!filter || filter(model)) {\n                    res.push(model);\n                }\n            });\n            return res;\n        }\n        add(resource, model) {\n            const knownModel = this.mapResourceToModel.get(resource);\n            if (knownModel === model) {\n                return; // already cached\n            }\n            // dispose any previously stored dispose listener for this resource\n            const disposeListener = this.mapResourceToDisposeListener.get(resource);\n            if (disposeListener) {\n                disposeListener.dispose();\n            }\n            // store in cache but remove when model gets disposed\n            this.mapResourceToModel.set(resource, model);\n            this.mapResourceToDisposeListener.set(resource, model.onDispose(() => {\n                this.remove(resource);\n                this._onModelDisposed.fire(resource);\n            }));\n        }\n        remove(resource) {\n            this.mapResourceToModel.delete(resource);\n            const disposeListener = this.mapResourceToDisposeListener.get(resource);\n            if (disposeListener) {\n                lifecycle_1.dispose(disposeListener);\n                this.mapResourceToDisposeListener.delete(resource);\n            }\n            const stateChangeListener = this.mapResourceToStateChangeListener.get(resource);\n            if (stateChangeListener) {\n                lifecycle_1.dispose(stateChangeListener);\n                this.mapResourceToStateChangeListener.delete(resource);\n            }\n            const modelContentChangeListener = this.mapResourceToModelContentChangeListener.get(resource);\n            if (modelContentChangeListener) {\n                lifecycle_1.dispose(modelContentChangeListener);\n                this.mapResourceToModelContentChangeListener.delete(resource);\n            }\n        }\n        clear() {\n            // model caches\n            this.mapResourceToModel.clear();\n            this.mapResourceToPendingModelLoaders.clear();\n            // dispose dispose listeners\n            this.mapResourceToDisposeListener.forEach(l => l.dispose());\n            this.mapResourceToDisposeListener.clear();\n            // dispose state change listeners\n            this.mapResourceToStateChangeListener.forEach(l => l.dispose());\n            this.mapResourceToStateChangeListener.clear();\n            // dispose model content change listeners\n            this.mapResourceToModelContentChangeListener.forEach(l => l.dispose());\n            this.mapResourceToModelContentChangeListener.clear();\n        }\n        disposeModel(model) {\n            if (!model) {\n                return; // we need data!\n            }\n            if (model.isDisposed()) {\n                return; // already disposed\n            }\n            if (this.mapResourceToPendingModelLoaders.has(model.getResource())) {\n                return; // not yet loaded\n            }\n            if (model.isDirty()) {\n                return; // not saved\n            }\n            model.dispose();\n        }\n    };\n    TextFileEditorModelManager = __decorate([\n        __param(0, lifecycle_2.ILifecycleService),\n        __param(1, instantiation_1.IInstantiationService)\n    ], TextFileEditorModelManager);\n    exports.TextFileEditorModelManager = TextFileEditorModelManager;\n});\n",null]}