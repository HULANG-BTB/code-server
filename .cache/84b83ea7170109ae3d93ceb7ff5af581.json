{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/files/common/explorerModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/files/common/explorerModel.ts","mtime":1555846338040},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\ndefine([\"require\", \"exports\", \"vs/base/common/uri\", \"vs/base/common/extpath\", \"vs/base/common/path\", \"vs/base/common/resources\", \"vs/base/common/map\", \"vs/base/common/platform\", \"vs/base/common/strings\", \"vs/base/common/arrays\", \"vs/base/common/lifecycle\", \"vs/base/common/decorators\", \"vs/base/common/event\"], function (require, exports, uri_1, extpath_1, path_1, resources, map_1, platform_1, strings_1, arrays_1, lifecycle_1, decorators_1, event_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class ExplorerModel {\n        constructor(contextService) {\n            this.contextService = contextService;\n            this._onDidChangeRoots = new event_1.Emitter();\n            const setRoots = () => this._roots = this.contextService.getWorkspace().folders\n                .map(folder => new ExplorerItem(folder.uri, undefined, true, false, false, folder.name));\n            setRoots();\n            this._listener = this.contextService.onDidChangeWorkspaceFolders(() => {\n                setRoots();\n                this._onDidChangeRoots.fire();\n            });\n        }\n        get roots() {\n            return this._roots;\n        }\n        get onDidChangeRoots() {\n            return this._onDidChangeRoots.event;\n        }\n        /**\n         * Returns an array of child stat from this stat that matches with the provided path.\n         * Starts matching from the first root.\n         * Will return empty array in case the FileStat does not exist.\n         */\n        findAll(resource) {\n            return arrays_1.coalesce(this.roots.map(root => root.find(resource)));\n        }\n        /**\n         * Returns a FileStat that matches the passed resource.\n         * In case multiple FileStat are matching the resource (same folder opened multiple times) returns the FileStat that has the closest root.\n         * Will return undefined in case the FileStat does not exist.\n         */\n        findClosest(resource) {\n            const folder = this.contextService.getWorkspaceFolder(resource);\n            if (folder) {\n                const root = this.roots.filter(r => r.resource.toString() === folder.uri.toString()).pop();\n                if (root) {\n                    return root.find(resource);\n                }\n            }\n            return null;\n        }\n        dispose() {\n            this._listener = lifecycle_1.dispose(this._listener);\n        }\n    }\n    exports.ExplorerModel = ExplorerModel;\n    class ExplorerItem {\n        constructor(resource, _parent, _isDirectory, _isSymbolicLink, _isReadonly, _name = resources.basenameOrAuthority(resource), _mtime) {\n            this.resource = resource;\n            this._parent = _parent;\n            this._isDirectory = _isDirectory;\n            this._isSymbolicLink = _isSymbolicLink;\n            this._isReadonly = _isReadonly;\n            this._name = _name;\n            this._mtime = _mtime;\n            this.forgotChildren = false;\n            this._isDirectoryResolved = false;\n        }\n        get isDirectoryResolved() {\n            return this._isDirectoryResolved;\n        }\n        get isSymbolicLink() {\n            return !!this._isSymbolicLink;\n        }\n        get isDirectory() {\n            return !!this._isDirectory;\n        }\n        get isReadonly() {\n            return !!this._isReadonly;\n        }\n        get mtime() {\n            return this._mtime;\n        }\n        get name() {\n            return this._name;\n        }\n        get parent() {\n            return this._parent;\n        }\n        get root() {\n            if (!this._parent) {\n                return this;\n            }\n            return this._parent.root;\n        }\n        get children() {\n            return new Map();\n        }\n        updateName(value) {\n            // Re-add to parent since the parent has a name map to children and the name might have changed\n            if (this._parent) {\n                this._parent.removeChild(this);\n            }\n            this._name = value;\n            if (this._parent) {\n                this._parent.addChild(this);\n            }\n        }\n        getId() {\n            return this.resource.toString();\n        }\n        get isRoot() {\n            return this === this.root;\n        }\n        static create(raw, parent, resolveTo) {\n            const stat = new ExplorerItem(raw.resource, parent, raw.isDirectory, raw.isSymbolicLink, raw.isReadonly, raw.name, raw.mtime);\n            // Recursively add children if present\n            if (stat.isDirectory) {\n                // isDirectoryResolved is a very important indicator in the stat model that tells if the folder was fully resolved\n                // the folder is fully resolved if either it has a list of children or the client requested this by using the resolveTo\n                // array of resource path to resolve.\n                stat._isDirectoryResolved = !!raw.children || (!!resolveTo && resolveTo.some((r) => {\n                    return resources.isEqualOrParent(r, stat.resource);\n                }));\n                // Recurse into children\n                if (raw.children) {\n                    for (let i = 0, len = raw.children.length; i < len; i++) {\n                        const child = ExplorerItem.create(raw.children[i], stat, resolveTo);\n                        stat.addChild(child);\n                    }\n                }\n            }\n            return stat;\n        }\n        /**\n         * Merges the stat which was resolved from the disk with the local stat by copying over properties\n         * and children. The merge will only consider resolved stat elements to avoid overwriting data which\n         * exists locally.\n         */\n        static mergeLocalWithDisk(disk, local) {\n            if (disk.resource.toString() !== local.resource.toString()) {\n                return; // Merging only supported for stats with the same resource\n            }\n            // Stop merging when a folder is not resolved to avoid loosing local data\n            const mergingDirectories = disk.isDirectory || local.isDirectory;\n            if (mergingDirectories && local._isDirectoryResolved && !disk._isDirectoryResolved) {\n                return;\n            }\n            // Properties\n            local.resource = disk.resource;\n            local.updateName(disk.name);\n            local._isDirectory = disk.isDirectory;\n            local._mtime = disk.mtime;\n            local._isDirectoryResolved = disk._isDirectoryResolved;\n            local._isSymbolicLink = disk.isSymbolicLink;\n            local._isReadonly = disk.isReadonly;\n            local.isError = disk.isError;\n            // Merge Children if resolved\n            if (mergingDirectories && disk._isDirectoryResolved) {\n                // Map resource => stat\n                const oldLocalChildren = new map_1.ResourceMap();\n                local.children.forEach(child => {\n                    oldLocalChildren.set(child.resource, child);\n                });\n                // Clear current children\n                local.children.clear();\n                // Merge received children\n                disk.children.forEach(diskChild => {\n                    const formerLocalChild = oldLocalChildren.get(diskChild.resource);\n                    // Existing child: merge\n                    if (formerLocalChild) {\n                        ExplorerItem.mergeLocalWithDisk(diskChild, formerLocalChild);\n                        local.addChild(formerLocalChild);\n                    }\n                    // New child: add\n                    else {\n                        local.addChild(diskChild);\n                    }\n                });\n            }\n        }\n        /**\n         * Adds a child element to this folder.\n         */\n        addChild(child) {\n            // Inherit some parent properties to child\n            child._parent = this;\n            child.updateResource(false);\n            this.children.set(this.getPlatformAwareName(child.name), child);\n        }\n        getChild(name) {\n            return this.children.get(this.getPlatformAwareName(name));\n        }\n        fetchChildren(fileService, explorerService) {\n            let promise = Promise.resolve(undefined);\n            if (!this._isDirectoryResolved || this.forgotChildren) {\n                this.forgotChildren = false;\n                // Resolve metadata only when the mtime is needed since this can be expensive\n                // Mtime is only used when the sort order is 'modified'\n                const resolveMetadata = explorerService.sortOrder === 'modified';\n                promise = fileService.resolveFile(this.resource, { resolveSingleChildDescendants: true, resolveMetadata }).then(stat => {\n                    const resolved = ExplorerItem.create(stat, this);\n                    ExplorerItem.mergeLocalWithDisk(resolved, this);\n                    this._isDirectoryResolved = true;\n                });\n            }\n            return promise.then(() => {\n                const items = [];\n                this.children.forEach(child => {\n                    items.push(child);\n                });\n                return items;\n            });\n        }\n        /**\n         * Removes a child element from this folder.\n         */\n        removeChild(child) {\n            this.children.delete(this.getPlatformAwareName(child.name));\n        }\n        forgetChildren() {\n            this.children.clear();\n            this.forgotChildren = true;\n            this._isDirectoryResolved = false;\n        }\n        getPlatformAwareName(name) {\n            return (platform_1.isLinux || !name) ? name : name.toLowerCase();\n        }\n        /**\n         * Moves this element under a new parent element.\n         */\n        move(newParent) {\n            if (this._parent) {\n                this._parent.removeChild(this);\n            }\n            newParent.removeChild(this); // make sure to remove any previous version of the file if any\n            newParent.addChild(this);\n            this.updateResource(true);\n        }\n        updateResource(recursive) {\n            if (this._parent) {\n                this.resource = resources.joinPath(this._parent.resource, this.name);\n            }\n            if (recursive) {\n                if (this.isDirectory) {\n                    this.children.forEach(child => {\n                        child.updateResource(true);\n                    });\n                }\n            }\n        }\n        /**\n         * Tells this stat that it was renamed. This requires changes to all children of this stat (if any)\n         * so that the path property can be updated properly.\n         */\n        rename(renamedStat) {\n            // Merge a subset of Properties that can change on rename\n            this.updateName(renamedStat.name);\n            this._mtime = renamedStat.mtime;\n            // Update Paths including children\n            this.updateResource(true);\n        }\n        /**\n         * Returns a child stat from this stat that matches with the provided path.\n         * Will return \"null\" in case the child does not exist.\n         */\n        find(resource) {\n            // Return if path found\n            // For performance reasons try to do the comparison as fast as possible\n            if (resource && this.resource.scheme === resource.scheme && strings_1.equalsIgnoreCase(this.resource.authority, resource.authority) &&\n                (resources.hasToIgnoreCase(resource) ? strings_1.startsWithIgnoreCase(resource.path, this.resource.path) : strings_1.startsWith(resource.path, this.resource.path))) {\n                return this.findByPath(strings_1.rtrim(resource.path, path_1.posix.sep), this.resource.path.length);\n            }\n            return null; //Unable to find\n        }\n        findByPath(path, index) {\n            if (extpath_1.isEqual(strings_1.rtrim(this.resource.path, path_1.posix.sep), path, !platform_1.isLinux)) {\n                return this;\n            }\n            if (this.isDirectory) {\n                // Ignore separtor to more easily deduct the next name to search\n                while (index < path.length && path[index] === path_1.posix.sep) {\n                    index++;\n                }\n                let indexOfNextSep = path.indexOf(path_1.posix.sep, index);\n                if (indexOfNextSep === -1) {\n                    // If there is no separator take the remainder of the path\n                    indexOfNextSep = path.length;\n                }\n                // The name to search is between two separators\n                const name = path.substring(index, indexOfNextSep);\n                const child = this.children.get(this.getPlatformAwareName(name));\n                if (child) {\n                    // We found a child with the given name, search inside it\n                    return child.findByPath(path, indexOfNextSep);\n                }\n            }\n            return null;\n        }\n    }\n    __decorate([\n        decorators_1.memoize\n    ], ExplorerItem.prototype, \"children\", null);\n    exports.ExplorerItem = ExplorerItem;\n    class NewExplorerItem extends ExplorerItem {\n        constructor(parent, isDirectory) {\n            super(uri_1.URI.file(''), parent, isDirectory);\n        }\n    }\n    exports.NewExplorerItem = NewExplorerItem;\n});\n",null]}