{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/smartSelect/bracketSelections.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/smartSelect/bracketSelections.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\", \"vs/base/common/linkedList\"], function (require, exports, position_1, range_1, linkedList_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class BracketSelectionRangeProvider {\n        provideSelectionRanges(model, positions) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const result = [];\n                for (const position of positions) {\n                    const bucket = [];\n                    result.push(bucket);\n                    const ranges = new Map();\n                    yield new Promise(resolve => BracketSelectionRangeProvider._bracketsRightYield(resolve, 0, model, position, ranges));\n                    yield new Promise(resolve => BracketSelectionRangeProvider._bracketsLeftYield(resolve, 0, model, position, ranges, bucket));\n                }\n                return result;\n            });\n        }\n        static _bracketsRightYield(resolve, round, model, pos, ranges) {\n            const counts = new Map();\n            const t1 = Date.now();\n            while (true) {\n                if (round >= BracketSelectionRangeProvider._maxRounds) {\n                    resolve();\n                    break;\n                }\n                if (!pos) {\n                    resolve();\n                    break;\n                }\n                let bracket = model.findNextBracket(pos);\n                if (!bracket) {\n                    resolve();\n                    break;\n                }\n                let d = Date.now() - t1;\n                if (d > BracketSelectionRangeProvider._maxDuration) {\n                    setTimeout(() => BracketSelectionRangeProvider._bracketsRightYield(resolve, round + 1, model, pos, ranges));\n                    break;\n                }\n                const key = bracket.close;\n                if (bracket.isOpen) {\n                    // wait for closing\n                    let val = counts.has(key) ? counts.get(key) : 0;\n                    counts.set(key, val + 1);\n                }\n                else {\n                    // process closing\n                    let val = counts.has(key) ? counts.get(key) : 0;\n                    val -= 1;\n                    counts.set(key, Math.max(0, val));\n                    if (val < 0) {\n                        let list = ranges.get(key);\n                        if (!list) {\n                            list = new linkedList_1.LinkedList();\n                            ranges.set(key, list);\n                        }\n                        list.push(bracket.range);\n                    }\n                }\n                pos = bracket.range.getEndPosition();\n            }\n        }\n        static _bracketsLeftYield(resolve, round, model, pos, ranges, bucket) {\n            const counts = new Map();\n            const t1 = Date.now();\n            while (true) {\n                if (round >= BracketSelectionRangeProvider._maxRounds && ranges.size === 0) {\n                    resolve();\n                    break;\n                }\n                if (!pos) {\n                    resolve();\n                    break;\n                }\n                let bracket = model.findPrevBracket(pos);\n                if (!bracket) {\n                    resolve();\n                    break;\n                }\n                let d = Date.now() - t1;\n                if (d > BracketSelectionRangeProvider._maxDuration) {\n                    setTimeout(() => BracketSelectionRangeProvider._bracketsLeftYield(resolve, round + 1, model, pos, ranges, bucket));\n                    break;\n                }\n                const key = bracket.close;\n                if (!bracket.isOpen) {\n                    // wait for opening\n                    let val = counts.has(key) ? counts.get(key) : 0;\n                    counts.set(key, val + 1);\n                }\n                else {\n                    // opening\n                    let val = counts.has(key) ? counts.get(key) : 0;\n                    val -= 1;\n                    counts.set(key, Math.max(0, val));\n                    if (val < 0) {\n                        let list = ranges.get(key);\n                        if (list) {\n                            let closing = list.shift();\n                            if (list.size === 0) {\n                                ranges.delete(key);\n                            }\n                            const innerBracket = range_1.Range.fromPositions(bracket.range.getEndPosition(), closing.getStartPosition());\n                            const outerBracket = range_1.Range.fromPositions(bracket.range.getStartPosition(), closing.getEndPosition());\n                            bucket.push({ range: innerBracket, kind: 'statement.brackets' });\n                            bucket.push({ range: outerBracket, kind: 'statement.brackets.full' });\n                            BracketSelectionRangeProvider._addBracketLeading(model, outerBracket, bucket);\n                        }\n                    }\n                }\n                pos = bracket.range.getStartPosition();\n            }\n        }\n        static _addBracketLeading(model, bracket, bucket) {\n            if (bracket.startLineNumber === bracket.endLineNumber) {\n                return;\n            }\n            // xxxxxxxx {\n            //\n            // }\n            const startLine = bracket.startLineNumber;\n            const column = model.getLineFirstNonWhitespaceColumn(startLine);\n            if (column !== 0 && column !== bracket.startColumn) {\n                bucket.push({ range: range_1.Range.fromPositions(new position_1.Position(startLine, column), bracket.getEndPosition()), kind: 'statement.brackets.leading' });\n                bucket.push({ range: range_1.Range.fromPositions(new position_1.Position(startLine, 1), bracket.getEndPosition()), kind: 'statement.brackets.leading.full' });\n            }\n            // xxxxxxxx\n            // {\n            //\n            // }\n            const aboveLine = startLine - 1;\n            if (aboveLine > 0) {\n                const column = model.getLineFirstNonWhitespaceColumn(aboveLine);\n                if (column === bracket.startColumn && column !== model.getLineLastNonWhitespaceColumn(aboveLine)) {\n                    bucket.push({ range: range_1.Range.fromPositions(new position_1.Position(aboveLine, column), bracket.getEndPosition()), kind: 'statement.brackets.leading' });\n                    bucket.push({ range: range_1.Range.fromPositions(new position_1.Position(aboveLine, 1), bracket.getEndPosition()), kind: 'statement.brackets.leading.full' });\n                }\n            }\n        }\n    }\n    BracketSelectionRangeProvider._maxDuration = 30;\n    BracketSelectionRangeProvider._maxRounds = 2;\n    exports.BracketSelectionRangeProvider = BracketSelectionRangeProvider;\n});\n",null]}