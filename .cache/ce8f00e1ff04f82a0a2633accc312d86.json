{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/platform/contextkey/common/contextkey.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/contextkey/common/contextkey.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar strings_1 = require(\"vs/base/common/strings\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar ContextKeyExprType;\n(function (ContextKeyExprType) {\n    ContextKeyExprType[ContextKeyExprType[\"Defined\"] = 1] = \"Defined\";\n    ContextKeyExprType[ContextKeyExprType[\"Not\"] = 2] = \"Not\";\n    ContextKeyExprType[ContextKeyExprType[\"Equals\"] = 3] = \"Equals\";\n    ContextKeyExprType[ContextKeyExprType[\"NotEquals\"] = 4] = \"NotEquals\";\n    ContextKeyExprType[ContextKeyExprType[\"And\"] = 5] = \"And\";\n    ContextKeyExprType[ContextKeyExprType[\"Regex\"] = 6] = \"Regex\";\n})(ContextKeyExprType = exports.ContextKeyExprType || (exports.ContextKeyExprType = {}));\nvar ContextKeyExpr = /** @class */ (function () {\n    function ContextKeyExpr() {\n    }\n    ContextKeyExpr.has = function (key) {\n        return new ContextKeyDefinedExpr(key);\n    };\n    ContextKeyExpr.equals = function (key, value) {\n        return new ContextKeyEqualsExpr(key, value);\n    };\n    ContextKeyExpr.notEquals = function (key, value) {\n        return new ContextKeyNotEqualsExpr(key, value);\n    };\n    ContextKeyExpr.regex = function (key, value) {\n        return new ContextKeyRegexExpr(key, value);\n    };\n    ContextKeyExpr.not = function (key) {\n        return new ContextKeyNotExpr(key);\n    };\n    ContextKeyExpr.and = function () {\n        var expr = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            expr[_i] = arguments[_i];\n        }\n        return new ContextKeyAndExpr(expr);\n    };\n    ContextKeyExpr.deserialize = function (serialized, strict) {\n        var _this = this;\n        if (strict === void 0) { strict = false; }\n        if (!serialized) {\n            return undefined;\n        }\n        var pieces = serialized.split('&&');\n        var result = new ContextKeyAndExpr(pieces.map(function (p) { return _this._deserializeOne(p, strict); }));\n        return result.normalize();\n    };\n    ContextKeyExpr._deserializeOne = function (serializedOne, strict) {\n        serializedOne = serializedOne.trim();\n        if (serializedOne.indexOf('!=') >= 0) {\n            var pieces = serializedOne.split('!=');\n            return new ContextKeyNotEqualsExpr(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n        }\n        if (serializedOne.indexOf('==') >= 0) {\n            var pieces = serializedOne.split('==');\n            return new ContextKeyEqualsExpr(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n        }\n        if (serializedOne.indexOf('=~') >= 0) {\n            var pieces = serializedOne.split('=~');\n            return new ContextKeyRegexExpr(pieces[0].trim(), this._deserializeRegexValue(pieces[1], strict));\n        }\n        if (/^\\!\\s*/.test(serializedOne)) {\n            return new ContextKeyNotExpr(serializedOne.substr(1).trim());\n        }\n        return new ContextKeyDefinedExpr(serializedOne);\n    };\n    ContextKeyExpr._deserializeValue = function (serializedValue, strict) {\n        serializedValue = serializedValue.trim();\n        if (serializedValue === 'true') {\n            return true;\n        }\n        if (serializedValue === 'false') {\n            return false;\n        }\n        var m = /^'([^']*)'$/.exec(serializedValue);\n        if (m) {\n            return m[1].trim();\n        }\n        return serializedValue;\n    };\n    ContextKeyExpr._deserializeRegexValue = function (serializedValue, strict) {\n        if (strings_1.isFalsyOrWhitespace(serializedValue)) {\n            if (strict) {\n                throw new Error('missing regexp-value for =~-expression');\n            }\n            else {\n                console.warn('missing regexp-value for =~-expression');\n            }\n            return null;\n        }\n        var start = serializedValue.indexOf('/');\n        var end = serializedValue.lastIndexOf('/');\n        if (start === end || start < 0 /* || to < 0 */) {\n            if (strict) {\n                throw new Error(\"bad regexp-value '\" + serializedValue + \"', missing /-enclosure\");\n            }\n            else {\n                console.warn(\"bad regexp-value '\" + serializedValue + \"', missing /-enclosure\");\n            }\n            return null;\n        }\n        var value = serializedValue.slice(start + 1, end);\n        var caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n        try {\n            return new RegExp(value, caseIgnoreFlag);\n        }\n        catch (e) {\n            if (strict) {\n                throw new Error(\"bad regexp-value '\" + serializedValue + \"', parse error: \" + e);\n            }\n            else {\n                console.warn(\"bad regexp-value '\" + serializedValue + \"', parse error: \" + e);\n            }\n            return null;\n        }\n    };\n    return ContextKeyExpr;\n}());\nexports.ContextKeyExpr = ContextKeyExpr;\nfunction cmp(a, b) {\n    var aType = a.getType();\n    var bType = b.getType();\n    if (aType !== bType) {\n        return aType - bType;\n    }\n    switch (aType) {\n        case ContextKeyExprType.Defined:\n            return a.cmp(b);\n        case ContextKeyExprType.Not:\n            return a.cmp(b);\n        case ContextKeyExprType.Equals:\n            return a.cmp(b);\n        case ContextKeyExprType.NotEquals:\n            return a.cmp(b);\n        case ContextKeyExprType.Regex:\n            return a.cmp(b);\n        default:\n            throw new Error('Unknown ContextKeyExpr!');\n    }\n}\nvar ContextKeyDefinedExpr = /** @class */ (function () {\n    function ContextKeyDefinedExpr(key) {\n        this.key = key;\n    }\n    ContextKeyDefinedExpr.prototype.getType = function () {\n        return ContextKeyExprType.Defined;\n    };\n    ContextKeyDefinedExpr.prototype.cmp = function (other) {\n        if (this.key < other.key) {\n            return -1;\n        }\n        if (this.key > other.key) {\n            return 1;\n        }\n        return 0;\n    };\n    ContextKeyDefinedExpr.prototype.equals = function (other) {\n        if (other instanceof ContextKeyDefinedExpr) {\n            return (this.key === other.key);\n        }\n        return false;\n    };\n    ContextKeyDefinedExpr.prototype.evaluate = function (context) {\n        return (!!context.getValue(this.key));\n    };\n    ContextKeyDefinedExpr.prototype.normalize = function () {\n        return this;\n    };\n    ContextKeyDefinedExpr.prototype.serialize = function () {\n        return this.key;\n    };\n    ContextKeyDefinedExpr.prototype.keys = function () {\n        return [this.key];\n    };\n    ContextKeyDefinedExpr.prototype.map = function (mapFnc) {\n        return mapFnc.mapDefined(this.key);\n    };\n    return ContextKeyDefinedExpr;\n}());\nexports.ContextKeyDefinedExpr = ContextKeyDefinedExpr;\nvar ContextKeyEqualsExpr = /** @class */ (function () {\n    function ContextKeyEqualsExpr(key, value) {\n        this.key = key;\n        this.value = value;\n    }\n    ContextKeyEqualsExpr.prototype.getType = function () {\n        return ContextKeyExprType.Equals;\n    };\n    ContextKeyEqualsExpr.prototype.cmp = function (other) {\n        if (this.key < other.key) {\n            return -1;\n        }\n        if (this.key > other.key) {\n            return 1;\n        }\n        if (this.value < other.value) {\n            return -1;\n        }\n        if (this.value > other.value) {\n            return 1;\n        }\n        return 0;\n    };\n    ContextKeyEqualsExpr.prototype.equals = function (other) {\n        if (other instanceof ContextKeyEqualsExpr) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    };\n    ContextKeyEqualsExpr.prototype.evaluate = function (context) {\n        /* tslint:disable:triple-equals */\n        // Intentional ==\n        return (context.getValue(this.key) == this.value);\n        /* tslint:enable:triple-equals */\n    };\n    ContextKeyEqualsExpr.prototype.normalize = function () {\n        if (typeof this.value === 'boolean') {\n            if (this.value) {\n                return new ContextKeyDefinedExpr(this.key);\n            }\n            return new ContextKeyNotExpr(this.key);\n        }\n        return this;\n    };\n    ContextKeyEqualsExpr.prototype.serialize = function () {\n        if (typeof this.value === 'boolean') {\n            return this.normalize().serialize();\n        }\n        return this.key + ' == \\'' + this.value + '\\'';\n    };\n    ContextKeyEqualsExpr.prototype.keys = function () {\n        return [this.key];\n    };\n    ContextKeyEqualsExpr.prototype.map = function (mapFnc) {\n        return mapFnc.mapEquals(this.key, this.value);\n    };\n    return ContextKeyEqualsExpr;\n}());\nexports.ContextKeyEqualsExpr = ContextKeyEqualsExpr;\nvar ContextKeyNotEqualsExpr = /** @class */ (function () {\n    function ContextKeyNotEqualsExpr(key, value) {\n        this.key = key;\n        this.value = value;\n    }\n    ContextKeyNotEqualsExpr.prototype.getType = function () {\n        return ContextKeyExprType.NotEquals;\n    };\n    ContextKeyNotEqualsExpr.prototype.cmp = function (other) {\n        if (this.key < other.key) {\n            return -1;\n        }\n        if (this.key > other.key) {\n            return 1;\n        }\n        if (this.value < other.value) {\n            return -1;\n        }\n        if (this.value > other.value) {\n            return 1;\n        }\n        return 0;\n    };\n    ContextKeyNotEqualsExpr.prototype.equals = function (other) {\n        if (other instanceof ContextKeyNotEqualsExpr) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    };\n    ContextKeyNotEqualsExpr.prototype.evaluate = function (context) {\n        /* tslint:disable:triple-equals */\n        // Intentional !=\n        return (context.getValue(this.key) != this.value);\n        /* tslint:enable:triple-equals */\n    };\n    ContextKeyNotEqualsExpr.prototype.normalize = function () {\n        if (typeof this.value === 'boolean') {\n            if (this.value) {\n                return new ContextKeyNotExpr(this.key);\n            }\n            return new ContextKeyDefinedExpr(this.key);\n        }\n        return this;\n    };\n    ContextKeyNotEqualsExpr.prototype.serialize = function () {\n        if (typeof this.value === 'boolean') {\n            return this.normalize().serialize();\n        }\n        return this.key + ' != \\'' + this.value + '\\'';\n    };\n    ContextKeyNotEqualsExpr.prototype.keys = function () {\n        return [this.key];\n    };\n    ContextKeyNotEqualsExpr.prototype.map = function (mapFnc) {\n        return mapFnc.mapNotEquals(this.key, this.value);\n    };\n    return ContextKeyNotEqualsExpr;\n}());\nexports.ContextKeyNotEqualsExpr = ContextKeyNotEqualsExpr;\nvar ContextKeyNotExpr = /** @class */ (function () {\n    function ContextKeyNotExpr(key) {\n        this.key = key;\n    }\n    ContextKeyNotExpr.prototype.getType = function () {\n        return ContextKeyExprType.Not;\n    };\n    ContextKeyNotExpr.prototype.cmp = function (other) {\n        if (this.key < other.key) {\n            return -1;\n        }\n        if (this.key > other.key) {\n            return 1;\n        }\n        return 0;\n    };\n    ContextKeyNotExpr.prototype.equals = function (other) {\n        if (other instanceof ContextKeyNotExpr) {\n            return (this.key === other.key);\n        }\n        return false;\n    };\n    ContextKeyNotExpr.prototype.evaluate = function (context) {\n        return (!context.getValue(this.key));\n    };\n    ContextKeyNotExpr.prototype.normalize = function () {\n        return this;\n    };\n    ContextKeyNotExpr.prototype.serialize = function () {\n        return '!' + this.key;\n    };\n    ContextKeyNotExpr.prototype.keys = function () {\n        return [this.key];\n    };\n    ContextKeyNotExpr.prototype.map = function (mapFnc) {\n        return mapFnc.mapNot(this.key);\n    };\n    return ContextKeyNotExpr;\n}());\nexports.ContextKeyNotExpr = ContextKeyNotExpr;\nvar ContextKeyRegexExpr = /** @class */ (function () {\n    function ContextKeyRegexExpr(key, regexp) {\n        this.key = key;\n        this.regexp = regexp;\n        //\n    }\n    ContextKeyRegexExpr.prototype.getType = function () {\n        return ContextKeyExprType.Regex;\n    };\n    ContextKeyRegexExpr.prototype.cmp = function (other) {\n        if (this.key < other.key) {\n            return -1;\n        }\n        if (this.key > other.key) {\n            return 1;\n        }\n        var thisSource = this.regexp ? this.regexp.source : '';\n        var otherSource = other.regexp ? other.regexp.source : '';\n        if (thisSource < otherSource) {\n            return -1;\n        }\n        if (thisSource > otherSource) {\n            return 1;\n        }\n        return 0;\n    };\n    ContextKeyRegexExpr.prototype.equals = function (other) {\n        if (other instanceof ContextKeyRegexExpr) {\n            var thisSource = this.regexp ? this.regexp.source : '';\n            var otherSource = other.regexp ? other.regexp.source : '';\n            return (this.key === other.key && thisSource === otherSource);\n        }\n        return false;\n    };\n    ContextKeyRegexExpr.prototype.evaluate = function (context) {\n        var value = context.getValue(this.key);\n        return this.regexp ? this.regexp.test(value) : false;\n    };\n    ContextKeyRegexExpr.prototype.normalize = function () {\n        return this;\n    };\n    ContextKeyRegexExpr.prototype.serialize = function () {\n        var value = this.regexp\n            ? \"/\" + this.regexp.source + \"/\" + (this.regexp.ignoreCase ? 'i' : '')\n            : '/invalid/';\n        return this.key + \" =~ \" + value;\n    };\n    ContextKeyRegexExpr.prototype.keys = function () {\n        return [this.key];\n    };\n    ContextKeyRegexExpr.prototype.map = function (mapFnc) {\n        return mapFnc.mapRegex(this.key, this.regexp);\n    };\n    return ContextKeyRegexExpr;\n}());\nexports.ContextKeyRegexExpr = ContextKeyRegexExpr;\nvar ContextKeyAndExpr = /** @class */ (function () {\n    function ContextKeyAndExpr(expr) {\n        this.expr = ContextKeyAndExpr._normalizeArr(expr);\n    }\n    ContextKeyAndExpr.prototype.getType = function () {\n        return ContextKeyExprType.And;\n    };\n    ContextKeyAndExpr.prototype.equals = function (other) {\n        if (other instanceof ContextKeyAndExpr) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (var i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    };\n    ContextKeyAndExpr.prototype.evaluate = function (context) {\n        for (var i = 0, len = this.expr.length; i < len; i++) {\n            if (!this.expr[i].evaluate(context)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    ContextKeyAndExpr._normalizeArr = function (arr) {\n        var expr = [];\n        if (arr) {\n            for (var i = 0, len = arr.length; i < len; i++) {\n                var e = arr[i];\n                if (!e) {\n                    continue;\n                }\n                e = e.normalize();\n                if (!e) {\n                    continue;\n                }\n                if (e instanceof ContextKeyAndExpr) {\n                    expr = expr.concat(e.expr);\n                    continue;\n                }\n                expr.push(e);\n            }\n            expr.sort(cmp);\n        }\n        return expr;\n    };\n    ContextKeyAndExpr.prototype.normalize = function () {\n        if (this.expr.length === 0) {\n            return undefined;\n        }\n        if (this.expr.length === 1) {\n            return this.expr[0];\n        }\n        return this;\n    };\n    ContextKeyAndExpr.prototype.serialize = function () {\n        if (this.expr.length === 0) {\n            return '';\n        }\n        if (this.expr.length === 1) {\n            var normalized = this.normalize();\n            if (!normalized) {\n                return '';\n            }\n            return normalized.serialize();\n        }\n        return this.expr.map(function (e) { return e.serialize(); }).join(' && ');\n    };\n    ContextKeyAndExpr.prototype.keys = function () {\n        var result = [];\n        for (var _i = 0, _a = this.expr; _i < _a.length; _i++) {\n            var expr = _a[_i];\n            result.push.apply(result, expr.keys());\n        }\n        return result;\n    };\n    ContextKeyAndExpr.prototype.map = function (mapFnc) {\n        return new ContextKeyAndExpr(this.expr.map(function (expr) { return expr.map(mapFnc); }));\n    };\n    return ContextKeyAndExpr;\n}());\nexports.ContextKeyAndExpr = ContextKeyAndExpr;\nvar RawContextKey = /** @class */ (function (_super) {\n    tslib_1.__extends(RawContextKey, _super);\n    function RawContextKey(key, defaultValue) {\n        var _this = _super.call(this, key) || this;\n        _this._defaultValue = defaultValue;\n        return _this;\n    }\n    RawContextKey.prototype.bindTo = function (target) {\n        return target.createKey(this.key, this._defaultValue);\n    };\n    RawContextKey.prototype.getValue = function (target) {\n        return target.getContextKeyValue(this.key);\n    };\n    RawContextKey.prototype.toNegated = function () {\n        return ContextKeyExpr.not(this.key);\n    };\n    RawContextKey.prototype.isEqualTo = function (value) {\n        return ContextKeyExpr.equals(this.key, value);\n    };\n    RawContextKey.prototype.notEqualsTo = function (value) {\n        return ContextKeyExpr.notEquals(this.key, value);\n    };\n    return RawContextKey;\n}(ContextKeyDefinedExpr));\nexports.RawContextKey = RawContextKey;\nexports.IContextKeyService = instantiation_1.createDecorator('contextKeyService');\nexports.SET_CONTEXT_COMMAND_ID = 'setContext';\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/platform/contextkey/common/contextkey.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/platform/contextkey/common/contextkey.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { isFalsyOrWhitespace } from 'vs/base/common/strings';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\n\nexport const enum ContextKeyExprType {\n\tDefined = 1,\n\tNot = 2,\n\tEquals = 3,\n\tNotEquals = 4,\n\tAnd = 5,\n\tRegex = 6\n}\n\nexport interface IContextKeyExprMapper {\n\tmapDefined(key: string): ContextKeyDefinedExpr;\n\tmapNot(key: string): ContextKeyNotExpr;\n\tmapEquals(key: string, value: any): ContextKeyEqualsExpr;\n\tmapNotEquals(key: string, value: any): ContextKeyNotEqualsExpr;\n\tmapRegex(key: string, regexp: RegExp | null): ContextKeyRegexExpr;\n}\n\nexport abstract class ContextKeyExpr {\n\n\tpublic static has(key: string): ContextKeyExpr {\n\t\treturn new ContextKeyDefinedExpr(key);\n\t}\n\n\tpublic static equals(key: string, value: any): ContextKeyExpr {\n\t\treturn new ContextKeyEqualsExpr(key, value);\n\t}\n\n\tpublic static notEquals(key: string, value: any): ContextKeyExpr {\n\t\treturn new ContextKeyNotEqualsExpr(key, value);\n\t}\n\n\tpublic static regex(key: string, value: RegExp): ContextKeyExpr {\n\t\treturn new ContextKeyRegexExpr(key, value);\n\t}\n\n\tpublic static not(key: string): ContextKeyExpr {\n\t\treturn new ContextKeyNotExpr(key);\n\t}\n\n\tpublic static and(...expr: Array<ContextKeyExpr | undefined | null>): ContextKeyExpr {\n\t\treturn new ContextKeyAndExpr(expr);\n\t}\n\n\tpublic static deserialize(serialized: string | null | undefined, strict: boolean = false): ContextKeyExpr | undefined {\n\t\tif (!serialized) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet pieces = serialized.split('&&');\n\t\tlet result = new ContextKeyAndExpr(pieces.map(p => this._deserializeOne(p, strict)));\n\t\treturn result.normalize();\n\t}\n\n\tprivate static _deserializeOne(serializedOne: string, strict: boolean): ContextKeyExpr {\n\t\tserializedOne = serializedOne.trim();\n\n\t\tif (serializedOne.indexOf('!=') >= 0) {\n\t\t\tlet pieces = serializedOne.split('!=');\n\t\t\treturn new ContextKeyNotEqualsExpr(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n\t\t}\n\n\t\tif (serializedOne.indexOf('==') >= 0) {\n\t\t\tlet pieces = serializedOne.split('==');\n\t\t\treturn new ContextKeyEqualsExpr(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n\t\t}\n\n\t\tif (serializedOne.indexOf('=~') >= 0) {\n\t\t\tlet pieces = serializedOne.split('=~');\n\t\t\treturn new ContextKeyRegexExpr(pieces[0].trim(), this._deserializeRegexValue(pieces[1], strict));\n\t\t}\n\n\t\tif (/^\\!\\s*/.test(serializedOne)) {\n\t\t\treturn new ContextKeyNotExpr(serializedOne.substr(1).trim());\n\t\t}\n\n\t\treturn new ContextKeyDefinedExpr(serializedOne);\n\t}\n\n\tprivate static _deserializeValue(serializedValue: string, strict: boolean): any {\n\t\tserializedValue = serializedValue.trim();\n\n\t\tif (serializedValue === 'true') {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (serializedValue === 'false') {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet m = /^'([^']*)'$/.exec(serializedValue);\n\t\tif (m) {\n\t\t\treturn m[1].trim();\n\t\t}\n\n\t\treturn serializedValue;\n\t}\n\n\tprivate static _deserializeRegexValue(serializedValue: string, strict: boolean): RegExp | null {\n\n\t\tif (isFalsyOrWhitespace(serializedValue)) {\n\t\t\tif (strict) {\n\t\t\t\tthrow new Error('missing regexp-value for =~-expression');\n\t\t\t} else {\n\t\t\t\tconsole.warn('missing regexp-value for =~-expression');\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tlet start = serializedValue.indexOf('/');\n\t\tlet end = serializedValue.lastIndexOf('/');\n\t\tif (start === end || start < 0 /* || to < 0 */) {\n\t\t\tif (strict) {\n\t\t\t\tthrow new Error(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n\t\t\t} else {\n\t\t\t\tconsole.warn(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tlet value = serializedValue.slice(start + 1, end);\n\t\tlet caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n\t\ttry {\n\t\t\treturn new RegExp(value, caseIgnoreFlag);\n\t\t} catch (e) {\n\t\t\tif (strict) {\n\t\t\t\tthrow new Error(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n\t\t\t} else {\n\t\t\t\tconsole.warn(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic abstract getType(): ContextKeyExprType;\n\tpublic abstract equals(other: ContextKeyExpr): boolean;\n\tpublic abstract evaluate(context: IContext): boolean;\n\tpublic abstract normalize(): ContextKeyExpr | undefined;\n\tpublic abstract serialize(): string;\n\tpublic abstract keys(): string[];\n\tpublic abstract map(mapFnc: IContextKeyExprMapper): ContextKeyExpr;\n}\n\nfunction cmp(a: ContextKeyExpr, b: ContextKeyExpr): number {\n\tlet aType = a.getType();\n\tlet bType = b.getType();\n\tif (aType !== bType) {\n\t\treturn aType - bType;\n\t}\n\tswitch (aType) {\n\t\tcase ContextKeyExprType.Defined:\n\t\t\treturn (<ContextKeyDefinedExpr>a).cmp(<ContextKeyDefinedExpr>b);\n\t\tcase ContextKeyExprType.Not:\n\t\t\treturn (<ContextKeyNotExpr>a).cmp(<ContextKeyNotExpr>b);\n\t\tcase ContextKeyExprType.Equals:\n\t\t\treturn (<ContextKeyEqualsExpr>a).cmp(<ContextKeyEqualsExpr>b);\n\t\tcase ContextKeyExprType.NotEquals:\n\t\t\treturn (<ContextKeyNotEqualsExpr>a).cmp(<ContextKeyNotEqualsExpr>b);\n\t\tcase ContextKeyExprType.Regex:\n\t\t\treturn (<ContextKeyRegexExpr>a).cmp(<ContextKeyRegexExpr>b);\n\t\tdefault:\n\t\t\tthrow new Error('Unknown ContextKeyExpr!');\n\t}\n}\n\nexport class ContextKeyDefinedExpr implements ContextKeyExpr {\n\tconstructor(protected key: string) {\n\t}\n\n\tpublic getType(): ContextKeyExprType {\n\t\treturn ContextKeyExprType.Defined;\n\t}\n\n\tpublic cmp(other: ContextKeyDefinedExpr): number {\n\t\tif (this.key < other.key) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.key > other.key) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpr): boolean {\n\t\tif (other instanceof ContextKeyDefinedExpr) {\n\t\t\treturn (this.key === other.key);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn (!!context.getValue(this.key));\n\t}\n\n\tpublic normalize(): ContextKeyExpr {\n\t\treturn this;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn this.key;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpr {\n\t\treturn mapFnc.mapDefined(this.key);\n\t}\n}\n\nexport class ContextKeyEqualsExpr implements ContextKeyExpr {\n\tconstructor(private readonly key: string, private readonly value: any) {\n\t}\n\n\tpublic getType(): ContextKeyExprType {\n\t\treturn ContextKeyExprType.Equals;\n\t}\n\n\tpublic cmp(other: ContextKeyEqualsExpr): number {\n\t\tif (this.key < other.key) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.key > other.key) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (this.value < other.value) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.value > other.value) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpr): boolean {\n\t\tif (other instanceof ContextKeyEqualsExpr) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\t/* tslint:disable:triple-equals */\n\t\t// Intentional ==\n\t\treturn (context.getValue(this.key) == this.value);\n\t\t/* tslint:enable:triple-equals */\n\t}\n\n\tpublic normalize(): ContextKeyExpr {\n\t\tif (typeof this.value === 'boolean') {\n\t\t\tif (this.value) {\n\t\t\t\treturn new ContextKeyDefinedExpr(this.key);\n\t\t\t}\n\t\t\treturn new ContextKeyNotExpr(this.key);\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic serialize(): string {\n\t\tif (typeof this.value === 'boolean') {\n\t\t\treturn this.normalize().serialize();\n\t\t}\n\n\t\treturn this.key + ' == \\'' + this.value + '\\'';\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpr {\n\t\treturn mapFnc.mapEquals(this.key, this.value);\n\t}\n}\n\nexport class ContextKeyNotEqualsExpr implements ContextKeyExpr {\n\tconstructor(private key: string, private value: any) {\n\t}\n\n\tpublic getType(): ContextKeyExprType {\n\t\treturn ContextKeyExprType.NotEquals;\n\t}\n\n\tpublic cmp(other: ContextKeyNotEqualsExpr): number {\n\t\tif (this.key < other.key) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.key > other.key) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (this.value < other.value) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.value > other.value) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpr): boolean {\n\t\tif (other instanceof ContextKeyNotEqualsExpr) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\t/* tslint:disable:triple-equals */\n\t\t// Intentional !=\n\t\treturn (context.getValue(this.key) != this.value);\n\t\t/* tslint:enable:triple-equals */\n\t}\n\n\tpublic normalize(): ContextKeyExpr {\n\t\tif (typeof this.value === 'boolean') {\n\t\t\tif (this.value) {\n\t\t\t\treturn new ContextKeyNotExpr(this.key);\n\t\t\t}\n\t\t\treturn new ContextKeyDefinedExpr(this.key);\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic serialize(): string {\n\t\tif (typeof this.value === 'boolean') {\n\t\t\treturn this.normalize().serialize();\n\t\t}\n\n\t\treturn this.key + ' != \\'' + this.value + '\\'';\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpr {\n\t\treturn mapFnc.mapNotEquals(this.key, this.value);\n\t}\n}\n\nexport class ContextKeyNotExpr implements ContextKeyExpr {\n\tconstructor(private key: string) {\n\t}\n\n\tpublic getType(): ContextKeyExprType {\n\t\treturn ContextKeyExprType.Not;\n\t}\n\n\tpublic cmp(other: ContextKeyNotExpr): number {\n\t\tif (this.key < other.key) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.key > other.key) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpr): boolean {\n\t\tif (other instanceof ContextKeyNotExpr) {\n\t\t\treturn (this.key === other.key);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn (!context.getValue(this.key));\n\t}\n\n\tpublic normalize(): ContextKeyExpr {\n\t\treturn this;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn '!' + this.key;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpr {\n\t\treturn mapFnc.mapNot(this.key);\n\t}\n}\n\nexport class ContextKeyRegexExpr implements ContextKeyExpr {\n\n\tconstructor(private key: string, private regexp: RegExp | null) {\n\t\t//\n\t}\n\n\tpublic getType(): ContextKeyExprType {\n\t\treturn ContextKeyExprType.Regex;\n\t}\n\n\tpublic cmp(other: ContextKeyRegexExpr): number {\n\t\tif (this.key < other.key) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.key > other.key) {\n\t\t\treturn 1;\n\t\t}\n\t\tconst thisSource = this.regexp ? this.regexp.source : '';\n\t\tconst otherSource = other.regexp ? other.regexp.source : '';\n\t\tif (thisSource < otherSource) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (thisSource > otherSource) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpr): boolean {\n\t\tif (other instanceof ContextKeyRegexExpr) {\n\t\t\tconst thisSource = this.regexp ? this.regexp.source : '';\n\t\t\tconst otherSource = other.regexp ? other.regexp.source : '';\n\t\t\treturn (this.key === other.key && thisSource === otherSource);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tlet value = context.getValue<any>(this.key);\n\t\treturn this.regexp ? this.regexp.test(value) : false;\n\t}\n\n\tpublic normalize(): ContextKeyExpr {\n\t\treturn this;\n\t}\n\n\tpublic serialize(): string {\n\t\tconst value = this.regexp\n\t\t\t? `/${this.regexp.source}/${this.regexp.ignoreCase ? 'i' : ''}`\n\t\t\t: '/invalid/';\n\t\treturn `${this.key} =~ ${value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpr {\n\t\treturn mapFnc.mapRegex(this.key, this.regexp);\n\t}\n}\n\nexport class ContextKeyAndExpr implements ContextKeyExpr {\n\tpublic readonly expr: ContextKeyExpr[];\n\n\tconstructor(expr: Array<ContextKeyExpr | null | undefined>) {\n\t\tthis.expr = ContextKeyAndExpr._normalizeArr(expr);\n\t}\n\n\tpublic getType(): ContextKeyExprType {\n\t\treturn ContextKeyExprType.And;\n\t}\n\n\tpublic equals(other: ContextKeyExpr): boolean {\n\t\tif (other instanceof ContextKeyAndExpr) {\n\t\t\tif (this.expr.length !== other.expr.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\t\tif (!this.expr[i].equals(other.expr[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tif (!this.expr[i].evaluate(context)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static _normalizeArr(arr: Array<ContextKeyExpr | null | undefined>): ContextKeyExpr[] {\n\t\tlet expr: ContextKeyExpr[] = [];\n\n\t\tif (arr) {\n\t\t\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\t\t\tlet e: ContextKeyExpr | null | undefined = arr[i];\n\t\t\t\tif (!e) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\te = e.normalize();\n\t\t\t\tif (!e) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (e instanceof ContextKeyAndExpr) {\n\t\t\t\t\texpr = expr.concat(e.expr);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\texpr.push(e);\n\t\t\t}\n\n\t\t\texpr.sort(cmp);\n\t\t}\n\n\t\treturn expr;\n\t}\n\n\tpublic normalize(): ContextKeyExpr | undefined {\n\t\tif (this.expr.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (this.expr.length === 1) {\n\t\t\treturn this.expr[0];\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tpublic serialize(): string {\n\t\tif (this.expr.length === 0) {\n\t\t\treturn '';\n\t\t}\n\t\tif (this.expr.length === 1) {\n\t\t\tconst normalized = this.normalize();\n\t\t\tif (!normalized) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\treturn normalized.serialize();\n\t\t}\n\t\treturn this.expr.map(e => e.serialize()).join(' && ');\n\t}\n\n\tpublic keys(): string[] {\n\t\tconst result: string[] = [];\n\t\tfor (let expr of this.expr) {\n\t\t\tresult.push(...expr.keys());\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpr {\n\t\treturn new ContextKeyAndExpr(this.expr.map(expr => expr.map(mapFnc)));\n\t}\n}\n\nexport class RawContextKey<T> extends ContextKeyDefinedExpr {\n\n\tprivate _defaultValue: T | undefined;\n\n\tconstructor(key: string, defaultValue: T | undefined) {\n\t\tsuper(key);\n\t\tthis._defaultValue = defaultValue;\n\t}\n\n\tpublic bindTo(target: IContextKeyService): IContextKey<T> {\n\t\treturn target.createKey(this.key, this._defaultValue);\n\t}\n\n\tpublic getValue(target: IContextKeyService): T | undefined {\n\t\treturn target.getContextKeyValue<T>(this.key);\n\t}\n\n\tpublic toNegated(): ContextKeyExpr {\n\t\treturn ContextKeyExpr.not(this.key);\n\t}\n\n\tpublic isEqualTo(value: string): ContextKeyExpr {\n\t\treturn ContextKeyExpr.equals(this.key, value);\n\t}\n\n\tpublic notEqualsTo(value: string): ContextKeyExpr {\n\t\treturn ContextKeyExpr.notEquals(this.key, value);\n\t}\n}\n\nexport interface IContext {\n\tgetValue<T>(key: string): T | undefined;\n}\n\nexport interface IContextKey<T> {\n\tset(value: T): void;\n\treset(): void;\n\tget(): T | undefined;\n}\n\nexport interface IContextKeyServiceTarget {\n\tparentElement: IContextKeyServiceTarget | null;\n\tsetAttribute(attr: string, value: string): void;\n\tremoveAttribute(attr: string): void;\n\thasAttribute(attr: string): boolean;\n\tgetAttribute(attr: string): string | null;\n}\n\nexport const IContextKeyService = createDecorator<IContextKeyService>('contextKeyService');\n\nexport interface IReadableSet<T> {\n\thas(value: T): boolean;\n}\n\nexport interface IContextKeyChangeEvent {\n\taffectsSome(keys: IReadableSet<string>): boolean;\n}\n\nexport interface IContextKeyService {\n\t_serviceBrand: any;\n\tdispose(): void;\n\n\tonDidChangeContext: Event<IContextKeyChangeEvent>;\n\tcreateKey<T>(key: string, defaultValue: T | undefined): IContextKey<T>;\n\tcontextMatchesRules(rules: ContextKeyExpr | undefined): boolean;\n\tgetContextKeyValue<T>(key: string): T | undefined;\n\n\tcreateScoped(target?: IContextKeyServiceTarget): IContextKeyService;\n\tgetContext(target: IContextKeyServiceTarget | null): IContext;\n}\n\nexport const SET_CONTEXT_COMMAND_ID = 'setContext';\n"]}]}