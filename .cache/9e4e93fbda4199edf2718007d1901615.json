{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/common/terminalEnvironment.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/common/terminalEnvironment.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/path\", \"vs/base/common/platform\"], function (require, exports, path, platform) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * This module contains utility functions related to the environment, cwd and paths.\n     */\n    function mergeEnvironments(parent, other) {\n        if (!other) {\n            return;\n        }\n        // On Windows apply the new values ignoring case, while still retaining\n        // the case of the original key.\n        if (platform.isWindows) {\n            for (const configKey in other) {\n                let actualKey = configKey;\n                for (const envKey in parent) {\n                    if (configKey.toLowerCase() === envKey.toLowerCase()) {\n                        actualKey = envKey;\n                        break;\n                    }\n                }\n                const value = other[configKey];\n                _mergeEnvironmentValue(parent, actualKey, value);\n            }\n        }\n        else {\n            Object.keys(other).forEach((key) => {\n                const value = other[key];\n                _mergeEnvironmentValue(parent, key, value);\n            });\n        }\n    }\n    exports.mergeEnvironments = mergeEnvironments;\n    function _mergeEnvironmentValue(env, key, value) {\n        if (typeof value === 'string') {\n            env[key] = value;\n        }\n        else {\n            delete env[key];\n        }\n    }\n    function addTerminalEnvironmentKeys(env, version, locale, setLocaleVariables) {\n        env['TERM_PROGRAM'] = 'vscode';\n        env['TERM_PROGRAM_VERSION'] = version ? version : null;\n        if (setLocaleVariables) {\n            env['LANG'] = _getLangEnvVariable(locale);\n        }\n    }\n    exports.addTerminalEnvironmentKeys = addTerminalEnvironmentKeys;\n    function resolveConfigurationVariables(configurationResolverService, env, lastActiveWorkspaceRoot) {\n        Object.keys(env).forEach((key) => {\n            const value = env[key];\n            if (typeof value === 'string' && lastActiveWorkspaceRoot !== null) {\n                env[key] = configurationResolverService.resolve(lastActiveWorkspaceRoot, value);\n            }\n        });\n        return env;\n    }\n    exports.resolveConfigurationVariables = resolveConfigurationVariables;\n    function _getLangEnvVariable(locale) {\n        const parts = locale ? locale.split('-') : [];\n        const n = parts.length;\n        if (n === 0) {\n            // Fallback to en_US to prevent possible encoding issues.\n            return 'en_US.UTF-8';\n        }\n        if (n === 1) {\n            // app.getLocale can return just a language without a variant, fill in the variant for\n            // supported languages as many shells expect a 2-part locale.\n            const languageVariants = {\n                de: 'DE',\n                en: 'US',\n                es: 'ES',\n                fi: 'FI',\n                fr: 'FR',\n                it: 'IT',\n                ja: 'JP',\n                ko: 'KR',\n                pl: 'PL',\n                ru: 'RU',\n                zh: 'CN'\n            };\n            if (parts[0] in languageVariants) {\n                parts.push(languageVariants[parts[0]]);\n            }\n        }\n        else {\n            // Ensure the variant is uppercase\n            parts[1] = parts[1].toUpperCase();\n        }\n        return parts.join('_') + '.UTF-8';\n    }\n    function getCwd(shell, userHome, root, customCwd) {\n        if (shell.cwd) {\n            return (typeof shell.cwd === 'object') ? shell.cwd.fsPath : shell.cwd;\n        }\n        let cwd;\n        // TODO: Handle non-existent customCwd\n        if (!shell.ignoreConfigurationCwd && customCwd) {\n            if (path.isAbsolute(customCwd)) {\n                cwd = customCwd;\n            }\n            else if (root) {\n                cwd = path.join(root.fsPath, customCwd);\n            }\n        }\n        // If there was no custom cwd or it was relative with no workspace\n        if (!cwd) {\n            cwd = root ? root.fsPath : userHome;\n        }\n        return _sanitizeCwd(cwd);\n    }\n    exports.getCwd = getCwd;\n    function _sanitizeCwd(cwd) {\n        // Make the drive letter uppercase on Windows (see #9448)\n        if (platform.platform === platform.Platform.Windows && cwd && cwd[1] === ':') {\n            return cwd[0].toUpperCase() + cwd.substr(1);\n        }\n        return cwd;\n    }\n    function escapeNonWindowsPath(path) {\n        let newPath = path;\n        if (newPath.indexOf('\\\\') !== 0) {\n            newPath = newPath.replace(/\\\\/g, '\\\\\\\\');\n        }\n        if (!newPath && (newPath.indexOf('\"') !== -1)) {\n            newPath = '\\'' + newPath + '\\'';\n        }\n        else if (newPath.indexOf(' ') !== -1) {\n            newPath = newPath.replace(/ /g, '\\\\ ');\n        }\n        return newPath;\n    }\n    exports.escapeNonWindowsPath = escapeNonWindowsPath;\n});\n",null]}