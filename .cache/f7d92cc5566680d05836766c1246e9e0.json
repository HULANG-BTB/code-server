{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/buffer.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/buffer.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const hasBuffer = (typeof Buffer !== 'undefined');\n    class VSBuffer {\n        static alloc(byteLength) {\n            if (hasBuffer) {\n                return new VSBuffer(Buffer.allocUnsafe(byteLength));\n            }\n            else {\n                return new VSBuffer(new Uint8Array(byteLength));\n            }\n        }\n        static wrap(actual) {\n            return new VSBuffer(actual);\n        }\n        static fromString(source) {\n            return new VSBuffer(Buffer.from(source));\n        }\n        static concat(buffers, totalLength) {\n            if (typeof totalLength === 'undefined') {\n                totalLength = 0;\n                for (let i = 0, len = buffers.length; i < len; i++) {\n                    totalLength += buffers[i].byteLength;\n                }\n            }\n            const ret = VSBuffer.alloc(totalLength);\n            let offset = 0;\n            for (let i = 0, len = buffers.length; i < len; i++) {\n                const element = buffers[i];\n                ret.set(element, offset);\n                offset += element.byteLength;\n            }\n            return ret;\n        }\n        constructor(buffer) {\n            this.buffer = buffer;\n            this.byteLength = this.buffer.byteLength;\n        }\n        toString() {\n            return this.buffer.toString();\n        }\n        slice(start, end) {\n            return new VSBuffer(this.buffer.slice(start, end));\n        }\n        set(array, offset) {\n            this.buffer.set(array.buffer, offset);\n        }\n        readUint32BE(offset) {\n            return readUint32BE(this.buffer, offset);\n        }\n        writeUint32BE(value, offset) {\n            writeUint32BE(this.buffer, value, offset);\n        }\n        readUint8(offset) {\n            return readUint8(this.buffer, offset);\n        }\n        writeUint8(value, offset) {\n            writeUint8(this.buffer, value, offset);\n        }\n    }\n    exports.VSBuffer = VSBuffer;\n    function readUint32BE(source, offset) {\n        return (source[offset] * Math.pow(2, 24)\n            + source[offset + 1] * Math.pow(2, 16)\n            + source[offset + 2] * Math.pow(2, 8)\n            + source[offset + 3]);\n    }\n    function writeUint32BE(destination, value, offset) {\n        destination[offset + 3] = value;\n        value = value >>> 8;\n        destination[offset + 2] = value;\n        value = value >>> 8;\n        destination[offset + 1] = value;\n        value = value >>> 8;\n        destination[offset] = value;\n    }\n    function readUint8(source, offset) {\n        return source[offset];\n    }\n    function writeUint8(destination, value, offset) {\n        destination[offset] = value;\n    }\n});\n",null]}