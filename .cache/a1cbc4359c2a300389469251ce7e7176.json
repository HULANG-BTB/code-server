{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/languageConfigurationRegistry.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/languageConfigurationRegistry.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/errors\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/base/common/strings\", \"vs/editor/common/core/range\", \"vs/editor/common/model/wordHelper\", \"vs/editor/common/modes/languageConfiguration\", \"vs/editor/common/modes/supports\", \"vs/editor/common/modes/supports/characterPair\", \"vs/editor/common/modes/supports/electricCharacter\", \"vs/editor/common/modes/supports/indentRules\", \"vs/editor/common/modes/supports/onEnter\", \"vs/editor/common/modes/supports/richEditBrackets\"], function (require, exports, errors_1, event_1, lifecycle_1, strings, range_1, wordHelper_1, languageConfiguration_1, supports_1, characterPair_1, electricCharacter_1, indentRules_1, onEnter_1, richEditBrackets_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class RichEditSupport {\n        constructor(languageIdentifier, previous, rawConf) {\n            this._languageIdentifier = languageIdentifier;\n            this._brackets = null;\n            this._electricCharacter = null;\n            let prev = null;\n            if (previous) {\n                prev = previous._conf;\n            }\n            this._conf = RichEditSupport._mergeConf(prev, rawConf);\n            this.onEnter = RichEditSupport._handleOnEnter(this._conf);\n            this.comments = RichEditSupport._handleComments(this._conf);\n            this.characterPair = new characterPair_1.CharacterPairSupport(this._conf);\n            this.wordDefinition = this._conf.wordPattern || wordHelper_1.DEFAULT_WORD_REGEXP;\n            this.indentationRules = this._conf.indentationRules;\n            if (this._conf.indentationRules) {\n                this.indentRulesSupport = new indentRules_1.IndentRulesSupport(this._conf.indentationRules);\n            }\n            this.foldingRules = this._conf.folding || {};\n        }\n        get brackets() {\n            if (!this._brackets && this._conf.brackets) {\n                this._brackets = new richEditBrackets_1.RichEditBrackets(this._languageIdentifier, this._conf.brackets);\n            }\n            return this._brackets;\n        }\n        get electricCharacter() {\n            if (!this._electricCharacter) {\n                let autoClosingPairs = [];\n                if (this._conf.autoClosingPairs) {\n                    autoClosingPairs = this._conf.autoClosingPairs;\n                }\n                else if (this._conf.brackets) {\n                    autoClosingPairs = this._conf.brackets.map(b => {\n                        return { open: b[0], close: b[1] };\n                    });\n                }\n                this._electricCharacter = new electricCharacter_1.BracketElectricCharacterSupport(this.brackets, autoClosingPairs, this._conf.__electricCharacterSupport);\n            }\n            return this._electricCharacter;\n        }\n        static _mergeConf(prev, current) {\n            return {\n                comments: (prev ? current.comments || prev.comments : current.comments),\n                brackets: (prev ? current.brackets || prev.brackets : current.brackets),\n                wordPattern: (prev ? current.wordPattern || prev.wordPattern : current.wordPattern),\n                indentationRules: (prev ? current.indentationRules || prev.indentationRules : current.indentationRules),\n                onEnterRules: (prev ? current.onEnterRules || prev.onEnterRules : current.onEnterRules),\n                autoClosingPairs: (prev ? current.autoClosingPairs || prev.autoClosingPairs : current.autoClosingPairs),\n                surroundingPairs: (prev ? current.surroundingPairs || prev.surroundingPairs : current.surroundingPairs),\n                autoCloseBefore: (prev ? current.autoCloseBefore || prev.autoCloseBefore : current.autoCloseBefore),\n                folding: (prev ? current.folding || prev.folding : current.folding),\n                __electricCharacterSupport: (prev ? current.__electricCharacterSupport || prev.__electricCharacterSupport : current.__electricCharacterSupport),\n            };\n        }\n        static _handleOnEnter(conf) {\n            // on enter\n            let onEnter = {};\n            let empty = true;\n            if (conf.brackets) {\n                empty = false;\n                onEnter.brackets = conf.brackets;\n            }\n            if (conf.indentationRules) {\n                empty = false;\n            }\n            if (conf.onEnterRules) {\n                empty = false;\n                onEnter.regExpRules = conf.onEnterRules;\n            }\n            if (!empty) {\n                return new onEnter_1.OnEnterSupport(onEnter);\n            }\n            return null;\n        }\n        static _handleComments(conf) {\n            let commentRule = conf.comments;\n            if (!commentRule) {\n                return null;\n            }\n            // comment configuration\n            let comments = {};\n            if (commentRule.lineComment) {\n                comments.lineCommentToken = commentRule.lineComment;\n            }\n            if (commentRule.blockComment) {\n                let [blockStart, blockEnd] = commentRule.blockComment;\n                comments.blockCommentStartToken = blockStart;\n                comments.blockCommentEndToken = blockEnd;\n            }\n            return comments;\n        }\n    }\n    exports.RichEditSupport = RichEditSupport;\n    class LanguageConfigurationChangeEvent {\n    }\n    exports.LanguageConfigurationChangeEvent = LanguageConfigurationChangeEvent;\n    class LanguageConfigurationRegistryImpl {\n        constructor() {\n            this._entries = new Map();\n            this._onDidChange = new event_1.Emitter();\n            this.onDidChange = this._onDidChange.event;\n        }\n        register(languageIdentifier, configuration) {\n            let previous = this._getRichEditSupport(languageIdentifier.id);\n            let current = new RichEditSupport(languageIdentifier, previous, configuration);\n            this._entries.set(languageIdentifier.id, current);\n            this._onDidChange.fire({ languageIdentifier });\n            return lifecycle_1.toDisposable(() => {\n                if (this._entries.get(languageIdentifier.id) === current) {\n                    this._entries.set(languageIdentifier.id, previous);\n                    this._onDidChange.fire({ languageIdentifier });\n                }\n            });\n        }\n        _getRichEditSupport(languageId) {\n            return this._entries.get(languageId);\n        }\n        getIndentationRules(languageId) {\n            const value = this._entries.get(languageId);\n            if (!value) {\n                return null;\n            }\n            return value.indentationRules || null;\n        }\n        // begin electricCharacter\n        _getElectricCharacterSupport(languageId) {\n            let value = this._getRichEditSupport(languageId);\n            if (!value) {\n                return null;\n            }\n            return value.electricCharacter || null;\n        }\n        getElectricCharacters(languageId) {\n            let electricCharacterSupport = this._getElectricCharacterSupport(languageId);\n            if (!electricCharacterSupport) {\n                return [];\n            }\n            return electricCharacterSupport.getElectricCharacters();\n        }\n        /**\n         * Should return opening bracket type to match indentation with\n         */\n        onElectricCharacter(character, context, column) {\n            let scopedLineTokens = supports_1.createScopedLineTokens(context, column - 1);\n            let electricCharacterSupport = this._getElectricCharacterSupport(scopedLineTokens.languageId);\n            if (!electricCharacterSupport) {\n                return null;\n            }\n            return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n        }\n        // end electricCharacter\n        getComments(languageId) {\n            let value = this._getRichEditSupport(languageId);\n            if (!value) {\n                return null;\n            }\n            return value.comments || null;\n        }\n        // begin characterPair\n        _getCharacterPairSupport(languageId) {\n            let value = this._getRichEditSupport(languageId);\n            if (!value) {\n                return null;\n            }\n            return value.characterPair || null;\n        }\n        getAutoClosingPairs(languageId) {\n            let characterPairSupport = this._getCharacterPairSupport(languageId);\n            if (!characterPairSupport) {\n                return [];\n            }\n            return characterPairSupport.getAutoClosingPairs();\n        }\n        getAutoCloseBeforeSet(languageId) {\n            let characterPairSupport = this._getCharacterPairSupport(languageId);\n            if (!characterPairSupport) {\n                return characterPair_1.CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;\n            }\n            return characterPairSupport.getAutoCloseBeforeSet();\n        }\n        getSurroundingPairs(languageId) {\n            let characterPairSupport = this._getCharacterPairSupport(languageId);\n            if (!characterPairSupport) {\n                return [];\n            }\n            return characterPairSupport.getSurroundingPairs();\n        }\n        shouldAutoClosePair(character, context, column) {\n            let scopedLineTokens = supports_1.createScopedLineTokens(context, column - 1);\n            let characterPairSupport = this._getCharacterPairSupport(scopedLineTokens.languageId);\n            if (!characterPairSupport) {\n                return false;\n            }\n            return characterPairSupport.shouldAutoClosePair(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n        }\n        // end characterPair\n        getWordDefinition(languageId) {\n            let value = this._getRichEditSupport(languageId);\n            if (!value) {\n                return wordHelper_1.ensureValidWordDefinition(null);\n            }\n            return wordHelper_1.ensureValidWordDefinition(value.wordDefinition || null);\n        }\n        getFoldingRules(languageId) {\n            let value = this._getRichEditSupport(languageId);\n            if (!value) {\n                return {};\n            }\n            return value.foldingRules;\n        }\n        // begin Indent Rules\n        getIndentRulesSupport(languageId) {\n            let value = this._getRichEditSupport(languageId);\n            if (!value) {\n                return null;\n            }\n            return value.indentRulesSupport || null;\n        }\n        /**\n         * Get nearest preceiding line which doesn't match unIndentPattern or contains all whitespace.\n         * Result:\n         * -1: run into the boundary of embedded languages\n         * 0: every line above are invalid\n         * else: nearest preceding line of the same language\n         */\n        getPrecedingValidLine(model, lineNumber, indentRulesSupport) {\n            let languageID = model.getLanguageIdAtPosition(lineNumber, 0);\n            if (lineNumber > 1) {\n                let lastLineNumber;\n                let resultLineNumber = -1;\n                for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                    if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageID) {\n                        return resultLineNumber;\n                    }\n                    let text = model.getLineContent(lastLineNumber);\n                    if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n                        resultLineNumber = lastLineNumber;\n                        continue;\n                    }\n                    return lastLineNumber;\n                }\n            }\n            return -1;\n        }\n        /**\n         * Get inherited indentation from above lines.\n         * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n         * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n         * 3. If this line doesn't match any indent rules\n         *   a. check whether the line above it matches indentNextLinePattern\n         *   b. If not, the indent level of this line is the result\n         *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n         * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n         *\n         * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n         */\n        getInheritIndentForLine(model, lineNumber, honorIntentialIndent = true) {\n            let indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);\n            if (!indentRulesSupport) {\n                return null;\n            }\n            if (lineNumber <= 1) {\n                return {\n                    indentation: '',\n                    action: null\n                };\n            }\n            let precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n            if (precedingUnIgnoredLine < 0) {\n                return null;\n            }\n            else if (precedingUnIgnoredLine < 1) {\n                return {\n                    indentation: '',\n                    action: null\n                };\n            }\n            let precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n            if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n                return {\n                    indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n                    action: languageConfiguration_1.IndentAction.Indent,\n                    line: precedingUnIgnoredLine\n                };\n            }\n            else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n                return {\n                    indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n                    action: null,\n                    line: precedingUnIgnoredLine\n                };\n            }\n            else {\n                // precedingUnIgnoredLine can not be ignored.\n                // it doesn't increase indent of following lines\n                // it doesn't increase just next line\n                // so current line is not affect by precedingUnIgnoredLine\n                // and then we should get a correct inheritted indentation from above lines\n                if (precedingUnIgnoredLine === 1) {\n                    return {\n                        indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                        action: null,\n                        line: precedingUnIgnoredLine\n                    };\n                }\n                let previousLine = precedingUnIgnoredLine - 1;\n                let previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n                if (!(previousLineIndentMetadata & (indentRules_1.IndentConsts.INCREASE_MASK | indentRules_1.IndentConsts.DECREASE_MASK)) &&\n                    (previousLineIndentMetadata & indentRules_1.IndentConsts.INDENT_NEXTLINE_MASK)) {\n                    let stopLine = 0;\n                    for (let i = previousLine - 1; i > 0; i--) {\n                        if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                            continue;\n                        }\n                        stopLine = i;\n                        break;\n                    }\n                    return {\n                        indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                        action: null,\n                        line: stopLine + 1\n                    };\n                }\n                if (honorIntentialIndent) {\n                    return {\n                        indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                        action: null,\n                        line: precedingUnIgnoredLine\n                    };\n                }\n                else {\n                    // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n                    for (let i = precedingUnIgnoredLine; i > 0; i--) {\n                        let lineContent = model.getLineContent(i);\n                        if (indentRulesSupport.shouldIncrease(lineContent)) {\n                            return {\n                                indentation: strings.getLeadingWhitespace(lineContent),\n                                action: languageConfiguration_1.IndentAction.Indent,\n                                line: i\n                            };\n                        }\n                        else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n                            let stopLine = 0;\n                            for (let j = i - 1; j > 0; j--) {\n                                if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                                    continue;\n                                }\n                                stopLine = j;\n                                break;\n                            }\n                            return {\n                                indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                                action: null,\n                                line: stopLine + 1\n                            };\n                        }\n                        else if (indentRulesSupport.shouldDecrease(lineContent)) {\n                            return {\n                                indentation: strings.getLeadingWhitespace(lineContent),\n                                action: null,\n                                line: i\n                            };\n                        }\n                    }\n                    return {\n                        indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n                        action: null,\n                        line: 1\n                    };\n                }\n            }\n        }\n        getGoodIndentForLine(virtualModel, languageId, lineNumber, indentConverter) {\n            let indentRulesSupport = this.getIndentRulesSupport(languageId);\n            if (!indentRulesSupport) {\n                return null;\n            }\n            let indent = this.getInheritIndentForLine(virtualModel, lineNumber);\n            let lineContent = virtualModel.getLineContent(lineNumber);\n            if (indent) {\n                let inheritLine = indent.line;\n                if (inheritLine !== undefined) {\n                    let onEnterSupport = this._getOnEnterSupport(languageId);\n                    let enterResult = null;\n                    try {\n                        if (onEnterSupport) {\n                            enterResult = onEnterSupport.onEnter('', virtualModel.getLineContent(inheritLine), '');\n                        }\n                    }\n                    catch (e) {\n                        errors_1.onUnexpectedError(e);\n                    }\n                    if (enterResult) {\n                        let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n                        if (enterResult.removeText) {\n                            indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n                        }\n                        if ((enterResult.indentAction === languageConfiguration_1.IndentAction.Indent) ||\n                            (enterResult.indentAction === languageConfiguration_1.IndentAction.IndentOutdent)) {\n                            indentation = indentConverter.shiftIndent(indentation);\n                        }\n                        else if (enterResult.indentAction === languageConfiguration_1.IndentAction.Outdent) {\n                            indentation = indentConverter.unshiftIndent(indentation);\n                        }\n                        if (indentRulesSupport.shouldDecrease(lineContent)) {\n                            indentation = indentConverter.unshiftIndent(indentation);\n                        }\n                        if (enterResult.appendText) {\n                            indentation += enterResult.appendText;\n                        }\n                        return strings.getLeadingWhitespace(indentation);\n                    }\n                }\n                if (indentRulesSupport.shouldDecrease(lineContent)) {\n                    if (indent.action === languageConfiguration_1.IndentAction.Indent) {\n                        return indent.indentation;\n                    }\n                    else {\n                        return indentConverter.unshiftIndent(indent.indentation);\n                    }\n                }\n                else {\n                    if (indent.action === languageConfiguration_1.IndentAction.Indent) {\n                        return indentConverter.shiftIndent(indent.indentation);\n                    }\n                    else {\n                        return indent.indentation;\n                    }\n                }\n            }\n            return null;\n        }\n        getIndentForEnter(model, range, indentConverter, autoIndent) {\n            model.forceTokenization(range.startLineNumber);\n            let lineTokens = model.getLineTokens(range.startLineNumber);\n            let beforeEnterText;\n            let afterEnterText;\n            let scopedLineTokens = supports_1.createScopedLineTokens(lineTokens, range.startColumn - 1);\n            let scopedLineText = scopedLineTokens.getLineContent();\n            let embeddedLanguage = false;\n            if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n                // we are in the embeded language content\n                embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n                beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n            }\n            else {\n                beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n            }\n            if (range.isEmpty()) {\n                afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n            }\n            else {\n                const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n                afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n            }\n            let indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n            if (!indentRulesSupport) {\n                return null;\n            }\n            let beforeEnterResult = beforeEnterText;\n            let beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n            if (!autoIndent && !embeddedLanguage) {\n                let beforeEnterIndentAction = this.getInheritIndentForLine(model, range.startLineNumber);\n                if (indentRulesSupport.shouldDecrease(beforeEnterText)) {\n                    if (beforeEnterIndentAction) {\n                        beforeEnterIndent = beforeEnterIndentAction.indentation;\n                        if (beforeEnterIndentAction.action !== languageConfiguration_1.IndentAction.Indent) {\n                            beforeEnterIndent = indentConverter.unshiftIndent(beforeEnterIndent);\n                        }\n                    }\n                }\n                beforeEnterResult = beforeEnterIndent + strings.ltrim(strings.ltrim(beforeEnterText, ' '), '\\t');\n            }\n            let virtualModel = {\n                getLineTokens: (lineNumber) => {\n                    return model.getLineTokens(lineNumber);\n                },\n                getLanguageIdentifier: () => {\n                    return model.getLanguageIdentifier();\n                },\n                getLanguageIdAtPosition: (lineNumber, column) => {\n                    return model.getLanguageIdAtPosition(lineNumber, column);\n                },\n                getLineContent: (lineNumber) => {\n                    if (lineNumber === range.startLineNumber) {\n                        return beforeEnterResult;\n                    }\n                    else {\n                        return model.getLineContent(lineNumber);\n                    }\n                }\n            };\n            let currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n            let afterEnterAction = this.getInheritIndentForLine(virtualModel, range.startLineNumber + 1);\n            if (!afterEnterAction) {\n                let beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n                return {\n                    beforeEnter: beforeEnter,\n                    afterEnter: beforeEnter\n                };\n            }\n            let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n            if (afterEnterAction.action === languageConfiguration_1.IndentAction.Indent) {\n                afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n            }\n            if (indentRulesSupport.shouldDecrease(afterEnterText)) {\n                afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n            }\n            return {\n                beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n                afterEnter: afterEnterIndent\n            };\n        }\n        /**\n         * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n         * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n         */\n        getIndentActionForType(model, range, ch, indentConverter) {\n            let scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n            let indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n            if (!indentRulesSupport) {\n                return null;\n            }\n            let scopedLineText = scopedLineTokens.getLineContent();\n            let beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n            let afterTypeText;\n            // selection support\n            if (range.isEmpty()) {\n                afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n            }\n            else {\n                const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n                afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n            }\n            // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n            // Users might change the indentation by purpose and we should honor that instead of readjusting.\n            if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n                // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n                // 1. Get inherited indent action\n                let r = this.getInheritIndentForLine(model, range.startLineNumber, false);\n                if (!r) {\n                    return null;\n                }\n                let indentation = r.indentation;\n                if (r.action !== languageConfiguration_1.IndentAction.Indent) {\n                    indentation = indentConverter.unshiftIndent(indentation);\n                }\n                return indentation;\n            }\n            return null;\n        }\n        getIndentMetadata(model, lineNumber) {\n            let indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);\n            if (!indentRulesSupport) {\n                return null;\n            }\n            if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n                return null;\n            }\n            return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n        }\n        // end Indent Rules\n        // begin onEnter\n        _getOnEnterSupport(languageId) {\n            let value = this._getRichEditSupport(languageId);\n            if (!value) {\n                return null;\n            }\n            return value.onEnter || null;\n        }\n        getRawEnterActionAtPosition(model, lineNumber, column) {\n            let r = this.getEnterAction(model, new range_1.Range(lineNumber, column, lineNumber, column));\n            return r ? r.enterAction : null;\n        }\n        getEnterAction(model, range) {\n            let indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n            let scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n            let onEnterSupport = this._getOnEnterSupport(scopedLineTokens.languageId);\n            if (!onEnterSupport) {\n                return null;\n            }\n            let scopedLineText = scopedLineTokens.getLineContent();\n            let beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n            let afterEnterText;\n            // selection support\n            if (range.isEmpty()) {\n                afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n            }\n            else {\n                const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n                afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n            }\n            let lineNumber = range.startLineNumber;\n            let oneLineAboveText = '';\n            if (lineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\n                // This is not the first line and the entire line belongs to this mode\n                let oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, lineNumber - 1);\n                if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\n                    // The line above ends with text belonging to the same mode\n                    oneLineAboveText = oneLineAboveScopedLineTokens.getLineContent();\n                }\n            }\n            let enterResult = null;\n            try {\n                enterResult = onEnterSupport.onEnter(oneLineAboveText, beforeEnterText, afterEnterText);\n            }\n            catch (e) {\n                errors_1.onUnexpectedError(e);\n            }\n            if (!enterResult) {\n                return null;\n            }\n            else {\n                // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n                if (!enterResult.appendText) {\n                    if ((enterResult.indentAction === languageConfiguration_1.IndentAction.Indent) ||\n                        (enterResult.indentAction === languageConfiguration_1.IndentAction.IndentOutdent)) {\n                        enterResult.appendText = '\\t';\n                    }\n                    else {\n                        enterResult.appendText = '';\n                    }\n                }\n            }\n            if (enterResult.removeText) {\n                indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n            }\n            return {\n                enterAction: enterResult,\n                indentation: indentation,\n            };\n        }\n        getIndentationAtPosition(model, lineNumber, column) {\n            let lineText = model.getLineContent(lineNumber);\n            let indentation = strings.getLeadingWhitespace(lineText);\n            if (indentation.length > column - 1) {\n                indentation = indentation.substring(0, column - 1);\n            }\n            return indentation;\n        }\n        getScopedLineTokens(model, lineNumber, columnNumber) {\n            model.forceTokenization(lineNumber);\n            let lineTokens = model.getLineTokens(lineNumber);\n            let column = (typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1);\n            let scopedLineTokens = supports_1.createScopedLineTokens(lineTokens, column);\n            return scopedLineTokens;\n        }\n        // end onEnter\n        getBracketsSupport(languageId) {\n            let value = this._getRichEditSupport(languageId);\n            if (!value) {\n                return null;\n            }\n            return value.brackets || null;\n        }\n    }\n    exports.LanguageConfigurationRegistryImpl = LanguageConfigurationRegistryImpl;\n    exports.LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();\n});\n",null]}