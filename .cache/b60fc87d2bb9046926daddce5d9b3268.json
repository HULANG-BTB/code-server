{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/common/problemMatcher.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/common/problemMatcher.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar nls_1 = require(\"vs/nls\");\nvar Objects = require(\"vs/base/common/objects\");\nvar Strings = require(\"vs/base/common/strings\");\nvar Assert = require(\"vs/base/common/assert\");\nvar path_1 = require(\"vs/base/common/path\");\nvar Types = require(\"vs/base/common/types\");\nvar UUID = require(\"vs/base/common/uuid\");\nvar Platform = require(\"vs/base/common/platform\");\nvar severity_1 = require(\"vs/base/common/severity\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar parsers_1 = require(\"vs/base/common/parsers\");\nvar markers_1 = require(\"vs/platform/markers/common/markers\");\nvar extensionsRegistry_1 = require(\"vs/workbench/services/extensions/common/extensionsRegistry\");\nvar event_1 = require(\"vs/base/common/event\");\nvar FileLocationKind;\n(function (FileLocationKind) {\n    FileLocationKind[FileLocationKind[\"Auto\"] = 0] = \"Auto\";\n    FileLocationKind[FileLocationKind[\"Relative\"] = 1] = \"Relative\";\n    FileLocationKind[FileLocationKind[\"Absolute\"] = 2] = \"Absolute\";\n})(FileLocationKind = exports.FileLocationKind || (exports.FileLocationKind = {}));\n(function (FileLocationKind) {\n    function fromString(value) {\n        value = value.toLowerCase();\n        if (value === 'absolute') {\n            return FileLocationKind.Absolute;\n        }\n        else if (value === 'relative') {\n            return FileLocationKind.Relative;\n        }\n        else {\n            return undefined;\n        }\n    }\n    FileLocationKind.fromString = fromString;\n})(FileLocationKind = exports.FileLocationKind || (exports.FileLocationKind = {}));\nvar ProblemLocationKind;\n(function (ProblemLocationKind) {\n    ProblemLocationKind[ProblemLocationKind[\"File\"] = 0] = \"File\";\n    ProblemLocationKind[ProblemLocationKind[\"Location\"] = 1] = \"Location\";\n})(ProblemLocationKind = exports.ProblemLocationKind || (exports.ProblemLocationKind = {}));\n(function (ProblemLocationKind) {\n    function fromString(value) {\n        value = value.toLowerCase();\n        if (value === 'file') {\n            return ProblemLocationKind.File;\n        }\n        else if (value === 'location') {\n            return ProblemLocationKind.Location;\n        }\n        else {\n            return undefined;\n        }\n    }\n    ProblemLocationKind.fromString = fromString;\n})(ProblemLocationKind = exports.ProblemLocationKind || (exports.ProblemLocationKind = {}));\nvar ApplyToKind;\n(function (ApplyToKind) {\n    ApplyToKind[ApplyToKind[\"allDocuments\"] = 0] = \"allDocuments\";\n    ApplyToKind[ApplyToKind[\"openDocuments\"] = 1] = \"openDocuments\";\n    ApplyToKind[ApplyToKind[\"closedDocuments\"] = 2] = \"closedDocuments\";\n})(ApplyToKind = exports.ApplyToKind || (exports.ApplyToKind = {}));\n(function (ApplyToKind) {\n    function fromString(value) {\n        value = value.toLowerCase();\n        if (value === 'alldocuments') {\n            return ApplyToKind.allDocuments;\n        }\n        else if (value === 'opendocuments') {\n            return ApplyToKind.openDocuments;\n        }\n        else if (value === 'closeddocuments') {\n            return ApplyToKind.closedDocuments;\n        }\n        else {\n            return undefined;\n        }\n    }\n    ApplyToKind.fromString = fromString;\n})(ApplyToKind = exports.ApplyToKind || (exports.ApplyToKind = {}));\nfunction isNamedProblemMatcher(value) {\n    return value && Types.isString(value.name) ? true : false;\n}\nexports.isNamedProblemMatcher = isNamedProblemMatcher;\nfunction getResource(filename, matcher) {\n    var kind = matcher.fileLocation;\n    var fullPath;\n    if (kind === FileLocationKind.Absolute) {\n        fullPath = filename;\n    }\n    else if ((kind === FileLocationKind.Relative) && matcher.filePrefix) {\n        fullPath = path_1.join(matcher.filePrefix, filename);\n    }\n    if (fullPath === undefined) {\n        throw new Error('FileLocationKind is not actionable. Does the matcher have a filePrefix? This should never happen.');\n    }\n    fullPath = fullPath.replace(/\\\\/g, '/');\n    if (fullPath[0] !== '/') {\n        fullPath = '/' + fullPath;\n    }\n    if (matcher.uriProvider !== undefined) {\n        return matcher.uriProvider(fullPath);\n    }\n    else {\n        return uri_1.URI.file(fullPath);\n    }\n}\nexports.getResource = getResource;\nfunction createLineMatcher(matcher) {\n    var pattern = matcher.pattern;\n    if (Types.isArray(pattern)) {\n        return new MultiLineMatcher(matcher);\n    }\n    else {\n        return new SingleLineMatcher(matcher);\n    }\n}\nexports.createLineMatcher = createLineMatcher;\nvar endOfLine = Platform.OS === Platform.OperatingSystem.Windows ? '\\r\\n' : '\\n';\nvar AbstractLineMatcher = /** @class */ (function () {\n    function AbstractLineMatcher(matcher) {\n        this.matcher = matcher;\n    }\n    AbstractLineMatcher.prototype.handle = function (lines, start) {\n        if (start === void 0) { start = 0; }\n        return { match: null, continue: false };\n    };\n    AbstractLineMatcher.prototype.next = function (line) {\n        return null;\n    };\n    AbstractLineMatcher.prototype.fillProblemData = function (data, pattern, matches) {\n        if (data) {\n            this.fillProperty(data, 'file', pattern, matches, true);\n            this.appendProperty(data, 'message', pattern, matches, true);\n            this.fillProperty(data, 'code', pattern, matches, true);\n            this.fillProperty(data, 'severity', pattern, matches, true);\n            this.fillProperty(data, 'location', pattern, matches, true);\n            this.fillProperty(data, 'line', pattern, matches);\n            this.fillProperty(data, 'character', pattern, matches);\n            this.fillProperty(data, 'endLine', pattern, matches);\n            this.fillProperty(data, 'endCharacter', pattern, matches);\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    AbstractLineMatcher.prototype.appendProperty = function (data, property, pattern, matches, trim) {\n        if (trim === void 0) { trim = false; }\n        var patternProperty = pattern[property];\n        if (Types.isUndefined(data[property])) {\n            this.fillProperty(data, property, pattern, matches, trim);\n        }\n        else if (!Types.isUndefined(patternProperty) && patternProperty < matches.length) {\n            var value = matches[patternProperty];\n            if (trim) {\n                value = Strings.trim(value);\n            }\n            data[property] += endOfLine + value;\n        }\n    };\n    AbstractLineMatcher.prototype.fillProperty = function (data, property, pattern, matches, trim) {\n        if (trim === void 0) { trim = false; }\n        var patternAtProperty = pattern[property];\n        if (Types.isUndefined(data[property]) && !Types.isUndefined(patternAtProperty) && patternAtProperty < matches.length) {\n            var value = matches[patternAtProperty];\n            if (value !== undefined) {\n                if (trim) {\n                    value = Strings.trim(value);\n                }\n                data[property] = value;\n            }\n        }\n    };\n    AbstractLineMatcher.prototype.getMarkerMatch = function (data) {\n        try {\n            var location = this.getLocation(data);\n            if (data.file && location && data.message) {\n                var marker = {\n                    severity: this.getSeverity(data),\n                    startLineNumber: location.startLineNumber,\n                    startColumn: location.startCharacter,\n                    endLineNumber: location.endLineNumber,\n                    endColumn: location.endCharacter,\n                    message: data.message\n                };\n                if (data.code !== undefined) {\n                    marker.code = data.code;\n                }\n                if (this.matcher.source !== undefined) {\n                    marker.source = this.matcher.source;\n                }\n                return {\n                    description: this.matcher,\n                    resource: this.getResource(data.file),\n                    marker: marker\n                };\n            }\n        }\n        catch (err) {\n            console.error(\"Failed to convert problem data into match: \" + JSON.stringify(data));\n        }\n        return undefined;\n    };\n    AbstractLineMatcher.prototype.getResource = function (filename) {\n        return getResource(filename, this.matcher);\n    };\n    AbstractLineMatcher.prototype.getLocation = function (data) {\n        if (data.kind === ProblemLocationKind.File) {\n            return this.createLocation(0, 0, 0, 0);\n        }\n        if (data.location) {\n            return this.parseLocationInfo(data.location);\n        }\n        if (!data.line) {\n            return null;\n        }\n        var startLine = parseInt(data.line);\n        var startColumn = data.character ? parseInt(data.character) : undefined;\n        var endLine = data.endLine ? parseInt(data.endLine) : undefined;\n        var endColumn = data.endCharacter ? parseInt(data.endCharacter) : undefined;\n        return this.createLocation(startLine, startColumn, endLine, endColumn);\n    };\n    AbstractLineMatcher.prototype.parseLocationInfo = function (value) {\n        if (!value || !value.match(/(\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)/)) {\n            return null;\n        }\n        var parts = value.split(',');\n        var startLine = parseInt(parts[0]);\n        var startColumn = parts.length > 1 ? parseInt(parts[1]) : undefined;\n        if (parts.length > 3) {\n            return this.createLocation(startLine, startColumn, parseInt(parts[2]), parseInt(parts[3]));\n        }\n        else {\n            return this.createLocation(startLine, startColumn, undefined, undefined);\n        }\n    };\n    AbstractLineMatcher.prototype.createLocation = function (startLine, startColumn, endLine, endColumn) {\n        if (startColumn !== undefined && endColumn !== undefined) {\n            return { startLineNumber: startLine, startCharacter: startColumn, endLineNumber: endLine || startLine, endCharacter: endColumn };\n        }\n        if (startColumn !== undefined) {\n            return { startLineNumber: startLine, startCharacter: startColumn, endLineNumber: startLine, endCharacter: startColumn };\n        }\n        return { startLineNumber: startLine, startCharacter: 1, endLineNumber: startLine, endCharacter: Number.MAX_VALUE };\n    };\n    AbstractLineMatcher.prototype.getSeverity = function (data) {\n        var result = null;\n        if (data.severity) {\n            var value = data.severity;\n            if (value) {\n                result = severity_1.default.fromValue(value);\n                if (result === severity_1.default.Ignore) {\n                    if (value === 'E') {\n                        result = severity_1.default.Error;\n                    }\n                    else if (value === 'W') {\n                        result = severity_1.default.Warning;\n                    }\n                    else if (value === 'I') {\n                        result = severity_1.default.Info;\n                    }\n                    else if (Strings.equalsIgnoreCase(value, 'hint')) {\n                        result = severity_1.default.Info;\n                    }\n                    else if (Strings.equalsIgnoreCase(value, 'note')) {\n                        result = severity_1.default.Info;\n                    }\n                }\n            }\n        }\n        if (result === null || result === severity_1.default.Ignore) {\n            result = this.matcher.severity || severity_1.default.Error;\n        }\n        return markers_1.MarkerSeverity.fromSeverity(result);\n    };\n    return AbstractLineMatcher;\n}());\nvar SingleLineMatcher = /** @class */ (function (_super) {\n    tslib_1.__extends(SingleLineMatcher, _super);\n    function SingleLineMatcher(matcher) {\n        var _this = _super.call(this, matcher) || this;\n        _this.pattern = matcher.pattern;\n        return _this;\n    }\n    Object.defineProperty(SingleLineMatcher.prototype, \"matchLength\", {\n        get: function () {\n            return 1;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SingleLineMatcher.prototype.handle = function (lines, start) {\n        if (start === void 0) { start = 0; }\n        Assert.ok(lines.length - start === 1);\n        var data = Object.create(null);\n        if (this.pattern.kind !== undefined) {\n            data.kind = this.pattern.kind;\n        }\n        var matches = this.pattern.regexp.exec(lines[start]);\n        if (matches) {\n            this.fillProblemData(data, this.pattern, matches);\n            var match = this.getMarkerMatch(data);\n            if (match) {\n                return { match: match, continue: false };\n            }\n        }\n        return { match: null, continue: false };\n    };\n    SingleLineMatcher.prototype.next = function (line) {\n        return null;\n    };\n    return SingleLineMatcher;\n}(AbstractLineMatcher));\nvar MultiLineMatcher = /** @class */ (function (_super) {\n    tslib_1.__extends(MultiLineMatcher, _super);\n    function MultiLineMatcher(matcher) {\n        var _this = _super.call(this, matcher) || this;\n        _this.patterns = matcher.pattern;\n        return _this;\n    }\n    Object.defineProperty(MultiLineMatcher.prototype, \"matchLength\", {\n        get: function () {\n            return this.patterns.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MultiLineMatcher.prototype.handle = function (lines, start) {\n        if (start === void 0) { start = 0; }\n        Assert.ok(lines.length - start === this.patterns.length);\n        this.data = Object.create(null);\n        var data = this.data;\n        data.kind = this.patterns[0].kind;\n        for (var i = 0; i < this.patterns.length; i++) {\n            var pattern = this.patterns[i];\n            var matches = pattern.regexp.exec(lines[i + start]);\n            if (!matches) {\n                return { match: null, continue: false };\n            }\n            else {\n                // Only the last pattern can loop\n                if (pattern.loop && i === this.patterns.length - 1) {\n                    data = Objects.deepClone(data);\n                }\n                this.fillProblemData(data, pattern, matches);\n            }\n        }\n        var loop = !!this.patterns[this.patterns.length - 1].loop;\n        if (!loop) {\n            this.data = null;\n        }\n        var markerMatch = data ? this.getMarkerMatch(data) : null;\n        return { match: markerMatch ? markerMatch : null, continue: loop };\n    };\n    MultiLineMatcher.prototype.next = function (line) {\n        var pattern = this.patterns[this.patterns.length - 1];\n        Assert.ok(pattern.loop === true && this.data !== null);\n        var matches = pattern.regexp.exec(line);\n        if (!matches) {\n            this.data = null;\n            return null;\n        }\n        var data = Objects.deepClone(this.data);\n        var problemMatch;\n        if (this.fillProblemData(data, pattern, matches)) {\n            problemMatch = this.getMarkerMatch(data);\n        }\n        return problemMatch ? problemMatch : null;\n    };\n    return MultiLineMatcher;\n}(AbstractLineMatcher));\nvar Config;\n(function (Config) {\n    var CheckedProblemPattern;\n    (function (CheckedProblemPattern) {\n        function is(value) {\n            var candidate = value;\n            return candidate && Types.isString(candidate.regexp);\n        }\n        CheckedProblemPattern.is = is;\n    })(CheckedProblemPattern = Config.CheckedProblemPattern || (Config.CheckedProblemPattern = {}));\n    var NamedProblemPattern;\n    (function (NamedProblemPattern) {\n        function is(value) {\n            var candidate = value;\n            return candidate && Types.isString(candidate.name);\n        }\n        NamedProblemPattern.is = is;\n    })(NamedProblemPattern = Config.NamedProblemPattern || (Config.NamedProblemPattern = {}));\n    var NamedCheckedProblemPattern;\n    (function (NamedCheckedProblemPattern) {\n        function is(value) {\n            var candidate = value;\n            return candidate && NamedProblemPattern.is(candidate) && Types.isString(candidate.regexp);\n        }\n        NamedCheckedProblemPattern.is = is;\n    })(NamedCheckedProblemPattern = Config.NamedCheckedProblemPattern || (Config.NamedCheckedProblemPattern = {}));\n    var MultiLineProblemPattern;\n    (function (MultiLineProblemPattern) {\n        function is(value) {\n            return value && Types.isArray(value);\n        }\n        MultiLineProblemPattern.is = is;\n    })(MultiLineProblemPattern = Config.MultiLineProblemPattern || (Config.MultiLineProblemPattern = {}));\n    var MultiLineCheckedProblemPattern;\n    (function (MultiLineCheckedProblemPattern) {\n        function is(value) {\n            if (!MultiLineProblemPattern.is(value)) {\n                return false;\n            }\n            for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {\n                var element = value_1[_i];\n                if (!Config.CheckedProblemPattern.is(element)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        MultiLineCheckedProblemPattern.is = is;\n    })(MultiLineCheckedProblemPattern = Config.MultiLineCheckedProblemPattern || (Config.MultiLineCheckedProblemPattern = {}));\n    var NamedMultiLineCheckedProblemPattern;\n    (function (NamedMultiLineCheckedProblemPattern) {\n        function is(value) {\n            var candidate = value;\n            return candidate && Types.isString(candidate.name) && Types.isArray(candidate.patterns) && MultiLineCheckedProblemPattern.is(candidate.patterns);\n        }\n        NamedMultiLineCheckedProblemPattern.is = is;\n    })(NamedMultiLineCheckedProblemPattern = Config.NamedMultiLineCheckedProblemPattern || (Config.NamedMultiLineCheckedProblemPattern = {}));\n    function isNamedProblemMatcher(value) {\n        return Types.isString(value.name);\n    }\n    Config.isNamedProblemMatcher = isNamedProblemMatcher;\n})(Config = exports.Config || (exports.Config = {}));\nvar ProblemPatternParser = /** @class */ (function (_super) {\n    tslib_1.__extends(ProblemPatternParser, _super);\n    function ProblemPatternParser(logger) {\n        return _super.call(this, logger) || this;\n    }\n    ProblemPatternParser.prototype.parse = function (value) {\n        if (Config.NamedMultiLineCheckedProblemPattern.is(value)) {\n            return this.createNamedMultiLineProblemPattern(value);\n        }\n        else if (Config.MultiLineCheckedProblemPattern.is(value)) {\n            return this.createMultiLineProblemPattern(value);\n        }\n        else if (Config.NamedCheckedProblemPattern.is(value)) {\n            var result = this.createSingleProblemPattern(value);\n            result.name = value.name;\n            return result;\n        }\n        else if (Config.CheckedProblemPattern.is(value)) {\n            return this.createSingleProblemPattern(value);\n        }\n        else {\n            this.error(nls_1.localize('ProblemPatternParser.problemPattern.missingRegExp', 'The problem pattern is missing a regular expression.'));\n            return null;\n        }\n    };\n    ProblemPatternParser.prototype.createSingleProblemPattern = function (value) {\n        var result = this.doCreateSingleProblemPattern(value, true);\n        if (result === undefined) {\n            return null;\n        }\n        else if (result.kind === undefined) {\n            result.kind = ProblemLocationKind.Location;\n        }\n        return this.validateProblemPattern([result]) ? result : null;\n    };\n    ProblemPatternParser.prototype.createNamedMultiLineProblemPattern = function (value) {\n        var validPatterns = this.createMultiLineProblemPattern(value.patterns);\n        if (!validPatterns) {\n            return null;\n        }\n        var result = {\n            name: value.name,\n            label: value.label ? value.label : value.name,\n            patterns: validPatterns\n        };\n        return result;\n    };\n    ProblemPatternParser.prototype.createMultiLineProblemPattern = function (values) {\n        var result = [];\n        for (var i = 0; i < values.length; i++) {\n            var pattern = this.doCreateSingleProblemPattern(values[i], false);\n            if (pattern === undefined) {\n                return null;\n            }\n            if (i < values.length - 1) {\n                if (!Types.isUndefined(pattern.loop) && pattern.loop) {\n                    pattern.loop = false;\n                    this.error(nls_1.localize('ProblemPatternParser.loopProperty.notLast', 'The loop property is only supported on the last line matcher.'));\n                }\n            }\n            result.push(pattern);\n        }\n        if (result[0].kind === undefined) {\n            result[0].kind = ProblemLocationKind.Location;\n        }\n        return this.validateProblemPattern(result) ? result : null;\n    };\n    ProblemPatternParser.prototype.doCreateSingleProblemPattern = function (value, setDefaults) {\n        var regexp = this.createRegularExpression(value.regexp);\n        if (regexp === undefined) {\n            return undefined;\n        }\n        var result = { regexp: regexp };\n        if (value.kind) {\n            result.kind = ProblemLocationKind.fromString(value.kind);\n        }\n        function copyProperty(result, source, resultKey, sourceKey) {\n            var value = source[sourceKey];\n            if (typeof value === 'number') {\n                result[resultKey] = value;\n            }\n        }\n        copyProperty(result, value, 'file', 'file');\n        copyProperty(result, value, 'location', 'location');\n        copyProperty(result, value, 'line', 'line');\n        copyProperty(result, value, 'character', 'column');\n        copyProperty(result, value, 'endLine', 'endLine');\n        copyProperty(result, value, 'endCharacter', 'endColumn');\n        copyProperty(result, value, 'severity', 'severity');\n        copyProperty(result, value, 'code', 'code');\n        copyProperty(result, value, 'message', 'message');\n        if (value.loop === true || value.loop === false) {\n            result.loop = value.loop;\n        }\n        if (setDefaults) {\n            if (result.location || result.kind === ProblemLocationKind.File) {\n                var defaultValue = {\n                    file: 1,\n                    message: 0\n                };\n                result = Objects.mixin(result, defaultValue, false);\n            }\n            else {\n                var defaultValue = {\n                    file: 1,\n                    line: 2,\n                    character: 3,\n                    message: 0\n                };\n                result = Objects.mixin(result, defaultValue, false);\n            }\n        }\n        return result;\n    };\n    ProblemPatternParser.prototype.validateProblemPattern = function (values) {\n        var _this = this;\n        var file = false, message = false, location = false, line = false;\n        var locationKind = (values[0].kind === undefined) ? ProblemLocationKind.Location : values[0].kind;\n        values.forEach(function (pattern, i) {\n            if (i !== 0 && pattern.kind) {\n                _this.error(nls_1.localize('ProblemPatternParser.problemPattern.kindProperty.notFirst', 'The problem pattern is invalid. The kind property must be provided only in the first element'));\n            }\n            file = file || !Types.isUndefined(pattern.file);\n            message = message || !Types.isUndefined(pattern.message);\n            location = location || !Types.isUndefined(pattern.location);\n            line = line || !Types.isUndefined(pattern.line);\n        });\n        if (!(file && message)) {\n            this.error(nls_1.localize('ProblemPatternParser.problemPattern.missingProperty', 'The problem pattern is invalid. It must have at least have a file and a message.'));\n            return false;\n        }\n        if (locationKind === ProblemLocationKind.Location && !(location || line)) {\n            this.error(nls_1.localize('ProblemPatternParser.problemPattern.missingLocation', 'The problem pattern is invalid. It must either have kind: \"file\" or have a line or location match group.'));\n            return false;\n        }\n        return true;\n    };\n    ProblemPatternParser.prototype.createRegularExpression = function (value) {\n        var result;\n        try {\n            result = new RegExp(value);\n        }\n        catch (err) {\n            this.error(nls_1.localize('ProblemPatternParser.invalidRegexp', 'Error: The string {0} is not a valid regular expression.\\n', value));\n        }\n        return result;\n    };\n    return ProblemPatternParser;\n}(parsers_1.Parser));\nexports.ProblemPatternParser = ProblemPatternParser;\nvar ExtensionRegistryReporter = /** @class */ (function () {\n    function ExtensionRegistryReporter(_collector, _validationStatus) {\n        if (_validationStatus === void 0) { _validationStatus = new parsers_1.ValidationStatus(); }\n        this._collector = _collector;\n        this._validationStatus = _validationStatus;\n    }\n    ExtensionRegistryReporter.prototype.info = function (message) {\n        this._validationStatus.state = parsers_1.ValidationState.Info;\n        this._collector.info(message);\n    };\n    ExtensionRegistryReporter.prototype.warn = function (message) {\n        this._validationStatus.state = parsers_1.ValidationState.Warning;\n        this._collector.warn(message);\n    };\n    ExtensionRegistryReporter.prototype.error = function (message) {\n        this._validationStatus.state = parsers_1.ValidationState.Error;\n        this._collector.error(message);\n    };\n    ExtensionRegistryReporter.prototype.fatal = function (message) {\n        this._validationStatus.state = parsers_1.ValidationState.Fatal;\n        this._collector.error(message);\n    };\n    Object.defineProperty(ExtensionRegistryReporter.prototype, \"status\", {\n        get: function () {\n            return this._validationStatus;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return ExtensionRegistryReporter;\n}());\nexports.ExtensionRegistryReporter = ExtensionRegistryReporter;\nvar Schemas;\n(function (Schemas) {\n    Schemas.ProblemPattern = {\n        default: {\n            regexp: '^([^\\\\\\\\s].*)\\\\\\\\((\\\\\\\\d+,\\\\\\\\d+)\\\\\\\\):\\\\\\\\s*(.*)$',\n            file: 1,\n            location: 2,\n            message: 3\n        },\n        type: 'object',\n        additionalProperties: false,\n        properties: {\n            regexp: {\n                type: 'string',\n                description: nls_1.localize('ProblemPatternSchema.regexp', 'The regular expression to find an error, warning or info in the output.')\n            },\n            kind: {\n                type: 'string',\n                description: nls_1.localize('ProblemPatternSchema.kind', 'whether the pattern matches a location (file and line) or only a file.')\n            },\n            file: {\n                type: 'integer',\n                description: nls_1.localize('ProblemPatternSchema.file', 'The match group index of the filename. If omitted 1 is used.')\n            },\n            location: {\n                type: 'integer',\n                description: nls_1.localize('ProblemPatternSchema.location', 'The match group index of the problem\\'s location. Valid location patterns are: (line), (line,column) and (startLine,startColumn,endLine,endColumn). If omitted (line,column) is assumed.')\n            },\n            line: {\n                type: 'integer',\n                description: nls_1.localize('ProblemPatternSchema.line', 'The match group index of the problem\\'s line. Defaults to 2')\n            },\n            column: {\n                type: 'integer',\n                description: nls_1.localize('ProblemPatternSchema.column', 'The match group index of the problem\\'s line character. Defaults to 3')\n            },\n            endLine: {\n                type: 'integer',\n                description: nls_1.localize('ProblemPatternSchema.endLine', 'The match group index of the problem\\'s end line. Defaults to undefined')\n            },\n            endColumn: {\n                type: 'integer',\n                description: nls_1.localize('ProblemPatternSchema.endColumn', 'The match group index of the problem\\'s end line character. Defaults to undefined')\n            },\n            severity: {\n                type: 'integer',\n                description: nls_1.localize('ProblemPatternSchema.severity', 'The match group index of the problem\\'s severity. Defaults to undefined')\n            },\n            code: {\n                type: 'integer',\n                description: nls_1.localize('ProblemPatternSchema.code', 'The match group index of the problem\\'s code. Defaults to undefined')\n            },\n            message: {\n                type: 'integer',\n                description: nls_1.localize('ProblemPatternSchema.message', 'The match group index of the message. If omitted it defaults to 4 if location is specified. Otherwise it defaults to 5.')\n            },\n            loop: {\n                type: 'boolean',\n                description: nls_1.localize('ProblemPatternSchema.loop', 'In a multi line matcher loop indicated whether this pattern is executed in a loop as long as it matches. Can only specified on a last pattern in a multi line pattern.')\n            }\n        }\n    };\n    Schemas.NamedProblemPattern = Objects.deepClone(Schemas.ProblemPattern);\n    Schemas.NamedProblemPattern.properties = Objects.deepClone(Schemas.NamedProblemPattern.properties) || {};\n    Schemas.NamedProblemPattern.properties['name'] = {\n        type: 'string',\n        description: nls_1.localize('NamedProblemPatternSchema.name', 'The name of the problem pattern.')\n    };\n    Schemas.MultiLineProblemPattern = {\n        type: 'array',\n        items: Schemas.ProblemPattern\n    };\n    Schemas.NamedMultiLineProblemPattern = {\n        type: 'object',\n        additionalProperties: false,\n        properties: {\n            name: {\n                type: 'string',\n                description: nls_1.localize('NamedMultiLineProblemPatternSchema.name', 'The name of the problem multi line problem pattern.')\n            },\n            patterns: {\n                type: 'array',\n                description: nls_1.localize('NamedMultiLineProblemPatternSchema.patterns', 'The actual patterns.'),\n                items: Schemas.ProblemPattern\n            }\n        }\n    };\n})(Schemas = exports.Schemas || (exports.Schemas = {}));\nvar problemPatternExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint({\n    extensionPoint: 'problemPatterns',\n    jsonSchema: {\n        description: nls_1.localize('ProblemPatternExtPoint', 'Contributes problem patterns'),\n        type: 'array',\n        items: {\n            anyOf: [\n                Schemas.NamedProblemPattern,\n                Schemas.NamedMultiLineProblemPattern\n            ]\n        }\n    }\n});\nvar ProblemPatternRegistryImpl = /** @class */ (function () {\n    function ProblemPatternRegistryImpl() {\n        var _this = this;\n        this.patterns = Object.create(null);\n        this.fillDefaults();\n        this.readyPromise = new Promise(function (resolve, reject) {\n            problemPatternExtPoint.setHandler(function (extensions, delta) {\n                // We get all statically know extension during startup in one batch\n                try {\n                    delta.removed.forEach(function (extension) {\n                        var problemPatterns = extension.value;\n                        for (var _i = 0, problemPatterns_1 = problemPatterns; _i < problemPatterns_1.length; _i++) {\n                            var pattern = problemPatterns_1[_i];\n                            if (_this.patterns[pattern.name]) {\n                                delete _this.patterns[pattern.name];\n                            }\n                        }\n                    });\n                    delta.added.forEach(function (extension) {\n                        var problemPatterns = extension.value;\n                        var parser = new ProblemPatternParser(new ExtensionRegistryReporter(extension.collector));\n                        for (var _i = 0, problemPatterns_2 = problemPatterns; _i < problemPatterns_2.length; _i++) {\n                            var pattern = problemPatterns_2[_i];\n                            if (Config.NamedMultiLineCheckedProblemPattern.is(pattern)) {\n                                var result = parser.parse(pattern);\n                                if (parser.problemReporter.status.state < parsers_1.ValidationState.Error) {\n                                    _this.add(result.name, result.patterns);\n                                }\n                                else {\n                                    extension.collector.error(nls_1.localize('ProblemPatternRegistry.error', 'Invalid problem pattern. The pattern will be ignored.'));\n                                    extension.collector.error(JSON.stringify(pattern, undefined, 4));\n                                }\n                            }\n                            else if (Config.NamedProblemPattern.is(pattern)) {\n                                var result = parser.parse(pattern);\n                                if (parser.problemReporter.status.state < parsers_1.ValidationState.Error) {\n                                    _this.add(pattern.name, result);\n                                }\n                                else {\n                                    extension.collector.error(nls_1.localize('ProblemPatternRegistry.error', 'Invalid problem pattern. The pattern will be ignored.'));\n                                    extension.collector.error(JSON.stringify(pattern, undefined, 4));\n                                }\n                            }\n                            parser.reset();\n                        }\n                    });\n                }\n                catch (error) {\n                    // Do nothing\n                }\n                resolve(undefined);\n            });\n        });\n    }\n    ProblemPatternRegistryImpl.prototype.onReady = function () {\n        return this.readyPromise;\n    };\n    ProblemPatternRegistryImpl.prototype.add = function (key, value) {\n        this.patterns[key] = value;\n    };\n    ProblemPatternRegistryImpl.prototype.get = function (key) {\n        return this.patterns[key];\n    };\n    ProblemPatternRegistryImpl.prototype.fillDefaults = function () {\n        this.add('msCompile', {\n            regexp: /^(?:\\s+\\d+\\>)?([^\\s].*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\)\\s*:\\s+(error|warning|info)\\s+(\\w{1,2}\\d+)\\s*:\\s*(.*)$/,\n            kind: ProblemLocationKind.Location,\n            file: 1,\n            location: 2,\n            severity: 3,\n            code: 4,\n            message: 5\n        });\n        this.add('gulp-tsc', {\n            regexp: /^([^\\s].*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\):\\s+(\\d+)\\s+(.*)$/,\n            kind: ProblemLocationKind.Location,\n            file: 1,\n            location: 2,\n            code: 3,\n            message: 4\n        });\n        this.add('cpp', {\n            regexp: /^([^\\s].*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\):\\s+(error|warning|info)\\s+(C\\d+)\\s*:\\s*(.*)$/,\n            kind: ProblemLocationKind.Location,\n            file: 1,\n            location: 2,\n            severity: 3,\n            code: 4,\n            message: 5\n        });\n        this.add('csc', {\n            regexp: /^([^\\s].*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\):\\s+(error|warning|info)\\s+(CS\\d+)\\s*:\\s*(.*)$/,\n            kind: ProblemLocationKind.Location,\n            file: 1,\n            location: 2,\n            severity: 3,\n            code: 4,\n            message: 5\n        });\n        this.add('vb', {\n            regexp: /^([^\\s].*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\):\\s+(error|warning|info)\\s+(BC\\d+)\\s*:\\s*(.*)$/,\n            kind: ProblemLocationKind.Location,\n            file: 1,\n            location: 2,\n            severity: 3,\n            code: 4,\n            message: 5\n        });\n        this.add('lessCompile', {\n            regexp: /^\\s*(.*) in file (.*) line no. (\\d+)$/,\n            kind: ProblemLocationKind.Location,\n            message: 1,\n            file: 2,\n            line: 3\n        });\n        this.add('jshint', {\n            regexp: /^(.*):\\s+line\\s+(\\d+),\\s+col\\s+(\\d+),\\s(.+?)(?:\\s+\\((\\w)(\\d+)\\))?$/,\n            kind: ProblemLocationKind.Location,\n            file: 1,\n            line: 2,\n            character: 3,\n            message: 4,\n            severity: 5,\n            code: 6\n        });\n        this.add('jshint-stylish', [\n            {\n                regexp: /^(.+)$/,\n                kind: ProblemLocationKind.Location,\n                file: 1\n            },\n            {\n                regexp: /^\\s+line\\s+(\\d+)\\s+col\\s+(\\d+)\\s+(.+?)(?:\\s+\\((\\w)(\\d+)\\))?$/,\n                line: 1,\n                character: 2,\n                message: 3,\n                severity: 4,\n                code: 5,\n                loop: true\n            }\n        ]);\n        this.add('eslint-compact', {\n            regexp: /^(.+):\\sline\\s(\\d+),\\scol\\s(\\d+),\\s(Error|Warning|Info)\\s-\\s(.+)\\s\\((.+)\\)$/,\n            file: 1,\n            kind: ProblemLocationKind.Location,\n            line: 2,\n            character: 3,\n            severity: 4,\n            message: 5,\n            code: 6\n        });\n        this.add('eslint-stylish', [\n            {\n                regexp: /^([^\\s].*)$/,\n                kind: ProblemLocationKind.Location,\n                file: 1\n            },\n            {\n                regexp: /^\\s+(\\d+):(\\d+)\\s+(error|warning|info)\\s+(.+?)(?:\\s\\s+(.*))?$/,\n                line: 1,\n                character: 2,\n                severity: 3,\n                message: 4,\n                code: 5,\n                loop: true\n            }\n        ]);\n        this.add('go', {\n            regexp: /^([^:]*: )?((.:)?[^:]*):(\\d+)(:(\\d+))?: (.*)$/,\n            kind: ProblemLocationKind.Location,\n            file: 2,\n            line: 4,\n            character: 6,\n            message: 7\n        });\n    };\n    return ProblemPatternRegistryImpl;\n}());\nexports.ProblemPatternRegistry = new ProblemPatternRegistryImpl();\nvar ProblemMatcherParser = /** @class */ (function (_super) {\n    tslib_1.__extends(ProblemMatcherParser, _super);\n    function ProblemMatcherParser(logger) {\n        return _super.call(this, logger) || this;\n    }\n    ProblemMatcherParser.prototype.parse = function (json) {\n        var result = this.createProblemMatcher(json);\n        if (!this.checkProblemMatcherValid(json, result)) {\n            return undefined;\n        }\n        this.addWatchingMatcher(json, result);\n        return result;\n    };\n    ProblemMatcherParser.prototype.checkProblemMatcherValid = function (externalProblemMatcher, problemMatcher) {\n        if (!problemMatcher) {\n            this.error(nls_1.localize('ProblemMatcherParser.noProblemMatcher', 'Error: the description can\\'t be converted into a problem matcher:\\n{0}\\n', JSON.stringify(externalProblemMatcher, null, 4)));\n            return false;\n        }\n        if (!problemMatcher.pattern) {\n            this.error(nls_1.localize('ProblemMatcherParser.noProblemPattern', 'Error: the description doesn\\'t define a valid problem pattern:\\n{0}\\n', JSON.stringify(externalProblemMatcher, null, 4)));\n            return false;\n        }\n        if (!problemMatcher.owner) {\n            this.error(nls_1.localize('ProblemMatcherParser.noOwner', 'Error: the description doesn\\'t define an owner:\\n{0}\\n', JSON.stringify(externalProblemMatcher, null, 4)));\n            return false;\n        }\n        if (Types.isUndefined(problemMatcher.fileLocation)) {\n            this.error(nls_1.localize('ProblemMatcherParser.noFileLocation', 'Error: the description doesn\\'t define a file location:\\n{0}\\n', JSON.stringify(externalProblemMatcher, null, 4)));\n            return false;\n        }\n        return true;\n    };\n    ProblemMatcherParser.prototype.createProblemMatcher = function (description) {\n        var result = null;\n        var owner = Types.isString(description.owner) ? description.owner : UUID.generateUuid();\n        var source = Types.isString(description.source) ? description.source : undefined;\n        var applyTo = Types.isString(description.applyTo) ? ApplyToKind.fromString(description.applyTo) : ApplyToKind.allDocuments;\n        if (!applyTo) {\n            applyTo = ApplyToKind.allDocuments;\n        }\n        var fileLocation = undefined;\n        var filePrefix = undefined;\n        var kind;\n        if (Types.isUndefined(description.fileLocation)) {\n            fileLocation = FileLocationKind.Relative;\n            filePrefix = '${workspaceFolder}';\n        }\n        else if (Types.isString(description.fileLocation)) {\n            kind = FileLocationKind.fromString(description.fileLocation);\n            if (kind) {\n                fileLocation = kind;\n                if (kind === FileLocationKind.Relative) {\n                    filePrefix = '${workspaceFolder}';\n                }\n            }\n        }\n        else if (Types.isStringArray(description.fileLocation)) {\n            var values = description.fileLocation;\n            if (values.length > 0) {\n                kind = FileLocationKind.fromString(values[0]);\n                if (values.length === 1 && kind === FileLocationKind.Absolute) {\n                    fileLocation = kind;\n                }\n                else if (values.length === 2 && kind === FileLocationKind.Relative && values[1]) {\n                    fileLocation = kind;\n                    filePrefix = values[1];\n                }\n            }\n        }\n        var pattern = description.pattern ? this.createProblemPattern(description.pattern) : undefined;\n        var severity = description.severity ? severity_1.default.fromValue(description.severity) : undefined;\n        if (severity === severity_1.default.Ignore) {\n            this.info(nls_1.localize('ProblemMatcherParser.unknownSeverity', 'Info: unknown severity {0}. Valid values are error, warning and info.\\n', description.severity));\n            severity = severity_1.default.Error;\n        }\n        if (Types.isString(description.base)) {\n            var variableName = description.base;\n            if (variableName.length > 1 && variableName[0] === '$') {\n                var base = exports.ProblemMatcherRegistry.get(variableName.substring(1));\n                if (base) {\n                    result = Objects.deepClone(base);\n                    if (description.owner !== undefined && owner !== undefined) {\n                        result.owner = owner;\n                    }\n                    if (description.source !== undefined && source !== undefined) {\n                        result.source = source;\n                    }\n                    if (description.fileLocation !== undefined && fileLocation !== undefined) {\n                        result.fileLocation = fileLocation;\n                        result.filePrefix = filePrefix;\n                    }\n                    if (description.pattern !== undefined && pattern !== undefined && pattern !== null) {\n                        result.pattern = pattern;\n                    }\n                    if (description.severity !== undefined && severity !== undefined) {\n                        result.severity = severity;\n                    }\n                    if (description.applyTo !== undefined && applyTo !== undefined) {\n                        result.applyTo = applyTo;\n                    }\n                }\n            }\n        }\n        else if (fileLocation && pattern) {\n            result = {\n                owner: owner,\n                applyTo: applyTo,\n                fileLocation: fileLocation,\n                pattern: pattern,\n            };\n            if (source) {\n                result.source = source;\n            }\n            if (filePrefix) {\n                result.filePrefix = filePrefix;\n            }\n            if (severity) {\n                result.severity = severity;\n            }\n        }\n        if (Config.isNamedProblemMatcher(description)) {\n            result.name = description.name;\n            result.label = Types.isString(description.label) ? description.label : description.name;\n        }\n        return result;\n    };\n    ProblemMatcherParser.prototype.createProblemPattern = function (value) {\n        if (Types.isString(value)) {\n            var variableName = value;\n            if (variableName.length > 1 && variableName[0] === '$') {\n                var result = exports.ProblemPatternRegistry.get(variableName.substring(1));\n                if (!result) {\n                    this.error(nls_1.localize('ProblemMatcherParser.noDefinedPatter', 'Error: the pattern with the identifier {0} doesn\\'t exist.', variableName));\n                }\n                return result;\n            }\n            else {\n                if (variableName.length === 0) {\n                    this.error(nls_1.localize('ProblemMatcherParser.noIdentifier', 'Error: the pattern property refers to an empty identifier.'));\n                }\n                else {\n                    this.error(nls_1.localize('ProblemMatcherParser.noValidIdentifier', 'Error: the pattern property {0} is not a valid pattern variable name.', variableName));\n                }\n            }\n        }\n        else if (value) {\n            var problemPatternParser = new ProblemPatternParser(this.problemReporter);\n            if (Array.isArray(value)) {\n                return problemPatternParser.parse(value);\n            }\n            else {\n                return problemPatternParser.parse(value);\n            }\n        }\n        return null;\n    };\n    ProblemMatcherParser.prototype.addWatchingMatcher = function (external, internal) {\n        var oldBegins = this.createRegularExpression(external.watchedTaskBeginsRegExp);\n        var oldEnds = this.createRegularExpression(external.watchedTaskEndsRegExp);\n        if (oldBegins && oldEnds) {\n            internal.watching = {\n                activeOnStart: false,\n                beginsPattern: { regexp: oldBegins },\n                endsPattern: { regexp: oldEnds }\n            };\n            return;\n        }\n        var backgroundMonitor = external.background || external.watching;\n        if (Types.isUndefinedOrNull(backgroundMonitor)) {\n            return;\n        }\n        var begins = this.createWatchingPattern(backgroundMonitor.beginsPattern);\n        var ends = this.createWatchingPattern(backgroundMonitor.endsPattern);\n        if (begins && ends) {\n            internal.watching = {\n                activeOnStart: Types.isBoolean(backgroundMonitor.activeOnStart) ? backgroundMonitor.activeOnStart : false,\n                beginsPattern: begins,\n                endsPattern: ends\n            };\n            return;\n        }\n        if (begins || ends) {\n            this.error(nls_1.localize('ProblemMatcherParser.problemPattern.watchingMatcher', 'A problem matcher must define both a begin pattern and an end pattern for watching.'));\n        }\n    };\n    ProblemMatcherParser.prototype.createWatchingPattern = function (external) {\n        if (Types.isUndefinedOrNull(external)) {\n            return null;\n        }\n        var regexp;\n        var file;\n        if (Types.isString(external)) {\n            regexp = this.createRegularExpression(external);\n        }\n        else {\n            regexp = this.createRegularExpression(external.regexp);\n            if (Types.isNumber(external.file)) {\n                file = external.file;\n            }\n        }\n        if (!regexp) {\n            return null;\n        }\n        return file ? { regexp: regexp, file: file } : { regexp: regexp, file: 1 };\n    };\n    ProblemMatcherParser.prototype.createRegularExpression = function (value) {\n        var result = null;\n        if (!value) {\n            return result;\n        }\n        try {\n            result = new RegExp(value);\n        }\n        catch (err) {\n            this.error(nls_1.localize('ProblemMatcherParser.invalidRegexp', 'Error: The string {0} is not a valid regular expression.\\n', value));\n        }\n        return result;\n    };\n    return ProblemMatcherParser;\n}(parsers_1.Parser));\nexports.ProblemMatcherParser = ProblemMatcherParser;\n(function (Schemas) {\n    Schemas.WatchingPattern = {\n        type: 'object',\n        additionalProperties: false,\n        properties: {\n            regexp: {\n                type: 'string',\n                description: nls_1.localize('WatchingPatternSchema.regexp', 'The regular expression to detect the begin or end of a background task.')\n            },\n            file: {\n                type: 'integer',\n                description: nls_1.localize('WatchingPatternSchema.file', 'The match group index of the filename. Can be omitted.')\n            },\n        }\n    };\n    Schemas.PatternType = {\n        anyOf: [\n            {\n                type: 'string',\n                description: nls_1.localize('PatternTypeSchema.name', 'The name of a contributed or predefined pattern')\n            },\n            Schemas.ProblemPattern,\n            Schemas.MultiLineProblemPattern\n        ],\n        description: nls_1.localize('PatternTypeSchema.description', 'A problem pattern or the name of a contributed or predefined problem pattern. Can be omitted if base is specified.')\n    };\n    Schemas.ProblemMatcher = {\n        type: 'object',\n        additionalProperties: false,\n        properties: {\n            base: {\n                type: 'string',\n                description: nls_1.localize('ProblemMatcherSchema.base', 'The name of a base problem matcher to use.')\n            },\n            owner: {\n                type: 'string',\n                description: nls_1.localize('ProblemMatcherSchema.owner', 'The owner of the problem inside Code. Can be omitted if base is specified. Defaults to \\'external\\' if omitted and base is not specified.')\n            },\n            source: {\n                type: 'string',\n                description: nls_1.localize('ProblemMatcherSchema.source', 'A human-readable string describing the source of this diagnostic, e.g. \\'typescript\\' or \\'super lint\\'.')\n            },\n            severity: {\n                type: 'string',\n                enum: ['error', 'warning', 'info'],\n                description: nls_1.localize('ProblemMatcherSchema.severity', 'The default severity for captures problems. Is used if the pattern doesn\\'t define a match group for severity.')\n            },\n            applyTo: {\n                type: 'string',\n                enum: ['allDocuments', 'openDocuments', 'closedDocuments'],\n                description: nls_1.localize('ProblemMatcherSchema.applyTo', 'Controls if a problem reported on a text document is applied only to open, closed or all documents.')\n            },\n            pattern: Schemas.PatternType,\n            fileLocation: {\n                oneOf: [\n                    {\n                        type: 'string',\n                        enum: ['absolute', 'relative']\n                    },\n                    {\n                        type: 'array',\n                        items: {\n                            type: 'string'\n                        }\n                    }\n                ],\n                description: nls_1.localize('ProblemMatcherSchema.fileLocation', 'Defines how file names reported in a problem pattern should be interpreted.')\n            },\n            background: {\n                type: 'object',\n                additionalProperties: false,\n                description: nls_1.localize('ProblemMatcherSchema.background', 'Patterns to track the begin and end of a matcher active on a background task.'),\n                properties: {\n                    activeOnStart: {\n                        type: 'boolean',\n                        description: nls_1.localize('ProblemMatcherSchema.background.activeOnStart', 'If set to true the background monitor is in active mode when the task starts. This is equals of issuing a line that matches the beginPattern')\n                    },\n                    beginsPattern: {\n                        oneOf: [\n                            {\n                                type: 'string'\n                            },\n                            Schemas.WatchingPattern\n                        ],\n                        description: nls_1.localize('ProblemMatcherSchema.background.beginsPattern', 'If matched in the output the start of a background task is signaled.')\n                    },\n                    endsPattern: {\n                        oneOf: [\n                            {\n                                type: 'string'\n                            },\n                            Schemas.WatchingPattern\n                        ],\n                        description: nls_1.localize('ProblemMatcherSchema.background.endsPattern', 'If matched in the output the end of a background task is signaled.')\n                    }\n                }\n            },\n            watching: {\n                type: 'object',\n                additionalProperties: false,\n                deprecationMessage: nls_1.localize('ProblemMatcherSchema.watching.deprecated', 'The watching property is deprecated. Use background instead.'),\n                description: nls_1.localize('ProblemMatcherSchema.watching', 'Patterns to track the begin and end of a watching matcher.'),\n                properties: {\n                    activeOnStart: {\n                        type: 'boolean',\n                        description: nls_1.localize('ProblemMatcherSchema.watching.activeOnStart', 'If set to true the watcher is in active mode when the task starts. This is equals of issuing a line that matches the beginPattern')\n                    },\n                    beginsPattern: {\n                        oneOf: [\n                            {\n                                type: 'string'\n                            },\n                            Schemas.WatchingPattern\n                        ],\n                        description: nls_1.localize('ProblemMatcherSchema.watching.beginsPattern', 'If matched in the output the start of a watching task is signaled.')\n                    },\n                    endsPattern: {\n                        oneOf: [\n                            {\n                                type: 'string'\n                            },\n                            Schemas.WatchingPattern\n                        ],\n                        description: nls_1.localize('ProblemMatcherSchema.watching.endsPattern', 'If matched in the output the end of a watching task is signaled.')\n                    }\n                }\n            }\n        }\n    };\n    Schemas.LegacyProblemMatcher = Objects.deepClone(Schemas.ProblemMatcher);\n    Schemas.LegacyProblemMatcher.properties = Objects.deepClone(Schemas.LegacyProblemMatcher.properties) || {};\n    Schemas.LegacyProblemMatcher.properties['watchedTaskBeginsRegExp'] = {\n        type: 'string',\n        deprecationMessage: nls_1.localize('LegacyProblemMatcherSchema.watchedBegin.deprecated', 'This property is deprecated. Use the watching property instead.'),\n        description: nls_1.localize('LegacyProblemMatcherSchema.watchedBegin', 'A regular expression signaling that a watched tasks begins executing triggered through file watching.')\n    };\n    Schemas.LegacyProblemMatcher.properties['watchedTaskEndsRegExp'] = {\n        type: 'string',\n        deprecationMessage: nls_1.localize('LegacyProblemMatcherSchema.watchedEnd.deprecated', 'This property is deprecated. Use the watching property instead.'),\n        description: nls_1.localize('LegacyProblemMatcherSchema.watchedEnd', 'A regular expression signaling that a watched tasks ends executing.')\n    };\n    Schemas.NamedProblemMatcher = Objects.deepClone(Schemas.ProblemMatcher);\n    Schemas.NamedProblemMatcher.properties = Objects.deepClone(Schemas.NamedProblemMatcher.properties) || {};\n    Schemas.NamedProblemMatcher.properties.name = {\n        type: 'string',\n        description: nls_1.localize('NamedProblemMatcherSchema.name', 'The name of the problem matcher used to refer to it.')\n    };\n    Schemas.NamedProblemMatcher.properties.label = {\n        type: 'string',\n        description: nls_1.localize('NamedProblemMatcherSchema.label', 'A human readable label of the problem matcher.')\n    };\n})(Schemas = exports.Schemas || (exports.Schemas = {}));\nvar problemMatchersExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint({\n    extensionPoint: 'problemMatchers',\n    deps: [problemPatternExtPoint],\n    jsonSchema: {\n        description: nls_1.localize('ProblemMatcherExtPoint', 'Contributes problem matchers'),\n        type: 'array',\n        items: Schemas.NamedProblemMatcher\n    }\n});\nvar ProblemMatcherRegistryImpl = /** @class */ (function () {\n    function ProblemMatcherRegistryImpl() {\n        var _this = this;\n        this._onMatchersChanged = new event_1.Emitter();\n        this.matchers = Object.create(null);\n        this.fillDefaults();\n        this.readyPromise = new Promise(function (resolve, reject) {\n            problemMatchersExtPoint.setHandler(function (extensions, delta) {\n                try {\n                    delta.removed.forEach(function (extension) {\n                        var problemMatchers = extension.value;\n                        for (var _i = 0, problemMatchers_1 = problemMatchers; _i < problemMatchers_1.length; _i++) {\n                            var matcher_1 = problemMatchers_1[_i];\n                            if (_this.matchers[matcher_1.name]) {\n                                delete _this.matchers[matcher_1.name];\n                            }\n                        }\n                    });\n                    delta.added.forEach(function (extension) {\n                        var problemMatchers = extension.value;\n                        var parser = new ProblemMatcherParser(new ExtensionRegistryReporter(extension.collector));\n                        for (var _i = 0, problemMatchers_2 = problemMatchers; _i < problemMatchers_2.length; _i++) {\n                            var matcher_2 = problemMatchers_2[_i];\n                            var result = parser.parse(matcher_2);\n                            if (result && isNamedProblemMatcher(result)) {\n                                _this.add(result);\n                            }\n                        }\n                    });\n                    if ((delta.removed.length > 0) || (delta.added.length > 0)) {\n                        _this._onMatchersChanged.fire();\n                    }\n                }\n                catch (error) {\n                }\n                var matcher = _this.get('tsc-watch');\n                if (matcher) {\n                    matcher.tscWatch = true;\n                }\n                resolve(undefined);\n            });\n        });\n    }\n    Object.defineProperty(ProblemMatcherRegistryImpl.prototype, \"onMatcherChanged\", {\n        get: function () { return this._onMatchersChanged.event; },\n        enumerable: true,\n        configurable: true\n    });\n    ProblemMatcherRegistryImpl.prototype.onReady = function () {\n        exports.ProblemPatternRegistry.onReady();\n        return this.readyPromise;\n    };\n    ProblemMatcherRegistryImpl.prototype.add = function (matcher) {\n        this.matchers[matcher.name] = matcher;\n    };\n    ProblemMatcherRegistryImpl.prototype.get = function (name) {\n        return this.matchers[name];\n    };\n    ProblemMatcherRegistryImpl.prototype.keys = function () {\n        return Object.keys(this.matchers);\n    };\n    ProblemMatcherRegistryImpl.prototype.fillDefaults = function () {\n        this.add({\n            name: 'msCompile',\n            label: nls_1.localize('msCompile', 'Microsoft compiler problems'),\n            owner: 'msCompile',\n            applyTo: ApplyToKind.allDocuments,\n            fileLocation: FileLocationKind.Absolute,\n            pattern: exports.ProblemPatternRegistry.get('msCompile')\n        });\n        this.add({\n            name: 'lessCompile',\n            label: nls_1.localize('lessCompile', 'Less problems'),\n            deprecated: true,\n            owner: 'lessCompile',\n            source: 'less',\n            applyTo: ApplyToKind.allDocuments,\n            fileLocation: FileLocationKind.Absolute,\n            pattern: exports.ProblemPatternRegistry.get('lessCompile'),\n            severity: severity_1.default.Error\n        });\n        this.add({\n            name: 'gulp-tsc',\n            label: nls_1.localize('gulp-tsc', 'Gulp TSC Problems'),\n            owner: 'typescript',\n            source: 'ts',\n            applyTo: ApplyToKind.closedDocuments,\n            fileLocation: FileLocationKind.Relative,\n            filePrefix: '${workspaceFolder}',\n            pattern: exports.ProblemPatternRegistry.get('gulp-tsc')\n        });\n        this.add({\n            name: 'jshint',\n            label: nls_1.localize('jshint', 'JSHint problems'),\n            owner: 'jshint',\n            source: 'jshint',\n            applyTo: ApplyToKind.allDocuments,\n            fileLocation: FileLocationKind.Absolute,\n            pattern: exports.ProblemPatternRegistry.get('jshint')\n        });\n        this.add({\n            name: 'jshint-stylish',\n            label: nls_1.localize('jshint-stylish', 'JSHint stylish problems'),\n            owner: 'jshint',\n            source: 'jshint',\n            applyTo: ApplyToKind.allDocuments,\n            fileLocation: FileLocationKind.Absolute,\n            pattern: exports.ProblemPatternRegistry.get('jshint-stylish')\n        });\n        this.add({\n            name: 'eslint-compact',\n            label: nls_1.localize('eslint-compact', 'ESLint compact problems'),\n            owner: 'eslint',\n            source: 'eslint',\n            applyTo: ApplyToKind.allDocuments,\n            fileLocation: FileLocationKind.Absolute,\n            filePrefix: '${workspaceFolder}',\n            pattern: exports.ProblemPatternRegistry.get('eslint-compact')\n        });\n        this.add({\n            name: 'eslint-stylish',\n            label: nls_1.localize('eslint-stylish', 'ESLint stylish problems'),\n            owner: 'eslint',\n            source: 'eslint',\n            applyTo: ApplyToKind.allDocuments,\n            fileLocation: FileLocationKind.Absolute,\n            pattern: exports.ProblemPatternRegistry.get('eslint-stylish')\n        });\n        this.add({\n            name: 'go',\n            label: nls_1.localize('go', 'Go problems'),\n            owner: 'go',\n            source: 'go',\n            applyTo: ApplyToKind.allDocuments,\n            fileLocation: FileLocationKind.Relative,\n            filePrefix: '${workspaceFolder}',\n            pattern: exports.ProblemPatternRegistry.get('go')\n        });\n    };\n    return ProblemMatcherRegistryImpl;\n}());\nexports.ProblemMatcherRegistry = new ProblemMatcherRegistryImpl();\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/common/problemMatcher.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/common/problemMatcher.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from 'vs/nls';\n\nimport * as Objects from 'vs/base/common/objects';\nimport * as Strings from 'vs/base/common/strings';\nimport * as Assert from 'vs/base/common/assert';\nimport { join } from 'vs/base/common/path';\nimport * as Types from 'vs/base/common/types';\nimport * as UUID from 'vs/base/common/uuid';\nimport * as Platform from 'vs/base/common/platform';\nimport Severity from 'vs/base/common/severity';\nimport { URI } from 'vs/base/common/uri';\nimport { IJSONSchema } from 'vs/base/common/jsonSchema';\nimport { ValidationStatus, ValidationState, IProblemReporter, Parser } from 'vs/base/common/parsers';\nimport { IStringDictionary } from 'vs/base/common/collections';\n\nimport { IMarkerData, MarkerSeverity } from 'vs/platform/markers/common/markers';\nimport { ExtensionsRegistry, ExtensionMessageCollector } from 'vs/workbench/services/extensions/common/extensionsRegistry';\nimport { Event, Emitter } from 'vs/base/common/event';\n\nexport enum FileLocationKind {\n\tAuto,\n\tRelative,\n\tAbsolute\n}\n\nexport module FileLocationKind {\n\texport function fromString(value: string): FileLocationKind | undefined {\n\t\tvalue = value.toLowerCase();\n\t\tif (value === 'absolute') {\n\t\t\treturn FileLocationKind.Absolute;\n\t\t} else if (value === 'relative') {\n\t\t\treturn FileLocationKind.Relative;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nexport enum ProblemLocationKind {\n\tFile,\n\tLocation\n}\n\nexport module ProblemLocationKind {\n\texport function fromString(value: string): ProblemLocationKind | undefined {\n\t\tvalue = value.toLowerCase();\n\t\tif (value === 'file') {\n\t\t\treturn ProblemLocationKind.File;\n\t\t} else if (value === 'location') {\n\t\t\treturn ProblemLocationKind.Location;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nexport interface ProblemPattern {\n\tregexp: RegExp;\n\n\tkind?: ProblemLocationKind;\n\n\tfile?: number;\n\n\tmessage?: number;\n\n\tlocation?: number;\n\n\tline?: number;\n\n\tcharacter?: number;\n\n\tendLine?: number;\n\n\tendCharacter?: number;\n\n\tcode?: number;\n\n\tseverity?: number;\n\n\tloop?: boolean;\n}\n\nexport interface NamedProblemPattern extends ProblemPattern {\n\tname: string;\n}\n\nexport type MultiLineProblemPattern = ProblemPattern[];\n\nexport interface WatchingPattern {\n\tregexp: RegExp;\n\tfile?: number;\n}\n\nexport interface WatchingMatcher {\n\tactiveOnStart: boolean;\n\tbeginsPattern: WatchingPattern;\n\tendsPattern: WatchingPattern;\n}\n\nexport enum ApplyToKind {\n\tallDocuments,\n\topenDocuments,\n\tclosedDocuments\n}\n\nexport module ApplyToKind {\n\texport function fromString(value: string): ApplyToKind | undefined {\n\t\tvalue = value.toLowerCase();\n\t\tif (value === 'alldocuments') {\n\t\t\treturn ApplyToKind.allDocuments;\n\t\t} else if (value === 'opendocuments') {\n\t\t\treturn ApplyToKind.openDocuments;\n\t\t} else if (value === 'closeddocuments') {\n\t\t\treturn ApplyToKind.closedDocuments;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nexport interface ProblemMatcher {\n\towner: string;\n\tsource?: string;\n\tapplyTo: ApplyToKind;\n\tfileLocation: FileLocationKind;\n\tfilePrefix?: string;\n\tpattern: ProblemPattern | ProblemPattern[];\n\tseverity?: Severity;\n\twatching?: WatchingMatcher;\n\turiProvider?: (path: string) => URI;\n}\n\nexport interface NamedProblemMatcher extends ProblemMatcher {\n\tname: string;\n\tlabel: string;\n\tdeprecated?: boolean;\n}\n\nexport interface NamedMultiLineProblemPattern {\n\tname: string;\n\tlabel: string;\n\tpatterns: MultiLineProblemPattern;\n}\n\nexport function isNamedProblemMatcher(value: ProblemMatcher | undefined): value is NamedProblemMatcher {\n\treturn value && Types.isString((<NamedProblemMatcher>value).name) ? true : false;\n}\n\ninterface Location {\n\tstartLineNumber: number;\n\tstartCharacter: number;\n\tendLineNumber: number;\n\tendCharacter: number;\n}\n\ninterface ProblemData {\n\tkind?: ProblemLocationKind;\n\tfile?: string;\n\tlocation?: string;\n\tline?: string;\n\tcharacter?: string;\n\tendLine?: string;\n\tendCharacter?: string;\n\tmessage?: string;\n\tseverity?: string;\n\tcode?: string;\n}\n\nexport interface ProblemMatch {\n\tresource: URI;\n\tmarker: IMarkerData;\n\tdescription: ProblemMatcher;\n}\n\nexport interface HandleResult {\n\tmatch: ProblemMatch | null;\n\tcontinue: boolean;\n}\n\nexport function getResource(filename: string, matcher: ProblemMatcher): URI {\n\tlet kind = matcher.fileLocation;\n\tlet fullPath: string | undefined;\n\tif (kind === FileLocationKind.Absolute) {\n\t\tfullPath = filename;\n\t} else if ((kind === FileLocationKind.Relative) && matcher.filePrefix) {\n\t\tfullPath = join(matcher.filePrefix, filename);\n\t}\n\tif (fullPath === undefined) {\n\t\tthrow new Error('FileLocationKind is not actionable. Does the matcher have a filePrefix? This should never happen.');\n\t}\n\tfullPath = fullPath.replace(/\\\\/g, '/');\n\tif (fullPath[0] !== '/') {\n\t\tfullPath = '/' + fullPath;\n\t}\n\tif (matcher.uriProvider !== undefined) {\n\t\treturn matcher.uriProvider(fullPath);\n\t} else {\n\t\treturn URI.file(fullPath);\n\t}\n}\n\nexport interface ILineMatcher {\n\tmatchLength: number;\n\tnext(line: string): ProblemMatch | null;\n\thandle(lines: string[], start?: number): HandleResult;\n}\n\nexport function createLineMatcher(matcher: ProblemMatcher): ILineMatcher {\n\tlet pattern = matcher.pattern;\n\tif (Types.isArray(pattern)) {\n\t\treturn new MultiLineMatcher(matcher);\n\t} else {\n\t\treturn new SingleLineMatcher(matcher);\n\t}\n}\n\nconst endOfLine: string = Platform.OS === Platform.OperatingSystem.Windows ? '\\r\\n' : '\\n';\n\nabstract class AbstractLineMatcher implements ILineMatcher {\n\tprivate matcher: ProblemMatcher;\n\n\tconstructor(matcher: ProblemMatcher) {\n\t\tthis.matcher = matcher;\n\t}\n\n\tpublic handle(lines: string[], start: number = 0): HandleResult {\n\t\treturn { match: null, continue: false };\n\t}\n\n\tpublic next(line: string): ProblemMatch | null {\n\t\treturn null;\n\t}\n\n\tpublic abstract get matchLength(): number;\n\n\tprotected fillProblemData(data: ProblemData | null, pattern: ProblemPattern, matches: RegExpExecArray): data is ProblemData {\n\t\tif (data) {\n\t\t\tthis.fillProperty(data, 'file', pattern, matches, true);\n\t\t\tthis.appendProperty(data, 'message', pattern, matches, true);\n\t\t\tthis.fillProperty(data, 'code', pattern, matches, true);\n\t\t\tthis.fillProperty(data, 'severity', pattern, matches, true);\n\t\t\tthis.fillProperty(data, 'location', pattern, matches, true);\n\t\t\tthis.fillProperty(data, 'line', pattern, matches);\n\t\t\tthis.fillProperty(data, 'character', pattern, matches);\n\t\t\tthis.fillProperty(data, 'endLine', pattern, matches);\n\t\t\tthis.fillProperty(data, 'endCharacter', pattern, matches);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate appendProperty(data: ProblemData, property: keyof ProblemData, pattern: ProblemPattern, matches: RegExpExecArray, trim: boolean = false): void {\n\t\tconst patternProperty = pattern[property];\n\t\tif (Types.isUndefined(data[property])) {\n\t\t\tthis.fillProperty(data, property, pattern, matches, trim);\n\t\t}\n\t\telse if (!Types.isUndefined(patternProperty) && patternProperty < matches.length) {\n\t\t\tlet value = matches[patternProperty];\n\t\t\tif (trim) {\n\t\t\t\tvalue = Strings.trim(value)!;\n\t\t\t}\n\t\t\tdata[property] += endOfLine + value;\n\t\t}\n\t}\n\n\tprivate fillProperty(data: ProblemData, property: keyof ProblemData, pattern: ProblemPattern, matches: RegExpExecArray, trim: boolean = false): void {\n\t\tconst patternAtProperty = pattern[property];\n\t\tif (Types.isUndefined(data[property]) && !Types.isUndefined(patternAtProperty) && patternAtProperty < matches.length) {\n\t\t\tlet value = matches[patternAtProperty];\n\t\t\tif (value !== undefined) {\n\t\t\t\tif (trim) {\n\t\t\t\t\tvalue = Strings.trim(value)!;\n\t\t\t\t}\n\t\t\t\tdata[property] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected getMarkerMatch(data: ProblemData): ProblemMatch | undefined {\n\t\ttry {\n\t\t\tlet location = this.getLocation(data);\n\t\t\tif (data.file && location && data.message) {\n\t\t\t\tlet marker: IMarkerData = {\n\t\t\t\t\tseverity: this.getSeverity(data),\n\t\t\t\t\tstartLineNumber: location.startLineNumber,\n\t\t\t\t\tstartColumn: location.startCharacter,\n\t\t\t\t\tendLineNumber: location.endLineNumber,\n\t\t\t\t\tendColumn: location.endCharacter,\n\t\t\t\t\tmessage: data.message\n\t\t\t\t};\n\t\t\t\tif (data.code !== undefined) {\n\t\t\t\t\tmarker.code = data.code;\n\t\t\t\t}\n\t\t\t\tif (this.matcher.source !== undefined) {\n\t\t\t\t\tmarker.source = this.matcher.source;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tdescription: this.matcher,\n\t\t\t\t\tresource: this.getResource(data.file),\n\t\t\t\t\tmarker: marker\n\t\t\t\t};\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.error(`Failed to convert problem data into match: ${JSON.stringify(data)}`);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprotected getResource(filename: string): URI {\n\t\treturn getResource(filename, this.matcher);\n\t}\n\n\tprivate getLocation(data: ProblemData): Location | null {\n\t\tif (data.kind === ProblemLocationKind.File) {\n\t\t\treturn this.createLocation(0, 0, 0, 0);\n\t\t}\n\t\tif (data.location) {\n\t\t\treturn this.parseLocationInfo(data.location);\n\t\t}\n\t\tif (!data.line) {\n\t\t\treturn null;\n\t\t}\n\t\tlet startLine = parseInt(data.line);\n\t\tlet startColumn = data.character ? parseInt(data.character) : undefined;\n\t\tlet endLine = data.endLine ? parseInt(data.endLine) : undefined;\n\t\tlet endColumn = data.endCharacter ? parseInt(data.endCharacter) : undefined;\n\t\treturn this.createLocation(startLine, startColumn, endLine, endColumn);\n\t}\n\n\tprivate parseLocationInfo(value: string): Location | null {\n\t\tif (!value || !value.match(/(\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)/)) {\n\t\t\treturn null;\n\t\t}\n\t\tlet parts = value.split(',');\n\t\tlet startLine = parseInt(parts[0]);\n\t\tlet startColumn = parts.length > 1 ? parseInt(parts[1]) : undefined;\n\t\tif (parts.length > 3) {\n\t\t\treturn this.createLocation(startLine, startColumn, parseInt(parts[2]), parseInt(parts[3]));\n\t\t} else {\n\t\t\treturn this.createLocation(startLine, startColumn, undefined, undefined);\n\t\t}\n\t}\n\n\tprivate createLocation(startLine: number, startColumn: number | undefined, endLine: number | undefined, endColumn: number | undefined): Location {\n\t\tif (startColumn !== undefined && endColumn !== undefined) {\n\t\t\treturn { startLineNumber: startLine, startCharacter: startColumn, endLineNumber: endLine || startLine, endCharacter: endColumn };\n\t\t}\n\t\tif (startColumn !== undefined) {\n\t\t\treturn { startLineNumber: startLine, startCharacter: startColumn, endLineNumber: startLine, endCharacter: startColumn };\n\t\t}\n\t\treturn { startLineNumber: startLine, startCharacter: 1, endLineNumber: startLine, endCharacter: Number.MAX_VALUE };\n\t}\n\n\tprivate getSeverity(data: ProblemData): MarkerSeverity {\n\t\tlet result: Severity | null = null;\n\t\tif (data.severity) {\n\t\t\tlet value = data.severity;\n\t\t\tif (value) {\n\t\t\t\tresult = Severity.fromValue(value);\n\t\t\t\tif (result === Severity.Ignore) {\n\t\t\t\t\tif (value === 'E') {\n\t\t\t\t\t\tresult = Severity.Error;\n\t\t\t\t\t} else if (value === 'W') {\n\t\t\t\t\t\tresult = Severity.Warning;\n\t\t\t\t\t} else if (value === 'I') {\n\t\t\t\t\t\tresult = Severity.Info;\n\t\t\t\t\t} else if (Strings.equalsIgnoreCase(value, 'hint')) {\n\t\t\t\t\t\tresult = Severity.Info;\n\t\t\t\t\t} else if (Strings.equalsIgnoreCase(value, 'note')) {\n\t\t\t\t\t\tresult = Severity.Info;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (result === null || result === Severity.Ignore) {\n\t\t\tresult = this.matcher.severity || Severity.Error;\n\t\t}\n\t\treturn MarkerSeverity.fromSeverity(result);\n\t}\n}\n\nclass SingleLineMatcher extends AbstractLineMatcher {\n\n\tprivate pattern: ProblemPattern;\n\n\tconstructor(matcher: ProblemMatcher) {\n\t\tsuper(matcher);\n\t\tthis.pattern = <ProblemPattern>matcher.pattern;\n\t}\n\n\tpublic get matchLength(): number {\n\t\treturn 1;\n\t}\n\n\tpublic handle(lines: string[], start: number = 0): HandleResult {\n\t\tAssert.ok(lines.length - start === 1);\n\t\tlet data: ProblemData = Object.create(null);\n\t\tif (this.pattern.kind !== undefined) {\n\t\t\tdata.kind = this.pattern.kind;\n\t\t}\n\t\tlet matches = this.pattern.regexp.exec(lines[start]);\n\t\tif (matches) {\n\t\t\tthis.fillProblemData(data, this.pattern, matches);\n\t\t\tlet match = this.getMarkerMatch(data);\n\t\t\tif (match) {\n\t\t\t\treturn { match: match, continue: false };\n\t\t\t}\n\t\t}\n\t\treturn { match: null, continue: false };\n\t}\n\n\tpublic next(line: string): ProblemMatch | null {\n\t\treturn null;\n\t}\n}\n\nclass MultiLineMatcher extends AbstractLineMatcher {\n\n\tprivate patterns: ProblemPattern[];\n\tprivate data: ProblemData | null;\n\n\tconstructor(matcher: ProblemMatcher) {\n\t\tsuper(matcher);\n\t\tthis.patterns = <ProblemPattern[]>matcher.pattern;\n\t}\n\n\tpublic get matchLength(): number {\n\t\treturn this.patterns.length;\n\t}\n\n\tpublic handle(lines: string[], start: number = 0): HandleResult {\n\t\tAssert.ok(lines.length - start === this.patterns.length);\n\t\tthis.data = Object.create(null);\n\t\tlet data = this.data!;\n\t\tdata.kind = this.patterns[0].kind;\n\t\tfor (let i = 0; i < this.patterns.length; i++) {\n\t\t\tlet pattern = this.patterns[i];\n\t\t\tlet matches = pattern.regexp.exec(lines[i + start]);\n\t\t\tif (!matches) {\n\t\t\t\treturn { match: null, continue: false };\n\t\t\t} else {\n\t\t\t\t// Only the last pattern can loop\n\t\t\t\tif (pattern.loop && i === this.patterns.length - 1) {\n\t\t\t\t\tdata = Objects.deepClone(data);\n\t\t\t\t}\n\t\t\t\tthis.fillProblemData(data, pattern, matches);\n\t\t\t}\n\t\t}\n\t\tlet loop = !!this.patterns[this.patterns.length - 1].loop;\n\t\tif (!loop) {\n\t\t\tthis.data = null;\n\t\t}\n\t\tconst markerMatch = data ? this.getMarkerMatch(data) : null;\n\t\treturn { match: markerMatch ? markerMatch : null, continue: loop };\n\t}\n\n\tpublic next(line: string): ProblemMatch | null {\n\t\tlet pattern = this.patterns[this.patterns.length - 1];\n\t\tAssert.ok(pattern.loop === true && this.data !== null);\n\t\tlet matches = pattern.regexp.exec(line);\n\t\tif (!matches) {\n\t\t\tthis.data = null;\n\t\t\treturn null;\n\t\t}\n\t\tlet data = Objects.deepClone(this.data);\n\t\tlet problemMatch: ProblemMatch | undefined;\n\t\tif (this.fillProblemData(data, pattern, matches)) {\n\t\t\tproblemMatch = this.getMarkerMatch(data);\n\t\t}\n\t\treturn problemMatch ? problemMatch : null;\n\t}\n}\n\nexport namespace Config {\n\n\texport interface ProblemPattern {\n\n\t\t/**\n\t\t* The regular expression to find a problem in the console output of an\n\t\t* executed task.\n\t\t*/\n\t\tregexp?: string;\n\n\t\t/**\n\t\t* Whether the pattern matches a whole file, or a location (file/line)\n\t\t*\n\t\t* The default is to match for a location. Only valid on the\n\t\t* first problem pattern in a multi line problem matcher.\n\t\t*/\n\t\tkind?: string;\n\n\t\t/**\n\t\t* The match group index of the filename.\n\t\t* If omitted 1 is used.\n\t\t*/\n\t\tfile?: number;\n\n\t\t/**\n\t\t* The match group index of the problem's location. Valid location\n\t\t* patterns are: (line), (line,column) and (startLine,startColumn,endLine,endColumn).\n\t\t* If omitted the line and column properties are used.\n\t\t*/\n\t\tlocation?: number;\n\n\t\t/**\n\t\t* The match group index of the problem's line in the source file.\n\t\t*\n\t\t* Defaults to 2.\n\t\t*/\n\t\tline?: number;\n\n\t\t/**\n\t\t* The match group index of the problem's column in the source file.\n\t\t*\n\t\t* Defaults to 3.\n\t\t*/\n\t\tcolumn?: number;\n\n\t\t/**\n\t\t* The match group index of the problem's end line in the source file.\n\t\t*\n\t\t* Defaults to undefined. No end line is captured.\n\t\t*/\n\t\tendLine?: number;\n\n\t\t/**\n\t\t* The match group index of the problem's end column in the source file.\n\t\t*\n\t\t* Defaults to undefined. No end column is captured.\n\t\t*/\n\t\tendColumn?: number;\n\n\t\t/**\n\t\t* The match group index of the problem's severity.\n\t\t*\n\t\t* Defaults to undefined. In this case the problem matcher's severity\n\t\t* is used.\n\t\t*/\n\t\tseverity?: number;\n\n\t\t/**\n\t\t* The match group index of the problem's code.\n\t\t*\n\t\t* Defaults to undefined. No code is captured.\n\t\t*/\n\t\tcode?: number;\n\n\t\t/**\n\t\t* The match group index of the message. If omitted it defaults\n\t\t* to 4 if location is specified. Otherwise it defaults to 5.\n\t\t*/\n\t\tmessage?: number;\n\n\t\t/**\n\t\t* Specifies if the last pattern in a multi line problem matcher should\n\t\t* loop as long as it does match a line consequently. Only valid on the\n\t\t* last problem pattern in a multi line problem matcher.\n\t\t*/\n\t\tloop?: boolean;\n\t}\n\n\texport interface CheckedProblemPattern extends ProblemPattern {\n\t\t/**\n\t\t* The regular expression to find a problem in the console output of an\n\t\t* executed task.\n\t\t*/\n\t\tregexp: string;\n\t}\n\n\texport namespace CheckedProblemPattern {\n\t\texport function is(value: any): value is CheckedProblemPattern {\n\t\t\tlet candidate: ProblemPattern = value as ProblemPattern;\n\t\t\treturn candidate && Types.isString(candidate.regexp);\n\t\t}\n\t}\n\n\texport interface NamedProblemPattern extends ProblemPattern {\n\t\t/**\n\t\t * The name of the problem pattern.\n\t\t */\n\t\tname: string;\n\n\t\t/**\n\t\t * A human readable label\n\t\t */\n\t\tlabel?: string;\n\t}\n\n\texport namespace NamedProblemPattern {\n\t\texport function is(value: any): value is NamedProblemPattern {\n\t\t\tlet candidate: NamedProblemPattern = value as NamedProblemPattern;\n\t\t\treturn candidate && Types.isString(candidate.name);\n\t\t}\n\t}\n\n\texport interface NamedCheckedProblemPattern extends NamedProblemPattern {\n\t\t/**\n\t\t* The regular expression to find a problem in the console output of an\n\t\t* executed task.\n\t\t*/\n\t\tregexp: string;\n\t}\n\n\texport namespace NamedCheckedProblemPattern {\n\t\texport function is(value: any): value is NamedCheckedProblemPattern {\n\t\t\tlet candidate: NamedProblemPattern = value as NamedProblemPattern;\n\t\t\treturn candidate && NamedProblemPattern.is(candidate) && Types.isString(candidate.regexp);\n\t\t}\n\t}\n\n\texport type MultiLineProblemPattern = ProblemPattern[];\n\n\texport namespace MultiLineProblemPattern {\n\t\texport function is(value: any): value is MultiLineProblemPattern {\n\t\t\treturn value && Types.isArray(value);\n\t\t}\n\t}\n\n\texport type MultiLineCheckedProblemPattern = CheckedProblemPattern[];\n\n\texport namespace MultiLineCheckedProblemPattern {\n\t\texport function is(value: any): value is MultiLineCheckedProblemPattern {\n\t\t\tif (!MultiLineProblemPattern.is(value)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (const element of value) {\n\t\t\t\tif (!Config.CheckedProblemPattern.is(element)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\texport interface NamedMultiLineCheckedProblemPattern {\n\t\t/**\n\t\t * The name of the problem pattern.\n\t\t */\n\t\tname: string;\n\n\t\t/**\n\t\t * A human readable label\n\t\t */\n\t\tlabel?: string;\n\n\t\t/**\n\t\t * The actual patterns\n\t\t */\n\t\tpatterns: MultiLineCheckedProblemPattern;\n\t}\n\n\texport namespace NamedMultiLineCheckedProblemPattern {\n\t\texport function is(value: any): value is NamedMultiLineCheckedProblemPattern {\n\t\t\tlet candidate = value as NamedMultiLineCheckedProblemPattern;\n\t\t\treturn candidate && Types.isString(candidate.name) && Types.isArray(candidate.patterns) && MultiLineCheckedProblemPattern.is(candidate.patterns);\n\t\t}\n\t}\n\n\texport type NamedProblemPatterns = (Config.NamedProblemPattern | Config.NamedMultiLineCheckedProblemPattern)[];\n\n\t/**\n\t* A watching pattern\n\t*/\n\texport interface WatchingPattern {\n\t\t/**\n\t\t* The actual regular expression\n\t\t*/\n\t\tregexp?: string;\n\n\t\t/**\n\t\t* The match group index of the filename. If provided the expression\n\t\t* is matched for that file only.\n\t\t*/\n\t\tfile?: number;\n\t}\n\n\t/**\n\t* A description to track the start and end of a watching task.\n\t*/\n\texport interface BackgroundMonitor {\n\n\t\t/**\n\t\t* If set to true the watcher is in active mode when the task\n\t\t* starts. This is equals of issuing a line that matches the\n\t\t* beginPattern.\n\t\t*/\n\t\tactiveOnStart?: boolean;\n\n\t\t/**\n\t\t* If matched in the output the start of a watching task is signaled.\n\t\t*/\n\t\tbeginsPattern?: string | WatchingPattern;\n\n\t\t/**\n\t\t* If matched in the output the end of a watching task is signaled.\n\t\t*/\n\t\tendsPattern?: string | WatchingPattern;\n\t}\n\n\t/**\n\t* A description of a problem matcher that detects problems\n\t* in build output.\n\t*/\n\texport interface ProblemMatcher {\n\n\t\t/**\n\t\t * The name of a base problem matcher to use. If specified the\n\t\t * base problem matcher will be used as a template and properties\n\t\t * specified here will replace properties of the base problem\n\t\t * matcher\n\t\t */\n\t\tbase?: string;\n\n\t\t/**\n\t\t * The owner of the produced VSCode problem. This is typically\n\t\t * the identifier of a VSCode language service if the problems are\n\t\t * to be merged with the one produced by the language service\n\t\t * or a generated internal id. Defaults to the generated internal id.\n\t\t */\n\t\towner?: string;\n\n\t\t/**\n\t\t * A human-readable string describing the source of this problem.\n\t\t * E.g. 'typescript' or 'super lint'.\n\t\t */\n\t\tsource?: string;\n\n\t\t/**\n\t\t* Specifies to which kind of documents the problems found by this\n\t\t* matcher are applied. Valid values are:\n\t\t*\n\t\t*   \"allDocuments\": problems found in all documents are applied.\n\t\t*   \"openDocuments\": problems found in documents that are open\n\t\t*   are applied.\n\t\t*   \"closedDocuments\": problems found in closed documents are\n\t\t*   applied.\n\t\t*/\n\t\tapplyTo?: string;\n\n\t\t/**\n\t\t* The severity of the VSCode problem produced by this problem matcher.\n\t\t*\n\t\t* Valid values are:\n\t\t*   \"error\": to produce errors.\n\t\t*   \"warning\": to produce warnings.\n\t\t*   \"info\": to produce infos.\n\t\t*\n\t\t* The value is used if a pattern doesn't specify a severity match group.\n\t\t* Defaults to \"error\" if omitted.\n\t\t*/\n\t\tseverity?: string;\n\n\t\t/**\n\t\t* Defines how filename reported in a problem pattern\n\t\t* should be read. Valid values are:\n\t\t*  - \"absolute\": the filename is always treated absolute.\n\t\t*  - \"relative\": the filename is always treated relative to\n\t\t*    the current working directory. This is the default.\n\t\t*  - [\"relative\", \"path value\"]: the filename is always\n\t\t*    treated relative to the given path value.\n\t\t*/\n\t\tfileLocation?: string | string[];\n\n\t\t/**\n\t\t* The name of a predefined problem pattern, the inline definintion\n\t\t* of a problem pattern or an array of problem patterns to match\n\t\t* problems spread over multiple lines.\n\t\t*/\n\t\tpattern?: string | ProblemPattern | ProblemPattern[];\n\n\t\t/**\n\t\t* A regular expression signaling that a watched tasks begins executing\n\t\t* triggered through file watching.\n\t\t*/\n\t\twatchedTaskBeginsRegExp?: string;\n\n\t\t/**\n\t\t* A regular expression signaling that a watched tasks ends executing.\n\t\t*/\n\t\twatchedTaskEndsRegExp?: string;\n\n\t\t/**\n\t\t * @deprecated Use background instead.\n\t\t */\n\t\twatching?: BackgroundMonitor;\n\t\tbackground?: BackgroundMonitor;\n\t}\n\n\texport type ProblemMatcherType = string | ProblemMatcher | Array<string | ProblemMatcher>;\n\n\texport interface NamedProblemMatcher extends ProblemMatcher {\n\t\t/**\n\t\t* This name can be used to refer to the\n\t\t* problem matcher from within a task.\n\t\t*/\n\t\tname: string;\n\n\t\t/**\n\t\t * A human readable label.\n\t\t */\n\t\tlabel?: string;\n\t}\n\n\texport function isNamedProblemMatcher(value: ProblemMatcher): value is NamedProblemMatcher {\n\t\treturn Types.isString((<NamedProblemMatcher>value).name);\n\t}\n}\n\nexport class ProblemPatternParser extends Parser {\n\n\tconstructor(logger: IProblemReporter) {\n\t\tsuper(logger);\n\t}\n\n\tpublic parse(value: Config.ProblemPattern): ProblemPattern;\n\tpublic parse(value: Config.MultiLineProblemPattern): MultiLineProblemPattern;\n\tpublic parse(value: Config.NamedProblemPattern): NamedProblemPattern;\n\tpublic parse(value: Config.NamedMultiLineCheckedProblemPattern): NamedMultiLineProblemPattern;\n\tpublic parse(value: Config.ProblemPattern | Config.MultiLineProblemPattern | Config.NamedProblemPattern | Config.NamedMultiLineCheckedProblemPattern): any {\n\t\tif (Config.NamedMultiLineCheckedProblemPattern.is(value)) {\n\t\t\treturn this.createNamedMultiLineProblemPattern(value);\n\t\t} else if (Config.MultiLineCheckedProblemPattern.is(value)) {\n\t\t\treturn this.createMultiLineProblemPattern(value);\n\t\t} else if (Config.NamedCheckedProblemPattern.is(value)) {\n\t\t\tlet result = this.createSingleProblemPattern(value) as NamedProblemPattern;\n\t\t\tresult.name = value.name;\n\t\t\treturn result;\n\t\t} else if (Config.CheckedProblemPattern.is(value)) {\n\t\t\treturn this.createSingleProblemPattern(value);\n\t\t} else {\n\t\t\tthis.error(localize('ProblemPatternParser.problemPattern.missingRegExp', 'The problem pattern is missing a regular expression.'));\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate createSingleProblemPattern(value: Config.CheckedProblemPattern): ProblemPattern | null {\n\t\tlet result = this.doCreateSingleProblemPattern(value, true);\n\t\tif (result === undefined) {\n\t\t\treturn null;\n\t\t} else if (result.kind === undefined) {\n\t\t\tresult.kind = ProblemLocationKind.Location;\n\t\t}\n\t\treturn this.validateProblemPattern([result]) ? result : null;\n\t}\n\n\tprivate createNamedMultiLineProblemPattern(value: Config.NamedMultiLineCheckedProblemPattern): NamedMultiLineProblemPattern | null {\n\t\tconst validPatterns = this.createMultiLineProblemPattern(value.patterns);\n\t\tif (!validPatterns) {\n\t\t\treturn null;\n\t\t}\n\t\tlet result = {\n\t\t\tname: value.name,\n\t\t\tlabel: value.label ? value.label : value.name,\n\t\t\tpatterns: validPatterns\n\t\t};\n\t\treturn result;\n\t}\n\n\tprivate createMultiLineProblemPattern(values: Config.MultiLineCheckedProblemPattern): MultiLineProblemPattern | null {\n\t\tlet result: MultiLineProblemPattern = [];\n\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\tlet pattern = this.doCreateSingleProblemPattern(values[i], false);\n\t\t\tif (pattern === undefined) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (i < values.length - 1) {\n\t\t\t\tif (!Types.isUndefined(pattern.loop) && pattern.loop) {\n\t\t\t\t\tpattern.loop = false;\n\t\t\t\t\tthis.error(localize('ProblemPatternParser.loopProperty.notLast', 'The loop property is only supported on the last line matcher.'));\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.push(pattern);\n\t\t}\n\t\tif (result[0].kind === undefined) {\n\t\t\tresult[0].kind = ProblemLocationKind.Location;\n\t\t}\n\t\treturn this.validateProblemPattern(result) ? result : null;\n\t}\n\n\tprivate doCreateSingleProblemPattern(value: Config.CheckedProblemPattern, setDefaults: boolean): ProblemPattern | undefined {\n\t\tconst regexp = this.createRegularExpression(value.regexp);\n\t\tif (regexp === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet result: ProblemPattern = { regexp };\n\t\tif (value.kind) {\n\t\t\tresult.kind = ProblemLocationKind.fromString(value.kind);\n\t\t}\n\n\t\tfunction copyProperty(result: ProblemPattern, source: Config.ProblemPattern, resultKey: keyof ProblemPattern, sourceKey: keyof Config.ProblemPattern) {\n\t\t\tlet value = source[sourceKey];\n\t\t\tif (typeof value === 'number') {\n\t\t\t\tresult[resultKey] = value;\n\t\t\t}\n\t\t}\n\t\tcopyProperty(result, value, 'file', 'file');\n\t\tcopyProperty(result, value, 'location', 'location');\n\t\tcopyProperty(result, value, 'line', 'line');\n\t\tcopyProperty(result, value, 'character', 'column');\n\t\tcopyProperty(result, value, 'endLine', 'endLine');\n\t\tcopyProperty(result, value, 'endCharacter', 'endColumn');\n\t\tcopyProperty(result, value, 'severity', 'severity');\n\t\tcopyProperty(result, value, 'code', 'code');\n\t\tcopyProperty(result, value, 'message', 'message');\n\t\tif (value.loop === true || value.loop === false) {\n\t\t\tresult.loop = value.loop;\n\t\t}\n\t\tif (setDefaults) {\n\t\t\tif (result.location || result.kind === ProblemLocationKind.File) {\n\t\t\t\tlet defaultValue: Partial<ProblemPattern> = {\n\t\t\t\t\tfile: 1,\n\t\t\t\t\tmessage: 0\n\t\t\t\t};\n\t\t\t\tresult = Objects.mixin(result, defaultValue, false);\n\t\t\t} else {\n\t\t\t\tlet defaultValue: Partial<ProblemPattern> = {\n\t\t\t\t\tfile: 1,\n\t\t\t\t\tline: 2,\n\t\t\t\t\tcharacter: 3,\n\t\t\t\t\tmessage: 0\n\t\t\t\t};\n\t\t\t\tresult = Objects.mixin(result, defaultValue, false);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate validateProblemPattern(values: ProblemPattern[]): boolean {\n\t\tlet file: boolean = false, message: boolean = false, location: boolean = false, line: boolean = false;\n\t\tlet locationKind = (values[0].kind === undefined) ? ProblemLocationKind.Location : values[0].kind;\n\n\t\tvalues.forEach((pattern, i) => {\n\t\t\tif (i !== 0 && pattern.kind) {\n\t\t\t\tthis.error(localize('ProblemPatternParser.problemPattern.kindProperty.notFirst', 'The problem pattern is invalid. The kind property must be provided only in the first element'));\n\t\t\t}\n\t\t\tfile = file || !Types.isUndefined(pattern.file);\n\t\t\tmessage = message || !Types.isUndefined(pattern.message);\n\t\t\tlocation = location || !Types.isUndefined(pattern.location);\n\t\t\tline = line || !Types.isUndefined(pattern.line);\n\t\t});\n\t\tif (!(file && message)) {\n\t\t\tthis.error(localize('ProblemPatternParser.problemPattern.missingProperty', 'The problem pattern is invalid. It must have at least have a file and a message.'));\n\t\t\treturn false;\n\t\t}\n\t\tif (locationKind === ProblemLocationKind.Location && !(location || line)) {\n\t\t\tthis.error(localize('ProblemPatternParser.problemPattern.missingLocation', 'The problem pattern is invalid. It must either have kind: \"file\" or have a line or location match group.'));\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate createRegularExpression(value: string): RegExp | undefined {\n\t\tlet result: RegExp | undefined;\n\t\ttry {\n\t\t\tresult = new RegExp(value);\n\t\t} catch (err) {\n\t\t\tthis.error(localize('ProblemPatternParser.invalidRegexp', 'Error: The string {0} is not a valid regular expression.\\n', value));\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport class ExtensionRegistryReporter implements IProblemReporter {\n\tconstructor(private _collector: ExtensionMessageCollector, private _validationStatus: ValidationStatus = new ValidationStatus()) {\n\t}\n\n\tpublic info(message: string): void {\n\t\tthis._validationStatus.state = ValidationState.Info;\n\t\tthis._collector.info(message);\n\t}\n\n\tpublic warn(message: string): void {\n\t\tthis._validationStatus.state = ValidationState.Warning;\n\t\tthis._collector.warn(message);\n\t}\n\n\tpublic error(message: string): void {\n\t\tthis._validationStatus.state = ValidationState.Error;\n\t\tthis._collector.error(message);\n\t}\n\n\tpublic fatal(message: string): void {\n\t\tthis._validationStatus.state = ValidationState.Fatal;\n\t\tthis._collector.error(message);\n\t}\n\n\tpublic get status(): ValidationStatus {\n\t\treturn this._validationStatus;\n\t}\n}\n\nexport namespace Schemas {\n\n\texport const ProblemPattern: IJSONSchema = {\n\t\tdefault: {\n\t\t\tregexp: '^([^\\\\\\\\s].*)\\\\\\\\((\\\\\\\\d+,\\\\\\\\d+)\\\\\\\\):\\\\\\\\s*(.*)$',\n\t\t\tfile: 1,\n\t\t\tlocation: 2,\n\t\t\tmessage: 3\n\t\t},\n\t\ttype: 'object',\n\t\tadditionalProperties: false,\n\t\tproperties: {\n\t\t\tregexp: {\n\t\t\t\ttype: 'string',\n\t\t\t\tdescription: localize('ProblemPatternSchema.regexp', 'The regular expression to find an error, warning or info in the output.')\n\t\t\t},\n\t\t\tkind: {\n\t\t\t\ttype: 'string',\n\t\t\t\tdescription: localize('ProblemPatternSchema.kind', 'whether the pattern matches a location (file and line) or only a file.')\n\t\t\t},\n\t\t\tfile: {\n\t\t\t\ttype: 'integer',\n\t\t\t\tdescription: localize('ProblemPatternSchema.file', 'The match group index of the filename. If omitted 1 is used.')\n\t\t\t},\n\t\t\tlocation: {\n\t\t\t\ttype: 'integer',\n\t\t\t\tdescription: localize('ProblemPatternSchema.location', 'The match group index of the problem\\'s location. Valid location patterns are: (line), (line,column) and (startLine,startColumn,endLine,endColumn). If omitted (line,column) is assumed.')\n\t\t\t},\n\t\t\tline: {\n\t\t\t\ttype: 'integer',\n\t\t\t\tdescription: localize('ProblemPatternSchema.line', 'The match group index of the problem\\'s line. Defaults to 2')\n\t\t\t},\n\t\t\tcolumn: {\n\t\t\t\ttype: 'integer',\n\t\t\t\tdescription: localize('ProblemPatternSchema.column', 'The match group index of the problem\\'s line character. Defaults to 3')\n\t\t\t},\n\t\t\tendLine: {\n\t\t\t\ttype: 'integer',\n\t\t\t\tdescription: localize('ProblemPatternSchema.endLine', 'The match group index of the problem\\'s end line. Defaults to undefined')\n\t\t\t},\n\t\t\tendColumn: {\n\t\t\t\ttype: 'integer',\n\t\t\t\tdescription: localize('ProblemPatternSchema.endColumn', 'The match group index of the problem\\'s end line character. Defaults to undefined')\n\t\t\t},\n\t\t\tseverity: {\n\t\t\t\ttype: 'integer',\n\t\t\t\tdescription: localize('ProblemPatternSchema.severity', 'The match group index of the problem\\'s severity. Defaults to undefined')\n\t\t\t},\n\t\t\tcode: {\n\t\t\t\ttype: 'integer',\n\t\t\t\tdescription: localize('ProblemPatternSchema.code', 'The match group index of the problem\\'s code. Defaults to undefined')\n\t\t\t},\n\t\t\tmessage: {\n\t\t\t\ttype: 'integer',\n\t\t\t\tdescription: localize('ProblemPatternSchema.message', 'The match group index of the message. If omitted it defaults to 4 if location is specified. Otherwise it defaults to 5.')\n\t\t\t},\n\t\t\tloop: {\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdescription: localize('ProblemPatternSchema.loop', 'In a multi line matcher loop indicated whether this pattern is executed in a loop as long as it matches. Can only specified on a last pattern in a multi line pattern.')\n\t\t\t}\n\t\t}\n\t};\n\n\texport const NamedProblemPattern: IJSONSchema = Objects.deepClone(ProblemPattern);\n\tNamedProblemPattern.properties = Objects.deepClone(NamedProblemPattern.properties) || {};\n\tNamedProblemPattern.properties['name'] = {\n\t\ttype: 'string',\n\t\tdescription: localize('NamedProblemPatternSchema.name', 'The name of the problem pattern.')\n\t};\n\n\texport const MultiLineProblemPattern: IJSONSchema = {\n\t\ttype: 'array',\n\t\titems: ProblemPattern\n\t};\n\n\texport const NamedMultiLineProblemPattern: IJSONSchema = {\n\t\ttype: 'object',\n\t\tadditionalProperties: false,\n\t\tproperties: {\n\t\t\tname: {\n\t\t\t\ttype: 'string',\n\t\t\t\tdescription: localize('NamedMultiLineProblemPatternSchema.name', 'The name of the problem multi line problem pattern.')\n\t\t\t},\n\t\t\tpatterns: {\n\t\t\t\ttype: 'array',\n\t\t\t\tdescription: localize('NamedMultiLineProblemPatternSchema.patterns', 'The actual patterns.'),\n\t\t\t\titems: ProblemPattern\n\t\t\t}\n\t\t}\n\t};\n}\n\nconst problemPatternExtPoint = ExtensionsRegistry.registerExtensionPoint<Config.NamedProblemPatterns>({\n\textensionPoint: 'problemPatterns',\n\tjsonSchema: {\n\t\tdescription: localize('ProblemPatternExtPoint', 'Contributes problem patterns'),\n\t\ttype: 'array',\n\t\titems: {\n\t\t\tanyOf: [\n\t\t\t\tSchemas.NamedProblemPattern,\n\t\t\t\tSchemas.NamedMultiLineProblemPattern\n\t\t\t]\n\t\t}\n\t}\n});\n\nexport interface IProblemPatternRegistry {\n\tonReady(): Promise<void>;\n\n\tget(key: string): ProblemPattern | MultiLineProblemPattern;\n}\n\nclass ProblemPatternRegistryImpl implements IProblemPatternRegistry {\n\n\tprivate patterns: IStringDictionary<ProblemPattern | ProblemPattern[]>;\n\tprivate readyPromise: Promise<void>;\n\n\tconstructor() {\n\t\tthis.patterns = Object.create(null);\n\t\tthis.fillDefaults();\n\t\tthis.readyPromise = new Promise<void>((resolve, reject) => {\n\t\t\tproblemPatternExtPoint.setHandler((extensions, delta) => {\n\t\t\t\t// We get all statically know extension during startup in one batch\n\t\t\t\ttry {\n\t\t\t\t\tdelta.removed.forEach(extension => {\n\t\t\t\t\t\tlet problemPatterns = extension.value as Config.NamedProblemPatterns;\n\t\t\t\t\t\tfor (let pattern of problemPatterns) {\n\t\t\t\t\t\t\tif (this.patterns[pattern.name]) {\n\t\t\t\t\t\t\t\tdelete this.patterns[pattern.name];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tdelta.added.forEach(extension => {\n\t\t\t\t\t\tlet problemPatterns = extension.value as Config.NamedProblemPatterns;\n\t\t\t\t\t\tlet parser = new ProblemPatternParser(new ExtensionRegistryReporter(extension.collector));\n\t\t\t\t\t\tfor (let pattern of problemPatterns) {\n\t\t\t\t\t\t\tif (Config.NamedMultiLineCheckedProblemPattern.is(pattern)) {\n\t\t\t\t\t\t\t\tlet result = parser.parse(pattern);\n\t\t\t\t\t\t\t\tif (parser.problemReporter.status.state < ValidationState.Error) {\n\t\t\t\t\t\t\t\t\tthis.add(result.name, result.patterns);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\textension.collector.error(localize('ProblemPatternRegistry.error', 'Invalid problem pattern. The pattern will be ignored.'));\n\t\t\t\t\t\t\t\t\textension.collector.error(JSON.stringify(pattern, undefined, 4));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (Config.NamedProblemPattern.is(pattern)) {\n\t\t\t\t\t\t\t\tlet result = parser.parse(pattern);\n\t\t\t\t\t\t\t\tif (parser.problemReporter.status.state < ValidationState.Error) {\n\t\t\t\t\t\t\t\t\tthis.add(pattern.name, result);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\textension.collector.error(localize('ProblemPatternRegistry.error', 'Invalid problem pattern. The pattern will be ignored.'));\n\t\t\t\t\t\t\t\t\textension.collector.error(JSON.stringify(pattern, undefined, 4));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparser.reset();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Do nothing\n\t\t\t\t}\n\t\t\t\tresolve(undefined);\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic onReady(): Promise<void> {\n\t\treturn this.readyPromise;\n\t}\n\n\tpublic add(key: string, value: ProblemPattern | ProblemPattern[]): void {\n\t\tthis.patterns[key] = value;\n\t}\n\n\tpublic get(key: string): ProblemPattern | ProblemPattern[] {\n\t\treturn this.patterns[key];\n\t}\n\n\tprivate fillDefaults(): void {\n\t\tthis.add('msCompile', {\n\t\t\tregexp: /^(?:\\s+\\d+\\>)?([^\\s].*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\)\\s*:\\s+(error|warning|info)\\s+(\\w{1,2}\\d+)\\s*:\\s*(.*)$/,\n\t\t\tkind: ProblemLocationKind.Location,\n\t\t\tfile: 1,\n\t\t\tlocation: 2,\n\t\t\tseverity: 3,\n\t\t\tcode: 4,\n\t\t\tmessage: 5\n\t\t});\n\t\tthis.add('gulp-tsc', {\n\t\t\tregexp: /^([^\\s].*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\):\\s+(\\d+)\\s+(.*)$/,\n\t\t\tkind: ProblemLocationKind.Location,\n\t\t\tfile: 1,\n\t\t\tlocation: 2,\n\t\t\tcode: 3,\n\t\t\tmessage: 4\n\t\t});\n\t\tthis.add('cpp', {\n\t\t\tregexp: /^([^\\s].*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\):\\s+(error|warning|info)\\s+(C\\d+)\\s*:\\s*(.*)$/,\n\t\t\tkind: ProblemLocationKind.Location,\n\t\t\tfile: 1,\n\t\t\tlocation: 2,\n\t\t\tseverity: 3,\n\t\t\tcode: 4,\n\t\t\tmessage: 5\n\t\t});\n\t\tthis.add('csc', {\n\t\t\tregexp: /^([^\\s].*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\):\\s+(error|warning|info)\\s+(CS\\d+)\\s*:\\s*(.*)$/,\n\t\t\tkind: ProblemLocationKind.Location,\n\t\t\tfile: 1,\n\t\t\tlocation: 2,\n\t\t\tseverity: 3,\n\t\t\tcode: 4,\n\t\t\tmessage: 5\n\t\t});\n\t\tthis.add('vb', {\n\t\t\tregexp: /^([^\\s].*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\):\\s+(error|warning|info)\\s+(BC\\d+)\\s*:\\s*(.*)$/,\n\t\t\tkind: ProblemLocationKind.Location,\n\t\t\tfile: 1,\n\t\t\tlocation: 2,\n\t\t\tseverity: 3,\n\t\t\tcode: 4,\n\t\t\tmessage: 5\n\t\t});\n\t\tthis.add('lessCompile', {\n\t\t\tregexp: /^\\s*(.*) in file (.*) line no. (\\d+)$/,\n\t\t\tkind: ProblemLocationKind.Location,\n\t\t\tmessage: 1,\n\t\t\tfile: 2,\n\t\t\tline: 3\n\t\t});\n\t\tthis.add('jshint', {\n\t\t\tregexp: /^(.*):\\s+line\\s+(\\d+),\\s+col\\s+(\\d+),\\s(.+?)(?:\\s+\\((\\w)(\\d+)\\))?$/,\n\t\t\tkind: ProblemLocationKind.Location,\n\t\t\tfile: 1,\n\t\t\tline: 2,\n\t\t\tcharacter: 3,\n\t\t\tmessage: 4,\n\t\t\tseverity: 5,\n\t\t\tcode: 6\n\t\t});\n\t\tthis.add('jshint-stylish', [\n\t\t\t{\n\t\t\t\tregexp: /^(.+)$/,\n\t\t\t\tkind: ProblemLocationKind.Location,\n\t\t\t\tfile: 1\n\t\t\t},\n\t\t\t{\n\t\t\t\tregexp: /^\\s+line\\s+(\\d+)\\s+col\\s+(\\d+)\\s+(.+?)(?:\\s+\\((\\w)(\\d+)\\))?$/,\n\t\t\t\tline: 1,\n\t\t\t\tcharacter: 2,\n\t\t\t\tmessage: 3,\n\t\t\t\tseverity: 4,\n\t\t\t\tcode: 5,\n\t\t\t\tloop: true\n\t\t\t}\n\t\t]);\n\t\tthis.add('eslint-compact', {\n\t\t\tregexp: /^(.+):\\sline\\s(\\d+),\\scol\\s(\\d+),\\s(Error|Warning|Info)\\s-\\s(.+)\\s\\((.+)\\)$/,\n\t\t\tfile: 1,\n\t\t\tkind: ProblemLocationKind.Location,\n\t\t\tline: 2,\n\t\t\tcharacter: 3,\n\t\t\tseverity: 4,\n\t\t\tmessage: 5,\n\t\t\tcode: 6\n\t\t});\n\t\tthis.add('eslint-stylish', [\n\t\t\t{\n\t\t\t\tregexp: /^([^\\s].*)$/,\n\t\t\t\tkind: ProblemLocationKind.Location,\n\t\t\t\tfile: 1\n\t\t\t},\n\t\t\t{\n\t\t\t\tregexp: /^\\s+(\\d+):(\\d+)\\s+(error|warning|info)\\s+(.+?)(?:\\s\\s+(.*))?$/,\n\t\t\t\tline: 1,\n\t\t\t\tcharacter: 2,\n\t\t\t\tseverity: 3,\n\t\t\t\tmessage: 4,\n\t\t\t\tcode: 5,\n\t\t\t\tloop: true\n\t\t\t}\n\t\t]);\n\t\tthis.add('go', {\n\t\t\tregexp: /^([^:]*: )?((.:)?[^:]*):(\\d+)(:(\\d+))?: (.*)$/,\n\t\t\tkind: ProblemLocationKind.Location,\n\t\t\tfile: 2,\n\t\t\tline: 4,\n\t\t\tcharacter: 6,\n\t\t\tmessage: 7\n\t\t});\n\t}\n}\n\nexport const ProblemPatternRegistry: IProblemPatternRegistry = new ProblemPatternRegistryImpl();\n\nexport class ProblemMatcherParser extends Parser {\n\n\tconstructor(logger: IProblemReporter) {\n\t\tsuper(logger);\n\t}\n\n\tpublic parse(json: Config.ProblemMatcher): ProblemMatcher | undefined {\n\t\tlet result = this.createProblemMatcher(json);\n\t\tif (!this.checkProblemMatcherValid(json, result)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis.addWatchingMatcher(json, result);\n\n\t\treturn result;\n\t}\n\n\tprivate checkProblemMatcherValid(externalProblemMatcher: Config.ProblemMatcher, problemMatcher: ProblemMatcher | null): problemMatcher is ProblemMatcher {\n\t\tif (!problemMatcher) {\n\t\t\tthis.error(localize('ProblemMatcherParser.noProblemMatcher', 'Error: the description can\\'t be converted into a problem matcher:\\n{0}\\n', JSON.stringify(externalProblemMatcher, null, 4)));\n\t\t\treturn false;\n\t\t}\n\t\tif (!problemMatcher.pattern) {\n\t\t\tthis.error(localize('ProblemMatcherParser.noProblemPattern', 'Error: the description doesn\\'t define a valid problem pattern:\\n{0}\\n', JSON.stringify(externalProblemMatcher, null, 4)));\n\t\t\treturn false;\n\t\t}\n\t\tif (!problemMatcher.owner) {\n\t\t\tthis.error(localize('ProblemMatcherParser.noOwner', 'Error: the description doesn\\'t define an owner:\\n{0}\\n', JSON.stringify(externalProblemMatcher, null, 4)));\n\t\t\treturn false;\n\t\t}\n\t\tif (Types.isUndefined(problemMatcher.fileLocation)) {\n\t\t\tthis.error(localize('ProblemMatcherParser.noFileLocation', 'Error: the description doesn\\'t define a file location:\\n{0}\\n', JSON.stringify(externalProblemMatcher, null, 4)));\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate createProblemMatcher(description: Config.ProblemMatcher): ProblemMatcher | null {\n\t\tlet result: ProblemMatcher | null = null;\n\n\t\tlet owner = Types.isString(description.owner) ? description.owner : UUID.generateUuid();\n\t\tlet source = Types.isString(description.source) ? description.source : undefined;\n\t\tlet applyTo = Types.isString(description.applyTo) ? ApplyToKind.fromString(description.applyTo) : ApplyToKind.allDocuments;\n\t\tif (!applyTo) {\n\t\t\tapplyTo = ApplyToKind.allDocuments;\n\t\t}\n\t\tlet fileLocation: FileLocationKind | undefined = undefined;\n\t\tlet filePrefix: string | undefined = undefined;\n\n\t\tlet kind: FileLocationKind | undefined;\n\t\tif (Types.isUndefined(description.fileLocation)) {\n\t\t\tfileLocation = FileLocationKind.Relative;\n\t\t\tfilePrefix = '${workspaceFolder}';\n\t\t} else if (Types.isString(description.fileLocation)) {\n\t\t\tkind = FileLocationKind.fromString(<string>description.fileLocation);\n\t\t\tif (kind) {\n\t\t\t\tfileLocation = kind;\n\t\t\t\tif (kind === FileLocationKind.Relative) {\n\t\t\t\t\tfilePrefix = '${workspaceFolder}';\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Types.isStringArray(description.fileLocation)) {\n\t\t\tlet values = <string[]>description.fileLocation;\n\t\t\tif (values.length > 0) {\n\t\t\t\tkind = FileLocationKind.fromString(values[0]);\n\t\t\t\tif (values.length === 1 && kind === FileLocationKind.Absolute) {\n\t\t\t\t\tfileLocation = kind;\n\t\t\t\t} else if (values.length === 2 && kind === FileLocationKind.Relative && values[1]) {\n\t\t\t\t\tfileLocation = kind;\n\t\t\t\t\tfilePrefix = values[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet pattern = description.pattern ? this.createProblemPattern(description.pattern) : undefined;\n\n\t\tlet severity = description.severity ? Severity.fromValue(description.severity) : undefined;\n\t\tif (severity === Severity.Ignore) {\n\t\t\tthis.info(localize('ProblemMatcherParser.unknownSeverity', 'Info: unknown severity {0}. Valid values are error, warning and info.\\n', description.severity));\n\t\t\tseverity = Severity.Error;\n\t\t}\n\n\t\tif (Types.isString(description.base)) {\n\t\t\tlet variableName = <string>description.base;\n\t\t\tif (variableName.length > 1 && variableName[0] === '$') {\n\t\t\t\tlet base = ProblemMatcherRegistry.get(variableName.substring(1));\n\t\t\t\tif (base) {\n\t\t\t\t\tresult = Objects.deepClone(base);\n\t\t\t\t\tif (description.owner !== undefined && owner !== undefined) {\n\t\t\t\t\t\tresult.owner = owner;\n\t\t\t\t\t}\n\t\t\t\t\tif (description.source !== undefined && source !== undefined) {\n\t\t\t\t\t\tresult.source = source;\n\t\t\t\t\t}\n\t\t\t\t\tif (description.fileLocation !== undefined && fileLocation !== undefined) {\n\t\t\t\t\t\tresult.fileLocation = fileLocation;\n\t\t\t\t\t\tresult.filePrefix = filePrefix;\n\t\t\t\t\t}\n\t\t\t\t\tif (description.pattern !== undefined && pattern !== undefined && pattern !== null) {\n\t\t\t\t\t\tresult.pattern = pattern;\n\t\t\t\t\t}\n\t\t\t\t\tif (description.severity !== undefined && severity !== undefined) {\n\t\t\t\t\t\tresult.severity = severity;\n\t\t\t\t\t}\n\t\t\t\t\tif (description.applyTo !== undefined && applyTo !== undefined) {\n\t\t\t\t\t\tresult.applyTo = applyTo;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (fileLocation && pattern) {\n\t\t\tresult = {\n\t\t\t\towner: owner,\n\t\t\t\tapplyTo: applyTo,\n\t\t\t\tfileLocation: fileLocation,\n\t\t\t\tpattern: pattern,\n\t\t\t};\n\t\t\tif (source) {\n\t\t\t\tresult.source = source;\n\t\t\t}\n\t\t\tif (filePrefix) {\n\t\t\t\tresult.filePrefix = filePrefix;\n\t\t\t}\n\t\t\tif (severity) {\n\t\t\t\tresult.severity = severity;\n\t\t\t}\n\t\t}\n\t\tif (Config.isNamedProblemMatcher(description)) {\n\t\t\t(result as NamedProblemMatcher).name = description.name;\n\t\t\t(result as NamedProblemMatcher).label = Types.isString(description.label) ? description.label : description.name;\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate createProblemPattern(value: string | Config.ProblemPattern | Config.MultiLineProblemPattern): ProblemPattern | ProblemPattern[] | null {\n\t\tif (Types.isString(value)) {\n\t\t\tlet variableName: string = <string>value;\n\t\t\tif (variableName.length > 1 && variableName[0] === '$') {\n\t\t\t\tlet result = ProblemPatternRegistry.get(variableName.substring(1));\n\t\t\t\tif (!result) {\n\t\t\t\t\tthis.error(localize('ProblemMatcherParser.noDefinedPatter', 'Error: the pattern with the identifier {0} doesn\\'t exist.', variableName));\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\tif (variableName.length === 0) {\n\t\t\t\t\tthis.error(localize('ProblemMatcherParser.noIdentifier', 'Error: the pattern property refers to an empty identifier.'));\n\t\t\t\t} else {\n\t\t\t\t\tthis.error(localize('ProblemMatcherParser.noValidIdentifier', 'Error: the pattern property {0} is not a valid pattern variable name.', variableName));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (value) {\n\t\t\tlet problemPatternParser = new ProblemPatternParser(this.problemReporter);\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\treturn problemPatternParser.parse(value);\n\t\t\t} else {\n\t\t\t\treturn problemPatternParser.parse(value);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate addWatchingMatcher(external: Config.ProblemMatcher, internal: ProblemMatcher): void {\n\t\tlet oldBegins = this.createRegularExpression(external.watchedTaskBeginsRegExp);\n\t\tlet oldEnds = this.createRegularExpression(external.watchedTaskEndsRegExp);\n\t\tif (oldBegins && oldEnds) {\n\t\t\tinternal.watching = {\n\t\t\t\tactiveOnStart: false,\n\t\t\t\tbeginsPattern: { regexp: oldBegins },\n\t\t\t\tendsPattern: { regexp: oldEnds }\n\t\t\t};\n\t\t\treturn;\n\t\t}\n\t\tlet backgroundMonitor = external.background || external.watching;\n\t\tif (Types.isUndefinedOrNull(backgroundMonitor)) {\n\t\t\treturn;\n\t\t}\n\t\tlet begins: WatchingPattern | null = this.createWatchingPattern(backgroundMonitor.beginsPattern);\n\t\tlet ends: WatchingPattern | null = this.createWatchingPattern(backgroundMonitor.endsPattern);\n\t\tif (begins && ends) {\n\t\t\tinternal.watching = {\n\t\t\t\tactiveOnStart: Types.isBoolean(backgroundMonitor.activeOnStart) ? backgroundMonitor.activeOnStart : false,\n\t\t\t\tbeginsPattern: begins,\n\t\t\t\tendsPattern: ends\n\t\t\t};\n\t\t\treturn;\n\t\t}\n\t\tif (begins || ends) {\n\t\t\tthis.error(localize('ProblemMatcherParser.problemPattern.watchingMatcher', 'A problem matcher must define both a begin pattern and an end pattern for watching.'));\n\t\t}\n\t}\n\n\tprivate createWatchingPattern(external: string | Config.WatchingPattern | undefined): WatchingPattern | null {\n\t\tif (Types.isUndefinedOrNull(external)) {\n\t\t\treturn null;\n\t\t}\n\t\tlet regexp: RegExp | null;\n\t\tlet file: number | undefined;\n\t\tif (Types.isString(external)) {\n\t\t\tregexp = this.createRegularExpression(external);\n\t\t} else {\n\t\t\tregexp = this.createRegularExpression(external.regexp);\n\t\t\tif (Types.isNumber(external.file)) {\n\t\t\t\tfile = external.file;\n\t\t\t}\n\t\t}\n\t\tif (!regexp) {\n\t\t\treturn null;\n\t\t}\n\t\treturn file ? { regexp, file } : { regexp, file: 1 };\n\t}\n\n\tprivate createRegularExpression(value: string | undefined): RegExp | null {\n\t\tlet result: RegExp | null = null;\n\t\tif (!value) {\n\t\t\treturn result;\n\t\t}\n\t\ttry {\n\t\t\tresult = new RegExp(value);\n\t\t} catch (err) {\n\t\t\tthis.error(localize('ProblemMatcherParser.invalidRegexp', 'Error: The string {0} is not a valid regular expression.\\n', value));\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport namespace Schemas {\n\n\texport const WatchingPattern: IJSONSchema = {\n\t\ttype: 'object',\n\t\tadditionalProperties: false,\n\t\tproperties: {\n\t\t\tregexp: {\n\t\t\t\ttype: 'string',\n\t\t\t\tdescription: localize('WatchingPatternSchema.regexp', 'The regular expression to detect the begin or end of a background task.')\n\t\t\t},\n\t\t\tfile: {\n\t\t\t\ttype: 'integer',\n\t\t\t\tdescription: localize('WatchingPatternSchema.file', 'The match group index of the filename. Can be omitted.')\n\t\t\t},\n\t\t}\n\t};\n\n\n\texport const PatternType: IJSONSchema = {\n\t\tanyOf: [\n\t\t\t{\n\t\t\t\ttype: 'string',\n\t\t\t\tdescription: localize('PatternTypeSchema.name', 'The name of a contributed or predefined pattern')\n\t\t\t},\n\t\t\tSchemas.ProblemPattern,\n\t\t\tSchemas.MultiLineProblemPattern\n\t\t],\n\t\tdescription: localize('PatternTypeSchema.description', 'A problem pattern or the name of a contributed or predefined problem pattern. Can be omitted if base is specified.')\n\t};\n\n\texport const ProblemMatcher: IJSONSchema = {\n\t\ttype: 'object',\n\t\tadditionalProperties: false,\n\t\tproperties: {\n\t\t\tbase: {\n\t\t\t\ttype: 'string',\n\t\t\t\tdescription: localize('ProblemMatcherSchema.base', 'The name of a base problem matcher to use.')\n\t\t\t},\n\t\t\towner: {\n\t\t\t\ttype: 'string',\n\t\t\t\tdescription: localize('ProblemMatcherSchema.owner', 'The owner of the problem inside Code. Can be omitted if base is specified. Defaults to \\'external\\' if omitted and base is not specified.')\n\t\t\t},\n\t\t\tsource: {\n\t\t\t\ttype: 'string',\n\t\t\t\tdescription: localize('ProblemMatcherSchema.source', 'A human-readable string describing the source of this diagnostic, e.g. \\'typescript\\' or \\'super lint\\'.')\n\t\t\t},\n\t\t\tseverity: {\n\t\t\t\ttype: 'string',\n\t\t\t\tenum: ['error', 'warning', 'info'],\n\t\t\t\tdescription: localize('ProblemMatcherSchema.severity', 'The default severity for captures problems. Is used if the pattern doesn\\'t define a match group for severity.')\n\t\t\t},\n\t\t\tapplyTo: {\n\t\t\t\ttype: 'string',\n\t\t\t\tenum: ['allDocuments', 'openDocuments', 'closedDocuments'],\n\t\t\t\tdescription: localize('ProblemMatcherSchema.applyTo', 'Controls if a problem reported on a text document is applied only to open, closed or all documents.')\n\t\t\t},\n\t\t\tpattern: PatternType,\n\t\t\tfileLocation: {\n\t\t\t\toneOf: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tenum: ['absolute', 'relative']\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'array',\n\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\ttype: 'string'\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\tdescription: localize('ProblemMatcherSchema.fileLocation', 'Defines how file names reported in a problem pattern should be interpreted.')\n\t\t\t},\n\t\t\tbackground: {\n\t\t\t\ttype: 'object',\n\t\t\t\tadditionalProperties: false,\n\t\t\t\tdescription: localize('ProblemMatcherSchema.background', 'Patterns to track the begin and end of a matcher active on a background task.'),\n\t\t\t\tproperties: {\n\t\t\t\t\tactiveOnStart: {\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdescription: localize('ProblemMatcherSchema.background.activeOnStart', 'If set to true the background monitor is in active mode when the task starts. This is equals of issuing a line that matches the beginPattern')\n\t\t\t\t\t},\n\t\t\t\t\tbeginsPattern: {\n\t\t\t\t\t\toneOf: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttype: 'string'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tSchemas.WatchingPattern\n\t\t\t\t\t\t],\n\t\t\t\t\t\tdescription: localize('ProblemMatcherSchema.background.beginsPattern', 'If matched in the output the start of a background task is signaled.')\n\t\t\t\t\t},\n\t\t\t\t\tendsPattern: {\n\t\t\t\t\t\toneOf: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttype: 'string'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tSchemas.WatchingPattern\n\t\t\t\t\t\t],\n\t\t\t\t\t\tdescription: localize('ProblemMatcherSchema.background.endsPattern', 'If matched in the output the end of a background task is signaled.')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\twatching: {\n\t\t\t\ttype: 'object',\n\t\t\t\tadditionalProperties: false,\n\t\t\t\tdeprecationMessage: localize('ProblemMatcherSchema.watching.deprecated', 'The watching property is deprecated. Use background instead.'),\n\t\t\t\tdescription: localize('ProblemMatcherSchema.watching', 'Patterns to track the begin and end of a watching matcher.'),\n\t\t\t\tproperties: {\n\t\t\t\t\tactiveOnStart: {\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdescription: localize('ProblemMatcherSchema.watching.activeOnStart', 'If set to true the watcher is in active mode when the task starts. This is equals of issuing a line that matches the beginPattern')\n\t\t\t\t\t},\n\t\t\t\t\tbeginsPattern: {\n\t\t\t\t\t\toneOf: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttype: 'string'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tSchemas.WatchingPattern\n\t\t\t\t\t\t],\n\t\t\t\t\t\tdescription: localize('ProblemMatcherSchema.watching.beginsPattern', 'If matched in the output the start of a watching task is signaled.')\n\t\t\t\t\t},\n\t\t\t\t\tendsPattern: {\n\t\t\t\t\t\toneOf: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttype: 'string'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tSchemas.WatchingPattern\n\t\t\t\t\t\t],\n\t\t\t\t\t\tdescription: localize('ProblemMatcherSchema.watching.endsPattern', 'If matched in the output the end of a watching task is signaled.')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\texport const LegacyProblemMatcher: IJSONSchema = Objects.deepClone(ProblemMatcher);\n\tLegacyProblemMatcher.properties = Objects.deepClone(LegacyProblemMatcher.properties) || {};\n\tLegacyProblemMatcher.properties['watchedTaskBeginsRegExp'] = {\n\t\ttype: 'string',\n\t\tdeprecationMessage: localize('LegacyProblemMatcherSchema.watchedBegin.deprecated', 'This property is deprecated. Use the watching property instead.'),\n\t\tdescription: localize('LegacyProblemMatcherSchema.watchedBegin', 'A regular expression signaling that a watched tasks begins executing triggered through file watching.')\n\t};\n\tLegacyProblemMatcher.properties['watchedTaskEndsRegExp'] = {\n\t\ttype: 'string',\n\t\tdeprecationMessage: localize('LegacyProblemMatcherSchema.watchedEnd.deprecated', 'This property is deprecated. Use the watching property instead.'),\n\t\tdescription: localize('LegacyProblemMatcherSchema.watchedEnd', 'A regular expression signaling that a watched tasks ends executing.')\n\t};\n\n\texport const NamedProblemMatcher: IJSONSchema = Objects.deepClone(ProblemMatcher);\n\tNamedProblemMatcher.properties = Objects.deepClone(NamedProblemMatcher.properties) || {};\n\tNamedProblemMatcher.properties.name = {\n\t\ttype: 'string',\n\t\tdescription: localize('NamedProblemMatcherSchema.name', 'The name of the problem matcher used to refer to it.')\n\t};\n\tNamedProblemMatcher.properties.label = {\n\t\ttype: 'string',\n\t\tdescription: localize('NamedProblemMatcherSchema.label', 'A human readable label of the problem matcher.')\n\t};\n}\n\nconst problemMatchersExtPoint = ExtensionsRegistry.registerExtensionPoint<Config.NamedProblemMatcher[]>({\n\textensionPoint: 'problemMatchers',\n\tdeps: [problemPatternExtPoint],\n\tjsonSchema: {\n\t\tdescription: localize('ProblemMatcherExtPoint', 'Contributes problem matchers'),\n\t\ttype: 'array',\n\t\titems: Schemas.NamedProblemMatcher\n\t}\n});\n\nexport interface IProblemMatcherRegistry {\n\tonReady(): Promise<void>;\n\tget(name: string): NamedProblemMatcher;\n\tkeys(): string[];\n\treadonly onMatcherChanged: Event<void>;\n}\n\nclass ProblemMatcherRegistryImpl implements IProblemMatcherRegistry {\n\n\tprivate matchers: IStringDictionary<NamedProblemMatcher>;\n\tprivate readyPromise: Promise<void>;\n\tprivate readonly _onMatchersChanged: Emitter<void> = new Emitter<void>();\n\tpublic get onMatcherChanged(): Event<void> { return this._onMatchersChanged.event; }\n\n\n\tconstructor() {\n\t\tthis.matchers = Object.create(null);\n\t\tthis.fillDefaults();\n\t\tthis.readyPromise = new Promise<void>((resolve, reject) => {\n\t\t\tproblemMatchersExtPoint.setHandler((extensions, delta) => {\n\t\t\t\ttry {\n\t\t\t\t\tdelta.removed.forEach(extension => {\n\t\t\t\t\t\tlet problemMatchers = extension.value;\n\t\t\t\t\t\tfor (let matcher of problemMatchers) {\n\t\t\t\t\t\t\tif (this.matchers[matcher.name]) {\n\t\t\t\t\t\t\t\tdelete this.matchers[matcher.name];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tdelta.added.forEach(extension => {\n\t\t\t\t\t\tlet problemMatchers = extension.value;\n\t\t\t\t\t\tlet parser = new ProblemMatcherParser(new ExtensionRegistryReporter(extension.collector));\n\t\t\t\t\t\tfor (let matcher of problemMatchers) {\n\t\t\t\t\t\t\tlet result = parser.parse(matcher);\n\t\t\t\t\t\t\tif (result && isNamedProblemMatcher(result)) {\n\t\t\t\t\t\t\t\tthis.add(result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif ((delta.removed.length > 0) || (delta.added.length > 0)) {\n\t\t\t\t\t\tthis._onMatchersChanged.fire();\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t}\n\t\t\t\tlet matcher = this.get('tsc-watch');\n\t\t\t\tif (matcher) {\n\t\t\t\t\t(<any>matcher).tscWatch = true;\n\t\t\t\t}\n\t\t\t\tresolve(undefined);\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic onReady(): Promise<void> {\n\t\tProblemPatternRegistry.onReady();\n\t\treturn this.readyPromise;\n\t}\n\n\tpublic add(matcher: NamedProblemMatcher): void {\n\t\tthis.matchers[matcher.name] = matcher;\n\t}\n\n\tpublic get(name: string): NamedProblemMatcher {\n\t\treturn this.matchers[name];\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn Object.keys(this.matchers);\n\t}\n\n\tprivate fillDefaults(): void {\n\t\tthis.add({\n\t\t\tname: 'msCompile',\n\t\t\tlabel: localize('msCompile', 'Microsoft compiler problems'),\n\t\t\towner: 'msCompile',\n\t\t\tapplyTo: ApplyToKind.allDocuments,\n\t\t\tfileLocation: FileLocationKind.Absolute,\n\t\t\tpattern: ProblemPatternRegistry.get('msCompile')\n\t\t});\n\n\t\tthis.add({\n\t\t\tname: 'lessCompile',\n\t\t\tlabel: localize('lessCompile', 'Less problems'),\n\t\t\tdeprecated: true,\n\t\t\towner: 'lessCompile',\n\t\t\tsource: 'less',\n\t\t\tapplyTo: ApplyToKind.allDocuments,\n\t\t\tfileLocation: FileLocationKind.Absolute,\n\t\t\tpattern: ProblemPatternRegistry.get('lessCompile'),\n\t\t\tseverity: Severity.Error\n\t\t});\n\n\t\tthis.add({\n\t\t\tname: 'gulp-tsc',\n\t\t\tlabel: localize('gulp-tsc', 'Gulp TSC Problems'),\n\t\t\towner: 'typescript',\n\t\t\tsource: 'ts',\n\t\t\tapplyTo: ApplyToKind.closedDocuments,\n\t\t\tfileLocation: FileLocationKind.Relative,\n\t\t\tfilePrefix: '${workspaceFolder}',\n\t\t\tpattern: ProblemPatternRegistry.get('gulp-tsc')\n\t\t});\n\n\t\tthis.add({\n\t\t\tname: 'jshint',\n\t\t\tlabel: localize('jshint', 'JSHint problems'),\n\t\t\towner: 'jshint',\n\t\t\tsource: 'jshint',\n\t\t\tapplyTo: ApplyToKind.allDocuments,\n\t\t\tfileLocation: FileLocationKind.Absolute,\n\t\t\tpattern: ProblemPatternRegistry.get('jshint')\n\t\t});\n\n\t\tthis.add({\n\t\t\tname: 'jshint-stylish',\n\t\t\tlabel: localize('jshint-stylish', 'JSHint stylish problems'),\n\t\t\towner: 'jshint',\n\t\t\tsource: 'jshint',\n\t\t\tapplyTo: ApplyToKind.allDocuments,\n\t\t\tfileLocation: FileLocationKind.Absolute,\n\t\t\tpattern: ProblemPatternRegistry.get('jshint-stylish')\n\t\t});\n\n\t\tthis.add({\n\t\t\tname: 'eslint-compact',\n\t\t\tlabel: localize('eslint-compact', 'ESLint compact problems'),\n\t\t\towner: 'eslint',\n\t\t\tsource: 'eslint',\n\t\t\tapplyTo: ApplyToKind.allDocuments,\n\t\t\tfileLocation: FileLocationKind.Absolute,\n\t\t\tfilePrefix: '${workspaceFolder}',\n\t\t\tpattern: ProblemPatternRegistry.get('eslint-compact')\n\t\t});\n\n\t\tthis.add({\n\t\t\tname: 'eslint-stylish',\n\t\t\tlabel: localize('eslint-stylish', 'ESLint stylish problems'),\n\t\t\towner: 'eslint',\n\t\t\tsource: 'eslint',\n\t\t\tapplyTo: ApplyToKind.allDocuments,\n\t\t\tfileLocation: FileLocationKind.Absolute,\n\t\t\tpattern: ProblemPatternRegistry.get('eslint-stylish')\n\t\t});\n\n\t\tthis.add({\n\t\t\tname: 'go',\n\t\t\tlabel: localize('go', 'Go problems'),\n\t\t\towner: 'go',\n\t\t\tsource: 'go',\n\t\t\tapplyTo: ApplyToKind.allDocuments,\n\t\t\tfileLocation: FileLocationKind.Relative,\n\t\t\tfilePrefix: '${workspaceFolder}',\n\t\t\tpattern: ProblemPatternRegistry.get('go')\n\t\t});\n\t}\n}\n\nexport const ProblemMatcherRegistry: IProblemMatcherRegistry = new ProblemMatcherRegistryImpl();\n"]}]}