{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/node/request.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/request.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar types_1 = require(\"vs/base/common/types\");\nvar url_1 = require(\"url\");\nvar fs_1 = require(\"fs\");\nvar objects_1 = require(\"vs/base/common/objects\");\nvar zlib_1 = require(\"zlib\");\nvar errors_1 = require(\"vs/base/common/errors\");\nfunction getNodeRequest(options) {\n    return tslib_1.__awaiter(this, void 0, Promise, function () {\n        var endpoint, module, _a;\n        return tslib_1.__generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    endpoint = url_1.parse(options.url);\n                    if (!(endpoint.protocol === 'https:')) return [3 /*break*/, 2];\n                    return [4 /*yield*/, Promise.resolve().then(function () { return require('https'); })];\n                case 1:\n                    _a = _b.sent();\n                    return [3 /*break*/, 4];\n                case 2: return [4 /*yield*/, Promise.resolve().then(function () { return require('http'); })];\n                case 3:\n                    _a = _b.sent();\n                    _b.label = 4;\n                case 4:\n                    module = _a;\n                    return [2 /*return*/, module.request];\n            }\n        });\n    });\n}\nfunction request(options, token) {\n    var req;\n    var rawRequestPromise = options.getRawRequest\n        ? Promise.resolve(options.getRawRequest(options))\n        : Promise.resolve(getNodeRequest(options));\n    return rawRequestPromise.then(function (rawRequest) {\n        return new Promise(function (c, e) {\n            var endpoint = url_1.parse(options.url);\n            var opts = {\n                hostname: endpoint.hostname,\n                port: endpoint.port ? parseInt(endpoint.port) : (endpoint.protocol === 'https:' ? 443 : 80),\n                protocol: endpoint.protocol,\n                path: endpoint.path,\n                method: options.type || 'GET',\n                headers: options.headers,\n                agent: options.agent,\n                rejectUnauthorized: types_1.isBoolean(options.strictSSL) ? options.strictSSL : true\n            };\n            if (options.user && options.password) {\n                opts.auth = options.user + ':' + options.password;\n            }\n            req = rawRequest(opts, function (res) {\n                var followRedirects = types_1.isNumber(options.followRedirects) ? options.followRedirects : 3;\n                if (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && followRedirects > 0 && res.headers['location']) {\n                    request(objects_1.assign({}, options, {\n                        url: res.headers['location'],\n                        followRedirects: followRedirects - 1\n                    }), token).then(c, e);\n                }\n                else {\n                    var stream = res;\n                    if (res.headers['content-encoding'] === 'gzip') {\n                        stream = stream.pipe(zlib_1.createGunzip());\n                    }\n                    c({ res: res, stream: stream });\n                }\n            });\n            req.on('error', e);\n            if (options.timeout) {\n                req.setTimeout(options.timeout);\n            }\n            if (options.data) {\n                if (typeof options.data === 'string') {\n                    req.write(options.data);\n                }\n                else {\n                    options.data.pipe(req);\n                    return;\n                }\n            }\n            req.end();\n            token.onCancellationRequested(function () {\n                req.abort();\n                e(errors_1.canceled());\n            });\n        });\n    });\n}\nexports.request = request;\nfunction isSuccess(context) {\n    return (context.res.statusCode && context.res.statusCode >= 200 && context.res.statusCode < 300) || context.res.statusCode === 1223;\n}\nfunction hasNoContent(context) {\n    return context.res.statusCode === 204;\n}\nfunction download(filePath, context) {\n    return new Promise(function (c, e) {\n        var out = fs_1.createWriteStream(filePath);\n        out.once('finish', function () { return c(undefined); });\n        context.stream.once('error', e);\n        context.stream.pipe(out);\n    });\n}\nexports.download = download;\nfunction asText(context) {\n    return new Promise(function (c, e) {\n        if (!isSuccess(context)) {\n            return e('Server returned ' + context.res.statusCode);\n        }\n        if (hasNoContent(context)) {\n            return c(null);\n        }\n        var buffer = [];\n        context.stream.on('data', function (d) { return buffer.push(d); });\n        context.stream.on('end', function () { return c(buffer.join('')); });\n        context.stream.on('error', e);\n    });\n}\nexports.asText = asText;\nfunction asJson(context) {\n    return new Promise(function (c, e) {\n        if (!isSuccess(context)) {\n            return e('Server returned ' + context.res.statusCode);\n        }\n        if (hasNoContent(context)) {\n            return c(null);\n        }\n        var buffer = [];\n        context.stream.on('data', function (d) { return buffer.push(d); });\n        context.stream.on('end', function () {\n            try {\n                c(JSON.parse(buffer.join('')));\n            }\n            catch (err) {\n                e(err);\n            }\n        });\n        context.stream.on('error', e);\n    });\n}\nexports.asJson = asJson;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/node/request.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/node/request.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isBoolean, isNumber } from 'vs/base/common/types';\nimport * as https from 'https';\nimport * as http from 'http';\nimport { Stream } from 'stream';\nimport { parse as parseUrl } from 'url';\nimport { createWriteStream } from 'fs';\nimport { assign } from 'vs/base/common/objects';\nimport { createGunzip } from 'zlib';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { canceled } from 'vs/base/common/errors';\n\nexport type Agent = any;\n\nexport interface IRawRequestFunction {\n\t(options: http.RequestOptions, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n}\n\nexport interface IRequestOptions {\n\ttype?: string;\n\turl?: string;\n\tuser?: string;\n\tpassword?: string;\n\theaders?: any;\n\ttimeout?: number;\n\tdata?: string | Stream;\n\tagent?: Agent;\n\tfollowRedirects?: number;\n\tstrictSSL?: boolean;\n\tgetRawRequest?(options: IRequestOptions): IRawRequestFunction;\n}\n\nexport interface IRequestContext {\n\t// req: http.ClientRequest;\n\t// res: http.ClientResponse;\n\tres: {\n\t\theaders: { [n: string]: string };\n\t\tstatusCode?: number;\n\t};\n\tstream: Stream;\n}\n\nexport interface IRequestFunction {\n\t(options: IRequestOptions, token: CancellationToken): Promise<IRequestContext>;\n}\n\nasync function getNodeRequest(options: IRequestOptions): Promise<IRawRequestFunction> {\n\tconst endpoint = parseUrl(options.url!);\n\tconst module = endpoint.protocol === 'https:' ? await import('https') : await import('http');\n\treturn module.request;\n}\n\nexport function request(options: IRequestOptions, token: CancellationToken): Promise<IRequestContext> {\n\tlet req: http.ClientRequest;\n\n\tconst rawRequestPromise = options.getRawRequest\n\t\t? Promise.resolve(options.getRawRequest(options))\n\t\t: Promise.resolve(getNodeRequest(options));\n\n\treturn rawRequestPromise.then(rawRequest => {\n\n\t\treturn new Promise<IRequestContext>((c, e) => {\n\t\t\tconst endpoint = parseUrl(options.url!);\n\n\t\t\tconst opts: https.RequestOptions = {\n\t\t\t\thostname: endpoint.hostname,\n\t\t\t\tport: endpoint.port ? parseInt(endpoint.port) : (endpoint.protocol === 'https:' ? 443 : 80),\n\t\t\t\tprotocol: endpoint.protocol,\n\t\t\t\tpath: endpoint.path,\n\t\t\t\tmethod: options.type || 'GET',\n\t\t\t\theaders: options.headers,\n\t\t\t\tagent: options.agent,\n\t\t\t\trejectUnauthorized: isBoolean(options.strictSSL) ? options.strictSSL : true\n\t\t\t};\n\n\t\t\tif (options.user && options.password) {\n\t\t\t\topts.auth = options.user + ':' + options.password;\n\t\t\t}\n\n\t\t\treq = rawRequest(opts, (res: http.IncomingMessage) => {\n\t\t\t\tconst followRedirects: number = isNumber(options.followRedirects) ? options.followRedirects : 3;\n\t\t\t\tif (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && followRedirects > 0 && res.headers['location']) {\n\t\t\t\t\trequest(assign({}, options, {\n\t\t\t\t\t\turl: res.headers['location'],\n\t\t\t\t\t\tfollowRedirects: followRedirects - 1\n\t\t\t\t\t}), token).then(c, e);\n\t\t\t\t} else {\n\t\t\t\t\tlet stream: Stream = res;\n\n\t\t\t\t\tif (res.headers['content-encoding'] === 'gzip') {\n\t\t\t\t\t\tstream = stream.pipe(createGunzip());\n\t\t\t\t\t}\n\n\t\t\t\t\tc({ res, stream } as IRequestContext);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treq.on('error', e);\n\n\t\t\tif (options.timeout) {\n\t\t\t\treq.setTimeout(options.timeout);\n\t\t\t}\n\n\t\t\tif (options.data) {\n\t\t\t\tif (typeof options.data === 'string') {\n\t\t\t\t\treq.write(options.data);\n\t\t\t\t} else {\n\t\t\t\t\toptions.data.pipe(req);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treq.end();\n\n\t\t\ttoken.onCancellationRequested(() => {\n\t\t\t\treq.abort();\n\t\t\t\te(canceled());\n\t\t\t});\n\t\t});\n\t});\n}\n\nfunction isSuccess(context: IRequestContext): boolean {\n\treturn (context.res.statusCode && context.res.statusCode >= 200 && context.res.statusCode < 300) || context.res.statusCode === 1223;\n}\n\nfunction hasNoContent(context: IRequestContext): boolean {\n\treturn context.res.statusCode === 204;\n}\n\nexport function download(filePath: string, context: IRequestContext): Promise<void> {\n\treturn new Promise<void>((c, e) => {\n\t\tconst out = createWriteStream(filePath);\n\n\t\tout.once('finish', () => c(undefined));\n\t\tcontext.stream.once('error', e);\n\t\tcontext.stream.pipe(out);\n\t});\n}\n\nexport function asText(context: IRequestContext): Promise<string | null> {\n\treturn new Promise((c, e) => {\n\t\tif (!isSuccess(context)) {\n\t\t\treturn e('Server returned ' + context.res.statusCode);\n\t\t}\n\n\t\tif (hasNoContent(context)) {\n\t\t\treturn c(null);\n\t\t}\n\n\t\tconst buffer: string[] = [];\n\t\tcontext.stream.on('data', (d: string) => buffer.push(d));\n\t\tcontext.stream.on('end', () => c(buffer.join('')));\n\t\tcontext.stream.on('error', e);\n\t});\n}\n\nexport function asJson<T>(context: IRequestContext): Promise<T | null> {\n\treturn new Promise((c, e) => {\n\t\tif (!isSuccess(context)) {\n\t\t\treturn e('Server returned ' + context.res.statusCode);\n\t\t}\n\n\t\tif (hasNoContent(context)) {\n\t\t\treturn c(null);\n\t\t}\n\n\t\tconst buffer: string[] = [];\n\t\tcontext.stream.on('data', (d: string) => buffer.push(d));\n\t\tcontext.stream.on('end', () => {\n\t\t\ttry {\n\t\t\t\tc(JSON.parse(buffer.join('')));\n\t\t\t} catch (err) {\n\t\t\t\te(err);\n\t\t\t}\n\t\t});\n\t\tcontext.stream.on('error', e);\n\t});\n}\n"]}]}