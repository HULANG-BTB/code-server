{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/node/textSearchManager.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/node/textSearchManager.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/path\", \"vs/base/common/arrays\", \"vs/base/common/cancellation\", \"vs/base/common/errorMessage\", \"vs/base/common/glob\", \"vs/base/common/resources\", \"vs/base/common/uri\", \"vs/base/node/encoding\", \"vs/base/node/extfs\", \"vs/workbench/services/search/common/search\"], function (require, exports, path, arrays_1, cancellation_1, errorMessage_1, glob, resources, uri_1, encoding_1, extfs, search_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class TextSearchManager {\n        constructor(query, provider, _extfs = extfs) {\n            this.query = query;\n            this.provider = provider;\n            this._extfs = _extfs;\n            this.resultCount = 0;\n        }\n        search(onProgress, token) {\n            const folderQueries = this.query.folderQueries || [];\n            const tokenSource = new cancellation_1.CancellationTokenSource();\n            token.onCancellationRequested(() => tokenSource.cancel());\n            return new Promise((resolve, reject) => {\n                this.collector = new TextSearchResultsCollector(onProgress);\n                let isCanceled = false;\n                const onResult = (result, folderIdx) => {\n                    if (isCanceled) {\n                        return;\n                    }\n                    if (!this.isLimitHit) {\n                        const resultSize = this.resultSize(result);\n                        if (extensionResultIsMatch(result) && typeof this.query.maxResults === 'number' && this.resultCount + resultSize > this.query.maxResults) {\n                            this.isLimitHit = true;\n                            isCanceled = true;\n                            tokenSource.cancel();\n                            result = this.trimResultToSize(result, this.query.maxResults - this.resultCount);\n                        }\n                        const newResultSize = this.resultSize(result);\n                        this.resultCount += newResultSize;\n                        if (newResultSize > 0) {\n                            this.collector.add(result, folderIdx);\n                        }\n                    }\n                };\n                // For each root folder\n                Promise.all(folderQueries.map((fq, i) => {\n                    return this.searchInFolder(fq, r => onResult(r, i), tokenSource.token);\n                })).then(results => {\n                    tokenSource.dispose();\n                    this.collector.flush();\n                    const someFolderHitLImit = results.some(result => !!result && !!result.limitHit);\n                    resolve({\n                        limitHit: this.isLimitHit || someFolderHitLImit,\n                        stats: {\n                            type: 'textSearchProvider'\n                        }\n                    });\n                }, (err) => {\n                    tokenSource.dispose();\n                    const errMsg = errorMessage_1.toErrorMessage(err);\n                    reject(new Error(errMsg));\n                });\n            });\n        }\n        resultSize(result) {\n            const match = result;\n            return Array.isArray(match.ranges) ?\n                match.ranges.length :\n                1;\n        }\n        trimResultToSize(result, size) {\n            const rangesArr = Array.isArray(result.ranges) ? result.ranges : [result.ranges];\n            const matchesArr = Array.isArray(result.preview.matches) ? result.preview.matches : [result.preview.matches];\n            return {\n                ranges: rangesArr.slice(0, size),\n                preview: {\n                    matches: matchesArr.slice(0, size),\n                    text: result.preview.text\n                },\n                uri: result.uri\n            };\n        }\n        searchInFolder(folderQuery, onResult, token) {\n            const queryTester = new search_1.QueryGlobTester(this.query, folderQuery);\n            const testingPs = [];\n            const progress = {\n                report: (result) => {\n                    if (!this.validateProviderResult(result)) {\n                        return;\n                    }\n                    const hasSibling = folderQuery.folder.scheme === 'file' ?\n                        glob.hasSiblingPromiseFn(() => {\n                            return this.readdir(path.dirname(result.uri.fsPath));\n                        }) :\n                        undefined;\n                    const relativePath = path.relative(folderQuery.folder.fsPath, result.uri.fsPath);\n                    testingPs.push(queryTester.includedInQuery(relativePath, path.basename(relativePath), hasSibling)\n                        .then(included => {\n                        if (included) {\n                            onResult(result);\n                        }\n                    }));\n                }\n            };\n            const searchOptions = this.getSearchOptionsForFolder(folderQuery);\n            return new Promise(resolve => process.nextTick(resolve))\n                .then(() => this.provider.provideTextSearchResults(patternInfoToQuery(this.query.contentPattern), searchOptions, progress, token))\n                .then(result => {\n                return Promise.all(testingPs)\n                    .then(() => result);\n            });\n        }\n        validateProviderResult(result) {\n            if (extensionResultIsMatch(result)) {\n                if (Array.isArray(result.ranges)) {\n                    if (!Array.isArray(result.preview.matches)) {\n                        console.warn('INVALID - A text search provider match\\'s`ranges` and`matches` properties must have the same type.');\n                        return false;\n                    }\n                    if (result.preview.matches.length !== result.ranges.length) {\n                        console.warn('INVALID - A text search provider match\\'s`ranges` and`matches` properties must have the same length.');\n                        return false;\n                    }\n                }\n                else {\n                    if (Array.isArray(result.preview.matches)) {\n                        console.warn('INVALID - A text search provider match\\'s`ranges` and`matches` properties must have the same length.');\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        readdir(dirname) {\n            return new Promise((resolve, reject) => {\n                this._extfs.readdir(dirname, (err, files) => {\n                    if (err) {\n                        return reject(err);\n                    }\n                    resolve(files);\n                });\n            });\n        }\n        getSearchOptionsForFolder(fq) {\n            const includes = search_1.resolvePatternsForProvider(this.query.includePattern, fq.includePattern);\n            const excludes = search_1.resolvePatternsForProvider(this.query.excludePattern, fq.excludePattern);\n            const options = {\n                folder: uri_1.URI.from(fq.folder),\n                excludes,\n                includes,\n                useIgnoreFiles: !fq.disregardIgnoreFiles,\n                useGlobalIgnoreFiles: !fq.disregardGlobalIgnoreFiles,\n                followSymlinks: !fq.ignoreSymlinks,\n                encoding: fq.fileEncoding && encoding_1.toCanonicalName(fq.fileEncoding),\n                maxFileSize: this.query.maxFileSize,\n                maxResults: this.query.maxResults,\n                previewOptions: this.query.previewOptions,\n                afterContext: this.query.afterContext,\n                beforeContext: this.query.beforeContext\n            };\n            options.usePCRE2 = this.query.usePCRE2;\n            return options;\n        }\n    }\n    exports.TextSearchManager = TextSearchManager;\n    function patternInfoToQuery(patternInfo) {\n        return {\n            isCaseSensitive: patternInfo.isCaseSensitive || false,\n            isRegExp: patternInfo.isRegExp || false,\n            isWordMatch: patternInfo.isWordMatch || false,\n            isMultiline: patternInfo.isMultiline || false,\n            pattern: patternInfo.pattern\n        };\n    }\n    class TextSearchResultsCollector {\n        constructor(_onResult) {\n            this._onResult = _onResult;\n            this._currentFileMatch = null;\n            this._batchedCollector = new BatchedCollector(512, items => this.sendItems(items));\n        }\n        add(data, folderIdx) {\n            // Collects TextSearchResults into IInternalFileMatches and collates using BatchedCollector.\n            // This is efficient for ripgrep which sends results back one file at a time. It wouldn't be efficient for other search\n            // providers that send results in random order. We could do this step afterwards instead.\n            if (this._currentFileMatch && (this._currentFolderIdx !== folderIdx || !resources.isEqual(this._currentUri, data.uri))) {\n                this.pushToCollector();\n                this._currentFileMatch = null;\n            }\n            if (!this._currentFileMatch) {\n                this._currentFolderIdx = folderIdx;\n                this._currentFileMatch = {\n                    resource: data.uri,\n                    results: []\n                };\n            }\n            this._currentFileMatch.results.push(extensionResultToFrontendResult(data));\n        }\n        pushToCollector() {\n            const size = this._currentFileMatch && this._currentFileMatch.results ?\n                this._currentFileMatch.results.length :\n                0;\n            this._batchedCollector.addItem(this._currentFileMatch, size);\n        }\n        flush() {\n            this.pushToCollector();\n            this._batchedCollector.flush();\n        }\n        sendItems(items) {\n            this._onResult(items);\n        }\n    }\n    exports.TextSearchResultsCollector = TextSearchResultsCollector;\n    function extensionResultToFrontendResult(data) {\n        // Warning: result from RipgrepTextSearchEH has fake vscode.Range. Don't depend on any other props beyond these...\n        if (extensionResultIsMatch(data)) {\n            return {\n                preview: {\n                    matches: arrays_1.mapArrayOrNot(data.preview.matches, m => ({\n                        startLineNumber: m.start.line,\n                        startColumn: m.start.character,\n                        endLineNumber: m.end.line,\n                        endColumn: m.end.character\n                    })),\n                    text: data.preview.text\n                },\n                ranges: arrays_1.mapArrayOrNot(data.ranges, r => ({\n                    startLineNumber: r.start.line,\n                    startColumn: r.start.character,\n                    endLineNumber: r.end.line,\n                    endColumn: r.end.character\n                }))\n            };\n        }\n        else {\n            return {\n                text: data.text,\n                lineNumber: data.lineNumber\n            };\n        }\n    }\n    function extensionResultIsMatch(data) {\n        return !!data.preview;\n    }\n    exports.extensionResultIsMatch = extensionResultIsMatch;\n    /**\n     * Collects items that have a size - before the cumulative size of collected items reaches START_BATCH_AFTER_COUNT, the callback is called for every\n     * set of items collected.\n     * But after that point, the callback is called with batches of maxBatchSize.\n     * If the batch isn't filled within some time, the callback is also called.\n     */\n    class BatchedCollector {\n        constructor(maxBatchSize, cb) {\n            this.maxBatchSize = maxBatchSize;\n            this.cb = cb;\n            this.totalNumberCompleted = 0;\n            this.batch = [];\n            this.batchSize = 0;\n        }\n        addItem(item, size) {\n            if (!item) {\n                return;\n            }\n            this.addItemToBatch(item, size);\n        }\n        addItems(items, size) {\n            if (!items) {\n                return;\n            }\n            this.addItemsToBatch(items, size);\n        }\n        addItemToBatch(item, size) {\n            this.batch.push(item);\n            this.batchSize += size;\n            this.onUpdate();\n        }\n        addItemsToBatch(item, size) {\n            this.batch = this.batch.concat(item);\n            this.batchSize += size;\n            this.onUpdate();\n        }\n        onUpdate() {\n            if (this.totalNumberCompleted < BatchedCollector.START_BATCH_AFTER_COUNT) {\n                // Flush because we aren't batching yet\n                this.flush();\n            }\n            else if (this.batchSize >= this.maxBatchSize) {\n                // Flush because the batch is full\n                this.flush();\n            }\n            else if (!this.timeoutHandle) {\n                // No timeout running, start a timeout to flush\n                this.timeoutHandle = setTimeout(() => {\n                    this.flush();\n                }, BatchedCollector.TIMEOUT);\n            }\n        }\n        flush() {\n            if (this.batchSize) {\n                this.totalNumberCompleted += this.batchSize;\n                this.cb(this.batch);\n                this.batch = [];\n                this.batchSize = 0;\n                if (this.timeoutHandle) {\n                    clearTimeout(this.timeoutHandle);\n                    this.timeoutHandle = 0;\n                }\n            }\n        }\n    }\n    BatchedCollector.TIMEOUT = 4000;\n    // After START_BATCH_AFTER_COUNT items have been collected, stop flushing on timeout\n    BatchedCollector.START_BATCH_AFTER_COUNT = 50;\n    exports.BatchedCollector = BatchedCollector;\n});\n",null]}