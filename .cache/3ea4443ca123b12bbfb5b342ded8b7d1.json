{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/node/rawSearchService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/node/rawSearchService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"fs\", \"graceful-fs\", \"vs/base/common/path\", \"vs/base/common/arrays\", \"vs/base/common/async\", \"vs/base/common/errors\", \"vs/base/common/event\", \"vs/base/common/objects\", \"vs/base/common/stopwatch\", \"vs/base/common/strings\", \"vs/base/common/uri\", \"vs/base/parts/quickopen/common/quickOpenScorer\", \"vs/platform/files/node/fileConstants\", \"vs/workbench/services/search/node/fileSearch\", \"vs/workbench/services/search/node/textSearchAdapter\"], function (require, exports, fs, gracefulFs, path_1, arrays, async_1, errors_1, event_1, objects, stopwatch_1, strings, uri_1, quickOpenScorer_1, fileConstants_1, fileSearch_1, textSearchAdapter_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    gracefulFs.gracefulify(fs);\n    class SearchService {\n        constructor() {\n            this.caches = Object.create(null);\n        }\n        fileSearch(config) {\n            let promise;\n            const query = reviveQuery(config);\n            const emitter = new event_1.Emitter({\n                onFirstListenerDidAdd: () => {\n                    promise = async_1.createCancelablePromise(token => {\n                        return this.doFileSearchWithEngine(fileSearch_1.Engine, query, p => emitter.fire(p), token);\n                    });\n                    promise.then(c => emitter.fire(c), err => emitter.fire({ type: 'error', error: { message: err.message, stack: err.stack } }));\n                },\n                onLastListenerRemove: () => {\n                    promise.cancel();\n                }\n            });\n            return emitter.event;\n        }\n        textSearch(rawQuery) {\n            let promise;\n            const query = reviveQuery(rawQuery);\n            const emitter = new event_1.Emitter({\n                onFirstListenerDidAdd: () => {\n                    promise = async_1.createCancelablePromise(token => {\n                        return this.ripgrepTextSearch(query, p => emitter.fire(p), token);\n                    });\n                    promise.then(c => emitter.fire(c), err => emitter.fire({ type: 'error', error: { message: err.message, stack: err.stack } }));\n                },\n                onLastListenerRemove: () => {\n                    promise.cancel();\n                }\n            });\n            return emitter.event;\n        }\n        ripgrepTextSearch(config, progressCallback, token) {\n            config.maxFileSize = fileConstants_1.MAX_FILE_SIZE;\n            const engine = new textSearchAdapter_1.TextSearchEngineAdapter(config);\n            return engine.search(token, progressCallback, progressCallback);\n        }\n        doFileSearch(config, progressCallback, token) {\n            return this.doFileSearchWithEngine(fileSearch_1.Engine, config, progressCallback, token);\n        }\n        doFileSearchWithEngine(EngineClass, config, progressCallback, token, batchSize = SearchService.BATCH_SIZE) {\n            let resultCount = 0;\n            const fileProgressCallback = progress => {\n                if (Array.isArray(progress)) {\n                    resultCount += progress.length;\n                    progressCallback(progress.map(m => this.rawMatchToSearchItem(m)));\n                }\n                else if (progress.relativePath) {\n                    resultCount++;\n                    progressCallback(this.rawMatchToSearchItem(progress));\n                }\n                else {\n                    progressCallback(progress);\n                }\n            };\n            if (config.sortByScore) {\n                let sortedSearch = this.trySortedSearchFromCache(config, fileProgressCallback, token);\n                if (!sortedSearch) {\n                    const walkerConfig = config.maxResults ? objects.assign({}, config, { maxResults: null }) : config;\n                    const engine = new EngineClass(walkerConfig);\n                    sortedSearch = this.doSortedSearch(engine, config, progressCallback, fileProgressCallback, token);\n                }\n                return new Promise((c, e) => {\n                    sortedSearch.then(([result, rawMatches]) => {\n                        const serializedMatches = rawMatches.map(rawMatch => this.rawMatchToSearchItem(rawMatch));\n                        this.sendProgress(serializedMatches, progressCallback, batchSize);\n                        c(result);\n                    }, e);\n                });\n            }\n            const engine = new EngineClass(config);\n            return this.doSearch(engine, fileProgressCallback, batchSize, token).then(complete => {\n                return {\n                    limitHit: complete.limitHit,\n                    type: 'success',\n                    stats: {\n                        detailStats: complete.stats,\n                        type: 'searchProcess',\n                        fromCache: false,\n                        resultCount,\n                        sortingTime: undefined\n                    }\n                };\n            });\n        }\n        rawMatchToSearchItem(match) {\n            return { path: match.base ? path_1.join(match.base, match.relativePath) : match.relativePath };\n        }\n        doSortedSearch(engine, config, progressCallback, fileProgressCallback, token) {\n            const emitter = new event_1.Emitter();\n            let allResultsPromise = async_1.createCancelablePromise(token => {\n                let results = [];\n                const innerProgressCallback = progress => {\n                    if (Array.isArray(progress)) {\n                        results = progress;\n                    }\n                    else {\n                        fileProgressCallback(progress);\n                        emitter.fire(progress);\n                    }\n                };\n                return this.doSearch(engine, innerProgressCallback, -1, token)\n                    .then(result => {\n                    return [result, results];\n                });\n            });\n            let cache;\n            if (config.cacheKey) {\n                cache = this.getOrCreateCache(config.cacheKey);\n                const cacheRow = {\n                    promise: allResultsPromise,\n                    event: emitter.event,\n                    resolved: false\n                };\n                cache.resultsToSearchCache[config.filePattern || ''] = cacheRow;\n                allResultsPromise.then(() => {\n                    cacheRow.resolved = true;\n                }, err => {\n                    delete cache.resultsToSearchCache[config.filePattern || ''];\n                });\n                allResultsPromise = this.preventCancellation(allResultsPromise);\n            }\n            return allResultsPromise.then(([result, results]) => {\n                const scorerCache = cache ? cache.scorerCache : Object.create(null);\n                const sortSW = (typeof config.maxResults !== 'number' || config.maxResults > 0) && stopwatch_1.StopWatch.create(false);\n                return this.sortResults(config, results, scorerCache, token)\n                    .then(sortedResults => {\n                    // sortingTime: -1 indicates a \"sorted\" search that was not sorted, i.e. populating the cache when quickopen is opened.\n                    // Contrasting with findFiles which is not sorted and will have sortingTime: undefined\n                    const sortingTime = sortSW ? sortSW.elapsed() : -1;\n                    return [{\n                            type: 'success',\n                            stats: {\n                                detailStats: result.stats,\n                                sortingTime,\n                                fromCache: false,\n                                type: 'searchProcess',\n                                workspaceFolderCount: config.folderQueries.length,\n                                resultCount: sortedResults.length\n                            },\n                            limitHit: result.limitHit || typeof config.maxResults === 'number' && results.length > config.maxResults\n                        }, sortedResults];\n                });\n            });\n        }\n        getOrCreateCache(cacheKey) {\n            const existing = this.caches[cacheKey];\n            if (existing) {\n                return existing;\n            }\n            return this.caches[cacheKey] = new Cache();\n        }\n        trySortedSearchFromCache(config, progressCallback, token) {\n            const cache = config.cacheKey && this.caches[config.cacheKey];\n            if (!cache) {\n                return undefined;\n            }\n            const cached = this.getResultsFromCache(cache, config.filePattern || '', progressCallback, token);\n            if (cached) {\n                return cached.then(([result, results, cacheStats]) => {\n                    const sortSW = stopwatch_1.StopWatch.create(false);\n                    return this.sortResults(config, results, cache.scorerCache, token)\n                        .then(sortedResults => {\n                        const sortingTime = sortSW.elapsed();\n                        const stats = {\n                            fromCache: true,\n                            detailStats: cacheStats,\n                            type: 'searchProcess',\n                            resultCount: results.length,\n                            sortingTime\n                        };\n                        return [\n                            {\n                                type: 'success',\n                                limitHit: result.limitHit || typeof config.maxResults === 'number' && results.length > config.maxResults,\n                                stats\n                            },\n                            sortedResults\n                        ];\n                    });\n                });\n            }\n            return undefined;\n        }\n        sortResults(config, results, scorerCache, token) {\n            // we use the same compare function that is used later when showing the results using fuzzy scoring\n            // this is very important because we are also limiting the number of results by config.maxResults\n            // and as such we want the top items to be included in this result set if the number of items\n            // exceeds config.maxResults.\n            const query = quickOpenScorer_1.prepareQuery(config.filePattern || '');\n            const compare = (matchA, matchB) => quickOpenScorer_1.compareItemsByScore(matchA, matchB, query, true, FileMatchItemAccessor, scorerCache);\n            const maxResults = config.maxResults || Number.MAX_VALUE;\n            return arrays.topAsync(results, compare, maxResults, 10000, token);\n        }\n        sendProgress(results, progressCb, batchSize) {\n            if (batchSize && batchSize > 0) {\n                for (let i = 0; i < results.length; i += batchSize) {\n                    progressCb(results.slice(i, i + batchSize));\n                }\n            }\n            else {\n                progressCb(results);\n            }\n        }\n        getResultsFromCache(cache, searchValue, progressCallback, token) {\n            const cacheLookupSW = stopwatch_1.StopWatch.create(false);\n            // Find cache entries by prefix of search value\n            const hasPathSep = searchValue.indexOf(path_1.sep) >= 0;\n            let cachedRow;\n            for (const previousSearch in cache.resultsToSearchCache) {\n                // If we narrow down, we might be able to reuse the cached results\n                if (strings.startsWith(searchValue, previousSearch)) {\n                    if (hasPathSep && previousSearch.indexOf(path_1.sep) < 0) {\n                        continue; // since a path character widens the search for potential more matches, require it in previous search too\n                    }\n                    const row = cache.resultsToSearchCache[previousSearch];\n                    cachedRow = {\n                        promise: this.preventCancellation(row.promise),\n                        event: row.event,\n                        resolved: row.resolved\n                    };\n                    break;\n                }\n            }\n            if (!cachedRow) {\n                return null;\n            }\n            const cacheLookupTime = cacheLookupSW.elapsed();\n            const cacheFilterSW = stopwatch_1.StopWatch.create(false);\n            const listener = cachedRow.event(progressCallback);\n            if (token) {\n                token.onCancellationRequested(() => {\n                    listener.dispose();\n                });\n            }\n            return cachedRow.promise.then(([complete, cachedEntries]) => {\n                if (token && token.isCancellationRequested) {\n                    throw errors_1.canceled();\n                }\n                // Pattern match on results\n                const results = [];\n                const normalizedSearchValueLowercase = strings.stripWildcards(searchValue).toLowerCase();\n                for (const entry of cachedEntries) {\n                    // Check if this entry is a match for the search value\n                    if (!strings.fuzzyContains(entry.relativePath, normalizedSearchValueLowercase)) {\n                        continue;\n                    }\n                    results.push(entry);\n                }\n                return [complete, results, {\n                        cacheWasResolved: cachedRow.resolved,\n                        cacheLookupTime,\n                        cacheFilterTime: cacheFilterSW.elapsed(),\n                        cacheEntryCount: cachedEntries.length\n                    }];\n            });\n        }\n        doSearch(engine, progressCallback, batchSize, token) {\n            return new Promise((c, e) => {\n                let batch = [];\n                if (token) {\n                    token.onCancellationRequested(() => engine.cancel());\n                }\n                engine.search((match) => {\n                    if (match) {\n                        if (batchSize) {\n                            batch.push(match);\n                            if (batchSize > 0 && batch.length >= batchSize) {\n                                progressCallback(batch);\n                                batch = [];\n                            }\n                        }\n                        else {\n                            progressCallback(match);\n                        }\n                    }\n                }, (progress) => {\n                    progressCallback(progress);\n                }, (error, complete) => {\n                    if (batch.length) {\n                        progressCallback(batch);\n                    }\n                    if (error) {\n                        e(error);\n                    }\n                    else {\n                        c(complete);\n                    }\n                });\n            });\n        }\n        clearCache(cacheKey) {\n            delete this.caches[cacheKey];\n            return Promise.resolve(undefined);\n        }\n        /**\n         * Return a CancelablePromise which is not actually cancelable\n         * TODO@rob - Is this really needed?\n         */\n        preventCancellation(promise) {\n            return new class {\n                cancel() {\n                    // Do nothing\n                }\n                then(resolve, reject) {\n                    return promise.then(resolve, reject);\n                }\n                catch(reject) {\n                    return this.then(undefined, reject);\n                }\n                finally(onFinally) {\n                    return promise.finally(onFinally);\n                }\n            };\n        }\n    }\n    SearchService.BATCH_SIZE = 512;\n    exports.SearchService = SearchService;\n    class Cache {\n        constructor() {\n            this.resultsToSearchCache = Object.create(null);\n            this.scorerCache = Object.create(null);\n        }\n    }\n    const FileMatchItemAccessor = new class {\n        getItemLabel(match) {\n            return match.basename; // e.g. myFile.txt\n        }\n        getItemDescription(match) {\n            return match.relativePath.substr(0, match.relativePath.length - match.basename.length - 1); // e.g. some/path/to/file\n        }\n        getItemPath(match) {\n            return match.relativePath; // e.g. some/path/to/file/myFile.txt\n        }\n    };\n    function reviveQuery(rawQuery) {\n        return Object.assign({}, rawQuery, {\n            folderQueries: rawQuery.folderQueries && rawQuery.folderQueries.map(reviveFolderQuery),\n            extraFileResources: rawQuery.extraFileResources && rawQuery.extraFileResources.map(components => uri_1.URI.revive(components))\n        });\n    }\n    function reviveFolderQuery(rawFolderQuery) {\n        return Object.assign({}, rawFolderQuery, { folder: uri_1.URI.revive(rawFolderQuery.folder) });\n    }\n});\n",null]}