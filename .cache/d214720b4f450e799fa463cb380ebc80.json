{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/codeEditor/browser/languageConfigurationExtensionPoint.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/codeEditor/browser/languageConfigurationExtensionPoint.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar nls = require(\"vs/nls\");\nvar json_1 = require(\"vs/base/common/json\");\nvar types = require(\"vs/base/common/types\");\nvar languageConfigurationRegistry_1 = require(\"vs/editor/common/modes/languageConfigurationRegistry\");\nvar modeService_1 = require(\"vs/editor/common/services/modeService\");\nvar files_1 = require(\"vs/platform/files/common/files\");\nvar jsonContributionRegistry_1 = require(\"vs/platform/jsonschemas/common/jsonContributionRegistry\");\nvar platform_1 = require(\"vs/platform/registry/common/platform\");\nvar extensions_1 = require(\"vs/workbench/services/extensions/common/extensions\");\nvar textMateService_1 = require(\"vs/workbench/services/textMate/common/textMateService\");\nfunction isStringArr(something) {\n    if (!Array.isArray(something)) {\n        return false;\n    }\n    for (var i = 0, len = something.length; i < len; i++) {\n        if (typeof something[i] !== 'string') {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isCharacterPair(something) {\n    return (isStringArr(something)\n        && something.length === 2);\n}\nvar LanguageConfigurationFileHandler = /** @class */ (function () {\n    function LanguageConfigurationFileHandler(textMateService, _modeService, _fileService, _extensionService) {\n        var _this = this;\n        this._modeService = _modeService;\n        this._fileService = _fileService;\n        this._extensionService = _extensionService;\n        this._done = [];\n        // Listen for hints that a language configuration is needed/usefull and then load it once\n        this._modeService.onDidCreateMode(function (mode) {\n            var languageIdentifier = mode.getLanguageIdentifier();\n            // Modes can be instantiated before the extension points have finished registering\n            _this._extensionService.whenInstalledExtensionsRegistered().then(function () {\n                _this._loadConfigurationsForMode(languageIdentifier);\n            });\n        });\n        textMateService.onDidEncounterLanguage(function (languageId) {\n            _this._loadConfigurationsForMode(_this._modeService.getLanguageIdentifier(languageId));\n        });\n    }\n    LanguageConfigurationFileHandler.prototype._loadConfigurationsForMode = function (languageIdentifier) {\n        var _this = this;\n        if (this._done[languageIdentifier.id]) {\n            return;\n        }\n        this._done[languageIdentifier.id] = true;\n        var configurationFiles = this._modeService.getConfigurationFiles(languageIdentifier.language);\n        configurationFiles.forEach(function (configFileLocation) { return _this._handleConfigFile(languageIdentifier, configFileLocation); });\n    };\n    LanguageConfigurationFileHandler.prototype._handleConfigFile = function (languageIdentifier, configFileLocation) {\n        var _this = this;\n        this._fileService.resolveContent(configFileLocation, { encoding: 'utf8' }).then(function (contents) {\n            var errors = [];\n            var configuration = json_1.parse(contents.value.toString(), errors);\n            if (errors.length) {\n                console.error(nls.localize('parseErrors', \"Errors parsing {0}: {1}\", configFileLocation.toString(), errors.join('\\n')));\n            }\n            _this._handleConfig(languageIdentifier, configuration);\n        }, function (err) {\n            console.error(err);\n        });\n    };\n    LanguageConfigurationFileHandler.prototype._extractValidCommentRule = function (languageIdentifier, configuration) {\n        var source = configuration.comments;\n        if (typeof source === 'undefined') {\n            return null;\n        }\n        if (!types.isObject(source)) {\n            console.warn(\"[\" + languageIdentifier.language + \"]: language configuration: expected `comments` to be an object.\");\n            return null;\n        }\n        var result = null;\n        if (typeof source.lineComment !== 'undefined') {\n            if (typeof source.lineComment !== 'string') {\n                console.warn(\"[\" + languageIdentifier.language + \"]: language configuration: expected `comments.lineComment` to be a string.\");\n            }\n            else {\n                result = result || {};\n                result.lineComment = source.lineComment;\n            }\n        }\n        if (typeof source.blockComment !== 'undefined') {\n            if (!isCharacterPair(source.blockComment)) {\n                console.warn(\"[\" + languageIdentifier.language + \"]: language configuration: expected `comments.blockComment` to be an array of two strings.\");\n            }\n            else {\n                result = result || {};\n                result.blockComment = source.blockComment;\n            }\n        }\n        return result;\n    };\n    LanguageConfigurationFileHandler.prototype._extractValidBrackets = function (languageIdentifier, configuration) {\n        var source = configuration.brackets;\n        if (typeof source === 'undefined') {\n            return null;\n        }\n        if (!Array.isArray(source)) {\n            console.warn(\"[\" + languageIdentifier.language + \"]: language configuration: expected `brackets` to be an array.\");\n            return null;\n        }\n        var result = null;\n        for (var i = 0, len = source.length; i < len; i++) {\n            var pair = source[i];\n            if (!isCharacterPair(pair)) {\n                console.warn(\"[\" + languageIdentifier.language + \"]: language configuration: expected `brackets[\" + i + \"]` to be an array of two strings.\");\n                continue;\n            }\n            result = result || [];\n            result.push(pair);\n        }\n        return result;\n    };\n    LanguageConfigurationFileHandler.prototype._extractValidAutoClosingPairs = function (languageIdentifier, configuration) {\n        var source = configuration.autoClosingPairs;\n        if (typeof source === 'undefined') {\n            return null;\n        }\n        if (!Array.isArray(source)) {\n            console.warn(\"[\" + languageIdentifier.language + \"]: language configuration: expected `autoClosingPairs` to be an array.\");\n            return null;\n        }\n        var result = null;\n        for (var i = 0, len = source.length; i < len; i++) {\n            var pair = source[i];\n            if (Array.isArray(pair)) {\n                if (!isCharacterPair(pair)) {\n                    console.warn(\"[\" + languageIdentifier.language + \"]: language configuration: expected `autoClosingPairs[\" + i + \"]` to be an array of two strings or an object.\");\n                    continue;\n                }\n                result = result || [];\n                result.push({ open: pair[0], close: pair[1] });\n            }\n            else {\n                if (!types.isObject(pair)) {\n                    console.warn(\"[\" + languageIdentifier.language + \"]: language configuration: expected `autoClosingPairs[\" + i + \"]` to be an array of two strings or an object.\");\n                    continue;\n                }\n                if (typeof pair.open !== 'string') {\n                    console.warn(\"[\" + languageIdentifier.language + \"]: language configuration: expected `autoClosingPairs[\" + i + \"].open` to be a string.\");\n                    continue;\n                }\n                if (typeof pair.close !== 'string') {\n                    console.warn(\"[\" + languageIdentifier.language + \"]: language configuration: expected `autoClosingPairs[\" + i + \"].close` to be a string.\");\n                    continue;\n                }\n                if (typeof pair.notIn !== 'undefined') {\n                    if (!isStringArr(pair.notIn)) {\n                        console.warn(\"[\" + languageIdentifier.language + \"]: language configuration: expected `autoClosingPairs[\" + i + \"].notIn` to be a string array.\");\n                        continue;\n                    }\n                }\n                result = result || [];\n                result.push({ open: pair.open, close: pair.close, notIn: pair.notIn });\n            }\n        }\n        return result;\n    };\n    LanguageConfigurationFileHandler.prototype._extractValidSurroundingPairs = function (languageIdentifier, configuration) {\n        var source = configuration.surroundingPairs;\n        if (typeof source === 'undefined') {\n            return null;\n        }\n        if (!Array.isArray(source)) {\n            console.warn(\"[\" + languageIdentifier.language + \"]: language configuration: expected `surroundingPairs` to be an array.\");\n            return null;\n        }\n        var result = null;\n        for (var i = 0, len = source.length; i < len; i++) {\n            var pair = source[i];\n            if (Array.isArray(pair)) {\n                if (!isCharacterPair(pair)) {\n                    console.warn(\"[\" + languageIdentifier.language + \"]: language configuration: expected `surroundingPairs[\" + i + \"]` to be an array of two strings or an object.\");\n                    continue;\n                }\n                result = result || [];\n                result.push({ open: pair[0], close: pair[1] });\n            }\n            else {\n                if (!types.isObject(pair)) {\n                    console.warn(\"[\" + languageIdentifier.language + \"]: language configuration: expected `surroundingPairs[\" + i + \"]` to be an array of two strings or an object.\");\n                    continue;\n                }\n                if (typeof pair.open !== 'string') {\n                    console.warn(\"[\" + languageIdentifier.language + \"]: language configuration: expected `surroundingPairs[\" + i + \"].open` to be a string.\");\n                    continue;\n                }\n                if (typeof pair.close !== 'string') {\n                    console.warn(\"[\" + languageIdentifier.language + \"]: language configuration: expected `surroundingPairs[\" + i + \"].close` to be a string.\");\n                    continue;\n                }\n                result = result || [];\n                result.push({ open: pair.open, close: pair.close });\n            }\n        }\n        return result;\n    };\n    // private _mapCharacterPairs(pairs: Array<CharacterPair | IAutoClosingPairConditional>): IAutoClosingPairConditional[] {\n    // \treturn pairs.map(pair => {\n    // \t\tif (Array.isArray(pair)) {\n    // \t\t\treturn { open: pair[0], close: pair[1] };\n    // \t\t}\n    // \t\treturn <IAutoClosingPairConditional>pair;\n    // \t});\n    // }\n    LanguageConfigurationFileHandler.prototype._handleConfig = function (languageIdentifier, configuration) {\n        var richEditConfig = {};\n        var comments = this._extractValidCommentRule(languageIdentifier, configuration);\n        if (comments) {\n            richEditConfig.comments = comments;\n        }\n        var brackets = this._extractValidBrackets(languageIdentifier, configuration);\n        if (brackets) {\n            richEditConfig.brackets = brackets;\n        }\n        var autoClosingPairs = this._extractValidAutoClosingPairs(languageIdentifier, configuration);\n        if (autoClosingPairs) {\n            richEditConfig.autoClosingPairs = autoClosingPairs;\n        }\n        var surroundingPairs = this._extractValidSurroundingPairs(languageIdentifier, configuration);\n        if (surroundingPairs) {\n            richEditConfig.surroundingPairs = surroundingPairs;\n        }\n        var autoCloseBefore = configuration.autoCloseBefore;\n        if (typeof autoCloseBefore === 'string') {\n            richEditConfig.autoCloseBefore = autoCloseBefore;\n        }\n        if (configuration.wordPattern) {\n            try {\n                var wordPattern = this._parseRegex(configuration.wordPattern);\n                if (wordPattern) {\n                    richEditConfig.wordPattern = wordPattern;\n                }\n            }\n            catch (error) {\n                // Malformed regexes are ignored\n            }\n        }\n        if (configuration.indentationRules) {\n            var indentationRules = this._mapIndentationRules(configuration.indentationRules);\n            if (indentationRules) {\n                richEditConfig.indentationRules = indentationRules;\n            }\n        }\n        if (configuration.folding) {\n            var markers = configuration.folding.markers;\n            richEditConfig.folding = {\n                offSide: configuration.folding.offSide,\n                markers: markers ? { start: new RegExp(markers.start), end: new RegExp(markers.end) } : undefined\n            };\n        }\n        languageConfigurationRegistry_1.LanguageConfigurationRegistry.register(languageIdentifier, richEditConfig);\n    };\n    LanguageConfigurationFileHandler.prototype._parseRegex = function (value) {\n        if (typeof value === 'string') {\n            return new RegExp(value, '');\n        }\n        else if (typeof value === 'object') {\n            return new RegExp(value.pattern, value.flags);\n        }\n        return null;\n    };\n    LanguageConfigurationFileHandler.prototype._mapIndentationRules = function (indentationRules) {\n        try {\n            var increaseIndentPattern = this._parseRegex(indentationRules.increaseIndentPattern);\n            var decreaseIndentPattern = this._parseRegex(indentationRules.decreaseIndentPattern);\n            if (increaseIndentPattern && decreaseIndentPattern) {\n                var result = {\n                    increaseIndentPattern: increaseIndentPattern,\n                    decreaseIndentPattern: decreaseIndentPattern\n                };\n                if (indentationRules.indentNextLinePattern) {\n                    result.indentNextLinePattern = this._parseRegex(indentationRules.indentNextLinePattern);\n                }\n                if (indentationRules.unIndentedLinePattern) {\n                    result.unIndentedLinePattern = this._parseRegex(indentationRules.unIndentedLinePattern);\n                }\n                return result;\n            }\n        }\n        catch (error) {\n            // Malformed regexes are ignored\n        }\n        return null;\n    };\n    LanguageConfigurationFileHandler = tslib_1.__decorate([\n        tslib_1.__param(0, textMateService_1.ITextMateService),\n        tslib_1.__param(1, modeService_1.IModeService),\n        tslib_1.__param(2, files_1.IFileService),\n        tslib_1.__param(3, extensions_1.IExtensionService)\n    ], LanguageConfigurationFileHandler);\n    return LanguageConfigurationFileHandler;\n}());\nexports.LanguageConfigurationFileHandler = LanguageConfigurationFileHandler;\nvar schemaId = 'vscode://schemas/language-configuration';\nvar schema = {\n    allowComments: true,\n    default: {\n        comments: {\n            blockComment: ['/*', '*/'],\n            lineComment: '//'\n        },\n        brackets: [['(', ')'], ['[', ']'], ['{', '}']],\n        autoClosingPairs: [['(', ')'], ['[', ']'], ['{', '}']],\n        surroundingPairs: [['(', ')'], ['[', ']'], ['{', '}']]\n    },\n    definitions: {\n        openBracket: {\n            type: 'string',\n            description: nls.localize('schema.openBracket', 'The opening bracket character or string sequence.')\n        },\n        closeBracket: {\n            type: 'string',\n            description: nls.localize('schema.closeBracket', 'The closing bracket character or string sequence.')\n        },\n        bracketPair: {\n            type: 'array',\n            items: [{\n                    $ref: '#definitions/openBracket'\n                }, {\n                    $ref: '#definitions/closeBracket'\n                }]\n        }\n    },\n    properties: {\n        comments: {\n            default: {\n                blockComment: ['/*', '*/'],\n                lineComment: '//'\n            },\n            description: nls.localize('schema.comments', 'Defines the comment symbols'),\n            type: 'object',\n            properties: {\n                blockComment: {\n                    type: 'array',\n                    description: nls.localize('schema.blockComments', 'Defines how block comments are marked.'),\n                    items: [{\n                            type: 'string',\n                            description: nls.localize('schema.blockComment.begin', 'The character sequence that starts a block comment.')\n                        }, {\n                            type: 'string',\n                            description: nls.localize('schema.blockComment.end', 'The character sequence that ends a block comment.')\n                        }]\n                },\n                lineComment: {\n                    type: 'string',\n                    description: nls.localize('schema.lineComment', 'The character sequence that starts a line comment.')\n                }\n            }\n        },\n        brackets: {\n            default: [['(', ')'], ['[', ']'], ['{', '}']],\n            description: nls.localize('schema.brackets', 'Defines the bracket symbols that increase or decrease the indentation.'),\n            type: 'array',\n            items: {\n                $ref: '#definitions/bracketPair'\n            }\n        },\n        autoClosingPairs: {\n            default: [['(', ')'], ['[', ']'], ['{', '}']],\n            description: nls.localize('schema.autoClosingPairs', 'Defines the bracket pairs. When a opening bracket is entered, the closing bracket is inserted automatically.'),\n            type: 'array',\n            items: {\n                oneOf: [{\n                        $ref: '#definitions/bracketPair'\n                    }, {\n                        type: 'object',\n                        properties: {\n                            open: {\n                                $ref: '#definitions/openBracket'\n                            },\n                            close: {\n                                $ref: '#definitions/closeBracket'\n                            },\n                            notIn: {\n                                type: 'array',\n                                description: nls.localize('schema.autoClosingPairs.notIn', 'Defines a list of scopes where the auto pairs are disabled.'),\n                                items: {\n                                    enum: ['string', 'comment']\n                                }\n                            }\n                        }\n                    }]\n            }\n        },\n        autoCloseBefore: {\n            default: ';:.,=}])> \\n\\t',\n            description: nls.localize('schema.autoCloseBefore', 'Defines what characters must be after the cursor in order for bracket or quote autoclosing to occur when using the \\'languageDefined\\' autoclosing setting. This is typically the set of characters which can not start an expression.'),\n            type: 'string',\n        },\n        surroundingPairs: {\n            default: [['(', ')'], ['[', ']'], ['{', '}']],\n            description: nls.localize('schema.surroundingPairs', 'Defines the bracket pairs that can be used to surround a selected string.'),\n            type: 'array',\n            items: {\n                oneOf: [{\n                        $ref: '#definitions/bracketPair'\n                    }, {\n                        type: 'object',\n                        properties: {\n                            open: {\n                                $ref: '#definitions/openBracket'\n                            },\n                            close: {\n                                $ref: '#definitions/closeBracket'\n                            }\n                        }\n                    }]\n            }\n        },\n        wordPattern: {\n            default: '',\n            description: nls.localize('schema.wordPattern', 'Defines what is considered to be a word in the programming language.'),\n            type: ['string', 'object'],\n            properties: {\n                pattern: {\n                    type: 'string',\n                    description: nls.localize('schema.wordPattern.pattern', 'The RegExp pattern used to match words.'),\n                    default: '',\n                },\n                flags: {\n                    type: 'string',\n                    description: nls.localize('schema.wordPattern.flags', 'The RegExp flags used to match words.'),\n                    default: 'g',\n                    pattern: '^([gimuy]+)$',\n                    patternErrorMessage: nls.localize('schema.wordPattern.flags.errorMessage', 'Must match the pattern `/^([gimuy]+)$/`.')\n                }\n            }\n        },\n        indentationRules: {\n            default: {\n                increaseIndentPattern: '',\n                decreaseIndentPattern: ''\n            },\n            description: nls.localize('schema.indentationRules', 'The language\\'s indentation settings.'),\n            type: 'object',\n            properties: {\n                increaseIndentPattern: {\n                    type: ['string', 'object'],\n                    description: nls.localize('schema.indentationRules.increaseIndentPattern', 'If a line matches this pattern, then all the lines after it should be indented once (until another rule matches).'),\n                    properties: {\n                        pattern: {\n                            type: 'string',\n                            description: nls.localize('schema.indentationRules.increaseIndentPattern.pattern', 'The RegExp pattern for increaseIndentPattern.'),\n                            default: '',\n                        },\n                        flags: {\n                            type: 'string',\n                            description: nls.localize('schema.indentationRules.increaseIndentPattern.flags', 'The RegExp flags for increaseIndentPattern.'),\n                            default: '',\n                            pattern: '^([gimuy]+)$',\n                            patternErrorMessage: nls.localize('schema.indentationRules.increaseIndentPattern.errorMessage', 'Must match the pattern `/^([gimuy]+)$/`.')\n                        }\n                    }\n                },\n                decreaseIndentPattern: {\n                    type: ['string', 'object'],\n                    description: nls.localize('schema.indentationRules.decreaseIndentPattern', 'If a line matches this pattern, then all the lines after it should be unindented once (until another rule matches).'),\n                    properties: {\n                        pattern: {\n                            type: 'string',\n                            description: nls.localize('schema.indentationRules.decreaseIndentPattern.pattern', 'The RegExp pattern for decreaseIndentPattern.'),\n                            default: '',\n                        },\n                        flags: {\n                            type: 'string',\n                            description: nls.localize('schema.indentationRules.decreaseIndentPattern.flags', 'The RegExp flags for decreaseIndentPattern.'),\n                            default: '',\n                            pattern: '^([gimuy]+)$',\n                            patternErrorMessage: nls.localize('schema.indentationRules.decreaseIndentPattern.errorMessage', 'Must match the pattern `/^([gimuy]+)$/`.')\n                        }\n                    }\n                },\n                indentNextLinePattern: {\n                    type: ['string', 'object'],\n                    description: nls.localize('schema.indentationRules.indentNextLinePattern', 'If a line matches this pattern, then **only the next line** after it should be indented once.'),\n                    properties: {\n                        pattern: {\n                            type: 'string',\n                            description: nls.localize('schema.indentationRules.indentNextLinePattern.pattern', 'The RegExp pattern for indentNextLinePattern.'),\n                            default: '',\n                        },\n                        flags: {\n                            type: 'string',\n                            description: nls.localize('schema.indentationRules.indentNextLinePattern.flags', 'The RegExp flags for indentNextLinePattern.'),\n                            default: '',\n                            pattern: '^([gimuy]+)$',\n                            patternErrorMessage: nls.localize('schema.indentationRules.indentNextLinePattern.errorMessage', 'Must match the pattern `/^([gimuy]+)$/`.')\n                        }\n                    }\n                },\n                unIndentedLinePattern: {\n                    type: ['string', 'object'],\n                    description: nls.localize('schema.indentationRules.unIndentedLinePattern', 'If a line matches this pattern, then its indentation should not be changed and it should not be evaluated against the other rules.'),\n                    properties: {\n                        pattern: {\n                            type: 'string',\n                            description: nls.localize('schema.indentationRules.unIndentedLinePattern.pattern', 'The RegExp pattern for unIndentedLinePattern.'),\n                            default: '',\n                        },\n                        flags: {\n                            type: 'string',\n                            description: nls.localize('schema.indentationRules.unIndentedLinePattern.flags', 'The RegExp flags for unIndentedLinePattern.'),\n                            default: '',\n                            pattern: '^([gimuy]+)$',\n                            patternErrorMessage: nls.localize('schema.indentationRules.unIndentedLinePattern.errorMessage', 'Must match the pattern `/^([gimuy]+)$/`.')\n                        }\n                    }\n                }\n            }\n        },\n        folding: {\n            type: 'object',\n            description: nls.localize('schema.folding', 'The language\\'s folding settings.'),\n            properties: {\n                offSide: {\n                    type: 'boolean',\n                    description: nls.localize('schema.folding.offSide', 'A language adheres to the off-side rule if blocks in that language are expressed by their indentation. If set, empty lines belong to the subsequent block.'),\n                },\n                markers: {\n                    type: 'object',\n                    description: nls.localize('schema.folding.markers', 'Language specific folding markers such as \\'#region\\' and \\'#endregion\\'. The start and end regexes will be tested against the contents of all lines and must be designed efficiently'),\n                    properties: {\n                        start: {\n                            type: 'string',\n                            description: nls.localize('schema.folding.markers.start', 'The RegExp pattern for the start marker. The regexp must start with \\'^\\'.')\n                        },\n                        end: {\n                            type: 'string',\n                            description: nls.localize('schema.folding.markers.end', 'The RegExp pattern for the end marker. The regexp must start with \\'^\\'.')\n                        },\n                    }\n                }\n            }\n        }\n    }\n};\nvar schemaRegistry = platform_1.Registry.as(jsonContributionRegistry_1.Extensions.JSONContribution);\nschemaRegistry.registerSchema(schemaId, schema);\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/codeEditor/browser/languageConfigurationExtensionPoint.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/codeEditor/browser/languageConfigurationExtensionPoint.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\nimport { ParseError, parse } from 'vs/base/common/json';\nimport { IJSONSchema } from 'vs/base/common/jsonSchema';\nimport * as types from 'vs/base/common/types';\nimport { URI } from 'vs/base/common/uri';\nimport { LanguageIdentifier } from 'vs/editor/common/modes';\nimport { CharacterPair, CommentRule, FoldingRules, IAutoClosingPair, IAutoClosingPairConditional, IndentationRule, LanguageConfiguration } from 'vs/editor/common/modes/languageConfiguration';\nimport { LanguageConfigurationRegistry } from 'vs/editor/common/modes/languageConfigurationRegistry';\nimport { IModeService } from 'vs/editor/common/services/modeService';\nimport { IFileService } from 'vs/platform/files/common/files';\nimport { Extensions, IJSONContributionRegistry } from 'vs/platform/jsonschemas/common/jsonContributionRegistry';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport { IExtensionService } from 'vs/workbench/services/extensions/common/extensions';\nimport { ITextMateService } from 'vs/workbench/services/textMate/common/textMateService';\n\ninterface IRegExp {\n\tpattern: string;\n\tflags?: string;\n}\n\ninterface IIndentationRules {\n\tdecreaseIndentPattern: string | IRegExp;\n\tincreaseIndentPattern: string | IRegExp;\n\tindentNextLinePattern?: string | IRegExp;\n\tunIndentedLinePattern?: string | IRegExp;\n}\n\ninterface ILanguageConfiguration {\n\tcomments?: CommentRule;\n\tbrackets?: CharacterPair[];\n\tautoClosingPairs?: Array<CharacterPair | IAutoClosingPairConditional>;\n\tsurroundingPairs?: Array<CharacterPair | IAutoClosingPair>;\n\twordPattern?: string | IRegExp;\n\tindentationRules?: IIndentationRules;\n\tfolding?: FoldingRules;\n\tautoCloseBefore?: string;\n}\n\nfunction isStringArr(something: string[] | null): something is string[] {\n\tif (!Array.isArray(something)) {\n\t\treturn false;\n\t}\n\tfor (let i = 0, len = something.length; i < len; i++) {\n\t\tif (typeof something[i] !== 'string') {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n\n}\n\nfunction isCharacterPair(something: CharacterPair | null): boolean {\n\treturn (\n\t\tisStringArr(something)\n\t\t&& something.length === 2\n\t);\n}\n\nexport class LanguageConfigurationFileHandler {\n\n\tprivate _done: boolean[];\n\n\tconstructor(\n\t\t@ITextMateService textMateService: ITextMateService,\n\t\t@IModeService private readonly _modeService: IModeService,\n\t\t@IFileService private readonly _fileService: IFileService,\n\t\t@IExtensionService private readonly _extensionService: IExtensionService\n\t) {\n\t\tthis._done = [];\n\n\t\t// Listen for hints that a language configuration is needed/usefull and then load it once\n\t\tthis._modeService.onDidCreateMode((mode) => {\n\t\t\tconst languageIdentifier = mode.getLanguageIdentifier();\n\t\t\t// Modes can be instantiated before the extension points have finished registering\n\t\t\tthis._extensionService.whenInstalledExtensionsRegistered().then(() => {\n\t\t\t\tthis._loadConfigurationsForMode(languageIdentifier);\n\t\t\t});\n\t\t});\n\t\ttextMateService.onDidEncounterLanguage((languageId) => {\n\t\t\tthis._loadConfigurationsForMode(this._modeService.getLanguageIdentifier(languageId)!);\n\t\t});\n\t}\n\n\tprivate _loadConfigurationsForMode(languageIdentifier: LanguageIdentifier): void {\n\t\tif (this._done[languageIdentifier.id]) {\n\t\t\treturn;\n\t\t}\n\t\tthis._done[languageIdentifier.id] = true;\n\n\t\tlet configurationFiles = this._modeService.getConfigurationFiles(languageIdentifier.language);\n\t\tconfigurationFiles.forEach((configFileLocation) => this._handleConfigFile(languageIdentifier, configFileLocation));\n\t}\n\n\tprivate _handleConfigFile(languageIdentifier: LanguageIdentifier, configFileLocation: URI): void {\n\t\tthis._fileService.resolveContent(configFileLocation, { encoding: 'utf8' }).then((contents) => {\n\t\t\tconst errors: ParseError[] = [];\n\t\t\tconst configuration = <ILanguageConfiguration>parse(contents.value.toString(), errors);\n\t\t\tif (errors.length) {\n\t\t\t\tconsole.error(nls.localize('parseErrors', \"Errors parsing {0}: {1}\", configFileLocation.toString(), errors.join('\\n')));\n\t\t\t}\n\t\t\tthis._handleConfig(languageIdentifier, configuration);\n\t\t}, (err) => {\n\t\t\tconsole.error(err);\n\t\t});\n\t}\n\n\tprivate _extractValidCommentRule(languageIdentifier: LanguageIdentifier, configuration: ILanguageConfiguration): CommentRule | null {\n\t\tconst source = configuration.comments;\n\t\tif (typeof source === 'undefined') {\n\t\t\treturn null;\n\t\t}\n\t\tif (!types.isObject(source)) {\n\t\t\tconsole.warn(`[${languageIdentifier.language}]: language configuration: expected \\`comments\\` to be an object.`);\n\t\t\treturn null;\n\t\t}\n\n\t\tlet result: CommentRule | null = null;\n\t\tif (typeof source.lineComment !== 'undefined') {\n\t\t\tif (typeof source.lineComment !== 'string') {\n\t\t\t\tconsole.warn(`[${languageIdentifier.language}]: language configuration: expected \\`comments.lineComment\\` to be a string.`);\n\t\t\t} else {\n\t\t\t\tresult = result || {};\n\t\t\t\tresult.lineComment = source.lineComment;\n\t\t\t}\n\t\t}\n\t\tif (typeof source.blockComment !== 'undefined') {\n\t\t\tif (!isCharacterPair(source.blockComment)) {\n\t\t\t\tconsole.warn(`[${languageIdentifier.language}]: language configuration: expected \\`comments.blockComment\\` to be an array of two strings.`);\n\t\t\t} else {\n\t\t\t\tresult = result || {};\n\t\t\t\tresult.blockComment = source.blockComment;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _extractValidBrackets(languageIdentifier: LanguageIdentifier, configuration: ILanguageConfiguration): CharacterPair[] | null {\n\t\tconst source = configuration.brackets;\n\t\tif (typeof source === 'undefined') {\n\t\t\treturn null;\n\t\t}\n\t\tif (!Array.isArray(source)) {\n\t\t\tconsole.warn(`[${languageIdentifier.language}]: language configuration: expected \\`brackets\\` to be an array.`);\n\t\t\treturn null;\n\t\t}\n\n\t\tlet result: CharacterPair[] | null = null;\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\tconst pair = source[i];\n\t\t\tif (!isCharacterPair(pair)) {\n\t\t\t\tconsole.warn(`[${languageIdentifier.language}]: language configuration: expected \\`brackets[${i}]\\` to be an array of two strings.`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresult = result || [];\n\t\t\tresult.push(pair);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _extractValidAutoClosingPairs(languageIdentifier: LanguageIdentifier, configuration: ILanguageConfiguration): IAutoClosingPairConditional[] | null {\n\t\tconst source = configuration.autoClosingPairs;\n\t\tif (typeof source === 'undefined') {\n\t\t\treturn null;\n\t\t}\n\t\tif (!Array.isArray(source)) {\n\t\t\tconsole.warn(`[${languageIdentifier.language}]: language configuration: expected \\`autoClosingPairs\\` to be an array.`);\n\t\t\treturn null;\n\t\t}\n\n\t\tlet result: IAutoClosingPairConditional[] | null = null;\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\tconst pair = source[i];\n\t\t\tif (Array.isArray(pair)) {\n\t\t\t\tif (!isCharacterPair(pair)) {\n\t\t\t\t\tconsole.warn(`[${languageIdentifier.language}]: language configuration: expected \\`autoClosingPairs[${i}]\\` to be an array of two strings or an object.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tresult = result || [];\n\t\t\t\tresult.push({ open: pair[0], close: pair[1] });\n\t\t\t} else {\n\t\t\t\tif (!types.isObject(pair)) {\n\t\t\t\t\tconsole.warn(`[${languageIdentifier.language}]: language configuration: expected \\`autoClosingPairs[${i}]\\` to be an array of two strings or an object.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (typeof pair.open !== 'string') {\n\t\t\t\t\tconsole.warn(`[${languageIdentifier.language}]: language configuration: expected \\`autoClosingPairs[${i}].open\\` to be a string.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (typeof pair.close !== 'string') {\n\t\t\t\t\tconsole.warn(`[${languageIdentifier.language}]: language configuration: expected \\`autoClosingPairs[${i}].close\\` to be a string.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (typeof pair.notIn !== 'undefined') {\n\t\t\t\t\tif (!isStringArr(pair.notIn)) {\n\t\t\t\t\t\tconsole.warn(`[${languageIdentifier.language}]: language configuration: expected \\`autoClosingPairs[${i}].notIn\\` to be a string array.`);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult = result || [];\n\t\t\t\tresult.push({ open: pair.open, close: pair.close, notIn: pair.notIn });\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _extractValidSurroundingPairs(languageIdentifier: LanguageIdentifier, configuration: ILanguageConfiguration): IAutoClosingPair[] | null {\n\t\tconst source = configuration.surroundingPairs;\n\t\tif (typeof source === 'undefined') {\n\t\t\treturn null;\n\t\t}\n\t\tif (!Array.isArray(source)) {\n\t\t\tconsole.warn(`[${languageIdentifier.language}]: language configuration: expected \\`surroundingPairs\\` to be an array.`);\n\t\t\treturn null;\n\t\t}\n\n\t\tlet result: IAutoClosingPair[] | null = null;\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\tconst pair = source[i];\n\t\t\tif (Array.isArray(pair)) {\n\t\t\t\tif (!isCharacterPair(pair)) {\n\t\t\t\t\tconsole.warn(`[${languageIdentifier.language}]: language configuration: expected \\`surroundingPairs[${i}]\\` to be an array of two strings or an object.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tresult = result || [];\n\t\t\t\tresult.push({ open: pair[0], close: pair[1] });\n\t\t\t} else {\n\t\t\t\tif (!types.isObject(pair)) {\n\t\t\t\t\tconsole.warn(`[${languageIdentifier.language}]: language configuration: expected \\`surroundingPairs[${i}]\\` to be an array of two strings or an object.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (typeof pair.open !== 'string') {\n\t\t\t\t\tconsole.warn(`[${languageIdentifier.language}]: language configuration: expected \\`surroundingPairs[${i}].open\\` to be a string.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (typeof pair.close !== 'string') {\n\t\t\t\t\tconsole.warn(`[${languageIdentifier.language}]: language configuration: expected \\`surroundingPairs[${i}].close\\` to be a string.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tresult = result || [];\n\t\t\t\tresult.push({ open: pair.open, close: pair.close });\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t// private _mapCharacterPairs(pairs: Array<CharacterPair | IAutoClosingPairConditional>): IAutoClosingPairConditional[] {\n\t// \treturn pairs.map(pair => {\n\t// \t\tif (Array.isArray(pair)) {\n\t// \t\t\treturn { open: pair[0], close: pair[1] };\n\t// \t\t}\n\t// \t\treturn <IAutoClosingPairConditional>pair;\n\t// \t});\n\t// }\n\n\tprivate _handleConfig(languageIdentifier: LanguageIdentifier, configuration: ILanguageConfiguration): void {\n\n\t\tlet richEditConfig: LanguageConfiguration = {};\n\n\t\tconst comments = this._extractValidCommentRule(languageIdentifier, configuration);\n\t\tif (comments) {\n\t\t\trichEditConfig.comments = comments;\n\t\t}\n\n\t\tconst brackets = this._extractValidBrackets(languageIdentifier, configuration);\n\t\tif (brackets) {\n\t\t\trichEditConfig.brackets = brackets;\n\t\t}\n\n\t\tconst autoClosingPairs = this._extractValidAutoClosingPairs(languageIdentifier, configuration);\n\t\tif (autoClosingPairs) {\n\t\t\trichEditConfig.autoClosingPairs = autoClosingPairs;\n\t\t}\n\n\t\tconst surroundingPairs = this._extractValidSurroundingPairs(languageIdentifier, configuration);\n\t\tif (surroundingPairs) {\n\t\t\trichEditConfig.surroundingPairs = surroundingPairs;\n\t\t}\n\n\t\tconst autoCloseBefore = configuration.autoCloseBefore;\n\t\tif (typeof autoCloseBefore === 'string') {\n\t\t\trichEditConfig.autoCloseBefore = autoCloseBefore;\n\t\t}\n\n\t\tif (configuration.wordPattern) {\n\t\t\ttry {\n\t\t\t\tlet wordPattern = this._parseRegex(configuration.wordPattern);\n\t\t\t\tif (wordPattern) {\n\t\t\t\t\trichEditConfig.wordPattern = wordPattern;\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// Malformed regexes are ignored\n\t\t\t}\n\t\t}\n\n\t\tif (configuration.indentationRules) {\n\t\t\tlet indentationRules = this._mapIndentationRules(configuration.indentationRules);\n\t\t\tif (indentationRules) {\n\t\t\t\trichEditConfig.indentationRules = indentationRules;\n\t\t\t}\n\t\t}\n\n\t\tif (configuration.folding) {\n\t\t\tlet markers = configuration.folding.markers;\n\n\t\t\trichEditConfig.folding = {\n\t\t\t\toffSide: configuration.folding.offSide,\n\t\t\t\tmarkers: markers ? { start: new RegExp(markers.start), end: new RegExp(markers.end) } : undefined\n\t\t\t};\n\t\t}\n\n\t\tLanguageConfigurationRegistry.register(languageIdentifier, richEditConfig);\n\t}\n\n\tprivate _parseRegex(value: string | IRegExp) {\n\t\tif (typeof value === 'string') {\n\t\t\treturn new RegExp(value, '');\n\t\t} else if (typeof value === 'object') {\n\t\t\treturn new RegExp(value.pattern, value.flags);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate _mapIndentationRules(indentationRules: IIndentationRules): IndentationRule | null {\n\t\ttry {\n\t\t\tlet increaseIndentPattern = this._parseRegex(indentationRules.increaseIndentPattern);\n\t\t\tlet decreaseIndentPattern = this._parseRegex(indentationRules.decreaseIndentPattern);\n\n\t\t\tif (increaseIndentPattern && decreaseIndentPattern) {\n\t\t\t\tlet result: IndentationRule = {\n\t\t\t\t\tincreaseIndentPattern: increaseIndentPattern,\n\t\t\t\t\tdecreaseIndentPattern: decreaseIndentPattern\n\t\t\t\t};\n\n\t\t\t\tif (indentationRules.indentNextLinePattern) {\n\t\t\t\t\tresult.indentNextLinePattern = this._parseRegex(indentationRules.indentNextLinePattern);\n\t\t\t\t}\n\t\t\t\tif (indentationRules.unIndentedLinePattern) {\n\t\t\t\t\tresult.unIndentedLinePattern = this._parseRegex(indentationRules.unIndentedLinePattern);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Malformed regexes are ignored\n\t\t}\n\n\t\treturn null;\n\t}\n}\n\nconst schemaId = 'vscode://schemas/language-configuration';\nconst schema: IJSONSchema = {\n\tallowComments: true,\n\tdefault: {\n\t\tcomments: {\n\t\t\tblockComment: ['/*', '*/'],\n\t\t\tlineComment: '//'\n\t\t},\n\t\tbrackets: [['(', ')'], ['[', ']'], ['{', '}']],\n\t\tautoClosingPairs: [['(', ')'], ['[', ']'], ['{', '}']],\n\t\tsurroundingPairs: [['(', ')'], ['[', ']'], ['{', '}']]\n\t},\n\tdefinitions: {\n\t\topenBracket: {\n\t\t\ttype: 'string',\n\t\t\tdescription: nls.localize('schema.openBracket', 'The opening bracket character or string sequence.')\n\t\t},\n\t\tcloseBracket: {\n\t\t\ttype: 'string',\n\t\t\tdescription: nls.localize('schema.closeBracket', 'The closing bracket character or string sequence.')\n\t\t},\n\t\tbracketPair: {\n\t\t\ttype: 'array',\n\t\t\titems: [{\n\t\t\t\t$ref: '#definitions/openBracket'\n\t\t\t}, {\n\t\t\t\t$ref: '#definitions/closeBracket'\n\t\t\t}]\n\t\t}\n\t},\n\tproperties: {\n\t\tcomments: {\n\t\t\tdefault: {\n\t\t\t\tblockComment: ['/*', '*/'],\n\t\t\t\tlineComment: '//'\n\t\t\t},\n\t\t\tdescription: nls.localize('schema.comments', 'Defines the comment symbols'),\n\t\t\ttype: 'object',\n\t\t\tproperties: {\n\t\t\t\tblockComment: {\n\t\t\t\t\ttype: 'array',\n\t\t\t\t\tdescription: nls.localize('schema.blockComments', 'Defines how block comments are marked.'),\n\t\t\t\t\titems: [{\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdescription: nls.localize('schema.blockComment.begin', 'The character sequence that starts a block comment.')\n\t\t\t\t\t}, {\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdescription: nls.localize('schema.blockComment.end', 'The character sequence that ends a block comment.')\n\t\t\t\t\t}]\n\t\t\t\t},\n\t\t\t\tlineComment: {\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: nls.localize('schema.lineComment', 'The character sequence that starts a line comment.')\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbrackets: {\n\t\t\tdefault: [['(', ')'], ['[', ']'], ['{', '}']],\n\t\t\tdescription: nls.localize('schema.brackets', 'Defines the bracket symbols that increase or decrease the indentation.'),\n\t\t\ttype: 'array',\n\t\t\titems: {\n\t\t\t\t$ref: '#definitions/bracketPair'\n\t\t\t}\n\t\t},\n\t\tautoClosingPairs: {\n\t\t\tdefault: [['(', ')'], ['[', ']'], ['{', '}']],\n\t\t\tdescription: nls.localize('schema.autoClosingPairs', 'Defines the bracket pairs. When a opening bracket is entered, the closing bracket is inserted automatically.'),\n\t\t\ttype: 'array',\n\t\t\titems: {\n\t\t\t\toneOf: [{\n\t\t\t\t\t$ref: '#definitions/bracketPair'\n\t\t\t\t}, {\n\t\t\t\t\ttype: 'object',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\topen: {\n\t\t\t\t\t\t\t$ref: '#definitions/openBracket'\n\t\t\t\t\t\t},\n\t\t\t\t\t\tclose: {\n\t\t\t\t\t\t\t$ref: '#definitions/closeBracket'\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnotIn: {\n\t\t\t\t\t\t\ttype: 'array',\n\t\t\t\t\t\t\tdescription: nls.localize('schema.autoClosingPairs.notIn', 'Defines a list of scopes where the auto pairs are disabled.'),\n\t\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\t\tenum: ['string', 'comment']\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}]\n\t\t\t}\n\t\t},\n\t\tautoCloseBefore: {\n\t\t\tdefault: ';:.,=}])> \\n\\t',\n\t\t\tdescription: nls.localize('schema.autoCloseBefore', 'Defines what characters must be after the cursor in order for bracket or quote autoclosing to occur when using the \\'languageDefined\\' autoclosing setting. This is typically the set of characters which can not start an expression.'),\n\t\t\ttype: 'string',\n\t\t},\n\t\tsurroundingPairs: {\n\t\t\tdefault: [['(', ')'], ['[', ']'], ['{', '}']],\n\t\t\tdescription: nls.localize('schema.surroundingPairs', 'Defines the bracket pairs that can be used to surround a selected string.'),\n\t\t\ttype: 'array',\n\t\t\titems: {\n\t\t\t\toneOf: [{\n\t\t\t\t\t$ref: '#definitions/bracketPair'\n\t\t\t\t}, {\n\t\t\t\t\ttype: 'object',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\topen: {\n\t\t\t\t\t\t\t$ref: '#definitions/openBracket'\n\t\t\t\t\t\t},\n\t\t\t\t\t\tclose: {\n\t\t\t\t\t\t\t$ref: '#definitions/closeBracket'\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}]\n\t\t\t}\n\t\t},\n\t\twordPattern: {\n\t\t\tdefault: '',\n\t\t\tdescription: nls.localize('schema.wordPattern', 'Defines what is considered to be a word in the programming language.'),\n\t\t\ttype: ['string', 'object'],\n\t\t\tproperties: {\n\t\t\t\tpattern: {\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: nls.localize('schema.wordPattern.pattern', 'The RegExp pattern used to match words.'),\n\t\t\t\t\tdefault: '',\n\t\t\t\t},\n\t\t\t\tflags: {\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdescription: nls.localize('schema.wordPattern.flags', 'The RegExp flags used to match words.'),\n\t\t\t\t\tdefault: 'g',\n\t\t\t\t\tpattern: '^([gimuy]+)$',\n\t\t\t\t\tpatternErrorMessage: nls.localize('schema.wordPattern.flags.errorMessage', 'Must match the pattern `/^([gimuy]+)$/`.')\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tindentationRules: {\n\t\t\tdefault: {\n\t\t\t\tincreaseIndentPattern: '',\n\t\t\t\tdecreaseIndentPattern: ''\n\t\t\t},\n\t\t\tdescription: nls.localize('schema.indentationRules', 'The language\\'s indentation settings.'),\n\t\t\ttype: 'object',\n\t\t\tproperties: {\n\t\t\t\tincreaseIndentPattern: {\n\t\t\t\t\ttype: ['string', 'object'],\n\t\t\t\t\tdescription: nls.localize('schema.indentationRules.increaseIndentPattern', 'If a line matches this pattern, then all the lines after it should be indented once (until another rule matches).'),\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tpattern: {\n\t\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\t\tdescription: nls.localize('schema.indentationRules.increaseIndentPattern.pattern', 'The RegExp pattern for increaseIndentPattern.'),\n\t\t\t\t\t\t\tdefault: '',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tflags: {\n\t\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\t\tdescription: nls.localize('schema.indentationRules.increaseIndentPattern.flags', 'The RegExp flags for increaseIndentPattern.'),\n\t\t\t\t\t\t\tdefault: '',\n\t\t\t\t\t\t\tpattern: '^([gimuy]+)$',\n\t\t\t\t\t\t\tpatternErrorMessage: nls.localize('schema.indentationRules.increaseIndentPattern.errorMessage', 'Must match the pattern `/^([gimuy]+)$/`.')\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdecreaseIndentPattern: {\n\t\t\t\t\ttype: ['string', 'object'],\n\t\t\t\t\tdescription: nls.localize('schema.indentationRules.decreaseIndentPattern', 'If a line matches this pattern, then all the lines after it should be unindented once (until another rule matches).'),\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tpattern: {\n\t\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\t\tdescription: nls.localize('schema.indentationRules.decreaseIndentPattern.pattern', 'The RegExp pattern for decreaseIndentPattern.'),\n\t\t\t\t\t\t\tdefault: '',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tflags: {\n\t\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\t\tdescription: nls.localize('schema.indentationRules.decreaseIndentPattern.flags', 'The RegExp flags for decreaseIndentPattern.'),\n\t\t\t\t\t\t\tdefault: '',\n\t\t\t\t\t\t\tpattern: '^([gimuy]+)$',\n\t\t\t\t\t\t\tpatternErrorMessage: nls.localize('schema.indentationRules.decreaseIndentPattern.errorMessage', 'Must match the pattern `/^([gimuy]+)$/`.')\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tindentNextLinePattern: {\n\t\t\t\t\ttype: ['string', 'object'],\n\t\t\t\t\tdescription: nls.localize('schema.indentationRules.indentNextLinePattern', 'If a line matches this pattern, then **only the next line** after it should be indented once.'),\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tpattern: {\n\t\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\t\tdescription: nls.localize('schema.indentationRules.indentNextLinePattern.pattern', 'The RegExp pattern for indentNextLinePattern.'),\n\t\t\t\t\t\t\tdefault: '',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tflags: {\n\t\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\t\tdescription: nls.localize('schema.indentationRules.indentNextLinePattern.flags', 'The RegExp flags for indentNextLinePattern.'),\n\t\t\t\t\t\t\tdefault: '',\n\t\t\t\t\t\t\tpattern: '^([gimuy]+)$',\n\t\t\t\t\t\t\tpatternErrorMessage: nls.localize('schema.indentationRules.indentNextLinePattern.errorMessage', 'Must match the pattern `/^([gimuy]+)$/`.')\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tunIndentedLinePattern: {\n\t\t\t\t\ttype: ['string', 'object'],\n\t\t\t\t\tdescription: nls.localize('schema.indentationRules.unIndentedLinePattern', 'If a line matches this pattern, then its indentation should not be changed and it should not be evaluated against the other rules.'),\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tpattern: {\n\t\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\t\tdescription: nls.localize('schema.indentationRules.unIndentedLinePattern.pattern', 'The RegExp pattern for unIndentedLinePattern.'),\n\t\t\t\t\t\t\tdefault: '',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tflags: {\n\t\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\t\tdescription: nls.localize('schema.indentationRules.unIndentedLinePattern.flags', 'The RegExp flags for unIndentedLinePattern.'),\n\t\t\t\t\t\t\tdefault: '',\n\t\t\t\t\t\t\tpattern: '^([gimuy]+)$',\n\t\t\t\t\t\t\tpatternErrorMessage: nls.localize('schema.indentationRules.unIndentedLinePattern.errorMessage', 'Must match the pattern `/^([gimuy]+)$/`.')\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tfolding: {\n\t\t\ttype: 'object',\n\t\t\tdescription: nls.localize('schema.folding', 'The language\\'s folding settings.'),\n\t\t\tproperties: {\n\t\t\t\toffSide: {\n\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\tdescription: nls.localize('schema.folding.offSide', 'A language adheres to the off-side rule if blocks in that language are expressed by their indentation. If set, empty lines belong to the subsequent block.'),\n\t\t\t\t},\n\t\t\t\tmarkers: {\n\t\t\t\t\ttype: 'object',\n\t\t\t\t\tdescription: nls.localize('schema.folding.markers', 'Language specific folding markers such as \\'#region\\' and \\'#endregion\\'. The start and end regexes will be tested against the contents of all lines and must be designed efficiently'),\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\t\tdescription: nls.localize('schema.folding.markers.start', 'The RegExp pattern for the start marker. The regexp must start with \\'^\\'.')\n\t\t\t\t\t\t},\n\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\t\tdescription: nls.localize('schema.folding.markers.end', 'The RegExp pattern for the end marker. The regexp must start with \\'^\\'.')\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n};\nlet schemaRegistry = Registry.as<IJSONContributionRegistry>(Extensions.JSONContribution);\nschemaRegistry.registerSchema(schemaId, schema);\n"]}]}