{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/model/editStack.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/editStack.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/errors\", \"vs/editor/common/model\"], function (require, exports, errors_1, model_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class EditStackElement {\n        constructor(beforeVersionId, beforeCursorState) {\n            this.beforeVersionId = beforeVersionId;\n            this.beforeCursorState = beforeCursorState;\n            this.afterCursorState = null;\n            this.afterVersionId = -1;\n            this.editOperations = [];\n        }\n        undo(model) {\n            // Apply all operations in reverse order\n            for (let i = this.editOperations.length - 1; i >= 0; i--) {\n                this.editOperations[i] = {\n                    operations: model.applyEdits(this.editOperations[i].operations)\n                };\n            }\n        }\n        redo(model) {\n            // Apply all operations\n            for (let i = 0; i < this.editOperations.length; i++) {\n                this.editOperations[i] = {\n                    operations: model.applyEdits(this.editOperations[i].operations)\n                };\n            }\n        }\n    }\n    function getModelEOL(model) {\n        const eol = model.getEOL();\n        if (eol === '\\n') {\n            return model_1.EndOfLineSequence.LF;\n        }\n        else {\n            return model_1.EndOfLineSequence.CRLF;\n        }\n    }\n    class EOLStackElement {\n        constructor(beforeVersionId, setEOL) {\n            this.beforeVersionId = beforeVersionId;\n            this.beforeCursorState = null;\n            this.afterCursorState = null;\n            this.afterVersionId = -1;\n            this.eol = setEOL;\n        }\n        undo(model) {\n            let redoEOL = getModelEOL(model);\n            model.setEOL(this.eol);\n            this.eol = redoEOL;\n        }\n        redo(model) {\n            let undoEOL = getModelEOL(model);\n            model.setEOL(this.eol);\n            this.eol = undoEOL;\n        }\n    }\n    class EditStack {\n        constructor(model) {\n            this.model = model;\n            this.currentOpenStackElement = null;\n            this.past = [];\n            this.future = [];\n        }\n        pushStackElement() {\n            if (this.currentOpenStackElement !== null) {\n                this.past.push(this.currentOpenStackElement);\n                this.currentOpenStackElement = null;\n            }\n        }\n        clear() {\n            this.currentOpenStackElement = null;\n            this.past = [];\n            this.future = [];\n        }\n        pushEOL(eol) {\n            // No support for parallel universes :(\n            this.future = [];\n            if (this.currentOpenStackElement) {\n                this.pushStackElement();\n            }\n            const prevEOL = getModelEOL(this.model);\n            let stackElement = new EOLStackElement(this.model.getAlternativeVersionId(), prevEOL);\n            this.model.setEOL(eol);\n            stackElement.afterVersionId = this.model.getVersionId();\n            this.currentOpenStackElement = stackElement;\n            this.pushStackElement();\n        }\n        pushEditOperation(beforeCursorState, editOperations, cursorStateComputer) {\n            // No support for parallel universes :(\n            this.future = [];\n            let stackElement = null;\n            if (this.currentOpenStackElement) {\n                if (this.currentOpenStackElement instanceof EditStackElement) {\n                    stackElement = this.currentOpenStackElement;\n                }\n                else {\n                    this.pushStackElement();\n                }\n            }\n            if (!this.currentOpenStackElement) {\n                stackElement = new EditStackElement(this.model.getAlternativeVersionId(), beforeCursorState);\n                this.currentOpenStackElement = stackElement;\n            }\n            const inverseEditOperation = {\n                operations: this.model.applyEdits(editOperations)\n            };\n            stackElement.editOperations.push(inverseEditOperation);\n            stackElement.afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperation.operations);\n            stackElement.afterVersionId = this.model.getVersionId();\n            return stackElement.afterCursorState;\n        }\n        static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n            try {\n                return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n            }\n            catch (e) {\n                errors_1.onUnexpectedError(e);\n                return null;\n            }\n        }\n        undo() {\n            this.pushStackElement();\n            if (this.past.length > 0) {\n                const pastStackElement = this.past.pop();\n                try {\n                    pastStackElement.undo(this.model);\n                }\n                catch (e) {\n                    errors_1.onUnexpectedError(e);\n                    this.clear();\n                    return null;\n                }\n                this.future.push(pastStackElement);\n                return {\n                    selections: pastStackElement.beforeCursorState,\n                    recordedVersionId: pastStackElement.beforeVersionId\n                };\n            }\n            return null;\n        }\n        canUndo() {\n            return (this.past.length > 0) || this.currentOpenStackElement !== null;\n        }\n        redo() {\n            if (this.future.length > 0) {\n                const futureStackElement = this.future.pop();\n                try {\n                    futureStackElement.redo(this.model);\n                }\n                catch (e) {\n                    errors_1.onUnexpectedError(e);\n                    this.clear();\n                    return null;\n                }\n                this.past.push(futureStackElement);\n                return {\n                    selections: futureStackElement.afterCursorState,\n                    recordedVersionId: futureStackElement.afterVersionId\n                };\n            }\n            return null;\n        }\n        canRedo() {\n            return (this.future.length > 0);\n        }\n    }\n    exports.EditStack = EditStack;\n});\n",null]}