{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/range.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/range.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Range;\n    (function (Range) {\n        /**\n         * Returns the intersection between two ranges as a range itself.\n         * Returns `{ start: 0, end: 0 }` if the intersection is empty.\n         */\n        function intersect(one, other) {\n            if (one.start >= other.end || other.start >= one.end) {\n                return { start: 0, end: 0 };\n            }\n            const start = Math.max(one.start, other.start);\n            const end = Math.min(one.end, other.end);\n            if (end - start <= 0) {\n                return { start: 0, end: 0 };\n            }\n            return { start, end };\n        }\n        Range.intersect = intersect;\n        function isEmpty(range) {\n            return range.end - range.start <= 0;\n        }\n        Range.isEmpty = isEmpty;\n        function intersects(one, other) {\n            return !isEmpty(intersect(one, other));\n        }\n        Range.intersects = intersects;\n        function relativeComplement(one, other) {\n            const result = [];\n            const first = { start: one.start, end: Math.min(other.start, one.end) };\n            const second = { start: Math.max(other.end, one.start), end: one.end };\n            if (!isEmpty(first)) {\n                result.push(first);\n            }\n            if (!isEmpty(second)) {\n                result.push(second);\n            }\n            return result;\n        }\n        Range.relativeComplement = relativeComplement;\n    })(Range = exports.Range || (exports.Range = {}));\n});\n",null]}