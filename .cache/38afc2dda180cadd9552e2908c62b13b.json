{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/common/problemMatcher.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/common/problemMatcher.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/objects\", \"vs/base/common/strings\", \"vs/base/common/assert\", \"vs/base/common/path\", \"vs/base/common/types\", \"vs/base/common/uuid\", \"vs/base/common/platform\", \"vs/base/common/severity\", \"vs/base/common/uri\", \"vs/base/common/parsers\", \"vs/platform/markers/common/markers\", \"vs/workbench/services/extensions/common/extensionsRegistry\", \"vs/base/common/event\"], function (require, exports, nls_1, Objects, Strings, Assert, path_1, Types, UUID, Platform, severity_1, uri_1, parsers_1, markers_1, extensionsRegistry_1, event_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var FileLocationKind;\n    (function (FileLocationKind) {\n        FileLocationKind[FileLocationKind[\"Auto\"] = 0] = \"Auto\";\n        FileLocationKind[FileLocationKind[\"Relative\"] = 1] = \"Relative\";\n        FileLocationKind[FileLocationKind[\"Absolute\"] = 2] = \"Absolute\";\n    })(FileLocationKind = exports.FileLocationKind || (exports.FileLocationKind = {}));\n    (function (FileLocationKind) {\n        function fromString(value) {\n            value = value.toLowerCase();\n            if (value === 'absolute') {\n                return FileLocationKind.Absolute;\n            }\n            else if (value === 'relative') {\n                return FileLocationKind.Relative;\n            }\n            else {\n                return undefined;\n            }\n        }\n        FileLocationKind.fromString = fromString;\n    })(FileLocationKind = exports.FileLocationKind || (exports.FileLocationKind = {}));\n    var ProblemLocationKind;\n    (function (ProblemLocationKind) {\n        ProblemLocationKind[ProblemLocationKind[\"File\"] = 0] = \"File\";\n        ProblemLocationKind[ProblemLocationKind[\"Location\"] = 1] = \"Location\";\n    })(ProblemLocationKind = exports.ProblemLocationKind || (exports.ProblemLocationKind = {}));\n    (function (ProblemLocationKind) {\n        function fromString(value) {\n            value = value.toLowerCase();\n            if (value === 'file') {\n                return ProblemLocationKind.File;\n            }\n            else if (value === 'location') {\n                return ProblemLocationKind.Location;\n            }\n            else {\n                return undefined;\n            }\n        }\n        ProblemLocationKind.fromString = fromString;\n    })(ProblemLocationKind = exports.ProblemLocationKind || (exports.ProblemLocationKind = {}));\n    var ApplyToKind;\n    (function (ApplyToKind) {\n        ApplyToKind[ApplyToKind[\"allDocuments\"] = 0] = \"allDocuments\";\n        ApplyToKind[ApplyToKind[\"openDocuments\"] = 1] = \"openDocuments\";\n        ApplyToKind[ApplyToKind[\"closedDocuments\"] = 2] = \"closedDocuments\";\n    })(ApplyToKind = exports.ApplyToKind || (exports.ApplyToKind = {}));\n    (function (ApplyToKind) {\n        function fromString(value) {\n            value = value.toLowerCase();\n            if (value === 'alldocuments') {\n                return ApplyToKind.allDocuments;\n            }\n            else if (value === 'opendocuments') {\n                return ApplyToKind.openDocuments;\n            }\n            else if (value === 'closeddocuments') {\n                return ApplyToKind.closedDocuments;\n            }\n            else {\n                return undefined;\n            }\n        }\n        ApplyToKind.fromString = fromString;\n    })(ApplyToKind = exports.ApplyToKind || (exports.ApplyToKind = {}));\n    function isNamedProblemMatcher(value) {\n        return value && Types.isString(value.name) ? true : false;\n    }\n    exports.isNamedProblemMatcher = isNamedProblemMatcher;\n    function getResource(filename, matcher) {\n        let kind = matcher.fileLocation;\n        let fullPath;\n        if (kind === FileLocationKind.Absolute) {\n            fullPath = filename;\n        }\n        else if ((kind === FileLocationKind.Relative) && matcher.filePrefix) {\n            fullPath = path_1.join(matcher.filePrefix, filename);\n        }\n        if (fullPath === undefined) {\n            throw new Error('FileLocationKind is not actionable. Does the matcher have a filePrefix? This should never happen.');\n        }\n        fullPath = fullPath.replace(/\\\\/g, '/');\n        if (fullPath[0] !== '/') {\n            fullPath = '/' + fullPath;\n        }\n        if (matcher.uriProvider !== undefined) {\n            return matcher.uriProvider(fullPath);\n        }\n        else {\n            return uri_1.URI.file(fullPath);\n        }\n    }\n    exports.getResource = getResource;\n    function createLineMatcher(matcher) {\n        let pattern = matcher.pattern;\n        if (Types.isArray(pattern)) {\n            return new MultiLineMatcher(matcher);\n        }\n        else {\n            return new SingleLineMatcher(matcher);\n        }\n    }\n    exports.createLineMatcher = createLineMatcher;\n    const endOfLine = Platform.OS === Platform.OperatingSystem.Windows ? '\\r\\n' : '\\n';\n    class AbstractLineMatcher {\n        constructor(matcher) {\n            this.matcher = matcher;\n        }\n        handle(lines, start = 0) {\n            return { match: null, continue: false };\n        }\n        next(line) {\n            return null;\n        }\n        fillProblemData(data, pattern, matches) {\n            if (data) {\n                this.fillProperty(data, 'file', pattern, matches, true);\n                this.appendProperty(data, 'message', pattern, matches, true);\n                this.fillProperty(data, 'code', pattern, matches, true);\n                this.fillProperty(data, 'severity', pattern, matches, true);\n                this.fillProperty(data, 'location', pattern, matches, true);\n                this.fillProperty(data, 'line', pattern, matches);\n                this.fillProperty(data, 'character', pattern, matches);\n                this.fillProperty(data, 'endLine', pattern, matches);\n                this.fillProperty(data, 'endCharacter', pattern, matches);\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        appendProperty(data, property, pattern, matches, trim = false) {\n            const patternProperty = pattern[property];\n            if (Types.isUndefined(data[property])) {\n                this.fillProperty(data, property, pattern, matches, trim);\n            }\n            else if (!Types.isUndefined(patternProperty) && patternProperty < matches.length) {\n                let value = matches[patternProperty];\n                if (trim) {\n                    value = Strings.trim(value);\n                }\n                data[property] += endOfLine + value;\n            }\n        }\n        fillProperty(data, property, pattern, matches, trim = false) {\n            const patternAtProperty = pattern[property];\n            if (Types.isUndefined(data[property]) && !Types.isUndefined(patternAtProperty) && patternAtProperty < matches.length) {\n                let value = matches[patternAtProperty];\n                if (value !== undefined) {\n                    if (trim) {\n                        value = Strings.trim(value);\n                    }\n                    data[property] = value;\n                }\n            }\n        }\n        getMarkerMatch(data) {\n            try {\n                let location = this.getLocation(data);\n                if (data.file && location && data.message) {\n                    let marker = {\n                        severity: this.getSeverity(data),\n                        startLineNumber: location.startLineNumber,\n                        startColumn: location.startCharacter,\n                        endLineNumber: location.endLineNumber,\n                        endColumn: location.endCharacter,\n                        message: data.message\n                    };\n                    if (data.code !== undefined) {\n                        marker.code = data.code;\n                    }\n                    if (this.matcher.source !== undefined) {\n                        marker.source = this.matcher.source;\n                    }\n                    return {\n                        description: this.matcher,\n                        resource: this.getResource(data.file),\n                        marker: marker\n                    };\n                }\n            }\n            catch (err) {\n                console.error(`Failed to convert problem data into match: ${JSON.stringify(data)}`);\n            }\n            return undefined;\n        }\n        getResource(filename) {\n            return getResource(filename, this.matcher);\n        }\n        getLocation(data) {\n            if (data.kind === ProblemLocationKind.File) {\n                return this.createLocation(0, 0, 0, 0);\n            }\n            if (data.location) {\n                return this.parseLocationInfo(data.location);\n            }\n            if (!data.line) {\n                return null;\n            }\n            let startLine = parseInt(data.line);\n            let startColumn = data.character ? parseInt(data.character) : undefined;\n            let endLine = data.endLine ? parseInt(data.endLine) : undefined;\n            let endColumn = data.endCharacter ? parseInt(data.endCharacter) : undefined;\n            return this.createLocation(startLine, startColumn, endLine, endColumn);\n        }\n        parseLocationInfo(value) {\n            if (!value || !value.match(/(\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)/)) {\n                return null;\n            }\n            let parts = value.split(',');\n            let startLine = parseInt(parts[0]);\n            let startColumn = parts.length > 1 ? parseInt(parts[1]) : undefined;\n            if (parts.length > 3) {\n                return this.createLocation(startLine, startColumn, parseInt(parts[2]), parseInt(parts[3]));\n            }\n            else {\n                return this.createLocation(startLine, startColumn, undefined, undefined);\n            }\n        }\n        createLocation(startLine, startColumn, endLine, endColumn) {\n            if (startColumn !== undefined && endColumn !== undefined) {\n                return { startLineNumber: startLine, startCharacter: startColumn, endLineNumber: endLine || startLine, endCharacter: endColumn };\n            }\n            if (startColumn !== undefined) {\n                return { startLineNumber: startLine, startCharacter: startColumn, endLineNumber: startLine, endCharacter: startColumn };\n            }\n            return { startLineNumber: startLine, startCharacter: 1, endLineNumber: startLine, endCharacter: Number.MAX_VALUE };\n        }\n        getSeverity(data) {\n            let result = null;\n            if (data.severity) {\n                let value = data.severity;\n                if (value) {\n                    result = severity_1.default.fromValue(value);\n                    if (result === severity_1.default.Ignore) {\n                        if (value === 'E') {\n                            result = severity_1.default.Error;\n                        }\n                        else if (value === 'W') {\n                            result = severity_1.default.Warning;\n                        }\n                        else if (value === 'I') {\n                            result = severity_1.default.Info;\n                        }\n                        else if (Strings.equalsIgnoreCase(value, 'hint')) {\n                            result = severity_1.default.Info;\n                        }\n                        else if (Strings.equalsIgnoreCase(value, 'note')) {\n                            result = severity_1.default.Info;\n                        }\n                    }\n                }\n            }\n            if (result === null || result === severity_1.default.Ignore) {\n                result = this.matcher.severity || severity_1.default.Error;\n            }\n            return markers_1.MarkerSeverity.fromSeverity(result);\n        }\n    }\n    class SingleLineMatcher extends AbstractLineMatcher {\n        constructor(matcher) {\n            super(matcher);\n            this.pattern = matcher.pattern;\n        }\n        get matchLength() {\n            return 1;\n        }\n        handle(lines, start = 0) {\n            Assert.ok(lines.length - start === 1);\n            let data = Object.create(null);\n            if (this.pattern.kind !== undefined) {\n                data.kind = this.pattern.kind;\n            }\n            let matches = this.pattern.regexp.exec(lines[start]);\n            if (matches) {\n                this.fillProblemData(data, this.pattern, matches);\n                let match = this.getMarkerMatch(data);\n                if (match) {\n                    return { match: match, continue: false };\n                }\n            }\n            return { match: null, continue: false };\n        }\n        next(line) {\n            return null;\n        }\n    }\n    class MultiLineMatcher extends AbstractLineMatcher {\n        constructor(matcher) {\n            super(matcher);\n            this.patterns = matcher.pattern;\n        }\n        get matchLength() {\n            return this.patterns.length;\n        }\n        handle(lines, start = 0) {\n            Assert.ok(lines.length - start === this.patterns.length);\n            this.data = Object.create(null);\n            let data = this.data;\n            data.kind = this.patterns[0].kind;\n            for (let i = 0; i < this.patterns.length; i++) {\n                let pattern = this.patterns[i];\n                let matches = pattern.regexp.exec(lines[i + start]);\n                if (!matches) {\n                    return { match: null, continue: false };\n                }\n                else {\n                    // Only the last pattern can loop\n                    if (pattern.loop && i === this.patterns.length - 1) {\n                        data = Objects.deepClone(data);\n                    }\n                    this.fillProblemData(data, pattern, matches);\n                }\n            }\n            let loop = !!this.patterns[this.patterns.length - 1].loop;\n            if (!loop) {\n                this.data = null;\n            }\n            const markerMatch = data ? this.getMarkerMatch(data) : null;\n            return { match: markerMatch ? markerMatch : null, continue: loop };\n        }\n        next(line) {\n            let pattern = this.patterns[this.patterns.length - 1];\n            Assert.ok(pattern.loop === true && this.data !== null);\n            let matches = pattern.regexp.exec(line);\n            if (!matches) {\n                this.data = null;\n                return null;\n            }\n            let data = Objects.deepClone(this.data);\n            let problemMatch;\n            if (this.fillProblemData(data, pattern, matches)) {\n                problemMatch = this.getMarkerMatch(data);\n            }\n            return problemMatch ? problemMatch : null;\n        }\n    }\n    var Config;\n    (function (Config) {\n        let CheckedProblemPattern;\n        (function (CheckedProblemPattern) {\n            function is(value) {\n                let candidate = value;\n                return candidate && Types.isString(candidate.regexp);\n            }\n            CheckedProblemPattern.is = is;\n        })(CheckedProblemPattern = Config.CheckedProblemPattern || (Config.CheckedProblemPattern = {}));\n        let NamedProblemPattern;\n        (function (NamedProblemPattern) {\n            function is(value) {\n                let candidate = value;\n                return candidate && Types.isString(candidate.name);\n            }\n            NamedProblemPattern.is = is;\n        })(NamedProblemPattern = Config.NamedProblemPattern || (Config.NamedProblemPattern = {}));\n        let NamedCheckedProblemPattern;\n        (function (NamedCheckedProblemPattern) {\n            function is(value) {\n                let candidate = value;\n                return candidate && NamedProblemPattern.is(candidate) && Types.isString(candidate.regexp);\n            }\n            NamedCheckedProblemPattern.is = is;\n        })(NamedCheckedProblemPattern = Config.NamedCheckedProblemPattern || (Config.NamedCheckedProblemPattern = {}));\n        let MultiLineProblemPattern;\n        (function (MultiLineProblemPattern) {\n            function is(value) {\n                return value && Types.isArray(value);\n            }\n            MultiLineProblemPattern.is = is;\n        })(MultiLineProblemPattern = Config.MultiLineProblemPattern || (Config.MultiLineProblemPattern = {}));\n        let MultiLineCheckedProblemPattern;\n        (function (MultiLineCheckedProblemPattern) {\n            function is(value) {\n                if (!MultiLineProblemPattern.is(value)) {\n                    return false;\n                }\n                for (const element of value) {\n                    if (!Config.CheckedProblemPattern.is(element)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            MultiLineCheckedProblemPattern.is = is;\n        })(MultiLineCheckedProblemPattern = Config.MultiLineCheckedProblemPattern || (Config.MultiLineCheckedProblemPattern = {}));\n        let NamedMultiLineCheckedProblemPattern;\n        (function (NamedMultiLineCheckedProblemPattern) {\n            function is(value) {\n                let candidate = value;\n                return candidate && Types.isString(candidate.name) && Types.isArray(candidate.patterns) && MultiLineCheckedProblemPattern.is(candidate.patterns);\n            }\n            NamedMultiLineCheckedProblemPattern.is = is;\n        })(NamedMultiLineCheckedProblemPattern = Config.NamedMultiLineCheckedProblemPattern || (Config.NamedMultiLineCheckedProblemPattern = {}));\n        function isNamedProblemMatcher(value) {\n            return Types.isString(value.name);\n        }\n        Config.isNamedProblemMatcher = isNamedProblemMatcher;\n    })(Config = exports.Config || (exports.Config = {}));\n    class ProblemPatternParser extends parsers_1.Parser {\n        constructor(logger) {\n            super(logger);\n        }\n        parse(value) {\n            if (Config.NamedMultiLineCheckedProblemPattern.is(value)) {\n                return this.createNamedMultiLineProblemPattern(value);\n            }\n            else if (Config.MultiLineCheckedProblemPattern.is(value)) {\n                return this.createMultiLineProblemPattern(value);\n            }\n            else if (Config.NamedCheckedProblemPattern.is(value)) {\n                let result = this.createSingleProblemPattern(value);\n                result.name = value.name;\n                return result;\n            }\n            else if (Config.CheckedProblemPattern.is(value)) {\n                return this.createSingleProblemPattern(value);\n            }\n            else {\n                this.error(nls_1.localize('ProblemPatternParser.problemPattern.missingRegExp', 'The problem pattern is missing a regular expression.'));\n                return null;\n            }\n        }\n        createSingleProblemPattern(value) {\n            let result = this.doCreateSingleProblemPattern(value, true);\n            if (result === undefined) {\n                return null;\n            }\n            else if (result.kind === undefined) {\n                result.kind = ProblemLocationKind.Location;\n            }\n            return this.validateProblemPattern([result]) ? result : null;\n        }\n        createNamedMultiLineProblemPattern(value) {\n            const validPatterns = this.createMultiLineProblemPattern(value.patterns);\n            if (!validPatterns) {\n                return null;\n            }\n            let result = {\n                name: value.name,\n                label: value.label ? value.label : value.name,\n                patterns: validPatterns\n            };\n            return result;\n        }\n        createMultiLineProblemPattern(values) {\n            let result = [];\n            for (let i = 0; i < values.length; i++) {\n                let pattern = this.doCreateSingleProblemPattern(values[i], false);\n                if (pattern === undefined) {\n                    return null;\n                }\n                if (i < values.length - 1) {\n                    if (!Types.isUndefined(pattern.loop) && pattern.loop) {\n                        pattern.loop = false;\n                        this.error(nls_1.localize('ProblemPatternParser.loopProperty.notLast', 'The loop property is only supported on the last line matcher.'));\n                    }\n                }\n                result.push(pattern);\n            }\n            if (result[0].kind === undefined) {\n                result[0].kind = ProblemLocationKind.Location;\n            }\n            return this.validateProblemPattern(result) ? result : null;\n        }\n        doCreateSingleProblemPattern(value, setDefaults) {\n            const regexp = this.createRegularExpression(value.regexp);\n            if (regexp === undefined) {\n                return undefined;\n            }\n            let result = { regexp };\n            if (value.kind) {\n                result.kind = ProblemLocationKind.fromString(value.kind);\n            }\n            function copyProperty(result, source, resultKey, sourceKey) {\n                let value = source[sourceKey];\n                if (typeof value === 'number') {\n                    result[resultKey] = value;\n                }\n            }\n            copyProperty(result, value, 'file', 'file');\n            copyProperty(result, value, 'location', 'location');\n            copyProperty(result, value, 'line', 'line');\n            copyProperty(result, value, 'character', 'column');\n            copyProperty(result, value, 'endLine', 'endLine');\n            copyProperty(result, value, 'endCharacter', 'endColumn');\n            copyProperty(result, value, 'severity', 'severity');\n            copyProperty(result, value, 'code', 'code');\n            copyProperty(result, value, 'message', 'message');\n            if (value.loop === true || value.loop === false) {\n                result.loop = value.loop;\n            }\n            if (setDefaults) {\n                if (result.location || result.kind === ProblemLocationKind.File) {\n                    let defaultValue = {\n                        file: 1,\n                        message: 0\n                    };\n                    result = Objects.mixin(result, defaultValue, false);\n                }\n                else {\n                    let defaultValue = {\n                        file: 1,\n                        line: 2,\n                        character: 3,\n                        message: 0\n                    };\n                    result = Objects.mixin(result, defaultValue, false);\n                }\n            }\n            return result;\n        }\n        validateProblemPattern(values) {\n            let file = false, message = false, location = false, line = false;\n            let locationKind = (values[0].kind === undefined) ? ProblemLocationKind.Location : values[0].kind;\n            values.forEach((pattern, i) => {\n                if (i !== 0 && pattern.kind) {\n                    this.error(nls_1.localize('ProblemPatternParser.problemPattern.kindProperty.notFirst', 'The problem pattern is invalid. The kind property must be provided only in the first element'));\n                }\n                file = file || !Types.isUndefined(pattern.file);\n                message = message || !Types.isUndefined(pattern.message);\n                location = location || !Types.isUndefined(pattern.location);\n                line = line || !Types.isUndefined(pattern.line);\n            });\n            if (!(file && message)) {\n                this.error(nls_1.localize('ProblemPatternParser.problemPattern.missingProperty', 'The problem pattern is invalid. It must have at least have a file and a message.'));\n                return false;\n            }\n            if (locationKind === ProblemLocationKind.Location && !(location || line)) {\n                this.error(nls_1.localize('ProblemPatternParser.problemPattern.missingLocation', 'The problem pattern is invalid. It must either have kind: \"file\" or have a line or location match group.'));\n                return false;\n            }\n            return true;\n        }\n        createRegularExpression(value) {\n            let result;\n            try {\n                result = new RegExp(value);\n            }\n            catch (err) {\n                this.error(nls_1.localize('ProblemPatternParser.invalidRegexp', 'Error: The string {0} is not a valid regular expression.\\n', value));\n            }\n            return result;\n        }\n    }\n    exports.ProblemPatternParser = ProblemPatternParser;\n    class ExtensionRegistryReporter {\n        constructor(_collector, _validationStatus = new parsers_1.ValidationStatus()) {\n            this._collector = _collector;\n            this._validationStatus = _validationStatus;\n        }\n        info(message) {\n            this._validationStatus.state = parsers_1.ValidationState.Info;\n            this._collector.info(message);\n        }\n        warn(message) {\n            this._validationStatus.state = parsers_1.ValidationState.Warning;\n            this._collector.warn(message);\n        }\n        error(message) {\n            this._validationStatus.state = parsers_1.ValidationState.Error;\n            this._collector.error(message);\n        }\n        fatal(message) {\n            this._validationStatus.state = parsers_1.ValidationState.Fatal;\n            this._collector.error(message);\n        }\n        get status() {\n            return this._validationStatus;\n        }\n    }\n    exports.ExtensionRegistryReporter = ExtensionRegistryReporter;\n    var Schemas;\n    (function (Schemas) {\n        Schemas.ProblemPattern = {\n            default: {\n                regexp: '^([^\\\\\\\\s].*)\\\\\\\\((\\\\\\\\d+,\\\\\\\\d+)\\\\\\\\):\\\\\\\\s*(.*)$',\n                file: 1,\n                location: 2,\n                message: 3\n            },\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n                regexp: {\n                    type: 'string',\n                    description: nls_1.localize('ProblemPatternSchema.regexp', 'The regular expression to find an error, warning or info in the output.')\n                },\n                kind: {\n                    type: 'string',\n                    description: nls_1.localize('ProblemPatternSchema.kind', 'whether the pattern matches a location (file and line) or only a file.')\n                },\n                file: {\n                    type: 'integer',\n                    description: nls_1.localize('ProblemPatternSchema.file', 'The match group index of the filename. If omitted 1 is used.')\n                },\n                location: {\n                    type: 'integer',\n                    description: nls_1.localize('ProblemPatternSchema.location', 'The match group index of the problem\\'s location. Valid location patterns are: (line), (line,column) and (startLine,startColumn,endLine,endColumn). If omitted (line,column) is assumed.')\n                },\n                line: {\n                    type: 'integer',\n                    description: nls_1.localize('ProblemPatternSchema.line', 'The match group index of the problem\\'s line. Defaults to 2')\n                },\n                column: {\n                    type: 'integer',\n                    description: nls_1.localize('ProblemPatternSchema.column', 'The match group index of the problem\\'s line character. Defaults to 3')\n                },\n                endLine: {\n                    type: 'integer',\n                    description: nls_1.localize('ProblemPatternSchema.endLine', 'The match group index of the problem\\'s end line. Defaults to undefined')\n                },\n                endColumn: {\n                    type: 'integer',\n                    description: nls_1.localize('ProblemPatternSchema.endColumn', 'The match group index of the problem\\'s end line character. Defaults to undefined')\n                },\n                severity: {\n                    type: 'integer',\n                    description: nls_1.localize('ProblemPatternSchema.severity', 'The match group index of the problem\\'s severity. Defaults to undefined')\n                },\n                code: {\n                    type: 'integer',\n                    description: nls_1.localize('ProblemPatternSchema.code', 'The match group index of the problem\\'s code. Defaults to undefined')\n                },\n                message: {\n                    type: 'integer',\n                    description: nls_1.localize('ProblemPatternSchema.message', 'The match group index of the message. If omitted it defaults to 4 if location is specified. Otherwise it defaults to 5.')\n                },\n                loop: {\n                    type: 'boolean',\n                    description: nls_1.localize('ProblemPatternSchema.loop', 'In a multi line matcher loop indicated whether this pattern is executed in a loop as long as it matches. Can only specified on a last pattern in a multi line pattern.')\n                }\n            }\n        };\n        Schemas.NamedProblemPattern = Objects.deepClone(Schemas.ProblemPattern);\n        Schemas.NamedProblemPattern.properties = Objects.deepClone(Schemas.NamedProblemPattern.properties) || {};\n        Schemas.NamedProblemPattern.properties['name'] = {\n            type: 'string',\n            description: nls_1.localize('NamedProblemPatternSchema.name', 'The name of the problem pattern.')\n        };\n        Schemas.MultiLineProblemPattern = {\n            type: 'array',\n            items: Schemas.ProblemPattern\n        };\n        Schemas.NamedMultiLineProblemPattern = {\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n                name: {\n                    type: 'string',\n                    description: nls_1.localize('NamedMultiLineProblemPatternSchema.name', 'The name of the problem multi line problem pattern.')\n                },\n                patterns: {\n                    type: 'array',\n                    description: nls_1.localize('NamedMultiLineProblemPatternSchema.patterns', 'The actual patterns.'),\n                    items: Schemas.ProblemPattern\n                }\n            }\n        };\n    })(Schemas = exports.Schemas || (exports.Schemas = {}));\n    const problemPatternExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint({\n        extensionPoint: 'problemPatterns',\n        jsonSchema: {\n            description: nls_1.localize('ProblemPatternExtPoint', 'Contributes problem patterns'),\n            type: 'array',\n            items: {\n                anyOf: [\n                    Schemas.NamedProblemPattern,\n                    Schemas.NamedMultiLineProblemPattern\n                ]\n            }\n        }\n    });\n    class ProblemPatternRegistryImpl {\n        constructor() {\n            this.patterns = Object.create(null);\n            this.fillDefaults();\n            this.readyPromise = new Promise((resolve, reject) => {\n                problemPatternExtPoint.setHandler((extensions, delta) => {\n                    // We get all statically know extension during startup in one batch\n                    try {\n                        delta.removed.forEach(extension => {\n                            let problemPatterns = extension.value;\n                            for (let pattern of problemPatterns) {\n                                if (this.patterns[pattern.name]) {\n                                    delete this.patterns[pattern.name];\n                                }\n                            }\n                        });\n                        delta.added.forEach(extension => {\n                            let problemPatterns = extension.value;\n                            let parser = new ProblemPatternParser(new ExtensionRegistryReporter(extension.collector));\n                            for (let pattern of problemPatterns) {\n                                if (Config.NamedMultiLineCheckedProblemPattern.is(pattern)) {\n                                    let result = parser.parse(pattern);\n                                    if (parser.problemReporter.status.state < parsers_1.ValidationState.Error) {\n                                        this.add(result.name, result.patterns);\n                                    }\n                                    else {\n                                        extension.collector.error(nls_1.localize('ProblemPatternRegistry.error', 'Invalid problem pattern. The pattern will be ignored.'));\n                                        extension.collector.error(JSON.stringify(pattern, undefined, 4));\n                                    }\n                                }\n                                else if (Config.NamedProblemPattern.is(pattern)) {\n                                    let result = parser.parse(pattern);\n                                    if (parser.problemReporter.status.state < parsers_1.ValidationState.Error) {\n                                        this.add(pattern.name, result);\n                                    }\n                                    else {\n                                        extension.collector.error(nls_1.localize('ProblemPatternRegistry.error', 'Invalid problem pattern. The pattern will be ignored.'));\n                                        extension.collector.error(JSON.stringify(pattern, undefined, 4));\n                                    }\n                                }\n                                parser.reset();\n                            }\n                        });\n                    }\n                    catch (error) {\n                        // Do nothing\n                    }\n                    resolve(undefined);\n                });\n            });\n        }\n        onReady() {\n            return this.readyPromise;\n        }\n        add(key, value) {\n            this.patterns[key] = value;\n        }\n        get(key) {\n            return this.patterns[key];\n        }\n        fillDefaults() {\n            this.add('msCompile', {\n                regexp: /^(?:\\s+\\d+\\>)?([^\\s].*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\)\\s*:\\s+(error|warning|info)\\s+(\\w{1,2}\\d+)\\s*:\\s*(.*)$/,\n                kind: ProblemLocationKind.Location,\n                file: 1,\n                location: 2,\n                severity: 3,\n                code: 4,\n                message: 5\n            });\n            this.add('gulp-tsc', {\n                regexp: /^([^\\s].*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\):\\s+(\\d+)\\s+(.*)$/,\n                kind: ProblemLocationKind.Location,\n                file: 1,\n                location: 2,\n                code: 3,\n                message: 4\n            });\n            this.add('cpp', {\n                regexp: /^([^\\s].*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\):\\s+(error|warning|info)\\s+(C\\d+)\\s*:\\s*(.*)$/,\n                kind: ProblemLocationKind.Location,\n                file: 1,\n                location: 2,\n                severity: 3,\n                code: 4,\n                message: 5\n            });\n            this.add('csc', {\n                regexp: /^([^\\s].*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\):\\s+(error|warning|info)\\s+(CS\\d+)\\s*:\\s*(.*)$/,\n                kind: ProblemLocationKind.Location,\n                file: 1,\n                location: 2,\n                severity: 3,\n                code: 4,\n                message: 5\n            });\n            this.add('vb', {\n                regexp: /^([^\\s].*)\\((\\d+|\\d+,\\d+|\\d+,\\d+,\\d+,\\d+)\\):\\s+(error|warning|info)\\s+(BC\\d+)\\s*:\\s*(.*)$/,\n                kind: ProblemLocationKind.Location,\n                file: 1,\n                location: 2,\n                severity: 3,\n                code: 4,\n                message: 5\n            });\n            this.add('lessCompile', {\n                regexp: /^\\s*(.*) in file (.*) line no. (\\d+)$/,\n                kind: ProblemLocationKind.Location,\n                message: 1,\n                file: 2,\n                line: 3\n            });\n            this.add('jshint', {\n                regexp: /^(.*):\\s+line\\s+(\\d+),\\s+col\\s+(\\d+),\\s(.+?)(?:\\s+\\((\\w)(\\d+)\\))?$/,\n                kind: ProblemLocationKind.Location,\n                file: 1,\n                line: 2,\n                character: 3,\n                message: 4,\n                severity: 5,\n                code: 6\n            });\n            this.add('jshint-stylish', [\n                {\n                    regexp: /^(.+)$/,\n                    kind: ProblemLocationKind.Location,\n                    file: 1\n                },\n                {\n                    regexp: /^\\s+line\\s+(\\d+)\\s+col\\s+(\\d+)\\s+(.+?)(?:\\s+\\((\\w)(\\d+)\\))?$/,\n                    line: 1,\n                    character: 2,\n                    message: 3,\n                    severity: 4,\n                    code: 5,\n                    loop: true\n                }\n            ]);\n            this.add('eslint-compact', {\n                regexp: /^(.+):\\sline\\s(\\d+),\\scol\\s(\\d+),\\s(Error|Warning|Info)\\s-\\s(.+)\\s\\((.+)\\)$/,\n                file: 1,\n                kind: ProblemLocationKind.Location,\n                line: 2,\n                character: 3,\n                severity: 4,\n                message: 5,\n                code: 6\n            });\n            this.add('eslint-stylish', [\n                {\n                    regexp: /^([^\\s].*)$/,\n                    kind: ProblemLocationKind.Location,\n                    file: 1\n                },\n                {\n                    regexp: /^\\s+(\\d+):(\\d+)\\s+(error|warning|info)\\s+(.+?)(?:\\s\\s+(.*))?$/,\n                    line: 1,\n                    character: 2,\n                    severity: 3,\n                    message: 4,\n                    code: 5,\n                    loop: true\n                }\n            ]);\n            this.add('go', {\n                regexp: /^([^:]*: )?((.:)?[^:]*):(\\d+)(:(\\d+))?: (.*)$/,\n                kind: ProblemLocationKind.Location,\n                file: 2,\n                line: 4,\n                character: 6,\n                message: 7\n            });\n        }\n    }\n    exports.ProblemPatternRegistry = new ProblemPatternRegistryImpl();\n    class ProblemMatcherParser extends parsers_1.Parser {\n        constructor(logger) {\n            super(logger);\n        }\n        parse(json) {\n            let result = this.createProblemMatcher(json);\n            if (!this.checkProblemMatcherValid(json, result)) {\n                return undefined;\n            }\n            this.addWatchingMatcher(json, result);\n            return result;\n        }\n        checkProblemMatcherValid(externalProblemMatcher, problemMatcher) {\n            if (!problemMatcher) {\n                this.error(nls_1.localize('ProblemMatcherParser.noProblemMatcher', 'Error: the description can\\'t be converted into a problem matcher:\\n{0}\\n', JSON.stringify(externalProblemMatcher, null, 4)));\n                return false;\n            }\n            if (!problemMatcher.pattern) {\n                this.error(nls_1.localize('ProblemMatcherParser.noProblemPattern', 'Error: the description doesn\\'t define a valid problem pattern:\\n{0}\\n', JSON.stringify(externalProblemMatcher, null, 4)));\n                return false;\n            }\n            if (!problemMatcher.owner) {\n                this.error(nls_1.localize('ProblemMatcherParser.noOwner', 'Error: the description doesn\\'t define an owner:\\n{0}\\n', JSON.stringify(externalProblemMatcher, null, 4)));\n                return false;\n            }\n            if (Types.isUndefined(problemMatcher.fileLocation)) {\n                this.error(nls_1.localize('ProblemMatcherParser.noFileLocation', 'Error: the description doesn\\'t define a file location:\\n{0}\\n', JSON.stringify(externalProblemMatcher, null, 4)));\n                return false;\n            }\n            return true;\n        }\n        createProblemMatcher(description) {\n            let result = null;\n            let owner = Types.isString(description.owner) ? description.owner : UUID.generateUuid();\n            let source = Types.isString(description.source) ? description.source : undefined;\n            let applyTo = Types.isString(description.applyTo) ? ApplyToKind.fromString(description.applyTo) : ApplyToKind.allDocuments;\n            if (!applyTo) {\n                applyTo = ApplyToKind.allDocuments;\n            }\n            let fileLocation = undefined;\n            let filePrefix = undefined;\n            let kind;\n            if (Types.isUndefined(description.fileLocation)) {\n                fileLocation = FileLocationKind.Relative;\n                filePrefix = '${workspaceFolder}';\n            }\n            else if (Types.isString(description.fileLocation)) {\n                kind = FileLocationKind.fromString(description.fileLocation);\n                if (kind) {\n                    fileLocation = kind;\n                    if (kind === FileLocationKind.Relative) {\n                        filePrefix = '${workspaceFolder}';\n                    }\n                }\n            }\n            else if (Types.isStringArray(description.fileLocation)) {\n                let values = description.fileLocation;\n                if (values.length > 0) {\n                    kind = FileLocationKind.fromString(values[0]);\n                    if (values.length === 1 && kind === FileLocationKind.Absolute) {\n                        fileLocation = kind;\n                    }\n                    else if (values.length === 2 && kind === FileLocationKind.Relative && values[1]) {\n                        fileLocation = kind;\n                        filePrefix = values[1];\n                    }\n                }\n            }\n            let pattern = description.pattern ? this.createProblemPattern(description.pattern) : undefined;\n            let severity = description.severity ? severity_1.default.fromValue(description.severity) : undefined;\n            if (severity === severity_1.default.Ignore) {\n                this.info(nls_1.localize('ProblemMatcherParser.unknownSeverity', 'Info: unknown severity {0}. Valid values are error, warning and info.\\n', description.severity));\n                severity = severity_1.default.Error;\n            }\n            if (Types.isString(description.base)) {\n                let variableName = description.base;\n                if (variableName.length > 1 && variableName[0] === '$') {\n                    let base = exports.ProblemMatcherRegistry.get(variableName.substring(1));\n                    if (base) {\n                        result = Objects.deepClone(base);\n                        if (description.owner !== undefined && owner !== undefined) {\n                            result.owner = owner;\n                        }\n                        if (description.source !== undefined && source !== undefined) {\n                            result.source = source;\n                        }\n                        if (description.fileLocation !== undefined && fileLocation !== undefined) {\n                            result.fileLocation = fileLocation;\n                            result.filePrefix = filePrefix;\n                        }\n                        if (description.pattern !== undefined && pattern !== undefined && pattern !== null) {\n                            result.pattern = pattern;\n                        }\n                        if (description.severity !== undefined && severity !== undefined) {\n                            result.severity = severity;\n                        }\n                        if (description.applyTo !== undefined && applyTo !== undefined) {\n                            result.applyTo = applyTo;\n                        }\n                    }\n                }\n            }\n            else if (fileLocation && pattern) {\n                result = {\n                    owner: owner,\n                    applyTo: applyTo,\n                    fileLocation: fileLocation,\n                    pattern: pattern,\n                };\n                if (source) {\n                    result.source = source;\n                }\n                if (filePrefix) {\n                    result.filePrefix = filePrefix;\n                }\n                if (severity) {\n                    result.severity = severity;\n                }\n            }\n            if (Config.isNamedProblemMatcher(description)) {\n                result.name = description.name;\n                result.label = Types.isString(description.label) ? description.label : description.name;\n            }\n            return result;\n        }\n        createProblemPattern(value) {\n            if (Types.isString(value)) {\n                let variableName = value;\n                if (variableName.length > 1 && variableName[0] === '$') {\n                    let result = exports.ProblemPatternRegistry.get(variableName.substring(1));\n                    if (!result) {\n                        this.error(nls_1.localize('ProblemMatcherParser.noDefinedPatter', 'Error: the pattern with the identifier {0} doesn\\'t exist.', variableName));\n                    }\n                    return result;\n                }\n                else {\n                    if (variableName.length === 0) {\n                        this.error(nls_1.localize('ProblemMatcherParser.noIdentifier', 'Error: the pattern property refers to an empty identifier.'));\n                    }\n                    else {\n                        this.error(nls_1.localize('ProblemMatcherParser.noValidIdentifier', 'Error: the pattern property {0} is not a valid pattern variable name.', variableName));\n                    }\n                }\n            }\n            else if (value) {\n                let problemPatternParser = new ProblemPatternParser(this.problemReporter);\n                if (Array.isArray(value)) {\n                    return problemPatternParser.parse(value);\n                }\n                else {\n                    return problemPatternParser.parse(value);\n                }\n            }\n            return null;\n        }\n        addWatchingMatcher(external, internal) {\n            let oldBegins = this.createRegularExpression(external.watchedTaskBeginsRegExp);\n            let oldEnds = this.createRegularExpression(external.watchedTaskEndsRegExp);\n            if (oldBegins && oldEnds) {\n                internal.watching = {\n                    activeOnStart: false,\n                    beginsPattern: { regexp: oldBegins },\n                    endsPattern: { regexp: oldEnds }\n                };\n                return;\n            }\n            let backgroundMonitor = external.background || external.watching;\n            if (Types.isUndefinedOrNull(backgroundMonitor)) {\n                return;\n            }\n            let begins = this.createWatchingPattern(backgroundMonitor.beginsPattern);\n            let ends = this.createWatchingPattern(backgroundMonitor.endsPattern);\n            if (begins && ends) {\n                internal.watching = {\n                    activeOnStart: Types.isBoolean(backgroundMonitor.activeOnStart) ? backgroundMonitor.activeOnStart : false,\n                    beginsPattern: begins,\n                    endsPattern: ends\n                };\n                return;\n            }\n            if (begins || ends) {\n                this.error(nls_1.localize('ProblemMatcherParser.problemPattern.watchingMatcher', 'A problem matcher must define both a begin pattern and an end pattern for watching.'));\n            }\n        }\n        createWatchingPattern(external) {\n            if (Types.isUndefinedOrNull(external)) {\n                return null;\n            }\n            let regexp;\n            let file;\n            if (Types.isString(external)) {\n                regexp = this.createRegularExpression(external);\n            }\n            else {\n                regexp = this.createRegularExpression(external.regexp);\n                if (Types.isNumber(external.file)) {\n                    file = external.file;\n                }\n            }\n            if (!regexp) {\n                return null;\n            }\n            return file ? { regexp, file } : { regexp, file: 1 };\n        }\n        createRegularExpression(value) {\n            let result = null;\n            if (!value) {\n                return result;\n            }\n            try {\n                result = new RegExp(value);\n            }\n            catch (err) {\n                this.error(nls_1.localize('ProblemMatcherParser.invalidRegexp', 'Error: The string {0} is not a valid regular expression.\\n', value));\n            }\n            return result;\n        }\n    }\n    exports.ProblemMatcherParser = ProblemMatcherParser;\n    (function (Schemas) {\n        Schemas.WatchingPattern = {\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n                regexp: {\n                    type: 'string',\n                    description: nls_1.localize('WatchingPatternSchema.regexp', 'The regular expression to detect the begin or end of a background task.')\n                },\n                file: {\n                    type: 'integer',\n                    description: nls_1.localize('WatchingPatternSchema.file', 'The match group index of the filename. Can be omitted.')\n                },\n            }\n        };\n        Schemas.PatternType = {\n            anyOf: [\n                {\n                    type: 'string',\n                    description: nls_1.localize('PatternTypeSchema.name', 'The name of a contributed or predefined pattern')\n                },\n                Schemas.ProblemPattern,\n                Schemas.MultiLineProblemPattern\n            ],\n            description: nls_1.localize('PatternTypeSchema.description', 'A problem pattern or the name of a contributed or predefined problem pattern. Can be omitted if base is specified.')\n        };\n        Schemas.ProblemMatcher = {\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n                base: {\n                    type: 'string',\n                    description: nls_1.localize('ProblemMatcherSchema.base', 'The name of a base problem matcher to use.')\n                },\n                owner: {\n                    type: 'string',\n                    description: nls_1.localize('ProblemMatcherSchema.owner', 'The owner of the problem inside Code. Can be omitted if base is specified. Defaults to \\'external\\' if omitted and base is not specified.')\n                },\n                source: {\n                    type: 'string',\n                    description: nls_1.localize('ProblemMatcherSchema.source', 'A human-readable string describing the source of this diagnostic, e.g. \\'typescript\\' or \\'super lint\\'.')\n                },\n                severity: {\n                    type: 'string',\n                    enum: ['error', 'warning', 'info'],\n                    description: nls_1.localize('ProblemMatcherSchema.severity', 'The default severity for captures problems. Is used if the pattern doesn\\'t define a match group for severity.')\n                },\n                applyTo: {\n                    type: 'string',\n                    enum: ['allDocuments', 'openDocuments', 'closedDocuments'],\n                    description: nls_1.localize('ProblemMatcherSchema.applyTo', 'Controls if a problem reported on a text document is applied only to open, closed or all documents.')\n                },\n                pattern: Schemas.PatternType,\n                fileLocation: {\n                    oneOf: [\n                        {\n                            type: 'string',\n                            enum: ['absolute', 'relative']\n                        },\n                        {\n                            type: 'array',\n                            items: {\n                                type: 'string'\n                            }\n                        }\n                    ],\n                    description: nls_1.localize('ProblemMatcherSchema.fileLocation', 'Defines how file names reported in a problem pattern should be interpreted.')\n                },\n                background: {\n                    type: 'object',\n                    additionalProperties: false,\n                    description: nls_1.localize('ProblemMatcherSchema.background', 'Patterns to track the begin and end of a matcher active on a background task.'),\n                    properties: {\n                        activeOnStart: {\n                            type: 'boolean',\n                            description: nls_1.localize('ProblemMatcherSchema.background.activeOnStart', 'If set to true the background monitor is in active mode when the task starts. This is equals of issuing a line that matches the beginPattern')\n                        },\n                        beginsPattern: {\n                            oneOf: [\n                                {\n                                    type: 'string'\n                                },\n                                Schemas.WatchingPattern\n                            ],\n                            description: nls_1.localize('ProblemMatcherSchema.background.beginsPattern', 'If matched in the output the start of a background task is signaled.')\n                        },\n                        endsPattern: {\n                            oneOf: [\n                                {\n                                    type: 'string'\n                                },\n                                Schemas.WatchingPattern\n                            ],\n                            description: nls_1.localize('ProblemMatcherSchema.background.endsPattern', 'If matched in the output the end of a background task is signaled.')\n                        }\n                    }\n                },\n                watching: {\n                    type: 'object',\n                    additionalProperties: false,\n                    deprecationMessage: nls_1.localize('ProblemMatcherSchema.watching.deprecated', 'The watching property is deprecated. Use background instead.'),\n                    description: nls_1.localize('ProblemMatcherSchema.watching', 'Patterns to track the begin and end of a watching matcher.'),\n                    properties: {\n                        activeOnStart: {\n                            type: 'boolean',\n                            description: nls_1.localize('ProblemMatcherSchema.watching.activeOnStart', 'If set to true the watcher is in active mode when the task starts. This is equals of issuing a line that matches the beginPattern')\n                        },\n                        beginsPattern: {\n                            oneOf: [\n                                {\n                                    type: 'string'\n                                },\n                                Schemas.WatchingPattern\n                            ],\n                            description: nls_1.localize('ProblemMatcherSchema.watching.beginsPattern', 'If matched in the output the start of a watching task is signaled.')\n                        },\n                        endsPattern: {\n                            oneOf: [\n                                {\n                                    type: 'string'\n                                },\n                                Schemas.WatchingPattern\n                            ],\n                            description: nls_1.localize('ProblemMatcherSchema.watching.endsPattern', 'If matched in the output the end of a watching task is signaled.')\n                        }\n                    }\n                }\n            }\n        };\n        Schemas.LegacyProblemMatcher = Objects.deepClone(Schemas.ProblemMatcher);\n        Schemas.LegacyProblemMatcher.properties = Objects.deepClone(Schemas.LegacyProblemMatcher.properties) || {};\n        Schemas.LegacyProblemMatcher.properties['watchedTaskBeginsRegExp'] = {\n            type: 'string',\n            deprecationMessage: nls_1.localize('LegacyProblemMatcherSchema.watchedBegin.deprecated', 'This property is deprecated. Use the watching property instead.'),\n            description: nls_1.localize('LegacyProblemMatcherSchema.watchedBegin', 'A regular expression signaling that a watched tasks begins executing triggered through file watching.')\n        };\n        Schemas.LegacyProblemMatcher.properties['watchedTaskEndsRegExp'] = {\n            type: 'string',\n            deprecationMessage: nls_1.localize('LegacyProblemMatcherSchema.watchedEnd.deprecated', 'This property is deprecated. Use the watching property instead.'),\n            description: nls_1.localize('LegacyProblemMatcherSchema.watchedEnd', 'A regular expression signaling that a watched tasks ends executing.')\n        };\n        Schemas.NamedProblemMatcher = Objects.deepClone(Schemas.ProblemMatcher);\n        Schemas.NamedProblemMatcher.properties = Objects.deepClone(Schemas.NamedProblemMatcher.properties) || {};\n        Schemas.NamedProblemMatcher.properties.name = {\n            type: 'string',\n            description: nls_1.localize('NamedProblemMatcherSchema.name', 'The name of the problem matcher used to refer to it.')\n        };\n        Schemas.NamedProblemMatcher.properties.label = {\n            type: 'string',\n            description: nls_1.localize('NamedProblemMatcherSchema.label', 'A human readable label of the problem matcher.')\n        };\n    })(Schemas = exports.Schemas || (exports.Schemas = {}));\n    const problemMatchersExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint({\n        extensionPoint: 'problemMatchers',\n        deps: [problemPatternExtPoint],\n        jsonSchema: {\n            description: nls_1.localize('ProblemMatcherExtPoint', 'Contributes problem matchers'),\n            type: 'array',\n            items: Schemas.NamedProblemMatcher\n        }\n    });\n    class ProblemMatcherRegistryImpl {\n        constructor() {\n            this._onMatchersChanged = new event_1.Emitter();\n            this.matchers = Object.create(null);\n            this.fillDefaults();\n            this.readyPromise = new Promise((resolve, reject) => {\n                problemMatchersExtPoint.setHandler((extensions, delta) => {\n                    try {\n                        delta.removed.forEach(extension => {\n                            let problemMatchers = extension.value;\n                            for (let matcher of problemMatchers) {\n                                if (this.matchers[matcher.name]) {\n                                    delete this.matchers[matcher.name];\n                                }\n                            }\n                        });\n                        delta.added.forEach(extension => {\n                            let problemMatchers = extension.value;\n                            let parser = new ProblemMatcherParser(new ExtensionRegistryReporter(extension.collector));\n                            for (let matcher of problemMatchers) {\n                                let result = parser.parse(matcher);\n                                if (result && isNamedProblemMatcher(result)) {\n                                    this.add(result);\n                                }\n                            }\n                        });\n                        if ((delta.removed.length > 0) || (delta.added.length > 0)) {\n                            this._onMatchersChanged.fire();\n                        }\n                    }\n                    catch (error) {\n                    }\n                    let matcher = this.get('tsc-watch');\n                    if (matcher) {\n                        matcher.tscWatch = true;\n                    }\n                    resolve(undefined);\n                });\n            });\n        }\n        get onMatcherChanged() { return this._onMatchersChanged.event; }\n        onReady() {\n            exports.ProblemPatternRegistry.onReady();\n            return this.readyPromise;\n        }\n        add(matcher) {\n            this.matchers[matcher.name] = matcher;\n        }\n        get(name) {\n            return this.matchers[name];\n        }\n        keys() {\n            return Object.keys(this.matchers);\n        }\n        fillDefaults() {\n            this.add({\n                name: 'msCompile',\n                label: nls_1.localize('msCompile', 'Microsoft compiler problems'),\n                owner: 'msCompile',\n                applyTo: ApplyToKind.allDocuments,\n                fileLocation: FileLocationKind.Absolute,\n                pattern: exports.ProblemPatternRegistry.get('msCompile')\n            });\n            this.add({\n                name: 'lessCompile',\n                label: nls_1.localize('lessCompile', 'Less problems'),\n                deprecated: true,\n                owner: 'lessCompile',\n                source: 'less',\n                applyTo: ApplyToKind.allDocuments,\n                fileLocation: FileLocationKind.Absolute,\n                pattern: exports.ProblemPatternRegistry.get('lessCompile'),\n                severity: severity_1.default.Error\n            });\n            this.add({\n                name: 'gulp-tsc',\n                label: nls_1.localize('gulp-tsc', 'Gulp TSC Problems'),\n                owner: 'typescript',\n                source: 'ts',\n                applyTo: ApplyToKind.closedDocuments,\n                fileLocation: FileLocationKind.Relative,\n                filePrefix: '${workspaceFolder}',\n                pattern: exports.ProblemPatternRegistry.get('gulp-tsc')\n            });\n            this.add({\n                name: 'jshint',\n                label: nls_1.localize('jshint', 'JSHint problems'),\n                owner: 'jshint',\n                source: 'jshint',\n                applyTo: ApplyToKind.allDocuments,\n                fileLocation: FileLocationKind.Absolute,\n                pattern: exports.ProblemPatternRegistry.get('jshint')\n            });\n            this.add({\n                name: 'jshint-stylish',\n                label: nls_1.localize('jshint-stylish', 'JSHint stylish problems'),\n                owner: 'jshint',\n                source: 'jshint',\n                applyTo: ApplyToKind.allDocuments,\n                fileLocation: FileLocationKind.Absolute,\n                pattern: exports.ProblemPatternRegistry.get('jshint-stylish')\n            });\n            this.add({\n                name: 'eslint-compact',\n                label: nls_1.localize('eslint-compact', 'ESLint compact problems'),\n                owner: 'eslint',\n                source: 'eslint',\n                applyTo: ApplyToKind.allDocuments,\n                fileLocation: FileLocationKind.Absolute,\n                filePrefix: '${workspaceFolder}',\n                pattern: exports.ProblemPatternRegistry.get('eslint-compact')\n            });\n            this.add({\n                name: 'eslint-stylish',\n                label: nls_1.localize('eslint-stylish', 'ESLint stylish problems'),\n                owner: 'eslint',\n                source: 'eslint',\n                applyTo: ApplyToKind.allDocuments,\n                fileLocation: FileLocationKind.Absolute,\n                pattern: exports.ProblemPatternRegistry.get('eslint-stylish')\n            });\n            this.add({\n                name: 'go',\n                label: nls_1.localize('go', 'Go problems'),\n                owner: 'go',\n                source: 'go',\n                applyTo: ApplyToKind.allDocuments,\n                fileLocation: FileLocationKind.Relative,\n                filePrefix: '${workspaceFolder}',\n                pattern: exports.ProblemPatternRegistry.get('go')\n            });\n        }\n    }\n    exports.ProblemMatcherRegistry = new ProblemMatcherRegistryImpl();\n});\n",null]}