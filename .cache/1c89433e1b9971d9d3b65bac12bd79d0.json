{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/find/findModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/find/findModel.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/async\", \"vs/base/common/keyCodes\", \"vs/base/common/lifecycle\", \"vs/editor/common/commands/replaceCommand\", \"vs/editor/common/controller/cursorEvents\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\", \"vs/editor/common/core/selection\", \"vs/editor/common/core/uint\", \"vs/editor/common/editorCommon\", \"vs/editor/common/model\", \"vs/editor/common/model/textModelSearch\", \"vs/editor/contrib/find/findDecorations\", \"vs/editor/contrib/find/replaceAllCommand\", \"vs/editor/contrib/find/replacePattern\", \"vs/platform/contextkey/common/contextkey\"], function (require, exports, async_1, keyCodes_1, lifecycle_1, replaceCommand_1, cursorEvents_1, position_1, range_1, selection_1, uint_1, editorCommon, model_1, textModelSearch_1, findDecorations_1, replaceAllCommand_1, replacePattern_1, contextkey_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.CONTEXT_FIND_WIDGET_VISIBLE = new contextkey_1.RawContextKey('findWidgetVisible', false);\n    exports.CONTEXT_FIND_WIDGET_NOT_VISIBLE = exports.CONTEXT_FIND_WIDGET_VISIBLE.toNegated();\n    // Keep ContextKey use of 'Focussed' to not break when clauses\n    exports.CONTEXT_FIND_INPUT_FOCUSED = new contextkey_1.RawContextKey('findInputFocussed', false);\n    exports.CONTEXT_REPLACE_INPUT_FOCUSED = new contextkey_1.RawContextKey('replaceInputFocussed', false);\n    exports.ToggleCaseSensitiveKeybinding = {\n        primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_C,\n        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_C }\n    };\n    exports.ToggleWholeWordKeybinding = {\n        primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_W,\n        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_W }\n    };\n    exports.ToggleRegexKeybinding = {\n        primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_R,\n        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_R }\n    };\n    exports.ToggleSearchScopeKeybinding = {\n        primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_L,\n        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_L }\n    };\n    exports.FIND_IDS = {\n        StartFindAction: 'actions.find',\n        StartFindWithSelection: 'actions.findWithSelection',\n        NextMatchFindAction: 'editor.action.nextMatchFindAction',\n        PreviousMatchFindAction: 'editor.action.previousMatchFindAction',\n        NextSelectionMatchFindAction: 'editor.action.nextSelectionMatchFindAction',\n        PreviousSelectionMatchFindAction: 'editor.action.previousSelectionMatchFindAction',\n        StartFindReplaceAction: 'editor.action.startFindReplaceAction',\n        CloseFindWidgetCommand: 'closeFindWidget',\n        ToggleCaseSensitiveCommand: 'toggleFindCaseSensitive',\n        ToggleWholeWordCommand: 'toggleFindWholeWord',\n        ToggleRegexCommand: 'toggleFindRegex',\n        ToggleSearchScopeCommand: 'toggleFindInSelection',\n        ReplaceOneAction: 'editor.action.replaceOne',\n        ReplaceAllAction: 'editor.action.replaceAll',\n        SelectAllMatchesAction: 'editor.action.selectAllMatches'\n    };\n    exports.MATCHES_LIMIT = 19999;\n    const RESEARCH_DELAY = 240;\n    class FindModelBoundToEditorModel {\n        constructor(editor, state) {\n            this._editor = editor;\n            this._state = state;\n            this._toDispose = [];\n            this._isDisposed = false;\n            this._startSearchingTimer = new async_1.TimeoutTimer();\n            this._decorations = new findDecorations_1.FindDecorations(editor);\n            this._toDispose.push(this._decorations);\n            this._updateDecorationsScheduler = new async_1.RunOnceScheduler(() => this.research(false), 100);\n            this._toDispose.push(this._updateDecorationsScheduler);\n            this._toDispose.push(this._editor.onDidChangeCursorPosition((e) => {\n                if (e.reason === cursorEvents_1.CursorChangeReason.Explicit\n                    || e.reason === cursorEvents_1.CursorChangeReason.Undo\n                    || e.reason === cursorEvents_1.CursorChangeReason.Redo) {\n                    this._decorations.setStartPosition(this._editor.getPosition());\n                }\n            }));\n            this._ignoreModelContentChanged = false;\n            this._toDispose.push(this._editor.onDidChangeModelContent((e) => {\n                if (this._ignoreModelContentChanged) {\n                    return;\n                }\n                if (e.isFlush) {\n                    // a model.setValue() was called\n                    this._decorations.reset();\n                }\n                this._decorations.setStartPosition(this._editor.getPosition());\n                this._updateDecorationsScheduler.schedule();\n            }));\n            this._toDispose.push(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));\n            this.research(false, this._state.searchScope);\n        }\n        dispose() {\n            this._isDisposed = true;\n            lifecycle_1.dispose(this._startSearchingTimer);\n            this._toDispose = lifecycle_1.dispose(this._toDispose);\n        }\n        _onStateChanged(e) {\n            if (this._isDisposed) {\n                // The find model is disposed during a find state changed event\n                return;\n            }\n            if (!this._editor.hasModel()) {\n                // The find model will be disposed momentarily\n                return;\n            }\n            if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {\n                let model = this._editor.getModel();\n                if (model.isTooLargeForSyncing()) {\n                    this._startSearchingTimer.cancel();\n                    this._startSearchingTimer.setIfNotSet(() => {\n                        if (e.searchScope) {\n                            this.research(e.moveCursor, this._state.searchScope);\n                        }\n                        else {\n                            this.research(e.moveCursor);\n                        }\n                    }, RESEARCH_DELAY);\n                }\n                else {\n                    if (e.searchScope) {\n                        this.research(e.moveCursor, this._state.searchScope);\n                    }\n                    else {\n                        this.research(e.moveCursor);\n                    }\n                }\n            }\n        }\n        static _getSearchRange(model, findScope) {\n            // If we have set now or before a find scope, use it for computing the search range\n            if (findScope) {\n                return findScope;\n            }\n            return model.getFullModelRange();\n        }\n        research(moveCursor, newFindScope) {\n            let findScope = null;\n            if (typeof newFindScope !== 'undefined') {\n                findScope = newFindScope;\n            }\n            else {\n                findScope = this._decorations.getFindScope();\n            }\n            if (findScope !== null) {\n                if (findScope.startLineNumber !== findScope.endLineNumber) {\n                    if (findScope.endColumn === 1) {\n                        findScope = new range_1.Range(findScope.startLineNumber, 1, findScope.endLineNumber - 1, this._editor.getModel().getLineMaxColumn(findScope.endLineNumber - 1));\n                    }\n                    else {\n                        // multiline find scope => expand to line starts / ends\n                        findScope = new range_1.Range(findScope.startLineNumber, 1, findScope.endLineNumber, this._editor.getModel().getLineMaxColumn(findScope.endLineNumber));\n                    }\n                }\n            }\n            let findMatches = this._findMatches(findScope, false, exports.MATCHES_LIMIT);\n            this._decorations.set(findMatches, findScope);\n            this._state.changeMatchInfo(this._decorations.getCurrentMatchesPosition(this._editor.getSelection()), this._decorations.getCount(), undefined);\n            if (moveCursor) {\n                this._moveToNextMatch(this._decorations.getStartPosition());\n            }\n        }\n        _hasMatches() {\n            return (this._state.matchesCount > 0);\n        }\n        _cannotFind() {\n            if (!this._hasMatches()) {\n                let findScope = this._decorations.getFindScope();\n                if (findScope) {\n                    // Reveal the selection so user is reminded that 'selection find' is on.\n                    this._editor.revealRangeInCenterIfOutsideViewport(findScope, editorCommon.ScrollType.Smooth);\n                }\n                return true;\n            }\n            return false;\n        }\n        _setCurrentFindMatch(match) {\n            let matchesPosition = this._decorations.setCurrentFindMatch(match);\n            this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match);\n            this._editor.setSelection(match);\n            this._editor.revealRangeInCenterIfOutsideViewport(match, editorCommon.ScrollType.Smooth);\n        }\n        _prevSearchPosition(before) {\n            let isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0\n                || this._state.searchString.indexOf('$') >= 0);\n            let { lineNumber, column } = before;\n            let model = this._editor.getModel();\n            if (isUsingLineStops || column === 1) {\n                if (lineNumber === 1) {\n                    lineNumber = model.getLineCount();\n                }\n                else {\n                    lineNumber--;\n                }\n                column = model.getLineMaxColumn(lineNumber);\n            }\n            else {\n                column--;\n            }\n            return new position_1.Position(lineNumber, column);\n        }\n        _moveToPrevMatch(before, isRecursed = false) {\n            if (this._decorations.getCount() < exports.MATCHES_LIMIT) {\n                let prevMatchRange = this._decorations.matchBeforePosition(before);\n                if (prevMatchRange && prevMatchRange.isEmpty() && prevMatchRange.getStartPosition().equals(before)) {\n                    before = this._prevSearchPosition(before);\n                    prevMatchRange = this._decorations.matchBeforePosition(before);\n                }\n                if (prevMatchRange) {\n                    this._setCurrentFindMatch(prevMatchRange);\n                }\n                return;\n            }\n            if (this._cannotFind()) {\n                return;\n            }\n            let findScope = this._decorations.getFindScope();\n            let searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);\n            // ...(----)...|...\n            if (searchRange.getEndPosition().isBefore(before)) {\n                before = searchRange.getEndPosition();\n            }\n            // ...|...(----)...\n            if (before.isBefore(searchRange.getStartPosition())) {\n                before = searchRange.getEndPosition();\n            }\n            let { lineNumber, column } = before;\n            let model = this._editor.getModel();\n            let position = new position_1.Position(lineNumber, column);\n            let prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, false);\n            if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {\n                // Looks like we're stuck at this position, unacceptable!\n                position = this._prevSearchPosition(position);\n                prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, false);\n            }\n            if (!prevMatch) {\n                // there is precisely one match and selection is on top of it\n                return;\n            }\n            if (!isRecursed && !searchRange.containsRange(prevMatch.range)) {\n                return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);\n            }\n            this._setCurrentFindMatch(prevMatch.range);\n        }\n        moveToPrevMatch() {\n            this._moveToPrevMatch(this._editor.getSelection().getStartPosition());\n        }\n        _nextSearchPosition(after) {\n            let isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0\n                || this._state.searchString.indexOf('$') >= 0);\n            let { lineNumber, column } = after;\n            let model = this._editor.getModel();\n            if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {\n                if (lineNumber === model.getLineCount()) {\n                    lineNumber = 1;\n                }\n                else {\n                    lineNumber++;\n                }\n                column = 1;\n            }\n            else {\n                column++;\n            }\n            return new position_1.Position(lineNumber, column);\n        }\n        _moveToNextMatch(after) {\n            if (this._decorations.getCount() < exports.MATCHES_LIMIT) {\n                let nextMatchRange = this._decorations.matchAfterPosition(after);\n                if (nextMatchRange && nextMatchRange.isEmpty() && nextMatchRange.getStartPosition().equals(after)) {\n                    // Looks like we're stuck at this position, unacceptable!\n                    after = this._nextSearchPosition(after);\n                    nextMatchRange = this._decorations.matchAfterPosition(after);\n                }\n                if (nextMatchRange) {\n                    this._setCurrentFindMatch(nextMatchRange);\n                }\n                return;\n            }\n            let nextMatch = this._getNextMatch(after, false, true);\n            if (nextMatch) {\n                this._setCurrentFindMatch(nextMatch.range);\n            }\n        }\n        _getNextMatch(after, captureMatches, forceMove, isRecursed = false) {\n            if (this._cannotFind()) {\n                return null;\n            }\n            let findScope = this._decorations.getFindScope();\n            let searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);\n            // ...(----)...|...\n            if (searchRange.getEndPosition().isBefore(after)) {\n                after = searchRange.getStartPosition();\n            }\n            // ...|...(----)...\n            if (after.isBefore(searchRange.getStartPosition())) {\n                after = searchRange.getStartPosition();\n            }\n            let { lineNumber, column } = after;\n            let model = this._editor.getModel();\n            let position = new position_1.Position(lineNumber, column);\n            let nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, captureMatches);\n            if (forceMove && nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {\n                // Looks like we're stuck at this position, unacceptable!\n                position = this._nextSearchPosition(position);\n                nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, captureMatches);\n            }\n            if (!nextMatch) {\n                // there is precisely one match and selection is on top of it\n                return null;\n            }\n            if (!isRecursed && !searchRange.containsRange(nextMatch.range)) {\n                return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, forceMove, true);\n            }\n            return nextMatch;\n        }\n        moveToNextMatch() {\n            this._moveToNextMatch(this._editor.getSelection().getEndPosition());\n        }\n        _getReplacePattern() {\n            if (this._state.isRegex) {\n                return replacePattern_1.parseReplaceString(this._state.replaceString);\n            }\n            return replacePattern_1.ReplacePattern.fromStaticValue(this._state.replaceString);\n        }\n        replace() {\n            if (!this._hasMatches()) {\n                return;\n            }\n            let replacePattern = this._getReplacePattern();\n            let selection = this._editor.getSelection();\n            let nextMatch = this._getNextMatch(selection.getStartPosition(), replacePattern.hasReplacementPatterns, false);\n            if (nextMatch) {\n                if (selection.equalsRange(nextMatch.range)) {\n                    // selection sits on a find match => replace it!\n                    let replaceString = replacePattern.buildReplaceString(nextMatch.matches);\n                    let command = new replaceCommand_1.ReplaceCommand(selection, replaceString);\n                    this._executeEditorCommand('replace', command);\n                    this._decorations.setStartPosition(new position_1.Position(selection.startLineNumber, selection.startColumn + replaceString.length));\n                    this.research(true);\n                }\n                else {\n                    this._decorations.setStartPosition(this._editor.getPosition());\n                    this._setCurrentFindMatch(nextMatch.range);\n                }\n            }\n        }\n        _findMatches(findScope, captureMatches, limitResultCount) {\n            let searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);\n            return this._editor.getModel().findMatches(this._state.searchString, searchRange, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, captureMatches, limitResultCount);\n        }\n        replaceAll() {\n            if (!this._hasMatches()) {\n                return;\n            }\n            const findScope = this._decorations.getFindScope();\n            if (findScope === null && this._state.matchesCount >= exports.MATCHES_LIMIT) {\n                // Doing a replace on the entire file that is over ${MATCHES_LIMIT} matches\n                this._largeReplaceAll();\n            }\n            else {\n                this._regularReplaceAll(findScope);\n            }\n            this.research(false);\n        }\n        _largeReplaceAll() {\n            const searchParams = new textModelSearch_1.SearchParams(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return;\n            }\n            let searchRegex = searchData.regex;\n            if (!searchRegex.multiline) {\n                let mod = 'm';\n                if (searchRegex.ignoreCase) {\n                    mod += 'i';\n                }\n                if (searchRegex.global) {\n                    mod += 'g';\n                }\n                searchRegex = new RegExp(searchRegex.source, mod);\n            }\n            const model = this._editor.getModel();\n            const modelText = model.getValue(model_1.EndOfLinePreference.LF);\n            const fullModelRange = model.getFullModelRange();\n            const replacePattern = this._getReplacePattern();\n            let resultText;\n            if (replacePattern.hasReplacementPatterns) {\n                resultText = modelText.replace(searchRegex, function () {\n                    return replacePattern.buildReplaceString(arguments);\n                });\n            }\n            else {\n                resultText = modelText.replace(searchRegex, replacePattern.buildReplaceString(null));\n            }\n            let command = new replaceCommand_1.ReplaceCommandThatPreservesSelection(fullModelRange, resultText, this._editor.getSelection());\n            this._executeEditorCommand('replaceAll', command);\n        }\n        _regularReplaceAll(findScope) {\n            const replacePattern = this._getReplacePattern();\n            // Get all the ranges (even more than the highlighted ones)\n            let matches = this._findMatches(findScope, replacePattern.hasReplacementPatterns, uint_1.Constants.MAX_SAFE_SMALL_INTEGER);\n            let replaceStrings = [];\n            for (let i = 0, len = matches.length; i < len; i++) {\n                replaceStrings[i] = replacePattern.buildReplaceString(matches[i].matches);\n            }\n            let command = new replaceAllCommand_1.ReplaceAllCommand(this._editor.getSelection(), matches.map(m => m.range), replaceStrings);\n            this._executeEditorCommand('replaceAll', command);\n        }\n        selectAllMatches() {\n            if (!this._hasMatches()) {\n                return;\n            }\n            let findScope = this._decorations.getFindScope();\n            // Get all the ranges (even more than the highlighted ones)\n            let matches = this._findMatches(findScope, false, uint_1.Constants.MAX_SAFE_SMALL_INTEGER);\n            let selections = matches.map(m => new selection_1.Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn));\n            // If one of the ranges is the editor selection, then maintain it as primary\n            let editorSelection = this._editor.getSelection();\n            for (let i = 0, len = selections.length; i < len; i++) {\n                let sel = selections[i];\n                if (sel.equalsRange(editorSelection)) {\n                    selections = [editorSelection].concat(selections.slice(0, i)).concat(selections.slice(i + 1));\n                    break;\n                }\n            }\n            this._editor.setSelections(selections);\n        }\n        _executeEditorCommand(source, command) {\n            try {\n                this._ignoreModelContentChanged = true;\n                this._editor.pushUndoStop();\n                this._editor.executeCommand(source, command);\n                this._editor.pushUndoStop();\n            }\n            finally {\n                this._ignoreModelContentChanged = false;\n            }\n        }\n    }\n    exports.FindModelBoundToEditorModel = FindModelBoundToEditorModel;\n});\n",null]}