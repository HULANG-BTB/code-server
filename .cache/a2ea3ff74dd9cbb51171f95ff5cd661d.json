{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/packages/ide/src/retry.ts","dependencies":[{"path":"/home/coding/workspace/packages/ide/src/retry.ts","mtime":1555841535682},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["define([\"require\", \"exports\", \"@coder/logger\", \"./fill/notification\"], function (require, exports, logger_1, notification_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Retry services. Handles multiple services so when a connection drops the\n     * user doesn't get a separate notification for each service.\n     *\n     * Attempts to restart services silently up to a maximum number of tries, then\n     * starts waiting for a delay that grows exponentially with each attempt with a\n     * cap on the delay. Once the delay is long enough, it will show a notification\n     * to the user explaining what is happening with an option to immediately retry.\n     */\n    class Retry {\n        constructor(_notificationService) {\n            this._notificationService = _notificationService;\n            this.items = new Map();\n            // Times are in seconds.\n            this.retryMinDelay = 1;\n            this.retryMaxDelay = 3;\n            this.maxImmediateRetries = 5;\n            this.retryExponent = 1.5;\n            this.updateDelay = 1;\n            this.notificationThreshold = 3;\n            // Time in milliseconds to wait before restarting a service. (See usage below\n            // for reasoning.)\n            this.waitDelay = 50;\n        }\n        set notificationService(service) {\n            this._notificationService = service;\n        }\n        get notificationService() {\n            return this._notificationService;\n        }\n        /**\n         * Register a function to retry that starts/connects to a service.\n         */\n        register(name, fn) {\n            if (this.items.has(name)) {\n                throw new Error(`\"${name}\" is already registered`);\n            }\n            this.items.set(name, { fn });\n            return {\n                block: () => this.block(name),\n                run: (error) => this.run(name, error),\n                recover: () => this.recover(name),\n            };\n        }\n        /**\n         * Un-register a function to retry.\n         */\n        unregister(name) {\n            if (!this.items.has(name)) {\n                throw new Error(`\"${name}\" is not registered`);\n            }\n            this.items.delete(name);\n        }\n        /**\n         * Block retries when we know they will fail (for example when the socket is\n         * down ). If a name is passed, that service will still be allowed to retry\n         * (unless we have already blocked).\n         *\n         * Blocking without a name will override a block with a name.\n         */\n        block(name) {\n            if (!this.blocked || !name) {\n                this.blocked = name || true;\n                this.items.forEach((item) => {\n                    this.stopItem(item);\n                });\n            }\n        }\n        /**\n         * Unblock retries and run any that are pending.\n         */\n        unblock() {\n            this.blocked = false;\n            this.items.forEach((item, name) => {\n                if (item.running) {\n                    this.runItem(name, item);\n                }\n            });\n        }\n        /**\n         * Retry a service.\n         */\n        run(name, error) {\n            if (!this.items.has(name)) {\n                throw new Error(`\"${name}\" is not registered`);\n            }\n            const item = this.items.get(name);\n            if (item.running) {\n                throw new Error(`\"${name}\" is already retrying`);\n            }\n            item.running = true;\n            // This timeout is for the case when the connection drops; this allows time\n            // for the socket service to come in and block everything because some other\n            // services might make it here first and try to restart, which will fail.\n            setTimeout(() => {\n                if (this.blocked && this.blocked !== name) {\n                    return;\n                }\n                if (!item.count || item.count < this.maxImmediateRetries) {\n                    return this.runItem(name, item, error);\n                }\n                if (!item.delay) {\n                    item.delay = this.retryMinDelay;\n                }\n                else {\n                    item.delay = Math.ceil(item.delay * this.retryExponent);\n                    if (item.delay > this.retryMaxDelay) {\n                        item.delay = this.retryMaxDelay;\n                    }\n                }\n                logger_1.logger.info(`Retrying ${name.toLowerCase()} in ${item.delay}s`, error && logger_1.field(\"error\", error.message));\n                const itemDelayMs = item.delay * 1000;\n                item.end = Date.now() + itemDelayMs;\n                item.timeout = setTimeout(() => this.runItem(name, item, error), itemDelayMs);\n                this.updateNotification();\n            }, this.waitDelay);\n        }\n        /**\n         * Reset a service after a successfully recovering.\n         */\n        recover(name) {\n            if (!this.items.has(name)) {\n                throw new Error(`\"${name}\" is not registered`);\n            }\n            const item = this.items.get(name);\n            if (typeof item.timeout === \"undefined\" && !item.running && typeof item.count !== \"undefined\") {\n                logger_1.logger.info(`Connected to ${name.toLowerCase()}`);\n                item.delay = undefined;\n                item.count = undefined;\n            }\n        }\n        /**\n         * Run an item.\n         */\n        runItem(name, item, error) {\n            if (!item.count) {\n                item.count = 1;\n            }\n            else {\n                ++item.count;\n            }\n            const retryCountText = item.count <= this.maxImmediateRetries\n                ? `[${item.count}/${this.maxImmediateRetries}]`\n                : `[${item.count}]`;\n            logger_1.logger.info(`Starting ${name.toLowerCase()} ${retryCountText}...`, error && logger_1.field(\"error\", error.message));\n            const endItem = () => {\n                this.stopItem(item);\n                item.running = false;\n            };\n            try {\n                const maybePromise = item.fn();\n                if (maybePromise instanceof Promise) {\n                    maybePromise.then(() => {\n                        endItem();\n                        this.recover(name);\n                        if (this.blocked === name) {\n                            this.unblock();\n                        }\n                    }).catch((error) => {\n                        endItem();\n                        this.run(name, error);\n                    });\n                }\n                else {\n                    endItem();\n                }\n            }\n            catch (error) {\n                // Prevent an exception from causing the item to never run again.\n                endItem();\n                throw error;\n            }\n        }\n        /**\n         * Update, close, or show the notification.\n         */\n        updateNotification() {\n            // tslint:disable-next-line no-any because NodeJS.Timer is valid.\n            clearTimeout(this.updateTimeout);\n            const now = Date.now();\n            const items = Array.from(this.items.entries()).filter(([_, item]) => {\n                return typeof item.end !== \"undefined\"\n                    && item.end > now\n                    && item.delay && item.delay >= this.notificationThreshold;\n            }).sort((a, b) => {\n                return a[1] < b[1] ? -1 : 1;\n            });\n            if (items.length === 0) {\n                if (this.notificationHandle) {\n                    this.notificationHandle.close();\n                    this.notificationHandle = undefined;\n                }\n                return;\n            }\n            const join = (arr) => {\n                const last = arr.pop(); // Assume length > 0.\n                return arr.length > 0 ? `${arr.join(\", \")} and ${last}` : last;\n            };\n            const servicesStr = join(items.map(([name, _]) => name.toLowerCase()));\n            const message = `Lost connection to ${servicesStr}. Retrying in ${join(items.map(([_, item]) => `${Math.ceil((item.end - now) / 1000)}s`))}.`;\n            const buttons = [{\n                    label: `Retry ${items.length > 1 ? \"Services\" : items[0][0]} Now`,\n                    run: () => {\n                        logger_1.logger.info(`Forcing ${servicesStr} to restart now`);\n                        items.forEach(([name, item]) => {\n                            this.runItem(name, item);\n                        });\n                        this.updateNotification();\n                    },\n                }];\n            if (!this.notificationHandle) {\n                this.notificationHandle = this.notificationService.prompt(notification_1.Severity.Info, message, buttons, () => {\n                    this.notificationHandle = undefined;\n                    // tslint:disable-next-line no-any because NodeJS.Timer is valid.\n                    clearTimeout(this.updateTimeout);\n                });\n            }\n            else {\n                this.notificationHandle.updateMessage(message);\n                this.notificationHandle.updateButtons(buttons);\n            }\n            this.updateTimeout = setTimeout(() => this.updateNotification(), this.updateDelay * 1000);\n        }\n        /**\n         * Stop an item's timer.\n         */\n        stopItem(item) {\n            // tslint:disable-next-line no-any because NodeJS.Timer is valid.\n            clearTimeout(item.timeout);\n            item.timeout = undefined;\n            item.end = undefined;\n        }\n    }\n    exports.Retry = Retry;\n    // Global instance so we can block other retries when retrying the main\n    // connection.\n    exports.retry = new Retry(new notification_1.NotificationService());\n});\n",null]}