{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostFileSystem.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostFileSystem.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/uri\", \"../common/extHost.protocol\", \"vs/platform/files/common/files\", \"vs/base/common/lifecycle\", \"vs/workbench/api/node/extHostTypes\", \"vs/workbench/api/node/extHostTypeConverters\", \"vs/base/common/network\", \"vs/editor/common/modes/linkComputer\", \"vs/base/common/strings\", \"vs/base/common/charCode\"], function (require, exports, uri_1, extHost_protocol_1, files, lifecycle_1, extHostTypes_1, typeConverter, network_1, linkComputer_1, strings_1, charCode_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class FsLinkProvider {\n        constructor() {\n            this._schemes = [];\n        }\n        add(scheme) {\n            this._stateMachine = undefined;\n            this._schemes.push(scheme);\n        }\n        delete(scheme) {\n            const idx = this._schemes.indexOf(scheme);\n            if (idx >= 0) {\n                this._schemes.splice(idx, 1);\n                this._stateMachine = undefined;\n            }\n        }\n        _initStateMachine() {\n            if (!this._stateMachine) {\n                // sort and compute common prefix with previous scheme\n                // then build state transitions based on the data\n                const schemes = this._schemes.sort();\n                const edges = [];\n                let prevScheme;\n                let prevState;\n                let nextState = linkComputer_1.State.LastKnownState;\n                for (const scheme of schemes) {\n                    // skip the common prefix of the prev scheme\n                    // and continue with its last state\n                    let pos = !prevScheme ? 0 : strings_1.commonPrefixLength(prevScheme, scheme);\n                    if (pos === 0) {\n                        prevState = linkComputer_1.State.Start;\n                    }\n                    else {\n                        prevState = nextState;\n                    }\n                    for (; pos < scheme.length; pos++) {\n                        // keep creating new (next) states until the\n                        // end (and the BeforeColon-state) is reached\n                        if (pos + 1 === scheme.length) {\n                            nextState = linkComputer_1.State.BeforeColon;\n                        }\n                        else {\n                            nextState += 1;\n                        }\n                        edges.push([prevState, scheme.toUpperCase().charCodeAt(pos), nextState]);\n                        edges.push([prevState, scheme.toLowerCase().charCodeAt(pos), nextState]);\n                        prevState = nextState;\n                    }\n                    prevScheme = scheme;\n                }\n                // all link must match this pattern `<scheme>:/<more>`\n                edges.push([linkComputer_1.State.BeforeColon, charCode_1.CharCode.Colon, linkComputer_1.State.AfterColon]);\n                edges.push([linkComputer_1.State.AfterColon, charCode_1.CharCode.Slash, linkComputer_1.State.End]);\n                this._stateMachine = new linkComputer_1.StateMachine(edges);\n            }\n        }\n        provideDocumentLinks(document) {\n            this._initStateMachine();\n            const result = [];\n            const links = linkComputer_1.LinkComputer.computeLinks({\n                getLineContent(lineNumber) {\n                    return document.lineAt(lineNumber - 1).text;\n                },\n                getLineCount() {\n                    return document.lineCount;\n                }\n            }, this._stateMachine);\n            for (const link of links) {\n                const docLink = typeConverter.DocumentLink.to(link);\n                if (docLink.target) {\n                    result.push(docLink);\n                }\n            }\n            return result;\n        }\n    }\n    class ExtHostFileSystem {\n        constructor(mainContext, _extHostLanguageFeatures) {\n            this._extHostLanguageFeatures = _extHostLanguageFeatures;\n            this._linkProvider = new FsLinkProvider();\n            this._fsProvider = new Map();\n            this._usedSchemes = new Set();\n            this._watches = new Map();\n            // Used as a handle both for file system providers and resource label formatters (being lazy)\n            this._handlePool = 0;\n            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadFileSystem);\n            this._usedSchemes.add(network_1.Schemas.file);\n            this._usedSchemes.add(network_1.Schemas.untitled);\n            this._usedSchemes.add(network_1.Schemas.vscode);\n            this._usedSchemes.add(network_1.Schemas.inMemory);\n            this._usedSchemes.add(network_1.Schemas.internal);\n            this._usedSchemes.add(network_1.Schemas.http);\n            this._usedSchemes.add(network_1.Schemas.https);\n            this._usedSchemes.add(network_1.Schemas.mailto);\n            this._usedSchemes.add(network_1.Schemas.data);\n            this._usedSchemes.add(network_1.Schemas.command);\n        }\n        dispose() {\n            lifecycle_1.dispose(this._linkProviderRegistration);\n        }\n        _registerLinkProviderIfNotYetRegistered() {\n            if (!this._linkProviderRegistration) {\n                this._linkProviderRegistration = this._extHostLanguageFeatures.registerDocumentLinkProvider(undefined, '*', this._linkProvider);\n            }\n        }\n        registerFileSystemProvider(scheme, provider, options = {}) {\n            if (this._usedSchemes.has(scheme)) {\n                throw new Error(`a provider for the scheme '${scheme}' is already registered`);\n            }\n            //\n            this._registerLinkProviderIfNotYetRegistered();\n            const handle = this._handlePool++;\n            this._linkProvider.add(scheme);\n            this._usedSchemes.add(scheme);\n            this._fsProvider.set(handle, provider);\n            let capabilites = files.FileSystemProviderCapabilities.FileReadWrite;\n            if (options.isCaseSensitive) {\n                capabilites += files.FileSystemProviderCapabilities.PathCaseSensitive;\n            }\n            if (options.isReadonly) {\n                capabilites += files.FileSystemProviderCapabilities.Readonly;\n            }\n            if (typeof provider.copy === 'function') {\n                capabilites += files.FileSystemProviderCapabilities.FileFolderCopy;\n            }\n            if (typeof provider.open === 'function' && typeof provider.close === 'function'\n                && typeof provider.read === 'function' && typeof provider.write === 'function') {\n                capabilites += files.FileSystemProviderCapabilities.FileOpenReadWriteClose;\n            }\n            this._proxy.$registerFileSystemProvider(handle, scheme, capabilites);\n            const subscription = provider.onDidChangeFile(event => {\n                const mapped = [];\n                for (const e of event) {\n                    let { uri: resource, type } = e;\n                    if (resource.scheme !== scheme) {\n                        // dropping events for wrong scheme\n                        continue;\n                    }\n                    let newType;\n                    switch (type) {\n                        case extHostTypes_1.FileChangeType.Changed:\n                            newType = files.FileChangeType.UPDATED;\n                            break;\n                        case extHostTypes_1.FileChangeType.Created:\n                            newType = files.FileChangeType.ADDED;\n                            break;\n                        case extHostTypes_1.FileChangeType.Deleted:\n                            newType = files.FileChangeType.DELETED;\n                            break;\n                        default:\n                            throw new Error('Unknown FileChangeType');\n                    }\n                    mapped.push({ resource, type: newType });\n                }\n                this._proxy.$onFileSystemChange(handle, mapped);\n            });\n            return lifecycle_1.toDisposable(() => {\n                subscription.dispose();\n                this._linkProvider.delete(scheme);\n                this._usedSchemes.delete(scheme);\n                this._fsProvider.delete(handle);\n                this._proxy.$unregisterProvider(handle);\n            });\n        }\n        registerResourceLabelFormatter(formatter) {\n            const handle = this._handlePool++;\n            this._proxy.$registerResourceLabelFormatter(handle, formatter);\n            return lifecycle_1.toDisposable(() => {\n                this._proxy.$unregisterResourceLabelFormatter(handle);\n            });\n        }\n        static _asIStat(stat) {\n            const { type, ctime, mtime, size } = stat;\n            return { type, ctime, mtime, size };\n        }\n        $stat(handle, resource) {\n            return Promise.resolve(this.getProvider(handle).stat(uri_1.URI.revive(resource))).then(ExtHostFileSystem._asIStat);\n        }\n        $readdir(handle, resource) {\n            return Promise.resolve(this.getProvider(handle).readDirectory(uri_1.URI.revive(resource)));\n        }\n        $readFile(handle, resource) {\n            return Promise.resolve(this.getProvider(handle).readFile(uri_1.URI.revive(resource))).then(data => {\n                return Buffer.isBuffer(data) ? data : Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n            });\n        }\n        $writeFile(handle, resource, content, opts) {\n            return Promise.resolve(this.getProvider(handle).writeFile(uri_1.URI.revive(resource), content, opts));\n        }\n        $delete(handle, resource, opts) {\n            return Promise.resolve(this.getProvider(handle).delete(uri_1.URI.revive(resource), opts));\n        }\n        $rename(handle, oldUri, newUri, opts) {\n            return Promise.resolve(this.getProvider(handle).rename(uri_1.URI.revive(oldUri), uri_1.URI.revive(newUri), opts));\n        }\n        $copy(handle, oldUri, newUri, opts) {\n            const provider = this.getProvider(handle);\n            if (!provider.copy) {\n                throw new Error('FileSystemProvider does not implement \"copy\"');\n            }\n            return Promise.resolve(provider.copy(uri_1.URI.revive(oldUri), uri_1.URI.revive(newUri), opts));\n        }\n        $mkdir(handle, resource) {\n            return Promise.resolve(this.getProvider(handle).createDirectory(uri_1.URI.revive(resource)));\n        }\n        $watch(handle, session, resource, opts) {\n            const subscription = this.getProvider(handle).watch(uri_1.URI.revive(resource), opts);\n            this._watches.set(session, subscription);\n        }\n        $unwatch(_handle, session) {\n            const subscription = this._watches.get(session);\n            if (subscription) {\n                subscription.dispose();\n                this._watches.delete(session);\n            }\n        }\n        $open(handle, resource, opts) {\n            const provider = this.getProvider(handle);\n            if (!provider.open) {\n                throw new Error('FileSystemProvider does not implement \"open\"');\n            }\n            return Promise.resolve(provider.open(uri_1.URI.revive(resource), opts));\n        }\n        $close(handle, fd) {\n            const provider = this.getProvider(handle);\n            if (!provider.close) {\n                throw new Error('FileSystemProvider does not implement \"close\"');\n            }\n            return Promise.resolve(provider.close(fd));\n        }\n        $read(handle, fd, pos, length) {\n            const provider = this.getProvider(handle);\n            if (!provider.read) {\n                throw new Error('FileSystemProvider does not implement \"read\"');\n            }\n            const data = Buffer.allocUnsafe(length);\n            return Promise.resolve(provider.read(fd, pos, data, 0, length)).then(read => {\n                return data.slice(0, read); // don't send zeros\n            });\n        }\n        $write(handle, fd, pos, data) {\n            const provider = this.getProvider(handle);\n            if (!provider.write) {\n                throw new Error('FileSystemProvider does not implement \"write\"');\n            }\n            return Promise.resolve(provider.write(fd, pos, data, 0, data.length));\n        }\n        getProvider(handle) {\n            const provider = this._fsProvider.get(handle);\n            if (!provider) {\n                const err = new Error();\n                err.name = 'ENOPRO';\n                err.message = `no provider`;\n                throw err;\n            }\n            return provider;\n        }\n    }\n    exports.ExtHostFileSystem = ExtHostFileSystem;\n});\n",null]}