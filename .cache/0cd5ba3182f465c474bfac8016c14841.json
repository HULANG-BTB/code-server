{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/lifecycle/electron-main/lifecycleMain.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/lifecycle/electron-main/lifecycleMain.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"electron\", \"vs/platform/log/common/log\", \"vs/platform/state/common/state\", \"vs/base/common/event\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/base/common/platform\", \"vs/base/common/lifecycle\"], function (require, exports, electron_1, log_1, state_1, event_1, instantiation_1, lifecycle_1, platform_1, lifecycle_2) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.ILifecycleService = instantiation_1.createDecorator('lifecycleService');\n    var UnloadReason;\n    (function (UnloadReason) {\n        UnloadReason[UnloadReason[\"CLOSE\"] = 1] = \"CLOSE\";\n        UnloadReason[UnloadReason[\"QUIT\"] = 2] = \"QUIT\";\n        UnloadReason[UnloadReason[\"RELOAD\"] = 3] = \"RELOAD\";\n        UnloadReason[UnloadReason[\"LOAD\"] = 4] = \"LOAD\";\n    })(UnloadReason = exports.UnloadReason || (exports.UnloadReason = {}));\n    let LifecycleService = class LifecycleService extends lifecycle_2.Disposable {\n        constructor(logService, stateService) {\n            super();\n            this.logService = logService;\n            this.stateService = stateService;\n            this.windowToCloseRequest = Object.create(null);\n            this.oneTimeListenerTokenGenerator = 0;\n            this.windowCounter = 0;\n            this._quitRequested = false;\n            this._wasRestarted = false;\n            this._onBeforeShutdown = this._register(new event_1.Emitter());\n            this.onBeforeShutdown = this._onBeforeShutdown.event;\n            this._onWillShutdown = this._register(new event_1.Emitter());\n            this.onWillShutdown = this._onWillShutdown.event;\n            this._onBeforeWindowClose = this._register(new event_1.Emitter());\n            this.onBeforeWindowClose = this._onBeforeWindowClose.event;\n            this._onBeforeWindowUnload = this._register(new event_1.Emitter());\n            this.onBeforeWindowUnload = this._onBeforeWindowUnload.event;\n            this.handleRestarted();\n        }\n        get quitRequested() { return this._quitRequested; }\n        get wasRestarted() { return this._wasRestarted; }\n        handleRestarted() {\n            this._wasRestarted = !!this.stateService.getItem(LifecycleService.QUIT_FROM_RESTART_MARKER);\n            if (this._wasRestarted) {\n                this.stateService.removeItem(LifecycleService.QUIT_FROM_RESTART_MARKER); // remove the marker right after if found\n            }\n        }\n        ready() {\n            this.registerListeners();\n        }\n        registerListeners() {\n            // before-quit: an event that is fired if application quit was\n            // requested but before any window was closed.\n            const beforeQuitListener = () => {\n                if (this._quitRequested) {\n                    return;\n                }\n                this.logService.trace('Lifecycle#app.on(before-quit)');\n                this._quitRequested = true;\n                // Emit event to indicate that we are about to shutdown\n                this.logService.trace('Lifecycle#onBeforeShutdown.fire()');\n                this._onBeforeShutdown.fire();\n                // macOS: can run without any window open. in that case we fire\n                // the onWillShutdown() event directly because there is no veto\n                // to be expected.\n                if (platform_1.isMacintosh && this.windowCounter === 0) {\n                    this.beginOnWillShutdown();\n                }\n            };\n            electron_1.app.addListener('before-quit', beforeQuitListener);\n            // window-all-closed: an event that only fires when the last window\n            // was closed. We override this event to be in charge if app.quit()\n            // should be called or not.\n            const windowAllClosedListener = () => {\n                this.logService.trace('Lifecycle#app.on(window-all-closed)');\n                // Windows/Linux: we quit when all windows have closed\n                // Mac: we only quit when quit was requested\n                if (this._quitRequested || !platform_1.isMacintosh) {\n                    electron_1.app.quit();\n                }\n            };\n            electron_1.app.addListener('window-all-closed', windowAllClosedListener);\n            // will-quit: an event that is fired after all windows have been\n            // closed, but before actually quitting.\n            electron_1.app.once('will-quit', e => {\n                this.logService.trace('Lifecycle#app.on(will-quit)');\n                // Prevent the quit until the shutdown promise was resolved\n                e.preventDefault();\n                // Start shutdown sequence\n                const shutdownPromise = this.beginOnWillShutdown();\n                // Wait until shutdown is signaled to be complete\n                shutdownPromise.finally(() => {\n                    // Resolve pending quit promise now without veto\n                    this.resolvePendingQuitPromise(false /* no veto */);\n                    // Quit again, this time do not prevent this, since our\n                    // will-quit listener is only installed \"once\". Also\n                    // remove any listener we have that is no longer needed\n                    electron_1.app.removeListener('before-quit', beforeQuitListener);\n                    electron_1.app.removeListener('window-all-closed', windowAllClosedListener);\n                    electron_1.app.quit();\n                });\n            });\n        }\n        beginOnWillShutdown() {\n            if (this.pendingWillShutdownPromise) {\n                return this.pendingWillShutdownPromise; // shutdown is already running\n            }\n            this.logService.trace('Lifecycle#onWillShutdown.fire()');\n            const joiners = [];\n            this._onWillShutdown.fire({\n                join(promise) {\n                    if (promise) {\n                        joiners.push(promise);\n                    }\n                }\n            });\n            this.pendingWillShutdownPromise = Promise.all(joiners).then(() => undefined, err => this.logService.error(err));\n            return this.pendingWillShutdownPromise;\n        }\n        registerWindow(window) {\n            // track window count\n            this.windowCounter++;\n            // Window Before Closing: Main -> Renderer\n            window.win.on('close', e => {\n                // The window already acknowledged to be closed\n                const windowId = window.id;\n                if (this.windowToCloseRequest[windowId]) {\n                    delete this.windowToCloseRequest[windowId];\n                    return;\n                }\n                this.logService.trace(`Lifecycle#window.on('close') - window ID ${window.id}`);\n                // Otherwise prevent unload and handle it from window\n                e.preventDefault();\n                this.unload(window, UnloadReason.CLOSE).then(veto => {\n                    if (veto) {\n                        delete this.windowToCloseRequest[windowId];\n                        return;\n                    }\n                    this.windowToCloseRequest[windowId] = true;\n                    // Fire onBeforeWindowClose before actually closing\n                    this.logService.trace(`Lifecycle#onBeforeWindowClose.fire() - window ID ${windowId}`);\n                    this._onBeforeWindowClose.fire(window);\n                    // No veto, close window now\n                    window.close();\n                });\n            });\n            // Window After Closing\n            window.win.on('closed', () => {\n                this.logService.trace(`Lifecycle#window.on('closed') - window ID ${window.id}`);\n                // update window count\n                this.windowCounter--;\n                // if there are no more code windows opened, fire the onWillShutdown event, unless\n                // we are on macOS where it is perfectly fine to close the last window and\n                // the application continues running (unless quit was actually requested)\n                if (this.windowCounter === 0 && (!platform_1.isMacintosh || this._quitRequested)) {\n                    this.beginOnWillShutdown();\n                }\n            });\n        }\n        unload(window, reason) {\n            // Always allow to unload a window that is not yet ready\n            if (!window.isReady) {\n                return Promise.resolve(false);\n            }\n            this.logService.trace(`Lifecycle#unload() - window ID ${window.id}`);\n            // first ask the window itself if it vetos the unload\n            const windowUnloadReason = this._quitRequested ? UnloadReason.QUIT : reason;\n            return this.onBeforeUnloadWindowInRenderer(window, windowUnloadReason).then(veto => {\n                if (veto) {\n                    this.logService.trace(`Lifecycle#unload() - veto in renderer (window ID ${window.id})`);\n                    return this.handleWindowUnloadVeto(veto);\n                }\n                // then check for vetos in the main side\n                return this.onBeforeUnloadWindowInMain(window, windowUnloadReason).then(veto => {\n                    if (veto) {\n                        this.logService.trace(`Lifecycle#unload() - veto in main (window ID ${window.id})`);\n                        return this.handleWindowUnloadVeto(veto);\n                    }\n                    this.logService.trace(`Lifecycle#unload() - no veto (window ID ${window.id})`);\n                    // finally if there are no vetos, unload the renderer\n                    return this.onWillUnloadWindowInRenderer(window, windowUnloadReason).then(() => false);\n                });\n            });\n        }\n        handleWindowUnloadVeto(veto) {\n            if (!veto) {\n                return false; // no veto\n            }\n            // a veto resolves any pending quit with veto\n            this.resolvePendingQuitPromise(true /* veto */);\n            // a veto resets the pending quit request flag\n            this._quitRequested = false;\n            return true; // veto\n        }\n        resolvePendingQuitPromise(veto) {\n            if (this.pendingQuitPromiseResolve) {\n                this.pendingQuitPromiseResolve(veto);\n                this.pendingQuitPromiseResolve = null;\n                this.pendingQuitPromise = null;\n            }\n        }\n        onBeforeUnloadWindowInRenderer(window, reason) {\n            return new Promise(c => {\n                const oneTimeEventToken = this.oneTimeListenerTokenGenerator++;\n                const okChannel = `vscode:ok${oneTimeEventToken}`;\n                const cancelChannel = `vscode:cancel${oneTimeEventToken}`;\n                electron_1.ipcMain.once(okChannel, () => {\n                    c(false); // no veto\n                });\n                electron_1.ipcMain.once(cancelChannel, () => {\n                    c(true); // veto\n                });\n                window.send('vscode:onBeforeUnload', { okChannel, cancelChannel, reason });\n            });\n        }\n        onBeforeUnloadWindowInMain(window, reason) {\n            const vetos = [];\n            this._onBeforeWindowUnload.fire({\n                reason,\n                window,\n                veto(value) {\n                    vetos.push(value);\n                }\n            });\n            return lifecycle_1.handleVetos(vetos, err => this.logService.error(err));\n        }\n        onWillUnloadWindowInRenderer(window, reason) {\n            return new Promise(resolve => {\n                const oneTimeEventToken = this.oneTimeListenerTokenGenerator++;\n                const replyChannel = `vscode:reply${oneTimeEventToken}`;\n                electron_1.ipcMain.once(replyChannel, () => resolve());\n                window.send('vscode:onWillUnload', { replyChannel, reason });\n            });\n        }\n        /**\n         * A promise that completes to indicate if the quit request has been veto'd\n         * by the user or not.\n         */\n        quit(fromUpdate) {\n            if (this.pendingQuitPromise) {\n                return this.pendingQuitPromise;\n            }\n            this.logService.trace(`Lifecycle#quit() - from update: ${fromUpdate}`);\n            // Remember the reason for quit was to restart\n            if (fromUpdate) {\n                this.stateService.setItem(LifecycleService.QUIT_FROM_RESTART_MARKER, true);\n            }\n            this.pendingQuitPromise = new Promise(resolve => {\n                // Store as field to access it from a window cancellation\n                this.pendingQuitPromiseResolve = resolve;\n                // Calling app.quit() will trigger the close handlers of each opened window\n                // and only if no window vetoed the shutdown, we will get the will-quit event\n                this.logService.trace('Lifecycle#quit() - calling app.quit()');\n                electron_1.app.quit();\n            });\n            return this.pendingQuitPromise;\n        }\n        relaunch(options) {\n            this.logService.trace('Lifecycle#relaunch()');\n            const args = process.argv.slice(1);\n            if (options && options.addArgs) {\n                args.push(...options.addArgs);\n            }\n            if (options && options.removeArgs) {\n                for (const a of options.removeArgs) {\n                    const idx = args.indexOf(a);\n                    if (idx >= 0) {\n                        args.splice(idx, 1);\n                    }\n                }\n            }\n            let quitVetoed = false;\n            electron_1.app.once('quit', () => {\n                if (!quitVetoed) {\n                    // Remember the reason for quit was to restart\n                    this.stateService.setItem(LifecycleService.QUIT_FROM_RESTART_MARKER, true);\n                    // Windows: we are about to restart and as such we need to restore the original\n                    // current working directory we had on startup to get the exact same startup\n                    // behaviour. As such, we briefly change back to the VSCODE_CWD and then when\n                    // Code starts it will set it back to the installation directory again.\n                    try {\n                        if (platform_1.isWindows) {\n                            const vscodeCwd = process.env['VSCODE_CWD'];\n                            if (vscodeCwd) {\n                                process.chdir(vscodeCwd);\n                            }\n                        }\n                    }\n                    catch (err) {\n                        this.logService.error(err);\n                    }\n                    // relaunch after we are sure there is no veto\n                    this.logService.trace('Lifecycle#relaunch() - calling app.relaunch()');\n                    electron_1.app.relaunch({ args });\n                }\n            });\n            // app.relaunch() does not quit automatically, so we quit first,\n            // check for vetoes and then relaunch from the app.on('quit') event\n            this.quit().then(veto => quitVetoed = veto);\n        }\n        kill(code) {\n            this.logService.trace('Lifecycle#kill()');\n            electron_1.app.exit(code);\n        }\n    };\n    LifecycleService.QUIT_FROM_RESTART_MARKER = 'quit.from.restart'; // use a marker to find out if the session was restarted\n    LifecycleService = __decorate([\n        __param(0, log_1.ILogService),\n        __param(1, state_1.IStateService)\n    ], LifecycleService);\n    exports.LifecycleService = LifecycleService;\n});\n",null]}