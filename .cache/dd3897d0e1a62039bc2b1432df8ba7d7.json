{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/dataTree.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/dataTree.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar abstractTree_1 = require(\"vs/base/browser/ui/tree/abstractTree\");\nvar objectTreeModel_1 = require(\"vs/base/browser/ui/tree/objectTreeModel\");\nvar iterator_1 = require(\"vs/base/common/iterator\");\nvar DataTree = /** @class */ (function (_super) {\n    tslib_1.__extends(DataTree, _super);\n    function DataTree(container, delegate, renderers, dataSource, options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, container, delegate, renderers, options) || this;\n        _this.dataSource = dataSource;\n        _this.nodesByIdentity = new Map();\n        _this.identityProvider = options.identityProvider;\n        return _this;\n    }\n    // Model\n    DataTree.prototype.getInput = function () {\n        return this.input;\n    };\n    DataTree.prototype.setInput = function (input, viewState) {\n        var _this = this;\n        if (viewState && !this.identityProvider) {\n            throw new Error('Can\\'t restore tree view state without an identity provider');\n        }\n        this.input = input;\n        if (!viewState) {\n            this._refresh(input);\n            return;\n        }\n        var focus = [];\n        var selection = [];\n        var isCollapsed = function (element) {\n            var id = _this.identityProvider.getId(element).toString();\n            return viewState.expanded.indexOf(id) === -1;\n        };\n        var onDidCreateNode = function (node) {\n            var id = _this.identityProvider.getId(node.element).toString();\n            if (viewState.focus.indexOf(id) > -1) {\n                focus.push(node.element);\n            }\n            if (viewState.selection.indexOf(id) > -1) {\n                selection.push(node.element);\n            }\n        };\n        this._refresh(input, isCollapsed, onDidCreateNode);\n        this.setFocus(focus);\n        this.setSelection(selection);\n    };\n    DataTree.prototype.updateChildren = function (element) {\n        var _this = this;\n        if (element === void 0) { element = this.input; }\n        if (typeof this.input === 'undefined') {\n            throw new Error('Tree input not set');\n        }\n        var isCollapsed;\n        if (this.identityProvider) {\n            isCollapsed = function (element) {\n                var id = _this.identityProvider.getId(element).toString();\n                var node = _this.nodesByIdentity.get(id);\n                if (!node) {\n                    return undefined;\n                }\n                return node.collapsed;\n            };\n        }\n        this._refresh(element, isCollapsed);\n    };\n    DataTree.prototype.resort = function (element, recursive) {\n        if (element === void 0) { element = this.input; }\n        if (recursive === void 0) { recursive = true; }\n        this.model.resort((element === this.input ? null : element), recursive);\n    };\n    // View\n    DataTree.prototype.refresh = function (element) {\n        if (element === undefined) {\n            this.view.rerender();\n            return;\n        }\n        this.model.rerender(element);\n    };\n    // Implementation\n    DataTree.prototype._refresh = function (element, isCollapsed, onDidCreateNode) {\n        var _this = this;\n        var onDidDeleteNode;\n        if (this.identityProvider) {\n            var insertedElements_1 = new Set();\n            var outerOnDidCreateNode_1 = onDidCreateNode;\n            onDidCreateNode = function (node) {\n                var id = _this.identityProvider.getId(node.element).toString();\n                insertedElements_1.add(id);\n                _this.nodesByIdentity.set(id, node);\n                if (outerOnDidCreateNode_1) {\n                    outerOnDidCreateNode_1(node);\n                }\n            };\n            onDidDeleteNode = function (node) {\n                var id = _this.identityProvider.getId(node.element).toString();\n                if (!insertedElements_1.has(id)) {\n                    _this.nodesByIdentity.delete(id);\n                }\n            };\n        }\n        this.model.setChildren((element === this.input ? null : element), this.iterate(element, isCollapsed).elements, onDidCreateNode, onDidDeleteNode);\n    };\n    DataTree.prototype.iterate = function (element, isCollapsed) {\n        var _this = this;\n        var children = this.dataSource.getChildren(element);\n        var elements = iterator_1.Iterator.map(iterator_1.Iterator.fromArray(children), function (element) {\n            var _a = _this.iterate(element, isCollapsed), children = _a.elements, size = _a.size;\n            var collapsed = size === 0 ? undefined : (isCollapsed && isCollapsed(element));\n            return { element: element, children: children, collapsed: collapsed };\n        });\n        return { elements: elements, size: children.length };\n    };\n    DataTree.prototype.createModel = function (view, options) {\n        return new objectTreeModel_1.ObjectTreeModel(view, options);\n    };\n    // view state\n    DataTree.prototype.getViewState = function () {\n        var _this = this;\n        if (!this.identityProvider) {\n            throw new Error('Can\\'t get tree view state without an identity provider');\n        }\n        var getId = function (element) { return _this.identityProvider.getId(element).toString(); };\n        var focus = this.getFocus().map(getId);\n        var selection = this.getSelection().map(getId);\n        var expanded = [];\n        var root = this.model.getNode();\n        var queue = [root];\n        while (queue.length > 0) {\n            var node = queue.shift();\n            if (node !== root && node.collapsible && !node.collapsed) {\n                expanded.push(getId(node.element));\n            }\n            queue.push.apply(queue, node.children);\n        }\n        return { focus: focus, selection: selection, expanded: expanded };\n    };\n    return DataTree;\n}(abstractTree_1.AbstractTree));\nexports.DataTree = DataTree;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/dataTree.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/dataTree.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AbstractTree, IAbstractTreeOptions } from 'vs/base/browser/ui/tree/abstractTree';\nimport { ISpliceable } from 'vs/base/common/sequence';\nimport { ITreeNode, ITreeModel, ITreeElement, ITreeRenderer, ITreeSorter, IDataSource } from 'vs/base/browser/ui/tree/tree';\nimport { ObjectTreeModel } from 'vs/base/browser/ui/tree/objectTreeModel';\nimport { IListVirtualDelegate, IIdentityProvider } from 'vs/base/browser/ui/list/list';\nimport { Iterator } from 'vs/base/common/iterator';\n\nexport interface IDataTreeOptions<T, TFilterData = void> extends IAbstractTreeOptions<T, TFilterData> {\n\tsorter?: ITreeSorter<T>;\n}\n\nexport interface IDataTreeViewState {\n\treadonly focus: string[];\n\treadonly selection: string[];\n\treadonly expanded: string[];\n}\n\nexport class DataTree<TInput, T, TFilterData = void> extends AbstractTree<T | null, TFilterData, T | null> {\n\n\tprotected model: ObjectTreeModel<T, TFilterData>;\n\tprivate input: TInput | undefined;\n\n\tprivate identityProvider: IIdentityProvider<T> | undefined;\n\tprivate nodesByIdentity = new Map<string, ITreeNode<T, TFilterData>>();\n\n\tconstructor(\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ITreeRenderer<any /* TODO@joao */, TFilterData, any>[],\n\t\tprivate dataSource: IDataSource<TInput, T>,\n\t\toptions: IDataTreeOptions<T, TFilterData> = {}\n\t) {\n\t\tsuper(container, delegate, renderers, options);\n\t\tthis.identityProvider = options.identityProvider;\n\t}\n\n\t// Model\n\n\tgetInput(): TInput | undefined {\n\t\treturn this.input;\n\t}\n\n\tsetInput(input: TInput, viewState?: IDataTreeViewState): void {\n\t\tif (viewState && !this.identityProvider) {\n\t\t\tthrow new Error('Can\\'t restore tree view state without an identity provider');\n\t\t}\n\n\t\tthis.input = input;\n\n\t\tif (!viewState) {\n\t\t\tthis._refresh(input);\n\t\t\treturn;\n\t\t}\n\n\t\tconst focus: T[] = [];\n\t\tconst selection: T[] = [];\n\n\t\tconst isCollapsed = (element: T) => {\n\t\t\tconst id = this.identityProvider!.getId(element).toString();\n\t\t\treturn viewState.expanded.indexOf(id) === -1;\n\t\t};\n\n\t\tconst onDidCreateNode = (node: ITreeNode<T, TFilterData>) => {\n\t\t\tconst id = this.identityProvider!.getId(node.element).toString();\n\n\t\t\tif (viewState.focus.indexOf(id) > -1) {\n\t\t\t\tfocus.push(node.element);\n\t\t\t}\n\n\t\t\tif (viewState.selection.indexOf(id) > -1) {\n\t\t\t\tselection.push(node.element);\n\t\t\t}\n\t\t};\n\n\t\tthis._refresh(input, isCollapsed, onDidCreateNode);\n\t\tthis.setFocus(focus);\n\t\tthis.setSelection(selection);\n\t}\n\n\tupdateChildren(element: TInput | T = this.input!): void {\n\t\tif (typeof this.input === 'undefined') {\n\t\t\tthrow new Error('Tree input not set');\n\t\t}\n\n\t\tlet isCollapsed: ((el: T) => boolean | undefined) | undefined;\n\n\t\tif (this.identityProvider) {\n\t\t\tisCollapsed = element => {\n\t\t\t\tconst id = this.identityProvider!.getId(element).toString();\n\t\t\t\tconst node = this.nodesByIdentity.get(id);\n\n\t\t\t\tif (!node) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\treturn node.collapsed;\n\t\t\t};\n\t\t}\n\n\t\tthis._refresh(element, isCollapsed);\n\t}\n\n\tresort(element: T | TInput = this.input!, recursive = true): void {\n\t\tthis.model.resort((element === this.input ? null : element) as T, recursive);\n\t}\n\n\t// View\n\n\trefresh(element?: T): void {\n\t\tif (element === undefined) {\n\t\t\tthis.view.rerender();\n\t\t\treturn;\n\t\t}\n\n\t\tthis.model.rerender(element);\n\t}\n\n\t// Implementation\n\n\tprivate _refresh(element: TInput | T, isCollapsed?: (el: T) => boolean | undefined, onDidCreateNode?: (node: ITreeNode<T, TFilterData>) => void): void {\n\t\tlet onDidDeleteNode: ((node: ITreeNode<T, TFilterData>) => void) | undefined;\n\n\t\tif (this.identityProvider) {\n\t\t\tconst insertedElements = new Set<string>();\n\n\t\t\tconst outerOnDidCreateNode = onDidCreateNode;\n\t\t\tonDidCreateNode = (node: ITreeNode<T, TFilterData>) => {\n\t\t\t\tconst id = this.identityProvider!.getId(node.element).toString();\n\n\t\t\t\tinsertedElements.add(id);\n\t\t\t\tthis.nodesByIdentity.set(id, node);\n\n\t\t\t\tif (outerOnDidCreateNode) {\n\t\t\t\t\touterOnDidCreateNode(node);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tonDidDeleteNode = (node: ITreeNode<T, TFilterData>) => {\n\t\t\t\tconst id = this.identityProvider!.getId(node.element).toString();\n\n\t\t\t\tif (!insertedElements.has(id)) {\n\t\t\t\t\tthis.nodesByIdentity.delete(id);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tthis.model.setChildren((element === this.input ? null : element) as T, this.iterate(element, isCollapsed).elements, onDidCreateNode, onDidDeleteNode);\n\t}\n\n\tprivate iterate(element: TInput | T, isCollapsed?: (el: T) => boolean | undefined): { elements: Iterator<ITreeElement<T>>, size: number } {\n\t\tconst children = this.dataSource.getChildren(element);\n\t\tconst elements = Iterator.map<any, ITreeElement<T>>(Iterator.fromArray(children), element => {\n\t\t\tconst { elements: children, size } = this.iterate(element, isCollapsed);\n\t\t\tconst collapsed = size === 0 ? undefined : (isCollapsed && isCollapsed(element));\n\n\t\t\treturn { element, children, collapsed };\n\t\t});\n\n\t\treturn { elements, size: children.length };\n\t}\n\n\tprotected createModel(view: ISpliceable<ITreeNode<T, TFilterData>>, options: IDataTreeOptions<T, TFilterData>): ITreeModel<T | null, TFilterData, T | null> {\n\t\treturn new ObjectTreeModel(view, options);\n\t}\n\n\t// view state\n\n\tgetViewState(): IDataTreeViewState {\n\t\tif (!this.identityProvider) {\n\t\t\tthrow new Error('Can\\'t get tree view state without an identity provider');\n\t\t}\n\n\t\tconst getId = (element: T) => this.identityProvider!.getId(element).toString();\n\t\tconst focus = this.getFocus().map(getId);\n\t\tconst selection = this.getSelection().map(getId);\n\n\t\tconst expanded: string[] = [];\n\t\tconst root = this.model.getNode();\n\t\tconst queue = [root];\n\n\t\twhile (queue.length > 0) {\n\t\t\tconst node = queue.shift()!;\n\n\t\t\tif (node !== root && node.collapsible && !node.collapsed) {\n\t\t\t\texpanded.push(getId(node.element!));\n\t\t\t}\n\n\t\t\tqueue.push(...node.children);\n\t\t}\n\n\t\treturn { focus, selection, expanded };\n\t}\n}\n"]}]}