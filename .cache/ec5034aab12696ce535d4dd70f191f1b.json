{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/async.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/async.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/cancellation\", \"vs/base/common/errors\", \"vs/base/common/event\", \"vs/base/common/lifecycle\"], function (require, exports, cancellation_1, errors, event_1, lifecycle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isThenable(obj) {\n        return obj && typeof obj.then === 'function';\n    }\n    exports.isThenable = isThenable;\n    function createCancelablePromise(callback) {\n        const source = new cancellation_1.CancellationTokenSource();\n        const thenable = callback(source.token);\n        const promise = new Promise((resolve, reject) => {\n            source.token.onCancellationRequested(() => {\n                reject(errors.canceled());\n            });\n            Promise.resolve(thenable).then(value => {\n                source.dispose();\n                resolve(value);\n            }, err => {\n                source.dispose();\n                reject(err);\n            });\n        });\n        return new class {\n            cancel() {\n                source.cancel();\n            }\n            then(resolve, reject) {\n                return promise.then(resolve, reject);\n            }\n            catch(reject) {\n                return this.then(undefined, reject);\n            }\n            finally(onfinally) {\n                return promise.finally(onfinally);\n            }\n        };\n    }\n    exports.createCancelablePromise = createCancelablePromise;\n    function asPromise(callback) {\n        return new Promise((resolve, reject) => {\n            const item = callback();\n            if (isThenable(item)) {\n                item.then(resolve, reject);\n            }\n            else {\n                resolve(item);\n            }\n        });\n    }\n    exports.asPromise = asPromise;\n    /**\n     * A helper to prevent accumulation of sequential async tasks.\n     *\n     * Imagine a mail man with the sole task of delivering letters. As soon as\n     * a letter submitted for delivery, he drives to the destination, delivers it\n     * and returns to his base. Imagine that during the trip, N more letters were submitted.\n     * When the mail man returns, he picks those N letters and delivers them all in a\n     * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n     *\n     * The throttler implements this via the queue() method, by providing it a task\n     * factory. Following the example:\n     *\n     * \t\tconst throttler = new Throttler();\n     * \t\tconst letters = [];\n     *\n     * \t\tfunction deliver() {\n     * \t\t\tconst lettersToDeliver = letters;\n     * \t\t\tletters = [];\n     * \t\t\treturn makeTheTrip(lettersToDeliver);\n     * \t\t}\n     *\n     * \t\tfunction onLetterReceived(l) {\n     * \t\t\tletters.push(l);\n     * \t\t\tthrottler.queue(deliver);\n     * \t\t}\n     */\n    class Throttler {\n        constructor() {\n            this.activePromise = null;\n            this.queuedPromise = null;\n            this.queuedPromiseFactory = null;\n        }\n        queue(promiseFactory) {\n            if (this.activePromise) {\n                this.queuedPromiseFactory = promiseFactory;\n                if (!this.queuedPromise) {\n                    const onComplete = () => {\n                        this.queuedPromise = null;\n                        const result = this.queue(this.queuedPromiseFactory);\n                        this.queuedPromiseFactory = null;\n                        return result;\n                    };\n                    this.queuedPromise = new Promise(c => {\n                        this.activePromise.then(onComplete, onComplete).then(c);\n                    });\n                }\n                return new Promise((c, e) => {\n                    this.queuedPromise.then(c, e);\n                });\n            }\n            this.activePromise = promiseFactory();\n            return new Promise((c, e) => {\n                this.activePromise.then((result) => {\n                    this.activePromise = null;\n                    c(result);\n                }, (err) => {\n                    this.activePromise = null;\n                    e(err);\n                });\n            });\n        }\n    }\n    exports.Throttler = Throttler;\n    class Sequencer {\n        constructor() {\n            this.current = Promise.resolve(null);\n        }\n        queue(promiseTask) {\n            return this.current = this.current.then(() => promiseTask());\n        }\n    }\n    exports.Sequencer = Sequencer;\n    /**\n     * A helper to delay execution of a task that is being requested often.\n     *\n     * Following the throttler, now imagine the mail man wants to optimize the number of\n     * trips proactively. The trip itself can be long, so he decides not to make the trip\n     * as soon as a letter is submitted. Instead he waits a while, in case more\n     * letters are submitted. After said waiting period, if no letters were submitted, he\n     * decides to make the trip. Imagine that N more letters were submitted after the first\n     * one, all within a short period of time between each other. Even though N+1\n     * submissions occurred, only 1 delivery was made.\n     *\n     * The delayer offers this behavior via the trigger() method, into which both the task\n     * to be executed and the waiting period (delay) must be passed in as arguments. Following\n     * the example:\n     *\n     * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n     * \t\tconst letters = [];\n     *\n     * \t\tfunction letterReceived(l) {\n     * \t\t\tletters.push(l);\n     * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n     * \t\t}\n     */\n    class Delayer {\n        constructor(defaultDelay) {\n            this.defaultDelay = defaultDelay;\n            this.timeout = null;\n            this.completionPromise = null;\n            this.doResolve = null;\n            this.task = null;\n        }\n        trigger(task, delay = this.defaultDelay) {\n            this.task = task;\n            this.cancelTimeout();\n            if (!this.completionPromise) {\n                this.completionPromise = new Promise((c, e) => {\n                    this.doResolve = c;\n                    this.doReject = e;\n                }).then(() => {\n                    this.completionPromise = null;\n                    this.doResolve = null;\n                    const task = this.task;\n                    this.task = null;\n                    return task();\n                });\n            }\n            this.timeout = setTimeout(() => {\n                this.timeout = null;\n                this.doResolve(null);\n            }, delay);\n            return this.completionPromise;\n        }\n        isTriggered() {\n            return this.timeout !== null;\n        }\n        cancel() {\n            this.cancelTimeout();\n            if (this.completionPromise) {\n                this.doReject(errors.canceled());\n                this.completionPromise = null;\n            }\n        }\n        cancelTimeout() {\n            if (this.timeout !== null) {\n                clearTimeout(this.timeout);\n                this.timeout = null;\n            }\n        }\n        dispose() {\n            this.cancelTimeout();\n        }\n    }\n    exports.Delayer = Delayer;\n    /**\n     * A helper to delay execution of a task that is being requested often, while\n     * preventing accumulation of consecutive executions, while the task runs.\n     *\n     * The mail man is clever and waits for a certain amount of time, before going\n     * out to deliver letters. While the mail man is going out, more letters arrive\n     * and can only be delivered once he is back. Once he is back the mail man will\n     * do one more trip to deliver the letters that have accumulated while he was out.\n     */\n    class ThrottledDelayer {\n        constructor(defaultDelay) {\n            this.delayer = new Delayer(defaultDelay);\n            this.throttler = new Throttler();\n        }\n        trigger(promiseFactory, delay) {\n            return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);\n        }\n        isTriggered() {\n            return this.delayer.isTriggered();\n        }\n        cancel() {\n            this.delayer.cancel();\n        }\n        dispose() {\n            this.delayer.dispose();\n        }\n    }\n    exports.ThrottledDelayer = ThrottledDelayer;\n    /**\n     * A barrier that is initially closed and then becomes opened permanently.\n     */\n    class Barrier {\n        constructor() {\n            this._isOpen = false;\n            this._promise = new Promise((c, e) => {\n                this._completePromise = c;\n            });\n        }\n        isOpen() {\n            return this._isOpen;\n        }\n        open() {\n            this._isOpen = true;\n            this._completePromise(true);\n        }\n        wait() {\n            return this._promise;\n        }\n    }\n    exports.Barrier = Barrier;\n    function timeout(millis, token) {\n        if (!token) {\n            return createCancelablePromise(token => timeout(millis, token));\n        }\n        return new Promise((resolve, reject) => {\n            const handle = setTimeout(resolve, millis);\n            token.onCancellationRequested(() => {\n                clearTimeout(handle);\n                reject(errors.canceled());\n            });\n        });\n    }\n    exports.timeout = timeout;\n    function disposableTimeout(handler, timeout = 0) {\n        const timer = setTimeout(handler, timeout);\n        return lifecycle_1.toDisposable(() => clearTimeout(timer));\n    }\n    exports.disposableTimeout = disposableTimeout;\n    function ignoreErrors(promise) {\n        return promise.then(undefined, _ => undefined);\n    }\n    exports.ignoreErrors = ignoreErrors;\n    /**\n     * Runs the provided list of promise factories in sequential order. The returned\n     * promise will complete to an array of results from each promise.\n     */\n    function sequence(promiseFactories) {\n        const results = [];\n        let index = 0;\n        const len = promiseFactories.length;\n        function next() {\n            return index < len ? promiseFactories[index++]() : null;\n        }\n        function thenHandler(result) {\n            if (result !== undefined && result !== null) {\n                results.push(result);\n            }\n            const n = next();\n            if (n) {\n                return n.then(thenHandler);\n            }\n            return Promise.resolve(results);\n        }\n        return Promise.resolve(null).then(thenHandler);\n    }\n    exports.sequence = sequence;\n    function first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {\n        let index = 0;\n        const len = promiseFactories.length;\n        const loop = () => {\n            if (index >= len) {\n                return Promise.resolve(defaultValue);\n            }\n            const factory = promiseFactories[index++];\n            const promise = Promise.resolve(factory());\n            return promise.then(result => {\n                if (shouldStop(result)) {\n                    return Promise.resolve(result);\n                }\n                return loop();\n            });\n        };\n        return loop();\n    }\n    exports.first = first;\n    /**\n     * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n     * ensures that at any time no more than M promises are running at the same time.\n     */\n    class Limiter {\n        constructor(maxDegreeOfParalellism) {\n            this._size = 0;\n            this.maxDegreeOfParalellism = maxDegreeOfParalellism;\n            this.outstandingPromises = [];\n            this.runningPromises = 0;\n            this._onFinished = new event_1.Emitter();\n        }\n        get onFinished() {\n            return this._onFinished.event;\n        }\n        get size() {\n            return this._size;\n            // return this.runningPromises + this.outstandingPromises.length;\n        }\n        queue(factory) {\n            this._size++;\n            return new Promise((c, e) => {\n                this.outstandingPromises.push({ factory, c, e });\n                this.consume();\n            });\n        }\n        consume() {\n            while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n                const iLimitedTask = this.outstandingPromises.shift();\n                this.runningPromises++;\n                const promise = iLimitedTask.factory();\n                promise.then(iLimitedTask.c, iLimitedTask.e);\n                promise.then(() => this.consumed(), () => this.consumed());\n            }\n        }\n        consumed() {\n            this._size--;\n            this.runningPromises--;\n            if (this.outstandingPromises.length > 0) {\n                this.consume();\n            }\n            else {\n                this._onFinished.fire();\n            }\n        }\n        dispose() {\n            this._onFinished.dispose();\n        }\n    }\n    exports.Limiter = Limiter;\n    /**\n     * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n     */\n    class Queue extends Limiter {\n        constructor() {\n            super(1);\n        }\n    }\n    exports.Queue = Queue;\n    /**\n     * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n     * by disposing them once the queue is empty.\n     */\n    class ResourceQueue {\n        constructor() {\n            this.queues = Object.create(null);\n        }\n        queueFor(resource) {\n            const key = resource.toString();\n            if (!this.queues[key]) {\n                const queue = new Queue();\n                queue.onFinished(() => {\n                    queue.dispose();\n                    delete this.queues[key];\n                });\n                this.queues[key] = queue;\n            }\n            return this.queues[key];\n        }\n    }\n    exports.ResourceQueue = ResourceQueue;\n    class TimeoutTimer extends lifecycle_1.Disposable {\n        constructor(runner, timeout) {\n            super();\n            this._token = -1;\n            if (typeof runner === 'function' && typeof timeout === 'number') {\n                this.setIfNotSet(runner, timeout);\n            }\n        }\n        dispose() {\n            this.cancel();\n            super.dispose();\n        }\n        cancel() {\n            if (this._token !== -1) {\n                clearTimeout(this._token);\n                this._token = -1;\n            }\n        }\n        cancelAndSet(runner, timeout) {\n            this.cancel();\n            this._token = setTimeout(() => {\n                this._token = -1;\n                runner();\n            }, timeout);\n        }\n        setIfNotSet(runner, timeout) {\n            if (this._token !== -1) {\n                // timer is already set\n                return;\n            }\n            this._token = setTimeout(() => {\n                this._token = -1;\n                runner();\n            }, timeout);\n        }\n    }\n    exports.TimeoutTimer = TimeoutTimer;\n    class IntervalTimer extends lifecycle_1.Disposable {\n        constructor() {\n            super();\n            this._token = -1;\n        }\n        dispose() {\n            this.cancel();\n            super.dispose();\n        }\n        cancel() {\n            if (this._token !== -1) {\n                clearInterval(this._token);\n                this._token = -1;\n            }\n        }\n        cancelAndSet(runner, interval) {\n            this.cancel();\n            this._token = setInterval(() => {\n                runner();\n            }, interval);\n        }\n    }\n    exports.IntervalTimer = IntervalTimer;\n    class RunOnceScheduler {\n        constructor(runner, timeout) {\n            this.timeoutToken = -1;\n            this.runner = runner;\n            this.timeout = timeout;\n            this.timeoutHandler = this.onTimeout.bind(this);\n        }\n        /**\n         * Dispose RunOnceScheduler\n         */\n        dispose() {\n            this.cancel();\n            this.runner = null;\n        }\n        /**\n         * Cancel current scheduled runner (if any).\n         */\n        cancel() {\n            if (this.isScheduled()) {\n                clearTimeout(this.timeoutToken);\n                this.timeoutToken = -1;\n            }\n        }\n        /**\n         * Cancel previous runner (if any) & schedule a new runner.\n         */\n        schedule(delay = this.timeout) {\n            this.cancel();\n            this.timeoutToken = setTimeout(this.timeoutHandler, delay);\n        }\n        /**\n         * Returns true if scheduled.\n         */\n        isScheduled() {\n            return this.timeoutToken !== -1;\n        }\n        onTimeout() {\n            this.timeoutToken = -1;\n            if (this.runner) {\n                this.doRun();\n            }\n        }\n        doRun() {\n            if (this.runner) {\n                this.runner();\n            }\n        }\n    }\n    exports.RunOnceScheduler = RunOnceScheduler;\n    class RunOnceWorker extends RunOnceScheduler {\n        constructor(runner, timeout) {\n            super(runner, timeout);\n            this.units = [];\n        }\n        work(unit) {\n            this.units.push(unit);\n            if (!this.isScheduled()) {\n                this.schedule();\n            }\n        }\n        doRun() {\n            const units = this.units;\n            this.units = [];\n            if (this.runner) {\n                this.runner(units);\n            }\n        }\n        dispose() {\n            this.units = [];\n            super.dispose();\n        }\n    }\n    exports.RunOnceWorker = RunOnceWorker;\n    function nfcall(fn, ...args) {\n        return new Promise((c, e) => fn(...args, (err, result) => err ? e(err) : c(result)));\n    }\n    exports.nfcall = nfcall;\n    function ninvoke(thisArg, fn, ...args) {\n        return new Promise((resolve, reject) => fn.call(thisArg, ...args, (err, result) => err ? reject(err) : resolve(result)));\n    }\n    exports.ninvoke = ninvoke;\n    (function () {\n        if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n            const dummyIdle = Object.freeze({\n                didTimeout: true,\n                timeRemaining() { return 15; }\n            });\n            exports.runWhenIdle = (runner) => {\n                const handle = setTimeout(() => runner(dummyIdle));\n                let disposed = false;\n                return {\n                    dispose() {\n                        if (disposed) {\n                            return;\n                        }\n                        disposed = true;\n                        clearTimeout(handle);\n                    }\n                };\n            };\n        }\n        else {\n            exports.runWhenIdle = (runner, timeout) => {\n                const handle = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n                let disposed = false;\n                return {\n                    dispose() {\n                        if (disposed) {\n                            return;\n                        }\n                        disposed = true;\n                        cancelIdleCallback(handle);\n                    }\n                };\n            };\n        }\n    })();\n    /**\n     * An implementation of the \"idle-until-urgent\"-strategy as introduced\n     * here: https://philipwalton.com/articles/idle-until-urgent/\n     */\n    class IdleValue {\n        constructor(executor) {\n            this._didRun = false;\n            this._executor = () => {\n                try {\n                    this._value = executor();\n                }\n                catch (err) {\n                    this._error = err;\n                }\n                finally {\n                    this._didRun = true;\n                }\n            };\n            this._handle = exports.runWhenIdle(() => this._executor());\n        }\n        dispose() {\n            this._handle.dispose();\n        }\n        getValue() {\n            if (!this._didRun) {\n                this._handle.dispose();\n                this._executor();\n            }\n            if (this._error) {\n                throw this._error;\n            }\n            return this._value;\n        }\n    }\n    exports.IdleValue = IdleValue;\n    //#endregion\n    function retry(task, delay, retries) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let lastError;\n            for (let i = 0; i < retries; i++) {\n                try {\n                    return yield task();\n                }\n                catch (error) {\n                    lastError = error;\n                    yield timeout(delay);\n                }\n            }\n            return Promise.reject(lastError);\n        });\n    }\n    exports.retry = retry;\n});\n",null]}