{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/files/common/editors/fileEditorInput.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/files/common/editors/fileEditorInput.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/decorators\", \"vs/base/common/path\", \"vs/base/common/resources\", \"vs/workbench/common/editor\", \"vs/workbench/common/editor/binaryEditorModel\", \"vs/platform/files/common/files\", \"vs/workbench/services/textfile/common/textfiles\", \"vs/platform/instantiation/common/instantiation\", \"vs/editor/common/services/resolverService\", \"vs/workbench/contrib/files/common/files\", \"vs/platform/label/common/label\"], function (require, exports, nls_1, decorators_1, path_1, resources_1, editor_1, binaryEditorModel_1, files_1, textfiles_1, instantiation_1, resolverService_1, files_2, label_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * A file editor input is the input type for the file editor of file system resources.\n     */\n    let FileEditorInput = class FileEditorInput extends editor_1.EditorInput {\n        /**\n         * An editor input who's contents are retrieved from file services.\n         */\n        constructor(resource, preferredEncoding, instantiationService, textFileService, textModelResolverService, labelService) {\n            super();\n            this.resource = resource;\n            this.instantiationService = instantiationService;\n            this.textFileService = textFileService;\n            this.textModelResolverService = textModelResolverService;\n            this.labelService = labelService;\n            if (preferredEncoding) {\n                this.setPreferredEncoding(preferredEncoding);\n            }\n            this.registerListeners();\n        }\n        registerListeners() {\n            // Model changes\n            this._register(this.textFileService.models.onModelDirty(e => this.onDirtyStateChange(e)));\n            this._register(this.textFileService.models.onModelSaveError(e => this.onDirtyStateChange(e)));\n            this._register(this.textFileService.models.onModelSaved(e => this.onDirtyStateChange(e)));\n            this._register(this.textFileService.models.onModelReverted(e => this.onDirtyStateChange(e)));\n            this._register(this.textFileService.models.onModelOrphanedChanged(e => this.onModelOrphanedChanged(e)));\n        }\n        onDirtyStateChange(e) {\n            if (e.resource.toString() === this.resource.toString()) {\n                this._onDidChangeDirty.fire();\n            }\n        }\n        onModelOrphanedChanged(e) {\n            if (e.resource.toString() === this.resource.toString()) {\n                this._onDidChangeLabel.fire();\n            }\n        }\n        getResource() {\n            return this.resource;\n        }\n        getEncoding() {\n            const textModel = this.textFileService.models.get(this.resource);\n            if (textModel) {\n                return textModel.getEncoding();\n            }\n            return this.preferredEncoding;\n        }\n        getPreferredEncoding() {\n            return this.preferredEncoding;\n        }\n        setEncoding(encoding, mode) {\n            this.preferredEncoding = encoding;\n            const textModel = this.textFileService.models.get(this.resource);\n            if (textModel) {\n                textModel.setEncoding(encoding, mode);\n            }\n        }\n        setPreferredEncoding(encoding) {\n            this.preferredEncoding = encoding;\n            this.forceOpenAsText = true; // encoding is a good hint to open the file as text\n        }\n        setForceOpenAsText() {\n            this.forceOpenAsText = true;\n            this.forceOpenAsBinary = false;\n        }\n        setForceOpenAsBinary() {\n            this.forceOpenAsBinary = true;\n            this.forceOpenAsText = false;\n        }\n        getTypeId() {\n            return files_2.FILE_EDITOR_INPUT_ID;\n        }\n        getName() {\n            if (!this.name) {\n                this.name = resources_1.basenameOrAuthority(this.resource);\n            }\n            return this.decorateLabel(this.name);\n        }\n        get shortDescription() {\n            return path_1.basename(this.labelService.getUriLabel(resources_1.dirname(this.resource)));\n        }\n        get mediumDescription() {\n            return this.labelService.getUriLabel(resources_1.dirname(this.resource), { relative: true });\n        }\n        get longDescription() {\n            return this.labelService.getUriLabel(resources_1.dirname(this.resource));\n        }\n        getDescription(verbosity = editor_1.Verbosity.MEDIUM) {\n            let description;\n            switch (verbosity) {\n                case editor_1.Verbosity.SHORT:\n                    description = this.shortDescription;\n                    break;\n                case editor_1.Verbosity.LONG:\n                    description = this.longDescription;\n                    break;\n                case editor_1.Verbosity.MEDIUM:\n                default:\n                    description = this.mediumDescription;\n                    break;\n            }\n            return description;\n        }\n        get shortTitle() {\n            return this.getName();\n        }\n        get mediumTitle() {\n            return this.labelService.getUriLabel(this.resource, { relative: true });\n        }\n        get longTitle() {\n            return this.labelService.getUriLabel(this.resource);\n        }\n        getTitle(verbosity) {\n            let title;\n            switch (verbosity) {\n                case editor_1.Verbosity.SHORT:\n                    title = this.shortTitle;\n                    break;\n                default:\n                case editor_1.Verbosity.MEDIUM:\n                    title = this.mediumTitle;\n                    break;\n                case editor_1.Verbosity.LONG:\n                    title = this.longTitle;\n                    break;\n            }\n            return this.decorateLabel(title);\n        }\n        decorateLabel(label) {\n            const model = this.textFileService.models.get(this.resource);\n            if (model && model.hasState(textfiles_1.ModelState.ORPHAN)) {\n                return nls_1.localize('orphanedFile', \"{0} (deleted from disk)\", label);\n            }\n            if (model && model.isReadonly()) {\n                return nls_1.localize('readonlyFile', \"{0} (read-only)\", label);\n            }\n            return label;\n        }\n        isDirty() {\n            const model = this.textFileService.models.get(this.resource);\n            if (!model) {\n                return false;\n            }\n            if (model.hasState(textfiles_1.ModelState.CONFLICT) || model.hasState(textfiles_1.ModelState.ERROR)) {\n                return true; // always indicate dirty state if we are in conflict or error state\n            }\n            if (this.textFileService.getAutoSaveMode() === textfiles_1.AutoSaveMode.AFTER_SHORT_DELAY) {\n                return false; // fast auto save enabled so we do not declare dirty\n            }\n            return model.isDirty();\n        }\n        confirmSave() {\n            return this.textFileService.confirmSave([this.resource]);\n        }\n        save() {\n            return this.textFileService.save(this.resource);\n        }\n        revert(options) {\n            return this.textFileService.revert(this.resource, options);\n        }\n        getPreferredEditorId(candidates) {\n            return this.forceOpenAsBinary ? files_2.BINARY_FILE_EDITOR_ID : files_2.TEXT_FILE_EDITOR_ID;\n        }\n        resolve() {\n            // Resolve as binary\n            if (this.forceOpenAsBinary) {\n                return this.doResolveAsBinary();\n            }\n            // Resolve as text\n            return this.doResolveAsText();\n        }\n        doResolveAsText() {\n            // Resolve as text\n            return this.textFileService.models.loadOrCreate(this.resource, {\n                encoding: this.preferredEncoding,\n                reload: { async: true },\n                allowBinary: this.forceOpenAsText,\n                reason: textfiles_1.LoadReason.EDITOR\n            }).then(model => {\n                // This is a bit ugly, because we first resolve the model and then resolve a model reference. the reason being that binary\n                // or very large files do not resolve to a text file model but should be opened as binary files without text. First calling into\n                // loadOrCreate ensures we are not creating model references for these kind of resources.\n                // In addition we have a bit of payload to take into account (encoding, reload) that the text resolver does not handle yet.\n                if (!this.textModelReference) {\n                    this.textModelReference = this.textModelResolverService.createModelReference(this.resource);\n                }\n                return this.textModelReference.then(ref => ref.object);\n            }, error => {\n                // In case of an error that indicates that the file is binary or too large, just return with the binary editor model\n                if (error.fileOperationResult === files_1.FileOperationResult.FILE_IS_BINARY || error.fileOperationResult === files_1.FileOperationResult.FILE_TOO_LARGE) {\n                    return this.doResolveAsBinary();\n                }\n                // Bubble any other error up\n                return Promise.reject(error);\n            });\n        }\n        doResolveAsBinary() {\n            return this.instantiationService.createInstance(binaryEditorModel_1.BinaryEditorModel, this.resource, this.getName()).load().then(m => m);\n        }\n        isResolved() {\n            return !!this.textFileService.models.get(this.resource);\n        }\n        dispose() {\n            // Model reference\n            if (this.textModelReference) {\n                this.textModelReference.then(ref => ref.dispose());\n                this.textModelReference = null;\n            }\n            super.dispose();\n        }\n        matches(otherInput) {\n            if (super.matches(otherInput) === true) {\n                return true;\n            }\n            if (otherInput) {\n                return otherInput instanceof FileEditorInput && otherInput.resource.toString() === this.resource.toString();\n            }\n            return false;\n        }\n    };\n    __decorate([\n        decorators_1.memoize\n    ], FileEditorInput.prototype, \"shortDescription\", null);\n    __decorate([\n        decorators_1.memoize\n    ], FileEditorInput.prototype, \"mediumDescription\", null);\n    __decorate([\n        decorators_1.memoize\n    ], FileEditorInput.prototype, \"longDescription\", null);\n    __decorate([\n        decorators_1.memoize\n    ], FileEditorInput.prototype, \"shortTitle\", null);\n    __decorate([\n        decorators_1.memoize\n    ], FileEditorInput.prototype, \"mediumTitle\", null);\n    __decorate([\n        decorators_1.memoize\n    ], FileEditorInput.prototype, \"longTitle\", null);\n    FileEditorInput = __decorate([\n        __param(2, instantiation_1.IInstantiationService),\n        __param(3, textfiles_1.ITextFileService),\n        __param(4, resolverService_1.ITextModelService),\n        __param(5, label_1.ILabelService)\n    ], FileEditorInput);\n    exports.FileEditorInput = FileEditorInput;\n});\n",null]}