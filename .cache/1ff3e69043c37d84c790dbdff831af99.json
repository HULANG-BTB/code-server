{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/node/pfs.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/pfs.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/node/extfs\", \"vs/base/common/path\", \"vs/base/common/async\", \"fs\", \"os\", \"vs/base/common/platform\", \"vs/base/common/event\"], function (require, exports, extfs, path_1, async_1, fs, os, platform, event_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function readdir(path) {\n        return async_1.nfcall(extfs.readdir, path);\n    }\n    exports.readdir = readdir;\n    function exists(path) {\n        return new Promise(c => fs.exists(path, c));\n    }\n    exports.exists = exists;\n    function chmod(path, mode) {\n        return async_1.nfcall(fs.chmod, path, mode);\n    }\n    exports.chmod = chmod;\n    exports.mkdirp = extfs.mkdirp;\n    function rimraf(path) {\n        return lstat(path).then(stat => {\n            if (stat.isDirectory() && !stat.isSymbolicLink()) {\n                return readdir(path)\n                    .then(children => Promise.all(children.map(child => rimraf(path_1.join(path, child)))))\n                    .then(() => rmdir(path));\n            }\n            else {\n                return unlink(path);\n            }\n        }, (err) => {\n            if (err.code === 'ENOENT') {\n                return undefined;\n            }\n            return Promise.reject(err);\n        });\n    }\n    exports.rimraf = rimraf;\n    function realpath(path) {\n        return async_1.nfcall(extfs.realpath, path);\n    }\n    exports.realpath = realpath;\n    function stat(path) {\n        return async_1.nfcall(fs.stat, path);\n    }\n    exports.stat = stat;\n    function statLink(path) {\n        return async_1.nfcall(extfs.statLink, path);\n    }\n    exports.statLink = statLink;\n    function lstat(path) {\n        return async_1.nfcall(fs.lstat, path);\n    }\n    exports.lstat = lstat;\n    function move(oldPath, newPath) {\n        return async_1.nfcall(extfs.mv, oldPath, newPath);\n    }\n    exports.move = move;\n    function rename(oldPath, newPath) {\n        return async_1.nfcall(fs.rename, oldPath, newPath);\n    }\n    exports.rename = rename;\n    function renameIgnoreError(oldPath, newPath) {\n        return new Promise(resolve => {\n            fs.rename(oldPath, newPath, () => resolve());\n        });\n    }\n    exports.renameIgnoreError = renameIgnoreError;\n    function rmdir(path) {\n        return async_1.nfcall(fs.rmdir, path);\n    }\n    exports.rmdir = rmdir;\n    function unlink(path) {\n        return async_1.nfcall(fs.unlink, path);\n    }\n    exports.unlink = unlink;\n    function symlink(target, path, type) {\n        return async_1.nfcall(fs.symlink, target, path, type);\n    }\n    exports.symlink = symlink;\n    function readlink(path) {\n        return async_1.nfcall(fs.readlink, path);\n    }\n    exports.readlink = readlink;\n    function truncate(path, len) {\n        return async_1.nfcall(fs.truncate, path, len);\n    }\n    exports.truncate = truncate;\n    function readFile(path, encoding) {\n        return async_1.nfcall(fs.readFile, path, encoding);\n    }\n    exports.readFile = readFile;\n    // According to node.js docs (https://nodejs.org/docs/v6.5.0/api/fs.html#fs_fs_writefile_file_data_options_callback)\n    // it is not safe to call writeFile() on the same path multiple times without waiting for the callback to return.\n    // Therefor we use a Queue on the path that is given to us to sequentialize calls to the same path properly.\n    const writeFilePathQueue = Object.create(null);\n    function writeFile(path, data, options) {\n        const queueKey = toQueueKey(path);\n        return ensureWriteFileQueue(queueKey).queue(() => async_1.nfcall(extfs.writeFileAndFlush, path, data, options));\n    }\n    exports.writeFile = writeFile;\n    function toQueueKey(path) {\n        let queueKey = path;\n        if (platform.isWindows || platform.isMacintosh) {\n            queueKey = queueKey.toLowerCase(); // accomodate for case insensitive file systems\n        }\n        return queueKey;\n    }\n    function ensureWriteFileQueue(queueKey) {\n        let writeFileQueue = writeFilePathQueue[queueKey];\n        if (!writeFileQueue) {\n            writeFileQueue = new async_1.Queue();\n            writeFilePathQueue[queueKey] = writeFileQueue;\n            const onFinish = event_1.Event.once(writeFileQueue.onFinished);\n            onFinish(() => {\n                delete writeFilePathQueue[queueKey];\n                writeFileQueue.dispose();\n            });\n        }\n        return writeFileQueue;\n    }\n    /**\n    * Read a dir and return only subfolders\n    */\n    function readDirsInDir(dirPath) {\n        return readdir(dirPath).then(children => {\n            return Promise.all(children.map(c => dirExists(path_1.join(dirPath, c)))).then(exists => {\n                return children.filter((_, i) => exists[i]);\n            });\n        });\n    }\n    exports.readDirsInDir = readDirsInDir;\n    /**\n    * `path` exists and is a directory\n    */\n    function dirExists(path) {\n        return stat(path).then(stat => stat.isDirectory(), () => false);\n    }\n    exports.dirExists = dirExists;\n    /**\n    * `path` exists and is a file.\n    */\n    function fileExists(path) {\n        return stat(path).then(stat => stat.isFile(), () => false);\n    }\n    exports.fileExists = fileExists;\n    /**\n     * Deletes a path from disk.\n     */\n    let _tmpDir = null;\n    function getTmpDir() {\n        if (!_tmpDir) {\n            _tmpDir = os.tmpdir();\n        }\n        return _tmpDir;\n    }\n    function del(path, tmp = getTmpDir()) {\n        return async_1.nfcall(extfs.del, path, tmp);\n    }\n    exports.del = del;\n    function whenDeleted(path) {\n        // Complete when wait marker file is deleted\n        return new Promise(resolve => {\n            let running = false;\n            const interval = setInterval(() => {\n                if (!running) {\n                    running = true;\n                    fs.exists(path, exists => {\n                        running = false;\n                        if (!exists) {\n                            clearInterval(interval);\n                            resolve(undefined);\n                        }\n                    });\n                }\n            }, 1000);\n        });\n    }\n    exports.whenDeleted = whenDeleted;\n    function copy(source, target) {\n        return async_1.nfcall(extfs.copy, source, target);\n    }\n    exports.copy = copy;\n});\n",null]}