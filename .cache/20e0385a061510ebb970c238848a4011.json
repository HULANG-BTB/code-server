{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursorMoveCommands.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursorMoveCommands.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/types\", \"vs/editor/common/controller/cursorCommon\", \"vs/editor/common/controller/cursorMoveOperations\", \"vs/editor/common/controller/cursorWordOperations\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\"], function (require, exports, types, cursorCommon_1, cursorMoveOperations_1, cursorWordOperations_1, position_1, range_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class CursorMoveCommands {\n        static addCursorDown(context, cursors, useLogicalLine) {\n            let result = [], resultLen = 0;\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                result[resultLen++] = new cursorCommon_1.CursorState(cursor.modelState, cursor.viewState);\n                if (useLogicalLine) {\n                    result[resultLen++] = cursorCommon_1.CursorState.fromModelState(cursorMoveOperations_1.MoveOperations.translateDown(context.config, context.model, cursor.modelState));\n                }\n                else {\n                    result[resultLen++] = cursorCommon_1.CursorState.fromViewState(cursorMoveOperations_1.MoveOperations.translateDown(context.config, context.viewModel, cursor.viewState));\n                }\n            }\n            return result;\n        }\n        static addCursorUp(context, cursors, useLogicalLine) {\n            let result = [], resultLen = 0;\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                result[resultLen++] = new cursorCommon_1.CursorState(cursor.modelState, cursor.viewState);\n                if (useLogicalLine) {\n                    result[resultLen++] = cursorCommon_1.CursorState.fromModelState(cursorMoveOperations_1.MoveOperations.translateUp(context.config, context.model, cursor.modelState));\n                }\n                else {\n                    result[resultLen++] = cursorCommon_1.CursorState.fromViewState(cursorMoveOperations_1.MoveOperations.translateUp(context.config, context.viewModel, cursor.viewState));\n                }\n            }\n            return result;\n        }\n        static moveToBeginningOfLine(context, cursors, inSelectionMode) {\n            let result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                result[i] = this._moveToLineStart(context, cursor, inSelectionMode);\n            }\n            return result;\n        }\n        static _moveToLineStart(context, cursor, inSelectionMode) {\n            const currentViewStateColumn = cursor.viewState.position.column;\n            const currentModelStateColumn = cursor.modelState.position.column;\n            const isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;\n            const currentViewStatelineNumber = cursor.viewState.position.lineNumber;\n            const firstNonBlankColumn = context.viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);\n            const isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;\n            if (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {\n                return this._moveToLineStartByView(context, cursor, inSelectionMode);\n            }\n            else {\n                return this._moveToLineStartByModel(context, cursor, inSelectionMode);\n            }\n        }\n        static _moveToLineStartByView(context, cursor, inSelectionMode) {\n            return cursorCommon_1.CursorState.fromViewState(cursorMoveOperations_1.MoveOperations.moveToBeginningOfLine(context.config, context.viewModel, cursor.viewState, inSelectionMode));\n        }\n        static _moveToLineStartByModel(context, cursor, inSelectionMode) {\n            return cursorCommon_1.CursorState.fromModelState(cursorMoveOperations_1.MoveOperations.moveToBeginningOfLine(context.config, context.model, cursor.modelState, inSelectionMode));\n        }\n        static moveToEndOfLine(context, cursors, inSelectionMode) {\n            let result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                result[i] = this._moveToLineEnd(context, cursor, inSelectionMode);\n            }\n            return result;\n        }\n        static _moveToLineEnd(context, cursor, inSelectionMode) {\n            const viewStatePosition = cursor.viewState.position;\n            const viewModelMaxColumn = context.viewModel.getLineMaxColumn(viewStatePosition.lineNumber);\n            const isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;\n            const modelStatePosition = cursor.modelState.position;\n            const modelMaxColumn = context.model.getLineMaxColumn(modelStatePosition.lineNumber);\n            const isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;\n            if (isEndOfViewLine || isEndLineOfWrappedLine) {\n                return this._moveToLineEndByModel(context, cursor, inSelectionMode);\n            }\n            else {\n                return this._moveToLineEndByView(context, cursor, inSelectionMode);\n            }\n        }\n        static _moveToLineEndByView(context, cursor, inSelectionMode) {\n            return cursorCommon_1.CursorState.fromViewState(cursorMoveOperations_1.MoveOperations.moveToEndOfLine(context.config, context.viewModel, cursor.viewState, inSelectionMode));\n        }\n        static _moveToLineEndByModel(context, cursor, inSelectionMode) {\n            return cursorCommon_1.CursorState.fromModelState(cursorMoveOperations_1.MoveOperations.moveToEndOfLine(context.config, context.model, cursor.modelState, inSelectionMode));\n        }\n        static expandLineSelection(context, cursors) {\n            let result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                const viewSelection = cursor.viewState.selection;\n                const startLineNumber = viewSelection.startLineNumber;\n                const lineCount = context.viewModel.getLineCount();\n                let endLineNumber = viewSelection.endLineNumber;\n                let endColumn;\n                if (endLineNumber === lineCount) {\n                    endColumn = context.viewModel.getLineMaxColumn(lineCount);\n                }\n                else {\n                    endLineNumber++;\n                    endColumn = 1;\n                }\n                result[i] = cursorCommon_1.CursorState.fromViewState(new cursorCommon_1.SingleCursorState(new range_1.Range(startLineNumber, 1, startLineNumber, 1), 0, new position_1.Position(endLineNumber, endColumn), 0));\n            }\n            return result;\n        }\n        static moveToBeginningOfBuffer(context, cursors, inSelectionMode) {\n            let result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                result[i] = cursorCommon_1.CursorState.fromModelState(cursorMoveOperations_1.MoveOperations.moveToBeginningOfBuffer(context.config, context.model, cursor.modelState, inSelectionMode));\n            }\n            return result;\n        }\n        static moveToEndOfBuffer(context, cursors, inSelectionMode) {\n            let result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                result[i] = cursorCommon_1.CursorState.fromModelState(cursorMoveOperations_1.MoveOperations.moveToEndOfBuffer(context.config, context.model, cursor.modelState, inSelectionMode));\n            }\n            return result;\n        }\n        static selectAll(context, cursor) {\n            const lineCount = context.model.getLineCount();\n            const maxColumn = context.model.getLineMaxColumn(lineCount);\n            return cursorCommon_1.CursorState.fromModelState(new cursorCommon_1.SingleCursorState(new range_1.Range(1, 1, 1, 1), 0, new position_1.Position(lineCount, maxColumn), 0));\n        }\n        static line(context, cursor, inSelectionMode, _position, _viewPosition) {\n            const position = context.model.validatePosition(_position);\n            const viewPosition = (_viewPosition\n                ? context.validateViewPosition(new position_1.Position(_viewPosition.lineNumber, _viewPosition.column), position)\n                : context.convertModelPositionToViewPosition(position));\n            if (!inSelectionMode || !cursor.modelState.hasSelection()) {\n                // Entering line selection for the first time\n                const lineCount = context.model.getLineCount();\n                let selectToLineNumber = position.lineNumber + 1;\n                let selectToColumn = 1;\n                if (selectToLineNumber > lineCount) {\n                    selectToLineNumber = lineCount;\n                    selectToColumn = context.model.getLineMaxColumn(selectToLineNumber);\n                }\n                return cursorCommon_1.CursorState.fromModelState(new cursorCommon_1.SingleCursorState(new range_1.Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), 0, new position_1.Position(selectToLineNumber, selectToColumn), 0));\n            }\n            // Continuing line selection\n            const enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;\n            if (position.lineNumber < enteringLineNumber) {\n                return cursorCommon_1.CursorState.fromViewState(cursor.viewState.move(cursor.modelState.hasSelection(), viewPosition.lineNumber, 1, 0));\n            }\n            else if (position.lineNumber > enteringLineNumber) {\n                const lineCount = context.viewModel.getLineCount();\n                let selectToViewLineNumber = viewPosition.lineNumber + 1;\n                let selectToViewColumn = 1;\n                if (selectToViewLineNumber > lineCount) {\n                    selectToViewLineNumber = lineCount;\n                    selectToViewColumn = context.viewModel.getLineMaxColumn(selectToViewLineNumber);\n                }\n                return cursorCommon_1.CursorState.fromViewState(cursor.viewState.move(cursor.modelState.hasSelection(), selectToViewLineNumber, selectToViewColumn, 0));\n            }\n            else {\n                const endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();\n                return cursorCommon_1.CursorState.fromModelState(cursor.modelState.move(cursor.modelState.hasSelection(), endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0));\n            }\n        }\n        static word(context, cursor, inSelectionMode, _position) {\n            const position = context.model.validatePosition(_position);\n            return cursorCommon_1.CursorState.fromModelState(cursorWordOperations_1.WordOperations.word(context.config, context.model, cursor.modelState, inSelectionMode, position));\n        }\n        static cancelSelection(context, cursor) {\n            if (!cursor.modelState.hasSelection()) {\n                return new cursorCommon_1.CursorState(cursor.modelState, cursor.viewState);\n            }\n            const lineNumber = cursor.viewState.position.lineNumber;\n            const column = cursor.viewState.position.column;\n            return cursorCommon_1.CursorState.fromViewState(new cursorCommon_1.SingleCursorState(new range_1.Range(lineNumber, column, lineNumber, column), 0, new position_1.Position(lineNumber, column), 0));\n        }\n        static moveTo(context, cursor, inSelectionMode, _position, _viewPosition) {\n            const position = context.model.validatePosition(_position);\n            const viewPosition = (_viewPosition\n                ? context.validateViewPosition(new position_1.Position(_viewPosition.lineNumber, _viewPosition.column), position)\n                : context.convertModelPositionToViewPosition(position));\n            return cursorCommon_1.CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));\n        }\n        static move(context, cursors, args) {\n            const inSelectionMode = args.select;\n            const value = args.value;\n            switch (args.direction) {\n                case CursorMove.Direction.Left: {\n                    if (args.unit === CursorMove.Unit.HalfLine) {\n                        // Move left by half the current line length\n                        return this._moveHalfLineLeft(context, cursors, inSelectionMode);\n                    }\n                    else {\n                        // Move left by `moveParams.value` columns\n                        return this._moveLeft(context, cursors, inSelectionMode, value);\n                    }\n                }\n                case CursorMove.Direction.Right: {\n                    if (args.unit === CursorMove.Unit.HalfLine) {\n                        // Move right by half the current line length\n                        return this._moveHalfLineRight(context, cursors, inSelectionMode);\n                    }\n                    else {\n                        // Move right by `moveParams.value` columns\n                        return this._moveRight(context, cursors, inSelectionMode, value);\n                    }\n                }\n                case CursorMove.Direction.Up: {\n                    if (args.unit === CursorMove.Unit.WrappedLine) {\n                        // Move up by view lines\n                        return this._moveUpByViewLines(context, cursors, inSelectionMode, value);\n                    }\n                    else {\n                        // Move up by model lines\n                        return this._moveUpByModelLines(context, cursors, inSelectionMode, value);\n                    }\n                }\n                case CursorMove.Direction.Down: {\n                    if (args.unit === CursorMove.Unit.WrappedLine) {\n                        // Move down by view lines\n                        return this._moveDownByViewLines(context, cursors, inSelectionMode, value);\n                    }\n                    else {\n                        // Move down by model lines\n                        return this._moveDownByModelLines(context, cursors, inSelectionMode, value);\n                    }\n                }\n                case CursorMove.Direction.WrappedLineStart: {\n                    // Move to the beginning of the current view line\n                    return this._moveToViewMinColumn(context, cursors, inSelectionMode);\n                }\n                case CursorMove.Direction.WrappedLineFirstNonWhitespaceCharacter: {\n                    // Move to the first non-whitespace column of the current view line\n                    return this._moveToViewFirstNonWhitespaceColumn(context, cursors, inSelectionMode);\n                }\n                case CursorMove.Direction.WrappedLineColumnCenter: {\n                    // Move to the \"center\" of the current view line\n                    return this._moveToViewCenterColumn(context, cursors, inSelectionMode);\n                }\n                case CursorMove.Direction.WrappedLineEnd: {\n                    // Move to the end of the current view line\n                    return this._moveToViewMaxColumn(context, cursors, inSelectionMode);\n                }\n                case CursorMove.Direction.WrappedLineLastNonWhitespaceCharacter: {\n                    // Move to the last non-whitespace column of the current view line\n                    return this._moveToViewLastNonWhitespaceColumn(context, cursors, inSelectionMode);\n                }\n                case CursorMove.Direction.ViewPortTop: {\n                    // Move to the nth line start in the viewport (from the top)\n                    const cursor = cursors[0];\n                    const visibleModelRange = context.getCompletelyVisibleModelRange();\n                    const modelLineNumber = this._firstLineNumberInRange(context.model, visibleModelRange, value);\n                    const modelColumn = context.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                    return [this._moveToModelPosition(context, cursor, inSelectionMode, modelLineNumber, modelColumn)];\n                }\n                case CursorMove.Direction.ViewPortBottom: {\n                    // Move to the nth line start in the viewport (from the bottom)\n                    const cursor = cursors[0];\n                    const visibleModelRange = context.getCompletelyVisibleModelRange();\n                    const modelLineNumber = this._lastLineNumberInRange(context.model, visibleModelRange, value);\n                    const modelColumn = context.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                    return [this._moveToModelPosition(context, cursor, inSelectionMode, modelLineNumber, modelColumn)];\n                }\n                case CursorMove.Direction.ViewPortCenter: {\n                    // Move to the line start in the viewport center\n                    const cursor = cursors[0];\n                    const visibleModelRange = context.getCompletelyVisibleModelRange();\n                    const modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);\n                    const modelColumn = context.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                    return [this._moveToModelPosition(context, cursor, inSelectionMode, modelLineNumber, modelColumn)];\n                }\n                case CursorMove.Direction.ViewPortIfOutside: {\n                    // Move to a position inside the viewport\n                    const visibleViewRange = context.getCompletelyVisibleViewRange();\n                    let result = [];\n                    for (let i = 0, len = cursors.length; i < len; i++) {\n                        const cursor = cursors[i];\n                        result[i] = this.findPositionInViewportIfOutside(context, cursor, visibleViewRange, inSelectionMode);\n                    }\n                    return result;\n                }\n            }\n            return null;\n        }\n        static findPositionInViewportIfOutside(context, cursor, visibleViewRange, inSelectionMode) {\n            let viewLineNumber = cursor.viewState.position.lineNumber;\n            if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {\n                // Nothing to do, cursor is in viewport\n                return new cursorCommon_1.CursorState(cursor.modelState, cursor.viewState);\n            }\n            else {\n                if (viewLineNumber > visibleViewRange.endLineNumber - 1) {\n                    viewLineNumber = visibleViewRange.endLineNumber - 1;\n                }\n                if (viewLineNumber < visibleViewRange.startLineNumber) {\n                    viewLineNumber = visibleViewRange.startLineNumber;\n                }\n                const viewColumn = context.viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n                return this._moveToViewPosition(context, cursor, inSelectionMode, viewLineNumber, viewColumn);\n            }\n        }\n        /**\n         * Find the nth line start included in the range (from the start).\n         */\n        static _firstLineNumberInRange(model, range, count) {\n            let startLineNumber = range.startLineNumber;\n            if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n                // Move on to the second line if the first line start is not included in the range\n                startLineNumber++;\n            }\n            return Math.min(range.endLineNumber, startLineNumber + count - 1);\n        }\n        /**\n         * Find the nth line start included in the range (from the end).\n         */\n        static _lastLineNumberInRange(model, range, count) {\n            let startLineNumber = range.startLineNumber;\n            if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n                // Move on to the second line if the first line start is not included in the range\n                startLineNumber++;\n            }\n            return Math.max(startLineNumber, range.endLineNumber - count + 1);\n        }\n        static _moveLeft(context, cursors, inSelectionMode, noOfColumns) {\n            let result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                let newViewState = cursorMoveOperations_1.MoveOperations.moveLeft(context.config, context.viewModel, cursor.viewState, inSelectionMode, noOfColumns);\n                if (noOfColumns === 1 && newViewState.position.lineNumber !== cursor.viewState.position.lineNumber) {\n                    // moved over to the previous view line\n                    const newViewModelPosition = context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(newViewState.position);\n                    if (newViewModelPosition.lineNumber === cursor.modelState.position.lineNumber) {\n                        // stayed on the same model line => pass wrapping point where 2 view positions map to a single model position\n                        newViewState = cursorMoveOperations_1.MoveOperations.moveLeft(context.config, context.viewModel, newViewState, inSelectionMode, 1);\n                    }\n                }\n                result[i] = cursorCommon_1.CursorState.fromViewState(newViewState);\n            }\n            return result;\n        }\n        static _moveHalfLineLeft(context, cursors, inSelectionMode) {\n            let result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                const viewLineNumber = cursor.viewState.position.lineNumber;\n                const halfLine = Math.round(context.viewModel.getLineContent(viewLineNumber).length / 2);\n                result[i] = cursorCommon_1.CursorState.fromViewState(cursorMoveOperations_1.MoveOperations.moveLeft(context.config, context.viewModel, cursor.viewState, inSelectionMode, halfLine));\n            }\n            return result;\n        }\n        static _moveRight(context, cursors, inSelectionMode, noOfColumns) {\n            let result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                let newViewState = cursorMoveOperations_1.MoveOperations.moveRight(context.config, context.viewModel, cursor.viewState, inSelectionMode, noOfColumns);\n                if (noOfColumns === 1 && newViewState.position.lineNumber !== cursor.viewState.position.lineNumber) {\n                    // moved over to the next view line\n                    const newViewModelPosition = context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(newViewState.position);\n                    if (newViewModelPosition.lineNumber === cursor.modelState.position.lineNumber) {\n                        // stayed on the same model line => pass wrapping point where 2 view positions map to a single model position\n                        newViewState = cursorMoveOperations_1.MoveOperations.moveRight(context.config, context.viewModel, newViewState, inSelectionMode, 1);\n                    }\n                }\n                result[i] = cursorCommon_1.CursorState.fromViewState(newViewState);\n            }\n            return result;\n        }\n        static _moveHalfLineRight(context, cursors, inSelectionMode) {\n            let result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                const viewLineNumber = cursor.viewState.position.lineNumber;\n                const halfLine = Math.round(context.viewModel.getLineContent(viewLineNumber).length / 2);\n                result[i] = cursorCommon_1.CursorState.fromViewState(cursorMoveOperations_1.MoveOperations.moveRight(context.config, context.viewModel, cursor.viewState, inSelectionMode, halfLine));\n            }\n            return result;\n        }\n        static _moveDownByViewLines(context, cursors, inSelectionMode, linesCount) {\n            let result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                result[i] = cursorCommon_1.CursorState.fromViewState(cursorMoveOperations_1.MoveOperations.moveDown(context.config, context.viewModel, cursor.viewState, inSelectionMode, linesCount));\n            }\n            return result;\n        }\n        static _moveDownByModelLines(context, cursors, inSelectionMode, linesCount) {\n            let result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                result[i] = cursorCommon_1.CursorState.fromModelState(cursorMoveOperations_1.MoveOperations.moveDown(context.config, context.model, cursor.modelState, inSelectionMode, linesCount));\n            }\n            return result;\n        }\n        static _moveUpByViewLines(context, cursors, inSelectionMode, linesCount) {\n            let result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                result[i] = cursorCommon_1.CursorState.fromViewState(cursorMoveOperations_1.MoveOperations.moveUp(context.config, context.viewModel, cursor.viewState, inSelectionMode, linesCount));\n            }\n            return result;\n        }\n        static _moveUpByModelLines(context, cursors, inSelectionMode, linesCount) {\n            let result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                result[i] = cursorCommon_1.CursorState.fromModelState(cursorMoveOperations_1.MoveOperations.moveUp(context.config, context.model, cursor.modelState, inSelectionMode, linesCount));\n            }\n            return result;\n        }\n        static _moveToViewPosition(context, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {\n            return cursorCommon_1.CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));\n        }\n        static _moveToModelPosition(context, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {\n            return cursorCommon_1.CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));\n        }\n        static _moveToViewMinColumn(context, cursors, inSelectionMode) {\n            let result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                const viewLineNumber = cursor.viewState.position.lineNumber;\n                const viewColumn = context.viewModel.getLineMinColumn(viewLineNumber);\n                result[i] = this._moveToViewPosition(context, cursor, inSelectionMode, viewLineNumber, viewColumn);\n            }\n            return result;\n        }\n        static _moveToViewFirstNonWhitespaceColumn(context, cursors, inSelectionMode) {\n            let result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                const viewLineNumber = cursor.viewState.position.lineNumber;\n                const viewColumn = context.viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n                result[i] = this._moveToViewPosition(context, cursor, inSelectionMode, viewLineNumber, viewColumn);\n            }\n            return result;\n        }\n        static _moveToViewCenterColumn(context, cursors, inSelectionMode) {\n            let result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                const viewLineNumber = cursor.viewState.position.lineNumber;\n                const viewColumn = Math.round((context.viewModel.getLineMaxColumn(viewLineNumber) + context.viewModel.getLineMinColumn(viewLineNumber)) / 2);\n                result[i] = this._moveToViewPosition(context, cursor, inSelectionMode, viewLineNumber, viewColumn);\n            }\n            return result;\n        }\n        static _moveToViewMaxColumn(context, cursors, inSelectionMode) {\n            let result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                const viewLineNumber = cursor.viewState.position.lineNumber;\n                const viewColumn = context.viewModel.getLineMaxColumn(viewLineNumber);\n                result[i] = this._moveToViewPosition(context, cursor, inSelectionMode, viewLineNumber, viewColumn);\n            }\n            return result;\n        }\n        static _moveToViewLastNonWhitespaceColumn(context, cursors, inSelectionMode) {\n            let result = [];\n            for (let i = 0, len = cursors.length; i < len; i++) {\n                const cursor = cursors[i];\n                const viewLineNumber = cursor.viewState.position.lineNumber;\n                const viewColumn = context.viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);\n                result[i] = this._moveToViewPosition(context, cursor, inSelectionMode, viewLineNumber, viewColumn);\n            }\n            return result;\n        }\n    }\n    exports.CursorMoveCommands = CursorMoveCommands;\n    var CursorMove;\n    (function (CursorMove) {\n        const isCursorMoveArgs = function (arg) {\n            if (!types.isObject(arg)) {\n                return false;\n            }\n            let cursorMoveArg = arg;\n            if (!types.isString(cursorMoveArg.to)) {\n                return false;\n            }\n            if (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {\n                return false;\n            }\n            if (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {\n                return false;\n            }\n            if (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {\n                return false;\n            }\n            return true;\n        };\n        CursorMove.description = {\n            description: 'Move cursor to a logical position in the view',\n            args: [\n                {\n                    name: 'Cursor move argument object',\n                    description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'left', 'right', 'up', 'down'\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t`,\n                    constraint: isCursorMoveArgs,\n                    schema: {\n                        'type': 'object',\n                        'required': ['to'],\n                        'properties': {\n                            'to': {\n                                'type': 'string',\n                                'enum': ['left', 'right', 'up', 'down', 'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter', 'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter', 'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside']\n                            },\n                            'by': {\n                                'type': 'string',\n                                'enum': ['line', 'wrappedLine', 'character', 'halfLine']\n                            },\n                            'value': {\n                                'type': 'number',\n                                'default': 1\n                            },\n                            'select': {\n                                'type': 'boolean',\n                                'default': false\n                            }\n                        }\n                    }\n                }\n            ]\n        };\n        /**\n         * Positions in the view for cursor move command.\n         */\n        CursorMove.RawDirection = {\n            Left: 'left',\n            Right: 'right',\n            Up: 'up',\n            Down: 'down',\n            WrappedLineStart: 'wrappedLineStart',\n            WrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',\n            WrappedLineColumnCenter: 'wrappedLineColumnCenter',\n            WrappedLineEnd: 'wrappedLineEnd',\n            WrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',\n            ViewPortTop: 'viewPortTop',\n            ViewPortCenter: 'viewPortCenter',\n            ViewPortBottom: 'viewPortBottom',\n            ViewPortIfOutside: 'viewPortIfOutside'\n        };\n        /**\n         * Units for Cursor move 'by' argument\n         */\n        CursorMove.RawUnit = {\n            Line: 'line',\n            WrappedLine: 'wrappedLine',\n            Character: 'character',\n            HalfLine: 'halfLine'\n        };\n        function parse(args) {\n            if (!args.to) {\n                // illegal arguments\n                return null;\n            }\n            let direction;\n            switch (args.to) {\n                case CursorMove.RawDirection.Left:\n                    direction = Direction.Left;\n                    break;\n                case CursorMove.RawDirection.Right:\n                    direction = Direction.Right;\n                    break;\n                case CursorMove.RawDirection.Up:\n                    direction = Direction.Up;\n                    break;\n                case CursorMove.RawDirection.Down:\n                    direction = Direction.Down;\n                    break;\n                case CursorMove.RawDirection.WrappedLineStart:\n                    direction = Direction.WrappedLineStart;\n                    break;\n                case CursorMove.RawDirection.WrappedLineFirstNonWhitespaceCharacter:\n                    direction = Direction.WrappedLineFirstNonWhitespaceCharacter;\n                    break;\n                case CursorMove.RawDirection.WrappedLineColumnCenter:\n                    direction = Direction.WrappedLineColumnCenter;\n                    break;\n                case CursorMove.RawDirection.WrappedLineEnd:\n                    direction = Direction.WrappedLineEnd;\n                    break;\n                case CursorMove.RawDirection.WrappedLineLastNonWhitespaceCharacter:\n                    direction = Direction.WrappedLineLastNonWhitespaceCharacter;\n                    break;\n                case CursorMove.RawDirection.ViewPortTop:\n                    direction = Direction.ViewPortTop;\n                    break;\n                case CursorMove.RawDirection.ViewPortBottom:\n                    direction = Direction.ViewPortBottom;\n                    break;\n                case CursorMove.RawDirection.ViewPortCenter:\n                    direction = Direction.ViewPortCenter;\n                    break;\n                case CursorMove.RawDirection.ViewPortIfOutside:\n                    direction = Direction.ViewPortIfOutside;\n                    break;\n                default:\n                    // illegal arguments\n                    return null;\n            }\n            let unit = Unit.None;\n            switch (args.by) {\n                case CursorMove.RawUnit.Line:\n                    unit = Unit.Line;\n                    break;\n                case CursorMove.RawUnit.WrappedLine:\n                    unit = Unit.WrappedLine;\n                    break;\n                case CursorMove.RawUnit.Character:\n                    unit = Unit.Character;\n                    break;\n                case CursorMove.RawUnit.HalfLine:\n                    unit = Unit.HalfLine;\n                    break;\n            }\n            return {\n                direction: direction,\n                unit: unit,\n                select: (!!args.select),\n                value: (args.value || 1)\n            };\n        }\n        CursorMove.parse = parse;\n        let Direction;\n        (function (Direction) {\n            Direction[Direction[\"Left\"] = 0] = \"Left\";\n            Direction[Direction[\"Right\"] = 1] = \"Right\";\n            Direction[Direction[\"Up\"] = 2] = \"Up\";\n            Direction[Direction[\"Down\"] = 3] = \"Down\";\n            Direction[Direction[\"WrappedLineStart\"] = 4] = \"WrappedLineStart\";\n            Direction[Direction[\"WrappedLineFirstNonWhitespaceCharacter\"] = 5] = \"WrappedLineFirstNonWhitespaceCharacter\";\n            Direction[Direction[\"WrappedLineColumnCenter\"] = 6] = \"WrappedLineColumnCenter\";\n            Direction[Direction[\"WrappedLineEnd\"] = 7] = \"WrappedLineEnd\";\n            Direction[Direction[\"WrappedLineLastNonWhitespaceCharacter\"] = 8] = \"WrappedLineLastNonWhitespaceCharacter\";\n            Direction[Direction[\"ViewPortTop\"] = 9] = \"ViewPortTop\";\n            Direction[Direction[\"ViewPortCenter\"] = 10] = \"ViewPortCenter\";\n            Direction[Direction[\"ViewPortBottom\"] = 11] = \"ViewPortBottom\";\n            Direction[Direction[\"ViewPortIfOutside\"] = 12] = \"ViewPortIfOutside\";\n        })(Direction = CursorMove.Direction || (CursorMove.Direction = {}));\n        let Unit;\n        (function (Unit) {\n            Unit[Unit[\"None\"] = 0] = \"None\";\n            Unit[Unit[\"Line\"] = 1] = \"Line\";\n            Unit[Unit[\"WrappedLine\"] = 2] = \"WrappedLine\";\n            Unit[Unit[\"Character\"] = 3] = \"Character\";\n            Unit[Unit[\"HalfLine\"] = 4] = \"HalfLine\";\n        })(Unit = CursorMove.Unit || (CursorMove.Unit = {}));\n    })(CursorMove = exports.CursorMove || (exports.CursorMove = {}));\n});\n",null]}