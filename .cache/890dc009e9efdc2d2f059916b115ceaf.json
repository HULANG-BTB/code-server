{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/common/terminal.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/common/terminal.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar contextkey_1 = require(\"vs/platform/contextkey/common/contextkey\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nexports.TERMINAL_PANEL_ID = 'workbench.panel.terminal';\n/** A context key that is set when there is at least one opened integrated terminal. */\nexports.KEYBINDING_CONTEXT_TERMINAL_IS_OPEN = new contextkey_1.RawContextKey('terminalIsOpen', false);\n/** A context key that is set when the integrated terminal has focus. */\nexports.KEYBINDING_CONTEXT_TERMINAL_FOCUS = new contextkey_1.RawContextKey('terminalFocus', false);\n/** A context key that is set when the integrated terminal does not have focus. */\nexports.KEYBINDING_CONTEXT_TERMINAL_NOT_FOCUSED = exports.KEYBINDING_CONTEXT_TERMINAL_FOCUS.toNegated();\n/** A keybinding context key that is set when the integrated terminal has text selected. */\nexports.KEYBINDING_CONTEXT_TERMINAL_TEXT_SELECTED = new contextkey_1.RawContextKey('terminalTextSelected', false);\n/** A keybinding context key that is set when the integrated terminal does not have text selected. */\nexports.KEYBINDING_CONTEXT_TERMINAL_TEXT_NOT_SELECTED = exports.KEYBINDING_CONTEXT_TERMINAL_TEXT_SELECTED.toNegated();\n/**  A context key that is set when the find widget in integrated terminal is visible. */\nexports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_VISIBLE = new contextkey_1.RawContextKey('terminalFindWidgetVisible', false);\n/**  A context key that is set when the find widget in integrated terminal is not visible. */\nexports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_NOT_VISIBLE = exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_VISIBLE.toNegated();\n/**  A context key that is set when the find widget find input in integrated terminal is focused. */\nexports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_INPUT_FOCUSED = new contextkey_1.RawContextKey('terminalFindWidgetInputFocused', false);\n/**  A context key that is set when the find widget in integrated terminal is focused. */\nexports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_FOCUSED = new contextkey_1.RawContextKey('terminalFindWidgetFocused', false);\n/**  A context key that is set when the find widget find input in integrated terminal is not focused. */\nexports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_INPUT_NOT_FOCUSED = exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_INPUT_FOCUSED.toNegated();\nexports.IS_WORKSPACE_SHELL_ALLOWED_STORAGE_KEY = 'terminal.integrated.isWorkspaceShellAllowed';\nexports.NEVER_SUGGEST_SELECT_WINDOWS_SHELL_STORAGE_KEY = 'terminal.integrated.neverSuggestSelectWindowsShell';\nexports.NEVER_MEASURE_RENDER_TIME_STORAGE_KEY = 'terminal.integrated.neverMeasureRenderTime';\n// The creation of extension host terminals is delayed by this value (milliseconds). The purpose of\n// this delay is to allow the terminal instance to initialize correctly and have its ID set before\n// trying to create the corressponding object on the ext host.\nexports.EXT_HOST_CREATION_DELAY = 100;\nexports.ITerminalService = instantiation_1.createDecorator('terminalService');\nexports.TerminalCursorStyle = {\n    BLOCK: 'block',\n    LINE: 'line',\n    UNDERLINE: 'underline'\n};\nexports.TERMINAL_CONFIG_SECTION = 'terminal.integrated';\nexports.DEFAULT_LETTER_SPACING = 0;\nexports.MINIMUM_LETTER_SPACING = -5;\nexports.DEFAULT_LINE_HEIGHT = 1;\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"Left\"] = 0] = \"Left\";\n    Direction[Direction[\"Right\"] = 1] = \"Right\";\n    Direction[Direction[\"Up\"] = 2] = \"Up\";\n    Direction[Direction[\"Down\"] = 3] = \"Down\";\n})(Direction = exports.Direction || (exports.Direction = {}));\nvar ProcessState;\n(function (ProcessState) {\n    // The process has not been initialized yet.\n    ProcessState[ProcessState[\"UNINITIALIZED\"] = 0] = \"UNINITIALIZED\";\n    // The process is currently launching, the process is marked as launching\n    // for a short duration after being created and is helpful to indicate\n    // whether the process died as a result of bad shell and args.\n    ProcessState[ProcessState[\"LAUNCHING\"] = 1] = \"LAUNCHING\";\n    // The process is running normally.\n    ProcessState[ProcessState[\"RUNNING\"] = 2] = \"RUNNING\";\n    // The process was killed during launch, likely as a result of bad shell and\n    // args.\n    ProcessState[ProcessState[\"KILLED_DURING_LAUNCH\"] = 3] = \"KILLED_DURING_LAUNCH\";\n    // The process was killed by the user (the event originated from VS Code).\n    ProcessState[ProcessState[\"KILLED_BY_USER\"] = 4] = \"KILLED_BY_USER\";\n    // The process was killed by itself, for example the shell crashed or `exit`\n    // was run.\n    ProcessState[ProcessState[\"KILLED_BY_PROCESS\"] = 5] = \"KILLED_BY_PROCESS\";\n})(ProcessState = exports.ProcessState || (exports.ProcessState = {}));\nvar LinuxDistro;\n(function (LinuxDistro) {\n    LinuxDistro[LinuxDistro[\"Fedora\"] = 0] = \"Fedora\";\n    LinuxDistro[LinuxDistro[\"Ubuntu\"] = 1] = \"Ubuntu\";\n    LinuxDistro[LinuxDistro[\"Unknown\"] = 2] = \"Unknown\";\n})(LinuxDistro = exports.LinuxDistro || (exports.LinuxDistro = {}));\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/common/terminal.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/common/terminal.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;AAKhG,uEAAsG;AACtG,gFAAiF;AAIpE,QAAA,iBAAiB,GAAG,0BAA0B,CAAC;AAE5D,uFAAuF;AAC1E,QAAA,mCAAmC,GAAG,IAAI,0BAAa,CAAU,gBAAgB,EAAE,KAAK,CAAC,CAAC;AACvG,wEAAwE;AAC3D,QAAA,iCAAiC,GAAG,IAAI,0BAAa,CAAU,eAAe,EAAE,KAAK,CAAC,CAAC;AACpG,kFAAkF;AACrE,QAAA,uCAAuC,GAAmB,yCAAiC,CAAC,SAAS,EAAE,CAAC;AAErH,2FAA2F;AAC9E,QAAA,yCAAyC,GAAG,IAAI,0BAAa,CAAU,sBAAsB,EAAE,KAAK,CAAC,CAAC;AACnH,qGAAqG;AACxF,QAAA,6CAA6C,GAAmB,iDAAyC,CAAC,SAAS,EAAE,CAAC;AAEnI,yFAAyF;AAC5E,QAAA,+CAA+C,GAAG,IAAI,0BAAa,CAAU,2BAA2B,EAAE,KAAK,CAAC,CAAC;AAC9H,6FAA6F;AAChF,QAAA,mDAAmD,GAAmB,uDAA+C,CAAC,SAAS,EAAE,CAAC;AAC/I,oGAAoG;AACvF,QAAA,qDAAqD,GAAG,IAAI,0BAAa,CAAU,gCAAgC,EAAE,KAAK,CAAC,CAAC;AACzI,yFAAyF;AAC5E,QAAA,+CAA+C,GAAG,IAAI,0BAAa,CAAU,2BAA2B,EAAE,KAAK,CAAC,CAAC;AAC9H,wGAAwG;AAC3F,QAAA,yDAAyD,GAAmB,6DAAqD,CAAC,SAAS,EAAE,CAAC;AAE9I,QAAA,sCAAsC,GAAG,6CAA6C,CAAC;AACvF,QAAA,8CAA8C,GAAG,oDAAoD,CAAC;AACtG,QAAA,qCAAqC,GAAG,4CAA4C,CAAC;AAElG,mGAAmG;AACnG,kGAAkG;AAClG,8DAA8D;AACjD,QAAA,uBAAuB,GAAG,GAAG,CAAC;AAE9B,QAAA,gBAAgB,GAAG,+BAAe,CAAmB,iBAAiB,CAAC,CAAC;AAExE,QAAA,mBAAmB,GAAG;IAClC,KAAK,EAAE,OAAO;IACd,IAAI,EAAE,MAAM;IACZ,SAAS,EAAE,WAAW;CACtB,CAAC;AAEW,QAAA,uBAAuB,GAAG,qBAAqB,CAAC;AAEhD,QAAA,sBAAsB,GAAG,CAAC,CAAC;AAC3B,QAAA,sBAAsB,GAAG,CAAC,CAAC,CAAC;AAC5B,QAAA,mBAAmB,GAAG,CAAC,CAAC;AAmNrC,IAAkB,SAKjB;AALD,WAAkB,SAAS;IAC1B,yCAAQ,CAAA;IACR,2CAAS,CAAA;IACT,qCAAM,CAAA;IACN,yCAAQ,CAAA;AACT,CAAC,EALiB,SAAS,GAAT,iBAAS,KAAT,iBAAS,QAK1B;AAgYD,IAAkB,YAiBjB;AAjBD,WAAkB,YAAY;IAC7B,4CAA4C;IAC5C,iEAAa,CAAA;IACb,yEAAyE;IACzE,sEAAsE;IACtE,8DAA8D;IAC9D,yDAAS,CAAA;IACT,mCAAmC;IACnC,qDAAO,CAAA;IACP,4EAA4E;IAC5E,QAAQ;IACR,+EAAoB,CAAA;IACpB,0EAA0E;IAC1E,mEAAc,CAAA;IACd,4EAA4E;IAC5E,WAAW;IACX,yEAAiB,CAAA;AAClB,CAAC,EAjBiB,YAAY,GAAZ,oBAAY,KAAZ,oBAAY,QAiB7B;AA8BD,IAAY,WAIX;AAJD,WAAY,WAAW;IACtB,iDAAM,CAAA;IACN,iDAAM,CAAA;IACN,mDAAO,CAAA;AACR,CAAC,EAJW,WAAW,GAAX,mBAAW,KAAX,mBAAW,QAItB","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport * as platform from 'vs/base/common/platform';\nimport { RawContextKey, ContextKeyExpr, IContextKey } from 'vs/platform/contextkey/common/contextkey';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { URI } from 'vs/base/common/uri';\nimport { FindReplaceState } from 'vs/editor/contrib/find/findState';\n\nexport const TERMINAL_PANEL_ID = 'workbench.panel.terminal';\n\n/** A context key that is set when there is at least one opened integrated terminal. */\nexport const KEYBINDING_CONTEXT_TERMINAL_IS_OPEN = new RawContextKey<boolean>('terminalIsOpen', false);\n/** A context key that is set when the integrated terminal has focus. */\nexport const KEYBINDING_CONTEXT_TERMINAL_FOCUS = new RawContextKey<boolean>('terminalFocus', false);\n/** A context key that is set when the integrated terminal does not have focus. */\nexport const KEYBINDING_CONTEXT_TERMINAL_NOT_FOCUSED: ContextKeyExpr = KEYBINDING_CONTEXT_TERMINAL_FOCUS.toNegated();\n\n/** A keybinding context key that is set when the integrated terminal has text selected. */\nexport const KEYBINDING_CONTEXT_TERMINAL_TEXT_SELECTED = new RawContextKey<boolean>('terminalTextSelected', false);\n/** A keybinding context key that is set when the integrated terminal does not have text selected. */\nexport const KEYBINDING_CONTEXT_TERMINAL_TEXT_NOT_SELECTED: ContextKeyExpr = KEYBINDING_CONTEXT_TERMINAL_TEXT_SELECTED.toNegated();\n\n/**  A context key that is set when the find widget in integrated terminal is visible. */\nexport const KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_VISIBLE = new RawContextKey<boolean>('terminalFindWidgetVisible', false);\n/**  A context key that is set when the find widget in integrated terminal is not visible. */\nexport const KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_NOT_VISIBLE: ContextKeyExpr = KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_VISIBLE.toNegated();\n/**  A context key that is set when the find widget find input in integrated terminal is focused. */\nexport const KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_INPUT_FOCUSED = new RawContextKey<boolean>('terminalFindWidgetInputFocused', false);\n/**  A context key that is set when the find widget in integrated terminal is focused. */\nexport const KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_FOCUSED = new RawContextKey<boolean>('terminalFindWidgetFocused', false);\n/**  A context key that is set when the find widget find input in integrated terminal is not focused. */\nexport const KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_INPUT_NOT_FOCUSED: ContextKeyExpr = KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_INPUT_FOCUSED.toNegated();\n\nexport const IS_WORKSPACE_SHELL_ALLOWED_STORAGE_KEY = 'terminal.integrated.isWorkspaceShellAllowed';\nexport const NEVER_SUGGEST_SELECT_WINDOWS_SHELL_STORAGE_KEY = 'terminal.integrated.neverSuggestSelectWindowsShell';\nexport const NEVER_MEASURE_RENDER_TIME_STORAGE_KEY = 'terminal.integrated.neverMeasureRenderTime';\n\n// The creation of extension host terminals is delayed by this value (milliseconds). The purpose of\n// this delay is to allow the terminal instance to initialize correctly and have its ID set before\n// trying to create the corressponding object on the ext host.\nexport const EXT_HOST_CREATION_DELAY = 100;\n\nexport const ITerminalService = createDecorator<ITerminalService>('terminalService');\n\nexport const TerminalCursorStyle = {\n\tBLOCK: 'block',\n\tLINE: 'line',\n\tUNDERLINE: 'underline'\n};\n\nexport const TERMINAL_CONFIG_SECTION = 'terminal.integrated';\n\nexport const DEFAULT_LETTER_SPACING = 0;\nexport const MINIMUM_LETTER_SPACING = -5;\nexport const DEFAULT_LINE_HEIGHT = 1;\n\nexport type FontWeight = 'normal' | 'bold' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';\n\nexport interface ITerminalConfiguration {\n\tshell: {\n\t\tlinux: string;\n\t\tosx: string;\n\t\twindows: string;\n\t};\n\tshellArgs: {\n\t\tlinux: string[];\n\t\tosx: string[];\n\t\twindows: string[];\n\t};\n\tmacOptionIsMeta: boolean;\n\tmacOptionClickForcesSelection: boolean;\n\trendererType: 'auto' | 'canvas' | 'dom';\n\trightClickBehavior: 'default' | 'copyPaste' | 'selectWord';\n\tcursorBlinking: boolean;\n\tcursorStyle: string;\n\tdrawBoldTextInBrightColors: boolean;\n\tfontFamily: string;\n\tfontWeight: FontWeight;\n\tfontWeightBold: FontWeight;\n\t// fontLigatures: boolean;\n\tfontSize: number;\n\tletterSpacing: number;\n\tlineHeight: number;\n\tsetLocaleVariables: boolean;\n\tscrollback: number;\n\tcommandsToSkipShell: string[];\n\tcwd: string;\n\tconfirmOnExit: boolean;\n\tenableBell: boolean;\n\tenv: {\n\t\tlinux: { [key: string]: string };\n\t\tosx: { [key: string]: string };\n\t\twindows: { [key: string]: string };\n\t};\n\tshowExitAlert: boolean;\n\texperimentalBufferImpl: 'JsArray' | 'TypedArray';\n\tsplitCwd: 'workspaceRoot' | 'initial' | 'inherited';\n\twindowsEnableConpty: boolean;\n}\n\nexport interface ITerminalConfigHelper {\n\tconfig: ITerminalConfiguration;\n\tconfigFontIsMonospace(): boolean;\n\tgetFont(): ITerminalFont;\n\t/**\n\t * Merges the default shell path and args into the provided launch configuration\n\t */\n\tmergeDefaultShellPathAndArgs(shell: IShellLaunchConfig, platformOverride?: platform.Platform): void;\n\t/** Sets whether a workspace shell configuration is allowed or not */\n\tsetWorkspaceShellAllowed(isAllowed: boolean): void;\n\tcheckWorkspaceShellPermissions(platformOverride?: platform.Platform): boolean;\n}\n\nexport interface ITerminalFont {\n\tfontFamily: string;\n\tfontSize: number;\n\tletterSpacing: number;\n\tlineHeight: number;\n\tcharWidth?: number;\n\tcharHeight?: number;\n}\n\nexport interface ITerminalEnvironment {\n\t[key: string]: string | null;\n}\n\nexport interface IShellLaunchConfig {\n\t/**\n\t * The name of the terminal, if this is not set the name of the process will be used.\n\t */\n\tname?: string;\n\n\t/**\n\t * The shell executable (bash, cmd, etc.).\n\t */\n\texecutable?: string;\n\n\t/**\n\t * The CLI arguments to use with executable, a string[] is in argv format and will be escaped,\n\t * a string is in \"CommandLine\" pre-escaped format and will be used as is. The string option is\n\t * only supported on Windows and will throw an exception if used on macOS or Linux.\n\t */\n\targs?: string[] | string;\n\n\t/**\n\t * The current working directory of the terminal, this overrides the `terminal.integrated.cwd`\n\t * settings key.\n\t */\n\tcwd?: string | URI;\n\n\t/**\n\t * A custom environment for the terminal, if this is not set the environment will be inherited\n\t * from the VS Code process.\n\t */\n\tenv?: ITerminalEnvironment;\n\n\t/**\n\t * Whether to ignore a custom cwd from the `terminal.integrated.cwd` settings key (eg. if the\n\t * shell is being launched by an extension).\n\t */\n\tignoreConfigurationCwd?: boolean;\n\n\t/** Whether to wait for a key press before closing the terminal. */\n\twaitOnExit?: boolean | string;\n\n\t/**\n\t * A string including ANSI escape sequences that will be written to the terminal emulator\n\t * _before_ the terminal process has launched, a trailing \\n is added at the end of the string.\n\t * This allows for example the terminal instance to display a styled message as the first line\n\t * of the terminal. Use \\x1b over \\033 or \\e for the escape control character.\n\t */\n\tinitialText?: string;\n\n\t/**\n\t * When true the terminal will be created with no process. This is primarily used to give\n\t * extensions full control over the terminal.\n\t */\n\tisRendererOnly?: boolean;\n\n\t/**\n\t * Whether the terminal process environment should be exactly as provided in\n\t * `TerminalOptions.env`. When this is false (default), the environment will be based on the\n\t * window's environment and also apply configured platform settings like\n\t * `terminal.integrated.windows.env` on top. When this is true, the complete environment must be\n\t * provided as nothing will be inherited from the process or any configuration.\n\t */\n\tstrictEnv?: boolean;\n}\n\nexport interface ITerminalService {\n\t_serviceBrand: any;\n\n\tactiveTabIndex: number;\n\tconfigHelper: ITerminalConfigHelper;\n\tonActiveTabChanged: Event<void>;\n\tonTabDisposed: Event<ITerminalTab>;\n\tonInstanceCreated: Event<ITerminalInstance>;\n\tonInstanceDisposed: Event<ITerminalInstance>;\n\tonInstanceProcessIdReady: Event<ITerminalInstance>;\n\tonInstanceDimensionsChanged: Event<ITerminalInstance>;\n\tonInstanceRequestExtHostProcess: Event<ITerminalProcessExtHostRequest>;\n\tonInstancesChanged: Event<void>;\n\tonInstanceTitleChanged: Event<ITerminalInstance>;\n\tonActiveInstanceChanged: Event<ITerminalInstance | undefined>;\n\tterminalInstances: ITerminalInstance[];\n\tterminalTabs: ITerminalTab[];\n\n\t/**\n\t * Creates a terminal.\n\t * @param shell The shell launch configuration to use.\n\t * @param wasNewTerminalAction Whether this was triggered by a new terminal action, if so a\n\t * default shell selection dialog may display.\n\t */\n\tcreateTerminal(shell?: IShellLaunchConfig, wasNewTerminalAction?: boolean): ITerminalInstance;\n\n\t/**\n\t * Creates a terminal renderer.\n\t * @param name The name of the terminal.\n\t */\n\tcreateTerminalRenderer(name: string): ITerminalInstance;\n\n\t/**\n\t * Creates a raw terminal instance, this should not be used outside of the terminal part.\n\t */\n\tcreateInstance(terminalFocusContextKey: IContextKey<boolean>, configHelper: ITerminalConfigHelper, container: HTMLElement | undefined, shellLaunchConfig: IShellLaunchConfig, doCreateProcess: boolean): ITerminalInstance;\n\tgetInstanceFromId(terminalId: number): ITerminalInstance;\n\tgetInstanceFromIndex(terminalIndex: number): ITerminalInstance;\n\tgetTabLabels(): string[];\n\tgetActiveInstance(): ITerminalInstance | null;\n\tsetActiveInstance(terminalInstance: ITerminalInstance): void;\n\tsetActiveInstanceByIndex(terminalIndex: number): void;\n\tgetActiveOrCreateInstance(wasNewTerminalAction?: boolean): ITerminalInstance;\n\tsplitInstance(instance: ITerminalInstance, shell?: IShellLaunchConfig): ITerminalInstance | null;\n\n\tgetActiveTab(): ITerminalTab | null;\n\tsetActiveTabToNext(): void;\n\tsetActiveTabToPrevious(): void;\n\tsetActiveTabByIndex(tabIndex: number): void;\n\n\tshowPanel(focus?: boolean): Promise<void>;\n\thidePanel(): void;\n\tfocusFindWidget(): Promise<void>;\n\thideFindWidget(): void;\n\tgetFindState(): FindReplaceState;\n\tfindNext(): void;\n\tfindPrevious(): void;\n\n\tsetContainers(panelContainer: HTMLElement, terminalContainer: HTMLElement): void;\n\tselectDefaultWindowsShell(): Promise<string | undefined>;\n\tsetWorkspaceShellAllowed(isAllowed: boolean): void;\n\n\t/**\n\t * Takes a path and returns the properly escaped path to send to the terminal.\n\t * On Windows, this included trying to prepare the path for WSL if needed.\n\t *\n\t * @param executable The executable off the shellLaunchConfig\n\t * @param title The terminal's title\n\t * @param path The path to be escaped and formatted.\n\t * @returns An escaped version of the path to be execuded in the terminal.\n\t */\n\tpreparePathForTerminalAsync(path: string, executable: string | undefined, title: string): Promise<string>;\n\n\trequestExtHostProcess(proxy: ITerminalProcessExtHostProxy, shellLaunchConfig: IShellLaunchConfig, activeWorkspaceRootUri: URI, cols: number, rows: number): void;\n}\n\nexport const enum Direction {\n\tLeft = 0,\n\tRight = 1,\n\tUp = 2,\n\tDown = 3\n}\n\nexport interface ITerminalTab {\n\tactiveInstance: ITerminalInstance | null;\n\tterminalInstances: ITerminalInstance[];\n\ttitle: string;\n\tonDisposed: Event<ITerminalTab>;\n\tonInstancesChanged: Event<void>;\n\n\tfocusPreviousPane(): void;\n\tfocusNextPane(): void;\n\tresizePane(direction: Direction): void;\n\tsetActiveInstanceByIndex(index: number): void;\n\tattachToElement(element: HTMLElement): void;\n\tsetVisible(visible: boolean): void;\n\tlayout(width: number, height: number): void;\n\taddDisposable(disposable: IDisposable): void;\n\tsplit(terminalFocusContextKey: IContextKey<boolean>, configHelper: ITerminalConfigHelper, shellLaunchConfig: IShellLaunchConfig): ITerminalInstance | undefined;\n}\n\nexport interface ITerminalDimensions {\n\t/**\n\t * The columns of the terminal.\n\t */\n\treadonly cols: number;\n\n\t/**\n\t * The rows of the terminal.\n\t */\n\treadonly rows: number;\n}\n\ninterface ISearchOptions {\n\t/**\n\t * Whether the find should be done as a regex.\n\t */\n\tregex?: boolean;\n\t/**\n\t * Whether only whole words should match.\n\t */\n\twholeWord?: boolean;\n\t/**\n\t * Whether find should pay attention to case.\n\t */\n\tcaseSensitive?: boolean;\n\t/**\n\t * Whether the search should start at the current search position (not the next row)\n\t */\n\tincremental?: boolean;\n}\n\nexport interface ITerminalInstance {\n\t/**\n\t * The ID of the terminal instance, this is an arbitrary number only used to identify the\n\t * terminal instance.\n\t */\n\treadonly id: number;\n\n\treadonly cols: number;\n\treadonly rows: number;\n\n\t/**\n\t * The process ID of the shell process, this is undefined when there is no process associated\n\t * with this terminal.\n\t */\n\tprocessId: number | undefined;\n\n\t/**\n\t * An event that fires when the terminal instance's title changes.\n\t */\n\tonTitleChanged: Event<ITerminalInstance>;\n\n\t/**\n\t * An event that fires when the terminal instance is disposed.\n\t */\n\tonDisposed: Event<ITerminalInstance>;\n\n\tonFocused: Event<ITerminalInstance>;\n\n\tonProcessIdReady: Event<ITerminalInstance>;\n\n\tonRequestExtHostProcess: Event<ITerminalInstance>;\n\n\tonDimensionsChanged: Event<void>;\n\n\tonFocus: Event<ITerminalInstance>;\n\n\t/**\n\t * Attach a listener to the raw data stream coming from the pty, including ANSI escape\n\t * sequences.\n\t */\n\tonData: Event<string>;\n\n\t/**\n\t * Attach a listener to the \"renderer\" input event, this event fires for terminal renderers on\n\t * keystrokes and when the Terminal.sendText extension API is used.\n\t * @param listener The listener function.\n\t */\n\tonRendererInput: Event<string>;\n\n\t/**\n\t * Attach a listener to listen for new lines added to this terminal instance.\n\t *\n\t * @param listener The listener function which takes new line strings added to the terminal,\n\t * excluding ANSI escape sequences. The line event will fire when an LF character is added to\n\t * the terminal (ie. the line is not wrapped). Note that this means that the line data will\n\t * not fire for the last line, until either the line is ended with a LF character of the process\n\t * is exited. The lineData string will contain the fully wrapped line, not containing any LF/CR\n\t * characters.\n\t */\n\tonLineData: Event<string>;\n\n\t/**\n\t * Attach a listener that fires when the terminal's pty process exits. The number in the event\n\t * is the processes' exit code, an exit code of null means the process was killed as a result of\n\t * the ITerminalInstance being disposed.\n\t */\n\tonExit: Event<number>;\n\n\tprocessReady: Promise<void>;\n\n\t/**\n\t * The title of the terminal. This is either title or the process currently running or an\n\t * explicit name given to the terminal instance through the extension API.\n\t */\n\treadonly title: string;\n\n\t/**\n\t * The focus state of the terminal before exiting.\n\t */\n\treadonly hadFocusOnExit: boolean;\n\n\t/**\n\t * False when the title is set by an API or the user. We check this to make sure we\n\t * do not override the title when the process title changes in the terminal.\n\t */\n\tisTitleSetByProcess: boolean;\n\n\t/**\n\t * The shell launch config used to launch the shell.\n\t */\n\treadonly shellLaunchConfig: IShellLaunchConfig;\n\n\t/**\n\t * Whether to disable layout for the terminal. This is useful when the size of the terminal is\n\t * being manipulating (eg. adding a split pane) and we want the terminal to ignore particular\n\t * resize events.\n\t */\n\tdisableLayout: boolean;\n\n\t/**\n\t * An object that tracks when commands are run and enables navigating and selecting between\n\t * them.\n\t */\n\treadonly commandTracker: ITerminalCommandTracker;\n\n\t/**\n\t * Dispose the terminal instance, removing it from the panel/service and freeing up resources.\n\t *\n\t * @param immediate Whether the kill should be immediate or not. Immediate should only be used\n\t * when VS Code is shutting down or in cases where the terminal dispose was user initiated.\n\t * The immediate===false exists to cover an edge case where the final output of the terminal can\n\t * get cut off. If immediate kill any terminal processes immediately.\n\t */\n\tdispose(immediate?: boolean): void;\n\n\t/**\n\t * Indicates that a consumer of a renderer only terminal is finished with it.\n\t *\n\t * @param exitCode The exit code of the terminal. Zero indicates success, non-zero indicates\n\t * failure.\n\t */\n\trendererExit(exitCode: number): void;\n\n\t/**\n\t * Forces the terminal to redraw its viewport.\n\t */\n\tforceRedraw(): void;\n\n\t/**\n\t * Registers a link matcher, allowing custom link patterns to be matched and handled.\n\t * @param regex The regular expression the search for, specifically this searches the\n\t * textContent of the rows. You will want to use \\s to match a space ' ' character for example.\n\t * @param handler The callback when the link is called.\n\t * @param matchIndex The index of the link from the regex.match(html) call. This defaults to 0\n\t * (for regular expressions without capture groups).\n\t * @param validationCallback A callback which can be used to validate the link after it has been\n\t * added to the DOM.\n\t * @return The ID of the new matcher, this can be used to deregister.\n\t */\n\tregisterLinkMatcher(regex: RegExp, handler: (url: string) => void, matchIndex?: number, validationCallback?: (uri: string, callback: (isValid: boolean) => void) => void): number;\n\n\t/**\n\t * Deregisters a link matcher if it has been registered.\n\t * @param matcherId The link matcher's ID (returned after register)\n\t * @return Whether a link matcher was found and deregistered.\n\t */\n\tderegisterLinkMatcher(matcherId: number): void;\n\n\t/**\n\t * Check if anything is selected in terminal.\n\t */\n\thasSelection(): boolean;\n\n\t/**\n\t * Copies the terminal selection to the clipboard.\n\t */\n\tcopySelection(): void;\n\n\t/**\n\t * Current selection in the terminal.\n\t */\n\treadonly selection: string | undefined;\n\n\t/**\n\t * Clear current selection.\n\t */\n\tclearSelection(): void;\n\n\t/**\n\t * Select all text in the terminal.\n\t */\n\tselectAll(): void;\n\n\t/**\n\t * Find the next instance of the term\n\t*/\n\tfindNext(term: string, searchOptions: ISearchOptions): boolean;\n\n\t/**\n\t * Find the previous instance of the term\n\t */\n\tfindPrevious(term: string, searchOptions: ISearchOptions): boolean;\n\n\t/**\n\t * Notifies the terminal that the find widget's focus state has been changed.\n\t */\n\tnotifyFindWidgetFocusChanged(isFocused: boolean): void;\n\n\t/**\n\t * Focuses the terminal instance if it's able to (xterm.js instance exists).\n\t *\n\t * @param focus Force focus even if there is a selection.\n\t */\n\tfocus(force?: boolean): void;\n\n\t/**\n\t * Focuses the terminal instance when it's ready (the xterm.js instance is created). Use this\n\t * when the terminal is being shown.\n\t *\n\t * @param focus Force focus even if there is a selection.\n\t */\n\tfocusWhenReady(force?: boolean): Promise<void>;\n\n\t/**\n\t * Focuses and pastes the contents of the clipboard into the terminal instance.\n\t */\n\tpaste(): void;\n\n\t/**\n\t * Send text to the terminal instance. The text is written to the stdin of the underlying pty\n\t * process (shell) of the terminal instance.\n\t *\n\t * @param text The text to send.\n\t * @param addNewLine Whether to add a new line to the text being sent, this is normally\n\t * required to run a command in the terminal. The character(s) added are \\n or \\r\\n\n\t * depending on the platform. This defaults to `true`.\n\t */\n\tsendText(text: string, addNewLine: boolean): void;\n\n\t/**\n\t * Write text directly to the terminal, skipping the process if it exists.\n\t * @param text The text to write.\n\t */\n\twrite(text: string): void;\n\n\t/** Scroll the terminal buffer down 1 line. */\n\tscrollDownLine(): void;\n\t/** Scroll the terminal buffer down 1 page. */\n\tscrollDownPage(): void;\n\t/** Scroll the terminal buffer to the bottom. */\n\tscrollToBottom(): void;\n\t/** Scroll the terminal buffer up 1 line. */\n\tscrollUpLine(): void;\n\t/** Scroll the terminal buffer up 1 page. */\n\tscrollUpPage(): void;\n\t/** Scroll the terminal buffer to the top. */\n\tscrollToTop(): void;\n\n\t/**\n\t * Clears the terminal buffer, leaving only the prompt line.\n\t */\n\tclear(): void;\n\n\t/**\n\t * Attaches the terminal instance to an element on the DOM, before this is called the terminal\n\t * instance process may run in the background but cannot be displayed on the UI.\n\t *\n\t * @param container The element to attach the terminal instance to.\n\t */\n\tattachToElement(container: HTMLElement): void;\n\n\t/**\n\t * Updates the configuration of the terminal instance.\n\t */\n\tupdateConfig(): void;\n\n\t/**\n\t * Updates the accessibility support state of the terminal instance.\n\t * @param isEnabled Whether it's enabled.\n\t */\n\tupdateAccessibilitySupport(isEnabled: boolean): void;\n\n\t/**\n\t * Configure the dimensions of the terminal instance.\n\t *\n\t * @param dimension The dimensions of the container.\n\t */\n\tlayout(dimension: { width: number, height: number }): void;\n\n\t/**\n\t * Sets whether the terminal instance's element is visible in the DOM.\n\t *\n\t * @param visible Whether the element is visible.\n\t */\n\tsetVisible(visible: boolean): void;\n\n\t/**\n\t * Immediately kills the terminal's current pty process and launches a new one to replace it.\n\t *\n\t * @param shell The new launch configuration.\n\t */\n\treuseTerminal(shell: IShellLaunchConfig): void;\n\n\t/**\n\t * Sets the title of the terminal instance.\n\t */\n\tsetTitle(title: string, eventFromProcess: boolean): void;\n\n\twaitForTitle(): Promise<string>;\n\n\tsetDimensions(dimensions: ITerminalDimensions): void;\n\n\taddDisposable(disposable: IDisposable): void;\n\n\ttoggleEscapeSequenceLogging(): void;\n\n\tgetInitialCwd(): Promise<string>;\n\tgetCwd(): Promise<string>;\n}\n\nexport interface ITerminalCommandTracker {\n\tscrollToPreviousCommand(): void;\n\tscrollToNextCommand(): void;\n\tselectToPreviousCommand(): void;\n\tselectToNextCommand(): void;\n\tselectToPreviousLine(): void;\n\tselectToNextLine(): void;\n}\n\nexport interface ITerminalProcessManager extends IDisposable {\n\treadonly processState: ProcessState;\n\treadonly ptyProcessReady: Promise<void>;\n\treadonly shellProcessId: number;\n\treadonly remoteAuthority: string | undefined;\n\treadonly os: platform.OperatingSystem | undefined;\n\treadonly userHome: string | undefined;\n\n\treadonly onProcessReady: Event<void>;\n\treadonly onProcessData: Event<string>;\n\treadonly onProcessTitle: Event<string>;\n\treadonly onProcessExit: Event<number>;\n\n\taddDisposable(disposable: IDisposable): void;\n\tdispose(immediate?: boolean): void;\n\tcreateProcess(shellLaunchConfig: IShellLaunchConfig, cols: number, rows: number): void;\n\twrite(data: string): void;\n\tsetDimensions(cols: number, rows: number): void;\n\n\tgetInitialCwd(): Promise<string>;\n\tgetCwd(): Promise<string>;\n\tgetLatency(): Promise<number>;\n}\n\nexport const enum ProcessState {\n\t// The process has not been initialized yet.\n\tUNINITIALIZED,\n\t// The process is currently launching, the process is marked as launching\n\t// for a short duration after being created and is helpful to indicate\n\t// whether the process died as a result of bad shell and args.\n\tLAUNCHING,\n\t// The process is running normally.\n\tRUNNING,\n\t// The process was killed during launch, likely as a result of bad shell and\n\t// args.\n\tKILLED_DURING_LAUNCH,\n\t// The process was killed by the user (the event originated from VS Code).\n\tKILLED_BY_USER,\n\t// The process was killed by itself, for example the shell crashed or `exit`\n\t// was run.\n\tKILLED_BY_PROCESS\n}\n\n\nexport interface ITerminalProcessExtHostProxy extends IDisposable {\n\treadonly terminalId: number;\n\n\temitData(data: string): void;\n\temitTitle(title: string): void;\n\temitPid(pid: number): void;\n\temitExit(exitCode: number): void;\n\temitInitialCwd(initialCwd: string): void;\n\temitCwd(cwd: string): void;\n\temitLatency(latency: number): void;\n\n\tonInput: Event<string>;\n\tonResize: Event<{ cols: number, rows: number }>;\n\tonShutdown: Event<boolean>;\n\tonRequestInitialCwd: Event<void>;\n\tonRequestCwd: Event<void>;\n\tonRequestLatency: Event<void>;\n}\n\nexport interface ITerminalProcessExtHostRequest {\n\tproxy: ITerminalProcessExtHostProxy;\n\tshellLaunchConfig: IShellLaunchConfig;\n\tactiveWorkspaceRootUri: URI;\n\tcols: number;\n\trows: number;\n}\n\nexport enum LinuxDistro {\n\tFedora,\n\tUbuntu,\n\tUnknown\n}\n\nexport interface IWindowsShellHelper extends IDisposable {\n\tgetShellName(): Promise<string>;\n}\n\n/**\n * An interface representing a raw terminal child process, this contains a subset of the\n * child_process.ChildProcess node.js interface.\n */\nexport interface ITerminalChildProcess {\n\tonProcessData: Event<string>;\n\tonProcessExit: Event<number>;\n\tonProcessIdReady: Event<number>;\n\tonProcessTitleChanged: Event<string>;\n\n\t/**\n\t * Shutdown the terminal process.\n\t *\n\t * @param immediate When true the process will be killed immediately, otherwise the process will\n\t * be given some time to make sure no additional data comes through.\n\t */\n\tshutdown(immediate: boolean): void;\n\tinput(data: string): void;\n\tresize(cols: number, rows: number): void;\n\n\tgetInitialCwd(): Promise<string>;\n\tgetCwd(): Promise<string>;\n\tgetLatency(): Promise<number>;\n}"]}]}