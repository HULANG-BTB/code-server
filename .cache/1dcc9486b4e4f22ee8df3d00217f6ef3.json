{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/debugModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/debugModel.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/resources\", \"vs/base/common/lifecycle\", \"vs/base/common/event\", \"vs/base/common/uuid\", \"vs/base/common/async\", \"vs/base/common/types\", \"vs/base/common/arrays\", \"vs/editor/common/core/range\", \"vs/workbench/contrib/debug/common/debug\", \"vs/base/common/strings\", \"vs/base/common/path\"], function (require, exports, nls, resources, lifecycle, event_1, uuid_1, async_1, types_1, arrays_1, range_1, debug_1, strings_1, path_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class SimpleReplElement {\n        constructor(id, value, severity, sourceData) {\n            this.id = id;\n            this.value = value;\n            this.severity = severity;\n            this.sourceData = sourceData;\n        }\n        toString() {\n            return this.value;\n        }\n        getId() {\n            return this.id;\n        }\n    }\n    exports.SimpleReplElement = SimpleReplElement;\n    class RawObjectReplElement {\n        constructor(id, name, valueObj, sourceData, annotation) {\n            this.id = id;\n            this.name = name;\n            this.valueObj = valueObj;\n            this.sourceData = sourceData;\n            this.annotation = annotation;\n        }\n        getId() {\n            return this.id;\n        }\n        get value() {\n            if (this.valueObj === null) {\n                return 'null';\n            }\n            else if (Array.isArray(this.valueObj)) {\n                return `Array[${this.valueObj.length}]`;\n            }\n            else if (types_1.isObject(this.valueObj)) {\n                return 'Object';\n            }\n            else if (types_1.isString(this.valueObj)) {\n                return `\"${this.valueObj}\"`;\n            }\n            return String(this.valueObj) || '';\n        }\n        get hasChildren() {\n            return (Array.isArray(this.valueObj) && this.valueObj.length > 0) || (types_1.isObject(this.valueObj) && Object.getOwnPropertyNames(this.valueObj).length > 0);\n        }\n        getChildren() {\n            let result = [];\n            if (Array.isArray(this.valueObj)) {\n                result = this.valueObj.slice(0, RawObjectReplElement.MAX_CHILDREN)\n                    .map((v, index) => new RawObjectReplElement(`${this.id}:${index}`, String(index), v));\n            }\n            else if (types_1.isObject(this.valueObj)) {\n                result = Object.getOwnPropertyNames(this.valueObj).slice(0, RawObjectReplElement.MAX_CHILDREN)\n                    .map((key, index) => new RawObjectReplElement(`${this.id}:${index}`, key, this.valueObj[key]));\n            }\n            return Promise.resolve(result);\n        }\n        toString() {\n            return `${this.name}\\n${this.value}`;\n        }\n    }\n    RawObjectReplElement.MAX_CHILDREN = 1000; // upper bound of children per value\n    exports.RawObjectReplElement = RawObjectReplElement;\n    class ExpressionContainer {\n        constructor(session, _reference, id, namedVariables = 0, indexedVariables = 0, startOfVariables = 0) {\n            this.session = session;\n            this._reference = _reference;\n            this.id = id;\n            this.namedVariables = namedVariables;\n            this.indexedVariables = indexedVariables;\n            this.startOfVariables = startOfVariables;\n        }\n        get reference() {\n            return this._reference;\n        }\n        set reference(value) {\n            this._reference = value;\n            this.children = undefined; // invalidate children cache\n        }\n        getChildren() {\n            if (!this.children) {\n                this.children = this.doGetChildren();\n            }\n            return this.children;\n        }\n        doGetChildren() {\n            if (!this.hasChildren) {\n                return Promise.resolve([]);\n            }\n            if (!this.getChildrenInChunks) {\n                return this.fetchVariables(undefined, undefined, undefined);\n            }\n            // Check if object has named variables, fetch them independent from indexed variables #9670\n            const childrenThenable = !!this.namedVariables ? this.fetchVariables(undefined, undefined, 'named') : Promise.resolve([]);\n            return childrenThenable.then(childrenArray => {\n                // Use a dynamic chunk size based on the number of elements #9774\n                let chunkSize = ExpressionContainer.BASE_CHUNK_SIZE;\n                while (!!this.indexedVariables && this.indexedVariables > chunkSize * ExpressionContainer.BASE_CHUNK_SIZE) {\n                    chunkSize *= ExpressionContainer.BASE_CHUNK_SIZE;\n                }\n                if (!!this.indexedVariables && this.indexedVariables > chunkSize) {\n                    // There are a lot of children, create fake intermediate values that represent chunks #9537\n                    const numberOfChunks = Math.ceil(this.indexedVariables / chunkSize);\n                    for (let i = 0; i < numberOfChunks; i++) {\n                        const start = (this.startOfVariables || 0) + i * chunkSize;\n                        const count = Math.min(chunkSize, this.indexedVariables - i * chunkSize);\n                        childrenArray.push(new Variable(this.session, this, this.reference, `[${start}..${start + count - 1}]`, '', '', undefined, count, { kind: 'virtual' }, undefined, true, start));\n                    }\n                    return childrenArray;\n                }\n                return this.fetchVariables(this.startOfVariables, this.indexedVariables, 'indexed')\n                    .then(variables => childrenArray.concat(variables));\n            });\n        }\n        getId() {\n            return this.id;\n        }\n        get value() {\n            return this._value;\n        }\n        get hasChildren() {\n            // only variables with reference > 0 have children.\n            return !!this.reference && this.reference > 0;\n        }\n        fetchVariables(start, count, filter) {\n            return this.session.variables(this.reference || 0, filter, start, count).then(response => {\n                return response && response.body && response.body.variables\n                    ? arrays_1.distinct(response.body.variables.filter(v => !!v && types_1.isString(v.name)), (v) => v.name).map((v) => new Variable(this.session, this, v.variablesReference, v.name, v.evaluateName, v.value, v.namedVariables, v.indexedVariables, v.presentationHint, v.type))\n                    : [];\n            }, (e) => [new Variable(this.session, this, 0, e.message, e.message, '', 0, 0, { kind: 'virtual' }, undefined, false)]);\n        }\n        // The adapter explicitly sents the children count of an expression only if there are lots of children which should be chunked.\n        get getChildrenInChunks() {\n            return !!this.indexedVariables;\n        }\n        set value(value) {\n            this._value = value;\n            this.valueChanged = !!ExpressionContainer.allValues.get(this.getId()) &&\n                ExpressionContainer.allValues.get(this.getId()) !== Expression.DEFAULT_VALUE && ExpressionContainer.allValues.get(this.getId()) !== value;\n            ExpressionContainer.allValues.set(this.getId(), value);\n        }\n        toString() {\n            return this.value;\n        }\n    }\n    ExpressionContainer.allValues = new Map();\n    // Use chunks to support variable paging #9537\n    ExpressionContainer.BASE_CHUNK_SIZE = 100;\n    exports.ExpressionContainer = ExpressionContainer;\n    class Expression extends ExpressionContainer {\n        constructor(name, id = uuid_1.generateUuid()) {\n            super(undefined, 0, id);\n            this.name = name;\n            this.available = false;\n            // name is not set if the expression is just being added\n            // in that case do not set default value to prevent flashing #14499\n            if (name) {\n                this.value = Expression.DEFAULT_VALUE;\n            }\n        }\n        evaluate(session, stackFrame, context) {\n            if (!session || (!stackFrame && context !== 'repl')) {\n                this.value = context === 'repl' ? nls.localize('startDebugFirst', \"Please start a debug session to evaluate expressions\") : Expression.DEFAULT_VALUE;\n                this.available = false;\n                this.reference = 0;\n                return Promise.resolve(undefined);\n            }\n            this.session = session;\n            return session.evaluate(this.name, stackFrame ? stackFrame.frameId : undefined, context).then(response => {\n                this.available = !!(response && response.body);\n                if (response && response.body) {\n                    this.value = response.body.result;\n                    this.reference = response.body.variablesReference;\n                    this.namedVariables = response.body.namedVariables;\n                    this.indexedVariables = response.body.indexedVariables;\n                    this.type = response.body.type || this.type;\n                }\n            }, err => {\n                this.value = err.message;\n                this.available = false;\n                this.reference = 0;\n            });\n        }\n        toString() {\n            return `${this.name}\\n${this.value}`;\n        }\n    }\n    Expression.DEFAULT_VALUE = nls.localize('notAvailable', \"not available\");\n    exports.Expression = Expression;\n    class Variable extends ExpressionContainer {\n        constructor(session, parent, reference, name, evaluateName, value, namedVariables, indexedVariables, presentationHint, type = undefined, available = true, startOfVariables = 0) {\n            super(session, reference, `variable:${parent.getId()}:${name}`, namedVariables, indexedVariables, startOfVariables);\n            this.parent = parent;\n            this.name = name;\n            this.evaluateName = evaluateName;\n            this.presentationHint = presentationHint;\n            this.type = type;\n            this.available = available;\n            this.value = value;\n        }\n        setVariable(value) {\n            if (!this.session) {\n                return Promise.resolve(undefined);\n            }\n            return this.session.setVariable(this.parent.reference, this.name, value).then(response => {\n                if (response && response.body) {\n                    this.value = response.body.value;\n                    this.type = response.body.type || this.type;\n                    this.reference = response.body.variablesReference;\n                    this.namedVariables = response.body.namedVariables;\n                    this.indexedVariables = response.body.indexedVariables;\n                }\n            }, err => {\n                this.errorMessage = err.message;\n            });\n        }\n        toString() {\n            return `${this.name}: ${this.value}`;\n        }\n    }\n    exports.Variable = Variable;\n    class Scope extends ExpressionContainer {\n        constructor(stackFrame, index, name, reference, expensive, namedVariables, indexedVariables, range) {\n            super(stackFrame.thread.session, reference, `scope:${stackFrame.getId()}:${name}:${index}`, namedVariables, indexedVariables);\n            this.name = name;\n            this.expensive = expensive;\n            this.range = range;\n        }\n        toString() {\n            return this.name;\n        }\n    }\n    exports.Scope = Scope;\n    class StackFrame {\n        constructor(thread, frameId, source, name, presentationHint, range, index) {\n            this.thread = thread;\n            this.frameId = frameId;\n            this.source = source;\n            this.name = name;\n            this.presentationHint = presentationHint;\n            this.range = range;\n            this.index = index;\n            this.scopes = null;\n        }\n        getId() {\n            return `stackframe:${this.thread.getId()}:${this.frameId}:${this.index}`;\n        }\n        getScopes() {\n            if (!this.scopes) {\n                this.scopes = this.thread.session.scopes(this.frameId).then(response => {\n                    return response && response.body && response.body.scopes ?\n                        response.body.scopes.map((rs, index) => new Scope(this, index, rs.name, rs.variablesReference, rs.expensive, rs.namedVariables, rs.indexedVariables, rs.line && rs.column && rs.endLine && rs.endColumn ? new range_1.Range(rs.line, rs.column, rs.endLine, rs.endColumn) : undefined)) : [];\n                }, err => []);\n            }\n            return this.scopes;\n        }\n        getSpecificSourceName() {\n            // To reduce flashing of the path name and the way we fetch stack frames\n            // We need to compute the source name based on the other frames in the stale call stack\n            let callStack = this.thread.getStaleCallStack();\n            callStack = callStack.length > 0 ? callStack : this.thread.getCallStack();\n            const otherSources = callStack.map(sf => sf.source).filter(s => s !== this.source);\n            let suffixLength = 0;\n            otherSources.forEach(s => {\n                if (s.name === this.source.name) {\n                    suffixLength = Math.max(suffixLength, strings_1.commonSuffixLength(this.source.uri.path, s.uri.path));\n                }\n            });\n            if (suffixLength === 0) {\n                return this.source.name;\n            }\n            const from = Math.max(0, this.source.uri.path.lastIndexOf(path_1.posix.sep, this.source.uri.path.length - suffixLength - 1));\n            return (from > 0 ? '...' : '') + this.source.uri.path.substr(from);\n        }\n        getMostSpecificScopes(range) {\n            return this.getScopes().then(scopes => {\n                scopes = scopes.filter(s => !s.expensive);\n                const haveRangeInfo = scopes.some(s => !!s.range);\n                if (!haveRangeInfo) {\n                    return scopes;\n                }\n                const scopesContainingRange = scopes.filter(scope => scope.range && range_1.Range.containsRange(scope.range, range))\n                    .sort((first, second) => (first.range.endLineNumber - first.range.startLineNumber) - (second.range.endLineNumber - second.range.startLineNumber));\n                return scopesContainingRange.length ? scopesContainingRange : scopes;\n            });\n        }\n        restart() {\n            return this.thread.session.restartFrame(this.frameId, this.thread.threadId);\n        }\n        toString() {\n            return `${this.name} (${this.source.inMemory ? this.source.name : this.source.uri.fsPath}:${this.range.startLineNumber})`;\n        }\n        openInEditor(editorService, preserveFocus, sideBySide, pinned) {\n            return !this.source.available ? Promise.resolve(null) :\n                this.source.openInEditor(editorService, this.range, preserveFocus, sideBySide, pinned);\n        }\n    }\n    exports.StackFrame = StackFrame;\n    class Thread {\n        constructor(session, name, threadId) {\n            this.session = session;\n            this.name = name;\n            this.threadId = threadId;\n            this.callStack = [];\n            this.staleCallStack = [];\n            this.stopped = false;\n        }\n        getId() {\n            return `thread:${this.session.getId()}:${this.threadId}`;\n        }\n        clearCallStack() {\n            if (this.callStack.length) {\n                this.staleCallStack = this.callStack;\n            }\n            this.callStack = [];\n        }\n        getCallStack() {\n            return this.callStack;\n        }\n        getStaleCallStack() {\n            return this.staleCallStack;\n        }\n        get stateLabel() {\n            if (this.stoppedDetails) {\n                return this.stoppedDetails.description ||\n                    this.stoppedDetails.reason ? nls.localize({ key: 'pausedOn', comment: ['indicates reason for program being paused'] }, \"Paused on {0}\", this.stoppedDetails.reason) : nls.localize('paused', \"Paused\");\n            }\n            return nls.localize({ key: 'running', comment: ['indicates state'] }, \"Running\");\n        }\n        /**\n         * Queries the debug adapter for the callstack and returns a promise\n         * which completes once the call stack has been retrieved.\n         * If the thread is not stopped, it returns a promise to an empty array.\n         * Only fetches the first stack frame for performance reasons. Calling this method consecutive times\n         * gets the remainder of the call stack.\n         */\n        fetchCallStack(levels = 20) {\n            if (!this.stopped) {\n                return Promise.resolve(undefined);\n            }\n            const start = this.callStack.length;\n            return this.getCallStackImpl(start, levels).then(callStack => {\n                if (start < this.callStack.length) {\n                    // Set the stack frames for exact position we requested. To make sure no concurrent requests create duplicate stack frames #30660\n                    this.callStack.splice(start, this.callStack.length - start);\n                }\n                this.callStack = this.callStack.concat(callStack || []);\n            });\n        }\n        getCallStackImpl(startFrame, levels) {\n            return this.session.stackTrace(this.threadId, startFrame, levels).then(response => {\n                if (!response || !response.body) {\n                    return [];\n                }\n                if (this.stoppedDetails) {\n                    this.stoppedDetails.totalFrames = response.body.totalFrames;\n                }\n                return response.body.stackFrames.map((rsf, index) => {\n                    const source = this.session.getSource(rsf.source);\n                    return new StackFrame(this, rsf.id, source, rsf.name, rsf.presentationHint, new range_1.Range(rsf.line, rsf.column, rsf.endLine || rsf.line, rsf.endColumn || rsf.column), startFrame + index);\n                });\n            }, (err) => {\n                if (this.stoppedDetails) {\n                    this.stoppedDetails.framesErrorMessage = err.message;\n                }\n                return [];\n            });\n        }\n        /**\n         * Returns exception info promise if the exception was thrown, otherwise undefined\n         */\n        get exceptionInfo() {\n            if (this.stoppedDetails && this.stoppedDetails.reason === 'exception') {\n                if (this.session.capabilities.supportsExceptionInfoRequest) {\n                    return this.session.exceptionInfo(this.threadId);\n                }\n                return Promise.resolve({\n                    description: this.stoppedDetails.text,\n                    breakMode: null\n                });\n            }\n            return Promise.resolve(undefined);\n        }\n        next() {\n            return this.session.next(this.threadId);\n        }\n        stepIn() {\n            return this.session.stepIn(this.threadId);\n        }\n        stepOut() {\n            return this.session.stepOut(this.threadId);\n        }\n        stepBack() {\n            return this.session.stepBack(this.threadId);\n        }\n        continue() {\n            return this.session.continue(this.threadId);\n        }\n        pause() {\n            return this.session.pause(this.threadId);\n        }\n        terminate() {\n            return this.session.terminateThreads([this.threadId]);\n        }\n        reverseContinue() {\n            return this.session.reverseContinue(this.threadId);\n        }\n    }\n    exports.Thread = Thread;\n    class Enablement {\n        constructor(enabled, id) {\n            this.enabled = enabled;\n            this.id = id;\n        }\n        getId() {\n            return this.id;\n        }\n    }\n    exports.Enablement = Enablement;\n    class BaseBreakpoint extends Enablement {\n        constructor(enabled, hitCondition, condition, logMessage, id) {\n            super(enabled, id);\n            this.hitCondition = hitCondition;\n            this.condition = condition;\n            this.logMessage = logMessage;\n            this.sessionData = new Map();\n            if (enabled === undefined) {\n                this.enabled = true;\n            }\n        }\n        getSessionData() {\n            return this.sessionId ? this.sessionData.get(this.sessionId) : undefined;\n        }\n        setSessionData(sessionId, data) {\n            this.sessionData.set(sessionId, data);\n        }\n        setSessionId(sessionId) {\n            this.sessionId = sessionId;\n        }\n        get verified() {\n            const data = this.getSessionData();\n            return data ? data.verified : true;\n        }\n        get idFromAdapter() {\n            const data = this.getSessionData();\n            return data ? data.id : undefined;\n        }\n        toJSON() {\n            const result = Object.create(null);\n            result.enabled = this.enabled;\n            result.condition = this.condition;\n            result.hitCondition = this.hitCondition;\n            result.logMessage = this.logMessage;\n            return result;\n        }\n    }\n    exports.BaseBreakpoint = BaseBreakpoint;\n    class Breakpoint extends BaseBreakpoint {\n        constructor(uri, _lineNumber, _column, enabled, condition, hitCondition, logMessage, _adapterData, textFileService, id = uuid_1.generateUuid()) {\n            super(enabled, hitCondition, condition, logMessage, id);\n            this.uri = uri;\n            this._lineNumber = _lineNumber;\n            this._column = _column;\n            this._adapterData = _adapterData;\n            this.textFileService = textFileService;\n        }\n        get lineNumber() {\n            const data = this.getSessionData();\n            return this.verified && data && typeof data.line === 'number' ? data.line : this._lineNumber;\n        }\n        get verified() {\n            const data = this.getSessionData();\n            if (data) {\n                return data.verified && !this.textFileService.isDirty(this.uri);\n            }\n            return true;\n        }\n        get column() {\n            const data = this.getSessionData();\n            // Only respect the column if the user explictly set the column to have an inline breakpoint\n            return data && typeof data.column === 'number' && typeof this._column === 'number' ? data.column : this._column;\n        }\n        get message() {\n            const data = this.getSessionData();\n            if (!data) {\n                return undefined;\n            }\n            if (this.textFileService.isDirty(this.uri)) {\n                return nls.localize('breakpointDirtydHover', \"Unverified breakpoint. File is modified, please restart debug session.\");\n            }\n            return data.message;\n        }\n        get adapterData() {\n            const data = this.getSessionData();\n            return data && data.source && data.source.adapterData ? data.source.adapterData : this._adapterData;\n        }\n        get endLineNumber() {\n            const data = this.getSessionData();\n            return data ? data.endLine : undefined;\n        }\n        get endColumn() {\n            const data = this.getSessionData();\n            return data ? data.endColumn : undefined;\n        }\n        setSessionData(sessionId, data) {\n            super.setSessionData(sessionId, data);\n            if (!this._adapterData) {\n                this._adapterData = this.adapterData;\n            }\n        }\n        toJSON() {\n            const result = super.toJSON();\n            result.uri = this.uri;\n            result.lineNumber = this._lineNumber;\n            result.column = this._column;\n            result.adapterData = this.adapterData;\n            return result;\n        }\n        toString() {\n            return resources.basenameOrAuthority(this.uri);\n        }\n        update(data) {\n            if (!types_1.isUndefinedOrNull(data.lineNumber)) {\n                this._lineNumber = data.lineNumber;\n            }\n            if (!types_1.isUndefinedOrNull(data.column)) {\n                this._column = data.column;\n            }\n            if (!types_1.isUndefinedOrNull(data.condition)) {\n                this.condition = data.condition;\n            }\n            if (!types_1.isUndefinedOrNull(data.hitCondition)) {\n                this.hitCondition = data.hitCondition;\n            }\n            if (!types_1.isUndefinedOrNull(data.logMessage)) {\n                this.logMessage = data.logMessage;\n            }\n        }\n    }\n    exports.Breakpoint = Breakpoint;\n    class FunctionBreakpoint extends BaseBreakpoint {\n        constructor(name, enabled, hitCondition, condition, logMessage, id = uuid_1.generateUuid()) {\n            super(enabled, hitCondition, condition, logMessage, id);\n            this.name = name;\n        }\n        toJSON() {\n            const result = super.toJSON();\n            result.name = this.name;\n            return result;\n        }\n        toString() {\n            return this.name;\n        }\n    }\n    exports.FunctionBreakpoint = FunctionBreakpoint;\n    class ExceptionBreakpoint extends Enablement {\n        constructor(filter, label, enabled) {\n            super(enabled, uuid_1.generateUuid());\n            this.filter = filter;\n            this.label = label;\n        }\n        toJSON() {\n            const result = Object.create(null);\n            result.filter = this.filter;\n            result.label = this.label;\n            result.enabled = this.enabled;\n            return result;\n        }\n        toString() {\n            return this.label;\n        }\n    }\n    exports.ExceptionBreakpoint = ExceptionBreakpoint;\n    class ThreadAndSessionIds {\n        constructor(sessionId, threadId) {\n            this.sessionId = sessionId;\n            this.threadId = threadId;\n        }\n        getId() {\n            return `${this.sessionId}:${this.threadId}`;\n        }\n    }\n    exports.ThreadAndSessionIds = ThreadAndSessionIds;\n    class DebugModel {\n        constructor(breakpoints, breakpointsActivated, functionBreakpoints, exceptionBreakpoints, watchExpressions, textFileService) {\n            this.breakpoints = breakpoints;\n            this.breakpointsActivated = breakpointsActivated;\n            this.functionBreakpoints = functionBreakpoints;\n            this.exceptionBreakpoints = exceptionBreakpoints;\n            this.watchExpressions = watchExpressions;\n            this.textFileService = textFileService;\n            this.schedulers = new Map();\n            this.sessions = [];\n            this.toDispose = [];\n            this._onDidChangeBreakpoints = new event_1.Emitter();\n            this._onDidChangeCallStack = new event_1.Emitter();\n            this._onDidChangeWatchExpressions = new event_1.Emitter();\n        }\n        getId() {\n            return 'root';\n        }\n        getSession(sessionId, includeInactive = false) {\n            if (sessionId) {\n                return this.getSessions(includeInactive).filter(s => s.getId() === sessionId).pop();\n            }\n            return undefined;\n        }\n        getSessions(includeInactive = false) {\n            // By default do not return inactive sesions.\n            // However we are still holding onto inactive sessions due to repl and debug service session revival (eh scenario)\n            return this.sessions.filter(s => includeInactive || s.state !== debug_1.State.Inactive);\n        }\n        addSession(session) {\n            this.sessions = this.sessions.filter(s => {\n                if (s.getId() === session.getId()) {\n                    // Make sure to de-dupe if a session is re-intialized. In case of EH debugging we are adding a session again after an attach.\n                    return false;\n                }\n                if (s.state === debug_1.State.Inactive && s.getLabel() === session.getLabel()) {\n                    // Make sure to remove all inactive sessions that are using the same configuration as the new session\n                    return false;\n                }\n                return true;\n            });\n            let index = -1;\n            if (session.parentSession) {\n                // Make sure that child sessions are placed after the parent session\n                index = arrays_1.lastIndex(this.sessions, s => s.parentSession === session.parentSession || s === session.parentSession);\n            }\n            if (index >= 0) {\n                this.sessions.splice(index + 1, 0, session);\n            }\n            else {\n                this.sessions.push(session);\n            }\n            this._onDidChangeCallStack.fire(undefined);\n        }\n        get onDidChangeBreakpoints() {\n            return this._onDidChangeBreakpoints.event;\n        }\n        get onDidChangeCallStack() {\n            return this._onDidChangeCallStack.event;\n        }\n        get onDidChangeWatchExpressions() {\n            return this._onDidChangeWatchExpressions.event;\n        }\n        rawUpdate(data) {\n            let session = this.sessions.filter(p => p.getId() === data.sessionId).pop();\n            if (session) {\n                session.rawUpdate(data);\n                this._onDidChangeCallStack.fire(undefined);\n            }\n        }\n        clearThreads(id, removeThreads, reference = undefined) {\n            const session = this.sessions.filter(p => p.getId() === id).pop();\n            this.schedulers.forEach(scheduler => scheduler.dispose());\n            this.schedulers.clear();\n            if (session) {\n                session.clearThreads(removeThreads, reference);\n                this._onDidChangeCallStack.fire(undefined);\n            }\n        }\n        fetchCallStack(thread) {\n            if (thread.session.capabilities.supportsDelayedStackTraceLoading) {\n                // For improved performance load the first stack frame and then load the rest async.\n                let topCallStack = Promise.resolve();\n                const wholeCallStack = new Promise((c, e) => {\n                    topCallStack = thread.fetchCallStack(1).then(() => {\n                        if (!this.schedulers.has(thread.getId())) {\n                            this.schedulers.set(thread.getId(), new async_1.RunOnceScheduler(() => {\n                                thread.fetchCallStack(19).then(() => {\n                                    this._onDidChangeCallStack.fire();\n                                    c();\n                                });\n                            }, 420));\n                        }\n                        this.schedulers.get(thread.getId()).schedule();\n                    });\n                    this._onDidChangeCallStack.fire();\n                });\n                return { topCallStack, wholeCallStack };\n            }\n            const wholeCallStack = thread.fetchCallStack();\n            return { wholeCallStack, topCallStack: wholeCallStack };\n        }\n        getBreakpoints(filter) {\n            if (filter) {\n                const uriStr = filter.uri ? filter.uri.toString() : undefined;\n                return this.breakpoints.filter(bp => {\n                    if (uriStr && bp.uri.toString() !== uriStr) {\n                        return false;\n                    }\n                    if (filter.lineNumber && bp.lineNumber !== filter.lineNumber) {\n                        return false;\n                    }\n                    if (filter.column && bp.column !== filter.column) {\n                        return false;\n                    }\n                    if (filter.enabledOnly && (!this.breakpointsActivated || !bp.enabled)) {\n                        return false;\n                    }\n                    return true;\n                });\n            }\n            return this.breakpoints;\n        }\n        getFunctionBreakpoints() {\n            return this.functionBreakpoints;\n        }\n        getExceptionBreakpoints() {\n            return this.exceptionBreakpoints;\n        }\n        setExceptionBreakpoints(data) {\n            if (data) {\n                if (this.exceptionBreakpoints.length === data.length && this.exceptionBreakpoints.every((exbp, i) => exbp.filter === data[i].filter && exbp.label === data[i].label)) {\n                    // No change\n                    return;\n                }\n                this.exceptionBreakpoints = data.map(d => {\n                    const ebp = this.exceptionBreakpoints.filter(ebp => ebp.filter === d.filter).pop();\n                    return new ExceptionBreakpoint(d.filter, d.label, ebp ? ebp.enabled : !!d.default);\n                });\n                this._onDidChangeBreakpoints.fire(undefined);\n            }\n        }\n        areBreakpointsActivated() {\n            return this.breakpointsActivated;\n        }\n        setBreakpointsActivated(activated) {\n            this.breakpointsActivated = activated;\n            this._onDidChangeBreakpoints.fire(undefined);\n        }\n        addBreakpoints(uri, rawData, fireEvent = true) {\n            const newBreakpoints = rawData.map(rawBp => new Breakpoint(uri, rawBp.lineNumber, rawBp.column, rawBp.enabled === false ? false : true, rawBp.condition, rawBp.hitCondition, rawBp.logMessage, undefined, this.textFileService, rawBp.id));\n            newBreakpoints.forEach(bp => bp.setSessionId(this.breakpointsSessionId));\n            this.breakpoints = this.breakpoints.concat(newBreakpoints);\n            this.breakpointsActivated = true;\n            this.sortAndDeDup();\n            if (fireEvent) {\n                this._onDidChangeBreakpoints.fire({ added: newBreakpoints });\n            }\n            return newBreakpoints;\n        }\n        removeBreakpoints(toRemove) {\n            this.breakpoints = this.breakpoints.filter(bp => !toRemove.some(toRemove => toRemove.getId() === bp.getId()));\n            this._onDidChangeBreakpoints.fire({ removed: toRemove });\n        }\n        updateBreakpoints(data) {\n            const updated = [];\n            this.breakpoints.forEach(bp => {\n                const bpData = data[bp.getId()];\n                if (bpData) {\n                    bp.update(bpData);\n                    updated.push(bp);\n                }\n            });\n            this.sortAndDeDup();\n            this._onDidChangeBreakpoints.fire({ changed: updated });\n        }\n        setBreakpointSessionData(sessionId, data) {\n            this.breakpoints.forEach(bp => {\n                const bpData = data[bp.getId()];\n                if (bpData) {\n                    bp.setSessionData(sessionId, bpData);\n                }\n            });\n            this.functionBreakpoints.forEach(fbp => {\n                const fbpData = data[fbp.getId()];\n                if (fbpData) {\n                    fbp.setSessionData(sessionId, fbpData);\n                }\n            });\n            this._onDidChangeBreakpoints.fire({\n                sessionOnly: true\n            });\n        }\n        setBreakpointsSessionId(sessionId) {\n            this.breakpointsSessionId = sessionId;\n            this.breakpoints.forEach(bp => bp.setSessionId(sessionId));\n            this.functionBreakpoints.forEach(fbp => fbp.setSessionId(sessionId));\n            this._onDidChangeBreakpoints.fire({\n                sessionOnly: true\n            });\n        }\n        sortAndDeDup() {\n            this.breakpoints = this.breakpoints.sort((first, second) => {\n                if (first.uri.toString() !== second.uri.toString()) {\n                    return resources.basenameOrAuthority(first.uri).localeCompare(resources.basenameOrAuthority(second.uri));\n                }\n                if (first.lineNumber === second.lineNumber) {\n                    if (first.column && second.column) {\n                        return first.column - second.column;\n                    }\n                    return -1;\n                }\n                return first.lineNumber - second.lineNumber;\n            });\n            this.breakpoints = arrays_1.distinct(this.breakpoints, bp => `${bp.uri.toString()}:${bp.lineNumber}:${bp.column}`);\n        }\n        setEnablement(element, enable) {\n            if (element instanceof Breakpoint || element instanceof FunctionBreakpoint || element instanceof ExceptionBreakpoint) {\n                const changed = [];\n                if (element.enabled !== enable && (element instanceof Breakpoint || element instanceof FunctionBreakpoint)) {\n                    changed.push(element);\n                }\n                element.enabled = enable;\n                this._onDidChangeBreakpoints.fire({ changed: changed });\n            }\n        }\n        enableOrDisableAllBreakpoints(enable) {\n            const changed = [];\n            this.breakpoints.forEach(bp => {\n                if (bp.enabled !== enable) {\n                    changed.push(bp);\n                }\n                bp.enabled = enable;\n            });\n            this.functionBreakpoints.forEach(fbp => {\n                if (fbp.enabled !== enable) {\n                    changed.push(fbp);\n                }\n                fbp.enabled = enable;\n            });\n            this._onDidChangeBreakpoints.fire({ changed: changed });\n        }\n        addFunctionBreakpoint(functionName, id) {\n            const newFunctionBreakpoint = new FunctionBreakpoint(functionName, true, undefined, undefined, undefined, id);\n            this.functionBreakpoints.push(newFunctionBreakpoint);\n            this._onDidChangeBreakpoints.fire({ added: [newFunctionBreakpoint] });\n            return newFunctionBreakpoint;\n        }\n        renameFunctionBreakpoint(id, name) {\n            const functionBreakpoint = this.functionBreakpoints.filter(fbp => fbp.getId() === id).pop();\n            if (functionBreakpoint) {\n                functionBreakpoint.name = name;\n                this._onDidChangeBreakpoints.fire({ changed: [functionBreakpoint] });\n            }\n        }\n        removeFunctionBreakpoints(id) {\n            let removed;\n            if (id) {\n                removed = this.functionBreakpoints.filter(fbp => fbp.getId() === id);\n                this.functionBreakpoints = this.functionBreakpoints.filter(fbp => fbp.getId() !== id);\n            }\n            else {\n                removed = this.functionBreakpoints;\n                this.functionBreakpoints = [];\n            }\n            this._onDidChangeBreakpoints.fire({ removed: removed });\n        }\n        getWatchExpressions() {\n            return this.watchExpressions;\n        }\n        addWatchExpression(name) {\n            const we = new Expression(name);\n            this.watchExpressions.push(we);\n            this._onDidChangeWatchExpressions.fire(we);\n            return we;\n        }\n        renameWatchExpression(id, newName) {\n            const filtered = this.watchExpressions.filter(we => we.getId() === id);\n            if (filtered.length === 1) {\n                filtered[0].name = newName;\n                this._onDidChangeWatchExpressions.fire(filtered[0]);\n            }\n        }\n        removeWatchExpressions(id = null) {\n            this.watchExpressions = id ? this.watchExpressions.filter(we => we.getId() !== id) : [];\n            this._onDidChangeWatchExpressions.fire(undefined);\n        }\n        moveWatchExpression(id, position) {\n            const we = this.watchExpressions.filter(we => we.getId() === id).pop();\n            if (we) {\n                this.watchExpressions = this.watchExpressions.filter(we => we.getId() !== id);\n                this.watchExpressions = this.watchExpressions.slice(0, position).concat(we, this.watchExpressions.slice(position));\n                this._onDidChangeWatchExpressions.fire(undefined);\n            }\n        }\n        sourceIsNotAvailable(uri) {\n            this.sessions.forEach(s => {\n                const source = s.getSourceForUri(uri);\n                if (source) {\n                    source.available = false;\n                }\n            });\n            this._onDidChangeCallStack.fire(undefined);\n        }\n        dispose() {\n            // Make sure to shutdown each session, such that no debugged process is left laying around\n            this.sessions.forEach(s => s.shutdown());\n            this.toDispose = lifecycle.dispose(this.toDispose);\n        }\n    }\n    exports.DebugModel = DebugModel;\n});\n",null]}