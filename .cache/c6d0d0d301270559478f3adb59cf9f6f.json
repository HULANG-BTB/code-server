{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostTreeViews.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostTreeViews.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/resources\", \"vs/base/common/uri\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/base/common/async\", \"vs/workbench/api/node/extHostTypes\", \"vs/base/common/types\", \"vs/base/common/arrays\", \"vs/workbench/services/extensions/common/extensions\"], function (require, exports, nls_1, resources_1, uri_1, event_1, lifecycle_1, async_1, extHostTypes_1, types_1, arrays_1, extensions_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function toTreeItemLabel(label, extension) {\n        if (types_1.isString(label)) {\n            return { label };\n        }\n        if (label\n            && typeof label === 'object'\n            && typeof label.label === 'string') {\n            extensions_1.checkProposedApiEnabled(extension);\n            let highlights = undefined;\n            if (Array.isArray(label.highlights)) {\n                highlights = label.highlights.filter((highlight => highlight.length === 2 && typeof highlight[0] === 'number' && typeof highlight[1] === 'number'));\n                highlights = highlights.length ? highlights : undefined;\n            }\n            return { label: label.label, highlights };\n        }\n        return undefined;\n    }\n    class ExtHostTreeViews {\n        constructor(_proxy, commands, logService) {\n            this._proxy = _proxy;\n            this.commands = commands;\n            this.logService = logService;\n            this.treeViews = new Map();\n            commands.registerArgumentProcessor({\n                processArgument: arg => {\n                    if (arg && arg.$treeViewId && arg.$treeItemHandle) {\n                        return this.convertArgument(arg);\n                    }\n                    return arg;\n                }\n            });\n        }\n        registerTreeDataProvider(id, treeDataProvider, extension) {\n            const treeView = this.createTreeView(id, { treeDataProvider }, extension);\n            return { dispose: () => treeView.dispose() };\n        }\n        createTreeView(viewId, options, extension) {\n            if (!options || !options.treeDataProvider) {\n                throw new Error('Options with treeDataProvider is mandatory');\n            }\n            const treeView = this.createExtHostTreeView(viewId, options, extension);\n            return {\n                get onDidCollapseElement() { return treeView.onDidCollapseElement; },\n                get onDidExpandElement() { return treeView.onDidExpandElement; },\n                get selection() { return treeView.selectedElements; },\n                get onDidChangeSelection() { return treeView.onDidChangeSelection; },\n                get visible() { return treeView.visible; },\n                get onDidChangeVisibility() { return treeView.onDidChangeVisibility; },\n                get message() { return treeView.message; },\n                set message(message) { extensions_1.checkProposedApiEnabled(extension); treeView.message = message; },\n                reveal: (element, options) => {\n                    return treeView.reveal(element, options);\n                },\n                dispose: () => {\n                    this.treeViews.delete(viewId);\n                    treeView.dispose();\n                }\n            };\n        }\n        $getChildren(treeViewId, treeItemHandle) {\n            const treeView = this.treeViews.get(treeViewId);\n            if (!treeView) {\n                return Promise.reject(new Error(nls_1.localize('treeView.notRegistered', 'No tree view with id \\'{0}\\' registered.', treeViewId)));\n            }\n            return treeView.getChildren(treeItemHandle);\n        }\n        $setExpanded(treeViewId, treeItemHandle, expanded) {\n            const treeView = this.treeViews.get(treeViewId);\n            if (!treeView) {\n                throw new Error(nls_1.localize('treeView.notRegistered', 'No tree view with id \\'{0}\\' registered.', treeViewId));\n            }\n            treeView.setExpanded(treeItemHandle, expanded);\n        }\n        $setSelection(treeViewId, treeItemHandles) {\n            const treeView = this.treeViews.get(treeViewId);\n            if (!treeView) {\n                throw new Error(nls_1.localize('treeView.notRegistered', 'No tree view with id \\'{0}\\' registered.', treeViewId));\n            }\n            treeView.setSelection(treeItemHandles);\n        }\n        $setVisible(treeViewId, isVisible) {\n            const treeView = this.treeViews.get(treeViewId);\n            if (!treeView) {\n                throw new Error(nls_1.localize('treeView.notRegistered', 'No tree view with id \\'{0}\\' registered.', treeViewId));\n            }\n            treeView.setVisible(isVisible);\n        }\n        createExtHostTreeView(id, options, extension) {\n            const treeView = new ExtHostTreeView(id, options, this._proxy, this.commands.converter, this.logService, extension);\n            this.treeViews.set(id, treeView);\n            return treeView;\n        }\n        convertArgument(arg) {\n            const treeView = this.treeViews.get(arg.$treeViewId);\n            return treeView ? treeView.getExtensionElement(arg.$treeItemHandle) : null;\n        }\n    }\n    exports.ExtHostTreeViews = ExtHostTreeViews;\n    class ExtHostTreeView extends lifecycle_1.Disposable {\n        constructor(viewId, options, proxy, commands, logService, extension) {\n            super();\n            this.viewId = viewId;\n            this.proxy = proxy;\n            this.commands = commands;\n            this.logService = logService;\n            this.extension = extension;\n            this.roots = null;\n            this.elements = new Map();\n            this.nodes = new Map();\n            this._visible = false;\n            this._selectedHandles = [];\n            this._onDidExpandElement = this._register(new event_1.Emitter());\n            this.onDidExpandElement = this._onDidExpandElement.event;\n            this._onDidCollapseElement = this._register(new event_1.Emitter());\n            this.onDidCollapseElement = this._onDidCollapseElement.event;\n            this._onDidChangeSelection = this._register(new event_1.Emitter());\n            this.onDidChangeSelection = this._onDidChangeSelection.event;\n            this._onDidChangeVisibility = this._register(new event_1.Emitter());\n            this.onDidChangeVisibility = this._onDidChangeVisibility.event;\n            this._onDidChangeData = this._register(new event_1.Emitter());\n            this.refreshPromise = Promise.resolve();\n            this.dataProvider = options.treeDataProvider;\n            this.proxy.$registerTreeViewDataProvider(viewId, { showCollapseAll: !!options.showCollapseAll });\n            if (this.dataProvider.onDidChangeTreeData) {\n                this._register(this.dataProvider.onDidChangeTreeData(element => this._onDidChangeData.fire({ message: false, element })));\n            }\n            let refreshingPromise;\n            let promiseCallback;\n            this._register(event_1.Event.debounce(this._onDidChangeData.event, (result, current) => {\n                if (!result) {\n                    result = { message: false, elements: [] };\n                }\n                if (current.element !== false) {\n                    if (!refreshingPromise) {\n                        // New refresh has started\n                        refreshingPromise = new Promise(c => promiseCallback = c);\n                        this.refreshPromise = this.refreshPromise.then(() => refreshingPromise);\n                    }\n                    result.elements.push(current.element);\n                }\n                if (current.message) {\n                    result.message = true;\n                }\n                return result;\n            }, 200)(({ message, elements }) => {\n                if (elements.length) {\n                    const _promiseCallback = promiseCallback;\n                    refreshingPromise = null;\n                    this.refresh(elements).then(() => _promiseCallback());\n                }\n                if (message) {\n                    this.proxy.$setMessage(this.viewId, this._message);\n                }\n            }));\n        }\n        get visible() { return this._visible; }\n        get selectedElements() { return this._selectedHandles.map(handle => this.getExtensionElement(handle)).filter(element => !types_1.isUndefinedOrNull(element)); }\n        getChildren(parentHandle) {\n            const parentElement = parentHandle ? this.getExtensionElement(parentHandle) : undefined;\n            if (parentHandle && !parentElement) {\n                console.error(`No tree item with id \\'${parentHandle}\\' found.`);\n                return Promise.resolve([]);\n            }\n            const childrenNodes = this.getChildrenNodes(parentHandle); // Get it from cache\n            return (childrenNodes ? Promise.resolve(childrenNodes) : this.fetchChildrenNodes(parentElement))\n                .then(nodes => nodes.map(n => n.item));\n        }\n        getExtensionElement(treeItemHandle) {\n            return this.elements.get(treeItemHandle);\n        }\n        reveal(element, options) {\n            options = options ? options : { select: true, focus: false };\n            const select = types_1.isUndefinedOrNull(options.select) ? true : options.select;\n            const focus = types_1.isUndefinedOrNull(options.focus) ? false : options.focus;\n            const expand = types_1.isUndefinedOrNull(options.expand) ? false : options.expand;\n            if (typeof this.dataProvider.getParent !== 'function') {\n                return Promise.reject(new Error(`Required registered TreeDataProvider to implement 'getParent' method to access 'reveal' method`));\n            }\n            return this.refreshPromise\n                .then(() => this.resolveUnknownParentChain(element))\n                .then(parentChain => this.resolveTreeNode(element, parentChain[parentChain.length - 1])\n                .then(treeNode => this.proxy.$reveal(this.viewId, treeNode.item, parentChain.map(p => p.item), { select, focus, expand })), error => this.logService.error(error));\n        }\n        get message() {\n            return this._message;\n        }\n        set message(message) {\n            this._message = message;\n            this._onDidChangeData.fire({ message: true, element: false });\n        }\n        setExpanded(treeItemHandle, expanded) {\n            const element = this.getExtensionElement(treeItemHandle);\n            if (element) {\n                if (expanded) {\n                    this._onDidExpandElement.fire(Object.freeze({ element }));\n                }\n                else {\n                    this._onDidCollapseElement.fire(Object.freeze({ element }));\n                }\n            }\n        }\n        setSelection(treeItemHandles) {\n            if (!arrays_1.equals(this._selectedHandles, treeItemHandles)) {\n                this._selectedHandles = treeItemHandles;\n                this._onDidChangeSelection.fire(Object.freeze({ selection: this.selectedElements }));\n            }\n        }\n        setVisible(visible) {\n            if (visible !== this._visible) {\n                this._visible = visible;\n                this._onDidChangeVisibility.fire(Object.freeze({ visible: this._visible }));\n            }\n        }\n        resolveUnknownParentChain(element) {\n            return this.resolveParent(element)\n                .then((parent) => {\n                if (!parent) {\n                    return Promise.resolve([]);\n                }\n                return this.resolveUnknownParentChain(parent)\n                    .then(result => this.resolveTreeNode(parent, result[result.length - 1])\n                    .then(parentNode => {\n                    result.push(parentNode);\n                    return result;\n                }));\n            });\n        }\n        resolveParent(element) {\n            const node = this.nodes.get(element);\n            if (node) {\n                return Promise.resolve(node.parent ? this.elements.get(node.parent.item.handle) : undefined);\n            }\n            return async_1.asPromise(() => this.dataProvider.getParent(element));\n        }\n        resolveTreeNode(element, parent) {\n            const node = this.nodes.get(element);\n            if (node) {\n                return Promise.resolve(node);\n            }\n            return async_1.asPromise(() => this.dataProvider.getTreeItem(element))\n                .then(extTreeItem => this.createHandle(element, extTreeItem, parent, true))\n                .then(handle => this.getChildren(parent ? parent.item.handle : undefined)\n                .then(() => {\n                const cachedElement = this.getExtensionElement(handle);\n                if (cachedElement) {\n                    const node = this.nodes.get(cachedElement);\n                    if (node) {\n                        return Promise.resolve(node);\n                    }\n                }\n                throw new Error(`Cannot resolve tree item for element ${handle}`);\n            }));\n        }\n        getChildrenNodes(parentNodeOrHandle) {\n            if (parentNodeOrHandle) {\n                let parentNode;\n                if (typeof parentNodeOrHandle === 'string') {\n                    const parentElement = this.getExtensionElement(parentNodeOrHandle);\n                    parentNode = parentElement ? this.nodes.get(parentElement) : undefined;\n                }\n                else {\n                    parentNode = parentNodeOrHandle;\n                }\n                return parentNode ? parentNode.children || null : null;\n            }\n            return this.roots;\n        }\n        fetchChildrenNodes(parentElement) {\n            // clear children cache\n            this.clearChildren(parentElement);\n            const parentNode = parentElement ? this.nodes.get(parentElement) : undefined;\n            return async_1.asPromise(() => this.dataProvider.getChildren(parentElement))\n                .then(elements => Promise.all(arrays_1.coalesce(elements || [])\n                .map(element => async_1.asPromise(() => this.dataProvider.getTreeItem(element))\n                .then(extTreeItem => extTreeItem ? this.createAndRegisterTreeNode(element, extTreeItem, parentNode) : null))))\n                .then(arrays_1.coalesce);\n        }\n        refresh(elements) {\n            const hasRoot = elements.some(element => !element);\n            if (hasRoot) {\n                this.clearAll(); // clear cache\n                return this.proxy.$refresh(this.viewId);\n            }\n            else {\n                const handlesToRefresh = this.getHandlesToRefresh(elements);\n                if (handlesToRefresh.length) {\n                    return this.refreshHandles(handlesToRefresh);\n                }\n            }\n            return Promise.resolve(undefined);\n        }\n        getHandlesToRefresh(elements) {\n            const elementsToUpdate = new Set();\n            for (const element of elements) {\n                const elementNode = this.nodes.get(element);\n                if (elementNode && !elementsToUpdate.has(elementNode.item.handle)) {\n                    // check if an ancestor of extElement is already in the elements to update list\n                    let currentNode = elementNode;\n                    while (currentNode && currentNode.parent && !elementsToUpdate.has(currentNode.parent.item.handle)) {\n                        const parentElement = this.elements.get(currentNode.parent.item.handle);\n                        currentNode = parentElement ? this.nodes.get(parentElement) : undefined;\n                    }\n                    if (currentNode && !currentNode.parent) {\n                        elementsToUpdate.add(elementNode.item.handle);\n                    }\n                }\n            }\n            const handlesToUpdate = [];\n            // Take only top level elements\n            elementsToUpdate.forEach((handle) => {\n                const element = this.elements.get(handle);\n                if (element) {\n                    const node = this.nodes.get(element);\n                    if (node && (!node.parent || !elementsToUpdate.has(node.parent.item.handle))) {\n                        handlesToUpdate.push(handle);\n                    }\n                }\n            });\n            return handlesToUpdate;\n        }\n        refreshHandles(itemHandles) {\n            const itemsToRefresh = {};\n            return Promise.all(itemHandles.map(treeItemHandle => this.refreshNode(treeItemHandle)\n                .then(node => {\n                if (node) {\n                    itemsToRefresh[treeItemHandle] = node.item;\n                }\n            })))\n                .then(() => Object.keys(itemsToRefresh).length ? this.proxy.$refresh(this.viewId, itemsToRefresh) : undefined);\n        }\n        refreshNode(treeItemHandle) {\n            const extElement = this.getExtensionElement(treeItemHandle);\n            if (extElement) {\n                const existing = this.nodes.get(extElement);\n                if (existing) {\n                    this.clearChildren(extElement); // clear children cache\n                    return async_1.asPromise(() => this.dataProvider.getTreeItem(extElement))\n                        .then(extTreeItem => {\n                        if (extTreeItem) {\n                            const newNode = this.createTreeNode(extElement, extTreeItem, existing.parent);\n                            this.updateNodeCache(extElement, newNode, existing, existing.parent);\n                            return newNode;\n                        }\n                        return null;\n                    });\n                }\n            }\n            return Promise.resolve(null);\n        }\n        createAndRegisterTreeNode(element, extTreeItem, parentNode) {\n            const node = this.createTreeNode(element, extTreeItem, parentNode);\n            if (extTreeItem.id && this.elements.has(node.item.handle)) {\n                throw new Error(nls_1.localize('treeView.duplicateElement', 'Element with id {0} is already registered', extTreeItem.id));\n            }\n            this.addNodeToCache(element, node);\n            this.addNodeToParentCache(node, parentNode);\n            return node;\n        }\n        createTreeNode(element, extensionTreeItem, parent) {\n            return {\n                item: this.createTreeItem(element, extensionTreeItem, parent),\n                parent,\n                children: undefined\n            };\n        }\n        createTreeItem(element, extensionTreeItem, parent) {\n            const handle = this.createHandle(element, extensionTreeItem, parent);\n            const icon = this.getLightIconPath(extensionTreeItem);\n            const item = {\n                handle,\n                parentHandle: parent ? parent.item.handle : undefined,\n                label: toTreeItemLabel(extensionTreeItem.label, this.extension),\n                description: extensionTreeItem.description,\n                resourceUri: extensionTreeItem.resourceUri,\n                tooltip: typeof extensionTreeItem.tooltip === 'string' ? extensionTreeItem.tooltip : undefined,\n                command: extensionTreeItem.command ? this.commands.toInternal(extensionTreeItem.command) : undefined,\n                contextValue: extensionTreeItem.contextValue,\n                icon,\n                iconDark: this.getDarkIconPath(extensionTreeItem) || icon,\n                themeIcon: extensionTreeItem.iconPath instanceof extHostTypes_1.ThemeIcon ? { id: extensionTreeItem.iconPath.id } : undefined,\n                collapsibleState: types_1.isUndefinedOrNull(extensionTreeItem.collapsibleState) ? extHostTypes_1.TreeItemCollapsibleState.None : extensionTreeItem.collapsibleState\n            };\n            return item;\n        }\n        createHandle(element, { id, label, resourceUri }, parent, returnFirst) {\n            if (id) {\n                return `${ExtHostTreeView.ID_HANDLE_PREFIX}/${id}`;\n            }\n            const treeItemLabel = toTreeItemLabel(label, this.extension);\n            const prefix = parent ? parent.item.handle : ExtHostTreeView.LABEL_HANDLE_PREFIX;\n            let elementId = treeItemLabel ? treeItemLabel.label : resourceUri ? resources_1.basename(resourceUri) : '';\n            elementId = elementId.indexOf('/') !== -1 ? elementId.replace('/', '//') : elementId;\n            const existingHandle = this.nodes.has(element) ? this.nodes.get(element).item.handle : undefined;\n            const childrenNodes = (this.getChildrenNodes(parent) || []);\n            let handle;\n            let counter = 0;\n            do {\n                handle = `${prefix}/${counter}:${elementId}`;\n                if (returnFirst || !this.elements.has(handle) || existingHandle === handle) {\n                    // Return first if asked for or\n                    // Return if handle does not exist or\n                    // Return if handle is being reused\n                    break;\n                }\n                counter++;\n            } while (counter <= childrenNodes.length);\n            return handle;\n        }\n        getLightIconPath(extensionTreeItem) {\n            if (extensionTreeItem.iconPath && !(extensionTreeItem.iconPath instanceof extHostTypes_1.ThemeIcon)) {\n                if (typeof extensionTreeItem.iconPath === 'string'\n                    || extensionTreeItem.iconPath instanceof uri_1.URI) {\n                    return this.getIconPath(extensionTreeItem.iconPath);\n                }\n                return this.getIconPath(extensionTreeItem.iconPath['light']);\n            }\n            return undefined;\n        }\n        getDarkIconPath(extensionTreeItem) {\n            if (extensionTreeItem.iconPath && !(extensionTreeItem.iconPath instanceof extHostTypes_1.ThemeIcon) && extensionTreeItem.iconPath['dark']) {\n                return this.getIconPath(extensionTreeItem.iconPath['dark']);\n            }\n            return undefined;\n        }\n        getIconPath(iconPath) {\n            if (iconPath instanceof uri_1.URI) {\n                return iconPath;\n            }\n            return uri_1.URI.file(iconPath);\n        }\n        addNodeToCache(element, node) {\n            this.elements.set(node.item.handle, element);\n            this.nodes.set(element, node);\n        }\n        updateNodeCache(element, newNode, existing, parentNode) {\n            // Remove from the cache\n            this.elements.delete(newNode.item.handle);\n            this.nodes.delete(element);\n            if (newNode.item.handle !== existing.item.handle) {\n                this.elements.delete(existing.item.handle);\n            }\n            // Add the new node to the cache\n            this.addNodeToCache(element, newNode);\n            // Replace the node in parent's children nodes\n            const childrenNodes = (this.getChildrenNodes(parentNode) || []);\n            const childNode = childrenNodes.filter(c => c.item.handle === existing.item.handle)[0];\n            if (childNode) {\n                childrenNodes.splice(childrenNodes.indexOf(childNode), 1, newNode);\n            }\n        }\n        addNodeToParentCache(node, parentNode) {\n            if (parentNode) {\n                if (!parentNode.children) {\n                    parentNode.children = [];\n                }\n                parentNode.children.push(node);\n            }\n            else {\n                if (!this.roots) {\n                    this.roots = [];\n                }\n                this.roots.push(node);\n            }\n        }\n        clearChildren(parentElement) {\n            if (parentElement) {\n                const node = this.nodes.get(parentElement);\n                if (node) {\n                    if (node.children) {\n                        for (const child of node.children) {\n                            const childEleement = this.elements.get(child.item.handle);\n                            if (childEleement) {\n                                this.clear(childEleement);\n                            }\n                        }\n                    }\n                    node.children = undefined;\n                }\n            }\n            else {\n                this.clearAll();\n            }\n        }\n        clear(element) {\n            const node = this.nodes.get(element);\n            if (node) {\n                if (node.children) {\n                    for (const child of node.children) {\n                        const childEleement = this.elements.get(child.item.handle);\n                        if (childEleement) {\n                            this.clear(childEleement);\n                        }\n                    }\n                }\n                this.nodes.delete(element);\n                this.elements.delete(node.item.handle);\n            }\n        }\n        clearAll() {\n            this.roots = null;\n            this.elements.clear();\n            this.nodes.clear();\n        }\n        dispose() {\n            this.clearAll();\n        }\n    }\n    ExtHostTreeView.LABEL_HANDLE_PREFIX = '0';\n    ExtHostTreeView.ID_HANDLE_PREFIX = '1';\n});\n",null]}