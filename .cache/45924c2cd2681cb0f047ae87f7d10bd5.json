{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostWorkspace.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostWorkspace.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/path\", \"vs/base/common/arrays\", \"vs/base/common/cancellation\", \"vs/base/common/event\", \"vs/base/common/map\", \"vs/base/common/platform\", \"vs/base/common/resources\", \"vs/base/common/strings\", \"vs/base/common/uri\", \"vs/nls\", \"vs/platform/notification/common/notification\", \"vs/workbench/services/search/common/search\", \"vs/platform/workspace/common/workspace\", \"vs/workbench/api/node/extHostTypes\", \"../common/extHost.protocol\", \"vs/base/common/async\"], function (require, exports, path_1, arrays_1, cancellation_1, event_1, map_1, platform_1, resources_1, strings_1, uri_1, nls_1, notification_1, search_1, workspace_1, extHostTypes_1, extHost_protocol_1, async_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isFolderEqual(folderA, folderB) {\n        return resources_1.isEqual(folderA, folderB, !platform_1.isLinux);\n    }\n    function compareWorkspaceFolderByUri(a, b) {\n        return isFolderEqual(a.uri, b.uri) ? 0 : strings_1.compare(a.uri.toString(), b.uri.toString());\n    }\n    function compareWorkspaceFolderByUriAndNameAndIndex(a, b) {\n        if (a.index !== b.index) {\n            return a.index < b.index ? -1 : 1;\n        }\n        return isFolderEqual(a.uri, b.uri) ? strings_1.compare(a.name, b.name) : strings_1.compare(a.uri.toString(), b.uri.toString());\n    }\n    function delta(oldFolders, newFolders, compare) {\n        const oldSortedFolders = oldFolders.slice(0).sort(compare);\n        const newSortedFolders = newFolders.slice(0).sort(compare);\n        return arrays_1.delta(oldSortedFolders, newSortedFolders, compare);\n    }\n    class ExtHostWorkspaceImpl extends workspace_1.Workspace {\n        constructor(id, _name, folders) {\n            super(id, folders.map(f => new workspace_1.WorkspaceFolder(f)));\n            this._name = _name;\n            this._workspaceFolders = [];\n            this._structure = map_1.TernarySearchTree.forPaths();\n            // setup the workspace folder data structure\n            folders.forEach(folder => {\n                this._workspaceFolders.push(folder);\n                this._structure.set(folder.uri.toString(), folder);\n            });\n        }\n        static toExtHostWorkspace(data, previousConfirmedWorkspace, previousUnconfirmedWorkspace) {\n            if (!data) {\n                return { workspace: null, added: [], removed: [] };\n            }\n            const { id, name, folders } = data;\n            const newWorkspaceFolders = [];\n            // If we have an existing workspace, we try to find the folders that match our\n            // data and update their properties. It could be that an extension stored them\n            // for later use and we want to keep them \"live\" if they are still present.\n            const oldWorkspace = previousConfirmedWorkspace;\n            if (previousConfirmedWorkspace) {\n                folders.forEach((folderData, index) => {\n                    const folderUri = uri_1.URI.revive(folderData.uri);\n                    const existingFolder = ExtHostWorkspaceImpl._findFolder(previousUnconfirmedWorkspace || previousConfirmedWorkspace, folderUri);\n                    if (existingFolder) {\n                        existingFolder.name = folderData.name;\n                        existingFolder.index = folderData.index;\n                        newWorkspaceFolders.push(existingFolder);\n                    }\n                    else {\n                        newWorkspaceFolders.push({ uri: folderUri, name: folderData.name, index });\n                    }\n                });\n            }\n            else {\n                newWorkspaceFolders.push(...folders.map(({ uri, name, index }) => ({ uri: uri_1.URI.revive(uri), name, index })));\n            }\n            // make sure to restore sort order based on index\n            newWorkspaceFolders.sort((f1, f2) => f1.index < f2.index ? -1 : 1);\n            const workspace = new ExtHostWorkspaceImpl(id, name, newWorkspaceFolders);\n            const { added, removed } = delta(oldWorkspace ? oldWorkspace.workspaceFolders : [], workspace.workspaceFolders, compareWorkspaceFolderByUri);\n            return { workspace, added, removed };\n        }\n        static _findFolder(workspace, folderUriToFind) {\n            for (let i = 0; i < workspace.folders.length; i++) {\n                const folder = workspace.workspaceFolders[i];\n                if (isFolderEqual(folder.uri, folderUriToFind)) {\n                    return folder;\n                }\n            }\n            return undefined;\n        }\n        get name() {\n            return this._name;\n        }\n        get workspaceFolders() {\n            return this._workspaceFolders.slice(0);\n        }\n        getWorkspaceFolder(uri, resolveParent) {\n            if (resolveParent && this._structure.get(uri.toString())) {\n                // `uri` is a workspace folder so we check for its parent\n                uri = resources_1.dirname(uri);\n            }\n            return this._structure.findSubstr(uri.toString());\n        }\n        resolveWorkspaceFolder(uri) {\n            return this._structure.get(uri.toString());\n        }\n    }\n    class ExtHostWorkspace {\n        constructor(mainContext, logService, requestIdProvider, data) {\n            this._onDidChangeWorkspace = new event_1.Emitter();\n            this.onDidChangeWorkspace = this._onDidChangeWorkspace.event;\n            this._activeSearchCallbacks = [];\n            this._logService = logService;\n            this._requestIdProvider = requestIdProvider;\n            this._barrier = new async_1.Barrier();\n            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadWorkspace);\n            this._messageService = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadMessageService);\n            this._confirmedWorkspace = data ? new ExtHostWorkspaceImpl(data.id, data.name, []) : undefined;\n        }\n        $initializeWorkspace(data) {\n            this.$acceptWorkspaceData(data);\n            this._barrier.open();\n        }\n        waitForInitializeCall() {\n            return this._barrier.wait();\n        }\n        // --- workspace ---\n        get workspace() {\n            return this._actualWorkspace;\n        }\n        get name() {\n            return this._actualWorkspace ? this._actualWorkspace.name : undefined;\n        }\n        get _actualWorkspace() {\n            return this._unconfirmedWorkspace || this._confirmedWorkspace;\n        }\n        getWorkspaceFolders() {\n            if (!this._actualWorkspace) {\n                return undefined;\n            }\n            return this._actualWorkspace.workspaceFolders.slice(0);\n        }\n        getWorkspaceFolders2() {\n            return __awaiter(this, void 0, void 0, function* () {\n                yield this._barrier.wait();\n                if (!this._actualWorkspace) {\n                    return undefined;\n                }\n                return this._actualWorkspace.workspaceFolders.slice(0);\n            });\n        }\n        updateWorkspaceFolders(extension, index, deleteCount, ...workspaceFoldersToAdd) {\n            const validatedDistinctWorkspaceFoldersToAdd = [];\n            if (Array.isArray(workspaceFoldersToAdd)) {\n                workspaceFoldersToAdd.forEach(folderToAdd => {\n                    if (uri_1.URI.isUri(folderToAdd.uri) && !validatedDistinctWorkspaceFoldersToAdd.some(f => isFolderEqual(f.uri, folderToAdd.uri))) {\n                        validatedDistinctWorkspaceFoldersToAdd.push({ uri: folderToAdd.uri, name: folderToAdd.name || resources_1.basenameOrAuthority(folderToAdd.uri) });\n                    }\n                });\n            }\n            if (!!this._unconfirmedWorkspace) {\n                return false; // prevent accumulated calls without a confirmed workspace\n            }\n            if ([index, deleteCount].some(i => typeof i !== 'number' || i < 0)) {\n                return false; // validate numbers\n            }\n            if (deleteCount === 0 && validatedDistinctWorkspaceFoldersToAdd.length === 0) {\n                return false; // nothing to delete or add\n            }\n            const currentWorkspaceFolders = this._actualWorkspace ? this._actualWorkspace.workspaceFolders : [];\n            if (index + deleteCount > currentWorkspaceFolders.length) {\n                return false; // cannot delete more than we have\n            }\n            // Simulate the updateWorkspaceFolders method on our data to do more validation\n            const newWorkspaceFolders = currentWorkspaceFolders.slice(0);\n            newWorkspaceFolders.splice(index, deleteCount, ...validatedDistinctWorkspaceFoldersToAdd.map(f => ({ uri: f.uri, name: f.name || resources_1.basenameOrAuthority(f.uri), index: undefined /* fixed later */ })));\n            for (let i = 0; i < newWorkspaceFolders.length; i++) {\n                const folder = newWorkspaceFolders[i];\n                if (newWorkspaceFolders.some((otherFolder, index) => index !== i && isFolderEqual(folder.uri, otherFolder.uri))) {\n                    return false; // cannot add the same folder multiple times\n                }\n            }\n            newWorkspaceFolders.forEach((f, index) => f.index = index); // fix index\n            const { added, removed } = delta(currentWorkspaceFolders, newWorkspaceFolders, compareWorkspaceFolderByUriAndNameAndIndex);\n            if (added.length === 0 && removed.length === 0) {\n                return false; // nothing actually changed\n            }\n            // Trigger on main side\n            if (this._proxy) {\n                const extName = extension.displayName || extension.name;\n                this._proxy.$updateWorkspaceFolders(extName, index, deleteCount, validatedDistinctWorkspaceFoldersToAdd).then(undefined, error => {\n                    // in case of an error, make sure to clear out the unconfirmed workspace\n                    // because we cannot expect the acknowledgement from the main side for this\n                    this._unconfirmedWorkspace = undefined;\n                    // show error to user\n                    this._messageService.$showMessage(notification_1.Severity.Error, nls_1.localize('updateerror', \"Extension '{0}' failed to update workspace folders: {1}\", extName, error), { extension }, []);\n                });\n            }\n            // Try to accept directly\n            this.trySetWorkspaceFolders(newWorkspaceFolders);\n            return true;\n        }\n        getWorkspaceFolder(uri, resolveParent) {\n            if (!this._actualWorkspace) {\n                return undefined;\n            }\n            return this._actualWorkspace.getWorkspaceFolder(uri, resolveParent);\n        }\n        getWorkspaceFolder2(uri, resolveParent) {\n            return __awaiter(this, void 0, void 0, function* () {\n                yield this._barrier.wait();\n                if (!this._actualWorkspace) {\n                    return undefined;\n                }\n                return this._actualWorkspace.getWorkspaceFolder(uri, resolveParent);\n            });\n        }\n        resolveWorkspaceFolder(uri) {\n            return __awaiter(this, void 0, void 0, function* () {\n                yield this._barrier.wait();\n                if (!this._actualWorkspace) {\n                    return undefined;\n                }\n                return this._actualWorkspace.resolveWorkspaceFolder(uri);\n            });\n        }\n        getPath() {\n            // this is legacy from the days before having\n            // multi-root and we keep it only alive if there\n            // is just one workspace folder.\n            if (!this._actualWorkspace) {\n                return undefined;\n            }\n            const { folders } = this._actualWorkspace;\n            if (folders.length === 0) {\n                return undefined;\n            }\n            // #54483 @Joh Why are we still using fsPath?\n            return folders[0].uri.fsPath;\n        }\n        getRelativePath(pathOrUri, includeWorkspace) {\n            let resource;\n            let path = '';\n            if (typeof pathOrUri === 'string') {\n                resource = uri_1.URI.file(pathOrUri);\n                path = pathOrUri;\n            }\n            else if (typeof pathOrUri !== 'undefined') {\n                resource = pathOrUri;\n                path = pathOrUri.fsPath;\n            }\n            if (!resource) {\n                return path;\n            }\n            const folder = this.getWorkspaceFolder(resource, true);\n            if (!folder) {\n                return path;\n            }\n            if (typeof includeWorkspace === 'undefined' && this._actualWorkspace) {\n                includeWorkspace = this._actualWorkspace.folders.length > 1;\n            }\n            let result = resources_1.relativePath(folder.uri, resource);\n            if (includeWorkspace && folder.name) {\n                result = `${folder.name}/${result}`;\n            }\n            return result;\n        }\n        trySetWorkspaceFolders(folders) {\n            // Update directly here. The workspace is unconfirmed as long as we did not get an\n            // acknowledgement from the main side (via $acceptWorkspaceData)\n            if (this._actualWorkspace) {\n                this._unconfirmedWorkspace = ExtHostWorkspaceImpl.toExtHostWorkspace({\n                    id: this._actualWorkspace.id,\n                    name: this._actualWorkspace.name,\n                    configuration: this._actualWorkspace.configuration,\n                    folders\n                }, this._actualWorkspace).workspace || undefined;\n            }\n        }\n        $acceptWorkspaceData(data) {\n            const { workspace, added, removed } = ExtHostWorkspaceImpl.toExtHostWorkspace(data, this._confirmedWorkspace, this._unconfirmedWorkspace);\n            // Update our workspace object. We have a confirmed workspace, so we drop our\n            // unconfirmed workspace.\n            this._confirmedWorkspace = workspace || undefined;\n            this._unconfirmedWorkspace = undefined;\n            // Events\n            this._onDidChangeWorkspace.fire(Object.freeze({\n                added,\n                removed,\n            }));\n        }\n        // --- search ---\n        findFiles(include, exclude, maxResults, extensionId, token = cancellation_1.CancellationToken.None) {\n            this._logService.trace(`extHostWorkspace#findFiles: fileSearch, extension: ${extensionId.value}, entryPoint: findFiles`);\n            let includePattern;\n            let includeFolder;\n            if (include) {\n                if (typeof include === 'string') {\n                    includePattern = include;\n                }\n                else {\n                    includePattern = include.pattern;\n                    // include.base must be an absolute path\n                    includeFolder = include.baseFolder || uri_1.URI.file(include.base);\n                }\n            }\n            let excludePatternOrDisregardExcludes = undefined;\n            if (exclude === null) {\n                excludePatternOrDisregardExcludes = false;\n            }\n            else if (exclude) {\n                if (typeof exclude === 'string') {\n                    excludePatternOrDisregardExcludes = exclude;\n                }\n                else {\n                    excludePatternOrDisregardExcludes = exclude.pattern;\n                }\n            }\n            if (token && token.isCancellationRequested) {\n                return Promise.resolve([]);\n            }\n            return this._proxy.$startFileSearch(includePattern, includeFolder, excludePatternOrDisregardExcludes, maxResults, token)\n                .then(data => Array.isArray(data) ? data.map(uri_1.URI.revive) : []);\n        }\n        findTextInFiles(query, options, callback, extensionId, token = cancellation_1.CancellationToken.None) {\n            this._logService.trace(`extHostWorkspace#findTextInFiles: textSearch, extension: ${extensionId.value}, entryPoint: findTextInFiles`);\n            const requestId = this._requestIdProvider.getNext();\n            const globPatternToString = (pattern) => {\n                if (typeof pattern === 'string') {\n                    return pattern;\n                }\n                return path_1.join(pattern.base, pattern.pattern);\n            };\n            const previewOptions = typeof options.previewOptions === 'undefined' ?\n                {\n                    matchLines: 100,\n                    charsPerLine: 10000\n                } :\n                options.previewOptions;\n            const queryOptions = {\n                ignoreSymlinks: typeof options.followSymlinks === 'boolean' ? !options.followSymlinks : undefined,\n                disregardIgnoreFiles: typeof options.useIgnoreFiles === 'boolean' ? !options.useIgnoreFiles : undefined,\n                disregardGlobalIgnoreFiles: typeof options.useGlobalIgnoreFiles === 'boolean' ? !options.useGlobalIgnoreFiles : undefined,\n                disregardExcludeSettings: options.exclude === null,\n                fileEncoding: options.encoding,\n                maxResults: options.maxResults,\n                previewOptions,\n                afterContext: options.afterContext,\n                beforeContext: options.beforeContext,\n                includePattern: options.include && globPatternToString(options.include),\n                excludePattern: options.exclude ? globPatternToString(options.exclude) : undefined\n            };\n            const isCanceled = false;\n            this._activeSearchCallbacks[requestId] = p => {\n                if (isCanceled) {\n                    return;\n                }\n                const uri = uri_1.URI.revive(p.resource);\n                p.results.forEach(result => {\n                    if (search_1.resultIsMatch(result)) {\n                        callback({\n                            uri,\n                            preview: {\n                                text: result.preview.text,\n                                matches: arrays_1.mapArrayOrNot(result.preview.matches, m => new extHostTypes_1.Range(m.startLineNumber, m.startColumn, m.endLineNumber, m.endColumn))\n                            },\n                            ranges: arrays_1.mapArrayOrNot(result.ranges, r => new extHostTypes_1.Range(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn))\n                        });\n                    }\n                    else {\n                        callback({\n                            uri,\n                            text: result.text,\n                            lineNumber: result.lineNumber\n                        });\n                    }\n                });\n            };\n            if (token.isCancellationRequested) {\n                return Promise.resolve(undefined);\n            }\n            return this._proxy.$startTextSearch(query, queryOptions, requestId, token).then(result => {\n                delete this._activeSearchCallbacks[requestId];\n                return result;\n            }, err => {\n                delete this._activeSearchCallbacks[requestId];\n                return Promise.reject(err);\n            });\n        }\n        $handleTextSearchResult(result, requestId) {\n            if (this._activeSearchCallbacks[requestId]) {\n                this._activeSearchCallbacks[requestId](result);\n            }\n        }\n        saveAll(includeUntitled) {\n            return this._proxy.$saveAll(includeUntitled);\n        }\n        resolveProxy(url) {\n            return this._proxy.$resolveProxy(url);\n        }\n    }\n    exports.ExtHostWorkspace = ExtHostWorkspace;\n});\n",null]}