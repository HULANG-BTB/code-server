{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/collections.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/collections.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const hasOwnProperty = Object.prototype.hasOwnProperty;\n    /**\n     * Returns an array which contains all values that reside\n     * in the given set.\n     */\n    function values(from) {\n        const result = [];\n        for (let key in from) {\n            if (hasOwnProperty.call(from, key)) {\n                result.push(from[key]);\n            }\n        }\n        return result;\n    }\n    exports.values = values;\n    function size(from) {\n        let count = 0;\n        for (let key in from) {\n            if (hasOwnProperty.call(from, key)) {\n                count += 1;\n            }\n        }\n        return count;\n    }\n    exports.size = size;\n    function first(from) {\n        for (let key in from) {\n            if (hasOwnProperty.call(from, key)) {\n                return from[key];\n            }\n        }\n        return undefined;\n    }\n    exports.first = first;\n    /**\n     * Iterates over each entry in the provided set. The iterator allows\n     * to remove elements and will stop when the callback returns {{false}}.\n     */\n    function forEach(from, callback) {\n        for (let key in from) {\n            if (hasOwnProperty.call(from, key)) {\n                const result = callback({ key: key, value: from[key] }, function () {\n                    delete from[key];\n                });\n                if (result === false) {\n                    return;\n                }\n            }\n        }\n    }\n    exports.forEach = forEach;\n    /**\n     * Groups the collection into a dictionary based on the provided\n     * group function.\n     */\n    function groupBy(data, groupFn) {\n        const result = Object.create(null);\n        for (const element of data) {\n            const key = groupFn(element);\n            let target = result[key];\n            if (!target) {\n                target = result[key] = [];\n            }\n            target.push(element);\n        }\n        return result;\n    }\n    exports.groupBy = groupBy;\n    function fromMap(original) {\n        const result = Object.create(null);\n        if (original) {\n            original.forEach((value, key) => {\n                result[key] = value;\n            });\n        }\n        return result;\n    }\n    exports.fromMap = fromMap;\n});\n",null]}