{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/comments/common/commentModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/comments/common/commentModel.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/uri\", \"vs/base/common/arrays\", \"vs/nls\", \"vs/base/common/map\"], function (require, exports, uri_1, arrays_1, nls_1, map_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class CommentNode {\n        constructor(threadId, resource, comment, range) {\n            this.replies = [];\n            this.threadId = threadId;\n            this.comment = comment;\n            this.resource = resource;\n            this.range = range;\n        }\n        hasReply() {\n            return this.replies && this.replies.length !== 0;\n        }\n    }\n    exports.CommentNode = CommentNode;\n    class ResourceWithCommentThreads {\n        constructor(resource, commentThreads) {\n            this.id = resource.toString();\n            this.resource = resource;\n            this.commentThreads = commentThreads.filter(thread => thread.comments.length).map(thread => ResourceWithCommentThreads.createCommentNode(resource, thread));\n        }\n        static createCommentNode(resource, commentThread) {\n            const { threadId, comments, range } = commentThread;\n            const commentNodes = comments.map(comment => new CommentNode(threadId, resource, comment, range));\n            if (commentNodes.length > 1) {\n                commentNodes[0].replies = commentNodes.slice(1, commentNodes.length);\n            }\n            return commentNodes[0];\n        }\n    }\n    exports.ResourceWithCommentThreads = ResourceWithCommentThreads;\n    class CommentsModel {\n        constructor() {\n            this.resourceCommentThreads = [];\n            this.commentThreadsMap = new Map();\n        }\n        setCommentThreads(owner, commentThreads) {\n            this.commentThreadsMap.set(owner, this.groupByResource(commentThreads));\n            this.resourceCommentThreads = arrays_1.flatten(map_1.values(this.commentThreadsMap));\n        }\n        updateCommentThreads(event) {\n            const { owner, removed, changed, added } = event;\n            let threadsForOwner = this.commentThreadsMap.get(owner) || [];\n            removed.forEach(thread => {\n                // Find resource that has the comment thread\n                const matchingResourceIndex = arrays_1.firstIndex(threadsForOwner, (resourceData) => resourceData.id === thread.resource);\n                const matchingResourceData = threadsForOwner[matchingResourceIndex];\n                // Find comment node on resource that is that thread and remove it\n                const index = arrays_1.firstIndex(matchingResourceData.commentThreads, (commentThread) => commentThread.threadId === thread.threadId);\n                matchingResourceData.commentThreads.splice(index, 1);\n                // If the comment thread was the last thread for a resource, remove that resource from the list\n                if (matchingResourceData.commentThreads.length === 0) {\n                    threadsForOwner.splice(matchingResourceIndex, 1);\n                }\n            });\n            changed.forEach(thread => {\n                // Find resource that has the comment thread\n                const matchingResourceIndex = arrays_1.firstIndex(threadsForOwner, (resourceData) => resourceData.id === thread.resource);\n                const matchingResourceData = threadsForOwner[matchingResourceIndex];\n                // Find comment node on resource that is that thread and replace it\n                const index = arrays_1.firstIndex(matchingResourceData.commentThreads, (commentThread) => commentThread.threadId === thread.threadId);\n                if (index >= 0) {\n                    matchingResourceData.commentThreads[index] = ResourceWithCommentThreads.createCommentNode(uri_1.URI.parse(matchingResourceData.id), thread);\n                }\n                else {\n                    matchingResourceData.commentThreads.push(ResourceWithCommentThreads.createCommentNode(uri_1.URI.parse(matchingResourceData.id), thread));\n                }\n            });\n            added.forEach(thread => {\n                const existingResource = threadsForOwner.filter(resourceWithThreads => resourceWithThreads.resource.toString() === thread.resource);\n                if (existingResource.length) {\n                    const resource = existingResource[0];\n                    if (thread.comments.length) {\n                        resource.commentThreads.push(ResourceWithCommentThreads.createCommentNode(resource.resource, thread));\n                    }\n                }\n                else {\n                    threadsForOwner.push(new ResourceWithCommentThreads(uri_1.URI.parse(thread.resource), [thread]));\n                }\n            });\n            this.commentThreadsMap.set(owner, threadsForOwner);\n            this.resourceCommentThreads = arrays_1.flatten(map_1.values(this.commentThreadsMap));\n            return removed.length > 0 || changed.length > 0 || added.length > 0;\n        }\n        hasCommentThreads() {\n            return !!this.resourceCommentThreads.length;\n        }\n        getMessage() {\n            if (!this.resourceCommentThreads.length) {\n                return nls_1.localize('noComments', \"There are no comments on this review.\");\n            }\n            else {\n                return '';\n            }\n        }\n        groupByResource(commentThreads) {\n            const resourceCommentThreads = [];\n            const commentThreadsByResource = new Map();\n            for (const group of arrays_1.groupBy(commentThreads, CommentsModel._compareURIs)) {\n                commentThreadsByResource.set(group[0].resource, new ResourceWithCommentThreads(uri_1.URI.parse(group[0].resource), group));\n            }\n            commentThreadsByResource.forEach((v, i, m) => {\n                resourceCommentThreads.push(v);\n            });\n            return resourceCommentThreads;\n        }\n        static _compareURIs(a, b) {\n            const resourceA = a.resource.toString();\n            const resourceB = b.resource.toString();\n            if (resourceA < resourceB) {\n                return -1;\n            }\n            else if (resourceA > resourceB) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        }\n    }\n    exports.CommentsModel = CommentsModel;\n});\n",null]}