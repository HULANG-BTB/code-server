{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/node/processRunnerDetector.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/node/processRunnerDetector.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/objects\", \"vs/base/common/path\", \"vs/base/common/processes\", \"vs/base/common/strings\", \"vs/base/node/processes\", \"vs/nls\", \"vs/platform/workspace/common/workspace\", \"../common/tasks\", \"../common/taskConfiguration\"], function (require, exports, Objects, Path, processes_1, Strings, processes_2, nls, workspace_1, Tasks, TaskConfig) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const build = 'build';\n    const test = 'test';\n    const defaultValue = 'default';\n    class RegexpTaskMatcher {\n        constructor(regExp) {\n            this.regexp = regExp;\n        }\n        init() {\n        }\n        match(tasks, line) {\n            let matches = this.regexp.exec(line);\n            if (matches && matches.length > 0) {\n                tasks.push(matches[1]);\n            }\n        }\n    }\n    class GruntTaskMatcher {\n        init() {\n            this.tasksStart = false;\n            this.tasksEnd = false;\n            this.descriptionOffset = null;\n        }\n        match(tasks, line) {\n            // grunt lists tasks as follows (description is wrapped into a new line if too long):\n            // ...\n            // Available tasks\n            //         uglify  Minify files with UglifyJS. *\n            //         jshint  Validate files with JSHint. *\n            //           test  Alias for \"jshint\", \"qunit\" tasks.\n            //        default  Alias for \"jshint\", \"qunit\", \"concat\", \"uglify\" tasks.\n            //           long  Alias for \"eslint\", \"qunit\", \"browserify\", \"sass\",\n            //                 \"autoprefixer\", \"uglify\", tasks.\n            //\n            // Tasks run in the order specified\n            if (!this.tasksStart && !this.tasksEnd) {\n                if (line.indexOf('Available tasks') === 0) {\n                    this.tasksStart = true;\n                }\n            }\n            else if (this.tasksStart && !this.tasksEnd) {\n                if (line.indexOf('Tasks run in the order specified') === 0) {\n                    this.tasksEnd = true;\n                }\n                else {\n                    if (this.descriptionOffset === null) {\n                        const match = line.match(/\\S  \\S/);\n                        if (match) {\n                            this.descriptionOffset = (match.index || 0) + 1;\n                        }\n                        else {\n                            this.descriptionOffset = 0;\n                        }\n                    }\n                    let taskName = line.substr(0, this.descriptionOffset).trim();\n                    if (taskName.length > 0) {\n                        tasks.push(taskName);\n                    }\n                }\n            }\n        }\n    }\n    class ProcessRunnerDetector {\n        constructor(workspaceFolder, fileService, contextService, configurationResolverService, config = null) {\n            this.fileService = fileService;\n            this.contextService = contextService;\n            this.configurationResolverService = configurationResolverService;\n            this.taskConfiguration = config;\n            this._workspaceRoot = workspaceFolder;\n            this._stderr = [];\n            this._stdout = [];\n            this._cwd = this.contextService.getWorkbenchState() !== workspace_1.WorkbenchState.EMPTY ? Path.normalize(this._workspaceRoot.uri.fsPath) : '';\n        }\n        static supports(runner) {\n            return ProcessRunnerDetector.SupportedRunners[runner];\n        }\n        static detectorConfig(runner) {\n            return ProcessRunnerDetector.TaskMatchers[runner];\n        }\n        get stderr() {\n            return this._stderr;\n        }\n        get stdout() {\n            return this._stdout;\n        }\n        detect(list = false, detectSpecific) {\n            let commandExecutable;\n            if (this.taskConfiguration && this.taskConfiguration.command && (commandExecutable = TaskConfig.CommandString.value(this.taskConfiguration.command)) && ProcessRunnerDetector.supports(commandExecutable)) {\n                let config = ProcessRunnerDetector.detectorConfig(commandExecutable);\n                let args = (this.taskConfiguration.args || []).concat(config.arg);\n                let options = this.taskConfiguration.options ? this.resolveCommandOptions(this._workspaceRoot, this.taskConfiguration.options) : { cwd: this._cwd };\n                let isShellCommand = !!this.taskConfiguration.isShellCommand;\n                return Promise.resolve(this.runDetection(new processes_2.LineProcess(commandExecutable, this.configurationResolverService.resolve(this._workspaceRoot, args.map(a => TaskConfig.CommandString.value(a))), isShellCommand, options), commandExecutable, isShellCommand, config.matcher, ProcessRunnerDetector.DefaultProblemMatchers, list));\n            }\n            else {\n                if (detectSpecific) {\n                    let detectorPromise;\n                    if ('gulp' === detectSpecific) {\n                        detectorPromise = this.tryDetectGulp(this._workspaceRoot, list);\n                    }\n                    else if ('jake' === detectSpecific) {\n                        detectorPromise = this.tryDetectJake(this._workspaceRoot, list);\n                    }\n                    else if ('grunt' === detectSpecific) {\n                        detectorPromise = this.tryDetectGrunt(this._workspaceRoot, list);\n                    }\n                    else {\n                        throw new Error('Unkown detector type');\n                    }\n                    return detectorPromise.then((value) => {\n                        if (value) {\n                            return value;\n                        }\n                        else {\n                            return { config: null, stdout: this.stdout, stderr: this.stderr };\n                        }\n                    });\n                }\n                else {\n                    return this.tryDetectGulp(this._workspaceRoot, list).then((value) => {\n                        if (value) {\n                            return value;\n                        }\n                        return this.tryDetectJake(this._workspaceRoot, list).then((value) => {\n                            if (value) {\n                                return value;\n                            }\n                            return this.tryDetectGrunt(this._workspaceRoot, list).then((value) => {\n                                if (value) {\n                                    return value;\n                                }\n                                return { config: null, stdout: this.stdout, stderr: this.stderr };\n                            });\n                        });\n                    });\n                }\n            }\n        }\n        resolveCommandOptions(workspaceFolder, options) {\n            // TODO@Dirk adopt new configuration resolver service https://github.com/Microsoft/vscode/issues/31365\n            let result = Objects.deepClone(options);\n            if (result.cwd) {\n                result.cwd = this.configurationResolverService.resolve(workspaceFolder, result.cwd);\n            }\n            if (result.env) {\n                result.env = this.configurationResolverService.resolve(workspaceFolder, result.env);\n            }\n            return result;\n        }\n        tryDetectGulp(workspaceFolder, list) {\n            return Promise.resolve(this.fileService.resolveFile(workspaceFolder.toResource('gulpfile.js'))).then((stat) => {\n                let config = ProcessRunnerDetector.detectorConfig('gulp');\n                let process = new processes_2.LineProcess('gulp', [config.arg, '--no-color'], true, { cwd: this._cwd });\n                return this.runDetection(process, 'gulp', true, config.matcher, ProcessRunnerDetector.DefaultProblemMatchers, list);\n            }, (err) => {\n                return null;\n            });\n        }\n        tryDetectGrunt(workspaceFolder, list) {\n            return Promise.resolve(this.fileService.resolveFile(workspaceFolder.toResource('Gruntfile.js'))).then((stat) => {\n                let config = ProcessRunnerDetector.detectorConfig('grunt');\n                let process = new processes_2.LineProcess('grunt', [config.arg, '--no-color'], true, { cwd: this._cwd });\n                return this.runDetection(process, 'grunt', true, config.matcher, ProcessRunnerDetector.DefaultProblemMatchers, list);\n            }, (err) => {\n                return null;\n            });\n        }\n        tryDetectJake(workspaceFolder, list) {\n            let run = () => {\n                let config = ProcessRunnerDetector.detectorConfig('jake');\n                let process = new processes_2.LineProcess('jake', [config.arg], true, { cwd: this._cwd });\n                return this.runDetection(process, 'jake', true, config.matcher, ProcessRunnerDetector.DefaultProblemMatchers, list);\n            };\n            return Promise.resolve(this.fileService.resolveFile(workspaceFolder.toResource('Jakefile'))).then((stat) => {\n                return run();\n            }, (err) => {\n                return this.fileService.resolveFile(workspaceFolder.toResource('Jakefile.js')).then((stat) => {\n                    return run();\n                }, (err) => {\n                    return null;\n                });\n            });\n        }\n        runDetection(process, command, isShellCommand, matcher, problemMatchers, list) {\n            let tasks = [];\n            matcher.init();\n            const onProgress = (progress) => {\n                if (progress.source === processes_1.Source.stderr) {\n                    this._stderr.push(progress.line);\n                    return;\n                }\n                let line = Strings.removeAnsiEscapeCodes(progress.line);\n                matcher.match(tasks, line);\n            };\n            return process.start(onProgress).then((success) => {\n                if (tasks.length === 0) {\n                    if (success.cmdCode !== 0) {\n                        if (command === 'gulp') {\n                            this._stderr.push(nls.localize('TaskSystemDetector.noGulpTasks', 'Running gulp --tasks-simple didn\\'t list any tasks. Did you run npm install?'));\n                        }\n                        else if (command === 'jake') {\n                            this._stderr.push(nls.localize('TaskSystemDetector.noJakeTasks', 'Running jake --tasks didn\\'t list any tasks. Did you run npm install?'));\n                        }\n                    }\n                    return { config: null, stdout: this._stdout, stderr: this._stderr };\n                }\n                let result = {\n                    version: ProcessRunnerDetector.Version,\n                    command: command,\n                    isShellCommand: isShellCommand\n                };\n                // Hack. We need to remove this.\n                if (command === 'gulp') {\n                    result.args = ['--no-color'];\n                }\n                result.tasks = this.createTaskDescriptions(tasks, problemMatchers, list);\n                return { config: result, stdout: this._stdout, stderr: this._stderr };\n            }, (err) => {\n                let error = err.error;\n                if (error.code === 'ENOENT') {\n                    if (command === 'gulp') {\n                        this._stderr.push(nls.localize('TaskSystemDetector.noGulpProgram', 'Gulp is not installed on your system. Run npm install -g gulp to install it.'));\n                    }\n                    else if (command === 'jake') {\n                        this._stderr.push(nls.localize('TaskSystemDetector.noJakeProgram', 'Jake is not installed on your system. Run npm install -g jake to install it.'));\n                    }\n                    else if (command === 'grunt') {\n                        this._stderr.push(nls.localize('TaskSystemDetector.noGruntProgram', 'Grunt is not installed on your system. Run npm install -g grunt to install it.'));\n                    }\n                }\n                else {\n                    this._stderr.push(nls.localize('TaskSystemDetector.noProgram', 'Program {0} was not found. Message is {1}', command, error ? error.message : ''));\n                }\n                return { config: null, stdout: this._stdout, stderr: this._stderr };\n            });\n        }\n        createTaskDescriptions(tasks, problemMatchers, list) {\n            let taskConfigs = [];\n            if (list) {\n                tasks.forEach((task) => {\n                    taskConfigs.push({\n                        taskName: task,\n                        args: []\n                    });\n                });\n            }\n            else {\n                let taskInfos = {\n                    build: { index: -1, exact: -1 },\n                    test: { index: -1, exact: -1 }\n                };\n                tasks.forEach((task, index) => {\n                    this.testBuild(taskInfos.build, task, index);\n                    this.testTest(taskInfos.test, task, index);\n                });\n                if (taskInfos.build.index !== -1) {\n                    let name = tasks[taskInfos.build.index];\n                    this._stdout.push(nls.localize('TaskSystemDetector.buildTaskDetected', 'Build task named \\'{0}\\' detected.', name));\n                    taskConfigs.push({\n                        taskName: name,\n                        args: [],\n                        group: Tasks.TaskGroup.Build,\n                        problemMatcher: problemMatchers\n                    });\n                }\n                if (taskInfos.test.index !== -1) {\n                    let name = tasks[taskInfos.test.index];\n                    this._stdout.push(nls.localize('TaskSystemDetector.testTaskDetected', 'Test task named \\'{0}\\' detected.', name));\n                    taskConfigs.push({\n                        taskName: name,\n                        args: [],\n                        group: Tasks.TaskGroup.Test,\n                    });\n                }\n            }\n            return taskConfigs;\n        }\n        testBuild(taskInfo, taskName, index) {\n            if (taskName === build) {\n                taskInfo.index = index;\n                taskInfo.exact = 4;\n            }\n            else if ((Strings.startsWith(taskName, build) || Strings.endsWith(taskName, build)) && taskInfo.exact < 4) {\n                taskInfo.index = index;\n                taskInfo.exact = 3;\n            }\n            else if (taskName.indexOf(build) !== -1 && taskInfo.exact < 3) {\n                taskInfo.index = index;\n                taskInfo.exact = 2;\n            }\n            else if (taskName === defaultValue && taskInfo.exact < 2) {\n                taskInfo.index = index;\n                taskInfo.exact = 1;\n            }\n        }\n        testTest(taskInfo, taskName, index) {\n            if (taskName === test) {\n                taskInfo.index = index;\n                taskInfo.exact = 3;\n            }\n            else if ((Strings.startsWith(taskName, test) || Strings.endsWith(taskName, test)) && taskInfo.exact < 3) {\n                taskInfo.index = index;\n                taskInfo.exact = 2;\n            }\n            else if (taskName.indexOf(test) !== -1 && taskInfo.exact < 2) {\n                taskInfo.index = index;\n                taskInfo.exact = 1;\n            }\n        }\n    }\n    ProcessRunnerDetector.Version = '0.1.0';\n    ProcessRunnerDetector.SupportedRunners = {\n        'gulp': true,\n        'jake': true,\n        'grunt': true\n    };\n    ProcessRunnerDetector.TaskMatchers = {\n        'gulp': { matcher: new RegexpTaskMatcher(/^(.*)$/), arg: '--tasks-simple' },\n        'jake': { matcher: new RegexpTaskMatcher(/^jake\\s+([^\\s]+)\\s/), arg: '--tasks' },\n        'grunt': { matcher: new GruntTaskMatcher(), arg: '--help' },\n    };\n    ProcessRunnerDetector.DefaultProblemMatchers = ['$lessCompile', '$tsc', '$jshint'];\n    exports.ProcessRunnerDetector = ProcessRunnerDetector;\n});\n",null]}