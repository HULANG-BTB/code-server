{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/node/flow.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/flow.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"assert\"], function (require, exports, assert) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Executes the given function (fn) over the given array of items (list) in parallel and returns the resulting errors and results as\n     * array to the callback (callback). The resulting errors and results are evaluated by calling the provided callback function.\n     */\n    function parallel(list, fn, callback) {\n        const results = new Array(list.length);\n        const errors = new Array(list.length);\n        let didErrorOccur = false;\n        let doneCount = 0;\n        if (list.length === 0) {\n            return callback(null, []);\n        }\n        list.forEach((item, index) => {\n            fn(item, (error, result) => {\n                if (error) {\n                    didErrorOccur = true;\n                    results[index] = null;\n                    errors[index] = error;\n                }\n                else {\n                    results[index] = result;\n                    errors[index] = null;\n                }\n                if (++doneCount === list.length) {\n                    return callback(didErrorOccur ? errors : null, results);\n                }\n            });\n        });\n    }\n    exports.parallel = parallel;\n    function loop(param, fn, callback) {\n        // Assert\n        assert.ok(param, 'Missing first parameter');\n        assert.ok(typeof (fn) === 'function', 'Second parameter must be a function that is called for each element');\n        assert.ok(typeof (callback) === 'function', 'Third parameter must be a function that is called on error and success');\n        // Param is function, execute to retrieve array\n        if (typeof (param) === 'function') {\n            try {\n                param((error, result) => {\n                    if (error) {\n                        callback(error, null);\n                    }\n                    else {\n                        loop(result, fn, callback);\n                    }\n                });\n            }\n            catch (error) {\n                callback(error, null);\n            }\n        }\n        // Expect the param to be an array and loop over it\n        else {\n            const results = [];\n            const looper = function (i) {\n                // Still work to do\n                if (i < param.length) {\n                    // Execute function on array element\n                    try {\n                        fn(param[i], (error, result) => {\n                            // A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully\n                            if (error === true || error === false) {\n                                result = error;\n                                error = null;\n                            }\n                            // Quit looping on error\n                            if (error) {\n                                callback(error, null);\n                            }\n                            // Otherwise push result on stack and continue looping\n                            else {\n                                if (result) { //Could be that provided function is not returning a result\n                                    results.push(result);\n                                }\n                                process.nextTick(() => {\n                                    looper(i + 1);\n                                });\n                            }\n                        }, i, param.length);\n                    }\n                    catch (error) {\n                        callback(error, null);\n                    }\n                }\n                // Done looping, pass back results too callback function\n                else {\n                    callback(null, results);\n                }\n            };\n            // Start looping with first element in array\n            looper(0);\n        }\n    }\n    exports.loop = loop;\n    function Sequence(sequences) {\n        // Assert\n        assert.ok(sequences.length > 1, 'Need at least one error handler and one function to process sequence');\n        sequences.forEach((sequence) => {\n            assert.ok(typeof (sequence) === 'function');\n        });\n        // Execute in Loop\n        const errorHandler = sequences.splice(0, 1)[0]; //Remove error handler\n        let sequenceResult = null;\n        loop(sequences, (sequence, clb) => {\n            const sequenceFunction = function (error, result) {\n                // A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully\n                if (error === true || error === false) {\n                    result = error;\n                    error = null;\n                }\n                // Handle Error and Result\n                if (error) {\n                    clb(error, null);\n                }\n                else {\n                    sequenceResult = result; //Remember result of sequence\n                    clb(null, null); //Don't pass on result to Looper as we are not aggregating it\n                }\n            };\n            // We call the sequence function setting \"this\" to be the callback we define here\n            // and we pass in the \"sequenceResult\" as first argument. Doing all this avoids having\n            // to pass in a callback to the sequence because the callback is already \"this\".\n            try {\n                sequence.call(sequenceFunction, sequenceResult);\n            }\n            catch (error) {\n                clb(error, null);\n            }\n        }, (error, result) => {\n            if (error) {\n                errorHandler(error);\n            }\n        });\n    }\n    function sequence(sequences) {\n        Sequence((Array.isArray(sequences)) ? sequences : Array.prototype.slice.call(arguments));\n    }\n    exports.sequence = sequence;\n});\n",null]}