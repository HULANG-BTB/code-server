{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/update/electron-main/abstractUpdateService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/update/electron-main/abstractUpdateService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/event\", \"vs/base/common/async\", \"vs/platform/configuration/common/configuration\", \"vs/platform/lifecycle/electron-main/lifecycleMain\", \"vs/platform/product/node/product\", \"vs/platform/update/common/update\", \"vs/platform/environment/common/environment\", \"vs/platform/log/common/log\", \"vs/platform/request/node/request\", \"vs/base/common/cancellation\"], function (require, exports, event_1, async_1, configuration_1, lifecycleMain_1, product_1, update_1, environment_1, log_1, request_1, cancellation_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function createUpdateURL(platform, quality) {\n        return `${product_1.default.updateUrl}/api/update/${platform}/${quality}/${product_1.default.commit}`;\n    }\n    exports.createUpdateURL = createUpdateURL;\n    let AbstractUpdateService = class AbstractUpdateService {\n        constructor(lifecycleService, configurationService, environmentService, requestService, logService) {\n            this.lifecycleService = lifecycleService;\n            this.configurationService = configurationService;\n            this.environmentService = environmentService;\n            this.requestService = requestService;\n            this.logService = logService;\n            this._state = update_1.State.Uninitialized;\n            this._onStateChange = new event_1.Emitter();\n            if (this.environmentService.disableUpdates) {\n                this.logService.info('update#ctor - updates are disabled by the environment');\n                return;\n            }\n            if (!product_1.default.updateUrl || !product_1.default.commit) {\n                this.logService.info('update#ctor - updates are disabled as there is no update URL');\n                return;\n            }\n            const updateMode = configuration_1.getMigratedSettingValue(this.configurationService, 'update.mode', 'update.channel');\n            const quality = this.getProductQuality(updateMode);\n            if (!quality) {\n                this.logService.info('update#ctor - updates are disabled by user preference');\n                return;\n            }\n            this.url = this.buildUpdateFeedUrl(quality);\n            if (!this.url) {\n                this.logService.info('update#ctor - updates are disabled as the update URL is badly formed');\n                return;\n            }\n            this.setState(update_1.State.Idle(this.getUpdateType()));\n            if (updateMode === 'manual') {\n                this.logService.info('update#ctor - manual checks only; automatic updates are disabled by user preference');\n                return;\n            }\n            // Start checking for updates after 30 seconds\n            this.scheduleCheckForUpdates(30 * 1000).then(undefined, err => this.logService.error(err));\n        }\n        get onStateChange() { return this._onStateChange.event; }\n        get state() {\n            return this._state;\n        }\n        setState(state) {\n            this.logService.info('update#setState', state.type);\n            this._state = state;\n            this._onStateChange.fire(state);\n        }\n        getProductQuality(updateMode) {\n            return updateMode === 'none' ? undefined : product_1.default.quality;\n        }\n        scheduleCheckForUpdates(delay = 60 * 60 * 1000) {\n            return async_1.timeout(delay)\n                .then(() => this.checkForUpdates(null))\n                .then(() => {\n                // Check again after 1 hour\n                return this.scheduleCheckForUpdates(60 * 60 * 1000);\n            });\n        }\n        checkForUpdates(context) {\n            return __awaiter(this, void 0, void 0, function* () {\n                this.logService.trace('update#checkForUpdates, state = ', this.state.type);\n                if (this.state.type !== update_1.StateType.Idle) {\n                    return;\n                }\n                this.doCheckForUpdates(context);\n            });\n        }\n        downloadUpdate() {\n            return __awaiter(this, void 0, void 0, function* () {\n                this.logService.trace('update#downloadUpdate, state = ', this.state.type);\n                if (this.state.type !== update_1.StateType.AvailableForDownload) {\n                    return;\n                }\n                yield this.doDownloadUpdate(this.state);\n            });\n        }\n        doDownloadUpdate(state) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // noop\n            });\n        }\n        applyUpdate() {\n            return __awaiter(this, void 0, void 0, function* () {\n                this.logService.trace('update#applyUpdate, state = ', this.state.type);\n                if (this.state.type !== update_1.StateType.Downloaded) {\n                    return;\n                }\n                yield this.doApplyUpdate();\n            });\n        }\n        doApplyUpdate() {\n            return __awaiter(this, void 0, void 0, function* () {\n                // noop\n            });\n        }\n        quitAndInstall() {\n            this.logService.trace('update#quitAndInstall, state = ', this.state.type);\n            if (this.state.type !== update_1.StateType.Ready) {\n                return Promise.resolve(undefined);\n            }\n            this.logService.trace('update#quitAndInstall(): before lifecycle quit()');\n            this.lifecycleService.quit(true /* from update */).then(vetod => {\n                this.logService.trace(`update#quitAndInstall(): after lifecycle quit() with veto: ${vetod}`);\n                if (vetod) {\n                    return;\n                }\n                this.logService.trace('update#quitAndInstall(): running raw#quitAndInstall()');\n                this.doQuitAndInstall();\n            });\n            return Promise.resolve(undefined);\n        }\n        isLatestVersion() {\n            if (!this.url) {\n                return Promise.resolve(undefined);\n            }\n            return this.requestService.request({ url: this.url }, cancellation_1.CancellationToken.None).then(context => {\n                // The update server replies with 204 (No Content) when no\n                // update is available - that's all we want to know.\n                if (context.res.statusCode === 204) {\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            });\n        }\n        getUpdateType() {\n            return update_1.UpdateType.Archive;\n        }\n        doQuitAndInstall() {\n            // noop\n        }\n    };\n    AbstractUpdateService = __decorate([\n        __param(0, lifecycleMain_1.ILifecycleService),\n        __param(1, configuration_1.IConfigurationService),\n        __param(2, environment_1.IEnvironmentService),\n        __param(3, request_1.IRequestService),\n        __param(4, log_1.ILogService)\n    ], AbstractUpdateService);\n    exports.AbstractUpdateService = AbstractUpdateService;\n});\n",null]}