{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/format/formattingEdit.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/format/formattingEdit.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar editOperation_1 = require(\"vs/editor/common/core/editOperation\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar FormattingEdit = /** @class */ (function () {\n    function FormattingEdit() {\n    }\n    FormattingEdit._handleEolEdits = function (editor, edits) {\n        var newEol = undefined;\n        var singleEdits = [];\n        for (var _i = 0, edits_1 = edits; _i < edits_1.length; _i++) {\n            var edit = edits_1[_i];\n            if (typeof edit.eol === 'number') {\n                newEol = edit.eol;\n            }\n            if (edit.range && typeof edit.text === 'string') {\n                singleEdits.push(edit);\n            }\n        }\n        if (typeof newEol === 'number') {\n            if (editor.hasModel()) {\n                editor.getModel().pushEOL(newEol);\n            }\n        }\n        return singleEdits;\n    };\n    FormattingEdit._isFullModelReplaceEdit = function (editor, edit) {\n        if (!editor.hasModel()) {\n            return false;\n        }\n        var model = editor.getModel();\n        var editRange = model.validateRange(edit.range);\n        var fullModelRange = model.getFullModelRange();\n        return fullModelRange.equalsRange(editRange);\n    };\n    FormattingEdit.execute = function (editor, _edits) {\n        editor.pushUndoStop();\n        var edits = FormattingEdit._handleEolEdits(editor, _edits);\n        if (edits.length === 1 && FormattingEdit._isFullModelReplaceEdit(editor, edits[0])) {\n            // We use replace semantics and hope that markers stay put...\n            editor.executeEdits('formatEditsCommand', edits.map(function (edit) { return editOperation_1.EditOperation.replace(range_1.Range.lift(edit.range), edit.text); }));\n        }\n        else {\n            editor.executeEdits('formatEditsCommand', edits.map(function (edit) { return editOperation_1.EditOperation.replaceMove(range_1.Range.lift(edit.range), edit.text); }));\n        }\n        editor.pushUndoStop();\n    };\n    return FormattingEdit;\n}());\nexports.FormattingEdit = FormattingEdit;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/format/formattingEdit.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/contrib/format/formattingEdit.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;AAGhG,qEAAoE;AACpE,qDAAoD;AAIpD;IAAA;IA6CA,CAAC;IA3Ce,8BAAe,GAA9B,UAA+B,MAAmB,EAAE,KAAiB;QACpE,IAAI,MAAM,GAAkC,SAAS,CAAC;QACtD,IAAI,WAAW,GAA2B,EAAE,CAAC;QAE7C,KAAiB,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK,EAAE;YAAnB,IAAI,IAAI,cAAA;YACZ,IAAI,OAAO,IAAI,CAAC,GAAG,KAAK,QAAQ,EAAE;gBACjC,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC;aAClB;YACD,IAAI,IAAI,CAAC,KAAK,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,EAAE;gBAChD,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACvB;SACD;QAED,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE;YAC/B,IAAI,MAAM,CAAC,QAAQ,EAAE,EAAE;gBACtB,MAAM,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;aAClC;SACD;QAED,OAAO,WAAW,CAAC;IACpB,CAAC;IAEc,sCAAuB,GAAtC,UAAuC,MAAmB,EAAE,IAA0B;QACrF,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,EAAE;YACvB,OAAO,KAAK,CAAC;SACb;QACD,IAAM,KAAK,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC;QAChC,IAAM,SAAS,GAAG,KAAK,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAClD,IAAM,cAAc,GAAG,KAAK,CAAC,iBAAiB,EAAE,CAAC;QACjD,OAAO,cAAc,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;IAC9C,CAAC;IAEM,sBAAO,GAAd,UAAe,MAAmB,EAAE,MAAkB;QACrD,MAAM,CAAC,YAAY,EAAE,CAAC;QACtB,IAAM,KAAK,GAAG,cAAc,CAAC,eAAe,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;QAC7D,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,cAAc,CAAC,uBAAuB,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;YACnF,6DAA6D;YAC7D,MAAM,CAAC,YAAY,CAAC,oBAAoB,EAAE,KAAK,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,6BAAa,CAAC,OAAO,CAAC,aAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,EAAxD,CAAwD,CAAC,CAAC,CAAC;SACvH;aAAM;YACN,MAAM,CAAC,YAAY,CAAC,oBAAoB,EAAE,KAAK,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,6BAAa,CAAC,WAAW,CAAC,aAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,EAA5D,CAA4D,CAAC,CAAC,CAAC;SAC3H;QACD,MAAM,CAAC,YAAY,EAAE,CAAC;IACvB,CAAC;IACF,qBAAC;AAAD,CAAC,AA7CD,IA6CC;AA7CY,wCAAc","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ICodeEditor } from 'vs/editor/browser/editorBrowser';\nimport { EditOperation } from 'vs/editor/common/core/editOperation';\nimport { Range } from 'vs/editor/common/core/range';\nimport { EndOfLineSequence, ISingleEditOperation } from 'vs/editor/common/model';\nimport { TextEdit } from 'vs/editor/common/modes';\n\nexport class FormattingEdit {\n\n\tprivate static _handleEolEdits(editor: ICodeEditor, edits: TextEdit[]): ISingleEditOperation[] {\n\t\tlet newEol: EndOfLineSequence | undefined = undefined;\n\t\tlet singleEdits: ISingleEditOperation[] = [];\n\n\t\tfor (let edit of edits) {\n\t\t\tif (typeof edit.eol === 'number') {\n\t\t\t\tnewEol = edit.eol;\n\t\t\t}\n\t\t\tif (edit.range && typeof edit.text === 'string') {\n\t\t\t\tsingleEdits.push(edit);\n\t\t\t}\n\t\t}\n\n\t\tif (typeof newEol === 'number') {\n\t\t\tif (editor.hasModel()) {\n\t\t\t\teditor.getModel().pushEOL(newEol);\n\t\t\t}\n\t\t}\n\n\t\treturn singleEdits;\n\t}\n\n\tprivate static _isFullModelReplaceEdit(editor: ICodeEditor, edit: ISingleEditOperation): boolean {\n\t\tif (!editor.hasModel()) {\n\t\t\treturn false;\n\t\t}\n\t\tconst model = editor.getModel();\n\t\tconst editRange = model.validateRange(edit.range);\n\t\tconst fullModelRange = model.getFullModelRange();\n\t\treturn fullModelRange.equalsRange(editRange);\n\t}\n\n\tstatic execute(editor: ICodeEditor, _edits: TextEdit[]) {\n\t\teditor.pushUndoStop();\n\t\tconst edits = FormattingEdit._handleEolEdits(editor, _edits);\n\t\tif (edits.length === 1 && FormattingEdit._isFullModelReplaceEdit(editor, edits[0])) {\n\t\t\t// We use replace semantics and hope that markers stay put...\n\t\t\teditor.executeEdits('formatEditsCommand', edits.map(edit => EditOperation.replace(Range.lift(edit.range), edit.text)));\n\t\t} else {\n\t\t\teditor.executeEdits('formatEditsCommand', edits.map(edit => EditOperation.replaceMove(Range.lift(edit.range), edit.text)));\n\t\t}\n\t\teditor.pushUndoStop();\n\t}\n}\n"]}]}