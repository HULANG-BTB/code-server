{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursorDeleteOperations.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursorDeleteOperations.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/strings\", \"vs/editor/common/commands/replaceCommand\", \"vs/editor/common/controller/cursorCommon\", \"vs/editor/common/controller/cursorMoveOperations\", \"vs/editor/common/core/range\"], function (require, exports, strings, replaceCommand_1, cursorCommon_1, cursorMoveOperations_1, range_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class DeleteOperations {\n        static deleteRight(prevEditOperationType, config, model, selections) {\n            let commands = [];\n            let shouldPushStackElementBefore = (prevEditOperationType !== cursorCommon_1.EditOperationType.DeletingRight);\n            for (let i = 0, len = selections.length; i < len; i++) {\n                const selection = selections[i];\n                let deleteSelection = selection;\n                if (deleteSelection.isEmpty()) {\n                    let position = selection.getPosition();\n                    let rightOfPosition = cursorMoveOperations_1.MoveOperations.right(config, model, position.lineNumber, position.column);\n                    deleteSelection = new range_1.Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n                }\n                if (deleteSelection.isEmpty()) {\n                    // Probably at end of file => ignore\n                    commands[i] = null;\n                    continue;\n                }\n                if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n                    shouldPushStackElementBefore = true;\n                }\n                commands[i] = new replaceCommand_1.ReplaceCommand(deleteSelection, '');\n            }\n            return [shouldPushStackElementBefore, commands];\n        }\n        static _isAutoClosingPairDelete(config, model, selections) {\n            if (config.autoClosingBrackets === 'never' && config.autoClosingQuotes === 'never') {\n                return false;\n            }\n            for (let i = 0, len = selections.length; i < len; i++) {\n                const selection = selections[i];\n                const position = selection.getPosition();\n                if (!selection.isEmpty()) {\n                    return false;\n                }\n                const lineText = model.getLineContent(position.lineNumber);\n                const character = lineText[position.column - 2];\n                if (!config.autoClosingPairsOpen.hasOwnProperty(character)) {\n                    return false;\n                }\n                if (cursorCommon_1.isQuote(character)) {\n                    if (config.autoClosingQuotes === 'never') {\n                        return false;\n                    }\n                }\n                else {\n                    if (config.autoClosingBrackets === 'never') {\n                        return false;\n                    }\n                }\n                const afterCharacter = lineText[position.column - 1];\n                const closeCharacter = config.autoClosingPairsOpen[character];\n                if (afterCharacter !== closeCharacter) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        static _runAutoClosingPairDelete(config, model, selections) {\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                const position = selections[i].getPosition();\n                const deleteSelection = new range_1.Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n                commands[i] = new replaceCommand_1.ReplaceCommand(deleteSelection, '');\n            }\n            return [true, commands];\n        }\n        static deleteLeft(prevEditOperationType, config, model, selections) {\n            if (this._isAutoClosingPairDelete(config, model, selections)) {\n                return this._runAutoClosingPairDelete(config, model, selections);\n            }\n            let commands = [];\n            let shouldPushStackElementBefore = (prevEditOperationType !== cursorCommon_1.EditOperationType.DeletingLeft);\n            for (let i = 0, len = selections.length; i < len; i++) {\n                const selection = selections[i];\n                let deleteSelection = selection;\n                if (deleteSelection.isEmpty()) {\n                    let position = selection.getPosition();\n                    if (config.useTabStops && position.column > 1) {\n                        let lineContent = model.getLineContent(position.lineNumber);\n                        let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n                        let lastIndentationColumn = (firstNonWhitespaceIndex === -1\n                            ? /* entire string is whitespace */ lineContent.length + 1\n                            : firstNonWhitespaceIndex + 1);\n                        if (position.column <= lastIndentationColumn) {\n                            let fromVisibleColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn2(config, model, position);\n                            let toVisibleColumn = cursorCommon_1.CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n                            let toColumn = cursorCommon_1.CursorColumns.columnFromVisibleColumn2(config, model, position.lineNumber, toVisibleColumn);\n                            deleteSelection = new range_1.Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n                        }\n                        else {\n                            deleteSelection = new range_1.Range(position.lineNumber, position.column - 1, position.lineNumber, position.column);\n                        }\n                    }\n                    else {\n                        let leftOfPosition = cursorMoveOperations_1.MoveOperations.left(config, model, position.lineNumber, position.column);\n                        deleteSelection = new range_1.Range(leftOfPosition.lineNumber, leftOfPosition.column, position.lineNumber, position.column);\n                    }\n                }\n                if (deleteSelection.isEmpty()) {\n                    // Probably at beginning of file => ignore\n                    commands[i] = null;\n                    continue;\n                }\n                if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n                    shouldPushStackElementBefore = true;\n                }\n                commands[i] = new replaceCommand_1.ReplaceCommand(deleteSelection, '');\n            }\n            return [shouldPushStackElementBefore, commands];\n        }\n        static cut(config, model, selections) {\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                const selection = selections[i];\n                if (selection.isEmpty()) {\n                    if (config.emptySelectionClipboard) {\n                        // This is a full line cut\n                        let position = selection.getPosition();\n                        let startLineNumber, startColumn, endLineNumber, endColumn;\n                        if (position.lineNumber < model.getLineCount()) {\n                            // Cutting a line in the middle of the model\n                            startLineNumber = position.lineNumber;\n                            startColumn = 1;\n                            endLineNumber = position.lineNumber + 1;\n                            endColumn = 1;\n                        }\n                        else if (position.lineNumber > 1) {\n                            // Cutting the last line & there are more than 1 lines in the model\n                            startLineNumber = position.lineNumber - 1;\n                            startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n                            endLineNumber = position.lineNumber;\n                            endColumn = model.getLineMaxColumn(position.lineNumber);\n                        }\n                        else {\n                            // Cutting the single line that the model contains\n                            startLineNumber = position.lineNumber;\n                            startColumn = 1;\n                            endLineNumber = position.lineNumber;\n                            endColumn = model.getLineMaxColumn(position.lineNumber);\n                        }\n                        let deleteSelection = new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);\n                        if (!deleteSelection.isEmpty()) {\n                            commands[i] = new replaceCommand_1.ReplaceCommand(deleteSelection, '');\n                        }\n                        else {\n                            commands[i] = null;\n                        }\n                    }\n                    else {\n                        // Cannot cut empty selection\n                        commands[i] = null;\n                    }\n                }\n                else {\n                    commands[i] = new replaceCommand_1.ReplaceCommand(selection, '');\n                }\n            }\n            return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Other, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: true\n            });\n        }\n    }\n    exports.DeleteOperations = DeleteOperations;\n});\n",null]}