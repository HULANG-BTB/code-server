{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/supports/electricCharacter.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/supports/electricCharacter.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/editor/common/modes/languageConfiguration\", \"vs/editor/common/modes/supports\", \"vs/editor/common/modes/supports/richEditBrackets\"], function (require, exports, languageConfiguration_1, supports_1, richEditBrackets_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class BracketElectricCharacterSupport {\n        constructor(richEditBrackets, autoClosePairs, contribution) {\n            contribution = contribution || {};\n            this._richEditBrackets = richEditBrackets;\n            this._complexAutoClosePairs = autoClosePairs.filter(pair => pair.open.length > 1 && !!pair.close).map(el => new languageConfiguration_1.StandardAutoClosingPairConditional(el));\n            if (contribution.docComment) {\n                // IDocComment is legacy, only partially supported\n                this._complexAutoClosePairs.push(new languageConfiguration_1.StandardAutoClosingPairConditional({ open: contribution.docComment.open, close: contribution.docComment.close || '' }));\n            }\n        }\n        getElectricCharacters() {\n            let result = [];\n            if (this._richEditBrackets) {\n                for (let i = 0, len = this._richEditBrackets.brackets.length; i < len; i++) {\n                    let bracketPair = this._richEditBrackets.brackets[i];\n                    let lastChar = bracketPair.close.charAt(bracketPair.close.length - 1);\n                    result.push(lastChar);\n                }\n            }\n            // auto close\n            for (let pair of this._complexAutoClosePairs) {\n                result.push(pair.open.charAt(pair.open.length - 1));\n            }\n            // Filter duplicate entries\n            result = result.filter((item, pos, array) => {\n                return array.indexOf(item) === pos;\n            });\n            return result;\n        }\n        onElectricCharacter(character, context, column) {\n            return (this._onElectricAutoClose(character, context, column) ||\n                this._onElectricAutoIndent(character, context, column));\n        }\n        _onElectricAutoIndent(character, context, column) {\n            if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n                return null;\n            }\n            let tokenIndex = context.findTokenIndexAtOffset(column - 1);\n            if (supports_1.ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n                return null;\n            }\n            let reversedBracketRegex = this._richEditBrackets.reversedRegex;\n            let text = context.getLineContent().substring(0, column - 1) + character;\n            let r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(reversedBracketRegex, 1, text, 0, text.length);\n            if (!r) {\n                return null;\n            }\n            let bracketText = text.substring(r.startColumn - 1, r.endColumn - 1);\n            bracketText = bracketText.toLowerCase();\n            let isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n            if (isOpen) {\n                return null;\n            }\n            let textBeforeBracket = text.substring(0, r.startColumn - 1);\n            if (!/^\\s*$/.test(textBeforeBracket)) {\n                // There is other text on the line before the bracket\n                return null;\n            }\n            return {\n                matchOpenBracket: bracketText\n            };\n        }\n        _onElectricAutoClose(character, context, column) {\n            if (!this._complexAutoClosePairs.length) {\n                return null;\n            }\n            let line = context.getLineContent();\n            for (let i = 0, len = this._complexAutoClosePairs.length; i < len; i++) {\n                let pair = this._complexAutoClosePairs[i];\n                // See if the right electric character was pressed\n                if (character !== pair.open.charAt(pair.open.length - 1)) {\n                    continue;\n                }\n                // check if the full open bracket matches\n                let start = column - pair.open.length + 1;\n                let actual = line.substring(start - 1, column - 1) + character;\n                if (actual !== pair.open) {\n                    continue;\n                }\n                let lastTokenIndex = context.findTokenIndexAtOffset(column - 1);\n                let lastTokenStandardType = context.getStandardTokenType(lastTokenIndex);\n                // If we're in a scope listed in 'notIn', do nothing\n                if (!pair.isOK(lastTokenStandardType)) {\n                    continue;\n                }\n                // If this line already contains the closing tag, do nothing.\n                if (line.indexOf(pair.close, column - 1) >= 0) {\n                    continue;\n                }\n                return { appendText: pair.close };\n            }\n            return null;\n        }\n    }\n    exports.BracketElectricCharacterSupport = BracketElectricCharacterSupport;\n});\n",null]}