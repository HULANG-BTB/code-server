{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/update/electron-main/updateService.win32.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/update/electron-main/updateService.win32.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"fs\", \"vs/base/common/path\", \"vs/base/node/pfs\", \"vs/base/common/decorators\", \"vs/platform/configuration/common/configuration\", \"vs/platform/lifecycle/electron-main/lifecycleMain\", \"vs/platform/request/node/request\", \"vs/platform/product/node/product\", \"vs/platform/update/common/update\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/environment/common/environment\", \"vs/platform/log/common/log\", \"vs/platform/update/electron-main/abstractUpdateService\", \"vs/base/node/request\", \"vs/base/node/crypto\", \"os\", \"child_process\", \"electron\", \"vs/base/common/cancellation\", \"vs/base/common/async\"], function (require, exports, fs, path, pfs, decorators_1, configuration_1, lifecycleMain_1, request_1, product_1, update_1, telemetry_1, environment_1, log_1, abstractUpdateService_1, request_2, crypto_1, os_1, child_process_1, electron_1, cancellation_1, async_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function pollUntil(fn, millis = 1000) {\n        return __awaiter(this, void 0, void 0, function* () {\n            while (!fn()) {\n                yield async_1.timeout(millis);\n            }\n        });\n    }\n    let _updateType = undefined;\n    function getUpdateType() {\n        if (typeof _updateType === 'undefined') {\n            _updateType = fs.existsSync(path.join(path.dirname(process.execPath), 'unins000.exe'))\n                ? update_1.UpdateType.Setup\n                : update_1.UpdateType.Archive;\n        }\n        return _updateType;\n    }\n    let Win32UpdateService = class Win32UpdateService extends abstractUpdateService_1.AbstractUpdateService {\n        constructor(lifecycleService, configurationService, telemetryService, environmentService, requestService, logService) {\n            super(lifecycleService, configurationService, environmentService, requestService, logService);\n            this.telemetryService = telemetryService;\n            if (getUpdateType() === update_1.UpdateType.Setup) {\n                /* __GDPR__\n                    \"update:win32SetupTarget\" : {\n                        \"target\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                    }\n                */\n                /* __GDPR__\n                    \"update:win<NUMBER>SetupTarget\" : {\n                        \"target\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                    }\n                */\n                telemetryService.publicLog('update:win32SetupTarget', { target: product_1.default.target });\n            }\n        }\n        get cachePath() {\n            const result = path.join(os_1.tmpdir(), `vscode-update-${product_1.default.target}-${process.arch}`);\n            return pfs.mkdirp(result, undefined).then(() => result);\n        }\n        buildUpdateFeedUrl(quality) {\n            let platform = 'win32';\n            if (process.arch === 'x64') {\n                platform += '-x64';\n            }\n            if (getUpdateType() === update_1.UpdateType.Archive) {\n                platform += '-archive';\n            }\n            else if (product_1.default.target === 'user') {\n                platform += '-user';\n            }\n            return abstractUpdateService_1.createUpdateURL(platform, quality);\n        }\n        doCheckForUpdates(context) {\n            if (!this.url) {\n                return;\n            }\n            this.setState(update_1.State.CheckingForUpdates(context));\n            this.requestService.request({ url: this.url }, cancellation_1.CancellationToken.None)\n                .then(request_2.asJson)\n                .then(update => {\n                const updateType = getUpdateType();\n                if (!update || !update.url || !update.version || !update.productVersion) {\n                    /* __GDPR__\n                            \"update:notAvailable\" : {\n                                \"explicit\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n                            }\n                        */\n                    this.telemetryService.publicLog('update:notAvailable', { explicit: !!context });\n                    this.setState(update_1.State.Idle(updateType));\n                    return Promise.resolve(null);\n                }\n                if (updateType === update_1.UpdateType.Archive) {\n                    this.setState(update_1.State.AvailableForDownload(update));\n                    return Promise.resolve(null);\n                }\n                this.setState(update_1.State.Downloading(update));\n                return this.cleanup(update.version).then(() => {\n                    return this.getUpdatePackagePath(update.version).then(updatePackagePath => {\n                        return pfs.exists(updatePackagePath).then(exists => {\n                            if (exists) {\n                                return Promise.resolve(updatePackagePath);\n                            }\n                            const url = update.url;\n                            const hash = update.hash;\n                            const downloadPath = `${updatePackagePath}.tmp`;\n                            return this.requestService.request({ url }, cancellation_1.CancellationToken.None)\n                                .then(context => request_2.download(downloadPath, context))\n                                .then(hash ? () => crypto_1.checksum(downloadPath, update.hash) : () => undefined)\n                                .then(() => pfs.rename(downloadPath, updatePackagePath))\n                                .then(() => updatePackagePath);\n                        });\n                    }).then(packagePath => {\n                        const fastUpdatesEnabled = this.configurationService.getValue('update.enableWindowsBackgroundUpdates');\n                        this.availableUpdate = { packagePath };\n                        if (fastUpdatesEnabled && update.supportsFastUpdate) {\n                            if (product_1.default.target === 'user') {\n                                this.doApplyUpdate();\n                            }\n                            else {\n                                this.setState(update_1.State.Downloaded(update));\n                            }\n                        }\n                        else {\n                            this.setState(update_1.State.Ready(update));\n                        }\n                    });\n                });\n            })\n                .then(undefined, err => {\n                this.logService.error(err);\n                /* __GDPR__\n                    \"update:notAvailable\" : {\n                        \"explicit\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n                    }\n                    */\n                this.telemetryService.publicLog('update:notAvailable', { explicit: !!context });\n                // only show message when explicitly checking for updates\n                const message = !!context ? (err.message || err) : undefined;\n                this.setState(update_1.State.Idle(getUpdateType(), message));\n            });\n        }\n        doDownloadUpdate(state) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (state.update.url) {\n                    electron_1.shell.openExternal(state.update.url);\n                }\n                this.setState(update_1.State.Idle(getUpdateType()));\n            });\n        }\n        getUpdatePackagePath(version) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const cachePath = yield this.cachePath;\n                return path.join(cachePath, `CodeSetup-${product_1.default.quality}-${version}.exe`);\n            });\n        }\n        cleanup(exceptVersion = null) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const filter = exceptVersion ? (one) => !(new RegExp(`${product_1.default.quality}-${exceptVersion}\\\\.exe$`).test(one)) : () => true;\n                const cachePath = yield this.cachePath;\n                const versions = yield pfs.readdir(cachePath);\n                const promises = versions.filter(filter).map((one) => __awaiter(this, void 0, void 0, function* () {\n                    try {\n                        yield pfs.unlink(path.join(cachePath, one));\n                    }\n                    catch (err) {\n                        // ignore\n                    }\n                }));\n                yield Promise.all(promises);\n            });\n        }\n        doApplyUpdate() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (this.state.type !== update_1.StateType.Downloaded && this.state.type !== update_1.StateType.Downloading) {\n                    return Promise.resolve(undefined);\n                }\n                if (!this.availableUpdate) {\n                    return Promise.resolve(undefined);\n                }\n                const update = this.state.update;\n                this.setState(update_1.State.Updating(update));\n                const cachePath = yield this.cachePath;\n                this.availableUpdate.updateFilePath = path.join(cachePath, `CodeSetup-${product_1.default.quality}-${update.version}.flag`);\n                yield pfs.writeFile(this.availableUpdate.updateFilePath, 'flag');\n                const child = child_process_1.spawn(this.availableUpdate.packagePath, ['/verysilent', `/update=\"${this.availableUpdate.updateFilePath}\"`, '/nocloseapplications', '/mergetasks=runcode,!desktopicon,!quicklaunchicon'], {\n                    detached: true,\n                    stdio: ['ignore', 'ignore', 'ignore'],\n                    windowsVerbatimArguments: true\n                });\n                child.once('exit', () => {\n                    this.availableUpdate = undefined;\n                    this.setState(update_1.State.Idle(getUpdateType()));\n                });\n                const readyMutexName = `${product_1.default.win32MutexName}-ready`;\n                const isActive = require.__$__nodeRequire('windows-mutex').isActive;\n                // poll for mutex-ready\n                pollUntil(() => isActive(readyMutexName))\n                    .then(() => this.setState(update_1.State.Ready(update)));\n            });\n        }\n        doQuitAndInstall() {\n            if (this.state.type !== update_1.StateType.Ready || !this.availableUpdate) {\n                return;\n            }\n            this.logService.trace('update#quitAndInstall(): running raw#quitAndInstall()');\n            if (this.state.update.supportsFastUpdate && this.availableUpdate.updateFilePath) {\n                fs.unlinkSync(this.availableUpdate.updateFilePath);\n            }\n            else {\n                child_process_1.spawn(this.availableUpdate.packagePath, ['/silent', '/mergetasks=runcode,!desktopicon,!quicklaunchicon'], {\n                    detached: true,\n                    stdio: ['ignore', 'ignore', 'ignore']\n                });\n            }\n        }\n        getUpdateType() {\n            return getUpdateType();\n        }\n    };\n    __decorate([\n        decorators_1.memoize\n    ], Win32UpdateService.prototype, \"cachePath\", null);\n    Win32UpdateService = __decorate([\n        __param(0, lifecycleMain_1.ILifecycleService),\n        __param(1, configuration_1.IConfigurationService),\n        __param(2, telemetry_1.ITelemetryService),\n        __param(3, environment_1.IEnvironmentService),\n        __param(4, request_1.IRequestService),\n        __param(5, log_1.ILogService)\n    ], Win32UpdateService);\n    exports.Win32UpdateService = Win32UpdateService;\n});\n",null]}