{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/viewModel/viewModelDecorations.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewModel/viewModelDecorations.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\", \"vs/editor/common/viewModel/viewModel\"], function (require, exports, position_1, range_1, viewModel_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class ViewModelDecorations {\n        constructor(editorId, model, configuration, linesCollection, coordinatesConverter) {\n            this.editorId = editorId;\n            this.model = model;\n            this.configuration = configuration;\n            this._linesCollection = linesCollection;\n            this._coordinatesConverter = coordinatesConverter;\n            this._decorationsCache = Object.create(null);\n            this._clearCachedModelDecorationsResolver();\n        }\n        _clearCachedModelDecorationsResolver() {\n            this._cachedModelDecorationsResolver = null;\n            this._cachedModelDecorationsResolverViewRange = null;\n        }\n        dispose() {\n            this._decorationsCache = Object.create(null);\n            this._clearCachedModelDecorationsResolver();\n        }\n        reset() {\n            this._decorationsCache = Object.create(null);\n            this._clearCachedModelDecorationsResolver();\n        }\n        onModelDecorationsChanged() {\n            this._decorationsCache = Object.create(null);\n            this._clearCachedModelDecorationsResolver();\n        }\n        onLineMappingChanged() {\n            this._decorationsCache = Object.create(null);\n            this._clearCachedModelDecorationsResolver();\n        }\n        _getOrCreateViewModelDecoration(modelDecoration) {\n            const id = modelDecoration.id;\n            let r = this._decorationsCache[id];\n            if (!r) {\n                const modelRange = modelDecoration.range;\n                const options = modelDecoration.options;\n                let viewRange;\n                if (options.isWholeLine) {\n                    const start = this._coordinatesConverter.convertModelPositionToViewPosition(new position_1.Position(modelRange.startLineNumber, 1));\n                    const end = this._coordinatesConverter.convertModelPositionToViewPosition(new position_1.Position(modelRange.endLineNumber, this.model.getLineMaxColumn(modelRange.endLineNumber)));\n                    viewRange = new range_1.Range(start.lineNumber, start.column, end.lineNumber, end.column);\n                }\n                else {\n                    viewRange = this._coordinatesConverter.convertModelRangeToViewRange(modelRange);\n                }\n                r = new viewModel_1.ViewModelDecoration(viewRange, options);\n                this._decorationsCache[id] = r;\n            }\n            return r;\n        }\n        getDecorationsViewportData(viewRange) {\n            let cacheIsValid = (this._cachedModelDecorationsResolver !== null);\n            cacheIsValid = cacheIsValid && (viewRange.equalsRange(this._cachedModelDecorationsResolverViewRange));\n            if (!cacheIsValid) {\n                this._cachedModelDecorationsResolver = this._getDecorationsViewportData(viewRange);\n                this._cachedModelDecorationsResolverViewRange = viewRange;\n            }\n            return this._cachedModelDecorationsResolver;\n        }\n        _getDecorationsViewportData(viewportRange) {\n            const modelDecorations = this._linesCollection.getDecorationsInRange(viewportRange, this.editorId, this.configuration.editor.readOnly);\n            const startLineNumber = viewportRange.startLineNumber;\n            const endLineNumber = viewportRange.endLineNumber;\n            let decorationsInViewport = [], decorationsInViewportLen = 0;\n            let inlineDecorations = [];\n            for (let j = startLineNumber; j <= endLineNumber; j++) {\n                inlineDecorations[j - startLineNumber] = [];\n            }\n            for (let i = 0, len = modelDecorations.length; i < len; i++) {\n                let modelDecoration = modelDecorations[i];\n                let decorationOptions = modelDecoration.options;\n                let viewModelDecoration = this._getOrCreateViewModelDecoration(modelDecoration);\n                let viewRange = viewModelDecoration.range;\n                decorationsInViewport[decorationsInViewportLen++] = viewModelDecoration;\n                if (decorationOptions.inlineClassName) {\n                    let inlineDecoration = new viewModel_1.InlineDecoration(viewRange, decorationOptions.inlineClassName, decorationOptions.inlineClassNameAffectsLetterSpacing ? viewModel_1.InlineDecorationType.RegularAffectingLetterSpacing : viewModel_1.InlineDecorationType.Regular);\n                    let intersectedStartLineNumber = Math.max(startLineNumber, viewRange.startLineNumber);\n                    let intersectedEndLineNumber = Math.min(endLineNumber, viewRange.endLineNumber);\n                    for (let j = intersectedStartLineNumber; j <= intersectedEndLineNumber; j++) {\n                        inlineDecorations[j - startLineNumber].push(inlineDecoration);\n                    }\n                }\n                if (decorationOptions.beforeContentClassName) {\n                    if (startLineNumber <= viewRange.startLineNumber && viewRange.startLineNumber <= endLineNumber) {\n                        let inlineDecoration = new viewModel_1.InlineDecoration(new range_1.Range(viewRange.startLineNumber, viewRange.startColumn, viewRange.startLineNumber, viewRange.startColumn), decorationOptions.beforeContentClassName, viewModel_1.InlineDecorationType.Before);\n                        inlineDecorations[viewRange.startLineNumber - startLineNumber].push(inlineDecoration);\n                    }\n                }\n                if (decorationOptions.afterContentClassName) {\n                    if (startLineNumber <= viewRange.endLineNumber && viewRange.endLineNumber <= endLineNumber) {\n                        let inlineDecoration = new viewModel_1.InlineDecoration(new range_1.Range(viewRange.endLineNumber, viewRange.endColumn, viewRange.endLineNumber, viewRange.endColumn), decorationOptions.afterContentClassName, viewModel_1.InlineDecorationType.After);\n                        inlineDecorations[viewRange.endLineNumber - startLineNumber].push(inlineDecoration);\n                    }\n                }\n            }\n            return {\n                decorations: decorationsInViewport,\n                inlineDecorations: inlineDecorations\n            };\n        }\n    }\n    exports.ViewModelDecorations = ViewModelDecorations;\n});\n",null]}