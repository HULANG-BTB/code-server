{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/node/flow.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/flow.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert = require(\"assert\");\n/**\n * Executes the given function (fn) over the given array of items (list) in parallel and returns the resulting errors and results as\n * array to the callback (callback). The resulting errors and results are evaluated by calling the provided callback function.\n */\nfunction parallel(list, fn, callback) {\n    var results = new Array(list.length);\n    var errors = new Array(list.length);\n    var didErrorOccur = false;\n    var doneCount = 0;\n    if (list.length === 0) {\n        return callback(null, []);\n    }\n    list.forEach(function (item, index) {\n        fn(item, function (error, result) {\n            if (error) {\n                didErrorOccur = true;\n                results[index] = null;\n                errors[index] = error;\n            }\n            else {\n                results[index] = result;\n                errors[index] = null;\n            }\n            if (++doneCount === list.length) {\n                return callback(didErrorOccur ? errors : null, results);\n            }\n        });\n    });\n}\nexports.parallel = parallel;\nfunction loop(param, fn, callback) {\n    // Assert\n    assert.ok(param, 'Missing first parameter');\n    assert.ok(typeof (fn) === 'function', 'Second parameter must be a function that is called for each element');\n    assert.ok(typeof (callback) === 'function', 'Third parameter must be a function that is called on error and success');\n    // Param is function, execute to retrieve array\n    if (typeof (param) === 'function') {\n        try {\n            param(function (error, result) {\n                if (error) {\n                    callback(error, null);\n                }\n                else {\n                    loop(result, fn, callback);\n                }\n            });\n        }\n        catch (error) {\n            callback(error, null);\n        }\n    }\n    // Expect the param to be an array and loop over it\n    else {\n        var results_1 = [];\n        var looper_1 = function (i) {\n            // Still work to do\n            if (i < param.length) {\n                // Execute function on array element\n                try {\n                    fn(param[i], function (error, result) {\n                        // A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully\n                        if (error === true || error === false) {\n                            result = error;\n                            error = null;\n                        }\n                        // Quit looping on error\n                        if (error) {\n                            callback(error, null);\n                        }\n                        // Otherwise push result on stack and continue looping\n                        else {\n                            if (result) { //Could be that provided function is not returning a result\n                                results_1.push(result);\n                            }\n                            process.nextTick(function () {\n                                looper_1(i + 1);\n                            });\n                        }\n                    }, i, param.length);\n                }\n                catch (error) {\n                    callback(error, null);\n                }\n            }\n            // Done looping, pass back results too callback function\n            else {\n                callback(null, results_1);\n            }\n        };\n        // Start looping with first element in array\n        looper_1(0);\n    }\n}\nexports.loop = loop;\nfunction Sequence(sequences) {\n    // Assert\n    assert.ok(sequences.length > 1, 'Need at least one error handler and one function to process sequence');\n    sequences.forEach(function (sequence) {\n        assert.ok(typeof (sequence) === 'function');\n    });\n    // Execute in Loop\n    var errorHandler = sequences.splice(0, 1)[0]; //Remove error handler\n    var sequenceResult = null;\n    loop(sequences, function (sequence, clb) {\n        var sequenceFunction = function (error, result) {\n            // A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully\n            if (error === true || error === false) {\n                result = error;\n                error = null;\n            }\n            // Handle Error and Result\n            if (error) {\n                clb(error, null);\n            }\n            else {\n                sequenceResult = result; //Remember result of sequence\n                clb(null, null); //Don't pass on result to Looper as we are not aggregating it\n            }\n        };\n        // We call the sequence function setting \"this\" to be the callback we define here\n        // and we pass in the \"sequenceResult\" as first argument. Doing all this avoids having\n        // to pass in a callback to the sequence because the callback is already \"this\".\n        try {\n            sequence.call(sequenceFunction, sequenceResult);\n        }\n        catch (error) {\n            clb(error, null);\n        }\n    }, function (error, result) {\n        if (error) {\n            errorHandler(error);\n        }\n    });\n}\nfunction sequence(sequences) {\n    Sequence((Array.isArray(sequences)) ? sequences : Array.prototype.slice.call(arguments));\n}\nexports.sequence = sequence;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/node/flow.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/node/flow.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as assert from 'assert';\n\n/**\n * Executes the given function (fn) over the given array of items (list) in parallel and returns the resulting errors and results as\n * array to the callback (callback). The resulting errors and results are evaluated by calling the provided callback function.\n */\nexport function parallel<T, E>(list: T[], fn: (item: T, callback: (err: Error | null, result: E | null) => void) => void, callback: (err: Array<Error | null> | null, result: E[]) => void): void {\n\tconst results = new Array(list.length);\n\tconst errors = new Array<Error | null>(list.length);\n\tlet didErrorOccur = false;\n\tlet doneCount = 0;\n\n\tif (list.length === 0) {\n\t\treturn callback(null, []);\n\t}\n\n\tlist.forEach((item, index) => {\n\t\tfn(item, (error, result) => {\n\t\t\tif (error) {\n\t\t\t\tdidErrorOccur = true;\n\t\t\t\tresults[index] = null;\n\t\t\t\terrors[index] = error;\n\t\t\t} else {\n\t\t\t\tresults[index] = result;\n\t\t\t\terrors[index] = null;\n\t\t\t}\n\n\t\t\tif (++doneCount === list.length) {\n\t\t\t\treturn callback(didErrorOccur ? errors : null, results);\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Executes the given function (fn) over the given array of items (param) in sequential order and returns the first occurred error or the result as\n * array to the callback (callback). The resulting errors and results are evaluated by calling the provided callback function. The first param can\n * either be a function that returns an array of results to loop in async fashion or be an array of items already.\n */\nexport function loop<T, E>(param: (callback: (error: Error, result: T[]) => void) => void, fn: (item: T, callback: (error: Error | null, result: E | null) => void, index: number, total: number) => void, callback: (error: Error | null, result: E[] | null) => void): void;\nexport function loop<T, E>(param: T[], fn: (item: T, callback: (error: Error | null, result: E | null) => void, index: number, total: number) => void, callback: (error: Error | null, result: E[] | null) => void): void;\nexport function loop<E>(param: any, fn: (item: any, callback: (error: Error | null, result: E | null) => void, index: number, total: number) => void, callback: (error: Error | null, result: E[] | null) => void): void {\n\n\t// Assert\n\tassert.ok(param, 'Missing first parameter');\n\tassert.ok(typeof (fn) === 'function', 'Second parameter must be a function that is called for each element');\n\tassert.ok(typeof (callback) === 'function', 'Third parameter must be a function that is called on error and success');\n\n\t// Param is function, execute to retrieve array\n\tif (typeof (param) === 'function') {\n\t\ttry {\n\t\t\tparam((error: Error, result: E[]) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tcallback(error, null);\n\t\t\t\t} else {\n\t\t\t\t\tloop(result, fn, callback);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tcallback(error, null);\n\t\t}\n\t}\n\n\t// Expect the param to be an array and loop over it\n\telse {\n\t\tconst results: E[] = [];\n\n\t\tconst looper: (i: number) => void = function (i: number): void {\n\n\t\t\t// Still work to do\n\t\t\tif (i < param.length) {\n\n\t\t\t\t// Execute function on array element\n\t\t\t\ttry {\n\t\t\t\t\tfn(param[i], (error: any, result: E) => {\n\n\t\t\t\t\t\t// A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully\n\t\t\t\t\t\tif (error === true || error === false) {\n\t\t\t\t\t\t\tresult = error;\n\t\t\t\t\t\t\terror = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Quit looping on error\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\tcallback(error, null);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise push result on stack and continue looping\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (result) { //Could be that provided function is not returning a result\n\t\t\t\t\t\t\t\tresults.push(result);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\t\t\t\tlooper(i + 1);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}, i, param.length);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tcallback(error, null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Done looping, pass back results too callback function\n\t\t\telse {\n\t\t\t\tcallback(null, results);\n\t\t\t}\n\t\t};\n\n\t\t// Start looping with first element in array\n\t\tlooper(0);\n\t}\n}\n\nfunction Sequence(sequences: { (...param: any[]): void; }[]): void {\n\n\t// Assert\n\tassert.ok(sequences.length > 1, 'Need at least one error handler and one function to process sequence');\n\tsequences.forEach((sequence) => {\n\t\tassert.ok(typeof (sequence) === 'function');\n\t});\n\n\t// Execute in Loop\n\tconst errorHandler = sequences.splice(0, 1)[0]; //Remove error handler\n\tlet sequenceResult: any = null;\n\n\tloop(sequences, (sequence, clb) => {\n\t\tconst sequenceFunction = function (error: any, result: any): void {\n\n\t\t\t// A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully\n\t\t\tif (error === true || error === false) {\n\t\t\t\tresult = error;\n\t\t\t\terror = null;\n\t\t\t}\n\n\t\t\t// Handle Error and Result\n\t\t\tif (error) {\n\t\t\t\tclb(error, null);\n\t\t\t} else {\n\t\t\t\tsequenceResult = result; //Remember result of sequence\n\t\t\t\tclb(null, null); //Don't pass on result to Looper as we are not aggregating it\n\t\t\t}\n\t\t};\n\n\t\t// We call the sequence function setting \"this\" to be the callback we define here\n\t\t// and we pass in the \"sequenceResult\" as first argument. Doing all this avoids having\n\t\t// to pass in a callback to the sequence because the callback is already \"this\".\n\t\ttry {\n\t\t\tsequence.call(sequenceFunction, sequenceResult);\n\t\t} catch (error) {\n\t\t\tclb(error, null);\n\t\t}\n\t}, (error, result) => {\n\t\tif (error) {\n\t\t\terrorHandler(error);\n\t\t}\n\t});\n}\n\n/**\n * Takes a variable list of functions to execute in sequence. The first function must be the error handler and the\n * following functions can do arbitrary work. \"this\" must be used as callback value for async functions to continue\n * through the sequence:\n * \tsequence(\n * \t\tfunction errorHandler(error) {\n * \t\t\tclb(error, null);\n * \t\t},\n *\n * \t\tfunction doSomethingAsync() {\n * \t\t\tfs.doAsync(path, this);\n * \t\t},\n *\n * \t\tfunction done(result) {\n * \t\t\tclb(null, result);\n * \t\t}\n * \t);\n */\nexport function sequence(errorHandler: (error: Error) => void, ...sequences: Function[]): void;\nexport function sequence(sequences: Function[]): void;\nexport function sequence(sequences: any): void {\n\tSequence((Array.isArray(sequences)) ? sequences : Array.prototype.slice.call(arguments));\n}"]}]}