{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/files/common/explorerService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/files/common/explorerService.ts","mtime":1555846338040},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/event\", \"vs/platform/workspace/common/workspace\", \"vs/base/common/lifecycle\", \"vs/workbench/contrib/files/common/files\", \"vs/workbench/contrib/files/common/explorerModel\", \"vs/platform/files/common/files\", \"vs/base/common/resources\", \"vs/base/common/decorators\", \"vs/workbench/common/resources\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/configuration/common/configuration\", \"vs/platform/clipboard/common/clipboardService\", \"vs/workbench/services/editor/common/editorService\"], function (require, exports, event_1, workspace_1, lifecycle_1, files_1, explorerModel_1, files_2, resources_1, decorators_1, resources_2, instantiation_1, configuration_1, clipboardService_1, editorService_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function getFileEventsExcludes(configurationService, root) {\n        const scope = root ? { resource: root } : undefined;\n        const configuration = scope ? configurationService.getValue(scope) : configurationService.getValue();\n        return (configuration && configuration.files && configuration.files.exclude) || Object.create(null);\n    }\n    let ExplorerService = class ExplorerService {\n        constructor(fileService, instantiationService, configurationService, contextService, clipboardService, editorService) {\n            this.fileService = fileService;\n            this.instantiationService = instantiationService;\n            this.configurationService = configurationService;\n            this.contextService = contextService;\n            this.clipboardService = clipboardService;\n            this.editorService = editorService;\n            this._onDidChangeRoots = new event_1.Emitter();\n            this._onDidChangeItem = new event_1.Emitter();\n            this._onDidChangeEditable = new event_1.Emitter();\n            this._onDidSelectResource = new event_1.Emitter();\n            this._onDidCopyItems = new event_1.Emitter();\n            this.disposables = [];\n            this._sortOrder = this.configurationService.getValue('explorer.sortOrder');\n        }\n        get roots() {\n            return this.model.roots;\n        }\n        get onDidChangeRoots() {\n            return this._onDidChangeRoots.event;\n        }\n        get onDidChangeItem() {\n            return this._onDidChangeItem.event;\n        }\n        get onDidChangeEditable() {\n            return this._onDidChangeEditable.event;\n        }\n        get onDidSelectResource() {\n            return this._onDidSelectResource.event;\n        }\n        get onDidCopyItems() {\n            return this._onDidCopyItems.event;\n        }\n        get sortOrder() {\n            return this._sortOrder;\n        }\n        // Memoized locals\n        get fileEventsFilter() {\n            const fileEventsFilter = this.instantiationService.createInstance(resources_2.ResourceGlobMatcher, (root) => getFileEventsExcludes(this.configurationService, root), (event) => event.affectsConfiguration(files_2.FILES_EXCLUDE_CONFIG));\n            this.disposables.push(fileEventsFilter);\n            return fileEventsFilter;\n        }\n        get model() {\n            const model = new explorerModel_1.ExplorerModel(this.contextService);\n            this.disposables.push(model);\n            this.disposables.push(this.fileService.onAfterOperation(e => this.onFileOperation(e)));\n            this.disposables.push(this.fileService.onFileChanges(e => this.onFileChanges(e)));\n            this.disposables.push(this.configurationService.onDidChangeConfiguration(e => this.onConfigurationUpdated(this.configurationService.getValue())));\n            this.disposables.push(this.fileService.onDidChangeFileSystemProviderRegistrations(() => this._onDidChangeItem.fire(undefined)));\n            this.disposables.push(model.onDidChangeRoots(() => this._onDidChangeRoots.fire()));\n            return model;\n        }\n        // IExplorerService methods\n        findClosest(resource) {\n            return this.model.findClosest(resource);\n        }\n        setEditable(stat, data) {\n            if (!data) {\n                this.editable = undefined;\n            }\n            else {\n                this.editable = { stat, data };\n            }\n            this._onDidChangeEditable.fire(stat);\n        }\n        setToCopy(items, cut) {\n            const previouslyCutItems = this.cutItems;\n            this.cutItems = cut ? items : undefined;\n            this.clipboardService.writeResources(items.map(s => s.resource));\n            this._onDidCopyItems.fire({ items, cut, previouslyCutItems });\n        }\n        isCut(item) {\n            return !!this.cutItems && this.cutItems.indexOf(item) >= 0;\n        }\n        getEditableData(stat) {\n            return this.editable && this.editable.stat === stat ? this.editable.data : undefined;\n        }\n        isEditable(stat) {\n            return !!this.editable && (this.editable.stat === stat || !stat);\n        }\n        select(resource, reveal) {\n            const fileStat = this.findClosest(resource);\n            if (fileStat) {\n                this._onDidSelectResource.fire({ resource: fileStat.resource, reveal });\n                return Promise.resolve(undefined);\n            }\n            // Stat needs to be resolved first and then revealed\n            const options = { resolveTo: [resource], resolveMetadata: false };\n            const workspaceFolder = this.contextService.getWorkspaceFolder(resource);\n            const rootUri = workspaceFolder ? workspaceFolder.uri : this.roots[0].resource;\n            const root = this.roots.filter(r => r.resource.toString() === rootUri.toString()).pop();\n            return this.fileService.resolveFile(rootUri, options).then(stat => {\n                // Convert to model\n                const modelStat = explorerModel_1.ExplorerItem.create(stat, undefined, options.resolveTo);\n                // Update Input with disk Stat\n                explorerModel_1.ExplorerItem.mergeLocalWithDisk(modelStat, root);\n                const item = root.find(resource);\n                this._onDidChangeItem.fire(item ? item.parent : undefined);\n                // Select and Reveal\n                this._onDidSelectResource.fire({ resource: item ? item.resource : undefined, reveal });\n            }, () => {\n                root.isError = true;\n                this._onDidChangeItem.fire(root);\n            });\n        }\n        refresh() {\n            this.model.roots.forEach(r => r.forgetChildren());\n            this._onDidChangeItem.fire(undefined);\n            const resource = this.editorService.activeEditor ? this.editorService.activeEditor.getResource() : undefined;\n            if (resource) {\n                // We did a top level refresh, reveal the active file #67118\n                this.select(resource, true);\n            }\n        }\n        // File events\n        onFileOperation(e) {\n            // Add\n            if (e.operation === files_2.FileOperation.CREATE || e.operation === files_2.FileOperation.COPY) {\n                const addedElement = e.target;\n                const parentResource = resources_1.dirname(addedElement.resource);\n                const parents = this.model.findAll(parentResource);\n                if (parents.length) {\n                    // Add the new file to its parent (Model)\n                    parents.forEach(p => {\n                        // We have to check if the parent is resolved #29177\n                        const resolveMetadata = this.sortOrder === `modified`;\n                        const thenable = p.isDirectoryResolved ? Promise.resolve(undefined) : this.fileService.resolveFile(p.resource, { resolveMetadata });\n                        thenable.then(stat => {\n                            if (stat) {\n                                const modelStat = explorerModel_1.ExplorerItem.create(stat, p.parent);\n                                explorerModel_1.ExplorerItem.mergeLocalWithDisk(modelStat, p);\n                            }\n                            const childElement = explorerModel_1.ExplorerItem.create(addedElement, p.parent);\n                            // Make sure to remove any previous version of the file if any\n                            p.removeChild(childElement);\n                            p.addChild(childElement);\n                            // Refresh the Parent (View)\n                            this._onDidChangeItem.fire(p);\n                        });\n                    });\n                }\n            }\n            // Move (including Rename)\n            else if (e.operation === files_2.FileOperation.MOVE) {\n                const oldResource = e.resource;\n                const newElement = e.target;\n                const oldParentResource = resources_1.dirname(oldResource);\n                const newParentResource = resources_1.dirname(newElement.resource);\n                // Handle Rename\n                if (oldParentResource.toString() === newParentResource.toString()) {\n                    const modelElements = this.model.findAll(oldResource);\n                    modelElements.forEach(modelElement => {\n                        // Rename File (Model)\n                        modelElement.rename(newElement);\n                        this._onDidChangeItem.fire(modelElement.parent);\n                    });\n                }\n                // Handle Move\n                else {\n                    const newParents = this.model.findAll(newParentResource);\n                    const modelElements = this.model.findAll(oldResource);\n                    if (newParents.length && modelElements.length) {\n                        // Move in Model\n                        modelElements.forEach((modelElement, index) => {\n                            const oldParent = modelElement.parent;\n                            modelElement.move(newParents[index]);\n                            this._onDidChangeItem.fire(oldParent);\n                            this._onDidChangeItem.fire(newParents[index]);\n                        });\n                    }\n                }\n            }\n            // Delete\n            else if (e.operation === files_2.FileOperation.DELETE) {\n                const modelElements = this.model.findAll(e.resource);\n                modelElements.forEach(element => {\n                    if (element.parent) {\n                        const parent = element.parent;\n                        // Remove Element from Parent (Model)\n                        parent.removeChild(element);\n                        // Refresh Parent (View)\n                        this._onDidChangeItem.fire(parent);\n                    }\n                });\n            }\n        }\n        onFileChanges(e) {\n            // Check if an explorer refresh is necessary (delayed to give internal events a chance to react first)\n            // Note: there is no guarantee when the internal events are fired vs real ones. Code has to deal with the fact that one might\n            // be fired first over the other or not at all.\n            setTimeout(() => {\n                // Filter to the ones we care\n                const shouldRefresh = () => {\n                    e = this.filterToViewRelevantEvents(e);\n                    // Handle added files/folders\n                    const added = e.getAdded();\n                    if (added.length) {\n                        // Check added: Refresh if added file/folder is not part of resolved root and parent is part of it\n                        const ignoredPaths = {};\n                        for (let i = 0; i < added.length; i++) {\n                            const change = added[i];\n                            // Find parent\n                            const parent = resources_1.dirname(change.resource);\n                            // Continue if parent was already determined as to be ignored\n                            if (ignoredPaths[parent.toString()]) {\n                                continue;\n                            }\n                            // Compute if parent is visible and added file not yet part of it\n                            const parentStat = this.model.findClosest(parent);\n                            if (parentStat && parentStat.isDirectoryResolved && !this.model.findClosest(change.resource)) {\n                                return true;\n                            }\n                            // Keep track of path that can be ignored for faster lookup\n                            if (!parentStat || !parentStat.isDirectoryResolved) {\n                                ignoredPaths[parent.toString()] = true;\n                            }\n                        }\n                    }\n                    // Handle deleted files/folders\n                    const deleted = e.getDeleted();\n                    if (deleted.length) {\n                        // Check deleted: Refresh if deleted file/folder part of resolved root\n                        for (let j = 0; j < deleted.length; j++) {\n                            const del = deleted[j];\n                            const item = this.model.findClosest(del.resource);\n                            if (item && item.parent) {\n                                return true;\n                            }\n                        }\n                    }\n                    // Handle updated files/folders if we sort by modified\n                    if (this._sortOrder === files_1.SortOrderConfiguration.MODIFIED) {\n                        const updated = e.getUpdated();\n                        // Check updated: Refresh if updated file/folder part of resolved root\n                        for (let j = 0; j < updated.length; j++) {\n                            const upd = updated[j];\n                            const item = this.model.findClosest(upd.resource);\n                            if (item && item.parent) {\n                                return true;\n                            }\n                        }\n                    }\n                    return false;\n                };\n                if (true || shouldRefresh()) {\n                    this.roots.forEach(r => r.forgetChildren());\n                    this._onDidChangeItem.fire(undefined);\n                }\n            }, ExplorerService.EXPLORER_FILE_CHANGES_REACT_DELAY);\n        }\n        filterToViewRelevantEvents(e) {\n            return new files_2.FileChangesEvent(e.changes.filter(change => {\n                if (change.type === files_2.FileChangeType.UPDATED && this._sortOrder !== files_1.SortOrderConfiguration.MODIFIED) {\n                    return false; // we only are about updated if we sort by modified time\n                }\n                if (!this.contextService.isInsideWorkspace(change.resource)) {\n                    return false; // exclude changes for resources outside of workspace\n                }\n                if (this.fileEventsFilter.matches(change.resource)) {\n                    return false; // excluded via files.exclude setting\n                }\n                return true;\n            }));\n        }\n        onConfigurationUpdated(configuration, event) {\n            const configSortOrder = configuration && configuration.explorer && configuration.explorer.sortOrder || 'default';\n            if (this._sortOrder !== configSortOrder) {\n                const shouldRefresh = this._sortOrder !== undefined;\n                this._sortOrder = configSortOrder;\n                if (shouldRefresh) {\n                    this.refresh();\n                }\n            }\n        }\n        dispose() {\n            lifecycle_1.dispose(this.disposables);\n        }\n    };\n    ExplorerService.EXPLORER_FILE_CHANGES_REACT_DELAY = 500; // delay in ms to react to file changes to give our internal events a chance to react first\n    __decorate([\n        decorators_1.memoize\n    ], ExplorerService.prototype, \"fileEventsFilter\", null);\n    __decorate([\n        decorators_1.memoize\n    ], ExplorerService.prototype, \"model\", null);\n    ExplorerService = __decorate([\n        __param(0, files_2.IFileService),\n        __param(1, instantiation_1.IInstantiationService),\n        __param(2, configuration_1.IConfigurationService),\n        __param(3, workspace_1.IWorkspaceContextService),\n        __param(4, clipboardService_1.IClipboardService),\n        __param(5, editorService_1.IEditorService)\n    ], ExplorerService);\n    exports.ExplorerService = ExplorerService;\n});\n",null]}