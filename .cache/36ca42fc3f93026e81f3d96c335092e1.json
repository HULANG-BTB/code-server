{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/streams.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/streams.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar stream_1 = require(\"stream\");\nvar encoding_1 = require(\"vs/base/node/encoding\");\nvar files_1 = require(\"vs/platform/files/common/files\");\nvar errors_1 = require(\"vs/base/common/errors\");\nfunction createWritableOfProvider(provider, resource, opts) {\n    if (provider.capabilities & files_1.FileSystemProviderCapabilities.FileOpenReadWriteClose) {\n        return createWritable(provider, resource, opts);\n    }\n    else if (provider.capabilities & files_1.FileSystemProviderCapabilities.FileReadWrite) {\n        return createSimpleWritable(provider, resource, opts);\n    }\n    else {\n        throw errors_1.illegalArgument();\n    }\n}\nexports.createWritableOfProvider = createWritableOfProvider;\nfunction createSimpleWritable(provider, resource, opts) {\n    return new /** @class */ (function (_super) {\n        tslib_1.__extends(class_1, _super);\n        function class_1(opts) {\n            var _this = _super.call(this, opts) || this;\n            _this._chunks = [];\n            return _this;\n        }\n        class_1.prototype._write = function (chunk, encoding, callback) {\n            this._chunks.push(chunk);\n            callback(null);\n        };\n        class_1.prototype.end = function () {\n            var _this = this;\n            // todo@joh - end might have another chunk...\n            provider.writeFile(resource, Buffer.concat(this._chunks), opts).then(function (_) {\n                _super.prototype.end.call(_this);\n            }, function (err) {\n                _this.emit('error', err);\n            });\n        };\n        return class_1;\n    }(stream_1.Writable));\n}\nfunction createWritable(provider, resource, opts) {\n    return new /** @class */ (function (_super) {\n        tslib_1.__extends(class_2, _super);\n        function class_2(opts) {\n            var _this = _super.call(this, opts) || this;\n            _this._pos = 0;\n            return _this;\n        }\n        class_2.prototype._write = function (chunk, encoding, callback) {\n            return tslib_1.__awaiter(this, void 0, void 0, function () {\n                var _a, bytesWritten, err_1;\n                return tslib_1.__generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _b.trys.push([0, 4, , 5]);\n                            if (!(typeof this._fd !== 'number')) return [3 /*break*/, 2];\n                            _a = this;\n                            return [4 /*yield*/, provider.open(resource, { create: true })];\n                        case 1:\n                            _a._fd = _b.sent();\n                            _b.label = 2;\n                        case 2: return [4 /*yield*/, provider.write(this._fd, this._pos, chunk, 0, chunk.length)];\n                        case 3:\n                            bytesWritten = _b.sent();\n                            this._pos += bytesWritten;\n                            callback();\n                            return [3 /*break*/, 5];\n                        case 4:\n                            err_1 = _b.sent();\n                            callback(err_1);\n                            return [3 /*break*/, 5];\n                        case 5: return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        class_2.prototype._final = function (callback) {\n            if (typeof this._fd !== 'number') {\n                provider.open(resource, { create: true }).then(function (fd) { return provider.close(fd); }).finally(callback);\n            }\n            else {\n                provider.close(this._fd).finally(callback);\n            }\n        };\n        return class_2;\n    }(stream_1.Writable));\n}\nfunction createReadableOfProvider(provider, resource, position) {\n    if (provider.capabilities & files_1.FileSystemProviderCapabilities.FileOpenReadWriteClose) {\n        return createReadable(provider, resource, position);\n    }\n    else if (provider.capabilities & files_1.FileSystemProviderCapabilities.FileReadWrite) {\n        return createSimpleReadable(provider, resource, position);\n    }\n    else {\n        throw errors_1.illegalArgument();\n    }\n}\nexports.createReadableOfProvider = createReadableOfProvider;\nfunction createReadable(provider, resource, position) {\n    return new /** @class */ (function (_super) {\n        tslib_1.__extends(class_3, _super);\n        function class_3() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this._pos = position;\n            _this._reading = false;\n            return _this;\n        }\n        class_3.prototype._read = function (size) {\n            if (size === void 0) { size = Math.pow(2, 10); }\n            return tslib_1.__awaiter(this, void 0, void 0, function () {\n                var _a, buffer, bytesRead, err_2;\n                return tslib_1.__generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            if (this._reading) {\n                                return [2 /*return*/];\n                            }\n                            this._reading = true;\n                            _b.label = 1;\n                        case 1:\n                            _b.trys.push([1, 9, , 10]);\n                            if (!(typeof this._fd !== 'number')) return [3 /*break*/, 3];\n                            _a = this;\n                            return [4 /*yield*/, provider.open(resource, { create: false })];\n                        case 2:\n                            _a._fd = _b.sent();\n                            _b.label = 3;\n                        case 3:\n                            if (!this._reading) return [3 /*break*/, 8];\n                            buffer = Buffer.allocUnsafe(size);\n                            return [4 /*yield*/, provider.read(this._fd, this._pos, buffer, 0, buffer.length)];\n                        case 4:\n                            bytesRead = _b.sent();\n                            if (!(bytesRead === 0)) return [3 /*break*/, 6];\n                            return [4 /*yield*/, provider.close(this._fd)];\n                        case 5:\n                            _b.sent();\n                            this._reading = false;\n                            this.push(null);\n                            return [3 /*break*/, 7];\n                        case 6:\n                            this._reading = this.push(buffer.slice(0, bytesRead));\n                            this._pos += bytesRead;\n                            _b.label = 7;\n                        case 7: return [3 /*break*/, 3];\n                        case 8: return [3 /*break*/, 10];\n                        case 9:\n                            err_2 = _b.sent();\n                            //\n                            this.emit('error', err_2);\n                            return [3 /*break*/, 10];\n                        case 10: return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        class_3.prototype._destroy = function (_err, callback) {\n            if (typeof this._fd === 'number') {\n                provider.close(this._fd).then(callback, callback);\n            }\n        };\n        return class_3;\n    }(stream_1.Readable));\n}\nfunction createSimpleReadable(provider, resource, position) {\n    return new /** @class */ (function (_super) {\n        tslib_1.__extends(class_4, _super);\n        function class_4() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        class_4.prototype._read = function (size) {\n            var _this = this;\n            if (this._readOperation) {\n                return;\n            }\n            this._readOperation = provider.readFile(resource).then(function (data) {\n                _this.push(data.slice(position));\n                _this.push(null);\n            }, function (err) {\n                _this.emit('error', err);\n                _this.push(null);\n            });\n        };\n        return class_4;\n    }(stream_1.Readable));\n}\nfunction createReadableOfSnapshot(snapshot) {\n    return new stream_1.Readable({\n        read: function () {\n            try {\n                var chunk = null;\n                var canPush = true;\n                // Push all chunks as long as we can push and as long as\n                // the underlying snapshot returns strings to us\n                while (canPush && typeof (chunk = snapshot.read()) === 'string') {\n                    canPush = this.push(chunk);\n                }\n                // Signal EOS by pushing NULL\n                if (typeof chunk !== 'string') {\n                    this.push(null);\n                }\n            }\n            catch (error) {\n                this.emit('error', error);\n            }\n        },\n        encoding: encoding_1.UTF8 // very important, so that strings are passed around and not buffers!\n    });\n}\nexports.createReadableOfSnapshot = createReadableOfSnapshot;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/streams.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/streams.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Readable, Writable, WritableOptions } from 'stream';\nimport { UTF8 } from 'vs/base/node/encoding';\nimport { URI } from 'vs/base/common/uri';\nimport { IFileSystemProvider, ITextSnapshot, FileSystemProviderCapabilities, FileWriteOptions } from 'vs/platform/files/common/files';\nimport { illegalArgument } from 'vs/base/common/errors';\n\nexport function createWritableOfProvider(provider: IFileSystemProvider, resource: URI, opts: FileWriteOptions): Writable {\n\tif (provider.capabilities & FileSystemProviderCapabilities.FileOpenReadWriteClose) {\n\t\treturn createWritable(provider, resource, opts);\n\t} else if (provider.capabilities & FileSystemProviderCapabilities.FileReadWrite) {\n\t\treturn createSimpleWritable(provider, resource, opts);\n\t} else {\n\t\tthrow illegalArgument();\n\t}\n}\n\nfunction createSimpleWritable(provider: IFileSystemProvider, resource: URI, opts: FileWriteOptions): Writable {\n\treturn new class extends Writable {\n\t\t_chunks: Buffer[] = [];\n\t\tconstructor(opts?: WritableOptions) {\n\t\t\tsuper(opts);\n\t\t}\n\t\t_write(chunk: Buffer, encoding: string, callback: Function) {\n\t\t\tthis._chunks.push(chunk);\n\t\t\tcallback(null);\n\t\t}\n\t\tend() {\n\t\t\t// todo@joh - end might have another chunk...\n\t\t\tprovider.writeFile!(resource, Buffer.concat(this._chunks), opts).then(_ => {\n\t\t\t\tsuper.end();\n\t\t\t}, err => {\n\t\t\t\tthis.emit('error', err);\n\t\t\t});\n\t\t}\n\t};\n}\n\nfunction createWritable(provider: IFileSystemProvider, resource: URI, opts: FileWriteOptions): Writable {\n\treturn new class extends Writable {\n\t\t_fd: number;\n\t\t_pos: number = 0;\n\t\tconstructor(opts?: WritableOptions) {\n\t\t\tsuper(opts);\n\t\t}\n\t\tasync _write(chunk: Buffer, encoding: string, callback: Function) {\n\t\t\ttry {\n\t\t\t\tif (typeof this._fd !== 'number') {\n\t\t\t\t\tthis._fd = await provider.open!(resource, { create: true });\n\t\t\t\t}\n\t\t\t\tlet bytesWritten = await provider.write!(this._fd, this._pos, chunk, 0, chunk.length);\n\t\t\t\tthis._pos += bytesWritten;\n\t\t\t\tcallback();\n\t\t\t} catch (err) {\n\t\t\t\tcallback(err);\n\t\t\t}\n\t\t}\n\t\t_final(callback: (err?: any) => any) {\n\t\t\tif (typeof this._fd !== 'number') {\n\t\t\t\tprovider.open!(resource, { create: true }).then(fd => provider.close!(fd)).finally(callback);\n\t\t\t} else {\n\t\t\t\tprovider.close!(this._fd).finally(callback);\n\t\t\t}\n\t\t}\n\t};\n}\n\nexport function createReadableOfProvider(provider: IFileSystemProvider, resource: URI, position: number): Readable {\n\tif (provider.capabilities & FileSystemProviderCapabilities.FileOpenReadWriteClose) {\n\t\treturn createReadable(provider, resource, position);\n\t} else if (provider.capabilities & FileSystemProviderCapabilities.FileReadWrite) {\n\t\treturn createSimpleReadable(provider, resource, position);\n\t} else {\n\t\tthrow illegalArgument();\n\t}\n}\n\nfunction createReadable(provider: IFileSystemProvider, resource: URI, position: number): Readable {\n\treturn new class extends Readable {\n\t\t_fd: number;\n\t\t_pos: number = position;\n\t\t_reading: boolean = false;\n\n\t\tasync _read(size: number = 2 ** 10) {\n\t\t\tif (this._reading) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._reading = true;\n\t\t\ttry {\n\t\t\t\tif (typeof this._fd !== 'number') {\n\t\t\t\t\tthis._fd = await provider.open!(resource, { create: false });\n\t\t\t\t}\n\t\t\t\twhile (this._reading) {\n\t\t\t\t\tlet buffer = Buffer.allocUnsafe(size);\n\t\t\t\t\tlet bytesRead = await provider.read!(this._fd, this._pos, buffer, 0, buffer.length);\n\t\t\t\t\tif (bytesRead === 0) {\n\t\t\t\t\t\tawait provider.close!(this._fd);\n\t\t\t\t\t\tthis._reading = false;\n\t\t\t\t\t\tthis.push(null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._reading = this.push(buffer.slice(0, bytesRead));\n\t\t\t\t\t\tthis._pos += bytesRead;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t//\n\t\t\t\tthis.emit('error', err);\n\t\t\t}\n\t\t}\n\t\t_destroy(_err: any, callback: (err?: any) => any) {\n\t\t\tif (typeof this._fd === 'number') {\n\t\t\t\tprovider.close!(this._fd).then(callback, callback);\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction createSimpleReadable(provider: IFileSystemProvider, resource: URI, position: number): Readable {\n\treturn new class extends Readable {\n\t\t_readOperation: Promise<any>;\n\t\t_read(size?: number): void {\n\t\t\tif (this._readOperation) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._readOperation = provider.readFile!(resource).then(data => {\n\t\t\t\tthis.push(data.slice(position));\n\t\t\t\tthis.push(null);\n\t\t\t}, err => {\n\t\t\t\tthis.emit('error', err);\n\t\t\t\tthis.push(null);\n\t\t\t});\n\t\t}\n\t};\n}\n\nexport function createReadableOfSnapshot(snapshot: ITextSnapshot): Readable {\n\treturn new Readable({\n\t\tread: function () {\n\t\t\ttry {\n\t\t\t\tlet chunk: string | null = null;\n\t\t\t\tlet canPush = true;\n\n\t\t\t\t// Push all chunks as long as we can push and as long as\n\t\t\t\t// the underlying snapshot returns strings to us\n\t\t\t\twhile (canPush && typeof (chunk = snapshot.read()) === 'string') {\n\t\t\t\t\tcanPush = this.push(chunk);\n\t\t\t\t}\n\n\t\t\t\t// Signal EOS by pushing NULL\n\t\t\t\tif (typeof chunk !== 'string') {\n\t\t\t\t\tthis.push(null);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis.emit('error', error);\n\t\t\t}\n\t\t},\n\t\tencoding: UTF8 // very important, so that strings are passed around and not buffers!\n\t});\n}\n"]}]}