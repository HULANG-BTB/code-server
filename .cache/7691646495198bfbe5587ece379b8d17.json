{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/common/searchHelpers.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/common/searchHelpers.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar search_1 = require(\"vs/workbench/services/search/common/search\");\nfunction editorMatchToTextSearchResult(matches, model, previewOptions) {\n    var firstLine = matches[0].range.startLineNumber;\n    var lastLine = matches[matches.length - 1].range.endLineNumber;\n    var lineTexts = [];\n    for (var i = firstLine; i <= lastLine; i++) {\n        lineTexts.push(model.getLineContent(i));\n    }\n    return new search_1.TextSearchMatch(lineTexts.join('\\n') + '\\n', matches.map(function (m) { return new range_1.Range(m.range.startLineNumber - 1, m.range.startColumn - 1, m.range.endLineNumber - 1, m.range.endColumn - 1); }), previewOptions);\n}\n/**\n * Combine a set of FindMatches into a set of TextSearchResults. They should be grouped by matches that start on the same line that the previous match ends on.\n */\nfunction editorMatchesToTextSearchResults(matches, model, previewOptions) {\n    var previousEndLine = -1;\n    var groupedMatches = [];\n    var currentMatches = [];\n    matches.forEach(function (match) {\n        if (match.range.startLineNumber !== previousEndLine) {\n            currentMatches = [];\n            groupedMatches.push(currentMatches);\n        }\n        currentMatches.push(match);\n        previousEndLine = match.range.endLineNumber;\n    });\n    return groupedMatches.map(function (sameLineMatches) {\n        return editorMatchToTextSearchResult(sameLineMatches, model, previewOptions);\n    });\n}\nexports.editorMatchesToTextSearchResults = editorMatchesToTextSearchResults;\nfunction addContextToEditorMatches(matches, model, query) {\n    var results = [];\n    var prevLine = -1;\n    for (var i = 0; i < matches.length; i++) {\n        var _a = getMatchStartEnd(matches[i]), matchStartLine = _a.start, matchEndLine = _a.end;\n        if (typeof query.beforeContext === 'number' && query.beforeContext > 0) {\n            var beforeContextStartLine = Math.max(prevLine + 1, matchStartLine - query.beforeContext);\n            for (var b = beforeContextStartLine; b < matchStartLine; b++) {\n                results.push({\n                    text: model.getLineContent(b + 1),\n                    lineNumber: b\n                });\n            }\n        }\n        results.push(matches[i]);\n        var nextMatch = matches[i + 1];\n        var nextMatchStartLine = nextMatch ? getMatchStartEnd(nextMatch).start : Number.MAX_VALUE;\n        if (typeof query.afterContext === 'number' && query.afterContext > 0) {\n            var afterContextToLine = Math.min(nextMatchStartLine - 1, matchEndLine + query.afterContext, model.getLineCount() - 1);\n            for (var a = matchEndLine + 1; a <= afterContextToLine; a++) {\n                results.push({\n                    text: model.getLineContent(a + 1),\n                    lineNumber: a\n                });\n            }\n        }\n        prevLine = matchEndLine;\n    }\n    return results;\n}\nexports.addContextToEditorMatches = addContextToEditorMatches;\nfunction getMatchStartEnd(match) {\n    var matchRanges = match.ranges;\n    var matchStartLine = Array.isArray(matchRanges) ? matchRanges[0].startLineNumber : matchRanges.startLineNumber;\n    var matchEndLine = Array.isArray(matchRanges) ? matchRanges[matchRanges.length - 1].endLineNumber : matchRanges.endLineNumber;\n    return {\n        start: matchStartLine,\n        end: matchEndLine\n    };\n}\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/common/searchHelpers.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/common/searchHelpers.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Range } from 'vs/editor/common/core/range';\nimport { FindMatch, ITextModel } from 'vs/editor/common/model';\nimport { ITextSearchPreviewOptions, TextSearchMatch, ITextSearchResult, ITextSearchMatch, ITextQuery, ITextSearchContext } from 'vs/workbench/services/search/common/search';\n\nfunction editorMatchToTextSearchResult(matches: FindMatch[], model: ITextModel, previewOptions?: ITextSearchPreviewOptions): TextSearchMatch {\n\tconst firstLine = matches[0].range.startLineNumber;\n\tconst lastLine = matches[matches.length - 1].range.endLineNumber;\n\n\tconst lineTexts: string[] = [];\n\tfor (let i = firstLine; i <= lastLine; i++) {\n\t\tlineTexts.push(model.getLineContent(i));\n\t}\n\n\treturn new TextSearchMatch(\n\t\tlineTexts.join('\\n') + '\\n',\n\t\tmatches.map(m => new Range(m.range.startLineNumber - 1, m.range.startColumn - 1, m.range.endLineNumber - 1, m.range.endColumn - 1)),\n\t\tpreviewOptions);\n}\n\n/**\n * Combine a set of FindMatches into a set of TextSearchResults. They should be grouped by matches that start on the same line that the previous match ends on.\n */\nexport function editorMatchesToTextSearchResults(matches: FindMatch[], model: ITextModel, previewOptions?: ITextSearchPreviewOptions): TextSearchMatch[] {\n\tlet previousEndLine = -1;\n\tconst groupedMatches: FindMatch[][] = [];\n\tlet currentMatches: FindMatch[] = [];\n\tmatches.forEach((match) => {\n\t\tif (match.range.startLineNumber !== previousEndLine) {\n\t\t\tcurrentMatches = [];\n\t\t\tgroupedMatches.push(currentMatches);\n\t\t}\n\n\t\tcurrentMatches.push(match);\n\t\tpreviousEndLine = match.range.endLineNumber;\n\t});\n\n\treturn groupedMatches.map(sameLineMatches => {\n\t\treturn editorMatchToTextSearchResult(sameLineMatches, model, previewOptions);\n\t});\n}\n\nexport function addContextToEditorMatches(matches: ITextSearchMatch[], model: ITextModel, query: ITextQuery): ITextSearchResult[] {\n\tconst results: ITextSearchResult[] = [];\n\n\tlet prevLine = -1;\n\tfor (let i = 0; i < matches.length; i++) {\n\t\tconst { start: matchStartLine, end: matchEndLine } = getMatchStartEnd(matches[i]);\n\t\tif (typeof query.beforeContext === 'number' && query.beforeContext > 0) {\n\t\t\tconst beforeContextStartLine = Math.max(prevLine + 1, matchStartLine - query.beforeContext);\n\t\t\tfor (let b = beforeContextStartLine; b < matchStartLine; b++) {\n\t\t\t\tresults.push(<ITextSearchContext>{\n\t\t\t\t\ttext: model.getLineContent(b + 1),\n\t\t\t\t\tlineNumber: b\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tresults.push(matches[i]);\n\n\t\tconst nextMatch = matches[i + 1];\n\t\tconst nextMatchStartLine = nextMatch ? getMatchStartEnd(nextMatch).start : Number.MAX_VALUE;\n\t\tif (typeof query.afterContext === 'number' && query.afterContext > 0) {\n\t\t\tconst afterContextToLine = Math.min(nextMatchStartLine - 1, matchEndLine + query.afterContext, model.getLineCount() - 1);\n\t\t\tfor (let a = matchEndLine + 1; a <= afterContextToLine; a++) {\n\t\t\t\tresults.push(<ITextSearchContext>{\n\t\t\t\t\ttext: model.getLineContent(a + 1),\n\t\t\t\t\tlineNumber: a\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tprevLine = matchEndLine;\n\t}\n\n\treturn results;\n}\n\nfunction getMatchStartEnd(match: ITextSearchMatch): { start: number, end: number } {\n\tconst matchRanges = match.ranges;\n\tconst matchStartLine = Array.isArray(matchRanges) ? matchRanges[0].startLineNumber : matchRanges.startLineNumber;\n\tconst matchEndLine = Array.isArray(matchRanges) ? matchRanges[matchRanges.length - 1].endLineNumber : matchRanges.endLineNumber;\n\n\treturn {\n\t\tstart: matchStartLine,\n\t\tend: matchEndLine\n\t};\n}"]}]}