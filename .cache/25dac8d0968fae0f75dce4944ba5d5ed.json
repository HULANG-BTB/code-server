{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/map.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/map.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/uri\", \"vs/base/common/charCode\", \"./iterator\"], function (require, exports, uri_1, charCode_1, iterator_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function values(forEachable) {\n        const result = [];\n        forEachable.forEach(value => result.push(value));\n        return result;\n    }\n    exports.values = values;\n    function keys(map) {\n        const result = [];\n        map.forEach((value, key) => result.push(key));\n        return result;\n    }\n    exports.keys = keys;\n    function getOrSet(map, key, value) {\n        let result = map.get(key);\n        if (result === undefined) {\n            result = value;\n            map.set(key, result);\n        }\n        return result;\n    }\n    exports.getOrSet = getOrSet;\n    function mapToString(map) {\n        const entries = [];\n        map.forEach((value, key) => {\n            entries.push(`${key} => ${value}`);\n        });\n        return `Map(${map.size}) {${entries.join(', ')}}`;\n    }\n    exports.mapToString = mapToString;\n    function setToString(set) {\n        const entries = [];\n        set.forEach(value => {\n            entries.push(value);\n        });\n        return `Set(${set.size}) {${entries.join(', ')}}`;\n    }\n    exports.setToString = setToString;\n    function mapToSerializable(map) {\n        const serializable = [];\n        map.forEach((value, key) => {\n            serializable.push([key, value]);\n        });\n        return serializable;\n    }\n    exports.mapToSerializable = mapToSerializable;\n    function serializableToMap(serializable) {\n        const items = new Map();\n        for (const [key, value] of serializable) {\n            items.set(key, value);\n        }\n        return items;\n    }\n    exports.serializableToMap = serializableToMap;\n    class StringIterator {\n        constructor() {\n            this._value = '';\n            this._pos = 0;\n        }\n        reset(key) {\n            this._value = key;\n            this._pos = 0;\n            return this;\n        }\n        next() {\n            this._pos += 1;\n            return this;\n        }\n        hasNext() {\n            return this._pos < this._value.length - 1;\n        }\n        cmp(a) {\n            const aCode = a.charCodeAt(0);\n            const thisCode = this._value.charCodeAt(this._pos);\n            return aCode - thisCode;\n        }\n        value() {\n            return this._value[this._pos];\n        }\n    }\n    exports.StringIterator = StringIterator;\n    class PathIterator {\n        reset(key) {\n            this._value = key.replace(/\\\\$|\\/$/, '');\n            this._from = 0;\n            this._to = 0;\n            return this.next();\n        }\n        hasNext() {\n            return this._to < this._value.length;\n        }\n        next() {\n            // this._data = key.split(/[\\\\/]/).filter(s => !!s);\n            this._from = this._to;\n            let justSeps = true;\n            for (; this._to < this._value.length; this._to++) {\n                const ch = this._value.charCodeAt(this._to);\n                if (ch === charCode_1.CharCode.Slash || ch === charCode_1.CharCode.Backslash) {\n                    if (justSeps) {\n                        this._from++;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                else {\n                    justSeps = false;\n                }\n            }\n            return this;\n        }\n        cmp(a) {\n            let aPos = 0;\n            const aLen = a.length;\n            let thisPos = this._from;\n            while (aPos < aLen && thisPos < this._to) {\n                const cmp = a.charCodeAt(aPos) - this._value.charCodeAt(thisPos);\n                if (cmp !== 0) {\n                    return cmp;\n                }\n                aPos += 1;\n                thisPos += 1;\n            }\n            if (aLen === this._to - this._from) {\n                return 0;\n            }\n            else if (aPos < aLen) {\n                return -1;\n            }\n            else {\n                return 1;\n            }\n        }\n        value() {\n            return this._value.substring(this._from, this._to);\n        }\n    }\n    exports.PathIterator = PathIterator;\n    class TernarySearchTreeNode {\n        isEmpty() {\n            return !this.left && !this.mid && !this.right && !this.value;\n        }\n    }\n    class TernarySearchTree {\n        constructor(segments) {\n            this._iter = segments;\n        }\n        static forPaths() {\n            return new TernarySearchTree(new PathIterator());\n        }\n        static forStrings() {\n            return new TernarySearchTree(new StringIterator());\n        }\n        clear() {\n            this._root = undefined;\n        }\n        set(key, element) {\n            const iter = this._iter.reset(key);\n            let node;\n            if (!this._root) {\n                this._root = new TernarySearchTreeNode();\n                this._root.segment = iter.value();\n            }\n            node = this._root;\n            while (true) {\n                const val = iter.cmp(node.segment);\n                if (val > 0) {\n                    // left\n                    if (!node.left) {\n                        node.left = new TernarySearchTreeNode();\n                        node.left.segment = iter.value();\n                    }\n                    node = node.left;\n                }\n                else if (val < 0) {\n                    // right\n                    if (!node.right) {\n                        node.right = new TernarySearchTreeNode();\n                        node.right.segment = iter.value();\n                    }\n                    node = node.right;\n                }\n                else if (iter.hasNext()) {\n                    // mid\n                    iter.next();\n                    if (!node.mid) {\n                        node.mid = new TernarySearchTreeNode();\n                        node.mid.segment = iter.value();\n                    }\n                    node = node.mid;\n                }\n                else {\n                    break;\n                }\n            }\n            const oldElement = node.value;\n            node.value = element;\n            node.key = key;\n            return oldElement;\n        }\n        get(key) {\n            const iter = this._iter.reset(key);\n            let node = this._root;\n            while (node) {\n                const val = iter.cmp(node.segment);\n                if (val > 0) {\n                    // left\n                    node = node.left;\n                }\n                else if (val < 0) {\n                    // right\n                    node = node.right;\n                }\n                else if (iter.hasNext()) {\n                    // mid\n                    iter.next();\n                    node = node.mid;\n                }\n                else {\n                    break;\n                }\n            }\n            return node ? node.value : undefined;\n        }\n        delete(key) {\n            const iter = this._iter.reset(key);\n            const stack = [];\n            let node = this._root;\n            // find and unset node\n            while (node) {\n                const val = iter.cmp(node.segment);\n                if (val > 0) {\n                    // left\n                    stack.push([1, node]);\n                    node = node.left;\n                }\n                else if (val < 0) {\n                    // right\n                    stack.push([-1, node]);\n                    node = node.right;\n                }\n                else if (iter.hasNext()) {\n                    // mid\n                    iter.next();\n                    stack.push([0, node]);\n                    node = node.mid;\n                }\n                else {\n                    // remove element\n                    node.value = undefined;\n                    // clean up empty nodes\n                    while (stack.length > 0 && node.isEmpty()) {\n                        let [dir, parent] = stack.pop();\n                        switch (dir) {\n                            case 1:\n                                parent.left = undefined;\n                                break;\n                            case 0:\n                                parent.mid = undefined;\n                                break;\n                            case -1:\n                                parent.right = undefined;\n                                break;\n                        }\n                        node = parent;\n                    }\n                    break;\n                }\n            }\n        }\n        findSubstr(key) {\n            const iter = this._iter.reset(key);\n            let node = this._root;\n            let candidate = undefined;\n            while (node) {\n                const val = iter.cmp(node.segment);\n                if (val > 0) {\n                    // left\n                    node = node.left;\n                }\n                else if (val < 0) {\n                    // right\n                    node = node.right;\n                }\n                else if (iter.hasNext()) {\n                    // mid\n                    iter.next();\n                    candidate = node.value || candidate;\n                    node = node.mid;\n                }\n                else {\n                    break;\n                }\n            }\n            return node && node.value || candidate;\n        }\n        findSuperstr(key) {\n            const iter = this._iter.reset(key);\n            let node = this._root;\n            while (node) {\n                const val = iter.cmp(node.segment);\n                if (val > 0) {\n                    // left\n                    node = node.left;\n                }\n                else if (val < 0) {\n                    // right\n                    node = node.right;\n                }\n                else if (iter.hasNext()) {\n                    // mid\n                    iter.next();\n                    node = node.mid;\n                }\n                else {\n                    // collect\n                    if (!node.mid) {\n                        return undefined;\n                    }\n                    else {\n                        return this._nodeIterator(node.mid);\n                    }\n                }\n            }\n            return undefined;\n        }\n        _nodeIterator(node) {\n            let res;\n            let idx;\n            let data;\n            const next = () => {\n                if (!data) {\n                    // lazy till first invocation\n                    data = [];\n                    idx = 0;\n                    this._forEach(node, value => data.push(value));\n                }\n                if (idx >= data.length) {\n                    return iterator_1.FIN;\n                }\n                if (!res) {\n                    res = { done: false, value: data[idx++] };\n                }\n                else {\n                    res.value = data[idx++];\n                }\n                return res;\n            };\n            return { next };\n        }\n        forEach(callback) {\n            this._forEach(this._root, callback);\n        }\n        _forEach(node, callback) {\n            if (node) {\n                // left\n                this._forEach(node.left, callback);\n                // node\n                if (node.value) {\n                    // callback(node.value, this._iter.join(parts));\n                    callback(node.value, node.key);\n                }\n                // mid\n                this._forEach(node.mid, callback);\n                // right\n                this._forEach(node.right, callback);\n            }\n        }\n    }\n    exports.TernarySearchTree = TernarySearchTree;\n    class ResourceMap {\n        constructor() {\n            this.map = new Map();\n            this.ignoreCase = false; // in the future this should be an uri-comparator\n        }\n        set(resource, value) {\n            this.map.set(this.toKey(resource), value);\n        }\n        get(resource) {\n            return this.map.get(this.toKey(resource));\n        }\n        has(resource) {\n            return this.map.has(this.toKey(resource));\n        }\n        get size() {\n            return this.map.size;\n        }\n        clear() {\n            this.map.clear();\n        }\n        delete(resource) {\n            return this.map.delete(this.toKey(resource));\n        }\n        forEach(clb) {\n            this.map.forEach(clb);\n        }\n        values() {\n            return values(this.map);\n        }\n        toKey(resource) {\n            let key = resource.toString();\n            if (this.ignoreCase) {\n                key = key.toLowerCase();\n            }\n            return key;\n        }\n        keys() {\n            return keys(this.map).map(k => uri_1.URI.parse(k));\n        }\n        clone() {\n            const resourceMap = new ResourceMap();\n            this.map.forEach((value, key) => resourceMap.map.set(key, value));\n            return resourceMap;\n        }\n    }\n    exports.ResourceMap = ResourceMap;\n    var Touch;\n    (function (Touch) {\n        Touch[Touch[\"None\"] = 0] = \"None\";\n        Touch[Touch[\"AsOld\"] = 1] = \"AsOld\";\n        Touch[Touch[\"AsNew\"] = 2] = \"AsNew\";\n    })(Touch = exports.Touch || (exports.Touch = {}));\n    class LinkedMap {\n        constructor() {\n            this._map = new Map();\n            this._head = undefined;\n            this._tail = undefined;\n            this._size = 0;\n        }\n        clear() {\n            this._map.clear();\n            this._head = undefined;\n            this._tail = undefined;\n            this._size = 0;\n        }\n        isEmpty() {\n            return !this._head && !this._tail;\n        }\n        get size() {\n            return this._size;\n        }\n        has(key) {\n            return this._map.has(key);\n        }\n        get(key, touch = Touch.None) {\n            const item = this._map.get(key);\n            if (!item) {\n                return undefined;\n            }\n            if (touch !== Touch.None) {\n                this.touch(item, touch);\n            }\n            return item.value;\n        }\n        set(key, value, touch = Touch.None) {\n            let item = this._map.get(key);\n            if (item) {\n                item.value = value;\n                if (touch !== Touch.None) {\n                    this.touch(item, touch);\n                }\n            }\n            else {\n                item = { key, value, next: undefined, previous: undefined };\n                switch (touch) {\n                    case Touch.None:\n                        this.addItemLast(item);\n                        break;\n                    case Touch.AsOld:\n                        this.addItemFirst(item);\n                        break;\n                    case Touch.AsNew:\n                        this.addItemLast(item);\n                        break;\n                    default:\n                        this.addItemLast(item);\n                        break;\n                }\n                this._map.set(key, item);\n                this._size++;\n            }\n        }\n        delete(key) {\n            return !!this.remove(key);\n        }\n        remove(key) {\n            const item = this._map.get(key);\n            if (!item) {\n                return undefined;\n            }\n            this._map.delete(key);\n            this.removeItem(item);\n            this._size--;\n            return item.value;\n        }\n        shift() {\n            if (!this._head && !this._tail) {\n                return undefined;\n            }\n            if (!this._head || !this._tail) {\n                throw new Error('Invalid list');\n            }\n            const item = this._head;\n            this._map.delete(item.key);\n            this.removeItem(item);\n            this._size--;\n            return item.value;\n        }\n        forEach(callbackfn, thisArg) {\n            let current = this._head;\n            while (current) {\n                if (thisArg) {\n                    callbackfn.bind(thisArg)(current.value, current.key, this);\n                }\n                else {\n                    callbackfn(current.value, current.key, this);\n                }\n                current = current.next;\n            }\n        }\n        values() {\n            const result = [];\n            let current = this._head;\n            while (current) {\n                result.push(current.value);\n                current = current.next;\n            }\n            return result;\n        }\n        keys() {\n            const result = [];\n            let current = this._head;\n            while (current) {\n                result.push(current.key);\n                current = current.next;\n            }\n            return result;\n        }\n        /* VS Code / Monaco editor runs on es5 which has no Symbol.iterator\n        keys(): IterableIterator<K> {\n            const current = this._head;\n            const iterator: IterableIterator<K> = {\n                [Symbol.iterator]() {\n                    return iterator;\n                },\n                next():IteratorResult<K> {\n                    if (current) {\n                        const result = { value: current.key, done: false };\n                        current = current.next;\n                        return result;\n                    } else {\n                        return { value: undefined, done: true };\n                    }\n                }\n            };\n            return iterator;\n        }\n    \n        values(): IterableIterator<V> {\n            const current = this._head;\n            const iterator: IterableIterator<V> = {\n                [Symbol.iterator]() {\n                    return iterator;\n                },\n                next():IteratorResult<V> {\n                    if (current) {\n                        const result = { value: current.value, done: false };\n                        current = current.next;\n                        return result;\n                    } else {\n                        return { value: undefined, done: true };\n                    }\n                }\n            };\n            return iterator;\n        }\n        */\n        trimOld(newSize) {\n            if (newSize >= this.size) {\n                return;\n            }\n            if (newSize === 0) {\n                this.clear();\n                return;\n            }\n            let current = this._head;\n            let currentSize = this.size;\n            while (current && currentSize > newSize) {\n                this._map.delete(current.key);\n                current = current.next;\n                currentSize--;\n            }\n            this._head = current;\n            this._size = currentSize;\n            if (current) {\n                current.previous = undefined;\n            }\n        }\n        addItemFirst(item) {\n            // First time Insert\n            if (!this._head && !this._tail) {\n                this._tail = item;\n            }\n            else if (!this._head) {\n                throw new Error('Invalid list');\n            }\n            else {\n                item.next = this._head;\n                this._head.previous = item;\n            }\n            this._head = item;\n        }\n        addItemLast(item) {\n            // First time Insert\n            if (!this._head && !this._tail) {\n                this._head = item;\n            }\n            else if (!this._tail) {\n                throw new Error('Invalid list');\n            }\n            else {\n                item.previous = this._tail;\n                this._tail.next = item;\n            }\n            this._tail = item;\n        }\n        removeItem(item) {\n            if (item === this._head && item === this._tail) {\n                this._head = undefined;\n                this._tail = undefined;\n            }\n            else if (item === this._head) {\n                // This can only happend if size === 1 which is handle\n                // by the case above.\n                if (!item.next) {\n                    throw new Error('Invalid list');\n                }\n                item.next.previous = undefined;\n                this._head = item.next;\n            }\n            else if (item === this._tail) {\n                // This can only happend if size === 1 which is handle\n                // by the case above.\n                if (!item.previous) {\n                    throw new Error('Invalid list');\n                }\n                item.previous.next = undefined;\n                this._tail = item.previous;\n            }\n            else {\n                const next = item.next;\n                const previous = item.previous;\n                if (!next || !previous) {\n                    throw new Error('Invalid list');\n                }\n                next.previous = previous;\n                previous.next = next;\n            }\n            item.next = undefined;\n            item.previous = undefined;\n        }\n        touch(item, touch) {\n            if (!this._head || !this._tail) {\n                throw new Error('Invalid list');\n            }\n            if ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {\n                return;\n            }\n            if (touch === Touch.AsOld) {\n                if (item === this._head) {\n                    return;\n                }\n                const next = item.next;\n                const previous = item.previous;\n                // Unlink the item\n                if (item === this._tail) {\n                    // previous must be defined since item was not head but is tail\n                    // So there are more than on item in the map\n                    previous.next = undefined;\n                    this._tail = previous;\n                }\n                else {\n                    // Both next and previous are not undefined since item was neither head nor tail.\n                    next.previous = previous;\n                    previous.next = next;\n                }\n                // Insert the node at head\n                item.previous = undefined;\n                item.next = this._head;\n                this._head.previous = item;\n                this._head = item;\n            }\n            else if (touch === Touch.AsNew) {\n                if (item === this._tail) {\n                    return;\n                }\n                const next = item.next;\n                const previous = item.previous;\n                // Unlink the item.\n                if (item === this._head) {\n                    // next must be defined since item was not tail but is head\n                    // So there are more than on item in the map\n                    next.previous = undefined;\n                    this._head = next;\n                }\n                else {\n                    // Both next and previous are not undefined since item was neither head nor tail.\n                    next.previous = previous;\n                    previous.next = next;\n                }\n                item.next = undefined;\n                item.previous = this._tail;\n                this._tail.next = item;\n                this._tail = item;\n            }\n        }\n        toJSON() {\n            const data = [];\n            this.forEach((value, key) => {\n                data.push([key, value]);\n            });\n            return data;\n        }\n        fromJSON(data) {\n            this.clear();\n            for (const [key, value] of data) {\n                this.set(key, value);\n            }\n        }\n    }\n    exports.LinkedMap = LinkedMap;\n    class LRUCache extends LinkedMap {\n        constructor(limit, ratio = 1) {\n            super();\n            this._limit = limit;\n            this._ratio = Math.min(Math.max(0, ratio), 1);\n        }\n        get limit() {\n            return this._limit;\n        }\n        set limit(limit) {\n            this._limit = limit;\n            this.checkTrim();\n        }\n        get ratio() {\n            return this._ratio;\n        }\n        set ratio(ratio) {\n            this._ratio = Math.min(Math.max(0, ratio), 1);\n            this.checkTrim();\n        }\n        get(key) {\n            return super.get(key, Touch.AsNew);\n        }\n        peek(key) {\n            return super.get(key, Touch.None);\n        }\n        set(key, value) {\n            super.set(key, value, Touch.AsNew);\n            this.checkTrim();\n        }\n        checkTrim() {\n            if (this.size > this._limit) {\n                this.trimOld(Math.round(this._limit * this._ratio));\n            }\n        }\n    }\n    exports.LRUCache = LRUCache;\n});\n",null]}