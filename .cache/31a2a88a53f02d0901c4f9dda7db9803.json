{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/model/textModelSearch.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/textModelSearch.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar strings = require(\"vs/base/common/strings\");\nvar wordCharacterClassifier_1 = require(\"vs/editor/common/controller/wordCharacterClassifier\");\nvar position_1 = require(\"vs/editor/common/core/position\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar model_1 = require(\"vs/editor/common/model\");\nvar LIMIT_FIND_COUNT = 999;\nvar SearchParams = /** @class */ (function () {\n    function SearchParams(searchString, isRegex, matchCase, wordSeparators) {\n        this.searchString = searchString;\n        this.isRegex = isRegex;\n        this.matchCase = matchCase;\n        this.wordSeparators = wordSeparators;\n    }\n    SearchParams.prototype.parseSearchRequest = function () {\n        if (this.searchString === '') {\n            return null;\n        }\n        // Try to create a RegExp out of the params\n        var multiline;\n        if (this.isRegex) {\n            multiline = isMultilineRegexSource(this.searchString);\n        }\n        else {\n            multiline = (this.searchString.indexOf('\\n') >= 0);\n        }\n        var regex = null;\n        try {\n            regex = strings.createRegExp(this.searchString, this.isRegex, {\n                matchCase: this.matchCase,\n                wholeWord: false,\n                multiline: multiline,\n                global: true\n            });\n        }\n        catch (err) {\n            return null;\n        }\n        if (!regex) {\n            return null;\n        }\n        var canUseSimpleSearch = (!this.isRegex && !multiline);\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n            // casing might make a difference\n            canUseSimpleSearch = this.matchCase;\n        }\n        return new SearchData(regex, this.wordSeparators ? wordCharacterClassifier_1.getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);\n    };\n    return SearchParams;\n}());\nexports.SearchParams = SearchParams;\nfunction isMultilineRegexSource(searchString) {\n    if (!searchString || searchString.length === 0) {\n        return false;\n    }\n    for (var i = 0, len = searchString.length; i < len; i++) {\n        var chCode = searchString.charCodeAt(i);\n        if (chCode === charCode_1.CharCode.Backslash) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a \\\n                break;\n            }\n            var nextChCode = searchString.charCodeAt(i);\n            if (nextChCode === charCode_1.CharCode.n || nextChCode === charCode_1.CharCode.r || nextChCode === charCode_1.CharCode.W) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexports.isMultilineRegexSource = isMultilineRegexSource;\nvar SearchData = /** @class */ (function () {\n    function SearchData(regex, wordSeparators, simpleSearch) {\n        this.regex = regex;\n        this.wordSeparators = wordSeparators;\n        this.simpleSearch = simpleSearch;\n    }\n    return SearchData;\n}());\nexports.SearchData = SearchData;\nfunction createFindMatch(range, rawMatches, captureMatches) {\n    if (!captureMatches) {\n        return new model_1.FindMatch(range, null);\n    }\n    var matches = [];\n    for (var i = 0, len = rawMatches.length; i < len; i++) {\n        matches[i] = rawMatches[i];\n    }\n    return new model_1.FindMatch(range, matches);\n}\nexports.createFindMatch = createFindMatch;\nvar LineFeedCounter = /** @class */ (function () {\n    function LineFeedCounter(text) {\n        var lineFeedsOffsets = [];\n        var lineFeedsOffsetsLen = 0;\n        for (var i = 0, textLen = text.length; i < textLen; i++) {\n            if (text.charCodeAt(i) === charCode_1.CharCode.LineFeed) {\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n            }\n        }\n        this._lineFeedsOffsets = lineFeedsOffsets;\n    }\n    LineFeedCounter.prototype.findLineFeedCountBeforeOffset = function (offset) {\n        var lineFeedsOffsets = this._lineFeedsOffsets;\n        var min = 0;\n        var max = lineFeedsOffsets.length - 1;\n        if (max === -1) {\n            // no line feeds\n            return 0;\n        }\n        if (offset <= lineFeedsOffsets[0]) {\n            // before first line feed\n            return 0;\n        }\n        while (min < max) {\n            var mid = min + ((max - min) / 2 >> 0);\n            if (lineFeedsOffsets[mid] >= offset) {\n                max = mid - 1;\n            }\n            else {\n                if (lineFeedsOffsets[mid + 1] >= offset) {\n                    // bingo!\n                    min = mid;\n                    max = mid;\n                }\n                else {\n                    min = mid + 1;\n                }\n            }\n        }\n        return min + 1;\n    };\n    return LineFeedCounter;\n}());\nvar TextModelSearch = /** @class */ (function () {\n    function TextModelSearch() {\n    }\n    TextModelSearch.findMatches = function (model, searchParams, searchRange, captureMatches, limitResultCount) {\n        var searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return [];\n        }\n        if (searchData.regex.multiline) {\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n        }\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n    };\n    /**\n     * Multiline search always executes on the lines concatenated with \\n.\n     * We must therefore compensate for the count of \\n in case the model is CRLF\n     */\n    TextModelSearch._getMultilineMatchRange = function (model, deltaOffset, text, lfCounter, matchIndex, match0) {\n        var startOffset;\n        var lineFeedCountBeforeMatch = 0;\n        if (lfCounter) {\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            startOffset = deltaOffset + matchIndex;\n        }\n        var endOffset;\n        if (lfCounter) {\n            var lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n            var lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            endOffset = startOffset + match0.length;\n        }\n        var startPosition = model.getPositionAt(startOffset);\n        var endPosition = model.getPositionAt(endOffset);\n        return new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    };\n    TextModelSearch._doFindMatchesMultiline = function (model, searchRange, searcher, captureMatches, limitResultCount) {\n        var deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        var text = model.getValueInRange(searchRange, model_1.EndOfLinePreference.LF);\n        var lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        var result = [];\n        var counter = 0;\n        var m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n            if (counter >= limitResultCount) {\n                return result;\n            }\n        }\n        return result;\n    };\n    TextModelSearch._doFindMatchesLineByLine = function (model, searchRange, searchData, captureMatches, limitResultCount) {\n        var result = [];\n        var resultLen = 0;\n        // Early case for a search range that starts & stops on the same line number\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\n            var text_1 = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text_1, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        // Collect results from first line\n        var text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n        // Collect results from middle lines\n        for (var lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        // Collect results from last line\n        if (resultLen < limitResultCount) {\n            var text_2 = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text_2, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        return result;\n    };\n    TextModelSearch._findMatchesInLine = function (searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        var wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            var searchString = searchData.simpleSearch;\n            var searchStringLen = searchString.length;\n            var textLength = text.length;\n            var lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new model_1.FindMatch(new range_1.Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        var m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new range_1.Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    };\n    TextModelSearch.findNextMatch = function (model, searchParams, searchStart, captureMatches) {\n        var searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n    };\n    TextModelSearch._doFindNextMatchMultiline = function (model, searchStart, searcher, captureMatches) {\n        var searchTextStart = new position_1.Position(searchStart.lineNumber, 1);\n        var deltaOffset = model.getOffsetAt(searchTextStart);\n        var lineCount = model.getLineCount();\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        var text = model.getValueInRange(new range_1.Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), model_1.EndOfLinePreference.LF);\n        var lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        searcher.reset(searchStart.column - 1);\n        var m = searcher.next(text);\n        if (m) {\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n        }\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n            // Try again from the top\n            return this._doFindNextMatchMultiline(model, new position_1.Position(1, 1), searcher, captureMatches);\n        }\n        return null;\n    };\n    TextModelSearch._doFindNextMatchLineByLine = function (model, searchStart, searcher, captureMatches) {\n        var lineCount = model.getLineCount();\n        var startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        var text = model.getLineContent(startLineNumber);\n        var r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (var i = 1; i <= lineCount; i++) {\n            var lineIndex = (startLineNumber + i - 1) % lineCount;\n            var text_3 = model.getLineContent(lineIndex + 1);\n            var r_1 = this._findFirstMatchInLine(searcher, text_3, lineIndex + 1, 1, captureMatches);\n            if (r_1) {\n                return r_1;\n            }\n        }\n        return null;\n    };\n    TextModelSearch._findFirstMatchInLine = function (searcher, text, lineNumber, fromColumn, captureMatches) {\n        // Set regex to search from column\n        searcher.reset(fromColumn - 1);\n        var m = searcher.next(text);\n        if (m) {\n            return createFindMatch(new range_1.Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return null;\n    };\n    TextModelSearch.findPreviousMatch = function (model, searchParams, searchStart, captureMatches) {\n        var searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n    };\n    TextModelSearch._doFindPreviousMatchMultiline = function (model, searchStart, searcher, captureMatches) {\n        var matches = this._doFindMatchesMultiline(model, new range_1.Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n        if (matches.length > 0) {\n            return matches[matches.length - 1];\n        }\n        var lineCount = model.getLineCount();\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n            // Try again with all content\n            return this._doFindPreviousMatchMultiline(model, new position_1.Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n        }\n        return null;\n    };\n    TextModelSearch._doFindPreviousMatchLineByLine = function (model, searchStart, searcher, captureMatches) {\n        var lineCount = model.getLineCount();\n        var startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        var text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n        var r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (var i = 1; i <= lineCount; i++) {\n            var lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n            var text_4 = model.getLineContent(lineIndex + 1);\n            var r_2 = this._findLastMatchInLine(searcher, text_4, lineIndex + 1, captureMatches);\n            if (r_2) {\n                return r_2;\n            }\n        }\n        return null;\n    };\n    TextModelSearch._findLastMatchInLine = function (searcher, text, lineNumber, captureMatches) {\n        var bestResult = null;\n        var m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            bestResult = createFindMatch(new range_1.Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return bestResult;\n    };\n    return TextModelSearch;\n}());\nexports.TextModelSearch = TextModelSearch;\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex === 0) {\n        // Match starts at start of string\n        return true;\n    }\n    var charBefore = text.charCodeAt(matchStartIndex - 1);\n    if (wordSeparators.get(charBefore) !== wordCharacterClassifier_1.WordCharacterClass.Regular) {\n        // The character before the match is a word separator\n        return true;\n    }\n    if (charBefore === charCode_1.CharCode.CarriageReturn || charBefore === charCode_1.CharCode.LineFeed) {\n        // The character before the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        var firstCharInMatch = text.charCodeAt(matchStartIndex);\n        if (wordSeparators.get(firstCharInMatch) !== wordCharacterClassifier_1.WordCharacterClass.Regular) {\n            // The first character inside the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex + matchLength === textLength) {\n        // Match ends at end of string\n        return true;\n    }\n    var charAfter = text.charCodeAt(matchStartIndex + matchLength);\n    if (wordSeparators.get(charAfter) !== wordCharacterClassifier_1.WordCharacterClass.Regular) {\n        // The character after the match is a word separator\n        return true;\n    }\n    if (charAfter === charCode_1.CharCode.CarriageReturn || charAfter === charCode_1.CharCode.LineFeed) {\n        // The character after the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        var lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n        if (wordSeparators.get(lastCharInMatch) !== wordCharacterClassifier_1.WordCharacterClass.Regular) {\n            // The last character in the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nfunction isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\n}\nexports.isValidMatch = isValidMatch;\nvar Searcher = /** @class */ (function () {\n    function Searcher(wordSeparators, searchRegex) {\n        this._wordSeparators = wordSeparators;\n        this._searchRegex = searchRegex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    Searcher.prototype.reset = function (lastIndex) {\n        this._searchRegex.lastIndex = lastIndex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    };\n    Searcher.prototype.next = function (text) {\n        var textLength = text.length;\n        var m;\n        do {\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n                // Reached the end of the line\n                return null;\n            }\n            m = this._searchRegex.exec(text);\n            if (!m) {\n                return null;\n            }\n            var matchStartIndex = m.index;\n            var matchLength = m[0].length;\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n                // Exit early if the regex matches the same range twice\n                return null;\n            }\n            this._prevMatchStartIndex = matchStartIndex;\n            this._prevMatchLength = matchLength;\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n                return m;\n            }\n        } while (m);\n        return null;\n    };\n    return Searcher;\n}());\nexports.Searcher = Searcher;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/textModelSearch.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/model/textModelSearch.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as strings from 'vs/base/common/strings';\nimport { WordCharacterClass, WordCharacterClassifier, getMapForWordSeparators } from 'vs/editor/common/controller/wordCharacterClassifier';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { EndOfLinePreference, FindMatch } from 'vs/editor/common/model';\nimport { TextModel } from 'vs/editor/common/model/textModel';\n\nconst LIMIT_FIND_COUNT = 999;\n\nexport class SearchParams {\n\tpublic readonly searchString: string;\n\tpublic readonly isRegex: boolean;\n\tpublic readonly matchCase: boolean;\n\tpublic readonly wordSeparators: string | null;\n\n\tconstructor(searchString: string, isRegex: boolean, matchCase: boolean, wordSeparators: string | null) {\n\t\tthis.searchString = searchString;\n\t\tthis.isRegex = isRegex;\n\t\tthis.matchCase = matchCase;\n\t\tthis.wordSeparators = wordSeparators;\n\t}\n\n\tpublic parseSearchRequest(): SearchData | null {\n\t\tif (this.searchString === '') {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Try to create a RegExp out of the params\n\t\tlet multiline: boolean;\n\t\tif (this.isRegex) {\n\t\t\tmultiline = isMultilineRegexSource(this.searchString);\n\t\t} else {\n\t\t\tmultiline = (this.searchString.indexOf('\\n') >= 0);\n\t\t}\n\n\t\tlet regex: RegExp | null = null;\n\t\ttry {\n\t\t\tregex = strings.createRegExp(this.searchString, this.isRegex, {\n\t\t\t\tmatchCase: this.matchCase,\n\t\t\t\twholeWord: false,\n\t\t\t\tmultiline: multiline,\n\t\t\t\tglobal: true\n\t\t\t});\n\t\t} catch (err) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!regex) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet canUseSimpleSearch = (!this.isRegex && !multiline);\n\t\tif (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n\t\t\t// casing might make a difference\n\t\t\tcanUseSimpleSearch = this.matchCase;\n\t\t}\n\n\t\treturn new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);\n\t}\n}\n\nexport function isMultilineRegexSource(searchString: string): boolean {\n\tif (!searchString || searchString.length === 0) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0, len = searchString.length; i < len; i++) {\n\t\tconst chCode = searchString.charCodeAt(i);\n\n\t\tif (chCode === CharCode.Backslash) {\n\n\t\t\t// move to next char\n\t\t\ti++;\n\n\t\t\tif (i >= len) {\n\t\t\t\t// string ends with a \\\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst nextChCode = searchString.charCodeAt(i);\n\t\t\tif (nextChCode === CharCode.n || nextChCode === CharCode.r || nextChCode === CharCode.W) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport class SearchData {\n\n\t/**\n\t * The regex to search for. Always defined.\n\t */\n\tpublic readonly regex: RegExp;\n\t/**\n\t * The word separator classifier.\n\t */\n\tpublic readonly wordSeparators: WordCharacterClassifier | null;\n\t/**\n\t * The simple string to search for (if possible).\n\t */\n\tpublic readonly simpleSearch: string | null;\n\n\tconstructor(regex: RegExp, wordSeparators: WordCharacterClassifier | null, simpleSearch: string | null) {\n\t\tthis.regex = regex;\n\t\tthis.wordSeparators = wordSeparators;\n\t\tthis.simpleSearch = simpleSearch;\n\t}\n}\n\nexport function createFindMatch(range: Range, rawMatches: RegExpExecArray, captureMatches: boolean): FindMatch {\n\tif (!captureMatches) {\n\t\treturn new FindMatch(range, null);\n\t}\n\tlet matches: string[] = [];\n\tfor (let i = 0, len = rawMatches.length; i < len; i++) {\n\t\tmatches[i] = rawMatches[i];\n\t}\n\treturn new FindMatch(range, matches);\n}\n\nclass LineFeedCounter {\n\n\tprivate readonly _lineFeedsOffsets: number[];\n\n\tconstructor(text: string) {\n\t\tlet lineFeedsOffsets: number[] = [];\n\t\tlet lineFeedsOffsetsLen = 0;\n\t\tfor (let i = 0, textLen = text.length; i < textLen; i++) {\n\t\t\tif (text.charCodeAt(i) === CharCode.LineFeed) {\n\t\t\t\tlineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n\t\t\t}\n\t\t}\n\t\tthis._lineFeedsOffsets = lineFeedsOffsets;\n\t}\n\n\tpublic findLineFeedCountBeforeOffset(offset: number): number {\n\t\tconst lineFeedsOffsets = this._lineFeedsOffsets;\n\t\tlet min = 0;\n\t\tlet max = lineFeedsOffsets.length - 1;\n\n\t\tif (max === -1) {\n\t\t\t// no line feeds\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (offset <= lineFeedsOffsets[0]) {\n\t\t\t// before first line feed\n\t\t\treturn 0;\n\t\t}\n\n\t\twhile (min < max) {\n\t\t\tconst mid = min + ((max - min) / 2 >> 0);\n\n\t\t\tif (lineFeedsOffsets[mid] >= offset) {\n\t\t\t\tmax = mid - 1;\n\t\t\t} else {\n\t\t\t\tif (lineFeedsOffsets[mid + 1] >= offset) {\n\t\t\t\t\t// bingo!\n\t\t\t\t\tmin = mid;\n\t\t\t\t\tmax = mid;\n\t\t\t\t} else {\n\t\t\t\t\tmin = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min + 1;\n\t}\n}\n\nexport class TextModelSearch {\n\n\tpublic static findMatches(model: TextModel, searchParams: SearchParams, searchRange: Range, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n\t\t}\n\t\treturn this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n\t}\n\n\t/**\n\t * Multiline search always executes on the lines concatenated with \\n.\n\t * We must therefore compensate for the count of \\n in case the model is CRLF\n\t */\n\tprivate static _getMultilineMatchRange(model: TextModel, deltaOffset: number, text: string, lfCounter: LineFeedCounter | null, matchIndex: number, match0: string): Range {\n\t\tlet startOffset: number;\n\t\tlet lineFeedCountBeforeMatch = 0;\n\t\tif (lfCounter) {\n\t\t\tlineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n\t\t\tstartOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n\t\t} else {\n\t\t\tstartOffset = deltaOffset + matchIndex;\n\t\t}\n\n\t\tlet endOffset: number;\n\t\tif (lfCounter) {\n\t\t\tlet lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n\t\t\tlet lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n\t\t\tendOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n\t\t} else {\n\t\t\tendOffset = startOffset + match0.length;\n\t\t}\n\n\t\tconst startPosition = model.getPositionAt(startOffset);\n\t\tconst endPosition = model.getPositionAt(endOffset);\n\t\treturn new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n\t}\n\n\tprivate static _doFindMatchesMultiline(model: TextModel, searchRange: Range, searcher: Searcher, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n\t\t// We always execute multiline search over the lines joined with \\n\n\t\t// This makes it that \\n will match the EOL for both CRLF and LF models\n\t\t// We compensate for offset errors in `_getMultilineMatchRange`\n\t\tconst text = model.getValueInRange(searchRange, EndOfLinePreference.LF);\n\t\tconst lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n\n\t\tconst result: FindMatch[] = [];\n\t\tlet counter = 0;\n\n\t\tlet m: RegExpExecArray | null;\n\t\tsearcher.reset(0);\n\t\twhile ((m = searcher.next(text))) {\n\t\t\tresult[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n\t\t\tif (counter >= limitResultCount) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _doFindMatchesLineByLine(model: TextModel, searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst result: FindMatch[] = [];\n\t\tlet resultLen = 0;\n\n\t\t// Early case for a search range that starts & stops on the same line number\n\t\tif (searchRange.startLineNumber === searchRange.endLineNumber) {\n\t\t\tconst text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n\t\t\treturn result;\n\t\t}\n\n\t\t// Collect results from first line\n\t\tconst text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n\n\t\t// Collect results from middle lines\n\t\tfor (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n\t\t\tresultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n\t\t}\n\n\t\t// Collect results from last line\n\t\tif (resultLen < limitResultCount) {\n\t\t\tconst text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _findMatchesInLine(searchData: SearchData, text: string, lineNumber: number, deltaOffset: number, resultLen: number, result: FindMatch[], captureMatches: boolean, limitResultCount: number): number {\n\t\tconst wordSeparators = searchData.wordSeparators;\n\t\tif (!captureMatches && searchData.simpleSearch) {\n\t\t\tconst searchString = searchData.simpleSearch;\n\t\t\tconst searchStringLen = searchString.length;\n\t\t\tconst textLength = text.length;\n\n\t\t\tlet lastMatchIndex = -searchStringLen;\n\t\t\twhile ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n\t\t\t\tif (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n\t\t\t\t\tresult[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\t\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\t\treturn resultLen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resultLen;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tsearcher.reset(0);\n\t\tdo {\n\t\t\tm = searcher.next(text);\n\t\t\tif (m) {\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (m);\n\t\treturn resultLen;\n\t}\n\n\tpublic static findNextMatch(model: TextModel, searchParams: SearchParams, searchStart: Position, captureMatches: boolean): FindMatch | null {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n\t\t}\n\t\treturn this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n\t}\n\n\tprivate static _doFindNextMatchMultiline(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst searchTextStart = new Position(searchStart.lineNumber, 1);\n\t\tconst deltaOffset = model.getOffsetAt(searchTextStart);\n\t\tconst lineCount = model.getLineCount();\n\t\t// We always execute multiline search over the lines joined with \\n\n\t\t// This makes it that \\n will match the EOL for both CRLF and LF models\n\t\t// We compensate for offset errors in `_getMultilineMatchRange`\n\t\tconst text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), EndOfLinePreference.LF);\n\t\tconst lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n\t\tsearcher.reset(searchStart.column - 1);\n\t\tlet m = searcher.next(text);\n\t\tif (m) {\n\t\t\treturn createFindMatch(\n\t\t\t\tthis._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]),\n\t\t\t\tm,\n\t\t\t\tcaptureMatches\n\t\t\t);\n\t\t}\n\n\t\tif (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n\t\t\t// Try again from the top\n\t\t\treturn this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _doFindNextMatchLineByLine(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst lineCount = model.getLineCount();\n\t\tconst startLineNumber = searchStart.lineNumber;\n\n\t\t// Look in first line\n\t\tconst text = model.getLineContent(startLineNumber);\n\t\tconst r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\tfor (let i = 1; i <= lineCount; i++) {\n\t\t\tconst lineIndex = (startLineNumber + i - 1) % lineCount;\n\t\t\tconst text = model.getLineContent(lineIndex + 1);\n\t\t\tconst r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findFirstMatchInLine(searcher: Searcher, text: string, lineNumber: number, fromColumn: number, captureMatches: boolean): FindMatch | null {\n\t\t// Set regex to search from column\n\t\tsearcher.reset(fromColumn - 1);\n\t\tconst m: RegExpExecArray | null = searcher.next(text);\n\t\tif (m) {\n\t\t\treturn createFindMatch(\n\t\t\t\tnew Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length),\n\t\t\t\tm,\n\t\t\t\tcaptureMatches\n\t\t\t);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static findPreviousMatch(model: TextModel, searchParams: SearchParams, searchStart: Position, captureMatches: boolean): FindMatch | null {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n\t\t}\n\t\treturn this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n\t}\n\n\tprivate static _doFindPreviousMatchMultiline(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n\t\tif (matches.length > 0) {\n\t\t\treturn matches[matches.length - 1];\n\t\t}\n\n\t\tconst lineCount = model.getLineCount();\n\t\tif (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n\t\t\t// Try again with all content\n\t\t\treturn this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _doFindPreviousMatchLineByLine(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst lineCount = model.getLineCount();\n\t\tconst startLineNumber = searchStart.lineNumber;\n\n\t\t// Look in first line\n\t\tconst text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n\t\tconst r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\tfor (let i = 1; i <= lineCount; i++) {\n\t\t\tconst lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n\t\t\tconst text = model.getLineContent(lineIndex + 1);\n\t\t\tconst r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findLastMatchInLine(searcher: Searcher, text: string, lineNumber: number, captureMatches: boolean): FindMatch | null {\n\t\tlet bestResult: FindMatch | null = null;\n\t\tlet m: RegExpExecArray | null;\n\t\tsearcher.reset(0);\n\t\twhile ((m = searcher.next(text))) {\n\t\t\tbestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n\t\t}\n\t\treturn bestResult;\n\t}\n}\n\nfunction leftIsWordBounday(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\tif (matchStartIndex === 0) {\n\t\t// Match starts at start of string\n\t\treturn true;\n\t}\n\n\tconst charBefore = text.charCodeAt(matchStartIndex - 1);\n\tif (wordSeparators.get(charBefore) !== WordCharacterClass.Regular) {\n\t\t// The character before the match is a word separator\n\t\treturn true;\n\t}\n\n\tif (charBefore === CharCode.CarriageReturn || charBefore === CharCode.LineFeed) {\n\t\t// The character before the match is line break or carriage return.\n\t\treturn true;\n\t}\n\n\tif (matchLength > 0) {\n\t\tconst firstCharInMatch = text.charCodeAt(matchStartIndex);\n\t\tif (wordSeparators.get(firstCharInMatch) !== WordCharacterClass.Regular) {\n\t\t\t// The first character inside the match is a word separator\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nfunction rightIsWordBounday(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\tif (matchStartIndex + matchLength === textLength) {\n\t\t// Match ends at end of string\n\t\treturn true;\n\t}\n\n\tconst charAfter = text.charCodeAt(matchStartIndex + matchLength);\n\tif (wordSeparators.get(charAfter) !== WordCharacterClass.Regular) {\n\t\t// The character after the match is a word separator\n\t\treturn true;\n\t}\n\n\tif (charAfter === CharCode.CarriageReturn || charAfter === CharCode.LineFeed) {\n\t\t// The character after the match is line break or carriage return.\n\t\treturn true;\n\t}\n\n\tif (matchLength > 0) {\n\t\tconst lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n\t\tif (wordSeparators.get(lastCharInMatch) !== WordCharacterClass.Regular) {\n\t\t\t// The last character in the match is a word separator\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function isValidMatch(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\treturn (\n\t\tleftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n\t\t&& rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n\t);\n}\n\nexport class Searcher {\n\tprivate readonly _wordSeparators: WordCharacterClassifier | null;\n\tprivate readonly _searchRegex: RegExp;\n\tprivate _prevMatchStartIndex: number;\n\tprivate _prevMatchLength: number;\n\n\tconstructor(wordSeparators: WordCharacterClassifier | null, searchRegex: RegExp, ) {\n\t\tthis._wordSeparators = wordSeparators;\n\t\tthis._searchRegex = searchRegex;\n\t\tthis._prevMatchStartIndex = -1;\n\t\tthis._prevMatchLength = 0;\n\t}\n\n\tpublic reset(lastIndex: number): void {\n\t\tthis._searchRegex.lastIndex = lastIndex;\n\t\tthis._prevMatchStartIndex = -1;\n\t\tthis._prevMatchLength = 0;\n\t}\n\n\tpublic next(text: string): RegExpExecArray | null {\n\t\tconst textLength = text.length;\n\n\t\tlet m: RegExpExecArray | null;\n\t\tdo {\n\t\t\tif (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n\t\t\t\t// Reached the end of the line\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tm = this._searchRegex.exec(text);\n\t\t\tif (!m) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst matchStartIndex = m.index;\n\t\t\tconst matchLength = m[0].length;\n\t\t\tif (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n\t\t\t\t// Exit early if the regex matches the same range twice\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis._prevMatchStartIndex = matchStartIndex;\n\t\t\tthis._prevMatchLength = matchLength;\n\n\t\t\tif (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n\t\t\t\treturn m;\n\t\t\t}\n\n\t\t} while (m);\n\n\t\treturn null;\n\t}\n}\n"]}]}