{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/model/textModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/textModel.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/charCode\", \"vs/base/common/errors\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/base/common/stopwatch\", \"vs/base/common/strings\", \"vs/base/common/uri\", \"vs/editor/common/config/editorOptions\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\", \"vs/editor/common/core/selection\", \"vs/editor/common/model\", \"vs/editor/common/model/editStack\", \"vs/editor/common/model/indentationGuesser\", \"vs/editor/common/model/intervalTree\", \"vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder\", \"vs/editor/common/model/textModelEvents\", \"vs/editor/common/model/textModelSearch\", \"vs/editor/common/model/textModelTokens\", \"vs/editor/common/model/wordHelper\", \"vs/editor/common/modes\", \"vs/editor/common/modes/languageConfigurationRegistry\", \"vs/editor/common/modes/nullMode\", \"vs/editor/common/modes/supports\", \"vs/editor/common/modes/supports/richEditBrackets\", \"vs/base/common/types\"], function (require, exports, charCode_1, errors_1, event_1, lifecycle_1, stopwatch_1, strings, uri_1, editorOptions_1, position_1, range_1, selection_1, model, editStack_1, indentationGuesser_1, intervalTree_1, pieceTreeTextBufferBuilder_1, textModelEvents_1, textModelSearch_1, textModelTokens_1, wordHelper_1, modes_1, languageConfigurationRegistry_1, nullMode_1, supports_1, richEditBrackets_1, types_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const CHEAP_TOKENIZATION_LENGTH_LIMIT = 2048;\n    function createTextBufferBuilder() {\n        return new pieceTreeTextBufferBuilder_1.PieceTreeTextBufferBuilder();\n    }\n    function createTextBufferFactory(text) {\n        const builder = createTextBufferBuilder();\n        builder.acceptChunk(text);\n        return builder.finish();\n    }\n    exports.createTextBufferFactory = createTextBufferFactory;\n    function createTextBufferFactoryFromStream(stream, filter) {\n        return new Promise((c, e) => {\n            let done = false;\n            let builder = createTextBufferBuilder();\n            stream.on('data', (chunk) => {\n                if (filter) {\n                    chunk = filter(chunk);\n                }\n                builder.acceptChunk(chunk);\n            });\n            stream.on('error', (error) => {\n                if (!done) {\n                    done = true;\n                    e(error);\n                }\n            });\n            stream.on('end', () => {\n                if (!done) {\n                    done = true;\n                    c(builder.finish());\n                }\n            });\n        });\n    }\n    exports.createTextBufferFactoryFromStream = createTextBufferFactoryFromStream;\n    function createTextBufferFactoryFromSnapshot(snapshot) {\n        let builder = createTextBufferBuilder();\n        let chunk;\n        while (typeof (chunk = snapshot.read()) === 'string') {\n            builder.acceptChunk(chunk);\n        }\n        return builder.finish();\n    }\n    exports.createTextBufferFactoryFromSnapshot = createTextBufferFactoryFromSnapshot;\n    function createTextBuffer(value, defaultEOL) {\n        const factory = (typeof value === 'string' ? createTextBufferFactory(value) : value);\n        return factory.create(defaultEOL);\n    }\n    exports.createTextBuffer = createTextBuffer;\n    let MODEL_ID = 0;\n    /**\n     * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.\n     */\n    function singleLetter(result) {\n        const LETTERS_CNT = (charCode_1.CharCode.Z - charCode_1.CharCode.A + 1);\n        result = result % (2 * LETTERS_CNT);\n        if (result < LETTERS_CNT) {\n            return String.fromCharCode(charCode_1.CharCode.a + result);\n        }\n        return String.fromCharCode(charCode_1.CharCode.A + result - LETTERS_CNT);\n    }\n    const LIMIT_FIND_COUNT = 999;\n    exports.LONG_LINE_BOUNDARY = 10000;\n    class TextModelSnapshot {\n        constructor(source) {\n            this._source = source;\n            this._eos = false;\n        }\n        read() {\n            if (this._eos) {\n                return null;\n            }\n            let result = [], resultCnt = 0, resultLength = 0;\n            do {\n                let tmp = this._source.read();\n                if (tmp === null) {\n                    // end-of-stream\n                    this._eos = true;\n                    if (resultCnt === 0) {\n                        return null;\n                    }\n                    else {\n                        return result.join('');\n                    }\n                }\n                if (tmp.length > 0) {\n                    result[resultCnt++] = tmp;\n                    resultLength += tmp.length;\n                }\n                if (resultLength >= 64 * 1024) {\n                    return result.join('');\n                }\n            } while (true);\n        }\n    }\n    const invalidFunc = () => { throw new Error(`Invalid change accessor`); };\n    class TextModel extends lifecycle_1.Disposable {\n        //#endregion\n        constructor(source, creationOptions, languageIdentifier, associatedResource = null) {\n            super();\n            //#region Events\n            this._onWillDispose = this._register(new event_1.Emitter());\n            this.onWillDispose = this._onWillDispose.event;\n            this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter());\n            this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n            this._onDidChangeLanguage = this._register(new event_1.Emitter());\n            this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n            this._onDidChangeLanguageConfiguration = this._register(new event_1.Emitter());\n            this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n            this._onDidChangeTokens = this._register(new event_1.Emitter());\n            this.onDidChangeTokens = this._onDidChangeTokens.event;\n            this._onDidChangeOptions = this._register(new event_1.Emitter());\n            this.onDidChangeOptions = this._onDidChangeOptions.event;\n            this._eventEmitter = this._register(new DidChangeContentEmitter());\n            // Generate a new unique model id\n            MODEL_ID++;\n            this.id = '$model' + MODEL_ID;\n            this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n            if (typeof associatedResource === 'undefined' || associatedResource === null) {\n                this._associatedResource = uri_1.URI.parse('inmemory://model/' + MODEL_ID);\n            }\n            else {\n                this._associatedResource = associatedResource;\n            }\n            this._attachedEditorCount = 0;\n            this._buffer = createTextBuffer(source, creationOptions.defaultEOL);\n            this._options = TextModel.resolveOptions(this._buffer, creationOptions);\n            const bufferLineCount = this._buffer.getLineCount();\n            const bufferTextLength = this._buffer.getValueLengthInRange(new range_1.Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), model.EndOfLinePreference.TextDefined);\n            // !!! Make a decision in the ctor and permanently respect this decision !!!\n            // If a model is too large at construction time, it will never get tokenized,\n            // under no circumstances.\n            if (creationOptions.largeFileOptimizations) {\n                this._isTooLargeForTokenization = ((bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD)\n                    || (bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD));\n            }\n            else {\n                this._isTooLargeForTokenization = false;\n            }\n            this._isTooLargeForSyncing = (bufferTextLength > TextModel.MODEL_SYNC_LIMIT);\n            this._setVersionId(1);\n            this._isDisposed = false;\n            this._isDisposing = false;\n            this._languageIdentifier = languageIdentifier || nullMode_1.NULL_LANGUAGE_IDENTIFIER;\n            this._tokenizationListener = modes_1.TokenizationRegistry.onDidChange((e) => {\n                if (e.changedLanguages.indexOf(this._languageIdentifier.language) === -1) {\n                    return;\n                }\n                this._resetTokenizationState();\n                this.emitModelTokensChangedEvent({\n                    tokenizationSupportChanged: true,\n                    ranges: [{\n                            fromLineNumber: 1,\n                            toLineNumber: this.getLineCount()\n                        }]\n                });\n                if (this._shouldAutoTokenize()) {\n                    this._warmUpTokens();\n                }\n            });\n            this._revalidateTokensTimeout = -1;\n            this._languageRegistryListener = languageConfigurationRegistry_1.LanguageConfigurationRegistry.onDidChange((e) => {\n                if (e.languageIdentifier.id === this._languageIdentifier.id) {\n                    this._onDidChangeLanguageConfiguration.fire({});\n                }\n            });\n            this._resetTokenizationState();\n            this._instanceId = singleLetter(MODEL_ID);\n            this._lastDecorationId = 0;\n            this._decorations = Object.create(null);\n            this._decorationsTree = new DecorationsTrees();\n            this._commandManager = new editStack_1.EditStack(this);\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._trimAutoWhitespaceLines = null;\n        }\n        static createFromString(text, options = TextModel.DEFAULT_CREATION_OPTIONS, languageIdentifier = null, uri = null) {\n            return new TextModel(text, options, languageIdentifier, uri);\n        }\n        static resolveOptions(textBuffer, options) {\n            if (options.detectIndentation) {\n                const guessedIndentation = indentationGuesser_1.guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n                return new model.TextModelResolvedOptions({\n                    tabSize: guessedIndentation.tabSize,\n                    indentSize: guessedIndentation.tabSize,\n                    insertSpaces: guessedIndentation.insertSpaces,\n                    trimAutoWhitespace: options.trimAutoWhitespace,\n                    defaultEOL: options.defaultEOL\n                });\n            }\n            return new model.TextModelResolvedOptions({\n                tabSize: options.tabSize,\n                indentSize: options.indentSize,\n                insertSpaces: options.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL\n            });\n        }\n        onDidChangeRawContentFast(listener) {\n            return this._eventEmitter.fastEvent((e) => listener(e.rawContentChangedEvent));\n        }\n        onDidChangeRawContent(listener) {\n            return this._eventEmitter.slowEvent((e) => listener(e.rawContentChangedEvent));\n        }\n        onDidChangeContent(listener) {\n            return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n        }\n        dispose() {\n            this._isDisposing = true;\n            this._onWillDispose.fire();\n            this._tokenizationListener.dispose();\n            this._languageRegistryListener.dispose();\n            this._clearTimers();\n            this._isDisposed = true;\n            // Null out members, such that any use of a disposed model will throw exceptions sooner rather than later\n            super.dispose();\n            this._isDisposing = false;\n        }\n        _assertNotDisposed() {\n            if (this._isDisposed) {\n                throw new Error('Model is disposed!');\n            }\n        }\n        equalsTextBuffer(other) {\n            this._assertNotDisposed();\n            return this._buffer.equals(other);\n        }\n        _emitContentChangedEvent(rawChange, change) {\n            if (this._isDisposing) {\n                // Do not confuse listeners by emitting any event after disposing\n                return;\n            }\n            this._eventEmitter.fire(new textModelEvents_1.InternalModelContentChangeEvent(rawChange, change));\n        }\n        setValue(value) {\n            this._assertNotDisposed();\n            if (value === null) {\n                // There's nothing to do\n                return;\n            }\n            const textBuffer = createTextBuffer(value, this._options.defaultEOL);\n            this.setValueFromTextBuffer(textBuffer);\n        }\n        _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {\n            return {\n                changes: [{\n                        range: range,\n                        rangeOffset: rangeOffset,\n                        rangeLength: rangeLength,\n                        text: text,\n                    }],\n                eol: this._buffer.getEOL(),\n                versionId: this.getVersionId(),\n                isUndoing: isUndoing,\n                isRedoing: isRedoing,\n                isFlush: isFlush\n            };\n        }\n        setValueFromTextBuffer(textBuffer) {\n            this._assertNotDisposed();\n            if (textBuffer === null) {\n                // There's nothing to do\n                return;\n            }\n            const oldFullModelRange = this.getFullModelRange();\n            const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n            const endLineNumber = this.getLineCount();\n            const endColumn = this.getLineMaxColumn(endLineNumber);\n            this._buffer = textBuffer;\n            this._increaseVersionId();\n            // Cancel tokenization, clear all tokens and begin tokenizing\n            this._resetTokenizationState();\n            // Destroy all my decorations\n            this._decorations = Object.create(null);\n            this._decorationsTree = new DecorationsTrees();\n            // Destroy my edit history and settings\n            this._commandManager = new editStack_1.EditStack(this);\n            this._trimAutoWhitespaceLines = null;\n            this._emitContentChangedEvent(new textModelEvents_1.ModelRawContentChangedEvent([\n                new textModelEvents_1.ModelRawFlush()\n            ], this._versionId, false, false), this._createContentChanged2(new range_1.Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));\n        }\n        setEOL(eol) {\n            this._assertNotDisposed();\n            const newEOL = (eol === model.EndOfLineSequence.CRLF ? '\\r\\n' : '\\n');\n            if (this._buffer.getEOL() === newEOL) {\n                // Nothing to do\n                return;\n            }\n            const oldFullModelRange = this.getFullModelRange();\n            const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n            const endLineNumber = this.getLineCount();\n            const endColumn = this.getLineMaxColumn(endLineNumber);\n            this._onBeforeEOLChange();\n            this._buffer.setEOL(newEOL);\n            this._increaseVersionId();\n            this._onAfterEOLChange();\n            this._emitContentChangedEvent(new textModelEvents_1.ModelRawContentChangedEvent([\n                new textModelEvents_1.ModelRawEOLChanged()\n            ], this._versionId, false, false), this._createContentChanged2(new range_1.Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));\n        }\n        _onBeforeEOLChange() {\n            // Ensure all decorations get their `range` set.\n            const versionId = this.getVersionId();\n            const allDecorations = this._decorationsTree.search(0, false, false, versionId);\n            this._ensureNodesHaveRanges(allDecorations);\n        }\n        _onAfterEOLChange() {\n            // Transform back `range` to offsets\n            const versionId = this.getVersionId();\n            const allDecorations = this._decorationsTree.collectNodesPostOrder();\n            for (let i = 0, len = allDecorations.length; i < len; i++) {\n                const node = allDecorations[i];\n                const delta = node.cachedAbsoluteStart - node.start;\n                const startOffset = this._buffer.getOffsetAt(node.range.startLineNumber, node.range.startColumn);\n                const endOffset = this._buffer.getOffsetAt(node.range.endLineNumber, node.range.endColumn);\n                node.cachedAbsoluteStart = startOffset;\n                node.cachedAbsoluteEnd = endOffset;\n                node.cachedVersionId = versionId;\n                node.start = startOffset - delta;\n                node.end = endOffset - delta;\n                intervalTree_1.recomputeMaxEnd(node);\n            }\n        }\n        _resetTokenizationState() {\n            this._clearTimers();\n            let tokenizationSupport = (this._isTooLargeForTokenization\n                ? null\n                : modes_1.TokenizationRegistry.get(this._languageIdentifier.language));\n            this._tokens = new textModelTokens_1.ModelLinesTokens(this._languageIdentifier, tokenizationSupport);\n            this._beginBackgroundTokenization();\n        }\n        _clearTimers() {\n            if (this._revalidateTokensTimeout !== -1) {\n                clearTimeout(this._revalidateTokensTimeout);\n                this._revalidateTokensTimeout = -1;\n            }\n        }\n        onBeforeAttached() {\n            this._attachedEditorCount++;\n            // Warm up tokens for the editor\n            this._warmUpTokens();\n        }\n        onBeforeDetached() {\n            this._attachedEditorCount--;\n        }\n        _shouldAutoTokenize() {\n            return this.isAttachedToEditor();\n        }\n        isAttachedToEditor() {\n            return this._attachedEditorCount > 0;\n        }\n        getAttachedEditorCount() {\n            return this._attachedEditorCount;\n        }\n        isTooLargeForSyncing() {\n            return this._isTooLargeForSyncing;\n        }\n        isTooLargeForTokenization() {\n            return this._isTooLargeForTokenization;\n        }\n        isDisposed() {\n            return this._isDisposed;\n        }\n        isDominatedByLongLines() {\n            this._assertNotDisposed();\n            if (this.isTooLargeForTokenization()) {\n                // Cannot word wrap huge files anyways, so it doesn't really matter\n                return false;\n            }\n            let smallLineCharCount = 0;\n            let longLineCharCount = 0;\n            const lineCount = this._buffer.getLineCount();\n            for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n                const lineLength = this._buffer.getLineLength(lineNumber);\n                if (lineLength >= exports.LONG_LINE_BOUNDARY) {\n                    longLineCharCount += lineLength;\n                }\n                else {\n                    smallLineCharCount += lineLength;\n                }\n            }\n            return (longLineCharCount > smallLineCharCount);\n        }\n        get uri() {\n            return this._associatedResource;\n        }\n        //#region Options\n        getOptions() {\n            this._assertNotDisposed();\n            return this._options;\n        }\n        getFormattingOptions() {\n            return {\n                tabSize: this._options.indentSize,\n                insertSpaces: this._options.insertSpaces\n            };\n        }\n        updateOptions(_newOpts) {\n            this._assertNotDisposed();\n            let tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n            let indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.indentSize;\n            let insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n            let trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n            let newOpts = new model.TextModelResolvedOptions({\n                tabSize: tabSize,\n                indentSize: indentSize,\n                insertSpaces: insertSpaces,\n                defaultEOL: this._options.defaultEOL,\n                trimAutoWhitespace: trimAutoWhitespace\n            });\n            if (this._options.equals(newOpts)) {\n                return;\n            }\n            let e = this._options.createChangeEvent(newOpts);\n            this._options = newOpts;\n            this._onDidChangeOptions.fire(e);\n        }\n        detectIndentation(defaultInsertSpaces, defaultTabSize) {\n            this._assertNotDisposed();\n            let guessedIndentation = indentationGuesser_1.guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n            this.updateOptions({\n                insertSpaces: guessedIndentation.insertSpaces,\n                tabSize: guessedIndentation.tabSize,\n                indentSize: guessedIndentation.tabSize,\n            });\n        }\n        static _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n            let spacesCnt = 0;\n            for (let i = 0; i < str.length; i++) {\n                if (str.charAt(i) === '\\t') {\n                    spacesCnt += indentSize;\n                }\n                else {\n                    spacesCnt++;\n                }\n            }\n            let result = '';\n            if (!insertSpaces) {\n                let tabsCnt = Math.floor(spacesCnt / indentSize);\n                spacesCnt = spacesCnt % indentSize;\n                for (let i = 0; i < tabsCnt; i++) {\n                    result += '\\t';\n                }\n            }\n            for (let i = 0; i < spacesCnt; i++) {\n                result += ' ';\n            }\n            return result;\n        }\n        static normalizeIndentation(str, indentSize, insertSpaces) {\n            let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n            if (firstNonWhitespaceIndex === -1) {\n                firstNonWhitespaceIndex = str.length;\n            }\n            return TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n        }\n        normalizeIndentation(str) {\n            this._assertNotDisposed();\n            return TextModel.normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n        }\n        //#endregion\n        //#region Reading\n        getVersionId() {\n            this._assertNotDisposed();\n            return this._versionId;\n        }\n        mightContainRTL() {\n            return this._buffer.mightContainRTL();\n        }\n        mightContainNonBasicASCII() {\n            return this._buffer.mightContainNonBasicASCII();\n        }\n        getAlternativeVersionId() {\n            this._assertNotDisposed();\n            return this._alternativeVersionId;\n        }\n        getOffsetAt(rawPosition) {\n            this._assertNotDisposed();\n            let position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, false);\n            return this._buffer.getOffsetAt(position.lineNumber, position.column);\n        }\n        getPositionAt(rawOffset) {\n            this._assertNotDisposed();\n            let offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n            return this._buffer.getPositionAt(offset);\n        }\n        _increaseVersionId() {\n            this._setVersionId(this._versionId + 1);\n        }\n        _setVersionId(newVersionId) {\n            this._versionId = newVersionId;\n            this._alternativeVersionId = this._versionId;\n        }\n        _overwriteAlternativeVersionId(newAlternativeVersionId) {\n            this._alternativeVersionId = newAlternativeVersionId;\n        }\n        getValue(eol, preserveBOM = false) {\n            this._assertNotDisposed();\n            const fullModelRange = this.getFullModelRange();\n            const fullModelValue = this.getValueInRange(fullModelRange, eol);\n            if (preserveBOM) {\n                return this._buffer.getBOM() + fullModelValue;\n            }\n            return fullModelValue;\n        }\n        createSnapshot(preserveBOM = false) {\n            return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n        }\n        getValueLength(eol, preserveBOM = false) {\n            this._assertNotDisposed();\n            const fullModelRange = this.getFullModelRange();\n            const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n            if (preserveBOM) {\n                return this._buffer.getBOM().length + fullModelValue;\n            }\n            return fullModelValue;\n        }\n        getValueInRange(rawRange, eol = model.EndOfLinePreference.TextDefined) {\n            this._assertNotDisposed();\n            return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n        }\n        getValueLengthInRange(rawRange, eol = model.EndOfLinePreference.TextDefined) {\n            this._assertNotDisposed();\n            return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n        }\n        getLineCount() {\n            this._assertNotDisposed();\n            return this._buffer.getLineCount();\n        }\n        getLineContent(lineNumber) {\n            this._assertNotDisposed();\n            if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n                throw new Error('Illegal value for lineNumber');\n            }\n            return this._buffer.getLineContent(lineNumber);\n        }\n        getLineLength(lineNumber) {\n            this._assertNotDisposed();\n            if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n                throw new Error('Illegal value for lineNumber');\n            }\n            return this._buffer.getLineLength(lineNumber);\n        }\n        getLinesContent() {\n            this._assertNotDisposed();\n            return this._buffer.getLinesContent();\n        }\n        getEOL() {\n            this._assertNotDisposed();\n            return this._buffer.getEOL();\n        }\n        getLineMinColumn(lineNumber) {\n            this._assertNotDisposed();\n            return 1;\n        }\n        getLineMaxColumn(lineNumber) {\n            this._assertNotDisposed();\n            if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n                throw new Error('Illegal value for lineNumber');\n            }\n            return this._buffer.getLineLength(lineNumber) + 1;\n        }\n        getLineFirstNonWhitespaceColumn(lineNumber) {\n            this._assertNotDisposed();\n            if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n                throw new Error('Illegal value for lineNumber');\n            }\n            return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n        }\n        getLineLastNonWhitespaceColumn(lineNumber) {\n            this._assertNotDisposed();\n            if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n                throw new Error('Illegal value for lineNumber');\n            }\n            return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n        }\n        /**\n         * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n         * Will try to not allocate if possible.\n         */\n        _validateRangeRelaxedNoAllocations(range) {\n            const linesCount = this._buffer.getLineCount();\n            const initialStartLineNumber = range.startLineNumber;\n            const initialStartColumn = range.startColumn;\n            let startLineNumber;\n            let startColumn;\n            if (initialStartLineNumber < 1) {\n                startLineNumber = 1;\n                startColumn = 1;\n            }\n            else if (initialStartLineNumber > linesCount) {\n                startLineNumber = linesCount;\n                startColumn = this.getLineMaxColumn(startLineNumber);\n            }\n            else {\n                startLineNumber = initialStartLineNumber | 0;\n                if (initialStartColumn <= 1) {\n                    startColumn = 1;\n                }\n                else {\n                    const maxColumn = this.getLineMaxColumn(startLineNumber);\n                    if (initialStartColumn >= maxColumn) {\n                        startColumn = maxColumn;\n                    }\n                    else {\n                        startColumn = initialStartColumn | 0;\n                    }\n                }\n            }\n            const initialEndLineNumber = range.endLineNumber;\n            const initialEndColumn = range.endColumn;\n            let endLineNumber;\n            let endColumn;\n            if (initialEndLineNumber < 1) {\n                endLineNumber = 1;\n                endColumn = 1;\n            }\n            else if (initialEndLineNumber > linesCount) {\n                endLineNumber = linesCount;\n                endColumn = this.getLineMaxColumn(endLineNumber);\n            }\n            else {\n                endLineNumber = initialEndLineNumber | 0;\n                if (initialEndColumn <= 1) {\n                    endColumn = 1;\n                }\n                else {\n                    const maxColumn = this.getLineMaxColumn(endLineNumber);\n                    if (initialEndColumn >= maxColumn) {\n                        endColumn = maxColumn;\n                    }\n                    else {\n                        endColumn = initialEndColumn | 0;\n                    }\n                }\n            }\n            if (initialStartLineNumber === startLineNumber\n                && initialStartColumn === startColumn\n                && initialEndLineNumber === endLineNumber\n                && initialEndColumn === endColumn\n                && range instanceof range_1.Range\n                && !(range instanceof selection_1.Selection)) {\n                return range;\n            }\n            return new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        /**\n         * @param strict Do NOT allow a position inside a high-low surrogate pair\n         */\n        _isValidPosition(lineNumber, column, strict) {\n            if (isNaN(lineNumber)) {\n                return false;\n            }\n            if (lineNumber < 1) {\n                return false;\n            }\n            const lineCount = this._buffer.getLineCount();\n            if (lineNumber > lineCount) {\n                return false;\n            }\n            if (isNaN(column)) {\n                return false;\n            }\n            if (column < 1) {\n                return false;\n            }\n            const maxColumn = this.getLineMaxColumn(lineNumber);\n            if (column > maxColumn) {\n                return false;\n            }\n            if (strict) {\n                if (column > 1) {\n                    const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n                    if (strings.isHighSurrogate(charCodeBefore)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        /**\n         * @param strict Do NOT allow a position inside a high-low surrogate pair\n         */\n        _validatePosition(_lineNumber, _column, strict) {\n            const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n            const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n            const lineCount = this._buffer.getLineCount();\n            if (lineNumber < 1) {\n                return new position_1.Position(1, 1);\n            }\n            if (lineNumber > lineCount) {\n                return new position_1.Position(lineCount, this.getLineMaxColumn(lineCount));\n            }\n            if (column <= 1) {\n                return new position_1.Position(lineNumber, 1);\n            }\n            const maxColumn = this.getLineMaxColumn(lineNumber);\n            if (column >= maxColumn) {\n                return new position_1.Position(lineNumber, maxColumn);\n            }\n            if (strict) {\n                // If the position would end up in the middle of a high-low surrogate pair,\n                // we move it to before the pair\n                // !!At this point, column > 1\n                const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    return new position_1.Position(lineNumber, column - 1);\n                }\n            }\n            return new position_1.Position(lineNumber, column);\n        }\n        validatePosition(position) {\n            this._assertNotDisposed();\n            // Avoid object allocation and cover most likely case\n            if (position instanceof position_1.Position) {\n                if (this._isValidPosition(position.lineNumber, position.column, true)) {\n                    return position;\n                }\n            }\n            return this._validatePosition(position.lineNumber, position.column, true);\n        }\n        /**\n         * @param strict Do NOT allow a range to have its boundaries inside a high-low surrogate pair\n         */\n        _isValidRange(range, strict) {\n            const startLineNumber = range.startLineNumber;\n            const startColumn = range.startColumn;\n            const endLineNumber = range.endLineNumber;\n            const endColumn = range.endColumn;\n            if (!this._isValidPosition(startLineNumber, startColumn, false)) {\n                return false;\n            }\n            if (!this._isValidPosition(endLineNumber, endColumn, false)) {\n                return false;\n            }\n            if (strict) {\n                const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n                const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n                const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n                const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n                if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                    return true;\n                }\n                return false;\n            }\n            return true;\n        }\n        validateRange(_range) {\n            this._assertNotDisposed();\n            // Avoid object allocation and cover most likely case\n            if ((_range instanceof range_1.Range) && !(_range instanceof selection_1.Selection)) {\n                if (this._isValidRange(_range, true)) {\n                    return _range;\n                }\n            }\n            const start = this._validatePosition(_range.startLineNumber, _range.startColumn, false);\n            const end = this._validatePosition(_range.endLineNumber, _range.endColumn, false);\n            const startLineNumber = start.lineNumber;\n            const startColumn = start.column;\n            const endLineNumber = end.lineNumber;\n            const endColumn = end.column;\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new range_1.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new range_1.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new range_1.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        modifyPosition(rawPosition, offset) {\n            this._assertNotDisposed();\n            let candidate = this.getOffsetAt(rawPosition) + offset;\n            return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n        }\n        getFullModelRange() {\n            this._assertNotDisposed();\n            const lineCount = this.getLineCount();\n            return new range_1.Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n        }\n        findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n            return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n            this._assertNotDisposed();\n            let searchRange;\n            if (range_1.Range.isIRange(rawSearchScope)) {\n                searchRange = this.validateRange(rawSearchScope);\n            }\n            else {\n                searchRange = this.getFullModelRange();\n            }\n            if (!isRegex && searchString.indexOf('\\n') < 0) {\n                // not regex, not multi line\n                const searchParams = new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wordSeparators);\n                const searchData = searchParams.parseSearchRequest();\n                if (!searchData) {\n                    return [];\n                }\n                return this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n            }\n            return textModelSearch_1.TextModelSearch.findMatches(this, new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n            this._assertNotDisposed();\n            const searchStart = this.validatePosition(rawSearchStart);\n            if (!isRegex && searchString.indexOf('\\n') < 0) {\n                const searchParams = new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wordSeparators);\n                const searchData = searchParams.parseSearchRequest();\n                if (!searchData) {\n                    return null;\n                }\n                const lineCount = this.getLineCount();\n                let searchRange = new range_1.Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n                let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n                textModelSearch_1.TextModelSearch.findNextMatch(this, new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n                if (ret.length > 0) {\n                    return ret[0];\n                }\n                searchRange = new range_1.Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n                ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n                if (ret.length > 0) {\n                    return ret[0];\n                }\n                return null;\n            }\n            return textModelSearch_1.TextModelSearch.findNextMatch(this, new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n        }\n        findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n            this._assertNotDisposed();\n            const searchStart = this.validatePosition(rawSearchStart);\n            return textModelSearch_1.TextModelSearch.findPreviousMatch(this, new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n        }\n        //#endregion\n        //#region Editing\n        pushStackElement() {\n            this._commandManager.pushStackElement();\n        }\n        pushEOL(eol) {\n            const currentEOL = (this.getEOL() === '\\n' ? model.EndOfLineSequence.LF : model.EndOfLineSequence.CRLF);\n            if (currentEOL === eol) {\n                return;\n            }\n            try {\n                this._onDidChangeDecorations.beginDeferredEmit();\n                this._eventEmitter.beginDeferredEmit();\n                this._commandManager.pushEOL(eol);\n            }\n            finally {\n                this._eventEmitter.endDeferredEmit();\n                this._onDidChangeDecorations.endDeferredEmit();\n            }\n        }\n        pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n            try {\n                this._onDidChangeDecorations.beginDeferredEmit();\n                this._eventEmitter.beginDeferredEmit();\n                return this._pushEditOperations(beforeCursorState, editOperations, cursorStateComputer);\n            }\n            finally {\n                this._eventEmitter.endDeferredEmit();\n                this._onDidChangeDecorations.endDeferredEmit();\n            }\n        }\n        _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n            if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n                // Go through each saved line number and insert a trim whitespace edit\n                // if it is safe to do so (no conflicts with other edits).\n                let incomingEdits = editOperations.map((op) => {\n                    return {\n                        range: this.validateRange(op.range),\n                        text: op.text\n                    };\n                });\n                // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n                // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n                let editsAreNearCursors = true;\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    let sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        let editRange = incomingEdits[j].range;\n                        let selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        let selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n                if (editsAreNearCursors) {\n                    for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                        let trimLineNumber = this._trimAutoWhitespaceLines[i];\n                        let maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                        let allowTrimLine = true;\n                        for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                            let editRange = incomingEdits[j].range;\n                            let editText = incomingEdits[j].text;\n                            if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                                // `trimLine` is completely outside this edit\n                                continue;\n                            }\n                            // At this point:\n                            //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                                && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                                // This edit inserts a new line (and maybe other text) after `trimLine`\n                                continue;\n                            }\n                            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                                && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                                // This edit inserts a new line (and maybe other text) before `trimLine`\n                                continue;\n                            }\n                            // Looks like we can't trim this line as it would interfere with an incoming edit\n                            allowTrimLine = false;\n                            break;\n                        }\n                        if (allowTrimLine) {\n                            editOperations.push({\n                                range: new range_1.Range(trimLineNumber, 1, trimLineNumber, maxLineColumn),\n                                text: null\n                            });\n                        }\n                    }\n                }\n                this._trimAutoWhitespaceLines = null;\n            }\n            return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\n        }\n        applyEdits(rawOperations) {\n            try {\n                this._onDidChangeDecorations.beginDeferredEmit();\n                this._eventEmitter.beginDeferredEmit();\n                return this._applyEdits(rawOperations);\n            }\n            finally {\n                this._eventEmitter.endDeferredEmit();\n                this._onDidChangeDecorations.endDeferredEmit();\n            }\n        }\n        static _eolCount(text) {\n            let eolCount = 0;\n            let firstLineLength = 0;\n            for (let i = 0, len = text.length; i < len; i++) {\n                const chr = text.charCodeAt(i);\n                if (chr === charCode_1.CharCode.CarriageReturn) {\n                    if (eolCount === 0) {\n                        firstLineLength = i;\n                    }\n                    eolCount++;\n                    if (i + 1 < len && text.charCodeAt(i + 1) === charCode_1.CharCode.LineFeed) {\n                        // \\r\\n... case\n                        i++; // skip \\n\n                    }\n                    else {\n                        // \\r... case\n                    }\n                }\n                else if (chr === charCode_1.CharCode.LineFeed) {\n                    if (eolCount === 0) {\n                        firstLineLength = i;\n                    }\n                    eolCount++;\n                }\n            }\n            if (eolCount === 0) {\n                firstLineLength = text.length;\n            }\n            return [eolCount, firstLineLength];\n        }\n        _applyEdits(rawOperations) {\n            for (let i = 0, len = rawOperations.length; i < len; i++) {\n                rawOperations[i].range = this.validateRange(rawOperations[i].range);\n            }\n            const oldLineCount = this._buffer.getLineCount();\n            const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace);\n            const newLineCount = this._buffer.getLineCount();\n            const contentChanges = result.changes;\n            this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n            if (contentChanges.length !== 0) {\n                let rawContentChanges = [];\n                let lineCount = oldLineCount;\n                for (let i = 0, len = contentChanges.length; i < len; i++) {\n                    const change = contentChanges[i];\n                    const [eolCount, firstLineLength] = TextModel._eolCount(change.text);\n                    try {\n                        this._tokens.applyEdits(change.range, eolCount, firstLineLength);\n                    }\n                    catch (err) {\n                        // emergency recovery => reset tokens\n                        this._tokens = new textModelTokens_1.ModelLinesTokens(this._tokens.languageIdentifier, this._tokens.tokenizationSupport);\n                    }\n                    this._onDidChangeDecorations.fire();\n                    this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n                    const startLineNumber = change.range.startLineNumber;\n                    const endLineNumber = change.range.endLineNumber;\n                    const deletingLinesCnt = endLineNumber - startLineNumber;\n                    const insertingLinesCnt = eolCount;\n                    const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                    const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                    for (let j = editingLinesCnt; j >= 0; j--) {\n                        const editLineNumber = startLineNumber + j;\n                        const currentEditLineNumber = newLineCount - lineCount - changeLineCountDelta + editLineNumber;\n                        rawContentChanges.push(new textModelEvents_1.ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber)));\n                    }\n                    if (editingLinesCnt < deletingLinesCnt) {\n                        // Must delete some lines\n                        const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                        rawContentChanges.push(new textModelEvents_1.ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                    }\n                    if (editingLinesCnt < insertingLinesCnt) {\n                        // Must insert some lines\n                        const spliceLineNumber = startLineNumber + editingLinesCnt;\n                        const cnt = insertingLinesCnt - editingLinesCnt;\n                        const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                        let newLines = [];\n                        for (let i = 0; i < cnt; i++) {\n                            let lineNumber = fromLineNumber + i;\n                            newLines[lineNumber - fromLineNumber] = this.getLineContent(lineNumber);\n                        }\n                        rawContentChanges.push(new textModelEvents_1.ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines));\n                    }\n                    lineCount += changeLineCountDelta;\n                }\n                this._increaseVersionId();\n                this._emitContentChangedEvent(new textModelEvents_1.ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                    changes: contentChanges,\n                    eol: this._buffer.getEOL(),\n                    versionId: this.getVersionId(),\n                    isUndoing: this._isUndoing,\n                    isRedoing: this._isRedoing,\n                    isFlush: false\n                });\n            }\n            if (this._tokens.hasLinesToTokenize(this._buffer)) {\n                this._beginBackgroundTokenization();\n            }\n            return result.reverseEdits;\n        }\n        _undo() {\n            this._isUndoing = true;\n            let r = this._commandManager.undo();\n            this._isUndoing = false;\n            if (!r) {\n                return null;\n            }\n            this._overwriteAlternativeVersionId(r.recordedVersionId);\n            return r.selections;\n        }\n        undo() {\n            try {\n                this._onDidChangeDecorations.beginDeferredEmit();\n                this._eventEmitter.beginDeferredEmit();\n                return this._undo();\n            }\n            finally {\n                this._eventEmitter.endDeferredEmit();\n                this._onDidChangeDecorations.endDeferredEmit();\n            }\n        }\n        canUndo() {\n            return this._commandManager.canUndo();\n        }\n        _redo() {\n            this._isRedoing = true;\n            let r = this._commandManager.redo();\n            this._isRedoing = false;\n            if (!r) {\n                return null;\n            }\n            this._overwriteAlternativeVersionId(r.recordedVersionId);\n            return r.selections;\n        }\n        redo() {\n            try {\n                this._onDidChangeDecorations.beginDeferredEmit();\n                this._eventEmitter.beginDeferredEmit();\n                return this._redo();\n            }\n            finally {\n                this._eventEmitter.endDeferredEmit();\n                this._onDidChangeDecorations.endDeferredEmit();\n            }\n        }\n        canRedo() {\n            return this._commandManager.canRedo();\n        }\n        //#endregion\n        //#region Decorations\n        changeDecorations(callback, ownerId = 0) {\n            this._assertNotDisposed();\n            try {\n                this._onDidChangeDecorations.beginDeferredEmit();\n                return this._changeDecorations(ownerId, callback);\n            }\n            finally {\n                this._onDidChangeDecorations.endDeferredEmit();\n            }\n        }\n        _changeDecorations(ownerId, callback) {\n            let changeAccessor = {\n                addDecoration: (range, options) => {\n                    this._onDidChangeDecorations.fire();\n                    return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n                },\n                changeDecoration: (id, newRange) => {\n                    this._onDidChangeDecorations.fire();\n                    this._changeDecorationImpl(id, newRange);\n                },\n                changeDecorationOptions: (id, options) => {\n                    this._onDidChangeDecorations.fire();\n                    this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n                },\n                removeDecoration: (id) => {\n                    this._onDidChangeDecorations.fire();\n                    this._deltaDecorationsImpl(ownerId, [id], []);\n                },\n                deltaDecorations: (oldDecorations, newDecorations) => {\n                    if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                        // nothing to do\n                        return [];\n                    }\n                    this._onDidChangeDecorations.fire();\n                    return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n                }\n            };\n            let result = null;\n            try {\n                result = callback(changeAccessor);\n            }\n            catch (e) {\n                errors_1.onUnexpectedError(e);\n            }\n            // Invalidate change accessor\n            changeAccessor.addDecoration = invalidFunc;\n            changeAccessor.changeDecoration = invalidFunc;\n            changeAccessor.changeDecorationOptions = invalidFunc;\n            changeAccessor.removeDecoration = invalidFunc;\n            changeAccessor.deltaDecorations = invalidFunc;\n            return result;\n        }\n        deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n            this._assertNotDisposed();\n            if (!oldDecorations) {\n                oldDecorations = [];\n            }\n            if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                // nothing to do\n                return [];\n            }\n            try {\n                this._onDidChangeDecorations.beginDeferredEmit();\n                this._onDidChangeDecorations.fire();\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n            finally {\n                this._onDidChangeDecorations.endDeferredEmit();\n            }\n        }\n        _getTrackedRange(id) {\n            return this.getDecorationRange(id);\n        }\n        _setTrackedRange(id, newRange, newStickiness) {\n            const node = (id ? this._decorations[id] : null);\n            if (!node) {\n                if (!newRange) {\n                    // node doesn't exist, the request is to delete => nothing to do\n                    return null;\n                }\n                // node doesn't exist, the request is to set => add the tracked range\n                return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }])[0];\n            }\n            if (!newRange) {\n                // node exists, the request is to delete => delete node\n                this._decorationsTree.delete(node);\n                delete this._decorations[node.id];\n                return null;\n            }\n            // node exists, the request is to set => change the tracked range and its options\n            const range = this._validateRangeRelaxedNoAllocations(newRange);\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            this._decorationsTree.delete(node);\n            node.reset(this.getVersionId(), startOffset, endOffset, range);\n            node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n            this._decorationsTree.insert(node);\n            return node.id;\n        }\n        removeAllDecorationsWithOwnerId(ownerId) {\n            if (this._isDisposed) {\n                return;\n            }\n            const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n            for (let i = 0, len = nodes.length; i < len; i++) {\n                const node = nodes[i];\n                this._decorationsTree.delete(node);\n                delete this._decorations[node.id];\n            }\n        }\n        getDecorationOptions(decorationId) {\n            const node = this._decorations[decorationId];\n            if (!node) {\n                return null;\n            }\n            return node.options;\n        }\n        getDecorationRange(decorationId) {\n            const node = this._decorations[decorationId];\n            if (!node) {\n                return null;\n            }\n            const versionId = this.getVersionId();\n            if (node.cachedVersionId !== versionId) {\n                this._decorationsTree.resolveNode(node, versionId);\n            }\n            if (node.range === null) {\n                node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n            return node.range;\n        }\n        getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n            if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n                return [];\n            }\n            return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n        }\n        getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false) {\n            let lineCount = this.getLineCount();\n            let startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n            let endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n            let endColumn = this.getLineMaxColumn(endLineNumber);\n            return this._getDecorationsInRange(new range_1.Range(startLineNumber, 1, endLineNumber, endColumn), ownerId, filterOutValidation);\n        }\n        getDecorationsInRange(range, ownerId = 0, filterOutValidation = false) {\n            let validatedRange = this.validateRange(range);\n            return this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\n        }\n        getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n            const versionId = this.getVersionId();\n            const result = this._decorationsTree.search(ownerId, filterOutValidation, true, versionId);\n            return this._ensureNodesHaveRanges(result);\n        }\n        getAllDecorations(ownerId = 0, filterOutValidation = false) {\n            const versionId = this.getVersionId();\n            const result = this._decorationsTree.search(ownerId, filterOutValidation, false, versionId);\n            return this._ensureNodesHaveRanges(result);\n        }\n        _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation) {\n            const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n            const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n            const versionId = this.getVersionId();\n            const result = this._decorationsTree.intervalSearch(startOffset, endOffset, filterOwnerId, filterOutValidation, versionId);\n            return this._ensureNodesHaveRanges(result);\n        }\n        _ensureNodesHaveRanges(nodes) {\n            for (let i = 0, len = nodes.length; i < len; i++) {\n                const node = nodes[i];\n                if (node.range === null) {\n                    node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n                }\n            }\n            return nodes;\n        }\n        _getRangeAt(start, end) {\n            return this._buffer.getRangeAt(start, end - start);\n        }\n        _changeDecorationImpl(decorationId, _range) {\n            const node = this._decorations[decorationId];\n            if (!node) {\n                return;\n            }\n            const range = this._validateRangeRelaxedNoAllocations(_range);\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            this._decorationsTree.delete(node);\n            node.reset(this.getVersionId(), startOffset, endOffset, range);\n            this._decorationsTree.insert(node);\n        }\n        _changeDecorationOptionsImpl(decorationId, options) {\n            const node = this._decorations[decorationId];\n            if (!node) {\n                return;\n            }\n            const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n            const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n            if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n                // Delete + Insert due to an overview ruler status change\n                this._decorationsTree.delete(node);\n                node.setOptions(options);\n                this._decorationsTree.insert(node);\n            }\n            else {\n                node.setOptions(options);\n            }\n        }\n        _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations) {\n            const versionId = this.getVersionId();\n            const oldDecorationsLen = oldDecorationsIds.length;\n            let oldDecorationIndex = 0;\n            const newDecorationsLen = newDecorations.length;\n            let newDecorationIndex = 0;\n            let result = new Array(newDecorationsLen);\n            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n                let node = null;\n                if (oldDecorationIndex < oldDecorationsLen) {\n                    // (1) get ourselves an old node\n                    do {\n                        node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                    } while (!node && oldDecorationIndex < oldDecorationsLen);\n                    // (2) remove the node from the tree (if it exists)\n                    if (node) {\n                        this._decorationsTree.delete(node);\n                    }\n                }\n                if (newDecorationIndex < newDecorationsLen) {\n                    // (3) create a new node if necessary\n                    if (!node) {\n                        const internalDecorationId = (++this._lastDecorationId);\n                        const decorationId = `${this._instanceId};${internalDecorationId}`;\n                        node = new intervalTree_1.IntervalNode(decorationId, 0, 0);\n                        this._decorations[decorationId] = node;\n                    }\n                    // (4) initialize node\n                    const newDecoration = newDecorations[newDecorationIndex];\n                    const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                    const options = _normalizeOptions(newDecoration.options);\n                    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                    node.ownerId = ownerId;\n                    node.reset(versionId, startOffset, endOffset, range);\n                    node.setOptions(options);\n                    this._decorationsTree.insert(node);\n                    result[newDecorationIndex] = node.id;\n                    newDecorationIndex++;\n                }\n                else {\n                    if (node) {\n                        delete this._decorations[node.id];\n                    }\n                }\n            }\n            return result;\n        }\n        //#endregion\n        //#region Tokenization\n        tokenizeViewport(startLineNumber, endLineNumber) {\n            if (!this._tokens.tokenizationSupport) {\n                // nothing to do\n                return;\n            }\n            startLineNumber = Math.max(1, startLineNumber);\n            endLineNumber = Math.min(this.getLineCount(), endLineNumber);\n            if (endLineNumber <= this._tokens.inValidLineStartIndex) {\n                // nothing to do\n                return;\n            }\n            if (startLineNumber <= this._tokens.inValidLineStartIndex) {\n                // tokenization has reached the viewport start...\n                this.forceTokenization(endLineNumber);\n                return;\n            }\n            let nonWhitespaceColumn = this.getLineFirstNonWhitespaceColumn(startLineNumber);\n            let fakeLines = [];\n            let initialState = null;\n            for (let i = startLineNumber - 1; nonWhitespaceColumn > 0 && i >= 1; i--) {\n                let newNonWhitespaceIndex = this.getLineFirstNonWhitespaceColumn(i);\n                if (newNonWhitespaceIndex === 0) {\n                    continue;\n                }\n                if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n                    initialState = this._tokens._getState(i - 1);\n                    if (initialState) {\n                        break;\n                    }\n                    fakeLines.push(this.getLineContent(i));\n                    nonWhitespaceColumn = newNonWhitespaceIndex;\n                }\n            }\n            if (!initialState) {\n                initialState = this._tokens.tokenizationSupport.getInitialState();\n            }\n            let state = initialState.clone();\n            for (let i = fakeLines.length - 1; i >= 0; i--) {\n                let r = this._tokens._tokenizeText(this._buffer, fakeLines[i], state);\n                if (r) {\n                    state = r.endState.clone();\n                }\n                else {\n                    state = initialState.clone();\n                }\n            }\n            const eventBuilder = new textModelTokens_1.ModelTokensChangedEventBuilder();\n            for (let i = startLineNumber; i <= endLineNumber; i++) {\n                let text = this.getLineContent(i);\n                let r = this._tokens._tokenizeText(this._buffer, text, state);\n                if (r) {\n                    this._tokens._setTokens(this._tokens.languageIdentifier.id, i - 1, text.length, r.tokens);\n                    // We cannot trust these states/tokens to be valid!\n                    // (see https://github.com/Microsoft/vscode/issues/67607)\n                    this._tokens._setIsInvalid(i - 1, true);\n                    this._tokens._setState(i - 1, state);\n                    state = r.endState.clone();\n                    eventBuilder.registerChangedTokens(i);\n                }\n                else {\n                    state = initialState.clone();\n                }\n            }\n            const e = eventBuilder.build();\n            if (e) {\n                this._onDidChangeTokens.fire(e);\n            }\n        }\n        flushTokens() {\n            this._resetTokenizationState();\n            this.emitModelTokensChangedEvent({\n                tokenizationSupportChanged: false,\n                ranges: [{\n                        fromLineNumber: 1,\n                        toLineNumber: this.getLineCount()\n                    }]\n            });\n        }\n        forceTokenization(lineNumber) {\n            if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n                throw new Error('Illegal value for lineNumber');\n            }\n            const eventBuilder = new textModelTokens_1.ModelTokensChangedEventBuilder();\n            this._tokens._updateTokensUntilLine(this._buffer, eventBuilder, lineNumber);\n            const e = eventBuilder.build();\n            if (e) {\n                this._onDidChangeTokens.fire(e);\n            }\n        }\n        isCheapToTokenize(lineNumber) {\n            if (!this._tokens.isCheapToTokenize(lineNumber)) {\n                return false;\n            }\n            if (lineNumber < this._tokens.inValidLineStartIndex + 1) {\n                return true;\n            }\n            if (this.getLineLength(lineNumber) < CHEAP_TOKENIZATION_LENGTH_LIMIT) {\n                return true;\n            }\n            return false;\n        }\n        tokenizeIfCheap(lineNumber) {\n            if (this.isCheapToTokenize(lineNumber)) {\n                this.forceTokenization(lineNumber);\n            }\n        }\n        getLineTokens(lineNumber) {\n            if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n                throw new Error('Illegal value for lineNumber');\n            }\n            return this._getLineTokens(lineNumber);\n        }\n        _getLineTokens(lineNumber) {\n            const lineText = this._buffer.getLineContent(lineNumber);\n            return this._tokens.getTokens(this._languageIdentifier.id, lineNumber - 1, lineText);\n        }\n        getLanguageIdentifier() {\n            return this._languageIdentifier;\n        }\n        getModeId() {\n            return this._languageIdentifier.language;\n        }\n        setMode(languageIdentifier) {\n            if (this._languageIdentifier.id === languageIdentifier.id) {\n                // There's nothing to do\n                return;\n            }\n            let e = {\n                oldLanguage: this._languageIdentifier.language,\n                newLanguage: languageIdentifier.language\n            };\n            this._languageIdentifier = languageIdentifier;\n            // Cancel tokenization, clear all tokens and begin tokenizing\n            this._resetTokenizationState();\n            this.emitModelTokensChangedEvent({\n                tokenizationSupportChanged: true,\n                ranges: [{\n                        fromLineNumber: 1,\n                        toLineNumber: this.getLineCount()\n                    }]\n            });\n            this._onDidChangeLanguage.fire(e);\n            this._onDidChangeLanguageConfiguration.fire({});\n        }\n        getLanguageIdAtPosition(_lineNumber, _column) {\n            if (!this._tokens.tokenizationSupport) {\n                return this._languageIdentifier.id;\n            }\n            let { lineNumber, column } = this.validatePosition({ lineNumber: _lineNumber, column: _column });\n            let lineTokens = this._getLineTokens(lineNumber);\n            return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(column - 1));\n        }\n        _beginBackgroundTokenization() {\n            if (this._shouldAutoTokenize() && this._revalidateTokensTimeout === -1) {\n                this._revalidateTokensTimeout = setTimeout(() => {\n                    this._revalidateTokensTimeout = -1;\n                    this._revalidateTokensNow();\n                }, 0);\n            }\n        }\n        _warmUpTokens() {\n            // Warm up first 100 lines (if it takes less than 50ms)\n            const maxLineNumber = Math.min(100, this.getLineCount());\n            this._revalidateTokensNow(maxLineNumber);\n            if (this._tokens.hasLinesToTokenize(this._buffer)) {\n                this._beginBackgroundTokenization();\n            }\n        }\n        _revalidateTokensNow(toLineNumber = this._buffer.getLineCount()) {\n            const MAX_ALLOWED_TIME = 20;\n            const eventBuilder = new textModelTokens_1.ModelTokensChangedEventBuilder();\n            const sw = stopwatch_1.StopWatch.create(false);\n            while (this._tokens.hasLinesToTokenize(this._buffer)) {\n                if (sw.elapsed() > MAX_ALLOWED_TIME) {\n                    // Stop if MAX_ALLOWED_TIME is reached\n                    break;\n                }\n                const tokenizedLineNumber = this._tokens._tokenizeOneLine(this._buffer, eventBuilder);\n                if (tokenizedLineNumber >= toLineNumber) {\n                    break;\n                }\n            }\n            if (this._tokens.hasLinesToTokenize(this._buffer)) {\n                this._beginBackgroundTokenization();\n            }\n            const e = eventBuilder.build();\n            if (e) {\n                this._onDidChangeTokens.fire(e);\n            }\n        }\n        emitModelTokensChangedEvent(e) {\n            if (!this._isDisposing) {\n                this._onDidChangeTokens.fire(e);\n            }\n        }\n        // Having tokens allows implementing additional helper methods\n        getWordAtPosition(_position) {\n            this._assertNotDisposed();\n            const position = this.validatePosition(_position);\n            const lineContent = this.getLineContent(position.lineNumber);\n            const lineTokens = this._getLineTokens(position.lineNumber);\n            const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n            // (1). First try checking right biased word\n            const [rbStartOffset, rbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex);\n            const rightBiasedWord = wordHelper_1.getWordAtText(position.column, languageConfigurationRegistry_1.LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex)), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\n                return rightBiasedWord;\n            }\n            // (2). Else, if we were at a language boundary, check the left biased word\n            if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n                // edge case, where `position` sits between two tokens belonging to two different languages\n                const [lbStartOffset, lbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n                const leftBiasedWord = wordHelper_1.getWordAtText(position.column, languageConfigurationRegistry_1.LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex - 1)), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n                // Make sure the result touches the original passed in position\n                if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\n                    return leftBiasedWord;\n                }\n            }\n            return null;\n        }\n        static _findLanguageBoundaries(lineTokens, tokenIndex) {\n            const languageId = lineTokens.getLanguageId(tokenIndex);\n            // go left until a different language is hit\n            let startOffset = 0;\n            for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n                startOffset = lineTokens.getStartOffset(i);\n            }\n            // go right until a different language is hit\n            let endOffset = lineTokens.getLineContent().length;\n            for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n                endOffset = lineTokens.getEndOffset(i);\n            }\n            return [startOffset, endOffset];\n        }\n        getWordUntilPosition(position) {\n            const wordAtPosition = this.getWordAtPosition(position);\n            if (!wordAtPosition) {\n                return {\n                    word: '',\n                    startColumn: position.column,\n                    endColumn: position.column\n                };\n            }\n            return {\n                word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n                startColumn: wordAtPosition.startColumn,\n                endColumn: position.column\n            };\n        }\n        findMatchingBracketUp(_bracket, _position) {\n            let bracket = _bracket.toLowerCase();\n            let position = this.validatePosition(_position);\n            let lineTokens = this._getLineTokens(position.lineNumber);\n            let languageId = lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n            let bracketsSupport = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(languageId);\n            if (!bracketsSupport) {\n                return null;\n            }\n            let data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return this._findMatchingBracketUp(data, position);\n        }\n        matchBracket(position) {\n            return this._matchBracket(this.validatePosition(position));\n        }\n        _matchBracket(position) {\n            const lineNumber = position.lineNumber;\n            const lineTokens = this._getLineTokens(lineNumber);\n            const lineText = this._buffer.getLineContent(lineNumber);\n            let tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n            if (tokenIndex < 0) {\n                return null;\n            }\n            const currentModeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex));\n            // check that the token is not to be ignored\n            if (currentModeBrackets && !supports_1.ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n                // limit search to not go before `maxBracketLength`\n                let searchStartOffset = Math.max(lineTokens.getStartOffset(tokenIndex), position.column - 1 - currentModeBrackets.maxBracketLength);\n                // limit search to not go after `maxBracketLength`\n                const searchEndOffset = Math.min(lineTokens.getEndOffset(tokenIndex), position.column - 1 + currentModeBrackets.maxBracketLength);\n                // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n                // `bestResult` will contain the most right-side result\n                let bestResult = null;\n                while (true) {\n                    let foundBracket = richEditBrackets_1.BracketsUtils.findNextBracketInToken(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                    if (!foundBracket) {\n                        // there are no more brackets in this text\n                        break;\n                    }\n                    // check that we didn't hit a bracket too far away from position\n                    if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                        let foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);\n                        foundBracketText = foundBracketText.toLowerCase();\n                        let r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText]);\n                        // check that we can actually match this bracket\n                        if (r) {\n                            bestResult = r;\n                        }\n                    }\n                    searchStartOffset = foundBracket.endColumn - 1;\n                }\n                if (bestResult) {\n                    return bestResult;\n                }\n            }\n            // If position is in between two tokens, try also looking in the previous token\n            if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n                const searchEndOffset = lineTokens.getStartOffset(tokenIndex);\n                tokenIndex--;\n                const prevModeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex));\n                // check that previous token is not to be ignored\n                if (prevModeBrackets && !supports_1.ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n                    // limit search in case previous token is very large, there's no need to go beyond `maxBracketLength`\n                    const searchStartOffset = Math.max(lineTokens.getStartOffset(tokenIndex), position.column - 1 - prevModeBrackets.maxBracketLength);\n                    const foundBracket = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                    // check that we didn't hit a bracket too far away from position\n                    if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                        let foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);\n                        foundBracketText = foundBracketText.toLowerCase();\n                        let r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText]);\n                        // check that we can actually match this bracket\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n            }\n            return null;\n        }\n        _matchFoundBracket(foundBracket, data, isOpen) {\n            if (!data) {\n                return null;\n            }\n            if (isOpen) {\n                let matched = this._findMatchingBracketDown(data, foundBracket.getEndPosition());\n                if (matched) {\n                    return [foundBracket, matched];\n                }\n            }\n            else {\n                let matched = this._findMatchingBracketUp(data, foundBracket.getStartPosition());\n                if (matched) {\n                    return [foundBracket, matched];\n                }\n            }\n            return null;\n        }\n        _findMatchingBracketUp(bracket, position) {\n            // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n            const languageId = bracket.languageIdentifier.id;\n            const reversedBracketRegex = bracket.reversedRegex;\n            let count = -1;\n            for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n                const lineTokens = this._getLineTokens(lineNumber);\n                const tokenCount = lineTokens.getCount();\n                const lineText = this._buffer.getLineContent(lineNumber);\n                let tokenIndex = tokenCount - 1;\n                let searchStopOffset = -1;\n                if (lineNumber === position.lineNumber) {\n                    tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                    searchStopOffset = position.column - 1;\n                }\n                for (; tokenIndex >= 0; tokenIndex--) {\n                    const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                    const tokenType = lineTokens.getStandardTokenType(tokenIndex);\n                    const tokenStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    const tokenEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    if (searchStopOffset === -1) {\n                        searchStopOffset = tokenEndOffset;\n                    }\n                    if (tokenLanguageId === languageId && !supports_1.ignoreBracketsInToken(tokenType)) {\n                        while (true) {\n                            let r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(reversedBracketRegex, lineNumber, lineText, tokenStartOffset, searchStopOffset);\n                            if (!r) {\n                                break;\n                            }\n                            let hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);\n                            hitText = hitText.toLowerCase();\n                            if (hitText === bracket.open) {\n                                count++;\n                            }\n                            else if (hitText === bracket.close) {\n                                count--;\n                            }\n                            if (count === 0) {\n                                return r;\n                            }\n                            searchStopOffset = r.startColumn - 1;\n                        }\n                    }\n                    searchStopOffset = -1;\n                }\n            }\n            return null;\n        }\n        _findMatchingBracketDown(bracket, position) {\n            // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n            const languageId = bracket.languageIdentifier.id;\n            const bracketRegex = bracket.forwardRegex;\n            let count = 1;\n            for (let lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n                const lineTokens = this._getLineTokens(lineNumber);\n                const tokenCount = lineTokens.getCount();\n                const lineText = this._buffer.getLineContent(lineNumber);\n                let tokenIndex = 0;\n                let searchStartOffset = 0;\n                if (lineNumber === position.lineNumber) {\n                    tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                    searchStartOffset = position.column - 1;\n                }\n                for (; tokenIndex < tokenCount; tokenIndex++) {\n                    const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                    const tokenType = lineTokens.getStandardTokenType(tokenIndex);\n                    const tokenStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    const tokenEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    if (searchStartOffset === 0) {\n                        searchStartOffset = tokenStartOffset;\n                    }\n                    if (tokenLanguageId === languageId && !supports_1.ignoreBracketsInToken(tokenType)) {\n                        while (true) {\n                            let r = richEditBrackets_1.BracketsUtils.findNextBracketInToken(bracketRegex, lineNumber, lineText, searchStartOffset, tokenEndOffset);\n                            if (!r) {\n                                break;\n                            }\n                            let hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);\n                            hitText = hitText.toLowerCase();\n                            if (hitText === bracket.open) {\n                                count++;\n                            }\n                            else if (hitText === bracket.close) {\n                                count--;\n                            }\n                            if (count === 0) {\n                                return r;\n                            }\n                            searchStartOffset = r.endColumn - 1;\n                        }\n                    }\n                    searchStartOffset = 0;\n                }\n            }\n            return null;\n        }\n        findPrevBracket(_position) {\n            const position = this.validatePosition(_position);\n            let languageId = -1;\n            let modeBrackets = null;\n            for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n                const lineTokens = this._getLineTokens(lineNumber);\n                const tokenCount = lineTokens.getCount();\n                const lineText = this._buffer.getLineContent(lineNumber);\n                let tokenIndex = tokenCount - 1;\n                let searchStopOffset = -1;\n                if (lineNumber === position.lineNumber) {\n                    tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                    searchStopOffset = position.column - 1;\n                }\n                for (; tokenIndex >= 0; tokenIndex--) {\n                    const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                    const tokenType = lineTokens.getStandardTokenType(tokenIndex);\n                    const tokenStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    const tokenEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    if (searchStopOffset === -1) {\n                        searchStopOffset = tokenEndOffset;\n                    }\n                    if (languageId !== tokenLanguageId) {\n                        languageId = tokenLanguageId;\n                        modeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(languageId);\n                    }\n                    if (modeBrackets && !supports_1.ignoreBracketsInToken(tokenType)) {\n                        let r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(modeBrackets.reversedRegex, lineNumber, lineText, tokenStartOffset, searchStopOffset);\n                        if (r) {\n                            return this._toFoundBracket(modeBrackets, r);\n                        }\n                    }\n                    searchStopOffset = -1;\n                }\n            }\n            return null;\n        }\n        findNextBracket(_position) {\n            const position = this.validatePosition(_position);\n            let languageId = -1;\n            let modeBrackets = null;\n            for (let lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n                const lineTokens = this._getLineTokens(lineNumber);\n                const tokenCount = lineTokens.getCount();\n                const lineText = this._buffer.getLineContent(lineNumber);\n                let tokenIndex = 0;\n                let searchStartOffset = 0;\n                if (lineNumber === position.lineNumber) {\n                    tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                    searchStartOffset = position.column - 1;\n                }\n                for (; tokenIndex < tokenCount; tokenIndex++) {\n                    const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                    const tokenType = lineTokens.getStandardTokenType(tokenIndex);\n                    const tokenStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    const tokenEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    if (searchStartOffset === 0) {\n                        searchStartOffset = tokenStartOffset;\n                    }\n                    if (languageId !== tokenLanguageId) {\n                        languageId = tokenLanguageId;\n                        modeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(languageId);\n                    }\n                    if (modeBrackets && !supports_1.ignoreBracketsInToken(tokenType)) {\n                        let r = richEditBrackets_1.BracketsUtils.findNextBracketInToken(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, tokenEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(modeBrackets, r);\n                        }\n                    }\n                    searchStartOffset = 0;\n                }\n            }\n            return null;\n        }\n        _toFoundBracket(modeBrackets, r) {\n            if (!r) {\n                return null;\n            }\n            let text = this.getValueInRange(r);\n            text = text.toLowerCase();\n            let data = modeBrackets.textIsBracket[text];\n            if (!data) {\n                return null;\n            }\n            return {\n                range: r,\n                open: data.open,\n                close: data.close,\n                isOpen: modeBrackets.textIsOpenBracket[text]\n            };\n        }\n        /**\n         * Returns:\n         *  - -1 => the line consists of whitespace\n         *  - otherwise => the indent level is returned value\n         */\n        static computeIndentLevel(line, tabSize) {\n            let indent = 0;\n            let i = 0;\n            let len = line.length;\n            while (i < len) {\n                let chCode = line.charCodeAt(i);\n                if (chCode === charCode_1.CharCode.Space) {\n                    indent++;\n                }\n                else if (chCode === charCode_1.CharCode.Tab) {\n                    indent = indent - indent % tabSize + tabSize;\n                }\n                else {\n                    break;\n                }\n                i++;\n            }\n            if (i === len) {\n                return -1; // line only consists of whitespace\n            }\n            return indent;\n        }\n        _computeIndentLevel(lineIndex) {\n            return TextModel.computeIndentLevel(this._buffer.getLineContent(lineIndex + 1), this._options.tabSize);\n        }\n        getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n            this._assertNotDisposed();\n            const lineCount = this.getLineCount();\n            if (lineNumber < 1 || lineNumber > lineCount) {\n                throw new Error('Illegal value for lineNumber');\n            }\n            const foldingRules = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\n            const offSide = Boolean(foldingRules && foldingRules.offSide);\n            let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n            let up_aboveContentLineIndent = -1;\n            let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n            let up_belowContentLineIndent = -1;\n            const up_resolveIndents = (lineNumber) => {\n                if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber - 1)) {\n                    up_aboveContentLineIndex = -1;\n                    up_aboveContentLineIndent = -1;\n                    // must find previous line with content\n                    for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                        let indent = this._computeIndentLevel(lineIndex);\n                        if (indent >= 0) {\n                            up_aboveContentLineIndex = lineIndex;\n                            up_aboveContentLineIndent = indent;\n                            break;\n                        }\n                    }\n                }\n                if (up_belowContentLineIndex === -2) {\n                    up_belowContentLineIndex = -1;\n                    up_belowContentLineIndent = -1;\n                    // must find next line with content\n                    for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                        let indent = this._computeIndentLevel(lineIndex);\n                        if (indent >= 0) {\n                            up_belowContentLineIndex = lineIndex;\n                            up_belowContentLineIndent = indent;\n                            break;\n                        }\n                    }\n                }\n            };\n            let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n            let down_aboveContentLineIndent = -1;\n            let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n            let down_belowContentLineIndent = -1;\n            const down_resolveIndents = (lineNumber) => {\n                if (down_aboveContentLineIndex === -2) {\n                    down_aboveContentLineIndex = -1;\n                    down_aboveContentLineIndent = -1;\n                    // must find previous line with content\n                    for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                        let indent = this._computeIndentLevel(lineIndex);\n                        if (indent >= 0) {\n                            down_aboveContentLineIndex = lineIndex;\n                            down_aboveContentLineIndent = indent;\n                            break;\n                        }\n                    }\n                }\n                if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber - 1)) {\n                    down_belowContentLineIndex = -1;\n                    down_belowContentLineIndent = -1;\n                    // must find next line with content\n                    for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                        let indent = this._computeIndentLevel(lineIndex);\n                        if (indent >= 0) {\n                            down_belowContentLineIndex = lineIndex;\n                            down_belowContentLineIndent = indent;\n                            break;\n                        }\n                    }\n                }\n            };\n            let startLineNumber = 0;\n            let goUp = true;\n            let endLineNumber = 0;\n            let goDown = true;\n            let indent = 0;\n            for (let distance = 0; goUp || goDown; distance++) {\n                const upLineNumber = lineNumber - distance;\n                const downLineNumber = lineNumber + distance;\n                if (distance !== 0 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                    goUp = false;\n                }\n                if (distance !== 0 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                    goDown = false;\n                }\n                if (distance > 50000) {\n                    // stop processing\n                    goUp = false;\n                    goDown = false;\n                }\n                if (goUp) {\n                    // compute indent level going up\n                    let upLineIndentLevel;\n                    const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                    if (currentIndent >= 0) {\n                        // This line has content (besides whitespace)\n                        // Use the line's indent\n                        up_belowContentLineIndex = upLineNumber - 1;\n                        up_belowContentLineIndent = currentIndent;\n                        upLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\n                    }\n                    else {\n                        up_resolveIndents(upLineNumber);\n                        upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                    }\n                    if (distance === 0) {\n                        // This is the initial line number\n                        startLineNumber = upLineNumber;\n                        endLineNumber = downLineNumber;\n                        indent = upLineIndentLevel;\n                        if (indent === 0) {\n                            // No need to continue\n                            return { startLineNumber, endLineNumber, indent };\n                        }\n                        continue;\n                    }\n                    if (upLineIndentLevel >= indent) {\n                        startLineNumber = upLineNumber;\n                    }\n                    else {\n                        goUp = false;\n                    }\n                }\n                if (goDown) {\n                    // compute indent level going down\n                    let downLineIndentLevel;\n                    const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                    if (currentIndent >= 0) {\n                        // This line has content (besides whitespace)\n                        // Use the line's indent\n                        down_aboveContentLineIndex = downLineNumber - 1;\n                        down_aboveContentLineIndent = currentIndent;\n                        downLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\n                    }\n                    else {\n                        down_resolveIndents(downLineNumber);\n                        downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                    }\n                    if (downLineIndentLevel >= indent) {\n                        endLineNumber = downLineNumber;\n                    }\n                    else {\n                        goDown = false;\n                    }\n                }\n            }\n            return { startLineNumber, endLineNumber, indent };\n        }\n        getLinesIndentGuides(startLineNumber, endLineNumber) {\n            this._assertNotDisposed();\n            const lineCount = this.getLineCount();\n            if (startLineNumber < 1 || startLineNumber > lineCount) {\n                throw new Error('Illegal value for startLineNumber');\n            }\n            if (endLineNumber < 1 || endLineNumber > lineCount) {\n                throw new Error('Illegal value for endLineNumber');\n            }\n            const foldingRules = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\n            const offSide = Boolean(foldingRules && foldingRules.offSide);\n            let result = new Array(endLineNumber - startLineNumber + 1);\n            let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n            let aboveContentLineIndent = -1;\n            let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n            let belowContentLineIndent = -1;\n            for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n                let resultIndex = lineNumber - startLineNumber;\n                const currentIndent = this._computeIndentLevel(lineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    aboveContentLineIndex = lineNumber - 1;\n                    aboveContentLineIndent = currentIndent;\n                    result[resultIndex] = Math.ceil(currentIndent / this._options.indentSize);\n                    continue;\n                }\n                if (aboveContentLineIndex === -2) {\n                    aboveContentLineIndex = -1;\n                    aboveContentLineIndent = -1;\n                    // must find previous line with content\n                    for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                        let indent = this._computeIndentLevel(lineIndex);\n                        if (indent >= 0) {\n                            aboveContentLineIndex = lineIndex;\n                            aboveContentLineIndent = indent;\n                            break;\n                        }\n                    }\n                }\n                if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                    belowContentLineIndex = -1;\n                    belowContentLineIndent = -1;\n                    // must find next line with content\n                    for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                        let indent = this._computeIndentLevel(lineIndex);\n                        if (indent >= 0) {\n                            belowContentLineIndex = lineIndex;\n                            belowContentLineIndent = indent;\n                            break;\n                        }\n                    }\n                }\n                result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n            }\n            return result;\n        }\n        _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n            if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n                // At the top or bottom of the file\n                return 0;\n            }\n            else if (aboveContentLineIndent < belowContentLineIndent) {\n                // we are inside the region above\n                return (1 + Math.floor(aboveContentLineIndent / this._options.indentSize));\n            }\n            else if (aboveContentLineIndent === belowContentLineIndent) {\n                // we are in between two regions\n                return Math.ceil(belowContentLineIndent / this._options.indentSize);\n            }\n            else {\n                if (offSide) {\n                    // same level as region below\n                    return Math.ceil(belowContentLineIndent / this._options.indentSize);\n                }\n                else {\n                    // we are inside the region that ends below\n                    return (1 + Math.floor(belowContentLineIndent / this._options.indentSize));\n                }\n            }\n        }\n    }\n    TextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\n    TextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\n    TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\n    TextModel.DEFAULT_CREATION_OPTIONS = {\n        isForSimpleWidget: false,\n        tabSize: editorOptions_1.EDITOR_MODEL_DEFAULTS.tabSize,\n        indentSize: editorOptions_1.EDITOR_MODEL_DEFAULTS.indentSize,\n        insertSpaces: editorOptions_1.EDITOR_MODEL_DEFAULTS.insertSpaces,\n        detectIndentation: false,\n        defaultEOL: model.DefaultEndOfLine.LF,\n        trimAutoWhitespace: editorOptions_1.EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n        largeFileOptimizations: editorOptions_1.EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n    };\n    exports.TextModel = TextModel;\n    //#region Decorations\n    class DecorationsTrees {\n        constructor() {\n            this._decorationsTree0 = new intervalTree_1.IntervalTree();\n            this._decorationsTree1 = new intervalTree_1.IntervalTree();\n        }\n        intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n            const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n            const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n            return r0.concat(r1);\n        }\n        search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {\n            if (overviewRulerOnly) {\n                return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            }\n            else {\n                const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\n                const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n                return r0.concat(r1);\n            }\n        }\n        collectNodesFromOwner(ownerId) {\n            const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n            const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n            return r0.concat(r1);\n        }\n        collectNodesPostOrder() {\n            const r0 = this._decorationsTree0.collectNodesPostOrder();\n            const r1 = this._decorationsTree1.collectNodesPostOrder();\n            return r0.concat(r1);\n        }\n        insert(node) {\n            if (intervalTree_1.getNodeIsInOverviewRuler(node)) {\n                this._decorationsTree1.insert(node);\n            }\n            else {\n                this._decorationsTree0.insert(node);\n            }\n        }\n        delete(node) {\n            if (intervalTree_1.getNodeIsInOverviewRuler(node)) {\n                this._decorationsTree1.delete(node);\n            }\n            else {\n                this._decorationsTree0.delete(node);\n            }\n        }\n        resolveNode(node, cachedVersionId) {\n            if (intervalTree_1.getNodeIsInOverviewRuler(node)) {\n                this._decorationsTree1.resolveNode(node, cachedVersionId);\n            }\n            else {\n                this._decorationsTree0.resolveNode(node, cachedVersionId);\n            }\n        }\n        acceptReplace(offset, length, textLength, forceMoveMarkers) {\n            this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n            this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        }\n    }\n    function cleanClassName(className) {\n        return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n    }\n    class ModelDecorationOverviewRulerOptions {\n        constructor(options) {\n            this.color = options.color || strings.empty;\n            this.darkColor = options.darkColor || strings.empty;\n            this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n            this._resolvedColor = null;\n        }\n        getColor(theme) {\n            if (!this._resolvedColor) {\n                if (theme.type !== 'light' && this.darkColor) {\n                    this._resolvedColor = this._resolveColor(this.darkColor, theme);\n                }\n                else {\n                    this._resolvedColor = this._resolveColor(this.color, theme);\n                }\n            }\n            return this._resolvedColor;\n        }\n        invalidateCachedColor() {\n            this._resolvedColor = null;\n        }\n        _resolveColor(color, theme) {\n            if (typeof color === 'string') {\n                return color;\n            }\n            let c = color ? theme.getColor(color.id) : null;\n            if (!c) {\n                return strings.empty;\n            }\n            return c.toString();\n        }\n    }\n    exports.ModelDecorationOverviewRulerOptions = ModelDecorationOverviewRulerOptions;\n    class ModelDecorationOptions {\n        static register(options) {\n            return new ModelDecorationOptions(options);\n        }\n        static createDynamic(options) {\n            return new ModelDecorationOptions(options);\n        }\n        constructor(options) {\n            this.stickiness = options.stickiness || model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges;\n            this.zIndex = options.zIndex || 0;\n            this.className = options.className ? cleanClassName(options.className) : null;\n            this.hoverMessage = types_1.withUndefinedAsNull(options.hoverMessage);\n            this.glyphMarginHoverMessage = types_1.withUndefinedAsNull(options.glyphMarginHoverMessage);\n            this.isWholeLine = options.isWholeLine || false;\n            this.showIfCollapsed = options.showIfCollapsed || false;\n            this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n            this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n            this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n            this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n            this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n            this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n            this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n            this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n            this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        }\n    }\n    exports.ModelDecorationOptions = ModelDecorationOptions;\n    ModelDecorationOptions.EMPTY = ModelDecorationOptions.register({});\n    /**\n     * The order carefully matches the values of the enum.\n     */\n    const TRACKED_RANGE_OPTIONS = [\n        ModelDecorationOptions.register({ stickiness: model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges }),\n        ModelDecorationOptions.register({ stickiness: model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges }),\n        ModelDecorationOptions.register({ stickiness: model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore }),\n        ModelDecorationOptions.register({ stickiness: model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter }),\n    ];\n    function _normalizeOptions(options) {\n        if (options instanceof ModelDecorationOptions) {\n            return options;\n        }\n        return ModelDecorationOptions.createDynamic(options);\n    }\n    class DidChangeDecorationsEmitter extends lifecycle_1.Disposable {\n        constructor() {\n            super();\n            this._actual = this._register(new event_1.Emitter());\n            this.event = this._actual.event;\n            this._deferredCnt = 0;\n            this._shouldFire = false;\n        }\n        beginDeferredEmit() {\n            this._deferredCnt++;\n        }\n        endDeferredEmit() {\n            this._deferredCnt--;\n            if (this._deferredCnt === 0) {\n                if (this._shouldFire) {\n                    this._shouldFire = false;\n                    this._actual.fire({});\n                }\n            }\n        }\n        fire() {\n            this._shouldFire = true;\n        }\n    }\n    exports.DidChangeDecorationsEmitter = DidChangeDecorationsEmitter;\n    //#endregion\n    class DidChangeContentEmitter extends lifecycle_1.Disposable {\n        constructor() {\n            super();\n            /**\n             * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n             */\n            this._fastEmitter = this._register(new event_1.Emitter());\n            this.fastEvent = this._fastEmitter.event;\n            this._slowEmitter = this._register(new event_1.Emitter());\n            this.slowEvent = this._slowEmitter.event;\n            this._deferredCnt = 0;\n            this._deferredEvent = null;\n        }\n        beginDeferredEmit() {\n            this._deferredCnt++;\n        }\n        endDeferredEmit() {\n            this._deferredCnt--;\n            if (this._deferredCnt === 0) {\n                if (this._deferredEvent !== null) {\n                    const e = this._deferredEvent;\n                    this._deferredEvent = null;\n                    this._fastEmitter.fire(e);\n                    this._slowEmitter.fire(e);\n                }\n            }\n        }\n        fire(e) {\n            if (this._deferredCnt > 0) {\n                if (this._deferredEvent) {\n                    this._deferredEvent = this._deferredEvent.merge(e);\n                }\n                else {\n                    this._deferredEvent = e;\n                }\n                return;\n            }\n            this._fastEmitter.fire(e);\n            this._slowEmitter.fire(e);\n        }\n    }\n    exports.DidChangeContentEmitter = DidChangeContentEmitter;\n});\n",null]}