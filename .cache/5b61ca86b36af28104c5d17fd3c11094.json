{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/platform/commands/common/commands.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/commands/common/commands.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar types_1 = require(\"vs/base/common/types\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar event_1 = require(\"vs/base/common/event\");\nvar linkedList_1 = require(\"vs/base/common/linkedList\");\nexports.ICommandService = instantiation_1.createDecorator('commandService');\nexports.CommandsRegistry = new /** @class */ (function () {\n    function class_1() {\n        this._commands = new Map();\n        this._onDidRegisterCommand = new event_1.Emitter();\n        this.onDidRegisterCommand = this._onDidRegisterCommand.event;\n    }\n    class_1.prototype.registerCommand = function (idOrCommand, handler) {\n        var _this = this;\n        if (!idOrCommand) {\n            throw new Error(\"invalid command\");\n        }\n        if (typeof idOrCommand === 'string') {\n            if (!handler) {\n                throw new Error(\"invalid command\");\n            }\n            return this.registerCommand({ id: idOrCommand, handler: handler });\n        }\n        // add argument validation if rich command metadata is provided\n        if (idOrCommand.description) {\n            var constraints_1 = [];\n            for (var _i = 0, _a = idOrCommand.description.args; _i < _a.length; _i++) {\n                var arg = _a[_i];\n                constraints_1.push(arg.constraint);\n            }\n            var actualHandler_1 = idOrCommand.handler;\n            idOrCommand.handler = function (accessor) {\n                var args = [];\n                for (var _i = 1; _i < arguments.length; _i++) {\n                    args[_i - 1] = arguments[_i];\n                }\n                types_1.validateConstraints(args, constraints_1);\n                return actualHandler_1.apply(void 0, [accessor].concat(args));\n            };\n        }\n        // find a place to store the command\n        var id = idOrCommand.id;\n        var commands = this._commands.get(id);\n        if (!commands) {\n            commands = new linkedList_1.LinkedList();\n            this._commands.set(id, commands);\n        }\n        var removeFn = commands.unshift(idOrCommand);\n        var ret = lifecycle_1.toDisposable(function () {\n            removeFn();\n            var command = _this._commands.get(id);\n            if (command && command.isEmpty()) {\n                _this._commands.delete(id);\n            }\n        });\n        // tell the world about this command\n        this._onDidRegisterCommand.fire(id);\n        return ret;\n    };\n    class_1.prototype.registerCommandAlias = function (oldId, newId) {\n        return exports.CommandsRegistry.registerCommand(oldId, function (accessor) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            var _a;\n            return (_a = accessor.get(exports.ICommandService)).executeCommand.apply(_a, [newId].concat(args));\n        });\n    };\n    class_1.prototype.getCommand = function (id) {\n        var list = this._commands.get(id);\n        if (!list || list.isEmpty()) {\n            return undefined;\n        }\n        return list.iterator().next().value;\n    };\n    class_1.prototype.getCommands = function () {\n        var _this = this;\n        var result = Object.create(null);\n        this._commands.forEach(function (value, key) {\n            result[key] = _this.getCommand(key);\n        });\n        return result;\n    };\n    return class_1;\n}());\nexports.NullCommandService = {\n    _serviceBrand: undefined,\n    onWillExecuteCommand: function () { return ({ dispose: function () { } }); },\n    executeCommand: function () {\n        return Promise.resolve(undefined);\n    }\n};\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/platform/commands/common/commands.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/platform/commands/common/commands.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { TypeConstraint, validateConstraints } from 'vs/base/common/types';\nimport { ServicesAccessor, createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { LinkedList } from 'vs/base/common/linkedList';\nimport { IJSONSchema } from 'vs/base/common/jsonSchema';\n\nexport const ICommandService = createDecorator<ICommandService>('commandService');\n\nexport interface ICommandEvent {\n\tcommandId: string;\n}\n\nexport interface ICommandService {\n\t_serviceBrand: any;\n\tonWillExecuteCommand: Event<ICommandEvent>;\n\texecuteCommand<T = any>(commandId: string, ...args: any[]): Promise<T | undefined>;\n}\n\nexport interface ICommandsMap {\n\t[id: string]: ICommand;\n}\n\nexport interface ICommandHandler {\n\t(accessor: ServicesAccessor, ...args: any[]): void;\n}\n\nexport interface ICommand {\n\tid: string;\n\thandler: ICommandHandler;\n\tdescription?: ICommandHandlerDescription | null;\n}\n\nexport interface ICommandHandlerDescription {\n\tdescription: string;\n\targs: { name: string; description?: string; constraint?: TypeConstraint; schema?: IJSONSchema; }[];\n\treturns?: string;\n}\n\nexport interface ICommandRegistry {\n\tonDidRegisterCommand: Event<string>;\n\tregisterCommand(id: string, command: ICommandHandler): IDisposable;\n\tregisterCommand(command: ICommand): IDisposable;\n\tregisterCommandAlias(oldId: string, newId: string): IDisposable;\n\tgetCommand(id: string): ICommand | undefined;\n\tgetCommands(): ICommandsMap;\n}\n\nexport const CommandsRegistry: ICommandRegistry = new class implements ICommandRegistry {\n\n\tprivate readonly _commands = new Map<string, LinkedList<ICommand>>();\n\n\tprivate readonly _onDidRegisterCommand = new Emitter<string>();\n\treadonly onDidRegisterCommand: Event<string> = this._onDidRegisterCommand.event;\n\n\tregisterCommand(idOrCommand: string | ICommand, handler?: ICommandHandler): IDisposable {\n\n\t\tif (!idOrCommand) {\n\t\t\tthrow new Error(`invalid command`);\n\t\t}\n\n\t\tif (typeof idOrCommand === 'string') {\n\t\t\tif (!handler) {\n\t\t\t\tthrow new Error(`invalid command`);\n\t\t\t}\n\t\t\treturn this.registerCommand({ id: idOrCommand, handler });\n\t\t}\n\n\t\t// add argument validation if rich command metadata is provided\n\t\tif (idOrCommand.description) {\n\t\t\tconst constraints: Array<TypeConstraint | undefined> = [];\n\t\t\tfor (let arg of idOrCommand.description.args) {\n\t\t\t\tconstraints.push(arg.constraint);\n\t\t\t}\n\t\t\tconst actualHandler = idOrCommand.handler;\n\t\t\tidOrCommand.handler = function (accessor, ...args: any[]) {\n\t\t\t\tvalidateConstraints(args, constraints);\n\t\t\t\treturn actualHandler(accessor, ...args);\n\t\t\t};\n\t\t}\n\n\t\t// find a place to store the command\n\t\tconst { id } = idOrCommand;\n\n\t\tlet commands = this._commands.get(id);\n\t\tif (!commands) {\n\t\t\tcommands = new LinkedList<ICommand>();\n\t\t\tthis._commands.set(id, commands);\n\t\t}\n\n\t\tlet removeFn = commands.unshift(idOrCommand);\n\n\t\tlet ret = toDisposable(() => {\n\t\t\tremoveFn();\n\t\t\tconst command = this._commands.get(id);\n\t\t\tif (command && command.isEmpty()) {\n\t\t\t\tthis._commands.delete(id);\n\t\t\t}\n\t\t});\n\n\t\t// tell the world about this command\n\t\tthis._onDidRegisterCommand.fire(id);\n\n\t\treturn ret;\n\t}\n\n\tregisterCommandAlias(oldId: string, newId: string): IDisposable {\n\t\treturn CommandsRegistry.registerCommand(oldId, (accessor, ...args) => accessor.get(ICommandService).executeCommand(newId, ...args));\n\t}\n\n\tgetCommand(id: string): ICommand | undefined {\n\t\tconst list = this._commands.get(id);\n\t\tif (!list || list.isEmpty()) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn list.iterator().next().value;\n\t}\n\n\tgetCommands(): ICommandsMap {\n\t\tconst result: ICommandsMap = Object.create(null);\n\t\tthis._commands.forEach((value, key) => {\n\t\t\tresult[key] = this.getCommand(key)!;\n\t\t});\n\t\treturn result;\n\t}\n};\n\nexport const NullCommandService: ICommandService = {\n\t_serviceBrand: undefined,\n\tonWillExecuteCommand: () => ({ dispose: () => { } }),\n\texecuteCommand() {\n\t\treturn Promise.resolve(undefined);\n\t}\n};\n"]}]}