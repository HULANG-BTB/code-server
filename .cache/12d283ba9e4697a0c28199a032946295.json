{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/configuration/common/jsonEditingService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/configuration/common/jsonEditingService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/json\", \"vs/base/common/strings\", \"vs/base/common/jsonEdit\", \"vs/base/common/async\", \"vs/editor/common/core/editOperation\", \"vs/editor/common/core/range\", \"vs/editor/common/core/selection\", \"vs/workbench/services/textfile/common/textfiles\", \"vs/platform/files/common/files\", \"vs/editor/common/services/resolverService\", \"vs/workbench/services/configuration/common/jsonEditing\", \"vs/platform/instantiation/common/extensions\"], function (require, exports, nls, json, strings, jsonEdit_1, async_1, editOperation_1, range_1, selection_1, textfiles_1, files_1, resolverService_1, jsonEditing_1, extensions_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let JSONEditingService = class JSONEditingService {\n        constructor(fileService, textModelResolverService, textFileService) {\n            this.fileService = fileService;\n            this.textModelResolverService = textModelResolverService;\n            this.textFileService = textFileService;\n            this.queue = new async_1.Queue();\n        }\n        write(resource, value, save) {\n            return Promise.resolve(this.queue.queue(() => this.doWriteConfiguration(resource, value, save))); // queue up writes to prevent race conditions\n        }\n        doWriteConfiguration(resource, value, save) {\n            return this.resolveAndValidate(resource, save)\n                .then(reference => this.writeToBuffer(reference.object.textEditorModel, value)\n                .then(() => reference.dispose()));\n        }\n        writeToBuffer(model, value) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const edit = this.getEdits(model, value)[0];\n                if (this.applyEditsToBuffer(edit, model)) {\n                    return this.textFileService.save(model.uri);\n                }\n            });\n        }\n        applyEditsToBuffer(edit, model) {\n            const startPosition = model.getPositionAt(edit.offset);\n            const endPosition = model.getPositionAt(edit.offset + edit.length);\n            const range = new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n            let currentText = model.getValueInRange(range);\n            if (edit.content !== currentText) {\n                const editOperation = currentText ? editOperation_1.EditOperation.replace(range, edit.content) : editOperation_1.EditOperation.insert(startPosition, edit.content);\n                model.pushEditOperations([new selection_1.Selection(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column)], [editOperation], () => []);\n                return true;\n            }\n            return false;\n        }\n        getEdits(model, configurationValue) {\n            const { tabSize, insertSpaces } = model.getOptions();\n            const eol = model.getEOL();\n            const { key, value } = configurationValue;\n            // Without key, the entire settings file is being replaced, so we just use JSON.stringify\n            if (!key) {\n                const content = JSON.stringify(value, null, insertSpaces ? strings.repeat(' ', tabSize) : '\\t');\n                return [{\n                        content,\n                        length: content.length,\n                        offset: 0\n                    }];\n            }\n            return jsonEdit_1.setProperty(model.getValue(), [key], value, { tabSize, insertSpaces, eol });\n        }\n        resolveModelReference(resource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const exists = yield this.fileService.existsFile(resource);\n                if (!exists) {\n                    yield this.fileService.updateContent(resource, '{}', { encoding: 'utf8' });\n                }\n                return this.textModelResolverService.createModelReference(resource);\n            });\n        }\n        hasParseErrors(model) {\n            const parseErrors = [];\n            json.parse(model.getValue(), parseErrors);\n            return parseErrors.length > 0;\n        }\n        resolveAndValidate(resource, checkDirty) {\n            return this.resolveModelReference(resource)\n                .then(reference => {\n                const model = reference.object.textEditorModel;\n                if (this.hasParseErrors(model)) {\n                    return this.reject(jsonEditing_1.JSONEditingErrorCode.ERROR_INVALID_FILE);\n                }\n                // Target cannot be dirty if not writing into buffer\n                if (checkDirty && this.textFileService.isDirty(resource)) {\n                    return this.reject(jsonEditing_1.JSONEditingErrorCode.ERROR_FILE_DIRTY);\n                }\n                return reference;\n            });\n        }\n        reject(code) {\n            const message = this.toErrorMessage(code);\n            return Promise.reject(new jsonEditing_1.JSONEditingError(message, code));\n        }\n        toErrorMessage(error) {\n            switch (error) {\n                // User issues\n                case jsonEditing_1.JSONEditingErrorCode.ERROR_INVALID_FILE: {\n                    return nls.localize('errorInvalidFile', \"Unable to write into the file. Please open the file to correct errors/warnings in the file and try again.\");\n                }\n                case jsonEditing_1.JSONEditingErrorCode.ERROR_FILE_DIRTY: {\n                    return nls.localize('errorFileDirty', \"Unable to write into the file because the file is dirty. Please save the file and try again.\");\n                }\n            }\n        }\n    };\n    JSONEditingService = __decorate([\n        __param(0, files_1.IFileService),\n        __param(1, resolverService_1.ITextModelService),\n        __param(2, textfiles_1.ITextFileService)\n    ], JSONEditingService);\n    exports.JSONEditingService = JSONEditingService;\n    extensions_1.registerSingleton(jsonEditing_1.IJSONEditingService, JSONEditingService, true);\n});\n",null]}