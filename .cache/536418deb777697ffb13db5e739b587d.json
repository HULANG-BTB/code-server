{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/files2/node/diskFileSystemProvider.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files2/node/diskFileSystemProvider.ts","mtime":1555846338048},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar fs_1 = require(\"fs\");\nvar os_1 = require(\"os\");\nvar util_1 = require(\"util\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar files_1 = require(\"vs/platform/files/common/files\");\nvar event_1 = require(\"vs/base/common/event\");\nvar platform_1 = require(\"vs/base/common/platform\");\nvar pfs_1 = require(\"vs/base/node/pfs\");\nvar path_1 = require(\"vs/base/common/path\");\nvar resources_1 = require(\"vs/base/common/resources\");\nvar extpath_1 = require(\"vs/base/common/extpath\");\nvar async_1 = require(\"vs/base/common/async\");\nvar nls_1 = require(\"vs/nls\");\nvar DiskFileSystemProvider = /** @class */ (function (_super) {\n    tslib_1.__extends(DiskFileSystemProvider, _super);\n    function DiskFileSystemProvider(logService) {\n        var _this = _super.call(this) || this;\n        _this.logService = logService;\n        //#region File Capabilities\n        _this.onDidChangeCapabilities = event_1.Event.None;\n        //#endregion\n        //#region File Watching\n        _this._onDidChangeFile = _this._register(new event_1.Emitter());\n        return _this;\n    }\n    Object.defineProperty(DiskFileSystemProvider.prototype, \"capabilities\", {\n        get: function () {\n            if (!this._capabilities) {\n                this._capabilities =\n                    files_1.FileSystemProviderCapabilities.FileReadWrite |\n                        files_1.FileSystemProviderCapabilities.FileOpenReadWriteClose |\n                        files_1.FileSystemProviderCapabilities.FileFolderCopy;\n                if (platform_1.isLinux) {\n                    this._capabilities |= files_1.FileSystemProviderCapabilities.PathCaseSensitive;\n                }\n            }\n            return this._capabilities;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    //#endregion\n    //#region File Metadata Resolving\n    DiskFileSystemProvider.prototype.stat = function (resource) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var _a, stat, isSymbolicLink, type, error_1;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _b.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, pfs_1.statLink(this.toFilePath(resource))];\n                    case 1:\n                        _a = _b.sent(), stat = _a.stat, isSymbolicLink = _a.isSymbolicLink;\n                        type = void 0;\n                        if (isSymbolicLink) {\n                            type = files_1.FileType.SymbolicLink | (stat.isDirectory() ? files_1.FileType.Directory : files_1.FileType.File);\n                        }\n                        else {\n                            type = stat.isFile() ? files_1.FileType.File : stat.isDirectory() ? files_1.FileType.Directory : files_1.FileType.Unknown;\n                        }\n                        return [2 /*return*/, {\n                                type: type,\n                                ctime: stat.ctime.getTime(),\n                                mtime: stat.mtime.getTime(),\n                                size: stat.size\n                            }];\n                    case 2:\n                        error_1 = _b.sent();\n                        throw this.toFileSystemProviderError(error_1);\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    DiskFileSystemProvider.prototype.readdir = function (resource) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var children, result_1, error_2;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 3, , 4]);\n                        return [4 /*yield*/, pfs_1.readdir(this.toFilePath(resource))];\n                    case 1:\n                        children = _a.sent();\n                        result_1 = [];\n                        return [4 /*yield*/, Promise.all(children.map(function (child) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                                var stat, error_3;\n                                return tslib_1.__generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0:\n                                            _a.trys.push([0, 2, , 3]);\n                                            return [4 /*yield*/, this.stat(resources_1.joinPath(resource, child))];\n                                        case 1:\n                                            stat = _a.sent();\n                                            result_1.push([child, stat.type]);\n                                            return [3 /*break*/, 3];\n                                        case 2:\n                                            error_3 = _a.sent();\n                                            this.logService.trace(error_3); // ignore errors for individual entries that can arise from permission denied\n                                            return [3 /*break*/, 3];\n                                        case 3: return [2 /*return*/];\n                                    }\n                                });\n                            }); }))];\n                    case 2:\n                        _a.sent(); // }\n                        return [2 /*return*/, result_1];\n                    case 3:\n                        error_2 = _a.sent();\n                        throw this.toFileSystemProviderError(error_2);\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    //#endregion\n    //#region File Reading/Writing\n    DiskFileSystemProvider.prototype.readFile = function (resource) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var filePath, error_4;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        filePath = this.toFilePath(resource);\n                        return [4 /*yield*/, pfs_1.readFile(filePath)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_4 = _a.sent();\n                        throw this.toFileSystemProviderError(error_4);\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    DiskFileSystemProvider.prototype.writeFile = function (resource, content, opts) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var filePath_1, exists, error_5, error_6;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 11, , 12]);\n                        filePath_1 = this.toFilePath(resource);\n                        return [4 /*yield*/, pfs_1.fileExists(filePath_1)];\n                    case 1:\n                        exists = _a.sent();\n                        if (exists && !opts.overwrite) {\n                            throw files_1.createFileSystemProviderError(new Error(nls_1.localize('fileExists', \"File already exists\")), files_1.FileSystemProviderErrorCode.FileExists);\n                        }\n                        else if (!exists && !opts.create) {\n                            throw files_1.createFileSystemProviderError(new Error(nls_1.localize('fileNotExists', \"File does not exist\")), files_1.FileSystemProviderErrorCode.FileNotFound);\n                        }\n                        if (!(exists && platform_1.isWindows)) return [3 /*break*/, 8];\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 5, , 7]);\n                        // On Windows and if the file exists, we use a different strategy of saving the file\n                        // by first truncating the file and then writing with r+ flag. This helps to save hidden files on Windows\n                        // (see https://github.com/Microsoft/vscode/issues/931) and prevent removing alternate data streams\n                        // (see https://github.com/Microsoft/vscode/issues/6363)\n                        return [4 /*yield*/, pfs_1.truncate(filePath_1, 0)];\n                    case 3:\n                        // On Windows and if the file exists, we use a different strategy of saving the file\n                        // by first truncating the file and then writing with r+ flag. This helps to save hidden files on Windows\n                        // (see https://github.com/Microsoft/vscode/issues/931) and prevent removing alternate data streams\n                        // (see https://github.com/Microsoft/vscode/issues/6363)\n                        _a.sent();\n                        // We heard from one user that fs.truncate() succeeds, but the save fails (https://github.com/Microsoft/vscode/issues/61310)\n                        // In that case, the file is now entirely empty and the contents are gone. This can happen if an external file watcher is\n                        // installed that reacts on the truncate and keeps the file busy right after. Our workaround is to retry to save after a\n                        // short timeout, assuming that the file is free to write then.\n                        return [4 /*yield*/, async_1.retry(function () { return pfs_1.writeFile(filePath_1, content, { flag: 'r+' }); }, 100 /* ms delay */, 3 /* retries */)];\n                    case 4:\n                        // We heard from one user that fs.truncate() succeeds, but the save fails (https://github.com/Microsoft/vscode/issues/61310)\n                        // In that case, the file is now entirely empty and the contents are gone. This can happen if an external file watcher is\n                        // installed that reacts on the truncate and keeps the file busy right after. Our workaround is to retry to save after a\n                        // short timeout, assuming that the file is free to write then.\n                        _a.sent();\n                        return [3 /*break*/, 7];\n                    case 5:\n                        error_5 = _a.sent();\n                        this.logService.trace(error_5);\n                        // we heard from users that fs.truncate() fails (https://github.com/Microsoft/vscode/issues/59561)\n                        // in that case we simply save the file without truncating first (same as macOS and Linux)\n                        return [4 /*yield*/, pfs_1.writeFile(filePath_1, content)];\n                    case 6:\n                        // we heard from users that fs.truncate() fails (https://github.com/Microsoft/vscode/issues/59561)\n                        // in that case we simply save the file without truncating first (same as macOS and Linux)\n                        _a.sent();\n                        return [3 /*break*/, 7];\n                    case 7: return [3 /*break*/, 10];\n                    case 8: return [4 /*yield*/, pfs_1.writeFile(filePath_1, content)];\n                    case 9:\n                        _a.sent();\n                        _a.label = 10;\n                    case 10: return [3 /*break*/, 12];\n                    case 11:\n                        error_6 = _a.sent();\n                        throw this.toFileSystemProviderError(error_6);\n                    case 12: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    DiskFileSystemProvider.prototype.open = function (resource, opts) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var filePath, flags, error_7;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        filePath = this.toFilePath(resource);\n                        flags = void 0;\n                        if (opts.create) {\n                            // we take this as a hint that the file is opened for writing\n                            // as such we use 'w' to truncate an existing or create the\n                            // file otherwise. we do not allow reading.\n                            flags = 'w';\n                        }\n                        else {\n                            // otherwise we assume the file is opened for reading\n                            // as such we use 'r' to neither truncate, nor create\n                            // the file.\n                            flags = 'r';\n                        }\n                        return [4 /*yield*/, util_1.promisify(fs_1.open)(filePath, flags)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_7 = _a.sent();\n                        throw this.toFileSystemProviderError(error_7);\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    DiskFileSystemProvider.prototype.close = function (fd) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var error_8;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, util_1.promisify(fs_1.close)(fd)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_8 = _a.sent();\n                        throw this.toFileSystemProviderError(error_8);\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    DiskFileSystemProvider.prototype.read = function (fd, pos, data, offset, length) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var result, error_9;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, util_1.promisify(fs_1.read)(fd, data, offset, length, pos)];\n                    case 1:\n                        result = _a.sent();\n                        if (typeof result === 'number') {\n                            return [2 /*return*/, result]; // node.d.ts fail\n                        }\n                        return [2 /*return*/, result.bytesRead];\n                    case 2:\n                        error_9 = _a.sent();\n                        throw this.toFileSystemProviderError(error_9);\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    DiskFileSystemProvider.prototype.write = function (fd, pos, data, offset, length) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var result, error_10;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, util_1.promisify(fs_1.write)(fd, data, offset, length, pos)];\n                    case 1:\n                        result = _a.sent();\n                        if (typeof result === 'number') {\n                            return [2 /*return*/, result]; // node.d.ts fail\n                        }\n                        return [2 /*return*/, result.bytesWritten];\n                    case 2:\n                        error_10 = _a.sent();\n                        throw this.toFileSystemProviderError(error_10);\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    //#endregion\n    //#region Move/Copy/Delete/Create Folder\n    DiskFileSystemProvider.prototype.mkdir = function (resource) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var error_11;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, util_1.promisify(fs_1.mkdir)(this.toFilePath(resource))];\n                    case 1:\n                        _a.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        error_11 = _a.sent();\n                        throw this.toFileSystemProviderError(error_11);\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    DiskFileSystemProvider.prototype.delete = function (resource, opts) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var filePath, error_12;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        filePath = this.toFilePath(resource);\n                        return [4 /*yield*/, this.doDelete(filePath, opts)];\n                    case 1:\n                        _a.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        error_12 = _a.sent();\n                        if (error_12.code === 'ENOENT') {\n                            return [2 /*return*/, Promise.resolve()]; // tolerate that the file might not exist\n                        }\n                        throw this.toFileSystemProviderError(error_12);\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    DiskFileSystemProvider.prototype.doDelete = function (filePath, opts) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!opts.recursive) return [3 /*break*/, 2];\n                        return [4 /*yield*/, pfs_1.del(filePath, os_1.tmpdir())];\n                    case 1:\n                        _a.sent();\n                        return [3 /*break*/, 4];\n                    case 2: return [4 /*yield*/, pfs_1.unlink(filePath)];\n                    case 3:\n                        _a.sent();\n                        _a.label = 4;\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    DiskFileSystemProvider.prototype.rename = function (from, to, opts) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var fromFilePath, toFilePath, error_13;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        fromFilePath = this.toFilePath(from);\n                        toFilePath = this.toFilePath(to);\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 4, , 5]);\n                        // Ensure target does not exist\n                        return [4 /*yield*/, this.validateTargetDeleted(from, to, opts && opts.overwrite)];\n                    case 2:\n                        // Ensure target does not exist\n                        _a.sent();\n                        // Move\n                        return [4 /*yield*/, pfs_1.move(fromFilePath, toFilePath)];\n                    case 3:\n                        // Move\n                        _a.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        error_13 = _a.sent();\n                        // rewrite some typical errors that can happen especially around symlinks\n                        // to something the user can better understand\n                        if (error_13.code === 'EINVAL' || error_13.code === 'EBUSY' || error_13.code === 'ENAMETOOLONG') {\n                            error_13 = new Error(nls_1.localize('moveError', \"Unable to move '{0}' into '{1}' ({2}).\", path_1.basename(fromFilePath), path_1.basename(path_1.dirname(toFilePath)), error_13.toString()));\n                        }\n                        throw this.toFileSystemProviderError(error_13);\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    DiskFileSystemProvider.prototype.copy = function (from, to, opts) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var fromFilePath, toFilePath, error_14;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        fromFilePath = this.toFilePath(from);\n                        toFilePath = this.toFilePath(to);\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 4, , 5]);\n                        // Ensure target does not exist\n                        return [4 /*yield*/, this.validateTargetDeleted(from, to, opts && opts.overwrite)];\n                    case 2:\n                        // Ensure target does not exist\n                        _a.sent();\n                        // Copy\n                        return [4 /*yield*/, pfs_1.copy(fromFilePath, toFilePath)];\n                    case 3:\n                        // Copy\n                        _a.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        error_14 = _a.sent();\n                        // rewrite some typical errors that can happen especially around symlinks\n                        // to something the user can better understand\n                        if (error_14.code === 'EINVAL' || error_14.code === 'EBUSY' || error_14.code === 'ENAMETOOLONG') {\n                            error_14 = new Error(nls_1.localize('copyError', \"Unable to copy '{0}' into '{1}' ({2}).\", path_1.basename(fromFilePath), path_1.basename(path_1.dirname(toFilePath)), error_14.toString()));\n                        }\n                        throw this.toFileSystemProviderError(error_14);\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    DiskFileSystemProvider.prototype.validateTargetDeleted = function (from, to, overwrite) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var fromFilePath, toFilePath, isPathCaseSensitive, isCaseChange, _a;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        fromFilePath = this.toFilePath(from);\n                        toFilePath = this.toFilePath(to);\n                        isPathCaseSensitive = !!(this.capabilities & files_1.FileSystemProviderCapabilities.PathCaseSensitive);\n                        isCaseChange = isPathCaseSensitive ? false : extpath_1.isEqual(fromFilePath, toFilePath, true /* ignore case */);\n                        _a = !isCaseChange;\n                        if (!_a) return [3 /*break*/, 2];\n                        return [4 /*yield*/, pfs_1.fileExists(toFilePath)];\n                    case 1:\n                        _a = (_b.sent());\n                        _b.label = 2;\n                    case 2:\n                        if (!_a) return [3 /*break*/, 4];\n                        if (!overwrite) {\n                            throw files_1.createFileSystemProviderError(new Error('File at target already exists'), files_1.FileSystemProviderErrorCode.FileExists);\n                        }\n                        return [4 /*yield*/, this.delete(to, { recursive: true, useTrash: false })];\n                    case 3:\n                        _b.sent();\n                        _b.label = 4;\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Object.defineProperty(DiskFileSystemProvider.prototype, \"onDidChangeFile\", {\n        get: function () { return this._onDidChangeFile.event; },\n        enumerable: true,\n        configurable: true\n    });\n    DiskFileSystemProvider.prototype.watch = function (resource, opts) {\n        throw new Error('Method not implemented.');\n    };\n    //#endregion\n    //#region Helpers\n    DiskFileSystemProvider.prototype.toFilePath = function (resource) {\n        return path_1.normalize(resource.fsPath);\n    };\n    DiskFileSystemProvider.prototype.toFileSystemProviderError = function (error) {\n        if (error instanceof files_1.FileSystemProviderError) {\n            return error; // avoid double conversion\n        }\n        var code;\n        switch (error.code) {\n            case 'ENOENT':\n                code = files_1.FileSystemProviderErrorCode.FileNotFound;\n                break;\n            case 'EISDIR':\n                code = files_1.FileSystemProviderErrorCode.FileIsADirectory;\n                break;\n            case 'EEXIST':\n                code = files_1.FileSystemProviderErrorCode.FileExists;\n                break;\n            case 'EPERM':\n            case 'EACCESS':\n                code = files_1.FileSystemProviderErrorCode.NoPermissions;\n                break;\n            default:\n                code = files_1.FileSystemProviderErrorCode.Unknown;\n        }\n        return files_1.createFileSystemProviderError(error, code);\n    };\n    return DiskFileSystemProvider;\n}(lifecycle_1.Disposable));\nexports.DiskFileSystemProvider = DiskFileSystemProvider;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files2/node/diskFileSystemProvider.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/files2/node/diskFileSystemProvider.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { mkdir, open, close, read, write } from 'fs';\nimport { tmpdir } from 'os';\nimport { promisify } from 'util';\nimport { IDisposable, Disposable } from 'vs/base/common/lifecycle';\nimport { IFileSystemProvider, FileSystemProviderCapabilities, IFileChange, IWatchOptions, IStat, FileType, FileDeleteOptions, FileOverwriteOptions, FileWriteOptions, FileOpenOptions, FileSystemProviderErrorCode, createFileSystemProviderError, FileSystemProviderError } from 'vs/platform/files/common/files';\nimport { URI } from 'vs/base/common/uri';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { statLink, readdir, unlink, del, move, copy, readFile, writeFile, fileExists, truncate } from 'vs/base/node/pfs';\nimport { normalize, basename, dirname } from 'vs/base/common/path';\nimport { joinPath } from 'vs/base/common/resources';\nimport { isEqual } from 'vs/base/common/extpath';\nimport { retry } from 'vs/base/common/async';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { localize } from 'vs/nls';\n\nexport class DiskFileSystemProvider extends Disposable implements IFileSystemProvider {\n\n\tconstructor(private logService: ILogService) {\n\t\tsuper();\n\t}\n\n\t//#region File Capabilities\n\n\tonDidChangeCapabilities: Event<void> = Event.None;\n\n\tprotected _capabilities: FileSystemProviderCapabilities;\n\tget capabilities(): FileSystemProviderCapabilities {\n\t\tif (!this._capabilities) {\n\t\t\tthis._capabilities =\n\t\t\t\tFileSystemProviderCapabilities.FileReadWrite |\n\t\t\t\tFileSystemProviderCapabilities.FileOpenReadWriteClose |\n\t\t\t\tFileSystemProviderCapabilities.FileFolderCopy;\n\n\t\t\tif (isLinux) {\n\t\t\t\tthis._capabilities |= FileSystemProviderCapabilities.PathCaseSensitive;\n\t\t\t}\n\t\t}\n\n\t\treturn this._capabilities;\n\t}\n\n\t//#endregion\n\n\t//#region File Metadata Resolving\n\n\tasync stat(resource: URI): Promise<IStat> {\n\t\ttry {\n\t\t\tconst { stat, isSymbolicLink } = await statLink(this.toFilePath(resource)); // cannot use fs.stat() here to support links properly\n\n\t\t\tlet type: number;\n\t\t\tif (isSymbolicLink) {\n\t\t\t\ttype = FileType.SymbolicLink | (stat.isDirectory() ? FileType.Directory : FileType.File);\n\t\t\t} else {\n\t\t\t\ttype = stat.isFile() ? FileType.File : stat.isDirectory() ? FileType.Directory : FileType.Unknown;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttype,\n\t\t\t\tctime: stat.ctime.getTime(),\n\t\t\t\tmtime: stat.mtime.getTime(),\n\t\t\t\tsize: stat.size\n\t\t\t} as IStat;\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync readdir(resource: URI): Promise<[string, FileType][]> {\n\t\ttry {\n\t\t\tconst children = await readdir(this.toFilePath(resource));\n\n\t\t\tconst result: [string, FileType][] = [];\n\t\t\tawait Promise.all(children.map(async (child) => { // for (let i = 0; i < children.length; i++) {\n\t\t\t\t// const child = children[i];\n\n\t\t\t\ttry {\n\t\t\t\t\tconst stat = await this.stat(joinPath(resource, child));\n\t\t\t\t\tresult.push([child, stat.type]);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.trace(error); // ignore errors for individual entries that can arise from permission denied\n\t\t\t\t}\n\t\t\t})); // }\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tasync readFile(resource: URI): Promise<Uint8Array> {\n\t\ttry {\n\t\t\tconst filePath = this.toFilePath(resource);\n\n\t\t\treturn await readFile(filePath);\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync writeFile(resource: URI, content: Uint8Array, opts: FileWriteOptions): Promise<void> {\n\t\ttry {\n\t\t\tconst filePath = this.toFilePath(resource);\n\n\t\t\t// Validate target\n\t\t\tconst exists = await fileExists(filePath);\n\t\t\tif (exists && !opts.overwrite) {\n\t\t\t\tthrow createFileSystemProviderError(new Error(localize('fileExists', \"File already exists\")), FileSystemProviderErrorCode.FileExists);\n\t\t\t} else if (!exists && !opts.create) {\n\t\t\t\tthrow createFileSystemProviderError(new Error(localize('fileNotExists', \"File does not exist\")), FileSystemProviderErrorCode.FileNotFound);\n\t\t\t}\n\n\t\t\tif (exists && isWindows) {\n\t\t\t\ttry {\n\t\t\t\t\t// On Windows and if the file exists, we use a different strategy of saving the file\n\t\t\t\t\t// by first truncating the file and then writing with r+ flag. This helps to save hidden files on Windows\n\t\t\t\t\t// (see https://github.com/Microsoft/vscode/issues/931) and prevent removing alternate data streams\n\t\t\t\t\t// (see https://github.com/Microsoft/vscode/issues/6363)\n\t\t\t\t\tawait truncate(filePath, 0);\n\n\t\t\t\t\t// We heard from one user that fs.truncate() succeeds, but the save fails (https://github.com/Microsoft/vscode/issues/61310)\n\t\t\t\t\t// In that case, the file is now entirely empty and the contents are gone. This can happen if an external file watcher is\n\t\t\t\t\t// installed that reacts on the truncate and keeps the file busy right after. Our workaround is to retry to save after a\n\t\t\t\t\t// short timeout, assuming that the file is free to write then.\n\t\t\t\t\tawait retry(() => writeFile(filePath, content, { flag: 'r+' }), 100 /* ms delay */, 3 /* retries */);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\t\t// we heard from users that fs.truncate() fails (https://github.com/Microsoft/vscode/issues/59561)\n\t\t\t\t\t// in that case we simply save the file without truncating first (same as macOS and Linux)\n\t\t\t\t\tawait writeFile(filePath, content);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// macOS/Linux: just write directly\n\t\t\telse {\n\t\t\t\tawait writeFile(filePath, content);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync open(resource: URI, opts: FileOpenOptions): Promise<number> {\n\t\ttry {\n\t\t\tconst filePath = this.toFilePath(resource);\n\n\t\t\tlet flags: string;\n\t\t\tif (opts.create) {\n\t\t\t\t// we take this as a hint that the file is opened for writing\n\t\t\t\t// as such we use 'w' to truncate an existing or create the\n\t\t\t\t// file otherwise. we do not allow reading.\n\t\t\t\tflags = 'w';\n\t\t\t} else {\n\t\t\t\t// otherwise we assume the file is opened for reading\n\t\t\t\t// as such we use 'r' to neither truncate, nor create\n\t\t\t\t// the file.\n\t\t\t\tflags = 'r';\n\t\t\t}\n\n\t\t\treturn await promisify(open)(filePath, flags);\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync close(fd: number): Promise<void> {\n\t\ttry {\n\t\t\treturn await promisify(close)(fd);\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\ttry {\n\t\t\tconst result = await promisify(read)(fd, data, offset, length, pos);\n\t\t\tif (typeof result === 'number') {\n\t\t\t\treturn result; // node.d.ts fail\n\t\t\t}\n\n\t\t\treturn result.bytesRead;\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync write(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n\t\ttry {\n\t\t\tconst result = await promisify(write)(fd, data, offset, length, pos);\n\t\t\tif (typeof result === 'number') {\n\t\t\t\treturn result; // node.d.ts fail\n\t\t\t}\n\n\t\t\treturn result.bytesWritten;\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tasync mkdir(resource: URI): Promise<void> {\n\t\ttry {\n\t\t\tawait promisify(mkdir)(this.toFilePath(resource));\n\t\t} catch (error) {\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync delete(resource: URI, opts: FileDeleteOptions): Promise<void> {\n\t\ttry {\n\t\t\tconst filePath = this.toFilePath(resource);\n\n\t\t\tawait this.doDelete(filePath, opts);\n\t\t} catch (error) {\n\t\t\tif (error.code === 'ENOENT') {\n\t\t\t\treturn Promise.resolve(); // tolerate that the file might not exist\n\t\t\t}\n\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprotected async doDelete(filePath: string, opts: FileDeleteOptions): Promise<void> {\n\t\tif (opts.recursive) {\n\t\t\tawait del(filePath, tmpdir());\n\t\t} else {\n\t\t\tawait unlink(filePath);\n\t\t}\n\t}\n\n\tasync rename(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void> {\n\t\tconst fromFilePath = this.toFilePath(from);\n\t\tconst toFilePath = this.toFilePath(to);\n\n\t\ttry {\n\n\t\t\t// Ensure target does not exist\n\t\t\tawait this.validateTargetDeleted(from, to, opts && opts.overwrite);\n\n\t\t\t// Move\n\t\t\tawait move(fromFilePath, toFilePath);\n\t\t} catch (error) {\n\n\t\t\t// rewrite some typical errors that can happen especially around symlinks\n\t\t\t// to something the user can better understand\n\t\t\tif (error.code === 'EINVAL' || error.code === 'EBUSY' || error.code === 'ENAMETOOLONG') {\n\t\t\t\terror = new Error(localize('moveError', \"Unable to move '{0}' into '{1}' ({2}).\", basename(fromFilePath), basename(dirname(toFilePath)), error.toString()));\n\t\t\t}\n\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tasync copy(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void> {\n\t\tconst fromFilePath = this.toFilePath(from);\n\t\tconst toFilePath = this.toFilePath(to);\n\n\t\ttry {\n\n\t\t\t// Ensure target does not exist\n\t\t\tawait this.validateTargetDeleted(from, to, opts && opts.overwrite);\n\n\t\t\t// Copy\n\t\t\tawait copy(fromFilePath, toFilePath);\n\t\t} catch (error) {\n\n\t\t\t// rewrite some typical errors that can happen especially around symlinks\n\t\t\t// to something the user can better understand\n\t\t\tif (error.code === 'EINVAL' || error.code === 'EBUSY' || error.code === 'ENAMETOOLONG') {\n\t\t\t\terror = new Error(localize('copyError', \"Unable to copy '{0}' into '{1}' ({2}).\", basename(fromFilePath), basename(dirname(toFilePath)), error.toString()));\n\t\t\t}\n\n\t\t\tthrow this.toFileSystemProviderError(error);\n\t\t}\n\t}\n\n\tprivate async validateTargetDeleted(from: URI, to: URI, overwrite?: boolean): Promise<void> {\n\t\tconst fromFilePath = this.toFilePath(from);\n\t\tconst toFilePath = this.toFilePath(to);\n\n\t\tconst isPathCaseSensitive = !!(this.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n\t\tconst isCaseChange = isPathCaseSensitive ? false : isEqual(fromFilePath, toFilePath, true /* ignore case */);\n\n\t\t// handle existing target (unless this is a case change)\n\t\tif (!isCaseChange && await fileExists(toFilePath)) {\n\t\t\tif (!overwrite) {\n\t\t\t\tthrow createFileSystemProviderError(new Error('File at target already exists'), FileSystemProviderErrorCode.FileExists);\n\t\t\t}\n\n\t\t\tawait this.delete(to, { recursive: true, useTrash: false });\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprivate _onDidChangeFile: Emitter<IFileChange[]> = this._register(new Emitter<IFileChange[]>());\n\tget onDidChangeFile(): Event<IFileChange[]> { return this._onDidChangeFile.event; }\n\n\twatch(resource: URI, opts: IWatchOptions): IDisposable {\n\t\tthrow new Error('Method not implemented.');\n\t}\n\n\t//#endregion\n\n\t//#region Helpers\n\n\tprotected toFilePath(resource: URI): string {\n\t\treturn normalize(resource.fsPath);\n\t}\n\n\tprivate toFileSystemProviderError(error: NodeJS.ErrnoException): FileSystemProviderError {\n\t\tif (error instanceof FileSystemProviderError) {\n\t\t\treturn error; // avoid double conversion\n\t\t}\n\n\t\tlet code: FileSystemProviderErrorCode;\n\t\tswitch (error.code) {\n\t\t\tcase 'ENOENT':\n\t\t\t\tcode = FileSystemProviderErrorCode.FileNotFound;\n\t\t\t\tbreak;\n\t\t\tcase 'EISDIR':\n\t\t\t\tcode = FileSystemProviderErrorCode.FileIsADirectory;\n\t\t\t\tbreak;\n\t\t\tcase 'EEXIST':\n\t\t\t\tcode = FileSystemProviderErrorCode.FileExists;\n\t\t\t\tbreak;\n\t\t\tcase 'EPERM':\n\t\t\tcase 'EACCESS':\n\t\t\t\tcode = FileSystemProviderErrorCode.NoPermissions;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcode = FileSystemProviderErrorCode.Unknown;\n\t\t}\n\n\t\treturn createFileSystemProviderError(error, code);\n\t}\n\n\t//#endregion\n}"]}]}