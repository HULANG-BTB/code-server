{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/node/config.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/config.ts","mtime":1555846338028},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar fs = require(\"fs\");\nvar path_1 = require(\"vs/base/common/path\");\nvar objects = require(\"vs/base/common/objects\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar event_1 = require(\"vs/base/common/event\");\nvar json = require(\"vs/base/common/json\");\nvar extfs = require(\"vs/base/node/extfs\");\nvar platform_1 = require(\"vs/base/common/platform\");\n/**\n * A simple helper to watch a configured file for changes and process its contents as JSON object.\n * Supports:\n * - comments in JSON files and errors\n * - symlinks for the config file itself\n * - delayed processing of changes to accomodate for lots of changes\n * - configurable defaults\n */\nvar ConfigWatcher = /** @class */ (function () {\n    function ConfigWatcher(_path, options) {\n        if (options === void 0) { options = { defaultConfig: Object.create(null), onError: function (error) { return console.error(error); } }; }\n        this._path = _path;\n        this.options = options;\n        this.disposables = [];\n        this.configName = path_1.basename(this._path);\n        this._onDidUpdateConfiguration = new event_1.Emitter();\n        this.disposables.push(this._onDidUpdateConfiguration);\n        this.registerWatcher();\n        this.initAsync();\n    }\n    Object.defineProperty(ConfigWatcher.prototype, \"path\", {\n        get: function () {\n            return this._path;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConfigWatcher.prototype, \"hasParseErrors\", {\n        get: function () {\n            return this.parseErrors && this.parseErrors.length > 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConfigWatcher.prototype, \"onDidUpdateConfiguration\", {\n        get: function () {\n            return this._onDidUpdateConfiguration.event;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ConfigWatcher.prototype.initAsync = function () {\n        var _this = this;\n        this.loadAsync(function (config) {\n            if (!_this.loaded) {\n                _this.updateCache(config); // prevent race condition if config was loaded sync already\n            }\n            else {\n                _this.cache = config; // update config\n                _this._onDidUpdateConfiguration.fire({ config: config });\n            }\n            if (_this.options.initCallback) {\n                _this.options.initCallback(_this.getConfig());\n            }\n        });\n    };\n    ConfigWatcher.prototype.updateCache = function (value) {\n        this.cache = value;\n        this.loaded = true;\n    };\n    ConfigWatcher.prototype.loadSync = function () {\n        try {\n            return this.parse(fs.readFileSync(this._path).toString());\n        }\n        catch (error) {\n            return this.options.defaultConfig;\n        }\n    };\n    ConfigWatcher.prototype.loadAsync = function (callback) {\n        var _this = this;\n        fs.readFile(this._path, function (error, raw) {\n            if (error) {\n                return callback(_this.options.defaultConfig);\n            }\n            return callback(_this.parse(raw.toString()));\n        });\n    };\n    ConfigWatcher.prototype.parse = function (raw) {\n        var res;\n        try {\n            this.parseErrors = [];\n            res = this.options.parse ? this.options.parse(raw, this.parseErrors) : json.parse(raw, this.parseErrors);\n            return res || this.options.defaultConfig;\n        }\n        catch (error) {\n            // Ignore parsing errors\n            return this.options.defaultConfig;\n        }\n    };\n    ConfigWatcher.prototype.registerWatcher = function () {\n        var _this = this;\n        // Watch the parent of the path so that we detect ADD and DELETES\n        var parentFolder = path_1.dirname(this._path);\n        this.watch(parentFolder, true);\n        // Check if the path is a symlink and watch its target if so\n        fs.lstat(this._path, function (err, stat) {\n            if (err || stat.isDirectory()) {\n                return; // path is not a valid file\n            }\n            // We found a symlink\n            if (stat.isSymbolicLink()) {\n                fs.readlink(_this._path, function (err, realPath) {\n                    if (err) {\n                        return; // path is not a valid symlink\n                    }\n                    _this.watch(realPath, false);\n                });\n            }\n        });\n    };\n    ConfigWatcher.prototype.watch = function (path, isParentFolder) {\n        var _this = this;\n        if (this.disposed) {\n            return; // avoid watchers that will never get disposed by checking for being disposed\n        }\n        this.disposables.push(extfs.watch(path, function (type, file) { return _this.onConfigFileChange(type, file, isParentFolder); }, function (error) { return _this.options.onError(error); }));\n    };\n    ConfigWatcher.prototype.onConfigFileChange = function (eventType, filename, isParentFolder) {\n        var _this = this;\n        if (isParentFolder) {\n            // Windows: in some cases the filename contains artifacts from the absolute path\n            // see https://github.com/nodejs/node/issues/19170\n            // As such, we have to ensure that the filename basename is used for comparison.\n            if (platform_1.isWindows && filename && filename !== this.configName) {\n                filename = path_1.basename(filename);\n            }\n            if (filename !== this.configName) {\n                return; // a change to a sibling file that is not our config file\n            }\n        }\n        if (this.timeoutHandle) {\n            global.clearTimeout(this.timeoutHandle);\n            this.timeoutHandle = null;\n        }\n        // we can get multiple change events for one change, so we buffer through a timeout\n        this.timeoutHandle = global.setTimeout(function () { return _this.reload(); }, this.options.changeBufferDelay || 0);\n    };\n    ConfigWatcher.prototype.reload = function (callback) {\n        var _this = this;\n        this.loadAsync(function (currentConfig) {\n            if (!objects.equals(currentConfig, _this.cache)) {\n                _this.updateCache(currentConfig);\n                _this._onDidUpdateConfiguration.fire({ config: _this.cache });\n            }\n            if (callback) {\n                return callback(currentConfig);\n            }\n        });\n    };\n    ConfigWatcher.prototype.getConfig = function () {\n        this.ensureLoaded();\n        return this.cache;\n    };\n    ConfigWatcher.prototype.ensureLoaded = function () {\n        if (!this.loaded) {\n            this.updateCache(this.loadSync());\n        }\n    };\n    ConfigWatcher.prototype.dispose = function () {\n        this.disposed = true;\n        this.disposables = lifecycle_1.dispose(this.disposables);\n    };\n    return ConfigWatcher;\n}());\nexports.ConfigWatcher = ConfigWatcher;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/node/config.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/node/config.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { dirname, basename } from 'vs/base/common/path';\nimport * as objects from 'vs/base/common/objects';\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport * as json from 'vs/base/common/json';\nimport * as extfs from 'vs/base/node/extfs';\nimport { isWindows } from 'vs/base/common/platform';\n\nexport interface IConfigurationChangeEvent<T> {\n\tconfig: T;\n}\n\nexport interface IConfigWatcher<T> {\n\tpath: string;\n\thasParseErrors: boolean;\n\n\treload(callback: (config: T) => void): void;\n\tgetConfig(): T;\n}\n\nexport interface IConfigOptions<T> {\n\tonError: (error: Error | string) => void;\n\tdefaultConfig: T;\n\tchangeBufferDelay?: number;\n\tparse?: (content: string, errors: any[]) => T;\n\tinitCallback?: (config: T) => void;\n}\n\n/**\n * A simple helper to watch a configured file for changes and process its contents as JSON object.\n * Supports:\n * - comments in JSON files and errors\n * - symlinks for the config file itself\n * - delayed processing of changes to accomodate for lots of changes\n * - configurable defaults\n */\nexport class ConfigWatcher<T> implements IConfigWatcher<T>, IDisposable {\n\tprivate cache: T;\n\tprivate parseErrors: json.ParseError[];\n\tprivate disposed: boolean;\n\tprivate loaded: boolean;\n\tprivate timeoutHandle: NodeJS.Timer | null;\n\tprivate disposables: IDisposable[];\n\tprivate readonly _onDidUpdateConfiguration: Emitter<IConfigurationChangeEvent<T>>;\n\tprivate configName: string;\n\n\tconstructor(private _path: string, private options: IConfigOptions<T> = { defaultConfig: Object.create(null), onError: error => console.error(error) }) {\n\t\tthis.disposables = [];\n\t\tthis.configName = basename(this._path);\n\n\t\tthis._onDidUpdateConfiguration = new Emitter<IConfigurationChangeEvent<T>>();\n\t\tthis.disposables.push(this._onDidUpdateConfiguration);\n\n\t\tthis.registerWatcher();\n\t\tthis.initAsync();\n\t}\n\n\tpublic get path(): string {\n\t\treturn this._path;\n\t}\n\n\tpublic get hasParseErrors(): boolean {\n\t\treturn this.parseErrors && this.parseErrors.length > 0;\n\t}\n\n\tpublic get onDidUpdateConfiguration(): Event<IConfigurationChangeEvent<T>> {\n\t\treturn this._onDidUpdateConfiguration.event;\n\t}\n\n\tprivate initAsync(): void {\n\t\tthis.loadAsync(config => {\n\t\t\tif (!this.loaded) {\n\t\t\t\tthis.updateCache(config); // prevent race condition if config was loaded sync already\n\t\t\t} else {\n\t\t\t\tthis.cache = config; // update config\n\t\t\t\tthis._onDidUpdateConfiguration.fire({ config });\n\t\t\t}\n\t\t\tif (this.options.initCallback) {\n\t\t\t\tthis.options.initCallback(this.getConfig());\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate updateCache(value: T): void {\n\t\tthis.cache = value;\n\t\tthis.loaded = true;\n\t}\n\n\tprivate loadSync(): T {\n\t\ttry {\n\t\t\treturn this.parse(fs.readFileSync(this._path).toString());\n\t\t} catch (error) {\n\t\t\treturn this.options.defaultConfig;\n\t\t}\n\t}\n\n\tprivate loadAsync(callback: (config: T) => void): void {\n\t\tfs.readFile(this._path, (error, raw) => {\n\t\t\tif (error) {\n\t\t\t\treturn callback(this.options.defaultConfig);\n\t\t\t}\n\n\t\t\treturn callback(this.parse(raw.toString()));\n\t\t});\n\t}\n\n\tprivate parse(raw: string): T {\n\t\tlet res: T;\n\t\ttry {\n\t\t\tthis.parseErrors = [];\n\t\t\tres = this.options.parse ? this.options.parse(raw, this.parseErrors) : json.parse(raw, this.parseErrors);\n\t\t\treturn res || this.options.defaultConfig;\n\t\t} catch (error) {\n\t\t\t// Ignore parsing errors\n\t\t\treturn this.options.defaultConfig;\n\t\t}\n\t}\n\n\tprivate registerWatcher(): void {\n\n\t\t// Watch the parent of the path so that we detect ADD and DELETES\n\t\tconst parentFolder = dirname(this._path);\n\t\tthis.watch(parentFolder, true);\n\n\t\t// Check if the path is a symlink and watch its target if so\n\t\tfs.lstat(this._path, (err, stat) => {\n\t\t\tif (err || stat.isDirectory()) {\n\t\t\t\treturn; // path is not a valid file\n\t\t\t}\n\n\t\t\t// We found a symlink\n\t\t\tif (stat.isSymbolicLink()) {\n\t\t\t\tfs.readlink(this._path, (err, realPath) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn; // path is not a valid symlink\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.watch(realPath, false);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate watch(path: string, isParentFolder: boolean): void {\n\t\tif (this.disposed) {\n\t\t\treturn; // avoid watchers that will never get disposed by checking for being disposed\n\t\t}\n\n\t\tthis.disposables.push(extfs.watch(path,\n\t\t\t(type, file) => this.onConfigFileChange(type, file, isParentFolder),\n\t\t\t(error: string) => this.options.onError(error)\n\t\t));\n\t}\n\n\tprivate onConfigFileChange(eventType: string, filename: string | undefined, isParentFolder: boolean): void {\n\t\tif (isParentFolder) {\n\n\t\t\t// Windows: in some cases the filename contains artifacts from the absolute path\n\t\t\t// see https://github.com/nodejs/node/issues/19170\n\t\t\t// As such, we have to ensure that the filename basename is used for comparison.\n\t\t\tif (isWindows && filename && filename !== this.configName) {\n\t\t\t\tfilename = basename(filename);\n\t\t\t}\n\n\t\t\tif (filename !== this.configName) {\n\t\t\t\treturn; // a change to a sibling file that is not our config file\n\t\t\t}\n\t\t}\n\n\t\tif (this.timeoutHandle) {\n\t\t\tglobal.clearTimeout(this.timeoutHandle);\n\t\t\tthis.timeoutHandle = null;\n\t\t}\n\n\t\t// we can get multiple change events for one change, so we buffer through a timeout\n\t\tthis.timeoutHandle = global.setTimeout(() => this.reload(), this.options.changeBufferDelay || 0);\n\t}\n\n\tpublic reload(callback?: (config: T) => void): void {\n\t\tthis.loadAsync(currentConfig => {\n\t\t\tif (!objects.equals(currentConfig, this.cache)) {\n\t\t\t\tthis.updateCache(currentConfig);\n\n\t\t\t\tthis._onDidUpdateConfiguration.fire({ config: this.cache });\n\t\t\t}\n\n\t\t\tif (callback) {\n\t\t\t\treturn callback(currentConfig);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic getConfig(): T {\n\t\tthis.ensureLoaded();\n\n\t\treturn this.cache;\n\t}\n\n\tprivate ensureLoaded(): void {\n\t\tif (!this.loaded) {\n\t\t\tthis.updateCache(this.loadSync());\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.disposed = true;\n\t\tthis.disposables = dispose(this.disposables);\n\t}\n}"]}]}