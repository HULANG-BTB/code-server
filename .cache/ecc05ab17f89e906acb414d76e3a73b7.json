{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/parameterHints/parameterHintsModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/parameterHints/parameterHintsModel.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/async\", \"vs/base/common/errors\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/editor/common/core/characterClassifier\", \"vs/editor/common/modes\", \"vs/editor/contrib/parameterHints/provideSignatureHelp\"], function (require, exports, async_1, errors_1, event_1, lifecycle_1, characterClassifier_1, modes, provideSignatureHelp_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var ParameterHintState;\n    (function (ParameterHintState) {\n        let Type;\n        (function (Type) {\n            Type[Type[\"Default\"] = 0] = \"Default\";\n            Type[Type[\"Active\"] = 1] = \"Active\";\n            Type[Type[\"Pending\"] = 2] = \"Pending\";\n        })(Type = ParameterHintState.Type || (ParameterHintState.Type = {}));\n        ParameterHintState.Default = new class {\n            constructor() {\n                this.type = Type.Default;\n            }\n        };\n        class Pending {\n            constructor(request) {\n                this.request = request;\n                this.type = Type.Pending;\n            }\n        }\n        ParameterHintState.Pending = Pending;\n        class Active {\n            constructor(hints) {\n                this.hints = hints;\n                this.type = Type.Active;\n            }\n        }\n        ParameterHintState.Active = Active;\n    })(ParameterHintState || (ParameterHintState = {}));\n    class ParameterHintsModel extends lifecycle_1.Disposable {\n        constructor(editor, delay = ParameterHintsModel.DEFAULT_DELAY) {\n            super();\n            this._onChangedHints = this._register(new event_1.Emitter());\n            this.onChangedHints = this._onChangedHints.event;\n            this._state = ParameterHintState.Default;\n            this.triggerChars = new characterClassifier_1.CharacterSet();\n            this.retriggerChars = new characterClassifier_1.CharacterSet();\n            this.triggerId = 0;\n            this.editor = editor;\n            this.enabled = false;\n            this.throttledDelayer = new async_1.Delayer(delay);\n            this._register(this.editor.onDidChangeConfiguration(() => this.onEditorConfigurationChange()));\n            this._register(this.editor.onDidChangeModel(e => this.onModelChanged()));\n            this._register(this.editor.onDidChangeModelLanguage(_ => this.onModelChanged()));\n            this._register(this.editor.onDidChangeCursorSelection(e => this.onCursorChange(e)));\n            this._register(this.editor.onDidChangeModelContent(e => this.onModelContentChange()));\n            this._register(modes.SignatureHelpProviderRegistry.onDidChange(this.onModelChanged, this));\n            this._register(this.editor.onDidType(text => this.onDidType(text)));\n            this.onEditorConfigurationChange();\n            this.onModelChanged();\n        }\n        get state() { return this._state; }\n        set state(value) {\n            if (this._state.type === ParameterHintState.Type.Pending) {\n                this._state.request.cancel();\n            }\n            this._state = value;\n        }\n        cancel(silent = false) {\n            this.state = ParameterHintState.Default;\n            this.throttledDelayer.cancel();\n            if (!silent) {\n                this._onChangedHints.fire(undefined);\n            }\n        }\n        trigger(context, delay) {\n            const model = this.editor.getModel();\n            if (!model || !modes.SignatureHelpProviderRegistry.has(model)) {\n                return;\n            }\n            const triggerId = ++this.triggerId;\n            this.throttledDelayer.trigger(() => this.doTrigger({\n                triggerKind: context.triggerKind,\n                triggerCharacter: context.triggerCharacter,\n                isRetrigger: this.state.type === ParameterHintState.Type.Active || this.state.type === ParameterHintState.Type.Pending,\n                activeSignatureHelp: this.state.type === ParameterHintState.Type.Active ? this.state.hints : undefined\n            }, triggerId), delay).then(undefined, errors_1.onUnexpectedError);\n        }\n        next() {\n            if (this.state.type !== ParameterHintState.Type.Active) {\n                return;\n            }\n            const length = this.state.hints.signatures.length;\n            const activeSignature = this.state.hints.activeSignature;\n            const last = (activeSignature % length) === (length - 1);\n            const cycle = this.editor.getConfiguration().contribInfo.parameterHints.cycle;\n            // If there is only one signature, or we're on last signature of list\n            if ((length < 2 || last) && !cycle) {\n                this.cancel();\n                return;\n            }\n            this.updateActiveSignature(last && cycle ? 0 : activeSignature + 1);\n        }\n        previous() {\n            if (this.state.type !== ParameterHintState.Type.Active) {\n                return;\n            }\n            const length = this.state.hints.signatures.length;\n            const activeSignature = this.state.hints.activeSignature;\n            const first = activeSignature === 0;\n            const cycle = this.editor.getConfiguration().contribInfo.parameterHints.cycle;\n            // If there is only one signature, or we're on first signature of list\n            if ((length < 2 || first) && !cycle) {\n                this.cancel();\n                return;\n            }\n            this.updateActiveSignature(first && cycle ? length - 1 : activeSignature - 1);\n        }\n        updateActiveSignature(activeSignature) {\n            if (this.state.type !== ParameterHintState.Type.Active) {\n                return;\n            }\n            this.state = new ParameterHintState.Active(Object.assign({}, this.state.hints, { activeSignature }));\n            this._onChangedHints.fire(this.state.hints);\n        }\n        doTrigger(triggerContext, triggerId) {\n            this.cancel(true);\n            if (!this.editor.hasModel()) {\n                return Promise.resolve(false);\n            }\n            const model = this.editor.getModel();\n            const position = this.editor.getPosition();\n            this.state = new ParameterHintState.Pending(async_1.createCancelablePromise(token => provideSignatureHelp_1.provideSignatureHelp(model, position, triggerContext, token)));\n            return this.state.request.then(result => {\n                // Check that we are still resolving the correct signature help\n                if (triggerId !== this.triggerId) {\n                    return false;\n                }\n                if (!result || !result.signatures || result.signatures.length === 0) {\n                    this.cancel();\n                    return false;\n                }\n                else {\n                    this.state = new ParameterHintState.Active(result);\n                    this._onChangedHints.fire(this.state.hints);\n                    return true;\n                }\n            }).catch(error => {\n                if (triggerId === this.triggerId) {\n                    this.state = ParameterHintState.Default;\n                }\n                errors_1.onUnexpectedError(error);\n                return false;\n            });\n        }\n        get isTriggered() {\n            return this.state.type === ParameterHintState.Type.Active\n                || this.state.type === ParameterHintState.Type.Pending\n                || this.throttledDelayer.isTriggered();\n        }\n        onModelChanged() {\n            this.cancel();\n            // Update trigger characters\n            this.triggerChars = new characterClassifier_1.CharacterSet();\n            this.retriggerChars = new characterClassifier_1.CharacterSet();\n            const model = this.editor.getModel();\n            if (!model) {\n                return;\n            }\n            for (const support of modes.SignatureHelpProviderRegistry.ordered(model)) {\n                for (const ch of support.signatureHelpTriggerCharacters || []) {\n                    this.triggerChars.add(ch.charCodeAt(0));\n                    // All trigger characters are also considered retrigger characters\n                    this.retriggerChars.add(ch.charCodeAt(0));\n                }\n                for (const ch of support.signatureHelpRetriggerCharacters || []) {\n                    this.retriggerChars.add(ch.charCodeAt(0));\n                }\n            }\n        }\n        onDidType(text) {\n            if (!this.enabled) {\n                return;\n            }\n            const lastCharIndex = text.length - 1;\n            const triggerCharCode = text.charCodeAt(lastCharIndex);\n            if (this.triggerChars.has(triggerCharCode) || this.isTriggered && this.retriggerChars.has(triggerCharCode)) {\n                this.trigger({\n                    triggerKind: modes.SignatureHelpTriggerKind.TriggerCharacter,\n                    triggerCharacter: text.charAt(lastCharIndex),\n                });\n            }\n        }\n        onCursorChange(e) {\n            if (e.source === 'mouse') {\n                this.cancel();\n            }\n            else if (this.isTriggered) {\n                this.trigger({ triggerKind: modes.SignatureHelpTriggerKind.ContentChange });\n            }\n        }\n        onModelContentChange() {\n            if (this.isTriggered) {\n                this.trigger({ triggerKind: modes.SignatureHelpTriggerKind.ContentChange });\n            }\n        }\n        onEditorConfigurationChange() {\n            this.enabled = this.editor.getConfiguration().contribInfo.parameterHints.enabled;\n            if (!this.enabled) {\n                this.cancel();\n            }\n        }\n        dispose() {\n            this.cancel(true);\n            super.dispose();\n        }\n    }\n    ParameterHintsModel.DEFAULT_DELAY = 120; // ms\n    exports.ParameterHintsModel = ParameterHintsModel;\n});\n",null]}