{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursor.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursor.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar errors_1 = require(\"vs/base/common/errors\");\nvar event_1 = require(\"vs/base/common/event\");\nvar strings = require(\"vs/base/common/strings\");\nvar cursorCollection_1 = require(\"vs/editor/common/controller/cursorCollection\");\nvar cursorCommon_1 = require(\"vs/editor/common/controller/cursorCommon\");\nvar cursorDeleteOperations_1 = require(\"vs/editor/common/controller/cursorDeleteOperations\");\nvar cursorEvents_1 = require(\"vs/editor/common/controller/cursorEvents\");\nvar cursorTypeOperations_1 = require(\"vs/editor/common/controller/cursorTypeOperations\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar selection_1 = require(\"vs/editor/common/core/selection\");\nvar editorCommon = require(\"vs/editor/common/editorCommon\");\nvar model_1 = require(\"vs/editor/common/model\");\nvar textModelEvents_1 = require(\"vs/editor/common/model/textModelEvents\");\nvar viewEvents = require(\"vs/editor/common/view/viewEvents\");\nfunction containsLineMappingChanged(events) {\n    for (var i = 0, len = events.length; i < len; i++) {\n        if (events[i].type === viewEvents.ViewEventType.ViewLineMappingChanged) {\n            return true;\n        }\n    }\n    return false;\n}\nvar CursorStateChangedEvent = /** @class */ (function () {\n    function CursorStateChangedEvent(selections, source, reason) {\n        this.selections = selections;\n        this.source = source;\n        this.reason = reason;\n    }\n    return CursorStateChangedEvent;\n}());\nexports.CursorStateChangedEvent = CursorStateChangedEvent;\n/**\n * A snapshot of the cursor and the model state\n */\nvar CursorModelState = /** @class */ (function () {\n    function CursorModelState(model, cursor) {\n        this.modelVersionId = model.getVersionId();\n        this.cursorState = cursor.getAll();\n    }\n    CursorModelState.prototype.equals = function (other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (var i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    };\n    return CursorModelState;\n}());\nexports.CursorModelState = CursorModelState;\nvar Cursor = /** @class */ (function (_super) {\n    tslib_1.__extends(Cursor, _super);\n    function Cursor(configuration, model, viewModel) {\n        var _this = _super.call(this) || this;\n        _this._onDidReachMaxCursorCount = _this._register(new event_1.Emitter());\n        _this.onDidReachMaxCursorCount = _this._onDidReachMaxCursorCount.event;\n        _this._onDidAttemptReadOnlyEdit = _this._register(new event_1.Emitter());\n        _this.onDidAttemptReadOnlyEdit = _this._onDidAttemptReadOnlyEdit.event;\n        _this._onDidChange = _this._register(new event_1.Emitter());\n        _this.onDidChange = _this._onDidChange.event;\n        _this._configuration = configuration;\n        _this._model = model;\n        _this._knownModelVersionId = _this._model.getVersionId();\n        _this._viewModel = viewModel;\n        _this.context = new cursorCommon_1.CursorContext(_this._configuration, _this._model, _this._viewModel);\n        _this._cursors = new cursorCollection_1.CursorCollection(_this.context);\n        _this._isHandling = false;\n        _this._isDoingComposition = false;\n        _this._columnSelectData = null;\n        _this._prevEditOperationType = cursorCommon_1.EditOperationType.Other;\n        _this._register(_this._model.onDidChangeRawContent(function (e) {\n            _this._knownModelVersionId = e.versionId;\n            if (_this._isHandling) {\n                return;\n            }\n            var hadFlushEvent = e.containsEvent(textModelEvents_1.RawContentChangedType.Flush);\n            _this._onModelContentChanged(hadFlushEvent);\n        }));\n        _this._register(viewModel.addEventListener(function (events) {\n            if (!containsLineMappingChanged(events)) {\n                return;\n            }\n            if (_this._knownModelVersionId !== _this._model.getVersionId()) {\n                // There are model change events that I didn't yet receive.\n                //\n                // This can happen when editing the model, and the view model receives the change events first,\n                // and the view model emits line mapping changed events, all before the cursor gets a chance to\n                // recover from markers.\n                //\n                // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n                return;\n            }\n            // Ensure valid state\n            _this.setStates('viewModel', cursorEvents_1.CursorChangeReason.NotSet, _this.getAll());\n        }));\n        var updateCursorContext = function () {\n            _this.context = new cursorCommon_1.CursorContext(_this._configuration, _this._model, _this._viewModel);\n            _this._cursors.updateContext(_this.context);\n        };\n        _this._register(_this._model.onDidChangeLanguage(function (e) {\n            updateCursorContext();\n        }));\n        _this._register(_this._model.onDidChangeLanguageConfiguration(function () {\n            updateCursorContext();\n        }));\n        _this._register(_this._model.onDidChangeOptions(function () {\n            updateCursorContext();\n        }));\n        _this._register(_this._configuration.onDidChange(function (e) {\n            if (cursorCommon_1.CursorConfiguration.shouldRecreate(e)) {\n                updateCursorContext();\n            }\n        }));\n        return _this;\n    }\n    Cursor.prototype.dispose = function () {\n        this._cursors.dispose();\n        _super.prototype.dispose.call(this);\n    };\n    // ------ some getters/setters\n    Cursor.prototype.getPrimaryCursor = function () {\n        return this._cursors.getPrimaryCursor();\n    };\n    Cursor.prototype.getLastAddedCursorIndex = function () {\n        return this._cursors.getLastAddedCursorIndex();\n    };\n    Cursor.prototype.getAll = function () {\n        return this._cursors.getAll();\n    };\n    Cursor.prototype.setStates = function (source, reason, states) {\n        if (states !== null && states.length > Cursor.MAX_CURSOR_COUNT) {\n            states = states.slice(0, Cursor.MAX_CURSOR_COUNT);\n            this._onDidReachMaxCursorCount.fire(undefined);\n        }\n        var oldState = new CursorModelState(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._emitStateChangedIfNecessary(source, reason, oldState);\n    };\n    Cursor.prototype.setColumnSelectData = function (columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    };\n    Cursor.prototype.reveal = function (horizontal, target, scrollType) {\n        this._revealRange(target, viewEvents.VerticalRevealType.Simple, horizontal, scrollType);\n    };\n    Cursor.prototype.revealRange = function (revealHorizontal, viewRange, verticalType, scrollType) {\n        this.emitCursorRevealRange(viewRange, verticalType, revealHorizontal, scrollType);\n    };\n    Cursor.prototype.scrollTo = function (desiredScrollTop) {\n        this._viewModel.viewLayout.setScrollPositionSmooth({\n            scrollTop: desiredScrollTop\n        });\n    };\n    Cursor.prototype.saveState = function () {\n        var result = [];\n        var selections = this._cursors.getSelections();\n        for (var i = 0, len = selections.length; i < len; i++) {\n            var selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    };\n    Cursor.prototype.restoreState = function (states) {\n        var desiredSelections = [];\n        for (var i = 0, len = states.length; i < len; i++) {\n            var state = states[i];\n            var positionLineNumber = 1;\n            var positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            var selectionStartLineNumber = positionLineNumber;\n            var selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates('restoreState', cursorEvents_1.CursorChangeReason.NotSet, cursorCommon_1.CursorState.fromModelSelections(desiredSelections));\n        this.reveal(true, cursorCommon_1.RevealTarget.Primary, editorCommon.ScrollType.Immediate);\n    };\n    Cursor.prototype._onModelContentChanged = function (hadFlushEvent) {\n        this._prevEditOperationType = cursorCommon_1.EditOperationType.Other;\n        if (hadFlushEvent) {\n            // a model.setValue() was called\n            this._cursors.dispose();\n            this._cursors = new cursorCollection_1.CursorCollection(this.context);\n            this._emitStateChangedIfNecessary('model', cursorEvents_1.CursorChangeReason.ContentFlush, null);\n        }\n        else {\n            var selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n            this.setStates('modelChange', cursorEvents_1.CursorChangeReason.RecoverFromMarkers, cursorCommon_1.CursorState.fromModelSelections(selectionsFromMarkers));\n        }\n    };\n    Cursor.prototype.getSelection = function () {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    };\n    Cursor.prototype.getColumnSelectData = function () {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        var primaryCursor = this._cursors.getPrimaryCursor();\n        var primaryPos = primaryCursor.viewState.position;\n        return {\n            toViewLineNumber: primaryPos.lineNumber,\n            toViewVisualColumn: cursorCommon_1.CursorColumns.visibleColumnFromColumn2(this.context.config, this.context.viewModel, primaryPos)\n        };\n    };\n    Cursor.prototype.getSelections = function () {\n        return this._cursors.getSelections();\n    };\n    Cursor.prototype.getViewSelections = function () {\n        return this._cursors.getViewSelections();\n    };\n    Cursor.prototype.getPosition = function () {\n        return this._cursors.getPrimaryCursor().modelState.position;\n    };\n    Cursor.prototype.setSelections = function (source, selections) {\n        this.setStates(source, cursorEvents_1.CursorChangeReason.NotSet, cursorCommon_1.CursorState.fromModelSelections(selections));\n    };\n    Cursor.prototype.getPrevEditOperationType = function () {\n        return this._prevEditOperationType;\n    };\n    Cursor.prototype.setPrevEditOperationType = function (type) {\n        this._prevEditOperationType = type;\n    };\n    // ------ auxiliary handling logic\n    Cursor.prototype._executeEditOperation = function (opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        var result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    };\n    Cursor.prototype._interpretCommandResult = function (cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    };\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    Cursor.prototype._emitStateChangedIfNecessary = function (source, reason, oldState) {\n        var newState = new CursorModelState(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        var selections = this._cursors.getSelections();\n        var viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        try {\n            var eventsCollector = this._beginEmit();\n            eventsCollector.emit(new viewEvents.ViewCursorStateChangedEvent(viewSelections));\n        }\n        finally {\n            this._endEmit();\n        }\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some(function (newCursorState, i) { return !newCursorState.modelState.equals(oldState.cursorState[i].modelState); })) {\n            this._onDidChange.fire(new CursorStateChangedEvent(selections, source || 'keyboard', reason));\n        }\n        return true;\n    };\n    Cursor.prototype._revealRange = function (revealTarget, verticalType, revealHorizontal, scrollType) {\n        var viewPositions = this._cursors.getViewPositions();\n        var viewPosition = viewPositions[0];\n        if (revealTarget === cursorCommon_1.RevealTarget.TopMost) {\n            for (var i = 1; i < viewPositions.length; i++) {\n                if (viewPositions[i].isBefore(viewPosition)) {\n                    viewPosition = viewPositions[i];\n                }\n            }\n        }\n        else if (revealTarget === cursorCommon_1.RevealTarget.BottomMost) {\n            for (var i = 1; i < viewPositions.length; i++) {\n                if (viewPosition.isBeforeOrEqual(viewPositions[i])) {\n                    viewPosition = viewPositions[i];\n                }\n            }\n        }\n        else {\n            if (viewPositions.length > 1) {\n                // no revealing!\n                return;\n            }\n        }\n        var viewRange = new range_1.Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this.emitCursorRevealRange(viewRange, verticalType, revealHorizontal, scrollType);\n    };\n    Cursor.prototype.emitCursorRevealRange = function (viewRange, verticalType, revealHorizontal, scrollType) {\n        try {\n            var eventsCollector = this._beginEmit();\n            eventsCollector.emit(new viewEvents.ViewRevealRangeRequestEvent(viewRange, verticalType, revealHorizontal, scrollType));\n        }\n        finally {\n            this._endEmit();\n        }\n    };\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    Cursor.prototype.trigger = function (source, handlerId, payload) {\n        var H = editorCommon.Handler;\n        if (handlerId === H.CompositionStart) {\n            this._isDoingComposition = true;\n            return;\n        }\n        if (handlerId === H.CompositionEnd) {\n            this._isDoingComposition = false;\n        }\n        if (this._configuration.editor.readOnly) {\n            // All the remaining handlers will try to edit the model,\n            // but we cannot edit when read only...\n            this._onDidAttemptReadOnlyEdit.fire(undefined);\n            return;\n        }\n        var oldState = new CursorModelState(this._model, this);\n        var cursorChangeReason = cursorEvents_1.CursorChangeReason.NotSet;\n        if (handlerId !== H.Undo && handlerId !== H.Redo) {\n            // TODO@Alex: if the undo/redo stack contains non-null selections\n            // it would also be OK to stop tracking selections here\n            this._cursors.stopTrackingSelections();\n        }\n        // ensure valid state on all cursors\n        this._cursors.ensureValidState();\n        this._isHandling = true;\n        try {\n            switch (handlerId) {\n                case H.Type:\n                    this._type(source, payload.text);\n                    break;\n                case H.ReplacePreviousChar:\n                    this._replacePreviousChar(payload.text, payload.replaceCharCnt);\n                    break;\n                case H.Paste:\n                    cursorChangeReason = cursorEvents_1.CursorChangeReason.Paste;\n                    this._paste(payload.text, payload.pasteOnNewLine, payload.multicursorText);\n                    break;\n                case H.Cut:\n                    this._cut();\n                    break;\n                case H.Undo:\n                    cursorChangeReason = cursorEvents_1.CursorChangeReason.Undo;\n                    this._interpretCommandResult(this._model.undo());\n                    break;\n                case H.Redo:\n                    cursorChangeReason = cursorEvents_1.CursorChangeReason.Redo;\n                    this._interpretCommandResult(this._model.redo());\n                    break;\n                case H.ExecuteCommand:\n                    this._externalExecuteCommand(payload);\n                    break;\n                case H.ExecuteCommands:\n                    this._externalExecuteCommands(payload);\n                    break;\n                case H.CompositionEnd:\n                    this._interpretCompositionEnd(source);\n                    break;\n            }\n        }\n        catch (err) {\n            errors_1.onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        if (handlerId !== H.Undo && handlerId !== H.Redo) {\n            this._cursors.startTrackingSelections();\n        }\n        if (this._emitStateChangedIfNecessary(source, cursorChangeReason, oldState)) {\n            this._revealRange(cursorCommon_1.RevealTarget.Primary, viewEvents.VerticalRevealType.Simple, true, editorCommon.ScrollType.Smooth);\n        }\n    };\n    Cursor.prototype._interpretCompositionEnd = function (source) {\n        if (!this._isDoingComposition && source === 'keyboard') {\n            // composition finishes, let's check if we need to auto complete if necessary.\n            this._executeEditOperation(cursorTypeOperations_1.TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections()));\n        }\n    };\n    Cursor.prototype._type = function (source, text) {\n        if (!this._isDoingComposition && source === 'keyboard') {\n            // If this event is coming straight from the keyboard, look for electric characters and enter\n            for (var i = 0, len = text.length; i < len; i++) {\n                var charCode = text.charCodeAt(i);\n                var chr = void 0;\n                if (strings.isHighSurrogate(charCode) && i + 1 < len) {\n                    chr = text.charAt(i) + text.charAt(i + 1);\n                    i++;\n                }\n                else {\n                    chr = text.charAt(i);\n                }\n                // Here we must interpret each typed character individually, that's why we create a new context\n                this._executeEditOperation(cursorTypeOperations_1.TypeOperations.typeWithInterceptors(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), chr));\n            }\n        }\n        else {\n            this._executeEditOperation(cursorTypeOperations_1.TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), text));\n        }\n    };\n    Cursor.prototype._replacePreviousChar = function (text, replaceCharCnt) {\n        this._executeEditOperation(cursorTypeOperations_1.TypeOperations.replacePreviousChar(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), text, replaceCharCnt));\n    };\n    Cursor.prototype._paste = function (text, pasteOnNewLine, multicursorText) {\n        this._executeEditOperation(cursorTypeOperations_1.TypeOperations.paste(this.context.config, this.context.model, this.getSelections(), text, pasteOnNewLine, multicursorText));\n    };\n    Cursor.prototype._cut = function () {\n        this._executeEditOperation(cursorDeleteOperations_1.DeleteOperations.cut(this.context.config, this.context.model, this.getSelections()));\n    };\n    Cursor.prototype._externalExecuteCommand = function (command) {\n        this._cursors.killSecondaryCursors();\n        this._executeEditOperation(new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Other, [command], {\n            shouldPushStackElementBefore: false,\n            shouldPushStackElementAfter: false\n        }));\n    };\n    Cursor.prototype._externalExecuteCommands = function (commands) {\n        this._executeEditOperation(new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Other, commands, {\n            shouldPushStackElementBefore: false,\n            shouldPushStackElementAfter: false\n        }));\n    };\n    Cursor.MAX_CURSOR_COUNT = 10000;\n    return Cursor;\n}(viewEvents.ViewEventEmitter));\nexports.Cursor = Cursor;\nvar CommandExecutor = /** @class */ (function () {\n    function CommandExecutor() {\n    }\n    CommandExecutor.executeCommands = function (model, selectionsBefore, commands) {\n        var ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        var result = this._innerExecuteCommands(ctx, commands);\n        for (var i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, model_1.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);\n        }\n        return result;\n    };\n    CommandExecutor._innerExecuteCommands = function (ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        var commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        var rawOperations = commandsData.operations;\n        var loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        var filteredOperations = [];\n        for (var i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        var selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, function (inverseEditOperations) {\n            var groupedInverseEditOperations = [];\n            for (var i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (var _i = 0, inverseEditOperations_1 = inverseEditOperations; _i < inverseEditOperations_1.length; _i++) {\n                var op = inverseEditOperations_1[_i];\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            var minorBasedSorter = function (a, b) {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            var cursorSelections = [];\n            var _loop_1 = function (i) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: function () {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: function (id) {\n                            var idx = parseInt(id, 10);\n                            var range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === selection_1.SelectionDirection.LTR) {\n                                return new selection_1.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new selection_1.Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            };\n            for (var i = 0; i < ctx.selectionsBefore.length; i++) {\n                _loop_1(i);\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        var losingCursors = [];\n        for (var losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort(function (a, b) {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (var _i = 0, losingCursors_1 = losingCursors; _i < losingCursors_1.length; _i++) {\n            var losingCursor = losingCursors_1[_i];\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    };\n    CommandExecutor._arrayIsEmpty = function (commands) {\n        for (var i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    };\n    CommandExecutor._getEditOperations = function (ctx, commands) {\n        var operations = [];\n        var hadTrackedEditOperation = false;\n        for (var i = 0, len = commands.length; i < len; i++) {\n            var command = commands[i];\n            if (command) {\n                var r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    };\n    CommandExecutor._getEditOperationsFromCommand = function (ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        var operations = [];\n        var operationMinor = 0;\n        var addEditOperation = function (selection, text) {\n            if (selection.isEmpty() && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: selection,\n                text: text,\n                forceMoveMarkers: false,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        var hadTrackedEditOperation = false;\n        var addTrackedEditOperation = function (selection, text) {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text);\n        };\n        var trackSelection = function (selection, trackPreviousOnEmpty) {\n            var stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = model_1.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore;\n                    }\n                    else {\n                        stickiness = model_1.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    var maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = model_1.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore;\n                    }\n                    else {\n                        stickiness = model_1.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter;\n                    }\n                }\n            }\n            else {\n                stickiness = model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges;\n            }\n            var l = ctx.trackedRanges.length;\n            var id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        var editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            errors_1.onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    };\n    CommandExecutor._getLoserCursorMap = function (operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort(function (a, b) {\n            // Note the minus!\n            return -(range_1.Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        var loserCursorsMap = {};\n        for (var i = 1; i < operations.length; i++) {\n            var previousOp = operations[i - 1];\n            var currentOp = operations[i];\n            if (previousOp.range.getStartPosition().isBefore(currentOp.range.getEndPosition())) {\n                var loserMajor = void 0;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (var j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    };\n    return CommandExecutor;\n}());\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursor.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursor.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport * as strings from 'vs/base/common/strings';\nimport { CursorCollection } from 'vs/editor/common/controller/cursorCollection';\nimport { CursorColumns, CursorConfiguration, CursorContext, CursorState, EditOperationResult, EditOperationType, IColumnSelectData, ICursors, PartialCursorState, RevealTarget } from 'vs/editor/common/controller/cursorCommon';\nimport { DeleteOperations } from 'vs/editor/common/controller/cursorDeleteOperations';\nimport { CursorChangeReason } from 'vs/editor/common/controller/cursorEvents';\nimport { TypeOperations } from 'vs/editor/common/controller/cursorTypeOperations';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { ISelection, Selection, SelectionDirection } from 'vs/editor/common/core/selection';\nimport * as editorCommon from 'vs/editor/common/editorCommon';\nimport { IIdentifiedSingleEditOperation, ITextModel, TrackedRangeStickiness } from 'vs/editor/common/model';\nimport { RawContentChangedType } from 'vs/editor/common/model/textModelEvents';\nimport * as viewEvents from 'vs/editor/common/view/viewEvents';\nimport { IViewModel } from 'vs/editor/common/viewModel/viewModel';\n\nfunction containsLineMappingChanged(events: viewEvents.ViewEvent[]): boolean {\n\tfor (let i = 0, len = events.length; i < len; i++) {\n\t\tif (events[i].type === viewEvents.ViewEventType.ViewLineMappingChanged) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nexport class CursorStateChangedEvent {\n\t/**\n\t * The new selections.\n\t * The primary selection is always at index 0.\n\t */\n\treadonly selections: Selection[];\n\t/**\n\t * Source of the call that caused the event.\n\t */\n\treadonly source: string;\n\t/**\n\t * Reason.\n\t */\n\treadonly reason: CursorChangeReason;\n\n\tconstructor(selections: Selection[], source: string, reason: CursorChangeReason) {\n\t\tthis.selections = selections;\n\t\tthis.source = source;\n\t\tthis.reason = reason;\n\t}\n}\n\n/**\n * A snapshot of the cursor and the model state\n */\nexport class CursorModelState {\n\n\tpublic readonly modelVersionId: number;\n\tpublic readonly cursorState: CursorState[];\n\n\tconstructor(model: ITextModel, cursor: Cursor) {\n\t\tthis.modelVersionId = model.getVersionId();\n\t\tthis.cursorState = cursor.getAll();\n\t}\n\n\tpublic equals(other: CursorModelState | null): boolean {\n\t\tif (!other) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.modelVersionId !== other.modelVersionId) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.cursorState.length !== other.cursorState.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0, len = this.cursorState.length; i < len; i++) {\n\t\t\tif (!this.cursorState[i].equals(other.cursorState[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nexport class Cursor extends viewEvents.ViewEventEmitter implements ICursors {\n\n\tpublic static MAX_CURSOR_COUNT = 10000;\n\n\tprivate readonly _onDidReachMaxCursorCount: Emitter<void> = this._register(new Emitter<void>());\n\tpublic readonly onDidReachMaxCursorCount: Event<void> = this._onDidReachMaxCursorCount.event;\n\n\tprivate readonly _onDidAttemptReadOnlyEdit: Emitter<void> = this._register(new Emitter<void>());\n\tpublic readonly onDidAttemptReadOnlyEdit: Event<void> = this._onDidAttemptReadOnlyEdit.event;\n\n\tprivate readonly _onDidChange: Emitter<CursorStateChangedEvent> = this._register(new Emitter<CursorStateChangedEvent>());\n\tpublic readonly onDidChange: Event<CursorStateChangedEvent> = this._onDidChange.event;\n\n\tprivate readonly _configuration: editorCommon.IConfiguration;\n\tprivate readonly _model: ITextModel;\n\tprivate _knownModelVersionId: number;\n\tprivate readonly _viewModel: IViewModel;\n\tpublic context: CursorContext;\n\tprivate _cursors: CursorCollection;\n\n\tprivate _isHandling: boolean;\n\tprivate _isDoingComposition: boolean;\n\tprivate _columnSelectData: IColumnSelectData | null;\n\tprivate _prevEditOperationType: EditOperationType;\n\n\tconstructor(configuration: editorCommon.IConfiguration, model: ITextModel, viewModel: IViewModel) {\n\t\tsuper();\n\t\tthis._configuration = configuration;\n\t\tthis._model = model;\n\t\tthis._knownModelVersionId = this._model.getVersionId();\n\t\tthis._viewModel = viewModel;\n\t\tthis.context = new CursorContext(this._configuration, this._model, this._viewModel);\n\t\tthis._cursors = new CursorCollection(this.context);\n\n\t\tthis._isHandling = false;\n\t\tthis._isDoingComposition = false;\n\t\tthis._columnSelectData = null;\n\t\tthis._prevEditOperationType = EditOperationType.Other;\n\n\t\tthis._register(this._model.onDidChangeRawContent((e) => {\n\t\t\tthis._knownModelVersionId = e.versionId;\n\t\t\tif (this._isHandling) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet hadFlushEvent = e.containsEvent(RawContentChangedType.Flush);\n\t\t\tthis._onModelContentChanged(hadFlushEvent);\n\t\t}));\n\n\t\tthis._register(viewModel.addEventListener((events: viewEvents.ViewEvent[]) => {\n\t\t\tif (!containsLineMappingChanged(events)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this._knownModelVersionId !== this._model.getVersionId()) {\n\t\t\t\t// There are model change events that I didn't yet receive.\n\t\t\t\t//\n\t\t\t\t// This can happen when editing the model, and the view model receives the change events first,\n\t\t\t\t// and the view model emits line mapping changed events, all before the cursor gets a chance to\n\t\t\t\t// recover from markers.\n\t\t\t\t//\n\t\t\t\t// The model change listener above will be called soon and we'll ensure a valid cursor state there.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Ensure valid state\n\t\t\tthis.setStates('viewModel', CursorChangeReason.NotSet, this.getAll());\n\t\t}));\n\n\t\tconst updateCursorContext = () => {\n\t\t\tthis.context = new CursorContext(this._configuration, this._model, this._viewModel);\n\t\t\tthis._cursors.updateContext(this.context);\n\t\t};\n\t\tthis._register(this._model.onDidChangeLanguage((e) => {\n\t\t\tupdateCursorContext();\n\t\t}));\n\t\tthis._register(this._model.onDidChangeLanguageConfiguration(() => {\n\t\t\tupdateCursorContext();\n\t\t}));\n\t\tthis._register(this._model.onDidChangeOptions(() => {\n\t\t\tupdateCursorContext();\n\t\t}));\n\t\tthis._register(this._configuration.onDidChange((e) => {\n\t\t\tif (CursorConfiguration.shouldRecreate(e)) {\n\t\t\t\tupdateCursorContext();\n\t\t\t}\n\t\t}));\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._cursors.dispose();\n\t\tsuper.dispose();\n\t}\n\n\t// ------ some getters/setters\n\n\tpublic getPrimaryCursor(): CursorState {\n\t\treturn this._cursors.getPrimaryCursor();\n\t}\n\n\tpublic getLastAddedCursorIndex(): number {\n\t\treturn this._cursors.getLastAddedCursorIndex();\n\t}\n\n\tpublic getAll(): CursorState[] {\n\t\treturn this._cursors.getAll();\n\t}\n\n\tpublic setStates(source: string, reason: CursorChangeReason, states: PartialCursorState[] | null): void {\n\t\tif (states !== null && states.length > Cursor.MAX_CURSOR_COUNT) {\n\t\t\tstates = states.slice(0, Cursor.MAX_CURSOR_COUNT);\n\t\t\tthis._onDidReachMaxCursorCount.fire(undefined);\n\t\t}\n\n\t\tconst oldState = new CursorModelState(this._model, this);\n\n\t\tthis._cursors.setStates(states);\n\t\tthis._cursors.normalize();\n\t\tthis._columnSelectData = null;\n\n\t\tthis._emitStateChangedIfNecessary(source, reason, oldState);\n\t}\n\n\tpublic setColumnSelectData(columnSelectData: IColumnSelectData): void {\n\t\tthis._columnSelectData = columnSelectData;\n\t}\n\n\tpublic reveal(horizontal: boolean, target: RevealTarget, scrollType: editorCommon.ScrollType): void {\n\t\tthis._revealRange(target, viewEvents.VerticalRevealType.Simple, horizontal, scrollType);\n\t}\n\n\tpublic revealRange(revealHorizontal: boolean, viewRange: Range, verticalType: viewEvents.VerticalRevealType, scrollType: editorCommon.ScrollType) {\n\t\tthis.emitCursorRevealRange(viewRange, verticalType, revealHorizontal, scrollType);\n\t}\n\n\tpublic scrollTo(desiredScrollTop: number): void {\n\t\tthis._viewModel.viewLayout.setScrollPositionSmooth({\n\t\t\tscrollTop: desiredScrollTop\n\t\t});\n\t}\n\n\tpublic saveState(): editorCommon.ICursorState[] {\n\n\t\tlet result: editorCommon.ICursorState[] = [];\n\n\t\tconst selections = this._cursors.getSelections();\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\n\t\t\tresult.push({\n\t\t\t\tinSelectionMode: !selection.isEmpty(),\n\t\t\t\tselectionStart: {\n\t\t\t\t\tlineNumber: selection.selectionStartLineNumber,\n\t\t\t\t\tcolumn: selection.selectionStartColumn,\n\t\t\t\t},\n\t\t\t\tposition: {\n\t\t\t\t\tlineNumber: selection.positionLineNumber,\n\t\t\t\t\tcolumn: selection.positionColumn,\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic restoreState(states: editorCommon.ICursorState[]): void {\n\n\t\tlet desiredSelections: ISelection[] = [];\n\n\t\tfor (let i = 0, len = states.length; i < len; i++) {\n\t\t\tconst state = states[i];\n\n\t\t\tlet positionLineNumber = 1;\n\t\t\tlet positionColumn = 1;\n\n\t\t\t// Avoid missing properties on the literal\n\t\t\tif (state.position && state.position.lineNumber) {\n\t\t\t\tpositionLineNumber = state.position.lineNumber;\n\t\t\t}\n\t\t\tif (state.position && state.position.column) {\n\t\t\t\tpositionColumn = state.position.column;\n\t\t\t}\n\n\t\t\tlet selectionStartLineNumber = positionLineNumber;\n\t\t\tlet selectionStartColumn = positionColumn;\n\n\t\t\t// Avoid missing properties on the literal\n\t\t\tif (state.selectionStart && state.selectionStart.lineNumber) {\n\t\t\t\tselectionStartLineNumber = state.selectionStart.lineNumber;\n\t\t\t}\n\t\t\tif (state.selectionStart && state.selectionStart.column) {\n\t\t\t\tselectionStartColumn = state.selectionStart.column;\n\t\t\t}\n\n\t\t\tdesiredSelections.push({\n\t\t\t\tselectionStartLineNumber: selectionStartLineNumber,\n\t\t\t\tselectionStartColumn: selectionStartColumn,\n\t\t\t\tpositionLineNumber: positionLineNumber,\n\t\t\t\tpositionColumn: positionColumn\n\t\t\t});\n\t\t}\n\n\t\tthis.setStates('restoreState', CursorChangeReason.NotSet, CursorState.fromModelSelections(desiredSelections));\n\t\tthis.reveal(true, RevealTarget.Primary, editorCommon.ScrollType.Immediate);\n\t}\n\n\tprivate _onModelContentChanged(hadFlushEvent: boolean): void {\n\n\t\tthis._prevEditOperationType = EditOperationType.Other;\n\n\t\tif (hadFlushEvent) {\n\t\t\t// a model.setValue() was called\n\t\t\tthis._cursors.dispose();\n\t\t\tthis._cursors = new CursorCollection(this.context);\n\n\t\t\tthis._emitStateChangedIfNecessary('model', CursorChangeReason.ContentFlush, null);\n\t\t} else {\n\t\t\tconst selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n\t\t\tthis.setStates('modelChange', CursorChangeReason.RecoverFromMarkers, CursorState.fromModelSelections(selectionsFromMarkers));\n\t\t}\n\t}\n\n\tpublic getSelection(): Selection {\n\t\treturn this._cursors.getPrimaryCursor().modelState.selection;\n\t}\n\n\tpublic getColumnSelectData(): IColumnSelectData {\n\t\tif (this._columnSelectData) {\n\t\t\treturn this._columnSelectData;\n\t\t}\n\t\tconst primaryCursor = this._cursors.getPrimaryCursor();\n\t\tconst primaryPos = primaryCursor.viewState.position;\n\t\treturn {\n\t\t\ttoViewLineNumber: primaryPos.lineNumber,\n\t\t\ttoViewVisualColumn: CursorColumns.visibleColumnFromColumn2(this.context.config, this.context.viewModel, primaryPos)\n\t\t};\n\t}\n\n\tpublic getSelections(): Selection[] {\n\t\treturn this._cursors.getSelections();\n\t}\n\n\tpublic getViewSelections(): Selection[] {\n\t\treturn this._cursors.getViewSelections();\n\t}\n\n\tpublic getPosition(): Position {\n\t\treturn this._cursors.getPrimaryCursor().modelState.position;\n\t}\n\n\tpublic setSelections(source: string, selections: ISelection[]): void {\n\t\tthis.setStates(source, CursorChangeReason.NotSet, CursorState.fromModelSelections(selections));\n\t}\n\n\tpublic getPrevEditOperationType(): EditOperationType {\n\t\treturn this._prevEditOperationType;\n\t}\n\n\tpublic setPrevEditOperationType(type: EditOperationType): void {\n\t\tthis._prevEditOperationType = type;\n\t}\n\n\t// ------ auxiliary handling logic\n\n\tprivate _executeEditOperation(opResult: EditOperationResult | null): void {\n\n\t\tif (!opResult) {\n\t\t\t// Nothing to execute\n\t\t\treturn;\n\t\t}\n\n\t\tif (opResult.shouldPushStackElementBefore) {\n\t\t\tthis._model.pushStackElement();\n\t\t}\n\n\t\tconst result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n\t\tif (result) {\n\t\t\t// The commands were applied correctly\n\t\t\tthis._interpretCommandResult(result);\n\n\t\t\tthis._prevEditOperationType = opResult.type;\n\t\t}\n\n\t\tif (opResult.shouldPushStackElementAfter) {\n\t\t\tthis._model.pushStackElement();\n\t\t}\n\t}\n\n\tprivate _interpretCommandResult(cursorState: Selection[] | null): void {\n\t\tif (!cursorState || cursorState.length === 0) {\n\t\t\tcursorState = this._cursors.readSelectionFromMarkers();\n\t\t}\n\n\t\tthis._columnSelectData = null;\n\t\tthis._cursors.setSelections(cursorState);\n\t\tthis._cursors.normalize();\n\t}\n\n\t// -----------------------------------------------------------------------------------------------------------\n\t// ----- emitting events\n\n\tprivate _emitStateChangedIfNecessary(source: string, reason: CursorChangeReason, oldState: CursorModelState | null): boolean {\n\t\tconst newState = new CursorModelState(this._model, this);\n\t\tif (newState.equals(oldState)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst selections = this._cursors.getSelections();\n\t\tconst viewSelections = this._cursors.getViewSelections();\n\n\t\t// Let the view get the event first.\n\t\ttry {\n\t\t\tconst eventsCollector = this._beginEmit();\n\t\t\teventsCollector.emit(new viewEvents.ViewCursorStateChangedEvent(viewSelections));\n\t\t} finally {\n\t\t\tthis._endEmit();\n\t\t}\n\n\t\t// Only after the view has been notified, let the rest of the world know...\n\t\tif (!oldState\n\t\t\t|| oldState.cursorState.length !== newState.cursorState.length\n\t\t\t|| newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))\n\t\t) {\n\t\t\tthis._onDidChange.fire(new CursorStateChangedEvent(selections, source || 'keyboard', reason));\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate _revealRange(revealTarget: RevealTarget, verticalType: viewEvents.VerticalRevealType, revealHorizontal: boolean, scrollType: editorCommon.ScrollType): void {\n\t\tconst viewPositions = this._cursors.getViewPositions();\n\n\t\tlet viewPosition = viewPositions[0];\n\n\t\tif (revealTarget === RevealTarget.TopMost) {\n\t\t\tfor (let i = 1; i < viewPositions.length; i++) {\n\t\t\t\tif (viewPositions[i].isBefore(viewPosition)) {\n\t\t\t\t\tviewPosition = viewPositions[i];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (revealTarget === RevealTarget.BottomMost) {\n\t\t\tfor (let i = 1; i < viewPositions.length; i++) {\n\t\t\t\tif (viewPosition.isBeforeOrEqual(viewPositions[i])) {\n\t\t\t\t\tviewPosition = viewPositions[i];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (viewPositions.length > 1) {\n\t\t\t\t// no revealing!\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n\t\tthis.emitCursorRevealRange(viewRange, verticalType, revealHorizontal, scrollType);\n\t}\n\n\tpublic emitCursorRevealRange(viewRange: Range, verticalType: viewEvents.VerticalRevealType, revealHorizontal: boolean, scrollType: editorCommon.ScrollType) {\n\t\ttry {\n\t\t\tconst eventsCollector = this._beginEmit();\n\t\t\teventsCollector.emit(new viewEvents.ViewRevealRangeRequestEvent(viewRange, verticalType, revealHorizontal, scrollType));\n\t\t} finally {\n\t\t\tthis._endEmit();\n\t\t}\n\t}\n\n\t// -----------------------------------------------------------------------------------------------------------\n\t// ----- handlers beyond this point\n\n\tpublic trigger(source: string, handlerId: string, payload: any): void {\n\t\tconst H = editorCommon.Handler;\n\n\t\tif (handlerId === H.CompositionStart) {\n\t\t\tthis._isDoingComposition = true;\n\t\t\treturn;\n\t\t}\n\n\t\tif (handlerId === H.CompositionEnd) {\n\t\t\tthis._isDoingComposition = false;\n\t\t}\n\n\t\tif (this._configuration.editor.readOnly) {\n\t\t\t// All the remaining handlers will try to edit the model,\n\t\t\t// but we cannot edit when read only...\n\t\t\tthis._onDidAttemptReadOnlyEdit.fire(undefined);\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldState = new CursorModelState(this._model, this);\n\t\tlet cursorChangeReason = CursorChangeReason.NotSet;\n\n\t\tif (handlerId !== H.Undo && handlerId !== H.Redo) {\n\t\t\t// TODO@Alex: if the undo/redo stack contains non-null selections\n\t\t\t// it would also be OK to stop tracking selections here\n\t\t\tthis._cursors.stopTrackingSelections();\n\t\t}\n\n\t\t// ensure valid state on all cursors\n\t\tthis._cursors.ensureValidState();\n\n\t\tthis._isHandling = true;\n\n\t\ttry {\n\t\t\tswitch (handlerId) {\n\t\t\t\tcase H.Type:\n\t\t\t\t\tthis._type(source, <string>payload.text);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase H.ReplacePreviousChar:\n\t\t\t\t\tthis._replacePreviousChar(<string>payload.text, <number>payload.replaceCharCnt);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase H.Paste:\n\t\t\t\t\tcursorChangeReason = CursorChangeReason.Paste;\n\t\t\t\t\tthis._paste(<string>payload.text, <boolean>payload.pasteOnNewLine, <string[]>payload.multicursorText);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase H.Cut:\n\t\t\t\t\tthis._cut();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase H.Undo:\n\t\t\t\t\tcursorChangeReason = CursorChangeReason.Undo;\n\t\t\t\t\tthis._interpretCommandResult(this._model.undo());\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase H.Redo:\n\t\t\t\t\tcursorChangeReason = CursorChangeReason.Redo;\n\t\t\t\t\tthis._interpretCommandResult(this._model.redo());\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase H.ExecuteCommand:\n\t\t\t\t\tthis._externalExecuteCommand(<editorCommon.ICommand>payload);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase H.ExecuteCommands:\n\t\t\t\t\tthis._externalExecuteCommands(<editorCommon.ICommand[]>payload);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase H.CompositionEnd:\n\t\t\t\t\tthis._interpretCompositionEnd(source);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tonUnexpectedError(err);\n\t\t}\n\n\t\tthis._isHandling = false;\n\n\t\tif (handlerId !== H.Undo && handlerId !== H.Redo) {\n\t\t\tthis._cursors.startTrackingSelections();\n\t\t}\n\n\t\tif (this._emitStateChangedIfNecessary(source, cursorChangeReason, oldState)) {\n\t\t\tthis._revealRange(RevealTarget.Primary, viewEvents.VerticalRevealType.Simple, true, editorCommon.ScrollType.Smooth);\n\t\t}\n\t}\n\n\tprivate _interpretCompositionEnd(source: string) {\n\t\tif (!this._isDoingComposition && source === 'keyboard') {\n\t\t\t// composition finishes, let's check if we need to auto complete if necessary.\n\t\t\tthis._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections()));\n\t\t}\n\t}\n\n\tprivate _type(source: string, text: string): void {\n\t\tif (!this._isDoingComposition && source === 'keyboard') {\n\t\t\t// If this event is coming straight from the keyboard, look for electric characters and enter\n\n\t\t\tfor (let i = 0, len = text.length; i < len; i++) {\n\t\t\t\tlet charCode = text.charCodeAt(i);\n\t\t\t\tlet chr: string;\n\t\t\t\tif (strings.isHighSurrogate(charCode) && i + 1 < len) {\n\t\t\t\t\tchr = text.charAt(i) + text.charAt(i + 1);\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\tchr = text.charAt(i);\n\t\t\t\t}\n\n\t\t\t\t// Here we must interpret each typed character individually, that's why we create a new context\n\t\t\t\tthis._executeEditOperation(TypeOperations.typeWithInterceptors(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), chr));\n\t\t\t}\n\n\t\t} else {\n\t\t\tthis._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), text));\n\t\t}\n\t}\n\n\tprivate _replacePreviousChar(text: string, replaceCharCnt: number): void {\n\t\tthis._executeEditOperation(TypeOperations.replacePreviousChar(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), text, replaceCharCnt));\n\t}\n\n\tprivate _paste(text: string, pasteOnNewLine: boolean, multicursorText: string[]): void {\n\t\tthis._executeEditOperation(TypeOperations.paste(this.context.config, this.context.model, this.getSelections(), text, pasteOnNewLine, multicursorText));\n\t}\n\n\tprivate _cut(): void {\n\t\tthis._executeEditOperation(DeleteOperations.cut(this.context.config, this.context.model, this.getSelections()));\n\t}\n\n\tprivate _externalExecuteCommand(command: editorCommon.ICommand): void {\n\t\tthis._cursors.killSecondaryCursors();\n\n\t\tthis._executeEditOperation(new EditOperationResult(EditOperationType.Other, [command], {\n\t\t\tshouldPushStackElementBefore: false,\n\t\t\tshouldPushStackElementAfter: false\n\t\t}));\n\t}\n\n\tprivate _externalExecuteCommands(commands: editorCommon.ICommand[]): void {\n\t\tthis._executeEditOperation(new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\tshouldPushStackElementBefore: false,\n\t\t\tshouldPushStackElementAfter: false\n\t\t}));\n\t}\n}\n\ninterface IExecContext {\n\treadonly model: ITextModel;\n\treadonly selectionsBefore: Selection[];\n\treadonly trackedRanges: string[];\n\treadonly trackedRangesDirection: SelectionDirection[];\n}\n\ninterface ICommandData {\n\toperations: IIdentifiedSingleEditOperation[];\n\thadTrackedEditOperation: boolean;\n}\n\ninterface ICommandsData {\n\toperations: IIdentifiedSingleEditOperation[];\n\thadTrackedEditOperation: boolean;\n}\n\nclass CommandExecutor {\n\n\tpublic static executeCommands(model: ITextModel, selectionsBefore: Selection[], commands: (editorCommon.ICommand | null)[]): Selection[] | null {\n\n\t\tconst ctx: IExecContext = {\n\t\t\tmodel: model,\n\t\t\tselectionsBefore: selectionsBefore,\n\t\t\ttrackedRanges: [],\n\t\t\ttrackedRangesDirection: []\n\t\t};\n\n\t\tconst result = this._innerExecuteCommands(ctx, commands);\n\n\t\tfor (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n\t\t\tctx.model._setTrackedRange(ctx.trackedRanges[i], null, TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _innerExecuteCommands(ctx: IExecContext, commands: (editorCommon.ICommand | null)[]): Selection[] | null {\n\n\t\tif (this._arrayIsEmpty(commands)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst commandsData = this._getEditOperations(ctx, commands);\n\t\tif (commandsData.operations.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst rawOperations = commandsData.operations;\n\n\t\tconst loserCursorsMap = this._getLoserCursorMap(rawOperations);\n\t\tif (loserCursorsMap.hasOwnProperty('0')) {\n\t\t\t// These commands are very messed up\n\t\t\tconsole.warn('Ignoring commands');\n\t\t\treturn null;\n\t\t}\n\n\t\t// Remove operations belonging to losing cursors\n\t\tlet filteredOperations: IIdentifiedSingleEditOperation[] = [];\n\t\tfor (let i = 0, len = rawOperations.length; i < len; i++) {\n\t\t\tif (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier!.major.toString())) {\n\t\t\t\tfilteredOperations.push(rawOperations[i]);\n\t\t\t}\n\t\t}\n\n\t\t// TODO@Alex: find a better way to do this.\n\t\t// give the hint that edit operations are tracked to the model\n\t\tif (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n\t\t\tfilteredOperations[0]._isTracked = true;\n\t\t}\n\t\tlet selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations: IIdentifiedSingleEditOperation[]): Selection[] => {\n\t\t\tlet groupedInverseEditOperations: IIdentifiedSingleEditOperation[][] = [];\n\t\t\tfor (let i = 0; i < ctx.selectionsBefore.length; i++) {\n\t\t\t\tgroupedInverseEditOperations[i] = [];\n\t\t\t}\n\t\t\tfor (const op of inverseEditOperations) {\n\t\t\t\tif (!op.identifier) {\n\t\t\t\t\t// perhaps auto whitespace trim edits\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tgroupedInverseEditOperations[op.identifier.major].push(op);\n\t\t\t}\n\t\t\tconst minorBasedSorter = (a: IIdentifiedSingleEditOperation, b: IIdentifiedSingleEditOperation) => {\n\t\t\t\treturn a.identifier!.minor - b.identifier!.minor;\n\t\t\t};\n\t\t\tlet cursorSelections: Selection[] = [];\n\t\t\tfor (let i = 0; i < ctx.selectionsBefore.length; i++) {\n\t\t\t\tif (groupedInverseEditOperations[i].length > 0) {\n\t\t\t\t\tgroupedInverseEditOperations[i].sort(minorBasedSorter);\n\t\t\t\t\tcursorSelections[i] = commands[i]!.computeCursorState(ctx.model, {\n\t\t\t\t\t\tgetInverseEditOperations: () => {\n\t\t\t\t\t\t\treturn groupedInverseEditOperations[i];\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetTrackedSelection: (id: string) => {\n\t\t\t\t\t\t\tconst idx = parseInt(id, 10);\n\t\t\t\t\t\t\tconst range = ctx.model._getTrackedRange(ctx.trackedRanges[idx])!;\n\t\t\t\t\t\t\tif (ctx.trackedRangesDirection[idx] === SelectionDirection.LTR) {\n\t\t\t\t\t\t\t\treturn new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcursorSelections[i] = ctx.selectionsBefore[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cursorSelections;\n\t\t});\n\t\tif (!selectionsAfter) {\n\t\t\tselectionsAfter = ctx.selectionsBefore;\n\t\t}\n\n\t\t// Extract losing cursors\n\t\tlet losingCursors: number[] = [];\n\t\tfor (let losingCursorIndex in loserCursorsMap) {\n\t\t\tif (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n\t\t\t\tlosingCursors.push(parseInt(losingCursorIndex, 10));\n\t\t\t}\n\t\t}\n\n\t\t// Sort losing cursors descending\n\t\tlosingCursors.sort((a: number, b: number): number => {\n\t\t\treturn b - a;\n\t\t});\n\n\t\t// Remove losing cursors\n\t\tfor (const losingCursor of losingCursors) {\n\t\t\tselectionsAfter.splice(losingCursor, 1);\n\t\t}\n\n\t\treturn selectionsAfter;\n\t}\n\n\tprivate static _arrayIsEmpty(commands: (editorCommon.ICommand | null)[]): boolean {\n\t\tfor (let i = 0, len = commands.length; i < len; i++) {\n\t\t\tif (commands[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static _getEditOperations(ctx: IExecContext, commands: (editorCommon.ICommand | null)[]): ICommandsData {\n\t\tlet operations: IIdentifiedSingleEditOperation[] = [];\n\t\tlet hadTrackedEditOperation: boolean = false;\n\n\t\tfor (let i = 0, len = commands.length; i < len; i++) {\n\t\t\tconst command = commands[i];\n\t\t\tif (command) {\n\t\t\t\tconst r = this._getEditOperationsFromCommand(ctx, i, command);\n\t\t\t\toperations = operations.concat(r.operations);\n\t\t\t\thadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\toperations: operations,\n\t\t\thadTrackedEditOperation: hadTrackedEditOperation\n\t\t};\n\t}\n\n\tprivate static _getEditOperationsFromCommand(ctx: IExecContext, majorIdentifier: number, command: editorCommon.ICommand): ICommandData {\n\t\t// This method acts as a transaction, if the command fails\n\t\t// everything it has done is ignored\n\t\tlet operations: IIdentifiedSingleEditOperation[] = [];\n\t\tlet operationMinor = 0;\n\n\t\tconst addEditOperation = (selection: Range, text: string | null) => {\n\t\t\tif (selection.isEmpty() && text === '') {\n\t\t\t\t// This command wants to add a no-op => no thank you\n\t\t\t\treturn;\n\t\t\t}\n\t\t\toperations.push({\n\t\t\t\tidentifier: {\n\t\t\t\t\tmajor: majorIdentifier,\n\t\t\t\t\tminor: operationMinor++\n\t\t\t\t},\n\t\t\t\trange: selection,\n\t\t\t\ttext: text,\n\t\t\t\tforceMoveMarkers: false,\n\t\t\t\tisAutoWhitespaceEdit: command.insertsAutoWhitespace\n\t\t\t});\n\t\t};\n\n\t\tlet hadTrackedEditOperation = false;\n\t\tconst addTrackedEditOperation = (selection: Range, text: string | null) => {\n\t\t\thadTrackedEditOperation = true;\n\t\t\taddEditOperation(selection, text);\n\t\t};\n\n\t\tconst trackSelection = (selection: Selection, trackPreviousOnEmpty?: boolean) => {\n\t\t\tlet stickiness: TrackedRangeStickiness;\n\t\t\tif (selection.isEmpty()) {\n\t\t\t\tif (typeof trackPreviousOnEmpty === 'boolean') {\n\t\t\t\t\tif (trackPreviousOnEmpty) {\n\t\t\t\t\t\tstickiness = TrackedRangeStickiness.GrowsOnlyWhenTypingBefore;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstickiness = TrackedRangeStickiness.GrowsOnlyWhenTypingAfter;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Try to lock it with surrounding text\n\t\t\t\t\tconst maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n\t\t\t\t\tif (selection.startColumn === maxLineColumn) {\n\t\t\t\t\t\tstickiness = TrackedRangeStickiness.GrowsOnlyWhenTypingBefore;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstickiness = TrackedRangeStickiness.GrowsOnlyWhenTypingAfter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstickiness = TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges;\n\t\t\t}\n\n\t\t\tconst l = ctx.trackedRanges.length;\n\t\t\tconst id = ctx.model._setTrackedRange(null, selection, stickiness);\n\t\t\tctx.trackedRanges[l] = id;\n\t\t\tctx.trackedRangesDirection[l] = selection.getDirection();\n\t\t\treturn l.toString();\n\t\t};\n\n\t\tconst editOperationBuilder: editorCommon.IEditOperationBuilder = {\n\t\t\taddEditOperation: addEditOperation,\n\t\t\taddTrackedEditOperation: addTrackedEditOperation,\n\t\t\ttrackSelection: trackSelection\n\t\t};\n\n\t\ttry {\n\t\t\tcommand.getEditOperations(ctx.model, editOperationBuilder);\n\t\t} catch (e) {\n\t\t\t// TODO@Alex use notification service if this should be user facing\n\t\t\t// e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n\t\t\tonUnexpectedError(e);\n\t\t\treturn {\n\t\t\t\toperations: [],\n\t\t\t\thadTrackedEditOperation: false\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\toperations: operations,\n\t\t\thadTrackedEditOperation: hadTrackedEditOperation\n\t\t};\n\t}\n\n\tprivate static _getLoserCursorMap(operations: IIdentifiedSingleEditOperation[]): { [index: string]: boolean; } {\n\t\t// This is destructive on the array\n\t\toperations = operations.slice(0);\n\n\t\t// Sort operations with last one first\n\t\toperations.sort((a: IIdentifiedSingleEditOperation, b: IIdentifiedSingleEditOperation): number => {\n\t\t\t// Note the minus!\n\t\t\treturn -(Range.compareRangesUsingEnds(a.range, b.range));\n\t\t});\n\n\t\t// Operations can not overlap!\n\t\tlet loserCursorsMap: { [index: string]: boolean; } = {};\n\n\t\tfor (let i = 1; i < operations.length; i++) {\n\t\t\tconst previousOp = operations[i - 1];\n\t\t\tconst currentOp = operations[i];\n\n\t\t\tif (previousOp.range.getStartPosition().isBefore(currentOp.range.getEndPosition())) {\n\n\t\t\t\tlet loserMajor: number;\n\n\t\t\t\tif (previousOp.identifier!.major > currentOp.identifier!.major) {\n\t\t\t\t\t// previousOp loses the battle\n\t\t\t\t\tloserMajor = previousOp.identifier!.major;\n\t\t\t\t} else {\n\t\t\t\t\tloserMajor = currentOp.identifier!.major;\n\t\t\t\t}\n\n\t\t\t\tloserCursorsMap[loserMajor.toString()] = true;\n\n\t\t\t\tfor (let j = 0; j < operations.length; j++) {\n\t\t\t\t\tif (operations[j].identifier!.major === loserMajor) {\n\t\t\t\t\t\toperations.splice(j, 1);\n\t\t\t\t\t\tif (j < i) {\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn loserCursorsMap;\n\t}\n}\n"]}]}