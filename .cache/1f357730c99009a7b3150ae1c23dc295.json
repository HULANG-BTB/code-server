{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostDiagnostics.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostDiagnostics.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/platform/markers/common/markers\", \"vs/base/common/uri\", \"../common/extHost.protocol\", \"./extHostTypes\", \"./extHostTypeConverters\", \"vs/base/common/arrays\", \"vs/base/common/event\", \"vs/base/common/map\"], function (require, exports, nls_1, markers_1, uri_1, extHost_protocol_1, extHostTypes_1, converter, arrays_1, event_1, map_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class DiagnosticCollection {\n        constructor(name, owner, maxDiagnosticsPerFile, proxy, onDidChangeDiagnostics) {\n            this._isDisposed = false;\n            this._data = new Map();\n            this._name = name;\n            this._owner = owner;\n            this._maxDiagnosticsPerFile = maxDiagnosticsPerFile;\n            this._proxy = proxy;\n            this._onDidChangeDiagnostics = onDidChangeDiagnostics;\n        }\n        dispose() {\n            if (!this._isDisposed) {\n                this._onDidChangeDiagnostics.fire(map_1.keys(this._data));\n                this._proxy.$clear(this._owner);\n                this._data = undefined;\n                this._isDisposed = true;\n            }\n        }\n        get name() {\n            this._checkDisposed();\n            return this._name;\n        }\n        set(first, diagnostics) {\n            if (!first) {\n                // this set-call is a clear-call\n                this.clear();\n                return;\n            }\n            // the actual implementation for #set\n            this._checkDisposed();\n            let toSync = [];\n            if (first instanceof uri_1.URI) {\n                if (!diagnostics) {\n                    // remove this entry\n                    this.delete(first);\n                    return;\n                }\n                // update single row\n                this._data.set(first.toString(), diagnostics.slice());\n                toSync = [first];\n            }\n            else if (Array.isArray(first)) {\n                // update many rows\n                toSync = [];\n                let lastUri;\n                // ensure stable-sort\n                arrays_1.mergeSort(first, DiagnosticCollection._compareIndexedTuplesByUri);\n                for (const tuple of first) {\n                    const [uri, diagnostics] = tuple;\n                    if (!lastUri || uri.toString() !== lastUri.toString()) {\n                        if (lastUri && this._data.get(lastUri.toString()).length === 0) {\n                            this._data.delete(lastUri.toString());\n                        }\n                        lastUri = uri;\n                        toSync.push(uri);\n                        this._data.set(uri.toString(), []);\n                    }\n                    if (!diagnostics) {\n                        // [Uri, undefined] means clear this\n                        const currentDiagnostics = this._data.get(uri.toString());\n                        if (currentDiagnostics) {\n                            currentDiagnostics.length = 0;\n                        }\n                    }\n                    else {\n                        const currentDiagnostics = this._data.get(uri.toString());\n                        if (currentDiagnostics) {\n                            currentDiagnostics.push(...diagnostics);\n                        }\n                    }\n                }\n            }\n            // send event for extensions\n            this._onDidChangeDiagnostics.fire(toSync);\n            // compute change and send to main side\n            const entries = [];\n            for (let uri of toSync) {\n                let marker = [];\n                const diagnostics = this._data.get(uri.toString());\n                if (diagnostics) {\n                    // no more than N diagnostics per file\n                    if (diagnostics.length > this._maxDiagnosticsPerFile) {\n                        marker = [];\n                        const order = [extHostTypes_1.DiagnosticSeverity.Error, extHostTypes_1.DiagnosticSeverity.Warning, extHostTypes_1.DiagnosticSeverity.Information, extHostTypes_1.DiagnosticSeverity.Hint];\n                        orderLoop: for (let i = 0; i < 4; i++) {\n                            for (let diagnostic of diagnostics) {\n                                if (diagnostic.severity === order[i]) {\n                                    const len = marker.push(converter.Diagnostic.from(diagnostic));\n                                    if (len === this._maxDiagnosticsPerFile) {\n                                        break orderLoop;\n                                    }\n                                }\n                            }\n                        }\n                        // add 'signal' marker for showing omitted errors/warnings\n                        marker.push({\n                            severity: markers_1.MarkerSeverity.Info,\n                            message: nls_1.localize({ key: 'limitHit', comment: ['amount of errors/warning skipped due to limits'] }, \"Not showing {0} further errors and warnings.\", diagnostics.length - this._maxDiagnosticsPerFile),\n                            startLineNumber: marker[marker.length - 1].startLineNumber,\n                            startColumn: marker[marker.length - 1].startColumn,\n                            endLineNumber: marker[marker.length - 1].endLineNumber,\n                            endColumn: marker[marker.length - 1].endColumn\n                        });\n                    }\n                    else {\n                        marker = diagnostics.map(diag => converter.Diagnostic.from(diag));\n                    }\n                }\n                entries.push([uri, marker]);\n            }\n            this._proxy.$changeMany(this._owner, entries);\n        }\n        delete(uri) {\n            this._checkDisposed();\n            this._onDidChangeDiagnostics.fire([uri]);\n            this._data.delete(uri.toString());\n            this._proxy.$changeMany(this._owner, [[uri, undefined]]);\n        }\n        clear() {\n            this._checkDisposed();\n            this._onDidChangeDiagnostics.fire(map_1.keys(this._data));\n            this._data.clear();\n            this._proxy.$clear(this._owner);\n        }\n        forEach(callback, thisArg) {\n            this._checkDisposed();\n            this._data.forEach((value, key) => {\n                const uri = uri_1.URI.parse(key);\n                callback.apply(thisArg, [uri, this.get(uri), this]);\n            });\n        }\n        get(uri) {\n            this._checkDisposed();\n            const result = this._data.get(uri.toString());\n            if (Array.isArray(result)) {\n                return Object.freeze(result.slice(0));\n            }\n            return [];\n        }\n        has(uri) {\n            this._checkDisposed();\n            return Array.isArray(this._data.get(uri.toString()));\n        }\n        _checkDisposed() {\n            if (this._isDisposed) {\n                throw new Error('illegal state - object is disposed');\n            }\n        }\n        static _compareIndexedTuplesByUri(a, b) {\n            if (a[0].toString() < b[0].toString()) {\n                return -1;\n            }\n            else if (a[0].toString() > b[0].toString()) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        }\n    }\n    exports.DiagnosticCollection = DiagnosticCollection;\n    class ExtHostDiagnostics {\n        constructor(mainContext) {\n            this._collections = new Map();\n            this._onDidChangeDiagnostics = new event_1.Emitter();\n            this.onDidChangeDiagnostics = event_1.Event.map(event_1.Event.debounce(this._onDidChangeDiagnostics.event, ExtHostDiagnostics._debouncer, 50), ExtHostDiagnostics._mapper);\n            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadDiagnostics);\n        }\n        static _debouncer(last, current) {\n            if (!last) {\n                return current;\n            }\n            else {\n                return last.concat(current);\n            }\n        }\n        static _mapper(last) {\n            const uris = [];\n            const map = new Set();\n            for (const uri of last) {\n                if (typeof uri === 'string') {\n                    if (!map.has(uri)) {\n                        map.add(uri);\n                        uris.push(uri_1.URI.parse(uri));\n                    }\n                }\n                else {\n                    if (!map.has(uri.toString())) {\n                        map.add(uri.toString());\n                        uris.push(uri);\n                    }\n                }\n            }\n            Object.freeze(uris);\n            return { uris };\n        }\n        createDiagnosticCollection(name) {\n            let { _collections, _proxy, _onDidChangeDiagnostics } = this;\n            let owner;\n            if (!name) {\n                name = '_generated_diagnostic_collection_name_#' + ExtHostDiagnostics._idPool++;\n                owner = name;\n            }\n            else if (!_collections.has(name)) {\n                owner = name;\n            }\n            else {\n                console.warn(`DiagnosticCollection with name '${name}' does already exist.`);\n                do {\n                    owner = name + ExtHostDiagnostics._idPool++;\n                } while (_collections.has(owner));\n            }\n            const result = new class extends DiagnosticCollection {\n                constructor() {\n                    super(name, owner, ExtHostDiagnostics._maxDiagnosticsPerFile, _proxy, _onDidChangeDiagnostics);\n                    _collections.set(owner, this);\n                }\n                dispose() {\n                    super.dispose();\n                    _collections.delete(owner);\n                }\n            };\n            return result;\n        }\n        getDiagnostics(resource) {\n            if (resource) {\n                return this._getDiagnostics(resource);\n            }\n            else {\n                const index = new Map();\n                const res = [];\n                this._collections.forEach(collection => {\n                    collection.forEach((uri, diagnostics) => {\n                        let idx = index.get(uri.toString());\n                        if (typeof idx === 'undefined') {\n                            idx = res.length;\n                            index.set(uri.toString(), idx);\n                            res.push([uri, []]);\n                        }\n                        res[idx][1] = res[idx][1].concat(...diagnostics);\n                    });\n                });\n                return res;\n            }\n        }\n        _getDiagnostics(resource) {\n            let res = [];\n            this._collections.forEach(collection => {\n                if (collection.has(resource)) {\n                    res = res.concat(collection.get(resource));\n                }\n            });\n            return res;\n        }\n    }\n    ExtHostDiagnostics._idPool = 0;\n    ExtHostDiagnostics._maxDiagnosticsPerFile = 1000;\n    exports.ExtHostDiagnostics = ExtHostDiagnostics;\n});\n",null]}