{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/foldingRanges.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/foldingRanges.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.MAX_FOLDING_REGIONS = 0xFFFF;\n    exports.MAX_LINE_NUMBER = 0xFFFFFF;\n    const MASK_INDENT = 0xFF000000;\n    class FoldingRegions {\n        constructor(startIndexes, endIndexes, types) {\n            if (startIndexes.length !== endIndexes.length || startIndexes.length > exports.MAX_FOLDING_REGIONS) {\n                throw new Error('invalid startIndexes or endIndexes size');\n            }\n            this._startIndexes = startIndexes;\n            this._endIndexes = endIndexes;\n            this._collapseStates = new Uint32Array(Math.ceil(startIndexes.length / 32));\n            this._types = types;\n        }\n        ensureParentIndices() {\n            if (!this._parentsComputed) {\n                this._parentsComputed = true;\n                let parentIndexes = [];\n                let isInsideLast = (startLineNumber, endLineNumber) => {\n                    let index = parentIndexes[parentIndexes.length - 1];\n                    return this.getStartLineNumber(index) <= startLineNumber && this.getEndLineNumber(index) >= endLineNumber;\n                };\n                for (let i = 0, len = this._startIndexes.length; i < len; i++) {\n                    let startLineNumber = this._startIndexes[i];\n                    let endLineNumber = this._endIndexes[i];\n                    if (startLineNumber > exports.MAX_LINE_NUMBER || endLineNumber > exports.MAX_LINE_NUMBER) {\n                        throw new Error('startLineNumber or endLineNumber must not exceed ' + exports.MAX_LINE_NUMBER);\n                    }\n                    while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {\n                        parentIndexes.pop();\n                    }\n                    let parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;\n                    parentIndexes.push(i);\n                    this._startIndexes[i] = startLineNumber + ((parentIndex & 0xFF) << 24);\n                    this._endIndexes[i] = endLineNumber + ((parentIndex & 0xFF00) << 16);\n                }\n            }\n        }\n        get length() {\n            return this._startIndexes.length;\n        }\n        getStartLineNumber(index) {\n            return this._startIndexes[index] & exports.MAX_LINE_NUMBER;\n        }\n        getEndLineNumber(index) {\n            return this._endIndexes[index] & exports.MAX_LINE_NUMBER;\n        }\n        getType(index) {\n            return this._types ? this._types[index] : undefined;\n        }\n        hasTypes() {\n            return !!this._types;\n        }\n        isCollapsed(index) {\n            let arrayIndex = (index / 32) | 0;\n            let bit = index % 32;\n            return (this._collapseStates[arrayIndex] & (1 << bit)) !== 0;\n        }\n        setCollapsed(index, newState) {\n            let arrayIndex = (index / 32) | 0;\n            let bit = index % 32;\n            let value = this._collapseStates[arrayIndex];\n            if (newState) {\n                this._collapseStates[arrayIndex] = value | (1 << bit);\n            }\n            else {\n                this._collapseStates[arrayIndex] = value & ~(1 << bit);\n            }\n        }\n        toRegion(index) {\n            return new FoldingRegion(this, index);\n        }\n        getParentIndex(index) {\n            this.ensureParentIndices();\n            let parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);\n            if (parent === exports.MAX_FOLDING_REGIONS) {\n                return -1;\n            }\n            return parent;\n        }\n        contains(index, line) {\n            return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;\n        }\n        findIndex(line) {\n            let low = 0, high = this._startIndexes.length;\n            if (high === 0) {\n                return -1; // no children\n            }\n            while (low < high) {\n                let mid = Math.floor((low + high) / 2);\n                if (line < this.getStartLineNumber(mid)) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            return low - 1;\n        }\n        findRange(line) {\n            let index = this.findIndex(line);\n            if (index >= 0) {\n                let endLineNumber = this.getEndLineNumber(index);\n                if (endLineNumber >= line) {\n                    return index;\n                }\n                index = this.getParentIndex(index);\n                while (index !== -1) {\n                    if (this.contains(index, line)) {\n                        return index;\n                    }\n                    index = this.getParentIndex(index);\n                }\n            }\n            return -1;\n        }\n        toString() {\n            let res = [];\n            for (let i = 0; i < this.length; i++) {\n                res[i] = `[${this.isCollapsed(i) ? '+' : '-'}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;\n            }\n            return res.join(', ');\n        }\n    }\n    exports.FoldingRegions = FoldingRegions;\n    class FoldingRegion {\n        constructor(ranges, index) {\n            this.ranges = ranges;\n            this.index = index;\n        }\n        get startLineNumber() {\n            return this.ranges.getStartLineNumber(this.index);\n        }\n        get endLineNumber() {\n            return this.ranges.getEndLineNumber(this.index);\n        }\n        get regionIndex() {\n            return this.index;\n        }\n        get parentIndex() {\n            return this.ranges.getParentIndex(this.index);\n        }\n        get isCollapsed() {\n            return this.ranges.isCollapsed(this.index);\n        }\n        containedBy(range) {\n            return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;\n        }\n        containsLine(lineNumber) {\n            return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;\n        }\n        hidesLine(lineNumber) {\n            return this.startLineNumber < lineNumber && lineNumber <= this.endLineNumber;\n        }\n    }\n    exports.FoldingRegion = FoldingRegion;\n});\n",null]}