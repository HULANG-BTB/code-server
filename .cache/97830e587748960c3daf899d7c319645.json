{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/electron-browser/terminalTaskSystem.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/electron-browser/terminalTaskSystem.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar path = require(\"vs/base/common/path\");\nvar nls = require(\"vs/nls\");\nvar Objects = require(\"vs/base/common/objects\");\nvar Types = require(\"vs/base/common/types\");\nvar Platform = require(\"vs/base/common/platform\");\nvar Async = require(\"vs/base/common/async\");\nvar collections_1 = require(\"vs/base/common/collections\");\nvar map_1 = require(\"vs/base/common/map\");\nvar severity_1 = require(\"vs/base/common/severity\");\nvar event_1 = require(\"vs/base/common/event\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar extpath_1 = require(\"vs/base/common/extpath\");\nvar processes_1 = require(\"vs/base/node/processes\");\nvar markers_1 = require(\"vs/platform/markers/common/markers\");\nvar workspace_1 = require(\"vs/platform/workspace/common/workspace\");\nvar problemMatcher_1 = require(\"vs/workbench/contrib/tasks/common/problemMatcher\");\nvar problemCollectors_1 = require(\"vs/workbench/contrib/tasks/common/problemCollectors\");\nvar tasks_1 = require(\"vs/workbench/contrib/tasks/common/tasks\");\nvar taskSystem_1 = require(\"vs/workbench/contrib/tasks/common/taskSystem\");\nvar remoteHosts_1 = require(\"vs/platform/remote/common/remoteHosts\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar network_1 = require(\"vs/base/common/network\");\nvar terminal_1 = require(\"vs/workbench/contrib/terminal/node/terminal\");\nvar VariableResolver = /** @class */ (function () {\n    function VariableResolver(workspaceFolder, taskSystemInfo, _values, _service) {\n        this.workspaceFolder = workspaceFolder;\n        this.taskSystemInfo = taskSystemInfo;\n        this._values = _values;\n        this._service = _service;\n    }\n    VariableResolver.prototype.resolve = function (value) {\n        var _this = this;\n        return value.replace(/\\$\\{(.*?)\\}/g, function (match, variable) {\n            // Strip out the ${} because the map contains them variables without those characters.\n            var result = _this._values.get(match.substring(2, match.length - 1));\n            if ((result !== undefined) && (result !== null)) {\n                return result;\n            }\n            if (_this._service) {\n                return _this._service.resolve(_this.workspaceFolder, match);\n            }\n            return match;\n        });\n    };\n    return VariableResolver;\n}());\nvar VerifiedTask = /** @class */ (function () {\n    function VerifiedTask(task, resolver, trigger) {\n        this.task = task;\n        this.resolver = resolver;\n        this.trigger = trigger;\n    }\n    VerifiedTask.prototype.verify = function () {\n        var verified = false;\n        if (this.trigger && this.resolvedVariables && this.workspaceFolder && (this.shellLaunchConfig !== undefined)) {\n            verified = true;\n        }\n        return verified;\n    };\n    VerifiedTask.prototype.getVerifiedTask = function () {\n        if (this.verify()) {\n            return { task: this.task, resolver: this.resolver, trigger: this.trigger, resolvedVariables: this.resolvedVariables, systemInfo: this.systemInfo, workspaceFolder: this.workspaceFolder, shellLaunchConfig: this.shellLaunchConfig };\n        }\n        else {\n            throw new Error('VerifiedTask was not checked. verify must be checked before getVerifiedTask.');\n        }\n    };\n    return VerifiedTask;\n}());\nexports.VerifiedTask = VerifiedTask;\nvar TerminalTaskSystem = /** @class */ (function () {\n    function TerminalTaskSystem(terminalService, outputService, markerService, modelService, configurationResolverService, telemetryService, contextService, windowService, outputChannelId, taskSystemInfoResolver) {\n        this.terminalService = terminalService;\n        this.outputService = outputService;\n        this.markerService = markerService;\n        this.modelService = modelService;\n        this.configurationResolverService = configurationResolverService;\n        this.telemetryService = telemetryService;\n        this.contextService = contextService;\n        this.windowService = windowService;\n        this.outputChannelId = outputChannelId;\n        this.activeTasks = Object.create(null);\n        this.terminals = Object.create(null);\n        this.idleTaskTerminals = new map_1.LinkedMap();\n        this.sameTaskTerminals = Object.create(null);\n        this._onDidStateChange = new event_1.Emitter();\n        this.taskSystemInfoResolver = taskSystemInfoResolver;\n    }\n    Object.defineProperty(TerminalTaskSystem.prototype, \"onDidStateChange\", {\n        get: function () {\n            return this._onDidStateChange.event;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TerminalTaskSystem.prototype.log = function (value) {\n        this.appendOutput(value + '\\n');\n    };\n    TerminalTaskSystem.prototype.showOutput = function () {\n        this.outputService.showChannel(this.outputChannelId, true);\n    };\n    TerminalTaskSystem.prototype.run = function (task, resolver, trigger) {\n        var _this = this;\n        if (trigger === void 0) { trigger = taskSystem_1.Triggers.command; }\n        this.currentTask = new VerifiedTask(task, resolver, trigger);\n        var terminalData = this.activeTasks[task.getMapKey()];\n        if (terminalData && terminalData.promise) {\n            var reveal = tasks_1.RevealKind.Always;\n            var focus = false;\n            if (tasks_1.CustomTask.is(task) || tasks_1.ContributedTask.is(task)) {\n                reveal = task.command.presentation.reveal;\n                focus = task.command.presentation.focus;\n            }\n            if (reveal === tasks_1.RevealKind.Always || focus) {\n                this.terminalService.setActiveInstance(terminalData.terminal);\n                this.terminalService.showPanel(focus);\n            }\n            this.lastTask = this.currentTask;\n            return { kind: taskSystem_1.TaskExecuteKind.Active, task: task, active: { same: true, background: task.configurationProperties.isBackground }, promise: terminalData.promise };\n        }\n        try {\n            var executeResult = { kind: taskSystem_1.TaskExecuteKind.Started, task: task, started: {}, promise: this.executeTask(task, resolver, trigger) };\n            executeResult.promise.then(function (summary) {\n                _this.lastTask = _this.currentTask;\n            });\n            return executeResult;\n        }\n        catch (error) {\n            if (error instanceof taskSystem_1.TaskError) {\n                throw error;\n            }\n            else if (error instanceof Error) {\n                this.log(error.message);\n                throw new taskSystem_1.TaskError(severity_1.default.Error, error.message, taskSystem_1.TaskErrors.UnknownError);\n            }\n            else {\n                this.log(error.toString());\n                throw new taskSystem_1.TaskError(severity_1.default.Error, nls.localize('TerminalTaskSystem.unknownError', 'A unknown error has occurred while executing a task. See task output log for details.'), taskSystem_1.TaskErrors.UnknownError);\n            }\n        }\n    };\n    TerminalTaskSystem.prototype.rerun = function () {\n        var _this = this;\n        if (this.lastTask && this.lastTask.verify()) {\n            if ((this.lastTask.task.runOptions.reevaluateOnRerun !== undefined) && !this.lastTask.task.runOptions.reevaluateOnRerun) {\n                this.isRerun = true;\n            }\n            var result = this.run(this.lastTask.task, this.lastTask.resolver);\n            result.promise.then(function (summary) {\n                _this.isRerun = false;\n            });\n            return result;\n        }\n        else {\n            return undefined;\n        }\n    };\n    TerminalTaskSystem.prototype.revealTask = function (task) {\n        var terminalData = this.activeTasks[task.getMapKey()];\n        if (!terminalData) {\n            return false;\n        }\n        this.terminalService.setActiveInstance(terminalData.terminal);\n        if (tasks_1.CustomTask.is(task) || tasks_1.ContributedTask.is(task)) {\n            this.terminalService.showPanel(task.command.presentation.focus);\n        }\n        return true;\n    };\n    TerminalTaskSystem.prototype.isActive = function () {\n        return Promise.resolve(this.isActiveSync());\n    };\n    TerminalTaskSystem.prototype.isActiveSync = function () {\n        return Object.keys(this.activeTasks).length > 0;\n    };\n    TerminalTaskSystem.prototype.canAutoTerminate = function () {\n        var _this = this;\n        return Object.keys(this.activeTasks).every(function (key) { return !_this.activeTasks[key].task.configurationProperties.promptOnClose; });\n    };\n    TerminalTaskSystem.prototype.getActiveTasks = function () {\n        var _this = this;\n        return Object.keys(this.activeTasks).map(function (key) { return _this.activeTasks[key].task; });\n    };\n    TerminalTaskSystem.prototype.customExecutionComplete = function (task, result) {\n        var activeTerminal = this.activeTasks[task.getMapKey()];\n        if (!activeTerminal) {\n            return Promise.reject(new Error('Expected to have a terminal for an custom execution task'));\n        }\n        return new Promise(function (resolve) {\n            activeTerminal.terminal.rendererExit(result);\n            resolve();\n        });\n    };\n    TerminalTaskSystem.prototype.terminate = function (task) {\n        var _this = this;\n        var activeTerminal = this.activeTasks[task.getMapKey()];\n        if (!activeTerminal) {\n            return Promise.resolve({ success: false, task: undefined });\n        }\n        return new Promise(function (resolve, reject) {\n            var terminal = activeTerminal.terminal;\n            var onExit = terminal.onExit(function () {\n                var task = activeTerminal.task;\n                try {\n                    onExit.dispose();\n                    _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Terminated, task));\n                }\n                catch (error) {\n                    // Do nothing.\n                }\n                resolve({ success: true, task: task });\n            });\n            terminal.dispose();\n        });\n    };\n    TerminalTaskSystem.prototype.terminateAll = function () {\n        var _this = this;\n        var promises = [];\n        Object.keys(this.activeTasks).forEach(function (key) {\n            var terminalData = _this.activeTasks[key];\n            var terminal = terminalData.terminal;\n            promises.push(new Promise(function (resolve, reject) {\n                var onExit = terminal.onExit(function () {\n                    var task = terminalData.task;\n                    try {\n                        onExit.dispose();\n                        _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Terminated, task));\n                    }\n                    catch (error) {\n                        // Do nothing.\n                    }\n                    resolve({ success: true, task: terminalData.task });\n                });\n            }));\n            terminal.dispose();\n        });\n        this.activeTasks = Object.create(null);\n        return Promise.all(promises);\n    };\n    TerminalTaskSystem.prototype.executeTask = function (task, resolver, trigger) {\n        var _this = this;\n        var promises = [];\n        if (task.configurationProperties.dependsOn) {\n            task.configurationProperties.dependsOn.forEach(function (dependency) {\n                var dependencyTask = resolver.resolve(dependency.workspaceFolder, dependency.task);\n                if (dependencyTask) {\n                    var key = dependencyTask.getMapKey();\n                    var promise = _this.activeTasks[key] ? _this.activeTasks[key].promise : undefined;\n                    if (!promise) {\n                        _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.DependsOnStarted, task));\n                        promise = _this.executeTask(dependencyTask, resolver, trigger);\n                    }\n                    promises.push(promise);\n                }\n                else {\n                    _this.log(nls.localize('dependencyFailed', 'Couldn\\'t resolve dependent task \\'{0}\\' in workspace folder \\'{1}\\'', Types.isString(dependency.task) ? dependency.task : JSON.stringify(dependency.task, undefined, 0), dependency.workspaceFolder.name));\n                    _this.showOutput();\n                }\n            });\n        }\n        if ((tasks_1.ContributedTask.is(task) || tasks_1.CustomTask.is(task)) && (task.command)) {\n            return Promise.all(promises).then(function (summaries) {\n                for (var _i = 0, summaries_1 = summaries; _i < summaries_1.length; _i++) {\n                    var summary = summaries_1[_i];\n                    if (summary.exitCode !== 0) {\n                        return { exitCode: summary.exitCode };\n                    }\n                }\n                if (_this.isRerun) {\n                    return _this.reexecuteCommand(task, trigger);\n                }\n                else {\n                    return _this.executeCommand(task, trigger);\n                }\n            });\n        }\n        else {\n            return Promise.all(promises).then(function (summaries) {\n                for (var _i = 0, summaries_2 = summaries; _i < summaries_2.length; _i++) {\n                    var summary = summaries_2[_i];\n                    if (summary.exitCode !== 0) {\n                        return { exitCode: summary.exitCode };\n                    }\n                }\n                return { exitCode: 0 };\n            });\n        }\n    };\n    TerminalTaskSystem.prototype.resolveVariablesFromSet = function (taskSystemInfo, workspaceFolder, task, variables) {\n        var _this = this;\n        var isProcess = task.command && task.command.runtime === tasks_1.RuntimeType.Process;\n        var options = task.command && task.command.options ? task.command.options : undefined;\n        var cwd = options ? options.cwd : undefined;\n        var envPath = undefined;\n        if (options && options.env) {\n            for (var _i = 0, _a = Object.keys(options.env); _i < _a.length; _i++) {\n                var key = _a[_i];\n                if (key.toLowerCase() === 'path') {\n                    if (Types.isString(options.env[key])) {\n                        envPath = options.env[key];\n                    }\n                    break;\n                }\n            }\n        }\n        var resolvedVariables;\n        if (taskSystemInfo) {\n            var resolveSet = {\n                variables: variables\n            };\n            if (taskSystemInfo.platform === Platform.Platform.Windows && isProcess) {\n                resolveSet.process = { name: tasks_1.CommandString.value(task.command.name) };\n                if (cwd) {\n                    resolveSet.process.cwd = cwd;\n                }\n                if (envPath) {\n                    resolveSet.process.path = envPath;\n                }\n            }\n            resolvedVariables = taskSystemInfo.resolveVariables(workspaceFolder, resolveSet).then(function (resolved) {\n                if ((taskSystemInfo.platform !== Platform.Platform.Windows) && isProcess) {\n                    resolved.variables.set(TerminalTaskSystem.ProcessVarName, tasks_1.CommandString.value(task.command.name));\n                }\n                return Promise.resolve(resolved);\n            });\n            return resolvedVariables;\n        }\n        else {\n            var variablesArray_1 = new Array();\n            variables.forEach(function (variable) { return variablesArray_1.push(variable); });\n            return new Promise(function (resolve, reject) {\n                _this.configurationResolverService.resolveWithInteraction(workspaceFolder, variablesArray_1, 'tasks').then(function (resolvedVariablesMap) {\n                    if (resolvedVariablesMap) {\n                        if (isProcess) {\n                            var processVarValue = void 0;\n                            if (Platform.isWindows) {\n                                processVarValue = processes_1.win32.findExecutable(_this.configurationResolverService.resolve(workspaceFolder, tasks_1.CommandString.value(task.command.name)), cwd ? _this.configurationResolverService.resolve(workspaceFolder, cwd) : undefined, envPath ? envPath.split(path.delimiter).map(function (p) { return _this.configurationResolverService.resolve(workspaceFolder, p); }) : undefined);\n                            }\n                            else {\n                                processVarValue = _this.configurationResolverService.resolve(workspaceFolder, tasks_1.CommandString.value(task.command.name));\n                            }\n                            resolvedVariablesMap.set(TerminalTaskSystem.ProcessVarName, processVarValue);\n                        }\n                        var resolvedVariablesResult = {\n                            variables: resolvedVariablesMap,\n                        };\n                        resolve(resolvedVariablesResult);\n                    }\n                    else {\n                        resolve(undefined);\n                    }\n                }, function (reason) {\n                    reject(reason);\n                });\n            });\n        }\n    };\n    TerminalTaskSystem.prototype.executeCommand = function (task, trigger) {\n        var _this = this;\n        this.currentTask.workspaceFolder = task.getWorkspaceFolder();\n        if (this.currentTask.workspaceFolder) {\n            this.currentTask.systemInfo = this.taskSystemInfoResolver(this.currentTask.workspaceFolder);\n        }\n        var variables = new Set();\n        this.collectTaskVariables(variables, task);\n        var resolvedVariables = this.resolveVariablesFromSet(this.currentTask.systemInfo, this.currentTask.workspaceFolder, task, variables);\n        return resolvedVariables.then(function (resolvedVariables) {\n            if (resolvedVariables && task.command && task.command.runtime) {\n                _this.currentTask.resolvedVariables = resolvedVariables;\n                return _this.executeInTerminal(task, trigger, new VariableResolver(_this.currentTask.workspaceFolder, _this.currentTask.systemInfo, resolvedVariables.variables, _this.configurationResolverService));\n            }\n            else {\n                return Promise.resolve({ exitCode: 0 });\n            }\n        }, function (reason) {\n            return Promise.reject(reason);\n        });\n    };\n    TerminalTaskSystem.prototype.reexecuteCommand = function (task, trigger) {\n        var _this = this;\n        this.currentTask.workspaceFolder = this.lastTask.workspaceFolder;\n        var variables = new Set();\n        this.collectTaskVariables(variables, task);\n        // Check that the task hasn't changed to include new variables\n        var hasAllVariables = true;\n        variables.forEach(function (value) {\n            if (value.substring(2, value.length - 1) in _this.lastTask.getVerifiedTask().resolvedVariables) {\n                hasAllVariables = false;\n            }\n        });\n        if (!hasAllVariables) {\n            return this.resolveVariablesFromSet(this.lastTask.getVerifiedTask().systemInfo, this.lastTask.getVerifiedTask().workspaceFolder, task, variables).then(function (resolvedVariables) {\n                _this.currentTask.resolvedVariables = resolvedVariables;\n                return _this.executeInTerminal(task, trigger, new VariableResolver(_this.lastTask.getVerifiedTask().workspaceFolder, _this.lastTask.getVerifiedTask().systemInfo, resolvedVariables.variables, _this.configurationResolverService));\n            }, function (reason) {\n                return Promise.reject(reason);\n            });\n        }\n        else {\n            this.currentTask.resolvedVariables = this.lastTask.getVerifiedTask().resolvedVariables;\n            return this.executeInTerminal(task, trigger, new VariableResolver(this.lastTask.getVerifiedTask().workspaceFolder, this.lastTask.getVerifiedTask().systemInfo, this.lastTask.getVerifiedTask().resolvedVariables.variables, this.configurationResolverService));\n        }\n    };\n    TerminalTaskSystem.prototype.executeInTerminal = function (task, trigger, resolver) {\n        var _this = this;\n        var terminal = undefined;\n        var executedCommand = undefined;\n        var error = undefined;\n        var promise = undefined;\n        if (task.configurationProperties.isBackground) {\n            promise = new Promise(function (resolve, reject) {\n                var _a;\n                var problemMatchers = _this.resolveMatchers(resolver, task.configurationProperties.problemMatchers);\n                var watchingProblemMatcher = new problemCollectors_1.WatchingProblemCollector(problemMatchers, _this.markerService, _this.modelService);\n                var toDispose = [];\n                var eventCounter = 0;\n                toDispose.push(watchingProblemMatcher.onDidStateChange(function (event) {\n                    if (event.kind === problemCollectors_1.ProblemCollectorEventKind.BackgroundProcessingBegins) {\n                        eventCounter++;\n                        _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Active, task));\n                    }\n                    else if (event.kind === problemCollectors_1.ProblemCollectorEventKind.BackgroundProcessingEnds) {\n                        eventCounter--;\n                        _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Inactive, task));\n                        if (eventCounter === 0) {\n                            var reveal = task.command.presentation.reveal;\n                            if ((reveal === tasks_1.RevealKind.Silent) && (watchingProblemMatcher.numberOfMatches > 0) && watchingProblemMatcher.maxMarkerSeverity &&\n                                (watchingProblemMatcher.maxMarkerSeverity >= markers_1.MarkerSeverity.Error)) {\n                                _this.terminalService.setActiveInstance(terminal);\n                                _this.terminalService.showPanel(false);\n                            }\n                        }\n                    }\n                }));\n                watchingProblemMatcher.aboutToStart();\n                var delayer = undefined;\n                _a = _this.createTerminal(task, resolver), terminal = _a[0], executedCommand = _a[1], error = _a[2];\n                if (error || !terminal) {\n                    return;\n                }\n                var processStartedSignaled = false;\n                terminal.processReady.then(function () {\n                    if (!processStartedSignaled) {\n                        if (task.command.runtime !== tasks_1.RuntimeType.CustomExecution) {\n                            _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.ProcessStarted, task, terminal.processId));\n                        }\n                        processStartedSignaled = true;\n                    }\n                }, function (_error) {\n                    // The process never got ready. Need to think how to handle this.\n                });\n                _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Start, task, terminal.id));\n                var registeredLinkMatchers = _this.registerLinkMatchers(terminal, problemMatchers);\n                var onData = terminal.onLineData(function (line) {\n                    watchingProblemMatcher.processLine(line);\n                    if (!delayer) {\n                        delayer = new Async.Delayer(3000);\n                    }\n                    delayer.trigger(function () {\n                        watchingProblemMatcher.forceDelivery();\n                        delayer = undefined;\n                    });\n                });\n                var onExit = terminal.onExit(function (exitCode) {\n                    onData.dispose();\n                    onExit.dispose();\n                    var key = task.getMapKey();\n                    delete _this.activeTasks[key];\n                    _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Changed));\n                    if (exitCode !== undefined) {\n                        // Only keep a reference to the terminal if it is not being disposed.\n                        switch (task.command.presentation.panel) {\n                            case tasks_1.PanelKind.Dedicated:\n                                _this.sameTaskTerminals[key] = terminal.id.toString();\n                                break;\n                            case tasks_1.PanelKind.Shared:\n                                _this.idleTaskTerminals.set(key, terminal.id.toString(), map_1.Touch.AsOld);\n                                break;\n                        }\n                    }\n                    var reveal = task.command.presentation.reveal;\n                    if ((reveal === tasks_1.RevealKind.Silent) && ((exitCode !== 0) || (watchingProblemMatcher.numberOfMatches > 0) && watchingProblemMatcher.maxMarkerSeverity &&\n                        (watchingProblemMatcher.maxMarkerSeverity >= markers_1.MarkerSeverity.Error))) {\n                        _this.terminalService.setActiveInstance(terminal);\n                        _this.terminalService.showPanel(false);\n                    }\n                    watchingProblemMatcher.done();\n                    watchingProblemMatcher.dispose();\n                    registeredLinkMatchers.forEach(function (handle) { return terminal.deregisterLinkMatcher(handle); });\n                    if (!processStartedSignaled) {\n                        _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.ProcessStarted, task, terminal.processId));\n                        processStartedSignaled = true;\n                    }\n                    if (task.command.runtime !== tasks_1.RuntimeType.CustomExecution) {\n                        _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.ProcessEnded, task, exitCode));\n                    }\n                    for (var i = 0; i < eventCounter; i++) {\n                        var event = tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Inactive, task);\n                        _this._onDidStateChange.fire(event);\n                    }\n                    eventCounter = 0;\n                    _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.End, task));\n                    toDispose = lifecycle_1.dispose(toDispose);\n                    toDispose = undefined;\n                    resolve({ exitCode: exitCode });\n                });\n            });\n        }\n        else {\n            promise = new Promise(function (resolve, reject) {\n                var _a;\n                _a = _this.createTerminal(task, resolver), terminal = _a[0], executedCommand = _a[1], error = _a[2];\n                if (!terminal || error) {\n                    return;\n                }\n                var processStartedSignaled = false;\n                terminal.processReady.then(function () {\n                    if (!processStartedSignaled) {\n                        if (task.command.runtime !== tasks_1.RuntimeType.CustomExecution) {\n                            _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.ProcessStarted, task, terminal.processId));\n                        }\n                        processStartedSignaled = true;\n                    }\n                }, function (_error) {\n                    // The process never got ready. Need to think how to handle this.\n                });\n                _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Start, task, terminal.id));\n                _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Active, task));\n                var problemMatchers = _this.resolveMatchers(resolver, task.configurationProperties.problemMatchers);\n                var startStopProblemMatcher = new problemCollectors_1.StartStopProblemCollector(problemMatchers, _this.markerService, _this.modelService);\n                var registeredLinkMatchers = _this.registerLinkMatchers(terminal, problemMatchers);\n                var onData = terminal.onLineData(function (line) {\n                    startStopProblemMatcher.processLine(line);\n                });\n                var onExit = terminal.onExit(function (exitCode) {\n                    onData.dispose();\n                    onExit.dispose();\n                    var key = task.getMapKey();\n                    delete _this.activeTasks[key];\n                    _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Changed));\n                    if (exitCode !== undefined) {\n                        // Only keep a reference to the terminal if it is not being disposed.\n                        switch (task.command.presentation.panel) {\n                            case tasks_1.PanelKind.Dedicated:\n                                _this.sameTaskTerminals[key] = terminal.id.toString();\n                                break;\n                            case tasks_1.PanelKind.Shared:\n                                _this.idleTaskTerminals.set(key, terminal.id.toString(), map_1.Touch.AsOld);\n                                break;\n                        }\n                    }\n                    var reveal = task.command.presentation.reveal;\n                    if (terminal && (reveal === tasks_1.RevealKind.Silent) && ((exitCode !== 0) || (startStopProblemMatcher.numberOfMatches > 0) && startStopProblemMatcher.maxMarkerSeverity &&\n                        (startStopProblemMatcher.maxMarkerSeverity >= markers_1.MarkerSeverity.Error))) {\n                        _this.terminalService.setActiveInstance(terminal);\n                        _this.terminalService.showPanel(false);\n                    }\n                    startStopProblemMatcher.done();\n                    startStopProblemMatcher.dispose();\n                    registeredLinkMatchers.forEach(function (handle) {\n                        if (terminal) {\n                            terminal.deregisterLinkMatcher(handle);\n                        }\n                    });\n                    if (!processStartedSignaled && terminal) {\n                        _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.ProcessStarted, task, terminal.processId));\n                        processStartedSignaled = true;\n                    }\n                    if (task.command.runtime !== tasks_1.RuntimeType.CustomExecution) {\n                        _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.ProcessEnded, task, exitCode));\n                    }\n                    _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Inactive, task));\n                    _this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.End, task));\n                    resolve({ exitCode: exitCode });\n                });\n            });\n        }\n        if (error) {\n            return Promise.reject(new Error(error.message));\n        }\n        if (!terminal) {\n            return Promise.reject(new Error(\"Failed to create terminal for task \" + task._label));\n        }\n        if (task.command.presentation && (task.command.presentation.reveal === tasks_1.RevealKind.Always)) {\n            this.terminalService.setActiveInstance(terminal);\n            this.terminalService.showPanel(task.command.presentation.focus);\n        }\n        this.activeTasks[task.getMapKey()] = { terminal: terminal, task: task, promise: promise };\n        this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Changed));\n        return promise.then(function (summary) {\n            try {\n                var telemetryEvent = {\n                    trigger: trigger,\n                    runner: 'terminal',\n                    taskKind: task.getTelemetryKind(),\n                    command: _this.getSanitizedCommand(executedCommand),\n                    success: true,\n                    exitCode: summary.exitCode\n                };\n                /* __GDPR__\n                    \"taskService\" : {\n                        \"${include}\": [\n                            \"${TelemetryEvent}\"\n                        ]\n                    }\n                */\n                _this.telemetryService.publicLog(TerminalTaskSystem.TelemetryEventName, telemetryEvent);\n            }\n            catch (error) {\n            }\n            return summary;\n        }, function (error) {\n            try {\n                var telemetryEvent = {\n                    trigger: trigger,\n                    runner: 'terminal',\n                    taskKind: task.getTelemetryKind(),\n                    command: _this.getSanitizedCommand(executedCommand),\n                    success: false\n                };\n                /* __GDPR__\n                    \"taskService\" : {\n                        \"${include}\": [\n                            \"${TelemetryEvent}\"\n                        ]\n                    }\n                */\n                _this.telemetryService.publicLog(TerminalTaskSystem.TelemetryEventName, telemetryEvent);\n            }\n            catch (error) {\n            }\n            return Promise.reject(error);\n        });\n    };\n    TerminalTaskSystem.prototype.createTerminalName = function (task) {\n        var needsFolderQualification = this.currentTask.workspaceFolder && this.contextService.getWorkbenchState() === workspace_1.WorkbenchState.WORKSPACE;\n        return nls.localize('TerminalTaskSystem.terminalName', 'Task - {0}', needsFolderQualification ? task.getQualifiedLabel() : task.configurationProperties.name);\n    };\n    TerminalTaskSystem.prototype.createShellLaunchConfig = function (task, variableResolver, platform, options, command, args, waitOnExit) {\n        var shellLaunchConfig;\n        var isShellCommand = task.command.runtime === tasks_1.RuntimeType.Shell;\n        var needsFolderQualification = this.currentTask.workspaceFolder && this.contextService.getWorkbenchState() === workspace_1.WorkbenchState.WORKSPACE;\n        var terminalName = this.createTerminalName(task);\n        var originalCommand = task.command.name;\n        if (isShellCommand) {\n            shellLaunchConfig = { name: terminalName, executable: undefined, args: undefined, waitOnExit: waitOnExit };\n            this.terminalService.configHelper.mergeDefaultShellPathAndArgs(shellLaunchConfig, platform);\n            var shellSpecified = false;\n            var shellOptions = task.command.options && task.command.options.shell;\n            if (shellOptions) {\n                if (shellOptions.executable) {\n                    shellLaunchConfig.executable = this.resolveVariable(variableResolver, shellOptions.executable);\n                    shellSpecified = true;\n                }\n                if (shellOptions.args) {\n                    shellLaunchConfig.args = this.resolveVariables(variableResolver, shellOptions.args.slice());\n                }\n                else {\n                    shellLaunchConfig.args = [];\n                }\n            }\n            var shellArgs_1 = shellLaunchConfig.args.slice(0);\n            var toAdd = [];\n            var commandLine = this.buildShellCommandLine(platform, shellLaunchConfig.executable, shellOptions, command, originalCommand, args);\n            var windowsShellArgs = false;\n            if (platform === Platform.Platform.Windows) {\n                // Change Sysnative to System32 if the OS is Windows but NOT WoW64. It's\n                // safe to assume that this was used by accident as Sysnative does not\n                // exist and will break the terminal in non-WoW64 environments.\n                if (!process.env.hasOwnProperty('PROCESSOR_ARCHITEW6432')) {\n                    var sysnativePath = path.join(process.env.windir, 'Sysnative').toLowerCase();\n                    if (shellLaunchConfig.executable.toLowerCase().indexOf(sysnativePath) === 0) {\n                        shellLaunchConfig.executable = path.join(process.env.windir, 'System32', shellLaunchConfig.executable.substr(sysnativePath.length));\n                    }\n                }\n                windowsShellArgs = true;\n                var basename = path.basename(shellLaunchConfig.executable).toLowerCase();\n                if (basename === 'cmd.exe' && ((options.cwd && extpath_1.isUNC(options.cwd)) || (!options.cwd && extpath_1.isUNC(process.cwd())))) {\n                    return undefined;\n                }\n                if ((basename === 'powershell.exe') || (basename === 'pwsh.exe')) {\n                    if (!shellSpecified) {\n                        toAdd.push('-Command');\n                    }\n                }\n                else if ((basename === 'bash.exe') || (basename === 'zsh.exe')) {\n                    windowsShellArgs = false;\n                    if (!shellSpecified) {\n                        toAdd.push('-c');\n                    }\n                }\n                else if (basename === 'wsl.exe') {\n                    if (!shellSpecified && (terminal_1.getWindowsBuildNumber() >= 17763)) { // See https://github.com/Microsoft/vscode/issues/67855\n                        toAdd.push('-e');\n                    }\n                }\n                else {\n                    if (!shellSpecified) {\n                        toAdd.push('/d', '/c');\n                    }\n                }\n            }\n            else {\n                if (!shellSpecified) {\n                    // Under Mac remove -l to not start it as a login shell.\n                    if (platform === Platform.Platform.Mac) {\n                        var index = shellArgs_1.indexOf('-l');\n                        if (index !== -1) {\n                            shellArgs_1.splice(index, 1);\n                        }\n                    }\n                    toAdd.push('-c');\n                }\n            }\n            toAdd.forEach(function (element) {\n                if (!shellArgs_1.some(function (arg) { return arg.toLowerCase() === element; })) {\n                    shellArgs_1.push(element);\n                }\n            });\n            shellArgs_1.push(commandLine);\n            shellLaunchConfig.args = windowsShellArgs ? shellArgs_1.join(' ') : shellArgs_1;\n            if (task.command.presentation && task.command.presentation.echo) {\n                if (needsFolderQualification) {\n                    shellLaunchConfig.initialText = \"\\u001B[1m> Executing task in folder \" + this.currentTask.workspaceFolder.name + \": \" + commandLine + \" <\\u001B[0m\\n\";\n                }\n                else {\n                    shellLaunchConfig.initialText = \"\\u001B[1m> Executing task: \" + commandLine + \" <\\u001B[0m\\n\";\n                }\n            }\n        }\n        else {\n            var commandExecutable = task.command.runtime !== tasks_1.RuntimeType.CustomExecution ? tasks_1.CommandString.value(command) : undefined;\n            var executable = !isShellCommand\n                ? this.resolveVariable(variableResolver, '${' + TerminalTaskSystem.ProcessVarName + '}')\n                : commandExecutable;\n            // When we have a process task there is no need to quote arguments. So we go ahead and take the string value.\n            shellLaunchConfig = {\n                name: terminalName,\n                executable: executable,\n                args: args.map(function (a) { return Types.isString(a) ? a : a.value; }),\n                waitOnExit: waitOnExit\n            };\n            if (task.command.presentation && task.command.presentation.echo) {\n                var getArgsToEcho = function (args) {\n                    if (!args || args.length === 0) {\n                        return '';\n                    }\n                    if (Types.isString(args)) {\n                        return args;\n                    }\n                    return args.join(' ');\n                };\n                if (needsFolderQualification) {\n                    shellLaunchConfig.initialText = \"\\u001B[1m> Executing task in folder \" + this.currentTask.workspaceFolder.name + \": \" + shellLaunchConfig.executable + \" \" + getArgsToEcho(shellLaunchConfig.args) + \" <\\u001B[0m\\n\";\n                }\n                else {\n                    shellLaunchConfig.initialText = \"\\u001B[1m> Executing task: \" + shellLaunchConfig.executable + \" \" + getArgsToEcho(shellLaunchConfig.args) + \" <\\u001B[0m\\n\";\n                }\n            }\n        }\n        if (options.cwd) {\n            var cwd = options.cwd;\n            if (!path.isAbsolute(cwd)) {\n                var workspaceFolder = task.getWorkspaceFolder();\n                if (workspaceFolder && (workspaceFolder.uri.scheme === 'file')) {\n                    cwd = path.join(workspaceFolder.uri.fsPath, cwd);\n                }\n            }\n            // This must be normalized to the OS\n            var authority = this.windowService.getConfiguration().remoteAuthority;\n            shellLaunchConfig.cwd = uri_1.URI.from({ scheme: authority ? remoteHosts_1.REMOTE_HOST_SCHEME : network_1.Schemas.file, authority: authority, path: cwd });\n        }\n        if (options.env) {\n            shellLaunchConfig.env = options.env;\n        }\n        return shellLaunchConfig;\n    };\n    TerminalTaskSystem.prototype.createTerminal = function (task, resolver) {\n        var _this = this;\n        var platform = resolver.taskSystemInfo ? resolver.taskSystemInfo.platform : Platform.platform;\n        var options = this.resolveOptions(resolver, task.command.options);\n        var waitOnExit = false;\n        var presentationOptions = task.command.presentation;\n        if (!presentationOptions) {\n            throw new Error('Task presentation options should not be undefined here.');\n        }\n        if (presentationOptions.reveal !== tasks_1.RevealKind.Never || !task.configurationProperties.isBackground) {\n            if (presentationOptions.panel === tasks_1.PanelKind.New) {\n                waitOnExit = nls.localize('closeTerminal', 'Press any key to close the terminal.');\n            }\n            else if (presentationOptions.showReuseMessage) {\n                waitOnExit = nls.localize('reuseTerminal', 'Terminal will be reused by tasks, press any key to close it.');\n            }\n            else {\n                waitOnExit = true;\n            }\n        }\n        var commandExecutable;\n        var command;\n        var args;\n        if (task.command.runtime === tasks_1.RuntimeType.CustomExecution) {\n            this.currentTask.shellLaunchConfig = {\n                isRendererOnly: true,\n                waitOnExit: waitOnExit,\n                name: this.createTerminalName(task),\n                initialText: task.command.presentation && task.command.presentation.echo ? \"\\u001B[1m> Executing task: \" + task._label + \" <\\u001B[0m\\n\" : undefined\n            };\n        }\n        else {\n            var resolvedResult = this.resolveCommandAndArgs(resolver, task.command);\n            command = resolvedResult.command;\n            args = resolvedResult.args;\n            commandExecutable = tasks_1.CommandString.value(command);\n            this.currentTask.shellLaunchConfig = this.isRerun ? this.lastTask.getVerifiedTask().shellLaunchConfig : this.createShellLaunchConfig(task, resolver, platform, options, command, args, waitOnExit);\n            if (this.currentTask.shellLaunchConfig === undefined) {\n                return [undefined, undefined, new taskSystem_1.TaskError(severity_1.default.Error, nls.localize('TerminalTaskSystem', 'Can\\'t execute a shell command on an UNC drive using cmd.exe.'), taskSystem_1.TaskErrors.UnknownError)];\n            }\n        }\n        var prefersSameTerminal = presentationOptions.panel === tasks_1.PanelKind.Dedicated;\n        var allowsSharedTerminal = presentationOptions.panel === tasks_1.PanelKind.Shared;\n        var group = presentationOptions.group;\n        var taskKey = task.getMapKey();\n        var terminalToReuse;\n        if (prefersSameTerminal) {\n            var terminalId = this.sameTaskTerminals[taskKey];\n            if (terminalId) {\n                terminalToReuse = this.terminals[terminalId];\n                delete this.sameTaskTerminals[taskKey];\n            }\n        }\n        else if (allowsSharedTerminal) {\n            // Always allow to reuse the terminal previously used by the same task.\n            var terminalId = this.idleTaskTerminals.remove(taskKey);\n            if (!terminalId) {\n                // There is no idle terminal which was used by the same task.\n                // Search for any idle terminal used previously by a task of the same group\n                // (or, if the task has no group, a terminal used by a task without group).\n                for (var _i = 0, _a = this.idleTaskTerminals.keys(); _i < _a.length; _i++) {\n                    var taskId = _a[_i];\n                    var idleTerminalId = this.idleTaskTerminals.get(taskId);\n                    if (idleTerminalId && this.terminals[idleTerminalId] && this.terminals[idleTerminalId].group === group) {\n                        terminalId = this.idleTaskTerminals.remove(taskId);\n                        break;\n                    }\n                }\n            }\n            if (terminalId) {\n                terminalToReuse = this.terminals[terminalId];\n            }\n        }\n        if (terminalToReuse) {\n            if (!this.currentTask.shellLaunchConfig) {\n                throw new Error('Task shell launch configuration should not be undefined here.');\n            }\n            terminalToReuse.terminal.reuseTerminal(this.currentTask.shellLaunchConfig);\n            if (task.command.presentation && task.command.presentation.clear) {\n                terminalToReuse.terminal.clear();\n            }\n            this.terminals[terminalToReuse.terminal.id.toString()].lastTask = taskKey;\n            return [terminalToReuse.terminal, commandExecutable, undefined];\n        }\n        var result = null;\n        if (group) {\n            // Try to find an existing terminal to split.\n            // Even if an existing terminal is found, the split can fail if the terminal width is too small.\n            for (var _b = 0, _c = collections_1.values(this.terminals); _b < _c.length; _b++) {\n                var terminal = _c[_b];\n                if (terminal.group === group) {\n                    var originalInstance = terminal.terminal;\n                    var config = this.currentTask.shellLaunchConfig;\n                    result = this.terminalService.splitInstance(originalInstance, config);\n                    if (result) {\n                        break;\n                    }\n                }\n            }\n        }\n        if (!result) {\n            // Either no group is used, no terminal with the group exists or splitting an existing terminal failed.\n            result = this.terminalService.createTerminal(this.currentTask.shellLaunchConfig);\n        }\n        var terminalKey = result.id.toString();\n        result.onDisposed(function (terminal) {\n            var terminalData = _this.terminals[terminalKey];\n            if (terminalData) {\n                delete _this.terminals[terminalKey];\n                delete _this.sameTaskTerminals[terminalData.lastTask];\n                _this.idleTaskTerminals.delete(terminalData.lastTask);\n                // Delete the task now as a work around for cases when the onExit isn't fired.\n                // This can happen if the terminal wasn't shutdown with an \"immediate\" flag and is expected.\n                // For correct terminal re-use, the task needs to be deleted immediately.\n                // Note that this shouldn't be a problem anymore since user initiated terminal kills are now immediate.\n                delete _this.activeTasks[task.getMapKey()];\n            }\n        });\n        this.terminals[terminalKey] = { terminal: result, lastTask: taskKey, group: group };\n        return [result, commandExecutable, undefined];\n    };\n    TerminalTaskSystem.prototype.buildShellCommandLine = function (platform, shellExecutable, shellOptions, command, originalCommand, args) {\n        var _a, _b;\n        var basename = path.parse(shellExecutable).name.toLowerCase();\n        var shellQuoteOptions = this.getQuotingOptions(basename, shellOptions);\n        function needsQuotes(value) {\n            if (value.length >= 2) {\n                var first = value[0] === shellQuoteOptions.strong ? shellQuoteOptions.strong : value[0] === shellQuoteOptions.weak ? shellQuoteOptions.weak : undefined;\n                if (first === value[value.length - 1]) {\n                    return false;\n                }\n            }\n            var quote;\n            for (var i = 0; i < value.length; i++) {\n                // We found the end quote.\n                var ch = value[i];\n                if (ch === quote) {\n                    quote = undefined;\n                }\n                else if (quote !== undefined) {\n                    // skip the character. We are quoted.\n                    continue;\n                }\n                else if (ch === shellQuoteOptions.escape) {\n                    // Skip the next character\n                    i++;\n                }\n                else if (ch === shellQuoteOptions.strong || ch === shellQuoteOptions.weak) {\n                    quote = ch;\n                }\n                else if (ch === ' ') {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function quote(value, kind) {\n            if (kind === tasks_1.ShellQuoting.Strong && shellQuoteOptions.strong) {\n                return [shellQuoteOptions.strong + value + shellQuoteOptions.strong, true];\n            }\n            else if (kind === tasks_1.ShellQuoting.Weak && shellQuoteOptions.weak) {\n                return [shellQuoteOptions.weak + value + shellQuoteOptions.weak, true];\n            }\n            else if (kind === tasks_1.ShellQuoting.Escape && shellQuoteOptions.escape) {\n                if (Types.isString(shellQuoteOptions.escape)) {\n                    return [value.replace(/ /g, shellQuoteOptions.escape + ' '), true];\n                }\n                else {\n                    var buffer = [];\n                    for (var _i = 0, _a = shellQuoteOptions.escape.charsToEscape; _i < _a.length; _i++) {\n                        var ch = _a[_i];\n                        buffer.push(\"\\\\\" + ch);\n                    }\n                    var regexp = new RegExp('[' + buffer.join(',') + ']', 'g');\n                    var escapeChar_1 = shellQuoteOptions.escape.escapeChar;\n                    return [value.replace(regexp, function (match) { return escapeChar_1 + match; }), true];\n                }\n            }\n            return [value, false];\n        }\n        function quoteIfNecessary(value) {\n            if (Types.isString(value)) {\n                if (needsQuotes(value)) {\n                    return quote(value, tasks_1.ShellQuoting.Strong);\n                }\n                else {\n                    return [value, false];\n                }\n            }\n            else {\n                return quote(value.value, value.quoting);\n            }\n        }\n        // If we have no args and the command is a string then use the command to stay backwards compatible with the old command line\n        // model. To allow variable resolving with spaces we do continue if the resolved value is different than the original one\n        // and the resolved one needs quoting.\n        if ((!args || args.length === 0) && Types.isString(command) && (command === originalCommand || needsQuotes(originalCommand))) {\n            return command;\n        }\n        var result = [];\n        var commandQuoted = false;\n        var argQuoted = false;\n        var value;\n        var quoted;\n        _a = quoteIfNecessary(command), value = _a[0], quoted = _a[1];\n        result.push(value);\n        commandQuoted = quoted;\n        for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {\n            var arg = args_1[_i];\n            _b = quoteIfNecessary(arg), value = _b[0], quoted = _b[1];\n            result.push(value);\n            argQuoted = argQuoted || quoted;\n        }\n        var commandLine = result.join(' ');\n        // There are special rules quoted command line in cmd.exe\n        if (platform === Platform.Platform.Windows) {\n            if (basename === 'cmd' && commandQuoted && argQuoted) {\n                commandLine = '\"' + commandLine + '\"';\n            }\n            else if (basename === 'powershell' && commandQuoted) {\n                commandLine = '& ' + commandLine;\n            }\n        }\n        if (basename === 'cmd' && platform === Platform.Platform.Windows && commandQuoted && argQuoted) {\n            commandLine = '\"' + commandLine + '\"';\n        }\n        return commandLine;\n    };\n    TerminalTaskSystem.prototype.getQuotingOptions = function (shellBasename, shellOptions) {\n        if (shellOptions && shellOptions.quoting) {\n            return shellOptions.quoting;\n        }\n        return TerminalTaskSystem.shellQuotes[shellBasename] || TerminalTaskSystem.osShellQuotes[process.platform];\n    };\n    TerminalTaskSystem.prototype.collectTaskVariables = function (variables, task) {\n        if (task.command && task.command.name) {\n            this.collectCommandVariables(variables, task.command, task);\n        }\n        this.collectMatcherVariables(variables, task.configurationProperties.problemMatchers);\n    };\n    TerminalTaskSystem.prototype.collectCommandVariables = function (variables, command, task) {\n        var _this = this;\n        // The custom execution should have everything it needs already as it provided\n        // the callback.\n        if (command.runtime === tasks_1.RuntimeType.CustomExecution) {\n            return;\n        }\n        if (command.name === undefined) {\n            throw new Error('Command name should never be undefined here.');\n        }\n        this.collectVariables(variables, command.name);\n        if (command.args) {\n            command.args.forEach(function (arg) { return _this.collectVariables(variables, arg); });\n        }\n        // Try to get a scope.\n        var scope = task._source.scope;\n        if (scope !== tasks_1.TaskScope.Global) {\n            variables.add('${workspaceFolder}');\n        }\n        if (command.options) {\n            var options = command.options;\n            if (options.cwd) {\n                this.collectVariables(variables, options.cwd);\n            }\n            var optionsEnv_1 = options.env;\n            if (optionsEnv_1) {\n                Object.keys(optionsEnv_1).forEach(function (key) {\n                    var value = optionsEnv_1[key];\n                    if (Types.isString(value)) {\n                        _this.collectVariables(variables, value);\n                    }\n                });\n            }\n            if (options.shell) {\n                if (options.shell.executable) {\n                    this.collectVariables(variables, options.shell.executable);\n                }\n                if (options.shell.args) {\n                    options.shell.args.forEach(function (arg) { return _this.collectVariables(variables, arg); });\n                }\n            }\n        }\n    };\n    TerminalTaskSystem.prototype.collectMatcherVariables = function (variables, values) {\n        var _this = this;\n        if (values === undefined || values === null || values.length === 0) {\n            return;\n        }\n        values.forEach(function (value) {\n            var matcher;\n            if (Types.isString(value)) {\n                if (value[0] === '$') {\n                    matcher = problemMatcher_1.ProblemMatcherRegistry.get(value.substring(1));\n                }\n                else {\n                    matcher = problemMatcher_1.ProblemMatcherRegistry.get(value);\n                }\n            }\n            else {\n                matcher = value;\n            }\n            if (matcher && matcher.filePrefix) {\n                _this.collectVariables(variables, matcher.filePrefix);\n            }\n        });\n    };\n    TerminalTaskSystem.prototype.collectVariables = function (variables, value) {\n        var string = Types.isString(value) ? value : value.value;\n        var r = /\\$\\{(.*?)\\}/g;\n        var matches;\n        do {\n            matches = r.exec(string);\n            if (matches) {\n                variables.add(matches[0]);\n            }\n        } while (matches);\n    };\n    TerminalTaskSystem.prototype.resolveCommandAndArgs = function (resolver, commandConfig) {\n        // First we need to use the command args:\n        var args = commandConfig.args ? commandConfig.args.slice() : [];\n        args = this.resolveVariables(resolver, args);\n        var command = this.resolveVariable(resolver, commandConfig.name);\n        return { command: command, args: args };\n    };\n    TerminalTaskSystem.prototype.resolveVariables = function (resolver, value) {\n        var _this = this;\n        return value.map(function (s) { return _this.resolveVariable(resolver, s); });\n    };\n    TerminalTaskSystem.prototype.resolveMatchers = function (resolver, values) {\n        var _this = this;\n        if (values === undefined || values === null || values.length === 0) {\n            return [];\n        }\n        var result = [];\n        values.forEach(function (value) {\n            var matcher;\n            if (Types.isString(value)) {\n                if (value[0] === '$') {\n                    matcher = problemMatcher_1.ProblemMatcherRegistry.get(value.substring(1));\n                }\n                else {\n                    matcher = problemMatcher_1.ProblemMatcherRegistry.get(value);\n                }\n            }\n            else {\n                matcher = value;\n            }\n            if (!matcher) {\n                _this.appendOutput(nls.localize('unkownProblemMatcher', 'Problem matcher {0} can\\'t be resolved. The matcher will be ignored'));\n                return;\n            }\n            var taskSystemInfo = resolver.taskSystemInfo;\n            var hasFilePrefix = matcher.filePrefix !== undefined;\n            var hasUriProvider = taskSystemInfo !== undefined && taskSystemInfo.uriProvider !== undefined;\n            if (!hasFilePrefix && !hasUriProvider) {\n                result.push(matcher);\n            }\n            else {\n                var copy = Objects.deepClone(matcher);\n                if (hasUriProvider && (taskSystemInfo !== undefined)) {\n                    copy.uriProvider = taskSystemInfo.uriProvider;\n                }\n                if (hasFilePrefix) {\n                    copy.filePrefix = _this.resolveVariable(resolver, copy.filePrefix);\n                }\n                result.push(copy);\n            }\n        });\n        return result;\n    };\n    TerminalTaskSystem.prototype.resolveVariable = function (resolver, value) {\n        // TODO@Dirk Task.getWorkspaceFolder should return a WorkspaceFolder that is defined in workspace.ts\n        if (Types.isString(value)) {\n            return resolver.resolve(value);\n        }\n        else if (value !== undefined) {\n            return {\n                value: resolver.resolve(value.value),\n                quoting: value.quoting\n            };\n        }\n        else { // This should never happen\n            throw new Error('Should never try to resolve undefined.');\n        }\n    };\n    TerminalTaskSystem.prototype.resolveOptions = function (resolver, options) {\n        var _this = this;\n        if (options === undefined || options === null) {\n            return { cwd: this.resolveVariable(resolver, '${workspaceFolder}') };\n        }\n        var result = Types.isString(options.cwd)\n            ? { cwd: this.resolveVariable(resolver, options.cwd) }\n            : { cwd: this.resolveVariable(resolver, '${workspaceFolder}') };\n        if (options.env) {\n            result.env = Object.create(null);\n            Object.keys(options.env).forEach(function (key) {\n                var value = options.env[key];\n                if (Types.isString(value)) {\n                    result.env[key] = _this.resolveVariable(resolver, value);\n                }\n                else {\n                    result.env[key] = value.toString();\n                }\n            });\n        }\n        return result;\n    };\n    TerminalTaskSystem.prototype.registerLinkMatchers = function (terminal, problemMatchers) {\n        var result = [];\n        /*\n        let handlePattern = (matcher: ProblemMatcher, pattern: ProblemPattern): void => {\n            if (pattern.regexp instanceof RegExp && Types.isNumber(pattern.file)) {\n                result.push(terminal.registerLinkMatcher(pattern.regexp, (match: string) => {\n                    let resource: URI = getResource(match, matcher);\n                    if (resource) {\n                        this.workbenchEditorService.openEditor({\n                            resource: resource\n                        });\n                    }\n                }, 0));\n            }\n        };\n\n        for (let problemMatcher of problemMatchers) {\n            if (Array.isArray(problemMatcher.pattern)) {\n                for (let pattern of problemMatcher.pattern) {\n                    handlePattern(problemMatcher, pattern);\n                }\n            } else if (problemMatcher.pattern) {\n                handlePattern(problemMatcher, problemMatcher.pattern);\n            }\n        }\n        */\n        return result;\n    };\n    TerminalTaskSystem.prototype.getSanitizedCommand = function (cmd) {\n        var result = cmd.toLowerCase();\n        var index = result.lastIndexOf(path.sep);\n        if (index !== -1) {\n            result = result.substring(index + 1);\n        }\n        if (TerminalTaskSystem.WellKnowCommands[result]) {\n            return result;\n        }\n        return 'other';\n    };\n    TerminalTaskSystem.prototype.appendOutput = function (output) {\n        var outputChannel = this.outputService.getChannel(this.outputChannelId);\n        if (outputChannel) {\n            outputChannel.append(output);\n        }\n    };\n    TerminalTaskSystem.TelemetryEventName = 'taskService';\n    TerminalTaskSystem.ProcessVarName = '__process__';\n    TerminalTaskSystem.shellQuotes = {\n        'cmd': {\n            strong: '\"'\n        },\n        'powershell': {\n            escape: {\n                escapeChar: '`',\n                charsToEscape: ' \"\\'()'\n            },\n            strong: '\\'',\n            weak: '\"'\n        },\n        'bash': {\n            escape: {\n                escapeChar: '\\\\',\n                charsToEscape: ' \"\\''\n            },\n            strong: '\\'',\n            weak: '\"'\n        },\n        'zsh': {\n            escape: {\n                escapeChar: '\\\\',\n                charsToEscape: ' \"\\''\n            },\n            strong: '\\'',\n            weak: '\"'\n        }\n    };\n    TerminalTaskSystem.osShellQuotes = {\n        'linux': TerminalTaskSystem.shellQuotes['bash'],\n        'darwin': TerminalTaskSystem.shellQuotes['bash'],\n        'win32': TerminalTaskSystem.shellQuotes['powershell']\n    };\n    TerminalTaskSystem.WellKnowCommands = {\n        'ant': true,\n        'cmake': true,\n        'eslint': true,\n        'gradle': true,\n        'grunt': true,\n        'gulp': true,\n        'jake': true,\n        'jenkins': true,\n        'jshint': true,\n        'make': true,\n        'maven': true,\n        'msbuild': true,\n        'msc': true,\n        'nmake': true,\n        'npm': true,\n        'rake': true,\n        'tsc': true,\n        'xbuild': true\n    };\n    return TerminalTaskSystem;\n}());\nexports.TerminalTaskSystem = TerminalTaskSystem;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/electron-browser/terminalTaskSystem.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/electron-browser/terminalTaskSystem.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from 'vs/base/common/path';\nimport * as nls from 'vs/nls';\nimport * as Objects from 'vs/base/common/objects';\nimport * as Types from 'vs/base/common/types';\nimport * as Platform from 'vs/base/common/platform';\nimport * as Async from 'vs/base/common/async';\nimport { IStringDictionary, values } from 'vs/base/common/collections';\nimport { LinkedMap, Touch } from 'vs/base/common/map';\nimport Severity from 'vs/base/common/severity';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { isUNC } from 'vs/base/common/extpath';\n\nimport { win32 } from 'vs/base/node/processes';\n\nimport { IMarkerService, MarkerSeverity } from 'vs/platform/markers/common/markers';\nimport { IWorkspaceContextService, WorkbenchState, IWorkspaceFolder } from 'vs/platform/workspace/common/workspace';\nimport { IModelService } from 'vs/editor/common/services/modelService';\nimport { ProblemMatcher, ProblemMatcherRegistry /*, ProblemPattern, getResource */ } from 'vs/workbench/contrib/tasks/common/problemMatcher';\n\nimport { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';\n\nimport { IConfigurationResolverService } from 'vs/workbench/services/configurationResolver/common/configurationResolver';\nimport { ITerminalService, ITerminalInstance, IShellLaunchConfig } from 'vs/workbench/contrib/terminal/common/terminal';\nimport { IOutputService } from 'vs/workbench/contrib/output/common/output';\nimport { StartStopProblemCollector, WatchingProblemCollector, ProblemCollectorEventKind } from 'vs/workbench/contrib/tasks/common/problemCollectors';\nimport {\n\tTask, CustomTask, ContributedTask, RevealKind, CommandOptions, ShellConfiguration, RuntimeType, PanelKind,\n\tTaskEvent, TaskEventKind, ShellQuotingOptions, ShellQuoting, CommandString, CommandConfiguration, ExtensionTaskSource, TaskScope\n} from 'vs/workbench/contrib/tasks/common/tasks';\nimport {\n\tITaskSystem, ITaskSummary, ITaskExecuteResult, TaskExecuteKind, TaskError, TaskErrors, ITaskResolver,\n\tTelemetryEvent, Triggers, TaskTerminateResponse, TaskSystemInfoResovler, TaskSystemInfo, ResolveSet, ResolvedVariables\n} from 'vs/workbench/contrib/tasks/common/taskSystem';\nimport { REMOTE_HOST_SCHEME } from 'vs/platform/remote/common/remoteHosts';\nimport { URI } from 'vs/base/common/uri';\nimport { IWindowService } from 'vs/platform/windows/common/windows';\nimport { Schemas } from 'vs/base/common/network';\nimport { getWindowsBuildNumber } from 'vs/workbench/contrib/terminal/node/terminal';\n\ninterface TerminalData {\n\tterminal: ITerminalInstance;\n\tlastTask: string;\n\tgroup?: string;\n}\n\ninterface ActiveTerminalData {\n\tterminal: ITerminalInstance;\n\ttask: Task;\n\tpromise: Promise<ITaskSummary>;\n}\n\nclass VariableResolver {\n\n\tconstructor(public workspaceFolder: IWorkspaceFolder, public taskSystemInfo: TaskSystemInfo | undefined, private _values: Map<string, string>, private _service: IConfigurationResolverService | undefined) {\n\t}\n\tresolve(value: string): string {\n\t\treturn value.replace(/\\$\\{(.*?)\\}/g, (match: string, variable: string) => {\n\t\t\t// Strip out the ${} because the map contains them variables without those characters.\n\t\t\tlet result = this._values.get(match.substring(2, match.length - 1));\n\t\t\tif ((result !== undefined) && (result !== null)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (this._service) {\n\t\t\t\treturn this._service.resolve(this.workspaceFolder, match);\n\t\t\t}\n\t\t\treturn match;\n\t\t});\n\t}\n}\n\nexport class VerifiedTask {\n\treadonly task: Task;\n\treadonly resolver: ITaskResolver;\n\treadonly trigger: string;\n\tresolvedVariables?: ResolvedVariables;\n\tsystemInfo?: TaskSystemInfo;\n\tworkspaceFolder?: IWorkspaceFolder;\n\tshellLaunchConfig?: IShellLaunchConfig;\n\n\tconstructor(task: Task, resolver: ITaskResolver, trigger: string) {\n\t\tthis.task = task;\n\t\tthis.resolver = resolver;\n\t\tthis.trigger = trigger;\n\t}\n\n\tpublic verify(): boolean {\n\t\tlet verified = false;\n\t\tif (this.trigger && this.resolvedVariables && this.workspaceFolder && (this.shellLaunchConfig !== undefined)) {\n\t\t\tverified = true;\n\t\t}\n\t\treturn verified;\n\t}\n\n\tpublic getVerifiedTask(): { task: Task, resolver: ITaskResolver, trigger: string, resolvedVariables: ResolvedVariables, systemInfo: TaskSystemInfo, workspaceFolder: IWorkspaceFolder, shellLaunchConfig: IShellLaunchConfig } {\n\t\tif (this.verify()) {\n\t\t\treturn { task: this.task, resolver: this.resolver, trigger: this.trigger, resolvedVariables: this.resolvedVariables!, systemInfo: this.systemInfo!, workspaceFolder: this.workspaceFolder!, shellLaunchConfig: this.shellLaunchConfig! };\n\t\t} else {\n\t\t\tthrow new Error('VerifiedTask was not checked. verify must be checked before getVerifiedTask.');\n\t\t}\n\t}\n}\n\nexport class TerminalTaskSystem implements ITaskSystem {\n\n\tpublic static TelemetryEventName: string = 'taskService';\n\n\tprivate static ProcessVarName = '__process__';\n\n\tprivate static shellQuotes: IStringDictionary<ShellQuotingOptions> = {\n\t\t'cmd': {\n\t\t\tstrong: '\"'\n\t\t},\n\t\t'powershell': {\n\t\t\tescape: {\n\t\t\t\tescapeChar: '`',\n\t\t\t\tcharsToEscape: ' \"\\'()'\n\t\t\t},\n\t\t\tstrong: '\\'',\n\t\t\tweak: '\"'\n\t\t},\n\t\t'bash': {\n\t\t\tescape: {\n\t\t\t\tescapeChar: '\\\\',\n\t\t\t\tcharsToEscape: ' \"\\''\n\t\t\t},\n\t\t\tstrong: '\\'',\n\t\t\tweak: '\"'\n\t\t},\n\t\t'zsh': {\n\t\t\tescape: {\n\t\t\t\tescapeChar: '\\\\',\n\t\t\t\tcharsToEscape: ' \"\\''\n\t\t\t},\n\t\t\tstrong: '\\'',\n\t\t\tweak: '\"'\n\t\t}\n\t};\n\n\tprivate static osShellQuotes: IStringDictionary<ShellQuotingOptions> = {\n\t\t'linux': TerminalTaskSystem.shellQuotes['bash'],\n\t\t'darwin': TerminalTaskSystem.shellQuotes['bash'],\n\t\t'win32': TerminalTaskSystem.shellQuotes['powershell']\n\t};\n\n\tprivate activeTasks: IStringDictionary<ActiveTerminalData>;\n\tprivate terminals: IStringDictionary<TerminalData>;\n\tprivate idleTaskTerminals: LinkedMap<string, string>;\n\tprivate sameTaskTerminals: IStringDictionary<string>;\n\tprivate taskSystemInfoResolver: TaskSystemInfoResovler;\n\tprivate lastTask: VerifiedTask;\n\tprivate currentTask: VerifiedTask;\n\tprivate isRerun: boolean;\n\n\tprivate readonly _onDidStateChange: Emitter<TaskEvent>;\n\n\tconstructor(private terminalService: ITerminalService, private outputService: IOutputService,\n\t\tprivate markerService: IMarkerService, private modelService: IModelService,\n\t\tprivate configurationResolverService: IConfigurationResolverService,\n\t\tprivate telemetryService: ITelemetryService,\n\t\tprivate contextService: IWorkspaceContextService,\n\t\tprivate windowService: IWindowService,\n\t\tprivate outputChannelId: string,\n\t\ttaskSystemInfoResolver: TaskSystemInfoResovler) {\n\n\t\tthis.activeTasks = Object.create(null);\n\t\tthis.terminals = Object.create(null);\n\t\tthis.idleTaskTerminals = new LinkedMap<string, string>();\n\t\tthis.sameTaskTerminals = Object.create(null);\n\n\t\tthis._onDidStateChange = new Emitter();\n\t\tthis.taskSystemInfoResolver = taskSystemInfoResolver;\n\t}\n\n\tpublic get onDidStateChange(): Event<TaskEvent> {\n\t\treturn this._onDidStateChange.event;\n\t}\n\n\tpublic log(value: string): void {\n\t\tthis.appendOutput(value + '\\n');\n\t}\n\n\tprotected showOutput(): void {\n\t\tthis.outputService.showChannel(this.outputChannelId, true);\n\t}\n\n\tpublic run(task: Task, resolver: ITaskResolver, trigger: string = Triggers.command): ITaskExecuteResult {\n\t\tthis.currentTask = new VerifiedTask(task, resolver, trigger);\n\t\tlet terminalData = this.activeTasks[task.getMapKey()];\n\t\tif (terminalData && terminalData.promise) {\n\t\t\tlet reveal = RevealKind.Always;\n\t\t\tlet focus = false;\n\t\t\tif (CustomTask.is(task) || ContributedTask.is(task)) {\n\t\t\t\treveal = task.command.presentation!.reveal;\n\t\t\t\tfocus = task.command.presentation!.focus;\n\t\t\t}\n\t\t\tif (reveal === RevealKind.Always || focus) {\n\t\t\t\tthis.terminalService.setActiveInstance(terminalData.terminal);\n\t\t\t\tthis.terminalService.showPanel(focus);\n\t\t\t}\n\t\t\tthis.lastTask = this.currentTask;\n\t\t\treturn { kind: TaskExecuteKind.Active, task, active: { same: true, background: task.configurationProperties.isBackground! }, promise: terminalData.promise };\n\t\t}\n\n\t\ttry {\n\t\t\tconst executeResult = { kind: TaskExecuteKind.Started, task, started: {}, promise: this.executeTask(task, resolver, trigger) };\n\t\t\texecuteResult.promise.then(summary => {\n\t\t\t\tthis.lastTask = this.currentTask;\n\t\t\t});\n\t\t\treturn executeResult;\n\t\t} catch (error) {\n\t\t\tif (error instanceof TaskError) {\n\t\t\t\tthrow error;\n\t\t\t} else if (error instanceof Error) {\n\t\t\t\tthis.log(error.message);\n\t\t\t\tthrow new TaskError(Severity.Error, error.message, TaskErrors.UnknownError);\n\t\t\t} else {\n\t\t\t\tthis.log(error.toString());\n\t\t\t\tthrow new TaskError(Severity.Error, nls.localize('TerminalTaskSystem.unknownError', 'A unknown error has occurred while executing a task. See task output log for details.'), TaskErrors.UnknownError);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic rerun(): ITaskExecuteResult | undefined {\n\t\tif (this.lastTask && this.lastTask.verify()) {\n\t\t\tif ((this.lastTask.task.runOptions.reevaluateOnRerun !== undefined) && !this.lastTask.task.runOptions.reevaluateOnRerun) {\n\t\t\t\tthis.isRerun = true;\n\t\t\t}\n\t\t\tconst result = this.run(this.lastTask.task, this.lastTask.resolver);\n\t\t\tresult.promise.then(summary => {\n\t\t\t\tthis.isRerun = false;\n\t\t\t});\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tpublic revealTask(task: Task): boolean {\n\t\tlet terminalData = this.activeTasks[task.getMapKey()];\n\t\tif (!terminalData) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.terminalService.setActiveInstance(terminalData.terminal);\n\t\tif (CustomTask.is(task) || ContributedTask.is(task)) {\n\t\t\tthis.terminalService.showPanel(task.command.presentation!.focus);\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic isActive(): Promise<boolean> {\n\t\treturn Promise.resolve(this.isActiveSync());\n\t}\n\n\tpublic isActiveSync(): boolean {\n\t\treturn Object.keys(this.activeTasks).length > 0;\n\t}\n\n\tpublic canAutoTerminate(): boolean {\n\t\treturn Object.keys(this.activeTasks).every(key => !this.activeTasks[key].task.configurationProperties.promptOnClose);\n\t}\n\n\tpublic getActiveTasks(): Task[] {\n\t\treturn Object.keys(this.activeTasks).map(key => this.activeTasks[key].task);\n\t}\n\n\tpublic customExecutionComplete(task: Task, result: number): Promise<void> {\n\t\tlet activeTerminal = this.activeTasks[task.getMapKey()];\n\t\tif (!activeTerminal) {\n\t\t\treturn Promise.reject(new Error('Expected to have a terminal for an custom execution task'));\n\t\t}\n\n\t\treturn new Promise<void>((resolve) => {\n\t\t\tactiveTerminal.terminal.rendererExit(result);\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic terminate(task: Task): Promise<TaskTerminateResponse> {\n\t\tlet activeTerminal = this.activeTasks[task.getMapKey()];\n\t\tif (!activeTerminal) {\n\t\t\treturn Promise.resolve<TaskTerminateResponse>({ success: false, task: undefined });\n\t\t}\n\t\treturn new Promise<TaskTerminateResponse>((resolve, reject) => {\n\t\t\tlet terminal = activeTerminal.terminal;\n\n\t\t\tconst onExit = terminal.onExit(() => {\n\t\t\t\tlet task = activeTerminal.task;\n\t\t\t\ttry {\n\t\t\t\t\tonExit.dispose();\n\t\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.Terminated, task));\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Do nothing.\n\t\t\t\t}\n\t\t\t\tresolve({ success: true, task: task });\n\t\t\t});\n\t\t\tterminal.dispose();\n\t\t});\n\t}\n\n\tpublic terminateAll(): Promise<TaskTerminateResponse[]> {\n\t\tlet promises: Promise<TaskTerminateResponse>[] = [];\n\t\tObject.keys(this.activeTasks).forEach((key) => {\n\t\t\tlet terminalData = this.activeTasks[key];\n\t\t\tlet terminal = terminalData.terminal;\n\t\t\tpromises.push(new Promise<TaskTerminateResponse>((resolve, reject) => {\n\t\t\t\tconst onExit = terminal.onExit(() => {\n\t\t\t\t\tlet task = terminalData.task;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tonExit.dispose();\n\t\t\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.Terminated, task));\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t// Do nothing.\n\t\t\t\t\t}\n\t\t\t\t\tresolve({ success: true, task: terminalData.task });\n\t\t\t\t});\n\t\t\t}));\n\t\t\tterminal.dispose();\n\t\t});\n\t\tthis.activeTasks = Object.create(null);\n\t\treturn Promise.all<TaskTerminateResponse>(promises);\n\t}\n\n\tprivate executeTask(task: Task, resolver: ITaskResolver, trigger: string): Promise<ITaskSummary> {\n\t\tlet promises: Promise<ITaskSummary>[] = [];\n\t\tif (task.configurationProperties.dependsOn) {\n\t\t\ttask.configurationProperties.dependsOn.forEach((dependency) => {\n\t\t\t\tlet dependencyTask = resolver.resolve(dependency.workspaceFolder, dependency.task!);\n\t\t\t\tif (dependencyTask) {\n\t\t\t\t\tlet key = dependencyTask.getMapKey();\n\t\t\t\t\tlet promise = this.activeTasks[key] ? this.activeTasks[key].promise : undefined;\n\t\t\t\t\tif (!promise) {\n\t\t\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.DependsOnStarted, task));\n\t\t\t\t\t\tpromise = this.executeTask(dependencyTask, resolver, trigger);\n\t\t\t\t\t}\n\t\t\t\t\tpromises.push(promise);\n\t\t\t\t} else {\n\t\t\t\t\tthis.log(nls.localize('dependencyFailed',\n\t\t\t\t\t\t'Couldn\\'t resolve dependent task \\'{0}\\' in workspace folder \\'{1}\\'',\n\t\t\t\t\t\tTypes.isString(dependency.task) ? dependency.task : JSON.stringify(dependency.task, undefined, 0),\n\t\t\t\t\t\tdependency.workspaceFolder.name\n\t\t\t\t\t));\n\t\t\t\t\tthis.showOutput();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif ((ContributedTask.is(task) || CustomTask.is(task)) && (task.command)) {\n\t\t\treturn Promise.all(promises).then((summaries): Promise<ITaskSummary> | ITaskSummary => {\n\t\t\t\tfor (let summary of summaries) {\n\t\t\t\t\tif (summary.exitCode !== 0) {\n\t\t\t\t\t\treturn { exitCode: summary.exitCode };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.isRerun) {\n\t\t\t\t\treturn this.reexecuteCommand(task, trigger);\n\t\t\t\t} else {\n\t\t\t\t\treturn this.executeCommand(task, trigger);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\treturn Promise.all(promises).then((summaries): ITaskSummary => {\n\t\t\t\tfor (let summary of summaries) {\n\t\t\t\t\tif (summary.exitCode !== 0) {\n\t\t\t\t\t\treturn { exitCode: summary.exitCode };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn { exitCode: 0 };\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate resolveVariablesFromSet(taskSystemInfo: TaskSystemInfo | undefined, workspaceFolder: IWorkspaceFolder, task: CustomTask | ContributedTask, variables: Set<string>): Promise<ResolvedVariables> {\n\t\tlet isProcess = task.command && task.command.runtime === RuntimeType.Process;\n\t\tlet options = task.command && task.command.options ? task.command.options : undefined;\n\t\tlet cwd = options ? options.cwd : undefined;\n\t\tlet envPath: string | undefined = undefined;\n\t\tif (options && options.env) {\n\t\t\tfor (let key of Object.keys(options.env)) {\n\t\t\t\tif (key.toLowerCase() === 'path') {\n\t\t\t\t\tif (Types.isString(options.env[key])) {\n\t\t\t\t\t\tenvPath = options.env[key];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet resolvedVariables: Promise<ResolvedVariables>;\n\t\tif (taskSystemInfo) {\n\t\t\tlet resolveSet: ResolveSet = {\n\t\t\t\tvariables\n\t\t\t};\n\n\t\t\tif (taskSystemInfo.platform === Platform.Platform.Windows && isProcess) {\n\t\t\t\tresolveSet.process = { name: CommandString.value(task.command.name!) };\n\t\t\t\tif (cwd) {\n\t\t\t\t\tresolveSet.process.cwd = cwd;\n\t\t\t\t}\n\t\t\t\tif (envPath) {\n\t\t\t\t\tresolveSet.process.path = envPath;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresolvedVariables = taskSystemInfo.resolveVariables(workspaceFolder, resolveSet).then(resolved => {\n\t\t\t\tif ((taskSystemInfo.platform !== Platform.Platform.Windows) && isProcess) {\n\t\t\t\t\tresolved.variables.set(TerminalTaskSystem.ProcessVarName, CommandString.value(task.command.name!));\n\t\t\t\t}\n\t\t\t\treturn Promise.resolve(resolved);\n\t\t\t});\n\t\t\treturn resolvedVariables;\n\t\t} else {\n\t\t\tlet variablesArray = new Array<string>();\n\t\t\tvariables.forEach(variable => variablesArray.push(variable));\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.configurationResolverService.resolveWithInteraction(workspaceFolder, variablesArray, 'tasks').then(resolvedVariablesMap => {\n\t\t\t\t\tif (resolvedVariablesMap) {\n\t\t\t\t\t\tif (isProcess) {\n\t\t\t\t\t\t\tlet processVarValue: string;\n\t\t\t\t\t\t\tif (Platform.isWindows) {\n\t\t\t\t\t\t\t\tprocessVarValue = win32.findExecutable(\n\t\t\t\t\t\t\t\t\tthis.configurationResolverService.resolve(workspaceFolder, CommandString.value(task.command.name!)),\n\t\t\t\t\t\t\t\t\tcwd ? this.configurationResolverService.resolve(workspaceFolder, cwd) : undefined,\n\t\t\t\t\t\t\t\t\tenvPath ? envPath.split(path.delimiter).map(p => this.configurationResolverService.resolve(workspaceFolder, p)) : undefined\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprocessVarValue = this.configurationResolverService.resolve(workspaceFolder, CommandString.value(task.command.name!));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresolvedVariablesMap.set(TerminalTaskSystem.ProcessVarName, processVarValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet resolvedVariablesResult: ResolvedVariables = {\n\t\t\t\t\t\t\tvariables: resolvedVariablesMap,\n\t\t\t\t\t\t};\n\t\t\t\t\t\tresolve(resolvedVariablesResult);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t}, reason => {\n\t\t\t\t\treject(reason);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate executeCommand(task: CustomTask | ContributedTask, trigger: string): Promise<ITaskSummary> {\n\t\tthis.currentTask.workspaceFolder = task.getWorkspaceFolder();\n\t\tif (this.currentTask.workspaceFolder) {\n\t\t\tthis.currentTask.systemInfo = this.taskSystemInfoResolver(this.currentTask.workspaceFolder);\n\t\t}\n\n\t\tlet variables = new Set<string>();\n\t\tthis.collectTaskVariables(variables, task);\n\t\tconst resolvedVariables = this.resolveVariablesFromSet(this.currentTask.systemInfo, this.currentTask.workspaceFolder!, task, variables);\n\n\t\treturn resolvedVariables.then((resolvedVariables) => {\n\t\t\tif (resolvedVariables && task.command && task.command.runtime) {\n\t\t\t\tthis.currentTask.resolvedVariables = resolvedVariables;\n\t\t\t\treturn this.executeInTerminal(task, trigger, new VariableResolver(this.currentTask.workspaceFolder!, this.currentTask.systemInfo, resolvedVariables.variables, this.configurationResolverService));\n\t\t\t} else {\n\t\t\t\treturn Promise.resolve({ exitCode: 0 });\n\t\t\t}\n\t\t}, reason => {\n\t\t\treturn Promise.reject(reason);\n\t\t});\n\t}\n\n\tprivate reexecuteCommand(task: CustomTask | ContributedTask, trigger: string): Promise<ITaskSummary> {\n\t\tthis.currentTask.workspaceFolder = this.lastTask.workspaceFolder;\n\t\tlet variables = new Set<string>();\n\t\tthis.collectTaskVariables(variables, task);\n\n\t\t// Check that the task hasn't changed to include new variables\n\t\tlet hasAllVariables = true;\n\t\tvariables.forEach(value => {\n\t\t\tif (value.substring(2, value.length - 1) in this.lastTask.getVerifiedTask().resolvedVariables) {\n\t\t\t\thasAllVariables = false;\n\t\t\t}\n\t\t});\n\n\t\tif (!hasAllVariables) {\n\t\t\treturn this.resolveVariablesFromSet(this.lastTask.getVerifiedTask().systemInfo, this.lastTask.getVerifiedTask().workspaceFolder, task, variables).then((resolvedVariables) => {\n\t\t\t\tthis.currentTask.resolvedVariables = resolvedVariables;\n\t\t\t\treturn this.executeInTerminal(task, trigger, new VariableResolver(this.lastTask.getVerifiedTask().workspaceFolder, this.lastTask.getVerifiedTask().systemInfo, resolvedVariables.variables, this.configurationResolverService));\n\t\t\t}, reason => {\n\t\t\t\treturn Promise.reject(reason);\n\t\t\t});\n\t\t} else {\n\t\t\tthis.currentTask.resolvedVariables = this.lastTask.getVerifiedTask().resolvedVariables;\n\t\t\treturn this.executeInTerminal(task, trigger, new VariableResolver(this.lastTask.getVerifiedTask().workspaceFolder, this.lastTask.getVerifiedTask().systemInfo, this.lastTask.getVerifiedTask().resolvedVariables.variables, this.configurationResolverService));\n\t\t}\n\t}\n\n\tprivate executeInTerminal(task: CustomTask | ContributedTask, trigger: string, resolver: VariableResolver): Promise<ITaskSummary> {\n\t\tlet terminal: ITerminalInstance | undefined = undefined;\n\t\tlet executedCommand: string | undefined = undefined;\n\t\tlet error: TaskError | undefined = undefined;\n\t\tlet promise: Promise<ITaskSummary> | undefined = undefined;\n\t\tif (task.configurationProperties.isBackground) {\n\t\t\tpromise = new Promise<ITaskSummary>((resolve, reject) => {\n\t\t\t\tconst problemMatchers = this.resolveMatchers(resolver, task.configurationProperties.problemMatchers);\n\t\t\t\tlet watchingProblemMatcher = new WatchingProblemCollector(problemMatchers, this.markerService, this.modelService);\n\t\t\t\tlet toDispose: IDisposable[] | undefined = [];\n\t\t\t\tlet eventCounter: number = 0;\n\t\t\t\ttoDispose.push(watchingProblemMatcher.onDidStateChange((event) => {\n\t\t\t\t\tif (event.kind === ProblemCollectorEventKind.BackgroundProcessingBegins) {\n\t\t\t\t\t\teventCounter++;\n\t\t\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.Active, task));\n\t\t\t\t\t} else if (event.kind === ProblemCollectorEventKind.BackgroundProcessingEnds) {\n\t\t\t\t\t\teventCounter--;\n\t\t\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.Inactive, task));\n\t\t\t\t\t\tif (eventCounter === 0) {\n\t\t\t\t\t\t\tlet reveal = task.command.presentation!.reveal;\n\t\t\t\t\t\t\tif ((reveal === RevealKind.Silent) && (watchingProblemMatcher.numberOfMatches > 0) && watchingProblemMatcher.maxMarkerSeverity &&\n\t\t\t\t\t\t\t\t(watchingProblemMatcher.maxMarkerSeverity >= MarkerSeverity.Error)) {\n\t\t\t\t\t\t\t\tthis.terminalService.setActiveInstance(terminal!);\n\t\t\t\t\t\t\t\tthis.terminalService.showPanel(false);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t\twatchingProblemMatcher.aboutToStart();\n\t\t\t\tlet delayer: Async.Delayer<any> | undefined = undefined;\n\t\t\t\t[terminal, executedCommand, error] = this.createTerminal(task, resolver);\n\t\t\t\tif (error || !terminal) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlet processStartedSignaled = false;\n\t\t\t\tterminal.processReady.then(() => {\n\t\t\t\t\tif (!processStartedSignaled) {\n\t\t\t\t\t\tif (task.command.runtime !== RuntimeType.CustomExecution) {\n\t\t\t\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.ProcessStarted, task, terminal!.processId!));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprocessStartedSignaled = true;\n\t\t\t\t\t}\n\t\t\t\t}, (_error) => {\n\t\t\t\t\t// The process never got ready. Need to think how to handle this.\n\t\t\t\t});\n\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.Start, task, terminal.id));\n\t\t\t\tconst registeredLinkMatchers = this.registerLinkMatchers(terminal, problemMatchers);\n\t\t\t\tconst onData = terminal.onLineData((line) => {\n\t\t\t\t\twatchingProblemMatcher.processLine(line);\n\t\t\t\t\tif (!delayer) {\n\t\t\t\t\t\tdelayer = new Async.Delayer(3000);\n\t\t\t\t\t}\n\t\t\t\t\tdelayer.trigger(() => {\n\t\t\t\t\t\twatchingProblemMatcher.forceDelivery();\n\t\t\t\t\t\tdelayer = undefined;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tconst onExit = terminal.onExit((exitCode) => {\n\t\t\t\t\tonData.dispose();\n\t\t\t\t\tonExit.dispose();\n\t\t\t\t\tlet key = task.getMapKey();\n\t\t\t\t\tdelete this.activeTasks[key];\n\t\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.Changed));\n\t\t\t\t\tif (exitCode !== undefined) {\n\t\t\t\t\t\t// Only keep a reference to the terminal if it is not being disposed.\n\t\t\t\t\t\tswitch (task.command.presentation!.panel) {\n\t\t\t\t\t\t\tcase PanelKind.Dedicated:\n\t\t\t\t\t\t\t\tthis.sameTaskTerminals[key] = terminal!.id.toString();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase PanelKind.Shared:\n\t\t\t\t\t\t\t\tthis.idleTaskTerminals.set(key, terminal!.id.toString(), Touch.AsOld);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet reveal = task.command.presentation!.reveal;\n\t\t\t\t\tif ((reveal === RevealKind.Silent) && ((exitCode !== 0) || (watchingProblemMatcher.numberOfMatches > 0) && watchingProblemMatcher.maxMarkerSeverity &&\n\t\t\t\t\t\t(watchingProblemMatcher.maxMarkerSeverity >= MarkerSeverity.Error))) {\n\t\t\t\t\t\tthis.terminalService.setActiveInstance(terminal!);\n\t\t\t\t\t\tthis.terminalService.showPanel(false);\n\t\t\t\t\t}\n\t\t\t\t\twatchingProblemMatcher.done();\n\t\t\t\t\twatchingProblemMatcher.dispose();\n\t\t\t\t\tregisteredLinkMatchers.forEach(handle => terminal!.deregisterLinkMatcher(handle));\n\t\t\t\t\tif (!processStartedSignaled) {\n\t\t\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.ProcessStarted, task, terminal!.processId!));\n\t\t\t\t\t\tprocessStartedSignaled = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (task.command.runtime !== RuntimeType.CustomExecution) {\n\t\t\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.ProcessEnded, task, exitCode));\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0; i < eventCounter; i++) {\n\t\t\t\t\t\tlet event = TaskEvent.create(TaskEventKind.Inactive, task);\n\t\t\t\t\t\tthis._onDidStateChange.fire(event);\n\t\t\t\t\t}\n\t\t\t\t\teventCounter = 0;\n\t\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.End, task));\n\t\t\t\t\ttoDispose = dispose(toDispose!);\n\t\t\t\t\ttoDispose = undefined;\n\t\t\t\t\tresolve({ exitCode });\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tpromise = new Promise<ITaskSummary>((resolve, reject) => {\n\t\t\t\t[terminal, executedCommand, error] = this.createTerminal(task, resolver);\n\t\t\t\tif (!terminal || error) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet processStartedSignaled = false;\n\t\t\t\tterminal.processReady.then(() => {\n\t\t\t\t\tif (!processStartedSignaled) {\n\t\t\t\t\t\tif (task.command.runtime !== RuntimeType.CustomExecution) {\n\t\t\t\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.ProcessStarted, task, terminal!.processId!));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprocessStartedSignaled = true;\n\t\t\t\t\t}\n\t\t\t\t}, (_error) => {\n\t\t\t\t\t// The process never got ready. Need to think how to handle this.\n\t\t\t\t});\n\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.Start, task, terminal.id));\n\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.Active, task));\n\t\t\t\tlet problemMatchers = this.resolveMatchers(resolver, task.configurationProperties.problemMatchers);\n\t\t\t\tlet startStopProblemMatcher = new StartStopProblemCollector(problemMatchers, this.markerService, this.modelService);\n\t\t\t\tconst registeredLinkMatchers = this.registerLinkMatchers(terminal, problemMatchers);\n\t\t\t\tconst onData = terminal.onLineData((line) => {\n\t\t\t\t\tstartStopProblemMatcher.processLine(line);\n\t\t\t\t});\n\t\t\t\tconst onExit = terminal.onExit((exitCode) => {\n\t\t\t\t\tonData.dispose();\n\t\t\t\t\tonExit.dispose();\n\t\t\t\t\tlet key = task.getMapKey();\n\t\t\t\t\tdelete this.activeTasks[key];\n\t\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.Changed));\n\t\t\t\t\tif (exitCode !== undefined) {\n\t\t\t\t\t\t// Only keep a reference to the terminal if it is not being disposed.\n\t\t\t\t\t\tswitch (task.command.presentation!.panel) {\n\t\t\t\t\t\t\tcase PanelKind.Dedicated:\n\t\t\t\t\t\t\t\tthis.sameTaskTerminals[key] = terminal!.id.toString();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase PanelKind.Shared:\n\t\t\t\t\t\t\t\tthis.idleTaskTerminals.set(key, terminal!.id.toString(), Touch.AsOld);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet reveal = task.command.presentation!.reveal;\n\t\t\t\t\tif (terminal && (reveal === RevealKind.Silent) && ((exitCode !== 0) || (startStopProblemMatcher.numberOfMatches > 0) && startStopProblemMatcher.maxMarkerSeverity &&\n\t\t\t\t\t\t(startStopProblemMatcher.maxMarkerSeverity >= MarkerSeverity.Error))) {\n\t\t\t\t\t\tthis.terminalService.setActiveInstance(terminal);\n\t\t\t\t\t\tthis.terminalService.showPanel(false);\n\t\t\t\t\t}\n\t\t\t\t\tstartStopProblemMatcher.done();\n\t\t\t\t\tstartStopProblemMatcher.dispose();\n\t\t\t\t\tregisteredLinkMatchers.forEach(handle => {\n\t\t\t\t\t\tif (terminal) {\n\t\t\t\t\t\t\tterminal.deregisterLinkMatcher(handle);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (!processStartedSignaled && terminal) {\n\t\t\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.ProcessStarted, task, terminal.processId!));\n\t\t\t\t\t\tprocessStartedSignaled = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (task.command.runtime !== RuntimeType.CustomExecution) {\n\t\t\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.ProcessEnded, task, exitCode));\n\t\t\t\t\t}\n\t\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.Inactive, task));\n\t\t\t\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.End, task));\n\t\t\t\t\tresolve({ exitCode });\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\tif (error) {\n\t\t\treturn Promise.reject(new Error((<TaskError>error).message));\n\t\t}\n\t\tif (!terminal) {\n\t\t\treturn Promise.reject(new Error(`Failed to create terminal for task ${task._label}`));\n\t\t}\n\t\tif (task.command.presentation && (task.command.presentation.reveal === RevealKind.Always)) {\n\t\t\tthis.terminalService.setActiveInstance(terminal);\n\t\t\tthis.terminalService.showPanel(task.command.presentation.focus);\n\t\t}\n\t\tthis.activeTasks[task.getMapKey()] = { terminal, task, promise };\n\t\tthis._onDidStateChange.fire(TaskEvent.create(TaskEventKind.Changed));\n\t\treturn promise.then((summary) => {\n\t\t\ttry {\n\t\t\t\tlet telemetryEvent: TelemetryEvent = {\n\t\t\t\t\ttrigger: trigger,\n\t\t\t\t\trunner: 'terminal',\n\t\t\t\t\ttaskKind: task.getTelemetryKind(),\n\t\t\t\t\tcommand: this.getSanitizedCommand(executedCommand!),\n\t\t\t\t\tsuccess: true,\n\t\t\t\t\texitCode: summary.exitCode\n\t\t\t\t};\n\t\t\t\t/* __GDPR__\n\t\t\t\t\t\"taskService\" : {\n\t\t\t\t\t\t\"${include}\": [\n\t\t\t\t\t\t\t\"${TelemetryEvent}\"\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tthis.telemetryService.publicLog(TerminalTaskSystem.TelemetryEventName, telemetryEvent);\n\t\t\t} catch (error) {\n\t\t\t}\n\t\t\treturn summary;\n\t\t}, (error) => {\n\t\t\ttry {\n\t\t\t\tlet telemetryEvent: TelemetryEvent = {\n\t\t\t\t\ttrigger: trigger,\n\t\t\t\t\trunner: 'terminal',\n\t\t\t\t\ttaskKind: task.getTelemetryKind(),\n\t\t\t\t\tcommand: this.getSanitizedCommand(executedCommand!),\n\t\t\t\t\tsuccess: false\n\t\t\t\t};\n\t\t\t\t/* __GDPR__\n\t\t\t\t\t\"taskService\" : {\n\t\t\t\t\t\t\"${include}\": [\n\t\t\t\t\t\t\t\"${TelemetryEvent}\"\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tthis.telemetryService.publicLog(TerminalTaskSystem.TelemetryEventName, telemetryEvent);\n\t\t\t} catch (error) {\n\t\t\t}\n\t\t\treturn Promise.reject<ITaskSummary>(error);\n\t\t});\n\t}\n\n\tprivate createTerminalName(task: CustomTask | ContributedTask): string {\n\t\tconst needsFolderQualification = this.currentTask.workspaceFolder && this.contextService.getWorkbenchState() === WorkbenchState.WORKSPACE;\n\t\treturn nls.localize('TerminalTaskSystem.terminalName', 'Task - {0}', needsFolderQualification ? task.getQualifiedLabel() : task.configurationProperties.name);\n\t}\n\n\tprivate createShellLaunchConfig(task: CustomTask | ContributedTask, variableResolver: VariableResolver, platform: Platform.Platform, options: CommandOptions, command: CommandString, args: CommandString[], waitOnExit: boolean | string): IShellLaunchConfig | undefined {\n\t\tlet shellLaunchConfig: IShellLaunchConfig;\n\t\tlet isShellCommand = task.command.runtime === RuntimeType.Shell;\n\t\tlet needsFolderQualification = this.currentTask.workspaceFolder && this.contextService.getWorkbenchState() === WorkbenchState.WORKSPACE;\n\t\tlet terminalName = this.createTerminalName(task);\n\t\tlet originalCommand = task.command.name;\n\t\tif (isShellCommand) {\n\t\t\tshellLaunchConfig = { name: terminalName, executable: undefined, args: undefined, waitOnExit };\n\t\t\tthis.terminalService.configHelper.mergeDefaultShellPathAndArgs(shellLaunchConfig, platform);\n\t\t\tlet shellSpecified: boolean = false;\n\t\t\tlet shellOptions: ShellConfiguration | undefined = task.command.options && task.command.options.shell;\n\t\t\tif (shellOptions) {\n\t\t\t\tif (shellOptions.executable) {\n\t\t\t\t\tshellLaunchConfig.executable = this.resolveVariable(variableResolver, shellOptions.executable);\n\t\t\t\t\tshellSpecified = true;\n\t\t\t\t}\n\t\t\t\tif (shellOptions.args) {\n\t\t\t\t\tshellLaunchConfig.args = this.resolveVariables(variableResolver, shellOptions.args.slice());\n\t\t\t\t} else {\n\t\t\t\t\tshellLaunchConfig.args = [];\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet shellArgs = <string[]>shellLaunchConfig.args!.slice(0);\n\t\t\tlet toAdd: string[] = [];\n\t\t\tlet commandLine = this.buildShellCommandLine(platform, shellLaunchConfig.executable!, shellOptions, command, originalCommand, args);\n\t\t\tlet windowsShellArgs: boolean = false;\n\t\t\tif (platform === Platform.Platform.Windows) {\n\t\t\t\t// Change Sysnative to System32 if the OS is Windows but NOT WoW64. It's\n\t\t\t\t// safe to assume that this was used by accident as Sysnative does not\n\t\t\t\t// exist and will break the terminal in non-WoW64 environments.\n\t\t\t\tif (!process.env.hasOwnProperty('PROCESSOR_ARCHITEW6432')) {\n\t\t\t\t\tconst sysnativePath = path.join(process.env.windir!, 'Sysnative').toLowerCase();\n\t\t\t\t\tif (shellLaunchConfig.executable!.toLowerCase().indexOf(sysnativePath) === 0) {\n\t\t\t\t\t\tshellLaunchConfig.executable = path.join(process.env.windir!, 'System32', shellLaunchConfig.executable!.substr(sysnativePath.length));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twindowsShellArgs = true;\n\t\t\t\tlet basename = path.basename(shellLaunchConfig.executable!).toLowerCase();\n\t\t\t\tif (basename === 'cmd.exe' && ((options.cwd && isUNC(options.cwd)) || (!options.cwd && isUNC(process.cwd())))) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif ((basename === 'powershell.exe') || (basename === 'pwsh.exe')) {\n\t\t\t\t\tif (!shellSpecified) {\n\t\t\t\t\t\ttoAdd.push('-Command');\n\t\t\t\t\t}\n\t\t\t\t} else if ((basename === 'bash.exe') || (basename === 'zsh.exe')) {\n\t\t\t\t\twindowsShellArgs = false;\n\t\t\t\t\tif (!shellSpecified) {\n\t\t\t\t\t\ttoAdd.push('-c');\n\t\t\t\t\t}\n\t\t\t\t} else if (basename === 'wsl.exe') {\n\t\t\t\t\tif (!shellSpecified && (getWindowsBuildNumber() >= 17763)) { // See https://github.com/Microsoft/vscode/issues/67855\n\t\t\t\t\t\ttoAdd.push('-e');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!shellSpecified) {\n\t\t\t\t\t\ttoAdd.push('/d', '/c');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!shellSpecified) {\n\t\t\t\t\t// Under Mac remove -l to not start it as a login shell.\n\t\t\t\t\tif (platform === Platform.Platform.Mac) {\n\t\t\t\t\t\tlet index = shellArgs.indexOf('-l');\n\t\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\t\tshellArgs.splice(index, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttoAdd.push('-c');\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoAdd.forEach(element => {\n\t\t\t\tif (!shellArgs.some(arg => arg.toLowerCase() === element)) {\n\t\t\t\t\tshellArgs.push(element);\n\t\t\t\t}\n\t\t\t});\n\t\t\tshellArgs.push(commandLine);\n\t\t\tshellLaunchConfig.args = windowsShellArgs ? shellArgs.join(' ') : shellArgs;\n\t\t\tif (task.command.presentation && task.command.presentation.echo) {\n\t\t\t\tif (needsFolderQualification) {\n\t\t\t\t\tshellLaunchConfig.initialText = `\\x1b[1m> Executing task in folder ${this.currentTask.workspaceFolder!.name}: ${commandLine} <\\x1b[0m\\n`;\n\t\t\t\t} else {\n\t\t\t\t\tshellLaunchConfig.initialText = `\\x1b[1m> Executing task: ${commandLine} <\\x1b[0m\\n`;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlet commandExecutable = task.command.runtime !== RuntimeType.CustomExecution ? CommandString.value(command) : undefined;\n\t\t\tlet executable = !isShellCommand\n\t\t\t\t? this.resolveVariable(variableResolver, '${' + TerminalTaskSystem.ProcessVarName + '}')\n\t\t\t\t: commandExecutable;\n\n\t\t\t// When we have a process task there is no need to quote arguments. So we go ahead and take the string value.\n\t\t\tshellLaunchConfig = {\n\t\t\t\tname: terminalName,\n\t\t\t\texecutable: executable,\n\t\t\t\targs: args.map(a => Types.isString(a) ? a : a.value),\n\t\t\t\twaitOnExit\n\t\t\t};\n\t\t\tif (task.command.presentation && task.command.presentation.echo) {\n\t\t\t\tlet getArgsToEcho = (args: string | string[] | undefined): string => {\n\t\t\t\t\tif (!args || args.length === 0) {\n\t\t\t\t\t\treturn '';\n\t\t\t\t\t}\n\t\t\t\t\tif (Types.isString(args)) {\n\t\t\t\t\t\treturn args;\n\t\t\t\t\t}\n\t\t\t\t\treturn args.join(' ');\n\t\t\t\t};\n\t\t\t\tif (needsFolderQualification) {\n\t\t\t\t\tshellLaunchConfig.initialText = `\\x1b[1m> Executing task in folder ${this.currentTask.workspaceFolder!.name}: ${shellLaunchConfig.executable} ${getArgsToEcho(shellLaunchConfig.args)} <\\x1b[0m\\n`;\n\t\t\t\t} else {\n\t\t\t\t\tshellLaunchConfig.initialText = `\\x1b[1m> Executing task: ${shellLaunchConfig.executable} ${getArgsToEcho(shellLaunchConfig.args)} <\\x1b[0m\\n`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (options.cwd) {\n\t\t\tlet cwd = options.cwd;\n\t\t\tif (!path.isAbsolute(cwd)) {\n\t\t\t\tlet workspaceFolder = task.getWorkspaceFolder();\n\t\t\t\tif (workspaceFolder && (workspaceFolder.uri.scheme === 'file')) {\n\t\t\t\t\tcwd = path.join(workspaceFolder.uri.fsPath, cwd);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// This must be normalized to the OS\n\t\t\tconst authority = this.windowService.getConfiguration().remoteAuthority;\n\t\t\tshellLaunchConfig.cwd = URI.from({ scheme: authority ? REMOTE_HOST_SCHEME : Schemas.file, authority: authority, path: cwd });\n\t\t}\n\t\tif (options.env) {\n\t\t\tshellLaunchConfig.env = options.env;\n\t\t}\n\t\treturn shellLaunchConfig;\n\t}\n\n\tprivate createTerminal(task: CustomTask | ContributedTask, resolver: VariableResolver): [ITerminalInstance | undefined, string | undefined, TaskError | undefined] {\n\t\tlet platform = resolver.taskSystemInfo ? resolver.taskSystemInfo.platform : Platform.platform;\n\t\tlet options = this.resolveOptions(resolver, task.command.options);\n\n\t\tlet waitOnExit: boolean | string = false;\n\t\tconst presentationOptions = task.command.presentation;\n\t\tif (!presentationOptions) {\n\t\t\tthrow new Error('Task presentation options should not be undefined here.');\n\t\t}\n\n\t\tif (presentationOptions.reveal !== RevealKind.Never || !task.configurationProperties.isBackground) {\n\t\t\tif (presentationOptions.panel === PanelKind.New) {\n\t\t\t\twaitOnExit = nls.localize('closeTerminal', 'Press any key to close the terminal.');\n\t\t\t} else if (presentationOptions.showReuseMessage) {\n\t\t\t\twaitOnExit = nls.localize('reuseTerminal', 'Terminal will be reused by tasks, press any key to close it.');\n\t\t\t} else {\n\t\t\t\twaitOnExit = true;\n\t\t\t}\n\t\t}\n\n\t\tlet commandExecutable: string | undefined;\n\t\tlet command: CommandString | undefined;\n\t\tlet args: CommandString[] | undefined;\n\n\t\tif (task.command.runtime === RuntimeType.CustomExecution) {\n\t\t\tthis.currentTask.shellLaunchConfig = {\n\t\t\t\tisRendererOnly: true,\n\t\t\t\twaitOnExit,\n\t\t\t\tname: this.createTerminalName(task),\n\t\t\t\tinitialText: task.command.presentation && task.command.presentation.echo ? `\\x1b[1m> Executing task: ${task._label} <\\x1b[0m\\n` : undefined\n\t\t\t};\n\t\t} else {\n\t\t\tlet resolvedResult: { command: CommandString, args: CommandString[] } = this.resolveCommandAndArgs(resolver, task.command);\n\t\t\tcommand = resolvedResult.command;\n\t\t\targs = resolvedResult.args;\n\t\t\tcommandExecutable = CommandString.value(command);\n\n\t\t\tthis.currentTask.shellLaunchConfig = this.isRerun ? this.lastTask.getVerifiedTask().shellLaunchConfig : this.createShellLaunchConfig(task, resolver, platform, options, command, args, waitOnExit);\n\t\t\tif (this.currentTask.shellLaunchConfig === undefined) {\n\t\t\t\treturn [undefined, undefined, new TaskError(Severity.Error, nls.localize('TerminalTaskSystem', 'Can\\'t execute a shell command on an UNC drive using cmd.exe.'), TaskErrors.UnknownError)];\n\t\t\t}\n\t\t}\n\n\t\tlet prefersSameTerminal = presentationOptions.panel === PanelKind.Dedicated;\n\t\tlet allowsSharedTerminal = presentationOptions.panel === PanelKind.Shared;\n\t\tlet group = presentationOptions.group;\n\n\t\tlet taskKey = task.getMapKey();\n\t\tlet terminalToReuse: TerminalData | undefined;\n\t\tif (prefersSameTerminal) {\n\t\t\tlet terminalId = this.sameTaskTerminals[taskKey];\n\t\t\tif (terminalId) {\n\t\t\t\tterminalToReuse = this.terminals[terminalId];\n\t\t\t\tdelete this.sameTaskTerminals[taskKey];\n\t\t\t}\n\t\t} else if (allowsSharedTerminal) {\n\t\t\t// Always allow to reuse the terminal previously used by the same task.\n\t\t\tlet terminalId = this.idleTaskTerminals.remove(taskKey);\n\t\t\tif (!terminalId) {\n\t\t\t\t// There is no idle terminal which was used by the same task.\n\t\t\t\t// Search for any idle terminal used previously by a task of the same group\n\t\t\t\t// (or, if the task has no group, a terminal used by a task without group).\n\t\t\t\tfor (const taskId of this.idleTaskTerminals.keys()) {\n\t\t\t\t\tconst idleTerminalId = this.idleTaskTerminals.get(taskId)!;\n\t\t\t\t\tif (idleTerminalId && this.terminals[idleTerminalId] && this.terminals[idleTerminalId].group === group) {\n\t\t\t\t\t\tterminalId = this.idleTaskTerminals.remove(taskId);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (terminalId) {\n\t\t\t\tterminalToReuse = this.terminals[terminalId];\n\t\t\t}\n\t\t}\n\t\tif (terminalToReuse) {\n\t\t\tif (!this.currentTask.shellLaunchConfig) {\n\t\t\t\tthrow new Error('Task shell launch configuration should not be undefined here.');\n\t\t\t}\n\n\t\t\tterminalToReuse.terminal.reuseTerminal(this.currentTask.shellLaunchConfig);\n\n\t\t\tif (task.command.presentation && task.command.presentation.clear) {\n\t\t\t\tterminalToReuse.terminal.clear();\n\t\t\t}\n\t\t\tthis.terminals[terminalToReuse.terminal.id.toString()].lastTask = taskKey;\n\t\t\treturn [terminalToReuse.terminal, commandExecutable, undefined];\n\t\t}\n\n\t\tlet result: ITerminalInstance | null = null;\n\t\tif (group) {\n\t\t\t// Try to find an existing terminal to split.\n\t\t\t// Even if an existing terminal is found, the split can fail if the terminal width is too small.\n\t\t\tfor (const terminal of values(this.terminals)) {\n\t\t\t\tif (terminal.group === group) {\n\t\t\t\t\tconst originalInstance = terminal.terminal;\n\t\t\t\t\tconst config = this.currentTask.shellLaunchConfig;\n\t\t\t\t\tresult = this.terminalService.splitInstance(originalInstance, config);\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!result) {\n\t\t\t// Either no group is used, no terminal with the group exists or splitting an existing terminal failed.\n\t\t\tresult = this.terminalService.createTerminal(this.currentTask.shellLaunchConfig);\n\t\t}\n\n\t\tconst terminalKey = result.id.toString();\n\t\tresult.onDisposed((terminal) => {\n\t\t\tlet terminalData = this.terminals[terminalKey];\n\t\t\tif (terminalData) {\n\t\t\t\tdelete this.terminals[terminalKey];\n\t\t\t\tdelete this.sameTaskTerminals[terminalData.lastTask];\n\t\t\t\tthis.idleTaskTerminals.delete(terminalData.lastTask);\n\t\t\t\t// Delete the task now as a work around for cases when the onExit isn't fired.\n\t\t\t\t// This can happen if the terminal wasn't shutdown with an \"immediate\" flag and is expected.\n\t\t\t\t// For correct terminal re-use, the task needs to be deleted immediately.\n\t\t\t\t// Note that this shouldn't be a problem anymore since user initiated terminal kills are now immediate.\n\t\t\t\tdelete this.activeTasks[task.getMapKey()];\n\t\t\t}\n\t\t});\n\t\tthis.terminals[terminalKey] = { terminal: result, lastTask: taskKey, group };\n\t\treturn [result, commandExecutable, undefined];\n\t}\n\n\tprivate buildShellCommandLine(platform: Platform.Platform, shellExecutable: string, shellOptions: ShellConfiguration | undefined, command: CommandString, originalCommand: CommandString | undefined, args: CommandString[]): string {\n\t\tlet basename = path.parse(shellExecutable).name.toLowerCase();\n\t\tlet shellQuoteOptions = this.getQuotingOptions(basename, shellOptions);\n\n\t\tfunction needsQuotes(value: string): boolean {\n\t\t\tif (value.length >= 2) {\n\t\t\t\tlet first = value[0] === shellQuoteOptions.strong ? shellQuoteOptions.strong : value[0] === shellQuoteOptions.weak ? shellQuoteOptions.weak : undefined;\n\t\t\t\tif (first === value[value.length - 1]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet quote: string | undefined;\n\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\t// We found the end quote.\n\t\t\t\tlet ch = value[i];\n\t\t\t\tif (ch === quote) {\n\t\t\t\t\tquote = undefined;\n\t\t\t\t} else if (quote !== undefined) {\n\t\t\t\t\t// skip the character. We are quoted.\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ch === shellQuoteOptions.escape) {\n\t\t\t\t\t// Skip the next character\n\t\t\t\t\ti++;\n\t\t\t\t} else if (ch === shellQuoteOptions.strong || ch === shellQuoteOptions.weak) {\n\t\t\t\t\tquote = ch;\n\t\t\t\t} else if (ch === ' ') {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction quote(value: string, kind: ShellQuoting): [string, boolean] {\n\t\t\tif (kind === ShellQuoting.Strong && shellQuoteOptions.strong) {\n\t\t\t\treturn [shellQuoteOptions.strong + value + shellQuoteOptions.strong, true];\n\t\t\t} else if (kind === ShellQuoting.Weak && shellQuoteOptions.weak) {\n\t\t\t\treturn [shellQuoteOptions.weak + value + shellQuoteOptions.weak, true];\n\t\t\t} else if (kind === ShellQuoting.Escape && shellQuoteOptions.escape) {\n\t\t\t\tif (Types.isString(shellQuoteOptions.escape)) {\n\t\t\t\t\treturn [value.replace(/ /g, shellQuoteOptions.escape + ' '), true];\n\t\t\t\t} else {\n\t\t\t\t\tlet buffer: string[] = [];\n\t\t\t\t\tfor (let ch of shellQuoteOptions.escape.charsToEscape) {\n\t\t\t\t\t\tbuffer.push(`\\\\${ch}`);\n\t\t\t\t\t}\n\t\t\t\t\tlet regexp: RegExp = new RegExp('[' + buffer.join(',') + ']', 'g');\n\t\t\t\t\tlet escapeChar = shellQuoteOptions.escape.escapeChar;\n\t\t\t\t\treturn [value.replace(regexp, (match) => escapeChar + match), true];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn [value, false];\n\t\t}\n\n\t\tfunction quoteIfNecessary(value: CommandString): [string, boolean] {\n\t\t\tif (Types.isString(value)) {\n\t\t\t\tif (needsQuotes(value)) {\n\t\t\t\t\treturn quote(value, ShellQuoting.Strong);\n\t\t\t\t} else {\n\t\t\t\t\treturn [value, false];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn quote(value.value, value.quoting);\n\t\t\t}\n\t\t}\n\n\t\t// If we have no args and the command is a string then use the command to stay backwards compatible with the old command line\n\t\t// model. To allow variable resolving with spaces we do continue if the resolved value is different than the original one\n\t\t// and the resolved one needs quoting.\n\t\tif ((!args || args.length === 0) && Types.isString(command) && (command === originalCommand as string || needsQuotes(originalCommand as string))) {\n\t\t\treturn command;\n\t\t}\n\n\t\tlet result: string[] = [];\n\t\tlet commandQuoted = false;\n\t\tlet argQuoted = false;\n\t\tlet value: string;\n\t\tlet quoted: boolean;\n\t\t[value, quoted] = quoteIfNecessary(command);\n\t\tresult.push(value);\n\t\tcommandQuoted = quoted;\n\t\tfor (let arg of args) {\n\t\t\t[value, quoted] = quoteIfNecessary(arg);\n\t\t\tresult.push(value);\n\t\t\targQuoted = argQuoted || quoted;\n\t\t}\n\n\t\tlet commandLine = result.join(' ');\n\t\t// There are special rules quoted command line in cmd.exe\n\t\tif (platform === Platform.Platform.Windows) {\n\t\t\tif (basename === 'cmd' && commandQuoted && argQuoted) {\n\t\t\t\tcommandLine = '\"' + commandLine + '\"';\n\t\t\t} else if (basename === 'powershell' && commandQuoted) {\n\t\t\t\tcommandLine = '& ' + commandLine;\n\t\t\t}\n\t\t}\n\n\t\tif (basename === 'cmd' && platform === Platform.Platform.Windows && commandQuoted && argQuoted) {\n\t\t\tcommandLine = '\"' + commandLine + '\"';\n\t\t}\n\t\treturn commandLine;\n\t}\n\n\tprivate getQuotingOptions(shellBasename: string, shellOptions: ShellConfiguration | undefined): ShellQuotingOptions {\n\t\tif (shellOptions && shellOptions.quoting) {\n\t\t\treturn shellOptions.quoting;\n\t\t}\n\t\treturn TerminalTaskSystem.shellQuotes[shellBasename] || TerminalTaskSystem.osShellQuotes[process.platform];\n\t}\n\n\tprivate collectTaskVariables(variables: Set<string>, task: CustomTask | ContributedTask): void {\n\t\tif (task.command && task.command.name) {\n\t\t\tthis.collectCommandVariables(variables, task.command, task);\n\t\t}\n\t\tthis.collectMatcherVariables(variables, task.configurationProperties.problemMatchers);\n\t}\n\n\tprivate collectCommandVariables(variables: Set<string>, command: CommandConfiguration, task: CustomTask | ContributedTask): void {\n\t\t// The custom execution should have everything it needs already as it provided\n\t\t// the callback.\n\t\tif (command.runtime === RuntimeType.CustomExecution) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (command.name === undefined) {\n\t\t\tthrow new Error('Command name should never be undefined here.');\n\t\t}\n\t\tthis.collectVariables(variables, command.name);\n\t\tif (command.args) {\n\t\t\tcommand.args.forEach(arg => this.collectVariables(variables, arg));\n\t\t}\n\t\t// Try to get a scope.\n\t\tconst scope = (<ExtensionTaskSource>task._source).scope;\n\t\tif (scope !== TaskScope.Global) {\n\t\t\tvariables.add('${workspaceFolder}');\n\t\t}\n\t\tif (command.options) {\n\t\t\tlet options = command.options;\n\t\t\tif (options.cwd) {\n\t\t\t\tthis.collectVariables(variables, options.cwd);\n\t\t\t}\n\t\t\tconst optionsEnv = options.env;\n\t\t\tif (optionsEnv) {\n\t\t\t\tObject.keys(optionsEnv).forEach((key) => {\n\t\t\t\t\tlet value: any = optionsEnv[key];\n\t\t\t\t\tif (Types.isString(value)) {\n\t\t\t\t\t\tthis.collectVariables(variables, value);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (options.shell) {\n\t\t\t\tif (options.shell.executable) {\n\t\t\t\t\tthis.collectVariables(variables, options.shell.executable);\n\t\t\t\t}\n\t\t\t\tif (options.shell.args) {\n\t\t\t\t\toptions.shell.args.forEach(arg => this.collectVariables(variables, arg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate collectMatcherVariables(variables: Set<string>, values: Array<string | ProblemMatcher> | undefined): void {\n\t\tif (values === undefined || values === null || values.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tvalues.forEach((value) => {\n\t\t\tlet matcher: ProblemMatcher;\n\t\t\tif (Types.isString(value)) {\n\t\t\t\tif (value[0] === '$') {\n\t\t\t\t\tmatcher = ProblemMatcherRegistry.get(value.substring(1));\n\t\t\t\t} else {\n\t\t\t\t\tmatcher = ProblemMatcherRegistry.get(value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmatcher = value;\n\t\t\t}\n\t\t\tif (matcher && matcher.filePrefix) {\n\t\t\t\tthis.collectVariables(variables, matcher.filePrefix);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate collectVariables(variables: Set<string>, value: string | CommandString): void {\n\t\tlet string: string = Types.isString(value) ? value : value.value;\n\t\tlet r = /\\$\\{(.*?)\\}/g;\n\t\tlet matches: RegExpExecArray | null;\n\t\tdo {\n\t\t\tmatches = r.exec(string);\n\t\t\tif (matches) {\n\t\t\t\tvariables.add(matches[0]);\n\t\t\t}\n\t\t} while (matches);\n\t}\n\n\tprivate resolveCommandAndArgs(resolver: VariableResolver, commandConfig: CommandConfiguration): { command: CommandString, args: CommandString[] } {\n\t\t// First we need to use the command args:\n\t\tlet args: CommandString[] = commandConfig.args ? commandConfig.args.slice() : [];\n\t\targs = this.resolveVariables(resolver, args);\n\t\tlet command: CommandString = this.resolveVariable(resolver, commandConfig.name);\n\t\treturn { command, args };\n\t}\n\n\tprivate resolveVariables(resolver: VariableResolver, value: string[]): string[];\n\tprivate resolveVariables(resolver: VariableResolver, value: CommandString[]): CommandString[];\n\tprivate resolveVariables(resolver: VariableResolver, value: CommandString[]): CommandString[] {\n\t\treturn value.map(s => this.resolveVariable(resolver, s));\n\t}\n\n\tprivate resolveMatchers(resolver: VariableResolver, values: Array<string | ProblemMatcher> | undefined): ProblemMatcher[] {\n\t\tif (values === undefined || values === null || values.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\tlet result: ProblemMatcher[] = [];\n\t\tvalues.forEach((value) => {\n\t\t\tlet matcher: ProblemMatcher;\n\t\t\tif (Types.isString(value)) {\n\t\t\t\tif (value[0] === '$') {\n\t\t\t\t\tmatcher = ProblemMatcherRegistry.get(value.substring(1));\n\t\t\t\t} else {\n\t\t\t\t\tmatcher = ProblemMatcherRegistry.get(value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmatcher = value;\n\t\t\t}\n\t\t\tif (!matcher) {\n\t\t\t\tthis.appendOutput(nls.localize('unkownProblemMatcher', 'Problem matcher {0} can\\'t be resolved. The matcher will be ignored'));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet taskSystemInfo: TaskSystemInfo | undefined = resolver.taskSystemInfo;\n\t\t\tlet hasFilePrefix = matcher.filePrefix !== undefined;\n\t\t\tlet hasUriProvider = taskSystemInfo !== undefined && taskSystemInfo.uriProvider !== undefined;\n\t\t\tif (!hasFilePrefix && !hasUriProvider) {\n\t\t\t\tresult.push(matcher);\n\t\t\t} else {\n\t\t\t\tlet copy = Objects.deepClone(matcher);\n\t\t\t\tif (hasUriProvider && (taskSystemInfo !== undefined)) {\n\t\t\t\t\tcopy.uriProvider = taskSystemInfo.uriProvider;\n\t\t\t\t}\n\t\t\t\tif (hasFilePrefix) {\n\t\t\t\t\tcopy.filePrefix = this.resolveVariable(resolver, copy.filePrefix);\n\t\t\t\t}\n\t\t\t\tresult.push(copy);\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}\n\n\tprivate resolveVariable(resolver: VariableResolver, value: string | undefined): string;\n\tprivate resolveVariable(resolver: VariableResolver, value: CommandString | undefined): CommandString;\n\tprivate resolveVariable(resolver: VariableResolver, value: CommandString | undefined): CommandString {\n\t\t// TODO@Dirk Task.getWorkspaceFolder should return a WorkspaceFolder that is defined in workspace.ts\n\t\tif (Types.isString(value)) {\n\t\t\treturn resolver.resolve(value);\n\t\t} else if (value !== undefined) {\n\t\t\treturn {\n\t\t\t\tvalue: resolver.resolve(value.value),\n\t\t\t\tquoting: value.quoting\n\t\t\t};\n\t\t} else { // This should never happen\n\t\t\tthrow new Error('Should never try to resolve undefined.');\n\t\t}\n\t}\n\n\tprivate resolveOptions(resolver: VariableResolver, options: CommandOptions | undefined): CommandOptions {\n\t\tif (options === undefined || options === null) {\n\t\t\treturn { cwd: this.resolveVariable(resolver, '${workspaceFolder}') };\n\t\t}\n\t\tlet result: CommandOptions = Types.isString(options.cwd)\n\t\t\t? { cwd: this.resolveVariable(resolver, options.cwd) }\n\t\t\t: { cwd: this.resolveVariable(resolver, '${workspaceFolder}') };\n\t\tif (options.env) {\n\t\t\tresult.env = Object.create(null);\n\t\t\tObject.keys(options.env).forEach((key) => {\n\t\t\t\tlet value: any = options.env![key];\n\t\t\t\tif (Types.isString(value)) {\n\t\t\t\t\tresult.env![key] = this.resolveVariable(resolver, value);\n\t\t\t\t} else {\n\t\t\t\t\tresult.env![key] = value.toString();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate registerLinkMatchers(terminal: ITerminalInstance, problemMatchers: ProblemMatcher[]): number[] {\n\t\tlet result: number[] = [];\n\t\t/*\n\t\tlet handlePattern = (matcher: ProblemMatcher, pattern: ProblemPattern): void => {\n\t\t\tif (pattern.regexp instanceof RegExp && Types.isNumber(pattern.file)) {\n\t\t\t\tresult.push(terminal.registerLinkMatcher(pattern.regexp, (match: string) => {\n\t\t\t\t\tlet resource: URI = getResource(match, matcher);\n\t\t\t\t\tif (resource) {\n\t\t\t\t\t\tthis.workbenchEditorService.openEditor({\n\t\t\t\t\t\t\tresource: resource\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}, 0));\n\t\t\t}\n\t\t};\n\n\t\tfor (let problemMatcher of problemMatchers) {\n\t\t\tif (Array.isArray(problemMatcher.pattern)) {\n\t\t\t\tfor (let pattern of problemMatcher.pattern) {\n\t\t\t\t\thandlePattern(problemMatcher, pattern);\n\t\t\t\t}\n\t\t\t} else if (problemMatcher.pattern) {\n\t\t\t\thandlePattern(problemMatcher, problemMatcher.pattern);\n\t\t\t}\n\t\t}\n\t\t*/\n\t\treturn result;\n\t}\n\n\tprivate static WellKnowCommands: IStringDictionary<boolean> = {\n\t\t'ant': true,\n\t\t'cmake': true,\n\t\t'eslint': true,\n\t\t'gradle': true,\n\t\t'grunt': true,\n\t\t'gulp': true,\n\t\t'jake': true,\n\t\t'jenkins': true,\n\t\t'jshint': true,\n\t\t'make': true,\n\t\t'maven': true,\n\t\t'msbuild': true,\n\t\t'msc': true,\n\t\t'nmake': true,\n\t\t'npm': true,\n\t\t'rake': true,\n\t\t'tsc': true,\n\t\t'xbuild': true\n\t};\n\n\tpublic getSanitizedCommand(cmd: string): string {\n\t\tlet result = cmd.toLowerCase();\n\t\tlet index = result.lastIndexOf(path.sep);\n\t\tif (index !== -1) {\n\t\t\tresult = result.substring(index + 1);\n\t\t}\n\t\tif (TerminalTaskSystem.WellKnowCommands[result]) {\n\t\t\treturn result;\n\t\t}\n\t\treturn 'other';\n\t}\n\n\tprivate appendOutput(output: string): void {\n\t\tconst outputChannel = this.outputService.getChannel(this.outputChannelId);\n\t\tif (outputChannel) {\n\t\t\toutputChannel.append(output);\n\t\t}\n\t}\n}\n"]}]}