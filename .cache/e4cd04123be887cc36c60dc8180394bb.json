{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/decorators.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/decorators.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function createDecorator(mapFn) {\n        return (target, key, descriptor) => {\n            let fnKey = null;\n            let fn = null;\n            if (typeof descriptor.value === 'function') {\n                fnKey = 'value';\n                fn = descriptor.value;\n            }\n            else if (typeof descriptor.get === 'function') {\n                fnKey = 'get';\n                fn = descriptor.get;\n            }\n            if (!fn) {\n                throw new Error('not supported');\n            }\n            descriptor[fnKey] = mapFn(fn, key);\n        };\n    }\n    exports.createDecorator = createDecorator;\n    function memoize(target, key, descriptor) {\n        let fnKey = null;\n        let fn = null;\n        if (typeof descriptor.value === 'function') {\n            fnKey = 'value';\n            fn = descriptor.value;\n            if (fn.length !== 0) {\n                console.warn('Memoize should only be used in functions with zero parameters');\n            }\n        }\n        else if (typeof descriptor.get === 'function') {\n            fnKey = 'get';\n            fn = descriptor.get;\n        }\n        if (!fn) {\n            throw new Error('not supported');\n        }\n        const memoizeKey = `$memoize$${key}`;\n        descriptor[fnKey] = function (...args) {\n            if (!this.hasOwnProperty(memoizeKey)) {\n                Object.defineProperty(this, memoizeKey, {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: fn.apply(this, args)\n                });\n            }\n            return this[memoizeKey];\n        };\n    }\n    exports.memoize = memoize;\n    function debounce(delay, reducer, initialValueProvider) {\n        return createDecorator((fn, key) => {\n            const timerKey = `$debounce$${key}`;\n            const resultKey = `$debounce$result$${key}`;\n            return function (...args) {\n                if (!this[resultKey]) {\n                    this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n                }\n                clearTimeout(this[timerKey]);\n                if (reducer) {\n                    this[resultKey] = reducer(this[resultKey], ...args);\n                    args = [this[resultKey]];\n                }\n                this[timerKey] = setTimeout(() => {\n                    fn.apply(this, args);\n                    this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n                }, delay);\n            };\n        });\n    }\n    exports.debounce = debounce;\n});\n",null]}