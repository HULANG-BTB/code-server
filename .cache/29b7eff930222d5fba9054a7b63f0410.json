{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/remoteFileService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/remoteFileService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/arrays\", \"vs/base/common/lifecycle\", \"vs/base/common/map\", \"vs/base/common/network\", \"vs/base/common/resources\", \"vs/base/node/encoding\", \"vs/editor/common/services/resourceConfiguration\", \"vs/nls\", \"vs/platform/configuration/common/configuration\", \"vs/platform/environment/common/environment\", \"vs/platform/files/common/files\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/platform/notification/common/notification\", \"vs/platform/storage/common/storage\", \"vs/platform/workspace/common/workspace\", \"vs/workbench/services/files/node/fileService\", \"vs/workbench/services/files/node/streams\", \"vs/platform/instantiation/common/extensions\"], function (require, exports, arrays_1, lifecycle_1, map_1, network_1, resources, encoding_1, resourceConfiguration_1, nls_1, configuration_1, environment_1, files_1, lifecycle_2, notification_1, storage_1, workspace_1, fileService_1, streams_1, extensions_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class TypeOnlyStat {\n        constructor(type) {\n            this.type = type;\n            // todo@remote -> make a getter and warn when\n            // being used in development.\n            this.mtime = 0;\n            this.ctime = 0;\n            this.size = 0;\n            //\n        }\n    }\n    function toIFileStat(provider, tuple, recurse) {\n        const [resource, stat] = tuple;\n        const fileStat = {\n            resource,\n            name: resources.basename(resource),\n            isDirectory: (stat.type & files_1.FileType.Directory) !== 0,\n            isSymbolicLink: (stat.type & files_1.FileType.SymbolicLink) !== 0,\n            isReadonly: !!(provider.capabilities & files_1.FileSystemProviderCapabilities.Readonly),\n            mtime: stat.mtime,\n            size: stat.size,\n            etag: files_1.etag(stat.mtime, stat.size),\n        };\n        if (fileStat.isDirectory) {\n            if (recurse && recurse([resource, stat])) {\n                // dir -> resolve\n                return provider.readdir(resource).then(entries => {\n                    // resolve children if requested\n                    return Promise.all(entries.map(tuple => {\n                        const [name, type] = tuple;\n                        const childResource = resources.joinPath(resource, name);\n                        return toIFileStat(provider, [childResource, new TypeOnlyStat(type)], recurse);\n                    })).then(children => {\n                        fileStat.children = children;\n                        return fileStat;\n                    });\n                });\n            }\n        }\n        // file or (un-resolved) dir\n        return Promise.resolve(fileStat);\n    }\n    function toDeepIFileStat(provider, tuple, to) {\n        const trie = map_1.TernarySearchTree.forPaths();\n        trie.set(tuple[0].toString(), true);\n        if (arrays_1.isNonEmptyArray(to)) {\n            to.forEach(uri => trie.set(uri.toString(), true));\n        }\n        return toIFileStat(provider, tuple, candidate => {\n            return Boolean(trie.findSuperstr(candidate[0].toString()) || trie.get(candidate[0].toString()));\n        });\n    }\n    exports.toDeepIFileStat = toDeepIFileStat;\n    let WorkspaceWatchLogic = class WorkspaceWatchLogic extends lifecycle_1.Disposable {\n        constructor(_fileService, _configurationService, _contextService) {\n            super();\n            this._fileService = _fileService;\n            this._configurationService = _configurationService;\n            this._contextService = _contextService;\n            this._watches = new Map();\n            this._refresh();\n            this._register(this._contextService.onDidChangeWorkspaceFolders(e => {\n                for (const removed of e.removed) {\n                    this._unwatchWorkspace(removed.uri);\n                }\n                for (const added of e.added) {\n                    this._watchWorkspace(added.uri);\n                }\n            }));\n            this._register(this._contextService.onDidChangeWorkbenchState(e => {\n                this._refresh();\n            }));\n            this._register(this._configurationService.onDidChangeConfiguration(e => {\n                if (e.affectsConfiguration('files.watcherExclude')) {\n                    this._refresh();\n                }\n            }));\n        }\n        dispose() {\n            this._unwatchWorkspaces();\n            super.dispose();\n        }\n        _refresh() {\n            this._unwatchWorkspaces();\n            for (const folder of this._contextService.getWorkspace().folders) {\n                if (folder.uri.scheme !== network_1.Schemas.file) {\n                    this._watchWorkspace(folder.uri);\n                }\n            }\n        }\n        _watchWorkspace(resource) {\n            let excludes = [];\n            let config = this._configurationService.getValue({ resource });\n            if (config.files && config.files.watcherExclude) {\n                for (const key in config.files.watcherExclude) {\n                    if (config.files.watcherExclude[key] === true) {\n                        excludes.push(key);\n                    }\n                }\n            }\n            this._watches.set(resource.toString(), resource);\n            this._fileService.watchFileChanges(resource, { recursive: true, excludes });\n        }\n        _unwatchWorkspace(resource) {\n            if (this._watches.has(resource.toString())) {\n                this._fileService.unwatchFileChanges(resource);\n                this._watches.delete(resource.toString());\n            }\n        }\n        _unwatchWorkspaces() {\n            this._watches.forEach(uri => this._fileService.unwatchFileChanges(uri));\n            this._watches.clear();\n        }\n    };\n    WorkspaceWatchLogic = __decorate([\n        __param(1, configuration_1.IConfigurationService),\n        __param(2, workspace_1.IWorkspaceContextService)\n    ], WorkspaceWatchLogic);\n    let RemoteFileService = class RemoteFileService extends fileService_1.FileService {\n        constructor(_fileService, storageService, environmentService, configurationService, contextService, lifecycleService, notificationService, textResourceConfigurationService) {\n            super(contextService, environmentService, textResourceConfigurationService, configurationService, lifecycleService, storageService, notificationService);\n            this._fileService = _fileService;\n            this._activeWatches = new Map();\n            this._provider = new Map();\n            this._register(new WorkspaceWatchLogic(this, configurationService, contextService));\n        }\n        registerProvider(scheme, provider) {\n            if (this._provider.has(scheme)) {\n                throw new Error('a provider for that scheme is already registered');\n            }\n            this._provider.set(scheme, provider);\n            return {\n                dispose: () => {\n                    this._provider.delete(scheme);\n                }\n            };\n        }\n        // --- stat\n        _withProvider(resource) {\n            if (!resources.isAbsolutePath(resource)) {\n                throw new files_1.FileOperationError(nls_1.localize('invalidPath', \"The path of resource '{0}' must be absolute\", resource.toString(true)), files_1.FileOperationResult.FILE_INVALID_PATH);\n            }\n            return Promise.all([\n                this._fileService.activateProvider(resource.scheme)\n            ]).then(() => {\n                const provider = this._provider.get(resource.scheme);\n                if (!provider) {\n                    const err = new Error();\n                    err.name = 'ENOPRO';\n                    err.message = `no provider for ${resource.toString()}`;\n                    throw err;\n                }\n                return provider;\n            });\n        }\n        resolveFile(resource, options) {\n            if (resource.scheme === network_1.Schemas.file) {\n                return super.resolveFile(resource, options);\n            }\n            else {\n                return this._doResolveFiles([{ resource, options }]).then(data => {\n                    if (data.length !== 1 || !data[0].success) {\n                        throw new files_1.FileOperationError(nls_1.localize('fileNotFoundError', \"File not found ({0})\", resource.toString(true)), files_1.FileOperationResult.FILE_NOT_FOUND);\n                    }\n                    else {\n                        return data[0].stat;\n                    }\n                });\n            }\n        }\n        _doResolveFiles(toResolve) {\n            return this._withProvider(toResolve[0].resource).then(provider => {\n                let result = [];\n                let promises = toResolve.map((item, idx) => {\n                    return provider.stat(item.resource).then(stat => {\n                        return toDeepIFileStat(provider, [item.resource, stat], item.options && item.options.resolveTo).then(fileStat => {\n                            result[idx] = { stat: fileStat, success: true };\n                        });\n                    }, _err => {\n                        result[idx] = { stat: undefined, success: false };\n                    });\n                });\n                return Promise.all(promises).then(() => result);\n            });\n        }\n        // --- resolve\n        resolveContent(resource, options) {\n            if (resource.scheme === network_1.Schemas.file) {\n                return super.resolveContent(resource, options);\n            }\n            else {\n                return this._readFile(resource, options).then(RemoteFileService._asContent);\n            }\n        }\n        resolveStreamContent(resource, options) {\n            if (resource.scheme === network_1.Schemas.file) {\n                return super.resolveStreamContent(resource, options);\n            }\n            else {\n                return this._readFile(resource, options);\n            }\n        }\n        _readFile(resource, options = Object.create(null)) {\n            return this._withProvider(resource).then(provider => {\n                return this.resolveFile(resource).then(fileStat => {\n                    if (fileStat.isDirectory) {\n                        // todo@joh cannot copy a folder\n                        // https://github.com/Microsoft/vscode/issues/41547\n                        throw new files_1.FileOperationError(nls_1.localize('fileIsDirectoryError', \"File is directory\"), files_1.FileOperationResult.FILE_IS_DIRECTORY, options);\n                    }\n                    if (typeof options.etag === 'string' && fileStat.etag === options.etag) {\n                        throw new files_1.FileOperationError(nls_1.localize('fileNotModifiedError', \"File not modified since\"), files_1.FileOperationResult.FILE_NOT_MODIFIED_SINCE, options);\n                    }\n                    const decodeStreamOpts = {\n                        guessEncoding: options.autoGuessEncoding,\n                        overwriteEncoding: detected => {\n                            return this.encoding.getReadEncoding(resource, options, { encoding: detected, seemsBinary: false });\n                        }\n                    };\n                    const readable = streams_1.createReadableOfProvider(provider, resource, options.position || 0);\n                    return encoding_1.toDecodeStream(readable, decodeStreamOpts).then(data => {\n                        if (options.acceptTextOnly && data.detected.seemsBinary) {\n                            return Promise.reject(new files_1.FileOperationError(nls_1.localize('fileBinaryError', \"File seems to be binary and cannot be opened as text\"), files_1.FileOperationResult.FILE_IS_BINARY, options));\n                        }\n                        return {\n                            encoding: data.detected.encoding,\n                            value: data.stream,\n                            resource: fileStat.resource,\n                            name: fileStat.name,\n                            etag: fileStat.etag,\n                            mtime: fileStat.mtime,\n                            isReadonly: fileStat.isReadonly,\n                            size: fileStat.size\n                        };\n                    });\n                });\n            });\n        }\n        // --- saving\n        static _mkdirp(provider, directory) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let basenames = [];\n                while (directory.path !== '/') {\n                    try {\n                        let stat = yield provider.stat(directory);\n                        if ((stat.type & files_1.FileType.Directory) === 0) {\n                            throw new Error(`${directory.toString()} is not a directory`);\n                        }\n                        break; // we have hit a directory -> good\n                    }\n                    catch (e) {\n                        // ENOENT\n                        basenames.push(resources.basename(directory));\n                        directory = resources.dirname(directory);\n                    }\n                }\n                for (let i = basenames.length - 1; i >= 0; i--) {\n                    directory = resources.joinPath(directory, basenames[i]);\n                    yield provider.mkdir(directory);\n                }\n            });\n        }\n        static _throwIfFileSystemIsReadonly(provider) {\n            if (provider.capabilities & files_1.FileSystemProviderCapabilities.Readonly) {\n                throw new files_1.FileOperationError(nls_1.localize('err.readonly', \"Resource can not be modified.\"), files_1.FileOperationResult.FILE_PERMISSION_DENIED);\n            }\n            return provider;\n        }\n        createFile(resource, content, options) {\n            if (resource.scheme === network_1.Schemas.file) {\n                return super.createFile(resource, content, options);\n            }\n            else {\n                return this._withProvider(resource).then(RemoteFileService._throwIfFileSystemIsReadonly).then(provider => {\n                    return RemoteFileService._mkdirp(provider, resources.dirname(resource)).then(() => {\n                        const { encoding } = this.encoding.getWriteEncoding(resource);\n                        return this._writeFile(provider, resource, new files_1.StringSnapshot(content || ''), encoding, { create: true, overwrite: Boolean(options && options.overwrite) });\n                    });\n                }).then(fileStat => {\n                    this._onAfterOperation.fire(new files_1.FileOperationEvent(resource, files_1.FileOperation.CREATE, fileStat));\n                    return fileStat;\n                }, err => {\n                    const message = nls_1.localize('err.create', \"Failed to create file {0}\", resource.toString(false));\n                    const result = files_1.toFileOperationResult(err);\n                    throw new files_1.FileOperationError(message, result, options);\n                });\n            }\n        }\n        updateContent(resource, value, options) {\n            if (resource.scheme === network_1.Schemas.file) {\n                return super.updateContent(resource, value, options);\n            }\n            else {\n                return this._withProvider(resource).then(RemoteFileService._throwIfFileSystemIsReadonly).then(provider => {\n                    return RemoteFileService._mkdirp(provider, resources.dirname(resource)).then(() => {\n                        const snapshot = typeof value === 'string' ? new files_1.StringSnapshot(value) : value;\n                        return this._writeFile(provider, resource, snapshot, options && options.encoding, { create: true, overwrite: true });\n                    });\n                });\n            }\n        }\n        _writeFile(provider, resource, snapshot, preferredEncoding = undefined, options) {\n            const readable = streams_1.createReadableOfSnapshot(snapshot);\n            const { encoding, hasBOM } = this.encoding.getWriteEncoding(resource, preferredEncoding);\n            const encoder = encoding_1.encodeStream(encoding, { addBOM: hasBOM });\n            const target = streams_1.createWritableOfProvider(provider, resource, options);\n            return new Promise((resolve, reject) => {\n                readable.pipe(encoder).pipe(target);\n                target.once('error', err => reject(err));\n                target.once('finish', (_) => resolve(undefined));\n            }).then(_ => {\n                return this.resolveFile(resource, { resolveMetadata: true });\n            });\n        }\n        static _asContent(content) {\n            return new Promise((resolve, reject) => {\n                let result = {\n                    value: '',\n                    encoding: content.encoding,\n                    etag: content.etag,\n                    size: content.size,\n                    mtime: content.mtime,\n                    name: content.name,\n                    resource: content.resource,\n                    isReadonly: content.isReadonly\n                };\n                content.value.on('data', chunk => result.value += chunk);\n                content.value.on('error', reject);\n                content.value.on('end', () => resolve(result));\n            });\n        }\n        watchFileChanges(resource, opts = { recursive: false, excludes: [] }) {\n            if (resource.scheme === network_1.Schemas.file) {\n                return super.watchFileChanges(resource);\n            }\n            const key = resource.toString();\n            const entry = this._activeWatches.get(key);\n            if (entry) {\n                entry.count += 1;\n                return;\n            }\n            this._activeWatches.set(key, {\n                count: 1,\n                unwatch: this._withProvider(resource).then(provider => {\n                    return provider.watch(resource, opts);\n                }, _err => {\n                    return { dispose() { } };\n                })\n            });\n        }\n        unwatchFileChanges(resource) {\n            if (resource.scheme === network_1.Schemas.file) {\n                return super.unwatchFileChanges(resource);\n            }\n            let entry = this._activeWatches.get(resource.toString());\n            if (entry && --entry.count === 0) {\n                entry.unwatch.then(lifecycle_1.dispose);\n                this._activeWatches.delete(resource.toString());\n            }\n        }\n    };\n    RemoteFileService = __decorate([\n        __param(0, files_1.IFileService),\n        __param(1, storage_1.IStorageService),\n        __param(2, environment_1.IEnvironmentService),\n        __param(3, configuration_1.IConfigurationService),\n        __param(4, workspace_1.IWorkspaceContextService),\n        __param(5, lifecycle_2.ILifecycleService),\n        __param(6, notification_1.INotificationService),\n        __param(7, resourceConfiguration_1.ITextResourceConfigurationService)\n    ], RemoteFileService);\n    exports.RemoteFileService = RemoteFileService;\n    extensions_1.registerSingleton(files_1.ILegacyFileService, RemoteFileService);\n});\n",null]}