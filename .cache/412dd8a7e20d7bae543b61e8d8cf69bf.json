{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/common/taskConfiguration.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/common/taskConfiguration.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar nls = require(\"vs/nls\");\nvar Objects = require(\"vs/base/common/objects\");\nvar platform_1 = require(\"vs/base/common/platform\");\nvar Types = require(\"vs/base/common/types\");\nvar UUID = require(\"vs/base/common/uuid\");\nvar problemMatcher_1 = require(\"vs/workbench/contrib/tasks/common/problemMatcher\");\nvar Tasks = require(\"./tasks\");\nvar taskDefinitionRegistry_1 = require(\"./taskDefinitionRegistry\");\nvar ShellQuoting;\n(function (ShellQuoting) {\n    /**\n     * Default is character escaping.\n     */\n    ShellQuoting[ShellQuoting[\"escape\"] = 1] = \"escape\";\n    /**\n     * Default is strong quoting\n     */\n    ShellQuoting[ShellQuoting[\"strong\"] = 2] = \"strong\";\n    /**\n     * Default is weak quoting.\n     */\n    ShellQuoting[ShellQuoting[\"weak\"] = 3] = \"weak\";\n})(ShellQuoting = exports.ShellQuoting || (exports.ShellQuoting = {}));\nvar TaskIdentifier;\n(function (TaskIdentifier) {\n    function is(value) {\n        var candidate = value;\n        return candidate !== undefined && Types.isString(value.type);\n    }\n    TaskIdentifier.is = is;\n})(TaskIdentifier = exports.TaskIdentifier || (exports.TaskIdentifier = {}));\nvar CommandString;\n(function (CommandString) {\n    function value(value) {\n        if (Types.isString(value)) {\n            return value;\n        }\n        else if (Types.isStringArray(value)) {\n            return value.join(' ');\n        }\n        else {\n            if (Types.isString(value.value)) {\n                return value.value;\n            }\n            else {\n                return value.value.join(' ');\n            }\n        }\n    }\n    CommandString.value = value;\n})(CommandString = exports.CommandString || (exports.CommandString = {}));\nvar ProblemMatcherKind;\n(function (ProblemMatcherKind) {\n    ProblemMatcherKind[ProblemMatcherKind[\"Unknown\"] = 0] = \"Unknown\";\n    ProblemMatcherKind[ProblemMatcherKind[\"String\"] = 1] = \"String\";\n    ProblemMatcherKind[ProblemMatcherKind[\"ProblemMatcher\"] = 2] = \"ProblemMatcher\";\n    ProblemMatcherKind[ProblemMatcherKind[\"Array\"] = 3] = \"Array\";\n})(ProblemMatcherKind || (ProblemMatcherKind = {}));\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nfunction assignProperty(target, source, key) {\n    var sourceAtKey = source[key];\n    if (sourceAtKey !== undefined) {\n        target[key] = sourceAtKey;\n    }\n}\nfunction fillProperty(target, source, key) {\n    var sourceAtKey = source[key];\n    if (target[key] === undefined && sourceAtKey !== undefined) {\n        target[key] = sourceAtKey;\n    }\n}\nfunction _isEmpty(value, properties) {\n    if (value === undefined || value === null || properties === undefined) {\n        return true;\n    }\n    for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {\n        var meta = properties_1[_i];\n        var property = value[meta.property];\n        if (property !== undefined && property !== null) {\n            if (meta.type !== undefined && !meta.type.isEmpty(property)) {\n                return false;\n            }\n            else if (!Array.isArray(property) || property.length > 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction _assignProperties(target, source, properties) {\n    if (_isEmpty(source, properties)) {\n        return target;\n    }\n    if (_isEmpty(target, properties)) {\n        return source;\n    }\n    for (var _i = 0, properties_2 = properties; _i < properties_2.length; _i++) {\n        var meta = properties_2[_i];\n        var property = meta.property;\n        var value = void 0;\n        if (meta.type !== undefined) {\n            value = meta.type.assignProperties(target[property], source[property]);\n        }\n        else {\n            value = source[property];\n        }\n        if (value !== undefined && value !== null) {\n            target[property] = value;\n        }\n    }\n    return target;\n}\nfunction _fillProperties(target, source, properties) {\n    if (_isEmpty(source, properties)) {\n        return target;\n    }\n    if (_isEmpty(target, properties)) {\n        return source;\n    }\n    for (var _i = 0, _a = properties; _i < _a.length; _i++) {\n        var meta = _a[_i];\n        var property = meta.property;\n        var value = void 0;\n        if (meta.type) {\n            value = meta.type.fillProperties(target[property], source[property]);\n        }\n        else if (target[property] === undefined) {\n            value = source[property];\n        }\n        if (value !== undefined && value !== null) {\n            target[property] = value;\n        }\n    }\n    return target;\n}\nfunction _fillDefaults(target, defaults, properties, context) {\n    if (target && Object.isFrozen(target)) {\n        return target;\n    }\n    if (target === undefined || target === null) {\n        if (defaults !== undefined && defaults !== null) {\n            return Objects.deepClone(defaults);\n        }\n        else {\n            return undefined;\n        }\n    }\n    for (var _i = 0, properties_3 = properties; _i < properties_3.length; _i++) {\n        var meta = properties_3[_i];\n        var property = meta.property;\n        if (target[property] !== undefined) {\n            continue;\n        }\n        var value = void 0;\n        if (meta.type) {\n            value = meta.type.fillDefaults(target[property], context);\n        }\n        else {\n            value = defaults[property];\n        }\n        if (value !== undefined && value !== null) {\n            target[property] = value;\n        }\n    }\n    return target;\n}\nfunction _freeze(target, properties) {\n    if (target === undefined || target === null) {\n        return undefined;\n    }\n    if (Object.isFrozen(target)) {\n        return target;\n    }\n    for (var _i = 0, properties_4 = properties; _i < properties_4.length; _i++) {\n        var meta = properties_4[_i];\n        if (meta.type) {\n            var value = target[meta.property];\n            if (value) {\n                meta.type.freeze(value);\n            }\n        }\n    }\n    Object.freeze(target);\n    return target;\n}\nvar RunOnOptions;\n(function (RunOnOptions) {\n    function fromString(value) {\n        if (!value) {\n            return Tasks.RunOnOptions.default;\n        }\n        switch (value.toLowerCase()) {\n            case 'folderopen':\n                return Tasks.RunOnOptions.folderOpen;\n            case 'default':\n            default:\n                return Tasks.RunOnOptions.default;\n        }\n    }\n    RunOnOptions.fromString = fromString;\n})(RunOnOptions = exports.RunOnOptions || (exports.RunOnOptions = {}));\nvar RunOptions;\n(function (RunOptions) {\n    function fromConfiguration(value) {\n        return {\n            reevaluateOnRerun: value ? value.reevaluateOnRerun : true,\n            runOn: value ? RunOnOptions.fromString(value.runOn) : Tasks.RunOnOptions.default\n        };\n    }\n    RunOptions.fromConfiguration = fromConfiguration;\n})(RunOptions = exports.RunOptions || (exports.RunOptions = {}));\nvar ParseContext = /** @class */ (function () {\n    function ParseContext() {\n    }\n    return ParseContext;\n}());\nvar ShellConfiguration;\n(function (ShellConfiguration) {\n    var properties = [{ property: 'executable' }, { property: 'args' }, { property: 'quoting' }];\n    function is(value) {\n        var candidate = value;\n        return candidate && (Types.isString(candidate.executable) || Types.isStringArray(candidate.args));\n    }\n    ShellConfiguration.is = is;\n    function from(config, context) {\n        if (!is(config)) {\n            return undefined;\n        }\n        var result = {};\n        if (config.executable !== undefined) {\n            result.executable = config.executable;\n        }\n        if (config.args !== undefined) {\n            result.args = config.args.slice();\n        }\n        if (config.quoting !== undefined) {\n            result.quoting = Objects.deepClone(config.quoting);\n        }\n        return result;\n    }\n    ShellConfiguration.from = from;\n    function isEmpty(value) {\n        return _isEmpty(value, properties);\n    }\n    ShellConfiguration.isEmpty = isEmpty;\n    function assignProperties(target, source) {\n        return _assignProperties(target, source, properties);\n    }\n    ShellConfiguration.assignProperties = assignProperties;\n    function fillProperties(target, source) {\n        return _fillProperties(target, source, properties);\n    }\n    ShellConfiguration.fillProperties = fillProperties;\n    function fillDefaults(value, context) {\n        return value;\n    }\n    ShellConfiguration.fillDefaults = fillDefaults;\n    function freeze(value) {\n        if (!value) {\n            return undefined;\n        }\n        return Object.freeze(value);\n    }\n    ShellConfiguration.freeze = freeze;\n})(ShellConfiguration || (ShellConfiguration = {}));\nvar CommandOptions;\n(function (CommandOptions) {\n    var properties = [{ property: 'cwd' }, { property: 'env' }, { property: 'shell', type: ShellConfiguration }];\n    var defaults = { cwd: '${workspaceFolder}' };\n    function from(options, context) {\n        var result = {};\n        if (options.cwd !== undefined) {\n            if (Types.isString(options.cwd)) {\n                result.cwd = options.cwd;\n            }\n            else {\n                context.taskLoadIssues.push(nls.localize('ConfigurationParser.invalidCWD', 'Warning: options.cwd must be of type string. Ignoring value {0}\\n', options.cwd));\n            }\n        }\n        if (options.env !== undefined) {\n            result.env = Objects.deepClone(options.env);\n        }\n        result.shell = ShellConfiguration.from(options.shell, context);\n        return isEmpty(result) ? undefined : result;\n    }\n    CommandOptions.from = from;\n    function isEmpty(value) {\n        return _isEmpty(value, properties);\n    }\n    CommandOptions.isEmpty = isEmpty;\n    function assignProperties(target, source) {\n        if ((source === undefined) || isEmpty(source)) {\n            return target;\n        }\n        if ((target === undefined) || isEmpty(target)) {\n            return source;\n        }\n        assignProperty(target, source, 'cwd');\n        if (target.env === undefined) {\n            target.env = source.env;\n        }\n        else if (source.env !== undefined) {\n            var env_1 = Object.create(null);\n            if (target.env !== undefined) {\n                Object.keys(target.env).forEach(function (key) { return env_1[key] = target.env[key]; });\n            }\n            if (source.env !== undefined) {\n                Object.keys(source.env).forEach(function (key) { return env_1[key] = source.env[key]; });\n            }\n            target.env = env_1;\n        }\n        target.shell = ShellConfiguration.assignProperties(target.shell, source.shell);\n        return target;\n    }\n    CommandOptions.assignProperties = assignProperties;\n    function fillProperties(target, source) {\n        return _fillProperties(target, source, properties);\n    }\n    CommandOptions.fillProperties = fillProperties;\n    function fillDefaults(value, context) {\n        return _fillDefaults(value, defaults, properties, context);\n    }\n    CommandOptions.fillDefaults = fillDefaults;\n    function freeze(value) {\n        return _freeze(value, properties);\n    }\n    CommandOptions.freeze = freeze;\n})(CommandOptions || (CommandOptions = {}));\nvar CommandConfiguration;\n(function (CommandConfiguration) {\n    var PresentationOptions;\n    (function (PresentationOptions) {\n        var properties = [{ property: 'echo' }, { property: 'reveal' }, { property: 'focus' }, { property: 'panel' }, { property: 'showReuseMessage' }, { property: 'clear' }, { property: 'group' }];\n        function from(config, context) {\n            var echo;\n            var reveal;\n            var focus;\n            var panel;\n            var showReuseMessage;\n            var clear;\n            var group;\n            var hasProps = false;\n            if (Types.isBoolean(config.echoCommand)) {\n                echo = config.echoCommand;\n                hasProps = true;\n            }\n            if (Types.isString(config.showOutput)) {\n                reveal = Tasks.RevealKind.fromString(config.showOutput);\n                hasProps = true;\n            }\n            var presentation = config.presentation || config.terminal;\n            if (presentation) {\n                if (Types.isBoolean(presentation.echo)) {\n                    echo = presentation.echo;\n                }\n                if (Types.isString(presentation.reveal)) {\n                    reveal = Tasks.RevealKind.fromString(presentation.reveal);\n                }\n                if (Types.isBoolean(presentation.focus)) {\n                    focus = presentation.focus;\n                }\n                if (Types.isString(presentation.panel)) {\n                    panel = Tasks.PanelKind.fromString(presentation.panel);\n                }\n                if (Types.isBoolean(presentation.showReuseMessage)) {\n                    showReuseMessage = presentation.showReuseMessage;\n                }\n                if (Types.isBoolean(presentation.clear)) {\n                    clear = presentation.clear;\n                }\n                if (Types.isString(presentation.group)) {\n                    group = presentation.group;\n                }\n                hasProps = true;\n            }\n            if (!hasProps) {\n                return undefined;\n            }\n            return { echo: echo, reveal: reveal, focus: focus, panel: panel, showReuseMessage: showReuseMessage, clear: clear, group: group };\n        }\n        PresentationOptions.from = from;\n        function assignProperties(target, source) {\n            return _assignProperties(target, source, properties);\n        }\n        PresentationOptions.assignProperties = assignProperties;\n        function fillProperties(target, source) {\n            return _fillProperties(target, source, properties);\n        }\n        PresentationOptions.fillProperties = fillProperties;\n        function fillDefaults(value, context) {\n            var defaultEcho = context.engine === Tasks.ExecutionEngine.Terminal ? true : false;\n            return _fillDefaults(value, { echo: defaultEcho, reveal: Tasks.RevealKind.Always, focus: false, panel: Tasks.PanelKind.Shared, showReuseMessage: true, clear: false }, properties, context);\n        }\n        PresentationOptions.fillDefaults = fillDefaults;\n        function freeze(value) {\n            return _freeze(value, properties);\n        }\n        PresentationOptions.freeze = freeze;\n        function isEmpty(value) {\n            return _isEmpty(value, properties);\n        }\n        PresentationOptions.isEmpty = isEmpty;\n    })(PresentationOptions = CommandConfiguration.PresentationOptions || (CommandConfiguration.PresentationOptions = {}));\n    var ShellString;\n    (function (ShellString) {\n        function from(value) {\n            if (value === undefined || value === null) {\n                return undefined;\n            }\n            if (Types.isString(value)) {\n                return value;\n            }\n            else if (Types.isStringArray(value)) {\n                return value.join(' ');\n            }\n            else {\n                var quoting = Tasks.ShellQuoting.from(value.quoting);\n                var result = Types.isString(value.value) ? value.value : Types.isStringArray(value.value) ? value.value.join(' ') : undefined;\n                if (result) {\n                    return {\n                        value: result,\n                        quoting: quoting\n                    };\n                }\n                else {\n                    return undefined;\n                }\n            }\n        }\n        ShellString.from = from;\n    })(ShellString || (ShellString = {}));\n    var properties = [\n        { property: 'runtime' }, { property: 'name' }, { property: 'options', type: CommandOptions },\n        { property: 'args' }, { property: 'taskSelector' }, { property: 'suppressTaskName' },\n        { property: 'presentation', type: PresentationOptions }\n    ];\n    function from(config, context) {\n        var result = fromBase(config, context);\n        var osConfig = undefined;\n        if (config.windows && context.platform === platform_1.Platform.Windows) {\n            osConfig = fromBase(config.windows, context);\n        }\n        else if (config.osx && context.platform === platform_1.Platform.Mac) {\n            osConfig = fromBase(config.osx, context);\n        }\n        else if (config.linux && context.platform === platform_1.Platform.Linux) {\n            osConfig = fromBase(config.linux, context);\n        }\n        if (osConfig) {\n            result = assignProperties(result, osConfig, context.schemaVersion === Tasks.JsonSchemaVersion.V2_0_0);\n        }\n        return isEmpty(result) ? undefined : result;\n    }\n    CommandConfiguration.from = from;\n    function fromBase(config, context) {\n        var name = ShellString.from(config.command);\n        var runtime;\n        if (Types.isString(config.type)) {\n            if (config.type === 'shell' || config.type === 'process') {\n                runtime = Tasks.RuntimeType.fromString(config.type);\n            }\n        }\n        var isShellConfiguration = ShellConfiguration.is(config.isShellCommand);\n        if (Types.isBoolean(config.isShellCommand) || isShellConfiguration) {\n            runtime = Tasks.RuntimeType.Shell;\n        }\n        else if (config.isShellCommand !== undefined) {\n            runtime = !!config.isShellCommand ? Tasks.RuntimeType.Shell : Tasks.RuntimeType.Process;\n        }\n        var result = {\n            name: name,\n            runtime: runtime,\n            presentation: PresentationOptions.from(config, context)\n        };\n        if (config.args !== undefined) {\n            result.args = [];\n            for (var _i = 0, _a = config.args; _i < _a.length; _i++) {\n                var arg = _a[_i];\n                var converted = ShellString.from(arg);\n                if (converted !== undefined) {\n                    result.args.push(converted);\n                }\n                else {\n                    context.taskLoadIssues.push(nls.localize('ConfigurationParser.inValidArg', 'Error: command argument must either be a string or a quoted string. Provided value is:\\n{0}', arg ? JSON.stringify(arg, undefined, 4) : 'undefined'));\n                }\n            }\n        }\n        if (config.options !== undefined) {\n            result.options = CommandOptions.from(config.options, context);\n            if (result.options && result.options.shell === undefined && isShellConfiguration) {\n                result.options.shell = ShellConfiguration.from(config.isShellCommand, context);\n                if (context.engine !== Tasks.ExecutionEngine.Terminal) {\n                    context.taskLoadIssues.push(nls.localize('ConfigurationParser.noShell', 'Warning: shell configuration is only supported when executing tasks in the terminal.'));\n                }\n            }\n        }\n        if (Types.isString(config.taskSelector)) {\n            result.taskSelector = config.taskSelector;\n        }\n        if (Types.isBoolean(config.suppressTaskName)) {\n            result.suppressTaskName = config.suppressTaskName;\n        }\n        return isEmpty(result) ? undefined : result;\n    }\n    function hasCommand(value) {\n        return value && !!value.name;\n    }\n    CommandConfiguration.hasCommand = hasCommand;\n    function isEmpty(value) {\n        return _isEmpty(value, properties);\n    }\n    CommandConfiguration.isEmpty = isEmpty;\n    function assignProperties(target, source, overwriteArgs) {\n        if (isEmpty(source)) {\n            return target;\n        }\n        if (isEmpty(target)) {\n            return source;\n        }\n        assignProperty(target, source, 'name');\n        assignProperty(target, source, 'runtime');\n        assignProperty(target, source, 'taskSelector');\n        assignProperty(target, source, 'suppressTaskName');\n        if (source.args !== undefined) {\n            if (target.args === undefined || overwriteArgs) {\n                target.args = source.args;\n            }\n            else {\n                target.args = target.args.concat(source.args);\n            }\n        }\n        target.presentation = PresentationOptions.assignProperties(target.presentation, source.presentation);\n        target.options = CommandOptions.assignProperties(target.options, source.options);\n        return target;\n    }\n    CommandConfiguration.assignProperties = assignProperties;\n    function fillProperties(target, source) {\n        return _fillProperties(target, source, properties);\n    }\n    CommandConfiguration.fillProperties = fillProperties;\n    function fillGlobals(target, source, taskName) {\n        if ((source === undefined) || isEmpty(source)) {\n            return target;\n        }\n        target = target || {\n            name: undefined,\n            runtime: undefined,\n            presentation: undefined\n        };\n        if (target.name === undefined) {\n            fillProperty(target, source, 'name');\n            fillProperty(target, source, 'taskSelector');\n            fillProperty(target, source, 'suppressTaskName');\n            var args = source.args ? source.args.slice() : [];\n            if (!target.suppressTaskName && taskName) {\n                if (target.taskSelector !== undefined) {\n                    args.push(target.taskSelector + taskName);\n                }\n                else {\n                    args.push(taskName);\n                }\n            }\n            if (target.args) {\n                args = args.concat(target.args);\n            }\n            target.args = args;\n        }\n        fillProperty(target, source, 'runtime');\n        target.presentation = PresentationOptions.fillProperties(target.presentation, source.presentation);\n        target.options = CommandOptions.fillProperties(target.options, source.options);\n        return target;\n    }\n    CommandConfiguration.fillGlobals = fillGlobals;\n    function fillDefaults(value, context) {\n        if (!value || Object.isFrozen(value)) {\n            return;\n        }\n        if (value.name !== undefined && value.runtime === undefined) {\n            value.runtime = Tasks.RuntimeType.Process;\n        }\n        value.presentation = PresentationOptions.fillDefaults(value.presentation, context);\n        if (!isEmpty(value)) {\n            value.options = CommandOptions.fillDefaults(value.options, context);\n        }\n        if (value.args === undefined) {\n            value.args = EMPTY_ARRAY;\n        }\n        if (value.suppressTaskName === undefined) {\n            value.suppressTaskName = false;\n        }\n    }\n    CommandConfiguration.fillDefaults = fillDefaults;\n    function freeze(value) {\n        return _freeze(value, properties);\n    }\n    CommandConfiguration.freeze = freeze;\n})(CommandConfiguration || (CommandConfiguration = {}));\nvar ProblemMatcherConverter;\n(function (ProblemMatcherConverter) {\n    function namedFrom(declares, context) {\n        var result = Object.create(null);\n        if (!Types.isArray(declares)) {\n            return result;\n        }\n        declares.forEach(function (value) {\n            var namedProblemMatcher = (new problemMatcher_1.ProblemMatcherParser(context.problemReporter)).parse(value);\n            if (problemMatcher_1.isNamedProblemMatcher(namedProblemMatcher)) {\n                result[namedProblemMatcher.name] = namedProblemMatcher;\n            }\n            else {\n                context.problemReporter.error(nls.localize('ConfigurationParser.noName', 'Error: Problem Matcher in declare scope must have a name:\\n{0}\\n', JSON.stringify(value, undefined, 4)));\n            }\n        });\n        return result;\n    }\n    ProblemMatcherConverter.namedFrom = namedFrom;\n    function from(config, context) {\n        var result = [];\n        if (config === undefined) {\n            return result;\n        }\n        var kind = getProblemMatcherKind(config);\n        if (kind === ProblemMatcherKind.Unknown) {\n            context.problemReporter.warn(nls.localize('ConfigurationParser.unknownMatcherKind', 'Warning: the defined problem matcher is unknown. Supported types are string | ProblemMatcher | Array<string | ProblemMatcher>.\\n{0}\\n', JSON.stringify(config, null, 4)));\n            return result;\n        }\n        else if (kind === ProblemMatcherKind.String || kind === ProblemMatcherKind.ProblemMatcher) {\n            var matcher = resolveProblemMatcher(config, context);\n            if (matcher) {\n                result.push(matcher);\n            }\n        }\n        else if (kind === ProblemMatcherKind.Array) {\n            var problemMatchers = config;\n            problemMatchers.forEach(function (problemMatcher) {\n                var matcher = resolveProblemMatcher(problemMatcher, context);\n                if (matcher) {\n                    result.push(matcher);\n                }\n            });\n        }\n        return result;\n    }\n    ProblemMatcherConverter.from = from;\n    function getProblemMatcherKind(value) {\n        if (Types.isString(value)) {\n            return ProblemMatcherKind.String;\n        }\n        else if (Types.isArray(value)) {\n            return ProblemMatcherKind.Array;\n        }\n        else if (!Types.isUndefined(value)) {\n            return ProblemMatcherKind.ProblemMatcher;\n        }\n        else {\n            return ProblemMatcherKind.Unknown;\n        }\n    }\n    function resolveProblemMatcher(value, context) {\n        if (Types.isString(value)) {\n            var variableName = value;\n            if (variableName.length > 1 && variableName[0] === '$') {\n                variableName = variableName.substring(1);\n                var global = problemMatcher_1.ProblemMatcherRegistry.get(variableName);\n                if (global) {\n                    return Objects.deepClone(global);\n                }\n                var localProblemMatcher = context.namedProblemMatchers[variableName];\n                if (localProblemMatcher) {\n                    localProblemMatcher = Objects.deepClone(localProblemMatcher);\n                    // remove the name\n                    delete localProblemMatcher.name;\n                    return localProblemMatcher;\n                }\n            }\n            context.taskLoadIssues.push(nls.localize('ConfigurationParser.invalidVaraibleReference', 'Error: Invalid problemMatcher reference: {0}\\n', value));\n            return undefined;\n        }\n        else {\n            var json = value;\n            return new problemMatcher_1.ProblemMatcherParser(context.problemReporter).parse(json);\n        }\n    }\n})(ProblemMatcherConverter || (ProblemMatcherConverter = {}));\nvar source = {\n    kind: Tasks.TaskSourceKind.Workspace,\n    label: 'Workspace',\n    config: undefined\n};\nvar GroupKind;\n(function (GroupKind) {\n    function from(external) {\n        if (external === undefined) {\n            return undefined;\n        }\n        if (Types.isString(external)) {\n            if (Tasks.TaskGroup.is(external)) {\n                return [external, Tasks.GroupType.user];\n            }\n            else {\n                return undefined;\n            }\n        }\n        if (!Types.isString(external.kind) || !Tasks.TaskGroup.is(external.kind)) {\n            return undefined;\n        }\n        var group = external.kind;\n        var isDefault = !!external.isDefault;\n        return [group, isDefault ? Tasks.GroupType.default : Tasks.GroupType.user];\n    }\n    GroupKind.from = from;\n})(GroupKind || (GroupKind = {}));\nvar TaskDependency;\n(function (TaskDependency) {\n    function from(external, context) {\n        if (Types.isString(external)) {\n            return { workspaceFolder: context.workspaceFolder, task: external };\n        }\n        else if (TaskIdentifier.is(external)) {\n            return { workspaceFolder: context.workspaceFolder, task: Tasks.TaskDefinition.createTaskIdentifier(external, context.problemReporter) };\n        }\n        else {\n            return undefined;\n        }\n    }\n    TaskDependency.from = from;\n})(TaskDependency || (TaskDependency = {}));\nvar ConfigurationProperties;\n(function (ConfigurationProperties) {\n    var properties = [\n        { property: 'name' }, { property: 'identifier' }, { property: 'group' }, { property: 'isBackground' },\n        { property: 'promptOnClose' }, { property: 'dependsOn' },\n        { property: 'presentation', type: CommandConfiguration.PresentationOptions }, { property: 'problemMatchers' }\n    ];\n    function from(external, context, includeCommandOptions) {\n        if (!external) {\n            return undefined;\n        }\n        var result = {};\n        if (Types.isString(external.taskName)) {\n            result.name = external.taskName;\n        }\n        if (Types.isString(external.label) && context.schemaVersion === Tasks.JsonSchemaVersion.V2_0_0) {\n            result.name = external.label;\n        }\n        if (Types.isString(external.identifier)) {\n            result.identifier = external.identifier;\n        }\n        if (external.isBackground !== undefined) {\n            result.isBackground = !!external.isBackground;\n        }\n        if (external.promptOnClose !== undefined) {\n            result.promptOnClose = !!external.promptOnClose;\n        }\n        if (external.group !== undefined) {\n            if (Types.isString(external.group) && Tasks.TaskGroup.is(external.group)) {\n                result.group = external.group;\n                result.groupType = Tasks.GroupType.user;\n            }\n            else {\n                var values = GroupKind.from(external.group);\n                if (values) {\n                    result.group = values[0];\n                    result.groupType = values[1];\n                }\n            }\n        }\n        if (external.dependsOn !== undefined) {\n            if (Types.isArray(external.dependsOn)) {\n                result.dependsOn = external.dependsOn.reduce(function (dependencies, item) {\n                    var dependency = TaskDependency.from(item, context);\n                    if (dependency) {\n                        dependencies.push(dependency);\n                    }\n                    return dependencies;\n                }, []);\n            }\n            else {\n                var dependsOnValue = TaskDependency.from(external.dependsOn, context);\n                result.dependsOn = dependsOnValue ? [dependsOnValue] : undefined;\n            }\n        }\n        if (includeCommandOptions && (external.presentation !== undefined || external.terminal !== undefined)) {\n            result.presentation = CommandConfiguration.PresentationOptions.from(external, context);\n        }\n        if (includeCommandOptions && (external.options !== undefined)) {\n            result.options = CommandOptions.from(external.options, context);\n        }\n        if (external.problemMatcher) {\n            result.problemMatchers = ProblemMatcherConverter.from(external.problemMatcher, context);\n        }\n        return isEmpty(result) ? undefined : result;\n    }\n    ConfigurationProperties.from = from;\n    function isEmpty(value) {\n        return _isEmpty(value, properties);\n    }\n    ConfigurationProperties.isEmpty = isEmpty;\n})(ConfigurationProperties || (ConfigurationProperties = {}));\nvar ConfiguringTask;\n(function (ConfiguringTask) {\n    var grunt = 'grunt.';\n    var jake = 'jake.';\n    var gulp = 'gulp.';\n    var npm = 'vscode.npm.';\n    var typescript = 'vscode.typescript.';\n    function from(external, context, index) {\n        if (!external) {\n            return undefined;\n        }\n        var type = external.type;\n        var customize = external.customize;\n        if (!type && !customize) {\n            context.problemReporter.error(nls.localize('ConfigurationParser.noTaskType', 'Error: tasks configuration must have a type property. The configuration will be ignored.\\n{0}\\n', JSON.stringify(external, null, 4)));\n            return undefined;\n        }\n        var typeDeclaration = type ? taskDefinitionRegistry_1.TaskDefinitionRegistry.get(type) : undefined;\n        if (!typeDeclaration) {\n            var message = nls.localize('ConfigurationParser.noTypeDefinition', 'Error: there is no registered task type \\'{0}\\'. Did you miss to install an extension that provides a corresponding task provider?', type);\n            context.problemReporter.error(message);\n            return undefined;\n        }\n        var identifier;\n        if (Types.isString(customize)) {\n            if (customize.indexOf(grunt) === 0) {\n                identifier = { type: 'grunt', task: customize.substring(grunt.length) };\n            }\n            else if (customize.indexOf(jake) === 0) {\n                identifier = { type: 'jake', task: customize.substring(jake.length) };\n            }\n            else if (customize.indexOf(gulp) === 0) {\n                identifier = { type: 'gulp', task: customize.substring(gulp.length) };\n            }\n            else if (customize.indexOf(npm) === 0) {\n                identifier = { type: 'npm', script: customize.substring(npm.length + 4) };\n            }\n            else if (customize.indexOf(typescript) === 0) {\n                identifier = { type: 'typescript', tsconfig: customize.substring(typescript.length + 6) };\n            }\n        }\n        else {\n            if (Types.isString(external.type)) {\n                identifier = external;\n            }\n        }\n        if (identifier === undefined) {\n            context.problemReporter.error(nls.localize('ConfigurationParser.missingType', 'Error: the task configuration \\'{0}\\' is missing the required property \\'type\\'. The task configuration will be ignored.', JSON.stringify(external, undefined, 0)));\n            return undefined;\n        }\n        var taskIdentifier = Tasks.TaskDefinition.createTaskIdentifier(identifier, context.problemReporter);\n        if (taskIdentifier === undefined) {\n            context.problemReporter.error(nls.localize('ConfigurationParser.incorrectType', 'Error: the task configuration \\'{0}\\' is using an unknown type. The task configuration will be ignored.', JSON.stringify(external, undefined, 0)));\n            return undefined;\n        }\n        var configElement = {\n            workspaceFolder: context.workspaceFolder,\n            file: '.vscode/tasks.json',\n            index: index,\n            element: external\n        };\n        var result = new Tasks.ConfiguringTask(typeDeclaration.extensionId + \".\" + taskIdentifier._key, Objects.assign({}, source, { config: configElement }), undefined, type, taskIdentifier, RunOptions.fromConfiguration(external.runOptions), {});\n        var configuration = ConfigurationProperties.from(external, context, true);\n        if (configuration) {\n            result.configurationProperties = Objects.assign(result.configurationProperties, configuration);\n            if (result.configurationProperties.name) {\n                result._label = result.configurationProperties.name;\n            }\n            else {\n                var label = result.configures.type;\n                if (typeDeclaration.required && typeDeclaration.required.length > 0) {\n                    for (var _i = 0, _a = typeDeclaration.required; _i < _a.length; _i++) {\n                        var required = _a[_i];\n                        var value = result.configures[required];\n                        if (value) {\n                            label = label + ' ' + value;\n                            break;\n                        }\n                    }\n                }\n                result._label = label;\n            }\n            if (!result.configurationProperties.identifier) {\n                result.configurationProperties.identifier = taskIdentifier._key;\n            }\n        }\n        return result;\n    }\n    ConfiguringTask.from = from;\n})(ConfiguringTask || (ConfiguringTask = {}));\nvar CustomTask;\n(function (CustomTask) {\n    function from(external, context, index) {\n        if (!external) {\n            return undefined;\n        }\n        var type = external.type;\n        if (type === undefined || type === null) {\n            type = Tasks.CUSTOMIZED_TASK_TYPE;\n        }\n        if (type !== Tasks.CUSTOMIZED_TASK_TYPE && type !== 'shell' && type !== 'process') {\n            context.problemReporter.error(nls.localize('ConfigurationParser.notCustom', 'Error: tasks is not declared as a custom task. The configuration will be ignored.\\n{0}\\n', JSON.stringify(external, null, 4)));\n            return undefined;\n        }\n        var taskName = external.taskName;\n        if (Types.isString(external.label) && context.schemaVersion === Tasks.JsonSchemaVersion.V2_0_0) {\n            taskName = external.label;\n        }\n        if (!taskName) {\n            context.problemReporter.error(nls.localize('ConfigurationParser.noTaskName', 'Error: a task must provide a label property. The task will be ignored.\\n{0}\\n', JSON.stringify(external, null, 4)));\n            return undefined;\n        }\n        var result = new Tasks.CustomTask(context.uuidMap.getUUID(taskName), Objects.assign({}, source, { config: { index: index, element: external, file: '.vscode/tasks.json', workspaceFolder: context.workspaceFolder } }), taskName, Tasks.CUSTOMIZED_TASK_TYPE, undefined, false, RunOptions.fromConfiguration(external.runOptions), {\n            name: taskName,\n            identifier: taskName,\n        });\n        var configuration = ConfigurationProperties.from(external, context, false);\n        if (configuration) {\n            result.configurationProperties = Objects.assign(result.configurationProperties, configuration);\n        }\n        var supportLegacy = true; //context.schemaVersion === Tasks.JsonSchemaVersion.V2_0_0;\n        if (supportLegacy) {\n            var legacy = external;\n            if (result.configurationProperties.isBackground === undefined && legacy.isWatching !== undefined) {\n                result.configurationProperties.isBackground = !!legacy.isWatching;\n            }\n            if (result.configurationProperties.group === undefined) {\n                if (legacy.isBuildCommand === true) {\n                    result.configurationProperties.group = Tasks.TaskGroup.Build;\n                }\n                else if (legacy.isTestCommand === true) {\n                    result.configurationProperties.group = Tasks.TaskGroup.Test;\n                }\n            }\n        }\n        var command = CommandConfiguration.from(external, context);\n        if (command) {\n            result.command = command;\n        }\n        if (external.command !== undefined) {\n            // if the task has its own command then we suppress the\n            // task name by default.\n            command.suppressTaskName = true;\n        }\n        return result;\n    }\n    CustomTask.from = from;\n    function fillGlobals(task, globals) {\n        // We only merge a command from a global definition if there is no dependsOn\n        // or there is a dependsOn and a defined command.\n        if (CommandConfiguration.hasCommand(task.command) || task.configurationProperties.dependsOn === undefined) {\n            task.command = CommandConfiguration.fillGlobals(task.command, globals.command, task.configurationProperties.name);\n        }\n        if (task.configurationProperties.problemMatchers === undefined && globals.problemMatcher !== undefined) {\n            task.configurationProperties.problemMatchers = Objects.deepClone(globals.problemMatcher);\n            task.hasDefinedMatchers = true;\n        }\n        // promptOnClose is inferred from isBackground if available\n        if (task.configurationProperties.promptOnClose === undefined && task.configurationProperties.isBackground === undefined && globals.promptOnClose !== undefined) {\n            task.configurationProperties.promptOnClose = globals.promptOnClose;\n        }\n    }\n    CustomTask.fillGlobals = fillGlobals;\n    function fillDefaults(task, context) {\n        CommandConfiguration.fillDefaults(task.command, context);\n        if (task.configurationProperties.promptOnClose === undefined) {\n            task.configurationProperties.promptOnClose = task.configurationProperties.isBackground !== undefined ? !task.configurationProperties.isBackground : true;\n        }\n        if (task.configurationProperties.isBackground === undefined) {\n            task.configurationProperties.isBackground = false;\n        }\n        if (task.configurationProperties.problemMatchers === undefined) {\n            task.configurationProperties.problemMatchers = EMPTY_ARRAY;\n        }\n        if (task.configurationProperties.group !== undefined && task.configurationProperties.groupType === undefined) {\n            task.configurationProperties.groupType = Tasks.GroupType.user;\n        }\n    }\n    CustomTask.fillDefaults = fillDefaults;\n    function createCustomTask(contributedTask, configuredProps) {\n        var result = new Tasks.CustomTask(configuredProps._id, Objects.assign({}, configuredProps._source, { customizes: contributedTask.defines }), configuredProps.configurationProperties.name || contributedTask._label, Tasks.CUSTOMIZED_TASK_TYPE, contributedTask.command, false, contributedTask.runOptions, {\n            name: configuredProps.configurationProperties.name || contributedTask.configurationProperties.name,\n            identifier: configuredProps.configurationProperties.identifier || contributedTask.configurationProperties.identifier,\n        });\n        result.addTaskLoadMessages(configuredProps.taskLoadMessages);\n        var resultConfigProps = result.configurationProperties;\n        assignProperty(resultConfigProps, configuredProps.configurationProperties, 'group');\n        assignProperty(resultConfigProps, configuredProps.configurationProperties, 'groupType');\n        assignProperty(resultConfigProps, configuredProps.configurationProperties, 'isBackground');\n        assignProperty(resultConfigProps, configuredProps.configurationProperties, 'dependsOn');\n        assignProperty(resultConfigProps, configuredProps.configurationProperties, 'problemMatchers');\n        assignProperty(resultConfigProps, configuredProps.configurationProperties, 'promptOnClose');\n        result.command.presentation = CommandConfiguration.PresentationOptions.assignProperties(result.command.presentation, configuredProps.configurationProperties.presentation);\n        result.command.options = CommandOptions.assignProperties(result.command.options, configuredProps.configurationProperties.options);\n        var contributedConfigProps = contributedTask.configurationProperties;\n        fillProperty(resultConfigProps, contributedConfigProps, 'group');\n        fillProperty(resultConfigProps, contributedConfigProps, 'groupType');\n        fillProperty(resultConfigProps, contributedConfigProps, 'isBackground');\n        fillProperty(resultConfigProps, contributedConfigProps, 'dependsOn');\n        fillProperty(resultConfigProps, contributedConfigProps, 'problemMatchers');\n        fillProperty(resultConfigProps, contributedConfigProps, 'promptOnClose');\n        result.command.presentation = CommandConfiguration.PresentationOptions.fillProperties(result.command.presentation, contributedConfigProps.presentation);\n        result.command.options = CommandOptions.fillProperties(result.command.options, contributedConfigProps.options);\n        if (contributedTask.hasDefinedMatchers === true) {\n            result.hasDefinedMatchers = true;\n        }\n        return result;\n    }\n    CustomTask.createCustomTask = createCustomTask;\n})(CustomTask || (CustomTask = {}));\nvar TaskParser;\n(function (TaskParser) {\n    function isCustomTask(value) {\n        var type = value.type;\n        var customize = value.customize;\n        return customize === undefined && (type === undefined || type === null || type === Tasks.CUSTOMIZED_TASK_TYPE || type === 'shell' || type === 'process');\n    }\n    function from(externals, globals, context) {\n        var result = { custom: [], configured: [] };\n        if (!externals) {\n            return result;\n        }\n        var defaultBuildTask = { task: undefined, rank: -1 };\n        var defaultTestTask = { task: undefined, rank: -1 };\n        var schema2_0_0 = context.schemaVersion === Tasks.JsonSchemaVersion.V2_0_0;\n        var baseLoadIssues = Objects.deepClone(context.taskLoadIssues);\n        for (var index = 0; index < externals.length; index++) {\n            var external = externals[index];\n            if (isCustomTask(external)) {\n                var customTask = CustomTask.from(external, context, index);\n                if (customTask) {\n                    CustomTask.fillGlobals(customTask, globals);\n                    CustomTask.fillDefaults(customTask, context);\n                    if (schema2_0_0) {\n                        if ((customTask.command === undefined || customTask.command.name === undefined) && (customTask.configurationProperties.dependsOn === undefined || customTask.configurationProperties.dependsOn.length === 0)) {\n                            context.problemReporter.error(nls.localize('taskConfiguration.noCommandOrDependsOn', 'Error: the task \\'{0}\\' neither specifies a command nor a dependsOn property. The task will be ignored. Its definition is:\\n{1}', customTask.configurationProperties.name, JSON.stringify(external, undefined, 4)));\n                            continue;\n                        }\n                    }\n                    else {\n                        if (customTask.command === undefined || customTask.command.name === undefined) {\n                            context.problemReporter.warn(nls.localize('taskConfiguration.noCommand', 'Error: the task \\'{0}\\' doesn\\'t define a command. The task will be ignored. Its definition is:\\n{1}', customTask.configurationProperties.name, JSON.stringify(external, undefined, 4)));\n                            continue;\n                        }\n                    }\n                    if (customTask.configurationProperties.group === Tasks.TaskGroup.Build && defaultBuildTask.rank < 2) {\n                        defaultBuildTask.task = customTask;\n                        defaultBuildTask.rank = 2;\n                    }\n                    else if (customTask.configurationProperties.group === Tasks.TaskGroup.Test && defaultTestTask.rank < 2) {\n                        defaultTestTask.task = customTask;\n                        defaultTestTask.rank = 2;\n                    }\n                    else if (customTask.configurationProperties.name === 'build' && defaultBuildTask.rank < 1) {\n                        defaultBuildTask.task = customTask;\n                        defaultBuildTask.rank = 1;\n                    }\n                    else if (customTask.configurationProperties.name === 'test' && defaultTestTask.rank < 1) {\n                        defaultTestTask.task = customTask;\n                        defaultTestTask.rank = 1;\n                    }\n                    customTask.addTaskLoadMessages(context.taskLoadIssues);\n                    result.custom.push(customTask);\n                }\n            }\n            else {\n                var configuredTask = ConfiguringTask.from(external, context, index);\n                if (configuredTask) {\n                    configuredTask.addTaskLoadMessages(context.taskLoadIssues);\n                    result.configured.push(configuredTask);\n                }\n            }\n            context.taskLoadIssues = Objects.deepClone(baseLoadIssues);\n        }\n        if ((defaultBuildTask.rank > -1) && (defaultBuildTask.rank < 2) && defaultBuildTask.task) {\n            defaultBuildTask.task.configurationProperties.group = Tasks.TaskGroup.Build;\n            defaultBuildTask.task.configurationProperties.groupType = Tasks.GroupType.user;\n        }\n        else if ((defaultTestTask.rank > -1) && (defaultTestTask.rank < 2) && defaultTestTask.task) {\n            defaultTestTask.task.configurationProperties.group = Tasks.TaskGroup.Test;\n            defaultTestTask.task.configurationProperties.groupType = Tasks.GroupType.user;\n        }\n        return result;\n    }\n    TaskParser.from = from;\n    function assignTasks(target, source) {\n        if (source === undefined || source.length === 0) {\n            return target;\n        }\n        if (target === undefined || target.length === 0) {\n            return source;\n        }\n        if (source) {\n            // Tasks are keyed by ID but we need to merge by name\n            var map_1 = Object.create(null);\n            target.forEach(function (task) {\n                map_1[task.configurationProperties.name] = task;\n            });\n            source.forEach(function (task) {\n                map_1[task.configurationProperties.name] = task;\n            });\n            var newTarget_1 = [];\n            target.forEach(function (task) {\n                newTarget_1.push(map_1[task.configurationProperties.name]);\n                delete map_1[task.configurationProperties.name];\n            });\n            Object.keys(map_1).forEach(function (key) { return newTarget_1.push(map_1[key]); });\n            target = newTarget_1;\n        }\n        return target;\n    }\n    TaskParser.assignTasks = assignTasks;\n})(TaskParser || (TaskParser = {}));\nvar Globals;\n(function (Globals) {\n    function from(config, context) {\n        var result = fromBase(config, context);\n        var osGlobals = undefined;\n        if (config.windows && context.platform === platform_1.Platform.Windows) {\n            osGlobals = fromBase(config.windows, context);\n        }\n        else if (config.osx && context.platform === platform_1.Platform.Mac) {\n            osGlobals = fromBase(config.osx, context);\n        }\n        else if (config.linux && context.platform === platform_1.Platform.Linux) {\n            osGlobals = fromBase(config.linux, context);\n        }\n        if (osGlobals) {\n            result = Globals.assignProperties(result, osGlobals);\n        }\n        var command = CommandConfiguration.from(config, context);\n        if (command) {\n            result.command = command;\n        }\n        Globals.fillDefaults(result, context);\n        Globals.freeze(result);\n        return result;\n    }\n    Globals.from = from;\n    function fromBase(config, context) {\n        var result = {};\n        if (config.suppressTaskName !== undefined) {\n            result.suppressTaskName = !!config.suppressTaskName;\n        }\n        if (config.promptOnClose !== undefined) {\n            result.promptOnClose = !!config.promptOnClose;\n        }\n        if (config.problemMatcher) {\n            result.problemMatcher = ProblemMatcherConverter.from(config.problemMatcher, context);\n        }\n        return result;\n    }\n    Globals.fromBase = fromBase;\n    function isEmpty(value) {\n        return !value || value.command === undefined && value.promptOnClose === undefined && value.suppressTaskName === undefined;\n    }\n    Globals.isEmpty = isEmpty;\n    function assignProperties(target, source) {\n        if (isEmpty(source)) {\n            return target;\n        }\n        if (isEmpty(target)) {\n            return source;\n        }\n        assignProperty(target, source, 'promptOnClose');\n        assignProperty(target, source, 'suppressTaskName');\n        return target;\n    }\n    Globals.assignProperties = assignProperties;\n    function fillDefaults(value, context) {\n        if (!value) {\n            return;\n        }\n        CommandConfiguration.fillDefaults(value.command, context);\n        if (value.suppressTaskName === undefined) {\n            value.suppressTaskName = false;\n        }\n        if (value.promptOnClose === undefined) {\n            value.promptOnClose = true;\n        }\n    }\n    Globals.fillDefaults = fillDefaults;\n    function freeze(value) {\n        Object.freeze(value);\n        if (value.command) {\n            CommandConfiguration.freeze(value.command);\n        }\n    }\n    Globals.freeze = freeze;\n})(Globals || (Globals = {}));\nvar ExecutionEngine;\n(function (ExecutionEngine) {\n    function from(config) {\n        var runner = config.runner || config._runner;\n        var result;\n        if (runner) {\n            switch (runner) {\n                case 'terminal':\n                    result = Tasks.ExecutionEngine.Terminal;\n                    break;\n                case 'process':\n                    result = Tasks.ExecutionEngine.Process;\n                    break;\n            }\n        }\n        var schemaVersion = JsonSchemaVersion.from(config);\n        if (schemaVersion === Tasks.JsonSchemaVersion.V0_1_0) {\n            return result || Tasks.ExecutionEngine.Process;\n        }\n        else if (schemaVersion === Tasks.JsonSchemaVersion.V2_0_0) {\n            return Tasks.ExecutionEngine.Terminal;\n        }\n        else {\n            throw new Error('Shouldn\\'t happen.');\n        }\n    }\n    ExecutionEngine.from = from;\n})(ExecutionEngine = exports.ExecutionEngine || (exports.ExecutionEngine = {}));\nvar JsonSchemaVersion;\n(function (JsonSchemaVersion) {\n    var _default = Tasks.JsonSchemaVersion.V2_0_0;\n    function from(config) {\n        var version = config.version;\n        if (!version) {\n            return _default;\n        }\n        switch (version) {\n            case '0.1.0':\n                return Tasks.JsonSchemaVersion.V0_1_0;\n            case '2.0.0':\n                return Tasks.JsonSchemaVersion.V2_0_0;\n            default:\n                return _default;\n        }\n    }\n    JsonSchemaVersion.from = from;\n})(JsonSchemaVersion = exports.JsonSchemaVersion || (exports.JsonSchemaVersion = {}));\nvar UUIDMap = /** @class */ (function () {\n    function UUIDMap(other) {\n        this.current = Object.create(null);\n        if (other) {\n            for (var _i = 0, _a = Object.keys(other.current); _i < _a.length; _i++) {\n                var key = _a[_i];\n                var value = other.current[key];\n                if (Array.isArray(value)) {\n                    this.current[key] = value.slice();\n                }\n                else {\n                    this.current[key] = value;\n                }\n            }\n        }\n    }\n    UUIDMap.prototype.start = function () {\n        this.last = this.current;\n        this.current = Object.create(null);\n    };\n    UUIDMap.prototype.getUUID = function (identifier) {\n        var lastValue = this.last ? this.last[identifier] : undefined;\n        var result = undefined;\n        if (lastValue !== undefined) {\n            if (Array.isArray(lastValue)) {\n                result = lastValue.shift();\n                if (lastValue.length === 0) {\n                    delete this.last[identifier];\n                }\n            }\n            else {\n                result = lastValue;\n                delete this.last[identifier];\n            }\n        }\n        if (result === undefined) {\n            result = UUID.generateUuid();\n        }\n        var currentValue = this.current[identifier];\n        if (currentValue === undefined) {\n            this.current[identifier] = result;\n        }\n        else {\n            if (Array.isArray(currentValue)) {\n                currentValue.push(result);\n            }\n            else {\n                var arrayValue = [currentValue];\n                arrayValue.push(result);\n                this.current[identifier] = arrayValue;\n            }\n        }\n        return result;\n    };\n    UUIDMap.prototype.finish = function () {\n        this.last = undefined;\n    };\n    return UUIDMap;\n}());\nvar ConfigurationParser = /** @class */ (function () {\n    function ConfigurationParser(workspaceFolder, platform, problemReporter, uuidMap) {\n        this.workspaceFolder = workspaceFolder;\n        this.platform = platform;\n        this.problemReporter = problemReporter;\n        this.uuidMap = uuidMap;\n    }\n    ConfigurationParser.prototype.run = function (fileConfig) {\n        var engine = ExecutionEngine.from(fileConfig);\n        var schemaVersion = JsonSchemaVersion.from(fileConfig);\n        var context = {\n            workspaceFolder: this.workspaceFolder,\n            problemReporter: this.problemReporter,\n            uuidMap: this.uuidMap,\n            namedProblemMatchers: {},\n            engine: engine,\n            schemaVersion: schemaVersion,\n            platform: this.platform,\n            taskLoadIssues: []\n        };\n        var taskParseResult = this.createTaskRunnerConfiguration(fileConfig, context);\n        return {\n            validationStatus: this.problemReporter.status,\n            custom: taskParseResult.custom,\n            configured: taskParseResult.configured,\n            engine: engine\n        };\n    };\n    ConfigurationParser.prototype.createTaskRunnerConfiguration = function (fileConfig, context) {\n        var globals = Globals.from(fileConfig, context);\n        if (this.problemReporter.status.isFatal()) {\n            return { custom: [], configured: [] };\n        }\n        context.namedProblemMatchers = ProblemMatcherConverter.namedFrom(fileConfig.declares, context);\n        var globalTasks = undefined;\n        var externalGlobalTasks = undefined;\n        if (fileConfig.windows && context.platform === platform_1.Platform.Windows) {\n            globalTasks = TaskParser.from(fileConfig.windows.tasks, globals, context).custom;\n            externalGlobalTasks = fileConfig.windows.tasks;\n        }\n        else if (fileConfig.osx && context.platform === platform_1.Platform.Mac) {\n            globalTasks = TaskParser.from(fileConfig.osx.tasks, globals, context).custom;\n            externalGlobalTasks = fileConfig.osx.tasks;\n        }\n        else if (fileConfig.linux && context.platform === platform_1.Platform.Linux) {\n            globalTasks = TaskParser.from(fileConfig.linux.tasks, globals, context).custom;\n            externalGlobalTasks = fileConfig.linux.tasks;\n        }\n        if (context.schemaVersion === Tasks.JsonSchemaVersion.V2_0_0 && globalTasks && globalTasks.length > 0 && externalGlobalTasks && externalGlobalTasks.length > 0) {\n            var taskContent = [];\n            for (var _i = 0, externalGlobalTasks_1 = externalGlobalTasks; _i < externalGlobalTasks_1.length; _i++) {\n                var task = externalGlobalTasks_1[_i];\n                taskContent.push(JSON.stringify(task, null, 4));\n            }\n            context.problemReporter.error(nls.localize('TaskParse.noOsSpecificGlobalTasks', 'Task version 2.0.0 doesn\\'t support global OS specific tasks. Convert them to a task with a OS specific command. Affected tasks are:\\n{0}', taskContent.join('\\n')));\n        }\n        var result = { custom: [], configured: [] };\n        if (fileConfig.tasks) {\n            result = TaskParser.from(fileConfig.tasks, globals, context);\n        }\n        if (globalTasks) {\n            result.custom = TaskParser.assignTasks(result.custom, globalTasks);\n        }\n        if ((!result.custom || result.custom.length === 0) && (globals.command && globals.command.name)) {\n            var matchers = ProblemMatcherConverter.from(fileConfig.problemMatcher, context);\n            var isBackground = fileConfig.isBackground ? !!fileConfig.isBackground : fileConfig.isWatching ? !!fileConfig.isWatching : undefined;\n            var name = Tasks.CommandString.value(globals.command.name);\n            var task = new Tasks.CustomTask(context.uuidMap.getUUID(name), Objects.assign({}, source, { config: { index: -1, element: fileConfig, workspaceFolder: context.workspaceFolder } }), name, Tasks.CUSTOMIZED_TASK_TYPE, {\n                name: undefined,\n                runtime: undefined,\n                presentation: undefined,\n                suppressTaskName: true\n            }, false, { reevaluateOnRerun: true }, {\n                name: name,\n                identifier: name,\n                group: Tasks.TaskGroup.Build,\n                isBackground: isBackground,\n                problemMatchers: matchers,\n            });\n            var value = GroupKind.from(fileConfig.group);\n            if (value) {\n                task.configurationProperties.group = value[0];\n                task.configurationProperties.groupType = value[1];\n            }\n            else if (fileConfig.group === 'none') {\n                task.configurationProperties.group = undefined;\n            }\n            CustomTask.fillGlobals(task, globals);\n            CustomTask.fillDefaults(task, context);\n            result.custom = [task];\n        }\n        result.custom = result.custom || [];\n        result.configured = result.configured || [];\n        return result;\n    };\n    return ConfigurationParser;\n}());\nvar uuidMaps = new Map();\nfunction parse(workspaceFolder, platform, configuration, logger) {\n    var uuidMap = uuidMaps.get(workspaceFolder.uri.toString());\n    if (!uuidMap) {\n        uuidMap = new UUIDMap();\n        uuidMaps.set(workspaceFolder.uri.toString(), uuidMap);\n    }\n    try {\n        uuidMap.start();\n        return (new ConfigurationParser(workspaceFolder, platform, logger, uuidMap)).run(configuration);\n    }\n    finally {\n        uuidMap.finish();\n    }\n}\nexports.parse = parse;\nfunction createCustomTask(contributedTask, configuredProps) {\n    return CustomTask.createCustomTask(contributedTask, configuredProps);\n}\nexports.createCustomTask = createCustomTask;\n/*\nclass VersionConverter {\n    constructor(private problemReporter: IProblemReporter) {\n    }\n\n    public convert(fromConfig: ExternalTaskRunnerConfiguration): ExternalTaskRunnerConfiguration {\n        let result: ExternalTaskRunnerConfiguration;\n        result.version = '2.0.0';\n        if (Array.isArray(fromConfig.tasks)) {\n\n        } else {\n            result.tasks = [];\n        }\n\n\n        return result;\n    }\n\n    private convertGlobalTask(fromConfig: ExternalTaskRunnerConfiguration): TaskDescription {\n        let command: string = this.getGlobalCommand(fromConfig);\n        if (!command) {\n            this.problemReporter.error(nls.localize('Converter.noGlobalName', 'No global command specified. Can\\'t convert to 2.0.0 version.'));\n            return undefined;\n        }\n        let result: TaskDescription = {\n            taskName: command\n        };\n        if (fromConfig.isShellCommand) {\n            result.type = 'shell';\n        } else {\n            result.type = 'process';\n            result.args = fromConfig.args;\n        }\n        if (fromConfig.)\n\n        return result;\n    }\n\n    private getGlobalCommand(fromConfig: ExternalTaskRunnerConfiguration): string {\n        if (fromConfig.command) {\n            return fromConfig.command;\n        } else if (fromConfig.windows && fromConfig.windows.command) {\n            return fromConfig.windows.command;\n        } else if (fromConfig.osx && fromConfig.osx.command) {\n            return fromConfig.osx.command;\n        } else if (fromConfig.linux && fromConfig.linux.command) {\n            return fromConfig.linux.command;\n        } else {\n            return undefined;\n        }\n    }\n\n    private createCommandLine(command: string, args: string[], isWindows: boolean): string {\n        let result: string[];\n        let commandHasSpace = false;\n        let argHasSpace = false;\n        if (TaskDescription.hasUnescapedSpaces(command)) {\n            result.push(`\"${command}\"`);\n            commandHasSpace = true;\n        } else {\n            result.push(command);\n        }\n        if (args) {\n            for (let arg of args) {\n                if (TaskDescription.hasUnescapedSpaces(arg)) {\n                    result.push(`\"${arg}\"`);\n                    argHasSpace= true;\n                } else {\n                    result.push(arg);\n                }\n            }\n        }\n        return result.join(' ');\n    }\n\n}\n*/\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/common/taskConfiguration.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/common/taskConfiguration.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\n\nimport * as Objects from 'vs/base/common/objects';\nimport { IStringDictionary } from 'vs/base/common/collections';\nimport { Platform } from 'vs/base/common/platform';\nimport * as Types from 'vs/base/common/types';\nimport * as UUID from 'vs/base/common/uuid';\n\nimport { ValidationStatus, IProblemReporter as IProblemReporterBase } from 'vs/base/common/parsers';\nimport {\n\tNamedProblemMatcher, ProblemMatcher, ProblemMatcherParser, Config as ProblemMatcherConfig,\n\tisNamedProblemMatcher, ProblemMatcherRegistry\n} from 'vs/workbench/contrib/tasks/common/problemMatcher';\n\nimport { IWorkspaceFolder } from 'vs/platform/workspace/common/workspace';\nimport * as Tasks from './tasks';\nimport { TaskDefinitionRegistry } from './taskDefinitionRegistry';\nimport { ConfiguredInput } from 'vs/workbench/services/configurationResolver/common/configurationResolver';\n\nexport const enum ShellQuoting {\n\t/**\n\t * Default is character escaping.\n\t */\n\tescape = 1,\n\n\t/**\n\t * Default is strong quoting\n\t */\n\tstrong = 2,\n\n\t/**\n\t * Default is weak quoting.\n\t */\n\tweak = 3\n}\n\nexport interface ShellQuotingOptions {\n\t/**\n\t * The character used to do character escaping.\n\t */\n\tescape?: string | {\n\t\tescapeChar: string;\n\t\tcharsToEscape: string;\n\t};\n\n\t/**\n\t * The character used for string quoting.\n\t */\n\tstrong?: string;\n\n\t/**\n\t * The character used for weak quoting.\n\t */\n\tweak?: string;\n}\n\nexport interface ShellConfiguration {\n\texecutable?: string;\n\targs?: string[];\n\tquoting?: ShellQuotingOptions;\n}\n\nexport interface CommandOptionsConfig {\n\t/**\n\t * The current working directory of the executed program or shell.\n\t * If omitted VSCode's current workspace root is used.\n\t */\n\tcwd?: string;\n\n\t/**\n\t * The additional environment of the executed program or shell. If omitted\n\t * the parent process' environment is used.\n\t */\n\tenv?: IStringDictionary<string>;\n\n\t/**\n\t * The shell configuration;\n\t */\n\tshell?: ShellConfiguration;\n}\n\nexport interface PresentationOptionsConfig {\n\t/**\n\t * Controls whether the terminal executing a task is brought to front or not.\n\t * Defaults to `RevealKind.Always`.\n\t */\n\treveal?: string;\n\n\t/**\n\t * Controls whether the executed command is printed to the output window or terminal as well.\n\t */\n\techo?: boolean;\n\n\t/**\n\t * Controls whether the terminal is focus when this task is executed\n\t */\n\tfocus?: boolean;\n\n\t/**\n\t * Controls whether the task runs in a new terminal\n\t */\n\tpanel?: string;\n\n\t/**\n\t * Controls whether to show the \"Terminal will be reused by tasks, press any key to close it\" message.\n\t */\n\tshowReuseMessage?: boolean;\n\n\t/**\n\t * Controls whether the terminal should be cleared before running the task.\n\t */\n\tclear?: boolean;\n\n\t/**\n\t * Controls whether the task is executed in a specific terminal group using split panes.\n\t */\n\tgroup?: string;\n}\n\nexport interface RunOptionsConfig {\n\treevaluateOnRerun?: boolean;\n\trunOn?: string;\n}\n\nexport interface TaskIdentifier {\n\ttype?: string;\n\t[name: string]: any;\n}\n\nexport namespace TaskIdentifier {\n\texport function is(value: any): value is TaskIdentifier {\n\t\tlet candidate: TaskIdentifier = value;\n\t\treturn candidate !== undefined && Types.isString(value.type);\n\t}\n}\n\nexport interface LegacyTaskProperties {\n\t/**\n\t * @deprecated Use `isBackground` instead.\n\t * Whether the executed command is kept alive and is watching the file system.\n\t */\n\tisWatching?: boolean;\n\n\t/**\n\t * @deprecated Use `group` instead.\n\t * Whether this task maps to the default build command.\n\t */\n\tisBuildCommand?: boolean;\n\n\t/**\n\t * @deprecated Use `group` instead.\n\t * Whether this task maps to the default test command.\n\t */\n\tisTestCommand?: boolean;\n}\n\nexport interface LegacyCommandProperties {\n\n\t/**\n\t * Whether this is a shell or process\n\t */\n\ttype?: string;\n\n\t/**\n\t * @deprecated Use presentation options\n\t * Controls whether the output view of the running tasks is brought to front or not.\n\t * See BaseTaskRunnerConfiguration#showOutput for details.\n\t */\n\tshowOutput?: string;\n\n\t/**\n\t * @deprecated Use presentation options\n\t * Controls whether the executed command is printed to the output windows as well.\n\t */\n\techoCommand?: boolean;\n\n\t/**\n\t * @deprecated Use presentation instead\n\t */\n\tterminal?: PresentationOptionsConfig;\n\n\t/**\n\t * @deprecated Use inline commands.\n\t * See BaseTaskRunnerConfiguration#suppressTaskName for details.\n\t */\n\tsuppressTaskName?: boolean;\n\n\t/**\n\t * Some commands require that the task argument is highlighted with a special\n\t * prefix (e.g. /t: for msbuild). This property can be used to control such\n\t * a prefix.\n\t */\n\ttaskSelector?: string;\n\n\t/**\n\t * @deprecated use the task type instead.\n\t * Specifies whether the command is a shell command and therefore must\n\t * be executed in a shell interpreter (e.g. cmd.exe, bash, ...).\n\t *\n\t * Defaults to false if omitted.\n\t */\n\tisShellCommand?: boolean | ShellConfiguration;\n}\n\nexport type CommandString = string | string[] | { value: string | string[], quoting: 'escape' | 'strong' | 'weak' };\n\nexport namespace CommandString {\n\texport function value(value: CommandString): string {\n\t\tif (Types.isString(value)) {\n\t\t\treturn value;\n\t\t} else if (Types.isStringArray(value)) {\n\t\t\treturn value.join(' ');\n\t\t} else {\n\t\t\tif (Types.isString(value.value)) {\n\t\t\t\treturn value.value;\n\t\t\t} else {\n\t\t\t\treturn value.value.join(' ');\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport interface BaseCommandProperties {\n\n\t/**\n\t * The command to be executed. Can be an external program or a shell\n\t * command.\n\t */\n\tcommand?: CommandString;\n\n\t/**\n\t * The command options used when the command is executed. Can be omitted.\n\t */\n\toptions?: CommandOptionsConfig;\n\n\t/**\n\t * The arguments passed to the command or additional arguments passed to the\n\t * command when using a global command.\n\t */\n\targs?: CommandString[];\n}\n\n\nexport interface CommandProperties extends BaseCommandProperties {\n\n\t/**\n\t * Windows specific command properties\n\t */\n\twindows?: BaseCommandProperties;\n\n\t/**\n\t * OSX specific command properties\n\t */\n\tosx?: BaseCommandProperties;\n\n\t/**\n\t * linux specific command properties\n\t */\n\tlinux?: BaseCommandProperties;\n}\n\nexport interface GroupKind {\n\tkind?: string;\n\tisDefault?: boolean;\n}\n\nexport interface ConfigurationProperties {\n\t/**\n\t * The task's name\n\t */\n\ttaskName?: string;\n\n\t/**\n\t * The UI label used for the task.\n\t */\n\tlabel?: string;\n\n\t/**\n\t * An optional indentifier which can be used to reference a task\n\t * in a dependsOn or other attributes.\n\t */\n\tidentifier?: string;\n\n\t/**\n\t * Whether the executed command is kept alive and runs in the background.\n\t */\n\tisBackground?: boolean;\n\n\t/**\n\t * Whether the task should prompt on close for confirmation if running.\n\t */\n\tpromptOnClose?: boolean;\n\n\t/**\n\t * Defines the group the task belongs too.\n\t */\n\tgroup?: string | GroupKind;\n\n\t/**\n\t * The other tasks the task depend on\n\t */\n\tdependsOn?: string | TaskIdentifier | Array<string | TaskIdentifier>;\n\n\t/**\n\t * Controls the behavior of the used terminal\n\t */\n\tpresentation?: PresentationOptionsConfig;\n\n\t/**\n\t * Controls shell options.\n\t */\n\toptions?: CommandOptionsConfig;\n\n\t/**\n\t * The problem matcher(s) to use to capture problems in the tasks\n\t * output.\n\t */\n\tproblemMatcher?: ProblemMatcherConfig.ProblemMatcherType;\n\n\t/**\n\t * Task run options. Control run related properties.\n\t */\n\trunOptions?: RunOptionsConfig;\n}\n\nexport interface CustomTask extends CommandProperties, ConfigurationProperties {\n\t/**\n\t * Custom tasks have the type CUSTOMIZED_TASK_TYPE\n\t */\n\ttype?: string;\n\n}\n\nexport interface ConfiguringTask extends ConfigurationProperties {\n\t/**\n\t * The contributed type of the task\n\t */\n\ttype?: string;\n}\n\n/**\n * The base task runner configuration\n */\nexport interface BaseTaskRunnerConfiguration {\n\n\t/**\n\t * The command to be executed. Can be an external program or a shell\n\t * command.\n\t */\n\tcommand?: CommandString;\n\n\t/**\n\t * @deprecated Use type instead\n\t *\n\t * Specifies whether the command is a shell command and therefore must\n\t * be executed in a shell interpreter (e.g. cmd.exe, bash, ...).\n\t *\n\t * Defaults to false if omitted.\n\t */\n\tisShellCommand?: boolean;\n\n\t/**\n\t * The task type\n\t */\n\ttype?: string;\n\n\t/**\n\t * The command options used when the command is executed. Can be omitted.\n\t */\n\toptions?: CommandOptionsConfig;\n\n\t/**\n\t * The arguments passed to the command. Can be omitted.\n\t */\n\targs?: CommandString[];\n\n\t/**\n\t * Controls whether the output view of the running tasks is brought to front or not.\n\t * Valid values are:\n\t *   \"always\": bring the output window always to front when a task is executed.\n\t *   \"silent\": only bring it to front if no problem matcher is defined for the task executed.\n\t *   \"never\": never bring the output window to front.\n\t *\n\t * If omitted \"always\" is used.\n\t */\n\tshowOutput?: string;\n\n\t/**\n\t * Controls whether the executed command is printed to the output windows as well.\n\t */\n\techoCommand?: boolean;\n\n\t/**\n\t * The group\n\t */\n\tgroup?: string | GroupKind;\n\t/**\n\t * Controls the behavior of the used terminal\n\t */\n\tpresentation?: PresentationOptionsConfig;\n\n\t/**\n\t * If set to false the task name is added as an additional argument to the\n\t * command when executed. If set to true the task name is suppressed. If\n\t * omitted false is used.\n\t */\n\tsuppressTaskName?: boolean;\n\n\t/**\n\t * Some commands require that the task argument is highlighted with a special\n\t * prefix (e.g. /t: for msbuild). This property can be used to control such\n\t * a prefix.\n\t */\n\ttaskSelector?: string;\n\n\t/**\n\t * The problem matcher(s) to used if a global command is exucuted (e.g. no tasks\n\t * are defined). A tasks.json file can either contain a global problemMatcher\n\t * property or a tasks property but not both.\n\t */\n\tproblemMatcher?: ProblemMatcherConfig.ProblemMatcherType;\n\n\t/**\n\t * @deprecated Use `isBackground` instead.\n\t *\n\t * Specifies whether a global command is a watching the filesystem. A task.json\n\t * file can either contain a global isWatching property or a tasks property\n\t * but not both.\n\t */\n\tisWatching?: boolean;\n\n\t/**\n\t * Specifies whether a global command is a background task.\n\t */\n\tisBackground?: boolean;\n\n\t/**\n\t * Whether the task should prompt on close for confirmation if running.\n\t */\n\tpromptOnClose?: boolean;\n\n\t/**\n\t * The configuration of the available tasks. A tasks.json file can either\n\t * contain a global problemMatcher property or a tasks property but not both.\n\t */\n\ttasks?: Array<CustomTask | ConfiguringTask>;\n\n\t/**\n\t * Problem matcher declarations.\n\t */\n\tdeclares?: ProblemMatcherConfig.NamedProblemMatcher[];\n\n\t/**\n\t * Optional user input variables.\n\t */\n\tinputs?: ConfiguredInput[];\n}\n\n/**\n * A configuration of an external build system. BuildConfiguration.buildSystem\n * must be set to 'program'\n */\nexport interface ExternalTaskRunnerConfiguration extends BaseTaskRunnerConfiguration {\n\n\t_runner?: string;\n\n\t/**\n\t * Determines the runner to use\n\t */\n\trunner?: string;\n\n\t/**\n\t * The config's version number\n\t */\n\tversion: string;\n\n\t/**\n\t * Windows specific task configuration\n\t */\n\twindows?: BaseTaskRunnerConfiguration;\n\n\t/**\n\t * Mac specific task configuration\n\t */\n\tosx?: BaseTaskRunnerConfiguration;\n\n\t/**\n\t * Linux speciif task configuration\n\t */\n\tlinux?: BaseTaskRunnerConfiguration;\n}\n\nenum ProblemMatcherKind {\n\tUnknown,\n\tString,\n\tProblemMatcher,\n\tArray\n}\n\nconst EMPTY_ARRAY: any[] = [];\nObject.freeze(EMPTY_ARRAY);\n\nfunction assignProperty<T, K extends keyof T>(target: T, source: Partial<T>, key: K) {\n\tconst sourceAtKey = source[key];\n\tif (sourceAtKey !== undefined) {\n\t\ttarget[key] = sourceAtKey!;\n\t}\n}\n\nfunction fillProperty<T, K extends keyof T>(target: T, source: Partial<T>, key: K) {\n\tconst sourceAtKey = source[key];\n\tif (target[key] === undefined && sourceAtKey !== undefined) {\n\t\ttarget[key] = sourceAtKey!;\n\t}\n}\n\n\ninterface ParserType<T> {\n\tisEmpty(value: T | undefined): boolean;\n\tassignProperties(target: T | undefined, source: T | undefined): T | undefined;\n\tfillProperties(target: T | undefined, source: T | undefined): T | undefined;\n\tfillDefaults(value: T | undefined, context: ParseContext): T | undefined;\n\tfreeze(value: T): Readonly<T> | undefined;\n}\n\ninterface MetaData<T, U> {\n\tproperty: keyof T;\n\ttype?: ParserType<U>;\n}\n\n\nfunction _isEmpty<T>(this: void, value: T, properties: MetaData<T, any>[] | undefined): boolean {\n\tif (value === undefined || value === null || properties === undefined) {\n\t\treturn true;\n\t}\n\tfor (let meta of properties) {\n\t\tlet property = value[meta.property];\n\t\tif (property !== undefined && property !== null) {\n\t\t\tif (meta.type !== undefined && !meta.type.isEmpty(property)) {\n\t\t\t\treturn false;\n\t\t\t} else if (!Array.isArray(property) || property.length > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction _assignProperties<T>(this: void, target: T, source: T, properties: MetaData<T, any>[]): T {\n\tif (_isEmpty(source, properties)) {\n\t\treturn target;\n\t}\n\tif (_isEmpty(target, properties)) {\n\t\treturn source;\n\t}\n\tfor (let meta of properties) {\n\t\tlet property = meta.property;\n\t\tlet value: any;\n\t\tif (meta.type !== undefined) {\n\t\t\tvalue = meta.type.assignProperties(target[property], source[property]);\n\t\t} else {\n\t\t\tvalue = source[property];\n\t\t}\n\t\tif (value !== undefined && value !== null) {\n\t\t\ttarget[property] = value;\n\t\t}\n\t}\n\treturn target;\n}\n\nfunction _fillProperties<T>(this: void, target: T, source: T, properties: MetaData<T, any>[] | undefined): T {\n\tif (_isEmpty(source, properties)) {\n\t\treturn target;\n\t}\n\tif (_isEmpty(target, properties)) {\n\t\treturn source;\n\t}\n\tfor (let meta of properties!) {\n\t\tlet property = meta.property;\n\t\tlet value: any;\n\t\tif (meta.type) {\n\t\t\tvalue = meta.type.fillProperties(target[property], source[property]);\n\t\t} else if (target[property] === undefined) {\n\t\t\tvalue = source[property];\n\t\t}\n\t\tif (value !== undefined && value !== null) {\n\t\t\ttarget[property] = value;\n\t\t}\n\t}\n\treturn target;\n}\n\nfunction _fillDefaults<T>(this: void, target: T, defaults: T, properties: MetaData<T, any>[], context: ParseContext): T | undefined {\n\tif (target && Object.isFrozen(target)) {\n\t\treturn target;\n\t}\n\tif (target === undefined || target === null) {\n\t\tif (defaults !== undefined && defaults !== null) {\n\t\t\treturn Objects.deepClone(defaults);\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\tfor (let meta of properties) {\n\t\tlet property = meta.property;\n\t\tif (target[property] !== undefined) {\n\t\t\tcontinue;\n\t\t}\n\t\tlet value: any;\n\t\tif (meta.type) {\n\t\t\tvalue = meta.type.fillDefaults(target[property], context);\n\t\t} else {\n\t\t\tvalue = defaults[property];\n\t\t}\n\n\t\tif (value !== undefined && value !== null) {\n\t\t\ttarget[property] = value;\n\t\t}\n\t}\n\treturn target;\n}\n\nfunction _freeze<T>(this: void, target: T, properties: MetaData<T, any>[]): Readonly<T> | undefined {\n\tif (target === undefined || target === null) {\n\t\treturn undefined;\n\t}\n\tif (Object.isFrozen(target)) {\n\t\treturn target;\n\t}\n\tfor (let meta of properties) {\n\t\tif (meta.type) {\n\t\t\tlet value = target[meta.property];\n\t\t\tif (value) {\n\t\t\t\tmeta.type.freeze(value);\n\t\t\t}\n\t\t}\n\t}\n\tObject.freeze(target);\n\treturn target;\n}\n\nexport namespace RunOnOptions {\n\texport function fromString(value: string | undefined): Tasks.RunOnOptions {\n\t\tif (!value) {\n\t\t\treturn Tasks.RunOnOptions.default;\n\t\t}\n\t\tswitch (value.toLowerCase()) {\n\t\t\tcase 'folderopen':\n\t\t\t\treturn Tasks.RunOnOptions.folderOpen;\n\t\t\tcase 'default':\n\t\t\tdefault:\n\t\t\t\treturn Tasks.RunOnOptions.default;\n\t\t}\n\t}\n}\n\nexport namespace RunOptions {\n\texport function fromConfiguration(value: RunOptionsConfig | undefined): Tasks.RunOptions {\n\t\treturn {\n\t\t\treevaluateOnRerun: value ? value.reevaluateOnRerun : true,\n\t\t\trunOn: value ? RunOnOptions.fromString(value.runOn) : Tasks.RunOnOptions.default\n\t\t};\n\t}\n}\n\nclass ParseContext {\n\tworkspaceFolder: IWorkspaceFolder;\n\tproblemReporter: IProblemReporter;\n\tnamedProblemMatchers: IStringDictionary<NamedProblemMatcher>;\n\tuuidMap: UUIDMap;\n\tengine: Tasks.ExecutionEngine;\n\tschemaVersion: Tasks.JsonSchemaVersion;\n\tplatform: Platform;\n\ttaskLoadIssues: string[];\n}\n\n\nnamespace ShellConfiguration {\n\n\tconst properties: MetaData<Tasks.ShellConfiguration, void>[] = [{ property: 'executable' }, { property: 'args' }, { property: 'quoting' }];\n\n\texport function is(value: any): value is ShellConfiguration {\n\t\tlet candidate: ShellConfiguration = value;\n\t\treturn candidate && (Types.isString(candidate.executable) || Types.isStringArray(candidate.args));\n\t}\n\n\texport function from(this: void, config: ShellConfiguration | undefined, context: ParseContext): Tasks.ShellConfiguration | undefined {\n\t\tif (!is(config)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet result: ShellConfiguration = {};\n\t\tif (config.executable !== undefined) {\n\t\t\tresult.executable = config.executable;\n\t\t}\n\t\tif (config.args !== undefined) {\n\t\t\tresult.args = config.args.slice();\n\t\t}\n\t\tif (config.quoting !== undefined) {\n\t\t\tresult.quoting = Objects.deepClone(config.quoting);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\texport function isEmpty(this: void, value: Tasks.ShellConfiguration): boolean {\n\t\treturn _isEmpty(value, properties);\n\t}\n\n\texport function assignProperties(this: void, target: Tasks.ShellConfiguration | undefined, source: Tasks.ShellConfiguration | undefined): Tasks.ShellConfiguration | undefined {\n\t\treturn _assignProperties(target, source, properties);\n\t}\n\n\texport function fillProperties(this: void, target: Tasks.ShellConfiguration, source: Tasks.ShellConfiguration): Tasks.ShellConfiguration {\n\t\treturn _fillProperties(target, source, properties);\n\t}\n\n\texport function fillDefaults(this: void, value: Tasks.ShellConfiguration, context: ParseContext): Tasks.ShellConfiguration {\n\t\treturn value;\n\t}\n\n\texport function freeze(this: void, value: Tasks.ShellConfiguration): Readonly<Tasks.ShellConfiguration> | undefined {\n\t\tif (!value) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn Object.freeze(value);\n\t}\n}\n\nnamespace CommandOptions {\n\n\tconst properties: MetaData<Tasks.CommandOptions, Tasks.ShellConfiguration>[] = [{ property: 'cwd' }, { property: 'env' }, { property: 'shell', type: ShellConfiguration }];\n\tconst defaults: CommandOptionsConfig = { cwd: '${workspaceFolder}' };\n\n\texport function from(this: void, options: CommandOptionsConfig, context: ParseContext): Tasks.CommandOptions | undefined {\n\t\tlet result: Tasks.CommandOptions = {};\n\t\tif (options.cwd !== undefined) {\n\t\t\tif (Types.isString(options.cwd)) {\n\t\t\t\tresult.cwd = options.cwd;\n\t\t\t} else {\n\t\t\t\tcontext.taskLoadIssues.push(nls.localize('ConfigurationParser.invalidCWD', 'Warning: options.cwd must be of type string. Ignoring value {0}\\n', options.cwd));\n\t\t\t}\n\t\t}\n\t\tif (options.env !== undefined) {\n\t\t\tresult.env = Objects.deepClone(options.env);\n\t\t}\n\t\tresult.shell = ShellConfiguration.from(options.shell, context);\n\t\treturn isEmpty(result) ? undefined : result;\n\t}\n\n\texport function isEmpty(value: Tasks.CommandOptions | undefined): boolean {\n\t\treturn _isEmpty(value, properties);\n\t}\n\n\texport function assignProperties(target: Tasks.CommandOptions | undefined, source: Tasks.CommandOptions | undefined): Tasks.CommandOptions | undefined {\n\t\tif ((source === undefined) || isEmpty(source)) {\n\t\t\treturn target;\n\t\t}\n\t\tif ((target === undefined) || isEmpty(target)) {\n\t\t\treturn source;\n\t\t}\n\t\tassignProperty(target, source, 'cwd');\n\t\tif (target.env === undefined) {\n\t\t\ttarget.env = source.env;\n\t\t} else if (source.env !== undefined) {\n\t\t\tlet env: { [key: string]: string; } = Object.create(null);\n\t\t\tif (target.env !== undefined) {\n\t\t\t\tObject.keys(target.env).forEach(key => env[key] = target.env![key]);\n\t\t\t}\n\t\t\tif (source.env !== undefined) {\n\t\t\t\tObject.keys(source.env).forEach(key => env[key] = source.env![key]);\n\t\t\t}\n\t\t\ttarget.env = env;\n\t\t}\n\t\ttarget.shell = ShellConfiguration.assignProperties(target.shell, source.shell);\n\t\treturn target;\n\t}\n\n\texport function fillProperties(target: Tasks.CommandOptions | undefined, source: Tasks.CommandOptions | undefined): Tasks.CommandOptions | undefined {\n\t\treturn _fillProperties(target, source, properties);\n\t}\n\n\texport function fillDefaults(value: Tasks.CommandOptions | undefined, context: ParseContext): Tasks.CommandOptions | undefined {\n\t\treturn _fillDefaults(value, defaults, properties, context);\n\t}\n\n\texport function freeze(value: Tasks.CommandOptions): Readonly<Tasks.CommandOptions> | undefined {\n\t\treturn _freeze(value, properties);\n\t}\n}\n\nnamespace CommandConfiguration {\n\n\texport namespace PresentationOptions {\n\t\tconst properties: MetaData<Tasks.PresentationOptions, void>[] = [{ property: 'echo' }, { property: 'reveal' }, { property: 'focus' }, { property: 'panel' }, { property: 'showReuseMessage' }, { property: 'clear' }, { property: 'group' }];\n\n\t\tinterface PresentationOptionsShape extends LegacyCommandProperties {\n\t\t\tpresentation?: PresentationOptionsConfig;\n\t\t}\n\n\t\texport function from(this: void, config: PresentationOptionsShape, context: ParseContext): Tasks.PresentationOptions | undefined {\n\t\t\tlet echo: boolean;\n\t\t\tlet reveal: Tasks.RevealKind;\n\t\t\tlet focus: boolean;\n\t\t\tlet panel: Tasks.PanelKind;\n\t\t\tlet showReuseMessage: boolean;\n\t\t\tlet clear: boolean;\n\t\t\tlet group: string | undefined;\n\t\t\tlet hasProps = false;\n\t\t\tif (Types.isBoolean(config.echoCommand)) {\n\t\t\t\techo = config.echoCommand;\n\t\t\t\thasProps = true;\n\t\t\t}\n\t\t\tif (Types.isString(config.showOutput)) {\n\t\t\t\treveal = Tasks.RevealKind.fromString(config.showOutput);\n\t\t\t\thasProps = true;\n\t\t\t}\n\t\t\tlet presentation = config.presentation || config.terminal;\n\t\t\tif (presentation) {\n\t\t\t\tif (Types.isBoolean(presentation.echo)) {\n\t\t\t\t\techo = presentation.echo;\n\t\t\t\t}\n\t\t\t\tif (Types.isString(presentation.reveal)) {\n\t\t\t\t\treveal = Tasks.RevealKind.fromString(presentation.reveal);\n\t\t\t\t}\n\t\t\t\tif (Types.isBoolean(presentation.focus)) {\n\t\t\t\t\tfocus = presentation.focus;\n\t\t\t\t}\n\t\t\t\tif (Types.isString(presentation.panel)) {\n\t\t\t\t\tpanel = Tasks.PanelKind.fromString(presentation.panel);\n\t\t\t\t}\n\t\t\t\tif (Types.isBoolean(presentation.showReuseMessage)) {\n\t\t\t\t\tshowReuseMessage = presentation.showReuseMessage;\n\t\t\t\t}\n\t\t\t\tif (Types.isBoolean(presentation.clear)) {\n\t\t\t\t\tclear = presentation.clear;\n\t\t\t\t}\n\t\t\t\tif (Types.isString(presentation.group)) {\n\t\t\t\t\tgroup = presentation.group;\n\t\t\t\t}\n\t\t\t\thasProps = true;\n\t\t\t}\n\t\t\tif (!hasProps) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\treturn { echo: echo!, reveal: reveal!, focus: focus!, panel: panel!, showReuseMessage: showReuseMessage!, clear: clear!, group };\n\t\t}\n\n\t\texport function assignProperties(target: Tasks.PresentationOptions, source: Tasks.PresentationOptions | undefined): Tasks.PresentationOptions | undefined {\n\t\t\treturn _assignProperties(target, source, properties);\n\t\t}\n\n\t\texport function fillProperties(target: Tasks.PresentationOptions, source: Tasks.PresentationOptions | undefined): Tasks.PresentationOptions | undefined {\n\t\t\treturn _fillProperties(target, source, properties);\n\t\t}\n\n\t\texport function fillDefaults(value: Tasks.PresentationOptions, context: ParseContext): Tasks.PresentationOptions | undefined {\n\t\t\tlet defaultEcho = context.engine === Tasks.ExecutionEngine.Terminal ? true : false;\n\t\t\treturn _fillDefaults(value, { echo: defaultEcho, reveal: Tasks.RevealKind.Always, focus: false, panel: Tasks.PanelKind.Shared, showReuseMessage: true, clear: false }, properties, context);\n\t\t}\n\n\t\texport function freeze(value: Tasks.PresentationOptions): Readonly<Tasks.PresentationOptions> | undefined {\n\t\t\treturn _freeze(value, properties);\n\t\t}\n\n\t\texport function isEmpty(this: void, value: Tasks.PresentationOptions): boolean {\n\t\t\treturn _isEmpty(value, properties);\n\t\t}\n\t}\n\n\tnamespace ShellString {\n\t\texport function from(this: void, value: CommandString | undefined): Tasks.CommandString | undefined {\n\t\t\tif (value === undefined || value === null) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (Types.isString(value)) {\n\t\t\t\treturn value;\n\t\t\t} else if (Types.isStringArray(value)) {\n\t\t\t\treturn value.join(' ');\n\t\t\t} else {\n\t\t\t\tlet quoting = Tasks.ShellQuoting.from(value.quoting);\n\t\t\t\tlet result = Types.isString(value.value) ? value.value : Types.isStringArray(value.value) ? value.value.join(' ') : undefined;\n\t\t\t\tif (result) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: result,\n\t\t\t\t\t\tquoting: quoting\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tinterface BaseCommandConfiguationShape extends BaseCommandProperties, LegacyCommandProperties {\n\t}\n\n\tinterface CommandConfiguationShape extends BaseCommandConfiguationShape {\n\t\twindows?: BaseCommandConfiguationShape;\n\t\tosx?: BaseCommandConfiguationShape;\n\t\tlinux?: BaseCommandConfiguationShape;\n\t}\n\n\tconst properties: MetaData<Tasks.CommandConfiguration, any>[] = [\n\t\t{ property: 'runtime' }, { property: 'name' }, { property: 'options', type: CommandOptions },\n\t\t{ property: 'args' }, { property: 'taskSelector' }, { property: 'suppressTaskName' },\n\t\t{ property: 'presentation', type: PresentationOptions }\n\t];\n\n\texport function from(this: void, config: CommandConfiguationShape, context: ParseContext): Tasks.CommandConfiguration | undefined {\n\t\tlet result: Tasks.CommandConfiguration = fromBase(config, context)!;\n\n\t\tlet osConfig: Tasks.CommandConfiguration | undefined = undefined;\n\t\tif (config.windows && context.platform === Platform.Windows) {\n\t\t\tosConfig = fromBase(config.windows, context);\n\t\t} else if (config.osx && context.platform === Platform.Mac) {\n\t\t\tosConfig = fromBase(config.osx, context);\n\t\t} else if (config.linux && context.platform === Platform.Linux) {\n\t\t\tosConfig = fromBase(config.linux, context);\n\t\t}\n\t\tif (osConfig) {\n\t\t\tresult = assignProperties(result, osConfig, context.schemaVersion === Tasks.JsonSchemaVersion.V2_0_0);\n\t\t}\n\t\treturn isEmpty(result) ? undefined : result;\n\t}\n\n\tfunction fromBase(this: void, config: BaseCommandConfiguationShape, context: ParseContext): Tasks.CommandConfiguration | undefined {\n\t\tlet name: Tasks.CommandString | undefined = ShellString.from(config.command);\n\t\tlet runtime: Tasks.RuntimeType;\n\t\tif (Types.isString(config.type)) {\n\t\t\tif (config.type === 'shell' || config.type === 'process') {\n\t\t\t\truntime = Tasks.RuntimeType.fromString(config.type);\n\t\t\t}\n\t\t}\n\t\tlet isShellConfiguration = ShellConfiguration.is(config.isShellCommand);\n\t\tif (Types.isBoolean(config.isShellCommand) || isShellConfiguration) {\n\t\t\truntime = Tasks.RuntimeType.Shell;\n\t\t} else if (config.isShellCommand !== undefined) {\n\t\t\truntime = !!config.isShellCommand ? Tasks.RuntimeType.Shell : Tasks.RuntimeType.Process;\n\t\t}\n\n\t\tlet result: Tasks.CommandConfiguration = {\n\t\t\tname: name,\n\t\t\truntime: runtime!,\n\t\t\tpresentation: PresentationOptions.from(config, context)!\n\t\t};\n\n\t\tif (config.args !== undefined) {\n\t\t\tresult.args = [];\n\t\t\tfor (let arg of config.args) {\n\t\t\t\tlet converted = ShellString.from(arg);\n\t\t\t\tif (converted !== undefined) {\n\t\t\t\t\tresult.args.push(converted);\n\t\t\t\t} else {\n\t\t\t\t\tcontext.taskLoadIssues.push(\n\t\t\t\t\t\tnls.localize(\n\t\t\t\t\t\t\t'ConfigurationParser.inValidArg',\n\t\t\t\t\t\t\t'Error: command argument must either be a string or a quoted string. Provided value is:\\n{0}',\n\t\t\t\t\t\t\targ ? JSON.stringify(arg, undefined, 4) : 'undefined'\n\t\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (config.options !== undefined) {\n\t\t\tresult.options = CommandOptions.from(config.options, context);\n\t\t\tif (result.options && result.options.shell === undefined && isShellConfiguration) {\n\t\t\t\tresult.options.shell = ShellConfiguration.from(config.isShellCommand as ShellConfiguration, context);\n\t\t\t\tif (context.engine !== Tasks.ExecutionEngine.Terminal) {\n\t\t\t\t\tcontext.taskLoadIssues.push(nls.localize('ConfigurationParser.noShell', 'Warning: shell configuration is only supported when executing tasks in the terminal.'));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Types.isString(config.taskSelector)) {\n\t\t\tresult.taskSelector = config.taskSelector;\n\t\t}\n\t\tif (Types.isBoolean(config.suppressTaskName)) {\n\t\t\tresult.suppressTaskName = config.suppressTaskName;\n\t\t}\n\n\t\treturn isEmpty(result) ? undefined : result;\n\t}\n\n\texport function hasCommand(value: Tasks.CommandConfiguration): boolean {\n\t\treturn value && !!value.name;\n\t}\n\n\texport function isEmpty(value: Tasks.CommandConfiguration | undefined): boolean {\n\t\treturn _isEmpty(value, properties);\n\t}\n\n\texport function assignProperties(target: Tasks.CommandConfiguration, source: Tasks.CommandConfiguration, overwriteArgs: boolean): Tasks.CommandConfiguration {\n\t\tif (isEmpty(source)) {\n\t\t\treturn target;\n\t\t}\n\t\tif (isEmpty(target)) {\n\t\t\treturn source;\n\t\t}\n\t\tassignProperty(target, source, 'name');\n\t\tassignProperty(target, source, 'runtime');\n\t\tassignProperty(target, source, 'taskSelector');\n\t\tassignProperty(target, source, 'suppressTaskName');\n\t\tif (source.args !== undefined) {\n\t\t\tif (target.args === undefined || overwriteArgs) {\n\t\t\t\ttarget.args = source.args;\n\t\t\t} else {\n\t\t\t\ttarget.args = target.args.concat(source.args);\n\t\t\t}\n\t\t}\n\t\ttarget.presentation = PresentationOptions.assignProperties(target.presentation!, source.presentation)!;\n\t\ttarget.options = CommandOptions.assignProperties(target.options, source.options);\n\t\treturn target;\n\t}\n\n\texport function fillProperties(target: Tasks.CommandConfiguration, source: Tasks.CommandConfiguration): Tasks.CommandConfiguration {\n\t\treturn _fillProperties(target, source, properties);\n\t}\n\n\texport function fillGlobals(target: Tasks.CommandConfiguration, source: Tasks.CommandConfiguration | undefined, taskName: string | undefined): Tasks.CommandConfiguration {\n\t\tif ((source === undefined) || isEmpty(source)) {\n\t\t\treturn target;\n\t\t}\n\t\ttarget = target || {\n\t\t\tname: undefined,\n\t\t\truntime: undefined,\n\t\t\tpresentation: undefined\n\t\t};\n\t\tif (target.name === undefined) {\n\t\t\tfillProperty(target, source, 'name');\n\t\t\tfillProperty(target, source, 'taskSelector');\n\t\t\tfillProperty(target, source, 'suppressTaskName');\n\t\t\tlet args: Tasks.CommandString[] = source.args ? source.args.slice() : [];\n\t\t\tif (!target.suppressTaskName && taskName) {\n\t\t\t\tif (target.taskSelector !== undefined) {\n\t\t\t\t\targs.push(target.taskSelector + taskName);\n\t\t\t\t} else {\n\t\t\t\t\targs.push(taskName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (target.args) {\n\t\t\t\targs = args.concat(target.args);\n\t\t\t}\n\t\t\ttarget.args = args;\n\t\t}\n\t\tfillProperty(target, source, 'runtime');\n\n\t\ttarget.presentation = PresentationOptions.fillProperties(target.presentation!, source.presentation)!;\n\t\ttarget.options = CommandOptions.fillProperties(target.options, source.options);\n\n\t\treturn target;\n\t}\n\n\texport function fillDefaults(value: Tasks.CommandConfiguration | undefined, context: ParseContext): void {\n\t\tif (!value || Object.isFrozen(value)) {\n\t\t\treturn;\n\t\t}\n\t\tif (value.name !== undefined && value.runtime === undefined) {\n\t\t\tvalue.runtime = Tasks.RuntimeType.Process;\n\t\t}\n\t\tvalue.presentation = PresentationOptions.fillDefaults(value.presentation!, context)!;\n\t\tif (!isEmpty(value)) {\n\t\t\tvalue.options = CommandOptions.fillDefaults(value.options, context);\n\t\t}\n\t\tif (value.args === undefined) {\n\t\t\tvalue.args = EMPTY_ARRAY;\n\t\t}\n\t\tif (value.suppressTaskName === undefined) {\n\t\t\tvalue.suppressTaskName = false;\n\t\t}\n\t}\n\n\texport function freeze(value: Tasks.CommandConfiguration): Readonly<Tasks.CommandConfiguration> | undefined {\n\t\treturn _freeze(value, properties);\n\t}\n}\n\nnamespace ProblemMatcherConverter {\n\n\texport function namedFrom(this: void, declares: ProblemMatcherConfig.NamedProblemMatcher[] | undefined, context: ParseContext): IStringDictionary<NamedProblemMatcher> {\n\t\tlet result: IStringDictionary<NamedProblemMatcher> = Object.create(null);\n\n\t\tif (!Types.isArray(declares)) {\n\t\t\treturn result;\n\t\t}\n\t\t(<ProblemMatcherConfig.NamedProblemMatcher[]>declares).forEach((value) => {\n\t\t\tlet namedProblemMatcher = (new ProblemMatcherParser(context.problemReporter)).parse(value);\n\t\t\tif (isNamedProblemMatcher(namedProblemMatcher)) {\n\t\t\t\tresult[namedProblemMatcher.name] = namedProblemMatcher;\n\t\t\t} else {\n\t\t\t\tcontext.problemReporter.error(nls.localize('ConfigurationParser.noName', 'Error: Problem Matcher in declare scope must have a name:\\n{0}\\n', JSON.stringify(value, undefined, 4)));\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}\n\n\texport function from(this: void, config: ProblemMatcherConfig.ProblemMatcherType | undefined, context: ParseContext): ProblemMatcher[] {\n\t\tlet result: ProblemMatcher[] = [];\n\t\tif (config === undefined) {\n\t\t\treturn result;\n\t\t}\n\t\tlet kind = getProblemMatcherKind(config);\n\t\tif (kind === ProblemMatcherKind.Unknown) {\n\t\t\tcontext.problemReporter.warn(nls.localize(\n\t\t\t\t'ConfigurationParser.unknownMatcherKind',\n\t\t\t\t'Warning: the defined problem matcher is unknown. Supported types are string | ProblemMatcher | Array<string | ProblemMatcher>.\\n{0}\\n',\n\t\t\t\tJSON.stringify(config, null, 4)));\n\t\t\treturn result;\n\t\t} else if (kind === ProblemMatcherKind.String || kind === ProblemMatcherKind.ProblemMatcher) {\n\t\t\tlet matcher = resolveProblemMatcher(config as ProblemMatcherConfig.ProblemMatcher, context);\n\t\t\tif (matcher) {\n\t\t\t\tresult.push(matcher);\n\t\t\t}\n\t\t} else if (kind === ProblemMatcherKind.Array) {\n\t\t\tlet problemMatchers = <(string | ProblemMatcherConfig.ProblemMatcher)[]>config;\n\t\t\tproblemMatchers.forEach(problemMatcher => {\n\t\t\t\tlet matcher = resolveProblemMatcher(problemMatcher, context);\n\t\t\t\tif (matcher) {\n\t\t\t\t\tresult.push(matcher);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction getProblemMatcherKind(this: void, value: ProblemMatcherConfig.ProblemMatcherType): ProblemMatcherKind {\n\t\tif (Types.isString(value)) {\n\t\t\treturn ProblemMatcherKind.String;\n\t\t} else if (Types.isArray(value)) {\n\t\t\treturn ProblemMatcherKind.Array;\n\t\t} else if (!Types.isUndefined(value)) {\n\t\t\treturn ProblemMatcherKind.ProblemMatcher;\n\t\t} else {\n\t\t\treturn ProblemMatcherKind.Unknown;\n\t\t}\n\t}\n\n\tfunction resolveProblemMatcher(this: void, value: string | ProblemMatcherConfig.ProblemMatcher, context: ParseContext): ProblemMatcher | undefined {\n\t\tif (Types.isString(value)) {\n\t\t\tlet variableName = <string>value;\n\t\t\tif (variableName.length > 1 && variableName[0] === '$') {\n\t\t\t\tvariableName = variableName.substring(1);\n\t\t\t\tlet global = ProblemMatcherRegistry.get(variableName);\n\t\t\t\tif (global) {\n\t\t\t\t\treturn Objects.deepClone(global);\n\t\t\t\t}\n\t\t\t\tlet localProblemMatcher = context.namedProblemMatchers[variableName];\n\t\t\t\tif (localProblemMatcher) {\n\t\t\t\t\tlocalProblemMatcher = Objects.deepClone(localProblemMatcher);\n\t\t\t\t\t// remove the name\n\t\t\t\t\tdelete localProblemMatcher.name;\n\t\t\t\t\treturn localProblemMatcher;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontext.taskLoadIssues.push(nls.localize('ConfigurationParser.invalidVaraibleReference', 'Error: Invalid problemMatcher reference: {0}\\n', value));\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tlet json = <ProblemMatcherConfig.ProblemMatcher>value;\n\t\t\treturn new ProblemMatcherParser(context.problemReporter).parse(json);\n\t\t}\n\t}\n}\n\nconst source: Partial<Tasks.TaskSource> = {\n\tkind: Tasks.TaskSourceKind.Workspace,\n\tlabel: 'Workspace',\n\tconfig: undefined\n};\n\nnamespace GroupKind {\n\texport function from(this: void, external: string | GroupKind | undefined): [string, Tasks.GroupType] | undefined {\n\t\tif (external === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (Types.isString(external)) {\n\t\t\tif (Tasks.TaskGroup.is(external)) {\n\t\t\t\treturn [external, Tasks.GroupType.user];\n\t\t\t} else {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\t\tif (!Types.isString(external.kind) || !Tasks.TaskGroup.is(external.kind)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet group: string = external.kind;\n\t\tlet isDefault: boolean = !!external.isDefault;\n\n\t\treturn [group, isDefault ? Tasks.GroupType.default : Tasks.GroupType.user];\n\t}\n}\n\nnamespace TaskDependency {\n\texport function from(this: void, external: string | TaskIdentifier, context: ParseContext): Tasks.TaskDependency | undefined {\n\t\tif (Types.isString(external)) {\n\t\t\treturn { workspaceFolder: context.workspaceFolder, task: external };\n\t\t} else if (TaskIdentifier.is(external)) {\n\t\t\treturn { workspaceFolder: context.workspaceFolder, task: Tasks.TaskDefinition.createTaskIdentifier(external as Tasks.TaskIdentifier, context.problemReporter) };\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nnamespace ConfigurationProperties {\n\n\tconst properties: MetaData<Tasks.ConfigurationProperties, any>[] = [\n\n\t\t{ property: 'name' }, { property: 'identifier' }, { property: 'group' }, { property: 'isBackground' },\n\t\t{ property: 'promptOnClose' }, { property: 'dependsOn' },\n\t\t{ property: 'presentation', type: CommandConfiguration.PresentationOptions }, { property: 'problemMatchers' }\n\t];\n\n\texport function from(this: void, external: ConfigurationProperties, context: ParseContext, includeCommandOptions: boolean): Tasks.ConfigurationProperties | undefined {\n\t\tif (!external) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet result: Tasks.ConfigurationProperties = {};\n\t\tif (Types.isString(external.taskName)) {\n\t\t\tresult.name = external.taskName;\n\t\t}\n\t\tif (Types.isString(external.label) && context.schemaVersion === Tasks.JsonSchemaVersion.V2_0_0) {\n\t\t\tresult.name = external.label;\n\t\t}\n\t\tif (Types.isString(external.identifier)) {\n\t\t\tresult.identifier = external.identifier;\n\t\t}\n\t\tif (external.isBackground !== undefined) {\n\t\t\tresult.isBackground = !!external.isBackground;\n\t\t}\n\t\tif (external.promptOnClose !== undefined) {\n\t\t\tresult.promptOnClose = !!external.promptOnClose;\n\t\t}\n\t\tif (external.group !== undefined) {\n\t\t\tif (Types.isString(external.group) && Tasks.TaskGroup.is(external.group)) {\n\t\t\t\tresult.group = external.group;\n\t\t\t\tresult.groupType = Tasks.GroupType.user;\n\t\t\t} else {\n\t\t\t\tlet values = GroupKind.from(external.group);\n\t\t\t\tif (values) {\n\t\t\t\t\tresult.group = values[0];\n\t\t\t\t\tresult.groupType = values[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (external.dependsOn !== undefined) {\n\t\t\tif (Types.isArray(external.dependsOn)) {\n\t\t\t\tresult.dependsOn = external.dependsOn.reduce((dependencies: Tasks.TaskDependency[], item): Tasks.TaskDependency[] => {\n\t\t\t\t\tconst dependency = TaskDependency.from(item, context);\n\t\t\t\t\tif (dependency) {\n\t\t\t\t\t\tdependencies.push(dependency);\n\t\t\t\t\t}\n\t\t\t\t\treturn dependencies;\n\t\t\t\t}, []);\n\t\t\t} else {\n\t\t\t\tconst dependsOnValue = TaskDependency.from(external.dependsOn, context);\n\t\t\t\tresult.dependsOn = dependsOnValue ? [dependsOnValue] : undefined;\n\t\t\t}\n\t\t}\n\t\tif (includeCommandOptions && (external.presentation !== undefined || (external as LegacyCommandProperties).terminal !== undefined)) {\n\t\t\tresult.presentation = CommandConfiguration.PresentationOptions.from(external, context);\n\t\t}\n\t\tif (includeCommandOptions && (external.options !== undefined)) {\n\t\t\tresult.options = CommandOptions.from(external.options, context);\n\t\t}\n\t\tif (external.problemMatcher) {\n\t\t\tresult.problemMatchers = ProblemMatcherConverter.from(external.problemMatcher, context);\n\t\t}\n\t\treturn isEmpty(result) ? undefined : result;\n\t}\n\n\texport function isEmpty(this: void, value: Tasks.ConfigurationProperties): boolean {\n\t\treturn _isEmpty(value, properties);\n\t}\n}\n\nnamespace ConfiguringTask {\n\n\tconst grunt = 'grunt.';\n\tconst jake = 'jake.';\n\tconst gulp = 'gulp.';\n\tconst npm = 'vscode.npm.';\n\tconst typescript = 'vscode.typescript.';\n\n\tinterface CustomizeShape {\n\t\tcustomize: string;\n\t}\n\n\texport function from(this: void, external: ConfiguringTask, context: ParseContext, index: number): Tasks.ConfiguringTask | undefined {\n\t\tif (!external) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet type = external.type;\n\t\tlet customize = (external as CustomizeShape).customize;\n\t\tif (!type && !customize) {\n\t\t\tcontext.problemReporter.error(nls.localize('ConfigurationParser.noTaskType', 'Error: tasks configuration must have a type property. The configuration will be ignored.\\n{0}\\n', JSON.stringify(external, null, 4)));\n\t\t\treturn undefined;\n\t\t}\n\t\tlet typeDeclaration = type ? TaskDefinitionRegistry.get(type) : undefined;\n\t\tif (!typeDeclaration) {\n\t\t\tlet message = nls.localize('ConfigurationParser.noTypeDefinition', 'Error: there is no registered task type \\'{0}\\'. Did you miss to install an extension that provides a corresponding task provider?', type);\n\t\t\tcontext.problemReporter.error(message);\n\t\t\treturn undefined;\n\t\t}\n\t\tlet identifier: Tasks.TaskIdentifier | undefined;\n\t\tif (Types.isString(customize)) {\n\t\t\tif (customize.indexOf(grunt) === 0) {\n\t\t\t\tidentifier = { type: 'grunt', task: customize.substring(grunt.length) };\n\t\t\t} else if (customize.indexOf(jake) === 0) {\n\t\t\t\tidentifier = { type: 'jake', task: customize.substring(jake.length) };\n\t\t\t} else if (customize.indexOf(gulp) === 0) {\n\t\t\t\tidentifier = { type: 'gulp', task: customize.substring(gulp.length) };\n\t\t\t} else if (customize.indexOf(npm) === 0) {\n\t\t\t\tidentifier = { type: 'npm', script: customize.substring(npm.length + 4) };\n\t\t\t} else if (customize.indexOf(typescript) === 0) {\n\t\t\t\tidentifier = { type: 'typescript', tsconfig: customize.substring(typescript.length + 6) };\n\t\t\t}\n\t\t} else {\n\t\t\tif (Types.isString(external.type)) {\n\t\t\t\tidentifier = external as Tasks.TaskIdentifier;\n\t\t\t}\n\t\t}\n\t\tif (identifier === undefined) {\n\t\t\tcontext.problemReporter.error(nls.localize(\n\t\t\t\t'ConfigurationParser.missingType',\n\t\t\t\t'Error: the task configuration \\'{0}\\' is missing the required property \\'type\\'. The task configuration will be ignored.', JSON.stringify(external, undefined, 0)\n\t\t\t));\n\t\t\treturn undefined;\n\t\t}\n\t\tlet taskIdentifier: Tasks.KeyedTaskIdentifier | undefined = Tasks.TaskDefinition.createTaskIdentifier(identifier, context.problemReporter);\n\t\tif (taskIdentifier === undefined) {\n\t\t\tcontext.problemReporter.error(nls.localize(\n\t\t\t\t'ConfigurationParser.incorrectType',\n\t\t\t\t'Error: the task configuration \\'{0}\\' is using an unknown type. The task configuration will be ignored.', JSON.stringify(external, undefined, 0)\n\t\t\t));\n\t\t\treturn undefined;\n\t\t}\n\t\tlet configElement: Tasks.TaskSourceConfigElement = {\n\t\t\tworkspaceFolder: context.workspaceFolder,\n\t\t\tfile: '.vscode/tasks.json',\n\t\t\tindex,\n\t\t\telement: external\n\t\t};\n\t\tlet result: Tasks.ConfiguringTask = new Tasks.ConfiguringTask(\n\t\t\t`${typeDeclaration.extensionId}.${taskIdentifier._key}`,\n\t\t\tObjects.assign({} as Tasks.WorkspaceTaskSource, source, { config: configElement }),\n\t\t\tundefined,\n\t\t\ttype,\n\t\t\ttaskIdentifier,\n\t\t\tRunOptions.fromConfiguration(external.runOptions),\n\t\t\t{}\n\t\t);\n\t\tlet configuration = ConfigurationProperties.from(external, context, true);\n\t\tif (configuration) {\n\t\t\tresult.configurationProperties = Objects.assign(result.configurationProperties, configuration);\n\t\t\tif (result.configurationProperties.name) {\n\t\t\t\tresult._label = result.configurationProperties.name;\n\t\t\t} else {\n\t\t\t\tlet label = result.configures.type;\n\t\t\t\tif (typeDeclaration.required && typeDeclaration.required.length > 0) {\n\t\t\t\t\tfor (let required of typeDeclaration.required) {\n\t\t\t\t\t\tlet value = result.configures[required];\n\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\tlabel = label + ' ' + value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult._label = label;\n\t\t\t}\n\t\t\tif (!result.configurationProperties.identifier) {\n\t\t\t\tresult.configurationProperties.identifier = taskIdentifier._key;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nnamespace CustomTask {\n\n\texport function from(this: void, external: CustomTask, context: ParseContext, index: number): Tasks.CustomTask | undefined {\n\t\tif (!external) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet type = external.type;\n\t\tif (type === undefined || type === null) {\n\t\t\ttype = Tasks.CUSTOMIZED_TASK_TYPE;\n\t\t}\n\t\tif (type !== Tasks.CUSTOMIZED_TASK_TYPE && type !== 'shell' && type !== 'process') {\n\t\t\tcontext.problemReporter.error(nls.localize('ConfigurationParser.notCustom', 'Error: tasks is not declared as a custom task. The configuration will be ignored.\\n{0}\\n', JSON.stringify(external, null, 4)));\n\t\t\treturn undefined;\n\t\t}\n\t\tlet taskName = external.taskName;\n\t\tif (Types.isString(external.label) && context.schemaVersion === Tasks.JsonSchemaVersion.V2_0_0) {\n\t\t\ttaskName = external.label;\n\t\t}\n\t\tif (!taskName) {\n\t\t\tcontext.problemReporter.error(nls.localize('ConfigurationParser.noTaskName', 'Error: a task must provide a label property. The task will be ignored.\\n{0}\\n', JSON.stringify(external, null, 4)));\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet result: Tasks.CustomTask = new Tasks.CustomTask(\n\t\t\tcontext.uuidMap.getUUID(taskName),\n\t\t\tObjects.assign({} as Tasks.WorkspaceTaskSource, source, { config: { index, element: external, file: '.vscode/tasks.json', workspaceFolder: context.workspaceFolder } }),\n\t\t\ttaskName,\n\t\t\tTasks.CUSTOMIZED_TASK_TYPE,\n\t\t\tundefined,\n\t\t\tfalse,\n\t\t\tRunOptions.fromConfiguration(external.runOptions),\n\t\t\t{\n\t\t\t\tname: taskName,\n\t\t\t\tidentifier: taskName,\n\t\t\t}\n\t\t);\n\t\tlet configuration = ConfigurationProperties.from(external, context, false);\n\t\tif (configuration) {\n\t\t\tresult.configurationProperties = Objects.assign(result.configurationProperties, configuration);\n\t\t}\n\t\tlet supportLegacy: boolean = true; //context.schemaVersion === Tasks.JsonSchemaVersion.V2_0_0;\n\t\tif (supportLegacy) {\n\t\t\tlet legacy: LegacyTaskProperties = external as LegacyTaskProperties;\n\t\t\tif (result.configurationProperties.isBackground === undefined && legacy.isWatching !== undefined) {\n\t\t\t\tresult.configurationProperties.isBackground = !!legacy.isWatching;\n\t\t\t}\n\t\t\tif (result.configurationProperties.group === undefined) {\n\t\t\t\tif (legacy.isBuildCommand === true) {\n\t\t\t\t\tresult.configurationProperties.group = Tasks.TaskGroup.Build;\n\t\t\t\t} else if (legacy.isTestCommand === true) {\n\t\t\t\t\tresult.configurationProperties.group = Tasks.TaskGroup.Test;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet command: Tasks.CommandConfiguration = CommandConfiguration.from(external, context)!;\n\t\tif (command) {\n\t\t\tresult.command = command;\n\t\t}\n\t\tif (external.command !== undefined) {\n\t\t\t// if the task has its own command then we suppress the\n\t\t\t// task name by default.\n\t\t\tcommand.suppressTaskName = true;\n\t\t}\n\t\treturn result;\n\t}\n\n\texport function fillGlobals(task: Tasks.CustomTask, globals: Globals): void {\n\t\t// We only merge a command from a global definition if there is no dependsOn\n\t\t// or there is a dependsOn and a defined command.\n\t\tif (CommandConfiguration.hasCommand(task.command) || task.configurationProperties.dependsOn === undefined) {\n\t\t\ttask.command = CommandConfiguration.fillGlobals(task.command, globals.command, task.configurationProperties.name);\n\t\t}\n\t\tif (task.configurationProperties.problemMatchers === undefined && globals.problemMatcher !== undefined) {\n\t\t\ttask.configurationProperties.problemMatchers = Objects.deepClone(globals.problemMatcher);\n\t\t\ttask.hasDefinedMatchers = true;\n\t\t}\n\t\t// promptOnClose is inferred from isBackground if available\n\t\tif (task.configurationProperties.promptOnClose === undefined && task.configurationProperties.isBackground === undefined && globals.promptOnClose !== undefined) {\n\t\t\ttask.configurationProperties.promptOnClose = globals.promptOnClose;\n\t\t}\n\t}\n\n\texport function fillDefaults(task: Tasks.CustomTask, context: ParseContext): void {\n\t\tCommandConfiguration.fillDefaults(task.command, context);\n\t\tif (task.configurationProperties.promptOnClose === undefined) {\n\t\t\ttask.configurationProperties.promptOnClose = task.configurationProperties.isBackground !== undefined ? !task.configurationProperties.isBackground : true;\n\t\t}\n\t\tif (task.configurationProperties.isBackground === undefined) {\n\t\t\ttask.configurationProperties.isBackground = false;\n\t\t}\n\t\tif (task.configurationProperties.problemMatchers === undefined) {\n\t\t\ttask.configurationProperties.problemMatchers = EMPTY_ARRAY;\n\t\t}\n\t\tif (task.configurationProperties.group !== undefined && task.configurationProperties.groupType === undefined) {\n\t\t\ttask.configurationProperties.groupType = Tasks.GroupType.user;\n\t\t}\n\t}\n\n\texport function createCustomTask(contributedTask: Tasks.ContributedTask, configuredProps: Tasks.ConfiguringTask | Tasks.CustomTask): Tasks.CustomTask {\n\t\tlet result: Tasks.CustomTask = new Tasks.CustomTask(\n\t\t\tconfiguredProps._id,\n\t\t\tObjects.assign({}, configuredProps._source, { customizes: contributedTask.defines }),\n\t\t\tconfiguredProps.configurationProperties.name || contributedTask._label,\n\t\t\tTasks.CUSTOMIZED_TASK_TYPE,\n\t\t\tcontributedTask.command,\n\t\t\tfalse,\n\t\t\tcontributedTask.runOptions,\n\t\t\t{\n\t\t\t\tname: configuredProps.configurationProperties.name || contributedTask.configurationProperties.name,\n\t\t\t\tidentifier: configuredProps.configurationProperties.identifier || contributedTask.configurationProperties.identifier,\n\t\t\t}\n\t\t);\n\t\tresult.addTaskLoadMessages(configuredProps.taskLoadMessages);\n\t\tlet resultConfigProps: Tasks.ConfigurationProperties = result.configurationProperties;\n\n\t\tassignProperty(resultConfigProps, configuredProps.configurationProperties, 'group');\n\t\tassignProperty(resultConfigProps, configuredProps.configurationProperties, 'groupType');\n\t\tassignProperty(resultConfigProps, configuredProps.configurationProperties, 'isBackground');\n\t\tassignProperty(resultConfigProps, configuredProps.configurationProperties, 'dependsOn');\n\t\tassignProperty(resultConfigProps, configuredProps.configurationProperties, 'problemMatchers');\n\t\tassignProperty(resultConfigProps, configuredProps.configurationProperties, 'promptOnClose');\n\t\tresult.command.presentation = CommandConfiguration.PresentationOptions.assignProperties(\n\t\t\tresult.command.presentation!, configuredProps.configurationProperties.presentation)!;\n\t\tresult.command.options = CommandOptions.assignProperties(result.command.options, configuredProps.configurationProperties.options);\n\n\t\tlet contributedConfigProps: Tasks.ConfigurationProperties = contributedTask.configurationProperties;\n\t\tfillProperty(resultConfigProps, contributedConfigProps, 'group');\n\t\tfillProperty(resultConfigProps, contributedConfigProps, 'groupType');\n\t\tfillProperty(resultConfigProps, contributedConfigProps, 'isBackground');\n\t\tfillProperty(resultConfigProps, contributedConfigProps, 'dependsOn');\n\t\tfillProperty(resultConfigProps, contributedConfigProps, 'problemMatchers');\n\t\tfillProperty(resultConfigProps, contributedConfigProps, 'promptOnClose');\n\t\tresult.command.presentation = CommandConfiguration.PresentationOptions.fillProperties(\n\t\t\tresult.command.presentation!, contributedConfigProps.presentation)!;\n\t\tresult.command.options = CommandOptions.fillProperties(result.command.options, contributedConfigProps.options);\n\n\t\tif (contributedTask.hasDefinedMatchers === true) {\n\t\t\tresult.hasDefinedMatchers = true;\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\ninterface TaskParseResult {\n\tcustom: Tasks.CustomTask[];\n\tconfigured: Tasks.ConfiguringTask[];\n}\n\nnamespace TaskParser {\n\n\tfunction isCustomTask(value: CustomTask | ConfiguringTask): value is CustomTask {\n\t\tlet type = value.type;\n\t\tlet customize = (value as any).customize;\n\t\treturn customize === undefined && (type === undefined || type === null || type === Tasks.CUSTOMIZED_TASK_TYPE || type === 'shell' || type === 'process');\n\t}\n\n\texport function from(this: void, externals: Array<CustomTask | ConfiguringTask> | undefined, globals: Globals, context: ParseContext): TaskParseResult {\n\t\tlet result: TaskParseResult = { custom: [], configured: [] };\n\t\tif (!externals) {\n\t\t\treturn result;\n\t\t}\n\t\tlet defaultBuildTask: { task: Tasks.Task | undefined; rank: number; } = { task: undefined, rank: -1 };\n\t\tlet defaultTestTask: { task: Tasks.Task | undefined; rank: number; } = { task: undefined, rank: -1 };\n\t\tlet schema2_0_0: boolean = context.schemaVersion === Tasks.JsonSchemaVersion.V2_0_0;\n\t\tconst baseLoadIssues = Objects.deepClone(context.taskLoadIssues);\n\t\tfor (let index = 0; index < externals.length; index++) {\n\t\t\tlet external = externals[index];\n\t\t\tif (isCustomTask(external)) {\n\t\t\t\tlet customTask = CustomTask.from(external, context, index);\n\t\t\t\tif (customTask) {\n\t\t\t\t\tCustomTask.fillGlobals(customTask, globals);\n\t\t\t\t\tCustomTask.fillDefaults(customTask, context);\n\t\t\t\t\tif (schema2_0_0) {\n\t\t\t\t\t\tif ((customTask.command === undefined || customTask.command.name === undefined) && (customTask.configurationProperties.dependsOn === undefined || customTask.configurationProperties.dependsOn.length === 0)) {\n\t\t\t\t\t\t\tcontext.problemReporter.error(nls.localize(\n\t\t\t\t\t\t\t\t'taskConfiguration.noCommandOrDependsOn', 'Error: the task \\'{0}\\' neither specifies a command nor a dependsOn property. The task will be ignored. Its definition is:\\n{1}',\n\t\t\t\t\t\t\t\tcustomTask.configurationProperties.name, JSON.stringify(external, undefined, 4)\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (customTask.command === undefined || customTask.command.name === undefined) {\n\t\t\t\t\t\t\tcontext.problemReporter.warn(nls.localize(\n\t\t\t\t\t\t\t\t'taskConfiguration.noCommand', 'Error: the task \\'{0}\\' doesn\\'t define a command. The task will be ignored. Its definition is:\\n{1}',\n\t\t\t\t\t\t\t\tcustomTask.configurationProperties.name, JSON.stringify(external, undefined, 4)\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (customTask.configurationProperties.group === Tasks.TaskGroup.Build && defaultBuildTask.rank < 2) {\n\t\t\t\t\t\tdefaultBuildTask.task = customTask;\n\t\t\t\t\t\tdefaultBuildTask.rank = 2;\n\t\t\t\t\t} else if (customTask.configurationProperties.group === Tasks.TaskGroup.Test && defaultTestTask.rank < 2) {\n\t\t\t\t\t\tdefaultTestTask.task = customTask;\n\t\t\t\t\t\tdefaultTestTask.rank = 2;\n\t\t\t\t\t} else if (customTask.configurationProperties.name === 'build' && defaultBuildTask.rank < 1) {\n\t\t\t\t\t\tdefaultBuildTask.task = customTask;\n\t\t\t\t\t\tdefaultBuildTask.rank = 1;\n\t\t\t\t\t} else if (customTask.configurationProperties.name === 'test' && defaultTestTask.rank < 1) {\n\t\t\t\t\t\tdefaultTestTask.task = customTask;\n\t\t\t\t\t\tdefaultTestTask.rank = 1;\n\t\t\t\t\t}\n\t\t\t\t\tcustomTask.addTaskLoadMessages(context.taskLoadIssues);\n\t\t\t\t\tresult.custom.push(customTask);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet configuredTask = ConfiguringTask.from(external, context, index);\n\t\t\t\tif (configuredTask) {\n\t\t\t\t\tconfiguredTask.addTaskLoadMessages(context.taskLoadIssues);\n\t\t\t\t\tresult.configured.push(configuredTask);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontext.taskLoadIssues = Objects.deepClone(baseLoadIssues);\n\t\t}\n\t\tif ((defaultBuildTask.rank > -1) && (defaultBuildTask.rank < 2) && defaultBuildTask.task) {\n\t\t\tdefaultBuildTask.task.configurationProperties.group = Tasks.TaskGroup.Build;\n\t\t\tdefaultBuildTask.task.configurationProperties.groupType = Tasks.GroupType.user;\n\t\t} else if ((defaultTestTask.rank > -1) && (defaultTestTask.rank < 2) && defaultTestTask.task) {\n\t\t\tdefaultTestTask.task.configurationProperties.group = Tasks.TaskGroup.Test;\n\t\t\tdefaultTestTask.task.configurationProperties.groupType = Tasks.GroupType.user;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\texport function assignTasks(target: Tasks.CustomTask[], source: Tasks.CustomTask[]): Tasks.CustomTask[] {\n\t\tif (source === undefined || source.length === 0) {\n\t\t\treturn target;\n\t\t}\n\t\tif (target === undefined || target.length === 0) {\n\t\t\treturn source;\n\t\t}\n\n\t\tif (source) {\n\t\t\t// Tasks are keyed by ID but we need to merge by name\n\t\t\tlet map: IStringDictionary<Tasks.CustomTask> = Object.create(null);\n\t\t\ttarget.forEach((task) => {\n\t\t\t\tmap[task.configurationProperties.name!] = task;\n\t\t\t});\n\n\t\t\tsource.forEach((task) => {\n\t\t\t\tmap[task.configurationProperties.name!] = task;\n\t\t\t});\n\t\t\tlet newTarget: Tasks.CustomTask[] = [];\n\t\t\ttarget.forEach(task => {\n\t\t\t\tnewTarget.push(map[task.configurationProperties.name!]);\n\t\t\t\tdelete map[task.configurationProperties.name!];\n\t\t\t});\n\t\t\tObject.keys(map).forEach(key => newTarget.push(map[key]));\n\t\t\ttarget = newTarget;\n\t\t}\n\t\treturn target;\n\t}\n}\n\ninterface Globals {\n\tcommand?: Tasks.CommandConfiguration;\n\tproblemMatcher?: ProblemMatcher[];\n\tpromptOnClose?: boolean;\n\tsuppressTaskName?: boolean;\n}\n\nnamespace Globals {\n\n\texport function from(config: ExternalTaskRunnerConfiguration, context: ParseContext): Globals {\n\t\tlet result = fromBase(config, context);\n\t\tlet osGlobals: Globals | undefined = undefined;\n\t\tif (config.windows && context.platform === Platform.Windows) {\n\t\t\tosGlobals = fromBase(config.windows, context);\n\t\t} else if (config.osx && context.platform === Platform.Mac) {\n\t\t\tosGlobals = fromBase(config.osx, context);\n\t\t} else if (config.linux && context.platform === Platform.Linux) {\n\t\t\tosGlobals = fromBase(config.linux, context);\n\t\t}\n\t\tif (osGlobals) {\n\t\t\tresult = Globals.assignProperties(result, osGlobals);\n\t\t}\n\t\tlet command = CommandConfiguration.from(config, context);\n\t\tif (command) {\n\t\t\tresult.command = command;\n\t\t}\n\t\tGlobals.fillDefaults(result, context);\n\t\tGlobals.freeze(result);\n\t\treturn result;\n\t}\n\n\texport function fromBase(this: void, config: BaseTaskRunnerConfiguration, context: ParseContext): Globals {\n\t\tlet result: Globals = {};\n\t\tif (config.suppressTaskName !== undefined) {\n\t\t\tresult.suppressTaskName = !!config.suppressTaskName;\n\t\t}\n\t\tif (config.promptOnClose !== undefined) {\n\t\t\tresult.promptOnClose = !!config.promptOnClose;\n\t\t}\n\t\tif (config.problemMatcher) {\n\t\t\tresult.problemMatcher = ProblemMatcherConverter.from(config.problemMatcher, context);\n\t\t}\n\t\treturn result;\n\t}\n\n\texport function isEmpty(value: Globals): boolean {\n\t\treturn !value || value.command === undefined && value.promptOnClose === undefined && value.suppressTaskName === undefined;\n\t}\n\n\texport function assignProperties(target: Globals, source: Globals): Globals {\n\t\tif (isEmpty(source)) {\n\t\t\treturn target;\n\t\t}\n\t\tif (isEmpty(target)) {\n\t\t\treturn source;\n\t\t}\n\t\tassignProperty(target, source, 'promptOnClose');\n\t\tassignProperty(target, source, 'suppressTaskName');\n\t\treturn target;\n\t}\n\n\texport function fillDefaults(value: Globals, context: ParseContext): void {\n\t\tif (!value) {\n\t\t\treturn;\n\t\t}\n\t\tCommandConfiguration.fillDefaults(value.command, context);\n\t\tif (value.suppressTaskName === undefined) {\n\t\t\tvalue.suppressTaskName = false;\n\t\t}\n\t\tif (value.promptOnClose === undefined) {\n\t\t\tvalue.promptOnClose = true;\n\t\t}\n\t}\n\n\texport function freeze(value: Globals): void {\n\t\tObject.freeze(value);\n\t\tif (value.command) {\n\t\t\tCommandConfiguration.freeze(value.command);\n\t\t}\n\t}\n}\n\nexport namespace ExecutionEngine {\n\n\texport function from(config: ExternalTaskRunnerConfiguration): Tasks.ExecutionEngine {\n\t\tlet runner = config.runner || config._runner;\n\t\tlet result: Tasks.ExecutionEngine | undefined;\n\t\tif (runner) {\n\t\t\tswitch (runner) {\n\t\t\t\tcase 'terminal':\n\t\t\t\t\tresult = Tasks.ExecutionEngine.Terminal;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'process':\n\t\t\t\t\tresult = Tasks.ExecutionEngine.Process;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlet schemaVersion = JsonSchemaVersion.from(config);\n\t\tif (schemaVersion === Tasks.JsonSchemaVersion.V0_1_0) {\n\t\t\treturn result || Tasks.ExecutionEngine.Process;\n\t\t} else if (schemaVersion === Tasks.JsonSchemaVersion.V2_0_0) {\n\t\t\treturn Tasks.ExecutionEngine.Terminal;\n\t\t} else {\n\t\t\tthrow new Error('Shouldn\\'t happen.');\n\t\t}\n\t}\n}\n\nexport namespace JsonSchemaVersion {\n\n\tconst _default: Tasks.JsonSchemaVersion = Tasks.JsonSchemaVersion.V2_0_0;\n\n\texport function from(config: ExternalTaskRunnerConfiguration): Tasks.JsonSchemaVersion {\n\t\tlet version = config.version;\n\t\tif (!version) {\n\t\t\treturn _default;\n\t\t}\n\t\tswitch (version) {\n\t\t\tcase '0.1.0':\n\t\t\t\treturn Tasks.JsonSchemaVersion.V0_1_0;\n\t\t\tcase '2.0.0':\n\t\t\t\treturn Tasks.JsonSchemaVersion.V2_0_0;\n\t\t\tdefault:\n\t\t\t\treturn _default;\n\t\t}\n\t}\n}\n\nexport interface ParseResult {\n\tvalidationStatus: ValidationStatus;\n\tcustom: Tasks.CustomTask[];\n\tconfigured: Tasks.ConfiguringTask[];\n\tengine: Tasks.ExecutionEngine;\n}\n\nexport interface IProblemReporter extends IProblemReporterBase {\n}\n\nclass UUIDMap {\n\n\tprivate last: IStringDictionary<string | string[]> | undefined;\n\tprivate current: IStringDictionary<string | string[]>;\n\n\tconstructor(other?: UUIDMap) {\n\t\tthis.current = Object.create(null);\n\t\tif (other) {\n\t\t\tfor (let key of Object.keys(other.current)) {\n\t\t\t\tlet value = other.current[key];\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tthis.current[key] = value.slice();\n\t\t\t\t} else {\n\t\t\t\t\tthis.current[key] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic start(): void {\n\t\tthis.last = this.current;\n\t\tthis.current = Object.create(null);\n\t}\n\n\tpublic getUUID(identifier: string): string {\n\t\tlet lastValue = this.last ? this.last[identifier] : undefined;\n\t\tlet result: string | undefined = undefined;\n\t\tif (lastValue !== undefined) {\n\t\t\tif (Array.isArray(lastValue)) {\n\t\t\t\tresult = lastValue.shift();\n\t\t\t\tif (lastValue.length === 0) {\n\t\t\t\t\tdelete this.last![identifier];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = lastValue;\n\t\t\t\tdelete this.last![identifier];\n\t\t\t}\n\t\t}\n\t\tif (result === undefined) {\n\t\t\tresult = UUID.generateUuid();\n\t\t}\n\t\tlet currentValue = this.current[identifier];\n\t\tif (currentValue === undefined) {\n\t\t\tthis.current[identifier] = result;\n\t\t} else {\n\t\t\tif (Array.isArray(currentValue)) {\n\t\t\t\tcurrentValue.push(result);\n\t\t\t} else {\n\t\t\t\tlet arrayValue: string[] = [currentValue];\n\t\t\t\tarrayValue.push(result);\n\t\t\t\tthis.current[identifier] = arrayValue;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic finish(): void {\n\t\tthis.last = undefined;\n\t}\n}\n\nclass ConfigurationParser {\n\n\tprivate workspaceFolder: IWorkspaceFolder;\n\tprivate problemReporter: IProblemReporter;\n\tprivate uuidMap: UUIDMap;\n\tprivate platform: Platform;\n\n\tconstructor(workspaceFolder: IWorkspaceFolder, platform: Platform, problemReporter: IProblemReporter, uuidMap: UUIDMap) {\n\t\tthis.workspaceFolder = workspaceFolder;\n\t\tthis.platform = platform;\n\t\tthis.problemReporter = problemReporter;\n\t\tthis.uuidMap = uuidMap;\n\t}\n\n\tpublic run(fileConfig: ExternalTaskRunnerConfiguration): ParseResult {\n\t\tlet engine = ExecutionEngine.from(fileConfig);\n\t\tlet schemaVersion = JsonSchemaVersion.from(fileConfig);\n\t\tlet context: ParseContext = {\n\t\t\tworkspaceFolder: this.workspaceFolder,\n\t\t\tproblemReporter: this.problemReporter,\n\t\t\tuuidMap: this.uuidMap,\n\t\t\tnamedProblemMatchers: {},\n\t\t\tengine,\n\t\t\tschemaVersion,\n\t\t\tplatform: this.platform,\n\t\t\ttaskLoadIssues: []\n\t\t};\n\t\tlet taskParseResult = this.createTaskRunnerConfiguration(fileConfig, context);\n\t\treturn {\n\t\t\tvalidationStatus: this.problemReporter.status,\n\t\t\tcustom: taskParseResult.custom,\n\t\t\tconfigured: taskParseResult.configured,\n\t\t\tengine\n\t\t};\n\t}\n\n\tprivate createTaskRunnerConfiguration(fileConfig: ExternalTaskRunnerConfiguration, context: ParseContext): TaskParseResult {\n\t\tlet globals = Globals.from(fileConfig, context);\n\t\tif (this.problemReporter.status.isFatal()) {\n\t\t\treturn { custom: [], configured: [] };\n\t\t}\n\t\tcontext.namedProblemMatchers = ProblemMatcherConverter.namedFrom(fileConfig.declares, context);\n\t\tlet globalTasks: Tasks.CustomTask[] | undefined = undefined;\n\t\tlet externalGlobalTasks: Array<ConfiguringTask | CustomTask> | undefined = undefined;\n\t\tif (fileConfig.windows && context.platform === Platform.Windows) {\n\t\t\tglobalTasks = TaskParser.from(fileConfig.windows.tasks, globals, context).custom;\n\t\t\texternalGlobalTasks = fileConfig.windows.tasks;\n\t\t} else if (fileConfig.osx && context.platform === Platform.Mac) {\n\t\t\tglobalTasks = TaskParser.from(fileConfig.osx.tasks, globals, context).custom;\n\t\t\texternalGlobalTasks = fileConfig.osx.tasks;\n\t\t} else if (fileConfig.linux && context.platform === Platform.Linux) {\n\t\t\tglobalTasks = TaskParser.from(fileConfig.linux.tasks, globals, context).custom;\n\t\t\texternalGlobalTasks = fileConfig.linux.tasks;\n\t\t}\n\t\tif (context.schemaVersion === Tasks.JsonSchemaVersion.V2_0_0 && globalTasks && globalTasks.length > 0 && externalGlobalTasks && externalGlobalTasks.length > 0) {\n\t\t\tlet taskContent: string[] = [];\n\t\t\tfor (let task of externalGlobalTasks) {\n\t\t\t\ttaskContent.push(JSON.stringify(task, null, 4));\n\t\t\t}\n\t\t\tcontext.problemReporter.error(\n\t\t\t\tnls.localize(\n\t\t\t\t\t'TaskParse.noOsSpecificGlobalTasks',\n\t\t\t\t\t'Task version 2.0.0 doesn\\'t support global OS specific tasks. Convert them to a task with a OS specific command. Affected tasks are:\\n{0}', taskContent.join('\\n'))\n\t\t\t);\n\t\t}\n\n\t\tlet result: TaskParseResult = { custom: [], configured: [] };\n\t\tif (fileConfig.tasks) {\n\t\t\tresult = TaskParser.from(fileConfig.tasks, globals, context);\n\t\t}\n\t\tif (globalTasks) {\n\t\t\tresult.custom = TaskParser.assignTasks(result.custom, globalTasks);\n\t\t}\n\n\t\tif ((!result.custom || result.custom.length === 0) && (globals.command && globals.command.name)) {\n\t\t\tlet matchers: ProblemMatcher[] = ProblemMatcherConverter.from(fileConfig.problemMatcher, context);\n\t\t\tlet isBackground = fileConfig.isBackground ? !!fileConfig.isBackground : fileConfig.isWatching ? !!fileConfig.isWatching : undefined;\n\t\t\tlet name = Tasks.CommandString.value(globals.command.name);\n\t\t\tlet task: Tasks.CustomTask = new Tasks.CustomTask(\n\t\t\t\tcontext.uuidMap.getUUID(name),\n\t\t\t\tObjects.assign({} as Tasks.WorkspaceTaskSource, source, { config: { index: -1, element: fileConfig, workspaceFolder: context.workspaceFolder } }),\n\t\t\t\tname,\n\t\t\t\tTasks.CUSTOMIZED_TASK_TYPE,\n\t\t\t\t{\n\t\t\t\t\tname: undefined,\n\t\t\t\t\truntime: undefined,\n\t\t\t\t\tpresentation: undefined,\n\t\t\t\t\tsuppressTaskName: true\n\t\t\t\t},\n\t\t\t\tfalse,\n\t\t\t\t{ reevaluateOnRerun: true },\n\t\t\t\t{\n\t\t\t\t\tname: name,\n\t\t\t\t\tidentifier: name,\n\t\t\t\t\tgroup: Tasks.TaskGroup.Build,\n\t\t\t\t\tisBackground: isBackground,\n\t\t\t\t\tproblemMatchers: matchers,\n\t\t\t\t}\n\t\t\t);\n\t\t\tlet value = GroupKind.from(fileConfig.group);\n\t\t\tif (value) {\n\t\t\t\ttask.configurationProperties.group = value[0];\n\t\t\t\ttask.configurationProperties.groupType = value[1];\n\t\t\t} else if (fileConfig.group === 'none') {\n\t\t\t\ttask.configurationProperties.group = undefined;\n\t\t\t}\n\t\t\tCustomTask.fillGlobals(task, globals);\n\t\t\tCustomTask.fillDefaults(task, context);\n\t\t\tresult.custom = [task];\n\t\t}\n\t\tresult.custom = result.custom || [];\n\t\tresult.configured = result.configured || [];\n\t\treturn result;\n\t}\n}\n\nlet uuidMaps: Map<string, UUIDMap> = new Map();\nexport function parse(workspaceFolder: IWorkspaceFolder, platform: Platform, configuration: ExternalTaskRunnerConfiguration, logger: IProblemReporter): ParseResult {\n\tlet uuidMap = uuidMaps.get(workspaceFolder.uri.toString());\n\tif (!uuidMap) {\n\t\tuuidMap = new UUIDMap();\n\t\tuuidMaps.set(workspaceFolder.uri.toString(), uuidMap);\n\t}\n\ttry {\n\t\tuuidMap.start();\n\t\treturn (new ConfigurationParser(workspaceFolder, platform, logger, uuidMap)).run(configuration);\n\t} finally {\n\t\tuuidMap.finish();\n\t}\n}\n\nexport function createCustomTask(contributedTask: Tasks.ContributedTask, configuredProps: Tasks.ConfiguringTask | Tasks.CustomTask): Tasks.CustomTask {\n\treturn CustomTask.createCustomTask(contributedTask, configuredProps);\n}\n\n/*\nclass VersionConverter {\n\tconstructor(private problemReporter: IProblemReporter) {\n\t}\n\n\tpublic convert(fromConfig: ExternalTaskRunnerConfiguration): ExternalTaskRunnerConfiguration {\n\t\tlet result: ExternalTaskRunnerConfiguration;\n\t\tresult.version = '2.0.0';\n\t\tif (Array.isArray(fromConfig.tasks)) {\n\n\t\t} else {\n\t\t\tresult.tasks = [];\n\t\t}\n\n\n\t\treturn result;\n\t}\n\n\tprivate convertGlobalTask(fromConfig: ExternalTaskRunnerConfiguration): TaskDescription {\n\t\tlet command: string = this.getGlobalCommand(fromConfig);\n\t\tif (!command) {\n\t\t\tthis.problemReporter.error(nls.localize('Converter.noGlobalName', 'No global command specified. Can\\'t convert to 2.0.0 version.'));\n\t\t\treturn undefined;\n\t\t}\n\t\tlet result: TaskDescription = {\n\t\t\ttaskName: command\n\t\t};\n\t\tif (fromConfig.isShellCommand) {\n\t\t\tresult.type = 'shell';\n\t\t} else {\n\t\t\tresult.type = 'process';\n\t\t\tresult.args = fromConfig.args;\n\t\t}\n\t\tif (fromConfig.)\n\n\t\treturn result;\n\t}\n\n\tprivate getGlobalCommand(fromConfig: ExternalTaskRunnerConfiguration): string {\n\t\tif (fromConfig.command) {\n\t\t\treturn fromConfig.command;\n\t\t} else if (fromConfig.windows && fromConfig.windows.command) {\n\t\t\treturn fromConfig.windows.command;\n\t\t} else if (fromConfig.osx && fromConfig.osx.command) {\n\t\t\treturn fromConfig.osx.command;\n\t\t} else if (fromConfig.linux && fromConfig.linux.command) {\n\t\t\treturn fromConfig.linux.command;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprivate createCommandLine(command: string, args: string[], isWindows: boolean): string {\n\t\tlet result: string[];\n\t\tlet commandHasSpace = false;\n\t\tlet argHasSpace = false;\n\t\tif (TaskDescription.hasUnescapedSpaces(command)) {\n\t\t\tresult.push(`\"${command}\"`);\n\t\t\tcommandHasSpace = true;\n\t\t} else {\n\t\t\tresult.push(command);\n\t\t}\n\t\tif (args) {\n\t\t\tfor (let arg of args) {\n\t\t\t\tif (TaskDescription.hasUnescapedSpaces(arg)) {\n\t\t\t\t\tresult.push(`\"${arg}\"`);\n\t\t\t\t\targHasSpace= true;\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(arg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result.join(' ');\n\t}\n\n}\n*/\n"]}]}