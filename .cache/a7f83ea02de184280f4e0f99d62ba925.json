{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/node/encoding.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/encoding.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/node/stream\", \"iconv-lite\", \"vs/base/common/platform\", \"child_process\", \"stream\"], function (require, exports, stream, iconv, platform_1, child_process_1, stream_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.UTF8 = 'utf8';\n    exports.UTF8_with_bom = 'utf8bom';\n    exports.UTF16be = 'utf16be';\n    exports.UTF16le = 'utf16le';\n    function toDecodeStream(readable, options) {\n        if (!options.minBytesRequiredForDetection) {\n            options.minBytesRequiredForDetection = options.guessEncoding ? AUTO_GUESS_BUFFER_MAX_LEN : NO_GUESS_BUFFER_MAX_LEN;\n        }\n        if (!options.overwriteEncoding) {\n            options.overwriteEncoding = detected => detected || exports.UTF8;\n        }\n        return new Promise((resolve, reject) => {\n            readable.on('error', reject);\n            readable.pipe(new class extends stream_1.Writable {\n                constructor() {\n                    super(...arguments);\n                    this._buffer = [];\n                    this._bytesBuffered = 0;\n                }\n                _write(chunk, encoding, callback) {\n                    if (!Buffer.isBuffer(chunk)) {\n                        callback(new Error('data must be a buffer'));\n                    }\n                    if (this._decodeStream) {\n                        // just a forwarder now\n                        this._decodeStream.write(chunk, callback);\n                        return;\n                    }\n                    this._buffer.push(chunk);\n                    this._bytesBuffered += chunk.length;\n                    if (this._decodeStreamConstruction) {\n                        // waiting for the decoder to be ready\n                        this._decodeStreamConstruction.then(_ => callback(), err => callback(err));\n                    }\n                    else if (typeof options.minBytesRequiredForDetection === 'number' && this._bytesBuffered >= options.minBytesRequiredForDetection) {\n                        // buffered enough data, create stream and forward data\n                        this._startDecodeStream(callback);\n                    }\n                    else {\n                        // only buffering\n                        callback();\n                    }\n                }\n                _startDecodeStream(callback) {\n                    this._decodeStreamConstruction = Promise.resolve(detectEncodingFromBuffer({\n                        buffer: Buffer.concat(this._buffer), bytesRead: this._bytesBuffered\n                    }, options.guessEncoding)).then(detected => {\n                        if (options.overwriteEncoding) {\n                            detected.encoding = options.overwriteEncoding(detected.encoding);\n                        }\n                        this._decodeStream = decodeStream(detected.encoding);\n                        for (const buffer of this._buffer) {\n                            this._decodeStream.write(buffer);\n                        }\n                        callback();\n                        resolve({ detected, stream: this._decodeStream });\n                    }, err => {\n                        this.emit('error', err);\n                        callback(err);\n                    });\n                }\n                _final(callback) {\n                    if (this._decodeStream) {\n                        // normal finish\n                        this._decodeStream.end(callback);\n                    }\n                    else {\n                        // we were still waiting for data...\n                        this._startDecodeStream(() => this._decodeStream.end(callback));\n                    }\n                }\n            });\n        });\n    }\n    exports.toDecodeStream = toDecodeStream;\n    function bomLength(encoding) {\n        switch (encoding) {\n            case exports.UTF8:\n                return 3;\n            case exports.UTF16be:\n            case exports.UTF16le:\n                return 2;\n        }\n        return 0;\n    }\n    exports.bomLength = bomLength;\n    function decode(buffer, encoding) {\n        return iconv.decode(buffer, toNodeEncoding(encoding));\n    }\n    exports.decode = decode;\n    function encode(content, encoding, options) {\n        return iconv.encode(content, toNodeEncoding(encoding), options);\n    }\n    exports.encode = encode;\n    function encodingExists(encoding) {\n        return iconv.encodingExists(toNodeEncoding(encoding));\n    }\n    exports.encodingExists = encodingExists;\n    function decodeStream(encoding) {\n        return iconv.decodeStream(toNodeEncoding(encoding));\n    }\n    exports.decodeStream = decodeStream;\n    function encodeStream(encoding, options) {\n        return iconv.encodeStream(toNodeEncoding(encoding), options);\n    }\n    exports.encodeStream = encodeStream;\n    function toNodeEncoding(enc) {\n        if (enc === exports.UTF8_with_bom || enc === null) {\n            return exports.UTF8; // iconv does not distinguish UTF 8 with or without BOM, so we need to help it\n        }\n        return enc;\n    }\n    function detectEncodingByBOMFromBuffer(buffer, bytesRead) {\n        if (!buffer || bytesRead < 2) {\n            return null;\n        }\n        const b0 = buffer.readUInt8(0);\n        const b1 = buffer.readUInt8(1);\n        // UTF-16 BE\n        if (b0 === 0xFE && b1 === 0xFF) {\n            return exports.UTF16be;\n        }\n        // UTF-16 LE\n        if (b0 === 0xFF && b1 === 0xFE) {\n            return exports.UTF16le;\n        }\n        if (bytesRead < 3) {\n            return null;\n        }\n        const b2 = buffer.readUInt8(2);\n        // UTF-8\n        if (b0 === 0xEF && b1 === 0xBB && b2 === 0xBF) {\n            return exports.UTF8;\n        }\n        return null;\n    }\n    exports.detectEncodingByBOMFromBuffer = detectEncodingByBOMFromBuffer;\n    /**\n     * Detects the Byte Order Mark in a given file.\n     * If no BOM is detected, null will be passed to callback.\n     */\n    function detectEncodingByBOM(file) {\n        return stream.readExactlyByFile(file, 3).then(({ buffer, bytesRead }) => detectEncodingByBOMFromBuffer(buffer, bytesRead));\n    }\n    exports.detectEncodingByBOM = detectEncodingByBOM;\n    const MINIMUM_THRESHOLD = 0.2;\n    const IGNORE_ENCODINGS = ['ascii', 'utf-8', 'utf-16', 'utf-32'];\n    /**\n     * Guesses the encoding from buffer.\n     */\n    function guessEncodingByBuffer(buffer) {\n        return new Promise((resolve_1, reject_1) => { require(['jschardet'], resolve_1, reject_1); }).then(jschardet => {\n            jschardet.Constants.MINIMUM_THRESHOLD = MINIMUM_THRESHOLD;\n            const guessed = jschardet.detect(buffer);\n            if (!guessed || !guessed.encoding) {\n                return null;\n            }\n            const enc = guessed.encoding.toLowerCase();\n            // Ignore encodings that cannot guess correctly\n            // (http://chardet.readthedocs.io/en/latest/supported-encodings.html)\n            if (0 <= IGNORE_ENCODINGS.indexOf(enc)) {\n                return null;\n            }\n            return toIconvLiteEncoding(guessed.encoding);\n        });\n    }\n    exports.guessEncodingByBuffer = guessEncodingByBuffer;\n    const JSCHARDET_TO_ICONV_ENCODINGS = {\n        'ibm866': 'cp866',\n        'big5': 'cp950'\n    };\n    function toIconvLiteEncoding(encodingName) {\n        const normalizedEncodingName = encodingName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n        const mapped = JSCHARDET_TO_ICONV_ENCODINGS[normalizedEncodingName];\n        return mapped || normalizedEncodingName;\n    }\n    /**\n     * The encodings that are allowed in a settings file don't match the canonical encoding labels specified by WHATWG.\n     * See https://encoding.spec.whatwg.org/#names-and-labels\n     * Iconv-lite strips all non-alphanumeric characters, but ripgrep doesn't. For backcompat, allow these labels.\n     */\n    function toCanonicalName(enc) {\n        switch (enc) {\n            case 'shiftjis':\n                return 'shift-jis';\n            case 'utf16le':\n                return 'utf-16le';\n            case 'utf16be':\n                return 'utf-16be';\n            case 'big5hkscs':\n                return 'big5-hkscs';\n            case 'eucjp':\n                return 'euc-jp';\n            case 'euckr':\n                return 'euc-kr';\n            case 'koi8r':\n                return 'koi8-r';\n            case 'koi8u':\n                return 'koi8-u';\n            case 'macroman':\n                return 'x-mac-roman';\n            case 'utf8bom':\n                return 'utf8';\n            default:\n                const m = enc.match(/windows(\\d+)/);\n                if (m) {\n                    return 'windows-' + m[1];\n                }\n                return enc;\n        }\n    }\n    exports.toCanonicalName = toCanonicalName;\n    const ZERO_BYTE_DETECTION_BUFFER_MAX_LEN = 512; // number of bytes to look at to decide about a file being binary or not\n    const NO_GUESS_BUFFER_MAX_LEN = 512; // when not auto guessing the encoding, small number of bytes are enough\n    const AUTO_GUESS_BUFFER_MAX_LEN = 512 * 8; // with auto guessing we want a lot more content to be read for guessing\n    function detectEncodingFromBuffer({ buffer, bytesRead }, autoGuessEncoding) {\n        // Always first check for BOM to find out about encoding\n        let encoding = detectEncodingByBOMFromBuffer(buffer, bytesRead);\n        // Detect 0 bytes to see if file is binary or UTF-16 LE/BE\n        // unless we already know that this file has a UTF-16 encoding\n        let seemsBinary = false;\n        if (encoding !== exports.UTF16be && encoding !== exports.UTF16le && buffer) {\n            let couldBeUTF16LE = true; // e.g. 0xAA 0x00\n            let couldBeUTF16BE = true; // e.g. 0x00 0xAA\n            let containsZeroByte = false;\n            // This is a simplified guess to detect UTF-16 BE or LE by just checking if\n            // the first 512 bytes have the 0-byte at a specific location. For UTF-16 LE\n            // this would be the odd byte index and for UTF-16 BE the even one.\n            // Note: this can produce false positives (a binary file that uses a 2-byte\n            // encoding of the same format as UTF-16) and false negatives (a UTF-16 file\n            // that is using 4 bytes to encode a character).\n            for (let i = 0; i < bytesRead && i < ZERO_BYTE_DETECTION_BUFFER_MAX_LEN; i++) {\n                const isEndian = (i % 2 === 1); // assume 2-byte sequences typical for UTF-16\n                const isZeroByte = (buffer.readInt8(i) === 0);\n                if (isZeroByte) {\n                    containsZeroByte = true;\n                }\n                // UTF-16 LE: expect e.g. 0xAA 0x00\n                if (couldBeUTF16LE && (isEndian && !isZeroByte || !isEndian && isZeroByte)) {\n                    couldBeUTF16LE = false;\n                }\n                // UTF-16 BE: expect e.g. 0x00 0xAA\n                if (couldBeUTF16BE && (isEndian && isZeroByte || !isEndian && !isZeroByte)) {\n                    couldBeUTF16BE = false;\n                }\n                // Return if this is neither UTF16-LE nor UTF16-BE and thus treat as binary\n                if (isZeroByte && !couldBeUTF16LE && !couldBeUTF16BE) {\n                    break;\n                }\n            }\n            // Handle case of 0-byte included\n            if (containsZeroByte) {\n                if (couldBeUTF16LE) {\n                    encoding = exports.UTF16le;\n                }\n                else if (couldBeUTF16BE) {\n                    encoding = exports.UTF16be;\n                }\n                else {\n                    seemsBinary = true;\n                }\n            }\n        }\n        // Auto guess encoding if configured\n        if (autoGuessEncoding && !seemsBinary && !encoding && buffer) {\n            return guessEncodingByBuffer(buffer.slice(0, bytesRead)).then(guessedEncoding => {\n                return {\n                    seemsBinary: false,\n                    encoding: guessedEncoding\n                };\n            });\n        }\n        return { seemsBinary, encoding };\n    }\n    exports.detectEncodingFromBuffer = detectEncodingFromBuffer;\n    // https://ss64.com/nt/chcp.html\n    const windowsTerminalEncodings = {\n        '437': 'cp437',\n        '850': 'cp850',\n        '852': 'cp852',\n        '855': 'cp855',\n        '857': 'cp857',\n        '860': 'cp860',\n        '861': 'cp861',\n        '863': 'cp863',\n        '865': 'cp865',\n        '866': 'cp866',\n        '869': 'cp869',\n        '936': 'cp936',\n        '1252': 'cp1252' // West European Latin\n    };\n    function resolveTerminalEncoding(verbose) {\n        let rawEncodingPromise;\n        // Support a global environment variable to win over other mechanics\n        const cliEncodingEnv = process.env['VSCODE_CLI_ENCODING'];\n        if (cliEncodingEnv) {\n            if (verbose) {\n                console.log(`Found VSCODE_CLI_ENCODING variable: ${cliEncodingEnv}`);\n            }\n            rawEncodingPromise = Promise.resolve(cliEncodingEnv);\n        }\n        // Linux/Mac: use \"locale charmap\" command\n        else if (platform_1.isLinux || platform_1.isMacintosh) {\n            rawEncodingPromise = new Promise(resolve => {\n                if (verbose) {\n                    console.log('Running \"locale charmap\" to detect terminal encoding...');\n                }\n                child_process_1.exec('locale charmap', (err, stdout, stderr) => resolve(stdout));\n            });\n        }\n        // Windows: educated guess\n        else {\n            rawEncodingPromise = new Promise(resolve => {\n                if (verbose) {\n                    console.log('Running \"chcp\" to detect terminal encoding...');\n                }\n                child_process_1.exec('chcp', (err, stdout, stderr) => {\n                    if (stdout) {\n                        const windowsTerminalEncodingKeys = Object.keys(windowsTerminalEncodings);\n                        for (const key of windowsTerminalEncodingKeys) {\n                            if (stdout.indexOf(key) >= 0) {\n                                return resolve(windowsTerminalEncodings[key]);\n                            }\n                        }\n                    }\n                    return resolve(undefined);\n                });\n            });\n        }\n        return rawEncodingPromise.then(rawEncoding => {\n            if (verbose) {\n                console.log(`Detected raw terminal encoding: ${rawEncoding}`);\n            }\n            if (!rawEncoding || rawEncoding.toLowerCase() === 'utf-8' || rawEncoding.toLowerCase() === exports.UTF8) {\n                return exports.UTF8;\n            }\n            const iconvEncoding = toIconvLiteEncoding(rawEncoding);\n            if (iconv.encodingExists(iconvEncoding)) {\n                return iconvEncoding;\n            }\n            if (verbose) {\n                console.log('Unsupported terminal encoding, falling back to UTF-8.');\n            }\n            return exports.UTF8;\n        });\n    }\n    exports.resolveTerminalEncoding = resolveTerminalEncoding;\n});\n",null]}