{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/viewLineRenderer.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/viewLineRenderer.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar strings = require(\"vs/base/common/strings\");\nvar stringBuilder_1 = require(\"vs/editor/common/core/stringBuilder\");\nvar lineDecorations_1 = require(\"vs/editor/common/viewLayout/lineDecorations\");\nvar viewModel_1 = require(\"vs/editor/common/viewModel/viewModel\");\nvar RenderWhitespace;\n(function (RenderWhitespace) {\n    RenderWhitespace[RenderWhitespace[\"None\"] = 0] = \"None\";\n    RenderWhitespace[RenderWhitespace[\"Boundary\"] = 1] = \"Boundary\";\n    RenderWhitespace[RenderWhitespace[\"All\"] = 2] = \"All\";\n})(RenderWhitespace = exports.RenderWhitespace || (exports.RenderWhitespace = {}));\nvar LinePart = /** @class */ (function () {\n    function LinePart(endIndex, type) {\n        this.endIndex = endIndex;\n        this.type = type;\n    }\n    return LinePart;\n}());\nvar RenderLineInput = /** @class */ (function () {\n    function RenderLineInput(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, spaceWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures) {\n        this.useMonospaceOptimizations = useMonospaceOptimizations;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = isBasicASCII;\n        this.containsRTL = containsRTL;\n        this.fauxIndentLength = fauxIndentLength;\n        this.lineTokens = lineTokens;\n        this.lineDecorations = lineDecorations;\n        this.tabSize = tabSize;\n        this.spaceWidth = spaceWidth;\n        this.stopRenderingLineAfter = stopRenderingLineAfter;\n        this.renderWhitespace = (renderWhitespace === 'all'\n            ? RenderWhitespace.All\n            : renderWhitespace === 'boundary'\n                ? RenderWhitespace.Boundary\n                : RenderWhitespace.None);\n        this.renderControlCharacters = renderControlCharacters;\n        this.fontLigatures = fontLigatures;\n    }\n    RenderLineInput.prototype.equals = function (other) {\n        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n            && this.lineContent === other.lineContent\n            && this.continuesWithWrappedLine === other.continuesWithWrappedLine\n            && this.isBasicASCII === other.isBasicASCII\n            && this.containsRTL === other.containsRTL\n            && this.fauxIndentLength === other.fauxIndentLength\n            && this.tabSize === other.tabSize\n            && this.spaceWidth === other.spaceWidth\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\n            && this.renderWhitespace === other.renderWhitespace\n            && this.renderControlCharacters === other.renderControlCharacters\n            && this.fontLigatures === other.fontLigatures\n            && lineDecorations_1.LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\n            && this.lineTokens.equals(other.lineTokens));\n    };\n    return RenderLineInput;\n}());\nexports.RenderLineInput = RenderLineInput;\nvar CharacterMappingConstants;\n(function (CharacterMappingConstants) {\n    CharacterMappingConstants[CharacterMappingConstants[\"PART_INDEX_MASK\"] = 4294901760] = \"PART_INDEX_MASK\";\n    CharacterMappingConstants[CharacterMappingConstants[\"CHAR_INDEX_MASK\"] = 65535] = \"CHAR_INDEX_MASK\";\n    CharacterMappingConstants[CharacterMappingConstants[\"CHAR_INDEX_OFFSET\"] = 0] = \"CHAR_INDEX_OFFSET\";\n    CharacterMappingConstants[CharacterMappingConstants[\"PART_INDEX_OFFSET\"] = 16] = \"PART_INDEX_OFFSET\";\n})(CharacterMappingConstants = exports.CharacterMappingConstants || (exports.CharacterMappingConstants = {}));\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\nvar CharacterMapping = /** @class */ (function () {\n    function CharacterMapping(length, partCount) {\n        this.length = length;\n        this._data = new Uint32Array(this.length);\n        this._absoluteOffsets = new Uint32Array(this.length);\n    }\n    CharacterMapping.getPartIndex = function (partData) {\n        return (partData & CharacterMappingConstants.PART_INDEX_MASK) >>> CharacterMappingConstants.PART_INDEX_OFFSET;\n    };\n    CharacterMapping.getCharIndex = function (partData) {\n        return (partData & CharacterMappingConstants.CHAR_INDEX_MASK) >>> CharacterMappingConstants.CHAR_INDEX_OFFSET;\n    };\n    CharacterMapping.prototype.setPartData = function (charOffset, partIndex, charIndex, partAbsoluteOffset) {\n        var partData = ((partIndex << CharacterMappingConstants.PART_INDEX_OFFSET)\n            | (charIndex << CharacterMappingConstants.CHAR_INDEX_OFFSET)) >>> 0;\n        this._data[charOffset] = partData;\n        this._absoluteOffsets[charOffset] = partAbsoluteOffset + charIndex;\n    };\n    CharacterMapping.prototype.getAbsoluteOffsets = function () {\n        return this._absoluteOffsets;\n    };\n    CharacterMapping.prototype.charOffsetToPartData = function (charOffset) {\n        if (this.length === 0) {\n            return 0;\n        }\n        if (charOffset < 0) {\n            return this._data[0];\n        }\n        if (charOffset >= this.length) {\n            return this._data[this.length - 1];\n        }\n        return this._data[charOffset];\n    };\n    CharacterMapping.prototype.partDataToCharOffset = function (partIndex, partLength, charIndex) {\n        if (this.length === 0) {\n            return 0;\n        }\n        var searchEntry = ((partIndex << CharacterMappingConstants.PART_INDEX_OFFSET)\n            | (charIndex << CharacterMappingConstants.CHAR_INDEX_OFFSET)) >>> 0;\n        var min = 0;\n        var max = this.length - 1;\n        while (min + 1 < max) {\n            var mid = ((min + max) >>> 1);\n            var midEntry = this._data[mid];\n            if (midEntry === searchEntry) {\n                return mid;\n            }\n            else if (midEntry > searchEntry) {\n                max = mid;\n            }\n            else {\n                min = mid;\n            }\n        }\n        if (min === max) {\n            return min;\n        }\n        var minEntry = this._data[min];\n        var maxEntry = this._data[max];\n        if (minEntry === searchEntry) {\n            return min;\n        }\n        if (maxEntry === searchEntry) {\n            return max;\n        }\n        var minPartIndex = CharacterMapping.getPartIndex(minEntry);\n        var minCharIndex = CharacterMapping.getCharIndex(minEntry);\n        var maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n        var maxCharIndex;\n        if (minPartIndex !== maxPartIndex) {\n            // sitting between parts\n            maxCharIndex = partLength;\n        }\n        else {\n            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n        }\n        var minEntryDistance = charIndex - minCharIndex;\n        var maxEntryDistance = maxCharIndex - charIndex;\n        if (minEntryDistance <= maxEntryDistance) {\n            return min;\n        }\n        return max;\n    };\n    return CharacterMapping;\n}());\nexports.CharacterMapping = CharacterMapping;\nvar ForeignElementType;\n(function (ForeignElementType) {\n    ForeignElementType[ForeignElementType[\"None\"] = 0] = \"None\";\n    ForeignElementType[ForeignElementType[\"Before\"] = 1] = \"Before\";\n    ForeignElementType[ForeignElementType[\"After\"] = 2] = \"After\";\n})(ForeignElementType = exports.ForeignElementType || (exports.ForeignElementType = {}));\nvar RenderLineOutput = /** @class */ (function () {\n    function RenderLineOutput(characterMapping, containsRTL, containsForeignElements) {\n        this.characterMapping = characterMapping;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n    return RenderLineOutput;\n}());\nexports.RenderLineOutput = RenderLineOutput;\nfunction renderViewLine(input, sb) {\n    if (input.lineContent.length === 0) {\n        var containsForeignElements = ForeignElementType.None;\n        // This is basically for IE's hit test to work\n        var content = '<span><span>\\u00a0</span></span>';\n        if (input.lineDecorations.length > 0) {\n            // This line is empty, but it contains inline decorations\n            var classNames = [];\n            for (var i = 0, len = input.lineDecorations.length; i < len; i++) {\n                var lineDecoration = input.lineDecorations[i];\n                if (lineDecoration.type === viewModel_1.InlineDecorationType.Before) {\n                    classNames.push(input.lineDecorations[i].className);\n                    containsForeignElements |= ForeignElementType.Before;\n                }\n                if (lineDecoration.type === viewModel_1.InlineDecorationType.After) {\n                    classNames.push(input.lineDecorations[i].className);\n                    containsForeignElements |= ForeignElementType.After;\n                }\n            }\n            if (containsForeignElements !== ForeignElementType.None) {\n                content = \"<span><span class=\\\"\" + classNames.join(' ') + \"\\\"></span></span>\";\n            }\n        }\n        sb.appendASCIIString(content);\n        return new RenderLineOutput(new CharacterMapping(0, 0), false, containsForeignElements);\n    }\n    return _renderLine(resolveRenderLineInput(input), sb);\n}\nexports.renderViewLine = renderViewLine;\nvar RenderLineOutput2 = /** @class */ (function () {\n    function RenderLineOutput2(characterMapping, html, containsRTL, containsForeignElements) {\n        this.characterMapping = characterMapping;\n        this.html = html;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n    return RenderLineOutput2;\n}());\nexports.RenderLineOutput2 = RenderLineOutput2;\nfunction renderViewLine2(input) {\n    var sb = stringBuilder_1.createStringBuilder(10000);\n    var out = renderViewLine(input, sb);\n    return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\nexports.renderViewLine2 = renderViewLine2;\nvar ResolvedRenderLineInput = /** @class */ (function () {\n    function ResolvedRenderLineInput(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, tabSize, containsRTL, spaceWidth, renderWhitespace, renderControlCharacters) {\n        this.fontIsMonospace = fontIsMonospace;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.len = len;\n        this.isOverflowing = isOverflowing;\n        this.parts = parts;\n        this.containsForeignElements = containsForeignElements;\n        this.tabSize = tabSize;\n        this.containsRTL = containsRTL;\n        this.spaceWidth = spaceWidth;\n        this.renderWhitespace = renderWhitespace;\n        this.renderControlCharacters = renderControlCharacters;\n        //\n    }\n    return ResolvedRenderLineInput;\n}());\nfunction resolveRenderLineInput(input) {\n    var useMonospaceOptimizations = input.useMonospaceOptimizations;\n    var lineContent = input.lineContent;\n    var isOverflowing;\n    var len;\n    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n        isOverflowing = true;\n        len = input.stopRenderingLineAfter;\n    }\n    else {\n        isOverflowing = false;\n        len = lineContent.length;\n    }\n    var tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);\n    if (input.renderWhitespace === RenderWhitespace.All || input.renderWhitespace === RenderWhitespace.Boundary) {\n        tokens = _applyRenderWhitespace(lineContent, len, input.continuesWithWrappedLine, tokens, input.fauxIndentLength, input.tabSize, useMonospaceOptimizations, input.renderWhitespace === RenderWhitespace.Boundary);\n    }\n    var containsForeignElements = ForeignElementType.None;\n    if (input.lineDecorations.length > 0) {\n        for (var i = 0, len_1 = input.lineDecorations.length; i < len_1; i++) {\n            var lineDecoration = input.lineDecorations[i];\n            if (lineDecoration.type === viewModel_1.InlineDecorationType.RegularAffectingLetterSpacing) {\n                // Pretend there are foreign elements... although not 100% accurate.\n                containsForeignElements |= ForeignElementType.Before;\n            }\n            else if (lineDecoration.type === viewModel_1.InlineDecorationType.Before) {\n                containsForeignElements |= ForeignElementType.Before;\n            }\n            else if (lineDecoration.type === viewModel_1.InlineDecorationType.After) {\n                containsForeignElements |= ForeignElementType.After;\n            }\n        }\n        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n    }\n    if (!input.containsRTL) {\n        // We can never split RTL text, as it ruins the rendering\n        tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n    }\n    return new ResolvedRenderLineInput(useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.tabSize, input.containsRTL, input.spaceWidth, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\nfunction transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {\n    var result = [], resultLen = 0;\n    // The faux indent part of the line should have no token type\n    if (fauxIndentLength > 0) {\n        result[resultLen++] = new LinePart(fauxIndentLength, '');\n    }\n    for (var tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n        var endIndex = tokens.getEndOffset(tokenIndex);\n        if (endIndex <= fauxIndentLength) {\n            // The faux indent part of the line should have no token type\n            continue;\n        }\n        var type = tokens.getClassName(tokenIndex);\n        if (endIndex >= len) {\n            result[resultLen++] = new LinePart(len, type);\n            break;\n        }\n        result[resultLen++] = new LinePart(endIndex, type);\n    }\n    return result;\n}\n/**\n * written as a const enum to get value inlining.\n */\nvar Constants;\n(function (Constants) {\n    Constants[Constants[\"LongToken\"] = 50] = \"LongToken\";\n})(Constants || (Constants = {}));\n/**\n * See https://github.com/Microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n    var lastTokenEndIndex = 0;\n    var result = [], resultLen = 0;\n    if (onlyAtSpaces) {\n        // Split only at spaces => we need to walk each character\n        for (var i = 0, len = tokens.length; i < len; i++) {\n            var token = tokens[i];\n            var tokenEndIndex = token.endIndex;\n            if (lastTokenEndIndex + Constants.LongToken < tokenEndIndex) {\n                var tokenType = token.type;\n                var lastSpaceOffset = -1;\n                var currTokenStart = lastTokenEndIndex;\n                for (var j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n                    if (lineContent.charCodeAt(j) === charCode_1.CharCode.Space) {\n                        lastSpaceOffset = j;\n                    }\n                    if (lastSpaceOffset !== -1 && j - currTokenStart >= Constants.LongToken) {\n                        // Split at `lastSpaceOffset` + 1\n                        result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType);\n                        currTokenStart = lastSpaceOffset + 1;\n                        lastSpaceOffset = -1;\n                    }\n                }\n                if (currTokenStart !== tokenEndIndex) {\n                    result[resultLen++] = new LinePart(tokenEndIndex, tokenType);\n                }\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    else {\n        // Split anywhere => we don't need to walk each character\n        for (var i = 0, len = tokens.length; i < len; i++) {\n            var token = tokens[i];\n            var tokenEndIndex = token.endIndex;\n            var diff = (tokenEndIndex - lastTokenEndIndex);\n            if (diff > Constants.LongToken) {\n                var tokenType = token.type;\n                var piecesCount = Math.ceil(diff / Constants.LongToken);\n                for (var j = 1; j < piecesCount; j++) {\n                    var pieceEndIndex = lastTokenEndIndex + (j * Constants.LongToken);\n                    result[resultLen++] = new LinePart(pieceEndIndex, tokenType);\n                }\n                result[resultLen++] = new LinePart(tokenEndIndex, tokenType);\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    return result;\n}\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `vs-whitespace` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\nfunction _applyRenderWhitespace(lineContent, len, continuesWithWrappedLine, tokens, fauxIndentLength, tabSize, useMonospaceOptimizations, onlyBoundary) {\n    var result = [], resultLen = 0;\n    var tokenIndex = 0;\n    var tokenType = tokens[tokenIndex].type;\n    var tokenEndIndex = tokens[tokenIndex].endIndex;\n    var tokensLength = tokens.length;\n    var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n    var lastNonWhitespaceIndex;\n    if (firstNonWhitespaceIndex === -1) {\n        // The entire line is whitespace\n        firstNonWhitespaceIndex = len;\n        lastNonWhitespaceIndex = len;\n    }\n    else {\n        lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n    }\n    var tmpIndent = 0;\n    for (var charIndex = 0; charIndex < fauxIndentLength; charIndex++) {\n        var chCode = lineContent.charCodeAt(charIndex);\n        if (chCode === charCode_1.CharCode.Tab) {\n            tmpIndent = tabSize;\n        }\n        else if (strings.isFullWidthCharacter(chCode)) {\n            tmpIndent += 2;\n        }\n        else {\n            tmpIndent++;\n        }\n    }\n    tmpIndent = tmpIndent % tabSize;\n    var wasInWhitespace = false;\n    for (var charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n        var chCode = lineContent.charCodeAt(charIndex);\n        var isInWhitespace = void 0;\n        if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n            // in leading or trailing whitespace\n            isInWhitespace = true;\n        }\n        else if (chCode === charCode_1.CharCode.Tab) {\n            // a tab character is rendered both in all and boundary cases\n            isInWhitespace = true;\n        }\n        else if (chCode === charCode_1.CharCode.Space) {\n            // hit a space character\n            if (onlyBoundary) {\n                // rendering only boundary whitespace\n                if (wasInWhitespace) {\n                    isInWhitespace = true;\n                }\n                else {\n                    var nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : charCode_1.CharCode.Null);\n                    isInWhitespace = (nextChCode === charCode_1.CharCode.Space || nextChCode === charCode_1.CharCode.Tab);\n                }\n            }\n            else {\n                isInWhitespace = true;\n            }\n        }\n        else {\n            isInWhitespace = false;\n        }\n        if (wasInWhitespace) {\n            // was in whitespace token\n            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\n                // leaving whitespace token or entering a new indent\n                result[resultLen++] = new LinePart(charIndex, 'vs-whitespace');\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        else {\n            // was in regular token\n            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\n                result[resultLen++] = new LinePart(charIndex, tokenType);\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        if (chCode === charCode_1.CharCode.Tab) {\n            tmpIndent = tabSize;\n        }\n        else if (strings.isFullWidthCharacter(chCode)) {\n            tmpIndent += 2;\n        }\n        else {\n            tmpIndent++;\n        }\n        wasInWhitespace = isInWhitespace;\n        if (charIndex === tokenEndIndex) {\n            tokenIndex++;\n            if (tokenIndex < tokensLength) {\n                tokenType = tokens[tokenIndex].type;\n                tokenEndIndex = tokens[tokenIndex].endIndex;\n            }\n        }\n    }\n    var generateWhitespace = false;\n    if (wasInWhitespace) {\n        // was in whitespace token\n        if (continuesWithWrappedLine && onlyBoundary) {\n            var lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : charCode_1.CharCode.Null);\n            var prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : charCode_1.CharCode.Null);\n            var isSingleTrailingSpace = (lastCharCode === charCode_1.CharCode.Space && (prevCharCode !== charCode_1.CharCode.Space && prevCharCode !== charCode_1.CharCode.Tab));\n            if (!isSingleTrailingSpace) {\n                generateWhitespace = true;\n            }\n        }\n        else {\n            generateWhitespace = true;\n        }\n    }\n    result[resultLen++] = new LinePart(len, generateWhitespace ? 'vs-whitespace' : tokenType);\n    return result;\n}\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n    _lineDecorations.sort(lineDecorations_1.LineDecoration.compare);\n    var lineDecorations = lineDecorations_1.LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n    var lineDecorationsLen = lineDecorations.length;\n    var lineDecorationIndex = 0;\n    var result = [], resultLen = 0, lastResultEndIndex = 0;\n    for (var tokenIndex = 0, len_2 = tokens.length; tokenIndex < len_2; tokenIndex++) {\n        var token = tokens[tokenIndex];\n        var tokenEndIndex = token.endIndex;\n        var tokenType = token.type;\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n            var lineDecoration = lineDecorations[lineDecorationIndex];\n            if (lineDecoration.startOffset > lastResultEndIndex) {\n                lastResultEndIndex = lineDecoration.startOffset;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType);\n            }\n            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n                // This line decoration ends before this token ends\n                lastResultEndIndex = lineDecoration.endOffset + 1;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);\n                lineDecorationIndex++;\n            }\n            else {\n                // This line decoration continues on to the next token\n                lastResultEndIndex = tokenEndIndex;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);\n                break;\n            }\n        }\n        if (tokenEndIndex > lastResultEndIndex) {\n            lastResultEndIndex = tokenEndIndex;\n            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType);\n        }\n    }\n    var lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n    if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n        var classNames = [];\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n            classNames.push(lineDecorations[lineDecorationIndex].className);\n            lineDecorationIndex++;\n        }\n        result[resultLen++] = new LinePart(lastResultEndIndex, classNames.join(' '));\n    }\n    return result;\n}\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\nfunction _renderLine(input, sb) {\n    var fontIsMonospace = input.fontIsMonospace;\n    var canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n    var containsForeignElements = input.containsForeignElements;\n    var lineContent = input.lineContent;\n    var len = input.len;\n    var isOverflowing = input.isOverflowing;\n    var parts = input.parts;\n    var tabSize = input.tabSize;\n    var containsRTL = input.containsRTL;\n    var spaceWidth = input.spaceWidth;\n    var renderWhitespace = input.renderWhitespace;\n    var renderControlCharacters = input.renderControlCharacters;\n    var characterMapping = new CharacterMapping(len + 1, parts.length);\n    var charIndex = 0;\n    var tabsCharDelta = 0;\n    var charOffsetInPart = 0;\n    var prevPartContentCnt = 0;\n    var partAbsoluteOffset = 0;\n    sb.appendASCIIString('<span>');\n    for (var partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n        partAbsoluteOffset += prevPartContentCnt;\n        var part = parts[partIndex];\n        var partEndIndex = part.endIndex;\n        var partType = part.type;\n        var partRendersWhitespace = (renderWhitespace !== RenderWhitespace.None && (partType.indexOf('vs-whitespace') >= 0));\n        charOffsetInPart = 0;\n        sb.appendASCIIString('<span class=\"');\n        sb.appendASCIIString(partType);\n        sb.appendASCII(charCode_1.CharCode.DoubleQuote);\n        if (partRendersWhitespace) {\n            var partContentCnt = 0;\n            {\n                var _charIndex = charIndex;\n                var _tabsCharDelta = tabsCharDelta;\n                for (; _charIndex < partEndIndex; _charIndex++) {\n                    var charCode = lineContent.charCodeAt(_charIndex);\n                    if (charCode === charCode_1.CharCode.Tab) {\n                        var insertSpacesCount = tabSize - (_charIndex + _tabsCharDelta) % tabSize;\n                        _tabsCharDelta += insertSpacesCount - 1;\n                        partContentCnt += insertSpacesCount;\n                    }\n                    else {\n                        // must be CharCode.Space\n                        partContentCnt++;\n                    }\n                }\n            }\n            if (!fontIsMonospace) {\n                var partIsOnlyWhitespace = (partType === 'vs-whitespace');\n                if (partIsOnlyWhitespace || !containsForeignElements) {\n                    sb.appendASCIIString(' style=\"width:');\n                    sb.appendASCIIString(String(spaceWidth * partContentCnt));\n                    sb.appendASCIIString('px\"');\n                }\n            }\n            sb.appendASCII(charCode_1.CharCode.GreaterThan);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setPartData(charIndex, partIndex, charOffsetInPart, partAbsoluteOffset);\n                var charCode = lineContent.charCodeAt(charIndex);\n                if (charCode === charCode_1.CharCode.Tab) {\n                    var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    charOffsetInPart += insertSpacesCount - 1;\n                    if (insertSpacesCount > 0) {\n                        if (!canUseHalfwidthRightwardsArrow || insertSpacesCount > 1) {\n                            sb.write1(0x2192); // RIGHTWARDS ARROW\n                        }\n                        else {\n                            sb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n                        }\n                        insertSpacesCount--;\n                    }\n                    while (insertSpacesCount > 0) {\n                        sb.write1(0xA0); // &nbsp;\n                        insertSpacesCount--;\n                    }\n                }\n                else {\n                    // must be CharCode.Space\n                    sb.write1(0xB7); // &middot;\n                }\n                charOffsetInPart++;\n            }\n            prevPartContentCnt = partContentCnt;\n        }\n        else {\n            var partContentCnt = 0;\n            if (containsRTL) {\n                sb.appendASCIIString(' dir=\"ltr\"');\n            }\n            sb.appendASCII(charCode_1.CharCode.GreaterThan);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setPartData(charIndex, partIndex, charOffsetInPart, partAbsoluteOffset);\n                var charCode = lineContent.charCodeAt(charIndex);\n                switch (charCode) {\n                    case charCode_1.CharCode.Tab:\n                        var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                        tabsCharDelta += insertSpacesCount - 1;\n                        charOffsetInPart += insertSpacesCount - 1;\n                        while (insertSpacesCount > 0) {\n                            sb.write1(0xA0); // &nbsp;\n                            partContentCnt++;\n                            insertSpacesCount--;\n                        }\n                        break;\n                    case charCode_1.CharCode.Space:\n                        sb.write1(0xA0); // &nbsp;\n                        partContentCnt++;\n                        break;\n                    case charCode_1.CharCode.LessThan:\n                        sb.appendASCIIString('&lt;');\n                        partContentCnt++;\n                        break;\n                    case charCode_1.CharCode.GreaterThan:\n                        sb.appendASCIIString('&gt;');\n                        partContentCnt++;\n                        break;\n                    case charCode_1.CharCode.Ampersand:\n                        sb.appendASCIIString('&amp;');\n                        partContentCnt++;\n                        break;\n                    case charCode_1.CharCode.Null:\n                        sb.appendASCIIString('&#00;');\n                        partContentCnt++;\n                        break;\n                    case charCode_1.CharCode.UTF8_BOM:\n                    case charCode_1.CharCode.LINE_SEPARATOR_2028:\n                        sb.write1(0xFFFD);\n                        partContentCnt++;\n                        break;\n                    default:\n                        if (strings.isFullWidthCharacter(charCode)) {\n                            tabsCharDelta++;\n                        }\n                        if (renderControlCharacters && charCode < 32) {\n                            sb.write1(9216 + charCode);\n                            partContentCnt++;\n                        }\n                        else {\n                            sb.write1(charCode);\n                            partContentCnt++;\n                        }\n                }\n                charOffsetInPart++;\n            }\n            prevPartContentCnt = partContentCnt;\n        }\n        sb.appendASCIIString('</span>');\n    }\n    // When getting client rects for the last character, we will position the\n    // text range at the end of the span, insteaf of at the beginning of next span\n    characterMapping.setPartData(len, parts.length - 1, charOffsetInPart, partAbsoluteOffset);\n    if (isOverflowing) {\n        sb.appendASCIIString('<span>&hellip;</span>');\n    }\n    sb.appendASCIIString('</span>');\n    return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/viewLineRenderer.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/viewLineRenderer.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as strings from 'vs/base/common/strings';\nimport { IViewLineTokens } from 'vs/editor/common/core/lineTokens';\nimport { IStringBuilder, createStringBuilder } from 'vs/editor/common/core/stringBuilder';\nimport { LineDecoration, LineDecorationsNormalizer } from 'vs/editor/common/viewLayout/lineDecorations';\nimport { InlineDecorationType } from 'vs/editor/common/viewModel/viewModel';\n\nexport const enum RenderWhitespace {\n\tNone = 0,\n\tBoundary = 1,\n\tAll = 2\n}\n\nclass LinePart {\n\t_linePartBrand: void;\n\n\t/**\n\t * last char index of this token (not inclusive).\n\t */\n\tpublic readonly endIndex: number;\n\tpublic readonly type: string;\n\n\tconstructor(endIndex: number, type: string) {\n\t\tthis.endIndex = endIndex;\n\t\tthis.type = type;\n\t}\n}\n\nexport class RenderLineInput {\n\n\tpublic readonly useMonospaceOptimizations: boolean;\n\tpublic readonly canUseHalfwidthRightwardsArrow: boolean;\n\tpublic readonly lineContent: string;\n\tpublic readonly continuesWithWrappedLine: boolean;\n\tpublic readonly isBasicASCII: boolean;\n\tpublic readonly containsRTL: boolean;\n\tpublic readonly fauxIndentLength: number;\n\tpublic readonly lineTokens: IViewLineTokens;\n\tpublic readonly lineDecorations: LineDecoration[];\n\tpublic readonly tabSize: number;\n\tpublic readonly spaceWidth: number;\n\tpublic readonly stopRenderingLineAfter: number;\n\tpublic readonly renderWhitespace: RenderWhitespace;\n\tpublic readonly renderControlCharacters: boolean;\n\tpublic readonly fontLigatures: boolean;\n\n\tconstructor(\n\t\tuseMonospaceOptimizations: boolean,\n\t\tcanUseHalfwidthRightwardsArrow: boolean,\n\t\tlineContent: string,\n\t\tcontinuesWithWrappedLine: boolean,\n\t\tisBasicASCII: boolean,\n\t\tcontainsRTL: boolean,\n\t\tfauxIndentLength: number,\n\t\tlineTokens: IViewLineTokens,\n\t\tlineDecorations: LineDecoration[],\n\t\ttabSize: number,\n\t\tspaceWidth: number,\n\t\tstopRenderingLineAfter: number,\n\t\trenderWhitespace: 'none' | 'boundary' | 'all',\n\t\trenderControlCharacters: boolean,\n\t\tfontLigatures: boolean\n\t) {\n\t\tthis.useMonospaceOptimizations = useMonospaceOptimizations;\n\t\tthis.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n\t\tthis.lineContent = lineContent;\n\t\tthis.continuesWithWrappedLine = continuesWithWrappedLine;\n\t\tthis.isBasicASCII = isBasicASCII;\n\t\tthis.containsRTL = containsRTL;\n\t\tthis.fauxIndentLength = fauxIndentLength;\n\t\tthis.lineTokens = lineTokens;\n\t\tthis.lineDecorations = lineDecorations;\n\t\tthis.tabSize = tabSize;\n\t\tthis.spaceWidth = spaceWidth;\n\t\tthis.stopRenderingLineAfter = stopRenderingLineAfter;\n\t\tthis.renderWhitespace = (\n\t\t\trenderWhitespace === 'all'\n\t\t\t\t? RenderWhitespace.All\n\t\t\t\t: renderWhitespace === 'boundary'\n\t\t\t\t\t? RenderWhitespace.Boundary\n\t\t\t\t\t: RenderWhitespace.None\n\t\t);\n\t\tthis.renderControlCharacters = renderControlCharacters;\n\t\tthis.fontLigatures = fontLigatures;\n\t}\n\n\tpublic equals(other: RenderLineInput): boolean {\n\t\treturn (\n\t\t\tthis.useMonospaceOptimizations === other.useMonospaceOptimizations\n\t\t\t&& this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n\t\t\t&& this.lineContent === other.lineContent\n\t\t\t&& this.continuesWithWrappedLine === other.continuesWithWrappedLine\n\t\t\t&& this.isBasicASCII === other.isBasicASCII\n\t\t\t&& this.containsRTL === other.containsRTL\n\t\t\t&& this.fauxIndentLength === other.fauxIndentLength\n\t\t\t&& this.tabSize === other.tabSize\n\t\t\t&& this.spaceWidth === other.spaceWidth\n\t\t\t&& this.stopRenderingLineAfter === other.stopRenderingLineAfter\n\t\t\t&& this.renderWhitespace === other.renderWhitespace\n\t\t\t&& this.renderControlCharacters === other.renderControlCharacters\n\t\t\t&& this.fontLigatures === other.fontLigatures\n\t\t\t&& LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\n\t\t\t&& this.lineTokens.equals(other.lineTokens)\n\t\t);\n\t}\n}\n\nexport const enum CharacterMappingConstants {\n\tPART_INDEX_MASK = 0b11111111111111110000000000000000,\n\tCHAR_INDEX_MASK = 0b00000000000000001111111111111111,\n\n\tCHAR_INDEX_OFFSET = 0,\n\tPART_INDEX_OFFSET = 16\n}\n\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\nexport class CharacterMapping {\n\n\tpublic static getPartIndex(partData: number): number {\n\t\treturn (partData & CharacterMappingConstants.PART_INDEX_MASK) >>> CharacterMappingConstants.PART_INDEX_OFFSET;\n\t}\n\n\tpublic static getCharIndex(partData: number): number {\n\t\treturn (partData & CharacterMappingConstants.CHAR_INDEX_MASK) >>> CharacterMappingConstants.CHAR_INDEX_OFFSET;\n\t}\n\n\tpublic readonly length: number;\n\tprivate readonly _data: Uint32Array;\n\tprivate readonly _absoluteOffsets: Uint32Array;\n\n\tconstructor(length: number, partCount: number) {\n\t\tthis.length = length;\n\t\tthis._data = new Uint32Array(this.length);\n\t\tthis._absoluteOffsets = new Uint32Array(this.length);\n\t}\n\n\tpublic setPartData(charOffset: number, partIndex: number, charIndex: number, partAbsoluteOffset: number): void {\n\t\tlet partData = (\n\t\t\t(partIndex << CharacterMappingConstants.PART_INDEX_OFFSET)\n\t\t\t| (charIndex << CharacterMappingConstants.CHAR_INDEX_OFFSET)\n\t\t) >>> 0;\n\t\tthis._data[charOffset] = partData;\n\t\tthis._absoluteOffsets[charOffset] = partAbsoluteOffset + charIndex;\n\t}\n\n\tpublic getAbsoluteOffsets(): Uint32Array {\n\t\treturn this._absoluteOffsets;\n\t}\n\n\tpublic charOffsetToPartData(charOffset: number): number {\n\t\tif (this.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (charOffset < 0) {\n\t\t\treturn this._data[0];\n\t\t}\n\t\tif (charOffset >= this.length) {\n\t\t\treturn this._data[this.length - 1];\n\t\t}\n\t\treturn this._data[charOffset];\n\t}\n\n\tpublic partDataToCharOffset(partIndex: number, partLength: number, charIndex: number): number {\n\t\tif (this.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet searchEntry = (\n\t\t\t(partIndex << CharacterMappingConstants.PART_INDEX_OFFSET)\n\t\t\t| (charIndex << CharacterMappingConstants.CHAR_INDEX_OFFSET)\n\t\t) >>> 0;\n\n\t\tlet min = 0;\n\t\tlet max = this.length - 1;\n\t\twhile (min + 1 < max) {\n\t\t\tlet mid = ((min + max) >>> 1);\n\t\t\tlet midEntry = this._data[mid];\n\t\t\tif (midEntry === searchEntry) {\n\t\t\t\treturn mid;\n\t\t\t} else if (midEntry > searchEntry) {\n\t\t\t\tmax = mid;\n\t\t\t} else {\n\t\t\t\tmin = mid;\n\t\t\t}\n\t\t}\n\n\t\tif (min === max) {\n\t\t\treturn min;\n\t\t}\n\n\t\tlet minEntry = this._data[min];\n\t\tlet maxEntry = this._data[max];\n\n\t\tif (minEntry === searchEntry) {\n\t\t\treturn min;\n\t\t}\n\t\tif (maxEntry === searchEntry) {\n\t\t\treturn max;\n\t\t}\n\n\t\tlet minPartIndex = CharacterMapping.getPartIndex(minEntry);\n\t\tlet minCharIndex = CharacterMapping.getCharIndex(minEntry);\n\n\t\tlet maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n\t\tlet maxCharIndex: number;\n\n\t\tif (minPartIndex !== maxPartIndex) {\n\t\t\t// sitting between parts\n\t\t\tmaxCharIndex = partLength;\n\t\t} else {\n\t\t\tmaxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n\t\t}\n\n\t\tlet minEntryDistance = charIndex - minCharIndex;\n\t\tlet maxEntryDistance = maxCharIndex - charIndex;\n\n\t\tif (minEntryDistance <= maxEntryDistance) {\n\t\t\treturn min;\n\t\t}\n\t\treturn max;\n\t}\n}\n\nexport const enum ForeignElementType {\n\tNone = 0,\n\tBefore = 1,\n\tAfter = 2\n}\n\nexport class RenderLineOutput {\n\t_renderLineOutputBrand: void;\n\n\treadonly characterMapping: CharacterMapping;\n\treadonly containsRTL: boolean;\n\treadonly containsForeignElements: ForeignElementType;\n\n\tconstructor(characterMapping: CharacterMapping, containsRTL: boolean, containsForeignElements: ForeignElementType) {\n\t\tthis.characterMapping = characterMapping;\n\t\tthis.containsRTL = containsRTL;\n\t\tthis.containsForeignElements = containsForeignElements;\n\t}\n}\n\nexport function renderViewLine(input: RenderLineInput, sb: IStringBuilder): RenderLineOutput {\n\tif (input.lineContent.length === 0) {\n\n\t\tlet containsForeignElements = ForeignElementType.None;\n\n\t\t// This is basically for IE's hit test to work\n\t\tlet content: string = '<span><span>\\u00a0</span></span>';\n\n\t\tif (input.lineDecorations.length > 0) {\n\t\t\t// This line is empty, but it contains inline decorations\n\t\t\tlet classNames: string[] = [];\n\t\t\tfor (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n\t\t\t\tconst lineDecoration = input.lineDecorations[i];\n\t\t\t\tif (lineDecoration.type === InlineDecorationType.Before) {\n\t\t\t\t\tclassNames.push(input.lineDecorations[i].className);\n\t\t\t\t\tcontainsForeignElements |= ForeignElementType.Before;\n\t\t\t\t}\n\t\t\t\tif (lineDecoration.type === InlineDecorationType.After) {\n\t\t\t\t\tclassNames.push(input.lineDecorations[i].className);\n\t\t\t\t\tcontainsForeignElements |= ForeignElementType.After;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (containsForeignElements !== ForeignElementType.None) {\n\t\t\t\tcontent = `<span><span class=\"${classNames.join(' ')}\"></span></span>`;\n\t\t\t}\n\t\t}\n\n\t\tsb.appendASCIIString(content);\n\t\treturn new RenderLineOutput(\n\t\t\tnew CharacterMapping(0, 0),\n\t\t\tfalse,\n\t\t\tcontainsForeignElements\n\t\t);\n\t}\n\n\treturn _renderLine(resolveRenderLineInput(input), sb);\n}\n\nexport class RenderLineOutput2 {\n\tconstructor(\n\t\tpublic readonly characterMapping: CharacterMapping,\n\t\tpublic readonly html: string,\n\t\tpublic readonly containsRTL: boolean,\n\t\tpublic readonly containsForeignElements: ForeignElementType\n\t) {\n\t}\n}\n\nexport function renderViewLine2(input: RenderLineInput): RenderLineOutput2 {\n\tlet sb = createStringBuilder(10000);\n\tlet out = renderViewLine(input, sb);\n\treturn new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\n\nclass ResolvedRenderLineInput {\n\tconstructor(\n\t\tpublic readonly fontIsMonospace: boolean,\n\t\tpublic readonly canUseHalfwidthRightwardsArrow: boolean,\n\t\tpublic readonly lineContent: string,\n\t\tpublic readonly len: number,\n\t\tpublic readonly isOverflowing: boolean,\n\t\tpublic readonly parts: LinePart[],\n\t\tpublic readonly containsForeignElements: ForeignElementType,\n\t\tpublic readonly tabSize: number,\n\t\tpublic readonly containsRTL: boolean,\n\t\tpublic readonly spaceWidth: number,\n\t\tpublic readonly renderWhitespace: RenderWhitespace,\n\t\tpublic readonly renderControlCharacters: boolean,\n\t) {\n\t\t//\n\t}\n}\n\nfunction resolveRenderLineInput(input: RenderLineInput): ResolvedRenderLineInput {\n\tconst useMonospaceOptimizations = input.useMonospaceOptimizations;\n\tconst lineContent = input.lineContent;\n\n\tlet isOverflowing: boolean;\n\tlet len: number;\n\n\tif (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n\t\tisOverflowing = true;\n\t\tlen = input.stopRenderingLineAfter;\n\t} else {\n\t\tisOverflowing = false;\n\t\tlen = lineContent.length;\n\t}\n\n\tlet tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);\n\tif (input.renderWhitespace === RenderWhitespace.All || input.renderWhitespace === RenderWhitespace.Boundary) {\n\t\ttokens = _applyRenderWhitespace(lineContent, len, input.continuesWithWrappedLine, tokens, input.fauxIndentLength, input.tabSize, useMonospaceOptimizations, input.renderWhitespace === RenderWhitespace.Boundary);\n\t}\n\tlet containsForeignElements = ForeignElementType.None;\n\tif (input.lineDecorations.length > 0) {\n\t\tfor (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n\t\t\tconst lineDecoration = input.lineDecorations[i];\n\t\t\tif (lineDecoration.type === InlineDecorationType.RegularAffectingLetterSpacing) {\n\t\t\t\t// Pretend there are foreign elements... although not 100% accurate.\n\t\t\t\tcontainsForeignElements |= ForeignElementType.Before;\n\t\t\t} else if (lineDecoration.type === InlineDecorationType.Before) {\n\t\t\t\tcontainsForeignElements |= ForeignElementType.Before;\n\t\t\t} else if (lineDecoration.type === InlineDecorationType.After) {\n\t\t\t\tcontainsForeignElements |= ForeignElementType.After;\n\t\t\t}\n\t\t}\n\t\ttokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n\t}\n\tif (!input.containsRTL) {\n\t\t// We can never split RTL text, as it ruins the rendering\n\t\ttokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n\t}\n\n\treturn new ResolvedRenderLineInput(\n\t\tuseMonospaceOptimizations,\n\t\tinput.canUseHalfwidthRightwardsArrow,\n\t\tlineContent,\n\t\tlen,\n\t\tisOverflowing,\n\t\ttokens,\n\t\tcontainsForeignElements,\n\t\tinput.tabSize,\n\t\tinput.containsRTL,\n\t\tinput.spaceWidth,\n\t\tinput.renderWhitespace,\n\t\tinput.renderControlCharacters\n\t);\n}\n\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\nfunction transformAndRemoveOverflowing(tokens: IViewLineTokens, fauxIndentLength: number, len: number): LinePart[] {\n\tlet result: LinePart[] = [], resultLen = 0;\n\n\t// The faux indent part of the line should have no token type\n\tif (fauxIndentLength > 0) {\n\t\tresult[resultLen++] = new LinePart(fauxIndentLength, '');\n\t}\n\n\tfor (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n\t\tconst endIndex = tokens.getEndOffset(tokenIndex);\n\t\tif (endIndex <= fauxIndentLength) {\n\t\t\t// The faux indent part of the line should have no token type\n\t\t\tcontinue;\n\t\t}\n\t\tconst type = tokens.getClassName(tokenIndex);\n\t\tif (endIndex >= len) {\n\t\t\tresult[resultLen++] = new LinePart(len, type);\n\t\t\tbreak;\n\t\t}\n\t\tresult[resultLen++] = new LinePart(endIndex, type);\n\t}\n\n\treturn result;\n}\n\n/**\n * written as a const enum to get value inlining.\n */\nconst enum Constants {\n\tLongToken = 50\n}\n\n/**\n * See https://github.com/Microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\nfunction splitLargeTokens(lineContent: string, tokens: LinePart[], onlyAtSpaces: boolean): LinePart[] {\n\tlet lastTokenEndIndex = 0;\n\tlet result: LinePart[] = [], resultLen = 0;\n\n\tif (onlyAtSpaces) {\n\t\t// Split only at spaces => we need to walk each character\n\t\tfor (let i = 0, len = tokens.length; i < len; i++) {\n\t\t\tconst token = tokens[i];\n\t\t\tconst tokenEndIndex = token.endIndex;\n\t\t\tif (lastTokenEndIndex + Constants.LongToken < tokenEndIndex) {\n\t\t\t\tconst tokenType = token.type;\n\n\t\t\t\tlet lastSpaceOffset = -1;\n\t\t\t\tlet currTokenStart = lastTokenEndIndex;\n\t\t\t\tfor (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n\t\t\t\t\tif (lineContent.charCodeAt(j) === CharCode.Space) {\n\t\t\t\t\t\tlastSpaceOffset = j;\n\t\t\t\t\t}\n\t\t\t\t\tif (lastSpaceOffset !== -1 && j - currTokenStart >= Constants.LongToken) {\n\t\t\t\t\t\t// Split at `lastSpaceOffset` + 1\n\t\t\t\t\t\tresult[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType);\n\t\t\t\t\t\tcurrTokenStart = lastSpaceOffset + 1;\n\t\t\t\t\t\tlastSpaceOffset = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currTokenStart !== tokenEndIndex) {\n\t\t\t\t\tresult[resultLen++] = new LinePart(tokenEndIndex, tokenType);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult[resultLen++] = token;\n\t\t\t}\n\n\t\t\tlastTokenEndIndex = tokenEndIndex;\n\t\t}\n\t} else {\n\t\t// Split anywhere => we don't need to walk each character\n\t\tfor (let i = 0, len = tokens.length; i < len; i++) {\n\t\t\tconst token = tokens[i];\n\t\t\tconst tokenEndIndex = token.endIndex;\n\t\t\tlet diff = (tokenEndIndex - lastTokenEndIndex);\n\t\t\tif (diff > Constants.LongToken) {\n\t\t\t\tconst tokenType = token.type;\n\t\t\t\tconst piecesCount = Math.ceil(diff / Constants.LongToken);\n\t\t\t\tfor (let j = 1; j < piecesCount; j++) {\n\t\t\t\t\tlet pieceEndIndex = lastTokenEndIndex + (j * Constants.LongToken);\n\t\t\t\t\tresult[resultLen++] = new LinePart(pieceEndIndex, tokenType);\n\t\t\t\t}\n\t\t\t\tresult[resultLen++] = new LinePart(tokenEndIndex, tokenType);\n\t\t\t} else {\n\t\t\t\tresult[resultLen++] = token;\n\t\t\t}\n\t\t\tlastTokenEndIndex = tokenEndIndex;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `vs-whitespace` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\nfunction _applyRenderWhitespace(lineContent: string, len: number, continuesWithWrappedLine: boolean, tokens: LinePart[], fauxIndentLength: number, tabSize: number, useMonospaceOptimizations: boolean, onlyBoundary: boolean): LinePart[] {\n\n\tlet result: LinePart[] = [], resultLen = 0;\n\tlet tokenIndex = 0;\n\tlet tokenType = tokens[tokenIndex].type;\n\tlet tokenEndIndex = tokens[tokenIndex].endIndex;\n\tconst tokensLength = tokens.length;\n\n\tlet firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n\tlet lastNonWhitespaceIndex: number;\n\tif (firstNonWhitespaceIndex === -1) {\n\t\t// The entire line is whitespace\n\t\tfirstNonWhitespaceIndex = len;\n\t\tlastNonWhitespaceIndex = len;\n\t} else {\n\t\tlastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n\t}\n\n\tlet tmpIndent = 0;\n\tfor (let charIndex = 0; charIndex < fauxIndentLength; charIndex++) {\n\t\tconst chCode = lineContent.charCodeAt(charIndex);\n\t\tif (chCode === CharCode.Tab) {\n\t\t\ttmpIndent = tabSize;\n\t\t} else if (strings.isFullWidthCharacter(chCode)) {\n\t\t\ttmpIndent += 2;\n\t\t} else {\n\t\t\ttmpIndent++;\n\t\t}\n\t}\n\ttmpIndent = tmpIndent % tabSize;\n\n\tlet wasInWhitespace = false;\n\tfor (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n\t\tconst chCode = lineContent.charCodeAt(charIndex);\n\n\t\tlet isInWhitespace: boolean;\n\t\tif (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n\t\t\t// in leading or trailing whitespace\n\t\t\tisInWhitespace = true;\n\t\t} else if (chCode === CharCode.Tab) {\n\t\t\t// a tab character is rendered both in all and boundary cases\n\t\t\tisInWhitespace = true;\n\t\t} else if (chCode === CharCode.Space) {\n\t\t\t// hit a space character\n\t\t\tif (onlyBoundary) {\n\t\t\t\t// rendering only boundary whitespace\n\t\t\t\tif (wasInWhitespace) {\n\t\t\t\t\tisInWhitespace = true;\n\t\t\t\t} else {\n\t\t\t\t\tconst nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : CharCode.Null);\n\t\t\t\t\tisInWhitespace = (nextChCode === CharCode.Space || nextChCode === CharCode.Tab);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisInWhitespace = true;\n\t\t\t}\n\t\t} else {\n\t\t\tisInWhitespace = false;\n\t\t}\n\n\t\tif (wasInWhitespace) {\n\t\t\t// was in whitespace token\n\t\t\tif (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\n\t\t\t\t// leaving whitespace token or entering a new indent\n\t\t\t\tresult[resultLen++] = new LinePart(charIndex, 'vs-whitespace');\n\t\t\t\ttmpIndent = tmpIndent % tabSize;\n\t\t\t}\n\t\t} else {\n\t\t\t// was in regular token\n\t\t\tif (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\n\t\t\t\tresult[resultLen++] = new LinePart(charIndex, tokenType);\n\t\t\t\ttmpIndent = tmpIndent % tabSize;\n\t\t\t}\n\t\t}\n\n\t\tif (chCode === CharCode.Tab) {\n\t\t\ttmpIndent = tabSize;\n\t\t} else if (strings.isFullWidthCharacter(chCode)) {\n\t\t\ttmpIndent += 2;\n\t\t} else {\n\t\t\ttmpIndent++;\n\t\t}\n\n\t\twasInWhitespace = isInWhitespace;\n\n\t\tif (charIndex === tokenEndIndex) {\n\t\t\ttokenIndex++;\n\t\t\tif (tokenIndex < tokensLength) {\n\t\t\t\ttokenType = tokens[tokenIndex].type;\n\t\t\t\ttokenEndIndex = tokens[tokenIndex].endIndex;\n\t\t\t}\n\t\t}\n\t}\n\n\tlet generateWhitespace = false;\n\tif (wasInWhitespace) {\n\t\t// was in whitespace token\n\t\tif (continuesWithWrappedLine && onlyBoundary) {\n\t\t\tlet lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : CharCode.Null);\n\t\t\tlet prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : CharCode.Null);\n\t\t\tlet isSingleTrailingSpace = (lastCharCode === CharCode.Space && (prevCharCode !== CharCode.Space && prevCharCode !== CharCode.Tab));\n\t\t\tif (!isSingleTrailingSpace) {\n\t\t\t\tgenerateWhitespace = true;\n\t\t\t}\n\t\t} else {\n\t\t\tgenerateWhitespace = true;\n\t\t}\n\t}\n\n\tresult[resultLen++] = new LinePart(len, generateWhitespace ? 'vs-whitespace' : tokenType);\n\n\treturn result;\n}\n\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\nfunction _applyInlineDecorations(lineContent: string, len: number, tokens: LinePart[], _lineDecorations: LineDecoration[]): LinePart[] {\n\t_lineDecorations.sort(LineDecoration.compare);\n\tconst lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n\tconst lineDecorationsLen = lineDecorations.length;\n\n\tlet lineDecorationIndex = 0;\n\tlet result: LinePart[] = [], resultLen = 0, lastResultEndIndex = 0;\n\tfor (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n\t\tconst token = tokens[tokenIndex];\n\t\tconst tokenEndIndex = token.endIndex;\n\t\tconst tokenType = token.type;\n\n\t\twhile (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n\t\t\tconst lineDecoration = lineDecorations[lineDecorationIndex];\n\n\t\t\tif (lineDecoration.startOffset > lastResultEndIndex) {\n\t\t\t\tlastResultEndIndex = lineDecoration.startOffset;\n\t\t\t\tresult[resultLen++] = new LinePart(lastResultEndIndex, tokenType);\n\t\t\t}\n\n\t\t\tif (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n\t\t\t\t// This line decoration ends before this token ends\n\t\t\t\tlastResultEndIndex = lineDecoration.endOffset + 1;\n\t\t\t\tresult[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);\n\t\t\t\tlineDecorationIndex++;\n\t\t\t} else {\n\t\t\t\t// This line decoration continues on to the next token\n\t\t\t\tlastResultEndIndex = tokenEndIndex;\n\t\t\t\tresult[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (tokenEndIndex > lastResultEndIndex) {\n\t\t\tlastResultEndIndex = tokenEndIndex;\n\t\t\tresult[resultLen++] = new LinePart(lastResultEndIndex, tokenType);\n\t\t}\n\t}\n\n\tconst lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n\tif (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n\t\tlet classNames: string[] = [];\n\t\twhile (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n\t\t\tclassNames.push(lineDecorations[lineDecorationIndex].className);\n\t\t\tlineDecorationIndex++;\n\t\t}\n\t\tresult[resultLen++] = new LinePart(lastResultEndIndex, classNames.join(' '));\n\t}\n\n\treturn result;\n}\n\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\nfunction _renderLine(input: ResolvedRenderLineInput, sb: IStringBuilder): RenderLineOutput {\n\tconst fontIsMonospace = input.fontIsMonospace;\n\tconst canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n\tconst containsForeignElements = input.containsForeignElements;\n\tconst lineContent = input.lineContent;\n\tconst len = input.len;\n\tconst isOverflowing = input.isOverflowing;\n\tconst parts = input.parts;\n\tconst tabSize = input.tabSize;\n\tconst containsRTL = input.containsRTL;\n\tconst spaceWidth = input.spaceWidth;\n\tconst renderWhitespace = input.renderWhitespace;\n\tconst renderControlCharacters = input.renderControlCharacters;\n\n\tconst characterMapping = new CharacterMapping(len + 1, parts.length);\n\n\tlet charIndex = 0;\n\tlet tabsCharDelta = 0;\n\tlet charOffsetInPart = 0;\n\n\tlet prevPartContentCnt = 0;\n\tlet partAbsoluteOffset = 0;\n\n\tsb.appendASCIIString('<span>');\n\n\tfor (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n\t\tpartAbsoluteOffset += prevPartContentCnt;\n\n\t\tconst part = parts[partIndex];\n\t\tconst partEndIndex = part.endIndex;\n\t\tconst partType = part.type;\n\t\tconst partRendersWhitespace = (renderWhitespace !== RenderWhitespace.None && (partType.indexOf('vs-whitespace') >= 0));\n\t\tcharOffsetInPart = 0;\n\n\t\tsb.appendASCIIString('<span class=\"');\n\t\tsb.appendASCIIString(partType);\n\t\tsb.appendASCII(CharCode.DoubleQuote);\n\n\t\tif (partRendersWhitespace) {\n\n\t\t\tlet partContentCnt = 0;\n\t\t\t{\n\t\t\t\tlet _charIndex = charIndex;\n\t\t\t\tlet _tabsCharDelta = tabsCharDelta;\n\n\t\t\t\tfor (; _charIndex < partEndIndex; _charIndex++) {\n\t\t\t\t\tconst charCode = lineContent.charCodeAt(_charIndex);\n\n\t\t\t\t\tif (charCode === CharCode.Tab) {\n\t\t\t\t\t\tlet insertSpacesCount = tabSize - (_charIndex + _tabsCharDelta) % tabSize;\n\t\t\t\t\t\t_tabsCharDelta += insertSpacesCount - 1;\n\t\t\t\t\t\tpartContentCnt += insertSpacesCount;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// must be CharCode.Space\n\t\t\t\t\t\tpartContentCnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!fontIsMonospace) {\n\t\t\t\tconst partIsOnlyWhitespace = (partType === 'vs-whitespace');\n\t\t\t\tif (partIsOnlyWhitespace || !containsForeignElements) {\n\t\t\t\t\tsb.appendASCIIString(' style=\"width:');\n\t\t\t\t\tsb.appendASCIIString(String(spaceWidth * partContentCnt));\n\t\t\t\t\tsb.appendASCIIString('px\"');\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.appendASCII(CharCode.GreaterThan);\n\n\t\t\tfor (; charIndex < partEndIndex; charIndex++) {\n\t\t\t\tcharacterMapping.setPartData(charIndex, partIndex, charOffsetInPart, partAbsoluteOffset);\n\t\t\t\tconst charCode = lineContent.charCodeAt(charIndex);\n\n\t\t\t\tif (charCode === CharCode.Tab) {\n\t\t\t\t\tlet insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n\t\t\t\t\ttabsCharDelta += insertSpacesCount - 1;\n\t\t\t\t\tcharOffsetInPart += insertSpacesCount - 1;\n\t\t\t\t\tif (insertSpacesCount > 0) {\n\t\t\t\t\t\tif (!canUseHalfwidthRightwardsArrow || insertSpacesCount > 1) {\n\t\t\t\t\t\t\tsb.write1(0x2192); // RIGHTWARDS ARROW\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinsertSpacesCount--;\n\t\t\t\t\t}\n\t\t\t\t\twhile (insertSpacesCount > 0) {\n\t\t\t\t\t\tsb.write1(0xA0); // &nbsp;\n\t\t\t\t\t\tinsertSpacesCount--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// must be CharCode.Space\n\t\t\t\t\tsb.write1(0xB7); // &middot;\n\t\t\t\t}\n\n\t\t\t\tcharOffsetInPart++;\n\t\t\t}\n\n\t\t\tprevPartContentCnt = partContentCnt;\n\n\t\t} else {\n\n\t\t\tlet partContentCnt = 0;\n\n\t\t\tif (containsRTL) {\n\t\t\t\tsb.appendASCIIString(' dir=\"ltr\"');\n\t\t\t}\n\t\t\tsb.appendASCII(CharCode.GreaterThan);\n\n\t\t\tfor (; charIndex < partEndIndex; charIndex++) {\n\t\t\t\tcharacterMapping.setPartData(charIndex, partIndex, charOffsetInPart, partAbsoluteOffset);\n\t\t\t\tconst charCode = lineContent.charCodeAt(charIndex);\n\n\t\t\t\tswitch (charCode) {\n\t\t\t\t\tcase CharCode.Tab:\n\t\t\t\t\t\tlet insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n\t\t\t\t\t\ttabsCharDelta += insertSpacesCount - 1;\n\t\t\t\t\t\tcharOffsetInPart += insertSpacesCount - 1;\n\t\t\t\t\t\twhile (insertSpacesCount > 0) {\n\t\t\t\t\t\t\tsb.write1(0xA0); // &nbsp;\n\t\t\t\t\t\t\tpartContentCnt++;\n\t\t\t\t\t\t\tinsertSpacesCount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CharCode.Space:\n\t\t\t\t\t\tsb.write1(0xA0); // &nbsp;\n\t\t\t\t\t\tpartContentCnt++;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CharCode.LessThan:\n\t\t\t\t\t\tsb.appendASCIIString('&lt;');\n\t\t\t\t\t\tpartContentCnt++;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CharCode.GreaterThan:\n\t\t\t\t\t\tsb.appendASCIIString('&gt;');\n\t\t\t\t\t\tpartContentCnt++;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CharCode.Ampersand:\n\t\t\t\t\t\tsb.appendASCIIString('&amp;');\n\t\t\t\t\t\tpartContentCnt++;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CharCode.Null:\n\t\t\t\t\t\tsb.appendASCIIString('&#00;');\n\t\t\t\t\t\tpartContentCnt++;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CharCode.UTF8_BOM:\n\t\t\t\t\tcase CharCode.LINE_SEPARATOR_2028:\n\t\t\t\t\t\tsb.write1(0xFFFD);\n\t\t\t\t\t\tpartContentCnt++;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (strings.isFullWidthCharacter(charCode)) {\n\t\t\t\t\t\t\ttabsCharDelta++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (renderControlCharacters && charCode < 32) {\n\t\t\t\t\t\t\tsb.write1(9216 + charCode);\n\t\t\t\t\t\t\tpartContentCnt++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsb.write1(charCode);\n\t\t\t\t\t\t\tpartContentCnt++;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcharOffsetInPart++;\n\t\t\t}\n\n\t\t\tprevPartContentCnt = partContentCnt;\n\t\t}\n\n\t\tsb.appendASCIIString('</span>');\n\n\t}\n\n\t// When getting client rects for the last character, we will position the\n\t// text range at the end of the span, insteaf of at the beginning of next span\n\tcharacterMapping.setPartData(len, parts.length - 1, charOffsetInPart, partAbsoluteOffset);\n\n\tif (isOverflowing) {\n\t\tsb.appendASCIIString('<span>&hellip;</span>');\n\t}\n\n\tsb.appendASCIIString('</span>');\n\n\treturn new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}\n"]}]}