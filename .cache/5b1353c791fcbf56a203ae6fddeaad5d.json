{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/referenceSearch/referencesController.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/referenceSearch/referencesController.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/errors\", \"vs/base/common/lifecycle\", \"vs/editor/browser/services/codeEditorService\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/contextkey/common/contextkey\", \"vs/platform/configuration/common/configuration\", \"vs/platform/storage/common/storage\", \"./referencesWidget\", \"vs/editor/common/core/range\", \"vs/editor/common/core/position\", \"vs/platform/notification/common/notification\"], function (require, exports, nls, errors_1, lifecycle_1, codeEditorService_1, instantiation_1, contextkey_1, configuration_1, storage_1, referencesWidget_1, range_1, position_1, notification_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.ctxReferenceSearchVisible = new contextkey_1.RawContextKey('referenceSearchVisible', false);\n    let ReferencesController = class ReferencesController {\n        constructor(_defaultTreeKeyboardSupport, editor, contextKeyService, _editorService, _notificationService, _instantiationService, _storageService, _configurationService) {\n            this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;\n            this._editorService = _editorService;\n            this._notificationService = _notificationService;\n            this._instantiationService = _instantiationService;\n            this._storageService = _storageService;\n            this._configurationService = _configurationService;\n            this._requestIdPool = 0;\n            this._disposables = [];\n            this._ignoreModelChangeEvent = false;\n            this._editor = editor;\n            this._referenceSearchVisible = exports.ctxReferenceSearchVisible.bindTo(contextKeyService);\n        }\n        static get(editor) {\n            return editor.getContribution(ReferencesController.ID);\n        }\n        getId() {\n            return ReferencesController.ID;\n        }\n        dispose() {\n            this._referenceSearchVisible.reset();\n            lifecycle_1.dispose(this._disposables);\n            if (this._widget) {\n                lifecycle_1.dispose(this._widget);\n                this._widget = null;\n            }\n            if (this._model) {\n                lifecycle_1.dispose(this._model);\n                this._model = null;\n            }\n        }\n        toggleWidget(range, modelPromise, options) {\n            // close current widget and return early is position didn't change\n            let widgetPosition;\n            if (this._widget) {\n                widgetPosition = this._widget.position;\n            }\n            this.closeWidget();\n            if (!!widgetPosition && range.containsPosition(widgetPosition)) {\n                return;\n            }\n            this._referenceSearchVisible.set(true);\n            // close the widget on model/mode changes\n            this._disposables.push(this._editor.onDidChangeModelLanguage(() => { this.closeWidget(); }));\n            this._disposables.push(this._editor.onDidChangeModel(() => {\n                if (!this._ignoreModelChangeEvent) {\n                    this.closeWidget();\n                }\n            }));\n            const storageKey = 'peekViewLayout';\n            const data = JSON.parse(this._storageService.get(storageKey, storage_1.StorageScope.GLOBAL, '{}'));\n            this._widget = this._instantiationService.createInstance(referencesWidget_1.ReferenceWidget, this._editor, this._defaultTreeKeyboardSupport, data);\n            this._widget.setTitle(nls.localize('labelLoading', \"Loading...\"));\n            this._widget.show(range);\n            this._disposables.push(this._widget.onDidClose(() => {\n                modelPromise.cancel();\n                if (this._widget) {\n                    this._storageService.store(storageKey, JSON.stringify(this._widget.layoutData), storage_1.StorageScope.GLOBAL);\n                    this._widget = null;\n                }\n                this.closeWidget();\n            }));\n            this._disposables.push(this._widget.onDidSelectReference(event => {\n                let { element, kind } = event;\n                switch (kind) {\n                    case 'open':\n                        if (event.source === 'editor'\n                            && this._configurationService.getValue('editor.stablePeek')) {\n                            // when stable peek is configured we don't close\n                            // the peek window on selecting the editor\n                            break;\n                        }\n                    case 'side':\n                        if (element) {\n                            this.openReference(element, kind === 'side');\n                        }\n                        break;\n                    case 'goto':\n                        if (element) {\n                            if (options.onGoto) {\n                                options.onGoto(element);\n                            }\n                            else {\n                                this._gotoReference(element);\n                            }\n                        }\n                        break;\n                }\n            }));\n            const requestId = ++this._requestIdPool;\n            modelPromise.then(model => {\n                // still current request? widget still open?\n                if (requestId !== this._requestIdPool || !this._widget) {\n                    return undefined;\n                }\n                if (this._model) {\n                    this._model.dispose();\n                }\n                this._model = model;\n                // show widget\n                return this._widget.setModel(this._model).then(() => {\n                    if (this._widget && this._model && this._editor.hasModel()) { // might have been closed\n                        // set title\n                        this._widget.setMetaTitle(options.getMetaTitle(this._model));\n                        // set 'best' selection\n                        let uri = this._editor.getModel().uri;\n                        let pos = new position_1.Position(range.startLineNumber, range.startColumn);\n                        let selection = this._model.nearestReference(uri, pos);\n                        if (selection) {\n                            return this._widget.setSelection(selection);\n                        }\n                    }\n                    return undefined;\n                });\n            }, error => {\n                this._notificationService.error(error);\n            });\n        }\n        goToNextOrPreviousReference(fwd) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!this._editor.hasModel() || !this._model || !this._widget) {\n                    // can be called while still resolving...\n                    return;\n                }\n                const currentPosition = this._widget.position;\n                if (!currentPosition) {\n                    return;\n                }\n                const source = this._model.nearestReference(this._editor.getModel().uri, currentPosition);\n                if (!source) {\n                    return;\n                }\n                const target = this._model.nextOrPreviousReference(source, fwd);\n                const editorFocus = this._editor.hasTextFocus();\n                yield this._widget.setSelection(target);\n                yield this._gotoReference(target);\n                if (editorFocus) {\n                    this._editor.focus();\n                }\n            });\n        }\n        closeWidget() {\n            if (this._widget) {\n                lifecycle_1.dispose(this._widget);\n                this._widget = null;\n            }\n            this._referenceSearchVisible.reset();\n            this._disposables = lifecycle_1.dispose(this._disposables);\n            if (this._model) {\n                lifecycle_1.dispose(this._model);\n                this._model = null;\n            }\n            this._editor.focus();\n            this._requestIdPool += 1; // Cancel pending requests\n        }\n        _gotoReference(ref) {\n            if (this._widget) {\n                this._widget.hide();\n            }\n            this._ignoreModelChangeEvent = true;\n            const range = range_1.Range.lift(ref.range).collapseToStart();\n            return this._editorService.openCodeEditor({\n                resource: ref.uri,\n                options: { selection: range }\n            }, this._editor).then(openedEditor => {\n                this._ignoreModelChangeEvent = false;\n                if (!openedEditor || openedEditor !== this._editor) {\n                    // TODO@Alex TODO@Joh\n                    // when opening the current reference we might end up\n                    // in a different editor instance. that means we also have\n                    // a different instance of this reference search controller\n                    // and cannot hold onto the widget (which likely doesn't\n                    // exist). Instead of bailing out we should find the\n                    // 'sister' action and pass our current model on to it.\n                    this.closeWidget();\n                    return;\n                }\n                if (this._widget) {\n                    this._widget.show(range);\n                    this._widget.focus();\n                }\n            }, (err) => {\n                this._ignoreModelChangeEvent = false;\n                errors_1.onUnexpectedError(err);\n            });\n        }\n        openReference(ref, sideBySide) {\n            // clear stage\n            if (!sideBySide) {\n                this.closeWidget();\n            }\n            const { uri, range } = ref;\n            this._editorService.openCodeEditor({\n                resource: uri,\n                options: { selection: range }\n            }, this._editor, sideBySide);\n        }\n    };\n    ReferencesController.ID = 'editor.contrib.referencesController';\n    ReferencesController = __decorate([\n        __param(2, contextkey_1.IContextKeyService),\n        __param(3, codeEditorService_1.ICodeEditorService),\n        __param(4, notification_1.INotificationService),\n        __param(5, instantiation_1.IInstantiationService),\n        __param(6, storage_1.IStorageService),\n        __param(7, configuration_1.IConfigurationService)\n    ], ReferencesController);\n    exports.ReferencesController = ReferencesController;\n});\n",null]}