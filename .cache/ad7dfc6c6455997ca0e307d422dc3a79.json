{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/packages/events/src/events.ts","dependencies":[{"path":"/home/coding/workspace/packages/events/src/events.ts","mtime":1555841535682},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Emitter typecasts for a single event type. You can optionally use IDs, but\n * using undefined with IDs will not work. If you emit without an ID, *all*\n * listeners regardless of their ID (or lack thereof) will receive the event.\n * Similarly, if you listen without an ID you will get *all* events for any or\n * no ID.\n */\nvar Emitter = /** @class */ (function () {\n    function Emitter() {\n        this.listeners = [];\n        this.idListeners = new Map();\n    }\n    Object.defineProperty(Emitter.prototype, \"event\", {\n        get: function () {\n            var _this = this;\n            return function (id, cb) {\n                if (typeof id !== \"function\") {\n                    if (_this.idListeners.has(id)) {\n                        _this.idListeners.get(id).push(cb);\n                    }\n                    else {\n                        _this.idListeners.set(id, [cb]);\n                    }\n                    return {\n                        dispose: function () {\n                            if (_this.idListeners.has(id)) {\n                                var cbs = _this.idListeners.get(id);\n                                var i = cbs.indexOf(cb);\n                                if (i !== -1) {\n                                    cbs.splice(i, 1);\n                                }\n                            }\n                        },\n                    };\n                }\n                cb = id;\n                _this.listeners.push(cb);\n                return {\n                    dispose: function () {\n                        var i = _this.listeners.indexOf(cb);\n                        if (i !== -1) {\n                            _this.listeners.splice(i, 1);\n                        }\n                    },\n                };\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Emitter.prototype.emit = function (id, value) {\n        if ((typeof id === \"number\" || typeof id === \"string\") && typeof value !== \"undefined\") {\n            if (this.idListeners.has(id)) {\n                this.idListeners.get(id).forEach(function (cb) { return cb(value); });\n            }\n            this.listeners.forEach(function (cb) { return cb(value); });\n        }\n        else {\n            this.idListeners.forEach(function (cbs) { return cbs.forEach(function (cb) { return cb(id); }); });\n            this.listeners.forEach(function (cb) { return cb(id); });\n        }\n    };\n    Emitter.prototype.dispose = function (id) {\n        if (typeof id !== \"undefined\") {\n            this.idListeners.delete(id);\n        }\n        else {\n            this.listeners = [];\n            this.idListeners.clear();\n        }\n    };\n    Object.defineProperty(Emitter.prototype, \"counts\", {\n        get: function () {\n            var counts = {};\n            if (this.listeners.length > 0) {\n                counts[\"n/a\"] = this.listeners.length;\n            }\n            this.idListeners.forEach(function (cbs, id) {\n                if (cbs.length > 0) {\n                    counts[\"\" + id] = cbs.length;\n                }\n            });\n            return counts;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Emitter;\n}());\nexports.Emitter = Emitter;\n",{"version":3,"file":"/home/coding/workspace/packages/events/src/events.ts","sourceRoot":"","sources":["/home/coding/workspace/packages/events/src/events.ts"],"names":[],"mappings":"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","sourcesContent":["import { IDisposable } from \"@coder/disposable\";\n\nexport interface Event<T> {\n\t(listener: (value: T) => void): IDisposable;\n\t(id: number | string, listener: (value: T) => void): IDisposable;\n}\n\n/**\n * Emitter typecasts for a single event type. You can optionally use IDs, but\n * using undefined with IDs will not work. If you emit without an ID, *all*\n * listeners regardless of their ID (or lack thereof) will receive the event.\n * Similarly, if you listen without an ID you will get *all* events for any or\n * no ID.\n */\nexport class Emitter<T> {\n\tprivate listeners = <Array<(value: T) => void>>[];\n\tprivate readonly idListeners = new Map<number | string, Array<(value: T) => void>>();\n\n\tpublic get event(): Event<T> {\n\t\treturn (id: number | string | ((value: T) => void), cb?: (value: T) => void): IDisposable => {\n\t\t\tif (typeof id !== \"function\") {\n\t\t\t\tif (this.idListeners.has(id)) {\n\t\t\t\t\tthis.idListeners.get(id)!.push(cb!);\n\t\t\t\t} else {\n\t\t\t\t\tthis.idListeners.set(id, [cb!]);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tdispose: (): void => {\n\t\t\t\t\t\tif (this.idListeners.has(id)) {\n\t\t\t\t\t\t\tconst cbs = this.idListeners.get(id)!;\n\t\t\t\t\t\t\tconst i = cbs.indexOf(cb!);\n\t\t\t\t\t\t\tif (i !== -1) {\n\t\t\t\t\t\t\t\tcbs.splice(i, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tcb = id;\n\t\t\tthis.listeners.push(cb);\n\n\t\t\treturn {\n\t\t\t\tdispose: (): void => {\n\t\t\t\t\tconst i = this.listeners.indexOf(cb!);\n\t\t\t\t\tif (i !== -1) {\n\t\t\t\t\t\tthis.listeners.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\t\t};\n\t}\n\n\t/**\n\t * Emit an event with a value.\n\t */\n\tpublic emit(value: T): void;\n\tpublic emit(id: number | string, value: T): void;\n\tpublic emit(id: number | string | T, value?: T): void {\n\t\tif ((typeof id === \"number\" || typeof id === \"string\") && typeof value !== \"undefined\") {\n\t\t\tif (this.idListeners.has(id)) {\n\t\t\t\tthis.idListeners.get(id)!.forEach((cb) => cb(value!));\n\t\t\t}\n\t\t\tthis.listeners.forEach((cb) => cb(value!));\n\t\t} else {\n\t\t\tthis.idListeners.forEach((cbs) => cbs.forEach((cb) => cb((id as T)!)));\n\t\t\tthis.listeners.forEach((cb) => cb((id as T)!));\n\t\t}\n\t}\n\n\t/**\n\t * Dispose the current events.\n\t */\n\tpublic dispose(): void;\n\tpublic dispose(id: number | string): void;\n\tpublic dispose(id?: number | string): void {\n\t\tif (typeof id !== \"undefined\") {\n\t\t\tthis.idListeners.delete(id);\n\t\t} else {\n\t\t\tthis.listeners = [];\n\t\t\tthis.idListeners.clear();\n\t\t}\n\t}\n\n\tpublic get counts(): { [key: string]: number } {\n\t\tconst counts = <{ [key: string]: number }>{};\n\t\tif (this.listeners.length > 0) {\n\t\t\tcounts[\"n/a\"] = this.listeners.length;\n\t\t}\n\t\tthis.idListeners.forEach((cbs, id) => {\n\t\t\tif (cbs.length > 0) {\n\t\t\t\tcounts[`${id}`] = cbs.length;\n\t\t\t}\n\t\t});\n\n\t\treturn counts;\n\t}\n}\n"]}]}