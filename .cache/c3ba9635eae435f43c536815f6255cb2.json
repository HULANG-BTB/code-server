{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/packages/protocol/src/browser/modules/net.ts","dependencies":[{"path":"/home/coding/workspace/packages/protocol/src/browser/modules/net.ts","mtime":1555841535686},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar util_1 = require(\"util\");\nvar proxy_1 = require(\"../../common/proxy\");\nvar stream_1 = require(\"./stream\");\n// tslint:disable completed-docs\nvar Socket = /** @class */ (function (_super) {\n    tslib_1.__extends(Socket, _super);\n    function Socket(proxyPromise, connecting) {\n        var _this = _super.call(this, proxyPromise) || this;\n        _this._connecting = false;\n        _this._destroyed = false;\n        if (connecting) {\n            _this._connecting = connecting;\n        }\n        _this.on(\"close\", function () {\n            _this._destroyed = true;\n            _this._connecting = false;\n        });\n        _this.on(\"connect\", function () { return _this._connecting = false; });\n        return _this;\n    }\n    Socket.prototype.connect = function (options, host, callback) {\n        if (typeof host === \"function\") {\n            callback = host;\n            host = undefined;\n        }\n        this._connecting = true;\n        if (callback) {\n            this.on(\"connect\", callback);\n        }\n        return this.catch(this.proxy.connect(options, host));\n    };\n    // tslint:disable-next-line no-any\n    Socket.prototype.end = function (data, encoding, callback) {\n        if (typeof encoding === \"function\") {\n            callback = encoding;\n            encoding = undefined;\n        }\n        util_1.callbackify(this.proxy.end)(data, encoding, function () {\n            if (callback) {\n                callback();\n            }\n        });\n    };\n    // tslint:disable-next-line no-any\n    Socket.prototype.write = function (data, encoding, fd) {\n        var callback;\n        if (typeof encoding === \"function\") {\n            callback = encoding;\n            encoding = undefined;\n        }\n        if (typeof fd === \"function\") {\n            callback = fd;\n            fd = undefined;\n        }\n        if (typeof fd !== \"undefined\") {\n            throw new Error(\"fd argument not supported\");\n        }\n        util_1.callbackify(this.proxy.write)(data, encoding, function () {\n            if (callback) {\n                callback();\n            }\n        });\n        return true; // Always true since we can't get this synchronously.\n    };\n    Object.defineProperty(Socket.prototype, \"connecting\", {\n        get: function () {\n            return this._connecting;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Socket.prototype, \"destroyed\", {\n        get: function () {\n            return this._destroyed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Socket.prototype, \"bufferSize\", {\n        get: function () {\n            throw new Error(\"not implemented\");\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Socket.prototype, \"bytesRead\", {\n        get: function () {\n            throw new Error(\"not implemented\");\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Socket.prototype, \"bytesWritten\", {\n        get: function () {\n            throw new Error(\"not implemented\");\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Socket.prototype, \"localAddress\", {\n        get: function () {\n            throw new Error(\"not implemented\");\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Socket.prototype, \"localPort\", {\n        get: function () {\n            throw new Error(\"not implemented\");\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Socket.prototype.address = function () {\n        throw new Error(\"not implemented\");\n    };\n    Socket.prototype.setTimeout = function () {\n        throw new Error(\"not implemented\");\n    };\n    Socket.prototype.setNoDelay = function () {\n        throw new Error(\"not implemented\");\n    };\n    Socket.prototype.setKeepAlive = function () {\n        throw new Error(\"not implemented\");\n    };\n    Socket.prototype.unref = function () {\n        this.catch(this.proxy.unref());\n    };\n    Socket.prototype.ref = function () {\n        this.catch(this.proxy.ref());\n    };\n    return Socket;\n}(stream_1.Duplex));\nexports.Socket = Socket;\nvar Server = /** @class */ (function (_super) {\n    tslib_1.__extends(Server, _super);\n    function Server(proxyPromise) {\n        var _this = _super.call(this, proxyPromise) || this;\n        _this.socketId = 0;\n        _this.sockets = new Map();\n        _this._listening = false;\n        _this.catch(_this.proxy.onConnection(function (socketProxy) {\n            var socket = new Socket(socketProxy);\n            var socketId = _this.socketId++;\n            _this.sockets.set(socketId, socket);\n            socket.on(\"error\", function () { return _this.sockets.delete(socketId); });\n            socket.on(\"close\", function () { return _this.sockets.delete(socketId); });\n            _this.emit(\"connection\", socket);\n        }));\n        _this.on(\"listening\", function () { return _this._listening = true; });\n        _this.on(\"error\", function () { return _this._listening = false; });\n        _this.on(\"close\", function () { return _this._listening = false; });\n        return _this;\n    }\n    Server.prototype.listen = function (handle, hostname, backlog, callback) {\n        if (typeof hostname === \"function\") {\n            callback = hostname;\n            hostname = undefined;\n        }\n        if (typeof backlog === \"function\") {\n            callback = backlog;\n            backlog = undefined;\n        }\n        if (callback) {\n            this.on(\"listening\", callback);\n        }\n        return this.catch(this.proxy.listen(handle, hostname, backlog));\n    };\n    Object.defineProperty(Server.prototype, \"connections\", {\n        get: function () {\n            return this.sockets.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Server.prototype, \"listening\", {\n        get: function () {\n            return this._listening;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Server.prototype, \"maxConnections\", {\n        get: function () {\n            throw new Error(\"not implemented\");\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Server.prototype.address = function () {\n        throw new Error(\"not implemented\");\n    };\n    Server.prototype.close = function (callback) {\n        this._listening = false;\n        if (callback) {\n            this.on(\"close\", callback);\n        }\n        return this.catch(this.proxy.close());\n    };\n    Server.prototype.ref = function () {\n        return this.catch(this.proxy.ref());\n    };\n    Server.prototype.unref = function () {\n        return this.catch(this.proxy.unref());\n    };\n    Server.prototype.getConnections = function (cb) {\n        cb(null, this.sockets.size);\n    };\n    Server.prototype.handleDisconnect = function () {\n        this.emit(\"close\");\n    };\n    return Server;\n}(proxy_1.ClientProxy));\nexports.Server = Server;\nvar NetModule = /** @class */ (function () {\n    function NetModule(proxy) {\n        var _this = this;\n        this.proxy = proxy;\n        this.createConnection = function (target, host, callback) {\n            if (typeof host === \"function\") {\n                callback = host;\n                host = undefined;\n            }\n            var socket = new Socket(_this.proxy.createConnection(target, host), true);\n            if (callback) {\n                socket.on(\"connect\", callback);\n            }\n            return socket;\n        };\n        this.createServer = function (options, callback) {\n            if (typeof options === \"function\") {\n                callback = options;\n                options = undefined;\n            }\n            var server = new Server(_this.proxy.createServer(options));\n            if (callback) {\n                server.on(\"connection\", callback);\n            }\n            return server;\n        };\n        this.connect = function () {\n            throw new Error(\"not implemented\");\n        };\n        this.isIP = function (_input) {\n            throw new Error(\"not implemented\");\n        };\n        this.isIPv4 = function (_input) {\n            throw new Error(\"not implemented\");\n        };\n        this.isIPv6 = function (_input) {\n            throw new Error(\"not implemented\");\n        };\n        // @ts-ignore this is because Socket is missing things from the Stream\n        // namespace but I'm unsure how best to provide them (finished,\n        // finished.__promisify__, pipeline, and some others) or if it even matters.\n        this.Socket = /** @class */ (function (_super) {\n            tslib_1.__extends(class_1, _super);\n            function class_1(options) {\n                return _super.call(this, proxy.createSocket(options)) || this;\n            }\n            return class_1;\n        }(Socket));\n        this.Server = /** @class */ (function (_super) {\n            tslib_1.__extends(class_2, _super);\n            function class_2(options, listener) {\n                var _this = _super.call(this, proxy.createServer(typeof options !== \"function\" ? options : undefined)) || this;\n                if (typeof options === \"function\") {\n                    listener = options;\n                }\n                if (listener) {\n                    _this.on(\"connection\", listener);\n                }\n                return _this;\n            }\n            return class_2;\n        }(Server));\n    }\n    return NetModule;\n}());\nexports.NetModule = NetModule;\n",{"version":3,"file":"/home/coding/workspace/packages/protocol/src/browser/modules/net.ts","sourceRoot":"","sources":["/home/coding/workspace/packages/protocol/src/browser/modules/net.ts"],"names":[],"mappings":"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","sourcesContent":["import * as net from \"net\";\nimport { callbackify } from \"util\";\nimport { ClientProxy } from \"../../common/proxy\";\nimport { NetModuleProxy, NetServerProxy, NetSocketProxy } from \"../../node/modules/net\";\nimport { Duplex } from \"./stream\";\n\n// tslint:disable completed-docs\n\nexport class Socket extends Duplex<NetSocketProxy> implements net.Socket {\n\tprivate _connecting: boolean = false;\n\tprivate _destroyed: boolean = false;\n\n\tpublic constructor(proxyPromise: Promise<NetSocketProxy> | NetSocketProxy, connecting?: boolean) {\n\t\tsuper(proxyPromise);\n\t\tif (connecting) {\n\t\t\tthis._connecting = connecting;\n\t\t}\n\t\tthis.on(\"close\", () => {\n\t\t\tthis._destroyed = true;\n\t\t\tthis._connecting = false;\n\t\t});\n\t\tthis.on(\"connect\", () => this._connecting = false);\n\t}\n\n\tpublic connect(options: number | string | net.SocketConnectOpts, host?: string | Function, callback?: Function): this {\n\t\tif (typeof host === \"function\") {\n\t\t\tcallback = host;\n\t\t\thost = undefined;\n\t\t}\n\t\tthis._connecting = true;\n\t\tif (callback) {\n\t\t\tthis.on(\"connect\", callback as () => void);\n\t\t}\n\n\t\treturn this.catch(this.proxy.connect(options, host));\n\t}\n\n\t// tslint:disable-next-line no-any\n\tpublic end(data?: any, encoding?: string | Function, callback?: Function): void {\n\t\tif (typeof encoding === \"function\") {\n\t\t\tcallback = encoding;\n\t\t\tencoding = undefined;\n\t\t}\n\n\t\tcallbackify(this.proxy.end)(data, encoding, () => {\n\t\t\tif (callback) {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t});\n\t}\n\n\t// tslint:disable-next-line no-any\n\tpublic write(data: any, encoding?: string | Function, fd?: string | Function): boolean {\n\t\tlet callback: undefined | Function;\n\t\tif (typeof encoding === \"function\") {\n\t\t\tcallback = encoding;\n\t\t\tencoding = undefined;\n\t\t}\n\t\tif (typeof fd === \"function\") {\n\t\t\tcallback = fd;\n\t\t\tfd = undefined;\n\t\t}\n\t\tif (typeof fd !== \"undefined\") {\n\t\t\tthrow new Error(\"fd argument not supported\");\n\t\t}\n\n\t\tcallbackify(this.proxy.write)(data, encoding, () => {\n\t\t\tif (callback) {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t});\n\n\t\treturn true; // Always true since we can't get this synchronously.\n\t}\n\n\tpublic get connecting(): boolean {\n\t\treturn this._connecting;\n\t}\n\n\tpublic get destroyed(): boolean {\n\t\treturn this._destroyed;\n\t}\n\n\tpublic get bufferSize(): number {\n\t\tthrow new Error(\"not implemented\");\n\t}\n\n\tpublic get bytesRead(): number {\n\t\tthrow new Error(\"not implemented\");\n\t}\n\n\tpublic get bytesWritten(): number {\n\t\tthrow new Error(\"not implemented\");\n\t}\n\n\tpublic get localAddress(): string {\n\t\tthrow new Error(\"not implemented\");\n\t}\n\n\tpublic get localPort(): number {\n\t\tthrow new Error(\"not implemented\");\n\t}\n\n\tpublic address(): net.AddressInfo | string {\n\t\tthrow new Error(\"not implemented\");\n\t}\n\n\tpublic setTimeout(): this {\n\t\tthrow new Error(\"not implemented\");\n\t}\n\n\tpublic setNoDelay(): this {\n\t\tthrow new Error(\"not implemented\");\n\t}\n\n\tpublic setKeepAlive(): this {\n\t\tthrow new Error(\"not implemented\");\n\t}\n\n\tpublic unref(): void {\n\t\tthis.catch(this.proxy.unref());\n\t}\n\n\tpublic ref(): void {\n\t\tthis.catch(this.proxy.ref());\n\t}\n}\n\nexport class Server extends ClientProxy<NetServerProxy> implements net.Server {\n\tprivate socketId = 0;\n\tprivate readonly sockets = new Map<number, net.Socket>();\n\tprivate _listening: boolean = false;\n\n\tpublic constructor(proxyPromise: Promise<NetServerProxy> | NetServerProxy) {\n\t\tsuper(proxyPromise);\n\n\t\tthis.catch(this.proxy.onConnection((socketProxy) => {\n\t\t\tconst socket = new Socket(socketProxy);\n\t\t\tconst socketId = this.socketId++;\n\t\t\tthis.sockets.set(socketId, socket);\n\t\t\tsocket.on(\"error\", () => this.sockets.delete(socketId));\n\t\t\tsocket.on(\"close\", () => this.sockets.delete(socketId));\n\t\t\tthis.emit(\"connection\", socket);\n\t\t}));\n\n\t\tthis.on(\"listening\", () => this._listening = true);\n\t\tthis.on(\"error\", () => this._listening = false);\n\t\tthis.on(\"close\", () => this._listening = false);\n\t}\n\n\tpublic listen(handle?: net.ListenOptions | number | string, hostname?: string | number | Function, backlog?: number | Function, callback?: Function): this {\n\t\tif (typeof hostname === \"function\") {\n\t\t\tcallback = hostname;\n\t\t\thostname = undefined;\n\t\t}\n\t\tif (typeof backlog === \"function\") {\n\t\t\tcallback = backlog;\n\t\t\tbacklog = undefined;\n\t\t}\n\t\tif (callback) {\n\t\t\tthis.on(\"listening\", callback as () => void);\n\t\t}\n\n\t\treturn this.catch(this.proxy.listen(handle, hostname, backlog));\n\t}\n\n\tpublic get connections(): number {\n\t\treturn this.sockets.size;\n\t}\n\n\tpublic get listening(): boolean {\n\t\treturn this._listening;\n\t}\n\n\tpublic get maxConnections(): number {\n\t\tthrow new Error(\"not implemented\");\n\t}\n\n\tpublic address(): net.AddressInfo | string {\n\t\tthrow new Error(\"not implemented\");\n\t}\n\n\tpublic close(callback?: () => void): this {\n\t\tthis._listening = false;\n\t\tif (callback) {\n\t\t\tthis.on(\"close\", callback);\n\t\t}\n\n\t\treturn this.catch(this.proxy.close());\n\t}\n\n\tpublic ref(): this {\n\t\treturn this.catch(this.proxy.ref());\n\t}\n\n\tpublic unref(): this {\n\t\treturn this.catch(this.proxy.unref());\n\t}\n\n\tpublic getConnections(cb: (error: Error | null, count: number) => void): void {\n\t\tcb(null, this.sockets.size);\n\t}\n\n\tprotected handleDisconnect(): void {\n\t\tthis.emit(\"close\");\n\t}\n}\n\ntype NodeNet = typeof net;\n\nexport class NetModule implements NodeNet {\n\tpublic readonly Socket: typeof net.Socket;\n\tpublic readonly Server: typeof net.Server;\n\n\tpublic constructor(private readonly proxy: NetModuleProxy) {\n\t\t// @ts-ignore this is because Socket is missing things from the Stream\n\t\t// namespace but I'm unsure how best to provide them (finished,\n\t\t// finished.__promisify__, pipeline, and some others) or if it even matters.\n\t\tthis.Socket = class extends Socket {\n\t\t\tpublic constructor(options?: net.SocketConstructorOpts) {\n\t\t\t\tsuper(proxy.createSocket(options));\n\t\t\t}\n\t\t};\n\n\t\tthis.Server = class extends Server {\n\t\t\tpublic constructor(options?: { allowHalfOpen?: boolean, pauseOnConnect?: boolean } | ((socket: Socket) => void), listener?: (socket: Socket) => void) {\n\t\t\t\tsuper(proxy.createServer(typeof options !== \"function\" ? options : undefined));\n\t\t\t\tif (typeof options === \"function\") {\n\t\t\t\t\tlistener = options;\n\t\t\t\t}\n\t\t\t\tif (listener) {\n\t\t\t\t\tthis.on(\"connection\", listener);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic createConnection = (target: string | number | net.NetConnectOpts, host?: string | Function, callback?: Function): net.Socket => {\n\t\tif (typeof host === \"function\") {\n\t\t\tcallback = host;\n\t\t\thost = undefined;\n\t\t}\n\n\t\tconst socket = new Socket(this.proxy.createConnection(target, host), true);\n\t\tif (callback) {\n\t\t\tsocket.on(\"connect\", callback as () => void);\n\t\t}\n\n\t\treturn socket;\n\t}\n\n\tpublic createServer = (\n\t\toptions?: { allowHalfOpen?: boolean, pauseOnConnect?: boolean } | ((socket: net.Socket) => void),\n\t\tcallback?: (socket: net.Socket) => void,\n\t): net.Server => {\n\t\tif (typeof options === \"function\") {\n\t\t\tcallback = options;\n\t\t\toptions = undefined;\n\t\t}\n\n\t\tconst server = new Server(this.proxy.createServer(options));\n\t\tif (callback) {\n\t\t\tserver.on(\"connection\", callback);\n\t\t}\n\n\t\treturn server;\n\t}\n\n\tpublic connect = (): net.Socket => {\n\t\tthrow new Error(\"not implemented\");\n\t}\n\n\tpublic isIP = (_input: string): number => {\n\t\tthrow new Error(\"not implemented\");\n\t}\n\n\tpublic isIPv4 = (_input: string): boolean => {\n\t\tthrow new Error(\"not implemented\");\n\t}\n\n\tpublic isIPv6 = (_input: string): boolean => {\n\t\tthrow new Error(\"not implemented\");\n\t}\n}\n"]}]}