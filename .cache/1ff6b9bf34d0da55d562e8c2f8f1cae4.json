{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/common/ipc.net.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/common/ipc.net.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/event\", \"vs/base/parts/ipc/common/ipc\", \"vs/base/common/lifecycle\", \"vs/base/common/buffer\", \"vs/base/common/platform\"], function (require, exports, event_1, ipc_1, lifecycle_1, buffer_1, platform) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let emptyBuffer = null;\n    function getEmptyBuffer() {\n        if (!emptyBuffer) {\n            emptyBuffer = buffer_1.VSBuffer.alloc(0);\n        }\n        return emptyBuffer;\n    }\n    class ChunkStream {\n        get byteLength() {\n            return this._totalLength;\n        }\n        constructor() {\n            this._chunks = [];\n            this._totalLength = 0;\n        }\n        acceptChunk(buff) {\n            this._chunks.push(buff);\n            this._totalLength += buff.byteLength;\n        }\n        read(byteCount) {\n            if (byteCount === 0) {\n                return getEmptyBuffer();\n            }\n            if (byteCount > this._totalLength) {\n                throw new Error(`Cannot read so many bytes!`);\n            }\n            if (this._chunks[0].byteLength === byteCount) {\n                // super fast path, precisely first chunk must be returned\n                const result = this._chunks.shift();\n                this._totalLength -= byteCount;\n                return result;\n            }\n            if (this._chunks[0].byteLength > byteCount) {\n                // fast path, the reading is entirely within the first chunk\n                const result = this._chunks[0].slice(0, byteCount);\n                this._chunks[0] = this._chunks[0].slice(byteCount);\n                this._totalLength -= byteCount;\n                return result;\n            }\n            let result = buffer_1.VSBuffer.alloc(byteCount);\n            let resultOffset = 0;\n            while (byteCount > 0) {\n                const chunk = this._chunks[0];\n                if (chunk.byteLength > byteCount) {\n                    // this chunk will survive\n                    this._chunks[0] = chunk.slice(byteCount);\n                    const chunkPart = chunk.slice(0, byteCount);\n                    result.set(chunkPart, resultOffset);\n                    resultOffset += byteCount;\n                    this._totalLength -= byteCount;\n                    byteCount -= byteCount;\n                }\n                else {\n                    // this chunk will be entirely read\n                    this._chunks.shift();\n                    result.set(chunk, resultOffset);\n                    resultOffset += chunk.byteLength;\n                    this._totalLength -= chunk.byteLength;\n                    byteCount -= chunk.byteLength;\n                }\n            }\n            return result;\n        }\n    }\n    var ProtocolMessageType;\n    (function (ProtocolMessageType) {\n        ProtocolMessageType[ProtocolMessageType[\"None\"] = 0] = \"None\";\n        ProtocolMessageType[ProtocolMessageType[\"Regular\"] = 1] = \"Regular\";\n        ProtocolMessageType[ProtocolMessageType[\"Control\"] = 2] = \"Control\";\n        ProtocolMessageType[ProtocolMessageType[\"Ack\"] = 3] = \"Ack\";\n        ProtocolMessageType[ProtocolMessageType[\"KeepAlive\"] = 4] = \"KeepAlive\";\n    })(ProtocolMessageType || (ProtocolMessageType = {}));\n    var ProtocolConstants;\n    (function (ProtocolConstants) {\n        ProtocolConstants[ProtocolConstants[\"HeaderLength\"] = 13] = \"HeaderLength\";\n        /**\n         * Send an Acknowledge message at most 2 seconds later...\n         */\n        ProtocolConstants[ProtocolConstants[\"AcknowledgeTime\"] = 2000] = \"AcknowledgeTime\";\n        /**\n         * If there is a message that has been unacknowledged for 10 seconds, consider the connection closed...\n         */\n        ProtocolConstants[ProtocolConstants[\"AcknowledgeTimeoutTime\"] = 10000] = \"AcknowledgeTimeoutTime\";\n        /**\n         * Send at least a message every 30s for keep alive reasons.\n         */\n        ProtocolConstants[ProtocolConstants[\"KeepAliveTime\"] = 30000] = \"KeepAliveTime\";\n        /**\n         * If there is no message received for 60 seconds, consider the connection closed...\n         */\n        ProtocolConstants[ProtocolConstants[\"KeepAliveTimeoutTime\"] = 60000] = \"KeepAliveTimeoutTime\";\n        /**\n         * If there is no reconnection within this time-frame, consider the connection permanently closed...\n         */\n        ProtocolConstants[ProtocolConstants[\"ReconnectionGraceTime\"] = 3600000] = \"ReconnectionGraceTime\";\n    })(ProtocolConstants = exports.ProtocolConstants || (exports.ProtocolConstants = {}));\n    class ProtocolMessage {\n        constructor(type, id, ack, data) {\n            this.type = type;\n            this.id = id;\n            this.ack = ack;\n            this.data = data;\n            this.writtenTime = 0;\n        }\n        get size() {\n            return this.data.byteLength;\n        }\n    }\n    class ProtocolReader extends lifecycle_1.Disposable {\n        constructor(socket) {\n            super();\n            this._onMessage = new event_1.Emitter();\n            this.onMessage = this._onMessage.event;\n            this._state = {\n                readHead: true,\n                readLen: ProtocolConstants.HeaderLength,\n                messageType: ProtocolMessageType.None,\n                id: 0,\n                ack: 0\n            };\n            this._socket = socket;\n            this._isDisposed = false;\n            this._incomingData = new ChunkStream();\n            this._register(this._socket.onData(data => this.acceptChunk(data)));\n            this.lastReadTime = Date.now();\n        }\n        acceptChunk(data) {\n            if (!data || data.byteLength === 0) {\n                return;\n            }\n            this.lastReadTime = Date.now();\n            this._incomingData.acceptChunk(data);\n            while (this._incomingData.byteLength >= this._state.readLen) {\n                const buff = this._incomingData.read(this._state.readLen);\n                if (this._state.readHead) {\n                    // buff is the header\n                    // save new state => next time will read the body\n                    this._state.readHead = false;\n                    this._state.readLen = buff.readUint32BE(9);\n                    this._state.messageType = buff.readUint8(0);\n                    this._state.id = buff.readUint32BE(1);\n                    this._state.ack = buff.readUint32BE(5);\n                }\n                else {\n                    // buff is the body\n                    const messageType = this._state.messageType;\n                    const id = this._state.id;\n                    const ack = this._state.ack;\n                    // save new state => next time will read the header\n                    this._state.readHead = true;\n                    this._state.readLen = ProtocolConstants.HeaderLength;\n                    this._state.messageType = ProtocolMessageType.None;\n                    this._state.id = 0;\n                    this._state.ack = 0;\n                    this._onMessage.fire(new ProtocolMessage(messageType, id, ack, buff));\n                    if (this._isDisposed) {\n                        // check if an event listener lead to our disposal\n                        break;\n                    }\n                }\n            }\n        }\n        readEntireBuffer() {\n            return this._incomingData.read(this._incomingData.byteLength);\n        }\n        dispose() {\n            this._isDisposed = true;\n            super.dispose();\n        }\n    }\n    class ProtocolWriter {\n        constructor(socket) {\n            this._isDisposed = false;\n            this._socket = socket;\n            this._data = [];\n            this._totalLength = 0;\n            this.lastWriteTime = 0;\n        }\n        dispose() {\n            this.flush();\n            this._isDisposed = true;\n        }\n        flush() {\n            // flush\n            this._writeNow();\n        }\n        write(msg) {\n            if (this._isDisposed) {\n                console.warn(`Cannot write message in a disposed ProtocolWriter`);\n                console.warn(msg);\n                return;\n            }\n            msg.writtenTime = Date.now();\n            this.lastWriteTime = Date.now();\n            const header = buffer_1.VSBuffer.alloc(ProtocolConstants.HeaderLength);\n            header.writeUint8(msg.type, 0);\n            header.writeUint32BE(msg.id, 1);\n            header.writeUint32BE(msg.ack, 5);\n            header.writeUint32BE(msg.data.byteLength, 9);\n            this._writeSoon(header, msg.data);\n        }\n        _bufferAdd(head, body) {\n            const wasEmpty = this._totalLength === 0;\n            this._data.push(head, body);\n            this._totalLength += head.byteLength + body.byteLength;\n            return wasEmpty;\n        }\n        _bufferTake() {\n            const ret = buffer_1.VSBuffer.concat(this._data, this._totalLength);\n            this._data.length = 0;\n            this._totalLength = 0;\n            return ret;\n        }\n        _writeSoon(header, data) {\n            if (this._bufferAdd(header, data)) {\n                platform.setImmediate(() => {\n                    this._writeNow();\n                });\n            }\n        }\n        _writeNow() {\n            if (this._totalLength === 0) {\n                return;\n            }\n            this._socket.write(this._bufferTake());\n        }\n    }\n    /**\n     * A message has the following format:\n     * ```\n     *     /-------------------------------|------\\\n     *     |             HEADER            |      |\n     *     |-------------------------------| DATA |\n     *     | TYPE | ID | ACK | DATA_LENGTH |      |\n     *     \\-------------------------------|------/\n     * ```\n     * The header is 9 bytes and consists of:\n     *  - TYPE is 1 byte (ProtocolMessageType) - the message type\n     *  - ID is 4 bytes (u32be) - the message id (can be 0 to indicate to be ignored)\n     *  - ACK is 4 bytes (u32be) - the acknowledged message id (can be 0 to indicate to be ignored)\n     *  - DATA_LENGTH is 4 bytes (u32be) - the length in bytes of DATA\n     *\n     * Only Regular messages are counted, other messages are not counted, nor acknowledged.\n     */\n    class Protocol extends lifecycle_1.Disposable {\n        constructor(socket) {\n            super();\n            this._onMessage = new event_1.Emitter();\n            this.onMessage = this._onMessage.event;\n            this._onClose = new event_1.Emitter();\n            this.onClose = this._onClose.event;\n            this._socket = socket;\n            this._socketWriter = this._register(new ProtocolWriter(this._socket));\n            this._socketReader = this._register(new ProtocolReader(this._socket));\n            this._register(this._socketReader.onMessage((msg) => {\n                if (msg.type === ProtocolMessageType.Regular) {\n                    this._onMessage.fire(msg.data);\n                }\n            }));\n            this._register(this._socket.onClose(() => this._onClose.fire()));\n        }\n        getSocket() {\n            return this._socket;\n        }\n        send(buffer) {\n            this._socketWriter.write(new ProtocolMessage(ProtocolMessageType.Regular, 0, 0, buffer));\n        }\n    }\n    exports.Protocol = Protocol;\n    class Client extends ipc_1.IPCClient {\n        constructor(protocol, id) {\n            super(protocol, id);\n            this.protocol = protocol;\n        }\n        static fromSocket(socket, id) {\n            return new Client(new Protocol(socket), id);\n        }\n        get onClose() { return this.protocol.onClose; }\n        dispose() {\n            super.dispose();\n            const socket = this.protocol.getSocket();\n            this.protocol.dispose();\n            socket.end();\n        }\n    }\n    exports.Client = Client;\n    /**\n     * Will ensure no messages are lost if there are no event listeners.\n     */\n    function createBufferedEvent(source) {\n        let emitter;\n        let hasListeners = false;\n        let isDeliveringMessages = false;\n        let bufferedMessages = [];\n        const deliverMessages = () => {\n            if (isDeliveringMessages) {\n                return;\n            }\n            isDeliveringMessages = true;\n            while (hasListeners && bufferedMessages.length > 0) {\n                emitter.fire(bufferedMessages.shift());\n            }\n            isDeliveringMessages = false;\n        };\n        source((e) => {\n            bufferedMessages.push(e);\n            deliverMessages();\n        });\n        emitter = new event_1.Emitter({\n            onFirstListenerAdd: () => {\n                hasListeners = true;\n                // it is important to deliver these messages after this call, but before\n                // other messages have a chance to be received (to guarantee in order delivery)\n                // that's why we're using here nextTick and not other types of timeouts\n                if (typeof process !== 'undefined') {\n                    process.nextTick(deliverMessages);\n                }\n                else {\n                    platform.setImmediate(deliverMessages);\n                }\n            },\n            onLastListenerRemove: () => {\n                hasListeners = false;\n            }\n        });\n        return emitter.event;\n    }\n    class QueueElement {\n        constructor(data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n    class Queue {\n        constructor() {\n            this._first = null;\n            this._last = null;\n        }\n        peek() {\n            if (!this._first) {\n                return null;\n            }\n            return this._first.data;\n        }\n        toArray() {\n            let result = [], resultLen = 0;\n            let it = this._first;\n            while (it) {\n                result[resultLen++] = it.data;\n                it = it.next;\n            }\n            return result;\n        }\n        pop() {\n            if (!this._first) {\n                return;\n            }\n            if (this._first === this._last) {\n                this._first = null;\n                this._last = null;\n                return;\n            }\n            this._first = this._first.next;\n        }\n        push(item) {\n            const element = new QueueElement(item);\n            if (!this._first) {\n                this._first = element;\n                this._last = element;\n                return;\n            }\n            this._last.next = element;\n            this._last = element;\n        }\n    }\n    /**\n     * Same as Protocol, but will actually track messages and acks.\n     * Moreover, it will ensure no messages are lost if there are no event listeners.\n     */\n    class PersistentProtocol {\n        constructor(socket, initialChunk = null) {\n            this._onControlMessage = new event_1.Emitter();\n            this.onControlMessage = createBufferedEvent(this._onControlMessage.event);\n            this._onMessage = new event_1.Emitter();\n            this.onMessage = createBufferedEvent(this._onMessage.event);\n            this._onClose = new event_1.Emitter();\n            this.onClose = createBufferedEvent(this._onClose.event);\n            this._onSocketClose = new event_1.Emitter();\n            this.onSocketClose = createBufferedEvent(this._onSocketClose.event);\n            this._onSocketTimeout = new event_1.Emitter();\n            this.onSocketTimeout = createBufferedEvent(this._onSocketTimeout.event);\n            this._isReconnecting = false;\n            this._outgoingUnackMsg = new Queue();\n            this._outgoingMsgId = 0;\n            this._outgoingAckId = 0;\n            this._outgoingAckTimeout = null;\n            this._incomingMsgId = 0;\n            this._incomingAckId = 0;\n            this._incomingMsgLastTime = 0;\n            this._incomingAckTimeout = null;\n            this._outgoingKeepAliveTimeout = null;\n            this._incomingKeepAliveTimeout = null;\n            this._socketDisposables = [];\n            this._socket = socket;\n            this._socketWriter = new ProtocolWriter(this._socket);\n            this._socketDisposables.push(this._socketWriter);\n            this._socketReader = new ProtocolReader(this._socket);\n            this._socketDisposables.push(this._socketReader);\n            this._socketDisposables.push(this._socketReader.onMessage(msg => this._receiveMessage(msg)));\n            this._socketDisposables.push(this._socket.onClose(() => this._onSocketClose.fire()));\n            this._socketDisposables.push(this._socket.onEnd(() => this._onClose.fire()));\n            if (initialChunk) {\n                this._socketReader.acceptChunk(initialChunk);\n            }\n            this._sendKeepAliveCheck();\n            this._recvKeepAliveCheck();\n        }\n        get unacknowledgedCount() {\n            return this._outgoingMsgId - this._outgoingAckId;\n        }\n        dispose() {\n            if (this._outgoingAckTimeout) {\n                clearTimeout(this._outgoingAckTimeout);\n                this._outgoingAckTimeout = null;\n            }\n            if (this._incomingAckTimeout) {\n                clearTimeout(this._incomingAckTimeout);\n                this._incomingAckTimeout = null;\n            }\n            if (this._outgoingKeepAliveTimeout) {\n                clearTimeout(this._outgoingKeepAliveTimeout);\n                this._outgoingKeepAliveTimeout = null;\n            }\n            if (this._incomingKeepAliveTimeout) {\n                clearTimeout(this._incomingKeepAliveTimeout);\n                this._incomingKeepAliveTimeout = null;\n            }\n            this._socketDisposables = lifecycle_1.dispose(this._socketDisposables);\n        }\n        _sendKeepAliveCheck() {\n            if (this._outgoingKeepAliveTimeout) {\n                // there will be a check in the near future\n                return;\n            }\n            const timeSinceLastOutgoingMsg = Date.now() - this._socketWriter.lastWriteTime;\n            if (timeSinceLastOutgoingMsg >= ProtocolConstants.KeepAliveTime) {\n                // sufficient time has passed since last message was written,\n                // and no message from our side needed to be sent in the meantime,\n                // so we will send a message containing only a keep alive.\n                const msg = new ProtocolMessage(ProtocolMessageType.KeepAlive, 0, 0, getEmptyBuffer());\n                this._socketWriter.write(msg);\n                this._sendKeepAliveCheck();\n                return;\n            }\n            this._outgoingKeepAliveTimeout = setTimeout(() => {\n                this._outgoingKeepAliveTimeout = null;\n                this._sendKeepAliveCheck();\n            }, ProtocolConstants.KeepAliveTime - timeSinceLastOutgoingMsg + 5);\n        }\n        _recvKeepAliveCheck() {\n            if (this._incomingKeepAliveTimeout) {\n                // there will be a check in the near future\n                return;\n            }\n            const timeSinceLastIncomingMsg = Date.now() - this._socketReader.lastReadTime;\n            if (timeSinceLastIncomingMsg >= ProtocolConstants.KeepAliveTimeoutTime) {\n                // Trash the socket\n                this._onSocketTimeout.fire(undefined);\n                return;\n            }\n            this._incomingKeepAliveTimeout = setTimeout(() => {\n                this._incomingKeepAliveTimeout = null;\n                this._recvKeepAliveCheck();\n            }, ProtocolConstants.KeepAliveTimeoutTime - timeSinceLastIncomingMsg + 5);\n        }\n        getSocket() {\n            return this._socket;\n        }\n        beginAcceptReconnection(socket, initialDataChunk) {\n            this._isReconnecting = true;\n            this._socketDisposables = lifecycle_1.dispose(this._socketDisposables);\n            this._socket = socket;\n            this._socketWriter = new ProtocolWriter(this._socket);\n            this._socketDisposables.push(this._socketWriter);\n            this._socketReader = new ProtocolReader(this._socket);\n            this._socketDisposables.push(this._socketReader);\n            this._socketDisposables.push(this._socketReader.onMessage(msg => this._receiveMessage(msg)));\n            this._socketDisposables.push(this._socket.onClose(() => this._onSocketClose.fire()));\n            this._socketDisposables.push(this._socket.onEnd(() => this._onClose.fire()));\n            this._socketReader.acceptChunk(initialDataChunk);\n        }\n        endAcceptReconnection() {\n            this._isReconnecting = false;\n            // Send again all unacknowledged messages\n            const toSend = this._outgoingUnackMsg.toArray();\n            for (let i = 0, len = toSend.length; i < len; i++) {\n                this._socketWriter.write(toSend[i]);\n            }\n            this._recvAckCheck();\n            this._sendKeepAliveCheck();\n            this._recvKeepAliveCheck();\n        }\n        _receiveMessage(msg) {\n            if (msg.ack > this._outgoingAckId) {\n                this._outgoingAckId = msg.ack;\n                do {\n                    const first = this._outgoingUnackMsg.peek();\n                    if (first && first.id <= msg.ack) {\n                        // this message has been confirmed, remove it\n                        this._outgoingUnackMsg.pop();\n                    }\n                    else {\n                        break;\n                    }\n                } while (true);\n            }\n            if (msg.type === ProtocolMessageType.Regular) {\n                if (msg.id > this._incomingMsgId) {\n                    if (msg.id !== this._incomingMsgId + 1) {\n                        console.error(`PROTOCOL CORRUPTION, LAST SAW MSG ${this._incomingMsgId} AND HAVE NOW RECEIVED MSG ${msg.id}`);\n                    }\n                    this._incomingMsgId = msg.id;\n                    this._incomingMsgLastTime = Date.now();\n                    this._sendAckCheck();\n                    this._onMessage.fire(msg.data);\n                }\n            }\n            else if (msg.type === ProtocolMessageType.Control) {\n                this._onControlMessage.fire(msg.data);\n            }\n        }\n        readEntireBuffer() {\n            return this._socketReader.readEntireBuffer();\n        }\n        flush() {\n            this._socketWriter.flush();\n        }\n        send(buffer) {\n            const myId = ++this._outgoingMsgId;\n            this._incomingAckId = this._incomingMsgId;\n            const msg = new ProtocolMessage(ProtocolMessageType.Regular, myId, this._incomingAckId, buffer);\n            this._outgoingUnackMsg.push(msg);\n            if (!this._isReconnecting) {\n                this._socketWriter.write(msg);\n                this._recvAckCheck();\n            }\n        }\n        /**\n         * Send a message which will not be part of the regular acknowledge flow.\n         * Use this for early control messages which are repeated in case of reconnection.\n         */\n        sendControl(buffer) {\n            const msg = new ProtocolMessage(ProtocolMessageType.Control, 0, 0, buffer);\n            this._socketWriter.write(msg);\n        }\n        _sendAckCheck() {\n            if (this._incomingMsgId <= this._incomingAckId) {\n                // nothink to acknowledge\n                return;\n            }\n            if (this._incomingAckTimeout) {\n                // there will be a check in the near future\n                return;\n            }\n            const timeSinceLastIncomingMsg = Date.now() - this._incomingMsgLastTime;\n            if (timeSinceLastIncomingMsg >= ProtocolConstants.AcknowledgeTime) {\n                // sufficient time has passed since this message has been received,\n                // and no message from our side needed to be sent in the meantime,\n                // so we will send a message containing only an ack.\n                this._sendAck();\n                return;\n            }\n            this._incomingAckTimeout = setTimeout(() => {\n                this._incomingAckTimeout = null;\n                this._sendAckCheck();\n            }, ProtocolConstants.AcknowledgeTime - timeSinceLastIncomingMsg + 5);\n        }\n        _recvAckCheck() {\n            if (this._outgoingMsgId <= this._outgoingAckId) {\n                // everything has been acknowledged\n                return;\n            }\n            if (this._outgoingAckTimeout) {\n                // there will be a check in the near future\n                return;\n            }\n            const oldestUnacknowledgedMsg = this._outgoingUnackMsg.peek();\n            const timeSinceOldestUnacknowledgedMsg = Date.now() - oldestUnacknowledgedMsg.writtenTime;\n            if (timeSinceOldestUnacknowledgedMsg >= ProtocolConstants.AcknowledgeTimeoutTime) {\n                // Trash the socket\n                this._onSocketTimeout.fire(undefined);\n                return;\n            }\n            this._outgoingAckTimeout = setTimeout(() => {\n                this._outgoingAckTimeout = null;\n                this._recvAckCheck();\n            }, ProtocolConstants.AcknowledgeTimeoutTime - timeSinceOldestUnacknowledgedMsg + 5);\n        }\n        _sendAck() {\n            if (this._incomingMsgId <= this._incomingAckId) {\n                // nothink to acknowledge\n                return;\n            }\n            this._incomingAckId = this._incomingMsgId;\n            const msg = new ProtocolMessage(ProtocolMessageType.Ack, 0, this._incomingAckId, getEmptyBuffer());\n            this._socketWriter.write(msg);\n        }\n    }\n    exports.PersistentProtocol = PersistentProtocol;\n});\n",null]}