{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/smartSelect/smartSelect.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/smartSelect/smartSelect.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/arrays\", \"vs/base/common/cancellation\", \"vs/base/common/keyCodes\", \"vs/editor/browser/editorExtensions\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\", \"vs/editor/common/core/selection\", \"vs/editor/common/editorContextKeys\", \"vs/editor/common/modes\", \"vs/nls\", \"vs/platform/actions/common/actions\", \"vs/platform/keybinding/common/keybindingsRegistry\", \"vs/base/common/lifecycle\", \"vs/editor/contrib/smartSelect/wordSelections\", \"vs/editor/contrib/smartSelect/bracketSelections\", \"vs/platform/commands/common/commands\", \"vs/base/common/errors\"], function (require, exports, arrays, cancellation_1, keyCodes_1, editorExtensions_1, position_1, range_1, selection_1, editorContextKeys_1, modes, nls, actions_1, keybindingsRegistry_1, lifecycle_1, wordSelections_1, bracketSelections_1, commands_1, errors_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class SelectionRanges {\n        constructor(index, ranges) {\n            this.index = index;\n            this.ranges = ranges;\n        }\n        mov(fwd) {\n            let index = this.index + (fwd ? 1 : -1);\n            if (index < 0 || index >= this.ranges.length) {\n                return this;\n            }\n            const res = new SelectionRanges(index, this.ranges);\n            if (res.ranges[index].equalsRange(this.ranges[this.index])) {\n                // next range equals this range, retry with next-next\n                return res.mov(fwd);\n            }\n            return res;\n        }\n    }\n    class SmartSelectController {\n        constructor(editor) {\n            this._ignoreSelection = false;\n            this._editor = editor;\n        }\n        static get(editor) {\n            return editor.getContribution(SmartSelectController._id);\n        }\n        dispose() {\n            lifecycle_1.dispose(this._selectionListener);\n        }\n        getId() {\n            return SmartSelectController._id;\n        }\n        run(forward) {\n            if (!this._editor.hasModel()) {\n                return;\n            }\n            const selections = this._editor.getSelections();\n            const model = this._editor.getModel();\n            if (!modes.SelectionRangeRegistry.has(model)) {\n                return;\n            }\n            let promise = Promise.resolve(undefined);\n            if (!this._state) {\n                promise = provideSelectionRanges(model, selections.map(s => s.getPosition()), cancellation_1.CancellationToken.None).then(ranges => {\n                    if (!arrays.isNonEmptyArray(ranges) || ranges.length !== selections.length) {\n                        // invalid result\n                        return;\n                    }\n                    if (!this._editor.hasModel() || !arrays.equals(this._editor.getSelections(), selections, (a, b) => a.equalsSelection(b))) {\n                        // invalid editor state\n                        return;\n                    }\n                    for (let i = 0; i < ranges.length; i++) {\n                        ranges[i] = ranges[i].filter(range => {\n                            // filter ranges inside the selection\n                            return range.containsPosition(selections[i].getStartPosition()) && range.containsPosition(selections[i].getEndPosition());\n                        });\n                        // prepend current selection\n                        ranges[i].unshift(selections[i]);\n                    }\n                    this._state = ranges.map(ranges => new SelectionRanges(0, ranges));\n                    // listen to caret move and forget about state\n                    lifecycle_1.dispose(this._selectionListener);\n                    this._selectionListener = this._editor.onDidChangeCursorPosition(() => {\n                        if (!this._ignoreSelection) {\n                            lifecycle_1.dispose(this._selectionListener);\n                            this._state = undefined;\n                        }\n                    });\n                });\n            }\n            return promise.then(() => {\n                if (!this._state) {\n                    // no state\n                    return;\n                }\n                this._state = this._state.map(state => state.mov(forward));\n                const selections = this._state.map(state => selection_1.Selection.fromPositions(state.ranges[state.index].getStartPosition(), state.ranges[state.index].getEndPosition()));\n                this._ignoreSelection = true;\n                try {\n                    this._editor.setSelections(selections);\n                }\n                finally {\n                    this._ignoreSelection = false;\n                }\n            });\n        }\n    }\n    SmartSelectController._id = 'editor.contrib.smartSelectController';\n    class AbstractSmartSelect extends editorExtensions_1.EditorAction {\n        constructor(forward, opts) {\n            super(opts);\n            this._forward = forward;\n        }\n        run(_accessor, editor) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let controller = SmartSelectController.get(editor);\n                if (controller) {\n                    yield controller.run(this._forward);\n                }\n            });\n        }\n    }\n    class GrowSelectionAction extends AbstractSmartSelect {\n        constructor() {\n            super(true, {\n                id: 'editor.action.smartSelect.expand',\n                label: nls.localize('smartSelect.expand', \"Expand Selection\"),\n                alias: 'Expand Selection',\n                precondition: null,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.RightArrow,\n                    mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.RightArrow },\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                menubarOpts: {\n                    menuId: actions_1.MenuId.MenubarSelectionMenu,\n                    group: '1_basic',\n                    title: nls.localize({ key: 'miSmartSelectGrow', comment: ['&& denotes a mnemonic'] }, \"&&Expand Selection\"),\n                    order: 2\n                }\n            });\n        }\n    }\n    // renamed command id\n    commands_1.CommandsRegistry.registerCommandAlias('editor.action.smartSelect.grow', 'editor.action.smartSelect.expand');\n    class ShrinkSelectionAction extends AbstractSmartSelect {\n        constructor() {\n            super(false, {\n                id: 'editor.action.smartSelect.shrink',\n                label: nls.localize('smartSelect.shrink', \"Shrink Selection\"),\n                alias: 'Shrink Selection',\n                precondition: null,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.LeftArrow,\n                    mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.LeftArrow },\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                menubarOpts: {\n                    menuId: actions_1.MenuId.MenubarSelectionMenu,\n                    group: '1_basic',\n                    title: nls.localize({ key: 'miSmartSelectShrink', comment: ['&& denotes a mnemonic'] }, \"&&Shrink Selection\"),\n                    order: 3\n                }\n            });\n        }\n    }\n    editorExtensions_1.registerEditorContribution(SmartSelectController);\n    editorExtensions_1.registerEditorAction(GrowSelectionAction);\n    editorExtensions_1.registerEditorAction(ShrinkSelectionAction);\n    // word selection\n    modes.SelectionRangeRegistry.register('*', new wordSelections_1.WordSelectionRangeProvider());\n    function provideSelectionRanges(model, positions, token) {\n        const providers = modes.SelectionRangeRegistry.all(model);\n        if (providers.length === 1) {\n            // add word selection and bracket selection when no provider exists\n            providers.unshift(new bracketSelections_1.BracketSelectionRangeProvider());\n        }\n        let work = [];\n        let allRawRanges = [];\n        for (const provider of providers) {\n            work.push(Promise.resolve(provider.provideSelectionRanges(model, positions, token)).then(allProviderRanges => {\n                if (arrays.isNonEmptyArray(allProviderRanges) && allProviderRanges.length === positions.length) {\n                    for (let i = 0; i < positions.length; i++) {\n                        if (!allRawRanges[i]) {\n                            allRawRanges[i] = [];\n                        }\n                        for (const oneProviderRanges of allProviderRanges[i]) {\n                            if (range_1.Range.isIRange(oneProviderRanges.range) && range_1.Range.containsPosition(oneProviderRanges.range, positions[i])) {\n                                allRawRanges[i].push(range_1.Range.lift(oneProviderRanges.range));\n                            }\n                        }\n                    }\n                }\n            }, errors_1.onUnexpectedExternalError));\n        }\n        return Promise.all(work).then(() => {\n            return allRawRanges.map(oneRawRanges => {\n                if (oneRawRanges.length === 0) {\n                    return [];\n                }\n                // sort all by start/end position\n                oneRawRanges.sort((a, b) => {\n                    if (position_1.Position.isBefore(a.getStartPosition(), b.getStartPosition())) {\n                        return 1;\n                    }\n                    else if (position_1.Position.isBefore(b.getStartPosition(), a.getStartPosition())) {\n                        return -1;\n                    }\n                    else if (position_1.Position.isBefore(a.getEndPosition(), b.getEndPosition())) {\n                        return -1;\n                    }\n                    else if (position_1.Position.isBefore(b.getEndPosition(), a.getEndPosition())) {\n                        return 1;\n                    }\n                    else {\n                        return 0;\n                    }\n                });\n                // remove ranges that don't contain the former range or that are equal to the\n                // former range\n                let oneRanges = [];\n                let last;\n                for (const range of oneRawRanges) {\n                    if (!last || (range_1.Range.containsRange(range, last) && !range_1.Range.equalsRange(range, last))) {\n                        oneRanges.push(range);\n                        last = range;\n                    }\n                }\n                // add ranges that expand trivia at line starts and ends whenever a range\n                // wraps onto the a new line\n                let oneRangesWithTrivia = [oneRanges[0]];\n                for (let i = 1; i < oneRanges.length; i++) {\n                    const prev = oneRanges[i - 1];\n                    const cur = oneRanges[i];\n                    if (cur.startLineNumber !== prev.startLineNumber || cur.endLineNumber !== prev.endLineNumber) {\n                        // add line/block range without leading/failing whitespace\n                        const rangeNoWhitespace = new range_1.Range(prev.startLineNumber, model.getLineFirstNonWhitespaceColumn(prev.startLineNumber), prev.endLineNumber, model.getLineLastNonWhitespaceColumn(prev.endLineNumber));\n                        if (rangeNoWhitespace.containsRange(prev) && !rangeNoWhitespace.equalsRange(prev)) {\n                            oneRangesWithTrivia.push(rangeNoWhitespace);\n                        }\n                        // add line/block range\n                        const rangeFull = new range_1.Range(prev.startLineNumber, 1, prev.endLineNumber, model.getLineMaxColumn(prev.endLineNumber));\n                        if (rangeFull.containsRange(prev) && !rangeFull.equalsRange(rangeNoWhitespace)) {\n                            oneRangesWithTrivia.push(rangeFull);\n                        }\n                    }\n                    oneRangesWithTrivia.push(cur);\n                }\n                return oneRangesWithTrivia;\n            });\n        });\n    }\n    exports.provideSelectionRanges = provideSelectionRanges;\n    editorExtensions_1.registerDefaultLanguageCommand('_executeSelectionRangeProvider', function (model, _position, args) {\n        return provideSelectionRanges(model, args.positions, cancellation_1.CancellationToken.None);\n    });\n});\n",null]}