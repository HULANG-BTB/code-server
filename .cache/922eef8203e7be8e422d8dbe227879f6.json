{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/mime.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/mime.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/path\", \"vs/base/common/strings\", \"vs/base/common/arrays\", \"vs/base/common/glob\"], function (require, exports, path_1, strings_1, arrays_1, glob_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.MIME_TEXT = 'text/plain';\n    exports.MIME_BINARY = 'application/octet-stream';\n    exports.MIME_UNKNOWN = 'application/unknown';\n    let registeredAssociations = [];\n    let nonUserRegisteredAssociations = [];\n    let userRegisteredAssociations = [];\n    /**\n     * Associate a text mime to the registry.\n     */\n    function registerTextMime(association, warnOnOverwrite = false) {\n        // Register\n        const associationItem = toTextMimeAssociationItem(association);\n        registeredAssociations.push(associationItem);\n        if (!associationItem.userConfigured) {\n            nonUserRegisteredAssociations.push(associationItem);\n        }\n        else {\n            userRegisteredAssociations.push(associationItem);\n        }\n        // Check for conflicts unless this is a user configured association\n        if (warnOnOverwrite && !associationItem.userConfigured) {\n            registeredAssociations.forEach(a => {\n                if (a.mime === associationItem.mime || a.userConfigured) {\n                    return; // same mime or userConfigured is ok\n                }\n                if (associationItem.extension && a.extension === associationItem.extension) {\n                    console.warn(`Overwriting extension <<${associationItem.extension}>> to now point to mime <<${associationItem.mime}>>`);\n                }\n                if (associationItem.filename && a.filename === associationItem.filename) {\n                    console.warn(`Overwriting filename <<${associationItem.filename}>> to now point to mime <<${associationItem.mime}>>`);\n                }\n                if (associationItem.filepattern && a.filepattern === associationItem.filepattern) {\n                    console.warn(`Overwriting filepattern <<${associationItem.filepattern}>> to now point to mime <<${associationItem.mime}>>`);\n                }\n                if (associationItem.firstline && a.firstline === associationItem.firstline) {\n                    console.warn(`Overwriting firstline <<${associationItem.firstline}>> to now point to mime <<${associationItem.mime}>>`);\n                }\n            });\n        }\n    }\n    exports.registerTextMime = registerTextMime;\n    function toTextMimeAssociationItem(association) {\n        return {\n            id: association.id,\n            mime: association.mime,\n            filename: association.filename,\n            extension: association.extension,\n            filepattern: association.filepattern,\n            firstline: association.firstline,\n            userConfigured: association.userConfigured,\n            filenameLowercase: association.filename ? association.filename.toLowerCase() : undefined,\n            extensionLowercase: association.extension ? association.extension.toLowerCase() : undefined,\n            filepatternLowercase: association.filepattern ? association.filepattern.toLowerCase() : undefined,\n            filepatternOnPath: association.filepattern ? association.filepattern.indexOf(path_1.posix.sep) >= 0 : false\n        };\n    }\n    /**\n     * Clear text mimes from the registry.\n     */\n    function clearTextMimes(onlyUserConfigured) {\n        if (!onlyUserConfigured) {\n            registeredAssociations = [];\n            nonUserRegisteredAssociations = [];\n            userRegisteredAssociations = [];\n        }\n        else {\n            registeredAssociations = registeredAssociations.filter(a => !a.userConfigured);\n            userRegisteredAssociations = [];\n        }\n    }\n    exports.clearTextMimes = clearTextMimes;\n    /**\n     * Given a file, return the best matching mime type for it\n     */\n    function guessMimeTypes(path, firstLine) {\n        if (!path) {\n            return [exports.MIME_UNKNOWN];\n        }\n        path = path.toLowerCase();\n        const filename = path_1.basename(path);\n        // 1.) User configured mappings have highest priority\n        const configuredMime = guessMimeTypeByPath(path, filename, userRegisteredAssociations);\n        if (configuredMime) {\n            return [configuredMime, exports.MIME_TEXT];\n        }\n        // 2.) Registered mappings have middle priority\n        const registeredMime = guessMimeTypeByPath(path, filename, nonUserRegisteredAssociations);\n        if (registeredMime) {\n            return [registeredMime, exports.MIME_TEXT];\n        }\n        // 3.) Firstline has lowest priority\n        if (firstLine) {\n            const firstlineMime = guessMimeTypeByFirstline(firstLine);\n            if (firstlineMime) {\n                return [firstlineMime, exports.MIME_TEXT];\n            }\n        }\n        return [exports.MIME_UNKNOWN];\n    }\n    exports.guessMimeTypes = guessMimeTypes;\n    function guessMimeTypeByPath(path, filename, associations) {\n        let filenameMatch = null;\n        let patternMatch = null;\n        let extensionMatch = null;\n        // We want to prioritize associations based on the order they are registered so that the last registered\n        // association wins over all other. This is for https://github.com/Microsoft/vscode/issues/20074\n        for (let i = associations.length - 1; i >= 0; i--) {\n            const association = associations[i];\n            // First exact name match\n            if (filename === association.filenameLowercase) {\n                filenameMatch = association;\n                break; // take it!\n            }\n            // Longest pattern match\n            if (association.filepattern) {\n                if (!patternMatch || association.filepattern.length > patternMatch.filepattern.length) {\n                    const target = association.filepatternOnPath ? path : filename; // match on full path if pattern contains path separator\n                    if (glob_1.match(association.filepatternLowercase, target)) {\n                        patternMatch = association;\n                    }\n                }\n            }\n            // Longest extension match\n            if (association.extension) {\n                if (!extensionMatch || association.extension.length > extensionMatch.extension.length) {\n                    if (strings_1.endsWith(filename, association.extensionLowercase)) {\n                        extensionMatch = association;\n                    }\n                }\n            }\n        }\n        // 1.) Exact name match has second highest prio\n        if (filenameMatch) {\n            return filenameMatch.mime;\n        }\n        // 2.) Match on pattern\n        if (patternMatch) {\n            return patternMatch.mime;\n        }\n        // 3.) Match on extension comes next\n        if (extensionMatch) {\n            return extensionMatch.mime;\n        }\n        return null;\n    }\n    function guessMimeTypeByFirstline(firstLine) {\n        if (strings_1.startsWithUTF8BOM(firstLine)) {\n            firstLine = firstLine.substr(1);\n        }\n        if (firstLine.length > 0) {\n            for (const association of registeredAssociations) {\n                if (!association.firstline) {\n                    continue;\n                }\n                const matches = firstLine.match(association.firstline);\n                if (matches && matches.length > 0) {\n                    return association.mime;\n                }\n            }\n        }\n        return null;\n    }\n    function isUnspecific(mime) {\n        if (!mime) {\n            return true;\n        }\n        if (typeof mime === 'string') {\n            return mime === exports.MIME_BINARY || mime === exports.MIME_TEXT || mime === exports.MIME_UNKNOWN;\n        }\n        return mime.length === 1 && isUnspecific(mime[0]);\n    }\n    exports.isUnspecific = isUnspecific;\n    /**\n     * Returns a suggestion for the filename by the following logic:\n     * 1. If a relevant extension exists and is an actual filename extension (starting with a dot), suggest the prefix appended by the first one.\n     * 2. Otherwise, if there are other extensions, suggest the first one.\n     * 3. Otherwise, suggest the prefix.\n     */\n    function suggestFilename(langId, prefix) {\n        const extensions = registeredAssociations\n            .filter(assoc => !assoc.userConfigured && assoc.extension && assoc.id === langId)\n            .map(assoc => assoc.extension);\n        const extensionsWithDotFirst = arrays_1.coalesce(extensions)\n            .filter(assoc => strings_1.startsWith(assoc, '.'));\n        if (extensionsWithDotFirst.length > 0) {\n            return prefix + extensionsWithDotFirst[0];\n        }\n        return extensions[0] || prefix;\n    }\n    exports.suggestFilename = suggestFilename;\n    // Known media mimes that we can handle\n    const mapExtToMediaMimes = {\n        '.bmp': 'image/bmp',\n        '.gif': 'image/gif',\n        '.jpg': 'image/jpg',\n        '.jpeg': 'image/jpg',\n        '.jpe': 'image/jpg',\n        '.png': 'image/png',\n        '.tiff': 'image/tiff',\n        '.tif': 'image/tiff',\n        '.ico': 'image/x-icon',\n        '.tga': 'image/x-tga',\n        '.psd': 'image/vnd.adobe.photoshop',\n        '.webp': 'image/webp',\n        '.mid': 'audio/midi',\n        '.midi': 'audio/midi',\n        '.mp4a': 'audio/mp4',\n        '.mpga': 'audio/mpeg',\n        '.mp2': 'audio/mpeg',\n        '.mp2a': 'audio/mpeg',\n        '.mp3': 'audio/mpeg',\n        '.m2a': 'audio/mpeg',\n        '.m3a': 'audio/mpeg',\n        '.oga': 'audio/ogg',\n        '.ogg': 'audio/ogg',\n        '.spx': 'audio/ogg',\n        '.aac': 'audio/x-aac',\n        '.wav': 'audio/x-wav',\n        '.wma': 'audio/x-ms-wma',\n        '.mp4': 'video/mp4',\n        '.mp4v': 'video/mp4',\n        '.mpg4': 'video/mp4',\n        '.mpeg': 'video/mpeg',\n        '.mpg': 'video/mpeg',\n        '.mpe': 'video/mpeg',\n        '.m1v': 'video/mpeg',\n        '.m2v': 'video/mpeg',\n        '.ogv': 'video/ogg',\n        '.qt': 'video/quicktime',\n        '.mov': 'video/quicktime',\n        '.webm': 'video/webm',\n        '.mkv': 'video/x-matroska',\n        '.mk3d': 'video/x-matroska',\n        '.mks': 'video/x-matroska',\n        '.wmv': 'video/x-ms-wmv',\n        '.flv': 'video/x-flv',\n        '.avi': 'video/x-msvideo',\n        '.movie': 'video/x-sgi-movie'\n    };\n    function getMediaMime(path) {\n        const ext = path_1.extname(path);\n        return mapExtToMediaMimes[ext.toLowerCase()];\n    }\n    exports.getMediaMime = getMediaMime;\n});\n",null]}