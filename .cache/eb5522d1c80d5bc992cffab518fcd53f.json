{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostTerminalService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostTerminalService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/platform/product/node/package\", \"os\", \"vs/base/common/uri\", \"vs/base/common/platform\", \"vs/workbench/contrib/terminal/common/terminalEnvironment\", \"vs/base/common/event\", \"vs/workbench/api/common/extHost.protocol\", \"vs/workbench/contrib/terminal/common/terminal\", \"vs/workbench/contrib/terminal/node/terminalProcess\", \"vs/base/common/async\", \"vs/base/common/processes\"], function (require, exports, package_1, os, uri_1, platform, terminalEnvironment, event_1, extHost_protocol_1, terminal_1, terminalProcess_1, async_1, processes_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const RENDERER_NO_PROCESS_ID = -1;\n    class BaseExtHostTerminal {\n        constructor(_proxy, id) {\n            this._proxy = _proxy;\n            this._disposed = false;\n            this._queuedRequests = [];\n            this._idPromise = new Promise(c => {\n                if (id !== undefined) {\n                    this._id = id;\n                    c(id);\n                }\n                else {\n                    this._idPromiseComplete = c;\n                }\n            });\n        }\n        dispose() {\n            if (!this._disposed) {\n                this._disposed = true;\n                this._queueApiRequest(this._proxy.$dispose, []);\n            }\n        }\n        _checkDisposed() {\n            if (this._disposed) {\n                throw new Error('Terminal has already been disposed');\n            }\n        }\n        _queueApiRequest(callback, args) {\n            const request = new ApiRequest(callback, args);\n            if (!this._id) {\n                this._queuedRequests.push(request);\n                return;\n            }\n            request.run(this._proxy, this._id);\n        }\n        _runQueuedRequests(id) {\n            this._id = id;\n            this._idPromiseComplete(id);\n            this._queuedRequests.forEach((r) => {\n                r.run(this._proxy, this._id);\n            });\n            this._queuedRequests.length = 0;\n        }\n    }\n    exports.BaseExtHostTerminal = BaseExtHostTerminal;\n    class ExtHostTerminal extends BaseExtHostTerminal {\n        constructor(proxy, _name, id, pid) {\n            super(proxy, id);\n            this._name = _name;\n            this._onData = new event_1.Emitter();\n            this._pidPromise = new Promise(c => {\n                if (pid === RENDERER_NO_PROCESS_ID) {\n                    c(undefined);\n                }\n                else {\n                    this._pidPromiseComplete = c;\n                }\n            });\n        }\n        get onDidWriteData() {\n            // Tell the main side to start sending data if it's not already\n            this._idPromise.then(c => {\n                this._proxy.$registerOnDataListener(this._id);\n            });\n            return this._onData && this._onData.event;\n        }\n        create(shellPath, shellArgs, cwd, env, waitOnExit, strictEnv) {\n            this._proxy.$createTerminal(this._name, shellPath, shellArgs, cwd, env, waitOnExit, strictEnv).then(terminal => {\n                this._name = terminal.name;\n                this._runQueuedRequests(terminal.id);\n            });\n        }\n        get name() {\n            return this._name || '';\n        }\n        set name(name) {\n            this._name = name;\n        }\n        get dimensions() {\n            if (this._cols === undefined || this._rows === undefined) {\n                return undefined;\n            }\n            return {\n                columns: this._cols,\n                rows: this._rows\n            };\n        }\n        setDimensions(cols, rows) {\n            if (cols === this._cols && rows === this._rows) {\n                // Nothing changed\n                return false;\n            }\n            this._cols = cols;\n            this._rows = rows;\n            return true;\n        }\n        get processId() {\n            return this._pidPromise;\n        }\n        sendText(text, addNewLine = true) {\n            this._checkDisposed();\n            this._queueApiRequest(this._proxy.$sendText, [text, addNewLine]);\n        }\n        show(preserveFocus) {\n            this._checkDisposed();\n            this._queueApiRequest(this._proxy.$show, [preserveFocus]);\n        }\n        hide() {\n            this._checkDisposed();\n            this._queueApiRequest(this._proxy.$hide, []);\n        }\n        _setProcessId(processId) {\n            // The event may fire 2 times when the panel is restored\n            if (this._pidPromiseComplete) {\n                this._pidPromiseComplete(processId);\n                this._pidPromiseComplete = null;\n            }\n            else {\n                // Recreate the promise if this is the nth processId set (eg. reused task terminals)\n                this._pidPromise.then(pid => {\n                    if (pid !== processId) {\n                        this._pidPromise = Promise.resolve(processId);\n                    }\n                });\n            }\n        }\n        _fireOnData(data) {\n            this._onData.fire(data);\n        }\n    }\n    exports.ExtHostTerminal = ExtHostTerminal;\n    class ExtHostTerminalRenderer extends BaseExtHostTerminal {\n        constructor(proxy, _name, _terminal, id) {\n            super(proxy, id);\n            this._name = _name;\n            this._terminal = _terminal;\n            this._onInput = new event_1.Emitter();\n            this._onDidChangeMaximumDimensions = new event_1.Emitter();\n            if (!id) {\n                this._proxy.$createTerminalRenderer(this._name).then(id => {\n                    this._runQueuedRequests(id);\n                    this._terminal._runQueuedRequests(id);\n                });\n            }\n        }\n        get name() { return this._name; }\n        set name(newName) {\n            this._name = newName;\n            this._checkDisposed();\n            this._queueApiRequest(this._proxy.$terminalRendererSetName, [this._name]);\n        }\n        get onDidAcceptInput() {\n            this._checkDisposed();\n            this._queueApiRequest(this._proxy.$terminalRendererRegisterOnInputListener, [this._id]);\n            // Tell the main side to start sending data if it's not already\n            // this._proxy.$terminalRendererRegisterOnDataListener(this._id);\n            return this._onInput && this._onInput.event;\n        }\n        get dimensions() { return this._dimensions; }\n        set dimensions(dimensions) {\n            this._checkDisposed();\n            this._dimensions = dimensions;\n            this._queueApiRequest(this._proxy.$terminalRendererSetDimensions, [dimensions]);\n        }\n        get maximumDimensions() {\n            if (!this._maximumDimensions) {\n                return undefined;\n            }\n            return {\n                rows: this._maximumDimensions.rows,\n                columns: this._maximumDimensions.columns\n            };\n        }\n        get onDidChangeMaximumDimensions() {\n            return this._onDidChangeMaximumDimensions && this._onDidChangeMaximumDimensions.event;\n        }\n        get terminal() {\n            return this._terminal;\n        }\n        write(data) {\n            this._checkDisposed();\n            this._queueApiRequest(this._proxy.$terminalRendererWrite, [data]);\n        }\n        _fireOnInput(data) {\n            this._onInput.fire(data);\n        }\n        _setMaximumDimensions(columns, rows) {\n            if (this._maximumDimensions && this._maximumDimensions.columns === columns && this._maximumDimensions.rows === rows) {\n                return;\n            }\n            const newValue = { columns, rows };\n            this._maximumDimensions = newValue;\n            this._onDidChangeMaximumDimensions.fire(newValue);\n        }\n    }\n    exports.ExtHostTerminalRenderer = ExtHostTerminalRenderer;\n    class ExtHostTerminalService {\n        constructor(mainContext, _extHostConfiguration, _logService) {\n            this._extHostConfiguration = _extHostConfiguration;\n            this._logService = _logService;\n            this._terminals = [];\n            this._terminalProcesses = {};\n            this._terminalRenderers = [];\n            this._getTerminalPromises = {};\n            this._onDidCloseTerminal = new event_1.Emitter();\n            this._onDidOpenTerminal = new event_1.Emitter();\n            this._onDidChangeActiveTerminal = new event_1.Emitter();\n            this._onDidChangeTerminalDimensions = new event_1.Emitter();\n            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadTerminalService);\n        }\n        get activeTerminal() { return this._activeTerminal; }\n        get terminals() { return this._terminals; }\n        get onDidCloseTerminal() { return this._onDidCloseTerminal && this._onDidCloseTerminal.event; }\n        get onDidOpenTerminal() { return this._onDidOpenTerminal && this._onDidOpenTerminal.event; }\n        get onDidChangeActiveTerminal() { return this._onDidChangeActiveTerminal && this._onDidChangeActiveTerminal.event; }\n        get onDidChangeTerminalDimensions() { return this._onDidChangeTerminalDimensions && this._onDidChangeTerminalDimensions.event; }\n        createTerminal(name, shellPath, shellArgs) {\n            const terminal = new ExtHostTerminal(this._proxy, name);\n            terminal.create(shellPath, shellArgs);\n            this._terminals.push(terminal);\n            return terminal;\n        }\n        createTerminalFromOptions(options) {\n            const terminal = new ExtHostTerminal(this._proxy, options.name);\n            terminal.create(options.shellPath, options.shellArgs, options.cwd, options.env, /*options.waitOnExit*/ undefined, options.strictEnv);\n            this._terminals.push(terminal);\n            return terminal;\n        }\n        createTerminalRenderer(name) {\n            const terminal = new ExtHostTerminal(this._proxy, name);\n            terminal._setProcessId(undefined);\n            this._terminals.push(terminal);\n            const renderer = new ExtHostTerminalRenderer(this._proxy, name, terminal);\n            this._terminalRenderers.push(renderer);\n            return renderer;\n        }\n        resolveTerminalRenderer(id) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // Check to see if the extension host already knows about this terminal.\n                for (const terminalRenderer of this._terminalRenderers) {\n                    if (terminalRenderer._id === id) {\n                        return terminalRenderer;\n                    }\n                }\n                const terminal = this._getTerminalById(id);\n                if (!terminal) {\n                    throw new Error(`Cannot resolve terminal renderer for terminal id ${id}`);\n                }\n                const renderer = new ExtHostTerminalRenderer(this._proxy, terminal.name, terminal, terminal._id);\n                this._terminalRenderers.push(renderer);\n                return renderer;\n            });\n        }\n        $acceptActiveTerminalChanged(id) {\n            const original = this._activeTerminal;\n            if (id === null) {\n                this._activeTerminal = undefined;\n                if (original !== this._activeTerminal) {\n                    this._onDidChangeActiveTerminal.fire(this._activeTerminal);\n                }\n                return;\n            }\n            this._performTerminalIdAction(id, terminal => {\n                if (terminal) {\n                    this._activeTerminal = terminal;\n                    if (original !== this._activeTerminal) {\n                        this._onDidChangeActiveTerminal.fire(this._activeTerminal);\n                    }\n                }\n            });\n        }\n        $acceptTerminalProcessData(id, data) {\n            this._getTerminalByIdEventually(id).then(terminal => {\n                if (terminal) {\n                    terminal._fireOnData(data);\n                }\n            });\n        }\n        $acceptTerminalDimensions(id, cols, rows) {\n            this._getTerminalByIdEventually(id).then(terminal => {\n                if (terminal) {\n                    if (terminal.setDimensions(cols, rows)) {\n                        this._onDidChangeTerminalDimensions.fire({\n                            terminal: terminal,\n                            dimensions: terminal.dimensions\n                        });\n                    }\n                }\n                // When a terminal's dimensions change, a renderer's _maximum_ dimensions change\n                const renderer = this._getTerminalRendererById(id);\n                if (renderer) {\n                    renderer._setMaximumDimensions(cols, rows);\n                }\n            });\n        }\n        $acceptTerminalRendererInput(id, data) {\n            const renderer = this._getTerminalRendererById(id);\n            if (renderer) {\n                renderer._fireOnInput(data);\n            }\n        }\n        $acceptTerminalTitleChange(id, name) {\n            const extHostTerminal = this._getTerminalObjectById(this.terminals, id);\n            if (extHostTerminal) {\n                extHostTerminal.name = name;\n            }\n        }\n        $acceptTerminalClosed(id) {\n            const index = this._getTerminalObjectIndexById(this.terminals, id);\n            if (index !== null) {\n                const terminal = this._terminals.splice(index, 1)[0];\n                this._onDidCloseTerminal.fire(terminal);\n            }\n        }\n        $acceptTerminalOpened(id, name) {\n            const index = this._getTerminalObjectIndexById(this._terminals, id);\n            if (index !== null) {\n                // The terminal has already been created (via createTerminal*), only fire the event\n                this._onDidOpenTerminal.fire(this.terminals[index]);\n                return;\n            }\n            const renderer = this._getTerminalRendererById(id);\n            const terminal = new ExtHostTerminal(this._proxy, name, id, renderer ? RENDERER_NO_PROCESS_ID : undefined);\n            this._terminals.push(terminal);\n            this._onDidOpenTerminal.fire(terminal);\n        }\n        $acceptTerminalProcessId(id, processId) {\n            this._performTerminalIdAction(id, terminal => terminal._setProcessId(processId));\n        }\n        _performTerminalIdAction(id, callback) {\n            let terminal = this._getTerminalById(id);\n            if (terminal) {\n                callback(terminal);\n            }\n            else {\n                // Retry one more time in case the terminal has not yet been initialized.\n                setTimeout(() => {\n                    terminal = this._getTerminalById(id);\n                    if (terminal) {\n                        callback(terminal);\n                    }\n                }, terminal_1.EXT_HOST_CREATION_DELAY);\n            }\n        }\n        $createProcess(id, shellLaunchConfigDto, activeWorkspaceRootUriComponents, cols, rows) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const shellLaunchConfig = {\n                    name: shellLaunchConfigDto.name,\n                    executable: shellLaunchConfigDto.executable,\n                    args: shellLaunchConfigDto.args,\n                    cwd: typeof shellLaunchConfigDto.cwd === 'string' ? shellLaunchConfigDto.cwd : uri_1.URI.revive(shellLaunchConfigDto.cwd),\n                    env: shellLaunchConfigDto.env\n                };\n                // TODO: This function duplicates a lot of TerminalProcessManager.createProcess, ideally\n                // they would be merged into a single implementation.\n                const configProvider = yield this._extHostConfiguration.getConfigProvider();\n                const terminalConfig = configProvider.getConfiguration('terminal.integrated');\n                if (!shellLaunchConfig.executable) {\n                    // TODO: This duplicates some of TerminalConfigHelper.mergeDefaultShellPathAndArgs and should be merged\n                    // this._configHelper.mergeDefaultShellPathAndArgs(shellLaunchConfig);\n                    const platformKey = platform.isWindows ? 'windows' : platform.isMacintosh ? 'osx' : 'linux';\n                    const shellConfigValue = terminalConfig.get(`shell.${platformKey}`);\n                    const shellArgsConfigValue = terminalConfig.get(`shellArgs.${platformKey}`);\n                    shellLaunchConfig.executable = shellConfigValue;\n                    shellLaunchConfig.args = shellArgsConfigValue;\n                }\n                // TODO: @daniel\n                const activeWorkspaceRootUri = uri_1.URI.revive(activeWorkspaceRootUriComponents);\n                const initialCwd = terminalEnvironment.getCwd(shellLaunchConfig, os.homedir(), activeWorkspaceRootUri, terminalConfig.cwd);\n                // TODO: Pull in and resolve config settings\n                // // Resolve env vars from config and shell\n                // const lastActiveWorkspaceRoot = this._workspaceContextService.getWorkspaceFolder(lastActiveWorkspaceRootUri);\n                const platformKey = platform.isWindows ? 'windows' : (platform.isMacintosh ? 'osx' : 'linux');\n                // const envFromConfig = terminalEnvironment.resolveConfigurationVariables(this._configurationResolverService, { ...terminalConfig.env[platformKey] }, lastActiveWorkspaceRoot);\n                const envFromConfig = Object.assign({}, terminalConfig.env[platformKey]);\n                // const envFromShell = terminalEnvironment.resolveConfigurationVariables(this._configurationResolverService, { ...shellLaunchConfig.env }, lastActiveWorkspaceRoot);\n                // Merge process env with the env from config\n                const env = Object.assign({}, process.env);\n                Object.keys(env).filter(k => env[k] === undefined).forEach(k => {\n                    delete env[k];\n                });\n                const castedEnv = env;\n                terminalEnvironment.mergeEnvironments(castedEnv, envFromConfig);\n                terminalEnvironment.mergeEnvironments(castedEnv, shellLaunchConfig.env);\n                // Sanitize the environment, removing any undesirable VS Code and Electron environment\n                // variables\n                processes_1.sanitizeProcessEnvironment(castedEnv, 'VSCODE_IPC_HOOK_CLI');\n                // Continue env initialization, merging in the env from the launch\n                // config and adding keys that are needed to create the process\n                terminalEnvironment.addTerminalEnvironmentKeys(castedEnv, package_1.default.version, platform.locale, terminalConfig.get('setLocaleVariables'));\n                // Fork the process and listen for messages\n                this._logService.debug(`Terminal process launching on ext host`, shellLaunchConfig, initialCwd, cols, rows, castedEnv);\n                const p = new terminalProcess_1.TerminalProcess(shellLaunchConfig, initialCwd, cols, rows, castedEnv, terminalConfig.get('windowsEnableConpty'));\n                p.onProcessIdReady(pid => this._proxy.$sendProcessPid(id, pid));\n                p.onProcessTitleChanged(title => this._proxy.$sendProcessTitle(id, title));\n                p.onProcessData(data => this._proxy.$sendProcessData(id, data));\n                p.onProcessExit((exitCode) => this._onProcessExit(id, exitCode));\n                this._terminalProcesses[id] = p;\n            });\n        }\n        $acceptProcessInput(id, data) {\n            this._terminalProcesses[id].input(data);\n        }\n        $acceptProcessResize(id, cols, rows) {\n            try {\n                this._terminalProcesses[id].resize(cols, rows);\n            }\n            catch (error) {\n                // We tried to write to a closed pipe / channel.\n                if (error.code !== 'EPIPE' && error.code !== 'ERR_IPC_CHANNEL_CLOSED') {\n                    throw (error);\n                }\n            }\n        }\n        $acceptProcessShutdown(id, immediate) {\n            this._terminalProcesses[id].shutdown(immediate);\n        }\n        $acceptProcessRequestInitialCwd(id) {\n            this._terminalProcesses[id].getInitialCwd().then(initialCwd => this._proxy.$sendProcessInitialCwd(id, initialCwd));\n        }\n        $acceptProcessRequestCwd(id) {\n            this._terminalProcesses[id].getCwd().then(cwd => this._proxy.$sendProcessCwd(id, cwd));\n        }\n        $acceptProcessRequestLatency(id) {\n            return id;\n        }\n        _onProcessExit(id, exitCode) {\n            // Remove listeners\n            this._terminalProcesses[id].dispose();\n            // Remove process reference\n            delete this._terminalProcesses[id];\n            // Send exit event to main side\n            this._proxy.$sendProcessExit(id, exitCode);\n        }\n        _getTerminalByIdEventually(id, retries = 5) {\n            if (!this._getTerminalPromises[id]) {\n                this._getTerminalPromises[id] = this._createGetTerminalPromise(id, retries);\n            }\n            else {\n                this._getTerminalPromises[id].then(c => {\n                    return this._createGetTerminalPromise(id, retries);\n                });\n            }\n            return this._getTerminalPromises[id];\n        }\n        _createGetTerminalPromise(id, retries = 5) {\n            return new Promise(c => {\n                if (retries === 0) {\n                    c(undefined);\n                    return;\n                }\n                const terminal = this._getTerminalById(id);\n                if (terminal) {\n                    c(terminal);\n                }\n                else {\n                    // This should only be needed immediately after createTerminalRenderer is called as\n                    // the ExtHostTerminal has not yet been iniitalized\n                    async_1.timeout(200).then(() => c(this._createGetTerminalPromise(id, retries - 1)));\n                }\n            });\n        }\n        _getTerminalById(id) {\n            return this._getTerminalObjectById(this._terminals, id);\n        }\n        _getTerminalRendererById(id) {\n            return this._getTerminalObjectById(this._terminalRenderers, id);\n        }\n        _getTerminalObjectById(array, id) {\n            const index = this._getTerminalObjectIndexById(array, id);\n            return index !== null ? array[index] : null;\n        }\n        _getTerminalObjectIndexById(array, id) {\n            let index = null;\n            array.some((item, i) => {\n                const thisId = item._id;\n                if (thisId === id) {\n                    index = i;\n                    return true;\n                }\n                return false;\n            });\n            return index;\n        }\n    }\n    exports.ExtHostTerminalService = ExtHostTerminalService;\n    class ApiRequest {\n        constructor(callback, args) {\n            this._callback = callback;\n            this._args = args;\n        }\n        run(proxy, id) {\n            this._callback.apply(proxy, [id].concat(this._args));\n        }\n    }\n});\n",null]}