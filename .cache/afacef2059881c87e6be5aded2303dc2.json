{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/contextmenu/electron-browser/contextmenuService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/contextmenu/electron-browser/contextmenuService.ts","mtime":1555846338048},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/actions\", \"vs/base/browser/ui/actionbar/actionbar\", \"vs/base/browser/dom\", \"vs/platform/contextview/browser/contextView\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/keybinding/common/keybinding\", \"electron\", \"vs/base/common/labels\", \"vs/base/common/event\", \"vs/platform/notification/common/notification\", \"vs/base/browser/contextmenu\", \"vs/base/common/functional\", \"vs/base/common/lifecycle\", \"vs/base/parts/contextmenu/electron-browser/contextmenu\", \"vs/platform/windows/common/windows\", \"vs/base/common/platform\", \"vs/platform/configuration/common/configuration\", \"vs/platform/environment/common/environment\", \"vs/platform/contextview/browser/contextMenuService\", \"vs/platform/theme/common/themeService\", \"vs/platform/instantiation/common/extensions\"], function (require, exports, actions_1, actionbar_1, dom, contextView_1, telemetry_1, keybinding_1, electron_1, labels_1, event_1, notification_1, contextmenu_1, functional_1, lifecycle_1, contextmenu_2, windows_1, platform_1, configuration_1, environment_1, contextMenuService_1, themeService_1, extensions_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let ContextMenuService = class ContextMenuService extends lifecycle_1.Disposable {\n        constructor(notificationService, telemetryService, keybindingService, configurationService, environmentService, contextViewService, themeService) {\n            super();\n            // Custom context menu: Linux/Windows if custom title is enabled\n            if (!(platform_1.isNative && platform_1.isMacintosh) && windows_1.getTitleBarStyle(configurationService, environmentService) === 'custom') {\n                this.impl = new contextMenuService_1.ContextMenuService(telemetryService, notificationService, contextViewService, keybindingService, themeService);\n            }\n            // Native context menu: otherwise\n            else {\n                this.impl = new NativeContextMenuService(notificationService, telemetryService, keybindingService);\n            }\n        }\n        get onDidContextMenu() { return this.impl.onDidContextMenu; }\n        showContextMenu(delegate) {\n            this.impl.showContextMenu(delegate);\n        }\n    };\n    ContextMenuService = __decorate([\n        __param(0, notification_1.INotificationService),\n        __param(1, telemetry_1.ITelemetryService),\n        __param(2, keybinding_1.IKeybindingService),\n        __param(3, configuration_1.IConfigurationService),\n        __param(4, environment_1.IEnvironmentService),\n        __param(5, contextView_1.IContextViewService),\n        __param(6, themeService_1.IThemeService)\n    ], ContextMenuService);\n    exports.ContextMenuService = ContextMenuService;\n    let NativeContextMenuService = class NativeContextMenuService extends lifecycle_1.Disposable {\n        constructor(notificationService, telemetryService, keybindingService) {\n            super();\n            this.notificationService = notificationService;\n            this.telemetryService = telemetryService;\n            this.keybindingService = keybindingService;\n            this._onDidContextMenu = this._register(new event_1.Emitter());\n        }\n        get onDidContextMenu() { return this._onDidContextMenu.event; }\n        showContextMenu(delegate) {\n            const actions = delegate.getActions();\n            if (actions.length) {\n                const onHide = functional_1.once(() => {\n                    if (delegate.onHide) {\n                        delegate.onHide(false);\n                    }\n                    this._onDidContextMenu.fire();\n                });\n                const menu = this.createMenu(delegate, actions, onHide);\n                const anchor = delegate.getAnchor();\n                let x, y;\n                if (dom.isHTMLElement(anchor)) {\n                    let elementPosition = dom.getDomNodePagePosition(anchor);\n                    x = elementPosition.left;\n                    y = elementPosition.top + elementPosition.height;\n                }\n                else {\n                    const pos = anchor;\n                    x = pos.x + 1; /* prevent first item from being selected automatically under mouse */\n                    y = pos.y;\n                }\n                let zoom = electron_1.webFrame.getZoomFactor();\n                x *= zoom;\n                y *= zoom;\n                contextmenu_2.popup(menu, {\n                    x: Math.floor(x),\n                    y: Math.floor(y),\n                    positioningItem: delegate.autoSelectFirstItem ? 0 : undefined,\n                    onHide: () => onHide()\n                });\n            }\n        }\n        createMenu(delegate, entries, onHide) {\n            const actionRunner = delegate.actionRunner || new actions_1.ActionRunner();\n            return entries.map(entry => this.createMenuItem(delegate, entry, actionRunner, onHide));\n        }\n        createMenuItem(delegate, entry, actionRunner, onHide) {\n            // Separator\n            if (entry instanceof actionbar_1.Separator) {\n                return { type: 'separator' };\n            }\n            // Submenu\n            if (entry instanceof contextmenu_1.ContextSubMenu) {\n                return {\n                    label: labels_1.unmnemonicLabel(entry.label),\n                    submenu: this.createMenu(delegate, entry.entries, onHide)\n                };\n            }\n            // Normal Menu Item\n            else {\n                const item = {\n                    label: labels_1.unmnemonicLabel(entry.label),\n                    checked: !!entry.checked || !!entry.radio,\n                    type: !!entry.checked ? 'checkbox' : !!entry.radio ? 'radio' : undefined,\n                    enabled: !!entry.enabled,\n                    click: event => {\n                        // To preserve pre-electron-2.x behaviour, we first trigger\n                        // the onHide callback and then the action.\n                        // Fixes https://github.com/Microsoft/vscode/issues/45601\n                        onHide();\n                        // Run action which will close the menu\n                        this.runAction(actionRunner, entry, delegate, event);\n                    }\n                };\n                const keybinding = !!delegate.getKeyBinding ? delegate.getKeyBinding(entry) : this.keybindingService.lookupKeybinding(entry.id);\n                if (keybinding) {\n                    const electronAccelerator = keybinding.getElectronAccelerator();\n                    if (electronAccelerator) {\n                        item.accelerator = electronAccelerator;\n                    }\n                    else {\n                        const label = keybinding.getLabel();\n                        if (label) {\n                            item.label = `${item.label} [${label}]`;\n                        }\n                    }\n                }\n                return item;\n            }\n        }\n        runAction(actionRunner, actionToRun, delegate, event) {\n            /* __GDPR__\n                \"workbenchActionExecuted\" : {\n                    \"id\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                    \"from\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                }\n            */\n            this.telemetryService.publicLog('workbenchActionExecuted', { id: actionToRun.id, from: 'contextMenu' });\n            const context = delegate.getActionsContext ? delegate.getActionsContext(event) : event;\n            const res = actionRunner.run(actionToRun, context) || Promise.resolve(null);\n            res.then(undefined, e => this.notificationService.error(e));\n        }\n    };\n    NativeContextMenuService = __decorate([\n        __param(0, notification_1.INotificationService),\n        __param(1, telemetry_1.ITelemetryService),\n        __param(2, keybinding_1.IKeybindingService)\n    ], NativeContextMenuService);\n    extensions_1.registerSingleton(contextView_1.IContextMenuService, ContextMenuService, true);\n});\n",null]}