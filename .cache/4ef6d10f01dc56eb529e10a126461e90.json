{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/node/ripgrepSearchUtils.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/node/ripgrepSearchUtils.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/strings\", \"vs/platform/log/common/log\", \"vs/workbench/services/search/common/search\", \"vs/base/common/arrays\"], function (require, exports, strings_1, log_1, search_1, arrays_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function anchorGlob(glob) {\n        return strings_1.startsWith(glob, '**') || strings_1.startsWith(glob, '/') ? glob : `/${glob}`;\n    }\n    exports.anchorGlob = anchorGlob;\n    /**\n     * Create a vscode.TextSearchResult by using our internal TextSearchResult type for its previewOptions logic.\n     */\n    function createTextSearchResult(uri, text, range, previewOptions) {\n        const searchRange = arrays_1.mapArrayOrNot(range, rangeToSearchRange);\n        const internalResult = new search_1.TextSearchMatch(text, searchRange, previewOptions);\n        const internalPreviewRange = internalResult.preview.matches;\n        return {\n            ranges: arrays_1.mapArrayOrNot(searchRange, searchRangeToRange),\n            uri,\n            preview: {\n                text: internalResult.preview.text,\n                matches: arrays_1.mapArrayOrNot(internalPreviewRange, searchRangeToRange)\n            }\n        };\n    }\n    exports.createTextSearchResult = createTextSearchResult;\n    function rangeToSearchRange(range) {\n        return new search_1.SearchRange(range.start.line, range.start.character, range.end.line, range.end.character);\n    }\n    function searchRangeToRange(range) {\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    class Position {\n        constructor(line, character) {\n            this.line = line;\n            this.character = character;\n        }\n        isBefore(other) { return false; }\n        isBeforeOrEqual(other) { return false; }\n        isAfter(other) { return false; }\n        isAfterOrEqual(other) { return false; }\n        isEqual(other) { return false; }\n        compareTo(other) { return 0; }\n        translate(_, _2) { return new Position(0, 0); }\n        with(_) { return new Position(0, 0); }\n    }\n    exports.Position = Position;\n    class Range {\n        constructor(startLine, startCol, endLine, endCol) {\n            this.start = new Position(startLine, startCol);\n            this.end = new Position(endLine, endCol);\n        }\n        contains(positionOrRange) { return false; }\n        isEqual(other) { return false; }\n        intersection(range) { return undefined; }\n        union(other) { return new Range(0, 0, 0, 0); }\n        with(_) { return new Range(0, 0, 0, 0); }\n    }\n    exports.Range = Range;\n    let OutputChannel = class OutputChannel {\n        constructor(logService) {\n            this.logService = logService;\n        }\n        appendLine(msg) {\n            this.logService.debug('RipgrepSearchEH#search', msg);\n        }\n    };\n    OutputChannel = __decorate([\n        __param(0, log_1.ILogService)\n    ], OutputChannel);\n    exports.OutputChannel = OutputChannel;\n});\n",null]}