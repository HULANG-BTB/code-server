{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/labels.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/labels.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/uri\", \"vs/base/common/path\", \"vs/base/common/strings\", \"vs/base/common/network\", \"vs/base/common/platform\", \"vs/base/common/resources\", \"vs/base/common/charCode\"], function (require, exports, uri_1, path_1, strings_1, network_1, platform_1, resources_1, charCode_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @deprecated use LabelService instead\n     */\n    function getPathLabel(resource, userHomeProvider, rootProvider) {\n        if (typeof resource === 'string') {\n            resource = uri_1.URI.file(resource);\n        }\n        // return early if we can resolve a relative path label from the root\n        if (rootProvider) {\n            const baseResource = rootProvider.getWorkspaceFolder(resource);\n            if (baseResource) {\n                const hasMultipleRoots = rootProvider.getWorkspace().folders.length > 1;\n                let pathLabel;\n                if (resources_1.isEqual(baseResource.uri, resource)) {\n                    pathLabel = ''; // no label if paths are identical\n                }\n                else {\n                    // TODO: isidor use resources.relative\n                    pathLabel = path_1.normalize(strings_1.ltrim(resource.path.substr(baseResource.uri.path.length), path_1.posix.sep));\n                }\n                if (hasMultipleRoots) {\n                    const rootName = (baseResource && baseResource.name) ? baseResource.name : resources_1.basename(baseResource.uri);\n                    pathLabel = pathLabel ? (rootName + ' â€¢ ' + pathLabel) : rootName; // always show root basename if there are multiple\n                }\n                return pathLabel;\n            }\n        }\n        // return if the resource is neither file:// nor untitled:// and no baseResource was provided\n        if (resource.scheme !== network_1.Schemas.file && resource.scheme !== network_1.Schemas.untitled) {\n            return resource.with({ query: null, fragment: null }).toString(true);\n        }\n        // convert c:\\something => C:\\something\n        if (hasDriveLetter(resource.fsPath)) {\n            return path_1.normalize(normalizeDriveLetter(resource.fsPath));\n        }\n        // normalize and tildify (macOS, Linux only)\n        let res = path_1.normalize(resource.fsPath);\n        if (!platform_1.isWindows && userHomeProvider) {\n            res = tildify(res, userHomeProvider.userHome);\n        }\n        return res;\n    }\n    exports.getPathLabel = getPathLabel;\n    function getBaseLabel(resource) {\n        if (!resource) {\n            return undefined;\n        }\n        if (typeof resource === 'string') {\n            resource = uri_1.URI.file(resource);\n        }\n        const base = resources_1.basename(resource) || (resource.scheme === network_1.Schemas.file ? resource.fsPath : resource.path) /* can be empty string if '/' is passed in */;\n        // convert c: => C:\n        if (hasDriveLetter(base)) {\n            return normalizeDriveLetter(base);\n        }\n        return base;\n    }\n    exports.getBaseLabel = getBaseLabel;\n    function hasDriveLetter(path) {\n        return !!(platform_1.isWindows && path && path[1] === ':');\n    }\n    function normalizeDriveLetter(path) {\n        if (hasDriveLetter(path)) {\n            return path.charAt(0).toUpperCase() + path.slice(1);\n        }\n        return path;\n    }\n    exports.normalizeDriveLetter = normalizeDriveLetter;\n    let normalizedUserHomeCached = Object.create(null);\n    function tildify(path, userHome) {\n        if (platform_1.isWindows || !path || !userHome) {\n            return path; // unsupported\n        }\n        // Keep a normalized user home path as cache to prevent accumulated string creation\n        let normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : undefined;\n        if (!normalizedUserHome) {\n            normalizedUserHome = `${strings_1.rtrim(userHome, path_1.posix.sep)}${path_1.posix.sep}`;\n            normalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };\n        }\n        // Linux: case sensitive, macOS: case insensitive\n        if (platform_1.isLinux ? strings_1.startsWith(path, normalizedUserHome) : strings_1.startsWithIgnoreCase(path, normalizedUserHome)) {\n            path = `~/${path.substr(normalizedUserHome.length)}`;\n        }\n        return path;\n    }\n    exports.tildify = tildify;\n    function untildify(path, userHome) {\n        return path.replace(/^~($|\\/|\\\\)/, `${userHome}$1`);\n    }\n    exports.untildify = untildify;\n    /**\n     * Shortens the paths but keeps them easy to distinguish.\n     * Replaces not important parts with ellipsis.\n     * Every shorten path matches only one original path and vice versa.\n     *\n     * Algorithm for shortening paths is as follows:\n     * 1. For every path in list, find unique substring of that path.\n     * 2. Unique substring along with ellipsis is shortened path of that path.\n     * 3. To find unique substring of path, consider every segment of length from 1 to path.length of path from end of string\n     *    and if present segment is not substring to any other paths then present segment is unique path,\n     *    else check if it is not present as suffix of any other path and present segment is suffix of path itself,\n     *    if it is true take present segment as unique path.\n     * 4. Apply ellipsis to unique segment according to whether segment is present at start/in-between/end of path.\n     *\n     * Example 1\n     * 1. consider 2 paths i.e. ['a\\\\b\\\\c\\\\d', 'a\\\\f\\\\b\\\\c\\\\d']\n     * 2. find unique path of first path,\n     * \ta. 'd' is present in path2 and is suffix of path2, hence not unique of present path.\n     * \tb. 'c' is present in path2 and 'c' is not suffix of present path, similarly for 'b' and 'a' also.\n     * \tc. 'd\\\\c' is suffix of path2.\n     *  d. 'b\\\\c' is not suffix of present path.\n     *  e. 'a\\\\b' is not present in path2, hence unique path is 'a\\\\b...'.\n     * 3. for path2, 'f' is not present in path1 hence unique is '...\\\\f\\\\...'.\n     *\n     * Example 2\n     * 1. consider 2 paths i.e. ['a\\\\b', 'a\\\\b\\\\c'].\n     * \ta. Even if 'b' is present in path2, as 'b' is suffix of path1 and is not suffix of path2, unique path will be '...\\\\b'.\n     * 2. for path2, 'c' is not present in path1 hence unique path is '..\\\\c'.\n     */\n    const ellipsis = '\\u2026';\n    const unc = '\\\\\\\\';\n    const home = '~';\n    function shorten(paths) {\n        const shortenedPaths = new Array(paths.length);\n        // for every path\n        let match = false;\n        for (let pathIndex = 0; pathIndex < paths.length; pathIndex++) {\n            let path = paths[pathIndex];\n            if (path === '') {\n                shortenedPaths[pathIndex] = `.${path_1.sep}`;\n                continue;\n            }\n            if (!path) {\n                shortenedPaths[pathIndex] = path;\n                continue;\n            }\n            match = true;\n            // trim for now and concatenate unc path (e.g. \\\\network) or root path (/etc, ~/etc) later\n            let prefix = '';\n            if (path.indexOf(unc) === 0) {\n                prefix = path.substr(0, path.indexOf(unc) + unc.length);\n                path = path.substr(path.indexOf(unc) + unc.length);\n            }\n            else if (path.indexOf(path_1.sep) === 0) {\n                prefix = path.substr(0, path.indexOf(path_1.sep) + path_1.sep.length);\n                path = path.substr(path.indexOf(path_1.sep) + path_1.sep.length);\n            }\n            else if (path.indexOf(home) === 0) {\n                prefix = path.substr(0, path.indexOf(home) + home.length);\n                path = path.substr(path.indexOf(home) + home.length);\n            }\n            // pick the first shortest subpath found\n            const segments = path.split(path_1.sep);\n            for (let subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {\n                for (let start = segments.length - subpathLength; match && start >= 0; start--) {\n                    match = false;\n                    let subpath = segments.slice(start, start + subpathLength).join(path_1.sep);\n                    // that is unique to any other path\n                    for (let otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {\n                        // suffix subpath treated specially as we consider no match 'x' and 'x/...'\n                        if (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {\n                            const isSubpathEnding = (start + subpathLength === segments.length);\n                            // Adding separator as prefix for subpath, such that 'endsWith(src, trgt)' considers subpath as directory name instead of plain string.\n                            // prefix is not added when either subpath is root directory or path[otherPathIndex] does not have multiple directories.\n                            const subpathWithSep = (start > 0 && paths[otherPathIndex].indexOf(path_1.sep) > -1) ? path_1.sep + subpath : subpath;\n                            const isOtherPathEnding = strings_1.endsWith(paths[otherPathIndex], subpathWithSep);\n                            match = !isSubpathEnding || isOtherPathEnding;\n                        }\n                    }\n                    // found unique subpath\n                    if (!match) {\n                        let result = '';\n                        // preserve disk drive or root prefix\n                        if (strings_1.endsWith(segments[0], ':') || prefix !== '') {\n                            if (start === 1) {\n                                // extend subpath to include disk drive prefix\n                                start = 0;\n                                subpathLength++;\n                                subpath = segments[0] + path_1.sep + subpath;\n                            }\n                            if (start > 0) {\n                                result = segments[0] + path_1.sep;\n                            }\n                            result = prefix + result;\n                        }\n                        // add ellipsis at the beginning if neeeded\n                        if (start > 0) {\n                            result = result + ellipsis + path_1.sep;\n                        }\n                        result = result + subpath;\n                        // add ellipsis at the end if needed\n                        if (start + subpathLength < segments.length) {\n                            result = result + path_1.sep + ellipsis;\n                        }\n                        shortenedPaths[pathIndex] = result;\n                    }\n                }\n            }\n            if (match) {\n                shortenedPaths[pathIndex] = path; // use full path if no unique subpaths found\n            }\n        }\n        return shortenedPaths;\n    }\n    exports.shorten = shorten;\n    var Type;\n    (function (Type) {\n        Type[Type[\"TEXT\"] = 0] = \"TEXT\";\n        Type[Type[\"VARIABLE\"] = 1] = \"VARIABLE\";\n        Type[Type[\"SEPARATOR\"] = 2] = \"SEPARATOR\";\n    })(Type || (Type = {}));\n    /**\n     * Helper to insert values for specific template variables into the string. E.g. \"this $(is) a $(template)\" can be\n     * passed to this function together with an object that maps \"is\" and \"template\" to strings to have them replaced.\n     * @param value string to which templating is applied\n     * @param values the values of the templates to use\n     */\n    function template(template, values = Object.create(null)) {\n        const segments = [];\n        let inVariable = false;\n        let curVal = '';\n        for (const char of template) {\n            // Beginning of variable\n            if (char === '$' || (inVariable && char === '{')) {\n                if (curVal) {\n                    segments.push({ value: curVal, type: Type.TEXT });\n                }\n                curVal = '';\n                inVariable = true;\n            }\n            // End of variable\n            else if (char === '}' && inVariable) {\n                const resolved = values[curVal];\n                // Variable\n                if (typeof resolved === 'string') {\n                    if (resolved.length) {\n                        segments.push({ value: resolved, type: Type.VARIABLE });\n                    }\n                }\n                // Separator\n                else if (resolved) {\n                    const prevSegment = segments[segments.length - 1];\n                    if (!prevSegment || prevSegment.type !== Type.SEPARATOR) {\n                        segments.push({ value: resolved.label, type: Type.SEPARATOR }); // prevent duplicate separators\n                    }\n                }\n                curVal = '';\n                inVariable = false;\n            }\n            // Text or Variable Name\n            else {\n                curVal += char;\n            }\n        }\n        // Tail\n        if (curVal && !inVariable) {\n            segments.push({ value: curVal, type: Type.TEXT });\n        }\n        return segments.filter((segment, index) => {\n            // Only keep separator if we have values to the left and right\n            if (segment.type === Type.SEPARATOR) {\n                const left = segments[index - 1];\n                const right = segments[index + 1];\n                return [left, right].every(segment => segment && (segment.type === Type.VARIABLE || segment.type === Type.TEXT) && segment.value.length > 0);\n            }\n            // accept any TEXT and VARIABLE\n            return true;\n        }).map(segment => segment.value).join('');\n    }\n    exports.template = template;\n    /**\n     * Handles mnemonics for menu items. Depending on OS:\n     * - Windows: Supported via & character (replace && with &)\n     * -   Linux: Supported via & character (replace && with &)\n     * -   macOS: Unsupported (replace && with empty string)\n     */\n    function mnemonicMenuLabel(label, forceDisableMnemonics) {\n        if (platform_1.isMacintosh || forceDisableMnemonics) {\n            return label.replace(/\\(&&\\w\\)|&&/g, '').replace(/&/g, platform_1.isMacintosh ? '&' : '&&');\n        }\n        return label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');\n    }\n    exports.mnemonicMenuLabel = mnemonicMenuLabel;\n    /**\n     * Handles mnemonics for buttons. Depending on OS:\n     * - Windows: Supported via & character (replace && with & and & with && for escaping)\n     * -   Linux: Supported via _ character (replace && with _)\n     * -   macOS: Unsupported (replace && with empty string)\n     */\n    function mnemonicButtonLabel(label, forceDisableMnemonics) {\n        if (platform_1.isMacintosh || forceDisableMnemonics) {\n            return label.replace(/\\(&&\\w\\)|&&/g, '');\n        }\n        if (platform_1.isWindows) {\n            return label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');\n        }\n        return label.replace(/&&/g, '_');\n    }\n    exports.mnemonicButtonLabel = mnemonicButtonLabel;\n    function unmnemonicLabel(label) {\n        return label.replace(/&/g, '&&');\n    }\n    exports.unmnemonicLabel = unmnemonicLabel;\n    /**\n     * Splits a path in name and parent path, supporting both '/' and '\\'\n     */\n    function splitName(fullPath) {\n        for (let i = fullPath.length - 1; i >= 1; i--) {\n            const code = fullPath.charCodeAt(i);\n            if (code === charCode_1.CharCode.Slash || code === charCode_1.CharCode.Backslash) {\n                return { parentPath: fullPath.substr(0, i), name: fullPath.substr(i + 1) };\n            }\n        }\n        return { parentPath: '', name: fullPath };\n    }\n    exports.splitName = splitName;\n});\n",null]}