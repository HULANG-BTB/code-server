{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/backup/electron-main/backupMainService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/backup/electron-main/backupMainService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"fs\", \"crypto\", \"vs/base/common/path\", \"vs/base/common/platform\", \"vs/base/node/extfs\", \"vs/base/common/arrays\", \"vs/platform/environment/common/environment\", \"vs/platform/configuration/common/configuration\", \"vs/platform/files/common/files\", \"vs/platform/log/common/log\", \"vs/platform/workspaces/common/workspaces\", \"vs/base/common/uri\", \"vs/base/common/resources\", \"vs/base/common/extpath\", \"vs/base/common/network\", \"vs/base/node/pfs\"], function (require, exports, fs, crypto, path, platform, extfs_1, arrays, environment_1, configuration_1, files_1, log_1, workspaces_1, uri_1, resources_1, extpath_1, network_1, pfs_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let BackupMainService = class BackupMainService {\n        constructor(environmentService, configurationService, logService) {\n            this.configurationService = configurationService;\n            this.logService = logService;\n            this.backupHome = environmentService.backupHome;\n            this.workspacesJsonPath = environmentService.backupWorkspacesPath;\n        }\n        initialize() {\n            return __awaiter(this, void 0, void 0, function* () {\n                let backups;\n                try {\n                    backups = JSON.parse(yield pfs_1.readFile(this.workspacesJsonPath, 'utf8')); // invalid JSON or permission issue can happen here\n                }\n                catch (error) {\n                    backups = Object.create(null);\n                }\n                // read empty workspaces backups first\n                if (backups.emptyWorkspaceInfos) {\n                    this.emptyWorkspaces = yield this.validateEmptyWorkspaces(backups.emptyWorkspaceInfos);\n                }\n                else if (Array.isArray(backups.emptyWorkspaces)) {\n                    // read legacy entries\n                    this.emptyWorkspaces = yield this.validateEmptyWorkspaces(backups.emptyWorkspaces.map(backupFolder => ({ backupFolder })));\n                }\n                else {\n                    this.emptyWorkspaces = [];\n                }\n                // read workspace backups\n                let rootWorkspaces = [];\n                try {\n                    if (Array.isArray(backups.rootURIWorkspaces)) {\n                        rootWorkspaces = backups.rootURIWorkspaces.map(f => ({ workspace: { id: f.id, configPath: uri_1.URI.parse(f.configURIPath) }, remoteAuthority: f.remoteAuthority }));\n                    }\n                    else if (Array.isArray(backups.rootWorkspaces)) {\n                        rootWorkspaces = backups.rootWorkspaces.map(f => ({ workspace: { id: f.id, configPath: uri_1.URI.file(f.configPath) } }));\n                    }\n                }\n                catch (e) {\n                    // ignore URI parsing exceptions\n                }\n                this.rootWorkspaces = yield this.validateWorkspaces(rootWorkspaces);\n                // read folder backups\n                let workspaceFolders = [];\n                try {\n                    if (Array.isArray(backups.folderURIWorkspaces)) {\n                        workspaceFolders = backups.folderURIWorkspaces.map(f => uri_1.URI.parse(f));\n                    }\n                    else if (Array.isArray(backups.folderWorkspaces)) {\n                        // migrate legacy folder paths\n                        workspaceFolders = [];\n                        for (const folderPath of backups.folderWorkspaces) {\n                            const oldFolderHash = this.getLegacyFolderHash(folderPath);\n                            const folderUri = uri_1.URI.file(folderPath);\n                            const newFolderHash = this.getFolderHash(folderUri);\n                            if (newFolderHash !== oldFolderHash) {\n                                yield this.moveBackupFolder(this.getBackupPath(newFolderHash), this.getBackupPath(oldFolderHash));\n                            }\n                            workspaceFolders.push(folderUri);\n                        }\n                    }\n                }\n                catch (e) {\n                    // ignore URI parsing exceptions\n                }\n                this.folderWorkspaces = yield this.validateFolders(workspaceFolders);\n                // save again in case some workspaces or folders have been removed\n                yield this.save();\n            });\n        }\n        getWorkspaceBackups() {\n            if (this.isHotExitOnExitAndWindowClose()) {\n                // Only non-folder windows are restored on main process launch when\n                // hot exit is configured as onExitAndWindowClose.\n                return [];\n            }\n            return this.rootWorkspaces.slice(0); // return a copy\n        }\n        getFolderBackupPaths() {\n            if (this.isHotExitOnExitAndWindowClose()) {\n                // Only non-folder windows are restored on main process launch when\n                // hot exit is configured as onExitAndWindowClose.\n                return [];\n            }\n            return this.folderWorkspaces.slice(0); // return a copy\n        }\n        isHotExitEnabled() {\n            return this.getHotExitConfig() !== files_1.HotExitConfiguration.OFF;\n        }\n        isHotExitOnExitAndWindowClose() {\n            return this.getHotExitConfig() === files_1.HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE;\n        }\n        getHotExitConfig() {\n            const config = this.configurationService.getValue();\n            return (config && config.files && config.files.hotExit) || files_1.HotExitConfiguration.ON_EXIT;\n        }\n        getEmptyWindowBackupPaths() {\n            return this.emptyWorkspaces.slice(0); // return a copy\n        }\n        registerWorkspaceBackupSync(workspaceInfo, migrateFrom) {\n            if (!this.rootWorkspaces.some(w => workspaceInfo.workspace.id === w.workspace.id)) {\n                this.rootWorkspaces.push(workspaceInfo);\n                this.saveSync();\n            }\n            const backupPath = this.getBackupPath(workspaceInfo.workspace.id);\n            if (migrateFrom) {\n                this.moveBackupFolderSync(backupPath, migrateFrom);\n            }\n            return backupPath;\n        }\n        moveBackupFolderSync(backupPath, moveFromPath) {\n            // Target exists: make sure to convert existing backups to empty window backups\n            if (fs.existsSync(backupPath)) {\n                this.convertToEmptyWindowBackupSync(backupPath);\n            }\n            // When we have data to migrate from, move it over to the target location\n            if (fs.existsSync(moveFromPath)) {\n                try {\n                    fs.renameSync(moveFromPath, backupPath);\n                }\n                catch (ex) {\n                    this.logService.error(`Backup: Could not move backup folder to new location: ${ex.toString()}`);\n                }\n            }\n        }\n        moveBackupFolder(backupPath, moveFromPath) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // Target exists: make sure to convert existing backups to empty window backups\n                if (yield pfs_1.exists(backupPath)) {\n                    yield this.convertToEmptyWindowBackup(backupPath);\n                }\n                // When we have data to migrate from, move it over to the target location\n                if (yield pfs_1.exists(moveFromPath)) {\n                    try {\n                        yield pfs_1.rename(moveFromPath, backupPath);\n                    }\n                    catch (ex) {\n                        this.logService.error(`Backup: Could not move backup folder to new location: ${ex.toString()}`);\n                    }\n                }\n            });\n        }\n        unregisterWorkspaceBackupSync(workspace) {\n            const id = workspace.id;\n            let index = arrays.firstIndex(this.rootWorkspaces, w => w.workspace.id === id);\n            if (index !== -1) {\n                this.rootWorkspaces.splice(index, 1);\n                this.saveSync();\n            }\n        }\n        registerFolderBackupSync(folderUri) {\n            if (!this.folderWorkspaces.some(uri => resources_1.isEqual(folderUri, uri))) {\n                this.folderWorkspaces.push(folderUri);\n                this.saveSync();\n            }\n            return this.getBackupPath(this.getFolderHash(folderUri));\n        }\n        unregisterFolderBackupSync(folderUri) {\n            let index = arrays.firstIndex(this.folderWorkspaces, uri => resources_1.isEqual(folderUri, uri));\n            if (index !== -1) {\n                this.folderWorkspaces.splice(index, 1);\n                this.saveSync();\n            }\n        }\n        registerEmptyWindowBackupSync(backupFolder, remoteAuthority) {\n            // Generate a new folder if this is a new empty workspace\n            if (!backupFolder) {\n                backupFolder = this.getRandomEmptyWindowId();\n            }\n            if (!this.emptyWorkspaces.some(w => !!w.backupFolder && extpath_1.isEqual(w.backupFolder, backupFolder, !platform.isLinux))) {\n                this.emptyWorkspaces.push({ backupFolder, remoteAuthority });\n                this.saveSync();\n            }\n            return this.getBackupPath(backupFolder);\n        }\n        unregisterEmptyWindowBackupSync(backupFolder) {\n            let index = arrays.firstIndex(this.emptyWorkspaces, w => !!w.backupFolder && extpath_1.isEqual(w.backupFolder, backupFolder, !platform.isLinux));\n            if (index !== -1) {\n                this.emptyWorkspaces.splice(index, 1);\n                this.saveSync();\n            }\n        }\n        getBackupPath(oldFolderHash) {\n            return path.join(this.backupHome, oldFolderHash);\n        }\n        validateWorkspaces(rootWorkspaces) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!Array.isArray(rootWorkspaces)) {\n                    return [];\n                }\n                const seenIds = Object.create(null);\n                const result = [];\n                // Validate Workspaces\n                for (let workspaceInfo of rootWorkspaces) {\n                    const workspace = workspaceInfo.workspace;\n                    if (!workspaces_1.isWorkspaceIdentifier(workspace)) {\n                        return []; // wrong format, skip all entries\n                    }\n                    if (!seenIds[workspace.id]) {\n                        seenIds[workspace.id] = true;\n                        const backupPath = this.getBackupPath(workspace.id);\n                        const hasBackups = yield this.hasBackups(backupPath);\n                        // If the workspace has no backups, ignore it\n                        if (hasBackups) {\n                            if (workspace.configPath.scheme !== network_1.Schemas.file || (yield pfs_1.exists(workspace.configPath.fsPath))) {\n                                result.push(workspaceInfo);\n                            }\n                            else {\n                                // If the workspace has backups, but the target workspace is missing, convert backups to empty ones\n                                yield this.convertToEmptyWindowBackup(backupPath);\n                            }\n                        }\n                        else {\n                            yield this.deleteStaleBackup(backupPath);\n                        }\n                    }\n                }\n                return result;\n            });\n        }\n        validateFolders(folderWorkspaces) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!Array.isArray(folderWorkspaces)) {\n                    return [];\n                }\n                const result = [];\n                const seen = Object.create(null);\n                for (let folderURI of folderWorkspaces) {\n                    const key = resources_1.getComparisonKey(folderURI);\n                    if (!seen[key]) {\n                        seen[key] = true;\n                        const backupPath = this.getBackupPath(this.getFolderHash(folderURI));\n                        const hasBackups = yield this.hasBackups(backupPath);\n                        // If the folder has no backups, ignore it\n                        if (hasBackups) {\n                            if (folderURI.scheme !== network_1.Schemas.file || (yield pfs_1.exists(folderURI.fsPath))) {\n                                result.push(folderURI);\n                            }\n                            else {\n                                // If the folder has backups, but the target workspace is missing, convert backups to empty ones\n                                yield this.convertToEmptyWindowBackup(backupPath);\n                            }\n                        }\n                        else {\n                            yield this.deleteStaleBackup(backupPath);\n                        }\n                    }\n                }\n                return result;\n            });\n        }\n        validateEmptyWorkspaces(emptyWorkspaces) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!Array.isArray(emptyWorkspaces)) {\n                    return [];\n                }\n                const result = [];\n                const seen = Object.create(null);\n                // Validate Empty Windows\n                for (let backupInfo of emptyWorkspaces) {\n                    const backupFolder = backupInfo.backupFolder;\n                    if (typeof backupFolder !== 'string') {\n                        return [];\n                    }\n                    if (!seen[backupFolder]) {\n                        seen[backupFolder] = true;\n                        const backupPath = this.getBackupPath(backupFolder);\n                        if (yield this.hasBackups(backupPath)) {\n                            result.push(backupInfo);\n                        }\n                        else {\n                            yield this.deleteStaleBackup(backupPath);\n                        }\n                    }\n                }\n                return result;\n            });\n        }\n        deleteStaleBackup(backupPath) {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    if (yield pfs_1.exists(backupPath)) {\n                        yield pfs_1.del(backupPath);\n                    }\n                }\n                catch (ex) {\n                    this.logService.error(`Backup: Could not delete stale backup: ${ex.toString()}`);\n                }\n            });\n        }\n        convertToEmptyWindowBackup(backupPath) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // New empty window backup\n                let newBackupFolder = this.getRandomEmptyWindowId();\n                while (this.emptyWorkspaces.some(w => !!w.backupFolder && extpath_1.isEqual(w.backupFolder, newBackupFolder, platform.isLinux))) {\n                    newBackupFolder = this.getRandomEmptyWindowId();\n                }\n                // Rename backupPath to new empty window backup path\n                const newEmptyWindowBackupPath = this.getBackupPath(newBackupFolder);\n                try {\n                    yield pfs_1.rename(backupPath, newEmptyWindowBackupPath);\n                }\n                catch (ex) {\n                    this.logService.error(`Backup: Could not rename backup folder: ${ex.toString()}`);\n                    return false;\n                }\n                this.emptyWorkspaces.push({ backupFolder: newBackupFolder });\n                return true;\n            });\n        }\n        convertToEmptyWindowBackupSync(backupPath) {\n            // New empty window backup\n            let newBackupFolder = this.getRandomEmptyWindowId();\n            while (this.emptyWorkspaces.some(w => !!w.backupFolder && extpath_1.isEqual(w.backupFolder, newBackupFolder, platform.isLinux))) {\n                newBackupFolder = this.getRandomEmptyWindowId();\n            }\n            // Rename backupPath to new empty window backup path\n            const newEmptyWindowBackupPath = this.getBackupPath(newBackupFolder);\n            try {\n                fs.renameSync(backupPath, newEmptyWindowBackupPath);\n            }\n            catch (ex) {\n                this.logService.error(`Backup: Could not rename backup folder: ${ex.toString()}`);\n                return false;\n            }\n            this.emptyWorkspaces.push({ backupFolder: newBackupFolder });\n            return true;\n        }\n        hasBackups(backupPath) {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const backupSchemas = yield pfs_1.readdir(backupPath);\n                    for (const backupSchema of backupSchemas) {\n                        try {\n                            const backupSchemaChildren = yield pfs_1.readdir(path.join(backupPath, backupSchema));\n                            if (backupSchemaChildren.length > 0) {\n                                return true;\n                            }\n                        }\n                        catch (error) {\n                            // invalid folder\n                        }\n                    }\n                }\n                catch (error) {\n                    // backup path does not exist\n                }\n                return false;\n            });\n        }\n        saveSync() {\n            try {\n                extfs_1.writeFileAndFlushSync(this.workspacesJsonPath, JSON.stringify(this.serializeBackups()));\n            }\n            catch (ex) {\n                this.logService.error(`Backup: Could not save workspaces.json: ${ex.toString()}`);\n            }\n        }\n        save() {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    yield pfs_1.writeFile(this.workspacesJsonPath, JSON.stringify(this.serializeBackups()));\n                }\n                catch (ex) {\n                    this.logService.error(`Backup: Could not save workspaces.json: ${ex.toString()}`);\n                }\n            });\n        }\n        serializeBackups() {\n            return {\n                rootURIWorkspaces: this.rootWorkspaces.map(f => ({ id: f.workspace.id, configURIPath: f.workspace.configPath.toString(), remoteAuthority: f.remoteAuthority })),\n                folderURIWorkspaces: this.folderWorkspaces.map(f => f.toString()),\n                emptyWorkspaceInfos: this.emptyWorkspaces,\n                emptyWorkspaces: this.emptyWorkspaces.map(info => info.backupFolder)\n            };\n        }\n        getRandomEmptyWindowId() {\n            return (Date.now() + Math.round(Math.random() * 1000)).toString();\n        }\n        getFolderHash(folderUri) {\n            let key;\n            if (folderUri.scheme === network_1.Schemas.file) {\n                // for backward compatibility, use the fspath as key\n                key = platform.isLinux ? folderUri.fsPath : folderUri.fsPath.toLowerCase();\n            }\n            else {\n                key = resources_1.hasToIgnoreCase(folderUri) ? folderUri.toString().toLowerCase() : folderUri.toString();\n            }\n            return crypto.createHash('md5').update(key).digest('hex');\n        }\n        getLegacyFolderHash(folderPath) {\n            return crypto.createHash('md5').update(platform.isLinux ? folderPath : folderPath.toLowerCase()).digest('hex');\n        }\n    };\n    BackupMainService = __decorate([\n        __param(0, environment_1.IEnvironmentService),\n        __param(1, configuration_1.IConfigurationService),\n        __param(2, log_1.ILogService)\n    ], BackupMainService);\n    exports.BackupMainService = BackupMainService;\n});\n",null]}