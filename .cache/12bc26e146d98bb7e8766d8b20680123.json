{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/electron-browser/extensionHost.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/electron-browser/extensionHost.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar nls = require(\"vs/nls\");\nvar child_process_1 = require(\"child_process\");\nvar electron_1 = require(\"electron\");\nvar net_1 = require(\"net\");\nvar amd_1 = require(\"vs/base/common/amd\");\nvar async_1 = require(\"vs/base/common/async\");\nvar errorMessage_1 = require(\"vs/base/common/errorMessage\");\nvar event_1 = require(\"vs/base/common/event\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar objects = require(\"vs/base/common/objects\");\nvar platform_1 = require(\"vs/base/common/platform\");\nvar resources_1 = require(\"vs/base/common/resources\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar console_1 = require(\"vs/base/common/console\");\nvar ports_1 = require(\"vs/base/node/ports\");\nvar ipc_net_1 = require(\"vs/base/parts/ipc/common/ipc.net\");\nvar ipc_net_2 = require(\"vs/base/parts/ipc/node/ipc.net\");\nvar broadcast_1 = require(\"vs/workbench/services/broadcast/common/broadcast\");\nvar environment_1 = require(\"vs/platform/environment/common/environment\");\nvar extensionHost_1 = require(\"vs/platform/extensions/common/extensionHost\");\nvar label_1 = require(\"vs/platform/label/common/label\");\nvar lifecycle_2 = require(\"vs/platform/lifecycle/common/lifecycle\");\nvar log_1 = require(\"vs/platform/log/common/log\");\nvar product_1 = require(\"vs/platform/product/node/product\");\nvar notification_1 = require(\"vs/platform/notification/common/notification\");\nvar telemetry_1 = require(\"vs/platform/telemetry/common/telemetry\");\nvar windows_1 = require(\"vs/platform/windows/common/windows\");\nvar workspace_1 = require(\"vs/platform/workspace/common/workspace\");\nvar extensionHostProtocol_1 = require(\"vs/workbench/services/extensions/node/extensionHostProtocol\");\nvar types_1 = require(\"vs/base/common/types\");\nvar extensionDevOptions_1 = require(\"../common/extensionDevOptions\");\nvar buffer_1 = require(\"vs/base/common/buffer\");\nvar ExtensionHostProcessWorker = /** @class */ (function () {\n    function ExtensionHostProcessWorker(_autoStart, _extensions, _extensionHostLogsLocation, _contextService, _notificationService, _windowsService, _windowService, _broadcastService, _lifecycleService, _environmentService, _telemetryService, _logService, _labelService) {\n        var _this = this;\n        this._autoStart = _autoStart;\n        this._extensions = _extensions;\n        this._extensionHostLogsLocation = _extensionHostLogsLocation;\n        this._contextService = _contextService;\n        this._notificationService = _notificationService;\n        this._windowsService = _windowsService;\n        this._windowService = _windowService;\n        this._broadcastService = _broadcastService;\n        this._lifecycleService = _lifecycleService;\n        this._environmentService = _environmentService;\n        this._telemetryService = _telemetryService;\n        this._logService = _logService;\n        this._labelService = _labelService;\n        this._onCrashed = new event_1.Emitter();\n        this.onCrashed = this._onCrashed.event;\n        var devOpts = extensionDevOptions_1.parseExtensionDevOptions(this._environmentService);\n        this._isExtensionDevHost = devOpts.isExtensionDevHost;\n        this._isExtensionDevDebug = devOpts.isExtensionDevDebug;\n        this._isExtensionDevDebugBrk = devOpts.isExtensionDevDebugBrk;\n        this._isExtensionDevTestFromCli = devOpts.isExtensionDevTestFromCli;\n        this._lastExtensionHostError = null;\n        this._terminating = false;\n        this._namedPipeServer = null;\n        this._extensionHostProcess = null;\n        this._extensionHostConnection = null;\n        this._messageProtocol = null;\n        this._toDispose = [];\n        this._toDispose.push(this._onCrashed);\n        this._toDispose.push(this._lifecycleService.onWillShutdown(function (e) { return _this._onWillShutdown(e); }));\n        this._toDispose.push(this._lifecycleService.onShutdown(function (reason) { return _this.terminate(); }));\n        this._toDispose.push(this._broadcastService.onBroadcast(function (b) { return _this._onBroadcast(b); }));\n        var globalExitListener = function () { return _this.terminate(); };\n        process.once('exit', globalExitListener);\n        this._toDispose.push(lifecycle_1.toDisposable(function () {\n            process.removeListener('exit', globalExitListener);\n        }));\n    }\n    ExtensionHostProcessWorker.prototype.dispose = function () {\n        this.terminate();\n    };\n    ExtensionHostProcessWorker.prototype._onBroadcast = function (broadcast) {\n        var _this = this;\n        // Close Ext Host Window Request\n        if (broadcast.channel === extensionHost_1.EXTENSION_CLOSE_EXTHOST_BROADCAST_CHANNEL && this._isExtensionDevHost) {\n            var extensionLocations = broadcast.payload;\n            if (Array.isArray(extensionLocations) && extensionLocations.some(function (uriString) { return resources_1.isEqual(_this._environmentService.extensionDevelopmentLocationURI, uri_1.URI.parse(uriString)); })) {\n                this._windowService.closeWindow();\n            }\n        }\n        if (broadcast.channel === extensionHost_1.EXTENSION_RELOAD_BROADCAST_CHANNEL && this._isExtensionDevHost) {\n            var extensionPaths = broadcast.payload;\n            if (Array.isArray(extensionPaths) && extensionPaths.some(function (uriString) { return resources_1.isEqual(_this._environmentService.extensionDevelopmentLocationURI, uri_1.URI.parse(uriString)); })) {\n                this._windowService.reloadWindow();\n            }\n        }\n    };\n    ExtensionHostProcessWorker.prototype.start = function () {\n        var _this = this;\n        if (this._terminating) {\n            // .terminate() was called\n            return null;\n        }\n        if (!this._messageProtocol) {\n            this._messageProtocol = Promise.all([this._tryListenOnPipe(), this._tryFindDebugPort()]).then(function (data) {\n                var pipeName = data[0];\n                var portData = data[1];\n                var opts = {\n                    env: objects.mixin(objects.deepClone(process.env), {\n                        AMD_ENTRYPOINT: 'vs/workbench/services/extensions/node/extensionHostProcess',\n                        PIPE_LOGGING: 'true',\n                        VERBOSE_LOGGING: true,\n                        VSCODE_IPC_HOOK_EXTHOST: pipeName,\n                        VSCODE_HANDLES_UNCAUGHT_ERRORS: true,\n                        VSCODE_LOG_STACK: !_this._isExtensionDevTestFromCli && (_this._isExtensionDevHost || !_this._environmentService.isBuilt || product_1.default.quality !== 'stable' || _this._environmentService.verbose),\n                        VSCODE_LOG_LEVEL: _this._environmentService.verbose ? 'trace' : _this._environmentService.log\n                    }),\n                    // We only detach the extension host on windows. Linux and Mac orphan by default\n                    // and detach under Linux and Mac create another process group.\n                    // We detach because we have noticed that when the renderer exits, its child processes\n                    // (i.e. extension host) are taken down in a brutal fashion by the OS\n                    detached: !!platform_1.isWindows,\n                    execArgv: undefined,\n                    silent: true\n                };\n                if (portData.actual) {\n                    opts.execArgv = [\n                        '--nolazy',\n                        (_this._isExtensionDevDebugBrk ? '--inspect-brk=' : '--inspect=') + portData.actual\n                    ];\n                    if (!portData.expected) {\n                        // No one asked for 'inspect' or 'inspect-brk', only us. We add another\n                        // option such that the extension host can manipulate the execArgv array\n                        opts.env.VSCODE_PREVENT_FOREIGN_INSPECT = true;\n                    }\n                }\n                var crashReporterOptions = undefined; // TODO@electron pass this in as options to the extension host after verifying this actually works\n                if (crashReporterOptions) {\n                    opts.env.CRASH_REPORTER_START_OPTIONS = JSON.stringify(crashReporterOptions);\n                }\n                // Run Extension Host as fork of current process\n                _this._extensionHostProcess = child_process_1.fork(amd_1.getPathFromAmdModule(require, 'bootstrap-fork'), ['--type=extensionHost'], opts);\n                _this._extensionHostProcess.stdout.setEncoding('utf8');\n                _this._extensionHostProcess.stderr.setEncoding('utf8');\n                var onStdout = event_1.Event.fromNodeEventEmitter(_this._extensionHostProcess.stdout, 'data');\n                var onStderr = event_1.Event.fromNodeEventEmitter(_this._extensionHostProcess.stderr, 'data');\n                var onOutput = event_1.Event.any(event_1.Event.map(onStdout, function (o) { return ({ data: \"%c\" + o, format: [''] }); }), event_1.Event.map(onStderr, function (o) { return ({ data: \"%c\" + o, format: ['color: red'] }); }));\n                // Debounce all output, so we can render it in the Chrome console as a group\n                var onDebouncedOutput = event_1.Event.debounce(onOutput, function (r, o) {\n                    return r\n                        ? { data: r.data + o.data, format: r.format.concat(o.format) }\n                        : { data: o.data, format: o.format };\n                }, 100);\n                // Print out extension host output\n                onDebouncedOutput(function (output) {\n                    var inspectorUrlMatch = output.data && output.data.match(/ws:\\/\\/([^\\s]+:(\\d+)\\/[^\\s]+)/);\n                    if (inspectorUrlMatch) {\n                        if (!_this._environmentService.isBuilt) {\n                            console.log(\"%c[Extension Host] %cdebugger inspector at chrome-devtools://devtools/bundled/inspector.html?experiments=true&v8only=true&ws=\" + inspectorUrlMatch[1], 'color: blue', 'color: black');\n                        }\n                        if (!_this._inspectPort) {\n                            _this._inspectPort = Number(inspectorUrlMatch[2]);\n                        }\n                    }\n                    else {\n                        console.group('Extension Host');\n                        console.log.apply(console, [output.data].concat(output.format));\n                        console.groupEnd();\n                    }\n                });\n                // Support logging from extension host\n                _this._extensionHostProcess.on('message', function (msg) {\n                    if (msg && msg.type === '__$console') {\n                        _this._logExtensionHostMessage(msg);\n                    }\n                });\n                // Lifecycle\n                _this._extensionHostProcess.on('error', function (err) { return _this._onExtHostProcessError(err); });\n                _this._extensionHostProcess.on('exit', function (code, signal) { return _this._onExtHostProcessExit(code, signal); });\n                // Notify debugger that we are ready to attach to the process if we run a development extension\n                if (_this._isExtensionDevHost && portData.actual && _this._isExtensionDevDebug) {\n                    _this._broadcastService.broadcast({\n                        channel: extensionHost_1.EXTENSION_ATTACH_BROADCAST_CHANNEL,\n                        payload: {\n                            debugId: _this._environmentService.debugExtensionHost.debugId,\n                            port: portData.actual\n                        }\n                    });\n                }\n                _this._inspectPort = portData.actual;\n                // Help in case we fail to start it\n                var startupTimeoutHandle;\n                if (!_this._environmentService.isBuilt && !_this._windowService.getConfiguration().remoteAuthority || _this._isExtensionDevHost) {\n                    startupTimeoutHandle = setTimeout(function () {\n                        var msg = _this._isExtensionDevDebugBrk\n                            ? nls.localize('extensionHostProcess.startupFailDebug', \"Extension host did not start in 10 seconds, it might be stopped on the first line and needs a debugger to continue.\")\n                            : nls.localize('extensionHostProcess.startupFail', \"Extension host did not start in 10 seconds, that might be a problem.\");\n                        _this._notificationService.prompt(notification_1.Severity.Warning, msg, [{\n                                label: nls.localize('reloadWindow', \"Reload Window\"),\n                                run: function () { return _this._windowService.reloadWindow(); }\n                            }], { sticky: true });\n                    }, 10000);\n                }\n                // Initialize extension host process with hand shakes\n                return _this._tryExtHostHandshake().then(function (protocol) {\n                    clearTimeout(startupTimeoutHandle);\n                    return protocol;\n                });\n            });\n        }\n        return this._messageProtocol;\n    };\n    /**\n     * Start a server (`this._namedPipeServer`) that listens on a named pipe and return the named pipe name.\n     */\n    ExtensionHostProcessWorker.prototype._tryListenOnPipe = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            var pipeName = ipc_net_2.generateRandomPipeName();\n            _this._namedPipeServer = net_1.createServer();\n            _this._namedPipeServer.on('error', reject);\n            _this._namedPipeServer.listen(pipeName, function () {\n                if (_this._namedPipeServer) {\n                    _this._namedPipeServer.removeListener('error', reject);\n                }\n                resolve(pipeName);\n            });\n        });\n    };\n    /**\n     * Find a free port if extension host debugging is enabled.\n     */\n    ExtensionHostProcessWorker.prototype._tryFindDebugPort = function () {\n        var _this = this;\n        var expected;\n        var startPort = ports_1.randomPort();\n        if (typeof this._environmentService.debugExtensionHost.port === 'number') {\n            startPort = expected = this._environmentService.debugExtensionHost.port;\n        }\n        return new Promise(function (resolve) {\n            return ports_1.findFreePort(startPort, 10 /* try 10 ports */, 5000 /* try up to 5 seconds */).then(function (port) {\n                if (!port) {\n                    console.warn('%c[Extension Host] %cCould not find a free port for debugging', 'color: blue', 'color: black');\n                }\n                else {\n                    if (expected && port !== expected) {\n                        console.warn(\"%c[Extension Host] %cProvided debugging port \" + expected + \" is not free, using \" + port + \" instead.\", 'color: blue', 'color: black');\n                    }\n                    if (_this._isExtensionDevDebugBrk) {\n                        console.warn(\"%c[Extension Host] %cSTOPPED on first line for debugging on port \" + port, 'color: blue', 'color: black');\n                    }\n                    else {\n                        console.info(\"%c[Extension Host] %cdebugger listening on port \" + port, 'color: blue', 'color: black');\n                    }\n                }\n                return resolve({ expected: expected, actual: port });\n            });\n        });\n    };\n    ExtensionHostProcessWorker.prototype._tryExtHostHandshake = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            // Wait for the extension host to connect to our named pipe\n            // and wrap the socket in the message passing protocol\n            var handle = setTimeout(function () {\n                if (_this._namedPipeServer) {\n                    _this._namedPipeServer.close();\n                    _this._namedPipeServer = null;\n                }\n                reject('timeout');\n            }, 60 * 1000);\n            _this._namedPipeServer.on('connection', function (socket) {\n                clearTimeout(handle);\n                if (_this._namedPipeServer) {\n                    _this._namedPipeServer.close();\n                    _this._namedPipeServer = null;\n                }\n                _this._extensionHostConnection = socket;\n                // using a buffered message protocol here because between now\n                // and the first time a `then` executes some messages might be lost\n                // unless we immediately register a listener for `onMessage`.\n                resolve(new ipc_net_1.PersistentProtocol(new ipc_net_2.NodeSocket(_this._extensionHostConnection)));\n            });\n        }).then(function (protocol) {\n            // 1) wait for the incoming `ready` event and send the initialization data.\n            // 2) wait for the incoming `initialized` event.\n            return new Promise(function (resolve, reject) {\n                var timeoutHandle;\n                var installTimeoutCheck = function () {\n                    timeoutHandle = setTimeout(function () {\n                        reject('timeout');\n                    }, 60 * 1000);\n                };\n                var uninstallTimeoutCheck = function () {\n                    clearTimeout(timeoutHandle);\n                };\n                // Wait 60s for the ready message\n                installTimeoutCheck();\n                var disposable = protocol.onMessage(function (msg) {\n                    if (extensionHostProtocol_1.isMessageOfType(msg, extensionHostProtocol_1.MessageType.Ready)) {\n                        // 1) Extension Host is ready to receive messages, initialize it\n                        uninstallTimeoutCheck();\n                        _this._createExtHostInitData().then(function (data) {\n                            // Wait 60s for the initialized message\n                            installTimeoutCheck();\n                            protocol.send(buffer_1.VSBuffer.fromString(JSON.stringify(data)));\n                        });\n                        return;\n                    }\n                    if (extensionHostProtocol_1.isMessageOfType(msg, extensionHostProtocol_1.MessageType.Initialized)) {\n                        // 2) Extension Host is initialized\n                        uninstallTimeoutCheck();\n                        // stop listening for messages here\n                        disposable.dispose();\n                        // release this promise\n                        resolve(protocol);\n                        return;\n                    }\n                    console.error(\"received unexpected message during handshake phase from the extension host: \", msg);\n                });\n            });\n        });\n    };\n    ExtensionHostProcessWorker.prototype._createExtHostInitData = function () {\n        var _this = this;\n        return Promise.all([this._telemetryService.getTelemetryInfo(), this._extensions])\n            .then(function (_a) {\n            var telemetryInfo = _a[0], extensionDescriptions = _a[1];\n            var workspace = _this._contextService.getWorkspace();\n            var r = {\n                commit: product_1.default.commit,\n                parentPid: process.pid,\n                environment: {\n                    isExtensionDevelopmentDebug: _this._isExtensionDevDebug,\n                    appRoot: _this._environmentService.appRoot ? uri_1.URI.file(_this._environmentService.appRoot) : undefined,\n                    appSettingsHome: _this._environmentService.appSettingsHome ? uri_1.URI.file(_this._environmentService.appSettingsHome) : undefined,\n                    extensionDevelopmentLocationURI: _this._environmentService.extensionDevelopmentLocationURI,\n                    extensionTestsLocationURI: _this._environmentService.extensionTestsLocationURI,\n                    globalStorageHome: uri_1.URI.file(_this._environmentService.globalStorageHome),\n                    userHome: uri_1.URI.file(_this._environmentService.userHome)\n                },\n                workspace: _this._contextService.getWorkbenchState() === workspace_1.WorkbenchState.EMPTY ? undefined : {\n                    configuration: types_1.withNullAsUndefined(workspace.configuration),\n                    id: workspace.id,\n                    name: _this._labelService.getWorkspaceLabel(workspace)\n                },\n                resolvedExtensions: [],\n                hostExtensions: [],\n                extensions: extensionDescriptions,\n                telemetryInfo: telemetryInfo,\n                logLevel: _this._logService.getLevel(),\n                logsLocation: _this._extensionHostLogsLocation,\n                autoStart: _this._autoStart\n            };\n            return r;\n        });\n    };\n    ExtensionHostProcessWorker.prototype._logExtensionHostMessage = function (entry) {\n        var _a;\n        // Send to local console unless we run tests from cli\n        if (!this._isExtensionDevTestFromCli) {\n            console_1.log(entry, 'Extension Host');\n        }\n        // Log on main side if running tests from cli\n        if (this._isExtensionDevTestFromCli) {\n            (_a = this._windowsService).log.apply(_a, [entry.severity].concat(console_1.parse(entry).args));\n        }\n        // Broadcast to other windows if we are in development mode\n        else if (!this._environmentService.isBuilt || this._isExtensionDevHost) {\n            this._broadcastService.broadcast({\n                channel: extensionHost_1.EXTENSION_LOG_BROADCAST_CHANNEL,\n                payload: {\n                    logEntry: entry,\n                    debugId: this._environmentService.debugExtensionHost.debugId\n                }\n            });\n        }\n    };\n    ExtensionHostProcessWorker.prototype._onExtHostProcessError = function (err) {\n        var errorMessage = errorMessage_1.toErrorMessage(err);\n        if (errorMessage === this._lastExtensionHostError) {\n            return; // prevent error spam\n        }\n        this._lastExtensionHostError = errorMessage;\n        this._notificationService.error(nls.localize('extensionHostProcess.error', \"Error from the extension host: {0}\", errorMessage));\n    };\n    ExtensionHostProcessWorker.prototype._onExtHostProcessExit = function (code, signal) {\n        if (this._terminating) {\n            // Expected termination path (we asked the process to terminate)\n            return;\n        }\n        // Unexpected termination\n        if (!this._isExtensionDevHost) {\n            this._onCrashed.fire([code, signal]);\n        }\n        // Expected development extension termination: When the extension host goes down we also shutdown the window\n        else if (!this._isExtensionDevTestFromCli) {\n            this._windowService.closeWindow();\n        }\n        // When CLI testing make sure to exit with proper exit code\n        else {\n            electron_1.ipcRenderer.send('vscode:exit', code);\n        }\n    };\n    ExtensionHostProcessWorker.prototype.enableInspector = function () {\n        if (this._inspectPort) {\n            return Promise.resolve();\n        }\n        // send SIGUSR1 and wait a little the actual port is read from the process stdout which we\n        // scan here: https://github.com/Microsoft/vscode/blob/67ffab8dcd1a6752d8b62bcd13d7020101eef568/src/vs/workbench/services/extensions/electron-browser/extensionHost.ts#L225-L240\n        if (this._extensionHostProcess) {\n            this._extensionHostProcess.kill('SIGUSR1');\n        }\n        return async_1.timeout(1000);\n    };\n    ExtensionHostProcessWorker.prototype.getInspectPort = function () {\n        return this._inspectPort;\n    };\n    ExtensionHostProcessWorker.prototype.terminate = function () {\n        var _this = this;\n        if (this._terminating) {\n            return;\n        }\n        this._terminating = true;\n        lifecycle_1.dispose(this._toDispose);\n        if (!this._messageProtocol) {\n            // .start() was not called\n            return;\n        }\n        this._messageProtocol.then(function (protocol) {\n            // Send the extension host a request to terminate itself\n            // (graceful termination)\n            protocol.send(extensionHostProtocol_1.createMessageOfType(extensionHostProtocol_1.MessageType.Terminate));\n            protocol.dispose();\n            // Give the extension host 10s, after which we will\n            // try to kill the process and release any resources\n            setTimeout(function () { return _this._cleanResources(); }, 10 * 1000);\n        }, function (err) {\n            // Establishing a protocol with the extension host failed, so\n            // try to kill the process and release any resources.\n            _this._cleanResources();\n        });\n    };\n    ExtensionHostProcessWorker.prototype._cleanResources = function () {\n        if (this._namedPipeServer) {\n            this._namedPipeServer.close();\n            this._namedPipeServer = null;\n        }\n        if (this._extensionHostConnection) {\n            this._extensionHostConnection.end();\n            this._extensionHostConnection = null;\n        }\n        if (this._extensionHostProcess) {\n            this._extensionHostProcess.kill();\n            this._extensionHostProcess = null;\n        }\n    };\n    ExtensionHostProcessWorker.prototype._onWillShutdown = function (event) {\n        // If the extension development host was started without debugger attached we need\n        // to communicate this back to the main side to terminate the debug session\n        if (this._isExtensionDevHost && !this._isExtensionDevTestFromCli && !this._isExtensionDevDebug) {\n            this._broadcastService.broadcast({\n                channel: extensionHost_1.EXTENSION_TERMINATE_BROADCAST_CHANNEL,\n                payload: {\n                    debugId: this._environmentService.debugExtensionHost.debugId\n                }\n            });\n            event.join(async_1.timeout(100 /* wait a bit for IPC to get delivered */));\n        }\n    };\n    ExtensionHostProcessWorker = tslib_1.__decorate([\n        tslib_1.__param(3, workspace_1.IWorkspaceContextService),\n        tslib_1.__param(4, notification_1.INotificationService),\n        tslib_1.__param(5, windows_1.IWindowsService),\n        tslib_1.__param(6, windows_1.IWindowService),\n        tslib_1.__param(7, broadcast_1.IBroadcastService),\n        tslib_1.__param(8, lifecycle_2.ILifecycleService),\n        tslib_1.__param(9, environment_1.IEnvironmentService),\n        tslib_1.__param(10, telemetry_1.ITelemetryService),\n        tslib_1.__param(11, log_1.ILogService),\n        tslib_1.__param(12, label_1.ILabelService)\n    ], ExtensionHostProcessWorker);\n    return ExtensionHostProcessWorker;\n}());\nexports.ExtensionHostProcessWorker = ExtensionHostProcessWorker;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/electron-browser/extensionHost.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/electron-browser/extensionHost.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\nimport { ChildProcess, fork } from 'child_process';\nimport { ipcRenderer as ipc } from 'electron';\nimport { Server, Socket, createServer } from 'net';\nimport { getPathFromAmdModule } from 'vs/base/common/amd';\nimport { timeout } from 'vs/base/common/async';\nimport { toErrorMessage } from 'vs/base/common/errorMessage';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDisposable, dispose, toDisposable } from 'vs/base/common/lifecycle';\nimport * as objects from 'vs/base/common/objects';\nimport { isWindows } from 'vs/base/common/platform';\nimport { isEqual } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { IRemoteConsoleLog, log, parse } from 'vs/base/common/console';\nimport { findFreePort, randomPort } from 'vs/base/node/ports';\nimport { IMessagePassingProtocol } from 'vs/base/parts/ipc/common/ipc';\nimport { PersistentProtocol } from 'vs/base/parts/ipc/common/ipc.net';\nimport { generateRandomPipeName, NodeSocket } from 'vs/base/parts/ipc/node/ipc.net';\nimport { IBroadcast, IBroadcastService } from 'vs/workbench/services/broadcast/common/broadcast';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { EXTENSION_ATTACH_BROADCAST_CHANNEL, EXTENSION_CLOSE_EXTHOST_BROADCAST_CHANNEL, EXTENSION_LOG_BROADCAST_CHANNEL, EXTENSION_RELOAD_BROADCAST_CHANNEL, EXTENSION_TERMINATE_BROADCAST_CHANNEL } from 'vs/platform/extensions/common/extensionHost';\nimport { ILabelService } from 'vs/platform/label/common/label';\nimport { ILifecycleService, WillShutdownEvent } from 'vs/platform/lifecycle/common/lifecycle';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport product from 'vs/platform/product/node/product';\nimport { INotificationService, Severity } from 'vs/platform/notification/common/notification';\nimport { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';\nimport { IWindowService, IWindowsService } from 'vs/platform/windows/common/windows';\nimport { IWorkspaceContextService, WorkbenchState } from 'vs/platform/workspace/common/workspace';\nimport { IInitData } from 'vs/workbench/api/common/extHost.protocol';\nimport { MessageType, createMessageOfType, isMessageOfType } from 'vs/workbench/services/extensions/node/extensionHostProtocol';\nimport { withNullAsUndefined } from 'vs/base/common/types';\nimport { IExtensionDescription } from 'vs/platform/extensions/common/extensions';\nimport { parseExtensionDevOptions } from '../common/extensionDevOptions';\nimport { VSBuffer } from 'vs/base/common/buffer';\n\nexport interface IExtensionHostStarter {\n\treadonly onCrashed: Event<[number, string | null]>;\n\tstart(): Promise<IMessagePassingProtocol> | null;\n\tgetInspectPort(): number | undefined;\n\tdispose(): void;\n}\n\nexport class ExtensionHostProcessWorker implements IExtensionHostStarter {\n\n\tprivate readonly _onCrashed: Emitter<[number, string]> = new Emitter<[number, string]>();\n\tpublic readonly onCrashed: Event<[number, string]> = this._onCrashed.event;\n\n\tprivate readonly _toDispose: IDisposable[];\n\n\tprivate readonly _isExtensionDevHost: boolean;\n\tprivate readonly _isExtensionDevDebug: boolean;\n\tprivate readonly _isExtensionDevDebugBrk: boolean;\n\tprivate readonly _isExtensionDevTestFromCli: boolean;\n\n\t// State\n\tprivate _lastExtensionHostError: string | null;\n\tprivate _terminating: boolean;\n\n\t// Resources, in order they get acquired/created when .start() is called:\n\tprivate _namedPipeServer: Server | null;\n\tprivate _inspectPort: number;\n\tprivate _extensionHostProcess: ChildProcess | null;\n\tprivate _extensionHostConnection: Socket | null;\n\tprivate _messageProtocol: Promise<PersistentProtocol> | null;\n\n\tconstructor(\n\t\tprivate readonly _autoStart: boolean,\n\t\tprivate readonly _extensions: Promise<IExtensionDescription[]>,\n\t\tprivate readonly _extensionHostLogsLocation: URI,\n\t\t@IWorkspaceContextService private readonly _contextService: IWorkspaceContextService,\n\t\t@INotificationService private readonly _notificationService: INotificationService,\n\t\t@IWindowsService private readonly _windowsService: IWindowsService,\n\t\t@IWindowService private readonly _windowService: IWindowService,\n\t\t@IBroadcastService private readonly _broadcastService: IBroadcastService,\n\t\t@ILifecycleService private readonly _lifecycleService: ILifecycleService,\n\t\t@IEnvironmentService private readonly _environmentService: IEnvironmentService,\n\t\t@ITelemetryService private readonly _telemetryService: ITelemetryService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@ILabelService private readonly _labelService: ILabelService\n\t) {\n\t\tconst devOpts = parseExtensionDevOptions(this._environmentService);\n\t\tthis._isExtensionDevHost = devOpts.isExtensionDevHost;\n\t\tthis._isExtensionDevDebug = devOpts.isExtensionDevDebug;\n\t\tthis._isExtensionDevDebugBrk = devOpts.isExtensionDevDebugBrk;\n\t\tthis._isExtensionDevTestFromCli = devOpts.isExtensionDevTestFromCli;\n\n\t\tthis._lastExtensionHostError = null;\n\t\tthis._terminating = false;\n\n\t\tthis._namedPipeServer = null;\n\t\tthis._extensionHostProcess = null;\n\t\tthis._extensionHostConnection = null;\n\t\tthis._messageProtocol = null;\n\n\t\tthis._toDispose = [];\n\t\tthis._toDispose.push(this._onCrashed);\n\t\tthis._toDispose.push(this._lifecycleService.onWillShutdown(e => this._onWillShutdown(e)));\n\t\tthis._toDispose.push(this._lifecycleService.onShutdown(reason => this.terminate()));\n\t\tthis._toDispose.push(this._broadcastService.onBroadcast(b => this._onBroadcast(b)));\n\n\t\tconst globalExitListener = () => this.terminate();\n\t\tprocess.once('exit', globalExitListener);\n\t\tthis._toDispose.push(toDisposable(() => {\n\t\t\tprocess.removeListener('exit', globalExitListener);\n\t\t}));\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.terminate();\n\t}\n\n\tprivate _onBroadcast(broadcast: IBroadcast): void {\n\n\t\t// Close Ext Host Window Request\n\t\tif (broadcast.channel === EXTENSION_CLOSE_EXTHOST_BROADCAST_CHANNEL && this._isExtensionDevHost) {\n\t\t\tconst extensionLocations = broadcast.payload as string[];\n\t\t\tif (Array.isArray(extensionLocations) && extensionLocations.some(uriString => isEqual(this._environmentService.extensionDevelopmentLocationURI, URI.parse(uriString)))) {\n\t\t\t\tthis._windowService.closeWindow();\n\t\t\t}\n\t\t}\n\n\t\tif (broadcast.channel === EXTENSION_RELOAD_BROADCAST_CHANNEL && this._isExtensionDevHost) {\n\t\t\tconst extensionPaths = broadcast.payload as string[];\n\t\t\tif (Array.isArray(extensionPaths) && extensionPaths.some(uriString => isEqual(this._environmentService.extensionDevelopmentLocationURI, URI.parse(uriString)))) {\n\t\t\t\tthis._windowService.reloadWindow();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic start(): Promise<IMessagePassingProtocol> | null {\n\t\tif (this._terminating) {\n\t\t\t// .terminate() was called\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!this._messageProtocol) {\n\t\t\tthis._messageProtocol = Promise.all([this._tryListenOnPipe(), this._tryFindDebugPort()]).then(data => {\n\t\t\t\tconst pipeName = data[0];\n\t\t\t\tconst portData = data[1];\n\n\t\t\t\tconst opts = {\n\t\t\t\t\tenv: objects.mixin(objects.deepClone(process.env), {\n\t\t\t\t\t\tAMD_ENTRYPOINT: 'vs/workbench/services/extensions/node/extensionHostProcess',\n\t\t\t\t\t\tPIPE_LOGGING: 'true',\n\t\t\t\t\t\tVERBOSE_LOGGING: true,\n\t\t\t\t\t\tVSCODE_IPC_HOOK_EXTHOST: pipeName,\n\t\t\t\t\t\tVSCODE_HANDLES_UNCAUGHT_ERRORS: true,\n\t\t\t\t\t\tVSCODE_LOG_STACK: !this._isExtensionDevTestFromCli && (this._isExtensionDevHost || !this._environmentService.isBuilt || product.quality !== 'stable' || this._environmentService.verbose),\n\t\t\t\t\t\tVSCODE_LOG_LEVEL: this._environmentService.verbose ? 'trace' : this._environmentService.log\n\t\t\t\t\t}),\n\t\t\t\t\t// We only detach the extension host on windows. Linux and Mac orphan by default\n\t\t\t\t\t// and detach under Linux and Mac create another process group.\n\t\t\t\t\t// We detach because we have noticed that when the renderer exits, its child processes\n\t\t\t\t\t// (i.e. extension host) are taken down in a brutal fashion by the OS\n\t\t\t\t\tdetached: !!isWindows,\n\t\t\t\t\texecArgv: undefined as string[] | undefined,\n\t\t\t\t\tsilent: true\n\t\t\t\t};\n\n\t\t\t\tif (portData.actual) {\n\t\t\t\t\topts.execArgv = [\n\t\t\t\t\t\t'--nolazy',\n\t\t\t\t\t\t(this._isExtensionDevDebugBrk ? '--inspect-brk=' : '--inspect=') + portData.actual\n\t\t\t\t\t];\n\t\t\t\t\tif (!portData.expected) {\n\t\t\t\t\t\t// No one asked for 'inspect' or 'inspect-brk', only us. We add another\n\t\t\t\t\t\t// option such that the extension host can manipulate the execArgv array\n\t\t\t\t\t\topts.env.VSCODE_PREVENT_FOREIGN_INSPECT = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst crashReporterOptions = undefined; // TODO@electron pass this in as options to the extension host after verifying this actually works\n\t\t\t\tif (crashReporterOptions) {\n\t\t\t\t\topts.env.CRASH_REPORTER_START_OPTIONS = JSON.stringify(crashReporterOptions);\n\t\t\t\t}\n\n\t\t\t\t// Run Extension Host as fork of current process\n\t\t\t\tthis._extensionHostProcess = fork(getPathFromAmdModule(require, 'bootstrap-fork'), ['--type=extensionHost'], opts);\n\n\t\t\t\t// Catch all output coming from the extension host process\n\t\t\t\ttype Output = { data: string, format: string[] };\n\t\t\t\tthis._extensionHostProcess.stdout.setEncoding('utf8');\n\t\t\t\tthis._extensionHostProcess.stderr.setEncoding('utf8');\n\t\t\t\tconst onStdout = Event.fromNodeEventEmitter<string>(this._extensionHostProcess.stdout, 'data');\n\t\t\t\tconst onStderr = Event.fromNodeEventEmitter<string>(this._extensionHostProcess.stderr, 'data');\n\t\t\t\tconst onOutput = Event.any(\n\t\t\t\t\tEvent.map(onStdout, o => ({ data: `%c${o}`, format: [''] })),\n\t\t\t\t\tEvent.map(onStderr, o => ({ data: `%c${o}`, format: ['color: red'] }))\n\t\t\t\t);\n\n\t\t\t\t// Debounce all output, so we can render it in the Chrome console as a group\n\t\t\t\tconst onDebouncedOutput = Event.debounce<Output>(onOutput, (r, o) => {\n\t\t\t\t\treturn r\n\t\t\t\t\t\t? { data: r.data + o.data, format: [...r.format, ...o.format] }\n\t\t\t\t\t\t: { data: o.data, format: o.format };\n\t\t\t\t}, 100);\n\n\t\t\t\t// Print out extension host output\n\t\t\t\tonDebouncedOutput(output => {\n\t\t\t\t\tconst inspectorUrlMatch = output.data && output.data.match(/ws:\\/\\/([^\\s]+:(\\d+)\\/[^\\s]+)/);\n\t\t\t\t\tif (inspectorUrlMatch) {\n\t\t\t\t\t\tif (!this._environmentService.isBuilt) {\n\t\t\t\t\t\t\tconsole.log(`%c[Extension Host] %cdebugger inspector at chrome-devtools://devtools/bundled/inspector.html?experiments=true&v8only=true&ws=${inspectorUrlMatch[1]}`, 'color: blue', 'color: black');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!this._inspectPort) {\n\t\t\t\t\t\t\tthis._inspectPort = Number(inspectorUrlMatch[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.group('Extension Host');\n\t\t\t\t\t\tconsole.log(output.data, ...output.format);\n\t\t\t\t\t\tconsole.groupEnd();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Support logging from extension host\n\t\t\t\tthis._extensionHostProcess.on('message', msg => {\n\t\t\t\t\tif (msg && (<IRemoteConsoleLog>msg).type === '__$console') {\n\t\t\t\t\t\tthis._logExtensionHostMessage(<IRemoteConsoleLog>msg);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Lifecycle\n\t\t\t\tthis._extensionHostProcess.on('error', (err) => this._onExtHostProcessError(err));\n\t\t\t\tthis._extensionHostProcess.on('exit', (code: number, signal: string) => this._onExtHostProcessExit(code, signal));\n\n\t\t\t\t// Notify debugger that we are ready to attach to the process if we run a development extension\n\t\t\t\tif (this._isExtensionDevHost && portData.actual && this._isExtensionDevDebug) {\n\t\t\t\t\tthis._broadcastService.broadcast({\n\t\t\t\t\t\tchannel: EXTENSION_ATTACH_BROADCAST_CHANNEL,\n\t\t\t\t\t\tpayload: {\n\t\t\t\t\t\t\tdebugId: this._environmentService.debugExtensionHost.debugId,\n\t\t\t\t\t\t\tport: portData.actual\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tthis._inspectPort = portData.actual;\n\n\t\t\t\t// Help in case we fail to start it\n\t\t\t\tlet startupTimeoutHandle: any;\n\t\t\t\tif (!this._environmentService.isBuilt && !this._windowService.getConfiguration().remoteAuthority || this._isExtensionDevHost) {\n\t\t\t\t\tstartupTimeoutHandle = setTimeout(() => {\n\t\t\t\t\t\tconst msg = this._isExtensionDevDebugBrk\n\t\t\t\t\t\t\t? nls.localize('extensionHostProcess.startupFailDebug', \"Extension host did not start in 10 seconds, it might be stopped on the first line and needs a debugger to continue.\")\n\t\t\t\t\t\t\t: nls.localize('extensionHostProcess.startupFail', \"Extension host did not start in 10 seconds, that might be a problem.\");\n\n\t\t\t\t\t\tthis._notificationService.prompt(Severity.Warning, msg,\n\t\t\t\t\t\t\t[{\n\t\t\t\t\t\t\t\tlabel: nls.localize('reloadWindow', \"Reload Window\"),\n\t\t\t\t\t\t\t\trun: () => this._windowService.reloadWindow()\n\t\t\t\t\t\t\t}],\n\t\t\t\t\t\t\t{ sticky: true }\n\t\t\t\t\t\t);\n\t\t\t\t\t}, 10000);\n\t\t\t\t}\n\n\t\t\t\t// Initialize extension host process with hand shakes\n\t\t\t\treturn this._tryExtHostHandshake().then((protocol) => {\n\t\t\t\t\tclearTimeout(startupTimeoutHandle);\n\t\t\t\t\treturn protocol;\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\treturn this._messageProtocol;\n\t}\n\n\t/**\n\t * Start a server (`this._namedPipeServer`) that listens on a named pipe and return the named pipe name.\n\t */\n\tprivate _tryListenOnPipe(): Promise<string> {\n\t\treturn new Promise<string>((resolve, reject) => {\n\t\t\tconst pipeName = generateRandomPipeName();\n\n\t\t\tthis._namedPipeServer = createServer();\n\t\t\tthis._namedPipeServer.on('error', reject);\n\t\t\tthis._namedPipeServer.listen(pipeName, () => {\n\t\t\t\tif (this._namedPipeServer) {\n\t\t\t\t\tthis._namedPipeServer.removeListener('error', reject);\n\t\t\t\t}\n\t\t\t\tresolve(pipeName);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Find a free port if extension host debugging is enabled.\n\t */\n\tprivate _tryFindDebugPort(): Promise<{ expected: number; actual: number }> {\n\t\tlet expected: number;\n\t\tlet startPort = randomPort();\n\t\tif (typeof this._environmentService.debugExtensionHost.port === 'number') {\n\t\t\tstartPort = expected = this._environmentService.debugExtensionHost.port;\n\t\t}\n\t\treturn new Promise(resolve => {\n\t\t\treturn findFreePort(startPort, 10 /* try 10 ports */, 5000 /* try up to 5 seconds */).then(port => {\n\t\t\t\tif (!port) {\n\t\t\t\t\tconsole.warn('%c[Extension Host] %cCould not find a free port for debugging', 'color: blue', 'color: black');\n\t\t\t\t} else {\n\t\t\t\t\tif (expected && port !== expected) {\n\t\t\t\t\t\tconsole.warn(`%c[Extension Host] %cProvided debugging port ${expected} is not free, using ${port} instead.`, 'color: blue', 'color: black');\n\t\t\t\t\t}\n\t\t\t\t\tif (this._isExtensionDevDebugBrk) {\n\t\t\t\t\t\tconsole.warn(`%c[Extension Host] %cSTOPPED on first line for debugging on port ${port}`, 'color: blue', 'color: black');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.info(`%c[Extension Host] %cdebugger listening on port ${port}`, 'color: blue', 'color: black');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn resolve({ expected, actual: port });\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate _tryExtHostHandshake(): Promise<PersistentProtocol> {\n\n\t\treturn new Promise<PersistentProtocol>((resolve, reject) => {\n\n\t\t\t// Wait for the extension host to connect to our named pipe\n\t\t\t// and wrap the socket in the message passing protocol\n\t\t\tlet handle = setTimeout(() => {\n\t\t\t\tif (this._namedPipeServer) {\n\t\t\t\t\tthis._namedPipeServer.close();\n\t\t\t\t\tthis._namedPipeServer = null;\n\t\t\t\t}\n\t\t\t\treject('timeout');\n\t\t\t}, 60 * 1000);\n\n\t\t\tthis._namedPipeServer!.on('connection', socket => {\n\t\t\t\tclearTimeout(handle);\n\t\t\t\tif (this._namedPipeServer) {\n\t\t\t\t\tthis._namedPipeServer.close();\n\t\t\t\t\tthis._namedPipeServer = null;\n\t\t\t\t}\n\t\t\t\tthis._extensionHostConnection = socket;\n\n\t\t\t\t// using a buffered message protocol here because between now\n\t\t\t\t// and the first time a `then` executes some messages might be lost\n\t\t\t\t// unless we immediately register a listener for `onMessage`.\n\t\t\t\tresolve(new PersistentProtocol(new NodeSocket(this._extensionHostConnection)));\n\t\t\t});\n\n\t\t}).then((protocol) => {\n\n\t\t\t// 1) wait for the incoming `ready` event and send the initialization data.\n\t\t\t// 2) wait for the incoming `initialized` event.\n\t\t\treturn new Promise<PersistentProtocol>((resolve, reject) => {\n\n\t\t\t\tlet timeoutHandle: NodeJS.Timer;\n\t\t\t\tconst installTimeoutCheck = () => {\n\t\t\t\t\ttimeoutHandle = setTimeout(() => {\n\t\t\t\t\t\treject('timeout');\n\t\t\t\t\t}, 60 * 1000);\n\t\t\t\t};\n\t\t\t\tconst uninstallTimeoutCheck = () => {\n\t\t\t\t\tclearTimeout(timeoutHandle);\n\t\t\t\t};\n\n\t\t\t\t// Wait 60s for the ready message\n\t\t\t\tinstallTimeoutCheck();\n\n\t\t\t\tconst disposable = protocol.onMessage(msg => {\n\n\t\t\t\t\tif (isMessageOfType(msg, MessageType.Ready)) {\n\t\t\t\t\t\t// 1) Extension Host is ready to receive messages, initialize it\n\t\t\t\t\t\tuninstallTimeoutCheck();\n\n\t\t\t\t\t\tthis._createExtHostInitData().then(data => {\n\n\t\t\t\t\t\t\t// Wait 60s for the initialized message\n\t\t\t\t\t\t\tinstallTimeoutCheck();\n\n\t\t\t\t\t\t\tprotocol.send(VSBuffer.fromString(JSON.stringify(data)));\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isMessageOfType(msg, MessageType.Initialized)) {\n\t\t\t\t\t\t// 2) Extension Host is initialized\n\t\t\t\t\t\tuninstallTimeoutCheck();\n\n\t\t\t\t\t\t// stop listening for messages here\n\t\t\t\t\t\tdisposable.dispose();\n\n\t\t\t\t\t\t// release this promise\n\t\t\t\t\t\tresolve(protocol);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.error(`received unexpected message during handshake phase from the extension host: `, msg);\n\t\t\t\t});\n\n\t\t\t});\n\n\t\t});\n\t}\n\n\tprivate _createExtHostInitData(): Promise<IInitData> {\n\t\treturn Promise.all([this._telemetryService.getTelemetryInfo(), this._extensions])\n\t\t\t.then(([telemetryInfo, extensionDescriptions]) => {\n\t\t\t\tconst workspace = this._contextService.getWorkspace();\n\t\t\t\tconst r: IInitData = {\n\t\t\t\t\tcommit: product.commit,\n\t\t\t\t\tparentPid: process.pid,\n\t\t\t\t\tenvironment: {\n\t\t\t\t\t\tisExtensionDevelopmentDebug: this._isExtensionDevDebug,\n\t\t\t\t\t\tappRoot: this._environmentService.appRoot ? URI.file(this._environmentService.appRoot) : undefined,\n\t\t\t\t\t\tappSettingsHome: this._environmentService.appSettingsHome ? URI.file(this._environmentService.appSettingsHome) : undefined,\n\t\t\t\t\t\textensionDevelopmentLocationURI: this._environmentService.extensionDevelopmentLocationURI,\n\t\t\t\t\t\textensionTestsLocationURI: this._environmentService.extensionTestsLocationURI,\n\t\t\t\t\t\tglobalStorageHome: URI.file(this._environmentService.globalStorageHome),\n\t\t\t\t\t\tuserHome: URI.file(this._environmentService.userHome)\n\t\t\t\t\t},\n\t\t\t\t\tworkspace: this._contextService.getWorkbenchState() === WorkbenchState.EMPTY ? undefined : {\n\t\t\t\t\t\tconfiguration: withNullAsUndefined(workspace.configuration),\n\t\t\t\t\t\tid: workspace.id,\n\t\t\t\t\t\tname: this._labelService.getWorkspaceLabel(workspace)\n\t\t\t\t\t},\n\t\t\t\t\tresolvedExtensions: [],\n\t\t\t\t\thostExtensions: [],\n\t\t\t\t\textensions: extensionDescriptions,\n\t\t\t\t\ttelemetryInfo,\n\t\t\t\t\tlogLevel: this._logService.getLevel(),\n\t\t\t\t\tlogsLocation: this._extensionHostLogsLocation,\n\t\t\t\t\tautoStart: this._autoStart\n\t\t\t\t};\n\t\t\t\treturn r;\n\t\t\t});\n\t}\n\n\tprivate _logExtensionHostMessage(entry: IRemoteConsoleLog) {\n\n\t\t// Send to local console unless we run tests from cli\n\t\tif (!this._isExtensionDevTestFromCli) {\n\t\t\tlog(entry, 'Extension Host');\n\t\t}\n\n\t\t// Log on main side if running tests from cli\n\t\tif (this._isExtensionDevTestFromCli) {\n\t\t\tthis._windowsService.log(entry.severity, ...parse(entry).args);\n\t\t}\n\n\t\t// Broadcast to other windows if we are in development mode\n\t\telse if (!this._environmentService.isBuilt || this._isExtensionDevHost) {\n\t\t\tthis._broadcastService.broadcast({\n\t\t\t\tchannel: EXTENSION_LOG_BROADCAST_CHANNEL,\n\t\t\t\tpayload: {\n\t\t\t\t\tlogEntry: entry,\n\t\t\t\t\tdebugId: this._environmentService.debugExtensionHost.debugId\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate _onExtHostProcessError(err: any): void {\n\t\tlet errorMessage = toErrorMessage(err);\n\t\tif (errorMessage === this._lastExtensionHostError) {\n\t\t\treturn; // prevent error spam\n\t\t}\n\n\t\tthis._lastExtensionHostError = errorMessage;\n\n\t\tthis._notificationService.error(nls.localize('extensionHostProcess.error', \"Error from the extension host: {0}\", errorMessage));\n\t}\n\n\tprivate _onExtHostProcessExit(code: number, signal: string): void {\n\t\tif (this._terminating) {\n\t\t\t// Expected termination path (we asked the process to terminate)\n\t\t\treturn;\n\t\t}\n\n\t\t// Unexpected termination\n\t\tif (!this._isExtensionDevHost) {\n\t\t\tthis._onCrashed.fire([code, signal]);\n\t\t}\n\n\t\t// Expected development extension termination: When the extension host goes down we also shutdown the window\n\t\telse if (!this._isExtensionDevTestFromCli) {\n\t\t\tthis._windowService.closeWindow();\n\t\t}\n\n\t\t// When CLI testing make sure to exit with proper exit code\n\t\telse {\n\t\t\tipc.send('vscode:exit', code);\n\t\t}\n\t}\n\n\tpublic enableInspector(): Promise<void> {\n\t\tif (this._inspectPort) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\t// send SIGUSR1 and wait a little the actual port is read from the process stdout which we\n\t\t// scan here: https://github.com/Microsoft/vscode/blob/67ffab8dcd1a6752d8b62bcd13d7020101eef568/src/vs/workbench/services/extensions/electron-browser/extensionHost.ts#L225-L240\n\t\tif (this._extensionHostProcess) {\n\t\t\tthis._extensionHostProcess.kill('SIGUSR1');\n\t\t}\n\t\treturn timeout(1000);\n\t}\n\n\tpublic getInspectPort(): number {\n\t\treturn this._inspectPort;\n\t}\n\n\tpublic terminate(): void {\n\t\tif (this._terminating) {\n\t\t\treturn;\n\t\t}\n\t\tthis._terminating = true;\n\n\t\tdispose(this._toDispose);\n\n\t\tif (!this._messageProtocol) {\n\t\t\t// .start() was not called\n\t\t\treturn;\n\t\t}\n\n\t\tthis._messageProtocol.then((protocol) => {\n\n\t\t\t// Send the extension host a request to terminate itself\n\t\t\t// (graceful termination)\n\t\t\tprotocol.send(createMessageOfType(MessageType.Terminate));\n\n\t\t\tprotocol.dispose();\n\n\t\t\t// Give the extension host 10s, after which we will\n\t\t\t// try to kill the process and release any resources\n\t\t\tsetTimeout(() => this._cleanResources(), 10 * 1000);\n\n\t\t}, (err) => {\n\n\t\t\t// Establishing a protocol with the extension host failed, so\n\t\t\t// try to kill the process and release any resources.\n\t\t\tthis._cleanResources();\n\t\t});\n\t}\n\n\tprivate _cleanResources(): void {\n\t\tif (this._namedPipeServer) {\n\t\t\tthis._namedPipeServer.close();\n\t\t\tthis._namedPipeServer = null;\n\t\t}\n\t\tif (this._extensionHostConnection) {\n\t\t\tthis._extensionHostConnection.end();\n\t\t\tthis._extensionHostConnection = null;\n\t\t}\n\t\tif (this._extensionHostProcess) {\n\t\t\tthis._extensionHostProcess.kill();\n\t\t\tthis._extensionHostProcess = null;\n\t\t}\n\t}\n\n\tprivate _onWillShutdown(event: WillShutdownEvent): void {\n\n\t\t// If the extension development host was started without debugger attached we need\n\t\t// to communicate this back to the main side to terminate the debug session\n\t\tif (this._isExtensionDevHost && !this._isExtensionDevTestFromCli && !this._isExtensionDevDebug) {\n\t\t\tthis._broadcastService.broadcast({\n\t\t\t\tchannel: EXTENSION_TERMINATE_BROADCAST_CHANNEL,\n\t\t\t\tpayload: {\n\t\t\t\t\tdebugId: this._environmentService.debugExtensionHost.debugId\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tevent.join(timeout(100 /* wait a bit for IPC to get delivered */));\n\t\t}\n\t}\n}\n"]}]}