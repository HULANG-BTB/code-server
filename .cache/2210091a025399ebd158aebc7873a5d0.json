{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/whitespaceComputer.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/whitespaceComputer.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Represent whitespaces in between lines and provide fast CRUD management methods.\n * The whitespaces are sorted ascending by `afterLineNumber`.\n */\nvar WhitespaceComputer = /** @class */ (function () {\n    function WhitespaceComputer() {\n        this._heights = [];\n        this._minWidths = [];\n        this._ids = [];\n        this._afterLineNumbers = [];\n        this._ordinals = [];\n        this._prefixSum = [];\n        this._prefixSumValidIndex = -1;\n        this._whitespaceId2Index = {};\n        this._lastWhitespaceId = 0;\n        this._minWidth = -1; /* marker for not being computed */\n    }\n    /**\n     * Find the insertion index for a new value inside a sorted array of values.\n     * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n     */\n    WhitespaceComputer.findInsertionIndex = function (sortedArray, value, ordinals, valueOrdinal) {\n        var low = 0;\n        var high = sortedArray.length;\n        while (low < high) {\n            var mid = ((low + high) >>> 1);\n            if (value === sortedArray[mid]) {\n                if (valueOrdinal < ordinals[mid]) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            else if (value < sortedArray[mid]) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    };\n    /**\n     * Insert a new whitespace of a certain height after a line number.\n     * The whitespace has a \"sticky\" characteristic.\n     * Irrespective of edits above or below `afterLineNumber`, the whitespace will follow the initial line.\n     *\n     * @param afterLineNumber The conceptual position of this whitespace. The whitespace will follow this line as best as possible even when deleting/inserting lines above/below.\n     * @param heightInPx The height of the whitespace, in pixels.\n     * @return An id that can be used later to mutate or delete the whitespace\n     */\n    WhitespaceComputer.prototype.insertWhitespace = function (afterLineNumber, ordinal, heightInPx, minWidth) {\n        afterLineNumber = afterLineNumber | 0;\n        ordinal = ordinal | 0;\n        heightInPx = heightInPx | 0;\n        minWidth = minWidth | 0;\n        var id = (++this._lastWhitespaceId);\n        var insertionIndex = WhitespaceComputer.findInsertionIndex(this._afterLineNumbers, afterLineNumber, this._ordinals, ordinal);\n        this._insertWhitespaceAtIndex(id, insertionIndex, afterLineNumber, ordinal, heightInPx, minWidth);\n        this._minWidth = -1; /* marker for not being computed */\n        return id;\n    };\n    WhitespaceComputer.prototype._insertWhitespaceAtIndex = function (id, insertIndex, afterLineNumber, ordinal, heightInPx, minWidth) {\n        id = id | 0;\n        insertIndex = insertIndex | 0;\n        afterLineNumber = afterLineNumber | 0;\n        ordinal = ordinal | 0;\n        heightInPx = heightInPx | 0;\n        minWidth = minWidth | 0;\n        this._heights.splice(insertIndex, 0, heightInPx);\n        this._minWidths.splice(insertIndex, 0, minWidth);\n        this._ids.splice(insertIndex, 0, id);\n        this._afterLineNumbers.splice(insertIndex, 0, afterLineNumber);\n        this._ordinals.splice(insertIndex, 0, ordinal);\n        this._prefixSum.splice(insertIndex, 0, 0);\n        var keys = Object.keys(this._whitespaceId2Index);\n        for (var i = 0, len = keys.length; i < len; i++) {\n            var sid = keys[i];\n            var oldIndex = this._whitespaceId2Index[sid];\n            if (oldIndex >= insertIndex) {\n                this._whitespaceId2Index[sid] = oldIndex + 1;\n            }\n        }\n        this._whitespaceId2Index[id.toString()] = insertIndex;\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n    };\n    /**\n     * Change properties associated with a certain whitespace.\n     */\n    WhitespaceComputer.prototype.changeWhitespace = function (id, newAfterLineNumber, newHeight) {\n        id = id | 0;\n        newAfterLineNumber = newAfterLineNumber | 0;\n        newHeight = newHeight | 0;\n        var hasChanges = false;\n        hasChanges = this.changeWhitespaceHeight(id, newHeight) || hasChanges;\n        hasChanges = this.changeWhitespaceAfterLineNumber(id, newAfterLineNumber) || hasChanges;\n        return hasChanges;\n    };\n    /**\n     * Change the height of an existing whitespace\n     *\n     * @param id The whitespace to change\n     * @param newHeightInPx The new height of the whitespace, in pixels\n     * @return Returns true if the whitespace is found and if the new height is different than the old height\n     */\n    WhitespaceComputer.prototype.changeWhitespaceHeight = function (id, newHeightInPx) {\n        id = id | 0;\n        newHeightInPx = newHeightInPx | 0;\n        var sid = id.toString();\n        if (this._whitespaceId2Index.hasOwnProperty(sid)) {\n            var index = this._whitespaceId2Index[sid];\n            if (this._heights[index] !== newHeightInPx) {\n                this._heights[index] = newHeightInPx;\n                this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Change the line number after which an existing whitespace flows.\n     *\n     * @param id The whitespace to change\n     * @param newAfterLineNumber The new line number the whitespace will follow\n     * @return Returns true if the whitespace is found and if the new line number is different than the old line number\n     */\n    WhitespaceComputer.prototype.changeWhitespaceAfterLineNumber = function (id, newAfterLineNumber) {\n        id = id | 0;\n        newAfterLineNumber = newAfterLineNumber | 0;\n        var sid = id.toString();\n        if (this._whitespaceId2Index.hasOwnProperty(sid)) {\n            var index = this._whitespaceId2Index[sid];\n            if (this._afterLineNumbers[index] !== newAfterLineNumber) {\n                // `afterLineNumber` changed for this whitespace\n                // Record old ordinal\n                var ordinal = this._ordinals[index];\n                // Record old height\n                var heightInPx = this._heights[index];\n                // Record old min width\n                var minWidth = this._minWidths[index];\n                // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n                this.removeWhitespace(id);\n                // And add it again\n                var insertionIndex = WhitespaceComputer.findInsertionIndex(this._afterLineNumbers, newAfterLineNumber, this._ordinals, ordinal);\n                this._insertWhitespaceAtIndex(id, insertionIndex, newAfterLineNumber, ordinal, heightInPx, minWidth);\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Remove an existing whitespace.\n     *\n     * @param id The whitespace to remove\n     * @return Returns true if the whitespace is found and it is removed.\n     */\n    WhitespaceComputer.prototype.removeWhitespace = function (id) {\n        id = id | 0;\n        var sid = id.toString();\n        if (this._whitespaceId2Index.hasOwnProperty(sid)) {\n            var index = this._whitespaceId2Index[sid];\n            delete this._whitespaceId2Index[sid];\n            this._removeWhitespaceAtIndex(index);\n            this._minWidth = -1; /* marker for not being computed */\n            return true;\n        }\n        return false;\n    };\n    WhitespaceComputer.prototype._removeWhitespaceAtIndex = function (removeIndex) {\n        removeIndex = removeIndex | 0;\n        this._heights.splice(removeIndex, 1);\n        this._minWidths.splice(removeIndex, 1);\n        this._ids.splice(removeIndex, 1);\n        this._afterLineNumbers.splice(removeIndex, 1);\n        this._ordinals.splice(removeIndex, 1);\n        this._prefixSum.splice(removeIndex, 1);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n        var keys = Object.keys(this._whitespaceId2Index);\n        for (var i = 0, len = keys.length; i < len; i++) {\n            var sid = keys[i];\n            var oldIndex = this._whitespaceId2Index[sid];\n            if (oldIndex >= removeIndex) {\n                this._whitespaceId2Index[sid] = oldIndex - 1;\n            }\n        }\n    };\n    /**\n     * Notify the computer that lines have been deleted (a continuous zone of lines).\n     * This gives it a chance to update `afterLineNumber` for whitespaces, giving the \"sticky\" characteristic.\n     *\n     * @param fromLineNumber The line number at which the deletion started, inclusive\n     * @param toLineNumber The line number at which the deletion ended, inclusive\n     */\n    WhitespaceComputer.prototype.onLinesDeleted = function (fromLineNumber, toLineNumber) {\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        for (var i = 0, len = this._afterLineNumbers.length; i < len; i++) {\n            var afterLineNumber = this._afterLineNumbers[i];\n            if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n                // The line this whitespace was after has been deleted\n                //  => move whitespace to before first deleted line\n                this._afterLineNumbers[i] = fromLineNumber - 1;\n            }\n            else if (afterLineNumber > toLineNumber) {\n                // The line this whitespace was after has been moved up\n                //  => move whitespace up\n                this._afterLineNumbers[i] -= (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    };\n    /**\n     * Notify the computer that lines have been inserted (a continuous zone of lines).\n     * This gives it a chance to update `afterLineNumber` for whitespaces, giving the \"sticky\" characteristic.\n     *\n     * @param fromLineNumber The line number at which the insertion started, inclusive\n     * @param toLineNumber The line number at which the insertion ended, inclusive.\n     */\n    WhitespaceComputer.prototype.onLinesInserted = function (fromLineNumber, toLineNumber) {\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        for (var i = 0, len = this._afterLineNumbers.length; i < len; i++) {\n            var afterLineNumber = this._afterLineNumbers[i];\n            if (fromLineNumber <= afterLineNumber) {\n                this._afterLineNumbers[i] += (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    };\n    /**\n     * Get the sum of all the whitespaces.\n     */\n    WhitespaceComputer.prototype.getTotalHeight = function () {\n        if (this._heights.length === 0) {\n            return 0;\n        }\n        return this.getAccumulatedHeight(this._heights.length - 1);\n    };\n    /**\n     * Return the sum of the heights of the whitespaces at [0..index].\n     * This includes the whitespace at `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n     */\n    WhitespaceComputer.prototype.getAccumulatedHeight = function (index) {\n        index = index | 0;\n        var startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n        if (startIndex === 0) {\n            this._prefixSum[0] = this._heights[0];\n            startIndex++;\n        }\n        for (var i = startIndex; i <= index; i++) {\n            this._prefixSum[i] = this._prefixSum[i - 1] + this._heights[i];\n        }\n        this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n        return this._prefixSum[index];\n    };\n    /**\n     * Find all whitespaces with `afterLineNumber` < `lineNumber` and return the sum of their heights.\n     *\n     * @param lineNumber The line number whitespaces should be before.\n     * @return The sum of the heights of the whitespaces before `lineNumber`.\n     */\n    WhitespaceComputer.prototype.getAccumulatedHeightBeforeLineNumber = function (lineNumber) {\n        lineNumber = lineNumber | 0;\n        var lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        if (lastWhitespaceBeforeLineNumber === -1) {\n            return 0;\n        }\n        return this.getAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n    };\n    WhitespaceComputer.prototype._findLastWhitespaceBeforeLineNumber = function (lineNumber) {\n        lineNumber = lineNumber | 0;\n        // Find the whitespace before line number\n        var afterLineNumbers = this._afterLineNumbers;\n        var low = 0;\n        var high = afterLineNumbers.length - 1;\n        while (low <= high) {\n            var delta = (high - low) | 0;\n            var halfDelta = (delta / 2) | 0;\n            var mid = (low + halfDelta) | 0;\n            if (afterLineNumbers[mid] < lineNumber) {\n                if (mid + 1 >= afterLineNumbers.length || afterLineNumbers[mid + 1] >= lineNumber) {\n                    return mid;\n                }\n                else {\n                    low = (mid + 1) | 0;\n                }\n            }\n            else {\n                high = (mid - 1) | 0;\n            }\n        }\n        return -1;\n    };\n    WhitespaceComputer.prototype._findFirstWhitespaceAfterLineNumber = function (lineNumber) {\n        lineNumber = lineNumber | 0;\n        var lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        var firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n        if (firstWhitespaceAfterLineNumber < this._heights.length) {\n            return firstWhitespaceAfterLineNumber;\n        }\n        return -1;\n    };\n    /**\n     * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n     * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n     */\n    WhitespaceComputer.prototype.getFirstWhitespaceIndexAfterLineNumber = function (lineNumber) {\n        lineNumber = lineNumber | 0;\n        return this._findFirstWhitespaceAfterLineNumber(lineNumber);\n    };\n    /**\n     * The number of whitespaces.\n     */\n    WhitespaceComputer.prototype.getCount = function () {\n        return this._heights.length;\n    };\n    /**\n     * The maximum min width for all whitespaces.\n     */\n    WhitespaceComputer.prototype.getMinWidth = function () {\n        if (this._minWidth === -1) {\n            var minWidth = 0;\n            for (var i = 0, len = this._minWidths.length; i < len; i++) {\n                minWidth = Math.max(minWidth, this._minWidths[i]);\n            }\n            this._minWidth = minWidth;\n        }\n        return this._minWidth;\n    };\n    /**\n     * Get the `afterLineNumber` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `afterLineNumber` of whitespace at `index`.\n     */\n    WhitespaceComputer.prototype.getAfterLineNumberForWhitespaceIndex = function (index) {\n        index = index | 0;\n        return this._afterLineNumbers[index];\n    };\n    /**\n     * Get the `id` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `id` of whitespace at `index`.\n     */\n    WhitespaceComputer.prototype.getIdForWhitespaceIndex = function (index) {\n        index = index | 0;\n        return this._ids[index];\n    };\n    /**\n     * Get the `height` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `height` of whitespace at `index`.\n     */\n    WhitespaceComputer.prototype.getHeightForWhitespaceIndex = function (index) {\n        index = index | 0;\n        return this._heights[index];\n    };\n    /**\n     * Get all whitespaces.\n     */\n    WhitespaceComputer.prototype.getWhitespaces = function (deviceLineHeight) {\n        deviceLineHeight = deviceLineHeight | 0;\n        var result = [];\n        for (var i = 0; i < this._heights.length; i++) {\n            result.push({\n                id: this._ids[i],\n                afterLineNumber: this._afterLineNumbers[i],\n                heightInLines: this._heights[i] / deviceLineHeight\n            });\n        }\n        return result;\n    };\n    return WhitespaceComputer;\n}());\nexports.WhitespaceComputer = WhitespaceComputer;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/whitespaceComputer.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/whitespaceComputer.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface IEditorWhitespace {\n\treadonly id: number;\n\treadonly afterLineNumber: number;\n\treadonly heightInLines: number;\n}\n\n/**\n * Represent whitespaces in between lines and provide fast CRUD management methods.\n * The whitespaces are sorted ascending by `afterLineNumber`.\n */\nexport class WhitespaceComputer {\n\n\t/**\n\t * heights[i] is the height in pixels for whitespace at index i\n\t */\n\tprivate readonly _heights: number[];\n\n\t/**\n\t * minWidths[i] is the min width in pixels for whitespace at index i\n\t */\n\tprivate readonly _minWidths: number[];\n\n\t/**\n\t * afterLineNumbers[i] is the line number whitespace at index i is after\n\t */\n\tprivate readonly _afterLineNumbers: number[];\n\n\t/**\n\t * ordinals[i] is the orinal of the whitespace at index i\n\t */\n\tprivate readonly _ordinals: number[];\n\n\t/**\n\t * prefixSum[i] = SUM(heights[j]), 1 <= j <= i\n\t */\n\tprivate readonly _prefixSum: number[];\n\n\t/**\n\t * prefixSum[i], 1 <= i <= prefixSumValidIndex can be trusted\n\t */\n\tprivate _prefixSumValidIndex: number;\n\n\t/**\n\t * ids[i] is the whitespace id of whitespace at index i\n\t */\n\tprivate readonly _ids: number[];\n\n\t/**\n\t * index at which a whitespace is positioned (inside heights, afterLineNumbers, prefixSum members)\n\t */\n\tprivate readonly _whitespaceId2Index: {\n\t\t[id: string]: number;\n\t};\n\n\t/**\n\t * last whitespace id issued\n\t */\n\tprivate _lastWhitespaceId: number;\n\n\tprivate _minWidth: number;\n\n\tconstructor() {\n\t\tthis._heights = [];\n\t\tthis._minWidths = [];\n\t\tthis._ids = [];\n\t\tthis._afterLineNumbers = [];\n\t\tthis._ordinals = [];\n\t\tthis._prefixSum = [];\n\t\tthis._prefixSumValidIndex = -1;\n\t\tthis._whitespaceId2Index = {};\n\t\tthis._lastWhitespaceId = 0;\n\t\tthis._minWidth = -1; /* marker for not being computed */\n\t}\n\n\t/**\n\t * Find the insertion index for a new value inside a sorted array of values.\n\t * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n\t */\n\tpublic static findInsertionIndex(sortedArray: number[], value: number, ordinals: number[], valueOrdinal: number): number {\n\t\tlet low = 0;\n\t\tlet high = sortedArray.length;\n\n\t\twhile (low < high) {\n\t\t\tlet mid = ((low + high) >>> 1);\n\n\t\t\tif (value === sortedArray[mid]) {\n\t\t\t\tif (valueOrdinal < ordinals[mid]) {\n\t\t\t\t\thigh = mid;\n\t\t\t\t} else {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t}\n\t\t\t} else if (value < sortedArray[mid]) {\n\t\t\t\thigh = mid;\n\t\t\t} else {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n\t/**\n\t * Insert a new whitespace of a certain height after a line number.\n\t * The whitespace has a \"sticky\" characteristic.\n\t * Irrespective of edits above or below `afterLineNumber`, the whitespace will follow the initial line.\n\t *\n\t * @param afterLineNumber The conceptual position of this whitespace. The whitespace will follow this line as best as possible even when deleting/inserting lines above/below.\n\t * @param heightInPx The height of the whitespace, in pixels.\n\t * @return An id that can be used later to mutate or delete the whitespace\n\t */\n\tpublic insertWhitespace(afterLineNumber: number, ordinal: number, heightInPx: number, minWidth: number): number {\n\t\tafterLineNumber = afterLineNumber | 0;\n\t\tordinal = ordinal | 0;\n\t\theightInPx = heightInPx | 0;\n\t\tminWidth = minWidth | 0;\n\n\t\tlet id = (++this._lastWhitespaceId);\n\t\tlet insertionIndex = WhitespaceComputer.findInsertionIndex(this._afterLineNumbers, afterLineNumber, this._ordinals, ordinal);\n\t\tthis._insertWhitespaceAtIndex(id, insertionIndex, afterLineNumber, ordinal, heightInPx, minWidth);\n\t\tthis._minWidth = -1; /* marker for not being computed */\n\t\treturn id;\n\t}\n\n\tprivate _insertWhitespaceAtIndex(id: number, insertIndex: number, afterLineNumber: number, ordinal: number, heightInPx: number, minWidth: number): void {\n\t\tid = id | 0;\n\t\tinsertIndex = insertIndex | 0;\n\t\tafterLineNumber = afterLineNumber | 0;\n\t\tordinal = ordinal | 0;\n\t\theightInPx = heightInPx | 0;\n\t\tminWidth = minWidth | 0;\n\n\t\tthis._heights.splice(insertIndex, 0, heightInPx);\n\t\tthis._minWidths.splice(insertIndex, 0, minWidth);\n\t\tthis._ids.splice(insertIndex, 0, id);\n\t\tthis._afterLineNumbers.splice(insertIndex, 0, afterLineNumber);\n\t\tthis._ordinals.splice(insertIndex, 0, ordinal);\n\t\tthis._prefixSum.splice(insertIndex, 0, 0);\n\n\t\tlet keys = Object.keys(this._whitespaceId2Index);\n\t\tfor (let i = 0, len = keys.length; i < len; i++) {\n\t\t\tlet sid = keys[i];\n\t\t\tlet oldIndex = this._whitespaceId2Index[sid];\n\t\t\tif (oldIndex >= insertIndex) {\n\t\t\t\tthis._whitespaceId2Index[sid] = oldIndex + 1;\n\t\t\t}\n\t\t}\n\n\t\tthis._whitespaceId2Index[id.toString()] = insertIndex;\n\t\tthis._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n\t}\n\n\t/**\n\t * Change properties associated with a certain whitespace.\n\t */\n\tpublic changeWhitespace(id: number, newAfterLineNumber: number, newHeight: number): boolean {\n\t\tid = id | 0;\n\t\tnewAfterLineNumber = newAfterLineNumber | 0;\n\t\tnewHeight = newHeight | 0;\n\n\t\tlet hasChanges = false;\n\t\thasChanges = this.changeWhitespaceHeight(id, newHeight) || hasChanges;\n\t\thasChanges = this.changeWhitespaceAfterLineNumber(id, newAfterLineNumber) || hasChanges;\n\t\treturn hasChanges;\n\t}\n\n\t/**\n\t * Change the height of an existing whitespace\n\t *\n\t * @param id The whitespace to change\n\t * @param newHeightInPx The new height of the whitespace, in pixels\n\t * @return Returns true if the whitespace is found and if the new height is different than the old height\n\t */\n\tpublic changeWhitespaceHeight(id: number, newHeightInPx: number): boolean {\n\t\tid = id | 0;\n\t\tnewHeightInPx = newHeightInPx | 0;\n\n\t\tlet sid = id.toString();\n\t\tif (this._whitespaceId2Index.hasOwnProperty(sid)) {\n\t\t\tlet index = this._whitespaceId2Index[sid];\n\t\t\tif (this._heights[index] !== newHeightInPx) {\n\t\t\t\tthis._heights[index] = newHeightInPx;\n\t\t\t\tthis._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Change the line number after which an existing whitespace flows.\n\t *\n\t * @param id The whitespace to change\n\t * @param newAfterLineNumber The new line number the whitespace will follow\n\t * @return Returns true if the whitespace is found and if the new line number is different than the old line number\n\t */\n\tpublic changeWhitespaceAfterLineNumber(id: number, newAfterLineNumber: number): boolean {\n\t\tid = id | 0;\n\t\tnewAfterLineNumber = newAfterLineNumber | 0;\n\n\t\tlet sid = id.toString();\n\t\tif (this._whitespaceId2Index.hasOwnProperty(sid)) {\n\t\t\tlet index = this._whitespaceId2Index[sid];\n\t\t\tif (this._afterLineNumbers[index] !== newAfterLineNumber) {\n\t\t\t\t// `afterLineNumber` changed for this whitespace\n\n\t\t\t\t// Record old ordinal\n\t\t\t\tlet ordinal = this._ordinals[index];\n\n\t\t\t\t// Record old height\n\t\t\t\tlet heightInPx = this._heights[index];\n\n\t\t\t\t// Record old min width\n\t\t\t\tlet minWidth = this._minWidths[index];\n\n\t\t\t\t// Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n\t\t\t\tthis.removeWhitespace(id);\n\n\t\t\t\t// And add it again\n\t\t\t\tlet insertionIndex = WhitespaceComputer.findInsertionIndex(this._afterLineNumbers, newAfterLineNumber, this._ordinals, ordinal);\n\t\t\t\tthis._insertWhitespaceAtIndex(id, insertionIndex, newAfterLineNumber, ordinal, heightInPx, minWidth);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Remove an existing whitespace.\n\t *\n\t * @param id The whitespace to remove\n\t * @return Returns true if the whitespace is found and it is removed.\n\t */\n\tpublic removeWhitespace(id: number): boolean {\n\t\tid = id | 0;\n\n\t\tlet sid = id.toString();\n\n\t\tif (this._whitespaceId2Index.hasOwnProperty(sid)) {\n\t\t\tlet index = this._whitespaceId2Index[sid];\n\t\t\tdelete this._whitespaceId2Index[sid];\n\t\t\tthis._removeWhitespaceAtIndex(index);\n\t\t\tthis._minWidth = -1; /* marker for not being computed */\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate _removeWhitespaceAtIndex(removeIndex: number): void {\n\t\tremoveIndex = removeIndex | 0;\n\n\t\tthis._heights.splice(removeIndex, 1);\n\t\tthis._minWidths.splice(removeIndex, 1);\n\t\tthis._ids.splice(removeIndex, 1);\n\t\tthis._afterLineNumbers.splice(removeIndex, 1);\n\t\tthis._ordinals.splice(removeIndex, 1);\n\t\tthis._prefixSum.splice(removeIndex, 1);\n\t\tthis._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n\n\t\tlet keys = Object.keys(this._whitespaceId2Index);\n\t\tfor (let i = 0, len = keys.length; i < len; i++) {\n\t\t\tlet sid = keys[i];\n\t\t\tlet oldIndex = this._whitespaceId2Index[sid];\n\t\t\tif (oldIndex >= removeIndex) {\n\t\t\t\tthis._whitespaceId2Index[sid] = oldIndex - 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Notify the computer that lines have been deleted (a continuous zone of lines).\n\t * This gives it a chance to update `afterLineNumber` for whitespaces, giving the \"sticky\" characteristic.\n\t *\n\t * @param fromLineNumber The line number at which the deletion started, inclusive\n\t * @param toLineNumber The line number at which the deletion ended, inclusive\n\t */\n\tpublic onLinesDeleted(fromLineNumber: number, toLineNumber: number): void {\n\t\tfromLineNumber = fromLineNumber | 0;\n\t\ttoLineNumber = toLineNumber | 0;\n\n\t\tfor (let i = 0, len = this._afterLineNumbers.length; i < len; i++) {\n\t\t\tlet afterLineNumber = this._afterLineNumbers[i];\n\n\t\t\tif (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n\t\t\t\t// The line this whitespace was after has been deleted\n\t\t\t\t//  => move whitespace to before first deleted line\n\t\t\t\tthis._afterLineNumbers[i] = fromLineNumber - 1;\n\t\t\t} else if (afterLineNumber > toLineNumber) {\n\t\t\t\t// The line this whitespace was after has been moved up\n\t\t\t\t//  => move whitespace up\n\t\t\t\tthis._afterLineNumbers[i] -= (toLineNumber - fromLineNumber + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Notify the computer that lines have been inserted (a continuous zone of lines).\n\t * This gives it a chance to update `afterLineNumber` for whitespaces, giving the \"sticky\" characteristic.\n\t *\n\t * @param fromLineNumber The line number at which the insertion started, inclusive\n\t * @param toLineNumber The line number at which the insertion ended, inclusive.\n\t */\n\tpublic onLinesInserted(fromLineNumber: number, toLineNumber: number): void {\n\t\tfromLineNumber = fromLineNumber | 0;\n\t\ttoLineNumber = toLineNumber | 0;\n\n\t\tfor (let i = 0, len = this._afterLineNumbers.length; i < len; i++) {\n\t\t\tlet afterLineNumber = this._afterLineNumbers[i];\n\n\t\t\tif (fromLineNumber <= afterLineNumber) {\n\t\t\t\tthis._afterLineNumbers[i] += (toLineNumber - fromLineNumber + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the sum of all the whitespaces.\n\t */\n\tpublic getTotalHeight(): number {\n\t\tif (this._heights.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.getAccumulatedHeight(this._heights.length - 1);\n\t}\n\n\t/**\n\t * Return the sum of the heights of the whitespaces at [0..index].\n\t * This includes the whitespace at `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n\t */\n\tpublic getAccumulatedHeight(index: number): number {\n\t\tindex = index | 0;\n\n\t\tlet startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n\t\tif (startIndex === 0) {\n\t\t\tthis._prefixSum[0] = this._heights[0];\n\t\t\tstartIndex++;\n\t\t}\n\n\t\tfor (let i = startIndex; i <= index; i++) {\n\t\t\tthis._prefixSum[i] = this._prefixSum[i - 1] + this._heights[i];\n\t\t}\n\t\tthis._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n\t\treturn this._prefixSum[index];\n\t}\n\n\t/**\n\t * Find all whitespaces with `afterLineNumber` < `lineNumber` and return the sum of their heights.\n\t *\n\t * @param lineNumber The line number whitespaces should be before.\n\t * @return The sum of the heights of the whitespaces before `lineNumber`.\n\t */\n\tpublic getAccumulatedHeightBeforeLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\tlet lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n\n\t\tif (lastWhitespaceBeforeLineNumber === -1) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn this.getAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n\t}\n\n\tprivate _findLastWhitespaceBeforeLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\t// Find the whitespace before line number\n\t\tlet afterLineNumbers = this._afterLineNumbers;\n\t\tlet low = 0;\n\t\tlet high = afterLineNumbers.length - 1;\n\n\t\twhile (low <= high) {\n\t\t\tlet delta = (high - low) | 0;\n\t\t\tlet halfDelta = (delta / 2) | 0;\n\t\t\tlet mid = (low + halfDelta) | 0;\n\n\t\t\tif (afterLineNumbers[mid] < lineNumber) {\n\t\t\t\tif (mid + 1 >= afterLineNumbers.length || afterLineNumbers[mid + 1] >= lineNumber) {\n\t\t\t\t\treturn mid;\n\t\t\t\t} else {\n\t\t\t\t\tlow = (mid + 1) | 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thigh = (mid - 1) | 0;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tprivate _findFirstWhitespaceAfterLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\tlet lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n\t\tlet firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n\n\t\tif (firstWhitespaceAfterLineNumber < this._heights.length) {\n\t\t\treturn firstWhitespaceAfterLineNumber;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n\t * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n\t */\n\tpublic getFirstWhitespaceIndexAfterLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\treturn this._findFirstWhitespaceAfterLineNumber(lineNumber);\n\t}\n\n\t/**\n\t * The number of whitespaces.\n\t */\n\tpublic getCount(): number {\n\t\treturn this._heights.length;\n\t}\n\n\t/**\n\t * The maximum min width for all whitespaces.\n\t */\n\tpublic getMinWidth(): number {\n\t\tif (this._minWidth === -1) {\n\t\t\tlet minWidth = 0;\n\t\t\tfor (let i = 0, len = this._minWidths.length; i < len; i++) {\n\t\t\t\tminWidth = Math.max(minWidth, this._minWidths[i]);\n\t\t\t}\n\t\t\tthis._minWidth = minWidth;\n\t\t}\n\t\treturn this._minWidth;\n\t}\n\n\t/**\n\t * Get the `afterLineNumber` for whitespace at index `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return `afterLineNumber` of whitespace at `index`.\n\t */\n\tpublic getAfterLineNumberForWhitespaceIndex(index: number): number {\n\t\tindex = index | 0;\n\n\t\treturn this._afterLineNumbers[index];\n\t}\n\n\t/**\n\t * Get the `id` for whitespace at index `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return `id` of whitespace at `index`.\n\t */\n\tpublic getIdForWhitespaceIndex(index: number): number {\n\t\tindex = index | 0;\n\n\t\treturn this._ids[index];\n\t}\n\n\t/**\n\t * Get the `height` for whitespace at index `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return `height` of whitespace at `index`.\n\t */\n\tpublic getHeightForWhitespaceIndex(index: number): number {\n\t\tindex = index | 0;\n\n\t\treturn this._heights[index];\n\t}\n\n\t/**\n\t * Get all whitespaces.\n\t */\n\tpublic getWhitespaces(deviceLineHeight: number): IEditorWhitespace[] {\n\t\tdeviceLineHeight = deviceLineHeight | 0;\n\n\t\tlet result: IEditorWhitespace[] = [];\n\t\tfor (let i = 0; i < this._heights.length; i++) {\n\t\t\tresult.push({\n\t\t\t\tid: this._ids[i],\n\t\t\t\tafterLineNumber: this._afterLineNumbers[i],\n\t\t\t\theightInLines: this._heights[i] / deviceLineHeight\n\t\t\t});\n\t\t}\n\t\treturn result;\n\t}\n}\n"]}]}