{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/scrollable.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/scrollable.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/event\", \"vs/base/common/lifecycle\"], function (require, exports, event_1, lifecycle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var ScrollbarVisibility;\n    (function (ScrollbarVisibility) {\n        ScrollbarVisibility[ScrollbarVisibility[\"Auto\"] = 1] = \"Auto\";\n        ScrollbarVisibility[ScrollbarVisibility[\"Hidden\"] = 2] = \"Hidden\";\n        ScrollbarVisibility[ScrollbarVisibility[\"Visible\"] = 3] = \"Visible\";\n    })(ScrollbarVisibility = exports.ScrollbarVisibility || (exports.ScrollbarVisibility = {}));\n    class ScrollState {\n        constructor(width, scrollWidth, scrollLeft, height, scrollHeight, scrollTop) {\n            width = width | 0;\n            scrollWidth = scrollWidth | 0;\n            scrollLeft = scrollLeft | 0;\n            height = height | 0;\n            scrollHeight = scrollHeight | 0;\n            scrollTop = scrollTop | 0;\n            if (width < 0) {\n                width = 0;\n            }\n            if (scrollLeft + width > scrollWidth) {\n                scrollLeft = scrollWidth - width;\n            }\n            if (scrollLeft < 0) {\n                scrollLeft = 0;\n            }\n            if (height < 0) {\n                height = 0;\n            }\n            if (scrollTop + height > scrollHeight) {\n                scrollTop = scrollHeight - height;\n            }\n            if (scrollTop < 0) {\n                scrollTop = 0;\n            }\n            this.width = width;\n            this.scrollWidth = scrollWidth;\n            this.scrollLeft = scrollLeft;\n            this.height = height;\n            this.scrollHeight = scrollHeight;\n            this.scrollTop = scrollTop;\n        }\n        equals(other) {\n            return (this.width === other.width\n                && this.scrollWidth === other.scrollWidth\n                && this.scrollLeft === other.scrollLeft\n                && this.height === other.height\n                && this.scrollHeight === other.scrollHeight\n                && this.scrollTop === other.scrollTop);\n        }\n        withScrollDimensions(update) {\n            return new ScrollState((typeof update.width !== 'undefined' ? update.width : this.width), (typeof update.scrollWidth !== 'undefined' ? update.scrollWidth : this.scrollWidth), this.scrollLeft, (typeof update.height !== 'undefined' ? update.height : this.height), (typeof update.scrollHeight !== 'undefined' ? update.scrollHeight : this.scrollHeight), this.scrollTop);\n        }\n        withScrollPosition(update) {\n            return new ScrollState(this.width, this.scrollWidth, (typeof update.scrollLeft !== 'undefined' ? update.scrollLeft : this.scrollLeft), this.height, this.scrollHeight, (typeof update.scrollTop !== 'undefined' ? update.scrollTop : this.scrollTop));\n        }\n        createScrollEvent(previous) {\n            const widthChanged = (this.width !== previous.width);\n            const scrollWidthChanged = (this.scrollWidth !== previous.scrollWidth);\n            const scrollLeftChanged = (this.scrollLeft !== previous.scrollLeft);\n            const heightChanged = (this.height !== previous.height);\n            const scrollHeightChanged = (this.scrollHeight !== previous.scrollHeight);\n            const scrollTopChanged = (this.scrollTop !== previous.scrollTop);\n            return {\n                width: this.width,\n                scrollWidth: this.scrollWidth,\n                scrollLeft: this.scrollLeft,\n                height: this.height,\n                scrollHeight: this.scrollHeight,\n                scrollTop: this.scrollTop,\n                widthChanged: widthChanged,\n                scrollWidthChanged: scrollWidthChanged,\n                scrollLeftChanged: scrollLeftChanged,\n                heightChanged: heightChanged,\n                scrollHeightChanged: scrollHeightChanged,\n                scrollTopChanged: scrollTopChanged,\n            };\n        }\n    }\n    exports.ScrollState = ScrollState;\n    class Scrollable extends lifecycle_1.Disposable {\n        constructor(smoothScrollDuration, scheduleAtNextAnimationFrame) {\n            super();\n            this._onScroll = this._register(new event_1.Emitter());\n            this.onScroll = this._onScroll.event;\n            this._smoothScrollDuration = smoothScrollDuration;\n            this._scheduleAtNextAnimationFrame = scheduleAtNextAnimationFrame;\n            this._state = new ScrollState(0, 0, 0, 0, 0, 0);\n            this._smoothScrolling = null;\n        }\n        dispose() {\n            if (this._smoothScrolling) {\n                this._smoothScrolling.dispose();\n                this._smoothScrolling = null;\n            }\n            super.dispose();\n        }\n        setSmoothScrollDuration(smoothScrollDuration) {\n            this._smoothScrollDuration = smoothScrollDuration;\n        }\n        validateScrollPosition(scrollPosition) {\n            return this._state.withScrollPosition(scrollPosition);\n        }\n        getScrollDimensions() {\n            return this._state;\n        }\n        setScrollDimensions(dimensions) {\n            const newState = this._state.withScrollDimensions(dimensions);\n            this._setState(newState);\n            // Validate outstanding animated scroll position target\n            if (this._smoothScrolling) {\n                this._smoothScrolling.acceptScrollDimensions(this._state);\n            }\n        }\n        /**\n         * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.\n         * If no scroll animation is occurring, it will return the current scroll position instead.\n         */\n        getFutureScrollPosition() {\n            if (this._smoothScrolling) {\n                return this._smoothScrolling.to;\n            }\n            return this._state;\n        }\n        /**\n         * Returns the current scroll position.\n         * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.\n         */\n        getCurrentScrollPosition() {\n            return this._state;\n        }\n        setScrollPositionNow(update) {\n            // no smooth scrolling requested\n            const newState = this._state.withScrollPosition(update);\n            // Terminate any outstanding smooth scrolling\n            if (this._smoothScrolling) {\n                this._smoothScrolling.dispose();\n                this._smoothScrolling = null;\n            }\n            this._setState(newState);\n        }\n        setScrollPositionSmooth(update) {\n            if (this._smoothScrollDuration === 0) {\n                // Smooth scrolling not supported.\n                return this.setScrollPositionNow(update);\n            }\n            if (this._smoothScrolling) {\n                // Combine our pending scrollLeft/scrollTop with incoming scrollLeft/scrollTop\n                update = {\n                    scrollLeft: (typeof update.scrollLeft === 'undefined' ? this._smoothScrolling.to.scrollLeft : update.scrollLeft),\n                    scrollTop: (typeof update.scrollTop === 'undefined' ? this._smoothScrolling.to.scrollTop : update.scrollTop)\n                };\n                // Validate `update`\n                const validTarget = this._state.withScrollPosition(update);\n                if (this._smoothScrolling.to.scrollLeft === validTarget.scrollLeft && this._smoothScrolling.to.scrollTop === validTarget.scrollTop) {\n                    // No need to interrupt or extend the current animation since we're going to the same place\n                    return;\n                }\n                const newSmoothScrolling = this._smoothScrolling.combine(this._state, validTarget, this._smoothScrollDuration);\n                this._smoothScrolling.dispose();\n                this._smoothScrolling = newSmoothScrolling;\n            }\n            else {\n                // Validate `update`\n                const validTarget = this._state.withScrollPosition(update);\n                this._smoothScrolling = SmoothScrollingOperation.start(this._state, validTarget, this._smoothScrollDuration);\n            }\n            // Begin smooth scrolling animation\n            this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {\n                if (!this._smoothScrolling) {\n                    return;\n                }\n                this._smoothScrolling.animationFrameDisposable = null;\n                this._performSmoothScrolling();\n            });\n        }\n        _performSmoothScrolling() {\n            if (!this._smoothScrolling) {\n                return;\n            }\n            const update = this._smoothScrolling.tick();\n            const newState = this._state.withScrollPosition(update);\n            this._setState(newState);\n            if (update.isDone) {\n                this._smoothScrolling.dispose();\n                this._smoothScrolling = null;\n                return;\n            }\n            // Continue smooth scrolling animation\n            this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {\n                if (!this._smoothScrolling) {\n                    return;\n                }\n                this._smoothScrolling.animationFrameDisposable = null;\n                this._performSmoothScrolling();\n            });\n        }\n        _setState(newState) {\n            const oldState = this._state;\n            if (oldState.equals(newState)) {\n                // no change\n                return;\n            }\n            this._state = newState;\n            this._onScroll.fire(this._state.createScrollEvent(oldState));\n        }\n    }\n    exports.Scrollable = Scrollable;\n    class SmoothScrollingUpdate {\n        constructor(scrollLeft, scrollTop, isDone) {\n            this.scrollLeft = scrollLeft;\n            this.scrollTop = scrollTop;\n            this.isDone = isDone;\n        }\n    }\n    exports.SmoothScrollingUpdate = SmoothScrollingUpdate;\n    function createEaseOutCubic(from, to) {\n        const delta = to - from;\n        return function (completion) {\n            return from + delta * easeOutCubic(completion);\n        };\n    }\n    function createComposed(a, b, cut) {\n        return function (completion) {\n            if (completion < cut) {\n                return a(completion / cut);\n            }\n            return b((completion - cut) / (1 - cut));\n        };\n    }\n    class SmoothScrollingOperation {\n        constructor(from, to, startTime, duration) {\n            this.from = from;\n            this.to = to;\n            this.duration = duration;\n            this._startTime = startTime;\n            this.animationFrameDisposable = null;\n            this._initAnimations();\n        }\n        _initAnimations() {\n            this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width);\n            this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);\n        }\n        _initAnimation(from, to, viewportSize) {\n            const delta = Math.abs(from - to);\n            if (delta > 2.5 * viewportSize) {\n                let stop1, stop2;\n                if (from < to) {\n                    // scroll to 75% of the viewportSize\n                    stop1 = from + 0.75 * viewportSize;\n                    stop2 = to - 0.75 * viewportSize;\n                }\n                else {\n                    stop1 = from - 0.75 * viewportSize;\n                    stop2 = to + 0.75 * viewportSize;\n                }\n                return createComposed(createEaseOutCubic(from, stop1), createEaseOutCubic(stop2, to), 0.33);\n            }\n            return createEaseOutCubic(from, to);\n        }\n        dispose() {\n            if (this.animationFrameDisposable !== null) {\n                this.animationFrameDisposable.dispose();\n                this.animationFrameDisposable = null;\n            }\n        }\n        acceptScrollDimensions(state) {\n            this.to = state.withScrollPosition(this.to);\n            this._initAnimations();\n        }\n        tick() {\n            return this._tick(Date.now());\n        }\n        _tick(now) {\n            const completion = (now - this._startTime) / this.duration;\n            if (completion < 1) {\n                const newScrollLeft = this.scrollLeft(completion);\n                const newScrollTop = this.scrollTop(completion);\n                return new SmoothScrollingUpdate(newScrollLeft, newScrollTop, false);\n            }\n            return new SmoothScrollingUpdate(this.to.scrollLeft, this.to.scrollTop, true);\n        }\n        combine(from, to, duration) {\n            return SmoothScrollingOperation.start(from, to, duration);\n        }\n        static start(from, to, duration) {\n            // +10 / -10 : pretend the animation already started for a quicker response to a scroll request\n            duration = duration + 10;\n            const startTime = Date.now() - 10;\n            return new SmoothScrollingOperation(from, to, startTime, duration);\n        }\n    }\n    exports.SmoothScrollingOperation = SmoothScrollingOperation;\n    function easeInCubic(t) {\n        return Math.pow(t, 3);\n    }\n    function easeOutCubic(t) {\n        return 1 - easeInCubic(1 - t);\n    }\n});\n",null]}