{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/foldingModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/foldingModel.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar event_1 = require(\"vs/base/common/event\");\nvar foldingRanges_1 = require(\"./foldingRanges\");\nvar FoldingModel = /** @class */ (function () {\n    function FoldingModel(textModel, decorationProvider) {\n        this._updateEventEmitter = new event_1.Emitter();\n        this._textModel = textModel;\n        this._decorationProvider = decorationProvider;\n        this._regions = new foldingRanges_1.FoldingRegions(new Uint32Array(0), new Uint32Array(0));\n        this._editorDecorationIds = [];\n        this._isInitialized = false;\n    }\n    Object.defineProperty(FoldingModel.prototype, \"regions\", {\n        get: function () { return this._regions; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FoldingModel.prototype, \"onDidChange\", {\n        get: function () { return this._updateEventEmitter.event; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FoldingModel.prototype, \"textModel\", {\n        get: function () { return this._textModel; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FoldingModel.prototype, \"isInitialized\", {\n        get: function () { return this._isInitialized; },\n        enumerable: true,\n        configurable: true\n    });\n    FoldingModel.prototype.toggleCollapseState = function (regions) {\n        var _this = this;\n        if (!regions.length) {\n            return;\n        }\n        var processed = {};\n        this._decorationProvider.changeDecorations(function (accessor) {\n            for (var _i = 0, regions_1 = regions; _i < regions_1.length; _i++) {\n                var region = regions_1[_i];\n                var index = region.regionIndex;\n                var editorDecorationId = _this._editorDecorationIds[index];\n                if (editorDecorationId && !processed[editorDecorationId]) {\n                    processed[editorDecorationId] = true;\n                    var newCollapseState = !_this._regions.isCollapsed(index);\n                    _this._regions.setCollapsed(index, newCollapseState);\n                    accessor.changeDecorationOptions(editorDecorationId, _this._decorationProvider.getDecorationOption(newCollapseState));\n                }\n            }\n        });\n        this._updateEventEmitter.fire({ model: this, collapseStateChanged: regions });\n    };\n    FoldingModel.prototype.update = function (newRegions, blockedLineNumers) {\n        var _this = this;\n        if (blockedLineNumers === void 0) { blockedLineNumers = []; }\n        var newEditorDecorations = [];\n        var isBlocked = function (startLineNumber, endLineNumber) {\n            for (var _i = 0, blockedLineNumers_1 = blockedLineNumers; _i < blockedLineNumers_1.length; _i++) {\n                var blockedLineNumber = blockedLineNumers_1[_i];\n                if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) { // first line is visible\n                    return true;\n                }\n            }\n            return false;\n        };\n        var initRange = function (index, isCollapsed) {\n            var startLineNumber = newRegions.getStartLineNumber(index);\n            if (isCollapsed && isBlocked(startLineNumber, newRegions.getEndLineNumber(index))) {\n                isCollapsed = false;\n            }\n            newRegions.setCollapsed(index, isCollapsed);\n            var maxColumn = _this._textModel.getLineMaxColumn(startLineNumber);\n            var decorationRange = {\n                startLineNumber: startLineNumber,\n                startColumn: maxColumn,\n                endLineNumber: startLineNumber,\n                endColumn: maxColumn\n            };\n            newEditorDecorations.push({ range: decorationRange, options: _this._decorationProvider.getDecorationOption(isCollapsed) });\n        };\n        var i = 0;\n        var nextCollapsed = function () {\n            while (i < _this._regions.length) {\n                var isCollapsed = _this._regions.isCollapsed(i);\n                i++;\n                if (isCollapsed) {\n                    return i - 1;\n                }\n            }\n            return -1;\n        };\n        var k = 0;\n        var collapsedIndex = nextCollapsed();\n        while (collapsedIndex !== -1 && k < newRegions.length) {\n            // get the latest range\n            var decRange = this._textModel.getDecorationRange(this._editorDecorationIds[collapsedIndex]);\n            if (decRange) {\n                var collapsedStartLineNumber = decRange.startLineNumber;\n                if (this._textModel.getLineMaxColumn(collapsedStartLineNumber) === decRange.startColumn) { // test that the decoration is still at the end otherwise it got deleted\n                    while (k < newRegions.length) {\n                        var startLineNumber = newRegions.getStartLineNumber(k);\n                        if (collapsedStartLineNumber >= startLineNumber) {\n                            initRange(k, collapsedStartLineNumber === startLineNumber);\n                            k++;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n            }\n            collapsedIndex = nextCollapsed();\n        }\n        while (k < newRegions.length) {\n            initRange(k, false);\n            k++;\n        }\n        this._editorDecorationIds = this._decorationProvider.deltaDecorations(this._editorDecorationIds, newEditorDecorations);\n        this._regions = newRegions;\n        this._isInitialized = true;\n        this._updateEventEmitter.fire({ model: this });\n    };\n    /**\n     * Collapse state memento, for persistence only\n     */\n    FoldingModel.prototype.getMemento = function () {\n        var collapsedRanges = [];\n        for (var i = 0; i < this._regions.length; i++) {\n            if (this._regions.isCollapsed(i)) {\n                var range = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\n                if (range) {\n                    var startLineNumber = range.startLineNumber;\n                    var endLineNumber = range.endLineNumber + this._regions.getEndLineNumber(i) - this._regions.getStartLineNumber(i);\n                    collapsedRanges.push({ startLineNumber: startLineNumber, endLineNumber: endLineNumber });\n                }\n            }\n        }\n        if (collapsedRanges.length > 0) {\n            return collapsedRanges;\n        }\n        return undefined;\n    };\n    /**\n     * Apply persisted state, for persistence only\n     */\n    FoldingModel.prototype.applyMemento = function (state) {\n        if (!Array.isArray(state)) {\n            return;\n        }\n        var toToogle = [];\n        for (var _i = 0, state_1 = state; _i < state_1.length; _i++) {\n            var range = state_1[_i];\n            var region = this.getRegionAtLine(range.startLineNumber);\n            if (region && !region.isCollapsed) {\n                toToogle.push(region);\n            }\n        }\n        this.toggleCollapseState(toToogle);\n    };\n    FoldingModel.prototype.dispose = function () {\n        this._decorationProvider.deltaDecorations(this._editorDecorationIds, []);\n    };\n    FoldingModel.prototype.getAllRegionsAtLine = function (lineNumber, filter) {\n        var result = [];\n        if (this._regions) {\n            var index = this._regions.findRange(lineNumber);\n            var level = 1;\n            while (index >= 0) {\n                var current = this._regions.toRegion(index);\n                if (!filter || filter(current, level)) {\n                    result.push(current);\n                }\n                level++;\n                index = current.parentIndex;\n            }\n        }\n        return result;\n    };\n    FoldingModel.prototype.getRegionAtLine = function (lineNumber) {\n        if (this._regions) {\n            var index = this._regions.findRange(lineNumber);\n            if (index >= 0) {\n                return this._regions.toRegion(index);\n            }\n        }\n        return null;\n    };\n    FoldingModel.prototype.getRegionsInside = function (region, filter) {\n        var result = [];\n        var index = region ? region.regionIndex + 1 : 0;\n        var endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n        if (filter && filter.length === 2) {\n            var levelStack = [];\n            for (var i = index, len = this._regions.length; i < len; i++) {\n                var current = this._regions.toRegion(i);\n                if (this._regions.getStartLineNumber(i) < endLineNumber) {\n                    while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\n                        levelStack.pop();\n                    }\n                    levelStack.push(current);\n                    if (filter(current, levelStack.length)) {\n                        result.push(current);\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        else {\n            for (var i = index, len = this._regions.length; i < len; i++) {\n                var current = this._regions.toRegion(i);\n                if (this._regions.getStartLineNumber(i) < endLineNumber) {\n                    if (!filter || filter(current)) {\n                        result.push(current);\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return result;\n    };\n    return FoldingModel;\n}());\nexports.FoldingModel = FoldingModel;\n/**\n * Collapse or expand the regions at the given locations including all children.\n * @param doCollapse Wheter to collase or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nfunction setCollapseStateLevelsDown(foldingModel, doCollapse, levels, lineNumbers) {\n    if (levels === void 0) { levels = Number.MAX_VALUE; }\n    var toToggle = [];\n    if (lineNumbers && lineNumbers.length > 0) {\n        for (var _i = 0, lineNumbers_1 = lineNumbers; _i < lineNumbers_1.length; _i++) {\n            var lineNumber = lineNumbers_1[_i];\n            var region = foldingModel.getRegionAtLine(lineNumber);\n            if (region) {\n                if (region.isCollapsed !== doCollapse) {\n                    toToggle.push(region);\n                }\n                if (levels > 1) {\n                    var regionsInside = foldingModel.getRegionsInside(region, function (r, level) { return r.isCollapsed !== doCollapse && level < levels; });\n                    toToggle.push.apply(toToggle, regionsInside);\n                }\n            }\n        }\n    }\n    else {\n        var regionsInside = foldingModel.getRegionsInside(null, function (r, level) { return r.isCollapsed !== doCollapse && level < levels; });\n        toToggle.push.apply(toToggle, regionsInside);\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\nexports.setCollapseStateLevelsDown = setCollapseStateLevelsDown;\n/**\n * Collapse or expand the regions at the given locations including all parents.\n * @param doCollapse Wheter to collase or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nfunction setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {\n    var toToggle = [];\n    for (var _i = 0, lineNumbers_2 = lineNumbers; _i < lineNumbers_2.length; _i++) {\n        var lineNumber = lineNumbers_2[_i];\n        var regions = foldingModel.getAllRegionsAtLine(lineNumber, function (region, level) { return region.isCollapsed !== doCollapse && level <= levels; });\n        toToggle.push.apply(toToggle, regions);\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\nexports.setCollapseStateLevelsUp = setCollapseStateLevelsUp;\n/**\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\n * @param foldLevel level. Level == 1 is the top level\n * @param doCollapse Wheter to collase or expand\n*/\nfunction setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {\n    var filter = function (region, level) { return level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(function (line) { return region.containsLine(line); }); };\n    var toToggle = foldingModel.getRegionsInside(null, filter);\n    foldingModel.toggleCollapseState(toToggle);\n}\nexports.setCollapseStateAtLevel = setCollapseStateAtLevel;\n/**\n * Folds all regions for which the lines start with a given regex\n * @param foldingModel the folding model\n */\nfunction setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {\n    var editorModel = foldingModel.textModel;\n    var regions = foldingModel.regions;\n    var toToggle = [];\n    for (var i = regions.length - 1; i >= 0; i--) {\n        if (doCollapse !== regions.isCollapsed(i)) {\n            var startLineNumber = regions.getStartLineNumber(i);\n            if (regExp.test(editorModel.getLineContent(startLineNumber))) {\n                toToggle.push(regions.toRegion(i));\n            }\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\nexports.setCollapseStateForMatchingLines = setCollapseStateForMatchingLines;\n/**\n * Folds all regions of the given type\n * @param foldingModel the folding model\n */\nfunction setCollapseStateForType(foldingModel, type, doCollapse) {\n    var regions = foldingModel.regions;\n    var toToggle = [];\n    for (var i = regions.length - 1; i >= 0; i--) {\n        if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\n            toToggle.push(regions.toRegion(i));\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\nexports.setCollapseStateForType = setCollapseStateForType;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/foldingModel.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/foldingModel.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ITextModel, IModelDecorationOptions, IModelDeltaDecoration, IModelDecorationsChangeAccessor } from 'vs/editor/common/model';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { FoldingRegions, ILineRange, FoldingRegion } from './foldingRanges';\n\nexport interface IDecorationProvider {\n\tgetDecorationOption(isCollapsed: boolean): IModelDecorationOptions;\n\tdeltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[]): string[];\n\tchangeDecorations<T>(callback: (changeAccessor: IModelDecorationsChangeAccessor) => T): T | null;\n}\n\nexport interface FoldingModelChangeEvent {\n\tmodel: FoldingModel;\n\tcollapseStateChanged?: FoldingRegion[];\n}\n\nexport type CollapseMemento = ILineRange[];\n\nexport class FoldingModel {\n\tprivate readonly _textModel: ITextModel;\n\tprivate readonly _decorationProvider: IDecorationProvider;\n\n\tprivate _regions: FoldingRegions;\n\tprivate _editorDecorationIds: string[];\n\tprivate _isInitialized: boolean;\n\n\tprivate _updateEventEmitter = new Emitter<FoldingModelChangeEvent>();\n\n\tpublic get regions(): FoldingRegions { return this._regions; }\n\tpublic get onDidChange(): Event<FoldingModelChangeEvent> { return this._updateEventEmitter.event; }\n\tpublic get textModel() { return this._textModel; }\n\tpublic get isInitialized() { return this._isInitialized; }\n\n\tconstructor(textModel: ITextModel, decorationProvider: IDecorationProvider) {\n\t\tthis._textModel = textModel;\n\t\tthis._decorationProvider = decorationProvider;\n\t\tthis._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));\n\t\tthis._editorDecorationIds = [];\n\t\tthis._isInitialized = false;\n\t}\n\n\tpublic toggleCollapseState(regions: FoldingRegion[]) {\n\t\tif (!regions.length) {\n\t\t\treturn;\n\t\t}\n\t\tlet processed = {};\n\t\tthis._decorationProvider.changeDecorations(accessor => {\n\t\t\tfor (let region of regions) {\n\t\t\t\tlet index = region.regionIndex;\n\t\t\t\tlet editorDecorationId = this._editorDecorationIds[index];\n\t\t\t\tif (editorDecorationId && !processed[editorDecorationId]) {\n\t\t\t\t\tprocessed[editorDecorationId] = true;\n\t\t\t\t\tlet newCollapseState = !this._regions.isCollapsed(index);\n\t\t\t\t\tthis._regions.setCollapsed(index, newCollapseState);\n\t\t\t\t\taccessor.changeDecorationOptions(editorDecorationId, this._decorationProvider.getDecorationOption(newCollapseState));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis._updateEventEmitter.fire({ model: this, collapseStateChanged: regions });\n\t}\n\n\tpublic update(newRegions: FoldingRegions, blockedLineNumers: number[] = []): void {\n\t\tlet newEditorDecorations: IModelDeltaDecoration[] = [];\n\n\t\tlet isBlocked = (startLineNumber: number, endLineNumber: number) => {\n\t\t\tfor (let blockedLineNumber of blockedLineNumers) {\n\t\t\t\tif (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) { // first line is visible\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\tlet initRange = (index: number, isCollapsed: boolean) => {\n\t\t\tlet startLineNumber = newRegions.getStartLineNumber(index);\n\t\t\tif (isCollapsed && isBlocked(startLineNumber, newRegions.getEndLineNumber(index))) {\n\t\t\t\tisCollapsed = false;\n\t\t\t}\n\t\t\tnewRegions.setCollapsed(index, isCollapsed);\n\t\t\tlet maxColumn = this._textModel.getLineMaxColumn(startLineNumber);\n\t\t\tlet decorationRange = {\n\t\t\t\tstartLineNumber: startLineNumber,\n\t\t\t\tstartColumn: maxColumn,\n\t\t\t\tendLineNumber: startLineNumber,\n\t\t\t\tendColumn: maxColumn\n\t\t\t};\n\t\t\tnewEditorDecorations.push({ range: decorationRange, options: this._decorationProvider.getDecorationOption(isCollapsed) });\n\t\t};\n\n\t\tlet i = 0;\n\t\tlet nextCollapsed = () => {\n\t\t\twhile (i < this._regions.length) {\n\t\t\t\tlet isCollapsed = this._regions.isCollapsed(i);\n\t\t\t\ti++;\n\t\t\t\tif (isCollapsed) {\n\t\t\t\t\treturn i - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\n\t\tlet k = 0;\n\t\tlet collapsedIndex = nextCollapsed();\n\t\twhile (collapsedIndex !== -1 && k < newRegions.length) {\n\t\t\t// get the latest range\n\t\t\tlet decRange = this._textModel.getDecorationRange(this._editorDecorationIds[collapsedIndex]);\n\t\t\tif (decRange) {\n\t\t\t\tlet collapsedStartLineNumber = decRange.startLineNumber;\n\t\t\t\tif (this._textModel.getLineMaxColumn(collapsedStartLineNumber) === decRange.startColumn) { // test that the decoration is still at the end otherwise it got deleted\n\t\t\t\t\twhile (k < newRegions.length) {\n\t\t\t\t\t\tlet startLineNumber = newRegions.getStartLineNumber(k);\n\t\t\t\t\t\tif (collapsedStartLineNumber >= startLineNumber) {\n\t\t\t\t\t\t\tinitRange(k, collapsedStartLineNumber === startLineNumber);\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcollapsedIndex = nextCollapsed();\n\t\t}\n\t\twhile (k < newRegions.length) {\n\t\t\tinitRange(k, false);\n\t\t\tk++;\n\t\t}\n\n\t\tthis._editorDecorationIds = this._decorationProvider.deltaDecorations(this._editorDecorationIds, newEditorDecorations);\n\t\tthis._regions = newRegions;\n\t\tthis._isInitialized = true;\n\t\tthis._updateEventEmitter.fire({ model: this });\n\t}\n\n\t/**\n\t * Collapse state memento, for persistence only\n\t */\n\tpublic getMemento(): CollapseMemento | undefined {\n\t\tlet collapsedRanges: ILineRange[] = [];\n\t\tfor (let i = 0; i < this._regions.length; i++) {\n\t\t\tif (this._regions.isCollapsed(i)) {\n\t\t\t\tlet range = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\n\t\t\t\tif (range) {\n\t\t\t\t\tlet startLineNumber = range.startLineNumber;\n\t\t\t\t\tlet endLineNumber = range.endLineNumber + this._regions.getEndLineNumber(i) - this._regions.getStartLineNumber(i);\n\t\t\t\t\tcollapsedRanges.push({ startLineNumber, endLineNumber });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (collapsedRanges.length > 0) {\n\t\t\treturn collapsedRanges;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Apply persisted state, for persistence only\n\t */\n\tpublic applyMemento(state: CollapseMemento) {\n\t\tif (!Array.isArray(state)) {\n\t\t\treturn;\n\t\t}\n\t\tlet toToogle: FoldingRegion[] = [];\n\t\tfor (let range of state) {\n\t\t\tlet region = this.getRegionAtLine(range.startLineNumber);\n\t\t\tif (region && !region.isCollapsed) {\n\t\t\t\ttoToogle.push(region);\n\t\t\t}\n\t\t}\n\t\tthis.toggleCollapseState(toToogle);\n\t}\n\n\tpublic dispose() {\n\t\tthis._decorationProvider.deltaDecorations(this._editorDecorationIds, []);\n\t}\n\n\tgetAllRegionsAtLine(lineNumber: number, filter?: (r: FoldingRegion, level: number) => boolean): FoldingRegion[] {\n\t\tlet result: FoldingRegion[] = [];\n\t\tif (this._regions) {\n\t\t\tlet index = this._regions.findRange(lineNumber);\n\t\t\tlet level = 1;\n\t\t\twhile (index >= 0) {\n\t\t\t\tlet current = this._regions.toRegion(index);\n\t\t\t\tif (!filter || filter(current, level)) {\n\t\t\t\t\tresult.push(current);\n\t\t\t\t}\n\t\t\t\tlevel++;\n\t\t\t\tindex = current.parentIndex;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetRegionAtLine(lineNumber: number): FoldingRegion | null {\n\t\tif (this._regions) {\n\t\t\tlet index = this._regions.findRange(lineNumber);\n\t\t\tif (index >= 0) {\n\t\t\t\treturn this._regions.toRegion(index);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tgetRegionsInside(region: FoldingRegion | null, filter?: (r: FoldingRegion, level?: number) => boolean): FoldingRegion[] {\n\t\tlet result: FoldingRegion[] = [];\n\t\tlet index = region ? region.regionIndex + 1 : 0;\n\t\tlet endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n\n\t\tif (filter && filter.length === 2) {\n\t\t\tconst levelStack: FoldingRegion[] = [];\n\t\t\tfor (let i = index, len = this._regions.length; i < len; i++) {\n\t\t\t\tlet current = this._regions.toRegion(i);\n\t\t\t\tif (this._regions.getStartLineNumber(i) < endLineNumber) {\n\t\t\t\t\twhile (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\n\t\t\t\t\t\tlevelStack.pop();\n\t\t\t\t\t}\n\t\t\t\t\tlevelStack.push(current);\n\t\t\t\t\tif (filter(current, levelStack.length)) {\n\t\t\t\t\t\tresult.push(current);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = index, len = this._regions.length; i < len; i++) {\n\t\t\t\tlet current = this._regions.toRegion(i);\n\t\t\t\tif (this._regions.getStartLineNumber(i) < endLineNumber) {\n\t\t\t\t\tif (!filter || filter(current)) {\n\t\t\t\t\t\tresult.push(current);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}\n\n\n\n/**\n * Collapse or expand the regions at the given locations including all children.\n * @param doCollapse Wheter to collase or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function setCollapseStateLevelsDown(foldingModel: FoldingModel, doCollapse: boolean, levels = Number.MAX_VALUE, lineNumbers?: number[]) {\n\tlet toToggle: FoldingRegion[] = [];\n\tif (lineNumbers && lineNumbers.length > 0) {\n\t\tfor (let lineNumber of lineNumbers) {\n\t\t\tlet region = foldingModel.getRegionAtLine(lineNumber);\n\t\t\tif (region) {\n\t\t\t\tif (region.isCollapsed !== doCollapse) {\n\t\t\t\t\ttoToggle.push(region);\n\t\t\t\t}\n\t\t\t\tif (levels > 1) {\n\t\t\t\t\tlet regionsInside = foldingModel.getRegionsInside(region, (r, level: number) => r.isCollapsed !== doCollapse && level < levels);\n\t\t\t\t\ttoToggle.push(...regionsInside);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlet regionsInside = foldingModel.getRegionsInside(null, (r, level: number) => r.isCollapsed !== doCollapse && level < levels);\n\t\ttoToggle.push(...regionsInside);\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Collapse or expand the regions at the given locations including all parents.\n * @param doCollapse Wheter to collase or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function setCollapseStateLevelsUp(foldingModel: FoldingModel, doCollapse: boolean, levels: number, lineNumbers: number[]) {\n\tlet toToggle: FoldingRegion[] = [];\n\tfor (let lineNumber of lineNumbers) {\n\t\tlet regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);\n\t\ttoToggle.push(...regions);\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\n * @param foldLevel level. Level == 1 is the top level\n * @param doCollapse Wheter to collase or expand\n*/\nexport function setCollapseStateAtLevel(foldingModel: FoldingModel, foldLevel: number, doCollapse: boolean, blockedLineNumbers: number[]): void {\n\tlet filter = (region: FoldingRegion, level: number) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(line => region.containsLine(line));\n\tlet toToggle = foldingModel.getRegionsInside(null, filter);\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Folds all regions for which the lines start with a given regex\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForMatchingLines(foldingModel: FoldingModel, regExp: RegExp, doCollapse: boolean): void {\n\tlet editorModel = foldingModel.textModel;\n\tlet regions = foldingModel.regions;\n\tlet toToggle: FoldingRegion[] = [];\n\tfor (let i = regions.length - 1; i >= 0; i--) {\n\t\tif (doCollapse !== regions.isCollapsed(i)) {\n\t\t\tlet startLineNumber = regions.getStartLineNumber(i);\n\t\t\tif (regExp.test(editorModel.getLineContent(startLineNumber))) {\n\t\t\t\ttoToggle.push(regions.toRegion(i));\n\t\t\t}\n\t\t}\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n\n/**\n * Folds all regions of the given type\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForType(foldingModel: FoldingModel, type: string, doCollapse: boolean): void {\n\tlet regions = foldingModel.regions;\n\tlet toToggle: FoldingRegion[] = [];\n\tfor (let i = regions.length - 1; i >= 0; i--) {\n\t\tif (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\n\t\t\ttoToggle.push(regions.toRegion(i));\n\t\t}\n\t}\n\tfoldingModel.toggleCollapseState(toToggle);\n}\n"]}]}