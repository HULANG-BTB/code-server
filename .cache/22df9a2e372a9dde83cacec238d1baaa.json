{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/themes/common/colorExtensionPoint.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/themes/common/colorExtensionPoint.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/workbench/services/extensions/common/extensionsRegistry\", \"vs/platform/theme/common/colorRegistry\", \"vs/base/common/color\", \"vs/platform/registry/common/platform\"], function (require, exports, nls, extensionsRegistry_1, colorRegistry_1, color_1, platform_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const colorRegistry = platform_1.Registry.as(colorRegistry_1.Extensions.ColorContribution);\n    const colorReferenceSchema = colorRegistry.getColorReferenceSchema();\n    const colorIdPattern = '^\\\\w+[.\\\\w+]*$';\n    const configurationExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint({\n        extensionPoint: 'colors',\n        jsonSchema: {\n            description: nls.localize('contributes.color', 'Contributes extension defined themable colors'),\n            type: 'array',\n            items: {\n                type: 'object',\n                properties: {\n                    id: {\n                        type: 'string',\n                        description: nls.localize('contributes.color.id', 'The identifier of the themable color'),\n                        pattern: colorIdPattern,\n                        patternErrorMessage: nls.localize('contributes.color.id.format', 'Identifiers should be in the form aa[.bb]*'),\n                    },\n                    description: {\n                        type: 'string',\n                        description: nls.localize('contributes.color.description', 'The description of the themable color'),\n                    },\n                    defaults: {\n                        type: 'object',\n                        properties: {\n                            light: {\n                                description: nls.localize('contributes.defaults.light', 'The default color for light themes. Either a color value in hex (#RRGGBB[AA]) or the identifier of a themable color which provides the default.'),\n                                type: 'string',\n                                anyOf: [\n                                    colorReferenceSchema,\n                                    { type: 'string', format: 'color-hex' }\n                                ]\n                            },\n                            dark: {\n                                description: nls.localize('contributes.defaults.dark', 'The default color for dark themes. Either a color value in hex (#RRGGBB[AA]) or the identifier of a themable color which provides the default.'),\n                                type: 'string',\n                                anyOf: [\n                                    colorReferenceSchema,\n                                    { type: 'string', format: 'color-hex' }\n                                ]\n                            },\n                            highContrast: {\n                                description: nls.localize('contributes.defaults.highContrast', 'The default color for high contrast themes. Either a color value in hex (#RRGGBB[AA]) or the identifier of a themable color which provides the default.'),\n                                type: 'string',\n                                anyOf: [\n                                    colorReferenceSchema,\n                                    { type: 'string', format: 'color-hex' }\n                                ]\n                            }\n                        }\n                    },\n                }\n            }\n        }\n    });\n    class ColorExtensionPoint {\n        constructor() {\n            configurationExtPoint.setHandler((extensions, delta) => {\n                for (const extension of delta.added) {\n                    const extensionValue = extension.value;\n                    const collector = extension.collector;\n                    if (!extensionValue || !Array.isArray(extensionValue)) {\n                        collector.error(nls.localize('invalid.colorConfiguration', \"'configuration.colors' must be a array\"));\n                        return;\n                    }\n                    let parseColorValue = (s, name) => {\n                        if (s.length > 0) {\n                            if (s[0] === '#') {\n                                return color_1.Color.Format.CSS.parseHex(s);\n                            }\n                            else {\n                                return s;\n                            }\n                        }\n                        collector.error(nls.localize('invalid.default.colorType', \"{0} must be either a color value in hex (#RRGGBB[AA] or #RGB[A]) or the identifier of a themable color which provides the default.\", name));\n                        return color_1.Color.red;\n                    };\n                    for (const colorContribution of extensionValue) {\n                        if (typeof colorContribution.id !== 'string' || colorContribution.id.length === 0) {\n                            collector.error(nls.localize('invalid.id', \"'configuration.colors.id' must be defined and can not be empty\"));\n                            return;\n                        }\n                        if (!colorContribution.id.match(colorIdPattern)) {\n                            collector.error(nls.localize('invalid.id.format', \"'configuration.colors.id' must follow the word[.word]*\"));\n                            return;\n                        }\n                        if (typeof colorContribution.description !== 'string' || colorContribution.id.length === 0) {\n                            collector.error(nls.localize('invalid.description', \"'configuration.colors.description' must be defined and can not be empty\"));\n                            return;\n                        }\n                        let defaults = colorContribution.defaults;\n                        if (!defaults || typeof defaults !== 'object' || typeof defaults.light !== 'string' || typeof defaults.dark !== 'string' || typeof defaults.highContrast !== 'string') {\n                            collector.error(nls.localize('invalid.defaults', \"'configuration.colors.defaults' must be defined and must contain 'light', 'dark' and 'highContrast'\"));\n                            return;\n                        }\n                        colorRegistry.registerColor(colorContribution.id, {\n                            light: parseColorValue(defaults.light, 'configuration.colors.defaults.light'),\n                            dark: parseColorValue(defaults.dark, 'configuration.colors.defaults.dark'),\n                            hc: parseColorValue(defaults.highContrast, 'configuration.colors.defaults.highContrast')\n                        }, colorContribution.description);\n                    }\n                }\n                for (const extension of delta.removed) {\n                    const extensionValue = extension.value;\n                    for (const colorContribution of extensionValue) {\n                        colorRegistry.deregisterColor(colorContribution.id);\n                    }\n                }\n            });\n        }\n    }\n    exports.ColorExtensionPoint = ColorExtensionPoint;\n});\n",null]}