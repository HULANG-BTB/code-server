{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/commands/common/commands.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/commands/common/commands.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/lifecycle\", \"vs/base/common/types\", \"vs/platform/instantiation/common/instantiation\", \"vs/base/common/event\", \"vs/base/common/linkedList\"], function (require, exports, lifecycle_1, types_1, instantiation_1, event_1, linkedList_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.ICommandService = instantiation_1.createDecorator('commandService');\n    exports.CommandsRegistry = new class {\n        constructor() {\n            this._commands = new Map();\n            this._onDidRegisterCommand = new event_1.Emitter();\n            this.onDidRegisterCommand = this._onDidRegisterCommand.event;\n        }\n        registerCommand(idOrCommand, handler) {\n            if (!idOrCommand) {\n                throw new Error(`invalid command`);\n            }\n            if (typeof idOrCommand === 'string') {\n                if (!handler) {\n                    throw new Error(`invalid command`);\n                }\n                return this.registerCommand({ id: idOrCommand, handler });\n            }\n            // add argument validation if rich command metadata is provided\n            if (idOrCommand.description) {\n                const constraints = [];\n                for (let arg of idOrCommand.description.args) {\n                    constraints.push(arg.constraint);\n                }\n                const actualHandler = idOrCommand.handler;\n                idOrCommand.handler = function (accessor, ...args) {\n                    types_1.validateConstraints(args, constraints);\n                    return actualHandler(accessor, ...args);\n                };\n            }\n            // find a place to store the command\n            const { id } = idOrCommand;\n            let commands = this._commands.get(id);\n            if (!commands) {\n                commands = new linkedList_1.LinkedList();\n                this._commands.set(id, commands);\n            }\n            let removeFn = commands.unshift(idOrCommand);\n            let ret = lifecycle_1.toDisposable(() => {\n                removeFn();\n                const command = this._commands.get(id);\n                if (command && command.isEmpty()) {\n                    this._commands.delete(id);\n                }\n            });\n            // tell the world about this command\n            this._onDidRegisterCommand.fire(id);\n            return ret;\n        }\n        registerCommandAlias(oldId, newId) {\n            return exports.CommandsRegistry.registerCommand(oldId, (accessor, ...args) => accessor.get(exports.ICommandService).executeCommand(newId, ...args));\n        }\n        getCommand(id) {\n            const list = this._commands.get(id);\n            if (!list || list.isEmpty()) {\n                return undefined;\n            }\n            return list.iterator().next().value;\n        }\n        getCommands() {\n            const result = Object.create(null);\n            this._commands.forEach((value, key) => {\n                result[key] = this.getCommand(key);\n            });\n            return result;\n        }\n    };\n    exports.NullCommandService = {\n        _serviceBrand: undefined,\n        onWillExecuteCommand: () => ({ dispose: () => { } }),\n        executeCommand() {\n            return Promise.resolve(undefined);\n        }\n    };\n});\n",null]}