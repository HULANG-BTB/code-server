{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/parameterHints/parameterHintsWidget.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/parameterHints/parameterHintsWidget.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/browser/dom\", \"vs/base/browser/event\", \"vs/base/browser/ui/aria/aria\", \"vs/base/browser/ui/scrollbar/scrollableElement\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/editor/browser/editorBrowser\", \"vs/editor/common/services/modeService\", \"vs/editor/contrib/markdown/markdownRenderer\", \"vs/editor/contrib/parameterHints/provideSignatureHelp\", \"vs/nls\", \"vs/platform/contextkey/common/contextkey\", \"vs/platform/opener/common/opener\", \"vs/platform/theme/common/colorRegistry\", \"vs/platform/theme/common/themeService\", \"vs/editor/contrib/parameterHints/parameterHintsModel\", \"vs/css!./parameterHints\"], function (require, exports, dom, event_1, aria, scrollableElement_1, event_2, lifecycle_1, editorBrowser_1, modeService_1, markdownRenderer_1, provideSignatureHelp_1, nls, contextkey_1, opener_1, colorRegistry_1, themeService_1, parameterHintsModel_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const $ = dom.$;\n    let ParameterHintsWidget = class ParameterHintsWidget {\n        constructor(editor, contextKeyService, openerService, modeService) {\n            this.editor = editor;\n            // Editor.IContentWidget.allowEditorOverflow\n            this.allowEditorOverflow = true;\n            this.markdownRenderer = new markdownRenderer_1.MarkdownRenderer(editor, modeService, openerService);\n            this.model = new parameterHintsModel_1.ParameterHintsModel(editor);\n            this.keyVisible = provideSignatureHelp_1.Context.Visible.bindTo(contextKeyService);\n            this.keyMultipleSignatures = provideSignatureHelp_1.Context.MultipleSignatures.bindTo(contextKeyService);\n            this.visible = false;\n            this.disposables = [];\n            this.disposables.push(this.model.onChangedHints(newParameterHints => {\n                if (newParameterHints) {\n                    this.show();\n                    this.render(newParameterHints);\n                }\n                else {\n                    this.hide();\n                }\n            }));\n        }\n        createParamaterHintDOMNodes() {\n            this.element = $('.editor-widget.parameter-hints-widget');\n            const wrapper = dom.append(this.element, $('.wrapper'));\n            wrapper.tabIndex = -1;\n            const buttons = dom.append(wrapper, $('.buttons'));\n            const previous = dom.append(buttons, $('.button.previous'));\n            const next = dom.append(buttons, $('.button.next'));\n            const onPreviousClick = event_1.stop(event_1.domEvent(previous, 'click'));\n            onPreviousClick(this.previous, this, this.disposables);\n            const onNextClick = event_1.stop(event_1.domEvent(next, 'click'));\n            onNextClick(this.next, this, this.disposables);\n            this.overloads = dom.append(wrapper, $('.overloads'));\n            const body = $('.body');\n            this.scrollbar = new scrollableElement_1.DomScrollableElement(body, {});\n            this.disposables.push(this.scrollbar);\n            wrapper.appendChild(this.scrollbar.getDomNode());\n            this.signature = dom.append(body, $('.signature'));\n            this.docs = dom.append(body, $('.docs'));\n            this.editor.addContentWidget(this);\n            this.hide();\n            this.element.style.userSelect = 'text';\n            this.disposables.push(this.editor.onDidChangeCursorSelection(e => {\n                if (this.visible) {\n                    this.editor.layoutContentWidget(this);\n                }\n            }));\n            const updateFont = () => {\n                const fontInfo = this.editor.getConfiguration().fontInfo;\n                this.element.style.fontSize = `${fontInfo.fontSize}px`;\n            };\n            updateFont();\n            event_2.Event.chain(this.editor.onDidChangeConfiguration.bind(this.editor))\n                .filter(e => e.fontInfo)\n                .on(updateFont, null, this.disposables);\n            this.disposables.push(this.editor.onDidLayoutChange(e => this.updateMaxHeight()));\n            this.updateMaxHeight();\n        }\n        show() {\n            if (!this.model || this.visible) {\n                return;\n            }\n            if (!this.element) {\n                this.createParamaterHintDOMNodes();\n            }\n            this.keyVisible.set(true);\n            this.visible = true;\n            setTimeout(() => dom.addClass(this.element, 'visible'), 100);\n            this.editor.layoutContentWidget(this);\n        }\n        hide() {\n            if (!this.model || !this.visible) {\n                return;\n            }\n            if (!this.element) {\n                this.createParamaterHintDOMNodes();\n            }\n            this.keyVisible.reset();\n            this.visible = false;\n            this.announcedLabel = null;\n            dom.removeClass(this.element, 'visible');\n            this.editor.layoutContentWidget(this);\n        }\n        getPosition() {\n            if (this.visible) {\n                return {\n                    position: this.editor.getPosition(),\n                    preference: [editorBrowser_1.ContentWidgetPositionPreference.ABOVE, editorBrowser_1.ContentWidgetPositionPreference.BELOW]\n                };\n            }\n            return null;\n        }\n        render(hints) {\n            const multiple = hints.signatures.length > 1;\n            dom.toggleClass(this.element, 'multiple', multiple);\n            this.keyMultipleSignatures.set(multiple);\n            this.signature.innerHTML = '';\n            this.docs.innerHTML = '';\n            const signature = hints.signatures[hints.activeSignature];\n            if (!signature) {\n                return;\n            }\n            const code = dom.append(this.signature, $('.code'));\n            const hasParameters = signature.parameters.length > 0;\n            const fontInfo = this.editor.getConfiguration().fontInfo;\n            code.style.fontSize = `${fontInfo.fontSize}px`;\n            code.style.fontFamily = fontInfo.fontFamily;\n            if (!hasParameters) {\n                const label = dom.append(code, $('span'));\n                label.textContent = signature.label;\n            }\n            else {\n                this.renderParameters(code, signature, hints.activeParameter);\n            }\n            lifecycle_1.dispose(this.renderDisposeables);\n            this.renderDisposeables = [];\n            const activeParameter = signature.parameters[hints.activeParameter];\n            if (activeParameter && activeParameter.documentation) {\n                const documentation = $('span.documentation');\n                if (typeof activeParameter.documentation === 'string') {\n                    documentation.textContent = activeParameter.documentation;\n                }\n                else {\n                    const renderedContents = this.markdownRenderer.render(activeParameter.documentation);\n                    dom.addClass(renderedContents.element, 'markdown-docs');\n                    this.renderDisposeables.push(renderedContents);\n                    documentation.appendChild(renderedContents.element);\n                }\n                dom.append(this.docs, $('p', {}, documentation));\n            }\n            dom.toggleClass(this.signature, 'has-docs', !!signature.documentation);\n            if (signature.documentation === undefined) { /** no op */ }\n            else if (typeof signature.documentation === 'string') {\n                dom.append(this.docs, $('p', {}, signature.documentation));\n            }\n            else {\n                const renderedContents = this.markdownRenderer.render(signature.documentation);\n                dom.addClass(renderedContents.element, 'markdown-docs');\n                this.renderDisposeables.push(renderedContents);\n                dom.append(this.docs, renderedContents.element);\n            }\n            let currentOverload = String(hints.activeSignature + 1);\n            if (hints.signatures.length < 10) {\n                currentOverload += `/${hints.signatures.length}`;\n            }\n            this.overloads.textContent = currentOverload;\n            if (activeParameter) {\n                const labelToAnnounce = this.getParameterLabel(signature, hints.activeParameter);\n                // Select method gets called on every user type while parameter hints are visible.\n                // We do not want to spam the user with same announcements, so we only announce if the current parameter changed.\n                if (this.announcedLabel !== labelToAnnounce) {\n                    aria.alert(nls.localize('hint', \"{0}, hint\", labelToAnnounce));\n                    this.announcedLabel = labelToAnnounce;\n                }\n            }\n            this.editor.layoutContentWidget(this);\n            this.scrollbar.scanDomNode();\n        }\n        renderParameters(parent, signature, currentParameter) {\n            const [start, end] = this.getParameterLabelOffsets(signature, currentParameter);\n            const beforeSpan = document.createElement('span');\n            beforeSpan.textContent = signature.label.substring(0, start);\n            const paramSpan = document.createElement('span');\n            paramSpan.textContent = signature.label.substring(start, end);\n            paramSpan.className = 'parameter active';\n            const afterSpan = document.createElement('span');\n            afterSpan.textContent = signature.label.substring(end);\n            dom.append(parent, beforeSpan, paramSpan, afterSpan);\n        }\n        getParameterLabel(signature, paramIdx) {\n            const param = signature.parameters[paramIdx];\n            if (typeof param.label === 'string') {\n                return param.label;\n            }\n            else {\n                return signature.label.substring(param.label[0], param.label[1]);\n            }\n        }\n        getParameterLabelOffsets(signature, paramIdx) {\n            const param = signature.parameters[paramIdx];\n            if (!param) {\n                return [0, 0];\n            }\n            else if (Array.isArray(param.label)) {\n                return param.label;\n            }\n            else {\n                const idx = signature.label.lastIndexOf(param.label);\n                return idx >= 0\n                    ? [idx, idx + param.label.length]\n                    : [0, 0];\n            }\n        }\n        next() {\n            if (this.model) {\n                this.editor.focus();\n                this.model.next();\n            }\n        }\n        previous() {\n            if (this.model) {\n                this.editor.focus();\n                this.model.previous();\n            }\n        }\n        cancel() {\n            if (this.model) {\n                this.model.cancel();\n            }\n        }\n        getDomNode() {\n            return this.element;\n        }\n        getId() {\n            return ParameterHintsWidget.ID;\n        }\n        trigger(context) {\n            if (this.model) {\n                this.model.trigger(context, 0);\n            }\n        }\n        updateMaxHeight() {\n            const height = Math.max(this.editor.getLayoutInfo().height / 4, 250);\n            this.element.style.maxHeight = `${height}px`;\n        }\n        dispose() {\n            this.disposables = lifecycle_1.dispose(this.disposables);\n            this.renderDisposeables = lifecycle_1.dispose(this.renderDisposeables);\n            if (this.model) {\n                this.model.dispose();\n                this.model = null;\n            }\n        }\n    };\n    ParameterHintsWidget.ID = 'editor.widget.parameterHintsWidget';\n    ParameterHintsWidget = __decorate([\n        __param(1, contextkey_1.IContextKeyService),\n        __param(2, opener_1.IOpenerService),\n        __param(3, modeService_1.IModeService)\n    ], ParameterHintsWidget);\n    exports.ParameterHintsWidget = ParameterHintsWidget;\n    themeService_1.registerThemingParticipant((theme, collector) => {\n        const border = theme.getColor(colorRegistry_1.editorHoverBorder);\n        if (border) {\n            const borderWidth = theme.type === themeService_1.HIGH_CONTRAST ? 2 : 1;\n            collector.addRule(`.monaco-editor .parameter-hints-widget { border: ${borderWidth}px solid ${border}; }`);\n            collector.addRule(`.monaco-editor .parameter-hints-widget.multiple .body { border-left: 1px solid ${border.transparent(0.5)}; }`);\n            collector.addRule(`.monaco-editor .parameter-hints-widget .signature.has-docs { border-bottom: 1px solid ${border.transparent(0.5)}; }`);\n        }\n        const background = theme.getColor(colorRegistry_1.editorHoverBackground);\n        if (background) {\n            collector.addRule(`.monaco-editor .parameter-hints-widget { background-color: ${background}; }`);\n        }\n        const link = theme.getColor(colorRegistry_1.textLinkForeground);\n        if (link) {\n            collector.addRule(`.monaco-editor .parameter-hints-widget a { color: ${link}; }`);\n        }\n        const codeBackground = theme.getColor(colorRegistry_1.textCodeBlockBackground);\n        if (codeBackground) {\n            collector.addRule(`.monaco-editor .parameter-hints-widget code { background-color: ${codeBackground}; }`);\n        }\n    });\n});\n",null]}