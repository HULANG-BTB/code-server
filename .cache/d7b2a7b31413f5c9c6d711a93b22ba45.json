{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true}!/home/coding/workspace/packages/protocol/src/node/server.ts","dependencies":[{"path":"/home/coding/workspace/packages/protocol/src/node/server.ts","mtime":1555841535686},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs_extra_1 = require(\"fs-extra\");\nconst os = require(\"os\");\nconst logger_1 = require(\"@coder/logger\");\nconst proxy_1 = require(\"../common/proxy\");\nconst util_1 = require(\"../common/util\");\nconst proto_1 = require(\"../proto\");\nconst modules_1 = require(\"./modules\");\n/**\n * Handle messages from the client.\n */\nclass Server {\n    constructor(connection, options) {\n        this.connection = connection;\n        this.options = options;\n        this.proxyId = 0;\n        this.proxies = new Map();\n        this.disconnected = false;\n        this.responseTimeout = 10000;\n        connection.onMessage(async (data) => {\n            try {\n                await this.handleMessage(proto_1.ClientMessage.deserializeBinary(data));\n            }\n            catch (ex) {\n                logger_1.logger.error(\"Failed to handle client message\", logger_1.field(\"length\", data.byteLength), logger_1.field(\"exception\", {\n                    message: ex.message,\n                    stack: ex.stack,\n                }));\n            }\n        });\n        connection.onClose(() => {\n            this.disconnected = true;\n            logger_1.logger.trace(() => [\n                \"disconnected from client\",\n                logger_1.field(\"proxies\", this.proxies.size),\n            ]);\n            this.proxies.forEach((proxy, proxyId) => {\n                if (util_1.isProxy(proxy.instance)) {\n                    proxy.instance.dispose().catch((error) => {\n                        logger_1.logger.error(error.message);\n                    });\n                }\n                this.removeProxy(proxyId);\n            });\n        });\n        this.storeProxy(new modules_1.ChildProcessModuleProxy(this.options ? this.options.fork : undefined), proxy_1.Module.ChildProcess);\n        this.storeProxy(new modules_1.FsModuleProxy(), proxy_1.Module.Fs);\n        this.storeProxy(new modules_1.NetModuleProxy(), proxy_1.Module.Net);\n        this.storeProxy(new modules_1.NodePtyModuleProxy(), proxy_1.Module.NodePty);\n        this.storeProxy(new modules_1.SpdlogModuleProxy(), proxy_1.Module.Spdlog);\n        this.storeProxy(new modules_1.TrashModuleProxy(), proxy_1.Module.Trash);\n        if (!this.options) {\n            logger_1.logger.warn(\"No server options provided. InitMessage will not be sent.\");\n            return;\n        }\n        Promise.all([\n            fs_extra_1.mkdirp(this.options.cacheDirectory),\n            fs_extra_1.mkdirp(this.options.dataDirectory),\n            fs_extra_1.mkdirp(this.options.workingDirectory),\n        ]).catch((error) => {\n            logger_1.logger.error(error.message, logger_1.field(\"error\", error));\n        });\n        const initMsg = new proto_1.WorkingInit();\n        initMsg.setDataDirectory(this.options.dataDirectory);\n        initMsg.setWorkingDirectory(this.options.workingDirectory);\n        initMsg.setBuiltinExtensionsDir(this.options.builtInExtensionsDirectory);\n        initMsg.setExtensionsDirectory(this.options.extensionsDirectory);\n        initMsg.setHomeDirectory(os.homedir());\n        initMsg.setTmpDirectory(os.tmpdir());\n        initMsg.setOperatingSystem(util_1.platformToProto(os.platform()));\n        initMsg.setShell(os.userInfo().shell || global.process.env.SHELL || \"\");\n        const srvMsg = new proto_1.ServerMessage();\n        srvMsg.setInit(initMsg);\n        connection.send(srvMsg.serializeBinary());\n    }\n    /**\n     * Handle all messages from the client.\n     */\n    async handleMessage(message) {\n        switch (message.getMsgCase()) {\n            case proto_1.ClientMessage.MsgCase.METHOD:\n                await this.runMethod(message.getMethod());\n                break;\n            case proto_1.ClientMessage.MsgCase.PING:\n                logger_1.logger.trace(\"ping\");\n                const srvMsg = new proto_1.ServerMessage();\n                srvMsg.setPong(new proto_1.Pong());\n                this.connection.send(srvMsg.serializeBinary());\n                break;\n            default:\n                throw new Error(\"unknown message type\");\n        }\n    }\n    /**\n     * Run a method on a proxy.\n     */\n    async runMethod(message) {\n        const proxyMessage = message.getNamedProxy() || message.getNumberedProxy();\n        const id = proxyMessage.getId();\n        const proxyId = message.hasNamedProxy()\n            ? util_1.protoToModule(message.getNamedProxy().getModule())\n            : message.getNumberedProxy().getProxyId();\n        const method = proxyMessage.getMethod();\n        const args = proxyMessage.getArgsList().map((a) => util_1.protoToArgument(a, (id, args) => this.sendCallback(proxyId, id, args)));\n        logger_1.logger.trace(() => [\n            \"received\",\n            logger_1.field(\"id\", id),\n            logger_1.field(\"proxyId\", proxyId),\n            logger_1.field(\"method\", method),\n        ]);\n        let response;\n        try {\n            const proxy = this.getProxy(proxyId);\n            if (typeof proxy.instance[method] !== \"function\") {\n                throw new Error(`\"${method}\" is not a function on proxy ${proxyId}`);\n            }\n            response = proxy.instance[method](...args);\n            // We wait for the client to call \"dispose\" instead of doing it onDone to\n            // ensure all the messages it sent get processed before we get rid of it.\n            if (method === \"dispose\") {\n                this.removeProxy(proxyId);\n            }\n            // Proxies must always return promises.\n            if (!util_1.isPromise(response)) {\n                throw new Error(`\"${method}\" must return a promise`);\n            }\n        }\n        catch (error) {\n            logger_1.logger.error(error.message, logger_1.field(\"type\", typeof response), logger_1.field(\"proxyId\", proxyId));\n            this.sendException(id, error);\n        }\n        try {\n            this.sendResponse(id, await response);\n        }\n        catch (error) {\n            this.sendException(id, error);\n        }\n    }\n    /**\n     * Send a callback to the client.\n     */\n    sendCallback(proxyId, callbackId, args) {\n        logger_1.logger.trace(() => [\n            \"sending callback\",\n            logger_1.field(\"proxyId\", proxyId),\n            logger_1.field(\"callbackId\", callbackId),\n        ]);\n        const message = new proto_1.Callback();\n        let callbackMessage;\n        if (typeof proxyId === \"string\") {\n            callbackMessage = new proto_1.Callback.Named();\n            callbackMessage.setModule(util_1.moduleToProto(proxyId));\n            message.setNamedCallback(callbackMessage);\n        }\n        else {\n            callbackMessage = new proto_1.Callback.Numbered();\n            callbackMessage.setProxyId(proxyId);\n            message.setNumberedCallback(callbackMessage);\n        }\n        callbackMessage.setCallbackId(callbackId);\n        callbackMessage.setArgsList(args.map((a) => this.argumentToProto(a)));\n        const serverMessage = new proto_1.ServerMessage();\n        serverMessage.setCallback(message);\n        this.connection.send(serverMessage.serializeBinary());\n    }\n    /**\n     * Store a proxy and bind events to send them back to the client.\n     */\n    storeProxy(instance, moduleProxyId) {\n        // In case we disposed while waiting for a function to return.\n        if (this.disconnected) {\n            if (util_1.isProxy(instance)) {\n                instance.dispose().catch((error) => {\n                    logger_1.logger.error(error.message);\n                });\n            }\n            throw new Error(\"disposed\");\n        }\n        const proxyId = moduleProxyId || this.proxyId++;\n        logger_1.logger.trace(() => [\n            \"storing proxy\",\n            logger_1.field(\"proxyId\", proxyId),\n        ]);\n        this.proxies.set(proxyId, { instance });\n        if (util_1.isProxy(instance)) {\n            instance.onEvent((event, ...args) => this.sendEvent(proxyId, event, ...args)).catch((error) => {\n                logger_1.logger.error(error.message);\n            });\n            instance.onDone(() => {\n                // It might have finished because we disposed it due to a disconnect.\n                if (!this.disconnected) {\n                    this.sendEvent(proxyId, \"done\");\n                    this.getProxy(proxyId).disposeTimeout = setTimeout(() => {\n                        instance.dispose().catch((error) => {\n                            logger_1.logger.error(error.message);\n                        });\n                        this.removeProxy(proxyId);\n                    }, this.responseTimeout);\n                }\n            }).catch((error) => {\n                logger_1.logger.error(error.message);\n            });\n        }\n        return proxyId;\n    }\n    /**\n     * Send an event to the client.\n     */\n    sendEvent(proxyId, event, ...args) {\n        logger_1.logger.trace(() => [\n            \"sending event\",\n            logger_1.field(\"proxyId\", proxyId),\n            logger_1.field(\"event\", event),\n        ]);\n        const message = new proto_1.Event();\n        let eventMessage;\n        if (typeof proxyId === \"string\") {\n            eventMessage = new proto_1.Event.Named();\n            eventMessage.setModule(util_1.moduleToProto(proxyId));\n            message.setNamedEvent(eventMessage);\n        }\n        else {\n            eventMessage = new proto_1.Event.Numbered();\n            eventMessage.setProxyId(proxyId);\n            message.setNumberedEvent(eventMessage);\n        }\n        eventMessage.setEvent(event);\n        eventMessage.setArgsList(args.map((a) => this.argumentToProto(a)));\n        const serverMessage = new proto_1.ServerMessage();\n        serverMessage.setEvent(message);\n        this.connection.send(serverMessage.serializeBinary());\n    }\n    /**\n     * Send a response back to the client.\n     */\n    sendResponse(id, response) {\n        logger_1.logger.trace(() => [\n            \"sending resolve\",\n            logger_1.field(\"id\", id),\n        ]);\n        const successMessage = new proto_1.Method.Success();\n        successMessage.setId(id);\n        successMessage.setResponse(this.argumentToProto(response));\n        const serverMessage = new proto_1.ServerMessage();\n        serverMessage.setSuccess(successMessage);\n        this.connection.send(serverMessage.serializeBinary());\n    }\n    /**\n     * Send an exception back to the client.\n     */\n    sendException(id, error) {\n        logger_1.logger.trace(() => [\n            \"sending reject\",\n            logger_1.field(\"id\", id),\n            logger_1.field(\"message\", error.message),\n        ]);\n        const failedMessage = new proto_1.Method.Fail();\n        failedMessage.setId(id);\n        failedMessage.setResponse(util_1.argumentToProto(error));\n        const serverMessage = new proto_1.ServerMessage();\n        serverMessage.setFail(failedMessage);\n        this.connection.send(serverMessage.serializeBinary());\n    }\n    /**\n     * Call after disposing a proxy.\n     */\n    removeProxy(proxyId) {\n        clearTimeout(this.getProxy(proxyId).disposeTimeout);\n        this.proxies.delete(proxyId);\n        logger_1.logger.trace(() => [\n            \"disposed and removed proxy\",\n            logger_1.field(\"proxyId\", proxyId),\n            logger_1.field(\"proxies\", this.proxies.size),\n        ]);\n    }\n    /**\n     * Same as argumentToProto but provides storeProxy.\n     */\n    argumentToProto(value) {\n        return util_1.argumentToProto(value, undefined, (p) => this.storeProxy(p));\n    }\n    /**\n     * Get a proxy. Error if it doesn't exist.\n     */\n    getProxy(proxyId) {\n        if (!this.proxies.has(proxyId)) {\n            throw new Error(`proxy ${proxyId} disposed too early`);\n        }\n        return this.proxies.get(proxyId);\n    }\n}\nexports.Server = Server;\n",{"version":3,"file":"/home/coding/workspace/packages/protocol/src/node/server.ts","sourceRoot":"","sources":["/home/coding/workspace/packages/protocol/src/node/server.ts"],"names":[],"mappings":"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","sourcesContent":["import { mkdirp } from \"fs-extra\";\nimport * as os from \"os\";\nimport { field, logger} from \"@coder/logger\";\nimport { ReadWriteConnection } from \"../common/connection\";\nimport { Module, ServerProxy } from \"../common/proxy\";\nimport { isPromise, isProxy, moduleToProto, protoToArgument, platformToProto, protoToModule, argumentToProto } from \"../common/util\";\nimport { Argument, Callback, ClientMessage, Event, Method, Pong, ServerMessage, WorkingInit } from \"../proto\";\nimport { ChildProcessModuleProxy, ForkProvider, FsModuleProxy, NetModuleProxy, NodePtyModuleProxy, SpdlogModuleProxy, TrashModuleProxy } from \"./modules\";\n\n// tslint:disable no-any\n\nexport interface ServerOptions {\n\treadonly workingDirectory: string;\n\treadonly dataDirectory: string;\n\treadonly cacheDirectory: string;\n\treadonly builtInExtensionsDirectory: string;\n\treadonly extensionsDirectory: string;\n\treadonly fork?: ForkProvider;\n}\n\ninterface ProxyData {\n\tdisposeTimeout?: number | NodeJS.Timer;\n\tinstance: any;\n}\n\n/**\n * Handle messages from the client.\n */\nexport class Server {\n\tprivate proxyId = 0;\n\tprivate readonly proxies = new Map<number | Module, ProxyData>();\n\tprivate disconnected: boolean = false;\n\tprivate readonly responseTimeout = 10000;\n\n\tpublic constructor(\n\t\tprivate readonly connection: ReadWriteConnection,\n\t\tprivate readonly options?: ServerOptions,\n\t) {\n\t\tconnection.onMessage(async (data) => {\n\t\t\ttry {\n\t\t\t\tawait this.handleMessage(ClientMessage.deserializeBinary(data));\n\t\t\t} catch (ex) {\n\t\t\t\tlogger.error(\n\t\t\t\t\t\"Failed to handle client message\",\n\t\t\t\t\tfield(\"length\", data.byteLength),\n\t\t\t\t\tfield(\"exception\", {\n\t\t\t\t\t\tmessage: ex.message,\n\t\t\t\t\t\tstack: ex.stack,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\tconnection.onClose(() => {\n\t\t\tthis.disconnected = true;\n\n\t\t\tlogger.trace(() => [\n\t\t\t\t\"disconnected from client\",\n\t\t\t\tfield(\"proxies\", this.proxies.size),\n\t\t\t]);\n\n\t\t\tthis.proxies.forEach((proxy, proxyId) => {\n\t\t\t\tif (isProxy(proxy.instance)) {\n\t\t\t\t\tproxy.instance.dispose().catch((error) => {\n\t\t\t\t\t\tlogger.error(error.message);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tthis.removeProxy(proxyId);\n\t\t\t});\n\t\t});\n\n\t\tthis.storeProxy(new ChildProcessModuleProxy(this.options ? this.options.fork : undefined), Module.ChildProcess);\n\t\tthis.storeProxy(new FsModuleProxy(), Module.Fs);\n\t\tthis.storeProxy(new NetModuleProxy(), Module.Net);\n\t\tthis.storeProxy(new NodePtyModuleProxy(), Module.NodePty);\n\t\tthis.storeProxy(new SpdlogModuleProxy(), Module.Spdlog);\n\t\tthis.storeProxy(new TrashModuleProxy(), Module.Trash);\n\n\t\tif (!this.options) {\n\t\t\tlogger.warn(\"No server options provided. InitMessage will not be sent.\");\n\n\t\t\treturn;\n\t\t}\n\n\t\tPromise.all([\n\t\t\tmkdirp(this.options.cacheDirectory),\n\t\t\tmkdirp(this.options.dataDirectory),\n\t\t\tmkdirp(this.options.workingDirectory),\n\t\t]).catch((error) => {\n\t\t\tlogger.error(error.message, field(\"error\", error));\n\t\t});\n\n\t\tconst initMsg = new WorkingInit();\n\t\tinitMsg.setDataDirectory(this.options.dataDirectory);\n\t\tinitMsg.setWorkingDirectory(this.options.workingDirectory);\n\t\tinitMsg.setBuiltinExtensionsDir(this.options.builtInExtensionsDirectory);\n\t\tinitMsg.setExtensionsDirectory(this.options.extensionsDirectory);\n\t\tinitMsg.setHomeDirectory(os.homedir());\n\t\tinitMsg.setTmpDirectory(os.tmpdir());\n\t\tinitMsg.setOperatingSystem(platformToProto(os.platform()));\n\t\tinitMsg.setShell(os.userInfo().shell || global.process.env.SHELL || \"\");\n\t\tconst srvMsg = new ServerMessage();\n\t\tsrvMsg.setInit(initMsg);\n\t\tconnection.send(srvMsg.serializeBinary());\n\t}\n\n\t/**\n\t * Handle all messages from the client.\n\t */\n\tprivate async handleMessage(message: ClientMessage): Promise<void> {\n\t\tswitch (message.getMsgCase()) {\n\t\t\tcase ClientMessage.MsgCase.METHOD:\n\t\t\t\tawait this.runMethod(message.getMethod()!);\n\t\t\t\tbreak;\n\t\t\tcase ClientMessage.MsgCase.PING:\n\t\t\t\tlogger.trace(\"ping\");\n\t\t\t\tconst srvMsg = new ServerMessage();\n\t\t\t\tsrvMsg.setPong(new Pong());\n\t\t\t\tthis.connection.send(srvMsg.serializeBinary());\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"unknown message type\");\n\t\t}\n\t}\n\n\t/**\n\t * Run a method on a proxy.\n\t */\n\tprivate async runMethod(message: Method): Promise<void> {\n\t\tconst proxyMessage = message.getNamedProxy()! || message.getNumberedProxy()!;\n\t\tconst id = proxyMessage.getId();\n\t\tconst proxyId = message.hasNamedProxy()\n\t\t\t? protoToModule(message.getNamedProxy()!.getModule())\n\t\t\t: message.getNumberedProxy()!.getProxyId();\n\t\tconst method = proxyMessage.getMethod();\n\t\tconst args = proxyMessage.getArgsList().map((a) => protoToArgument(\n\t\t\ta,\n\t\t\t(id, args) => this.sendCallback(proxyId, id, args),\n\t\t));\n\n\t\tlogger.trace(() => [\n\t\t\t\"received\",\n\t\t\tfield(\"id\", id),\n\t\t\tfield(\"proxyId\", proxyId),\n\t\t\tfield(\"method\", method),\n\t\t]);\n\n\t\tlet response: any;\n\t\ttry {\n\t\t\tconst proxy = this.getProxy(proxyId);\n\t\t\tif (typeof proxy.instance[method] !== \"function\") {\n\t\t\t\tthrow new Error(`\"${method}\" is not a function on proxy ${proxyId}`);\n\t\t\t}\n\n\t\t\tresponse = proxy.instance[method](...args);\n\n\t\t\t// We wait for the client to call \"dispose\" instead of doing it onDone to\n\t\t\t// ensure all the messages it sent get processed before we get rid of it.\n\t\t\tif (method === \"dispose\") {\n\t\t\t\tthis.removeProxy(proxyId);\n\t\t\t}\n\n\t\t\t// Proxies must always return promises.\n\t\t\tif (!isPromise(response)) {\n\t\t\t\tthrow new Error(`\"${method}\" must return a promise`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.error(\n\t\t\t\terror.message,\n\t\t\t\tfield(\"type\", typeof response),\n\t\t\t\tfield(\"proxyId\", proxyId),\n\t\t\t);\n\t\t\tthis.sendException(id, error);\n\t\t}\n\n\t\ttry {\n\t\t\tthis.sendResponse(id, await response);\n\t\t} catch (error) {\n\t\t\tthis.sendException(id, error);\n\t\t}\n\t}\n\n\t/**\n\t * Send a callback to the client.\n\t */\n\tprivate sendCallback(proxyId: number | Module, callbackId: number, args: any[]): void {\n\t\tlogger.trace(() => [\n\t\t\t\"sending callback\",\n\t\t\tfield(\"proxyId\", proxyId),\n\t\t\tfield(\"callbackId\", callbackId),\n\t\t]);\n\n\t\tconst message = new Callback();\n\t\tlet callbackMessage: Callback.Named | Callback.Numbered;\n\t\tif (typeof proxyId === \"string\") {\n\t\t\tcallbackMessage = new Callback.Named();\n\t\t\tcallbackMessage.setModule(moduleToProto(proxyId));\n\t\t\tmessage.setNamedCallback(callbackMessage);\n\t\t} else  {\n\t\t\tcallbackMessage = new Callback.Numbered();\n\t\t\tcallbackMessage.setProxyId(proxyId);\n\t\t\tmessage.setNumberedCallback(callbackMessage);\n\t\t}\n\t\tcallbackMessage.setCallbackId(callbackId);\n\t\tcallbackMessage.setArgsList(args.map((a) => this.argumentToProto(a)));\n\n\t\tconst serverMessage = new ServerMessage();\n\t\tserverMessage.setCallback(message);\n\t\tthis.connection.send(serverMessage.serializeBinary());\n\t}\n\n\t/**\n\t * Store a numbered proxy and bind events to send them back to the client.\n\t */\n\tprivate storeProxy(instance: ServerProxy): number;\n\t/**\n\t * Store a unique proxy and bind events to send them back to the client.\n\t */\n\tprivate storeProxy(instance: any, moduleProxyId: Module): Module;\n\t/**\n\t * Store a proxy and bind events to send them back to the client.\n\t */\n\tprivate storeProxy(instance: ServerProxy | any, moduleProxyId?: Module): number | Module {\n\t\t// In case we disposed while waiting for a function to return.\n\t\tif (this.disconnected) {\n\t\t\tif (isProxy(instance)) {\n\t\t\t\tinstance.dispose().catch((error) => {\n\t\t\t\t\tlogger.error(error.message);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthrow new Error(\"disposed\");\n\t\t}\n\n\t\tconst proxyId = moduleProxyId || this.proxyId++;\n\t\tlogger.trace(() => [\n\t\t\t\"storing proxy\",\n\t\t\tfield(\"proxyId\", proxyId),\n\t\t]);\n\n\t\tthis.proxies.set(proxyId, { instance });\n\n\t\tif (isProxy(instance)) {\n\t\t\tinstance.onEvent((event, ...args) => this.sendEvent(proxyId, event, ...args)).catch((error) => {\n\t\t\t\tlogger.error(error.message);\n\t\t\t});\n\t\t\tinstance.onDone(() => {\n\t\t\t\t// It might have finished because we disposed it due to a disconnect.\n\t\t\t\tif (!this.disconnected) {\n\t\t\t\t\tthis.sendEvent(proxyId, \"done\");\n\t\t\t\t\tthis.getProxy(proxyId).disposeTimeout = setTimeout(() => {\n\t\t\t\t\t\tinstance.dispose().catch((error) => {\n\t\t\t\t\t\t\tlogger.error(error.message);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthis.removeProxy(proxyId);\n\t\t\t\t\t}, this.responseTimeout);\n\t\t\t\t}\n\t\t\t}).catch((error) => {\n\t\t\t\tlogger.error(error.message);\n\t\t\t});\n\t\t}\n\n\t\treturn proxyId;\n\t}\n\n\t/**\n\t * Send an event to the client.\n\t */\n\tprivate sendEvent(proxyId: number | Module, event: string, ...args: any[]): void {\n\t\tlogger.trace(() => [\n\t\t\t\"sending event\",\n\t\t\tfield(\"proxyId\", proxyId),\n\t\t\tfield(\"event\", event),\n\t\t]);\n\n\t\tconst message = new Event();\n\t\tlet eventMessage: Event.Named | Event.Numbered;\n\t\tif (typeof proxyId === \"string\") {\n\t\t\teventMessage = new Event.Named();\n\t\t\teventMessage.setModule(moduleToProto(proxyId));\n\t\t\tmessage.setNamedEvent(eventMessage);\n\t\t} else  {\n\t\t\teventMessage = new Event.Numbered();\n\t\t\teventMessage.setProxyId(proxyId);\n\t\t\tmessage.setNumberedEvent(eventMessage);\n\t\t}\n\t\teventMessage.setEvent(event);\n\t\teventMessage.setArgsList(args.map((a) => this.argumentToProto(a)));\n\n\t\tconst serverMessage = new ServerMessage();\n\t\tserverMessage.setEvent(message);\n\t\tthis.connection.send(serverMessage.serializeBinary());\n\t}\n\n\t/**\n\t * Send a response back to the client.\n\t */\n\tprivate sendResponse(id: number, response: any): void {\n\t\tlogger.trace(() => [\n\t\t\t\"sending resolve\",\n\t\t\tfield(\"id\", id),\n\t\t]);\n\n\t\tconst successMessage = new Method.Success();\n\t\tsuccessMessage.setId(id);\n\t\tsuccessMessage.setResponse(this.argumentToProto(response));\n\n\t\tconst serverMessage = new ServerMessage();\n\t\tserverMessage.setSuccess(successMessage);\n\t\tthis.connection.send(serverMessage.serializeBinary());\n\t}\n\n\t/**\n\t * Send an exception back to the client.\n\t */\n\tprivate sendException(id: number, error: Error): void {\n\t\tlogger.trace(() => [\n\t\t\t\"sending reject\",\n\t\t\tfield(\"id\", id) ,\n\t\t\tfield(\"message\", error.message),\n\t\t]);\n\n\t\tconst failedMessage = new Method.Fail();\n\t\tfailedMessage.setId(id);\n\t\tfailedMessage.setResponse(argumentToProto(error));\n\n\t\tconst serverMessage = new ServerMessage();\n\t\tserverMessage.setFail(failedMessage);\n\t\tthis.connection.send(serverMessage.serializeBinary());\n\t}\n\n\t/**\n\t * Call after disposing a proxy.\n\t */\n\tprivate removeProxy(proxyId: number | Module): void {\n\t\tclearTimeout(this.getProxy(proxyId).disposeTimeout as any);\n\t\tthis.proxies.delete(proxyId);\n\n\t\tlogger.trace(() => [\n\t\t\t\"disposed and removed proxy\",\n\t\t\tfield(\"proxyId\", proxyId),\n\t\t\tfield(\"proxies\", this.proxies.size),\n\t\t]);\n\t}\n\n\t/**\n\t * Same as argumentToProto but provides storeProxy.\n\t */\n\tprivate argumentToProto(value: any): Argument {\n\t\treturn argumentToProto(value, undefined, (p) => this.storeProxy(p));\n\t}\n\n\t/**\n\t * Get a proxy. Error if it doesn't exist.\n\t */\n\tprivate getProxy(proxyId: number | Module): ProxyData {\n\t\tif (!this.proxies.has(proxyId)) {\n\t\t\tthrow new Error(`proxy ${proxyId} disposed too early`);\n\t\t}\n\n\t\treturn this.proxies.get(proxyId)!;\n\t}\n}\n"]}]}