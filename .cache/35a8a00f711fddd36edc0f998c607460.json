{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/electron-browser/main.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/electron-browser/main.ts","mtime":1555846338044},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"fs\", \"graceful-fs\", \"crypto\", \"vs/base/common/performance\", \"vs/workbench/browser/workbench\", \"vs/workbench/electron-browser/window\", \"vs/base/browser/browser\", \"vs/base/browser/dom\", \"vs/base/common/errors\", \"vs/base/common/platform\", \"vs/base/common/uri\", \"vs/workbench/services/configuration/node/configurationService\", \"vs/platform/instantiation/common/descriptors\", \"vs/platform/instantiation/common/serviceCollection\", \"vs/base/node/pfs\", \"vs/platform/environment/node/environmentService\", \"vs/workbench/services/keybinding/electron-browser/keybindingService\", \"vs/platform/windows/common/windows\", \"vs/platform/windows/electron-browser/windowService\", \"vs/platform/environment/common/environment\", \"electron\", \"vs/platform/workspaces/common/workspaces\", \"vs/platform/log/node/spdlogService\", \"vs/platform/log/common/log\", \"vs/platform/storage/node/storageService\", \"vs/platform/log/node/logIpc\", \"vs/base/common/network\", \"vs/base/node/extfs\", \"vs/base/common/path\", \"vs/platform/storage/node/storageIpc\", \"vs/platform/workspace/common/workspace\", \"vs/platform/configuration/common/configuration\", \"vs/platform/storage/common/storage\", \"vs/base/common/lifecycle\", \"vs/platform/driver/electron-browser/driver\", \"vs/platform/ipc/electron-browser/mainProcessService\", \"vs/platform/remote/electron-browser/remoteAuthorityResolverService\", \"vs/platform/remote/common/remoteAuthorityResolver\", \"vs/workbench/services/remote/electron-browser/remoteAgentServiceImpl\", \"vs/workbench/services/remote/common/remoteAgentService\", \"vs/workbench/services/files2/common/fileService2\", \"vs/platform/files/common/files\", \"vs/workbench/services/files2/electron-browser/diskFileSystemProvider\", \"vs/platform/remote/common/remoteAgentFileSystemChannel\", \"vs/platform/remote/common/remoteHosts\"], function (require, exports, fs, gracefulFs, crypto_1, performance_1, workbench_1, window_1, browser_1, dom_1, errors_1, platform_1, uri_1, configurationService_1, descriptors_1, serviceCollection_1, pfs_1, environmentService_1, keybindingService_1, windows_1, windowService_1, environment_1, electron_1, workspaces_1, spdlogService_1, log_1, storageService_1, logIpc_1, network_1, extfs_1, path_1, storageIpc_1, workspace_1, configuration_1, storage_1, lifecycle_1, driver_1, mainProcessService_1, remoteAuthorityResolverService_1, remoteAuthorityResolver_1, remoteAgentServiceImpl_1, remoteAgentService_1, fileService2_1, files_1, diskFileSystemProvider_1, remoteAgentFileSystemChannel_1, remoteHosts_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class CodeRendererMain extends lifecycle_1.Disposable {\n        constructor(configuration) {\n            super();\n            this.configuration = configuration;\n            this.init();\n        }\n        init() {\n            // Enable gracefulFs\n            gracefulFs.gracefulify(fs);\n            // Massage configuration file URIs\n            this.reviveUris();\n            // Setup perf\n            performance_1.importEntries(this.configuration.perfEntries);\n            // Browser config\n            browser_1.setZoomFactor(electron_1.webFrame.getZoomFactor()); // Ensure others can listen to zoom level changes\n            browser_1.setZoomLevel(electron_1.webFrame.getZoomLevel(), true /* isTrusted */); // Can be trusted because we are not setting it ourselves (https://github.com/Microsoft/vscode/issues/26151)\n            browser_1.setFullscreen(!!this.configuration.fullscreen);\n            // Keyboard support\n            keybindingService_1.KeyboardMapperFactory.INSTANCE._onKeyboardLayoutChanged();\n        }\n        reviveUris() {\n            if (this.configuration.folderUri) {\n                this.configuration.folderUri = uri_1.URI.revive(this.configuration.folderUri);\n            }\n            if (this.configuration.workspace) {\n                this.configuration.workspace = workspaces_1.reviveWorkspaceIdentifier(this.configuration.workspace);\n            }\n            const filesToWait = this.configuration.filesToWait;\n            const filesToWaitPaths = filesToWait && filesToWait.paths;\n            [filesToWaitPaths, this.configuration.filesToOpen, this.configuration.filesToCreate, this.configuration.filesToDiff].forEach(paths => {\n                if (Array.isArray(paths)) {\n                    paths.forEach(path => {\n                        if (path.fileUri) {\n                            path.fileUri = uri_1.URI.revive(path.fileUri);\n                        }\n                    });\n                }\n            });\n            if (filesToWait) {\n                filesToWait.waitMarkerFileUri = uri_1.URI.revive(filesToWait.waitMarkerFileUri);\n            }\n        }\n        open() {\n            return this.initServices().then(services => {\n                return dom_1.domContentLoaded().then(() => {\n                    performance_1.mark('willStartWorkbench');\n                    // Create Workbench\n                    this.workbench = new workbench_1.Workbench(document.body, services.serviceCollection, services.logService);\n                    // Layout\n                    this._register(dom_1.addDisposableListener(window, dom_1.EventType.RESIZE, e => this.onWindowResize(e, true)));\n                    // Workbench Lifecycle\n                    this._register(this.workbench.onShutdown(() => this.dispose()));\n                    this._register(this.workbench.onWillShutdown(event => event.join(services.storageService.close())));\n                    // Startup\n                    const instantiationService = this.workbench.startup();\n                    // Window\n                    this._register(instantiationService.createInstance(window_1.ElectronWindow));\n                    // Driver\n                    if (this.configuration.driver) {\n                        instantiationService.invokeFunction(accessor => driver_1.registerWindowDriver(accessor).then(disposable => this._register(disposable)));\n                    }\n                    // Config Exporter\n                    if (this.configuration['export-default-configuration']) {\n                        instantiationService.createInstance(configurationService_1.DefaultConfigurationExportHelper);\n                    }\n                    // Logging\n                    services.logService.trace('workbench configuration', JSON.stringify(this.configuration));\n                    require('vs/../../../../packages/vscode/src/workbench').workbench.serviceCollection = services.serviceCollection;\n                });\n            });\n        }\n        onWindowResize(e, retry) {\n            if (e.target === window) {\n                if (window.document && window.document.body && window.document.body.clientWidth === 0) {\n                    // TODO@Ben this is an electron issue on macOS when simple fullscreen is enabled\n                    // where for some reason the window clientWidth is reported as 0 when switching\n                    // between simple fullscreen and normal screen. In that case we schedule the layout\n                    // call at the next animation frame once, in the hope that the dimensions are\n                    // proper then.\n                    if (retry) {\n                        dom_1.scheduleAtNextAnimationFrame(() => this.onWindowResize(e, false));\n                    }\n                    return;\n                }\n                this.workbench.layout();\n            }\n        }\n        initServices() {\n            const serviceCollection = new serviceCollection_1.ServiceCollection();\n            // Main Process\n            const mainProcessService = this._register(new mainProcessService_1.MainProcessService(this.configuration.windowId));\n            serviceCollection.set(mainProcessService_1.IMainProcessService, mainProcessService);\n            // Window\n            serviceCollection.set(windows_1.IWindowService, new descriptors_1.SyncDescriptor(windowService_1.WindowService, [this.configuration]));\n            // Environment\n            const environmentService = new environmentService_1.EnvironmentService(this.configuration, this.configuration.execPath);\n            serviceCollection.set(environment_1.IEnvironmentService, environmentService);\n            // Log\n            const logService = this._register(this.createLogService(mainProcessService, environmentService));\n            serviceCollection.set(log_1.ILogService, logService);\n            // Remote\n            const remoteAuthorityResolverService = new remoteAuthorityResolverService_1.RemoteAuthorityResolverService();\n            serviceCollection.set(remoteAuthorityResolver_1.IRemoteAuthorityResolverService, remoteAuthorityResolverService);\n            const remoteAgentService = new remoteAgentServiceImpl_1.RemoteAgentService(this.configuration, environmentService, remoteAuthorityResolverService);\n            serviceCollection.set(remoteAgentService_1.IRemoteAgentService, remoteAgentService);\n            // Files\n            const fileService = new fileService2_1.FileService2(logService);\n            serviceCollection.set(files_1.IFileService, fileService);\n            fileService.registerProvider(network_1.Schemas.file, new diskFileSystemProvider_1.DiskFileSystemProvider(logService));\n            const connection = remoteAgentService.getConnection();\n            if (connection) {\n                const channel = connection.getChannel(remoteAgentFileSystemChannel_1.REMOTE_FILE_SYSTEM_CHANNEL_NAME);\n                fileService.registerProvider(remoteHosts_1.REMOTE_HOST_SCHEME, new remoteAgentFileSystemChannel_1.RemoteExtensionsFileSystemProvider(channel, remoteAgentService.getEnvironment()));\n            }\n            return this.resolveWorkspaceInitializationPayload(environmentService).then(payload => Promise.all([\n                this.createWorkspaceService(payload, environmentService, remoteAgentService, logService).then(service => {\n                    // Workspace\n                    serviceCollection.set(workspace_1.IWorkspaceContextService, service);\n                    // Configuration\n                    serviceCollection.set(configuration_1.IConfigurationService, service);\n                    return service;\n                }),\n                this.createStorageService(payload, environmentService, logService, mainProcessService).then(service => {\n                    // Storage\n                    serviceCollection.set(storage_1.IStorageService, service);\n                    return service;\n                })\n            ]).then(services => ({ serviceCollection, logService, storageService: services[1] })));\n        }\n        resolveWorkspaceInitializationPayload(environmentService) {\n            // Multi-root workspace\n            if (this.configuration.workspace) {\n                return Promise.resolve(this.configuration.workspace);\n            }\n            // Single-folder workspace\n            let workspaceInitializationPayload = Promise.resolve(undefined);\n            if (this.configuration.folderUri) {\n                workspaceInitializationPayload = this.resolveSingleFolderWorkspaceInitializationPayload(this.configuration.folderUri);\n            }\n            return workspaceInitializationPayload.then(payload => {\n                // Fallback to empty workspace if we have no payload yet.\n                if (!payload) {\n                    let id;\n                    if (this.configuration.backupPath) {\n                        id = path_1.basename(this.configuration.backupPath); // we know the backupPath must be a unique path so we leverage its name as workspace ID\n                    }\n                    else if (environmentService.isExtensionDevelopment) {\n                        id = 'ext-dev'; // extension development window never stores backups and is a singleton\n                    }\n                    else {\n                        return Promise.reject(new Error('Unexpected window configuration without backupPath'));\n                    }\n                    payload = { id };\n                }\n                return payload;\n            });\n        }\n        resolveSingleFolderWorkspaceInitializationPayload(folderUri) {\n            // Return early the folder is not local\n            if (folderUri.scheme !== network_1.Schemas.file) {\n                return Promise.resolve({ id: crypto_1.createHash('md5').update(folderUri.toString()).digest('hex'), folder: folderUri });\n            }\n            function computeLocalDiskFolderId(folder, stat) {\n                let ctime;\n                if (platform_1.isLinux) {\n                    ctime = stat.ino; // Linux: birthtime is ctime, so we cannot use it! We use the ino instead!\n                }\n                else if (platform_1.isMacintosh) {\n                    ctime = stat.birthtime.getTime(); // macOS: birthtime is fine to use as is\n                }\n                else if (platform_1.isWindows) {\n                    if (typeof stat.birthtimeMs === 'number') {\n                        ctime = Math.floor(stat.birthtimeMs); // Windows: fix precision issue in node.js 8.x to get 7.x results (see https://github.com/nodejs/node/issues/19897)\n                    }\n                    else {\n                        ctime = stat.birthtime.getTime();\n                    }\n                }\n                // we use the ctime as extra salt to the ID so that we catch the case of a folder getting\n                // deleted and recreated. in that case we do not want to carry over previous state\n                return crypto_1.createHash('md5').update(folder.fsPath).update(ctime ? String(ctime) : '').digest('hex');\n            }\n            // For local: ensure path is absolute and exists\n            const sanitizedFolderPath = extfs_1.sanitizeFilePath(folderUri.fsPath, process.env['VSCODE_CWD'] || process.cwd());\n            return pfs_1.stat(sanitizedFolderPath).then(stat => {\n                const sanitizedFolderUri = uri_1.URI.file(sanitizedFolderPath);\n                return {\n                    id: computeLocalDiskFolderId(sanitizedFolderUri, stat),\n                    folder: sanitizedFolderUri\n                };\n            }, error => errors_1.onUnexpectedError(error));\n        }\n        createWorkspaceService(payload, environmentService, remoteAgentService, logService) {\n            const workspaceService = new configurationService_1.WorkspaceService(this.configuration, environmentService, remoteAgentService);\n            return workspaceService.initialize(payload).then(() => workspaceService, error => {\n                errors_1.onUnexpectedError(error);\n                logService.error(error);\n                return workspaceService;\n            });\n        }\n        createStorageService(payload, environmentService, logService, mainProcessService) {\n            const globalStorageDatabase = new storageIpc_1.GlobalStorageDatabaseChannelClient(mainProcessService.getChannel('storage'));\n            const storageService = new storageService_1.StorageService(globalStorageDatabase, logService, environmentService);\n            return storageService.initialize(payload).then(() => storageService, error => {\n                errors_1.onUnexpectedError(error);\n                logService.error(error);\n                return storageService;\n            });\n        }\n        createLogService(mainProcessService, environmentService) {\n            const spdlogService = spdlogService_1.createSpdLogService(`renderer${this.configuration.windowId}`, this.configuration.logLevel, environmentService.logsPath);\n            const consoleLogService = new log_1.ConsoleLogService(this.configuration.logLevel);\n            const logService = new log_1.MultiplexLogService([consoleLogService, spdlogService]);\n            const logLevelClient = new logIpc_1.LogLevelSetterChannelClient(mainProcessService.getChannel('loglevel'));\n            return new logIpc_1.FollowerLogService(logLevelClient, logService);\n        }\n    }\n    function main(configuration) {\n        const renderer = new CodeRendererMain(configuration);\n        return renderer.open();\n    }\n    exports.main = main;\n});\n",null]}