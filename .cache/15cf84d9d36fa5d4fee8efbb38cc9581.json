{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/commands/common/commandService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/commands/common/commandService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar commands_1 = require(\"vs/platform/commands/common/commands\");\nvar extensions_1 = require(\"vs/workbench/services/extensions/common/extensions\");\nvar event_1 = require(\"vs/base/common/event\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar log_1 = require(\"vs/platform/log/common/log\");\nvar extensions_2 = require(\"vs/platform/instantiation/common/extensions\");\nvar CommandService = /** @class */ (function (_super) {\n    tslib_1.__extends(CommandService, _super);\n    function CommandService(_instantiationService, _extensionService, _logService) {\n        var _this = _super.call(this) || this;\n        _this._instantiationService = _instantiationService;\n        _this._extensionService = _extensionService;\n        _this._logService = _logService;\n        _this._extensionHostIsReady = false;\n        _this._onWillExecuteCommand = _this._register(new event_1.Emitter());\n        _this.onWillExecuteCommand = _this._onWillExecuteCommand.event;\n        _this._extensionService.whenInstalledExtensionsRegistered().then(function (value) { return _this._extensionHostIsReady = value; });\n        return _this;\n    }\n    CommandService.prototype.executeCommand = function (id) {\n        var _this = this;\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        this._logService.trace('CommandService#executeCommand', id);\n        // we always send an activation event, but\n        // we don't wait for it when the extension\n        // host didn't yet start and the command is already registered\n        var activation = this._extensionService.activateByEvent(\"onCommand:\" + id);\n        var commandIsRegistered = !!commands_1.CommandsRegistry.getCommand(id);\n        if (!this._extensionHostIsReady && commandIsRegistered) {\n            return this._tryExecuteCommand(id, args);\n        }\n        else {\n            var waitFor = activation;\n            if (!commandIsRegistered) {\n                waitFor = Promise.race([\n                    // race activation events against command registration\n                    Promise.all([activation, this._extensionService.activateByEvent(\"*\")]),\n                    event_1.Event.toPromise(event_1.Event.filter(commands_1.CommandsRegistry.onDidRegisterCommand, function (e) { return e === id; })),\n                ]);\n            }\n            return waitFor.then(function (_) { return _this._tryExecuteCommand(id, args); });\n        }\n    };\n    CommandService.prototype._tryExecuteCommand = function (id, args) {\n        var command = commands_1.CommandsRegistry.getCommand(id);\n        if (!command) {\n            return Promise.reject(new Error(\"command '\" + id + \"' not found\"));\n        }\n        try {\n            this._onWillExecuteCommand.fire({ commandId: id });\n            var result = this._instantiationService.invokeFunction.apply(this._instantiationService, [command.handler].concat(args));\n            return Promise.resolve(result);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    };\n    CommandService = tslib_1.__decorate([\n        tslib_1.__param(0, instantiation_1.IInstantiationService),\n        tslib_1.__param(1, extensions_1.IExtensionService),\n        tslib_1.__param(2, log_1.ILogService)\n    ], CommandService);\n    return CommandService;\n}(lifecycle_1.Disposable));\nexports.CommandService = CommandService;\nextensions_2.registerSingleton(commands_1.ICommandService, CommandService, true);\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/commands/common/commandService.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/commands/common/commandService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';\nimport { ICommandService, ICommandEvent, CommandsRegistry } from 'vs/platform/commands/common/commands';\nimport { IExtensionService } from 'vs/workbench/services/extensions/common/extensions';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { registerSingleton } from 'vs/platform/instantiation/common/extensions';\n\nexport class CommandService extends Disposable implements ICommandService {\n\n\t_serviceBrand: any;\n\n\tprivate _extensionHostIsReady: boolean = false;\n\n\tprivate readonly _onWillExecuteCommand: Emitter<ICommandEvent> = this._register(new Emitter<ICommandEvent>());\n\tpublic readonly onWillExecuteCommand: Event<ICommandEvent> = this._onWillExecuteCommand.event;\n\n\tconstructor(\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@IExtensionService private readonly _extensionService: IExtensionService,\n\t\t@ILogService private readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\t\tthis._extensionService.whenInstalledExtensionsRegistered().then(value => this._extensionHostIsReady = value);\n\t}\n\n\texecuteCommand<T>(id: string, ...args: any[]): Promise<T> {\n\t\tthis._logService.trace('CommandService#executeCommand', id);\n\n\t\t// we always send an activation event, but\n\t\t// we don't wait for it when the extension\n\t\t// host didn't yet start and the command is already registered\n\n\t\tconst activation: Promise<any> = this._extensionService.activateByEvent(`onCommand:${id}`);\n\t\tconst commandIsRegistered = !!CommandsRegistry.getCommand(id);\n\n\t\tif (!this._extensionHostIsReady && commandIsRegistered) {\n\t\t\treturn this._tryExecuteCommand(id, args);\n\t\t} else {\n\t\t\tlet waitFor = activation;\n\t\t\tif (!commandIsRegistered) {\n\t\t\t\twaitFor = Promise.race<any>([\n\t\t\t\t\t// race activation events against command registration\n\t\t\t\t\tPromise.all([activation, this._extensionService.activateByEvent(`*`)]),\n\t\t\t\t\tEvent.toPromise(Event.filter(CommandsRegistry.onDidRegisterCommand, e => e === id)),\n\t\t\t\t]);\n\t\t\t}\n\t\t\treturn (waitFor as Promise<any>).then(_ => this._tryExecuteCommand(id, args));\n\t\t}\n\t}\n\n\tprivate _tryExecuteCommand(id: string, args: any[]): Promise<any> {\n\t\tconst command = CommandsRegistry.getCommand(id);\n\t\tif (!command) {\n\t\t\treturn Promise.reject(new Error(`command '${id}' not found`));\n\t\t}\n\t\ttry {\n\t\t\tthis._onWillExecuteCommand.fire({ commandId: id });\n\t\t\tconst result = this._instantiationService.invokeFunction.apply(this._instantiationService, [command.handler, ...args]);\n\t\t\treturn Promise.resolve(result);\n\t\t} catch (err) {\n\t\t\treturn Promise.reject(err);\n\t\t}\n\t}\n}\n\nregisterSingleton(ICommandService, CommandService, true);"]}]}