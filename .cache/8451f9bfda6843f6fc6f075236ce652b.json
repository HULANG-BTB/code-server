{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/fileService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/fileService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar paths = require(\"vs/base/common/path\");\nvar fs = require(\"fs\");\nvar os = require(\"os\");\nvar crypto = require(\"crypto\");\nvar assert = require(\"assert\");\nvar files_1 = require(\"vs/platform/files/common/files\");\nvar fileConstants_1 = require(\"vs/platform/files/node/fileConstants\");\nvar extpath_1 = require(\"vs/base/common/extpath\");\nvar map_1 = require(\"vs/base/common/map\");\nvar arrays = require(\"vs/base/common/arrays\");\nvar objects = require(\"vs/base/common/objects\");\nvar extfs = require(\"vs/base/node/extfs\");\nvar async_1 = require(\"vs/base/common/async\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar nls = require(\"vs/nls\");\nvar platform_1 = require(\"vs/base/common/platform\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar workspace_1 = require(\"vs/platform/workspace/common/workspace\");\nvar pfs = require(\"vs/base/node/pfs\");\nvar encoding_1 = require(\"vs/base/node/encoding\");\nvar flow = require(\"vs/base/node/flow\");\nvar watcherService_1 = require(\"vs/workbench/services/files/node/watcher/unix/watcherService\");\nvar watcherService_2 = require(\"vs/workbench/services/files/node/watcher/win32/watcherService\");\nvar common_1 = require(\"vs/workbench/services/files/node/watcher/common\");\nvar event_1 = require(\"vs/base/common/event\");\nvar watcherService_3 = require(\"vs/workbench/services/files/node/watcher/nsfw/watcherService\");\nvar cancellation_1 = require(\"vs/base/common/cancellation\");\nvar lifecycle_2 = require(\"vs/platform/lifecycle/common/lifecycle\");\nvar labels_1 = require(\"vs/base/common/labels\");\nvar network_1 = require(\"vs/base/common/network\");\nvar storage_1 = require(\"vs/platform/storage/common/storage\");\nvar notification_1 = require(\"vs/platform/notification/common/notification\");\nvar errors_1 = require(\"vs/base/common/errors\");\nvar product_1 = require(\"vs/platform/product/node/product\");\nvar encoding_2 = require(\"vs/workbench/services/files/node/encoding\");\nvar streams_1 = require(\"vs/workbench/services/files/node/streams\");\nvar types_1 = require(\"vs/base/common/types\");\nvar FileService = /** @class */ (function (_super) {\n    tslib_1.__extends(FileService, _super);\n    function FileService(contextService, environmentService, textResourceConfigurationService, configurationService, lifecycleService, storageService, notificationService, options) {\n        if (options === void 0) { options = Object.create(null); }\n        var _this = _super.call(this) || this;\n        _this.contextService = contextService;\n        _this.environmentService = environmentService;\n        _this.textResourceConfigurationService = textResourceConfigurationService;\n        _this.configurationService = configurationService;\n        _this.lifecycleService = lifecycleService;\n        _this.storageService = storageService;\n        _this.notificationService = notificationService;\n        _this.options = options;\n        _this._onFileChanges = _this._register(new event_1.Emitter());\n        _this._onAfterOperation = _this._register(new event_1.Emitter());\n        _this._onDidChangeFileSystemProviderRegistrations = _this._register(new event_1.Emitter());\n        _this.onWillActivateFileSystemProvider = event_1.Event.None;\n        _this.activeFileChangesWatchers = new map_1.ResourceMap();\n        _this.fileChangesWatchDelayer = new async_1.ThrottledDelayer(FileService.FS_EVENT_DELAY);\n        _this.undeliveredRawFileChangesEvents = [];\n        _this._encoding = new encoding_2.ResourceEncodings(textResourceConfigurationService, environmentService, contextService, _this.options.encodingOverride);\n        _this.registerListeners();\n        return _this;\n    }\n    Object.defineProperty(FileService.prototype, \"onFileChanges\", {\n        get: function () { return this._onFileChanges.event; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FileService.prototype, \"onAfterOperation\", {\n        get: function () { return this._onAfterOperation.event; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FileService.prototype, \"onDidChangeFileSystemProviderRegistrations\", {\n        get: function () { return this._onDidChangeFileSystemProviderRegistrations.event; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FileService.prototype, \"encoding\", {\n        get: function () {\n            return this._encoding;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    FileService.prototype.registerListeners = function () {\n        var _this = this;\n        // Wait until we are fully running before starting file watchers\n        this.lifecycleService.when(lifecycle_2.LifecyclePhase.Restored).then(function () {\n            _this.setupFileWatching();\n        });\n        // Workbench State Change\n        this._register(this.contextService.onDidChangeWorkbenchState(function () {\n            if (_this.lifecycleService.phase >= lifecycle_2.LifecyclePhase.Restored) {\n                _this.setupFileWatching();\n            }\n        }));\n        // Lifecycle\n        this.lifecycleService.onShutdown(this.dispose, this);\n    };\n    FileService.prototype.handleError = function (error) {\n        var _this = this;\n        var msg = error ? error.toString() : undefined;\n        if (!msg) {\n            return;\n        }\n        // Forward to unexpected error handler\n        errors_1.onUnexpectedError(msg);\n        // Detect if we run < .NET Framework 4.5 (TODO@ben remove with new watcher impl)\n        if (msg.indexOf(FileService.NET_VERSION_ERROR) >= 0 && !this.storageService.getBoolean(FileService.NET_VERSION_ERROR_IGNORE_KEY, storage_1.StorageScope.WORKSPACE)) {\n            this.notificationService.prompt(notification_1.Severity.Warning, nls.localize('netVersionError', \"The Microsoft .NET Framework 4.5 is required. Please follow the link to install it.\"), [{\n                    label: nls.localize('installNet', \"Download .NET Framework 4.5\"),\n                    run: function () { return window.open('https://go.microsoft.com/fwlink/?LinkId=786533'); }\n                },\n                {\n                    label: nls.localize('neverShowAgain', \"Don't Show Again\"),\n                    isSecondary: true,\n                    run: function () { return _this.storageService.store(FileService.NET_VERSION_ERROR_IGNORE_KEY, true, storage_1.StorageScope.WORKSPACE); }\n                }], { sticky: true });\n        }\n        // Detect if we run into ENOSPC issues\n        if (msg.indexOf(FileService.ENOSPC_ERROR) >= 0 && !this.storageService.getBoolean(FileService.ENOSPC_ERROR_IGNORE_KEY, storage_1.StorageScope.WORKSPACE)) {\n            this.notificationService.prompt(notification_1.Severity.Warning, nls.localize('enospcError', \"{0} is unable to watch for file changes in this large workspace. Please follow the instructions link to resolve this issue.\", product_1.default.nameLong), [{\n                    label: nls.localize('learnMore', \"Instructions\"),\n                    run: function () { return window.open('https://go.microsoft.com/fwlink/?linkid=867693'); }\n                },\n                {\n                    label: nls.localize('neverShowAgain', \"Don't Show Again\"),\n                    isSecondary: true,\n                    run: function () { return _this.storageService.store(FileService.ENOSPC_ERROR_IGNORE_KEY, true, storage_1.StorageScope.WORKSPACE); }\n                }], { sticky: true });\n        }\n    };\n    FileService.prototype.setupFileWatching = function () {\n        var _this = this;\n        // dispose old if any\n        if (this.activeWorkspaceFileChangeWatcher) {\n            this.activeWorkspaceFileChangeWatcher.dispose();\n        }\n        // Return if not aplicable\n        var workbenchState = this.contextService.getWorkbenchState();\n        if (workbenchState === workspace_1.WorkbenchState.EMPTY || this.options.disableWatcher) {\n            return;\n        }\n        // new watcher: use it if setting tells us so or we run in multi-root environment\n        var configuration = this.configurationService.getValue();\n        if ((configuration.files && configuration.files.useExperimentalFileWatcher) || workbenchState === workspace_1.WorkbenchState.WORKSPACE) {\n            var multiRootWatcher = new watcherService_3.FileWatcher(this.contextService, this.configurationService, function (e) { return _this._onFileChanges.fire(e); }, function (err) { return _this.handleError(err); }, this.environmentService.verbose);\n            this.activeWorkspaceFileChangeWatcher = lifecycle_1.toDisposable(multiRootWatcher.startWatching());\n        }\n        // legacy watcher\n        else {\n            var watcherIgnoredPatterns = [];\n            if (configuration.files && configuration.files.watcherExclude) {\n                watcherIgnoredPatterns = Object.keys(configuration.files.watcherExclude).filter(function (k) { return !!configuration.files.watcherExclude[k]; });\n            }\n            if (platform_1.isWindows) {\n                var legacyWindowsWatcher = new watcherService_2.FileWatcher(this.contextService, watcherIgnoredPatterns, function (e) { return _this._onFileChanges.fire(e); }, function (err) { return _this.handleError(err); }, this.environmentService.verbose);\n                this.activeWorkspaceFileChangeWatcher = lifecycle_1.toDisposable(legacyWindowsWatcher.startWatching());\n            }\n            else {\n                var legacyUnixWatcher = new watcherService_1.FileWatcher(this.contextService, this.configurationService, function (e) { return _this._onFileChanges.fire(e); }, function (err) { return _this.handleError(err); }, this.environmentService.verbose);\n                this.activeWorkspaceFileChangeWatcher = lifecycle_1.toDisposable(legacyUnixWatcher.startWatching());\n            }\n        }\n    };\n    FileService.prototype.registerProvider = function (scheme, provider) {\n        return lifecycle_1.Disposable.None;\n    };\n    FileService.prototype.activateProvider = function (scheme) {\n        return Promise.reject(new Error('not implemented'));\n    };\n    FileService.prototype.canHandleResource = function (resource) {\n        return resource.scheme === network_1.Schemas.file;\n    };\n    FileService.prototype.hasCapability = function (resource, capability) {\n        return Promise.resolve(false);\n    };\n    FileService.prototype.resolveContent = function (resource, options) {\n        return this.resolveStreamContent(resource, options).then(function (streamContent) {\n            return new Promise(function (resolve, reject) {\n                var result = {\n                    resource: streamContent.resource,\n                    name: streamContent.name,\n                    mtime: streamContent.mtime,\n                    etag: streamContent.etag,\n                    encoding: streamContent.encoding,\n                    isReadonly: streamContent.isReadonly,\n                    size: streamContent.size,\n                    value: ''\n                };\n                streamContent.value.on('data', function (chunk) { return result.value += chunk; });\n                streamContent.value.on('error', function (err) { return reject(err); });\n                streamContent.value.on('end', function () { return resolve(result); });\n                return result;\n            });\n        });\n    };\n    FileService.prototype.resolveStreamContent = function (resource, options) {\n        var _this = this;\n        // Guard early against attempts to resolve an invalid file path\n        if (resource.scheme !== network_1.Schemas.file || !resource.fsPath) {\n            return Promise.reject(new files_1.FileOperationError(nls.localize('fileInvalidPath', \"Invalid file resource ({0})\", resource.toString(true)), files_1.FileOperationResult.FILE_INVALID_PATH, options));\n        }\n        var result = {\n            resource: undefined,\n            name: undefined,\n            mtime: undefined,\n            etag: undefined,\n            encoding: undefined,\n            isReadonly: false,\n            value: undefined\n        };\n        var contentResolverTokenSource = new cancellation_1.CancellationTokenSource();\n        var onStatError = function (error) {\n            // error: stop reading the file the stat and content resolve call\n            // usually race, mostly likely the stat call will win and cancel\n            // the content call\n            contentResolverTokenSource.cancel();\n            // forward error\n            return Promise.reject(error);\n        };\n        var statsPromise = this.resolveFile(resource).then(function (stat) {\n            result.resource = stat.resource;\n            result.name = stat.name;\n            result.mtime = stat.mtime;\n            result.etag = stat.etag;\n            result.size = stat.size;\n            // Return early if resource is a directory\n            if (stat.isDirectory) {\n                return onStatError(new files_1.FileOperationError(nls.localize('fileIsDirectoryError', \"File is directory\"), files_1.FileOperationResult.FILE_IS_DIRECTORY, options));\n            }\n            // Return early if file not modified since\n            if (options && options.etag && options.etag === stat.etag) {\n                return onStatError(new files_1.FileOperationError(nls.localize('fileNotModifiedError', \"File not modified since\"), files_1.FileOperationResult.FILE_NOT_MODIFIED_SINCE, options));\n            }\n            // Return early if file is too large to load\n            if (typeof stat.size === 'number') {\n                if (stat.size > Math.max(typeof _this.environmentService.args['max-memory'] === 'string' ? parseInt(_this.environmentService.args['max-memory']) * 1024 * 1024 || 0 : 0, fileConstants_1.MAX_HEAP_SIZE)) {\n                    return onStatError(new files_1.FileOperationError(nls.localize('fileTooLargeForHeapError', \"To open a file of this size, you need to restart VS Code and allow it to use more memory\"), files_1.FileOperationResult.FILE_EXCEED_MEMORY_LIMIT));\n                }\n                if (stat.size > fileConstants_1.MAX_FILE_SIZE) {\n                    return onStatError(new files_1.FileOperationError(nls.localize('fileTooLargeError', \"File too large to open\"), files_1.FileOperationResult.FILE_TOO_LARGE));\n                }\n            }\n            return undefined;\n        }, function (err) {\n            // Wrap file not found errors\n            if (err.code === 'ENOENT') {\n                return onStatError(new files_1.FileOperationError(nls.localize('fileNotFoundError', \"File not found ({0})\", resource.toString(true)), files_1.FileOperationResult.FILE_NOT_FOUND, options));\n            }\n            return onStatError(err);\n        });\n        var completePromise;\n        // await the stat iff we already have an etag so that we compare the\n        // etag from the stat before we actually read the file again.\n        if (options && options.etag) {\n            completePromise = statsPromise.then(function () {\n                return _this.fillInContents(result, resource, options, contentResolverTokenSource.token); // Waterfall -> only now resolve the contents\n            });\n        }\n        // a fresh load without a previous etag which means we can resolve the file stat\n        // and the content at the same time, avoiding the waterfall.\n        else {\n            var statsError_1;\n            var contentsError_1;\n            completePromise = Promise.all([\n                statsPromise.then(function () { return undefined; }, function (error) { return statsError_1 = error; }),\n                this.fillInContents(result, resource, options, contentResolverTokenSource.token).then(function () { return undefined; }, function (error) { return contentsError_1 = error; })\n            ]).then(function () {\n                // Since each file operation can return a FileOperationError\n                // we want to prefer that one if possible. Otherwise we just\n                // return with the first error we get.\n                if (files_1.FileOperationError.isFileOperationError(statsError_1)) {\n                    return Promise.reject(statsError_1);\n                }\n                if (files_1.FileOperationError.isFileOperationError(contentsError_1)) {\n                    return Promise.reject(contentsError_1);\n                }\n                if (statsError_1 || contentsError_1) {\n                    return Promise.reject(statsError_1 || contentsError_1);\n                }\n                return undefined;\n            });\n        }\n        return completePromise.then(function () {\n            contentResolverTokenSource.dispose();\n            return result;\n        }, function (error) {\n            contentResolverTokenSource.dispose();\n            return Promise.reject(error);\n        });\n    };\n    FileService.prototype.fillInContents = function (content, resource, options, token) {\n        return this.resolveFileData(resource, options, token).then(function (data) {\n            content.encoding = data.encoding;\n            content.value = data.stream;\n        });\n    };\n    FileService.prototype.resolveFileData = function (resource, options, token) {\n        var _this = this;\n        var chunkBuffer = Buffer.allocUnsafe(64 * 1024);\n        var result = {\n            encoding: undefined,\n            stream: undefined\n        };\n        return new Promise(function (resolve, reject) {\n            fs.open(_this.toAbsolutePath(resource), 'r', function (err, fd) {\n                if (err) {\n                    if (err.code === 'ENOENT') {\n                        // Wrap file not found errors\n                        err = new files_1.FileOperationError(nls.localize('fileNotFoundError', \"File not found ({0})\", resource.toString(true)), files_1.FileOperationResult.FILE_NOT_FOUND, options);\n                    }\n                    return reject(err);\n                }\n                var decoder;\n                var totalBytesRead = 0;\n                var finish = function (err) {\n                    if (err) {\n                        if (err.code === 'EISDIR') {\n                            // Wrap EISDIR errors (fs.open on a directory works, but you cannot read from it)\n                            err = new files_1.FileOperationError(nls.localize('fileIsDirectoryError', \"File is directory\"), files_1.FileOperationResult.FILE_IS_DIRECTORY, options);\n                        }\n                        if (decoder) {\n                            // If the decoder already started, we have to emit the error through it as\n                            // event because the promise is already resolved!\n                            decoder.emit('error', err);\n                        }\n                        else {\n                            reject(err);\n                        }\n                    }\n                    if (decoder) {\n                        decoder.end();\n                    }\n                    if (fd) {\n                        fs.close(fd, function (err) {\n                            if (err) {\n                                _this.handleError(\"resolveFileData#close(): \" + err.toString());\n                            }\n                        });\n                    }\n                };\n                var handleChunk = function (bytesRead) {\n                    if (token.isCancellationRequested) {\n                        // cancellation -> finish\n                        finish(new Error('cancelled'));\n                    }\n                    else if (bytesRead === 0) {\n                        // no more data -> finish\n                        finish();\n                    }\n                    else if (bytesRead < chunkBuffer.length) {\n                        // write the sub-part of data we received -> repeat\n                        decoder.write(chunkBuffer.slice(0, bytesRead), readChunk);\n                    }\n                    else {\n                        // write all data we received -> repeat\n                        decoder.write(chunkBuffer, readChunk);\n                    }\n                };\n                var currentPosition = types_1.withUndefinedAsNull(options && options.position);\n                var readChunk = function () {\n                    fs.read(fd, chunkBuffer, 0, chunkBuffer.length, currentPosition, function (err, bytesRead) {\n                        totalBytesRead += bytesRead;\n                        if (typeof currentPosition === 'number') {\n                            // if we received a position argument as option we need to ensure that\n                            // we advance the position by the number of bytesread\n                            currentPosition += bytesRead;\n                        }\n                        if (totalBytesRead > Math.max(typeof _this.environmentService.args['max-memory'] === 'number' ? parseInt(_this.environmentService.args['max-memory']) * 1024 * 1024 || 0 : 0, fileConstants_1.MAX_HEAP_SIZE)) {\n                            finish(new files_1.FileOperationError(nls.localize('fileTooLargeForHeapError', \"To open a file of this size, you need to restart VS Code and allow it to use more memory\"), files_1.FileOperationResult.FILE_EXCEED_MEMORY_LIMIT));\n                        }\n                        if (totalBytesRead > fileConstants_1.MAX_FILE_SIZE) {\n                            // stop when reading too much\n                            finish(new files_1.FileOperationError(nls.localize('fileTooLargeError', \"File too large to open\"), files_1.FileOperationResult.FILE_TOO_LARGE, options));\n                        }\n                        else if (err) {\n                            // some error happened\n                            finish(err);\n                        }\n                        else if (decoder) {\n                            // pass on to decoder\n                            handleChunk(bytesRead);\n                        }\n                        else {\n                            // when receiving the first chunk of data we need to create the\n                            // decoding stream which is then used to drive the string stream.\n                            Promise.resolve(encoding_1.detectEncodingFromBuffer({ buffer: chunkBuffer, bytesRead: bytesRead }, (options && options.autoGuessEncoding) || _this.textResourceConfigurationService.getValue(resource, 'files.autoGuessEncoding'))).then(function (detected) {\n                                if (options && options.acceptTextOnly && detected.seemsBinary) {\n                                    // Return error early if client only accepts text and this is not text\n                                    finish(new files_1.FileOperationError(nls.localize('fileBinaryError', \"File seems to be binary and cannot be opened as text\"), files_1.FileOperationResult.FILE_IS_BINARY, options));\n                                }\n                                else {\n                                    result.encoding = _this._encoding.getReadEncoding(resource, options, detected);\n                                    result.stream = decoder = encoding_1.decodeStream(result.encoding);\n                                    resolve(result);\n                                    handleChunk(bytesRead);\n                                }\n                            }).then(undefined, function (err) {\n                                // failed to get encoding\n                                finish(err);\n                            });\n                        }\n                    });\n                };\n                // start reading\n                readChunk();\n            });\n        });\n    };\n    FileService.prototype.updateContent = function (resource, value, options) {\n        if (options === void 0) { options = Object.create(null); }\n        if (options.writeElevated) {\n            return this.doUpdateContentElevated(resource, value, options);\n        }\n        return this.doUpdateContent(resource, value, options);\n    };\n    FileService.prototype.doUpdateContent = function (resource, value, options) {\n        var _this = this;\n        if (options === void 0) { options = Object.create(null); }\n        var absolutePath = this.toAbsolutePath(resource);\n        // 1.) check file for writing\n        return this.checkFileBeforeWriting(absolutePath, options).then(function (exists) {\n            var createParentsPromise;\n            if (exists) {\n                createParentsPromise = Promise.resolve();\n            }\n            else {\n                createParentsPromise = pfs.mkdirp(paths.dirname(absolutePath));\n            }\n            // 2.) create parents as needed\n            return createParentsPromise.then(function () {\n                var _a = _this._encoding.getWriteEncoding(resource, options.encoding), encoding = _a.encoding, hasBOM = _a.hasBOM;\n                var addBomPromise = Promise.resolve(false);\n                // Some encodings come with a BOM automatically\n                if (hasBOM) {\n                    addBomPromise = Promise.resolve(hasBOM);\n                }\n                // Existing UTF-8 file: check for options regarding BOM\n                else if (exists && encoding === encoding_1.UTF8) {\n                    if (options.overwriteEncoding) {\n                        addBomPromise = Promise.resolve(false); // if we are to overwrite the encoding, we do not preserve it if found\n                    }\n                    else {\n                        addBomPromise = encoding_1.detectEncodingByBOM(absolutePath).then(function (enc) { return enc === encoding_1.UTF8; }); // otherwise preserve it if found\n                    }\n                }\n                // 3.) check to add UTF BOM\n                return addBomPromise.then(function (addBom) {\n                    // 4.) set contents and resolve\n                    if (!exists || !platform_1.isWindows) {\n                        return _this.doSetContentsAndResolve(resource, absolutePath, value, addBom, encoding);\n                    }\n                    // On Windows and if the file exists, we use a different strategy of saving the file\n                    // by first truncating the file and then writing with r+ mode. This helps to save hidden files on Windows\n                    // (see https://github.com/Microsoft/vscode/issues/931) and prevent removing alternate data streams\n                    // (see https://github.com/Microsoft/vscode/issues/6363)\n                    else {\n                        // 4.) truncate\n                        return pfs.truncate(absolutePath, 0).then(function () {\n                            // 5.) set contents (with r+ mode) and resolve\n                            return _this.doSetContentsAndResolve(resource, absolutePath, value, addBom, encoding, { flag: 'r+' }).then(undefined, function (error) {\n                                if (_this.environmentService.verbose) {\n                                    console.error(\"Truncate succeeded, but save failed (\" + error + \"), retrying after 100ms\");\n                                }\n                                // We heard from one user that fs.truncate() succeeds, but the save fails (https://github.com/Microsoft/vscode/issues/61310)\n                                // In that case, the file is now entirely empty and the contents are gone. This can happen if an external file watcher is\n                                // installed that reacts on the truncate and keeps the file busy right after. Our workaround is to retry to save after a\n                                // short timeout, assuming that the file is free to write then.\n                                return async_1.timeout(100).then(function () { return _this.doSetContentsAndResolve(resource, absolutePath, value, addBom, encoding, { flag: 'r+' }); });\n                            });\n                        }, function (error) {\n                            if (_this.environmentService.verbose) {\n                                console.error(\"Truncate failed (\" + error + \"), falling back to normal save\");\n                            }\n                            // we heard from users that fs.truncate() fails (https://github.com/Microsoft/vscode/issues/59561)\n                            // in that case we simply save the file without truncating first (same as macOS and Linux)\n                            return _this.doSetContentsAndResolve(resource, absolutePath, value, addBom, encoding);\n                        });\n                    }\n                });\n            });\n        }).then(undefined, function (error) {\n            if (error.code === 'EACCES' || error.code === 'EPERM') {\n                return Promise.reject(new files_1.FileOperationError(nls.localize('filePermission', \"Permission denied writing to file ({0})\", resource.toString(true)), files_1.FileOperationResult.FILE_PERMISSION_DENIED, options));\n            }\n            return Promise.reject(error);\n        });\n    };\n    FileService.prototype.doSetContentsAndResolve = function (resource, absolutePath, value, addBOM, encodingToWrite, options) {\n        var _this = this;\n        // Configure encoding related options as needed\n        var writeFileOptions = options ? options : Object.create(null);\n        if (addBOM || encodingToWrite !== encoding_1.UTF8) {\n            writeFileOptions.encoding = {\n                charset: encodingToWrite,\n                addBOM: addBOM\n            };\n        }\n        var writeFilePromise;\n        if (typeof value === 'string') {\n            writeFilePromise = pfs.writeFile(absolutePath, value, writeFileOptions);\n        }\n        else {\n            writeFilePromise = pfs.writeFile(absolutePath, streams_1.createReadableOfSnapshot(value), writeFileOptions);\n        }\n        // set contents\n        return writeFilePromise.then(function () {\n            // resolve\n            return _this.resolve(resource);\n        });\n    };\n    FileService.prototype.doUpdateContentElevated = function (resource, value, options) {\n        var _this = this;\n        if (options === void 0) { options = Object.create(null); }\n        var absolutePath = this.toAbsolutePath(resource);\n        // 1.) check file for writing\n        return this.checkFileBeforeWriting(absolutePath, options, options.overwriteReadonly /* ignore readonly if we overwrite readonly, this is handled via sudo later */).then(function (exists) {\n            var writeOptions = objects.assign(Object.create(null), options);\n            writeOptions.writeElevated = false;\n            writeOptions.encoding = _this._encoding.getWriteEncoding(resource, options.encoding).encoding;\n            // 2.) write to a temporary file to be able to copy over later\n            var tmpPath = paths.join(os.tmpdir(), \"code-elevated-\" + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 6));\n            return _this.updateContent(uri_1.URI.file(tmpPath), value, writeOptions).then(function () {\n                // 3.) invoke our CLI as super user\n                return Promise.resolve().then(function () { return require('sudo-prompt'); }).then(function (sudoPrompt) {\n                    return new Promise(function (resolve, reject) {\n                        var promptOptions = {\n                            name: _this.environmentService.appNameLong.replace('-', ''),\n                            icns: (platform_1.isMacintosh && _this.environmentService.isBuilt) ? paths.join(paths.dirname(_this.environmentService.appRoot), product_1.default.nameShort + \".icns\") : undefined\n                        };\n                        var sudoCommand = [\"\\\"\" + _this.environmentService.cliPath + \"\\\"\"];\n                        if (options.overwriteReadonly) {\n                            sudoCommand.push('--file-chmod');\n                        }\n                        sudoCommand.push('--file-write', \"\\\"\" + tmpPath + \"\\\"\", \"\\\"\" + absolutePath + \"\\\"\");\n                        sudoPrompt.exec(sudoCommand.join(' '), promptOptions, function (error, stdout, stderr) {\n                            if (error || stderr) {\n                                reject(error || stderr);\n                            }\n                            else {\n                                resolve(undefined);\n                            }\n                        });\n                    });\n                }).then(function () {\n                    // 3.) delete temp file\n                    return pfs.del(tmpPath, os.tmpdir()).then(function () {\n                        // 4.) resolve again\n                        return _this.resolve(resource);\n                    });\n                });\n            });\n        }).then(undefined, function (error) {\n            if (_this.environmentService.verbose) {\n                _this.handleError(\"Unable to write to file '\" + resource.toString(true) + \"' as elevated user (\" + error + \")\");\n            }\n            if (!files_1.FileOperationError.isFileOperationError(error)) {\n                error = new files_1.FileOperationError(nls.localize('filePermission', \"Permission denied writing to file ({0})\", resource.toString(true)), files_1.FileOperationResult.FILE_PERMISSION_DENIED, options);\n            }\n            return Promise.reject(error);\n        });\n    };\n    FileService.prototype.createFile = function (resource, content, options) {\n        var _this = this;\n        if (content === void 0) { content = ''; }\n        if (options === void 0) { options = Object.create(null); }\n        var absolutePath = this.toAbsolutePath(resource);\n        var checkFilePromise;\n        if (options.overwrite) {\n            checkFilePromise = Promise.resolve(false);\n        }\n        else {\n            checkFilePromise = pfs.exists(absolutePath);\n        }\n        // Check file exists\n        return checkFilePromise.then(function (exists) {\n            if (exists && !options.overwrite) {\n                return Promise.reject(new files_1.FileOperationError(nls.localize('fileExists', \"File to create already exists ({0})\", resource.toString(true)), files_1.FileOperationResult.FILE_MODIFIED_SINCE, options));\n            }\n            // Create file\n            return _this.updateContent(resource, content).then(function (result) {\n                // Events\n                _this._onAfterOperation.fire(new files_1.FileOperationEvent(resource, files_1.FileOperation.CREATE, result));\n                return result;\n            });\n        });\n    };\n    FileService.prototype.checkFileBeforeWriting = function (absolutePath, options, ignoreReadonly) {\n        var _this = this;\n        if (options === void 0) { options = Object.create(null); }\n        return pfs.exists(absolutePath).then(function (exists) {\n            if (exists) {\n                return pfs.stat(absolutePath).then(function (stat) {\n                    if (stat.isDirectory()) {\n                        return Promise.reject(new Error('Expected file is actually a directory'));\n                    }\n                    // Dirty write prevention: if the file on disk has been changed and does not match our expected\n                    // mtime and etag, we bail out to prevent dirty writing.\n                    //\n                    // First, we check for a mtime that is in the future before we do more checks. The assumption is\n                    // that only the mtime is an indicator for a file that has changd on disk.\n                    //\n                    // Second, if the mtime has advanced, we compare the size of the file on disk with our previous\n                    // one using the etag() function. Relying only on the mtime check has prooven to produce false\n                    // positives due to file system weirdness (especially around remote file systems). As such, the\n                    // check for size is a weaker check because it can return a false negative if the file has changed\n                    // but to the same length. This is a compromise we take to avoid having to produce checksums of\n                    // the file content for comparison which would be much slower to compute.\n                    if (typeof options.mtime === 'number' && typeof options.etag === 'string' && options.mtime < stat.mtime.getTime() && options.etag !== etag(stat.size, options.mtime)) {\n                        return Promise.reject(new files_1.FileOperationError(nls.localize('fileModifiedError', \"File Modified Since\"), files_1.FileOperationResult.FILE_MODIFIED_SINCE, options));\n                    }\n                    // Throw if file is readonly and we are not instructed to overwrite\n                    if (!ignoreReadonly && !(stat.mode & 128) /* readonly */) {\n                        if (!options.overwriteReadonly) {\n                            return _this.readOnlyError(options);\n                        }\n                        // Try to change mode to writeable\n                        var mode = stat.mode;\n                        mode = mode | 128;\n                        return pfs.chmod(absolutePath, mode).then(function () {\n                            // Make sure to check the mode again, it could have failed\n                            return pfs.stat(absolutePath).then(function (stat) {\n                                if (!(stat.mode & 128) /* readonly */) {\n                                    return _this.readOnlyError(options);\n                                }\n                                return exists;\n                            });\n                        });\n                    }\n                    return exists;\n                });\n            }\n            return exists;\n        });\n    };\n    FileService.prototype.readOnlyError = function (options) {\n        return Promise.reject(new files_1.FileOperationError(nls.localize('fileReadOnlyError', \"File is Read Only\"), files_1.FileOperationResult.FILE_READ_ONLY, options));\n    };\n    FileService.prototype.moveFile = function (source, target, overwrite) {\n        return this.moveOrCopyFile(source, target, false, !!overwrite);\n    };\n    FileService.prototype.copyFile = function (source, target, overwrite) {\n        return this.moveOrCopyFile(source, target, true, !!overwrite);\n    };\n    FileService.prototype.moveOrCopyFile = function (source, target, keepCopy, overwrite) {\n        var _this = this;\n        var sourcePath = this.toAbsolutePath(source);\n        var targetPath = this.toAbsolutePath(target);\n        // 1.) move / copy\n        return this.doMoveOrCopyFile(sourcePath, targetPath, keepCopy, overwrite).then(function () {\n            // 2.) resolve\n            return _this.resolve(target, { resolveMetadata: true }).then(function (result) {\n                // Events (unless it was a no-op because paths are identical)\n                if (sourcePath !== targetPath) {\n                    _this._onAfterOperation.fire(new files_1.FileOperationEvent(source, keepCopy ? files_1.FileOperation.COPY : files_1.FileOperation.MOVE, result));\n                }\n                return result;\n            });\n        });\n    };\n    FileService.prototype.doMoveOrCopyFile = function (sourcePath, targetPath, keepCopy, overwrite) {\n        var _this = this;\n        // 1.) validate operation\n        if (files_1.isParent(targetPath, sourcePath, !platform_1.isLinux)) {\n            return Promise.reject(new Error('Unable to move/copy when source path is parent of target path'));\n        }\n        else if (sourcePath === targetPath) {\n            return Promise.resolve(); // no-op but not an error\n        }\n        // 2.) check if target exists\n        return pfs.exists(targetPath).then(function (exists) {\n            var isCaseRename = sourcePath.toLowerCase() === targetPath.toLowerCase();\n            // Return early with conflict if target exists and we are not told to overwrite\n            if (exists && !isCaseRename && !overwrite) {\n                return Promise.reject(new files_1.FileOperationError(nls.localize('fileMoveConflict', \"Unable to move/copy. File already exists at destination.\"), files_1.FileOperationResult.FILE_MOVE_CONFLICT));\n            }\n            // 3.) make sure target is deleted before we move/copy unless this is a case rename of the same file\n            var deleteTargetPromise = Promise.resolve();\n            if (exists && !isCaseRename) {\n                if (extpath_1.isEqualOrParent(sourcePath, targetPath, !platform_1.isLinux /* ignorecase */)) {\n                    return Promise.reject(new Error(nls.localize('unableToMoveCopyError', \"Unable to move/copy. File would replace folder it is contained in.\"))); // catch this corner case!\n                }\n                deleteTargetPromise = _this.del(uri_1.URI.file(targetPath), { recursive: true });\n            }\n            return deleteTargetPromise.then(function () {\n                // 4.) make sure parents exists\n                return pfs.mkdirp(paths.dirname(targetPath)).then(function () {\n                    // 4.) copy/move\n                    if (keepCopy) {\n                        return async_1.nfcall(extfs.copy, sourcePath, targetPath);\n                    }\n                    else {\n                        return async_1.nfcall(extfs.mv, sourcePath, targetPath);\n                    }\n                });\n            });\n        });\n    };\n    FileService.prototype.del = function (resource, options) {\n        if (options && options.useTrash) {\n            return this.doMoveItemToTrash(resource);\n        }\n        return this.doDelete(resource, !!(options && options.recursive));\n    };\n    FileService.prototype.doMoveItemToTrash = function (resource) {\n        var absolutePath = resource.fsPath;\n        var shell = require('electron').shell; // workaround for being able to run tests out of VSCode debugger\n        var result = shell.moveItemToTrash(absolutePath);\n        if (!result) {\n            return Promise.reject(new Error(platform_1.isWindows ? nls.localize('binFailed', \"Failed to move '{0}' to the recycle bin\", paths.basename(absolutePath)) : nls.localize('trashFailed', \"Failed to move '{0}' to the trash\", paths.basename(absolutePath))));\n        }\n        this._onAfterOperation.fire(new files_1.FileOperationEvent(resource, files_1.FileOperation.DELETE));\n        return Promise.resolve();\n    };\n    FileService.prototype.doDelete = function (resource, recursive) {\n        var _this = this;\n        var absolutePath = this.toAbsolutePath(resource);\n        var assertNonRecursiveDelete;\n        if (!recursive) {\n            assertNonRecursiveDelete = pfs.stat(absolutePath).then(function (stat) {\n                if (!stat.isDirectory()) {\n                    return undefined;\n                }\n                return pfs.readdir(absolutePath).then(function (children) {\n                    if (children.length === 0) {\n                        return undefined;\n                    }\n                    return Promise.reject(new Error(nls.localize('deleteFailed', \"Failed to delete non-empty folder '{0}'.\", paths.basename(absolutePath))));\n                });\n            }, function (error) { return Promise.resolve(); } /* ignore errors */);\n        }\n        else {\n            assertNonRecursiveDelete = Promise.resolve();\n        }\n        return assertNonRecursiveDelete.then(function () {\n            return pfs.del(absolutePath, os.tmpdir()).then(function () {\n                // Events\n                _this._onAfterOperation.fire(new files_1.FileOperationEvent(resource, files_1.FileOperation.DELETE));\n            });\n        });\n    };\n    // Helpers\n    FileService.prototype.toAbsolutePath = function (arg1) {\n        var resource;\n        if (arg1 instanceof uri_1.URI) {\n            resource = arg1;\n        }\n        else {\n            resource = arg1.resource;\n        }\n        assert.ok(resource && resource.scheme === network_1.Schemas.file, \"Invalid resource: \" + resource);\n        return paths.normalize(resource.fsPath);\n    };\n    FileService.prototype.resolve = function (resource, options) {\n        if (options === void 0) { options = Object.create(null); }\n        return this.toStatResolver(resource).then(function (model) { return model.resolve(options); });\n    };\n    FileService.prototype.toStatResolver = function (resource) {\n        var _this = this;\n        var absolutePath = this.toAbsolutePath(resource);\n        return pfs.statLink(absolutePath).then(function (_a) {\n            var isSymbolicLink = _a.isSymbolicLink, stat = _a.stat;\n            return new StatResolver(resource, isSymbolicLink, stat.isDirectory(), stat.mtime.getTime(), stat.size, _this.environmentService.verbose ? function (err) { return _this.handleError(err); } : undefined);\n        });\n    };\n    FileService.prototype.watchFileChanges = function (resource) {\n        var _this = this;\n        assert.ok(resource && resource.scheme === network_1.Schemas.file, \"Invalid resource for watching: \" + resource);\n        // Check for existing watcher first\n        var entry = this.activeFileChangesWatchers.get(resource);\n        if (entry) {\n            entry.count += 1;\n            return;\n        }\n        // Create or get watcher for provided path\n        var fsPath = resource.fsPath;\n        var fsName = paths.basename(resource.fsPath);\n        var watcherDisposable = extfs.watch(fsPath, function (eventType, filename) {\n            var renamedOrDeleted = ((filename && filename !== fsName) || eventType === 'rename');\n            // The file was either deleted or renamed. Many tools apply changes to files in an\n            // atomic way (\"Atomic Save\") by first renaming the file to a temporary name and then\n            // renaming it back to the original name. Our watcher will detect this as a rename\n            // and then stops to work on Mac and Linux because the watcher is applied to the\n            // inode and not the name. The fix is to detect this case and trying to watch the file\n            // again after a certain delay.\n            // In addition, we send out a delete event if after a timeout we detect that the file\n            // does indeed not exist anymore.\n            if (renamedOrDeleted) {\n                // Very important to dispose the watcher which now points to a stale inode\n                watcherDisposable.dispose();\n                _this.activeFileChangesWatchers.delete(resource);\n                // Wait a bit and try to install watcher again, assuming that the file was renamed quickly (\"Atomic Save\")\n                setTimeout(function () {\n                    _this.existsFile(resource).then(function (exists) {\n                        // File still exists, so reapply the watcher\n                        if (exists) {\n                            _this.watchFileChanges(resource);\n                        }\n                        // File seems to be really gone, so emit a deleted event\n                        else {\n                            _this.onRawFileChange({\n                                type: files_1.FileChangeType.DELETED,\n                                path: fsPath\n                            });\n                        }\n                    });\n                }, FileService.FS_REWATCH_DELAY);\n            }\n            // Handle raw file change\n            _this.onRawFileChange({\n                type: files_1.FileChangeType.UPDATED,\n                path: fsPath\n            });\n        }, function (error) { return _this.handleError(error); });\n        // Remember in map\n        this.activeFileChangesWatchers.set(resource, {\n            count: 1,\n            unwatch: function () { return watcherDisposable.dispose(); }\n        });\n    };\n    FileService.prototype.onRawFileChange = function (event) {\n        var _this = this;\n        // add to bucket of undelivered events\n        this.undeliveredRawFileChangesEvents.push(event);\n        if (this.environmentService.verbose) {\n            console.log('%c[File Watcher (node.js)]%c', 'color: blue', 'color: black', (event.type === files_1.FileChangeType.ADDED ? '[ADDED]' : event.type === files_1.FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]') + \" \" + event.path);\n        }\n        // handle emit through delayer to accommodate for bulk changes\n        this.fileChangesWatchDelayer.trigger(function () {\n            var buffer = _this.undeliveredRawFileChangesEvents;\n            _this.undeliveredRawFileChangesEvents = [];\n            // Normalize\n            var normalizedEvents = common_1.normalize(buffer);\n            // Logging\n            if (_this.environmentService.verbose) {\n                normalizedEvents.forEach(function (r) {\n                    console.log('%c[File Watcher (node.js)]%c >> normalized', 'color: blue', 'color: black', (r.type === files_1.FileChangeType.ADDED ? '[ADDED]' : r.type === files_1.FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]') + \" \" + r.path);\n                });\n            }\n            // Emit\n            _this._onFileChanges.fire(common_1.toFileChangesEvent(normalizedEvents));\n            return Promise.resolve();\n        });\n    };\n    FileService.prototype.unwatchFileChanges = function (resource) {\n        var watcher = this.activeFileChangesWatchers.get(resource);\n        if (watcher && --watcher.count === 0) {\n            watcher.unwatch();\n            this.activeFileChangesWatchers.delete(resource);\n        }\n    };\n    FileService.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        if (this.activeWorkspaceFileChangeWatcher) {\n            this.activeWorkspaceFileChangeWatcher.dispose();\n            this.activeWorkspaceFileChangeWatcher = null;\n        }\n        this.activeFileChangesWatchers.forEach(function (watcher) { return watcher.unwatch(); });\n        this.activeFileChangesWatchers.clear();\n    };\n    FileService.prototype.resolveFile = function (resource, options) {\n        return this.resolve(resource, options);\n    };\n    FileService.prototype.resolveFiles = function (toResolve) {\n        var _this = this;\n        return Promise.all(toResolve.map(function (resourceAndOptions) { return _this.resolve(resourceAndOptions.resource, resourceAndOptions.options)\n            .then(function (stat) { return ({ stat: stat, success: true }); }, function (error) { return ({ stat: undefined, success: false }); }); }));\n    };\n    FileService.prototype.createFolder = function (resource) {\n        var _this = this;\n        // 1.) Create folder\n        var absolutePath = this.toAbsolutePath(resource);\n        return pfs.mkdirp(absolutePath).then(function () {\n            // 2.) Resolve\n            return _this.resolve(resource, { resolveMetadata: true }).then(function (result) {\n                // Events\n                _this._onAfterOperation.fire(new files_1.FileOperationEvent(resource, files_1.FileOperation.CREATE, result));\n                return result;\n            });\n        });\n    };\n    FileService.prototype.existsFile = function (resource) {\n        return this.resolveFile(resource).then(function () { return true; }, function () { return false; });\n    };\n    FileService.FS_EVENT_DELAY = 50; // aggregate and only emit events when changes have stopped for this duration (in ms)\n    FileService.FS_REWATCH_DELAY = 300; // delay to rewatch a file that was renamed or deleted (in ms)\n    FileService.NET_VERSION_ERROR = 'System.MissingMethodException';\n    FileService.NET_VERSION_ERROR_IGNORE_KEY = 'ignoreNetVersionError';\n    FileService.ENOSPC_ERROR = 'ENOSPC';\n    FileService.ENOSPC_ERROR_IGNORE_KEY = 'ignoreEnospcError';\n    return FileService;\n}(lifecycle_1.Disposable));\nexports.FileService = FileService;\nfunction etag(arg1, arg2) {\n    var size;\n    var mtime;\n    if (typeof arg2 === 'number') {\n        size = arg1;\n        mtime = arg2;\n    }\n    else {\n        size = arg1.size;\n        mtime = arg1.mtime.getTime();\n    }\n    return \"\\\"\" + crypto.createHash('sha1').update(String(size) + String(mtime)).digest('hex') + \"\\\"\";\n}\nvar StatResolver = /** @class */ (function () {\n    function StatResolver(resource, isSymbolicLink, isDirectory, mtime, size, errorLogger) {\n        this.resource = resource;\n        this.isSymbolicLink = isSymbolicLink;\n        this.isDirectory = isDirectory;\n        this.mtime = mtime;\n        this.size = size;\n        this.errorLogger = errorLogger;\n        assert.ok(resource && resource.scheme === network_1.Schemas.file, \"Invalid resource: \" + resource);\n        this.name = labels_1.getBaseLabel(resource);\n        this.etag = etag(size, mtime);\n    }\n    StatResolver.prototype.resolve = function (options) {\n        var _this = this;\n        // General Data\n        var fileStat = {\n            resource: this.resource,\n            isDirectory: this.isDirectory,\n            isSymbolicLink: this.isSymbolicLink,\n            isReadonly: false,\n            name: this.name,\n            etag: this.etag,\n            size: this.size,\n            mtime: this.mtime\n        };\n        // File Specific Data\n        if (!this.isDirectory) {\n            return Promise.resolve(fileStat);\n        }\n        // Directory Specific Data\n        else {\n            // Convert the paths from options.resolveTo to absolute paths\n            var absoluteTargetPaths_1 = null;\n            if (options && options.resolveTo) {\n                absoluteTargetPaths_1 = [];\n                for (var _i = 0, _a = options.resolveTo; _i < _a.length; _i++) {\n                    var resource = _a[_i];\n                    absoluteTargetPaths_1.push(resource.fsPath);\n                }\n            }\n            return new Promise(function (resolve) {\n                // Load children\n                _this.resolveChildren(_this.resource.fsPath, absoluteTargetPaths_1, !!(options && options.resolveSingleChildDescendants), function (children) {\n                    if (children) {\n                        children = arrays.coalesce(children); // we don't want those null children (could be permission denied when reading a child)\n                    }\n                    fileStat.children = children || [];\n                    resolve(fileStat);\n                });\n            });\n        }\n    };\n    StatResolver.prototype.resolveChildren = function (absolutePath, absoluteTargetPaths, resolveSingleChildDescendants, callback) {\n        var _this = this;\n        extfs.readdir(absolutePath, function (error, files) {\n            if (error) {\n                if (_this.errorLogger) {\n                    _this.errorLogger(error);\n                }\n                return callback(null); // return - we might not have permissions to read the folder\n            }\n            // for each file in the folder\n            flow.parallel(files, function (file, clb) {\n                var fileResource = uri_1.URI.file(paths.resolve(absolutePath, file));\n                var fileStat;\n                var isSymbolicLink = false;\n                var $this = _this;\n                flow.sequence(function onError(error) {\n                    if ($this.errorLogger) {\n                        $this.errorLogger(error);\n                    }\n                    clb(null, null); // return - we might not have permissions to read the folder or stat the file\n                }, function stat() {\n                    extfs.statLink(fileResource.fsPath, this);\n                }, function countChildren(statAndLink) {\n                    var _this = this;\n                    fileStat = statAndLink.stat;\n                    isSymbolicLink = statAndLink.isSymbolicLink;\n                    if (fileStat.isDirectory()) {\n                        extfs.readdir(fileResource.fsPath, function (error, result) {\n                            _this(null, result ? result.length : 0);\n                        });\n                    }\n                    else {\n                        this(null, 0);\n                    }\n                }, function resolve(childCount) {\n                    var childStat = {\n                        resource: fileResource,\n                        isDirectory: fileStat.isDirectory(),\n                        isSymbolicLink: isSymbolicLink,\n                        isReadonly: false,\n                        name: file,\n                        mtime: fileStat.mtime.getTime(),\n                        etag: etag(fileStat),\n                        size: fileStat.size\n                    };\n                    // Return early for files\n                    if (!fileStat.isDirectory()) {\n                        return clb(null, childStat);\n                    }\n                    // Handle Folder\n                    var resolveFolderChildren = false;\n                    if (files.length === 1 && resolveSingleChildDescendants) {\n                        resolveFolderChildren = true;\n                    }\n                    else if (childCount > 0 && absoluteTargetPaths && absoluteTargetPaths.some(function (targetPath) { return extpath_1.isEqualOrParent(targetPath, fileResource.fsPath, !platform_1.isLinux /* ignorecase */); })) {\n                        resolveFolderChildren = true;\n                    }\n                    // Continue resolving children based on condition\n                    if (resolveFolderChildren) {\n                        $this.resolveChildren(fileResource.fsPath, absoluteTargetPaths, resolveSingleChildDescendants, function (children) {\n                            if (children) {\n                                children = arrays.coalesce(children); // we don't want those null children\n                            }\n                            childStat.children = children || [];\n                            clb(null, childStat);\n                        });\n                    }\n                    // Otherwise return result\n                    else {\n                        clb(null, childStat);\n                    }\n                });\n            }, function (errors, result) {\n                callback(result);\n            });\n        });\n    };\n    return StatResolver;\n}());\nexports.StatResolver = StatResolver;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/fileService.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/fileService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as paths from 'vs/base/common/path';\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport * as crypto from 'crypto';\nimport * as assert from 'assert';\nimport { isParent, FileOperation, FileOperationEvent, IContent, IResolveFileOptions, IResolveFileResult, IResolveContentOptions, IFileStat, IStreamContent, FileOperationError, FileOperationResult, IUpdateContentOptions, FileChangeType, FileChangesEvent, ICreateFileOptions, IContentData, ITextSnapshot, IFilesConfiguration, IFileSystemProviderRegistrationEvent, IFileSystemProvider, ILegacyFileService, IFileStatWithMetadata, IFileService, IResolveMetadataFileOptions, FileSystemProviderCapabilities } from 'vs/platform/files/common/files';\nimport { MAX_FILE_SIZE, MAX_HEAP_SIZE } from 'vs/platform/files/node/fileConstants';\nimport { isEqualOrParent } from 'vs/base/common/extpath';\nimport { ResourceMap } from 'vs/base/common/map';\nimport * as arrays from 'vs/base/common/arrays';\nimport * as objects from 'vs/base/common/objects';\nimport * as extfs from 'vs/base/node/extfs';\nimport { nfcall, ThrottledDelayer, timeout } from 'vs/base/common/async';\nimport { URI as uri } from 'vs/base/common/uri';\nimport * as nls from 'vs/nls';\nimport { isWindows, isLinux, isMacintosh } from 'vs/base/common/platform';\nimport { IDisposable, toDisposable, Disposable } from 'vs/base/common/lifecycle';\nimport { IWorkspaceContextService, WorkbenchState } from 'vs/platform/workspace/common/workspace';\nimport * as pfs from 'vs/base/node/pfs';\nimport { detectEncodingFromBuffer, decodeStream, detectEncodingByBOM, UTF8 } from 'vs/base/node/encoding';\nimport * as flow from 'vs/base/node/flow';\nimport { FileWatcher as UnixWatcherService } from 'vs/workbench/services/files/node/watcher/unix/watcherService';\nimport { FileWatcher as WindowsWatcherService } from 'vs/workbench/services/files/node/watcher/win32/watcherService';\nimport { toFileChangesEvent, normalize, IRawFileChange } from 'vs/workbench/services/files/node/watcher/common';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { FileWatcher as NsfwWatcherService } from 'vs/workbench/services/files/node/watcher/nsfw/watcherService';\nimport { ITextResourceConfigurationService } from 'vs/editor/common/services/resourceConfiguration';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { ILifecycleService, LifecyclePhase } from 'vs/platform/lifecycle/common/lifecycle';\nimport { getBaseLabel } from 'vs/base/common/labels';\nimport { Schemas } from 'vs/base/common/network';\nimport { IStorageService, StorageScope } from 'vs/platform/storage/common/storage';\nimport { INotificationService, Severity } from 'vs/platform/notification/common/notification';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport product from 'vs/platform/product/node/product';\nimport { IEncodingOverride, ResourceEncodings } from 'vs/workbench/services/files/node/encoding';\nimport { createReadableOfSnapshot } from 'vs/workbench/services/files/node/streams';\nimport { withUndefinedAsNull } from 'vs/base/common/types';\n\nexport interface IFileServiceTestOptions {\n\tdisableWatcher?: boolean;\n\tencodingOverride?: IEncodingOverride[];\n}\n\nexport class FileService extends Disposable implements ILegacyFileService, IFileService {\n\n\t_serviceBrand: any;\n\n\tprivate static readonly FS_EVENT_DELAY = 50; // aggregate and only emit events when changes have stopped for this duration (in ms)\n\tprivate static readonly FS_REWATCH_DELAY = 300; // delay to rewatch a file that was renamed or deleted (in ms)\n\n\tprivate static readonly NET_VERSION_ERROR = 'System.MissingMethodException';\n\tprivate static readonly NET_VERSION_ERROR_IGNORE_KEY = 'ignoreNetVersionError';\n\n\tprivate static readonly ENOSPC_ERROR = 'ENOSPC';\n\tprivate static readonly ENOSPC_ERROR_IGNORE_KEY = 'ignoreEnospcError';\n\n\tprotected readonly _onFileChanges: Emitter<FileChangesEvent> = this._register(new Emitter<FileChangesEvent>());\n\tget onFileChanges(): Event<FileChangesEvent> { return this._onFileChanges.event; }\n\n\tprotected readonly _onAfterOperation: Emitter<FileOperationEvent> = this._register(new Emitter<FileOperationEvent>());\n\tget onAfterOperation(): Event<FileOperationEvent> { return this._onAfterOperation.event; }\n\n\tprotected readonly _onDidChangeFileSystemProviderRegistrations = this._register(new Emitter<IFileSystemProviderRegistrationEvent>());\n\tget onDidChangeFileSystemProviderRegistrations(): Event<IFileSystemProviderRegistrationEvent> { return this._onDidChangeFileSystemProviderRegistrations.event; }\n\n\treadonly onWillActivateFileSystemProvider = Event.None;\n\n\tprivate activeWorkspaceFileChangeWatcher: IDisposable | null;\n\tprivate activeFileChangesWatchers: ResourceMap<{ unwatch: Function, count: number }>;\n\tprivate fileChangesWatchDelayer: ThrottledDelayer<void>;\n\tprivate undeliveredRawFileChangesEvents: IRawFileChange[];\n\n\tprivate _encoding: ResourceEncodings;\n\n\tconstructor(\n\t\tprivate contextService: IWorkspaceContextService,\n\t\tprivate environmentService: IEnvironmentService,\n\t\tprivate textResourceConfigurationService: ITextResourceConfigurationService,\n\t\tprivate configurationService: IConfigurationService,\n\t\tprivate lifecycleService: ILifecycleService,\n\t\tprivate storageService: IStorageService,\n\t\tprivate notificationService: INotificationService,\n\t\tprivate options: IFileServiceTestOptions = Object.create(null)\n\t) {\n\t\tsuper();\n\n\t\tthis.activeFileChangesWatchers = new ResourceMap<{ unwatch: Function, count: number }>();\n\t\tthis.fileChangesWatchDelayer = new ThrottledDelayer<void>(FileService.FS_EVENT_DELAY);\n\t\tthis.undeliveredRawFileChangesEvents = [];\n\n\t\tthis._encoding = new ResourceEncodings(textResourceConfigurationService, environmentService, contextService, this.options.encodingOverride);\n\n\t\tthis.registerListeners();\n\t}\n\n\tget encoding(): ResourceEncodings {\n\t\treturn this._encoding;\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Wait until we are fully running before starting file watchers\n\t\tthis.lifecycleService.when(LifecyclePhase.Restored).then(() => {\n\t\t\tthis.setupFileWatching();\n\t\t});\n\n\t\t// Workbench State Change\n\t\tthis._register(this.contextService.onDidChangeWorkbenchState(() => {\n\t\t\tif (this.lifecycleService.phase >= LifecyclePhase.Restored) {\n\t\t\t\tthis.setupFileWatching();\n\t\t\t}\n\t\t}));\n\n\t\t// Lifecycle\n\t\tthis.lifecycleService.onShutdown(this.dispose, this);\n\t}\n\n\tprivate handleError(error: string | Error): void {\n\t\tconst msg = error ? error.toString() : undefined;\n\t\tif (!msg) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Forward to unexpected error handler\n\t\tonUnexpectedError(msg);\n\n\t\t// Detect if we run < .NET Framework 4.5 (TODO@ben remove with new watcher impl)\n\t\tif (msg.indexOf(FileService.NET_VERSION_ERROR) >= 0 && !this.storageService.getBoolean(FileService.NET_VERSION_ERROR_IGNORE_KEY, StorageScope.WORKSPACE)) {\n\t\t\tthis.notificationService.prompt(\n\t\t\t\tSeverity.Warning,\n\t\t\t\tnls.localize('netVersionError', \"The Microsoft .NET Framework 4.5 is required. Please follow the link to install it.\"),\n\t\t\t\t[{\n\t\t\t\t\tlabel: nls.localize('installNet', \"Download .NET Framework 4.5\"),\n\t\t\t\t\trun: () => window.open('https://go.microsoft.com/fwlink/?LinkId=786533')\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlabel: nls.localize('neverShowAgain', \"Don't Show Again\"),\n\t\t\t\t\tisSecondary: true,\n\t\t\t\t\trun: () => this.storageService.store(FileService.NET_VERSION_ERROR_IGNORE_KEY, true, StorageScope.WORKSPACE)\n\t\t\t\t}],\n\t\t\t\t{ sticky: true }\n\t\t\t);\n\t\t}\n\n\t\t// Detect if we run into ENOSPC issues\n\t\tif (msg.indexOf(FileService.ENOSPC_ERROR) >= 0 && !this.storageService.getBoolean(FileService.ENOSPC_ERROR_IGNORE_KEY, StorageScope.WORKSPACE)) {\n\t\t\tthis.notificationService.prompt(\n\t\t\t\tSeverity.Warning,\n\t\t\t\tnls.localize('enospcError', \"{0} is unable to watch for file changes in this large workspace. Please follow the instructions link to resolve this issue.\", product.nameLong),\n\t\t\t\t[{\n\t\t\t\t\tlabel: nls.localize('learnMore', \"Instructions\"),\n\t\t\t\t\trun: () => window.open('https://go.microsoft.com/fwlink/?linkid=867693')\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlabel: nls.localize('neverShowAgain', \"Don't Show Again\"),\n\t\t\t\t\tisSecondary: true,\n\t\t\t\t\trun: () => this.storageService.store(FileService.ENOSPC_ERROR_IGNORE_KEY, true, StorageScope.WORKSPACE)\n\t\t\t\t}],\n\t\t\t\t{ sticky: true }\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate setupFileWatching(): void {\n\n\t\t// dispose old if any\n\t\tif (this.activeWorkspaceFileChangeWatcher) {\n\t\t\tthis.activeWorkspaceFileChangeWatcher.dispose();\n\t\t}\n\n\t\t// Return if not aplicable\n\t\tconst workbenchState = this.contextService.getWorkbenchState();\n\t\tif (workbenchState === WorkbenchState.EMPTY || this.options.disableWatcher) {\n\t\t\treturn;\n\t\t}\n\n\t\t// new watcher: use it if setting tells us so or we run in multi-root environment\n\t\tconst configuration = this.configurationService.getValue<IFilesConfiguration>();\n\t\tif ((configuration.files && configuration.files.useExperimentalFileWatcher) || workbenchState === WorkbenchState.WORKSPACE) {\n\t\t\tconst multiRootWatcher = new NsfwWatcherService(this.contextService, this.configurationService, e => this._onFileChanges.fire(e), err => this.handleError(err), this.environmentService.verbose);\n\t\t\tthis.activeWorkspaceFileChangeWatcher = toDisposable(multiRootWatcher.startWatching());\n\t\t}\n\n\t\t// legacy watcher\n\t\telse {\n\t\t\tlet watcherIgnoredPatterns: string[] = [];\n\t\t\tif (configuration.files && configuration.files.watcherExclude) {\n\t\t\t\twatcherIgnoredPatterns = Object.keys(configuration.files.watcherExclude).filter(k => !!configuration.files.watcherExclude[k]);\n\t\t\t}\n\n\t\t\tif (isWindows) {\n\t\t\t\tconst legacyWindowsWatcher = new WindowsWatcherService(this.contextService, watcherIgnoredPatterns, e => this._onFileChanges.fire(e), err => this.handleError(err), this.environmentService.verbose);\n\t\t\t\tthis.activeWorkspaceFileChangeWatcher = toDisposable(legacyWindowsWatcher.startWatching());\n\t\t\t} else {\n\t\t\t\tconst legacyUnixWatcher = new UnixWatcherService(this.contextService, this.configurationService, e => this._onFileChanges.fire(e), err => this.handleError(err), this.environmentService.verbose);\n\t\t\t\tthis.activeWorkspaceFileChangeWatcher = toDisposable(legacyUnixWatcher.startWatching());\n\t\t\t}\n\t\t}\n\t}\n\n\tregisterProvider(scheme: string, provider: IFileSystemProvider): IDisposable {\n\t\treturn Disposable.None;\n\t}\n\n\tactivateProvider(scheme: string): Promise<void> {\n\t\treturn Promise.reject(new Error('not implemented'));\n\t}\n\n\tcanHandleResource(resource: uri): boolean {\n\t\treturn resource.scheme === Schemas.file;\n\t}\n\n\thasCapability(resource: uri, capability: FileSystemProviderCapabilities): Promise<boolean> {\n\t\treturn Promise.resolve(false);\n\t}\n\n\tresolveContent(resource: uri, options?: IResolveContentOptions): Promise<IContent> {\n\t\treturn this.resolveStreamContent(resource, options).then(streamContent => {\n\t\t\treturn new Promise<IContent>((resolve, reject) => {\n\n\t\t\t\tconst result: IContent = {\n\t\t\t\t\tresource: streamContent.resource,\n\t\t\t\t\tname: streamContent.name,\n\t\t\t\t\tmtime: streamContent.mtime,\n\t\t\t\t\tetag: streamContent.etag,\n\t\t\t\t\tencoding: streamContent.encoding,\n\t\t\t\t\tisReadonly: streamContent.isReadonly,\n\t\t\t\t\tsize: streamContent.size,\n\t\t\t\t\tvalue: ''\n\t\t\t\t};\n\n\t\t\t\tstreamContent.value.on('data', chunk => result.value += chunk);\n\t\t\t\tstreamContent.value.on('error', err => reject(err));\n\t\t\t\tstreamContent.value.on('end', () => resolve(result));\n\n\t\t\t\treturn result;\n\t\t\t});\n\t\t});\n\t}\n\n\tresolveStreamContent(resource: uri, options?: IResolveContentOptions): Promise<IStreamContent> {\n\n\t\t// Guard early against attempts to resolve an invalid file path\n\t\tif (resource.scheme !== Schemas.file || !resource.fsPath) {\n\t\t\treturn Promise.reject(new FileOperationError(\n\t\t\t\tnls.localize('fileInvalidPath', \"Invalid file resource ({0})\", resource.toString(true)),\n\t\t\t\tFileOperationResult.FILE_INVALID_PATH,\n\t\t\t\toptions\n\t\t\t));\n\t\t}\n\n\t\tconst result: Partial<IStreamContent> = {\n\t\t\tresource: undefined,\n\t\t\tname: undefined,\n\t\t\tmtime: undefined,\n\t\t\tetag: undefined,\n\t\t\tencoding: undefined,\n\t\t\tisReadonly: false,\n\t\t\tvalue: undefined\n\t\t};\n\n\t\tconst contentResolverTokenSource = new CancellationTokenSource();\n\n\t\tconst onStatError = (error: Error) => {\n\n\t\t\t// error: stop reading the file the stat and content resolve call\n\t\t\t// usually race, mostly likely the stat call will win and cancel\n\t\t\t// the content call\n\t\t\tcontentResolverTokenSource.cancel();\n\n\t\t\t// forward error\n\t\t\treturn Promise.reject(error);\n\t\t};\n\n\t\tconst statsPromise = this.resolveFile(resource).then(stat => {\n\t\t\tresult.resource = stat.resource;\n\t\t\tresult.name = stat.name;\n\t\t\tresult.mtime = stat.mtime;\n\t\t\tresult.etag = stat.etag;\n\t\t\tresult.size = stat.size;\n\n\t\t\t// Return early if resource is a directory\n\t\t\tif (stat.isDirectory) {\n\t\t\t\treturn onStatError(new FileOperationError(\n\t\t\t\t\tnls.localize('fileIsDirectoryError', \"File is directory\"),\n\t\t\t\t\tFileOperationResult.FILE_IS_DIRECTORY,\n\t\t\t\t\toptions\n\t\t\t\t));\n\t\t\t}\n\n\t\t\t// Return early if file not modified since\n\t\t\tif (options && options.etag && options.etag === stat.etag) {\n\t\t\t\treturn onStatError(new FileOperationError(\n\t\t\t\t\tnls.localize('fileNotModifiedError', \"File not modified since\"),\n\t\t\t\t\tFileOperationResult.FILE_NOT_MODIFIED_SINCE,\n\t\t\t\t\toptions\n\t\t\t\t));\n\t\t\t}\n\n\t\t\t// Return early if file is too large to load\n\t\t\tif (typeof stat.size === 'number') {\n\t\t\t\tif (stat.size > Math.max(typeof this.environmentService.args['max-memory'] === 'string' ? parseInt(this.environmentService.args['max-memory']) * 1024 * 1024 || 0 : 0, MAX_HEAP_SIZE)) {\n\t\t\t\t\treturn onStatError(new FileOperationError(\n\t\t\t\t\t\tnls.localize('fileTooLargeForHeapError', \"To open a file of this size, you need to restart VS Code and allow it to use more memory\"),\n\t\t\t\t\t\tFileOperationResult.FILE_EXCEED_MEMORY_LIMIT\n\t\t\t\t\t));\n\t\t\t\t}\n\n\t\t\t\tif (stat.size > MAX_FILE_SIZE) {\n\t\t\t\t\treturn onStatError(new FileOperationError(\n\t\t\t\t\t\tnls.localize('fileTooLargeError', \"File too large to open\"),\n\t\t\t\t\t\tFileOperationResult.FILE_TOO_LARGE\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}, err => {\n\n\t\t\t// Wrap file not found errors\n\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\treturn onStatError(new FileOperationError(\n\t\t\t\t\tnls.localize('fileNotFoundError', \"File not found ({0})\", resource.toString(true)),\n\t\t\t\t\tFileOperationResult.FILE_NOT_FOUND,\n\t\t\t\t\toptions\n\t\t\t\t));\n\t\t\t}\n\n\t\t\treturn onStatError(err);\n\t\t});\n\n\t\tlet completePromise: Promise<void>;\n\n\t\t// await the stat iff we already have an etag so that we compare the\n\t\t// etag from the stat before we actually read the file again.\n\t\tif (options && options.etag) {\n\t\t\tcompletePromise = statsPromise.then(() => {\n\t\t\t\treturn this.fillInContents(result, resource, options, contentResolverTokenSource.token); // Waterfall -> only now resolve the contents\n\t\t\t});\n\t\t}\n\n\t\t// a fresh load without a previous etag which means we can resolve the file stat\n\t\t// and the content at the same time, avoiding the waterfall.\n\t\telse {\n\t\t\tlet statsError: Error;\n\t\t\tlet contentsError: Error;\n\n\t\t\tcompletePromise = Promise.all([\n\t\t\t\tstatsPromise.then(() => undefined, error => statsError = error),\n\t\t\t\tthis.fillInContents(result, resource, options, contentResolverTokenSource.token).then(() => undefined, error => contentsError = error)\n\t\t\t]).then(() => {\n\t\t\t\t// Since each file operation can return a FileOperationError\n\t\t\t\t// we want to prefer that one if possible. Otherwise we just\n\t\t\t\t// return with the first error we get.\n\t\t\t\tif (FileOperationError.isFileOperationError(statsError)) {\n\t\t\t\t\treturn Promise.reject(statsError);\n\t\t\t\t}\n\n\t\t\t\tif (FileOperationError.isFileOperationError(contentsError)) {\n\t\t\t\t\treturn Promise.reject(contentsError);\n\t\t\t\t}\n\n\t\t\t\tif (statsError || contentsError) {\n\t\t\t\t\treturn Promise.reject(statsError || contentsError);\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\treturn completePromise.then(() => {\n\t\t\tcontentResolverTokenSource.dispose();\n\n\t\t\treturn result;\n\t\t}, error => {\n\t\t\tcontentResolverTokenSource.dispose();\n\n\t\t\treturn Promise.reject(error);\n\t\t});\n\t}\n\n\tprivate fillInContents(content: Partial<IStreamContent>, resource: uri, options: IResolveContentOptions | undefined, token: CancellationToken): Promise<void> {\n\t\treturn this.resolveFileData(resource, options, token).then(data => {\n\t\t\tcontent.encoding = data.encoding;\n\t\t\tcontent.value = data.stream;\n\t\t});\n\t}\n\n\tprivate resolveFileData(resource: uri, options: IResolveContentOptions | undefined, token: CancellationToken): Promise<IContentData> {\n\t\tconst chunkBuffer = Buffer.allocUnsafe(64 * 1024);\n\n\t\tconst result: Partial<IContentData> = {\n\t\t\tencoding: undefined,\n\t\t\tstream: undefined\n\t\t};\n\n\t\treturn new Promise<IContentData>((resolve, reject) => {\n\t\t\tfs.open(this.toAbsolutePath(resource), 'r', (err, fd) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\t\t\t// Wrap file not found errors\n\t\t\t\t\t\terr = new FileOperationError(\n\t\t\t\t\t\t\tnls.localize('fileNotFoundError', \"File not found ({0})\", resource.toString(true)),\n\t\t\t\t\t\t\tFileOperationResult.FILE_NOT_FOUND,\n\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn reject(err);\n\t\t\t\t}\n\n\t\t\t\tlet decoder: NodeJS.ReadWriteStream;\n\t\t\t\tlet totalBytesRead = 0;\n\n\t\t\t\tconst finish = (err?: any) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tif (err.code === 'EISDIR') {\n\n\t\t\t\t\t\t\t// Wrap EISDIR errors (fs.open on a directory works, but you cannot read from it)\n\t\t\t\t\t\t\terr = new FileOperationError(\n\t\t\t\t\t\t\t\tnls.localize('fileIsDirectoryError', \"File is directory\"),\n\t\t\t\t\t\t\t\tFileOperationResult.FILE_IS_DIRECTORY,\n\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (decoder) {\n\t\t\t\t\t\t\t// If the decoder already started, we have to emit the error through it as\n\t\t\t\t\t\t\t// event because the promise is already resolved!\n\t\t\t\t\t\t\tdecoder.emit('error', err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (decoder) {\n\t\t\t\t\t\tdecoder.end();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (fd) {\n\t\t\t\t\t\tfs.close(fd, err => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tthis.handleError(`resolveFileData#close(): ${err.toString()}`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tconst handleChunk = (bytesRead: number) => {\n\t\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\t\t// cancellation -> finish\n\t\t\t\t\t\tfinish(new Error('cancelled'));\n\t\t\t\t\t} else if (bytesRead === 0) {\n\t\t\t\t\t\t// no more data -> finish\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t} else if (bytesRead < chunkBuffer.length) {\n\t\t\t\t\t\t// write the sub-part of data we received -> repeat\n\t\t\t\t\t\tdecoder.write(chunkBuffer.slice(0, bytesRead), readChunk);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// write all data we received -> repeat\n\t\t\t\t\t\tdecoder.write(chunkBuffer, readChunk);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tlet currentPosition: number | null = withUndefinedAsNull(options && options.position);\n\n\t\t\t\tconst readChunk = () => {\n\t\t\t\t\tfs.read(fd, chunkBuffer, 0, chunkBuffer.length, currentPosition, (err, bytesRead) => {\n\t\t\t\t\t\ttotalBytesRead += bytesRead;\n\n\t\t\t\t\t\tif (typeof currentPosition === 'number') {\n\t\t\t\t\t\t\t// if we received a position argument as option we need to ensure that\n\t\t\t\t\t\t\t// we advance the position by the number of bytesread\n\t\t\t\t\t\t\tcurrentPosition += bytesRead;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (totalBytesRead > Math.max(typeof this.environmentService.args['max-memory'] === 'number' ? parseInt(this.environmentService.args['max-memory']) * 1024 * 1024 || 0 : 0, MAX_HEAP_SIZE)) {\n\t\t\t\t\t\t\tfinish(new FileOperationError(\n\t\t\t\t\t\t\t\tnls.localize('fileTooLargeForHeapError', \"To open a file of this size, you need to restart VS Code and allow it to use more memory\"),\n\t\t\t\t\t\t\t\tFileOperationResult.FILE_EXCEED_MEMORY_LIMIT\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (totalBytesRead > MAX_FILE_SIZE) {\n\t\t\t\t\t\t\t// stop when reading too much\n\t\t\t\t\t\t\tfinish(new FileOperationError(\n\t\t\t\t\t\t\t\tnls.localize('fileTooLargeError', \"File too large to open\"),\n\t\t\t\t\t\t\t\tFileOperationResult.FILE_TOO_LARGE,\n\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t} else if (err) {\n\t\t\t\t\t\t\t// some error happened\n\t\t\t\t\t\t\tfinish(err);\n\n\t\t\t\t\t\t} else if (decoder) {\n\t\t\t\t\t\t\t// pass on to decoder\n\t\t\t\t\t\t\thandleChunk(bytesRead);\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// when receiving the first chunk of data we need to create the\n\t\t\t\t\t\t\t// decoding stream which is then used to drive the string stream.\n\t\t\t\t\t\t\tPromise.resolve(detectEncodingFromBuffer(\n\t\t\t\t\t\t\t\t{ buffer: chunkBuffer, bytesRead },\n\t\t\t\t\t\t\t\t(options && options.autoGuessEncoding) || this.textResourceConfigurationService.getValue(resource, 'files.autoGuessEncoding')\n\t\t\t\t\t\t\t)).then(detected => {\n\t\t\t\t\t\t\t\tif (options && options.acceptTextOnly && detected.seemsBinary) {\n\t\t\t\t\t\t\t\t\t// Return error early if client only accepts text and this is not text\n\t\t\t\t\t\t\t\t\tfinish(new FileOperationError(\n\t\t\t\t\t\t\t\t\t\tnls.localize('fileBinaryError', \"File seems to be binary and cannot be opened as text\"),\n\t\t\t\t\t\t\t\t\t\tFileOperationResult.FILE_IS_BINARY,\n\t\t\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t\t\t));\n\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tresult.encoding = this._encoding.getReadEncoding(resource, options, detected);\n\t\t\t\t\t\t\t\t\tresult.stream = decoder = decodeStream(result.encoding);\n\t\t\t\t\t\t\t\t\tresolve(result as IContentData);\n\t\t\t\t\t\t\t\t\thandleChunk(bytesRead);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}).then(undefined, err => {\n\t\t\t\t\t\t\t\t// failed to get encoding\n\t\t\t\t\t\t\t\tfinish(err);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\t// start reading\n\t\t\t\treadChunk();\n\t\t\t});\n\t\t});\n\t}\n\n\tupdateContent(resource: uri, value: string | ITextSnapshot, options: IUpdateContentOptions = Object.create(null)): Promise<IFileStatWithMetadata> {\n\t\tif (options.writeElevated) {\n\t\t\treturn this.doUpdateContentElevated(resource, value, options);\n\t\t}\n\n\t\treturn this.doUpdateContent(resource, value, options);\n\t}\n\n\tprivate doUpdateContent(resource: uri, value: string | ITextSnapshot, options: IUpdateContentOptions = Object.create(null)): Promise<IFileStatWithMetadata> {\n\t\tconst absolutePath = this.toAbsolutePath(resource);\n\n\t\t// 1.) check file for writing\n\t\treturn this.checkFileBeforeWriting(absolutePath, options).then(exists => {\n\t\t\tlet createParentsPromise: Promise<any>;\n\t\t\tif (exists) {\n\t\t\t\tcreateParentsPromise = Promise.resolve();\n\t\t\t} else {\n\t\t\t\tcreateParentsPromise = pfs.mkdirp(paths.dirname(absolutePath));\n\t\t\t}\n\n\t\t\t// 2.) create parents as needed\n\t\t\treturn createParentsPromise.then(() => {\n\t\t\t\tconst { encoding, hasBOM } = this._encoding.getWriteEncoding(resource, options.encoding);\n\t\t\t\tlet addBomPromise: Promise<boolean> = Promise.resolve(false);\n\n\t\t\t\t// Some encodings come with a BOM automatically\n\t\t\t\tif (hasBOM) {\n\t\t\t\t\taddBomPromise = Promise.resolve(hasBOM);\n\t\t\t\t}\n\n\t\t\t\t// Existing UTF-8 file: check for options regarding BOM\n\t\t\t\telse if (exists && encoding === UTF8) {\n\t\t\t\t\tif (options.overwriteEncoding) {\n\t\t\t\t\t\taddBomPromise = Promise.resolve(false); // if we are to overwrite the encoding, we do not preserve it if found\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddBomPromise = detectEncodingByBOM(absolutePath).then(enc => enc === UTF8); // otherwise preserve it if found\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 3.) check to add UTF BOM\n\t\t\t\treturn addBomPromise.then(addBom => {\n\n\t\t\t\t\t// 4.) set contents and resolve\n\t\t\t\t\tif (!exists || !isWindows) {\n\t\t\t\t\t\treturn this.doSetContentsAndResolve(resource, absolutePath, value, addBom, encoding);\n\t\t\t\t\t}\n\n\t\t\t\t\t// On Windows and if the file exists, we use a different strategy of saving the file\n\t\t\t\t\t// by first truncating the file and then writing with r+ mode. This helps to save hidden files on Windows\n\t\t\t\t\t// (see https://github.com/Microsoft/vscode/issues/931) and prevent removing alternate data streams\n\t\t\t\t\t// (see https://github.com/Microsoft/vscode/issues/6363)\n\t\t\t\t\telse {\n\n\t\t\t\t\t\t// 4.) truncate\n\t\t\t\t\t\treturn pfs.truncate(absolutePath, 0).then(() => {\n\n\t\t\t\t\t\t\t// 5.) set contents (with r+ mode) and resolve\n\t\t\t\t\t\t\treturn this.doSetContentsAndResolve(resource, absolutePath, value, addBom, encoding, { flag: 'r+' }).then(undefined, error => {\n\t\t\t\t\t\t\t\tif (this.environmentService.verbose) {\n\t\t\t\t\t\t\t\t\tconsole.error(`Truncate succeeded, but save failed (${error}), retrying after 100ms`);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// We heard from one user that fs.truncate() succeeds, but the save fails (https://github.com/Microsoft/vscode/issues/61310)\n\t\t\t\t\t\t\t\t// In that case, the file is now entirely empty and the contents are gone. This can happen if an external file watcher is\n\t\t\t\t\t\t\t\t// installed that reacts on the truncate and keeps the file busy right after. Our workaround is to retry to save after a\n\t\t\t\t\t\t\t\t// short timeout, assuming that the file is free to write then.\n\t\t\t\t\t\t\t\treturn timeout(100).then(() => this.doSetContentsAndResolve(resource, absolutePath, value, addBom, encoding, { flag: 'r+' }));\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}, error => {\n\t\t\t\t\t\t\tif (this.environmentService.verbose) {\n\t\t\t\t\t\t\t\tconsole.error(`Truncate failed (${error}), falling back to normal save`);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// we heard from users that fs.truncate() fails (https://github.com/Microsoft/vscode/issues/59561)\n\t\t\t\t\t\t\t// in that case we simply save the file without truncating first (same as macOS and Linux)\n\t\t\t\t\t\t\treturn this.doSetContentsAndResolve(resource, absolutePath, value, addBom, encoding);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}).then(undefined, error => {\n\t\t\tif (error.code === 'EACCES' || error.code === 'EPERM') {\n\t\t\t\treturn Promise.reject(new FileOperationError(\n\t\t\t\t\tnls.localize('filePermission', \"Permission denied writing to file ({0})\", resource.toString(true)),\n\t\t\t\t\tFileOperationResult.FILE_PERMISSION_DENIED,\n\t\t\t\t\toptions\n\t\t\t\t));\n\t\t\t}\n\n\t\t\treturn Promise.reject(error);\n\t\t});\n\t}\n\n\tprivate doSetContentsAndResolve(resource: uri, absolutePath: string, value: string | ITextSnapshot, addBOM: boolean, encodingToWrite: string, options?: { mode?: number; flag?: string; }): Promise<IFileStat> {\n\n\t\t// Configure encoding related options as needed\n\t\tconst writeFileOptions: extfs.IWriteFileOptions = options ? options : Object.create(null);\n\t\tif (addBOM || encodingToWrite !== UTF8) {\n\t\t\twriteFileOptions.encoding = {\n\t\t\t\tcharset: encodingToWrite,\n\t\t\t\taddBOM\n\t\t\t};\n\t\t}\n\n\t\tlet writeFilePromise: Promise<void>;\n\t\tif (typeof value === 'string') {\n\t\t\twriteFilePromise = pfs.writeFile(absolutePath, value, writeFileOptions);\n\t\t} else {\n\t\t\twriteFilePromise = pfs.writeFile(absolutePath, createReadableOfSnapshot(value), writeFileOptions);\n\t\t}\n\n\t\t// set contents\n\t\treturn writeFilePromise.then(() => {\n\n\t\t\t// resolve\n\t\t\treturn this.resolve(resource);\n\t\t});\n\t}\n\n\tprivate doUpdateContentElevated(resource: uri, value: string | ITextSnapshot, options: IUpdateContentOptions = Object.create(null)): Promise<IFileStatWithMetadata> {\n\t\tconst absolutePath = this.toAbsolutePath(resource);\n\n\t\t// 1.) check file for writing\n\t\treturn this.checkFileBeforeWriting(absolutePath, options, options.overwriteReadonly /* ignore readonly if we overwrite readonly, this is handled via sudo later */).then(exists => {\n\t\t\tconst writeOptions: IUpdateContentOptions = objects.assign(Object.create(null), options);\n\t\t\twriteOptions.writeElevated = false;\n\t\t\twriteOptions.encoding = this._encoding.getWriteEncoding(resource, options.encoding).encoding;\n\n\t\t\t// 2.) write to a temporary file to be able to copy over later\n\t\t\tconst tmpPath = paths.join(os.tmpdir(), `code-elevated-${Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 6)}`);\n\t\t\treturn this.updateContent(uri.file(tmpPath), value, writeOptions).then(() => {\n\n\t\t\t\t// 3.) invoke our CLI as super user\n\t\t\t\treturn import('sudo-prompt').then(sudoPrompt => {\n\t\t\t\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\t\t\t\tconst promptOptions = {\n\t\t\t\t\t\t\tname: this.environmentService.appNameLong.replace('-', ''),\n\t\t\t\t\t\t\ticns: (isMacintosh && this.environmentService.isBuilt) ? paths.join(paths.dirname(this.environmentService.appRoot), `${product.nameShort}.icns`) : undefined\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst sudoCommand: string[] = [`\"${this.environmentService.cliPath}\"`];\n\t\t\t\t\t\tif (options.overwriteReadonly) {\n\t\t\t\t\t\t\tsudoCommand.push('--file-chmod');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsudoCommand.push('--file-write', `\"${tmpPath}\"`, `\"${absolutePath}\"`);\n\n\t\t\t\t\t\tsudoPrompt.exec(sudoCommand.join(' '), promptOptions, (error: string, stdout: string, stderr: string) => {\n\t\t\t\t\t\t\tif (error || stderr) {\n\t\t\t\t\t\t\t\treject(error || stderr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}).then(() => {\n\n\t\t\t\t\t// 3.) delete temp file\n\t\t\t\t\treturn pfs.del(tmpPath, os.tmpdir()).then(() => {\n\n\t\t\t\t\t\t// 4.) resolve again\n\t\t\t\t\t\treturn this.resolve(resource);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t}).then(undefined, error => {\n\t\t\tif (this.environmentService.verbose) {\n\t\t\t\tthis.handleError(`Unable to write to file '${resource.toString(true)}' as elevated user (${error})`);\n\t\t\t}\n\n\t\t\tif (!FileOperationError.isFileOperationError(error)) {\n\t\t\t\terror = new FileOperationError(\n\t\t\t\t\tnls.localize('filePermission', \"Permission denied writing to file ({0})\", resource.toString(true)),\n\t\t\t\t\tFileOperationResult.FILE_PERMISSION_DENIED,\n\t\t\t\t\toptions\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn Promise.reject(error);\n\t\t});\n\t}\n\n\tcreateFile(resource: uri, content: string = '', options: ICreateFileOptions = Object.create(null)): Promise<IFileStatWithMetadata> {\n\t\tconst absolutePath = this.toAbsolutePath(resource);\n\n\t\tlet checkFilePromise: Promise<boolean>;\n\t\tif (options.overwrite) {\n\t\t\tcheckFilePromise = Promise.resolve(false);\n\t\t} else {\n\t\t\tcheckFilePromise = pfs.exists(absolutePath);\n\t\t}\n\n\t\t// Check file exists\n\t\treturn checkFilePromise.then(exists => {\n\t\t\tif (exists && !options.overwrite) {\n\t\t\t\treturn Promise.reject(new FileOperationError(\n\t\t\t\t\tnls.localize('fileExists', \"File to create already exists ({0})\", resource.toString(true)),\n\t\t\t\t\tFileOperationResult.FILE_MODIFIED_SINCE,\n\t\t\t\t\toptions\n\t\t\t\t));\n\t\t\t}\n\n\t\t\t// Create file\n\t\t\treturn this.updateContent(resource, content).then(result => {\n\n\t\t\t\t// Events\n\t\t\t\tthis._onAfterOperation.fire(new FileOperationEvent(resource, FileOperation.CREATE, result));\n\n\t\t\t\treturn result;\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate checkFileBeforeWriting(absolutePath: string, options: IUpdateContentOptions = Object.create(null), ignoreReadonly?: boolean): Promise<boolean /* exists */> {\n\t\treturn pfs.exists(absolutePath).then(exists => {\n\t\t\tif (exists) {\n\t\t\t\treturn pfs.stat(absolutePath).then(stat => {\n\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\treturn Promise.reject(new Error('Expected file is actually a directory'));\n\t\t\t\t\t}\n\n\t\t\t\t\t// Dirty write prevention: if the file on disk has been changed and does not match our expected\n\t\t\t\t\t// mtime and etag, we bail out to prevent dirty writing.\n\t\t\t\t\t//\n\t\t\t\t\t// First, we check for a mtime that is in the future before we do more checks. The assumption is\n\t\t\t\t\t// that only the mtime is an indicator for a file that has changd on disk.\n\t\t\t\t\t//\n\t\t\t\t\t// Second, if the mtime has advanced, we compare the size of the file on disk with our previous\n\t\t\t\t\t// one using the etag() function. Relying only on the mtime check has prooven to produce false\n\t\t\t\t\t// positives due to file system weirdness (especially around remote file systems). As such, the\n\t\t\t\t\t// check for size is a weaker check because it can return a false negative if the file has changed\n\t\t\t\t\t// but to the same length. This is a compromise we take to avoid having to produce checksums of\n\t\t\t\t\t// the file content for comparison which would be much slower to compute.\n\t\t\t\t\tif (typeof options.mtime === 'number' && typeof options.etag === 'string' && options.mtime < stat.mtime.getTime() && options.etag !== etag(stat.size, options.mtime)) {\n\t\t\t\t\t\treturn Promise.reject(new FileOperationError(nls.localize('fileModifiedError', \"File Modified Since\"), FileOperationResult.FILE_MODIFIED_SINCE, options));\n\t\t\t\t\t}\n\n\t\t\t\t\t// Throw if file is readonly and we are not instructed to overwrite\n\t\t\t\t\tif (!ignoreReadonly && !(stat.mode & 128) /* readonly */) {\n\t\t\t\t\t\tif (!options.overwriteReadonly) {\n\t\t\t\t\t\t\treturn this.readOnlyError<boolean>(options);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Try to change mode to writeable\n\t\t\t\t\t\tlet mode = stat.mode;\n\t\t\t\t\t\tmode = mode | 128;\n\t\t\t\t\t\treturn pfs.chmod(absolutePath, mode).then(() => {\n\n\t\t\t\t\t\t\t// Make sure to check the mode again, it could have failed\n\t\t\t\t\t\t\treturn pfs.stat(absolutePath).then(stat => {\n\t\t\t\t\t\t\t\tif (!(stat.mode & 128) /* readonly */) {\n\t\t\t\t\t\t\t\t\treturn this.readOnlyError<boolean>(options);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn exists;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn exists;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn exists;\n\t\t});\n\t}\n\n\tprivate readOnlyError<T>(options: IUpdateContentOptions): Promise<T> {\n\t\treturn Promise.reject(new FileOperationError(\n\t\t\tnls.localize('fileReadOnlyError', \"File is Read Only\"),\n\t\t\tFileOperationResult.FILE_READ_ONLY,\n\t\t\toptions\n\t\t));\n\t}\n\n\tmoveFile(source: uri, target: uri, overwrite?: boolean): Promise<IFileStatWithMetadata> {\n\t\treturn this.moveOrCopyFile(source, target, false, !!overwrite);\n\t}\n\n\tcopyFile(source: uri, target: uri, overwrite?: boolean): Promise<IFileStatWithMetadata> {\n\t\treturn this.moveOrCopyFile(source, target, true, !!overwrite);\n\t}\n\n\tprivate moveOrCopyFile(source: uri, target: uri, keepCopy: boolean, overwrite: boolean): Promise<IFileStatWithMetadata> {\n\t\tconst sourcePath = this.toAbsolutePath(source);\n\t\tconst targetPath = this.toAbsolutePath(target);\n\n\t\t// 1.) move / copy\n\t\treturn this.doMoveOrCopyFile(sourcePath, targetPath, keepCopy, overwrite).then(() => {\n\n\t\t\t// 2.) resolve\n\t\t\treturn this.resolve(target, { resolveMetadata: true }).then(result => {\n\n\t\t\t\t// Events (unless it was a no-op because paths are identical)\n\t\t\t\tif (sourcePath !== targetPath) {\n\t\t\t\t\tthis._onAfterOperation.fire(new FileOperationEvent(source, keepCopy ? FileOperation.COPY : FileOperation.MOVE, result));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate doMoveOrCopyFile(sourcePath: string, targetPath: string, keepCopy: boolean, overwrite: boolean): Promise<void> {\n\n\t\t// 1.) validate operation\n\t\tif (isParent(targetPath, sourcePath, !isLinux)) {\n\t\t\treturn Promise.reject(new Error('Unable to move/copy when source path is parent of target path'));\n\t\t} else if (sourcePath === targetPath) {\n\t\t\treturn Promise.resolve(); // no-op but not an error\n\t\t}\n\n\t\t// 2.) check if target exists\n\t\treturn pfs.exists(targetPath).then(exists => {\n\t\t\tconst isCaseRename = sourcePath.toLowerCase() === targetPath.toLowerCase();\n\n\t\t\t// Return early with conflict if target exists and we are not told to overwrite\n\t\t\tif (exists && !isCaseRename && !overwrite) {\n\t\t\t\treturn Promise.reject(new FileOperationError(nls.localize('fileMoveConflict', \"Unable to move/copy. File already exists at destination.\"), FileOperationResult.FILE_MOVE_CONFLICT));\n\t\t\t}\n\n\t\t\t// 3.) make sure target is deleted before we move/copy unless this is a case rename of the same file\n\t\t\tlet deleteTargetPromise: Promise<void> = Promise.resolve();\n\t\t\tif (exists && !isCaseRename) {\n\t\t\t\tif (isEqualOrParent(sourcePath, targetPath, !isLinux /* ignorecase */)) {\n\t\t\t\t\treturn Promise.reject(new Error(nls.localize('unableToMoveCopyError', \"Unable to move/copy. File would replace folder it is contained in.\"))); // catch this corner case!\n\t\t\t\t}\n\n\t\t\t\tdeleteTargetPromise = this.del(uri.file(targetPath), { recursive: true });\n\t\t\t}\n\n\t\t\treturn deleteTargetPromise.then(() => {\n\n\t\t\t\t// 4.) make sure parents exists\n\t\t\t\treturn pfs.mkdirp(paths.dirname(targetPath)).then(() => {\n\n\t\t\t\t\t// 4.) copy/move\n\t\t\t\t\tif (keepCopy) {\n\t\t\t\t\t\treturn nfcall(extfs.copy, sourcePath, targetPath);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn nfcall(extfs.mv, sourcePath, targetPath);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tdel(resource: uri, options?: { useTrash?: boolean, recursive?: boolean }): Promise<void> {\n\t\tif (options && options.useTrash) {\n\t\t\treturn this.doMoveItemToTrash(resource);\n\t\t}\n\n\t\treturn this.doDelete(resource, !!(options && options.recursive));\n\t}\n\n\tprivate doMoveItemToTrash(resource: uri): Promise<void> {\n\t\tconst absolutePath = resource.fsPath;\n\n\t\tconst shell = (require('electron') as any as Electron.RendererInterface).shell; // workaround for being able to run tests out of VSCode debugger\n\t\tconst result = shell.moveItemToTrash(absolutePath);\n\t\tif (!result) {\n\t\t\treturn Promise.reject(new Error(isWindows ? nls.localize('binFailed', \"Failed to move '{0}' to the recycle bin\", paths.basename(absolutePath)) : nls.localize('trashFailed', \"Failed to move '{0}' to the trash\", paths.basename(absolutePath))));\n\t\t}\n\n\t\tthis._onAfterOperation.fire(new FileOperationEvent(resource, FileOperation.DELETE));\n\n\t\treturn Promise.resolve();\n\t}\n\n\tprivate doDelete(resource: uri, recursive: boolean): Promise<void> {\n\t\tconst absolutePath = this.toAbsolutePath(resource);\n\n\t\tlet assertNonRecursiveDelete: Promise<void>;\n\t\tif (!recursive) {\n\t\t\tassertNonRecursiveDelete = pfs.stat(absolutePath).then(stat => {\n\t\t\t\tif (!stat.isDirectory()) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\treturn pfs.readdir(absolutePath).then(children => {\n\t\t\t\t\tif (children.length === 0) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Promise.reject(new Error(nls.localize('deleteFailed', \"Failed to delete non-empty folder '{0}'.\", paths.basename(absolutePath))));\n\t\t\t\t});\n\t\t\t}, error => Promise.resolve() /* ignore errors */);\n\t\t} else {\n\t\t\tassertNonRecursiveDelete = Promise.resolve();\n\t\t}\n\n\t\treturn assertNonRecursiveDelete.then(() => {\n\t\t\treturn pfs.del(absolutePath, os.tmpdir()).then(() => {\n\n\t\t\t\t// Events\n\t\t\t\tthis._onAfterOperation.fire(new FileOperationEvent(resource, FileOperation.DELETE));\n\t\t\t});\n\t\t});\n\t}\n\n\t// Helpers\n\n\tprivate toAbsolutePath(arg1: uri | IFileStat): string {\n\t\tlet resource: uri;\n\t\tif (arg1 instanceof uri) {\n\t\t\tresource = <uri>arg1;\n\t\t} else {\n\t\t\tresource = (<IFileStat>arg1).resource;\n\t\t}\n\n\t\tassert.ok(resource && resource.scheme === Schemas.file, `Invalid resource: ${resource}`);\n\n\t\treturn paths.normalize(resource.fsPath);\n\t}\n\n\tprivate resolve(resource: uri, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tprivate resolve(resource: uri, options?: IResolveFileOptions): Promise<IFileStat>;\n\tprivate resolve(resource: uri, options: IResolveFileOptions = Object.create(null)): Promise<IFileStat> {\n\t\treturn this.toStatResolver(resource).then(model => model.resolve(options));\n\t}\n\n\tprivate toStatResolver(resource: uri): Promise<StatResolver> {\n\t\tconst absolutePath = this.toAbsolutePath(resource);\n\n\t\treturn pfs.statLink(absolutePath).then(({ isSymbolicLink, stat }) => {\n\t\t\treturn new StatResolver(resource, isSymbolicLink, stat.isDirectory(), stat.mtime.getTime(), stat.size, this.environmentService.verbose ? err => this.handleError(err) : undefined);\n\t\t});\n\t}\n\n\twatchFileChanges(resource: uri): void {\n\t\tassert.ok(resource && resource.scheme === Schemas.file, `Invalid resource for watching: ${resource}`);\n\n\t\t// Check for existing watcher first\n\t\tconst entry = this.activeFileChangesWatchers.get(resource);\n\t\tif (entry) {\n\t\t\tentry.count += 1;\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Create or get watcher for provided path\n\t\tconst fsPath = resource.fsPath;\n\t\tconst fsName = paths.basename(resource.fsPath);\n\n\t\tconst watcherDisposable = extfs.watch(fsPath, (eventType: string, filename: string) => {\n\t\t\tconst renamedOrDeleted = ((filename && filename !== fsName) || eventType === 'rename');\n\n\t\t\t// The file was either deleted or renamed. Many tools apply changes to files in an\n\t\t\t// atomic way (\"Atomic Save\") by first renaming the file to a temporary name and then\n\t\t\t// renaming it back to the original name. Our watcher will detect this as a rename\n\t\t\t// and then stops to work on Mac and Linux because the watcher is applied to the\n\t\t\t// inode and not the name. The fix is to detect this case and trying to watch the file\n\t\t\t// again after a certain delay.\n\t\t\t// In addition, we send out a delete event if after a timeout we detect that the file\n\t\t\t// does indeed not exist anymore.\n\t\t\tif (renamedOrDeleted) {\n\n\t\t\t\t// Very important to dispose the watcher which now points to a stale inode\n\t\t\t\twatcherDisposable.dispose();\n\t\t\t\tthis.activeFileChangesWatchers.delete(resource);\n\n\t\t\t\t// Wait a bit and try to install watcher again, assuming that the file was renamed quickly (\"Atomic Save\")\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.existsFile(resource).then(exists => {\n\n\t\t\t\t\t\t// File still exists, so reapply the watcher\n\t\t\t\t\t\tif (exists) {\n\t\t\t\t\t\t\tthis.watchFileChanges(resource);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// File seems to be really gone, so emit a deleted event\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis.onRawFileChange({\n\t\t\t\t\t\t\t\ttype: FileChangeType.DELETED,\n\t\t\t\t\t\t\t\tpath: fsPath\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}, FileService.FS_REWATCH_DELAY);\n\t\t\t}\n\n\t\t\t// Handle raw file change\n\t\t\tthis.onRawFileChange({\n\t\t\t\ttype: FileChangeType.UPDATED,\n\t\t\t\tpath: fsPath\n\t\t\t});\n\t\t}, (error: string) => this.handleError(error));\n\n\t\t// Remember in map\n\t\tthis.activeFileChangesWatchers.set(resource, {\n\t\t\tcount: 1,\n\t\t\tunwatch: () => watcherDisposable.dispose()\n\t\t});\n\t}\n\n\tprivate onRawFileChange(event: IRawFileChange): void {\n\n\t\t// add to bucket of undelivered events\n\t\tthis.undeliveredRawFileChangesEvents.push(event);\n\n\t\tif (this.environmentService.verbose) {\n\t\t\tconsole.log('%c[File Watcher (node.js)]%c', 'color: blue', 'color: black', `${event.type === FileChangeType.ADDED ? '[ADDED]' : event.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.path}`);\n\t\t}\n\n\t\t// handle emit through delayer to accommodate for bulk changes\n\t\tthis.fileChangesWatchDelayer.trigger(() => {\n\t\t\tconst buffer = this.undeliveredRawFileChangesEvents;\n\t\t\tthis.undeliveredRawFileChangesEvents = [];\n\n\t\t\t// Normalize\n\t\t\tconst normalizedEvents = normalize(buffer);\n\n\t\t\t// Logging\n\t\t\tif (this.environmentService.verbose) {\n\t\t\t\tnormalizedEvents.forEach(r => {\n\t\t\t\t\tconsole.log('%c[File Watcher (node.js)]%c >> normalized', 'color: blue', 'color: black', `${r.type === FileChangeType.ADDED ? '[ADDED]' : r.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${r.path}`);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Emit\n\t\t\tthis._onFileChanges.fire(toFileChangesEvent(normalizedEvents));\n\n\t\t\treturn Promise.resolve();\n\t\t});\n\t}\n\n\tunwatchFileChanges(resource: uri): void {\n\t\tconst watcher = this.activeFileChangesWatchers.get(resource);\n\t\tif (watcher && --watcher.count === 0) {\n\t\t\twatcher.unwatch();\n\t\t\tthis.activeFileChangesWatchers.delete(resource);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tsuper.dispose();\n\n\t\tif (this.activeWorkspaceFileChangeWatcher) {\n\t\t\tthis.activeWorkspaceFileChangeWatcher.dispose();\n\t\t\tthis.activeWorkspaceFileChangeWatcher = null;\n\t\t}\n\n\t\tthis.activeFileChangesWatchers.forEach(watcher => watcher.unwatch());\n\t\tthis.activeFileChangesWatchers.clear();\n\t}\n\n\n\n\n\n\n\n\n\t// Tests only\n\n\tresolveFile(resource: uri, options?: IResolveFileOptions): Promise<IFileStat>;\n\tresolveFile(resource: uri, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tresolveFile(resource: uri, options?: IResolveFileOptions): Promise<IFileStat> {\n\t\treturn this.resolve(resource, options);\n\t}\n\n\tresolveFiles(toResolve: { resource: uri, options?: IResolveFileOptions }[]): Promise<IResolveFileResult[]> {\n\t\treturn Promise.all(toResolve.map(resourceAndOptions => this.resolve(resourceAndOptions.resource, resourceAndOptions.options)\n\t\t\t.then(stat => ({ stat, success: true }), error => ({ stat: undefined, success: false }))));\n\t}\n\n\tcreateFolder(resource: uri): Promise<IFileStatWithMetadata> {\n\n\t\t// 1.) Create folder\n\t\tconst absolutePath = this.toAbsolutePath(resource);\n\t\treturn pfs.mkdirp(absolutePath).then(() => {\n\n\t\t\t// 2.) Resolve\n\t\t\treturn this.resolve(resource, { resolveMetadata: true }).then(result => {\n\n\t\t\t\t// Events\n\t\t\t\tthis._onAfterOperation.fire(new FileOperationEvent(resource, FileOperation.CREATE, result));\n\n\t\t\t\treturn result;\n\t\t\t});\n\t\t});\n\t}\n\n\texistsFile(resource: uri): Promise<boolean> {\n\t\treturn this.resolveFile(resource).then(() => true, () => false);\n\t}\n}\n\nfunction etag(stat: fs.Stats): string;\nfunction etag(size: number, mtime: number): string;\nfunction etag(arg1: any, arg2?: any): string {\n\tlet size: number;\n\tlet mtime: number;\n\tif (typeof arg2 === 'number') {\n\t\tsize = arg1;\n\t\tmtime = arg2;\n\t} else {\n\t\tsize = (<fs.Stats>arg1).size;\n\t\tmtime = (<fs.Stats>arg1).mtime.getTime();\n\t}\n\n\treturn `\"${crypto.createHash('sha1').update(String(size) + String(mtime)).digest('hex')}\"`;\n}\n\nexport class StatResolver {\n\tprivate name: string;\n\tprivate etag: string;\n\n\tconstructor(\n\t\tprivate resource: uri,\n\t\tprivate isSymbolicLink: boolean,\n\t\tprivate isDirectory: boolean,\n\t\tprivate mtime: number,\n\t\tprivate size: number,\n\t\tprivate errorLogger?: (error: Error | string) => void\n\t) {\n\t\tassert.ok(resource && resource.scheme === Schemas.file, `Invalid resource: ${resource}`);\n\n\t\tthis.name = getBaseLabel(resource);\n\t\tthis.etag = etag(size, mtime);\n\t}\n\n\tresolve(options: IResolveFileOptions | undefined): Promise<IFileStat> {\n\n\t\t// General Data\n\t\tconst fileStat: IFileStat = {\n\t\t\tresource: this.resource,\n\t\t\tisDirectory: this.isDirectory,\n\t\t\tisSymbolicLink: this.isSymbolicLink,\n\t\t\tisReadonly: false,\n\t\t\tname: this.name,\n\t\t\tetag: this.etag,\n\t\t\tsize: this.size,\n\t\t\tmtime: this.mtime\n\t\t};\n\n\t\t// File Specific Data\n\t\tif (!this.isDirectory) {\n\t\t\treturn Promise.resolve(fileStat);\n\t\t}\n\n\t\t// Directory Specific Data\n\t\telse {\n\n\t\t\t// Convert the paths from options.resolveTo to absolute paths\n\t\t\tlet absoluteTargetPaths: string[] | null = null;\n\t\t\tif (options && options.resolveTo) {\n\t\t\t\tabsoluteTargetPaths = [];\n\t\t\t\tfor (const resource of options.resolveTo) {\n\t\t\t\t\tabsoluteTargetPaths.push(resource.fsPath);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new Promise<IFileStat>(resolve => {\n\n\t\t\t\t// Load children\n\t\t\t\tthis.resolveChildren(this.resource.fsPath, absoluteTargetPaths, !!(options && options.resolveSingleChildDescendants), children => {\n\t\t\t\t\tif (children) {\n\t\t\t\t\t\tchildren = arrays.coalesce(children); // we don't want those null children (could be permission denied when reading a child)\n\t\t\t\t\t}\n\t\t\t\t\tfileStat.children = children || [];\n\n\t\t\t\t\tresolve(fileStat);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate resolveChildren(absolutePath: string, absoluteTargetPaths: string[] | null, resolveSingleChildDescendants: boolean, callback: (children: IFileStat[] | null) => void): void {\n\t\textfs.readdir(absolutePath, (error: Error, files: string[]) => {\n\t\t\tif (error) {\n\t\t\t\tif (this.errorLogger) {\n\t\t\t\t\tthis.errorLogger(error);\n\t\t\t\t}\n\n\t\t\t\treturn callback(null); // return - we might not have permissions to read the folder\n\t\t\t}\n\n\t\t\t// for each file in the folder\n\t\t\tflow.parallel(files, (file: string, clb: (error: Error | null, children: IFileStat | null) => void) => {\n\t\t\t\tconst fileResource = uri.file(paths.resolve(absolutePath, file));\n\t\t\t\tlet fileStat: fs.Stats;\n\t\t\t\tlet isSymbolicLink = false;\n\t\t\t\tconst $this = this;\n\n\t\t\t\tflow.sequence(\n\t\t\t\t\tfunction onError(error: Error): void {\n\t\t\t\t\t\tif ($this.errorLogger) {\n\t\t\t\t\t\t\t$this.errorLogger(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclb(null, null); // return - we might not have permissions to read the folder or stat the file\n\t\t\t\t\t},\n\n\t\t\t\t\tfunction stat(this: any): void {\n\t\t\t\t\t\textfs.statLink(fileResource.fsPath, this);\n\t\t\t\t\t},\n\n\t\t\t\t\tfunction countChildren(this: any, statAndLink: extfs.IStatAndLink): void {\n\t\t\t\t\t\tfileStat = statAndLink.stat;\n\t\t\t\t\t\tisSymbolicLink = statAndLink.isSymbolicLink;\n\n\t\t\t\t\t\tif (fileStat.isDirectory()) {\n\t\t\t\t\t\t\textfs.readdir(fileResource.fsPath, (error, result) => {\n\t\t\t\t\t\t\t\tthis(null, result ? result.length : 0);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis(null, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tfunction resolve(childCount: number): void {\n\t\t\t\t\t\tconst childStat: IFileStat = {\n\t\t\t\t\t\t\tresource: fileResource,\n\t\t\t\t\t\t\tisDirectory: fileStat.isDirectory(),\n\t\t\t\t\t\t\tisSymbolicLink,\n\t\t\t\t\t\t\tisReadonly: false,\n\t\t\t\t\t\t\tname: file,\n\t\t\t\t\t\t\tmtime: fileStat.mtime.getTime(),\n\t\t\t\t\t\t\tetag: etag(fileStat),\n\t\t\t\t\t\t\tsize: fileStat.size\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Return early for files\n\t\t\t\t\t\tif (!fileStat.isDirectory()) {\n\t\t\t\t\t\t\treturn clb(null, childStat);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Handle Folder\n\t\t\t\t\t\tlet resolveFolderChildren = false;\n\t\t\t\t\t\tif (files.length === 1 && resolveSingleChildDescendants) {\n\t\t\t\t\t\t\tresolveFolderChildren = true;\n\t\t\t\t\t\t} else if (childCount > 0 && absoluteTargetPaths && absoluteTargetPaths.some(targetPath => isEqualOrParent(targetPath, fileResource.fsPath, !isLinux /* ignorecase */))) {\n\t\t\t\t\t\t\tresolveFolderChildren = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Continue resolving children based on condition\n\t\t\t\t\t\tif (resolveFolderChildren) {\n\t\t\t\t\t\t\t$this.resolveChildren(fileResource.fsPath, absoluteTargetPaths, resolveSingleChildDescendants, children => {\n\t\t\t\t\t\t\t\tif (children) {\n\t\t\t\t\t\t\t\t\tchildren = arrays.coalesce(children);  // we don't want those null children\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchildStat.children = children || [];\n\n\t\t\t\t\t\t\t\tclb(null, childStat);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise return result\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tclb(null, childStat);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}, (errors, result) => {\n\t\t\t\tcallback(result);\n\t\t\t});\n\t\t});\n\t}\n}\n"]}]}