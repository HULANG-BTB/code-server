{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/supports/richEditBrackets.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/supports/richEditBrackets.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/strings\", \"vs/editor/common/core/range\"], function (require, exports, strings, range_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class RichEditBracket {\n        constructor(languageIdentifier, open, close, forwardRegex, reversedRegex) {\n            this.languageIdentifier = languageIdentifier;\n            this.open = open;\n            this.close = close;\n            this.forwardRegex = forwardRegex;\n            this.reversedRegex = reversedRegex;\n        }\n    }\n    exports.RichEditBracket = RichEditBracket;\n    class RichEditBrackets {\n        constructor(languageIdentifier, brackets) {\n            this.brackets = brackets.map((b) => {\n                return new RichEditBracket(languageIdentifier, b[0], b[1], getRegexForBracketPair({ open: b[0], close: b[1] }), getReversedRegexForBracketPair({ open: b[0], close: b[1] }));\n            });\n            this.forwardRegex = getRegexForBrackets(this.brackets);\n            this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n            this.textIsBracket = {};\n            this.textIsOpenBracket = {};\n            let maxBracketLength = 0;\n            this.brackets.forEach((b) => {\n                this.textIsBracket[b.open.toLowerCase()] = b;\n                this.textIsBracket[b.close.toLowerCase()] = b;\n                this.textIsOpenBracket[b.open.toLowerCase()] = true;\n                this.textIsOpenBracket[b.close.toLowerCase()] = false;\n                maxBracketLength = Math.max(maxBracketLength, b.open.length);\n                maxBracketLength = Math.max(maxBracketLength, b.close.length);\n            });\n            this.maxBracketLength = maxBracketLength;\n        }\n    }\n    exports.RichEditBrackets = RichEditBrackets;\n    function once(keyFn, computeFn) {\n        let cache = {};\n        return (input) => {\n            let key = keyFn(input);\n            if (!cache.hasOwnProperty(key)) {\n                cache[key] = computeFn(input);\n            }\n            return cache[key];\n        };\n    }\n    const getRegexForBracketPair = once((input) => `${input.open};${input.close}`, (input) => {\n        return createBracketOrRegExp([input.open, input.close]);\n    });\n    const getReversedRegexForBracketPair = once((input) => `${input.open};${input.close}`, (input) => {\n        return createBracketOrRegExp([toReversedString(input.open), toReversedString(input.close)]);\n    });\n    const getRegexForBrackets = once((input) => input.map(b => `${b.open};${b.close}`).join(';'), (input) => {\n        let pieces = [];\n        input.forEach((b) => {\n            pieces.push(b.open);\n            pieces.push(b.close);\n        });\n        return createBracketOrRegExp(pieces);\n    });\n    const getReversedRegexForBrackets = once((input) => input.map(b => `${b.open};${b.close}`).join(';'), (input) => {\n        let pieces = [];\n        input.forEach((b) => {\n            pieces.push(toReversedString(b.open));\n            pieces.push(toReversedString(b.close));\n        });\n        return createBracketOrRegExp(pieces);\n    });\n    function prepareBracketForRegExp(str) {\n        // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n        const insertWordBoundaries = (/^[\\w]+$/.test(str));\n        str = strings.escapeRegExpCharacters(str);\n        return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n    }\n    function createBracketOrRegExp(pieces) {\n        let regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n        return strings.createRegExp(regexStr, true);\n    }\n    let toReversedString = (function () {\n        function reverse(str) {\n            let reversedStr = '';\n            for (let i = str.length - 1; i >= 0; i--) {\n                reversedStr += str.charAt(i);\n            }\n            return reversedStr;\n        }\n        let lastInput = null;\n        let lastOutput = null;\n        return function toReversedString(str) {\n            if (lastInput !== str) {\n                lastInput = str;\n                lastOutput = reverse(lastInput);\n            }\n            return lastOutput;\n        };\n    })();\n    class BracketsUtils {\n        static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n            let m = reversedText.match(reversedBracketRegex);\n            if (!m) {\n                return null;\n            }\n            let matchOffset = reversedText.length - (m.index || 0);\n            let matchLength = m[0].length;\n            let absoluteMatchOffset = offset + matchOffset;\n            return new range_1.Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n        }\n        static findPrevBracketInToken(reversedBracketRegex, lineNumber, lineText, currentTokenStart, currentTokenEnd) {\n            // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n            let reversedLineText = toReversedString(lineText);\n            let reversedTokenText = reversedLineText.substring(lineText.length - currentTokenEnd, lineText.length - currentTokenStart);\n            return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedTokenText, currentTokenStart);\n        }\n        static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n            let m = text.match(bracketRegex);\n            if (!m) {\n                return null;\n            }\n            let matchOffset = m.index || 0;\n            let matchLength = m[0].length;\n            if (matchLength === 0) {\n                return null;\n            }\n            let absoluteMatchOffset = offset + matchOffset;\n            return new range_1.Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n        }\n        static findNextBracketInToken(bracketRegex, lineNumber, lineText, currentTokenStart, currentTokenEnd) {\n            let currentTokenText = lineText.substring(currentTokenStart, currentTokenEnd);\n            return this.findNextBracketInText(bracketRegex, lineNumber, currentTokenText, currentTokenStart);\n        }\n    }\n    exports.BracketsUtils = BracketsUtils;\n});\n",null]}