{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/linkedList.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/linkedList.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/iterator\"], function (require, exports, iterator_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class Node {\n        constructor(element) {\n            this.element = element;\n        }\n    }\n    class LinkedList {\n        constructor() {\n            this._size = 0;\n        }\n        get size() {\n            return this._size;\n        }\n        isEmpty() {\n            return !this._first;\n        }\n        clear() {\n            this._first = undefined;\n            this._last = undefined;\n            this._size = 0;\n        }\n        unshift(element) {\n            return this._insert(element, false);\n        }\n        push(element) {\n            return this._insert(element, true);\n        }\n        _insert(element, atTheEnd) {\n            const newNode = new Node(element);\n            if (!this._first) {\n                this._first = newNode;\n                this._last = newNode;\n            }\n            else if (atTheEnd) {\n                // push\n                const oldLast = this._last;\n                this._last = newNode;\n                newNode.prev = oldLast;\n                oldLast.next = newNode;\n            }\n            else {\n                // unshift\n                const oldFirst = this._first;\n                this._first = newNode;\n                newNode.next = oldFirst;\n                oldFirst.prev = newNode;\n            }\n            this._size += 1;\n            return this._remove.bind(this, newNode);\n        }\n        shift() {\n            if (!this._first) {\n                return undefined;\n            }\n            else {\n                const res = this._first.element;\n                this._remove(this._first);\n                return res;\n            }\n        }\n        pop() {\n            if (!this._last) {\n                return undefined;\n            }\n            else {\n                const res = this._last.element;\n                this._remove(this._last);\n                return res;\n            }\n        }\n        _remove(node) {\n            let candidate = this._first;\n            while (candidate instanceof Node) {\n                if (candidate !== node) {\n                    candidate = candidate.next;\n                    continue;\n                }\n                if (candidate.prev && candidate.next) {\n                    // middle\n                    const anchor = candidate.prev;\n                    anchor.next = candidate.next;\n                    candidate.next.prev = anchor;\n                }\n                else if (!candidate.prev && !candidate.next) {\n                    // only node\n                    this._first = undefined;\n                    this._last = undefined;\n                }\n                else if (!candidate.next) {\n                    // last\n                    this._last = this._last.prev;\n                    this._last.next = undefined;\n                }\n                else if (!candidate.prev) {\n                    // first\n                    this._first = this._first.next;\n                    this._first.prev = undefined;\n                }\n                // done\n                this._size -= 1;\n                break;\n            }\n        }\n        iterator() {\n            let element;\n            let node = this._first;\n            return {\n                next() {\n                    if (!node) {\n                        return iterator_1.FIN;\n                    }\n                    if (!element) {\n                        element = { done: false, value: node.element };\n                    }\n                    else {\n                        element.value = node.element;\n                    }\n                    node = node.next;\n                    return element;\n                }\n            };\n        }\n        toArray() {\n            const result = [];\n            for (let node = this._first; node instanceof Node; node = node.next) {\n                result.push(node.element);\n            }\n            return result;\n        }\n    }\n    exports.LinkedList = LinkedList;\n});\n",null]}