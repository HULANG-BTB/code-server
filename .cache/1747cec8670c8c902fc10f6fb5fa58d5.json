{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/preferences/common/smartSnippetInserter.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/preferences/common/smartSnippetInserter.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/json\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\"], function (require, exports, json_1, position_1, range_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class SmartSnippetInserter {\n        static hasOpenBrace(scanner) {\n            while (scanner.scan() !== json_1.SyntaxKind.EOF) {\n                const kind = scanner.getToken();\n                if (kind === json_1.SyntaxKind.OpenBraceToken) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        static offsetToPosition(model, offset) {\n            let offsetBeforeLine = 0;\n            const eolLength = model.getEOL().length;\n            const lineCount = model.getLineCount();\n            for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n                const lineTotalLength = model.getLineContent(lineNumber).length + eolLength;\n                const offsetAfterLine = offsetBeforeLine + lineTotalLength;\n                if (offsetAfterLine > offset) {\n                    return new position_1.Position(lineNumber, offset - offsetBeforeLine + 1);\n                }\n                offsetBeforeLine = offsetAfterLine;\n            }\n            return new position_1.Position(lineCount, model.getLineMaxColumn(lineCount));\n        }\n        static insertSnippet(model, _position) {\n            const desiredPosition = model.getValueLengthInRange(new range_1.Range(1, 1, _position.lineNumber, _position.column));\n            // <INVALID> [ <BEFORE_OBJECT> { <INVALID> } <AFTER_OBJECT>, <BEFORE_OBJECT> { <INVALID> } <AFTER_OBJECT> ] <INVALID>\n            let State;\n            (function (State) {\n                State[State[\"INVALID\"] = 0] = \"INVALID\";\n                State[State[\"AFTER_OBJECT\"] = 1] = \"AFTER_OBJECT\";\n                State[State[\"BEFORE_OBJECT\"] = 2] = \"BEFORE_OBJECT\";\n            })(State || (State = {}));\n            let currentState = State.INVALID;\n            let lastValidPos = -1;\n            let lastValidState = State.INVALID;\n            const scanner = json_1.createScanner(model.getValue());\n            let arrayLevel = 0;\n            let objLevel = 0;\n            const checkRangeStatus = (pos, state) => {\n                if (state !== State.INVALID && arrayLevel === 1 && objLevel === 0) {\n                    currentState = state;\n                    lastValidPos = pos;\n                    lastValidState = state;\n                }\n                else {\n                    if (currentState !== State.INVALID) {\n                        currentState = State.INVALID;\n                        lastValidPos = scanner.getTokenOffset();\n                    }\n                }\n            };\n            while (scanner.scan() !== json_1.SyntaxKind.EOF) {\n                const currentPos = scanner.getPosition();\n                const kind = scanner.getToken();\n                let goodKind = false;\n                switch (kind) {\n                    case json_1.SyntaxKind.OpenBracketToken:\n                        goodKind = true;\n                        arrayLevel++;\n                        checkRangeStatus(currentPos, State.BEFORE_OBJECT);\n                        break;\n                    case json_1.SyntaxKind.CloseBracketToken:\n                        goodKind = true;\n                        arrayLevel--;\n                        checkRangeStatus(currentPos, State.INVALID);\n                        break;\n                    case json_1.SyntaxKind.CommaToken:\n                        goodKind = true;\n                        checkRangeStatus(currentPos, State.BEFORE_OBJECT);\n                        break;\n                    case json_1.SyntaxKind.OpenBraceToken:\n                        goodKind = true;\n                        objLevel++;\n                        checkRangeStatus(currentPos, State.INVALID);\n                        break;\n                    case json_1.SyntaxKind.CloseBraceToken:\n                        goodKind = true;\n                        objLevel--;\n                        checkRangeStatus(currentPos, State.AFTER_OBJECT);\n                        break;\n                    case json_1.SyntaxKind.Trivia:\n                    case json_1.SyntaxKind.LineBreakTrivia:\n                        goodKind = true;\n                }\n                if (currentPos >= desiredPosition && (currentState !== State.INVALID || lastValidPos !== -1)) {\n                    let acceptPosition;\n                    let acceptState;\n                    if (currentState !== State.INVALID) {\n                        acceptPosition = (goodKind ? currentPos : scanner.getTokenOffset());\n                        acceptState = currentState;\n                    }\n                    else {\n                        acceptPosition = lastValidPos;\n                        acceptState = lastValidState;\n                    }\n                    if (acceptState === State.AFTER_OBJECT) {\n                        return {\n                            position: this.offsetToPosition(model, acceptPosition),\n                            prepend: ',',\n                            append: ''\n                        };\n                    }\n                    else {\n                        scanner.setPosition(acceptPosition);\n                        return {\n                            position: this.offsetToPosition(model, acceptPosition),\n                            prepend: '',\n                            append: this.hasOpenBrace(scanner) ? ',' : ''\n                        };\n                    }\n                }\n            }\n            // no valid position found!\n            const modelLineCount = model.getLineCount();\n            return {\n                position: new position_1.Position(modelLineCount, model.getLineMaxColumn(modelLineCount)),\n                prepend: '\\n[',\n                append: ']'\n            };\n        }\n    }\n    exports.SmartSnippetInserter = SmartSnippetInserter;\n});\n",null]}