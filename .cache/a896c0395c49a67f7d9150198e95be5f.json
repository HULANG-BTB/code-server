{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/electron-browser/extensionHostProfiler.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/electron-browser/extensionHostProfiler.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar map_1 = require(\"vs/base/common/map\");\nvar extfs_1 = require(\"vs/base/node/extfs\");\nvar extensions_1 = require(\"vs/workbench/services/extensions/common/extensions\");\nvar types_1 = require(\"vs/base/common/types\");\nvar ExtensionHostProfiler = /** @class */ (function () {\n    function ExtensionHostProfiler(_port, _extensionService) {\n        this._port = _port;\n        this._extensionService = _extensionService;\n    }\n    ExtensionHostProfiler.prototype.start = function () {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var profiler, session;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, Promise.resolve().then(function () { return require('v8-inspect-profiler'); })];\n                    case 1:\n                        profiler = _a.sent();\n                        return [4 /*yield*/, profiler.startProfiling({ port: this._port, checkForPaused: true })];\n                    case 2:\n                        session = _a.sent();\n                        return [2 /*return*/, {\n                                stop: function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                                    var profile, extensions;\n                                    return tslib_1.__generator(this, function (_a) {\n                                        switch (_a.label) {\n                                            case 0: return [4 /*yield*/, session.stop()];\n                                            case 1:\n                                                profile = _a.sent();\n                                                return [4 /*yield*/, this._extensionService.getExtensions()];\n                                            case 2:\n                                                extensions = _a.sent();\n                                                return [2 /*return*/, this.distill(profile.profile, extensions)];\n                                        }\n                                    });\n                                }); }\n                            }];\n                }\n            });\n        });\n    };\n    ExtensionHostProfiler.prototype.distill = function (profile, extensions) {\n        var searchTree = map_1.TernarySearchTree.forPaths();\n        for (var _i = 0, extensions_2 = extensions; _i < extensions_2.length; _i++) {\n            var extension = extensions_2[_i];\n            searchTree.set(extfs_1.realpathSync(extension.extensionLocation.fsPath), extension);\n        }\n        var nodes = profile.nodes;\n        var idsToNodes = new Map();\n        var idsToSegmentId = new Map();\n        for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {\n            var node = nodes_1[_a];\n            idsToNodes.set(node.id, node);\n        }\n        function visit(node, segmentId) {\n            if (!segmentId) {\n                switch (node.callFrame.functionName) {\n                    case '(root)':\n                        break;\n                    case '(program)':\n                        segmentId = 'program';\n                        break;\n                    case '(garbage collector)':\n                        segmentId = 'gc';\n                        break;\n                    default:\n                        segmentId = 'self';\n                        break;\n                }\n            }\n            else if (segmentId === 'self' && node.callFrame.url) {\n                var extension = searchTree.findSubstr(node.callFrame.url);\n                if (extension) {\n                    segmentId = extension.identifier.value;\n                }\n            }\n            idsToSegmentId.set(node.id, segmentId);\n            if (node.children) {\n                for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                    var child = _a[_i];\n                    var childNode = idsToNodes.get(child);\n                    if (childNode) {\n                        visit(childNode, segmentId);\n                    }\n                }\n            }\n        }\n        visit(nodes[0], null);\n        var samples = profile.samples || [];\n        var timeDeltas = profile.timeDeltas || [];\n        var distilledDeltas = [];\n        var distilledIds = [];\n        var currSegmentTime = 0;\n        var currSegmentId;\n        for (var i = 0; i < samples.length; i++) {\n            var id = samples[i];\n            var segmentId = idsToSegmentId.get(id);\n            if (segmentId !== currSegmentId) {\n                if (currSegmentId) {\n                    distilledIds.push(currSegmentId);\n                    distilledDeltas.push(currSegmentTime);\n                }\n                currSegmentId = types_1.withNullAsUndefined(segmentId);\n                currSegmentTime = 0;\n            }\n            currSegmentTime += timeDeltas[i];\n        }\n        if (currSegmentId) {\n            distilledIds.push(currSegmentId);\n            distilledDeltas.push(currSegmentTime);\n        }\n        return {\n            startTime: profile.startTime,\n            endTime: profile.endTime,\n            deltas: distilledDeltas,\n            ids: distilledIds,\n            data: profile,\n            getAggregatedTimes: function () {\n                var segmentsToTime = new Map();\n                for (var i = 0; i < distilledIds.length; i++) {\n                    var id = distilledIds[i];\n                    segmentsToTime.set(id, (segmentsToTime.get(id) || 0) + distilledDeltas[i]);\n                }\n                return segmentsToTime;\n            }\n        };\n    };\n    ExtensionHostProfiler = tslib_1.__decorate([\n        tslib_1.__param(1, extensions_1.IExtensionService)\n    ], ExtensionHostProfiler);\n    return ExtensionHostProfiler;\n}());\nexports.ExtensionHostProfiler = ExtensionHostProfiler;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/electron-browser/extensionHostProfiler.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/electron-browser/extensionHostProfiler.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Profile, ProfileNode } from 'v8-inspect-profiler';\nimport { TernarySearchTree } from 'vs/base/common/map';\nimport { realpathSync } from 'vs/base/node/extfs';\nimport { IExtensionHostProfile, IExtensionService, ProfileSegmentId, ProfileSession } from 'vs/workbench/services/extensions/common/extensions';\nimport { IExtensionDescription } from 'vs/platform/extensions/common/extensions';\nimport { withNullAsUndefined } from 'vs/base/common/types';\n\nexport class ExtensionHostProfiler {\n\n\tconstructor(private readonly _port: number, @IExtensionService private readonly _extensionService: IExtensionService) {\n\t}\n\n\tpublic async start(): Promise<ProfileSession> {\n\t\tconst profiler = await import('v8-inspect-profiler');\n\t\tconst session = await profiler.startProfiling({ port: this._port, checkForPaused: true });\n\t\treturn {\n\t\t\tstop: async () => {\n\t\t\t\tconst profile = await session.stop();\n\t\t\t\tconst extensions = await this._extensionService.getExtensions();\n\t\t\t\treturn this.distill((profile as any).profile, extensions);\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate distill(profile: Profile, extensions: IExtensionDescription[]): IExtensionHostProfile {\n\t\tlet searchTree = TernarySearchTree.forPaths<IExtensionDescription>();\n\t\tfor (let extension of extensions) {\n\t\t\tsearchTree.set(realpathSync(extension.extensionLocation.fsPath), extension);\n\t\t}\n\n\t\tlet nodes = profile.nodes;\n\t\tlet idsToNodes = new Map<number, ProfileNode>();\n\t\tlet idsToSegmentId = new Map<number, ProfileSegmentId | null>();\n\t\tfor (let node of nodes) {\n\t\t\tidsToNodes.set(node.id, node);\n\t\t}\n\n\t\tfunction visit(node: ProfileNode, segmentId: ProfileSegmentId | null) {\n\t\t\tif (!segmentId) {\n\t\t\t\tswitch (node.callFrame.functionName) {\n\t\t\t\t\tcase '(root)':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '(program)':\n\t\t\t\t\t\tsegmentId = 'program';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '(garbage collector)':\n\t\t\t\t\t\tsegmentId = 'gc';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tsegmentId = 'self';\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (segmentId === 'self' && node.callFrame.url) {\n\t\t\t\tlet extension = searchTree.findSubstr(node.callFrame.url);\n\t\t\t\tif (extension) {\n\t\t\t\t\tsegmentId = extension.identifier.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidsToSegmentId.set(node.id, segmentId);\n\n\t\t\tif (node.children) {\n\t\t\t\tfor (const child of node.children) {\n\t\t\t\t\tconst childNode = idsToNodes.get(child);\n\t\t\t\t\tif (childNode) {\n\t\t\t\t\t\tvisit(childNode, segmentId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvisit(nodes[0], null);\n\n\t\tconst samples = profile.samples || [];\n\t\tlet timeDeltas = profile.timeDeltas || [];\n\t\tlet distilledDeltas: number[] = [];\n\t\tlet distilledIds: ProfileSegmentId[] = [];\n\n\t\tlet currSegmentTime = 0;\n\t\tlet currSegmentId: string | undefined;\n\t\tfor (let i = 0; i < samples.length; i++) {\n\t\t\tlet id = samples[i];\n\t\t\tlet segmentId = idsToSegmentId.get(id);\n\t\t\tif (segmentId !== currSegmentId) {\n\t\t\t\tif (currSegmentId) {\n\t\t\t\t\tdistilledIds.push(currSegmentId);\n\t\t\t\t\tdistilledDeltas.push(currSegmentTime);\n\t\t\t\t}\n\t\t\t\tcurrSegmentId = withNullAsUndefined(segmentId);\n\t\t\t\tcurrSegmentTime = 0;\n\t\t\t}\n\t\t\tcurrSegmentTime += timeDeltas[i];\n\t\t}\n\t\tif (currSegmentId) {\n\t\t\tdistilledIds.push(currSegmentId);\n\t\t\tdistilledDeltas.push(currSegmentTime);\n\t\t}\n\n\t\treturn {\n\t\t\tstartTime: profile.startTime,\n\t\t\tendTime: profile.endTime,\n\t\t\tdeltas: distilledDeltas,\n\t\t\tids: distilledIds,\n\t\t\tdata: profile,\n\t\t\tgetAggregatedTimes: () => {\n\t\t\t\tlet segmentsToTime = new Map<ProfileSegmentId, number>();\n\t\t\t\tfor (let i = 0; i < distilledIds.length; i++) {\n\t\t\t\t\tlet id = distilledIds[i];\n\t\t\t\t\tsegmentsToTime.set(id, (segmentsToTime.get(id) || 0) + distilledDeltas[i]);\n\t\t\t\t}\n\t\t\t\treturn segmentsToTime;\n\t\t\t}\n\t\t};\n\t}\n}\n"]}]}