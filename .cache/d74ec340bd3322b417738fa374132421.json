{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/packages/ide/src/client.ts","dependencies":[{"path":"/home/coding/workspace/packages/ide/src/client.ts","mtime":1555841535682},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"@coder/logger\", \"./retry\", \"./upload\", \"./fill/client\", \"./fill/clipboard\", \"./fill/os\"], function (require, exports, logger_1, retry_1, upload_1, client_1, clipboard_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * A general abstraction of an IDE client.\n     *\n     * Everything the client provides is asynchronous so you can wait on what\n     * you need from it without blocking anything else.\n     *\n     * It also provides task management to help asynchronously load and time code.\n     */\n    class IdeClient {\n        constructor() {\n            this.retry = retry_1.retry;\n            this.clipboard = clipboard_1.clipboard;\n            this.upload = upload_1.upload;\n            this.tasks = [];\n            this.finishedTaskCount = 0;\n            this.initData = client_1.client.initData;\n            this.onSharedProcessActive = client_1.client.onSharedProcessActive;\n            logger_1.logger.info(\"Loading IDE\");\n            this.loadTime = logger_1.time(2500);\n            let appWindow;\n            window.addEventListener(\"beforeunload\", (e) => {\n                e.preventDefault(); // FireFox\n                e.returnValue = \"\"; // Chrome\n            });\n            window.addEventListener(\"message\", (event) => {\n                if (event.data === \"app\") {\n                    appWindow = event.source;\n                }\n            });\n            this.sharedProcessData = new Promise((resolve) => {\n                let d = client_1.client.onSharedProcessActive((data) => {\n                    d.dispose();\n                    d = client_1.client.onSharedProcessActive(() => {\n                        d.dispose();\n                        this.retry.notificationService.error(new Error(\"Disconnected from shared process. Searching, installing, enabling, and disabling extensions will not work until the page is refreshed.\"));\n                    });\n                    resolve(data);\n                });\n            });\n            window.addEventListener(\"contextmenu\", (event) => {\n                event.preventDefault();\n            });\n            // Prevent Firefox from trying to reconnect when the page unloads.\n            window.addEventListener(\"unload\", () => {\n                this.retry.block();\n                logger_1.logger.info(\"Unloaded\");\n            });\n            this.initialize().then(() => {\n                logger_1.logger.info(\"Load completed\", logger_1.field(\"duration\", this.loadTime));\n                if (appWindow) {\n                    appWindow.postMessage(\"loaded\", \"*\");\n                }\n            }).catch((error) => {\n                logger_1.logger.error(error.message);\n                logger_1.logger.warn(\"Load completed with errors\", logger_1.field(\"duration\", this.loadTime));\n            });\n        }\n        /**\n         * Wrap a task in some logging, timing, and progress updates. Can optionally\n         * wait on other tasks which won't count towards this task's time.\n         */\n        task(description, duration = 100, task, ...after // tslint:disable-line no-any\n        ) {\n            return __awaiter(this, void 0, void 0, function* () {\n                this.tasks.push(description);\n                if (!this.start) {\n                    this.start = logger_1.time(1000);\n                }\n                let start;\n                try {\n                    const waitFor = yield (after && after.length > 0 ? Promise.all(after) : Promise.resolve([]));\n                    start = logger_1.time(duration);\n                    logger_1.logger.info(description);\n                    const value = yield task(...waitFor);\n                    logger_1.logger.info(`Finished \"${description}\"`, logger_1.field(\"duration\", start));\n                    const index = this.tasks.indexOf(description);\n                    if (index !== -1) {\n                        this.tasks.splice(index, 1);\n                    }\n                    ++this.finishedTaskCount;\n                    if (this.tasks.length === 0) {\n                        logger_1.logger.info(\"Finished all queued tasks\", logger_1.field(\"duration\", this.start), logger_1.field(\"count\", this.finishedTaskCount));\n                        this.start = undefined;\n                    }\n                    return value;\n                }\n                catch (error) {\n                    logger_1.logger.error(`Failed \"${description}\"`, logger_1.field(\"duration\", typeof start !== \"undefined\" ? start : \"not started\"), logger_1.field(\"error\", error));\n                    throw error;\n                }\n            });\n        }\n        set notificationService(service) {\n            this.retry.notificationService = service;\n            this.upload.notificationService = service;\n        }\n        set progressService(service) {\n            this.upload.progressService = service;\n        }\n    }\n    exports.IdeClient = IdeClient;\n});\n",null]}