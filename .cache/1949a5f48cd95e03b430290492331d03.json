{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/wordHighlighter/wordHighlighter.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/wordHighlighter/wordHighlighter.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/arrays\", \"vs/base/common/async\", \"vs/base/common/cancellation\", \"vs/base/common/errors\", \"vs/base/common/keyCodes\", \"vs/base/common/lifecycle\", \"vs/editor/browser/editorExtensions\", \"vs/editor/common/controller/cursorEvents\", \"vs/editor/common/core/range\", \"vs/editor/common/editorContextKeys\", \"vs/editor/common/model\", \"vs/editor/common/model/textModel\", \"vs/editor/common/modes\", \"vs/platform/contextkey/common/contextkey\", \"vs/platform/keybinding/common/keybindingsRegistry\", \"vs/platform/theme/common/colorRegistry\", \"vs/platform/theme/common/themeService\"], function (require, exports, nls, arrays, async_1, cancellation_1, errors_1, keyCodes_1, lifecycle_1, editorExtensions_1, cursorEvents_1, range_1, editorContextKeys_1, model_1, textModel_1, modes_1, contextkey_1, keybindingsRegistry_1, colorRegistry_1, themeService_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.editorWordHighlight = colorRegistry_1.registerColor('editor.wordHighlightBackground', { dark: '#575757B8', light: '#57575740', hc: null }, nls.localize('wordHighlight', 'Background color of a symbol during read-access, like reading a variable. The color must not be opaque so as not to hide underlying decorations.'), true);\n    exports.editorWordHighlightStrong = colorRegistry_1.registerColor('editor.wordHighlightStrongBackground', { dark: '#004972B8', light: '#0e639c40', hc: null }, nls.localize('wordHighlightStrong', 'Background color of a symbol during write-access, like writing to a variable. The color must not be opaque so as not to hide underlying decorations.'), true);\n    exports.editorWordHighlightBorder = colorRegistry_1.registerColor('editor.wordHighlightBorder', { light: null, dark: null, hc: colorRegistry_1.activeContrastBorder }, nls.localize('wordHighlightBorder', 'Border color of a symbol during read-access, like reading a variable.'));\n    exports.editorWordHighlightStrongBorder = colorRegistry_1.registerColor('editor.wordHighlightStrongBorder', { light: null, dark: null, hc: colorRegistry_1.activeContrastBorder }, nls.localize('wordHighlightStrongBorder', 'Border color of a symbol during write-access, like writing to a variable.'));\n    exports.overviewRulerWordHighlightForeground = colorRegistry_1.registerColor('editorOverviewRuler.wordHighlightForeground', { dark: '#A0A0A0CC', light: '#A0A0A0CC', hc: '#A0A0A0CC' }, nls.localize('overviewRulerWordHighlightForeground', 'Overview ruler marker color for symbol highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\n    exports.overviewRulerWordHighlightStrongForeground = colorRegistry_1.registerColor('editorOverviewRuler.wordHighlightStrongForeground', { dark: '#C0A0C0CC', light: '#C0A0C0CC', hc: '#C0A0C0CC' }, nls.localize('overviewRulerWordHighlightStrongForeground', 'Overview ruler marker color for write-access symbol highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\n    exports.ctxHasWordHighlights = new contextkey_1.RawContextKey('hasWordHighlights', false);\n    function getOccurrencesAtPosition(model, position, token) {\n        const orderedByScore = modes_1.DocumentHighlightProviderRegistry.ordered(model);\n        // in order of score ask the occurrences provider\n        // until someone response with a good result\n        // (good = none empty array)\n        return async_1.first(orderedByScore.map(provider => () => {\n            return Promise.resolve(provider.provideDocumentHighlights(model, position, token))\n                .then(undefined, errors_1.onUnexpectedExternalError);\n        }), arrays.isNonEmptyArray);\n    }\n    exports.getOccurrencesAtPosition = getOccurrencesAtPosition;\n    class OccurenceAtPositionRequest {\n        constructor(model, selection, wordSeparators) {\n            this._wordRange = this._getCurrentWordRange(model, selection);\n            this.result = async_1.createCancelablePromise(token => this._compute(model, selection, wordSeparators, token));\n        }\n        _getCurrentWordRange(model, selection) {\n            const word = model.getWordAtPosition(selection.getPosition());\n            if (word) {\n                return new range_1.Range(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);\n            }\n            return null;\n        }\n        isValid(model, selection, decorationIds) {\n            const lineNumber = selection.startLineNumber;\n            const startColumn = selection.startColumn;\n            const endColumn = selection.endColumn;\n            const currentWordRange = this._getCurrentWordRange(model, selection);\n            let requestIsValid = Boolean(this._wordRange && this._wordRange.equalsRange(currentWordRange));\n            // Even if we are on a different word, if that word is in the decorations ranges, the request is still valid\n            // (Same symbol)\n            for (let i = 0, len = decorationIds.length; !requestIsValid && i < len; i++) {\n                let range = model.getDecorationRange(decorationIds[i]);\n                if (range && range.startLineNumber === lineNumber) {\n                    if (range.startColumn <= startColumn && range.endColumn >= endColumn) {\n                        requestIsValid = true;\n                    }\n                }\n            }\n            return requestIsValid;\n        }\n        cancel() {\n            this.result.cancel();\n        }\n    }\n    class SemanticOccurenceAtPositionRequest extends OccurenceAtPositionRequest {\n        _compute(model, selection, wordSeparators, token) {\n            return getOccurrencesAtPosition(model, selection.getPosition(), token).then(value => value || []);\n        }\n    }\n    class TextualOccurenceAtPositionRequest extends OccurenceAtPositionRequest {\n        constructor(model, selection, wordSeparators) {\n            super(model, selection, wordSeparators);\n            this._selectionIsEmpty = selection.isEmpty();\n        }\n        _compute(model, selection, wordSeparators, token) {\n            return async_1.timeout(250, token).then(() => {\n                if (!selection.isEmpty()) {\n                    return [];\n                }\n                const word = model.getWordAtPosition(selection.getPosition());\n                if (!word) {\n                    return [];\n                }\n                const matches = model.findMatches(word.word, true, false, true, wordSeparators, false);\n                return matches.map(m => {\n                    return {\n                        range: m.range,\n                        kind: modes_1.DocumentHighlightKind.Text\n                    };\n                });\n            });\n        }\n        isValid(model, selection, decorationIds) {\n            const currentSelectionIsEmpty = selection.isEmpty();\n            if (this._selectionIsEmpty !== currentSelectionIsEmpty) {\n                return false;\n            }\n            return super.isValid(model, selection, decorationIds);\n        }\n    }\n    function computeOccurencesAtPosition(model, selection, wordSeparators) {\n        if (modes_1.DocumentHighlightProviderRegistry.has(model)) {\n            return new SemanticOccurenceAtPositionRequest(model, selection, wordSeparators);\n        }\n        return new TextualOccurenceAtPositionRequest(model, selection, wordSeparators);\n    }\n    editorExtensions_1.registerDefaultLanguageCommand('_executeDocumentHighlights', (model, position) => getOccurrencesAtPosition(model, position, cancellation_1.CancellationToken.None));\n    class WordHighlighter {\n        constructor(editor, contextKeyService) {\n            this.workerRequestTokenId = 0;\n            this.workerRequestCompleted = false;\n            this.workerRequestValue = [];\n            this.lastCursorPositionChangeTime = 0;\n            this.renderDecorationsTimer = -1;\n            this.editor = editor;\n            this._hasWordHighlights = exports.ctxHasWordHighlights.bindTo(contextKeyService);\n            this._ignorePositionChangeEvent = false;\n            this.occurrencesHighlight = this.editor.getConfiguration().contribInfo.occurrencesHighlight;\n            this.model = this.editor.getModel();\n            this.toUnhook = [];\n            this.toUnhook.push(editor.onDidChangeCursorPosition((e) => {\n                if (this._ignorePositionChangeEvent) {\n                    // We are changing the position => ignore this event\n                    return;\n                }\n                if (!this.occurrencesHighlight) {\n                    // Early exit if nothing needs to be done!\n                    // Leave some form of early exit check here if you wish to continue being a cursor position change listener ;)\n                    return;\n                }\n                this._onPositionChanged(e);\n            }));\n            this.toUnhook.push(editor.onDidChangeModelContent((e) => {\n                this._stopAll();\n            }));\n            this.toUnhook.push(editor.onDidChangeConfiguration((e) => {\n                let newValue = this.editor.getConfiguration().contribInfo.occurrencesHighlight;\n                if (this.occurrencesHighlight !== newValue) {\n                    this.occurrencesHighlight = newValue;\n                    this._stopAll();\n                }\n            }));\n            this._decorationIds = [];\n            this.workerRequestTokenId = 0;\n            this.workerRequest = null;\n            this.workerRequestCompleted = false;\n            this.lastCursorPositionChangeTime = 0;\n            this.renderDecorationsTimer = -1;\n        }\n        hasDecorations() {\n            return (this._decorationIds.length > 0);\n        }\n        restore() {\n            if (!this.occurrencesHighlight) {\n                return;\n            }\n            this._run();\n        }\n        _getSortedHighlights() {\n            return arrays.coalesce(this._decorationIds\n                .map((id) => this.model.getDecorationRange(id))\n                .sort(range_1.Range.compareRangesUsingStarts));\n        }\n        moveNext() {\n            let highlights = this._getSortedHighlights();\n            let index = arrays.firstIndex(highlights, (range) => range.containsPosition(this.editor.getPosition()));\n            let newIndex = ((index + 1) % highlights.length);\n            let dest = highlights[newIndex];\n            try {\n                this._ignorePositionChangeEvent = true;\n                this.editor.setPosition(dest.getStartPosition());\n                this.editor.revealRangeInCenterIfOutsideViewport(dest);\n            }\n            finally {\n                this._ignorePositionChangeEvent = false;\n            }\n        }\n        moveBack() {\n            let highlights = this._getSortedHighlights();\n            let index = arrays.firstIndex(highlights, (range) => range.containsPosition(this.editor.getPosition()));\n            let newIndex = ((index - 1 + highlights.length) % highlights.length);\n            let dest = highlights[newIndex];\n            try {\n                this._ignorePositionChangeEvent = true;\n                this.editor.setPosition(dest.getStartPosition());\n                this.editor.revealRangeInCenterIfOutsideViewport(dest);\n            }\n            finally {\n                this._ignorePositionChangeEvent = false;\n            }\n        }\n        _removeDecorations() {\n            if (this._decorationIds.length > 0) {\n                // remove decorations\n                this._decorationIds = this.editor.deltaDecorations(this._decorationIds, []);\n                this._hasWordHighlights.set(false);\n            }\n        }\n        _stopAll() {\n            // Remove any existing decorations\n            this._removeDecorations();\n            // Cancel any renderDecorationsTimer\n            if (this.renderDecorationsTimer !== -1) {\n                clearTimeout(this.renderDecorationsTimer);\n                this.renderDecorationsTimer = -1;\n            }\n            // Cancel any worker request\n            if (this.workerRequest !== null) {\n                this.workerRequest.cancel();\n                this.workerRequest = null;\n            }\n            // Invalidate any worker request callback\n            if (!this.workerRequestCompleted) {\n                this.workerRequestTokenId++;\n                this.workerRequestCompleted = true;\n            }\n        }\n        _onPositionChanged(e) {\n            // disabled\n            if (!this.occurrencesHighlight) {\n                this._stopAll();\n                return;\n            }\n            // ignore typing & other\n            if (e.reason !== cursorEvents_1.CursorChangeReason.Explicit) {\n                this._stopAll();\n                return;\n            }\n            this._run();\n        }\n        _run() {\n            let editorSelection = this.editor.getSelection();\n            // ignore multiline selection\n            if (editorSelection.startLineNumber !== editorSelection.endLineNumber) {\n                this._stopAll();\n                return;\n            }\n            let lineNumber = editorSelection.startLineNumber;\n            let startColumn = editorSelection.startColumn;\n            let endColumn = editorSelection.endColumn;\n            let word = this.model.getWordAtPosition({\n                lineNumber: lineNumber,\n                column: startColumn\n            });\n            // The selection must be inside a word or surround one word at most\n            if (!word || word.startColumn > startColumn || word.endColumn < endColumn) {\n                this._stopAll();\n                return;\n            }\n            // All the effort below is trying to achieve this:\n            // - when cursor is moved to a word, trigger immediately a findOccurrences request\n            // - 250ms later after the last cursor move event, render the occurrences\n            // - no flickering!\n            const workerRequestIsValid = (this.workerRequest && this.workerRequest.isValid(this.model, editorSelection, this._decorationIds));\n            // There are 4 cases:\n            // a) old workerRequest is valid & completed, renderDecorationsTimer fired\n            // b) old workerRequest is valid & completed, renderDecorationsTimer not fired\n            // c) old workerRequest is valid, but not completed\n            // d) old workerRequest is not valid\n            // For a) no action is needed\n            // For c), member 'lastCursorPositionChangeTime' will be used when installing the timer so no action is needed\n            this.lastCursorPositionChangeTime = (new Date()).getTime();\n            if (workerRequestIsValid) {\n                if (this.workerRequestCompleted && this.renderDecorationsTimer !== -1) {\n                    // case b)\n                    // Delay the firing of renderDecorationsTimer by an extra 250 ms\n                    clearTimeout(this.renderDecorationsTimer);\n                    this.renderDecorationsTimer = -1;\n                    this._beginRenderDecorations();\n                }\n            }\n            else {\n                // case d)\n                // Stop all previous actions and start fresh\n                this._stopAll();\n                let myRequestId = ++this.workerRequestTokenId;\n                this.workerRequestCompleted = false;\n                this.workerRequest = computeOccurencesAtPosition(this.model, this.editor.getSelection(), this.editor.getConfiguration().wordSeparators);\n                this.workerRequest.result.then(data => {\n                    if (myRequestId === this.workerRequestTokenId) {\n                        this.workerRequestCompleted = true;\n                        this.workerRequestValue = data || [];\n                        this._beginRenderDecorations();\n                    }\n                }, errors_1.onUnexpectedError);\n            }\n        }\n        _beginRenderDecorations() {\n            let currentTime = (new Date()).getTime();\n            let minimumRenderTime = this.lastCursorPositionChangeTime + 250;\n            if (currentTime >= minimumRenderTime) {\n                // Synchronous\n                this.renderDecorationsTimer = -1;\n                this.renderDecorations();\n            }\n            else {\n                // Asynchronous\n                this.renderDecorationsTimer = setTimeout(() => {\n                    this.renderDecorations();\n                }, (minimumRenderTime - currentTime));\n            }\n        }\n        renderDecorations() {\n            this.renderDecorationsTimer = -1;\n            let decorations = [];\n            for (let i = 0, len = this.workerRequestValue.length; i < len; i++) {\n                let info = this.workerRequestValue[i];\n                decorations.push({\n                    range: info.range,\n                    options: WordHighlighter._getDecorationOptions(info.kind)\n                });\n            }\n            this._decorationIds = this.editor.deltaDecorations(this._decorationIds, decorations);\n            this._hasWordHighlights.set(this.hasDecorations());\n        }\n        static _getDecorationOptions(kind) {\n            if (kind === modes_1.DocumentHighlightKind.Write) {\n                return this._WRITE_OPTIONS;\n            }\n            else if (kind === modes_1.DocumentHighlightKind.Text) {\n                return this._TEXT_OPTIONS;\n            }\n            else {\n                return this._REGULAR_OPTIONS;\n            }\n        }\n        dispose() {\n            this._stopAll();\n            this.toUnhook = lifecycle_1.dispose(this.toUnhook);\n        }\n    }\n    WordHighlighter._WRITE_OPTIONS = textModel_1.ModelDecorationOptions.register({\n        stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n        className: 'wordHighlightStrong',\n        overviewRuler: {\n            color: themeService_1.themeColorFromId(exports.overviewRulerWordHighlightStrongForeground),\n            position: model_1.OverviewRulerLane.Center\n        }\n    });\n    WordHighlighter._TEXT_OPTIONS = textModel_1.ModelDecorationOptions.register({\n        stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n        className: 'selectionHighlight',\n        overviewRuler: {\n            color: themeService_1.themeColorFromId(colorRegistry_1.overviewRulerSelectionHighlightForeground),\n            position: model_1.OverviewRulerLane.Center\n        }\n    });\n    WordHighlighter._REGULAR_OPTIONS = textModel_1.ModelDecorationOptions.register({\n        stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n        className: 'wordHighlight',\n        overviewRuler: {\n            color: themeService_1.themeColorFromId(exports.overviewRulerWordHighlightForeground),\n            position: model_1.OverviewRulerLane.Center\n        }\n    });\n    let WordHighlighterContribution = class WordHighlighterContribution extends lifecycle_1.Disposable {\n        constructor(editor, contextKeyService) {\n            super();\n            const createWordHighlighterIfPossible = () => {\n                if (editor.hasModel()) {\n                    this.wordHighligher = new WordHighlighter(editor, contextKeyService);\n                }\n            };\n            this._register(editor.onDidChangeModel((e) => {\n                if (this.wordHighligher) {\n                    this.wordHighligher.dispose();\n                    this.wordHighligher = null;\n                }\n                createWordHighlighterIfPossible();\n            }));\n            createWordHighlighterIfPossible();\n        }\n        static get(editor) {\n            return editor.getContribution(WordHighlighterContribution.ID);\n        }\n        getId() {\n            return WordHighlighterContribution.ID;\n        }\n        saveViewState() {\n            if (this.wordHighligher && this.wordHighligher.hasDecorations()) {\n                return true;\n            }\n            return false;\n        }\n        moveNext() {\n            if (this.wordHighligher) {\n                this.wordHighligher.moveNext();\n            }\n        }\n        moveBack() {\n            if (this.wordHighligher) {\n                this.wordHighligher.moveBack();\n            }\n        }\n        restoreViewState(state) {\n            if (this.wordHighligher && state) {\n                this.wordHighligher.restore();\n            }\n        }\n        dispose() {\n            if (this.wordHighligher) {\n                this.wordHighligher.dispose();\n                this.wordHighligher = null;\n            }\n            super.dispose();\n        }\n    };\n    WordHighlighterContribution.ID = 'editor.contrib.wordHighlighter';\n    WordHighlighterContribution = __decorate([\n        __param(1, contextkey_1.IContextKeyService)\n    ], WordHighlighterContribution);\n    class WordHighlightNavigationAction extends editorExtensions_1.EditorAction {\n        constructor(next, opts) {\n            super(opts);\n            this._isNext = next;\n        }\n        run(accessor, editor) {\n            const controller = WordHighlighterContribution.get(editor);\n            if (!controller) {\n                return;\n            }\n            if (this._isNext) {\n                controller.moveNext();\n            }\n            else {\n                controller.moveBack();\n            }\n        }\n    }\n    class NextWordHighlightAction extends WordHighlightNavigationAction {\n        constructor() {\n            super(true, {\n                id: 'editor.action.wordHighlight.next',\n                label: nls.localize('wordHighlight.next.label', \"Go to Next Symbol Highlight\"),\n                alias: 'Go to Next Symbol Highlight',\n                precondition: exports.ctxHasWordHighlights,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyCode.F7,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n    }\n    class PrevWordHighlightAction extends WordHighlightNavigationAction {\n        constructor() {\n            super(false, {\n                id: 'editor.action.wordHighlight.prev',\n                label: nls.localize('wordHighlight.previous.label', \"Go to Previous Symbol Highlight\"),\n                alias: 'Go to Previous Symbol Highlight',\n                precondition: exports.ctxHasWordHighlights,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.F7,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n    }\n    class TriggerWordHighlightAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.wordHighlight.trigger',\n                label: nls.localize('wordHighlight.trigger.label', \"Trigger Symbol Highlight\"),\n                alias: 'Trigger Symbol Highlight',\n                precondition: exports.ctxHasWordHighlights.toNegated(),\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: 0,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        run(accessor, editor, args) {\n            const controller = WordHighlighterContribution.get(editor);\n            if (!controller) {\n                return;\n            }\n            controller.restoreViewState(true);\n        }\n    }\n    editorExtensions_1.registerEditorContribution(WordHighlighterContribution);\n    editorExtensions_1.registerEditorAction(NextWordHighlightAction);\n    editorExtensions_1.registerEditorAction(PrevWordHighlightAction);\n    editorExtensions_1.registerEditorAction(TriggerWordHighlightAction);\n    themeService_1.registerThemingParticipant((theme, collector) => {\n        const selectionHighlight = theme.getColor(colorRegistry_1.editorSelectionHighlight);\n        if (selectionHighlight) {\n            collector.addRule(`.monaco-editor .focused .selectionHighlight { background-color: ${selectionHighlight}; }`);\n            collector.addRule(`.monaco-editor .selectionHighlight { background-color: ${selectionHighlight.transparent(0.5)}; }`);\n        }\n        const wordHighlight = theme.getColor(exports.editorWordHighlight);\n        if (wordHighlight) {\n            collector.addRule(`.monaco-editor .wordHighlight { background-color: ${wordHighlight}; }`);\n        }\n        const wordHighlightStrong = theme.getColor(exports.editorWordHighlightStrong);\n        if (wordHighlightStrong) {\n            collector.addRule(`.monaco-editor .wordHighlightStrong { background-color: ${wordHighlightStrong}; }`);\n        }\n        const selectionHighlightBorder = theme.getColor(colorRegistry_1.editorSelectionHighlightBorder);\n        if (selectionHighlightBorder) {\n            collector.addRule(`.monaco-editor .selectionHighlight { border: 1px ${theme.type === 'hc' ? 'dotted' : 'solid'} ${selectionHighlightBorder}; box-sizing: border-box; }`);\n        }\n        const wordHighlightBorder = theme.getColor(exports.editorWordHighlightBorder);\n        if (wordHighlightBorder) {\n            collector.addRule(`.monaco-editor .wordHighlight { border: 1px ${theme.type === 'hc' ? 'dashed' : 'solid'} ${wordHighlightBorder}; box-sizing: border-box; }`);\n        }\n        const wordHighlightStrongBorder = theme.getColor(exports.editorWordHighlightStrongBorder);\n        if (wordHighlightStrongBorder) {\n            collector.addRule(`.monaco-editor .wordHighlightStrong { border: 1px ${theme.type === 'hc' ? 'dashed' : 'solid'} ${wordHighlightStrongBorder}; box-sizing: border-box; }`);\n        }\n    });\n});\n",null]}