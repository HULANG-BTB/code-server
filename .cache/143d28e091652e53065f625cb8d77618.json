{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/electron-browser/debugConfigurationManager.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/electron-browser/debugConfigurationManager.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/lifecycle\", \"vs/base/common/event\", \"vs/base/common/strings\", \"vs/base/common/objects\", \"vs/base/common/uri\", \"vs/base/common/resources\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/platform/storage/common/storage\", \"vs/workbench/services/extensions/common/extensions\", \"vs/platform/configuration/common/configuration\", \"vs/platform/files/common/files\", \"vs/platform/workspace/common/workspace\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/commands/common/commands\", \"vs/workbench/contrib/debug/common/debug\", \"vs/workbench/contrib/debug/node/debugger\", \"vs/workbench/services/editor/common/editorService\", \"vs/editor/browser/editorBrowser\", \"vs/workbench/services/configuration/common/configuration\", \"vs/workbench/services/preferences/common/preferences\", \"vs/workbench/contrib/debug/electron-browser/terminalSupport\", \"vs/platform/registry/common/platform\", \"vs/platform/jsonschemas/common/jsonContributionRegistry\", \"vs/workbench/contrib/debug/common/debugSchemas\", \"vs/platform/quickinput/common/quickInput\", \"vs/platform/contextkey/common/contextkey\", \"vs/base/common/errors\"], function (require, exports, nls, lifecycle_1, event_1, strings, objects, uri_1, resources, lifecycle_2, storage_1, extensions_1, configuration_1, files_1, workspace_1, instantiation_1, commands_1, debug_1, debugger_1, editorService_1, editorBrowser_1, configuration_2, preferences_1, terminalSupport_1, platform_1, jsonContributionRegistry_1, debugSchemas_1, quickInput_1, contextkey_1, errors_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const jsonRegistry = platform_1.Registry.as(jsonContributionRegistry_1.Extensions.JSONContribution);\n    jsonRegistry.registerSchema(configuration_2.launchSchemaId, debugSchemas_1.launchSchema);\n    const DEBUG_SELECTED_CONFIG_NAME_KEY = 'debug.selectedconfigname';\n    const DEBUG_SELECTED_ROOT = 'debug.selectedroot';\n    let ConfigurationManager = class ConfigurationManager {\n        constructor(debugService, contextService, editorService, configurationService, quickInputService, instantiationService, commandService, storageService, lifecycleService, extensionService, contextKeyService) {\n            this.debugService = debugService;\n            this.contextService = contextService;\n            this.editorService = editorService;\n            this.configurationService = configurationService;\n            this.quickInputService = quickInputService;\n            this.instantiationService = instantiationService;\n            this.commandService = commandService;\n            this.storageService = storageService;\n            this.extensionService = extensionService;\n            this.breakpointModeIdsSet = new Set();\n            this._onDidSelectConfigurationName = new event_1.Emitter();\n            this.configProviders = [];\n            this.adapterDescriptorFactories = [];\n            this.adapterTrackerFactories = [];\n            this.debuggers = [];\n            this.toDispose = [];\n            this.registerListeners(lifecycleService);\n            this.initLaunches();\n            const previousSelectedRoot = this.storageService.get(DEBUG_SELECTED_ROOT, storage_1.StorageScope.WORKSPACE);\n            const previousSelectedLaunch = this.launches.filter(l => l.uri.toString() === previousSelectedRoot).pop();\n            this.debugConfigurationTypeContext = debug_1.CONTEXT_DEBUG_CONFIGURATION_TYPE.bindTo(contextKeyService);\n            this.debugAdapterFactories = new Map();\n            if (previousSelectedLaunch) {\n                this.selectConfiguration(previousSelectedLaunch, this.storageService.get(DEBUG_SELECTED_CONFIG_NAME_KEY, storage_1.StorageScope.WORKSPACE));\n            }\n        }\n        // debuggers\n        registerDebugAdapterFactory(debugTypes, debugAdapterLauncher) {\n            debugTypes.forEach(debugType => this.debugAdapterFactories.set(debugType, debugAdapterLauncher));\n            return {\n                dispose: () => {\n                    debugTypes.forEach(debugType => this.debugAdapterFactories.delete(debugType));\n                }\n            };\n        }\n        createDebugAdapter(session) {\n            let dap = this.debugAdapterFactories.get(session.configuration.type);\n            if (dap) {\n                return dap.createDebugAdapter(session);\n            }\n            return undefined;\n        }\n        substituteVariables(debugType, folder, config) {\n            let dap = this.debugAdapterFactories.get(debugType);\n            if (dap) {\n                return dap.substituteVariables(folder, config);\n            }\n            return Promise.resolve(config);\n        }\n        runInTerminal(debugType, args, config) {\n            let tl = this.debugAdapterFactories.get(debugType);\n            if (!tl) {\n                if (!this.terminalLauncher) {\n                    this.terminalLauncher = this.instantiationService.createInstance(terminalSupport_1.TerminalLauncher);\n                }\n                tl = this.terminalLauncher;\n            }\n            return tl.runInTerminal(args, config);\n        }\n        // debug adapter\n        registerDebugAdapterDescriptorFactory(debugAdapterProvider) {\n            this.adapterDescriptorFactories.push(debugAdapterProvider);\n            return {\n                dispose: () => {\n                    this.unregisterDebugAdapterDescriptorFactory(debugAdapterProvider);\n                }\n            };\n        }\n        unregisterDebugAdapterDescriptorFactory(debugAdapterProvider) {\n            const ix = this.adapterDescriptorFactories.indexOf(debugAdapterProvider);\n            if (ix >= 0) {\n                this.adapterDescriptorFactories.splice(ix, 1);\n            }\n        }\n        getDebugAdapterDescriptor(session) {\n            const config = session.configuration;\n            // first try legacy proposed API: DebugConfigurationProvider.debugAdapterExecutable\n            const providers0 = this.configProviders.filter(p => p.type === config.type && p.debugAdapterExecutable);\n            if (providers0.length === 1 && providers0[0].debugAdapterExecutable) {\n                return providers0[0].debugAdapterExecutable(session.root ? session.root.uri : undefined);\n            }\n            else {\n                // TODO@AW handle n > 1 case\n            }\n            // new API\n            const providers = this.adapterDescriptorFactories.filter(p => p.type === config.type && p.createDebugAdapterDescriptor);\n            if (providers.length === 1) {\n                return providers[0].createDebugAdapterDescriptor(session);\n            }\n            else {\n                // TODO@AW handle n > 1 case\n            }\n            return Promise.resolve(undefined);\n        }\n        // debug adapter trackers\n        registerDebugAdapterTrackerFactory(debugAdapterTrackerFactory) {\n            this.adapterTrackerFactories.push(debugAdapterTrackerFactory);\n            return {\n                dispose: () => {\n                    this.unregisterDebugAdapterTrackerFactory(debugAdapterTrackerFactory);\n                }\n            };\n        }\n        unregisterDebugAdapterTrackerFactory(debugAdapterTrackerFactory) {\n            const ix = this.adapterTrackerFactories.indexOf(debugAdapterTrackerFactory);\n            if (ix >= 0) {\n                this.adapterTrackerFactories.splice(ix, 1);\n            }\n        }\n        // debug configurations\n        registerDebugConfigurationProvider(debugConfigurationProvider) {\n            this.configProviders.push(debugConfigurationProvider);\n            return {\n                dispose: () => {\n                    this.unregisterDebugConfigurationProvider(debugConfigurationProvider);\n                }\n            };\n        }\n        unregisterDebugConfigurationProvider(debugConfigurationProvider) {\n            const ix = this.configProviders.indexOf(debugConfigurationProvider);\n            if (ix >= 0) {\n                this.configProviders.splice(ix, 1);\n            }\n        }\n        hasDebugConfigurationProvider(debugType) {\n            // check if there are providers for the given type that contribute a provideDebugConfigurations method\n            const providers = this.configProviders.filter(p => p.provideDebugConfigurations && (p.type === debugType));\n            return providers.length > 0;\n        }\n        needsToRunInExtHost(debugType) {\n            // if the given debugType matches any registered tracker factory we need to run the DA in the EH\n            const providers = this.adapterTrackerFactories.filter(p => p.type === debugType || p.type === '*');\n            return providers.length > 0;\n        }\n        resolveConfigurationByProviders(folderUri, type, debugConfiguration) {\n            return this.activateDebuggers('onDebugResolve', type).then(() => {\n                // pipe the config through the promises sequentially. Append at the end the '*' types\n                const providers = this.configProviders.filter(p => p.type === type && p.resolveDebugConfiguration)\n                    .concat(this.configProviders.filter(p => p.type === '*' && p.resolveDebugConfiguration));\n                return providers.reduce((promise, provider) => {\n                    return promise.then(config => {\n                        if (config) {\n                            return provider.resolveDebugConfiguration(folderUri, config);\n                        }\n                        else {\n                            return Promise.resolve(config);\n                        }\n                    });\n                }, Promise.resolve(debugConfiguration));\n            });\n        }\n        provideDebugConfigurations(folderUri, type) {\n            return this.activateDebuggers('onDebugInitialConfigurations')\n                .then(() => Promise.all(this.configProviders.filter(p => p.type === type && p.provideDebugConfigurations).map(p => p.provideDebugConfigurations(folderUri)))\n                .then(results => results.reduce((first, second) => first.concat(second), [])));\n        }\n        registerListeners(lifecycleService) {\n            debugSchemas_1.debuggersExtPoint.setHandler((extensions, delta) => {\n                delta.added.forEach(added => {\n                    added.value.forEach(rawAdapter => {\n                        if (!rawAdapter.type || (typeof rawAdapter.type !== 'string')) {\n                            added.collector.error(nls.localize('debugNoType', \"Debugger 'type' can not be omitted and must be of type 'string'.\"));\n                        }\n                        if (rawAdapter.enableBreakpointsFor) {\n                            rawAdapter.enableBreakpointsFor.languageIds.forEach(modeId => {\n                                this.breakpointModeIdsSet.add(modeId);\n                            });\n                        }\n                        if (rawAdapter.type !== '*') {\n                            const existing = this.getDebugger(rawAdapter.type);\n                            if (existing) {\n                                existing.merge(rawAdapter, added.description);\n                            }\n                            else {\n                                this.debuggers.push(this.instantiationService.createInstance(debugger_1.Debugger, this, rawAdapter, added.description));\n                            }\n                        }\n                    });\n                });\n                // take care of all wildcard contributions\n                extensions.forEach(extension => {\n                    extension.value.forEach(rawAdapter => {\n                        if (rawAdapter.type === '*') {\n                            this.debuggers.forEach(dbg => dbg.merge(rawAdapter, extension.description));\n                        }\n                    });\n                });\n                delta.removed.forEach(removed => {\n                    const removedTypes = removed.value.map(rawAdapter => rawAdapter.type);\n                    this.debuggers = this.debuggers.filter(d => removedTypes.indexOf(d.type) === -1);\n                    this.debugService.getModel().getSessions().forEach(s => {\n                        // Stop sessions if their debugger has been removed\n                        if (removedTypes.indexOf(s.configuration.type) >= 0) {\n                            this.debugService.stopSession(s).then(undefined, errors_1.onUnexpectedError);\n                        }\n                    });\n                });\n                // update the schema to include all attributes, snippets and types from extensions.\n                this.debuggers.forEach(adapter => {\n                    const items = debugSchemas_1.launchSchema.properties['configurations'].items;\n                    const schemaAttributes = adapter.getSchemaAttributes();\n                    if (schemaAttributes && items.oneOf) {\n                        items.oneOf.push(...schemaAttributes);\n                    }\n                    const configurationSnippets = adapter.configurationSnippets;\n                    if (configurationSnippets && items.defaultSnippets) {\n                        items.defaultSnippets.push(...configurationSnippets);\n                    }\n                });\n                this.setCompoundSchemaValues();\n            });\n            debugSchemas_1.breakpointsExtPoint.setHandler((extensions, delta) => {\n                delta.removed.forEach(removed => {\n                    removed.value.forEach(breakpoints => this.breakpointModeIdsSet.delete(breakpoints.language));\n                });\n                delta.added.forEach(added => {\n                    added.value.forEach(breakpoints => this.breakpointModeIdsSet.add(breakpoints.language));\n                });\n            });\n            this.toDispose.push(this.contextService.onDidChangeWorkspaceFolders(() => {\n                this.initLaunches();\n                this.selectConfiguration(this.selectedLaunch);\n                this.setCompoundSchemaValues();\n            }));\n            this.toDispose.push(this.configurationService.onDidChangeConfiguration(e => {\n                if (e.affectsConfiguration('launch')) {\n                    this.selectConfiguration(this.selectedLaunch);\n                    this.setCompoundSchemaValues();\n                }\n            }));\n            this.toDispose.push(this.storageService.onWillSaveState(this.saveState, this));\n        }\n        initLaunches() {\n            this.launches = this.contextService.getWorkspace().folders.map(folder => this.instantiationService.createInstance(Launch, this, folder));\n            if (this.contextService.getWorkbenchState() === workspace_1.WorkbenchState.WORKSPACE) {\n                this.launches.push(this.instantiationService.createInstance(WorkspaceLaunch));\n            }\n            this.launches.push(this.instantiationService.createInstance(UserLaunch));\n            if (this.selectedLaunch && this.launches.indexOf(this.selectedLaunch) === -1) {\n                this.selectedLaunch = undefined;\n            }\n        }\n        setCompoundSchemaValues() {\n            const compoundConfigurationsSchema = debugSchemas_1.launchSchema.properties['compounds'].items.properties['configurations'];\n            const launchNames = this.launches.map(l => l.getConfigurationNames(false)).reduce((first, second) => first.concat(second), []);\n            compoundConfigurationsSchema.items.oneOf[0].enum = launchNames;\n            compoundConfigurationsSchema.items.oneOf[1].properties.name.enum = launchNames;\n            const folderNames = this.contextService.getWorkspace().folders.map(f => f.name);\n            compoundConfigurationsSchema.items.oneOf[1].properties.folder.enum = folderNames;\n            jsonRegistry.registerSchema(configuration_2.launchSchemaId, debugSchemas_1.launchSchema);\n        }\n        getLaunches() {\n            return this.launches;\n        }\n        getLaunch(workspaceUri) {\n            if (!uri_1.URI.isUri(workspaceUri)) {\n                return undefined;\n            }\n            return this.launches.filter(l => l.workspace && l.workspace.uri.toString() === workspaceUri.toString()).pop();\n        }\n        get selectedConfiguration() {\n            return {\n                launch: this.selectedLaunch,\n                name: this.selectedName\n            };\n        }\n        get onDidSelectConfiguration() {\n            return this._onDidSelectConfigurationName.event;\n        }\n        getWorkspaceLaunch() {\n            if (this.contextService.getWorkbenchState() === workspace_1.WorkbenchState.WORKSPACE) {\n                return this.launches[this.launches.length - 1];\n            }\n            return undefined;\n        }\n        selectConfiguration(launch, name) {\n            const previousLaunch = this.selectedLaunch;\n            const previousName = this.selectedName;\n            this.selectedLaunch = launch;\n            const names = launch ? launch.getConfigurationNames() : [];\n            if (name && names.indexOf(name) >= 0) {\n                this.selectedName = name;\n            }\n            if (!this.selectedName || names.indexOf(this.selectedName) === -1) {\n                this.selectedName = names.length ? names[0] : undefined;\n            }\n            const configuration = this.selectedLaunch && this.selectedName ? this.selectedLaunch.getConfiguration(this.selectedName) : undefined;\n            if (configuration) {\n                this.debugConfigurationTypeContext.set(configuration.type);\n            }\n            else {\n                this.debugConfigurationTypeContext.reset();\n            }\n            if (this.selectedLaunch !== previousLaunch || this.selectedName !== previousName) {\n                this._onDidSelectConfigurationName.fire();\n            }\n        }\n        canSetBreakpointsIn(model) {\n            const modeId = model.getLanguageIdentifier().language;\n            if (!modeId || modeId === 'jsonc' || modeId === 'log') {\n                // do not allow breakpoints in our settings files and output\n                return false;\n            }\n            if (this.configurationService.getValue('debug').allowBreakpointsEverywhere) {\n                return true;\n            }\n            return this.breakpointModeIdsSet.has(modeId);\n        }\n        getDebugger(type) {\n            return this.debuggers.filter(dbg => strings.equalsIgnoreCase(dbg.type, type)).pop();\n        }\n        guessDebugger(type) {\n            if (type) {\n                const adapter = this.getDebugger(type);\n                return Promise.resolve(adapter);\n            }\n            const activeTextEditorWidget = this.editorService.activeTextEditorWidget;\n            let candidates;\n            if (editorBrowser_1.isCodeEditor(activeTextEditorWidget)) {\n                const model = activeTextEditorWidget.getModel();\n                const language = model ? model.getLanguageIdentifier().language : undefined;\n                const adapters = this.debuggers.filter(a => language && a.languages && a.languages.indexOf(language) >= 0);\n                if (adapters.length === 1) {\n                    return Promise.resolve(adapters[0]);\n                }\n                if (adapters.length > 1) {\n                    candidates = Promise.resolve(adapters);\n                }\n            }\n            if (!candidates) {\n                candidates = this.activateDebuggers('onDebugInitialConfigurations').then(() => this.debuggers.filter(dbg => dbg.hasInitialConfiguration() || dbg.hasConfigurationProvider()));\n            }\n            return candidates.then(debuggers => {\n                debuggers.sort((first, second) => first.label.localeCompare(second.label));\n                const picks = debuggers.map(c => ({ label: c.label, debugger: c }));\n                return this.quickInputService.pick([...picks, { type: 'separator' }, { label: 'More...', debugger: undefined }], { placeHolder: nls.localize('selectDebug', \"Select Environment\") })\n                    .then(picked => {\n                    if (picked && picked.debugger) {\n                        return picked.debugger;\n                    }\n                    if (picked) {\n                        this.commandService.executeCommand('debug.installAdditionalDebuggers');\n                    }\n                    return undefined;\n                });\n            });\n        }\n        activateDebuggers(activationEvent, debugType) {\n            const thenables = [\n                this.extensionService.activateByEvent(activationEvent),\n                this.extensionService.activateByEvent('onDebug')\n            ];\n            if (debugType) {\n                thenables.push(this.extensionService.activateByEvent(`${activationEvent}:${debugType}`));\n            }\n            return Promise.all(thenables).then(_ => {\n                return undefined;\n            });\n        }\n        saveState() {\n            if (this.selectedName) {\n                this.storageService.store(DEBUG_SELECTED_CONFIG_NAME_KEY, this.selectedName, storage_1.StorageScope.WORKSPACE);\n            }\n            if (this.selectedLaunch) {\n                this.storageService.store(DEBUG_SELECTED_ROOT, this.selectedLaunch.uri.toString(), storage_1.StorageScope.WORKSPACE);\n            }\n        }\n        dispose() {\n            this.toDispose = lifecycle_1.dispose(this.toDispose);\n        }\n    };\n    ConfigurationManager = __decorate([\n        __param(1, workspace_1.IWorkspaceContextService),\n        __param(2, editorService_1.IEditorService),\n        __param(3, configuration_1.IConfigurationService),\n        __param(4, quickInput_1.IQuickInputService),\n        __param(5, instantiation_1.IInstantiationService),\n        __param(6, commands_1.ICommandService),\n        __param(7, storage_1.IStorageService),\n        __param(8, lifecycle_2.ILifecycleService),\n        __param(9, extensions_1.IExtensionService),\n        __param(10, contextkey_1.IContextKeyService)\n    ], ConfigurationManager);\n    exports.ConfigurationManager = ConfigurationManager;\n    class AbstractLaunch {\n        getCompound(name) {\n            const config = this.getConfig();\n            if (!config || !config.compounds) {\n                return undefined;\n            }\n            return config.compounds.filter(compound => compound.name === name).pop();\n        }\n        getConfigurationNames(includeCompounds = true) {\n            const config = this.getConfig();\n            if (!config || !config.configurations || !Array.isArray(config.configurations)) {\n                return [];\n            }\n            else {\n                const names = config.configurations.filter(cfg => cfg && typeof cfg.name === 'string').map(cfg => cfg.name);\n                if (includeCompounds && config.compounds) {\n                    if (config.compounds) {\n                        names.push(...config.compounds.filter(compound => typeof compound.name === 'string' && compound.configurations && compound.configurations.length)\n                            .map(compound => compound.name));\n                    }\n                }\n                return names;\n            }\n        }\n        getConfiguration(name) {\n            // We need to clone the configuration in order to be able to make changes to it #42198\n            const config = objects.deepClone(this.getConfig());\n            if (!config || !config.configurations) {\n                return undefined;\n            }\n            return config.configurations.filter(config => config && config.name === name).shift();\n        }\n        get hidden() {\n            return false;\n        }\n    }\n    let Launch = class Launch extends AbstractLaunch {\n        constructor(configurationManager, workspace, fileService, editorService, configurationService) {\n            super();\n            this.configurationManager = configurationManager;\n            this.workspace = workspace;\n            this.fileService = fileService;\n            this.editorService = editorService;\n            this.configurationService = configurationService;\n        }\n        get uri() {\n            return resources.joinPath(this.workspace.uri, '/.vscode/launch.json');\n        }\n        get name() {\n            return this.workspace.name;\n        }\n        getConfig() {\n            return this.configurationService.inspect('launch', { resource: this.workspace.uri }).workspaceFolder;\n        }\n        openConfigFile(sideBySide, preserveFocus, type) {\n            const resource = this.uri;\n            let created = false;\n            return this.fileService.resolveContent(resource).then(content => content.value, err => {\n                // launch.json not found: create one by collecting launch configs from debugConfigProviders\n                return this.configurationManager.guessDebugger(type).then(adapter => {\n                    if (adapter) {\n                        return this.configurationManager.provideDebugConfigurations(this.workspace.uri, adapter.type).then(initialConfigs => {\n                            return adapter.getInitialConfigurationContent(initialConfigs);\n                        });\n                    }\n                    else {\n                        return '';\n                    }\n                }).then(content => {\n                    if (!content) {\n                        return '';\n                    }\n                    created = true; // pin only if config file is created #8727\n                    return this.fileService.updateContent(resource, content).then(() => {\n                        // convert string into IContent; see #32135\n                        return content;\n                    });\n                });\n            }).then(content => {\n                if (!content) {\n                    return { editor: null, created: false };\n                }\n                const index = content.indexOf(`\"${this.configurationManager.selectedConfiguration.name}\"`);\n                let startLineNumber = 1;\n                for (let i = 0; i < index; i++) {\n                    if (content.charAt(i) === '\\n') {\n                        startLineNumber++;\n                    }\n                }\n                const selection = startLineNumber > 1 ? { startLineNumber, startColumn: 4 } : undefined;\n                return Promise.resolve(this.editorService.openEditor({\n                    resource,\n                    options: {\n                        selection,\n                        preserveFocus,\n                        pinned: created,\n                        revealIfVisible: true\n                    },\n                }, sideBySide ? editorService_1.SIDE_GROUP : editorService_1.ACTIVE_GROUP).then(editor => ({ editor, created })));\n            }, (error) => {\n                throw new Error(nls.localize('DebugConfig.failed', \"Unable to create 'launch.json' file inside the '.vscode' folder ({0}).\", error.message));\n            });\n        }\n    };\n    Launch = __decorate([\n        __param(2, files_1.IFileService),\n        __param(3, editorService_1.IEditorService),\n        __param(4, configuration_1.IConfigurationService)\n    ], Launch);\n    let WorkspaceLaunch = class WorkspaceLaunch extends AbstractLaunch {\n        constructor(editorService, configurationService, contextService) {\n            super();\n            this.editorService = editorService;\n            this.configurationService = configurationService;\n            this.contextService = contextService;\n        }\n        get workspace() {\n            return undefined;\n        }\n        get uri() {\n            return this.contextService.getWorkspace().configuration;\n        }\n        get name() {\n            return nls.localize('workspace', \"workspace\");\n        }\n        getConfig() {\n            return this.configurationService.inspect('launch').workspace;\n        }\n        openConfigFile(sideBySide, preserveFocus, type) {\n            return this.editorService.openEditor({\n                resource: this.contextService.getWorkspace().configuration,\n                options: { preserveFocus }\n            }, sideBySide ? editorService_1.SIDE_GROUP : editorService_1.ACTIVE_GROUP).then(editor => ({ editor, created: false }));\n        }\n    };\n    WorkspaceLaunch = __decorate([\n        __param(0, editorService_1.IEditorService),\n        __param(1, configuration_1.IConfigurationService),\n        __param(2, workspace_1.IWorkspaceContextService)\n    ], WorkspaceLaunch);\n    let UserLaunch = class UserLaunch extends AbstractLaunch {\n        constructor(configurationService, preferencesService) {\n            super();\n            this.configurationService = configurationService;\n            this.preferencesService = preferencesService;\n        }\n        get workspace() {\n            return undefined;\n        }\n        get uri() {\n            return this.preferencesService.userSettingsResource;\n        }\n        get name() {\n            return nls.localize('user settings', \"user settings\");\n        }\n        get hidden() {\n            return true;\n        }\n        getConfig() {\n            return this.configurationService.inspect('launch').user;\n        }\n        openConfigFile(sideBySide, preserveFocus, type) {\n            return this.preferencesService.openGlobalSettings(false, { preserveFocus }).then(editor => ({ editor, created: false }));\n        }\n    };\n    UserLaunch = __decorate([\n        __param(0, configuration_1.IConfigurationService),\n        __param(1, preferences_1.IPreferencesService)\n    ], UserLaunch);\n});\n",null]}