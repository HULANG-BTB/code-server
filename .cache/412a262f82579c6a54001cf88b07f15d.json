{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/node/rpcProtocol.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/node/rpcProtocol.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/async\", \"vs/base/common/cancellation\", \"vs/base/common/charCode\", \"vs/base/common/errors\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/base/common/uriIpc\", \"vs/workbench/services/extensions/node/lazyPromise\", \"vs/workbench/services/extensions/common/proxyIdentifier\", \"vs/base/common/buffer\"], function (require, exports, async_1, cancellation_1, charCode_1, errors, event_1, lifecycle_1, uriIpc_1, lazyPromise_1, proxyIdentifier_1, buffer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function safeStringify(obj, replacer) {\n        try {\n            return JSON.stringify(obj, replacer);\n        }\n        catch (err) {\n            return 'null';\n        }\n    }\n    function createURIReplacer(transformer) {\n        if (!transformer) {\n            return null;\n        }\n        return (key, value) => {\n            if (value && value.$mid === 1) {\n                return transformer.transformOutgoing(value);\n            }\n            return value;\n        };\n    }\n    var RequestInitiator;\n    (function (RequestInitiator) {\n        RequestInitiator[RequestInitiator[\"LocalSide\"] = 0] = \"LocalSide\";\n        RequestInitiator[RequestInitiator[\"OtherSide\"] = 1] = \"OtherSide\";\n    })(RequestInitiator = exports.RequestInitiator || (exports.RequestInitiator = {}));\n    var ResponsiveState;\n    (function (ResponsiveState) {\n        ResponsiveState[ResponsiveState[\"Responsive\"] = 0] = \"Responsive\";\n        ResponsiveState[ResponsiveState[\"Unresponsive\"] = 1] = \"Unresponsive\";\n    })(ResponsiveState = exports.ResponsiveState || (exports.ResponsiveState = {}));\n    const noop = () => { };\n    class RPCProtocol extends lifecycle_1.Disposable {\n        constructor(protocol, logger = null, transformer = null) {\n            super();\n            this._onDidChangeResponsiveState = this._register(new event_1.Emitter());\n            this.onDidChangeResponsiveState = this._onDidChangeResponsiveState.event;\n            this._protocol = protocol;\n            this._logger = logger;\n            this._uriTransformer = transformer;\n            this._uriReplacer = createURIReplacer(this._uriTransformer);\n            this._isDisposed = false;\n            this._locals = [];\n            this._proxies = [];\n            for (let i = 0, len = proxyIdentifier_1.ProxyIdentifier.count; i < len; i++) {\n                this._locals[i] = null;\n                this._proxies[i] = null;\n            }\n            this._lastMessageId = 0;\n            this._cancelInvokedHandlers = Object.create(null);\n            this._pendingRPCReplies = {};\n            this._responsiveState = ResponsiveState.Responsive;\n            this._unacknowledgedCount = 0;\n            this._unresponsiveTime = 0;\n            this._asyncCheckUresponsive = this._register(new async_1.RunOnceScheduler(() => this._checkUnresponsive(), 1000));\n            this._protocol.onMessage((msg) => this._receiveOneMessage(msg));\n        }\n        dispose() {\n            this._isDisposed = true;\n            // Release all outstanding promises with a canceled error\n            Object.keys(this._pendingRPCReplies).forEach((msgId) => {\n                const pending = this._pendingRPCReplies[msgId];\n                pending.resolveErr(errors.canceled());\n            });\n        }\n        _onWillSendRequest(req) {\n            if (this._unacknowledgedCount === 0) {\n                // Since this is the first request we are sending in a while,\n                // mark this moment as the start for the countdown to unresponsive time\n                this._unresponsiveTime = Date.now() + RPCProtocol.UNRESPONSIVE_TIME;\n            }\n            this._unacknowledgedCount++;\n            if (!this._asyncCheckUresponsive.isScheduled()) {\n                this._asyncCheckUresponsive.schedule();\n            }\n        }\n        _onDidReceiveAcknowledge(req) {\n            // The next possible unresponsive time is now + delta.\n            this._unresponsiveTime = Date.now() + RPCProtocol.UNRESPONSIVE_TIME;\n            this._unacknowledgedCount--;\n            if (this._unacknowledgedCount === 0) {\n                // No more need to check for unresponsive\n                this._asyncCheckUresponsive.cancel();\n            }\n            // The ext host is responsive!\n            this._setResponsiveState(ResponsiveState.Responsive);\n        }\n        _checkUnresponsive() {\n            if (this._unacknowledgedCount === 0) {\n                // Not waiting for anything => cannot say if it is responsive or not\n                return;\n            }\n            if (Date.now() > this._unresponsiveTime) {\n                // Unresponsive!!\n                this._setResponsiveState(ResponsiveState.Unresponsive);\n            }\n            else {\n                // Not (yet) unresponsive, be sure to check again soon\n                this._asyncCheckUresponsive.schedule();\n            }\n        }\n        _setResponsiveState(newResponsiveState) {\n            if (this._responsiveState === newResponsiveState) {\n                // no change\n                return;\n            }\n            this._responsiveState = newResponsiveState;\n            this._onDidChangeResponsiveState.fire(this._responsiveState);\n        }\n        get responsiveState() {\n            return this._responsiveState;\n        }\n        transformIncomingURIs(obj) {\n            if (!this._uriTransformer) {\n                return obj;\n            }\n            return uriIpc_1.transformIncomingURIs(obj, this._uriTransformer);\n        }\n        getProxy(identifier) {\n            const rpcId = identifier.nid;\n            if (!this._proxies[rpcId]) {\n                this._proxies[rpcId] = this._createProxy(rpcId);\n            }\n            return this._proxies[rpcId];\n        }\n        _createProxy(rpcId) {\n            let handler = {\n                get: (target, name) => {\n                    if (!target[name] && name.charCodeAt(0) === charCode_1.CharCode.DollarSign) {\n                        target[name] = (...myArgs) => {\n                            return this._remoteCall(rpcId, name, myArgs);\n                        };\n                    }\n                    return target[name];\n                }\n            };\n            return new Proxy(Object.create(null), handler);\n        }\n        set(identifier, value) {\n            this._locals[identifier.nid] = value;\n            return value;\n        }\n        assertRegistered(identifiers) {\n            for (let i = 0, len = identifiers.length; i < len; i++) {\n                const identifier = identifiers[i];\n                if (!this._locals[identifier.nid]) {\n                    throw new Error(`Missing actor ${identifier.sid} (isMain: ${identifier.isMain})`);\n                }\n            }\n        }\n        _receiveOneMessage(rawmsg) {\n            if (this._isDisposed) {\n                return;\n            }\n            const msgLength = rawmsg.byteLength;\n            const buff = MessageBuffer.read(rawmsg, 0);\n            const messageType = buff.readUInt8();\n            const req = buff.readUInt32();\n            switch (messageType) {\n                case MessageType.RequestJSONArgs:\n                case MessageType.RequestJSONArgsWithCancellation: {\n                    let { rpcId, method, args } = MessageIO.deserializeRequestJSONArgs(buff);\n                    if (this._uriTransformer) {\n                        args = uriIpc_1.transformIncomingURIs(args, this._uriTransformer);\n                    }\n                    this._receiveRequest(msgLength, req, rpcId, method, args, (messageType === MessageType.RequestJSONArgsWithCancellation));\n                    break;\n                }\n                case MessageType.RequestMixedArgs:\n                case MessageType.RequestMixedArgsWithCancellation: {\n                    let { rpcId, method, args } = MessageIO.deserializeRequestMixedArgs(buff);\n                    if (this._uriTransformer) {\n                        args = uriIpc_1.transformIncomingURIs(args, this._uriTransformer);\n                    }\n                    this._receiveRequest(msgLength, req, rpcId, method, args, (messageType === MessageType.RequestMixedArgsWithCancellation));\n                    break;\n                }\n                case MessageType.Acknowledged: {\n                    if (this._logger) {\n                        this._logger.logIncoming(msgLength, req, RequestInitiator.LocalSide, `ack`);\n                    }\n                    this._onDidReceiveAcknowledge(req);\n                    break;\n                }\n                case MessageType.Cancel: {\n                    this._receiveCancel(msgLength, req);\n                    break;\n                }\n                case MessageType.ReplyOKEmpty: {\n                    this._receiveReply(msgLength, req, undefined);\n                    break;\n                }\n                case MessageType.ReplyOKJSON: {\n                    let value = MessageIO.deserializeReplyOKJSON(buff);\n                    if (this._uriTransformer) {\n                        value = uriIpc_1.transformIncomingURIs(value, this._uriTransformer);\n                    }\n                    this._receiveReply(msgLength, req, value);\n                    break;\n                }\n                case MessageType.ReplyOKBuffer: {\n                    let value = MessageIO.deserializeReplyOKBuffer(buff);\n                    this._receiveReply(msgLength, req, value);\n                    break;\n                }\n                case MessageType.ReplyOKVSBuffer: {\n                    let value = MessageIO.deserializeReplyOKVSBuffer(buff);\n                    this._receiveReply(msgLength, req, value);\n                    break;\n                }\n                case MessageType.ReplyErrError: {\n                    let err = MessageIO.deserializeReplyErrError(buff);\n                    if (this._uriTransformer) {\n                        err = uriIpc_1.transformIncomingURIs(err, this._uriTransformer);\n                    }\n                    this._receiveReplyErr(msgLength, req, err);\n                    break;\n                }\n                case MessageType.ReplyErrEmpty: {\n                    this._receiveReplyErr(msgLength, req, undefined);\n                    break;\n                }\n                default:\n                    console.error(`received unexpected message`);\n                    console.error(rawmsg);\n            }\n        }\n        _receiveRequest(msgLength, req, rpcId, method, args, usesCancellationToken) {\n            if (this._logger) {\n                this._logger.logIncoming(msgLength, req, RequestInitiator.OtherSide, `receiveRequest ${proxyIdentifier_1.getStringIdentifierForProxy(rpcId)}.${method}(`, args);\n            }\n            const callId = String(req);\n            let promise;\n            let cancel;\n            if (usesCancellationToken) {\n                const cancellationTokenSource = new cancellation_1.CancellationTokenSource();\n                args.push(cancellationTokenSource.token);\n                promise = this._invokeHandler(rpcId, method, args);\n                cancel = () => cancellationTokenSource.cancel();\n            }\n            else {\n                // cannot be cancelled\n                promise = this._invokeHandler(rpcId, method, args);\n                cancel = noop;\n            }\n            this._cancelInvokedHandlers[callId] = cancel;\n            // Acknowledge the request\n            const msg = MessageIO.serializeAcknowledged(req);\n            if (this._logger) {\n                this._logger.logOutgoing(msg.byteLength, req, RequestInitiator.OtherSide, `ack`);\n            }\n            this._protocol.send(msg);\n            promise.then((r) => {\n                delete this._cancelInvokedHandlers[callId];\n                const msg = MessageIO.serializeReplyOK(req, r, this._uriReplacer);\n                if (this._logger) {\n                    this._logger.logOutgoing(msg.byteLength, req, RequestInitiator.OtherSide, `reply:`, r);\n                }\n                this._protocol.send(msg);\n            }, (err) => {\n                delete this._cancelInvokedHandlers[callId];\n                const msg = MessageIO.serializeReplyErr(req, err);\n                if (this._logger) {\n                    this._logger.logOutgoing(msg.byteLength, req, RequestInitiator.OtherSide, `replyErr:`, err);\n                }\n                this._protocol.send(msg);\n            });\n        }\n        _receiveCancel(msgLength, req) {\n            if (this._logger) {\n                this._logger.logIncoming(msgLength, req, RequestInitiator.OtherSide, `receiveCancel`);\n            }\n            const callId = String(req);\n            if (this._cancelInvokedHandlers[callId]) {\n                this._cancelInvokedHandlers[callId]();\n            }\n        }\n        _receiveReply(msgLength, req, value) {\n            if (this._logger) {\n                this._logger.logIncoming(msgLength, req, RequestInitiator.LocalSide, `receiveReply:`, value);\n            }\n            const callId = String(req);\n            if (!this._pendingRPCReplies.hasOwnProperty(callId)) {\n                return;\n            }\n            const pendingReply = this._pendingRPCReplies[callId];\n            delete this._pendingRPCReplies[callId];\n            pendingReply.resolveOk(value);\n        }\n        _receiveReplyErr(msgLength, req, value) {\n            if (this._logger) {\n                this._logger.logIncoming(msgLength, req, RequestInitiator.LocalSide, `receiveReplyErr:`, value);\n            }\n            const callId = String(req);\n            if (!this._pendingRPCReplies.hasOwnProperty(callId)) {\n                return;\n            }\n            const pendingReply = this._pendingRPCReplies[callId];\n            delete this._pendingRPCReplies[callId];\n            let err = null;\n            if (value && value.$isError) {\n                err = new Error();\n                err.name = value.name;\n                err.message = value.message;\n                err.stack = value.stack;\n            }\n            pendingReply.resolveErr(err);\n        }\n        _invokeHandler(rpcId, methodName, args) {\n            try {\n                return Promise.resolve(this._doInvokeHandler(rpcId, methodName, args));\n            }\n            catch (err) {\n                return Promise.reject(err);\n            }\n        }\n        _doInvokeHandler(rpcId, methodName, args) {\n            const actor = this._locals[rpcId];\n            if (!actor) {\n                throw new Error('Unknown actor ' + proxyIdentifier_1.getStringIdentifierForProxy(rpcId));\n            }\n            let method = actor[methodName];\n            if (typeof method !== 'function') {\n                throw new Error('Unknown method ' + methodName + ' on actor ' + proxyIdentifier_1.getStringIdentifierForProxy(rpcId));\n            }\n            return method.apply(actor, args);\n        }\n        _remoteCall(rpcId, methodName, args) {\n            if (this._isDisposed) {\n                return Promise.reject(errors.canceled());\n            }\n            let cancellationToken = null;\n            if (args.length > 0 && cancellation_1.CancellationToken.isCancellationToken(args[args.length - 1])) {\n                cancellationToken = args.pop();\n            }\n            if (cancellationToken && cancellationToken.isCancellationRequested) {\n                // No need to do anything...\n                return Promise.reject(errors.canceled());\n            }\n            const req = ++this._lastMessageId;\n            const callId = String(req);\n            const result = new lazyPromise_1.LazyPromise();\n            if (cancellationToken) {\n                cancellationToken.onCancellationRequested(() => {\n                    const msg = MessageIO.serializeCancel(req);\n                    if (this._logger) {\n                        this._logger.logOutgoing(msg.byteLength, req, RequestInitiator.LocalSide, `cancel`);\n                    }\n                    this._protocol.send(MessageIO.serializeCancel(req));\n                });\n            }\n            this._pendingRPCReplies[callId] = result;\n            this._onWillSendRequest(req);\n            const msg = MessageIO.serializeRequest(req, rpcId, methodName, args, !!cancellationToken, this._uriReplacer);\n            if (this._logger) {\n                this._logger.logOutgoing(msg.byteLength, req, RequestInitiator.LocalSide, `request: ${proxyIdentifier_1.getStringIdentifierForProxy(rpcId)}.${methodName}(`, args);\n            }\n            this._protocol.send(msg);\n            return result;\n        }\n    }\n    RPCProtocol.UNRESPONSIVE_TIME = 3 * 1000; // 3s\n    exports.RPCProtocol = RPCProtocol;\n    class MessageBuffer {\n        static alloc(type, req, messageSize) {\n            let result = new MessageBuffer(buffer_1.VSBuffer.alloc(messageSize + 1 /* type */ + 4 /* req */), 0);\n            result.writeUInt8(type);\n            result.writeUInt32(req);\n            return result;\n        }\n        static read(buff, offset) {\n            return new MessageBuffer(buff, offset);\n        }\n        get buffer() {\n            return this._buff;\n        }\n        constructor(buff, offset) {\n            this._buff = buff;\n            this._offset = offset;\n        }\n        static sizeUInt8() {\n            return 1;\n        }\n        writeUInt8(n) {\n            this._buff.writeUint8(n, this._offset);\n            this._offset += 1;\n        }\n        readUInt8() {\n            const n = this._buff.readUint8(this._offset);\n            this._offset += 1;\n            return n;\n        }\n        writeUInt32(n) {\n            this._buff.writeUint32BE(n, this._offset);\n            this._offset += 4;\n        }\n        readUInt32() {\n            const n = this._buff.readUint32BE(this._offset);\n            this._offset += 4;\n            return n;\n        }\n        static sizeShortString(str) {\n            return 1 /* string length */ + str.byteLength /* actual string */;\n        }\n        writeShortString(str) {\n            this._buff.writeUint8(str.byteLength, this._offset);\n            this._offset += 1;\n            this._buff.set(str, this._offset);\n            this._offset += str.byteLength;\n        }\n        readShortString() {\n            const strByteLength = this._buff.readUint8(this._offset);\n            this._offset += 1;\n            const strBuff = this._buff.slice(this._offset, this._offset + strByteLength);\n            const str = strBuff.toString();\n            this._offset += strByteLength;\n            return str;\n        }\n        static sizeLongString(str) {\n            return 4 /* string length */ + str.byteLength /* actual string */;\n        }\n        writeLongString(str) {\n            this._buff.writeUint32BE(str.byteLength, this._offset);\n            this._offset += 4;\n            this._buff.set(str, this._offset);\n            this._offset += str.byteLength;\n        }\n        readLongString() {\n            const strByteLength = this._buff.readUint32BE(this._offset);\n            this._offset += 4;\n            const strBuff = this._buff.slice(this._offset, this._offset + strByteLength);\n            const str = strBuff.toString();\n            this._offset += strByteLength;\n            return str;\n        }\n        static sizeBuffer(buff) {\n            return 4 /* buffer length */ + buff.byteLength /* actual buffer */;\n        }\n        writeBuffer(buff) {\n            this._buff.writeUint32BE(buff.byteLength, this._offset);\n            this._offset += 4;\n            this._buff.set(buff, this._offset);\n            this._offset += buff.byteLength;\n        }\n        readBuffer() {\n            const buffLength = this._buff.readUint32BE(this._offset);\n            this._offset += 4;\n            const buff = this._buff.slice(this._offset, this._offset + buffLength);\n            this._offset += buffLength;\n            return buff.buffer;\n        }\n        static sizeVSBuffer(buff) {\n            return 4 /* buffer length */ + buff.byteLength /* actual buffer */;\n        }\n        writeVSBuffer(buff) {\n            this._buff.writeUint32BE(buff.byteLength, this._offset);\n            this._offset += 4;\n            this._buff.set(buff, this._offset);\n            this._offset += buff.byteLength;\n        }\n        readVSBuffer() {\n            const buffLength = this._buff.readUint32BE(this._offset);\n            this._offset += 4;\n            const buff = this._buff.slice(this._offset, this._offset + buffLength);\n            this._offset += buffLength;\n            return buff;\n        }\n        static sizeMixedArray(arr, arrType) {\n            let size = 0;\n            size += 1; // arr length\n            for (let i = 0, len = arr.length; i < len; i++) {\n                const el = arr[i];\n                const elType = arrType[i];\n                size += 1; // arg type\n                if (elType === ArgType.String) {\n                    size += this.sizeLongString(el);\n                }\n                else if (elType === ArgType.Buffer) {\n                    size += this.sizeBuffer(el);\n                }\n                else {\n                    size += this.sizeVSBuffer(el);\n                }\n            }\n            return size;\n        }\n        writeMixedArray(arr, arrType) {\n            this._buff.writeUint8(arr.length, this._offset);\n            this._offset += 1;\n            for (let i = 0, len = arr.length; i < len; i++) {\n                const el = arr[i];\n                const elType = arrType[i];\n                if (elType === ArgType.String) {\n                    this.writeUInt8(ArgType.String);\n                    this.writeLongString(el);\n                }\n                else if (elType === ArgType.Buffer) {\n                    this.writeUInt8(ArgType.Buffer);\n                    this.writeVSBuffer(el);\n                }\n                else {\n                    this.writeUInt8(ArgType.VSBuffer);\n                    this.writeVSBuffer(el);\n                }\n            }\n        }\n        readMixedArray() {\n            const arrLen = this._buff.readUint8(this._offset);\n            this._offset += 1;\n            let arr = new Array(arrLen);\n            for (let i = 0; i < arrLen; i++) {\n                const argType = this.readUInt8();\n                switch (argType) {\n                    case ArgType.String:\n                        arr[i] = this.readLongString();\n                        break;\n                    case ArgType.Buffer:\n                        arr[i] = this.readBuffer();\n                        break;\n                    case ArgType.VSBuffer:\n                        arr[i] = this.readVSBuffer();\n                        break;\n                }\n            }\n            return arr;\n        }\n    }\n    class MessageIO {\n        static _arrayContainsBuffer(arr) {\n            for (let i = 0, len = arr.length; i < len; i++) {\n                if (Buffer.isBuffer(arr[i])) {\n                    return true;\n                }\n                if (arr[i] instanceof buffer_1.VSBuffer) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        static serializeRequest(req, rpcId, method, args, usesCancellationToken, replacer) {\n            if (this._arrayContainsBuffer(args)) {\n                let massagedArgs = [];\n                let massagedArgsType = [];\n                for (let i = 0, len = args.length; i < len; i++) {\n                    const arg = args[i];\n                    if (Buffer.isBuffer(arg)) {\n                        massagedArgs[i] = buffer_1.VSBuffer.wrap(arg);\n                        massagedArgsType[i] = ArgType.Buffer;\n                    }\n                    else if (arg instanceof buffer_1.VSBuffer) {\n                        massagedArgs[i] = arg;\n                        massagedArgsType[i] = ArgType.VSBuffer;\n                    }\n                    else {\n                        massagedArgs[i] = buffer_1.VSBuffer.fromString(safeStringify(arg, replacer));\n                        massagedArgsType[i] = ArgType.String;\n                    }\n                }\n                return this._requestMixedArgs(req, rpcId, method, massagedArgs, massagedArgsType, usesCancellationToken);\n            }\n            return this._requestJSONArgs(req, rpcId, method, safeStringify(args, replacer), usesCancellationToken);\n        }\n        static _requestJSONArgs(req, rpcId, method, args, usesCancellationToken) {\n            const methodBuff = buffer_1.VSBuffer.fromString(method);\n            const argsBuff = buffer_1.VSBuffer.fromString(args);\n            let len = 0;\n            len += MessageBuffer.sizeUInt8();\n            len += MessageBuffer.sizeShortString(methodBuff);\n            len += MessageBuffer.sizeLongString(argsBuff);\n            let result = MessageBuffer.alloc(usesCancellationToken ? MessageType.RequestJSONArgsWithCancellation : MessageType.RequestJSONArgs, req, len);\n            result.writeUInt8(rpcId);\n            result.writeShortString(methodBuff);\n            result.writeLongString(argsBuff);\n            return result.buffer;\n        }\n        static deserializeRequestJSONArgs(buff) {\n            const rpcId = buff.readUInt8();\n            const method = buff.readShortString();\n            const args = buff.readLongString();\n            return {\n                rpcId: rpcId,\n                method: method,\n                args: JSON.parse(args)\n            };\n        }\n        static _requestMixedArgs(req, rpcId, method, args, argsType, usesCancellationToken) {\n            const methodBuff = buffer_1.VSBuffer.fromString(method);\n            let len = 0;\n            len += MessageBuffer.sizeUInt8();\n            len += MessageBuffer.sizeShortString(methodBuff);\n            len += MessageBuffer.sizeMixedArray(args, argsType);\n            let result = MessageBuffer.alloc(usesCancellationToken ? MessageType.RequestMixedArgsWithCancellation : MessageType.RequestMixedArgs, req, len);\n            result.writeUInt8(rpcId);\n            result.writeShortString(methodBuff);\n            result.writeMixedArray(args, argsType);\n            return result.buffer;\n        }\n        static deserializeRequestMixedArgs(buff) {\n            const rpcId = buff.readUInt8();\n            const method = buff.readShortString();\n            const rawargs = buff.readMixedArray();\n            const args = new Array(rawargs.length);\n            for (let i = 0, len = rawargs.length; i < len; i++) {\n                const rawarg = rawargs[i];\n                if (typeof rawarg === 'string') {\n                    args[i] = JSON.parse(rawarg);\n                }\n                else {\n                    args[i] = rawarg;\n                }\n            }\n            return {\n                rpcId: rpcId,\n                method: method,\n                args: args\n            };\n        }\n        static serializeAcknowledged(req) {\n            return MessageBuffer.alloc(MessageType.Acknowledged, req, 0).buffer;\n        }\n        static serializeCancel(req) {\n            return MessageBuffer.alloc(MessageType.Cancel, req, 0).buffer;\n        }\n        static serializeReplyOK(req, res, replacer) {\n            if (typeof res === 'undefined') {\n                return this._serializeReplyOKEmpty(req);\n            }\n            if (Buffer.isBuffer(res)) {\n                return this._serializeReplyOKBuffer(req, res);\n            }\n            if (res instanceof buffer_1.VSBuffer) {\n                return this._serializeReplyOKVSBuffer(req, res);\n            }\n            return this._serializeReplyOKJSON(req, safeStringify(res, replacer));\n        }\n        static _serializeReplyOKEmpty(req) {\n            return MessageBuffer.alloc(MessageType.ReplyOKEmpty, req, 0).buffer;\n        }\n        static _serializeReplyOKBuffer(req, res) {\n            const buff = buffer_1.VSBuffer.wrap(res);\n            let len = 0;\n            len += MessageBuffer.sizeBuffer(buff);\n            let result = MessageBuffer.alloc(MessageType.ReplyOKBuffer, req, len);\n            result.writeBuffer(buff);\n            return result.buffer;\n        }\n        static _serializeReplyOKVSBuffer(req, res) {\n            let len = 0;\n            len += MessageBuffer.sizeVSBuffer(res);\n            let result = MessageBuffer.alloc(MessageType.ReplyOKVSBuffer, req, len);\n            result.writeVSBuffer(res);\n            return result.buffer;\n        }\n        static deserializeReplyOKBuffer(buff) {\n            return buff.readBuffer();\n        }\n        static deserializeReplyOKVSBuffer(buff) {\n            return buff.readVSBuffer();\n        }\n        static _serializeReplyOKJSON(req, res) {\n            const resBuff = buffer_1.VSBuffer.fromString(res);\n            let len = 0;\n            len += MessageBuffer.sizeLongString(resBuff);\n            let result = MessageBuffer.alloc(MessageType.ReplyOKJSON, req, len);\n            result.writeLongString(resBuff);\n            return result.buffer;\n        }\n        static deserializeReplyOKJSON(buff) {\n            const res = buff.readLongString();\n            return JSON.parse(res);\n        }\n        static serializeReplyErr(req, err) {\n            if (err instanceof Error) {\n                return this._serializeReplyErrEror(req, err);\n            }\n            return this._serializeReplyErrEmpty(req);\n        }\n        static _serializeReplyErrEror(req, _err) {\n            const errBuff = buffer_1.VSBuffer.fromString(safeStringify(errors.transformErrorForSerialization(_err), null));\n            let len = 0;\n            len += MessageBuffer.sizeLongString(errBuff);\n            let result = MessageBuffer.alloc(MessageType.ReplyErrError, req, len);\n            result.writeLongString(errBuff);\n            return result.buffer;\n        }\n        static deserializeReplyErrError(buff) {\n            const err = buff.readLongString();\n            return JSON.parse(err);\n        }\n        static _serializeReplyErrEmpty(req) {\n            return MessageBuffer.alloc(MessageType.ReplyErrEmpty, req, 0).buffer;\n        }\n    }\n    var MessageType;\n    (function (MessageType) {\n        MessageType[MessageType[\"RequestJSONArgs\"] = 1] = \"RequestJSONArgs\";\n        MessageType[MessageType[\"RequestJSONArgsWithCancellation\"] = 2] = \"RequestJSONArgsWithCancellation\";\n        MessageType[MessageType[\"RequestMixedArgs\"] = 3] = \"RequestMixedArgs\";\n        MessageType[MessageType[\"RequestMixedArgsWithCancellation\"] = 4] = \"RequestMixedArgsWithCancellation\";\n        MessageType[MessageType[\"Acknowledged\"] = 5] = \"Acknowledged\";\n        MessageType[MessageType[\"Cancel\"] = 6] = \"Cancel\";\n        MessageType[MessageType[\"ReplyOKEmpty\"] = 7] = \"ReplyOKEmpty\";\n        MessageType[MessageType[\"ReplyOKBuffer\"] = 8] = \"ReplyOKBuffer\";\n        MessageType[MessageType[\"ReplyOKVSBuffer\"] = 8] = \"ReplyOKVSBuffer\";\n        MessageType[MessageType[\"ReplyOKJSON\"] = 9] = \"ReplyOKJSON\";\n        MessageType[MessageType[\"ReplyErrError\"] = 10] = \"ReplyErrError\";\n        MessageType[MessageType[\"ReplyErrEmpty\"] = 11] = \"ReplyErrEmpty\";\n    })(MessageType || (MessageType = {}));\n    var ArgType;\n    (function (ArgType) {\n        ArgType[ArgType[\"String\"] = 1] = \"String\";\n        ArgType[ArgType[\"Buffer\"] = 2] = \"Buffer\";\n        ArgType[ArgType[\"VSBuffer\"] = 3] = \"VSBuffer\";\n    })(ArgType || (ArgType = {}));\n});\n",null]}