{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/common/json.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/json.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ScanError;\n(function (ScanError) {\n    ScanError[ScanError[\"None\"] = 0] = \"None\";\n    ScanError[ScanError[\"UnexpectedEndOfComment\"] = 1] = \"UnexpectedEndOfComment\";\n    ScanError[ScanError[\"UnexpectedEndOfString\"] = 2] = \"UnexpectedEndOfString\";\n    ScanError[ScanError[\"UnexpectedEndOfNumber\"] = 3] = \"UnexpectedEndOfNumber\";\n    ScanError[ScanError[\"InvalidUnicode\"] = 4] = \"InvalidUnicode\";\n    ScanError[ScanError[\"InvalidEscapeCharacter\"] = 5] = \"InvalidEscapeCharacter\";\n    ScanError[ScanError[\"InvalidCharacter\"] = 6] = \"InvalidCharacter\";\n})(ScanError = exports.ScanError || (exports.ScanError = {}));\nvar SyntaxKind;\n(function (SyntaxKind) {\n    SyntaxKind[SyntaxKind[\"OpenBraceToken\"] = 1] = \"OpenBraceToken\";\n    SyntaxKind[SyntaxKind[\"CloseBraceToken\"] = 2] = \"CloseBraceToken\";\n    SyntaxKind[SyntaxKind[\"OpenBracketToken\"] = 3] = \"OpenBracketToken\";\n    SyntaxKind[SyntaxKind[\"CloseBracketToken\"] = 4] = \"CloseBracketToken\";\n    SyntaxKind[SyntaxKind[\"CommaToken\"] = 5] = \"CommaToken\";\n    SyntaxKind[SyntaxKind[\"ColonToken\"] = 6] = \"ColonToken\";\n    SyntaxKind[SyntaxKind[\"NullKeyword\"] = 7] = \"NullKeyword\";\n    SyntaxKind[SyntaxKind[\"TrueKeyword\"] = 8] = \"TrueKeyword\";\n    SyntaxKind[SyntaxKind[\"FalseKeyword\"] = 9] = \"FalseKeyword\";\n    SyntaxKind[SyntaxKind[\"StringLiteral\"] = 10] = \"StringLiteral\";\n    SyntaxKind[SyntaxKind[\"NumericLiteral\"] = 11] = \"NumericLiteral\";\n    SyntaxKind[SyntaxKind[\"LineCommentTrivia\"] = 12] = \"LineCommentTrivia\";\n    SyntaxKind[SyntaxKind[\"BlockCommentTrivia\"] = 13] = \"BlockCommentTrivia\";\n    SyntaxKind[SyntaxKind[\"LineBreakTrivia\"] = 14] = \"LineBreakTrivia\";\n    SyntaxKind[SyntaxKind[\"Trivia\"] = 15] = \"Trivia\";\n    SyntaxKind[SyntaxKind[\"Unknown\"] = 16] = \"Unknown\";\n    SyntaxKind[SyntaxKind[\"EOF\"] = 17] = \"EOF\";\n})(SyntaxKind = exports.SyntaxKind || (exports.SyntaxKind = {}));\nvar ParseErrorCode;\n(function (ParseErrorCode) {\n    ParseErrorCode[ParseErrorCode[\"InvalidSymbol\"] = 1] = \"InvalidSymbol\";\n    ParseErrorCode[ParseErrorCode[\"InvalidNumberFormat\"] = 2] = \"InvalidNumberFormat\";\n    ParseErrorCode[ParseErrorCode[\"PropertyNameExpected\"] = 3] = \"PropertyNameExpected\";\n    ParseErrorCode[ParseErrorCode[\"ValueExpected\"] = 4] = \"ValueExpected\";\n    ParseErrorCode[ParseErrorCode[\"ColonExpected\"] = 5] = \"ColonExpected\";\n    ParseErrorCode[ParseErrorCode[\"CommaExpected\"] = 6] = \"CommaExpected\";\n    ParseErrorCode[ParseErrorCode[\"CloseBraceExpected\"] = 7] = \"CloseBraceExpected\";\n    ParseErrorCode[ParseErrorCode[\"CloseBracketExpected\"] = 8] = \"CloseBracketExpected\";\n    ParseErrorCode[ParseErrorCode[\"EndOfFileExpected\"] = 9] = \"EndOfFileExpected\";\n    ParseErrorCode[ParseErrorCode[\"InvalidCommentToken\"] = 10] = \"InvalidCommentToken\";\n    ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfComment\"] = 11] = \"UnexpectedEndOfComment\";\n    ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfString\"] = 12] = \"UnexpectedEndOfString\";\n    ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfNumber\"] = 13] = \"UnexpectedEndOfNumber\";\n    ParseErrorCode[ParseErrorCode[\"InvalidUnicode\"] = 14] = \"InvalidUnicode\";\n    ParseErrorCode[ParseErrorCode[\"InvalidEscapeCharacter\"] = 15] = \"InvalidEscapeCharacter\";\n    ParseErrorCode[ParseErrorCode[\"InvalidCharacter\"] = 16] = \"InvalidCharacter\";\n})(ParseErrorCode = exports.ParseErrorCode || (exports.ParseErrorCode = {}));\nvar ParseOptions;\n(function (ParseOptions) {\n    ParseOptions.DEFAULT = {\n        allowTrailingComma: true\n    };\n})(ParseOptions = exports.ParseOptions || (exports.ParseOptions = {}));\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nfunction createScanner(text, ignoreTrivia) {\n    if (ignoreTrivia === void 0) { ignoreTrivia = false; }\n    var pos = 0, len = text.length, value = '', tokenOffset = 0, token = SyntaxKind.Unknown, scanError = ScanError.None;\n    function scanHexDigits(count) {\n        var digits = 0;\n        var value = 0;\n        while (digits < count) {\n            var ch = text.charCodeAt(pos);\n            if (ch >= CharacterCodes._0 && ch <= CharacterCodes._9) {\n                value = value * 16 + ch - CharacterCodes._0;\n            }\n            else if (ch >= CharacterCodes.A && ch <= CharacterCodes.F) {\n                value = value * 16 + ch - CharacterCodes.A + 10;\n            }\n            else if (ch >= CharacterCodes.a && ch <= CharacterCodes.f) {\n                value = value * 16 + ch - CharacterCodes.a + 10;\n            }\n            else {\n                break;\n            }\n            pos++;\n            digits++;\n        }\n        if (digits < count) {\n            value = -1;\n        }\n        return value;\n    }\n    function setPosition(newPosition) {\n        pos = newPosition;\n        value = '';\n        tokenOffset = 0;\n        token = SyntaxKind.Unknown;\n        scanError = ScanError.None;\n    }\n    function scanNumber() {\n        var start = pos;\n        if (text.charCodeAt(pos) === CharacterCodes._0) {\n            pos++;\n        }\n        else {\n            pos++;\n            while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n            }\n        }\n        if (pos < text.length && text.charCodeAt(pos) === CharacterCodes.dot) {\n            pos++;\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n            }\n            else {\n                scanError = ScanError.UnexpectedEndOfNumber;\n                return text.substring(start, pos);\n            }\n        }\n        var end = pos;\n        if (pos < text.length && (text.charCodeAt(pos) === CharacterCodes.E || text.charCodeAt(pos) === CharacterCodes.e)) {\n            pos++;\n            if (pos < text.length && text.charCodeAt(pos) === CharacterCodes.plus || text.charCodeAt(pos) === CharacterCodes.minus) {\n                pos++;\n            }\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n                end = pos;\n            }\n            else {\n                scanError = ScanError.UnexpectedEndOfNumber;\n            }\n        }\n        return text.substring(start, end);\n    }\n    function scanString() {\n        var result = '', start = pos;\n        while (true) {\n            if (pos >= len) {\n                result += text.substring(start, pos);\n                scanError = ScanError.UnexpectedEndOfString;\n                break;\n            }\n            var ch = text.charCodeAt(pos);\n            if (ch === CharacterCodes.doubleQuote) {\n                result += text.substring(start, pos);\n                pos++;\n                break;\n            }\n            if (ch === CharacterCodes.backslash) {\n                result += text.substring(start, pos);\n                pos++;\n                if (pos >= len) {\n                    scanError = ScanError.UnexpectedEndOfString;\n                    break;\n                }\n                ch = text.charCodeAt(pos++);\n                switch (ch) {\n                    case CharacterCodes.doubleQuote:\n                        result += '\\\"';\n                        break;\n                    case CharacterCodes.backslash:\n                        result += '\\\\';\n                        break;\n                    case CharacterCodes.slash:\n                        result += '/';\n                        break;\n                    case CharacterCodes.b:\n                        result += '\\b';\n                        break;\n                    case CharacterCodes.f:\n                        result += '\\f';\n                        break;\n                    case CharacterCodes.n:\n                        result += '\\n';\n                        break;\n                    case CharacterCodes.r:\n                        result += '\\r';\n                        break;\n                    case CharacterCodes.t:\n                        result += '\\t';\n                        break;\n                    case CharacterCodes.u:\n                        var ch_1 = scanHexDigits(4);\n                        if (ch_1 >= 0) {\n                            result += String.fromCharCode(ch_1);\n                        }\n                        else {\n                            scanError = ScanError.InvalidUnicode;\n                        }\n                        break;\n                    default:\n                        scanError = ScanError.InvalidEscapeCharacter;\n                }\n                start = pos;\n                continue;\n            }\n            if (ch >= 0 && ch <= 0x1F) {\n                if (isLineBreak(ch)) {\n                    result += text.substring(start, pos);\n                    scanError = ScanError.UnexpectedEndOfString;\n                    break;\n                }\n                else {\n                    scanError = ScanError.InvalidCharacter;\n                    // mark as error but continue with string\n                }\n            }\n            pos++;\n        }\n        return result;\n    }\n    function scanNext() {\n        value = '';\n        scanError = ScanError.None;\n        tokenOffset = pos;\n        if (pos >= len) {\n            // at the end\n            tokenOffset = len;\n            return token = SyntaxKind.EOF;\n        }\n        var code = text.charCodeAt(pos);\n        // trivia: whitespace\n        if (isWhiteSpace(code)) {\n            do {\n                pos++;\n                value += String.fromCharCode(code);\n                code = text.charCodeAt(pos);\n            } while (isWhiteSpace(code));\n            return token = SyntaxKind.Trivia;\n        }\n        // trivia: newlines\n        if (isLineBreak(code)) {\n            pos++;\n            value += String.fromCharCode(code);\n            if (code === CharacterCodes.carriageReturn && text.charCodeAt(pos) === CharacterCodes.lineFeed) {\n                pos++;\n                value += '\\n';\n            }\n            return token = SyntaxKind.LineBreakTrivia;\n        }\n        switch (code) {\n            // tokens: []{}:,\n            case CharacterCodes.openBrace:\n                pos++;\n                return token = SyntaxKind.OpenBraceToken;\n            case CharacterCodes.closeBrace:\n                pos++;\n                return token = SyntaxKind.CloseBraceToken;\n            case CharacterCodes.openBracket:\n                pos++;\n                return token = SyntaxKind.OpenBracketToken;\n            case CharacterCodes.closeBracket:\n                pos++;\n                return token = SyntaxKind.CloseBracketToken;\n            case CharacterCodes.colon:\n                pos++;\n                return token = SyntaxKind.ColonToken;\n            case CharacterCodes.comma:\n                pos++;\n                return token = SyntaxKind.CommaToken;\n            // strings\n            case CharacterCodes.doubleQuote:\n                pos++;\n                value = scanString();\n                return token = SyntaxKind.StringLiteral;\n            // comments\n            case CharacterCodes.slash:\n                var start = pos - 1;\n                // Single-line comment\n                if (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\n                    pos += 2;\n                    while (pos < len) {\n                        if (isLineBreak(text.charCodeAt(pos))) {\n                            break;\n                        }\n                        pos++;\n                    }\n                    value = text.substring(start, pos);\n                    return token = SyntaxKind.LineCommentTrivia;\n                }\n                // Multi-line comment\n                if (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {\n                    pos += 2;\n                    var safeLength = len - 1; // For lookahead.\n                    var commentClosed = false;\n                    while (pos < safeLength) {\n                        var ch = text.charCodeAt(pos);\n                        if (ch === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\n                            pos += 2;\n                            commentClosed = true;\n                            break;\n                        }\n                        pos++;\n                    }\n                    if (!commentClosed) {\n                        pos++;\n                        scanError = ScanError.UnexpectedEndOfComment;\n                    }\n                    value = text.substring(start, pos);\n                    return token = SyntaxKind.BlockCommentTrivia;\n                }\n                // just a single slash\n                value += String.fromCharCode(code);\n                pos++;\n                return token = SyntaxKind.Unknown;\n            // numbers\n            case CharacterCodes.minus:\n                value += String.fromCharCode(code);\n                pos++;\n                if (pos === len || !isDigit(text.charCodeAt(pos))) {\n                    return token = SyntaxKind.Unknown;\n                }\n            // found a minus, followed by a number so\n            // we fall through to proceed with scanning\n            // numbers\n            case CharacterCodes._0:\n            case CharacterCodes._1:\n            case CharacterCodes._2:\n            case CharacterCodes._3:\n            case CharacterCodes._4:\n            case CharacterCodes._5:\n            case CharacterCodes._6:\n            case CharacterCodes._7:\n            case CharacterCodes._8:\n            case CharacterCodes._9:\n                value += scanNumber();\n                return token = SyntaxKind.NumericLiteral;\n            // literals and unknown symbols\n            default:\n                // is a literal? Read the full word.\n                while (pos < len && isUnknownContentCharacter(code)) {\n                    pos++;\n                    code = text.charCodeAt(pos);\n                }\n                if (tokenOffset !== pos) {\n                    value = text.substring(tokenOffset, pos);\n                    // keywords: true, false, null\n                    switch (value) {\n                        case 'true': return token = SyntaxKind.TrueKeyword;\n                        case 'false': return token = SyntaxKind.FalseKeyword;\n                        case 'null': return token = SyntaxKind.NullKeyword;\n                    }\n                    return token = SyntaxKind.Unknown;\n                }\n                // some\n                value += String.fromCharCode(code);\n                pos++;\n                return token = SyntaxKind.Unknown;\n        }\n    }\n    function isUnknownContentCharacter(code) {\n        if (isWhiteSpace(code) || isLineBreak(code)) {\n            return false;\n        }\n        switch (code) {\n            case CharacterCodes.closeBrace:\n            case CharacterCodes.closeBracket:\n            case CharacterCodes.openBrace:\n            case CharacterCodes.openBracket:\n            case CharacterCodes.doubleQuote:\n            case CharacterCodes.colon:\n            case CharacterCodes.comma:\n            case CharacterCodes.slash:\n                return false;\n        }\n        return true;\n    }\n    function scanNextNonTrivia() {\n        var result;\n        do {\n            result = scanNext();\n        } while (result >= SyntaxKind.LineCommentTrivia && result <= SyntaxKind.Trivia);\n        return result;\n    }\n    return {\n        setPosition: setPosition,\n        getPosition: function () { return pos; },\n        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n        getToken: function () { return token; },\n        getTokenValue: function () { return value; },\n        getTokenOffset: function () { return tokenOffset; },\n        getTokenLength: function () { return pos - tokenOffset; },\n        getTokenError: function () { return scanError; }\n    };\n}\nexports.createScanner = createScanner;\nfunction isWhiteSpace(ch) {\n    return ch === CharacterCodes.space || ch === CharacterCodes.tab || ch === CharacterCodes.verticalTab || ch === CharacterCodes.formFeed ||\n        ch === CharacterCodes.nonBreakingSpace || ch === CharacterCodes.ogham || ch >= CharacterCodes.enQuad && ch <= CharacterCodes.zeroWidthSpace ||\n        ch === CharacterCodes.narrowNoBreakSpace || ch === CharacterCodes.mathematicalSpace || ch === CharacterCodes.ideographicSpace || ch === CharacterCodes.byteOrderMark;\n}\nfunction isLineBreak(ch) {\n    return ch === CharacterCodes.lineFeed || ch === CharacterCodes.carriageReturn || ch === CharacterCodes.lineSeparator || ch === CharacterCodes.paragraphSeparator;\n}\nfunction isDigit(ch) {\n    return ch >= CharacterCodes._0 && ch <= CharacterCodes._9;\n}\nvar CharacterCodes;\n(function (CharacterCodes) {\n    CharacterCodes[CharacterCodes[\"nullCharacter\"] = 0] = \"nullCharacter\";\n    CharacterCodes[CharacterCodes[\"maxAsciiCharacter\"] = 127] = \"maxAsciiCharacter\";\n    CharacterCodes[CharacterCodes[\"lineFeed\"] = 10] = \"lineFeed\";\n    CharacterCodes[CharacterCodes[\"carriageReturn\"] = 13] = \"carriageReturn\";\n    CharacterCodes[CharacterCodes[\"lineSeparator\"] = 8232] = \"lineSeparator\";\n    CharacterCodes[CharacterCodes[\"paragraphSeparator\"] = 8233] = \"paragraphSeparator\";\n    // REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems\n    // like an odd disparity?  (Or maybe it's completely fine for them to be different).\n    CharacterCodes[CharacterCodes[\"nextLine\"] = 133] = \"nextLine\";\n    // Unicode 3.0 space characters\n    CharacterCodes[CharacterCodes[\"space\"] = 32] = \"space\";\n    CharacterCodes[CharacterCodes[\"nonBreakingSpace\"] = 160] = \"nonBreakingSpace\";\n    CharacterCodes[CharacterCodes[\"enQuad\"] = 8192] = \"enQuad\";\n    CharacterCodes[CharacterCodes[\"emQuad\"] = 8193] = \"emQuad\";\n    CharacterCodes[CharacterCodes[\"enSpace\"] = 8194] = \"enSpace\";\n    CharacterCodes[CharacterCodes[\"emSpace\"] = 8195] = \"emSpace\";\n    CharacterCodes[CharacterCodes[\"threePerEmSpace\"] = 8196] = \"threePerEmSpace\";\n    CharacterCodes[CharacterCodes[\"fourPerEmSpace\"] = 8197] = \"fourPerEmSpace\";\n    CharacterCodes[CharacterCodes[\"sixPerEmSpace\"] = 8198] = \"sixPerEmSpace\";\n    CharacterCodes[CharacterCodes[\"figureSpace\"] = 8199] = \"figureSpace\";\n    CharacterCodes[CharacterCodes[\"punctuationSpace\"] = 8200] = \"punctuationSpace\";\n    CharacterCodes[CharacterCodes[\"thinSpace\"] = 8201] = \"thinSpace\";\n    CharacterCodes[CharacterCodes[\"hairSpace\"] = 8202] = \"hairSpace\";\n    CharacterCodes[CharacterCodes[\"zeroWidthSpace\"] = 8203] = \"zeroWidthSpace\";\n    CharacterCodes[CharacterCodes[\"narrowNoBreakSpace\"] = 8239] = \"narrowNoBreakSpace\";\n    CharacterCodes[CharacterCodes[\"ideographicSpace\"] = 12288] = \"ideographicSpace\";\n    CharacterCodes[CharacterCodes[\"mathematicalSpace\"] = 8287] = \"mathematicalSpace\";\n    CharacterCodes[CharacterCodes[\"ogham\"] = 5760] = \"ogham\";\n    CharacterCodes[CharacterCodes[\"_\"] = 95] = \"_\";\n    CharacterCodes[CharacterCodes[\"$\"] = 36] = \"$\";\n    CharacterCodes[CharacterCodes[\"_0\"] = 48] = \"_0\";\n    CharacterCodes[CharacterCodes[\"_1\"] = 49] = \"_1\";\n    CharacterCodes[CharacterCodes[\"_2\"] = 50] = \"_2\";\n    CharacterCodes[CharacterCodes[\"_3\"] = 51] = \"_3\";\n    CharacterCodes[CharacterCodes[\"_4\"] = 52] = \"_4\";\n    CharacterCodes[CharacterCodes[\"_5\"] = 53] = \"_5\";\n    CharacterCodes[CharacterCodes[\"_6\"] = 54] = \"_6\";\n    CharacterCodes[CharacterCodes[\"_7\"] = 55] = \"_7\";\n    CharacterCodes[CharacterCodes[\"_8\"] = 56] = \"_8\";\n    CharacterCodes[CharacterCodes[\"_9\"] = 57] = \"_9\";\n    CharacterCodes[CharacterCodes[\"a\"] = 97] = \"a\";\n    CharacterCodes[CharacterCodes[\"b\"] = 98] = \"b\";\n    CharacterCodes[CharacterCodes[\"c\"] = 99] = \"c\";\n    CharacterCodes[CharacterCodes[\"d\"] = 100] = \"d\";\n    CharacterCodes[CharacterCodes[\"e\"] = 101] = \"e\";\n    CharacterCodes[CharacterCodes[\"f\"] = 102] = \"f\";\n    CharacterCodes[CharacterCodes[\"g\"] = 103] = \"g\";\n    CharacterCodes[CharacterCodes[\"h\"] = 104] = \"h\";\n    CharacterCodes[CharacterCodes[\"i\"] = 105] = \"i\";\n    CharacterCodes[CharacterCodes[\"j\"] = 106] = \"j\";\n    CharacterCodes[CharacterCodes[\"k\"] = 107] = \"k\";\n    CharacterCodes[CharacterCodes[\"l\"] = 108] = \"l\";\n    CharacterCodes[CharacterCodes[\"m\"] = 109] = \"m\";\n    CharacterCodes[CharacterCodes[\"n\"] = 110] = \"n\";\n    CharacterCodes[CharacterCodes[\"o\"] = 111] = \"o\";\n    CharacterCodes[CharacterCodes[\"p\"] = 112] = \"p\";\n    CharacterCodes[CharacterCodes[\"q\"] = 113] = \"q\";\n    CharacterCodes[CharacterCodes[\"r\"] = 114] = \"r\";\n    CharacterCodes[CharacterCodes[\"s\"] = 115] = \"s\";\n    CharacterCodes[CharacterCodes[\"t\"] = 116] = \"t\";\n    CharacterCodes[CharacterCodes[\"u\"] = 117] = \"u\";\n    CharacterCodes[CharacterCodes[\"v\"] = 118] = \"v\";\n    CharacterCodes[CharacterCodes[\"w\"] = 119] = \"w\";\n    CharacterCodes[CharacterCodes[\"x\"] = 120] = \"x\";\n    CharacterCodes[CharacterCodes[\"y\"] = 121] = \"y\";\n    CharacterCodes[CharacterCodes[\"z\"] = 122] = \"z\";\n    CharacterCodes[CharacterCodes[\"A\"] = 65] = \"A\";\n    CharacterCodes[CharacterCodes[\"B\"] = 66] = \"B\";\n    CharacterCodes[CharacterCodes[\"C\"] = 67] = \"C\";\n    CharacterCodes[CharacterCodes[\"D\"] = 68] = \"D\";\n    CharacterCodes[CharacterCodes[\"E\"] = 69] = \"E\";\n    CharacterCodes[CharacterCodes[\"F\"] = 70] = \"F\";\n    CharacterCodes[CharacterCodes[\"G\"] = 71] = \"G\";\n    CharacterCodes[CharacterCodes[\"H\"] = 72] = \"H\";\n    CharacterCodes[CharacterCodes[\"I\"] = 73] = \"I\";\n    CharacterCodes[CharacterCodes[\"J\"] = 74] = \"J\";\n    CharacterCodes[CharacterCodes[\"K\"] = 75] = \"K\";\n    CharacterCodes[CharacterCodes[\"L\"] = 76] = \"L\";\n    CharacterCodes[CharacterCodes[\"M\"] = 77] = \"M\";\n    CharacterCodes[CharacterCodes[\"N\"] = 78] = \"N\";\n    CharacterCodes[CharacterCodes[\"O\"] = 79] = \"O\";\n    CharacterCodes[CharacterCodes[\"P\"] = 80] = \"P\";\n    CharacterCodes[CharacterCodes[\"Q\"] = 81] = \"Q\";\n    CharacterCodes[CharacterCodes[\"R\"] = 82] = \"R\";\n    CharacterCodes[CharacterCodes[\"S\"] = 83] = \"S\";\n    CharacterCodes[CharacterCodes[\"T\"] = 84] = \"T\";\n    CharacterCodes[CharacterCodes[\"U\"] = 85] = \"U\";\n    CharacterCodes[CharacterCodes[\"V\"] = 86] = \"V\";\n    CharacterCodes[CharacterCodes[\"W\"] = 87] = \"W\";\n    CharacterCodes[CharacterCodes[\"X\"] = 88] = \"X\";\n    CharacterCodes[CharacterCodes[\"Y\"] = 89] = \"Y\";\n    CharacterCodes[CharacterCodes[\"Z\"] = 90] = \"Z\";\n    CharacterCodes[CharacterCodes[\"ampersand\"] = 38] = \"ampersand\";\n    CharacterCodes[CharacterCodes[\"asterisk\"] = 42] = \"asterisk\";\n    CharacterCodes[CharacterCodes[\"at\"] = 64] = \"at\";\n    CharacterCodes[CharacterCodes[\"backslash\"] = 92] = \"backslash\";\n    CharacterCodes[CharacterCodes[\"bar\"] = 124] = \"bar\";\n    CharacterCodes[CharacterCodes[\"caret\"] = 94] = \"caret\";\n    CharacterCodes[CharacterCodes[\"closeBrace\"] = 125] = \"closeBrace\";\n    CharacterCodes[CharacterCodes[\"closeBracket\"] = 93] = \"closeBracket\";\n    CharacterCodes[CharacterCodes[\"closeParen\"] = 41] = \"closeParen\";\n    CharacterCodes[CharacterCodes[\"colon\"] = 58] = \"colon\";\n    CharacterCodes[CharacterCodes[\"comma\"] = 44] = \"comma\";\n    CharacterCodes[CharacterCodes[\"dot\"] = 46] = \"dot\";\n    CharacterCodes[CharacterCodes[\"doubleQuote\"] = 34] = \"doubleQuote\";\n    CharacterCodes[CharacterCodes[\"equals\"] = 61] = \"equals\";\n    CharacterCodes[CharacterCodes[\"exclamation\"] = 33] = \"exclamation\";\n    CharacterCodes[CharacterCodes[\"greaterThan\"] = 62] = \"greaterThan\";\n    CharacterCodes[CharacterCodes[\"lessThan\"] = 60] = \"lessThan\";\n    CharacterCodes[CharacterCodes[\"minus\"] = 45] = \"minus\";\n    CharacterCodes[CharacterCodes[\"openBrace\"] = 123] = \"openBrace\";\n    CharacterCodes[CharacterCodes[\"openBracket\"] = 91] = \"openBracket\";\n    CharacterCodes[CharacterCodes[\"openParen\"] = 40] = \"openParen\";\n    CharacterCodes[CharacterCodes[\"percent\"] = 37] = \"percent\";\n    CharacterCodes[CharacterCodes[\"plus\"] = 43] = \"plus\";\n    CharacterCodes[CharacterCodes[\"question\"] = 63] = \"question\";\n    CharacterCodes[CharacterCodes[\"semicolon\"] = 59] = \"semicolon\";\n    CharacterCodes[CharacterCodes[\"singleQuote\"] = 39] = \"singleQuote\";\n    CharacterCodes[CharacterCodes[\"slash\"] = 47] = \"slash\";\n    CharacterCodes[CharacterCodes[\"tilde\"] = 126] = \"tilde\";\n    CharacterCodes[CharacterCodes[\"backspace\"] = 8] = \"backspace\";\n    CharacterCodes[CharacterCodes[\"formFeed\"] = 12] = \"formFeed\";\n    CharacterCodes[CharacterCodes[\"byteOrderMark\"] = 65279] = \"byteOrderMark\";\n    CharacterCodes[CharacterCodes[\"tab\"] = 9] = \"tab\";\n    CharacterCodes[CharacterCodes[\"verticalTab\"] = 11] = \"verticalTab\";\n})(CharacterCodes || (CharacterCodes = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nfunction getLocation(text, position) {\n    var segments = []; // strings or numbers\n    var earlyReturnException = new Object();\n    var previousNode = undefined;\n    var previousNodeInst = {\n        value: {},\n        offset: 0,\n        length: 0,\n        type: 'object',\n        parent: undefined\n    };\n    var isAtPropertyKey = false;\n    function setPreviousNode(value, offset, length, type) {\n        previousNodeInst.value = value;\n        previousNodeInst.offset = offset;\n        previousNodeInst.length = length;\n        previousNodeInst.type = type;\n        previousNodeInst.colonOffset = undefined;\n        previousNode = previousNodeInst;\n    }\n    try {\n        visit(text, {\n            onObjectBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                isAtPropertyKey = position > offset;\n                segments.push(''); // push a placeholder (will be replaced)\n            },\n            onObjectProperty: function (name, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(name, offset, length, 'property');\n                segments[segments.length - 1] = name;\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onObjectEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onArrayBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.push(0);\n            },\n            onArrayEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onLiteralValue: function (value, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(value, offset, length, getLiteralNodeType(value));\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onSeparator: function (sep, offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                if (sep === ':' && previousNode && previousNode.type === 'property') {\n                    previousNode.colonOffset = offset;\n                    isAtPropertyKey = false;\n                    previousNode = undefined;\n                }\n                else if (sep === ',') {\n                    var last = segments[segments.length - 1];\n                    if (typeof last === 'number') {\n                        segments[segments.length - 1] = last + 1;\n                    }\n                    else {\n                        isAtPropertyKey = true;\n                        segments[segments.length - 1] = '';\n                    }\n                    previousNode = undefined;\n                }\n            }\n        });\n    }\n    catch (e) {\n        if (e !== earlyReturnException) {\n            throw e;\n        }\n    }\n    return {\n        path: segments,\n        previousNode: previousNode,\n        isAtPropertyKey: isAtPropertyKey,\n        matches: function (pattern) {\n            var k = 0;\n            for (var i = 0; k < pattern.length && i < segments.length; i++) {\n                if (pattern[k] === segments[i] || pattern[k] === '*') {\n                    k++;\n                }\n                else if (pattern[k] !== '**') {\n                    return false;\n                }\n            }\n            return k === pattern.length;\n        }\n    };\n}\nexports.getLocation = getLocation;\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nfunction parse(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var currentProperty = null;\n    var currentParent = [];\n    var previousParents = [];\n    function onValue(value) {\n        if (Array.isArray(currentParent)) {\n            currentParent.push(value);\n        }\n        else if (currentProperty) {\n            currentParent[currentProperty] = value;\n        }\n    }\n    var visitor = {\n        onObjectBegin: function () {\n            var object = {};\n            onValue(object);\n            previousParents.push(currentParent);\n            currentParent = object;\n            currentProperty = null;\n        },\n        onObjectProperty: function (name) {\n            currentProperty = name;\n        },\n        onObjectEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onArrayBegin: function () {\n            var array = [];\n            onValue(array);\n            previousParents.push(currentParent);\n            currentParent = array;\n            currentProperty = null;\n        },\n        onArrayEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onLiteralValue: onValue,\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    return currentParent[0];\n}\nexports.parse = parse;\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nfunction parseTree(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root\n    function ensurePropertyComplete(endOffset) {\n        if (currentParent.type === 'property') {\n            currentParent.length = endOffset - currentParent.offset;\n            currentParent = currentParent.parent;\n        }\n    }\n    function onValue(valueNode) {\n        currentParent.children.push(valueNode);\n        return valueNode;\n    }\n    var visitor = {\n        onObjectBegin: function (offset) {\n            currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onObjectProperty: function (name, offset, length) {\n            currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });\n            currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });\n        },\n        onObjectEnd: function (offset, length) {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onArrayBegin: function (offset, length) {\n            currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onArrayEnd: function (offset, length) {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onLiteralValue: function (value, offset, length) {\n            onValue({ type: getLiteralNodeType(value), offset: offset, length: length, parent: currentParent, value: value });\n            ensurePropertyComplete(offset + length);\n        },\n        onSeparator: function (sep, offset, length) {\n            if (currentParent.type === 'property') {\n                if (sep === ':') {\n                    currentParent.colonOffset = offset;\n                }\n                else if (sep === ',') {\n                    ensurePropertyComplete(offset);\n                }\n            }\n        },\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    var result = currentParent.children[0];\n    if (result) {\n        delete result.parent;\n    }\n    return result;\n}\nexports.parseTree = parseTree;\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nfunction findNodeAtLocation(root, path) {\n    if (!root) {\n        return undefined;\n    }\n    var node = root;\n    for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n        var segment = path_1[_i];\n        if (typeof segment === 'string') {\n            if (node.type !== 'object' || !Array.isArray(node.children)) {\n                return undefined;\n            }\n            var found = false;\n            for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\n                var propertyNode = _b[_a];\n                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n                    node = propertyNode.children[1];\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return undefined;\n            }\n        }\n        else {\n            var index = segment;\n            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n                return undefined;\n            }\n            node = node.children[index];\n        }\n    }\n    return node;\n}\nexports.findNodeAtLocation = findNodeAtLocation;\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nfunction getNodePath(node) {\n    if (!node.parent || !node.parent.children) {\n        return [];\n    }\n    var path = getNodePath(node.parent);\n    if (node.parent.type === 'property') {\n        var key = node.parent.children[0].value;\n        path.push(key);\n    }\n    else if (node.parent.type === 'array') {\n        var index = node.parent.children.indexOf(node);\n        if (index !== -1) {\n            path.push(index);\n        }\n    }\n    return path;\n}\nexports.getNodePath = getNodePath;\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nfunction getNodeValue(node) {\n    switch (node.type) {\n        case 'array':\n            return node.children.map(getNodeValue);\n        case 'object':\n            var obj = Object.create(null);\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                var prop = _a[_i];\n                var valueNode = prop.children[1];\n                if (valueNode) {\n                    obj[prop.children[0].value] = getNodeValue(valueNode);\n                }\n            }\n            return obj;\n        case 'null':\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return node.value;\n        default:\n            return undefined;\n    }\n}\nexports.getNodeValue = getNodeValue;\nfunction contains(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n}\nexports.contains = contains;\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nfunction findNodeAtOffset(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    if (contains(node, offset, includeRightBound)) {\n        var children = node.children;\n        if (Array.isArray(children)) {\n            for (var i = 0; i < children.length && children[i].offset <= offset; i++) {\n                var item = findNodeAtOffset(children[i], offset, includeRightBound);\n                if (item) {\n                    return item;\n                }\n            }\n        }\n        return node;\n    }\n    return undefined;\n}\nexports.findNodeAtOffset = findNodeAtOffset;\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nfunction visit(text, visitor, options) {\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var _scanner = createScanner(text, false);\n    function toNoArgVisit(visitFunction) {\n        return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };\n    }\n    function toOneArgVisit(visitFunction) {\n        return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };\n    }\n    var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\n    var disallowComments = options && options.disallowComments;\n    var allowTrailingComma = options && options.allowTrailingComma;\n    function scanNext() {\n        while (true) {\n            var token = _scanner.scan();\n            switch (_scanner.getTokenError()) {\n                case ScanError.InvalidUnicode:\n                    handleError(ParseErrorCode.InvalidUnicode);\n                    break;\n                case ScanError.InvalidEscapeCharacter:\n                    handleError(ParseErrorCode.InvalidEscapeCharacter);\n                    break;\n                case ScanError.UnexpectedEndOfNumber:\n                    handleError(ParseErrorCode.UnexpectedEndOfNumber);\n                    break;\n                case ScanError.UnexpectedEndOfComment:\n                    if (!disallowComments) {\n                        handleError(ParseErrorCode.UnexpectedEndOfComment);\n                    }\n                    break;\n                case ScanError.UnexpectedEndOfString:\n                    handleError(ParseErrorCode.UnexpectedEndOfString);\n                    break;\n                case ScanError.InvalidCharacter:\n                    handleError(ParseErrorCode.InvalidCharacter);\n                    break;\n            }\n            switch (token) {\n                case SyntaxKind.LineCommentTrivia:\n                case SyntaxKind.BlockCommentTrivia:\n                    if (disallowComments) {\n                        handleError(ParseErrorCode.InvalidCommentToken);\n                    }\n                    else {\n                        onComment();\n                    }\n                    break;\n                case SyntaxKind.Unknown:\n                    handleError(ParseErrorCode.InvalidSymbol);\n                    break;\n                case SyntaxKind.Trivia:\n                case SyntaxKind.LineBreakTrivia:\n                    break;\n                default:\n                    return token;\n            }\n        }\n    }\n    function handleError(error, skipUntilAfter, skipUntil) {\n        if (skipUntilAfter === void 0) { skipUntilAfter = []; }\n        if (skipUntil === void 0) { skipUntil = []; }\n        onError(error);\n        if (skipUntilAfter.length + skipUntil.length > 0) {\n            var token = _scanner.getToken();\n            while (token !== SyntaxKind.EOF) {\n                if (skipUntilAfter.indexOf(token) !== -1) {\n                    scanNext();\n                    break;\n                }\n                else if (skipUntil.indexOf(token) !== -1) {\n                    break;\n                }\n                token = scanNext();\n            }\n        }\n    }\n    function parseString(isValue) {\n        var value = _scanner.getTokenValue();\n        if (isValue) {\n            onLiteralValue(value);\n        }\n        else {\n            onObjectProperty(value);\n        }\n        scanNext();\n        return true;\n    }\n    function parseLiteral() {\n        switch (_scanner.getToken()) {\n            case SyntaxKind.NumericLiteral:\n                var value = 0;\n                try {\n                    value = JSON.parse(_scanner.getTokenValue());\n                    if (typeof value !== 'number') {\n                        handleError(ParseErrorCode.InvalidNumberFormat);\n                        value = 0;\n                    }\n                }\n                catch (e) {\n                    handleError(ParseErrorCode.InvalidNumberFormat);\n                }\n                onLiteralValue(value);\n                break;\n            case SyntaxKind.NullKeyword:\n                onLiteralValue(null);\n                break;\n            case SyntaxKind.TrueKeyword:\n                onLiteralValue(true);\n                break;\n            case SyntaxKind.FalseKeyword:\n                onLiteralValue(false);\n                break;\n            default:\n                return false;\n        }\n        scanNext();\n        return true;\n    }\n    function parseProperty() {\n        if (_scanner.getToken() !== SyntaxKind.StringLiteral) {\n            handleError(ParseErrorCode.PropertyNameExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n            return false;\n        }\n        parseString(false);\n        if (_scanner.getToken() === SyntaxKind.ColonToken) {\n            onSeparator(':');\n            scanNext(); // consume colon\n            if (!parseValue()) {\n                handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n            }\n        }\n        else {\n            handleError(ParseErrorCode.ColonExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n        }\n        return true;\n    }\n    function parseObject() {\n        onObjectBegin();\n        scanNext(); // consume open brace\n        var needsComma = false;\n        while (_scanner.getToken() !== SyntaxKind.CloseBraceToken && _scanner.getToken() !== SyntaxKind.EOF) {\n            if (_scanner.getToken() === SyntaxKind.CommaToken) {\n                if (!needsComma) {\n                    handleError(ParseErrorCode.ValueExpected, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === SyntaxKind.CloseBraceToken && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(ParseErrorCode.CommaExpected, [], []);\n            }\n            if (!parseProperty()) {\n                handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n            }\n            needsComma = true;\n        }\n        onObjectEnd();\n        if (_scanner.getToken() !== SyntaxKind.CloseBraceToken) {\n            handleError(ParseErrorCode.CloseBraceExpected, [SyntaxKind.CloseBraceToken], []);\n        }\n        else {\n            scanNext(); // consume close brace\n        }\n        return true;\n    }\n    function parseArray() {\n        onArrayBegin();\n        scanNext(); // consume open bracket\n        var needsComma = false;\n        while (_scanner.getToken() !== SyntaxKind.CloseBracketToken && _scanner.getToken() !== SyntaxKind.EOF) {\n            if (_scanner.getToken() === SyntaxKind.CommaToken) {\n                if (!needsComma) {\n                    handleError(ParseErrorCode.ValueExpected, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === SyntaxKind.CloseBracketToken && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(ParseErrorCode.CommaExpected, [], []);\n            }\n            if (!parseValue()) {\n                handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBracketToken, SyntaxKind.CommaToken]);\n            }\n            needsComma = true;\n        }\n        onArrayEnd();\n        if (_scanner.getToken() !== SyntaxKind.CloseBracketToken) {\n            handleError(ParseErrorCode.CloseBracketExpected, [SyntaxKind.CloseBracketToken], []);\n        }\n        else {\n            scanNext(); // consume close bracket\n        }\n        return true;\n    }\n    function parseValue() {\n        switch (_scanner.getToken()) {\n            case SyntaxKind.OpenBracketToken:\n                return parseArray();\n            case SyntaxKind.OpenBraceToken:\n                return parseObject();\n            case SyntaxKind.StringLiteral:\n                return parseString(true);\n            default:\n                return parseLiteral();\n        }\n    }\n    scanNext();\n    if (_scanner.getToken() === SyntaxKind.EOF) {\n        return true;\n    }\n    if (!parseValue()) {\n        handleError(ParseErrorCode.ValueExpected, [], []);\n        return false;\n    }\n    if (_scanner.getToken() !== SyntaxKind.EOF) {\n        handleError(ParseErrorCode.EndOfFileExpected, [], []);\n    }\n    return true;\n}\nexports.visit = visit;\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nfunction stripComments(text, replaceCh) {\n    var _scanner = createScanner(text), parts = [], kind, offset = 0, pos;\n    do {\n        pos = _scanner.getPosition();\n        kind = _scanner.scan();\n        switch (kind) {\n            case SyntaxKind.LineCommentTrivia:\n            case SyntaxKind.BlockCommentTrivia:\n            case SyntaxKind.EOF:\n                if (offset !== pos) {\n                    parts.push(text.substring(offset, pos));\n                }\n                if (replaceCh !== undefined) {\n                    parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n                }\n                offset = _scanner.getPosition();\n                break;\n        }\n    } while (kind !== SyntaxKind.EOF);\n    return parts.join('');\n}\nexports.stripComments = stripComments;\nfunction getLiteralNodeType(value) {\n    switch (typeof value) {\n        case 'boolean': return 'boolean';\n        case 'number': return 'number';\n        case 'string': return 'string';\n        default: return 'null';\n    }\n}\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/common/json.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/common/json.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport const enum ScanError {\n\tNone = 0,\n\tUnexpectedEndOfComment = 1,\n\tUnexpectedEndOfString = 2,\n\tUnexpectedEndOfNumber = 3,\n\tInvalidUnicode = 4,\n\tInvalidEscapeCharacter = 5,\n\tInvalidCharacter = 6\n}\n\nexport const enum SyntaxKind {\n\tOpenBraceToken = 1,\n\tCloseBraceToken = 2,\n\tOpenBracketToken = 3,\n\tCloseBracketToken = 4,\n\tCommaToken = 5,\n\tColonToken = 6,\n\tNullKeyword = 7,\n\tTrueKeyword = 8,\n\tFalseKeyword = 9,\n\tStringLiteral = 10,\n\tNumericLiteral = 11,\n\tLineCommentTrivia = 12,\n\tBlockCommentTrivia = 13,\n\tLineBreakTrivia = 14,\n\tTrivia = 15,\n\tUnknown = 16,\n\tEOF = 17\n}\n\n/**\n * The scanner object, representing a JSON scanner at a position in the input string.\n */\nexport interface JSONScanner {\n\t/**\n\t * Sets the scan position to a new offset. A call to 'scan' is needed to get the first token.\n\t */\n\tsetPosition(pos: number): void;\n\t/**\n\t * Read the next token. Returns the token code.\n\t */\n\tscan(): SyntaxKind;\n\t/**\n\t * Returns the current scan position, which is after the last read token.\n\t */\n\tgetPosition(): number;\n\t/**\n\t * Returns the last read token.\n\t */\n\tgetToken(): SyntaxKind;\n\t/**\n\t * Returns the last read token value. The value for strings is the decoded string content. For numbers its of type number, for boolean it's true or false.\n\t */\n\tgetTokenValue(): string;\n\t/**\n\t * The start offset of the last read token.\n\t */\n\tgetTokenOffset(): number;\n\t/**\n\t * The length of the last read token.\n\t */\n\tgetTokenLength(): number;\n\t/**\n\t * An error code of the last scan.\n\t */\n\tgetTokenError(): ScanError;\n}\n\n\nexport interface ParseError {\n\terror: ParseErrorCode;\n\toffset: number;\n\tlength: number;\n}\n\nexport const enum ParseErrorCode {\n\tInvalidSymbol = 1,\n\tInvalidNumberFormat = 2,\n\tPropertyNameExpected = 3,\n\tValueExpected = 4,\n\tColonExpected = 5,\n\tCommaExpected = 6,\n\tCloseBraceExpected = 7,\n\tCloseBracketExpected = 8,\n\tEndOfFileExpected = 9,\n\tInvalidCommentToken = 10,\n\tUnexpectedEndOfComment = 11,\n\tUnexpectedEndOfString = 12,\n\tUnexpectedEndOfNumber = 13,\n\tInvalidUnicode = 14,\n\tInvalidEscapeCharacter = 15,\n\tInvalidCharacter = 16\n}\n\nexport type NodeType = 'object' | 'array' | 'property' | 'string' | 'number' | 'boolean' | 'null';\n\nexport interface Node {\n\treadonly type: NodeType;\n\treadonly value?: any;\n\treadonly offset: number;\n\treadonly length: number;\n\treadonly colonOffset?: number;\n\treadonly parent?: Node;\n\treadonly children?: Node[];\n}\n\nexport type Segment = string | number;\nexport type JSONPath = Segment[];\n\nexport interface Location {\n\t/**\n\t * The previous property key or literal value (string, number, boolean or null) or undefined.\n\t */\n\tpreviousNode?: Node;\n\t/**\n\t * The path describing the location in the JSON document. The path consists of a sequence strings\n\t * representing an object property or numbers for array indices.\n\t */\n\tpath: JSONPath;\n\t/**\n\t * Matches the locations path against a pattern consisting of strings (for properties) and numbers (for array indices).\n\t * '*' will match a single segment, of any property name or index.\n\t * '**' will match a sequece of segments or no segment, of any property name or index.\n\t */\n\tmatches: (patterns: JSONPath) => boolean;\n\t/**\n\t * If set, the location's offset is at a property key.\n\t */\n\tisAtPropertyKey: boolean;\n}\n\nexport interface ParseOptions {\n\tdisallowComments?: boolean;\n\tallowTrailingComma?: boolean;\n}\n\nexport namespace ParseOptions {\n\texport const DEFAULT = {\n\t\tallowTrailingComma: true\n\t};\n}\n\nexport interface JSONVisitor {\n\t/**\n\t * Invoked when an open brace is encountered and an object is started. The offset and length represent the location of the open brace.\n\t */\n\tonObjectBegin?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a property is encountered. The offset and length represent the location of the property name.\n\t */\n\tonObjectProperty?: (property: string, offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a closing brace is encountered and an object is completed. The offset and length represent the location of the closing brace.\n\t */\n\tonObjectEnd?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when an open bracket is encountered. The offset and length represent the location of the open bracket.\n\t */\n\tonArrayBegin?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a closing bracket is encountered. The offset and length represent the location of the closing bracket.\n\t */\n\tonArrayEnd?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a literal value is encountered. The offset and length represent the location of the literal value.\n\t */\n\tonLiteralValue?: (value: any, offset: number, length: number) => void;\n\n\t/**\n\t * Invoked when a comma or colon separator is encountered. The offset and length represent the location of the separator.\n\t */\n\tonSeparator?: (character: string, offset: number, length: number) => void;\n\n\t/**\n\t * When comments are allowed, invoked when a line or block comment is encountered. The offset and length represent the location of the comment.\n\t */\n\tonComment?: (offset: number, length: number) => void;\n\n\t/**\n\t * Invoked on an error.\n\t */\n\tonError?: (error: ParseErrorCode, offset: number, length: number) => void;\n}\n\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport function createScanner(text: string, ignoreTrivia: boolean = false): JSONScanner {\n\n\tlet pos = 0,\n\t\tlen = text.length,\n\t\tvalue: string = '',\n\t\ttokenOffset = 0,\n\t\ttoken: SyntaxKind = SyntaxKind.Unknown,\n\t\tscanError: ScanError = ScanError.None;\n\n\tfunction scanHexDigits(count: number): number {\n\t\tlet digits = 0;\n\t\tlet value = 0;\n\t\twhile (digits < count) {\n\t\t\tconst ch = text.charCodeAt(pos);\n\t\t\tif (ch >= CharacterCodes._0 && ch <= CharacterCodes._9) {\n\t\t\t\tvalue = value * 16 + ch - CharacterCodes._0;\n\t\t\t}\n\t\t\telse if (ch >= CharacterCodes.A && ch <= CharacterCodes.F) {\n\t\t\t\tvalue = value * 16 + ch - CharacterCodes.A + 10;\n\t\t\t}\n\t\t\telse if (ch >= CharacterCodes.a && ch <= CharacterCodes.f) {\n\t\t\t\tvalue = value * 16 + ch - CharacterCodes.a + 10;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos++;\n\t\t\tdigits++;\n\t\t}\n\t\tif (digits < count) {\n\t\t\tvalue = -1;\n\t\t}\n\t\treturn value;\n\t}\n\n\tfunction setPosition(newPosition: number) {\n\t\tpos = newPosition;\n\t\tvalue = '';\n\t\ttokenOffset = 0;\n\t\ttoken = SyntaxKind.Unknown;\n\t\tscanError = ScanError.None;\n\t}\n\n\tfunction scanNumber(): string {\n\t\tconst start = pos;\n\t\tif (text.charCodeAt(pos) === CharacterCodes._0) {\n\t\t\tpos++;\n\t\t} else {\n\t\t\tpos++;\n\t\t\twhile (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\tif (pos < text.length && text.charCodeAt(pos) === CharacterCodes.dot) {\n\t\t\tpos++;\n\t\t\tif (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t\twhile (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tscanError = ScanError.UnexpectedEndOfNumber;\n\t\t\t\treturn text.substring(start, pos);\n\t\t\t}\n\t\t}\n\t\tlet end = pos;\n\t\tif (pos < text.length && (text.charCodeAt(pos) === CharacterCodes.E || text.charCodeAt(pos) === CharacterCodes.e)) {\n\t\t\tpos++;\n\t\t\tif (pos < text.length && text.charCodeAt(pos) === CharacterCodes.plus || text.charCodeAt(pos) === CharacterCodes.minus) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tif (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t\twhile (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\tend = pos;\n\t\t\t} else {\n\t\t\t\tscanError = ScanError.UnexpectedEndOfNumber;\n\t\t\t}\n\t\t}\n\t\treturn text.substring(start, end);\n\t}\n\n\tfunction scanString(): string {\n\n\t\tlet result = '',\n\t\t\tstart = pos;\n\n\t\twhile (true) {\n\t\t\tif (pos >= len) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tscanError = ScanError.UnexpectedEndOfString;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlet ch = text.charCodeAt(pos);\n\t\t\tif (ch === CharacterCodes.doubleQuote) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch === CharacterCodes.backslash) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tpos++;\n\t\t\t\tif (pos >= len) {\n\t\t\t\t\tscanError = ScanError.UnexpectedEndOfString;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tch = text.charCodeAt(pos++);\n\t\t\t\tswitch (ch) {\n\t\t\t\t\tcase CharacterCodes.doubleQuote:\n\t\t\t\t\t\tresult += '\\\"';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.backslash:\n\t\t\t\t\t\tresult += '\\\\';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.slash:\n\t\t\t\t\t\tresult += '/';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.b:\n\t\t\t\t\t\tresult += '\\b';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.f:\n\t\t\t\t\t\tresult += '\\f';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.n:\n\t\t\t\t\t\tresult += '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.r:\n\t\t\t\t\t\tresult += '\\r';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.t:\n\t\t\t\t\t\tresult += '\\t';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.u:\n\t\t\t\t\t\tconst ch = scanHexDigits(4);\n\t\t\t\t\t\tif (ch >= 0) {\n\t\t\t\t\t\t\tresult += String.fromCharCode(ch);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscanError = ScanError.InvalidUnicode;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tscanError = ScanError.InvalidEscapeCharacter;\n\t\t\t\t}\n\t\t\t\tstart = pos;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch >= 0 && ch <= 0x1F) {\n\t\t\t\tif (isLineBreak(ch)) {\n\t\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\t\tscanError = ScanError.UnexpectedEndOfString;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tscanError = ScanError.InvalidCharacter;\n\t\t\t\t\t// mark as error but continue with string\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction scanNext(): SyntaxKind {\n\n\t\tvalue = '';\n\t\tscanError = ScanError.None;\n\n\t\ttokenOffset = pos;\n\n\t\tif (pos >= len) {\n\t\t\t// at the end\n\t\t\ttokenOffset = len;\n\t\t\treturn token = SyntaxKind.EOF;\n\t\t}\n\n\t\tlet code = text.charCodeAt(pos);\n\t\t// trivia: whitespace\n\t\tif (isWhiteSpace(code)) {\n\t\t\tdo {\n\t\t\t\tpos++;\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tcode = text.charCodeAt(pos);\n\t\t\t} while (isWhiteSpace(code));\n\n\t\t\treturn token = SyntaxKind.Trivia;\n\t\t}\n\n\t\t// trivia: newlines\n\t\tif (isLineBreak(code)) {\n\t\t\tpos++;\n\t\t\tvalue += String.fromCharCode(code);\n\t\t\tif (code === CharacterCodes.carriageReturn && text.charCodeAt(pos) === CharacterCodes.lineFeed) {\n\t\t\t\tpos++;\n\t\t\t\tvalue += '\\n';\n\t\t\t}\n\t\t\treturn token = SyntaxKind.LineBreakTrivia;\n\t\t}\n\n\t\tswitch (code) {\n\t\t\t// tokens: []{}:,\n\t\t\tcase CharacterCodes.openBrace:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.OpenBraceToken;\n\t\t\tcase CharacterCodes.closeBrace:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.CloseBraceToken;\n\t\t\tcase CharacterCodes.openBracket:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.OpenBracketToken;\n\t\t\tcase CharacterCodes.closeBracket:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.CloseBracketToken;\n\t\t\tcase CharacterCodes.colon:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.ColonToken;\n\t\t\tcase CharacterCodes.comma:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.CommaToken;\n\n\t\t\t// strings\n\t\t\tcase CharacterCodes.doubleQuote:\n\t\t\t\tpos++;\n\t\t\t\tvalue = scanString();\n\t\t\t\treturn token = SyntaxKind.StringLiteral;\n\n\t\t\t// comments\n\t\t\tcase CharacterCodes.slash:\n\t\t\t\tconst start = pos - 1;\n\t\t\t\t// Single-line comment\n\t\t\t\tif (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\n\t\t\t\t\tpos += 2;\n\n\t\t\t\t\twhile (pos < len) {\n\t\t\t\t\t\tif (isLineBreak(text.charCodeAt(pos))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos++;\n\n\t\t\t\t\t}\n\t\t\t\t\tvalue = text.substring(start, pos);\n\t\t\t\t\treturn token = SyntaxKind.LineCommentTrivia;\n\t\t\t\t}\n\n\t\t\t\t// Multi-line comment\n\t\t\t\tif (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {\n\t\t\t\t\tpos += 2;\n\n\t\t\t\t\tconst safeLength = len - 1; // For lookahead.\n\t\t\t\t\tlet commentClosed = false;\n\t\t\t\t\twhile (pos < safeLength) {\n\t\t\t\t\t\tconst ch = text.charCodeAt(pos);\n\n\t\t\t\t\t\tif (ch === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\n\t\t\t\t\t\t\tpos += 2;\n\t\t\t\t\t\t\tcommentClosed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!commentClosed) {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tscanError = ScanError.UnexpectedEndOfComment;\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = text.substring(start, pos);\n\t\t\t\t\treturn token = SyntaxKind.BlockCommentTrivia;\n\t\t\t\t}\n\t\t\t\t// just a single slash\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.Unknown;\n\n\t\t\t// numbers\n\t\t\tcase CharacterCodes.minus:\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tpos++;\n\t\t\t\tif (pos === len || !isDigit(text.charCodeAt(pos))) {\n\t\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t\t\t}\n\t\t\t// found a minus, followed by a number so\n\t\t\t// we fall through to proceed with scanning\n\t\t\t// numbers\n\t\t\tcase CharacterCodes._0:\n\t\t\tcase CharacterCodes._1:\n\t\t\tcase CharacterCodes._2:\n\t\t\tcase CharacterCodes._3:\n\t\t\tcase CharacterCodes._4:\n\t\t\tcase CharacterCodes._5:\n\t\t\tcase CharacterCodes._6:\n\t\t\tcase CharacterCodes._7:\n\t\t\tcase CharacterCodes._8:\n\t\t\tcase CharacterCodes._9:\n\t\t\t\tvalue += scanNumber();\n\t\t\t\treturn token = SyntaxKind.NumericLiteral;\n\t\t\t// literals and unknown symbols\n\t\t\tdefault:\n\t\t\t\t// is a literal? Read the full word.\n\t\t\t\twhile (pos < len && isUnknownContentCharacter(code)) {\n\t\t\t\t\tpos++;\n\t\t\t\t\tcode = text.charCodeAt(pos);\n\t\t\t\t}\n\t\t\t\tif (tokenOffset !== pos) {\n\t\t\t\t\tvalue = text.substring(tokenOffset, pos);\n\t\t\t\t\t// keywords: true, false, null\n\t\t\t\t\tswitch (value) {\n\t\t\t\t\t\tcase 'true': return token = SyntaxKind.TrueKeyword;\n\t\t\t\t\t\tcase 'false': return token = SyntaxKind.FalseKeyword;\n\t\t\t\t\t\tcase 'null': return token = SyntaxKind.NullKeyword;\n\t\t\t\t\t}\n\t\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t\t\t}\n\t\t\t\t// some\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t}\n\t}\n\n\tfunction isUnknownContentCharacter(code: CharacterCodes) {\n\t\tif (isWhiteSpace(code) || isLineBreak(code)) {\n\t\t\treturn false;\n\t\t}\n\t\tswitch (code) {\n\t\t\tcase CharacterCodes.closeBrace:\n\t\t\tcase CharacterCodes.closeBracket:\n\t\t\tcase CharacterCodes.openBrace:\n\t\t\tcase CharacterCodes.openBracket:\n\t\t\tcase CharacterCodes.doubleQuote:\n\t\t\tcase CharacterCodes.colon:\n\t\t\tcase CharacterCodes.comma:\n\t\t\tcase CharacterCodes.slash:\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\n\tfunction scanNextNonTrivia(): SyntaxKind {\n\t\tlet result: SyntaxKind;\n\t\tdo {\n\t\t\tresult = scanNext();\n\t\t} while (result >= SyntaxKind.LineCommentTrivia && result <= SyntaxKind.Trivia);\n\t\treturn result;\n\t}\n\n\treturn {\n\t\tsetPosition: setPosition,\n\t\tgetPosition: () => pos,\n\t\tscan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n\t\tgetToken: () => token,\n\t\tgetTokenValue: () => value,\n\t\tgetTokenOffset: () => tokenOffset,\n\t\tgetTokenLength: () => pos - tokenOffset,\n\t\tgetTokenError: () => scanError\n\t};\n}\n\nfunction isWhiteSpace(ch: number): boolean {\n\treturn ch === CharacterCodes.space || ch === CharacterCodes.tab || ch === CharacterCodes.verticalTab || ch === CharacterCodes.formFeed ||\n\t\tch === CharacterCodes.nonBreakingSpace || ch === CharacterCodes.ogham || ch >= CharacterCodes.enQuad && ch <= CharacterCodes.zeroWidthSpace ||\n\t\tch === CharacterCodes.narrowNoBreakSpace || ch === CharacterCodes.mathematicalSpace || ch === CharacterCodes.ideographicSpace || ch === CharacterCodes.byteOrderMark;\n}\n\nfunction isLineBreak(ch: number): boolean {\n\treturn ch === CharacterCodes.lineFeed || ch === CharacterCodes.carriageReturn || ch === CharacterCodes.lineSeparator || ch === CharacterCodes.paragraphSeparator;\n}\n\nfunction isDigit(ch: number): boolean {\n\treturn ch >= CharacterCodes._0 && ch <= CharacterCodes._9;\n}\n\nconst enum CharacterCodes {\n\tnullCharacter = 0,\n\tmaxAsciiCharacter = 0x7F,\n\n\tlineFeed = 0x0A,              // \\n\n\tcarriageReturn = 0x0D,        // \\r\n\tlineSeparator = 0x2028,\n\tparagraphSeparator = 0x2029,\n\n\t// REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems\n\t// like an odd disparity?  (Or maybe it's completely fine for them to be different).\n\tnextLine = 0x0085,\n\n\t// Unicode 3.0 space characters\n\tspace = 0x0020,   // \" \"\n\tnonBreakingSpace = 0x00A0,   //\n\tenQuad = 0x2000,\n\temQuad = 0x2001,\n\tenSpace = 0x2002,\n\temSpace = 0x2003,\n\tthreePerEmSpace = 0x2004,\n\tfourPerEmSpace = 0x2005,\n\tsixPerEmSpace = 0x2006,\n\tfigureSpace = 0x2007,\n\tpunctuationSpace = 0x2008,\n\tthinSpace = 0x2009,\n\thairSpace = 0x200A,\n\tzeroWidthSpace = 0x200B,\n\tnarrowNoBreakSpace = 0x202F,\n\tideographicSpace = 0x3000,\n\tmathematicalSpace = 0x205F,\n\togham = 0x1680,\n\n\t_ = 0x5F,\n\t$ = 0x24,\n\n\t_0 = 0x30,\n\t_1 = 0x31,\n\t_2 = 0x32,\n\t_3 = 0x33,\n\t_4 = 0x34,\n\t_5 = 0x35,\n\t_6 = 0x36,\n\t_7 = 0x37,\n\t_8 = 0x38,\n\t_9 = 0x39,\n\n\ta = 0x61,\n\tb = 0x62,\n\tc = 0x63,\n\td = 0x64,\n\te = 0x65,\n\tf = 0x66,\n\tg = 0x67,\n\th = 0x68,\n\ti = 0x69,\n\tj = 0x6A,\n\tk = 0x6B,\n\tl = 0x6C,\n\tm = 0x6D,\n\tn = 0x6E,\n\to = 0x6F,\n\tp = 0x70,\n\tq = 0x71,\n\tr = 0x72,\n\ts = 0x73,\n\tt = 0x74,\n\tu = 0x75,\n\tv = 0x76,\n\tw = 0x77,\n\tx = 0x78,\n\ty = 0x79,\n\tz = 0x7A,\n\n\tA = 0x41,\n\tB = 0x42,\n\tC = 0x43,\n\tD = 0x44,\n\tE = 0x45,\n\tF = 0x46,\n\tG = 0x47,\n\tH = 0x48,\n\tI = 0x49,\n\tJ = 0x4A,\n\tK = 0x4B,\n\tL = 0x4C,\n\tM = 0x4D,\n\tN = 0x4E,\n\tO = 0x4F,\n\tP = 0x50,\n\tQ = 0x51,\n\tR = 0x52,\n\tS = 0x53,\n\tT = 0x54,\n\tU = 0x55,\n\tV = 0x56,\n\tW = 0x57,\n\tX = 0x58,\n\tY = 0x59,\n\tZ = 0x5A,\n\n\tampersand = 0x26,             // &\n\tasterisk = 0x2A,              // *\n\tat = 0x40,                    // @\n\tbackslash = 0x5C,             // \\\n\tbar = 0x7C,                   // |\n\tcaret = 0x5E,                 // ^\n\tcloseBrace = 0x7D,            // }\n\tcloseBracket = 0x5D,          // ]\n\tcloseParen = 0x29,            // )\n\tcolon = 0x3A,                 // :\n\tcomma = 0x2C,                 // ,\n\tdot = 0x2E,                   // .\n\tdoubleQuote = 0x22,           // \"\n\tequals = 0x3D,                // =\n\texclamation = 0x21,           // !\n\tgreaterThan = 0x3E,           // >\n\tlessThan = 0x3C,              // <\n\tminus = 0x2D,                 // -\n\topenBrace = 0x7B,             // {\n\topenBracket = 0x5B,           // [\n\topenParen = 0x28,             // (\n\tpercent = 0x25,               // %\n\tplus = 0x2B,                  // +\n\tquestion = 0x3F,              // ?\n\tsemicolon = 0x3B,             // ;\n\tsingleQuote = 0x27,           // '\n\tslash = 0x2F,                 // /\n\ttilde = 0x7E,                 // ~\n\n\tbackspace = 0x08,             // \\b\n\tformFeed = 0x0C,              // \\f\n\tbyteOrderMark = 0xFEFF,\n\ttab = 0x09,                   // \\t\n\tverticalTab = 0x0B,           // \\v\n}\n\ninterface NodeImpl extends Node {\n\ttype: NodeType;\n\tvalue?: any;\n\toffset: number;\n\tlength: number;\n\tcolonOffset?: number;\n\tparent?: NodeImpl;\n\tchildren?: NodeImpl[];\n}\n\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport function getLocation(text: string, position: number): Location {\n\tconst segments: Segment[] = []; // strings or numbers\n\tconst earlyReturnException = new Object();\n\tlet previousNode: NodeImpl | undefined = undefined;\n\tconst previousNodeInst: NodeImpl = {\n\t\tvalue: {},\n\t\toffset: 0,\n\t\tlength: 0,\n\t\ttype: 'object',\n\t\tparent: undefined\n\t};\n\tlet isAtPropertyKey = false;\n\tfunction setPreviousNode(value: string, offset: number, length: number, type: NodeType) {\n\t\tpreviousNodeInst.value = value;\n\t\tpreviousNodeInst.offset = offset;\n\t\tpreviousNodeInst.length = length;\n\t\tpreviousNodeInst.type = type;\n\t\tpreviousNodeInst.colonOffset = undefined;\n\t\tpreviousNode = previousNodeInst;\n\t}\n\ttry {\n\n\t\tvisit(text, {\n\t\t\tonObjectBegin: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = undefined;\n\t\t\t\tisAtPropertyKey = position > offset;\n\t\t\t\tsegments.push(''); // push a placeholder (will be replaced)\n\t\t\t},\n\t\t\tonObjectProperty: (name: string, offset: number, length: number) => {\n\t\t\t\tif (position < offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tsetPreviousNode(name, offset, length, 'property');\n\t\t\t\tsegments[segments.length - 1] = name;\n\t\t\t\tif (position <= offset + length) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonObjectEnd: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = undefined;\n\t\t\t\tsegments.pop();\n\t\t\t},\n\t\t\tonArrayBegin: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = undefined;\n\t\t\t\tsegments.push(0);\n\t\t\t},\n\t\t\tonArrayEnd: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = undefined;\n\t\t\t\tsegments.pop();\n\t\t\t},\n\t\t\tonLiteralValue: (value: any, offset: number, length: number) => {\n\t\t\t\tif (position < offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tsetPreviousNode(value, offset, length, getLiteralNodeType(value));\n\n\t\t\t\tif (position <= offset + length) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonSeparator: (sep: string, offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tif (sep === ':' && previousNode && previousNode.type === 'property') {\n\t\t\t\t\tpreviousNode.colonOffset = offset;\n\t\t\t\t\tisAtPropertyKey = false;\n\t\t\t\t\tpreviousNode = undefined;\n\t\t\t\t} else if (sep === ',') {\n\t\t\t\t\tconst last = segments[segments.length - 1];\n\t\t\t\t\tif (typeof last === 'number') {\n\t\t\t\t\t\tsegments[segments.length - 1] = last + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisAtPropertyKey = true;\n\t\t\t\t\t\tsegments[segments.length - 1] = '';\n\t\t\t\t\t}\n\t\t\t\t\tpreviousNode = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t} catch (e) {\n\t\tif (e !== earlyReturnException) {\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\treturn {\n\t\tpath: segments,\n\t\tpreviousNode,\n\t\tisAtPropertyKey,\n\t\tmatches: (pattern: Segment[]) => {\n\t\t\tlet k = 0;\n\t\t\tfor (let i = 0; k < pattern.length && i < segments.length; i++) {\n\t\t\t\tif (pattern[k] === segments[i] || pattern[k] === '*') {\n\t\t\t\t\tk++;\n\t\t\t\t} else if (pattern[k] !== '**') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn k === pattern.length;\n\t\t}\n\t};\n}\n\n\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport function parse(text: string, errors: ParseError[] = [], options: ParseOptions = ParseOptions.DEFAULT): any {\n\tlet currentProperty: string | null = null;\n\tlet currentParent: any = [];\n\tconst previousParents: any[] = [];\n\n\tfunction onValue(value: any) {\n\t\tif (Array.isArray(currentParent)) {\n\t\t\t(<any[]>currentParent).push(value);\n\t\t} else if (currentProperty) {\n\t\t\tcurrentParent[currentProperty] = value;\n\t\t}\n\t}\n\n\tconst visitor: JSONVisitor = {\n\t\tonObjectBegin: () => {\n\t\t\tconst object = {};\n\t\t\tonValue(object);\n\t\t\tpreviousParents.push(currentParent);\n\t\t\tcurrentParent = object;\n\t\t\tcurrentProperty = null;\n\t\t},\n\t\tonObjectProperty: (name: string) => {\n\t\t\tcurrentProperty = name;\n\t\t},\n\t\tonObjectEnd: () => {\n\t\t\tcurrentParent = previousParents.pop();\n\t\t},\n\t\tonArrayBegin: () => {\n\t\t\tconst array: any[] = [];\n\t\t\tonValue(array);\n\t\t\tpreviousParents.push(currentParent);\n\t\t\tcurrentParent = array;\n\t\t\tcurrentProperty = null;\n\t\t},\n\t\tonArrayEnd: () => {\n\t\t\tcurrentParent = previousParents.pop();\n\t\t},\n\t\tonLiteralValue: onValue,\n\t\tonError: (error: ParseErrorCode, offset: number, length: number) => {\n\t\t\terrors.push({ error, offset, length });\n\t\t}\n\t};\n\tvisit(text, visitor, options);\n\treturn currentParent[0];\n}\n\n\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport function parseTree(text: string, errors: ParseError[] = [], options: ParseOptions = ParseOptions.DEFAULT): Node {\n\tlet currentParent: NodeImpl = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root\n\n\tfunction ensurePropertyComplete(endOffset: number) {\n\t\tif (currentParent.type === 'property') {\n\t\t\tcurrentParent.length = endOffset - currentParent.offset;\n\t\t\tcurrentParent = currentParent.parent!;\n\t\t}\n\t}\n\n\tfunction onValue(valueNode: Node): Node {\n\t\tcurrentParent.children!.push(valueNode);\n\t\treturn valueNode;\n\t}\n\n\tconst visitor: JSONVisitor = {\n\t\tonObjectBegin: (offset: number) => {\n\t\t\tcurrentParent = onValue({ type: 'object', offset, length: -1, parent: currentParent, children: [] });\n\t\t},\n\t\tonObjectProperty: (name: string, offset: number, length: number) => {\n\t\t\tcurrentParent = onValue({ type: 'property', offset, length: -1, parent: currentParent, children: [] });\n\t\t\tcurrentParent.children!.push({ type: 'string', value: name, offset, length, parent: currentParent });\n\t\t},\n\t\tonObjectEnd: (offset: number, length: number) => {\n\t\t\tcurrentParent.length = offset + length - currentParent.offset;\n\t\t\tcurrentParent = currentParent.parent!;\n\t\t\tensurePropertyComplete(offset + length);\n\t\t},\n\t\tonArrayBegin: (offset: number, length: number) => {\n\t\t\tcurrentParent = onValue({ type: 'array', offset, length: -1, parent: currentParent, children: [] });\n\t\t},\n\t\tonArrayEnd: (offset: number, length: number) => {\n\t\t\tcurrentParent.length = offset + length - currentParent.offset;\n\t\t\tcurrentParent = currentParent.parent!;\n\t\t\tensurePropertyComplete(offset + length);\n\t\t},\n\t\tonLiteralValue: (value: any, offset: number, length: number) => {\n\t\t\tonValue({ type: getLiteralNodeType(value), offset, length, parent: currentParent, value });\n\t\t\tensurePropertyComplete(offset + length);\n\t\t},\n\t\tonSeparator: (sep: string, offset: number, length: number) => {\n\t\t\tif (currentParent.type === 'property') {\n\t\t\t\tif (sep === ':') {\n\t\t\t\t\tcurrentParent.colonOffset = offset;\n\t\t\t\t} else if (sep === ',') {\n\t\t\t\t\tensurePropertyComplete(offset);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tonError: (error: ParseErrorCode, offset: number, length: number) => {\n\t\t\terrors.push({ error, offset, length });\n\t\t}\n\t};\n\tvisit(text, visitor, options);\n\n\tconst result = currentParent.children![0];\n\tif (result) {\n\t\tdelete result.parent;\n\t}\n\treturn result;\n}\n\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport function findNodeAtLocation(root: Node, path: JSONPath): Node | undefined {\n\tif (!root) {\n\t\treturn undefined;\n\t}\n\tlet node = root;\n\tfor (let segment of path) {\n\t\tif (typeof segment === 'string') {\n\t\t\tif (node.type !== 'object' || !Array.isArray(node.children)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tlet found = false;\n\t\t\tfor (const propertyNode of node.children) {\n\t\t\t\tif (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n\t\t\t\t\tnode = propertyNode.children[1];\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tconst index = <number>segment;\n\t\t\tif (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tnode = node.children[index];\n\t\t}\n\t}\n\treturn node;\n}\n\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport function getNodePath(node: Node): JSONPath {\n\tif (!node.parent || !node.parent.children) {\n\t\treturn [];\n\t}\n\tconst path = getNodePath(node.parent);\n\tif (node.parent.type === 'property') {\n\t\tconst key = node.parent.children[0].value;\n\t\tpath.push(key);\n\t} else if (node.parent.type === 'array') {\n\t\tconst index = node.parent.children.indexOf(node);\n\t\tif (index !== -1) {\n\t\t\tpath.push(index);\n\t\t}\n\t}\n\treturn path;\n}\n\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport function getNodeValue(node: Node): any {\n\tswitch (node.type) {\n\t\tcase 'array':\n\t\t\treturn node.children!.map(getNodeValue);\n\t\tcase 'object':\n\t\t\tconst obj = Object.create(null);\n\t\t\tfor (let prop of node.children!) {\n\t\t\t\tconst valueNode = prop.children![1];\n\t\t\t\tif (valueNode) {\n\t\t\t\t\tobj[prop.children![0].value] = getNodeValue(valueNode);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn obj;\n\t\tcase 'null':\n\t\tcase 'string':\n\t\tcase 'number':\n\t\tcase 'boolean':\n\t\t\treturn node.value;\n\t\tdefault:\n\t\t\treturn undefined;\n\t}\n\n}\n\nexport function contains(node: Node, offset: number, includeRightBound = false): boolean {\n\treturn (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n}\n\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport function findNodeAtOffset(node: Node, offset: number, includeRightBound = false): Node | undefined {\n\tif (contains(node, offset, includeRightBound)) {\n\t\tconst children = node.children;\n\t\tif (Array.isArray(children)) {\n\t\t\tfor (let i = 0; i < children.length && children[i].offset <= offset; i++) {\n\t\t\t\tconst item = findNodeAtOffset(children[i], offset, includeRightBound);\n\t\t\t\tif (item) {\n\t\t\t\t\treturn item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport function visit(text: string, visitor: JSONVisitor, options: ParseOptions = ParseOptions.DEFAULT): any {\n\n\tconst _scanner = createScanner(text, false);\n\n\tfunction toNoArgVisit(visitFunction?: (offset: number, length: number) => void): () => void {\n\t\treturn visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;\n\t}\n\tfunction toOneArgVisit<T>(visitFunction?: (arg: T, offset: number, length: number) => void): (arg: T) => void {\n\t\treturn visitFunction ? (arg: T) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;\n\t}\n\n\tconst onObjectBegin = toNoArgVisit(visitor.onObjectBegin),\n\t\tonObjectProperty = toOneArgVisit(visitor.onObjectProperty),\n\t\tonObjectEnd = toNoArgVisit(visitor.onObjectEnd),\n\t\tonArrayBegin = toNoArgVisit(visitor.onArrayBegin),\n\t\tonArrayEnd = toNoArgVisit(visitor.onArrayEnd),\n\t\tonLiteralValue = toOneArgVisit(visitor.onLiteralValue),\n\t\tonSeparator = toOneArgVisit(visitor.onSeparator),\n\t\tonComment = toNoArgVisit(visitor.onComment),\n\t\tonError = toOneArgVisit(visitor.onError);\n\n\tconst disallowComments = options && options.disallowComments;\n\tconst allowTrailingComma = options && options.allowTrailingComma;\n\tfunction scanNext(): SyntaxKind {\n\t\twhile (true) {\n\t\t\tconst token = _scanner.scan();\n\t\t\tswitch (_scanner.getTokenError()) {\n\t\t\t\tcase ScanError.InvalidUnicode:\n\t\t\t\t\thandleError(ParseErrorCode.InvalidUnicode);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.InvalidEscapeCharacter:\n\t\t\t\t\thandleError(ParseErrorCode.InvalidEscapeCharacter);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.UnexpectedEndOfNumber:\n\t\t\t\t\thandleError(ParseErrorCode.UnexpectedEndOfNumber);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.UnexpectedEndOfComment:\n\t\t\t\t\tif (!disallowComments) {\n\t\t\t\t\t\thandleError(ParseErrorCode.UnexpectedEndOfComment);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.UnexpectedEndOfString:\n\t\t\t\t\thandleError(ParseErrorCode.UnexpectedEndOfString);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ScanError.InvalidCharacter:\n\t\t\t\t\thandleError(ParseErrorCode.InvalidCharacter);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (token) {\n\t\t\t\tcase SyntaxKind.LineCommentTrivia:\n\t\t\t\tcase SyntaxKind.BlockCommentTrivia:\n\t\t\t\t\tif (disallowComments) {\n\t\t\t\t\t\thandleError(ParseErrorCode.InvalidCommentToken);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tonComment();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.Unknown:\n\t\t\t\t\thandleError(ParseErrorCode.InvalidSymbol);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.Trivia:\n\t\t\t\tcase SyntaxKind.LineBreakTrivia:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn token;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handleError(error: ParseErrorCode, skipUntilAfter: SyntaxKind[] = [], skipUntil: SyntaxKind[] = []): void {\n\t\tonError(error);\n\t\tif (skipUntilAfter.length + skipUntil.length > 0) {\n\t\t\tlet token = _scanner.getToken();\n\t\t\twhile (token !== SyntaxKind.EOF) {\n\t\t\t\tif (skipUntilAfter.indexOf(token) !== -1) {\n\t\t\t\t\tscanNext();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (skipUntil.indexOf(token) !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttoken = scanNext();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction parseString(isValue: boolean): boolean {\n\t\tconst value = _scanner.getTokenValue();\n\t\tif (isValue) {\n\t\t\tonLiteralValue(value);\n\t\t} else {\n\t\t\tonObjectProperty(value);\n\t\t}\n\t\tscanNext();\n\t\treturn true;\n\t}\n\n\tfunction parseLiteral(): boolean {\n\t\tswitch (_scanner.getToken()) {\n\t\t\tcase SyntaxKind.NumericLiteral:\n\t\t\t\tlet value = 0;\n\t\t\t\ttry {\n\t\t\t\t\tvalue = JSON.parse(_scanner.getTokenValue());\n\t\t\t\t\tif (typeof value !== 'number') {\n\t\t\t\t\t\thandleError(ParseErrorCode.InvalidNumberFormat);\n\t\t\t\t\t\tvalue = 0;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\thandleError(ParseErrorCode.InvalidNumberFormat);\n\t\t\t\t}\n\t\t\t\tonLiteralValue(value);\n\t\t\t\tbreak;\n\t\t\tcase SyntaxKind.NullKeyword:\n\t\t\t\tonLiteralValue(null);\n\t\t\t\tbreak;\n\t\t\tcase SyntaxKind.TrueKeyword:\n\t\t\t\tonLiteralValue(true);\n\t\t\t\tbreak;\n\t\t\tcase SyntaxKind.FalseKeyword:\n\t\t\t\tonLiteralValue(false);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t\tscanNext();\n\t\treturn true;\n\t}\n\n\tfunction parseProperty(): boolean {\n\t\tif (_scanner.getToken() !== SyntaxKind.StringLiteral) {\n\t\t\thandleError(ParseErrorCode.PropertyNameExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n\t\t\treturn false;\n\t\t}\n\t\tparseString(false);\n\t\tif (_scanner.getToken() === SyntaxKind.ColonToken) {\n\t\t\tonSeparator(':');\n\t\t\tscanNext(); // consume colon\n\n\t\t\tif (!parseValue()) {\n\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n\t\t\t}\n\t\t} else {\n\t\t\thandleError(ParseErrorCode.ColonExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction parseObject(): boolean {\n\t\tonObjectBegin();\n\t\tscanNext(); // consume open brace\n\n\t\tlet needsComma = false;\n\t\twhile (_scanner.getToken() !== SyntaxKind.CloseBraceToken && _scanner.getToken() !== SyntaxKind.EOF) {\n\t\t\tif (_scanner.getToken() === SyntaxKind.CommaToken) {\n\t\t\t\tif (!needsComma) {\n\t\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], []);\n\t\t\t\t}\n\t\t\t\tonSeparator(',');\n\t\t\t\tscanNext(); // consume comma\n\t\t\t\tif (_scanner.getToken() === SyntaxKind.CloseBraceToken && allowTrailingComma) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (needsComma) {\n\t\t\t\thandleError(ParseErrorCode.CommaExpected, [], []);\n\t\t\t}\n\t\t\tif (!parseProperty()) {\n\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n\t\t\t}\n\t\t\tneedsComma = true;\n\t\t}\n\t\tonObjectEnd();\n\t\tif (_scanner.getToken() !== SyntaxKind.CloseBraceToken) {\n\t\t\thandleError(ParseErrorCode.CloseBraceExpected, [SyntaxKind.CloseBraceToken], []);\n\t\t} else {\n\t\t\tscanNext(); // consume close brace\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction parseArray(): boolean {\n\t\tonArrayBegin();\n\t\tscanNext(); // consume open bracket\n\n\t\tlet needsComma = false;\n\t\twhile (_scanner.getToken() !== SyntaxKind.CloseBracketToken && _scanner.getToken() !== SyntaxKind.EOF) {\n\t\t\tif (_scanner.getToken() === SyntaxKind.CommaToken) {\n\t\t\t\tif (!needsComma) {\n\t\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], []);\n\t\t\t\t}\n\t\t\t\tonSeparator(',');\n\t\t\t\tscanNext(); // consume comma\n\t\t\t\tif (_scanner.getToken() === SyntaxKind.CloseBracketToken && allowTrailingComma) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (needsComma) {\n\t\t\t\thandleError(ParseErrorCode.CommaExpected, [], []);\n\t\t\t}\n\t\t\tif (!parseValue()) {\n\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBracketToken, SyntaxKind.CommaToken]);\n\t\t\t}\n\t\t\tneedsComma = true;\n\t\t}\n\t\tonArrayEnd();\n\t\tif (_scanner.getToken() !== SyntaxKind.CloseBracketToken) {\n\t\t\thandleError(ParseErrorCode.CloseBracketExpected, [SyntaxKind.CloseBracketToken], []);\n\t\t} else {\n\t\t\tscanNext(); // consume close bracket\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction parseValue(): boolean {\n\t\tswitch (_scanner.getToken()) {\n\t\t\tcase SyntaxKind.OpenBracketToken:\n\t\t\t\treturn parseArray();\n\t\t\tcase SyntaxKind.OpenBraceToken:\n\t\t\t\treturn parseObject();\n\t\t\tcase SyntaxKind.StringLiteral:\n\t\t\t\treturn parseString(true);\n\t\t\tdefault:\n\t\t\t\treturn parseLiteral();\n\t\t}\n\t}\n\n\tscanNext();\n\tif (_scanner.getToken() === SyntaxKind.EOF) {\n\t\treturn true;\n\t}\n\tif (!parseValue()) {\n\t\thandleError(ParseErrorCode.ValueExpected, [], []);\n\t\treturn false;\n\t}\n\tif (_scanner.getToken() !== SyntaxKind.EOF) {\n\t\thandleError(ParseErrorCode.EndOfFileExpected, [], []);\n\t}\n\treturn true;\n}\n\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport function stripComments(text: string, replaceCh?: string): string {\n\n\tlet _scanner = createScanner(text),\n\t\tparts: string[] = [],\n\t\tkind: SyntaxKind,\n\t\toffset = 0,\n\t\tpos: number;\n\n\tdo {\n\t\tpos = _scanner.getPosition();\n\t\tkind = _scanner.scan();\n\t\tswitch (kind) {\n\t\t\tcase SyntaxKind.LineCommentTrivia:\n\t\t\tcase SyntaxKind.BlockCommentTrivia:\n\t\t\tcase SyntaxKind.EOF:\n\t\t\t\tif (offset !== pos) {\n\t\t\t\t\tparts.push(text.substring(offset, pos));\n\t\t\t\t}\n\t\t\t\tif (replaceCh !== undefined) {\n\t\t\t\t\tparts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n\t\t\t\t}\n\t\t\t\toffset = _scanner.getPosition();\n\t\t\t\tbreak;\n\t\t}\n\t} while (kind !== SyntaxKind.EOF);\n\n\treturn parts.join('');\n}\n\nfunction getLiteralNodeType(value: any): NodeType {\n\tswitch (typeof value) {\n\t\tcase 'boolean': return 'boolean';\n\t\tcase 'number': return 'number';\n\t\tcase 'string': return 'string';\n\t\tdefault: return 'null';\n\t}\n}"]}]}