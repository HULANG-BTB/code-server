{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/json.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/json.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var ScanError;\n    (function (ScanError) {\n        ScanError[ScanError[\"None\"] = 0] = \"None\";\n        ScanError[ScanError[\"UnexpectedEndOfComment\"] = 1] = \"UnexpectedEndOfComment\";\n        ScanError[ScanError[\"UnexpectedEndOfString\"] = 2] = \"UnexpectedEndOfString\";\n        ScanError[ScanError[\"UnexpectedEndOfNumber\"] = 3] = \"UnexpectedEndOfNumber\";\n        ScanError[ScanError[\"InvalidUnicode\"] = 4] = \"InvalidUnicode\";\n        ScanError[ScanError[\"InvalidEscapeCharacter\"] = 5] = \"InvalidEscapeCharacter\";\n        ScanError[ScanError[\"InvalidCharacter\"] = 6] = \"InvalidCharacter\";\n    })(ScanError = exports.ScanError || (exports.ScanError = {}));\n    var SyntaxKind;\n    (function (SyntaxKind) {\n        SyntaxKind[SyntaxKind[\"OpenBraceToken\"] = 1] = \"OpenBraceToken\";\n        SyntaxKind[SyntaxKind[\"CloseBraceToken\"] = 2] = \"CloseBraceToken\";\n        SyntaxKind[SyntaxKind[\"OpenBracketToken\"] = 3] = \"OpenBracketToken\";\n        SyntaxKind[SyntaxKind[\"CloseBracketToken\"] = 4] = \"CloseBracketToken\";\n        SyntaxKind[SyntaxKind[\"CommaToken\"] = 5] = \"CommaToken\";\n        SyntaxKind[SyntaxKind[\"ColonToken\"] = 6] = \"ColonToken\";\n        SyntaxKind[SyntaxKind[\"NullKeyword\"] = 7] = \"NullKeyword\";\n        SyntaxKind[SyntaxKind[\"TrueKeyword\"] = 8] = \"TrueKeyword\";\n        SyntaxKind[SyntaxKind[\"FalseKeyword\"] = 9] = \"FalseKeyword\";\n        SyntaxKind[SyntaxKind[\"StringLiteral\"] = 10] = \"StringLiteral\";\n        SyntaxKind[SyntaxKind[\"NumericLiteral\"] = 11] = \"NumericLiteral\";\n        SyntaxKind[SyntaxKind[\"LineCommentTrivia\"] = 12] = \"LineCommentTrivia\";\n        SyntaxKind[SyntaxKind[\"BlockCommentTrivia\"] = 13] = \"BlockCommentTrivia\";\n        SyntaxKind[SyntaxKind[\"LineBreakTrivia\"] = 14] = \"LineBreakTrivia\";\n        SyntaxKind[SyntaxKind[\"Trivia\"] = 15] = \"Trivia\";\n        SyntaxKind[SyntaxKind[\"Unknown\"] = 16] = \"Unknown\";\n        SyntaxKind[SyntaxKind[\"EOF\"] = 17] = \"EOF\";\n    })(SyntaxKind = exports.SyntaxKind || (exports.SyntaxKind = {}));\n    var ParseErrorCode;\n    (function (ParseErrorCode) {\n        ParseErrorCode[ParseErrorCode[\"InvalidSymbol\"] = 1] = \"InvalidSymbol\";\n        ParseErrorCode[ParseErrorCode[\"InvalidNumberFormat\"] = 2] = \"InvalidNumberFormat\";\n        ParseErrorCode[ParseErrorCode[\"PropertyNameExpected\"] = 3] = \"PropertyNameExpected\";\n        ParseErrorCode[ParseErrorCode[\"ValueExpected\"] = 4] = \"ValueExpected\";\n        ParseErrorCode[ParseErrorCode[\"ColonExpected\"] = 5] = \"ColonExpected\";\n        ParseErrorCode[ParseErrorCode[\"CommaExpected\"] = 6] = \"CommaExpected\";\n        ParseErrorCode[ParseErrorCode[\"CloseBraceExpected\"] = 7] = \"CloseBraceExpected\";\n        ParseErrorCode[ParseErrorCode[\"CloseBracketExpected\"] = 8] = \"CloseBracketExpected\";\n        ParseErrorCode[ParseErrorCode[\"EndOfFileExpected\"] = 9] = \"EndOfFileExpected\";\n        ParseErrorCode[ParseErrorCode[\"InvalidCommentToken\"] = 10] = \"InvalidCommentToken\";\n        ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfComment\"] = 11] = \"UnexpectedEndOfComment\";\n        ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfString\"] = 12] = \"UnexpectedEndOfString\";\n        ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfNumber\"] = 13] = \"UnexpectedEndOfNumber\";\n        ParseErrorCode[ParseErrorCode[\"InvalidUnicode\"] = 14] = \"InvalidUnicode\";\n        ParseErrorCode[ParseErrorCode[\"InvalidEscapeCharacter\"] = 15] = \"InvalidEscapeCharacter\";\n        ParseErrorCode[ParseErrorCode[\"InvalidCharacter\"] = 16] = \"InvalidCharacter\";\n    })(ParseErrorCode = exports.ParseErrorCode || (exports.ParseErrorCode = {}));\n    var ParseOptions;\n    (function (ParseOptions) {\n        ParseOptions.DEFAULT = {\n            allowTrailingComma: true\n        };\n    })(ParseOptions = exports.ParseOptions || (exports.ParseOptions = {}));\n    /**\n     * Creates a JSON scanner on the given text.\n     * If ignoreTrivia is set, whitespaces or comments are ignored.\n     */\n    function createScanner(text, ignoreTrivia = false) {\n        let pos = 0, len = text.length, value = '', tokenOffset = 0, token = SyntaxKind.Unknown, scanError = ScanError.None;\n        function scanHexDigits(count) {\n            let digits = 0;\n            let value = 0;\n            while (digits < count) {\n                const ch = text.charCodeAt(pos);\n                if (ch >= CharacterCodes._0 && ch <= CharacterCodes._9) {\n                    value = value * 16 + ch - CharacterCodes._0;\n                }\n                else if (ch >= CharacterCodes.A && ch <= CharacterCodes.F) {\n                    value = value * 16 + ch - CharacterCodes.A + 10;\n                }\n                else if (ch >= CharacterCodes.a && ch <= CharacterCodes.f) {\n                    value = value * 16 + ch - CharacterCodes.a + 10;\n                }\n                else {\n                    break;\n                }\n                pos++;\n                digits++;\n            }\n            if (digits < count) {\n                value = -1;\n            }\n            return value;\n        }\n        function setPosition(newPosition) {\n            pos = newPosition;\n            value = '';\n            tokenOffset = 0;\n            token = SyntaxKind.Unknown;\n            scanError = ScanError.None;\n        }\n        function scanNumber() {\n            const start = pos;\n            if (text.charCodeAt(pos) === CharacterCodes._0) {\n                pos++;\n            }\n            else {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n            }\n            if (pos < text.length && text.charCodeAt(pos) === CharacterCodes.dot) {\n                pos++;\n                if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                        pos++;\n                    }\n                }\n                else {\n                    scanError = ScanError.UnexpectedEndOfNumber;\n                    return text.substring(start, pos);\n                }\n            }\n            let end = pos;\n            if (pos < text.length && (text.charCodeAt(pos) === CharacterCodes.E || text.charCodeAt(pos) === CharacterCodes.e)) {\n                pos++;\n                if (pos < text.length && text.charCodeAt(pos) === CharacterCodes.plus || text.charCodeAt(pos) === CharacterCodes.minus) {\n                    pos++;\n                }\n                if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                        pos++;\n                    }\n                    end = pos;\n                }\n                else {\n                    scanError = ScanError.UnexpectedEndOfNumber;\n                }\n            }\n            return text.substring(start, end);\n        }\n        function scanString() {\n            let result = '', start = pos;\n            while (true) {\n                if (pos >= len) {\n                    result += text.substring(start, pos);\n                    scanError = ScanError.UnexpectedEndOfString;\n                    break;\n                }\n                let ch = text.charCodeAt(pos);\n                if (ch === CharacterCodes.doubleQuote) {\n                    result += text.substring(start, pos);\n                    pos++;\n                    break;\n                }\n                if (ch === CharacterCodes.backslash) {\n                    result += text.substring(start, pos);\n                    pos++;\n                    if (pos >= len) {\n                        scanError = ScanError.UnexpectedEndOfString;\n                        break;\n                    }\n                    ch = text.charCodeAt(pos++);\n                    switch (ch) {\n                        case CharacterCodes.doubleQuote:\n                            result += '\\\"';\n                            break;\n                        case CharacterCodes.backslash:\n                            result += '\\\\';\n                            break;\n                        case CharacterCodes.slash:\n                            result += '/';\n                            break;\n                        case CharacterCodes.b:\n                            result += '\\b';\n                            break;\n                        case CharacterCodes.f:\n                            result += '\\f';\n                            break;\n                        case CharacterCodes.n:\n                            result += '\\n';\n                            break;\n                        case CharacterCodes.r:\n                            result += '\\r';\n                            break;\n                        case CharacterCodes.t:\n                            result += '\\t';\n                            break;\n                        case CharacterCodes.u:\n                            const ch = scanHexDigits(4);\n                            if (ch >= 0) {\n                                result += String.fromCharCode(ch);\n                            }\n                            else {\n                                scanError = ScanError.InvalidUnicode;\n                            }\n                            break;\n                        default:\n                            scanError = ScanError.InvalidEscapeCharacter;\n                    }\n                    start = pos;\n                    continue;\n                }\n                if (ch >= 0 && ch <= 0x1F) {\n                    if (isLineBreak(ch)) {\n                        result += text.substring(start, pos);\n                        scanError = ScanError.UnexpectedEndOfString;\n                        break;\n                    }\n                    else {\n                        scanError = ScanError.InvalidCharacter;\n                        // mark as error but continue with string\n                    }\n                }\n                pos++;\n            }\n            return result;\n        }\n        function scanNext() {\n            value = '';\n            scanError = ScanError.None;\n            tokenOffset = pos;\n            if (pos >= len) {\n                // at the end\n                tokenOffset = len;\n                return token = SyntaxKind.EOF;\n            }\n            let code = text.charCodeAt(pos);\n            // trivia: whitespace\n            if (isWhiteSpace(code)) {\n                do {\n                    pos++;\n                    value += String.fromCharCode(code);\n                    code = text.charCodeAt(pos);\n                } while (isWhiteSpace(code));\n                return token = SyntaxKind.Trivia;\n            }\n            // trivia: newlines\n            if (isLineBreak(code)) {\n                pos++;\n                value += String.fromCharCode(code);\n                if (code === CharacterCodes.carriageReturn && text.charCodeAt(pos) === CharacterCodes.lineFeed) {\n                    pos++;\n                    value += '\\n';\n                }\n                return token = SyntaxKind.LineBreakTrivia;\n            }\n            switch (code) {\n                // tokens: []{}:,\n                case CharacterCodes.openBrace:\n                    pos++;\n                    return token = SyntaxKind.OpenBraceToken;\n                case CharacterCodes.closeBrace:\n                    pos++;\n                    return token = SyntaxKind.CloseBraceToken;\n                case CharacterCodes.openBracket:\n                    pos++;\n                    return token = SyntaxKind.OpenBracketToken;\n                case CharacterCodes.closeBracket:\n                    pos++;\n                    return token = SyntaxKind.CloseBracketToken;\n                case CharacterCodes.colon:\n                    pos++;\n                    return token = SyntaxKind.ColonToken;\n                case CharacterCodes.comma:\n                    pos++;\n                    return token = SyntaxKind.CommaToken;\n                // strings\n                case CharacterCodes.doubleQuote:\n                    pos++;\n                    value = scanString();\n                    return token = SyntaxKind.StringLiteral;\n                // comments\n                case CharacterCodes.slash:\n                    const start = pos - 1;\n                    // Single-line comment\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\n                        pos += 2;\n                        while (pos < len) {\n                            if (isLineBreak(text.charCodeAt(pos))) {\n                                break;\n                            }\n                            pos++;\n                        }\n                        value = text.substring(start, pos);\n                        return token = SyntaxKind.LineCommentTrivia;\n                    }\n                    // Multi-line comment\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {\n                        pos += 2;\n                        const safeLength = len - 1; // For lookahead.\n                        let commentClosed = false;\n                        while (pos < safeLength) {\n                            const ch = text.charCodeAt(pos);\n                            if (ch === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\n                                pos += 2;\n                                commentClosed = true;\n                                break;\n                            }\n                            pos++;\n                        }\n                        if (!commentClosed) {\n                            pos++;\n                            scanError = ScanError.UnexpectedEndOfComment;\n                        }\n                        value = text.substring(start, pos);\n                        return token = SyntaxKind.BlockCommentTrivia;\n                    }\n                    // just a single slash\n                    value += String.fromCharCode(code);\n                    pos++;\n                    return token = SyntaxKind.Unknown;\n                // numbers\n                case CharacterCodes.minus:\n                    value += String.fromCharCode(code);\n                    pos++;\n                    if (pos === len || !isDigit(text.charCodeAt(pos))) {\n                        return token = SyntaxKind.Unknown;\n                    }\n                // found a minus, followed by a number so\n                // we fall through to proceed with scanning\n                // numbers\n                case CharacterCodes._0:\n                case CharacterCodes._1:\n                case CharacterCodes._2:\n                case CharacterCodes._3:\n                case CharacterCodes._4:\n                case CharacterCodes._5:\n                case CharacterCodes._6:\n                case CharacterCodes._7:\n                case CharacterCodes._8:\n                case CharacterCodes._9:\n                    value += scanNumber();\n                    return token = SyntaxKind.NumericLiteral;\n                // literals and unknown symbols\n                default:\n                    // is a literal? Read the full word.\n                    while (pos < len && isUnknownContentCharacter(code)) {\n                        pos++;\n                        code = text.charCodeAt(pos);\n                    }\n                    if (tokenOffset !== pos) {\n                        value = text.substring(tokenOffset, pos);\n                        // keywords: true, false, null\n                        switch (value) {\n                            case 'true': return token = SyntaxKind.TrueKeyword;\n                            case 'false': return token = SyntaxKind.FalseKeyword;\n                            case 'null': return token = SyntaxKind.NullKeyword;\n                        }\n                        return token = SyntaxKind.Unknown;\n                    }\n                    // some\n                    value += String.fromCharCode(code);\n                    pos++;\n                    return token = SyntaxKind.Unknown;\n            }\n        }\n        function isUnknownContentCharacter(code) {\n            if (isWhiteSpace(code) || isLineBreak(code)) {\n                return false;\n            }\n            switch (code) {\n                case CharacterCodes.closeBrace:\n                case CharacterCodes.closeBracket:\n                case CharacterCodes.openBrace:\n                case CharacterCodes.openBracket:\n                case CharacterCodes.doubleQuote:\n                case CharacterCodes.colon:\n                case CharacterCodes.comma:\n                case CharacterCodes.slash:\n                    return false;\n            }\n            return true;\n        }\n        function scanNextNonTrivia() {\n            let result;\n            do {\n                result = scanNext();\n            } while (result >= SyntaxKind.LineCommentTrivia && result <= SyntaxKind.Trivia);\n            return result;\n        }\n        return {\n            setPosition: setPosition,\n            getPosition: () => pos,\n            scan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n            getToken: () => token,\n            getTokenValue: () => value,\n            getTokenOffset: () => tokenOffset,\n            getTokenLength: () => pos - tokenOffset,\n            getTokenError: () => scanError\n        };\n    }\n    exports.createScanner = createScanner;\n    function isWhiteSpace(ch) {\n        return ch === CharacterCodes.space || ch === CharacterCodes.tab || ch === CharacterCodes.verticalTab || ch === CharacterCodes.formFeed ||\n            ch === CharacterCodes.nonBreakingSpace || ch === CharacterCodes.ogham || ch >= CharacterCodes.enQuad && ch <= CharacterCodes.zeroWidthSpace ||\n            ch === CharacterCodes.narrowNoBreakSpace || ch === CharacterCodes.mathematicalSpace || ch === CharacterCodes.ideographicSpace || ch === CharacterCodes.byteOrderMark;\n    }\n    function isLineBreak(ch) {\n        return ch === CharacterCodes.lineFeed || ch === CharacterCodes.carriageReturn || ch === CharacterCodes.lineSeparator || ch === CharacterCodes.paragraphSeparator;\n    }\n    function isDigit(ch) {\n        return ch >= CharacterCodes._0 && ch <= CharacterCodes._9;\n    }\n    var CharacterCodes;\n    (function (CharacterCodes) {\n        CharacterCodes[CharacterCodes[\"nullCharacter\"] = 0] = \"nullCharacter\";\n        CharacterCodes[CharacterCodes[\"maxAsciiCharacter\"] = 127] = \"maxAsciiCharacter\";\n        CharacterCodes[CharacterCodes[\"lineFeed\"] = 10] = \"lineFeed\";\n        CharacterCodes[CharacterCodes[\"carriageReturn\"] = 13] = \"carriageReturn\";\n        CharacterCodes[CharacterCodes[\"lineSeparator\"] = 8232] = \"lineSeparator\";\n        CharacterCodes[CharacterCodes[\"paragraphSeparator\"] = 8233] = \"paragraphSeparator\";\n        // REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems\n        // like an odd disparity?  (Or maybe it's completely fine for them to be different).\n        CharacterCodes[CharacterCodes[\"nextLine\"] = 133] = \"nextLine\";\n        // Unicode 3.0 space characters\n        CharacterCodes[CharacterCodes[\"space\"] = 32] = \"space\";\n        CharacterCodes[CharacterCodes[\"nonBreakingSpace\"] = 160] = \"nonBreakingSpace\";\n        CharacterCodes[CharacterCodes[\"enQuad\"] = 8192] = \"enQuad\";\n        CharacterCodes[CharacterCodes[\"emQuad\"] = 8193] = \"emQuad\";\n        CharacterCodes[CharacterCodes[\"enSpace\"] = 8194] = \"enSpace\";\n        CharacterCodes[CharacterCodes[\"emSpace\"] = 8195] = \"emSpace\";\n        CharacterCodes[CharacterCodes[\"threePerEmSpace\"] = 8196] = \"threePerEmSpace\";\n        CharacterCodes[CharacterCodes[\"fourPerEmSpace\"] = 8197] = \"fourPerEmSpace\";\n        CharacterCodes[CharacterCodes[\"sixPerEmSpace\"] = 8198] = \"sixPerEmSpace\";\n        CharacterCodes[CharacterCodes[\"figureSpace\"] = 8199] = \"figureSpace\";\n        CharacterCodes[CharacterCodes[\"punctuationSpace\"] = 8200] = \"punctuationSpace\";\n        CharacterCodes[CharacterCodes[\"thinSpace\"] = 8201] = \"thinSpace\";\n        CharacterCodes[CharacterCodes[\"hairSpace\"] = 8202] = \"hairSpace\";\n        CharacterCodes[CharacterCodes[\"zeroWidthSpace\"] = 8203] = \"zeroWidthSpace\";\n        CharacterCodes[CharacterCodes[\"narrowNoBreakSpace\"] = 8239] = \"narrowNoBreakSpace\";\n        CharacterCodes[CharacterCodes[\"ideographicSpace\"] = 12288] = \"ideographicSpace\";\n        CharacterCodes[CharacterCodes[\"mathematicalSpace\"] = 8287] = \"mathematicalSpace\";\n        CharacterCodes[CharacterCodes[\"ogham\"] = 5760] = \"ogham\";\n        CharacterCodes[CharacterCodes[\"_\"] = 95] = \"_\";\n        CharacterCodes[CharacterCodes[\"$\"] = 36] = \"$\";\n        CharacterCodes[CharacterCodes[\"_0\"] = 48] = \"_0\";\n        CharacterCodes[CharacterCodes[\"_1\"] = 49] = \"_1\";\n        CharacterCodes[CharacterCodes[\"_2\"] = 50] = \"_2\";\n        CharacterCodes[CharacterCodes[\"_3\"] = 51] = \"_3\";\n        CharacterCodes[CharacterCodes[\"_4\"] = 52] = \"_4\";\n        CharacterCodes[CharacterCodes[\"_5\"] = 53] = \"_5\";\n        CharacterCodes[CharacterCodes[\"_6\"] = 54] = \"_6\";\n        CharacterCodes[CharacterCodes[\"_7\"] = 55] = \"_7\";\n        CharacterCodes[CharacterCodes[\"_8\"] = 56] = \"_8\";\n        CharacterCodes[CharacterCodes[\"_9\"] = 57] = \"_9\";\n        CharacterCodes[CharacterCodes[\"a\"] = 97] = \"a\";\n        CharacterCodes[CharacterCodes[\"b\"] = 98] = \"b\";\n        CharacterCodes[CharacterCodes[\"c\"] = 99] = \"c\";\n        CharacterCodes[CharacterCodes[\"d\"] = 100] = \"d\";\n        CharacterCodes[CharacterCodes[\"e\"] = 101] = \"e\";\n        CharacterCodes[CharacterCodes[\"f\"] = 102] = \"f\";\n        CharacterCodes[CharacterCodes[\"g\"] = 103] = \"g\";\n        CharacterCodes[CharacterCodes[\"h\"] = 104] = \"h\";\n        CharacterCodes[CharacterCodes[\"i\"] = 105] = \"i\";\n        CharacterCodes[CharacterCodes[\"j\"] = 106] = \"j\";\n        CharacterCodes[CharacterCodes[\"k\"] = 107] = \"k\";\n        CharacterCodes[CharacterCodes[\"l\"] = 108] = \"l\";\n        CharacterCodes[CharacterCodes[\"m\"] = 109] = \"m\";\n        CharacterCodes[CharacterCodes[\"n\"] = 110] = \"n\";\n        CharacterCodes[CharacterCodes[\"o\"] = 111] = \"o\";\n        CharacterCodes[CharacterCodes[\"p\"] = 112] = \"p\";\n        CharacterCodes[CharacterCodes[\"q\"] = 113] = \"q\";\n        CharacterCodes[CharacterCodes[\"r\"] = 114] = \"r\";\n        CharacterCodes[CharacterCodes[\"s\"] = 115] = \"s\";\n        CharacterCodes[CharacterCodes[\"t\"] = 116] = \"t\";\n        CharacterCodes[CharacterCodes[\"u\"] = 117] = \"u\";\n        CharacterCodes[CharacterCodes[\"v\"] = 118] = \"v\";\n        CharacterCodes[CharacterCodes[\"w\"] = 119] = \"w\";\n        CharacterCodes[CharacterCodes[\"x\"] = 120] = \"x\";\n        CharacterCodes[CharacterCodes[\"y\"] = 121] = \"y\";\n        CharacterCodes[CharacterCodes[\"z\"] = 122] = \"z\";\n        CharacterCodes[CharacterCodes[\"A\"] = 65] = \"A\";\n        CharacterCodes[CharacterCodes[\"B\"] = 66] = \"B\";\n        CharacterCodes[CharacterCodes[\"C\"] = 67] = \"C\";\n        CharacterCodes[CharacterCodes[\"D\"] = 68] = \"D\";\n        CharacterCodes[CharacterCodes[\"E\"] = 69] = \"E\";\n        CharacterCodes[CharacterCodes[\"F\"] = 70] = \"F\";\n        CharacterCodes[CharacterCodes[\"G\"] = 71] = \"G\";\n        CharacterCodes[CharacterCodes[\"H\"] = 72] = \"H\";\n        CharacterCodes[CharacterCodes[\"I\"] = 73] = \"I\";\n        CharacterCodes[CharacterCodes[\"J\"] = 74] = \"J\";\n        CharacterCodes[CharacterCodes[\"K\"] = 75] = \"K\";\n        CharacterCodes[CharacterCodes[\"L\"] = 76] = \"L\";\n        CharacterCodes[CharacterCodes[\"M\"] = 77] = \"M\";\n        CharacterCodes[CharacterCodes[\"N\"] = 78] = \"N\";\n        CharacterCodes[CharacterCodes[\"O\"] = 79] = \"O\";\n        CharacterCodes[CharacterCodes[\"P\"] = 80] = \"P\";\n        CharacterCodes[CharacterCodes[\"Q\"] = 81] = \"Q\";\n        CharacterCodes[CharacterCodes[\"R\"] = 82] = \"R\";\n        CharacterCodes[CharacterCodes[\"S\"] = 83] = \"S\";\n        CharacterCodes[CharacterCodes[\"T\"] = 84] = \"T\";\n        CharacterCodes[CharacterCodes[\"U\"] = 85] = \"U\";\n        CharacterCodes[CharacterCodes[\"V\"] = 86] = \"V\";\n        CharacterCodes[CharacterCodes[\"W\"] = 87] = \"W\";\n        CharacterCodes[CharacterCodes[\"X\"] = 88] = \"X\";\n        CharacterCodes[CharacterCodes[\"Y\"] = 89] = \"Y\";\n        CharacterCodes[CharacterCodes[\"Z\"] = 90] = \"Z\";\n        CharacterCodes[CharacterCodes[\"ampersand\"] = 38] = \"ampersand\";\n        CharacterCodes[CharacterCodes[\"asterisk\"] = 42] = \"asterisk\";\n        CharacterCodes[CharacterCodes[\"at\"] = 64] = \"at\";\n        CharacterCodes[CharacterCodes[\"backslash\"] = 92] = \"backslash\";\n        CharacterCodes[CharacterCodes[\"bar\"] = 124] = \"bar\";\n        CharacterCodes[CharacterCodes[\"caret\"] = 94] = \"caret\";\n        CharacterCodes[CharacterCodes[\"closeBrace\"] = 125] = \"closeBrace\";\n        CharacterCodes[CharacterCodes[\"closeBracket\"] = 93] = \"closeBracket\";\n        CharacterCodes[CharacterCodes[\"closeParen\"] = 41] = \"closeParen\";\n        CharacterCodes[CharacterCodes[\"colon\"] = 58] = \"colon\";\n        CharacterCodes[CharacterCodes[\"comma\"] = 44] = \"comma\";\n        CharacterCodes[CharacterCodes[\"dot\"] = 46] = \"dot\";\n        CharacterCodes[CharacterCodes[\"doubleQuote\"] = 34] = \"doubleQuote\";\n        CharacterCodes[CharacterCodes[\"equals\"] = 61] = \"equals\";\n        CharacterCodes[CharacterCodes[\"exclamation\"] = 33] = \"exclamation\";\n        CharacterCodes[CharacterCodes[\"greaterThan\"] = 62] = \"greaterThan\";\n        CharacterCodes[CharacterCodes[\"lessThan\"] = 60] = \"lessThan\";\n        CharacterCodes[CharacterCodes[\"minus\"] = 45] = \"minus\";\n        CharacterCodes[CharacterCodes[\"openBrace\"] = 123] = \"openBrace\";\n        CharacterCodes[CharacterCodes[\"openBracket\"] = 91] = \"openBracket\";\n        CharacterCodes[CharacterCodes[\"openParen\"] = 40] = \"openParen\";\n        CharacterCodes[CharacterCodes[\"percent\"] = 37] = \"percent\";\n        CharacterCodes[CharacterCodes[\"plus\"] = 43] = \"plus\";\n        CharacterCodes[CharacterCodes[\"question\"] = 63] = \"question\";\n        CharacterCodes[CharacterCodes[\"semicolon\"] = 59] = \"semicolon\";\n        CharacterCodes[CharacterCodes[\"singleQuote\"] = 39] = \"singleQuote\";\n        CharacterCodes[CharacterCodes[\"slash\"] = 47] = \"slash\";\n        CharacterCodes[CharacterCodes[\"tilde\"] = 126] = \"tilde\";\n        CharacterCodes[CharacterCodes[\"backspace\"] = 8] = \"backspace\";\n        CharacterCodes[CharacterCodes[\"formFeed\"] = 12] = \"formFeed\";\n        CharacterCodes[CharacterCodes[\"byteOrderMark\"] = 65279] = \"byteOrderMark\";\n        CharacterCodes[CharacterCodes[\"tab\"] = 9] = \"tab\";\n        CharacterCodes[CharacterCodes[\"verticalTab\"] = 11] = \"verticalTab\";\n    })(CharacterCodes || (CharacterCodes = {}));\n    /**\n     * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n     */\n    function getLocation(text, position) {\n        const segments = []; // strings or numbers\n        const earlyReturnException = new Object();\n        let previousNode = undefined;\n        const previousNodeInst = {\n            value: {},\n            offset: 0,\n            length: 0,\n            type: 'object',\n            parent: undefined\n        };\n        let isAtPropertyKey = false;\n        function setPreviousNode(value, offset, length, type) {\n            previousNodeInst.value = value;\n            previousNodeInst.offset = offset;\n            previousNodeInst.length = length;\n            previousNodeInst.type = type;\n            previousNodeInst.colonOffset = undefined;\n            previousNode = previousNodeInst;\n        }\n        try {\n            visit(text, {\n                onObjectBegin: (offset, length) => {\n                    if (position <= offset) {\n                        throw earlyReturnException;\n                    }\n                    previousNode = undefined;\n                    isAtPropertyKey = position > offset;\n                    segments.push(''); // push a placeholder (will be replaced)\n                },\n                onObjectProperty: (name, offset, length) => {\n                    if (position < offset) {\n                        throw earlyReturnException;\n                    }\n                    setPreviousNode(name, offset, length, 'property');\n                    segments[segments.length - 1] = name;\n                    if (position <= offset + length) {\n                        throw earlyReturnException;\n                    }\n                },\n                onObjectEnd: (offset, length) => {\n                    if (position <= offset) {\n                        throw earlyReturnException;\n                    }\n                    previousNode = undefined;\n                    segments.pop();\n                },\n                onArrayBegin: (offset, length) => {\n                    if (position <= offset) {\n                        throw earlyReturnException;\n                    }\n                    previousNode = undefined;\n                    segments.push(0);\n                },\n                onArrayEnd: (offset, length) => {\n                    if (position <= offset) {\n                        throw earlyReturnException;\n                    }\n                    previousNode = undefined;\n                    segments.pop();\n                },\n                onLiteralValue: (value, offset, length) => {\n                    if (position < offset) {\n                        throw earlyReturnException;\n                    }\n                    setPreviousNode(value, offset, length, getLiteralNodeType(value));\n                    if (position <= offset + length) {\n                        throw earlyReturnException;\n                    }\n                },\n                onSeparator: (sep, offset, length) => {\n                    if (position <= offset) {\n                        throw earlyReturnException;\n                    }\n                    if (sep === ':' && previousNode && previousNode.type === 'property') {\n                        previousNode.colonOffset = offset;\n                        isAtPropertyKey = false;\n                        previousNode = undefined;\n                    }\n                    else if (sep === ',') {\n                        const last = segments[segments.length - 1];\n                        if (typeof last === 'number') {\n                            segments[segments.length - 1] = last + 1;\n                        }\n                        else {\n                            isAtPropertyKey = true;\n                            segments[segments.length - 1] = '';\n                        }\n                        previousNode = undefined;\n                    }\n                }\n            });\n        }\n        catch (e) {\n            if (e !== earlyReturnException) {\n                throw e;\n            }\n        }\n        return {\n            path: segments,\n            previousNode,\n            isAtPropertyKey,\n            matches: (pattern) => {\n                let k = 0;\n                for (let i = 0; k < pattern.length && i < segments.length; i++) {\n                    if (pattern[k] === segments[i] || pattern[k] === '*') {\n                        k++;\n                    }\n                    else if (pattern[k] !== '**') {\n                        return false;\n                    }\n                }\n                return k === pattern.length;\n            }\n        };\n    }\n    exports.getLocation = getLocation;\n    /**\n     * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n     * Therefore always check the errors list to find out if the input was valid.\n     */\n    function parse(text, errors = [], options = ParseOptions.DEFAULT) {\n        let currentProperty = null;\n        let currentParent = [];\n        const previousParents = [];\n        function onValue(value) {\n            if (Array.isArray(currentParent)) {\n                currentParent.push(value);\n            }\n            else if (currentProperty) {\n                currentParent[currentProperty] = value;\n            }\n        }\n        const visitor = {\n            onObjectBegin: () => {\n                const object = {};\n                onValue(object);\n                previousParents.push(currentParent);\n                currentParent = object;\n                currentProperty = null;\n            },\n            onObjectProperty: (name) => {\n                currentProperty = name;\n            },\n            onObjectEnd: () => {\n                currentParent = previousParents.pop();\n            },\n            onArrayBegin: () => {\n                const array = [];\n                onValue(array);\n                previousParents.push(currentParent);\n                currentParent = array;\n                currentProperty = null;\n            },\n            onArrayEnd: () => {\n                currentParent = previousParents.pop();\n            },\n            onLiteralValue: onValue,\n            onError: (error, offset, length) => {\n                errors.push({ error, offset, length });\n            }\n        };\n        visit(text, visitor, options);\n        return currentParent[0];\n    }\n    exports.parse = parse;\n    /**\n     * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n     */\n    function parseTree(text, errors = [], options = ParseOptions.DEFAULT) {\n        let currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root\n        function ensurePropertyComplete(endOffset) {\n            if (currentParent.type === 'property') {\n                currentParent.length = endOffset - currentParent.offset;\n                currentParent = currentParent.parent;\n            }\n        }\n        function onValue(valueNode) {\n            currentParent.children.push(valueNode);\n            return valueNode;\n        }\n        const visitor = {\n            onObjectBegin: (offset) => {\n                currentParent = onValue({ type: 'object', offset, length: -1, parent: currentParent, children: [] });\n            },\n            onObjectProperty: (name, offset, length) => {\n                currentParent = onValue({ type: 'property', offset, length: -1, parent: currentParent, children: [] });\n                currentParent.children.push({ type: 'string', value: name, offset, length, parent: currentParent });\n            },\n            onObjectEnd: (offset, length) => {\n                currentParent.length = offset + length - currentParent.offset;\n                currentParent = currentParent.parent;\n                ensurePropertyComplete(offset + length);\n            },\n            onArrayBegin: (offset, length) => {\n                currentParent = onValue({ type: 'array', offset, length: -1, parent: currentParent, children: [] });\n            },\n            onArrayEnd: (offset, length) => {\n                currentParent.length = offset + length - currentParent.offset;\n                currentParent = currentParent.parent;\n                ensurePropertyComplete(offset + length);\n            },\n            onLiteralValue: (value, offset, length) => {\n                onValue({ type: getLiteralNodeType(value), offset, length, parent: currentParent, value });\n                ensurePropertyComplete(offset + length);\n            },\n            onSeparator: (sep, offset, length) => {\n                if (currentParent.type === 'property') {\n                    if (sep === ':') {\n                        currentParent.colonOffset = offset;\n                    }\n                    else if (sep === ',') {\n                        ensurePropertyComplete(offset);\n                    }\n                }\n            },\n            onError: (error, offset, length) => {\n                errors.push({ error, offset, length });\n            }\n        };\n        visit(text, visitor, options);\n        const result = currentParent.children[0];\n        if (result) {\n            delete result.parent;\n        }\n        return result;\n    }\n    exports.parseTree = parseTree;\n    /**\n     * Finds the node at the given path in a JSON DOM.\n     */\n    function findNodeAtLocation(root, path) {\n        if (!root) {\n            return undefined;\n        }\n        let node = root;\n        for (let segment of path) {\n            if (typeof segment === 'string') {\n                if (node.type !== 'object' || !Array.isArray(node.children)) {\n                    return undefined;\n                }\n                let found = false;\n                for (const propertyNode of node.children) {\n                    if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n                        node = propertyNode.children[1];\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return undefined;\n                }\n            }\n            else {\n                const index = segment;\n                if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n                    return undefined;\n                }\n                node = node.children[index];\n            }\n        }\n        return node;\n    }\n    exports.findNodeAtLocation = findNodeAtLocation;\n    /**\n     * Gets the JSON path of the given JSON DOM node\n     */\n    function getNodePath(node) {\n        if (!node.parent || !node.parent.children) {\n            return [];\n        }\n        const path = getNodePath(node.parent);\n        if (node.parent.type === 'property') {\n            const key = node.parent.children[0].value;\n            path.push(key);\n        }\n        else if (node.parent.type === 'array') {\n            const index = node.parent.children.indexOf(node);\n            if (index !== -1) {\n                path.push(index);\n            }\n        }\n        return path;\n    }\n    exports.getNodePath = getNodePath;\n    /**\n     * Evaluates the JavaScript object of the given JSON DOM node\n     */\n    function getNodeValue(node) {\n        switch (node.type) {\n            case 'array':\n                return node.children.map(getNodeValue);\n            case 'object':\n                const obj = Object.create(null);\n                for (let prop of node.children) {\n                    const valueNode = prop.children[1];\n                    if (valueNode) {\n                        obj[prop.children[0].value] = getNodeValue(valueNode);\n                    }\n                }\n                return obj;\n            case 'null':\n            case 'string':\n            case 'number':\n            case 'boolean':\n                return node.value;\n            default:\n                return undefined;\n        }\n    }\n    exports.getNodeValue = getNodeValue;\n    function contains(node, offset, includeRightBound = false) {\n        return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n    }\n    exports.contains = contains;\n    /**\n     * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n     */\n    function findNodeAtOffset(node, offset, includeRightBound = false) {\n        if (contains(node, offset, includeRightBound)) {\n            const children = node.children;\n            if (Array.isArray(children)) {\n                for (let i = 0; i < children.length && children[i].offset <= offset; i++) {\n                    const item = findNodeAtOffset(children[i], offset, includeRightBound);\n                    if (item) {\n                        return item;\n                    }\n                }\n            }\n            return node;\n        }\n        return undefined;\n    }\n    exports.findNodeAtOffset = findNodeAtOffset;\n    /**\n     * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n     */\n    function visit(text, visitor, options = ParseOptions.DEFAULT) {\n        const _scanner = createScanner(text, false);\n        function toNoArgVisit(visitFunction) {\n            return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;\n        }\n        function toOneArgVisit(visitFunction) {\n            return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;\n        }\n        const onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\n        const disallowComments = options && options.disallowComments;\n        const allowTrailingComma = options && options.allowTrailingComma;\n        function scanNext() {\n            while (true) {\n                const token = _scanner.scan();\n                switch (_scanner.getTokenError()) {\n                    case ScanError.InvalidUnicode:\n                        handleError(ParseErrorCode.InvalidUnicode);\n                        break;\n                    case ScanError.InvalidEscapeCharacter:\n                        handleError(ParseErrorCode.InvalidEscapeCharacter);\n                        break;\n                    case ScanError.UnexpectedEndOfNumber:\n                        handleError(ParseErrorCode.UnexpectedEndOfNumber);\n                        break;\n                    case ScanError.UnexpectedEndOfComment:\n                        if (!disallowComments) {\n                            handleError(ParseErrorCode.UnexpectedEndOfComment);\n                        }\n                        break;\n                    case ScanError.UnexpectedEndOfString:\n                        handleError(ParseErrorCode.UnexpectedEndOfString);\n                        break;\n                    case ScanError.InvalidCharacter:\n                        handleError(ParseErrorCode.InvalidCharacter);\n                        break;\n                }\n                switch (token) {\n                    case SyntaxKind.LineCommentTrivia:\n                    case SyntaxKind.BlockCommentTrivia:\n                        if (disallowComments) {\n                            handleError(ParseErrorCode.InvalidCommentToken);\n                        }\n                        else {\n                            onComment();\n                        }\n                        break;\n                    case SyntaxKind.Unknown:\n                        handleError(ParseErrorCode.InvalidSymbol);\n                        break;\n                    case SyntaxKind.Trivia:\n                    case SyntaxKind.LineBreakTrivia:\n                        break;\n                    default:\n                        return token;\n                }\n            }\n        }\n        function handleError(error, skipUntilAfter = [], skipUntil = []) {\n            onError(error);\n            if (skipUntilAfter.length + skipUntil.length > 0) {\n                let token = _scanner.getToken();\n                while (token !== SyntaxKind.EOF) {\n                    if (skipUntilAfter.indexOf(token) !== -1) {\n                        scanNext();\n                        break;\n                    }\n                    else if (skipUntil.indexOf(token) !== -1) {\n                        break;\n                    }\n                    token = scanNext();\n                }\n            }\n        }\n        function parseString(isValue) {\n            const value = _scanner.getTokenValue();\n            if (isValue) {\n                onLiteralValue(value);\n            }\n            else {\n                onObjectProperty(value);\n            }\n            scanNext();\n            return true;\n        }\n        function parseLiteral() {\n            switch (_scanner.getToken()) {\n                case SyntaxKind.NumericLiteral:\n                    let value = 0;\n                    try {\n                        value = JSON.parse(_scanner.getTokenValue());\n                        if (typeof value !== 'number') {\n                            handleError(ParseErrorCode.InvalidNumberFormat);\n                            value = 0;\n                        }\n                    }\n                    catch (e) {\n                        handleError(ParseErrorCode.InvalidNumberFormat);\n                    }\n                    onLiteralValue(value);\n                    break;\n                case SyntaxKind.NullKeyword:\n                    onLiteralValue(null);\n                    break;\n                case SyntaxKind.TrueKeyword:\n                    onLiteralValue(true);\n                    break;\n                case SyntaxKind.FalseKeyword:\n                    onLiteralValue(false);\n                    break;\n                default:\n                    return false;\n            }\n            scanNext();\n            return true;\n        }\n        function parseProperty() {\n            if (_scanner.getToken() !== SyntaxKind.StringLiteral) {\n                handleError(ParseErrorCode.PropertyNameExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n                return false;\n            }\n            parseString(false);\n            if (_scanner.getToken() === SyntaxKind.ColonToken) {\n                onSeparator(':');\n                scanNext(); // consume colon\n                if (!parseValue()) {\n                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n                }\n            }\n            else {\n                handleError(ParseErrorCode.ColonExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n            }\n            return true;\n        }\n        function parseObject() {\n            onObjectBegin();\n            scanNext(); // consume open brace\n            let needsComma = false;\n            while (_scanner.getToken() !== SyntaxKind.CloseBraceToken && _scanner.getToken() !== SyntaxKind.EOF) {\n                if (_scanner.getToken() === SyntaxKind.CommaToken) {\n                    if (!needsComma) {\n                        handleError(ParseErrorCode.ValueExpected, [], []);\n                    }\n                    onSeparator(',');\n                    scanNext(); // consume comma\n                    if (_scanner.getToken() === SyntaxKind.CloseBraceToken && allowTrailingComma) {\n                        break;\n                    }\n                }\n                else if (needsComma) {\n                    handleError(ParseErrorCode.CommaExpected, [], []);\n                }\n                if (!parseProperty()) {\n                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n                }\n                needsComma = true;\n            }\n            onObjectEnd();\n            if (_scanner.getToken() !== SyntaxKind.CloseBraceToken) {\n                handleError(ParseErrorCode.CloseBraceExpected, [SyntaxKind.CloseBraceToken], []);\n            }\n            else {\n                scanNext(); // consume close brace\n            }\n            return true;\n        }\n        function parseArray() {\n            onArrayBegin();\n            scanNext(); // consume open bracket\n            let needsComma = false;\n            while (_scanner.getToken() !== SyntaxKind.CloseBracketToken && _scanner.getToken() !== SyntaxKind.EOF) {\n                if (_scanner.getToken() === SyntaxKind.CommaToken) {\n                    if (!needsComma) {\n                        handleError(ParseErrorCode.ValueExpected, [], []);\n                    }\n                    onSeparator(',');\n                    scanNext(); // consume comma\n                    if (_scanner.getToken() === SyntaxKind.CloseBracketToken && allowTrailingComma) {\n                        break;\n                    }\n                }\n                else if (needsComma) {\n                    handleError(ParseErrorCode.CommaExpected, [], []);\n                }\n                if (!parseValue()) {\n                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBracketToken, SyntaxKind.CommaToken]);\n                }\n                needsComma = true;\n            }\n            onArrayEnd();\n            if (_scanner.getToken() !== SyntaxKind.CloseBracketToken) {\n                handleError(ParseErrorCode.CloseBracketExpected, [SyntaxKind.CloseBracketToken], []);\n            }\n            else {\n                scanNext(); // consume close bracket\n            }\n            return true;\n        }\n        function parseValue() {\n            switch (_scanner.getToken()) {\n                case SyntaxKind.OpenBracketToken:\n                    return parseArray();\n                case SyntaxKind.OpenBraceToken:\n                    return parseObject();\n                case SyntaxKind.StringLiteral:\n                    return parseString(true);\n                default:\n                    return parseLiteral();\n            }\n        }\n        scanNext();\n        if (_scanner.getToken() === SyntaxKind.EOF) {\n            return true;\n        }\n        if (!parseValue()) {\n            handleError(ParseErrorCode.ValueExpected, [], []);\n            return false;\n        }\n        if (_scanner.getToken() !== SyntaxKind.EOF) {\n            handleError(ParseErrorCode.EndOfFileExpected, [], []);\n        }\n        return true;\n    }\n    exports.visit = visit;\n    /**\n     * Takes JSON with JavaScript-style comments and remove\n     * them. Optionally replaces every none-newline character\n     * of comments with a replaceCharacter\n     */\n    function stripComments(text, replaceCh) {\n        let _scanner = createScanner(text), parts = [], kind, offset = 0, pos;\n        do {\n            pos = _scanner.getPosition();\n            kind = _scanner.scan();\n            switch (kind) {\n                case SyntaxKind.LineCommentTrivia:\n                case SyntaxKind.BlockCommentTrivia:\n                case SyntaxKind.EOF:\n                    if (offset !== pos) {\n                        parts.push(text.substring(offset, pos));\n                    }\n                    if (replaceCh !== undefined) {\n                        parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n                    }\n                    offset = _scanner.getPosition();\n                    break;\n            }\n        } while (kind !== SyntaxKind.EOF);\n        return parts.join('');\n    }\n    exports.stripComments = stripComments;\n    function getLiteralNodeType(value) {\n        switch (typeof value) {\n            case 'boolean': return 'boolean';\n            case 'number': return 'number';\n            case 'string': return 'string';\n            default: return 'null';\n        }\n    }\n});\n",null]}