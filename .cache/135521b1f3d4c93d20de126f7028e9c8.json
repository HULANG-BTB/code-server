{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/unix/watcherService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/unix/watcherService.ts","mtime":1555846338048},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ipc_1 = require(\"vs/base/parts/ipc/common/ipc\");\nvar ipc_cp_1 = require(\"vs/base/parts/ipc/node/ipc.cp\");\nvar common_1 = require(\"vs/workbench/services/files/node/watcher/common\");\nvar watcherIpc_1 = require(\"vs/workbench/services/files/node/watcher/unix/watcherIpc\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar network_1 = require(\"vs/base/common/network\");\nvar event_1 = require(\"vs/base/common/event\");\nvar amd_1 = require(\"vs/base/common/amd\");\nvar FileWatcher = /** @class */ (function () {\n    function FileWatcher(contextService, configurationService, onFileChanges, errorLogger, verboseLogging) {\n        var _this = this;\n        this.contextService = contextService;\n        this.configurationService = configurationService;\n        this.onFileChanges = onFileChanges;\n        this.errorLogger = errorLogger;\n        this.verboseLogging = verboseLogging;\n        this.retry = require('vs/../../../../packages/vscode/src/workbench').workbench.retry.register('Watcher', function () { return _this.startWatching(); });\n        this.isDisposed = false;\n        this.restartCounter = 0;\n        this.toDispose = [];\n    }\n    FileWatcher.prototype.startWatching = function () {\n        var _this = this;\n        var args = ['--type=watcherService'];\n        var client = new ipc_cp_1.Client(amd_1.getPathFromAmdModule(require, 'bootstrap-fork'), {\n            serverName: 'File Watcher (chokidar)',\n            args: args,\n            env: {\n                AMD_ENTRYPOINT: 'vs/workbench/services/files/node/watcher/unix/watcherApp',\n                PIPE_LOGGING: 'true',\n                VERBOSE_LOGGING: this.verboseLogging\n            }\n        });\n        this.toDispose.push(client);\n        client.onDidProcessExit(function () {\n            // our watcher app should never be completed because it keeps on watching. being in here indicates\n            // that the watcher process died and we want to restart it here. we only do it a max number of times\n            if (!_this.isDisposed) {\n                _this.toDispose = lifecycle_1.dispose(_this.toDispose);\n                return _this.retry.run();\n                if (_this.restartCounter <= FileWatcher.MAX_RESTARTS) {\n                    _this.errorLogger('[FileWatcher] terminated unexpectedly and is restarted again...');\n                    _this.restartCounter++;\n                    _this.startWatching();\n                }\n                else {\n                    _this.errorLogger('[FileWatcher] failed to start after retrying for some time, giving up. Please report this as a bug report!');\n                }\n            }\n        }, null, this.toDispose);\n        var channel = ipc_1.getNextTickChannel(client.getChannel('watcher'));\n        this.service = new watcherIpc_1.WatcherChannelClient(channel);\n        var options = { verboseLogging: this.verboseLogging };\n        var onWatchEvent = event_1.Event.filter(this.service.watch(options), function () { return !_this.isDisposed; });\n        var onError = event_1.Event.filter(onWatchEvent, function (e) { return typeof e.message === 'string'; });\n        onError(function (err) { return _this.errorLogger(err.message); }, null, this.toDispose);\n        var onFileChanges = event_1.Event.filter(onWatchEvent, function (e) { return Array.isArray(e) && e.length > 0; });\n        onFileChanges(function (e) { return _this.onFileChanges(common_1.toFileChangesEvent(e)); }, null, this.toDispose);\n        // Start watching\n        this.updateFolders();\n        this.toDispose.push(this.contextService.onDidChangeWorkspaceFolders(function () { return _this.updateFolders(); }));\n        this.toDispose.push(this.configurationService.onDidChangeConfiguration(function (e) {\n            if (e.affectsConfiguration('files.watcherExclude')) {\n                _this.updateFolders();\n            }\n        }));\n        return function () { return _this.dispose(); };\n    };\n    FileWatcher.prototype.updateFolders = function () {\n        var _this = this;\n        if (this.isDisposed) {\n            return;\n        }\n        this.service.setRoots(this.contextService.getWorkspace().folders.filter(function (folder) {\n            // Only workspace folders on disk\n            return folder.uri.scheme === network_1.Schemas.file;\n        }).map(function (folder) {\n            // Fetch the root's watcherExclude setting and return it\n            var configuration = _this.configurationService.getValue({\n                resource: folder.uri\n            });\n            var ignored = [];\n            if (configuration.files && configuration.files.watcherExclude) {\n                ignored = Object.keys(configuration.files.watcherExclude).filter(function (k) { return !!configuration.files.watcherExclude[k]; });\n            }\n            return {\n                basePath: folder.uri.fsPath,\n                ignored: ignored,\n                recursive: false\n            };\n        })).then(function () { return _this.retry.recover(); });\n    };\n    FileWatcher.prototype.dispose = function () {\n        this.isDisposed = true;\n        this.toDispose = lifecycle_1.dispose(this.toDispose);\n    };\n    FileWatcher.MAX_RESTARTS = 5;\n    return FileWatcher;\n}());\nexports.FileWatcher = FileWatcher;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/unix/watcherService.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/unix/watcherService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getNextTickChannel } from 'vs/base/parts/ipc/common/ipc';\nimport { Client } from 'vs/base/parts/ipc/node/ipc.cp';\nimport { toFileChangesEvent, IRawFileChange } from 'vs/workbench/services/files/node/watcher/common';\nimport { WatcherChannelClient } from 'vs/workbench/services/files/node/watcher/unix/watcherIpc';\nimport { FileChangesEvent, IFilesConfiguration } from 'vs/platform/files/common/files';\nimport { IWorkspaceContextService } from 'vs/platform/workspace/common/workspace';\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { Schemas } from 'vs/base/common/network';\nimport { Event } from 'vs/base/common/event';\nimport { IWatchError } from 'vs/workbench/services/files/node/watcher/unix/watcher';\nimport { getPathFromAmdModule } from 'vs/base/common/amd';\n\nexport class FileWatcher {\n\tprivate static readonly MAX_RESTARTS = 5;\n\n\tprivate isDisposed: boolean;\n\tprivate restartCounter: number;\n\tprivate service: WatcherChannelClient;\n\tprivate toDispose: IDisposable[];\n\n\tprivate readonly retry = (require('vs/../../../../packages/vscode/src/workbench') as typeof import ('vs/../../../../packages/vscode/src/workbench')).workbench.retry.register('Watcher', () => this.startWatching());\n\tconstructor(\n\t\tprivate contextService: IWorkspaceContextService,\n\t\tprivate configurationService: IConfigurationService,\n\t\tprivate onFileChanges: (changes: FileChangesEvent) => void,\n\t\tprivate errorLogger: (msg: string) => void,\n\t\tprivate verboseLogging: boolean\n\t) {\n\t\tthis.isDisposed = false;\n\t\tthis.restartCounter = 0;\n\t\tthis.toDispose = [];\n\t}\n\n\tpublic startWatching(): () => void {\n\t\tconst args = ['--type=watcherService'];\n\n\t\tconst client = new Client(\n\t\t\tgetPathFromAmdModule(require, 'bootstrap-fork'),\n\t\t\t{\n\t\t\t\tserverName: 'File Watcher (chokidar)',\n\t\t\t\targs,\n\t\t\t\tenv: {\n\t\t\t\t\tAMD_ENTRYPOINT: 'vs/workbench/services/files/node/watcher/unix/watcherApp',\n\t\t\t\t\tPIPE_LOGGING: 'true',\n\t\t\t\t\tVERBOSE_LOGGING: this.verboseLogging\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tthis.toDispose.push(client);\n\n\t\tclient.onDidProcessExit(() => {\n\t\t\t// our watcher app should never be completed because it keeps on watching. being in here indicates\n\t\t\t// that the watcher process died and we want to restart it here. we only do it a max number of times\n\t\t\tif (!this.isDisposed) {\n\t\t\t\tthis.toDispose = dispose(this.toDispose);\n\t\t\t\treturn this.retry.run();\n\t\t\t\tif (this.restartCounter <= FileWatcher.MAX_RESTARTS) {\n\t\t\t\t\tthis.errorLogger('[FileWatcher] terminated unexpectedly and is restarted again...');\n\t\t\t\t\tthis.restartCounter++;\n\t\t\t\t\tthis.startWatching();\n\t\t\t\t} else {\n\t\t\t\t\tthis.errorLogger('[FileWatcher] failed to start after retrying for some time, giving up. Please report this as a bug report!');\n\t\t\t\t}\n\t\t\t}\n\t\t}, null, this.toDispose);\n\n\t\tconst channel = getNextTickChannel(client.getChannel('watcher'));\n\t\tthis.service = new WatcherChannelClient(channel);\n\n\t\tconst options = { verboseLogging: this.verboseLogging };\n\t\tconst onWatchEvent = Event.filter(this.service.watch(options), () => !this.isDisposed);\n\n\t\tconst onError = Event.filter<any, IWatchError>(onWatchEvent, (e): e is IWatchError => typeof e.message === 'string');\n\t\tonError(err => this.errorLogger(err.message), null, this.toDispose);\n\n\t\tconst onFileChanges = Event.filter<any, IRawFileChange[]>(onWatchEvent, (e): e is IRawFileChange[] => Array.isArray(e) && e.length > 0);\n\t\tonFileChanges(e => this.onFileChanges(toFileChangesEvent(e)), null, this.toDispose);\n\n\t\t// Start watching\n\t\tthis.updateFolders();\n\t\tthis.toDispose.push(this.contextService.onDidChangeWorkspaceFolders(() => this.updateFolders()));\n\t\tthis.toDispose.push(this.configurationService.onDidChangeConfiguration(e => {\n\t\t\tif (e.affectsConfiguration('files.watcherExclude')) {\n\t\t\t\tthis.updateFolders();\n\t\t\t}\n\t\t}));\n\n\t\treturn () => this.dispose();\n\t}\n\n\tprivate updateFolders() {\n\t\tif (this.isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.service.setRoots(this.contextService.getWorkspace().folders.filter(folder => {\n\t\t\t// Only workspace folders on disk\n\t\t\treturn folder.uri.scheme === Schemas.file;\n\t\t}).map(folder => {\n\t\t\t// Fetch the root's watcherExclude setting and return it\n\t\t\tconst configuration = this.configurationService.getValue<IFilesConfiguration>({\n\t\t\t\tresource: folder.uri\n\t\t\t});\n\t\t\tlet ignored: string[] = [];\n\t\t\tif (configuration.files && configuration.files.watcherExclude) {\n\t\t\t\tignored = Object.keys(configuration.files.watcherExclude).filter(k => !!configuration.files.watcherExclude[k]);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tbasePath: folder.uri.fsPath,\n\t\t\t\tignored,\n\t\t\t\trecursive: false\n\t\t\t};\n\t\t})).then(() => this.retry.recover());\n\t}\n\n\tprivate dispose(): void {\n\t\tthis.isDisposed = true;\n\t\tthis.toDispose = dispose(this.toDispose);\n\t}\n}\n"]}]}