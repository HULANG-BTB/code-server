{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/browser/parts/editor/editorDropTarget.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/browser/parts/editor/editorDropTarget.ts","mtime":1555846338036},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nrequire(\"vs/css!./media/editordroptarget\");\nvar dnd_1 = require(\"vs/workbench/browser/dnd\");\nvar dom_1 = require(\"vs/base/browser/dom\");\nvar editor_1 = require(\"vs/workbench/browser/parts/editor/editor\");\nvar theme_1 = require(\"vs/workbench/common/theme\");\nvar themeService_1 = require(\"vs/platform/theme/common/themeService\");\nvar colorRegistry_1 = require(\"vs/platform/theme/common/colorRegistry\");\nvar editor_2 = require(\"vs/workbench/common/editor\");\nvar browser_1 = require(\"vs/base/browser/browser\");\nvar editorGroupsService_1 = require(\"vs/workbench/services/editor/common/editorGroupsService\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar async_1 = require(\"vs/base/common/async\");\nvar DropOverlay = /** @class */ (function (_super) {\n    tslib_1.__extends(DropOverlay, _super);\n    function DropOverlay(accessor, groupView, themeService, instantiationService) {\n        var _this = _super.call(this, themeService) || this;\n        _this.accessor = accessor;\n        _this.groupView = groupView;\n        _this.instantiationService = instantiationService;\n        _this.editorTransfer = dnd_1.LocalSelectionTransfer.getInstance();\n        _this.groupTransfer = dnd_1.LocalSelectionTransfer.getInstance();\n        _this.cleanupOverlayScheduler = _this._register(new async_1.RunOnceScheduler(function () { return _this.dispose(); }, 300));\n        _this.create();\n        return _this;\n    }\n    Object.defineProperty(DropOverlay.prototype, \"disposed\", {\n        get: function () {\n            return this._disposed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DropOverlay.prototype.create = function () {\n        var _this = this;\n        var overlayOffsetHeight = this.getOverlayOffsetHeight();\n        // Container\n        this.container = document.createElement('div');\n        this.container.id = DropOverlay.OVERLAY_ID;\n        this.container.style.top = overlayOffsetHeight + \"px\";\n        // Parent\n        this.groupView.element.appendChild(this.container);\n        dom_1.addClass(this.groupView.element, 'dragged-over');\n        this._register(lifecycle_1.toDisposable(function () {\n            _this.groupView.element.removeChild(_this.container);\n            dom_1.removeClass(_this.groupView.element, 'dragged-over');\n        }));\n        // Overlay\n        this.overlay = document.createElement('div');\n        dom_1.addClass(this.overlay, 'editor-group-overlay-indicator');\n        this.container.appendChild(this.overlay);\n        // Overlay Event Handling\n        this.registerListeners();\n        // Styles\n        this.updateStyles();\n    };\n    DropOverlay.prototype.updateStyles = function () {\n        // Overlay drop background\n        this.overlay.style.backgroundColor = this.getColor(theme_1.EDITOR_DRAG_AND_DROP_BACKGROUND);\n        // Overlay contrast border (if any)\n        var activeContrastBorderColor = this.getColor(colorRegistry_1.activeContrastBorder);\n        this.overlay.style.outlineColor = activeContrastBorderColor;\n        this.overlay.style.outlineOffset = activeContrastBorderColor ? '-2px' : null;\n        this.overlay.style.outlineStyle = activeContrastBorderColor ? 'dashed' : null;\n        this.overlay.style.outlineWidth = activeContrastBorderColor ? '2px' : null;\n    };\n    DropOverlay.prototype.registerListeners = function () {\n        var _this = this;\n        this._register(new dnd_1.DragAndDropObserver(this.container, {\n            onDragEnter: function (e) { return undefined; },\n            onDragOver: function (e) {\n                var isDraggingGroup = _this.groupTransfer.hasData(dnd_1.DraggedEditorGroupIdentifier.prototype);\n                var isDraggingEditor = _this.editorTransfer.hasData(dnd_1.DraggedEditorIdentifier.prototype);\n                // Update the dropEffect to \"copy\" if there is no local data to be dragged because\n                // in that case we can only copy the data into and not move it from its source\n                if (!isDraggingEditor && !isDraggingGroup && e.dataTransfer) {\n                    e.dataTransfer.dropEffect = 'copy';\n                }\n                // Find out if operation is valid\n                var isCopy = isDraggingGroup ? _this.isCopyOperation(e) : isDraggingEditor ? _this.isCopyOperation(e, _this.editorTransfer.getData(dnd_1.DraggedEditorIdentifier.prototype)[0].identifier) : true;\n                if (!isCopy) {\n                    var sourceGroupView = _this.findSourceGroupView();\n                    if (sourceGroupView === _this.groupView) {\n                        if (isDraggingGroup || (isDraggingEditor && sourceGroupView.count < 2)) {\n                            _this.hideOverlay();\n                            return; // do not allow to drop group/editor on itself if this results in an empty group\n                        }\n                    }\n                }\n                // Position overlay\n                _this.positionOverlay(e.offsetX, e.offsetY, isDraggingGroup);\n                // Make sure to stop any running cleanup scheduler to remove the overlay\n                if (_this.cleanupOverlayScheduler.isScheduled()) {\n                    _this.cleanupOverlayScheduler.cancel();\n                }\n            },\n            onDragLeave: function (e) { return _this.dispose(); },\n            onDragEnd: function (e) { return _this.dispose(); },\n            onDrop: function (e) {\n                dom_1.EventHelper.stop(e, true);\n                // Dispose overlay\n                _this.dispose();\n                // Handle drop if we have a valid operation\n                if (_this.currentDropOperation) {\n                    _this.handleDrop(e, _this.currentDropOperation.splitDirection);\n                }\n            }\n        }));\n        this._register(dom_1.addDisposableListener(this.container, dom_1.EventType.MOUSE_OVER, function () {\n            // Under some circumstances we have seen reports where the drop overlay is not being\n            // cleaned up and as such the editor area remains under the overlay so that you cannot\n            // type into the editor anymore. This seems related to using VMs and DND via host and\n            // guest OS, though some users also saw it without VMs.\n            // To protect against this issue we always destroy the overlay as soon as we detect a\n            // mouse event over it. The delay is used to guarantee we are not interfering with the\n            // actual DROP event that can also trigger a mouse over event.\n            if (!_this.cleanupOverlayScheduler.isScheduled()) {\n                _this.cleanupOverlayScheduler.schedule();\n            }\n        }));\n    };\n    DropOverlay.prototype.findSourceGroupView = function () {\n        // Check for group transfer\n        if (this.groupTransfer.hasData(dnd_1.DraggedEditorGroupIdentifier.prototype)) {\n            return this.accessor.getGroup(this.groupTransfer.getData(dnd_1.DraggedEditorGroupIdentifier.prototype)[0].identifier);\n        }\n        // Check for editor transfer\n        else if (this.editorTransfer.hasData(dnd_1.DraggedEditorIdentifier.prototype)) {\n            return this.accessor.getGroup(this.editorTransfer.getData(dnd_1.DraggedEditorIdentifier.prototype)[0].identifier.groupId);\n        }\n        return undefined;\n    };\n    DropOverlay.prototype.handleDrop = function (event, splitDirection) {\n        var _this = this;\n        // Determine target group\n        var ensureTargetGroup = function () {\n            var targetGroup;\n            if (typeof splitDirection === 'number') {\n                targetGroup = _this.accessor.addGroup(_this.groupView, splitDirection);\n            }\n            else {\n                targetGroup = _this.groupView;\n            }\n            return targetGroup;\n        };\n        // Check for group transfer\n        if (this.groupTransfer.hasData(dnd_1.DraggedEditorGroupIdentifier.prototype)) {\n            var draggedEditorGroup = this.groupTransfer.getData(dnd_1.DraggedEditorGroupIdentifier.prototype)[0].identifier;\n            // Return if the drop is a no-op\n            var sourceGroup = this.accessor.getGroup(draggedEditorGroup);\n            if (sourceGroup) {\n                if (typeof splitDirection !== 'number' && sourceGroup === this.groupView) {\n                    return;\n                }\n                // Split to new group\n                var targetGroup = void 0;\n                if (typeof splitDirection === 'number') {\n                    if (this.isCopyOperation(event)) {\n                        targetGroup = this.accessor.copyGroup(sourceGroup, this.groupView, splitDirection);\n                    }\n                    else {\n                        targetGroup = this.accessor.moveGroup(sourceGroup, this.groupView, splitDirection);\n                    }\n                }\n                // Merge into existing group\n                else {\n                    if (this.isCopyOperation(event)) {\n                        targetGroup = this.accessor.mergeGroup(sourceGroup, this.groupView, { mode: editorGroupsService_1.MergeGroupMode.COPY_EDITORS });\n                    }\n                    else {\n                        targetGroup = this.accessor.mergeGroup(sourceGroup, this.groupView);\n                    }\n                }\n                if (targetGroup) {\n                    this.accessor.activateGroup(targetGroup);\n                }\n            }\n            this.groupTransfer.clearData(dnd_1.DraggedEditorGroupIdentifier.prototype);\n        }\n        // Check for editor transfer\n        else if (this.editorTransfer.hasData(dnd_1.DraggedEditorIdentifier.prototype)) {\n            var draggedEditor = this.editorTransfer.getData(dnd_1.DraggedEditorIdentifier.prototype)[0].identifier;\n            var targetGroup = ensureTargetGroup();\n            // Return if the drop is a no-op\n            var sourceGroup = this.accessor.getGroup(draggedEditor.groupId);\n            if (sourceGroup) {\n                if (sourceGroup === targetGroup) {\n                    return;\n                }\n                // Open in target group\n                var options = editor_1.getActiveTextEditorOptions(sourceGroup, draggedEditor.editor, editor_2.EditorOptions.create({ pinned: true }));\n                targetGroup.openEditor(draggedEditor.editor, options);\n                // Ensure target has focus\n                targetGroup.focus();\n                // Close in source group unless we copy\n                var copyEditor = this.isCopyOperation(event, draggedEditor);\n                if (!copyEditor) {\n                    sourceGroup.closeEditor(draggedEditor.editor);\n                }\n            }\n            this.editorTransfer.clearData(dnd_1.DraggedEditorIdentifier.prototype);\n        }\n        // Check for URI transfer\n        else {\n            var dropHandler = this.instantiationService.createInstance(dnd_1.ResourcesDropHandler, { allowWorkspaceOpen: true /* open workspace instead of file if dropped */ });\n            dropHandler.handleDrop(event, function () { return ensureTargetGroup(); }, function (targetGroup) { return targetGroup.focus(); });\n        }\n    };\n    DropOverlay.prototype.isCopyOperation = function (e, draggedEditor) {\n        if (draggedEditor && !draggedEditor.editor.supportsSplitEditor()) {\n            return false;\n        }\n        return (e.ctrlKey && !browser_1.isMacintosh) || (e.altKey && browser_1.isMacintosh);\n    };\n    DropOverlay.prototype.positionOverlay = function (mousePosX, mousePosY, isDraggingGroup) {\n        var _this = this;\n        var preferSplitVertically = this.accessor.partOptions.openSideBySideDirection === 'right';\n        var editorControlWidth = this.groupView.element.clientWidth;\n        var editorControlHeight = this.groupView.element.clientHeight - this.getOverlayOffsetHeight();\n        var edgeWidthThresholdFactor;\n        if (isDraggingGroup) {\n            edgeWidthThresholdFactor = preferSplitVertically ? 0.3 : 0.1; // give larger threshold when dragging group depending on preferred split direction\n        }\n        else {\n            edgeWidthThresholdFactor = 0.1; // 10% threshold to split if dragging editors\n        }\n        var edgeHeightThresholdFactor;\n        if (isDraggingGroup) {\n            edgeHeightThresholdFactor = preferSplitVertically ? 0.1 : 0.3; // give larger threshold when dragging group depending on preferred split direction\n        }\n        else {\n            edgeHeightThresholdFactor = 0.1; // 10% threshold to split if dragging editors\n        }\n        var edgeWidthThreshold = editorControlWidth * edgeWidthThresholdFactor;\n        var edgeHeightThreshold = editorControlHeight * edgeHeightThresholdFactor;\n        var splitWidthThreshold = editorControlWidth / 3; // offer to split left/right at 33%\n        var splitHeightThreshold = editorControlHeight / 3; // offer to split up/down at 33%\n        // Enable to debug the drop threshold square\n        // let child = this.overlay.children.item(0) as HTMLElement || this.overlay.appendChild(document.createElement('div'));\n        // child.style.backgroundColor = 'red';\n        // child.style.position = 'absolute';\n        // child.style.width = (groupViewWidth - (2 * edgeWidthThreshold)) + 'px';\n        // child.style.height = (groupViewHeight - (2 * edgeHeightThreshold)) + 'px';\n        // child.style.left = edgeWidthThreshold + 'px';\n        // child.style.top = edgeHeightThreshold + 'px';\n        // No split if mouse is above certain threshold in the center of the view\n        var splitDirection;\n        if (mousePosX > edgeWidthThreshold && mousePosX < editorControlWidth - edgeWidthThreshold &&\n            mousePosY > edgeHeightThreshold && mousePosY < editorControlHeight - edgeHeightThreshold) {\n            splitDirection = undefined;\n        }\n        // Offer to split otherwise\n        else {\n            // User prefers to split vertically: offer a larger hitzone\n            // for this direction like so:\n            // ----------------------------------------------\n            // |\t\t|\t\tSPLIT UP\t\t|\t\t\t|\n            // | SPLIT \t|-----------------------|\tSPLIT\t|\n            // |\t\t|\t\t  MERGE\t\t\t|\t\t\t|\n            // | LEFT\t|-----------------------|\tRIGHT\t|\n            // |\t\t|\t\tSPLIT DOWN\t\t|\t\t\t|\n            // ----------------------------------------------\n            if (preferSplitVertically) {\n                if (mousePosX < splitWidthThreshold) {\n                    splitDirection = editorGroupsService_1.GroupDirection.LEFT;\n                }\n                else if (mousePosX > splitWidthThreshold * 2) {\n                    splitDirection = editorGroupsService_1.GroupDirection.RIGHT;\n                }\n                else if (mousePosY < editorControlHeight / 2) {\n                    splitDirection = editorGroupsService_1.GroupDirection.UP;\n                }\n                else {\n                    splitDirection = editorGroupsService_1.GroupDirection.DOWN;\n                }\n            }\n            // User prefers to split horizontally: offer a larger hitzone\n            // for this direction like so:\n            // ----------------------------------------------\n            // |\t\t\t\tSPLIT UP\t\t\t\t\t|\n            // |--------------------------------------------|\n            // |  SPLIT LEFT  |\t   MERGE\t|  SPLIT RIGHT  |\n            // |--------------------------------------------|\n            // |\t\t\t\tSPLIT DOWN\t\t\t\t\t|\n            // ----------------------------------------------\n            else {\n                if (mousePosY < splitHeightThreshold) {\n                    splitDirection = editorGroupsService_1.GroupDirection.UP;\n                }\n                else if (mousePosY > splitHeightThreshold * 2) {\n                    splitDirection = editorGroupsService_1.GroupDirection.DOWN;\n                }\n                else if (mousePosX < editorControlWidth / 2) {\n                    splitDirection = editorGroupsService_1.GroupDirection.LEFT;\n                }\n                else {\n                    splitDirection = editorGroupsService_1.GroupDirection.RIGHT;\n                }\n            }\n        }\n        // Draw overlay based on split direction\n        switch (splitDirection) {\n            case editorGroupsService_1.GroupDirection.UP:\n                this.doPositionOverlay({ top: '0', left: '0', width: '100%', height: '50%' });\n                break;\n            case editorGroupsService_1.GroupDirection.DOWN:\n                this.doPositionOverlay({ top: '50%', left: '0', width: '100%', height: '50%' });\n                break;\n            case editorGroupsService_1.GroupDirection.LEFT:\n                this.doPositionOverlay({ top: '0', left: '0', width: '50%', height: '100%' });\n                break;\n            case editorGroupsService_1.GroupDirection.RIGHT:\n                this.doPositionOverlay({ top: '0', left: '50%', width: '50%', height: '100%' });\n                break;\n            default:\n                this.doPositionOverlay({ top: '0', left: '0', width: '100%', height: '100%' });\n        }\n        // Make sure the overlay is visible now\n        this.overlay.style.opacity = '1';\n        // Enable transition after a timeout to prevent initial animation\n        setTimeout(function () { return dom_1.addClass(_this.overlay, 'overlay-move-transition'); }, 0);\n        // Remember as current split direction\n        this.currentDropOperation = { splitDirection: splitDirection };\n    };\n    DropOverlay.prototype.doPositionOverlay = function (options) {\n        // Container\n        var offsetHeight = this.getOverlayOffsetHeight();\n        if (offsetHeight) {\n            this.container.style.height = \"calc(100% - \" + offsetHeight + \"px)\";\n        }\n        else {\n            this.container.style.height = '100%';\n        }\n        // Overlay\n        this.overlay.style.top = options.top;\n        this.overlay.style.left = options.left;\n        this.overlay.style.width = options.width;\n        this.overlay.style.height = options.height;\n    };\n    DropOverlay.prototype.getOverlayOffsetHeight = function () {\n        if (!this.groupView.isEmpty() && this.accessor.partOptions.showTabs) {\n            return editor_1.EDITOR_TITLE_HEIGHT; // show overlay below title if group shows tabs\n        }\n        return 0;\n    };\n    DropOverlay.prototype.hideOverlay = function () {\n        // Reset overlay\n        this.doPositionOverlay({ top: '0', left: '0', width: '100%', height: '100%' });\n        this.overlay.style.opacity = '0';\n        dom_1.removeClass(this.overlay, 'overlay-move-transition');\n        // Reset current operation\n        this.currentDropOperation = undefined;\n    };\n    DropOverlay.prototype.contains = function (element) {\n        return element === this.container || element === this.overlay;\n    };\n    DropOverlay.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._disposed = true;\n    };\n    DropOverlay.OVERLAY_ID = 'monaco-workbench-editor-drop-overlay';\n    return DropOverlay;\n}(theme_1.Themable));\nvar EditorDropTarget = /** @class */ (function (_super) {\n    tslib_1.__extends(EditorDropTarget, _super);\n    function EditorDropTarget(accessor, container, themeService, instantiationService) {\n        var _this = _super.call(this, themeService) || this;\n        _this.accessor = accessor;\n        _this.container = container;\n        _this.instantiationService = instantiationService;\n        _this.counter = 0;\n        _this.editorTransfer = dnd_1.LocalSelectionTransfer.getInstance();\n        _this.groupTransfer = dnd_1.LocalSelectionTransfer.getInstance();\n        _this.registerListeners();\n        return _this;\n    }\n    Object.defineProperty(EditorDropTarget.prototype, \"overlay\", {\n        get: function () {\n            if (this._overlay && !this._overlay.disposed) {\n                return this._overlay;\n            }\n            return undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    EditorDropTarget.prototype.registerListeners = function () {\n        var _this = this;\n        this._register(dom_1.addDisposableListener(this.container, dom_1.EventType.DRAG_ENTER, function (e) { return _this.onDragEnter(e); }));\n        this._register(dom_1.addDisposableListener(this.container, dom_1.EventType.DRAG_LEAVE, function () { return _this.onDragLeave(); }));\n        [this.container, window].forEach(function (node) { return _this._register(dom_1.addDisposableListener(node, dom_1.EventType.DRAG_END, function () { return _this.onDragEnd(); })); });\n    };\n    EditorDropTarget.prototype.onDragEnter = function (event) {\n        this.counter++;\n        // Validate transfer\n        if (!this.editorTransfer.hasData(dnd_1.DraggedEditorIdentifier.prototype) &&\n            !this.groupTransfer.hasData(dnd_1.DraggedEditorGroupIdentifier.prototype) &&\n            event.dataTransfer && !event.dataTransfer.types.length // see https://github.com/Microsoft/vscode/issues/25789\n        ) {\n            event.dataTransfer.dropEffect = 'none';\n            return; // unsupported transfer\n        }\n        // Signal DND start\n        this.updateContainer(true);\n        var target = event.target;\n        if (target) {\n            // Somehow we managed to move the mouse quickly out of the current overlay, so destroy it\n            if (this.overlay && !this.overlay.contains(target)) {\n                this.disposeOverlay();\n            }\n            // Create overlay over target\n            if (!this.overlay) {\n                var targetGroupView = this.findTargetGroupView(target);\n                if (targetGroupView) {\n                    this._overlay = new DropOverlay(this.accessor, targetGroupView, this.themeService, this.instantiationService);\n                }\n            }\n        }\n    };\n    EditorDropTarget.prototype.onDragLeave = function () {\n        this.counter--;\n        if (this.counter === 0) {\n            this.updateContainer(false);\n        }\n    };\n    EditorDropTarget.prototype.onDragEnd = function () {\n        this.counter = 0;\n        this.updateContainer(false);\n        this.disposeOverlay();\n    };\n    EditorDropTarget.prototype.findTargetGroupView = function (child) {\n        var groups = this.accessor.groups;\n        for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {\n            var groupView = groups_1[_i];\n            if (dom_1.isAncestor(child, groupView.element)) {\n                return groupView;\n            }\n        }\n        return undefined;\n    };\n    EditorDropTarget.prototype.updateContainer = function (isDraggedOver) {\n        dom_1.toggleClass(this.container, 'dragged-over', isDraggedOver);\n    };\n    EditorDropTarget.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this.disposeOverlay();\n    };\n    EditorDropTarget.prototype.disposeOverlay = function () {\n        if (this.overlay) {\n            this.overlay.dispose();\n            this._overlay = undefined;\n        }\n    };\n    EditorDropTarget = tslib_1.__decorate([\n        tslib_1.__param(2, themeService_1.IThemeService),\n        tslib_1.__param(3, instantiation_1.IInstantiationService)\n    ], EditorDropTarget);\n    return EditorDropTarget;\n}(theme_1.Themable));\nexports.EditorDropTarget = EditorDropTarget;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/browser/parts/editor/editorDropTarget.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/browser/parts/editor/editorDropTarget.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;;AAEhG,2CAAyC;AACzC,gDAAoK;AACpK,2CAAoI;AACpI,mEAAoJ;AACpJ,mDAAsF;AACtF,sEAAsE;AACtE,wEAA8E;AAC9E,qDAA2F;AAC3F,mDAAsD;AACtD,+FAAyG;AACzG,sDAAwD;AACxD,gFAAuF;AACvF,8CAAwD;AAMxD;IAA0B,uCAAQ;IAejC,qBACS,QAA+B,EAC/B,SAA2B,EACnC,YAA2B,EACnB,oBAA2C;QAJpD,YAMC,kBAAM,YAAY,CAAC,SAKnB;QAVQ,cAAQ,GAAR,QAAQ,CAAuB;QAC/B,eAAS,GAAT,SAAS,CAAkB;QAE3B,0BAAoB,GAApB,oBAAoB,CAAuB;QAPnC,oBAAc,GAAG,4BAAsB,CAAC,WAAW,EAA2B,CAAC;QAC/E,mBAAa,GAAG,4BAAsB,CAAC,WAAW,EAAgC,CAAC;QAUnG,KAAI,CAAC,uBAAuB,GAAG,KAAI,CAAC,SAAS,CAAC,IAAI,wBAAgB,CAAC,cAAM,OAAA,KAAI,CAAC,OAAO,EAAE,EAAd,CAAc,EAAE,GAAG,CAAC,CAAC,CAAC;QAE/F,KAAI,CAAC,MAAM,EAAE,CAAC;;IACf,CAAC;IAED,sBAAI,iCAAQ;aAAZ;YACC,OAAO,IAAI,CAAC,SAAS,CAAC;QACvB,CAAC;;;OAAA;IAEO,4BAAM,GAAd;QAAA,iBA0BC;QAzBA,IAAM,mBAAmB,GAAG,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAE1D,YAAY;QACZ,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;QAC/C,IAAI,CAAC,SAAS,CAAC,EAAE,GAAG,WAAW,CAAC,UAAU,CAAC;QAC3C,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,GAAM,mBAAmB,OAAI,CAAC;QAEtD,SAAS;QACT,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACnD,cAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,cAAc,CAAC,CAAC;QACjD,IAAI,CAAC,SAAS,CAAC,wBAAY,CAAC;YAC3B,KAAI,CAAC,SAAS,CAAC,OAAO,CAAC,WAAW,CAAC,KAAI,CAAC,SAAS,CAAC,CAAC;YACnD,iBAAW,CAAC,KAAI,CAAC,SAAS,CAAC,OAAO,EAAE,cAAc,CAAC,CAAC;QACrD,CAAC,CAAC,CAAC,CAAC;QAEJ,UAAU;QACV,IAAI,CAAC,OAAO,GAAG,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;QAC7C,cAAQ,CAAC,IAAI,CAAC,OAAO,EAAE,gCAAgC,CAAC,CAAC;QACzD,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAEzC,yBAAyB;QACzB,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAEzB,SAAS;QACT,IAAI,CAAC,YAAY,EAAE,CAAC;IACrB,CAAC;IAES,kCAAY,GAAtB;QAEC,0BAA0B;QAC1B,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,eAAe,GAAG,IAAI,CAAC,QAAQ,CAAC,uCAA+B,CAAC,CAAC;QAEpF,mCAAmC;QACnC,IAAM,yBAAyB,GAAG,IAAI,CAAC,QAAQ,CAAC,oCAAoB,CAAC,CAAC;QACtE,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,YAAY,GAAG,yBAAyB,CAAC;QAC5D,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,aAAa,GAAG,yBAAyB,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;QAC7E,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,YAAY,GAAG,yBAAyB,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC;QAC9E,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,YAAY,GAAG,yBAAyB,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;IAC5E,CAAC;IAEO,uCAAiB,GAAzB;QAAA,iBA8DC;QA7DA,IAAI,CAAC,SAAS,CAAC,IAAI,yBAAmB,CAAC,IAAI,CAAC,SAAS,EAAE;YACtD,WAAW,EAAE,UAAA,CAAC,IAAI,OAAA,SAAS,EAAT,CAAS;YAC3B,UAAU,EAAE,UAAA,CAAC;gBACZ,IAAM,eAAe,GAAG,KAAI,CAAC,aAAa,CAAC,OAAO,CAAC,kCAA4B,CAAC,SAAS,CAAC,CAAC;gBAC3F,IAAM,gBAAgB,GAAG,KAAI,CAAC,cAAc,CAAC,OAAO,CAAC,6BAAuB,CAAC,SAAS,CAAC,CAAC;gBAExF,kFAAkF;gBAClF,8EAA8E;gBAC9E,IAAI,CAAC,gBAAgB,IAAI,CAAC,eAAe,IAAI,CAAC,CAAC,YAAY,EAAE;oBAC5D,CAAC,CAAC,YAAY,CAAC,UAAU,GAAG,MAAM,CAAC;iBACnC;gBAED,iCAAiC;gBACjC,IAAM,MAAM,GAAG,eAAe,CAAC,CAAC,CAAC,KAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,KAAI,CAAC,eAAe,CAAC,CAAC,EAAE,KAAI,CAAC,cAAc,CAAC,OAAO,CAAC,6BAAuB,CAAC,SAAS,CAAE,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;gBAC5L,IAAI,CAAC,MAAM,EAAE;oBACZ,IAAM,eAAe,GAAG,KAAI,CAAC,mBAAmB,EAAE,CAAC;oBACnD,IAAI,eAAe,KAAK,KAAI,CAAC,SAAS,EAAE;wBACvC,IAAI,eAAe,IAAI,CAAC,gBAAgB,IAAI,eAAe,CAAC,KAAK,GAAG,CAAC,CAAC,EAAE;4BACvE,KAAI,CAAC,WAAW,EAAE,CAAC;4BACnB,OAAO,CAAC,gFAAgF;yBACxF;qBACD;iBACD;gBAED,mBAAmB;gBACnB,KAAI,CAAC,eAAe,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC;gBAE5D,wEAAwE;gBACxE,IAAI,KAAI,CAAC,uBAAuB,CAAC,WAAW,EAAE,EAAE;oBAC/C,KAAI,CAAC,uBAAuB,CAAC,MAAM,EAAE,CAAC;iBACtC;YACF,CAAC;YAED,WAAW,EAAE,UAAA,CAAC,IAAI,OAAA,KAAI,CAAC,OAAO,EAAE,EAAd,CAAc;YAChC,SAAS,EAAE,UAAA,CAAC,IAAI,OAAA,KAAI,CAAC,OAAO,EAAE,EAAd,CAAc;YAE9B,MAAM,EAAE,UAAA,CAAC;gBACR,iBAAW,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;gBAE1B,kBAAkB;gBAClB,KAAI,CAAC,OAAO,EAAE,CAAC;gBAEf,2CAA2C;gBAC3C,IAAI,KAAI,CAAC,oBAAoB,EAAE;oBAC9B,KAAI,CAAC,UAAU,CAAC,CAAC,EAAE,KAAI,CAAC,oBAAoB,CAAC,cAAc,CAAC,CAAC;iBAC7D;YACF,CAAC;SACD,CAAC,CAAC,CAAC;QAEJ,IAAI,CAAC,SAAS,CAAC,2BAAqB,CAAC,IAAI,CAAC,SAAS,EAAE,eAAS,CAAC,UAAU,EAAE;YAC1E,oFAAoF;YACpF,sFAAsF;YACtF,qFAAqF;YACrF,uDAAuD;YACvD,qFAAqF;YACrF,sFAAsF;YACtF,8DAA8D;YAC9D,IAAI,CAAC,KAAI,CAAC,uBAAuB,CAAC,WAAW,EAAE,EAAE;gBAChD,KAAI,CAAC,uBAAuB,CAAC,QAAQ,EAAE,CAAC;aACxC;QACF,CAAC,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,yCAAmB,GAA3B;QAEC,2BAA2B;QAC3B,IAAI,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,kCAA4B,CAAC,SAAS,CAAC,EAAE;YACvE,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,kCAA4B,CAAC,SAAS,CAAE,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;SACjH;QAED,4BAA4B;aACvB,IAAI,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,6BAAuB,CAAC,SAAS,CAAC,EAAE;YACxE,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,6BAAuB,CAAC,SAAS,CAAE,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;SACrH;QAED,OAAO,SAAS,CAAC;IAClB,CAAC;IAEO,gCAAU,GAAlB,UAAmB,KAAgB,EAAE,cAA+B;QAApE,iBAsFC;QApFA,yBAAyB;QACzB,IAAM,iBAAiB,GAAG;YACzB,IAAI,WAA6B,CAAC;YAClC,IAAI,OAAO,cAAc,KAAK,QAAQ,EAAE;gBACvC,WAAW,GAAG,KAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAI,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC;aACrE;iBAAM;gBACN,WAAW,GAAG,KAAI,CAAC,SAAS,CAAC;aAC7B;YAED,OAAO,WAAW,CAAC;QACpB,CAAC,CAAC;QAEF,2BAA2B;QAC3B,IAAI,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,kCAA4B,CAAC,SAAS,CAAC,EAAE;YACvE,IAAM,kBAAkB,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,kCAA4B,CAAC,SAAS,CAAE,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;YAE7G,gCAAgC;YAChC,IAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,kBAAkB,CAAC,CAAC;YAC/D,IAAI,WAAW,EAAE;gBAChB,IAAI,OAAO,cAAc,KAAK,QAAQ,IAAI,WAAW,KAAK,IAAI,CAAC,SAAS,EAAE;oBACzE,OAAO;iBACP;gBAED,qBAAqB;gBACrB,IAAI,WAAW,SAA8B,CAAC;gBAC9C,IAAI,OAAO,cAAc,KAAK,QAAQ,EAAE;oBACvC,IAAI,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,EAAE;wBAChC,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,WAAW,EAAE,IAAI,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC;qBACnF;yBAAM;wBACN,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,WAAW,EAAE,IAAI,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC;qBACnF;iBACD;gBAED,4BAA4B;qBACvB;oBACJ,IAAI,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,EAAE;wBAChC,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,WAAW,EAAE,IAAI,CAAC,SAAS,EAAE,EAAE,IAAI,EAAE,oCAAc,CAAC,YAAY,EAAE,CAAC,CAAC;qBAC3G;yBAAM;wBACN,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,WAAW,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;qBACpE;iBACD;gBAED,IAAI,WAAW,EAAE;oBAChB,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC;iBACzC;aACD;YAED,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,kCAA4B,CAAC,SAAS,CAAC,CAAC;SACrE;QAED,4BAA4B;aACvB,IAAI,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,6BAAuB,CAAC,SAAS,CAAC,EAAE;YACxE,IAAM,aAAa,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,6BAAuB,CAAC,SAAS,CAAE,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;YACpG,IAAM,WAAW,GAAG,iBAAiB,EAAE,CAAC;YAExC,gCAAgC;YAChC,IAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;YAClE,IAAI,WAAW,EAAE;gBAChB,IAAI,WAAW,KAAK,WAAW,EAAE;oBAChC,OAAO;iBACP;gBAED,uBAAuB;gBACvB,IAAM,OAAO,GAAG,mCAA0B,CAAC,WAAW,EAAE,aAAa,CAAC,MAAM,EAAE,sBAAa,CAAC,MAAM,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;gBACtH,WAAW,CAAC,UAAU,CAAC,aAAa,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;gBAEtD,0BAA0B;gBAC1B,WAAW,CAAC,KAAK,EAAE,CAAC;gBAEpB,uCAAuC;gBACvC,IAAM,UAAU,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,aAAa,CAAC,CAAC;gBAC9D,IAAI,CAAC,UAAU,EAAE;oBAChB,WAAW,CAAC,WAAW,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;iBAC9C;aACD;YAED,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,6BAAuB,CAAC,SAAS,CAAC,CAAC;SACjE;QAED,yBAAyB;aACpB;YACJ,IAAM,WAAW,GAAG,IAAI,CAAC,oBAAoB,CAAC,cAAc,CAAC,0BAAoB,EAAE,EAAE,kBAAkB,EAAE,IAAI,CAAC,+CAA+C,EAAE,CAAC,CAAC;YACjK,WAAW,CAAC,UAAU,CAAC,KAAK,EAAE,cAAM,OAAA,iBAAiB,EAAE,EAAnB,CAAmB,EAAE,UAAA,WAAW,IAAI,OAAA,WAAY,CAAC,KAAK,EAAE,EAApB,CAAoB,CAAC,CAAC;SAC9F;IACF,CAAC;IAEO,qCAAe,GAAvB,UAAwB,CAAY,EAAE,aAAiC;QACtE,IAAI,aAAa,IAAI,CAAE,aAAa,CAAC,MAAsB,CAAC,mBAAmB,EAAE,EAAE;YAClF,OAAO,KAAK,CAAC;SACb;QAED,OAAO,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,qBAAW,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,IAAI,qBAAW,CAAC,CAAC;IACjE,CAAC;IAEO,qCAAe,GAAvB,UAAwB,SAAiB,EAAE,SAAiB,EAAE,eAAwB;QAAtF,iBAoHC;QAnHA,IAAM,qBAAqB,GAAG,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,uBAAuB,KAAK,OAAO,CAAC;QAE5F,IAAM,kBAAkB,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,WAAW,CAAC;QAC9D,IAAM,mBAAmB,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,YAAY,GAAG,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAEhG,IAAI,wBAAgC,CAAC;QACrC,IAAI,eAAe,EAAE;YACpB,wBAAwB,GAAG,qBAAqB,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,mFAAmF;SACjJ;aAAM;YACN,wBAAwB,GAAG,GAAG,CAAC,CAAC,6CAA6C;SAC7E;QAED,IAAI,yBAAiC,CAAC;QACtC,IAAI,eAAe,EAAE;YACpB,yBAAyB,GAAG,qBAAqB,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,mFAAmF;SAClJ;aAAM;YACN,yBAAyB,GAAG,GAAG,CAAC,CAAC,6CAA6C;SAC9E;QAED,IAAM,kBAAkB,GAAG,kBAAkB,GAAG,wBAAwB,CAAC;QACzE,IAAM,mBAAmB,GAAG,mBAAmB,GAAG,yBAAyB,CAAC;QAE5E,IAAM,mBAAmB,GAAG,kBAAkB,GAAG,CAAC,CAAC,CAAE,mCAAmC;QACxF,IAAM,oBAAoB,GAAG,mBAAmB,GAAG,CAAC,CAAC,CAAC,gCAAgC;QAEtF,4CAA4C;QAC5C,uHAAuH;QACvH,uCAAuC;QACvC,qCAAqC;QACrC,0EAA0E;QAC1E,6EAA6E;QAC7E,gDAAgD;QAChD,gDAAgD;QAEhD,yEAAyE;QACzE,IAAI,cAA0C,CAAC;QAC/C,IACC,SAAS,GAAG,kBAAkB,IAAI,SAAS,GAAG,kBAAkB,GAAG,kBAAkB;YACrF,SAAS,GAAG,mBAAmB,IAAI,SAAS,GAAG,mBAAmB,GAAG,mBAAmB,EACvF;YACD,cAAc,GAAG,SAAS,CAAC;SAC3B;QAED,2BAA2B;aACtB;YAEJ,2DAA2D;YAC3D,8BAA8B;YAC9B,iDAAiD;YACjD,wBAAwB;YACxB,6CAA6C;YAC7C,wBAAwB;YACxB,2CAA2C;YAC3C,0BAA0B;YAC1B,iDAAiD;YACjD,IAAI,qBAAqB,EAAE;gBAC1B,IAAI,SAAS,GAAG,mBAAmB,EAAE;oBACpC,cAAc,GAAG,oCAAc,CAAC,IAAI,CAAC;iBACrC;qBAAM,IAAI,SAAS,GAAG,mBAAmB,GAAG,CAAC,EAAE;oBAC/C,cAAc,GAAG,oCAAc,CAAC,KAAK,CAAC;iBACtC;qBAAM,IAAI,SAAS,GAAG,mBAAmB,GAAG,CAAC,EAAE;oBAC/C,cAAc,GAAG,oCAAc,CAAC,EAAE,CAAC;iBACnC;qBAAM;oBACN,cAAc,GAAG,oCAAc,CAAC,IAAI,CAAC;iBACrC;aACD;YAED,6DAA6D;YAC7D,8BAA8B;YAC9B,iDAAiD;YACjD,sBAAsB;YACtB,iDAAiD;YACjD,8CAA8C;YAC9C,iDAAiD;YACjD,wBAAwB;YACxB,iDAAiD;iBAC5C;gBACJ,IAAI,SAAS,GAAG,oBAAoB,EAAE;oBACrC,cAAc,GAAG,oCAAc,CAAC,EAAE,CAAC;iBACnC;qBAAM,IAAI,SAAS,GAAG,oBAAoB,GAAG,CAAC,EAAE;oBAChD,cAAc,GAAG,oCAAc,CAAC,IAAI,CAAC;iBACrC;qBAAM,IAAI,SAAS,GAAG,kBAAkB,GAAG,CAAC,EAAE;oBAC9C,cAAc,GAAG,oCAAc,CAAC,IAAI,CAAC;iBACrC;qBAAM;oBACN,cAAc,GAAG,oCAAc,CAAC,KAAK,CAAC;iBACtC;aACD;SACD;QAED,wCAAwC;QACxC,QAAQ,cAAc,EAAE;YACvB,KAAK,oCAAc,CAAC,EAAE;gBACrB,IAAI,CAAC,iBAAiB,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;gBAC9E,MAAM;YACP,KAAK,oCAAc,CAAC,IAAI;gBACvB,IAAI,CAAC,iBAAiB,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;gBAChF,MAAM;YACP,KAAK,oCAAc,CAAC,IAAI;gBACvB,IAAI,CAAC,iBAAiB,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC;gBAC9E,MAAM;YACP,KAAK,oCAAc,CAAC,KAAK;gBACxB,IAAI,CAAC,iBAAiB,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC;gBAChF,MAAM;YACP;gBACC,IAAI,CAAC,iBAAiB,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC;SAChF;QAED,uCAAuC;QACvC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,GAAG,GAAG,CAAC;QAEjC,iEAAiE;QACjE,UAAU,CAAC,cAAM,OAAA,cAAQ,CAAC,KAAI,CAAC,OAAO,EAAE,yBAAyB,CAAC,EAAjD,CAAiD,EAAE,CAAC,CAAC,CAAC;QAEvE,sCAAsC;QACtC,IAAI,CAAC,oBAAoB,GAAG,EAAE,cAAc,gBAAA,EAAE,CAAC;IAChD,CAAC;IAEO,uCAAiB,GAAzB,UAA0B,OAAqE;QAE9F,YAAY;QACZ,IAAM,YAAY,GAAG,IAAI,CAAC,sBAAsB,EAAE,CAAC;QACnD,IAAI,YAAY,EAAE;YACjB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,GAAG,iBAAe,YAAY,QAAK,CAAC;SAC/D;aAAM;YACN,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC;SACrC;QAED,UAAU;QACV,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC;QACrC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;QACvC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;QACzC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAC5C,CAAC;IAEO,4CAAsB,GAA9B;QACC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,IAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,QAAQ,EAAE;YACpE,OAAO,4BAAmB,CAAC,CAAC,+CAA+C;SAC3E;QAED,OAAO,CAAC,CAAC;IACV,CAAC;IAEO,iCAAW,GAAnB;QAEC,gBAAgB;QAChB,IAAI,CAAC,iBAAiB,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC;QAC/E,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,GAAG,GAAG,CAAC;QACjC,iBAAW,CAAC,IAAI,CAAC,OAAO,EAAE,yBAAyB,CAAC,CAAC;QAErD,0BAA0B;QAC1B,IAAI,CAAC,oBAAoB,GAAG,SAAS,CAAC;IACvC,CAAC;IAED,8BAAQ,GAAR,UAAS,OAAoB;QAC5B,OAAO,OAAO,KAAK,IAAI,CAAC,SAAS,IAAI,OAAO,KAAK,IAAI,CAAC,OAAO,CAAC;IAC/D,CAAC;IAED,6BAAO,GAAP;QACC,iBAAM,OAAO,WAAE,CAAC;QAEhB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;IACvB,CAAC;IAxZc,sBAAU,GAAG,sCAAsC,CAAC;IAyZpE,kBAAC;CAAA,AA3ZD,CAA0B,gBAAQ,GA2ZjC;AAED;IAAsC,4CAAQ;IAS7C,0BACS,QAA+B,EAC/B,SAAsB,EACf,YAA2B,EACF,oBAA2C;QAJpF,YAMC,kBAAM,YAAY,CAAC,SAGnB;QARQ,cAAQ,GAAR,QAAQ,CAAuB;QAC/B,eAAS,GAAT,SAAS,CAAa;QAEU,0BAAoB,GAApB,oBAAoB,CAAuB;QAT5E,aAAO,GAAG,CAAC,CAAC;QAEH,oBAAc,GAAG,4BAAsB,CAAC,WAAW,EAA2B,CAAC;QAC/E,mBAAa,GAAG,4BAAsB,CAAC,WAAW,EAAgC,CAAC;QAUnG,KAAI,CAAC,iBAAiB,EAAE,CAAC;;IAC1B,CAAC;IAED,sBAAY,qCAAO;aAAnB;YACC,IAAI,IAAI,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE;gBAC7C,OAAO,IAAI,CAAC,QAAQ,CAAC;aACrB;YAED,OAAO,SAAS,CAAC;QAClB,CAAC;;;OAAA;IAEO,4CAAiB,GAAzB;QAAA,iBAIC;QAHA,IAAI,CAAC,SAAS,CAAC,2BAAqB,CAAC,IAAI,CAAC,SAAS,EAAE,eAAS,CAAC,UAAU,EAAE,UAAA,CAAC,IAAI,OAAA,KAAI,CAAC,WAAW,CAAC,CAAC,CAAC,EAAnB,CAAmB,CAAC,CAAC,CAAC;QACtG,IAAI,CAAC,SAAS,CAAC,2BAAqB,CAAC,IAAI,CAAC,SAAS,EAAE,eAAS,CAAC,UAAU,EAAE,cAAM,OAAA,KAAI,CAAC,WAAW,EAAE,EAAlB,CAAkB,CAAC,CAAC,CAAC;QACtG,CAAC,IAAI,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC,OAAO,CAAC,UAAA,IAAI,IAAI,OAAA,KAAI,CAAC,SAAS,CAAC,2BAAqB,CAAC,IAAmB,EAAE,eAAS,CAAC,QAAQ,EAAE,cAAM,OAAA,KAAI,CAAC,SAAS,EAAE,EAAhB,CAAgB,CAAC,CAAC,EAAtG,CAAsG,CAAC,CAAC;IAClJ,CAAC;IAEO,sCAAW,GAAnB,UAAoB,KAAgB;QACnC,IAAI,CAAC,OAAO,EAAE,CAAC;QAEf,oBAAoB;QACpB,IACC,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,6BAAuB,CAAC,SAAS,CAAC;YAC/D,CAAC,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,kCAA4B,CAAC,SAAS,CAAC;YACnE,KAAK,CAAC,YAAY,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,uDAAuD;UAC7G;YACD,KAAK,CAAC,YAAY,CAAC,UAAU,GAAG,MAAM,CAAC;YACvC,OAAO,CAAC,uBAAuB;SAC/B;QAED,mBAAmB;QACnB,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;QAE3B,IAAM,MAAM,GAAG,KAAK,CAAC,MAAqB,CAAC;QAC3C,IAAI,MAAM,EAAE;YAEX,yFAAyF;YACzF,IAAI,IAAI,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;gBACnD,IAAI,CAAC,cAAc,EAAE,CAAC;aACtB;YAED,6BAA6B;YAC7B,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;gBAClB,IAAM,eAAe,GAAG,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC;gBACzD,IAAI,eAAe,EAAE;oBACpB,IAAI,CAAC,QAAQ,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,QAAQ,EAAE,eAAe,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,oBAAoB,CAAC,CAAC;iBAC9G;aACD;SACD;IACF,CAAC;IAEO,sCAAW,GAAnB;QACC,IAAI,CAAC,OAAO,EAAE,CAAC;QAEf,IAAI,IAAI,CAAC,OAAO,KAAK,CAAC,EAAE;YACvB,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;SAC5B;IACF,CAAC;IAEO,oCAAS,GAAjB;QACC,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;QAEjB,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;QAC5B,IAAI,CAAC,cAAc,EAAE,CAAC;IACvB,CAAC;IAEO,8CAAmB,GAA3B,UAA4B,KAAkB;QAC7C,IAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;QACpC,KAAwB,UAAM,EAAN,iBAAM,EAAN,oBAAM,EAAN,IAAM,EAAE;YAA3B,IAAM,SAAS,eAAA;YACnB,IAAI,gBAAU,CAAC,KAAK,EAAE,SAAS,CAAC,OAAO,CAAC,EAAE;gBACzC,OAAO,SAAS,CAAC;aACjB;SACD;QAED,OAAO,SAAS,CAAC;IAClB,CAAC;IAEO,0CAAe,GAAvB,UAAwB,aAAsB;QAC7C,iBAAW,CAAC,IAAI,CAAC,SAAS,EAAE,cAAc,EAAE,aAAa,CAAC,CAAC;IAC5D,CAAC;IAED,kCAAO,GAAP;QACC,iBAAM,OAAO,WAAE,CAAC;QAEhB,IAAI,CAAC,cAAc,EAAE,CAAC;IACvB,CAAC;IAEO,yCAAc,GAAtB;QACC,IAAI,IAAI,CAAC,OAAO,EAAE;YACjB,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;YACvB,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;SAC1B;IACF,CAAC;IA7GW,gBAAgB;QAY1B,mBAAA,4BAAa,CAAA;QACb,mBAAA,qCAAqB,CAAA;OAbX,gBAAgB,CA8G5B;IAAD,uBAAC;CAAA,AA9GD,CAAsC,gBAAQ,GA8G7C;AA9GY,4CAAgB","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport 'vs/css!./media/editordroptarget';\nimport { LocalSelectionTransfer, DraggedEditorIdentifier, ResourcesDropHandler, DraggedEditorGroupIdentifier, DragAndDropObserver } from 'vs/workbench/browser/dnd';\nimport { addDisposableListener, EventType, EventHelper, isAncestor, toggleClass, addClass, removeClass } from 'vs/base/browser/dom';\nimport { IEditorGroupsAccessor, EDITOR_TITLE_HEIGHT, IEditorGroupView, getActiveTextEditorOptions } from 'vs/workbench/browser/parts/editor/editor';\nimport { EDITOR_DRAG_AND_DROP_BACKGROUND, Themable } from 'vs/workbench/common/theme';\nimport { IThemeService } from 'vs/platform/theme/common/themeService';\nimport { activeContrastBorder } from 'vs/platform/theme/common/colorRegistry';\nimport { IEditorIdentifier, EditorInput, EditorOptions } from 'vs/workbench/common/editor';\nimport { isMacintosh } from 'vs/base/browser/browser';\nimport { GroupDirection, MergeGroupMode } from 'vs/workbench/services/editor/common/editorGroupsService';\nimport { toDisposable } from 'vs/base/common/lifecycle';\nimport { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';\nimport { RunOnceScheduler } from 'vs/base/common/async';\n\ninterface IDropOperation {\n\tsplitDirection?: GroupDirection;\n}\n\nclass DropOverlay extends Themable {\n\n\tprivate static OVERLAY_ID = 'monaco-workbench-editor-drop-overlay';\n\n\tprivate container: HTMLElement;\n\tprivate overlay: HTMLElement;\n\n\tprivate currentDropOperation?: IDropOperation;\n\tprivate _disposed: boolean;\n\n\tprivate cleanupOverlayScheduler: RunOnceScheduler;\n\n\tprivate readonly editorTransfer = LocalSelectionTransfer.getInstance<DraggedEditorIdentifier>();\n\tprivate readonly groupTransfer = LocalSelectionTransfer.getInstance<DraggedEditorGroupIdentifier>();\n\n\tconstructor(\n\t\tprivate accessor: IEditorGroupsAccessor,\n\t\tprivate groupView: IEditorGroupView,\n\t\tthemeService: IThemeService,\n\t\tprivate instantiationService: IInstantiationService\n\t) {\n\t\tsuper(themeService);\n\n\t\tthis.cleanupOverlayScheduler = this._register(new RunOnceScheduler(() => this.dispose(), 300));\n\n\t\tthis.create();\n\t}\n\n\tget disposed(): boolean {\n\t\treturn this._disposed;\n\t}\n\n\tprivate create(): void {\n\t\tconst overlayOffsetHeight = this.getOverlayOffsetHeight();\n\n\t\t// Container\n\t\tthis.container = document.createElement('div');\n\t\tthis.container.id = DropOverlay.OVERLAY_ID;\n\t\tthis.container.style.top = `${overlayOffsetHeight}px`;\n\n\t\t// Parent\n\t\tthis.groupView.element.appendChild(this.container);\n\t\taddClass(this.groupView.element, 'dragged-over');\n\t\tthis._register(toDisposable(() => {\n\t\t\tthis.groupView.element.removeChild(this.container);\n\t\t\tremoveClass(this.groupView.element, 'dragged-over');\n\t\t}));\n\n\t\t// Overlay\n\t\tthis.overlay = document.createElement('div');\n\t\taddClass(this.overlay, 'editor-group-overlay-indicator');\n\t\tthis.container.appendChild(this.overlay);\n\n\t\t// Overlay Event Handling\n\t\tthis.registerListeners();\n\n\t\t// Styles\n\t\tthis.updateStyles();\n\t}\n\n\tprotected updateStyles(): void {\n\n\t\t// Overlay drop background\n\t\tthis.overlay.style.backgroundColor = this.getColor(EDITOR_DRAG_AND_DROP_BACKGROUND);\n\n\t\t// Overlay contrast border (if any)\n\t\tconst activeContrastBorderColor = this.getColor(activeContrastBorder);\n\t\tthis.overlay.style.outlineColor = activeContrastBorderColor;\n\t\tthis.overlay.style.outlineOffset = activeContrastBorderColor ? '-2px' : null;\n\t\tthis.overlay.style.outlineStyle = activeContrastBorderColor ? 'dashed' : null;\n\t\tthis.overlay.style.outlineWidth = activeContrastBorderColor ? '2px' : null;\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(new DragAndDropObserver(this.container, {\n\t\t\tonDragEnter: e => undefined,\n\t\t\tonDragOver: e => {\n\t\t\t\tconst isDraggingGroup = this.groupTransfer.hasData(DraggedEditorGroupIdentifier.prototype);\n\t\t\t\tconst isDraggingEditor = this.editorTransfer.hasData(DraggedEditorIdentifier.prototype);\n\n\t\t\t\t// Update the dropEffect to \"copy\" if there is no local data to be dragged because\n\t\t\t\t// in that case we can only copy the data into and not move it from its source\n\t\t\t\tif (!isDraggingEditor && !isDraggingGroup && e.dataTransfer) {\n\t\t\t\t\te.dataTransfer.dropEffect = 'copy';\n\t\t\t\t}\n\n\t\t\t\t// Find out if operation is valid\n\t\t\t\tconst isCopy = isDraggingGroup ? this.isCopyOperation(e) : isDraggingEditor ? this.isCopyOperation(e, this.editorTransfer.getData(DraggedEditorIdentifier.prototype)![0].identifier) : true;\n\t\t\t\tif (!isCopy) {\n\t\t\t\t\tconst sourceGroupView = this.findSourceGroupView();\n\t\t\t\t\tif (sourceGroupView === this.groupView) {\n\t\t\t\t\t\tif (isDraggingGroup || (isDraggingEditor && sourceGroupView.count < 2)) {\n\t\t\t\t\t\t\tthis.hideOverlay();\n\t\t\t\t\t\t\treturn; // do not allow to drop group/editor on itself if this results in an empty group\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Position overlay\n\t\t\t\tthis.positionOverlay(e.offsetX, e.offsetY, isDraggingGroup);\n\n\t\t\t\t// Make sure to stop any running cleanup scheduler to remove the overlay\n\t\t\t\tif (this.cleanupOverlayScheduler.isScheduled()) {\n\t\t\t\t\tthis.cleanupOverlayScheduler.cancel();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonDragLeave: e => this.dispose(),\n\t\t\tonDragEnd: e => this.dispose(),\n\n\t\t\tonDrop: e => {\n\t\t\t\tEventHelper.stop(e, true);\n\n\t\t\t\t// Dispose overlay\n\t\t\t\tthis.dispose();\n\n\t\t\t\t// Handle drop if we have a valid operation\n\t\t\t\tif (this.currentDropOperation) {\n\t\t\t\t\tthis.handleDrop(e, this.currentDropOperation.splitDirection);\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\n\t\tthis._register(addDisposableListener(this.container, EventType.MOUSE_OVER, () => {\n\t\t\t// Under some circumstances we have seen reports where the drop overlay is not being\n\t\t\t// cleaned up and as such the editor area remains under the overlay so that you cannot\n\t\t\t// type into the editor anymore. This seems related to using VMs and DND via host and\n\t\t\t// guest OS, though some users also saw it without VMs.\n\t\t\t// To protect against this issue we always destroy the overlay as soon as we detect a\n\t\t\t// mouse event over it. The delay is used to guarantee we are not interfering with the\n\t\t\t// actual DROP event that can also trigger a mouse over event.\n\t\t\tif (!this.cleanupOverlayScheduler.isScheduled()) {\n\t\t\t\tthis.cleanupOverlayScheduler.schedule();\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate findSourceGroupView(): IEditorGroupView | undefined {\n\n\t\t// Check for group transfer\n\t\tif (this.groupTransfer.hasData(DraggedEditorGroupIdentifier.prototype)) {\n\t\t\treturn this.accessor.getGroup(this.groupTransfer.getData(DraggedEditorGroupIdentifier.prototype)![0].identifier);\n\t\t}\n\n\t\t// Check for editor transfer\n\t\telse if (this.editorTransfer.hasData(DraggedEditorIdentifier.prototype)) {\n\t\t\treturn this.accessor.getGroup(this.editorTransfer.getData(DraggedEditorIdentifier.prototype)![0].identifier.groupId);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate handleDrop(event: DragEvent, splitDirection?: GroupDirection): void {\n\n\t\t// Determine target group\n\t\tconst ensureTargetGroup = () => {\n\t\t\tlet targetGroup: IEditorGroupView;\n\t\t\tif (typeof splitDirection === 'number') {\n\t\t\t\ttargetGroup = this.accessor.addGroup(this.groupView, splitDirection);\n\t\t\t} else {\n\t\t\t\ttargetGroup = this.groupView;\n\t\t\t}\n\n\t\t\treturn targetGroup;\n\t\t};\n\n\t\t// Check for group transfer\n\t\tif (this.groupTransfer.hasData(DraggedEditorGroupIdentifier.prototype)) {\n\t\t\tconst draggedEditorGroup = this.groupTransfer.getData(DraggedEditorGroupIdentifier.prototype)![0].identifier;\n\n\t\t\t// Return if the drop is a no-op\n\t\t\tconst sourceGroup = this.accessor.getGroup(draggedEditorGroup);\n\t\t\tif (sourceGroup) {\n\t\t\t\tif (typeof splitDirection !== 'number' && sourceGroup === this.groupView) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Split to new group\n\t\t\t\tlet targetGroup: IEditorGroupView | undefined;\n\t\t\t\tif (typeof splitDirection === 'number') {\n\t\t\t\t\tif (this.isCopyOperation(event)) {\n\t\t\t\t\t\ttargetGroup = this.accessor.copyGroup(sourceGroup, this.groupView, splitDirection);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttargetGroup = this.accessor.moveGroup(sourceGroup, this.groupView, splitDirection);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Merge into existing group\n\t\t\t\telse {\n\t\t\t\t\tif (this.isCopyOperation(event)) {\n\t\t\t\t\t\ttargetGroup = this.accessor.mergeGroup(sourceGroup, this.groupView, { mode: MergeGroupMode.COPY_EDITORS });\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttargetGroup = this.accessor.mergeGroup(sourceGroup, this.groupView);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (targetGroup) {\n\t\t\t\t\tthis.accessor.activateGroup(targetGroup);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.groupTransfer.clearData(DraggedEditorGroupIdentifier.prototype);\n\t\t}\n\n\t\t// Check for editor transfer\n\t\telse if (this.editorTransfer.hasData(DraggedEditorIdentifier.prototype)) {\n\t\t\tconst draggedEditor = this.editorTransfer.getData(DraggedEditorIdentifier.prototype)![0].identifier;\n\t\t\tconst targetGroup = ensureTargetGroup();\n\n\t\t\t// Return if the drop is a no-op\n\t\t\tconst sourceGroup = this.accessor.getGroup(draggedEditor.groupId);\n\t\t\tif (sourceGroup) {\n\t\t\t\tif (sourceGroup === targetGroup) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Open in target group\n\t\t\t\tconst options = getActiveTextEditorOptions(sourceGroup, draggedEditor.editor, EditorOptions.create({ pinned: true }));\n\t\t\t\ttargetGroup.openEditor(draggedEditor.editor, options);\n\n\t\t\t\t// Ensure target has focus\n\t\t\t\ttargetGroup.focus();\n\n\t\t\t\t// Close in source group unless we copy\n\t\t\t\tconst copyEditor = this.isCopyOperation(event, draggedEditor);\n\t\t\t\tif (!copyEditor) {\n\t\t\t\t\tsourceGroup.closeEditor(draggedEditor.editor);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.editorTransfer.clearData(DraggedEditorIdentifier.prototype);\n\t\t}\n\n\t\t// Check for URI transfer\n\t\telse {\n\t\t\tconst dropHandler = this.instantiationService.createInstance(ResourcesDropHandler, { allowWorkspaceOpen: true /* open workspace instead of file if dropped */ });\n\t\t\tdropHandler.handleDrop(event, () => ensureTargetGroup(), targetGroup => targetGroup!.focus());\n\t\t}\n\t}\n\n\tprivate isCopyOperation(e: DragEvent, draggedEditor?: IEditorIdentifier): boolean {\n\t\tif (draggedEditor && !(draggedEditor.editor as EditorInput).supportsSplitEditor()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn (e.ctrlKey && !isMacintosh) || (e.altKey && isMacintosh);\n\t}\n\n\tprivate positionOverlay(mousePosX: number, mousePosY: number, isDraggingGroup: boolean): void {\n\t\tconst preferSplitVertically = this.accessor.partOptions.openSideBySideDirection === 'right';\n\n\t\tconst editorControlWidth = this.groupView.element.clientWidth;\n\t\tconst editorControlHeight = this.groupView.element.clientHeight - this.getOverlayOffsetHeight();\n\n\t\tlet edgeWidthThresholdFactor: number;\n\t\tif (isDraggingGroup) {\n\t\t\tedgeWidthThresholdFactor = preferSplitVertically ? 0.3 : 0.1; // give larger threshold when dragging group depending on preferred split direction\n\t\t} else {\n\t\t\tedgeWidthThresholdFactor = 0.1; // 10% threshold to split if dragging editors\n\t\t}\n\n\t\tlet edgeHeightThresholdFactor: number;\n\t\tif (isDraggingGroup) {\n\t\t\tedgeHeightThresholdFactor = preferSplitVertically ? 0.1 : 0.3; // give larger threshold when dragging group depending on preferred split direction\n\t\t} else {\n\t\t\tedgeHeightThresholdFactor = 0.1; // 10% threshold to split if dragging editors\n\t\t}\n\n\t\tconst edgeWidthThreshold = editorControlWidth * edgeWidthThresholdFactor;\n\t\tconst edgeHeightThreshold = editorControlHeight * edgeHeightThresholdFactor;\n\n\t\tconst splitWidthThreshold = editorControlWidth / 3;\t\t// offer to split left/right at 33%\n\t\tconst splitHeightThreshold = editorControlHeight / 3;\t// offer to split up/down at 33%\n\n\t\t// Enable to debug the drop threshold square\n\t\t// let child = this.overlay.children.item(0) as HTMLElement || this.overlay.appendChild(document.createElement('div'));\n\t\t// child.style.backgroundColor = 'red';\n\t\t// child.style.position = 'absolute';\n\t\t// child.style.width = (groupViewWidth - (2 * edgeWidthThreshold)) + 'px';\n\t\t// child.style.height = (groupViewHeight - (2 * edgeHeightThreshold)) + 'px';\n\t\t// child.style.left = edgeWidthThreshold + 'px';\n\t\t// child.style.top = edgeHeightThreshold + 'px';\n\n\t\t// No split if mouse is above certain threshold in the center of the view\n\t\tlet splitDirection: GroupDirection | undefined;\n\t\tif (\n\t\t\tmousePosX > edgeWidthThreshold && mousePosX < editorControlWidth - edgeWidthThreshold &&\n\t\t\tmousePosY > edgeHeightThreshold && mousePosY < editorControlHeight - edgeHeightThreshold\n\t\t) {\n\t\t\tsplitDirection = undefined;\n\t\t}\n\n\t\t// Offer to split otherwise\n\t\telse {\n\n\t\t\t// User prefers to split vertically: offer a larger hitzone\n\t\t\t// for this direction like so:\n\t\t\t// ----------------------------------------------\n\t\t\t// |\t\t|\t\tSPLIT UP\t\t|\t\t\t|\n\t\t\t// | SPLIT \t|-----------------------|\tSPLIT\t|\n\t\t\t// |\t\t|\t\t  MERGE\t\t\t|\t\t\t|\n\t\t\t// | LEFT\t|-----------------------|\tRIGHT\t|\n\t\t\t// |\t\t|\t\tSPLIT DOWN\t\t|\t\t\t|\n\t\t\t// ----------------------------------------------\n\t\t\tif (preferSplitVertically) {\n\t\t\t\tif (mousePosX < splitWidthThreshold) {\n\t\t\t\t\tsplitDirection = GroupDirection.LEFT;\n\t\t\t\t} else if (mousePosX > splitWidthThreshold * 2) {\n\t\t\t\t\tsplitDirection = GroupDirection.RIGHT;\n\t\t\t\t} else if (mousePosY < editorControlHeight / 2) {\n\t\t\t\t\tsplitDirection = GroupDirection.UP;\n\t\t\t\t} else {\n\t\t\t\t\tsplitDirection = GroupDirection.DOWN;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// User prefers to split horizontally: offer a larger hitzone\n\t\t\t// for this direction like so:\n\t\t\t// ----------------------------------------------\n\t\t\t// |\t\t\t\tSPLIT UP\t\t\t\t\t|\n\t\t\t// |--------------------------------------------|\n\t\t\t// |  SPLIT LEFT  |\t   MERGE\t|  SPLIT RIGHT  |\n\t\t\t// |--------------------------------------------|\n\t\t\t// |\t\t\t\tSPLIT DOWN\t\t\t\t\t|\n\t\t\t// ----------------------------------------------\n\t\t\telse {\n\t\t\t\tif (mousePosY < splitHeightThreshold) {\n\t\t\t\t\tsplitDirection = GroupDirection.UP;\n\t\t\t\t} else if (mousePosY > splitHeightThreshold * 2) {\n\t\t\t\t\tsplitDirection = GroupDirection.DOWN;\n\t\t\t\t} else if (mousePosX < editorControlWidth / 2) {\n\t\t\t\t\tsplitDirection = GroupDirection.LEFT;\n\t\t\t\t} else {\n\t\t\t\t\tsplitDirection = GroupDirection.RIGHT;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Draw overlay based on split direction\n\t\tswitch (splitDirection) {\n\t\t\tcase GroupDirection.UP:\n\t\t\t\tthis.doPositionOverlay({ top: '0', left: '0', width: '100%', height: '50%' });\n\t\t\t\tbreak;\n\t\t\tcase GroupDirection.DOWN:\n\t\t\t\tthis.doPositionOverlay({ top: '50%', left: '0', width: '100%', height: '50%' });\n\t\t\t\tbreak;\n\t\t\tcase GroupDirection.LEFT:\n\t\t\t\tthis.doPositionOverlay({ top: '0', left: '0', width: '50%', height: '100%' });\n\t\t\t\tbreak;\n\t\t\tcase GroupDirection.RIGHT:\n\t\t\t\tthis.doPositionOverlay({ top: '0', left: '50%', width: '50%', height: '100%' });\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.doPositionOverlay({ top: '0', left: '0', width: '100%', height: '100%' });\n\t\t}\n\n\t\t// Make sure the overlay is visible now\n\t\tthis.overlay.style.opacity = '1';\n\n\t\t// Enable transition after a timeout to prevent initial animation\n\t\tsetTimeout(() => addClass(this.overlay, 'overlay-move-transition'), 0);\n\n\t\t// Remember as current split direction\n\t\tthis.currentDropOperation = { splitDirection };\n\t}\n\n\tprivate doPositionOverlay(options: { top: string, left: string, width: string, height: string }): void {\n\n\t\t// Container\n\t\tconst offsetHeight = this.getOverlayOffsetHeight();\n\t\tif (offsetHeight) {\n\t\t\tthis.container.style.height = `calc(100% - ${offsetHeight}px)`;\n\t\t} else {\n\t\t\tthis.container.style.height = '100%';\n\t\t}\n\n\t\t// Overlay\n\t\tthis.overlay.style.top = options.top;\n\t\tthis.overlay.style.left = options.left;\n\t\tthis.overlay.style.width = options.width;\n\t\tthis.overlay.style.height = options.height;\n\t}\n\n\tprivate getOverlayOffsetHeight(): number {\n\t\tif (!this.groupView.isEmpty() && this.accessor.partOptions.showTabs) {\n\t\t\treturn EDITOR_TITLE_HEIGHT; // show overlay below title if group shows tabs\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tprivate hideOverlay(): void {\n\n\t\t// Reset overlay\n\t\tthis.doPositionOverlay({ top: '0', left: '0', width: '100%', height: '100%' });\n\t\tthis.overlay.style.opacity = '0';\n\t\tremoveClass(this.overlay, 'overlay-move-transition');\n\n\t\t// Reset current operation\n\t\tthis.currentDropOperation = undefined;\n\t}\n\n\tcontains(element: HTMLElement): boolean {\n\t\treturn element === this.container || element === this.overlay;\n\t}\n\n\tdispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis._disposed = true;\n\t}\n}\n\nexport class EditorDropTarget extends Themable {\n\n\tprivate _overlay?: DropOverlay;\n\n\tprivate counter = 0;\n\n\tprivate readonly editorTransfer = LocalSelectionTransfer.getInstance<DraggedEditorIdentifier>();\n\tprivate readonly groupTransfer = LocalSelectionTransfer.getInstance<DraggedEditorGroupIdentifier>();\n\n\tconstructor(\n\t\tprivate accessor: IEditorGroupsAccessor,\n\t\tprivate container: HTMLElement,\n\t\t@IThemeService themeService: IThemeService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService\n\t) {\n\t\tsuper(themeService);\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate get overlay(): DropOverlay | undefined {\n\t\tif (this._overlay && !this._overlay.disposed) {\n\t\t\treturn this._overlay;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(addDisposableListener(this.container, EventType.DRAG_ENTER, e => this.onDragEnter(e)));\n\t\tthis._register(addDisposableListener(this.container, EventType.DRAG_LEAVE, () => this.onDragLeave()));\n\t\t[this.container, window].forEach(node => this._register(addDisposableListener(node as HTMLElement, EventType.DRAG_END, () => this.onDragEnd())));\n\t}\n\n\tprivate onDragEnter(event: DragEvent): void {\n\t\tthis.counter++;\n\n\t\t// Validate transfer\n\t\tif (\n\t\t\t!this.editorTransfer.hasData(DraggedEditorIdentifier.prototype) &&\n\t\t\t!this.groupTransfer.hasData(DraggedEditorGroupIdentifier.prototype) &&\n\t\t\tevent.dataTransfer && !event.dataTransfer.types.length // see https://github.com/Microsoft/vscode/issues/25789\n\t\t) {\n\t\t\tevent.dataTransfer.dropEffect = 'none';\n\t\t\treturn; // unsupported transfer\n\t\t}\n\n\t\t// Signal DND start\n\t\tthis.updateContainer(true);\n\n\t\tconst target = event.target as HTMLElement;\n\t\tif (target) {\n\n\t\t\t// Somehow we managed to move the mouse quickly out of the current overlay, so destroy it\n\t\t\tif (this.overlay && !this.overlay.contains(target)) {\n\t\t\t\tthis.disposeOverlay();\n\t\t\t}\n\n\t\t\t// Create overlay over target\n\t\t\tif (!this.overlay) {\n\t\t\t\tconst targetGroupView = this.findTargetGroupView(target);\n\t\t\t\tif (targetGroupView) {\n\t\t\t\t\tthis._overlay = new DropOverlay(this.accessor, targetGroupView, this.themeService, this.instantiationService);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onDragLeave(): void {\n\t\tthis.counter--;\n\n\t\tif (this.counter === 0) {\n\t\t\tthis.updateContainer(false);\n\t\t}\n\t}\n\n\tprivate onDragEnd(): void {\n\t\tthis.counter = 0;\n\n\t\tthis.updateContainer(false);\n\t\tthis.disposeOverlay();\n\t}\n\n\tprivate findTargetGroupView(child: HTMLElement): IEditorGroupView | undefined {\n\t\tconst groups = this.accessor.groups;\n\t\tfor (const groupView of groups) {\n\t\t\tif (isAncestor(child, groupView.element)) {\n\t\t\t\treturn groupView;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate updateContainer(isDraggedOver: boolean): void {\n\t\ttoggleClass(this.container, 'dragged-over', isDraggedOver);\n\t}\n\n\tdispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.disposeOverlay();\n\t}\n\n\tprivate disposeOverlay(): void {\n\t\tif (this.overlay) {\n\t\t\tthis.overlay.dispose();\n\t\t\tthis._overlay = undefined;\n\t\t}\n\t}\n}\n"]}]}