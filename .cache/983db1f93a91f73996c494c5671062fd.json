{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/packages/ide/src/fill/client.ts","dependencies":[{"path":"/home/coding/workspace/packages/ide/src/fill/client.ts","mtime":1555841535682},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"@coder/events\", \"@coder/logger\", \"@coder/protocol\", \"../retry\"], function (require, exports, events_1, logger_1, protocol_1, retry_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * A connection based on a web socket. Automatically reconnects and buffers\n     * messages during connection.\n     */\n    class WebsocketConnection {\n        constructor() {\n            this.messageBuffer = [];\n            this.socketTimeoutDelay = 60 * 1000;\n            this.retry = retry_1.retry.register(\"Socket\", () => this.connect());\n            this.isUp = false;\n            this.closed = false;\n            this.messageEmitter = new events_1.Emitter();\n            this.closeEmitter = new events_1.Emitter();\n            this.upEmitter = new events_1.Emitter();\n            this.downEmitter = new events_1.Emitter();\n            this.onUp = this.upEmitter.event;\n            this.onClose = this.closeEmitter.event;\n            this.onDown = this.downEmitter.event;\n            this.onMessage = this.messageEmitter.event;\n            this.retry.block();\n            this.retry.run();\n        }\n        /**\n         * Send data across the socket. If closed, will error. If connecting, will\n         * queue.\n         */\n        send(data) {\n            if (this.closed) {\n                throw new Error(\"web socket is closed\");\n            }\n            if (!this.activeSocket || this.activeSocket.readyState !== this.activeSocket.OPEN) {\n                this.messageBuffer.push(data);\n            }\n            else {\n                this.activeSocket.send(data);\n            }\n        }\n        /**\n         * Close socket connection.\n         */\n        close() {\n            this.closed = true;\n            this.dispose();\n            this.closeEmitter.emit();\n        }\n        /**\n         * Connect to the server.\n         */\n        connect() {\n            return __awaiter(this, void 0, void 0, function* () {\n                const socket = yield this.openSocket();\n                socket.addEventListener(\"message\", (event) => {\n                    this.messageEmitter.emit(event.data);\n                });\n                socket.addEventListener(\"close\", (event) => {\n                    if (this.isUp) {\n                        this.isUp = false;\n                        try {\n                            this.downEmitter.emit(undefined);\n                        }\n                        catch (error) {\n                            // Don't let errors here prevent restarting.\n                            logger_1.logger.error(error.message);\n                        }\n                    }\n                    logger_1.logger.warn(\"Web socket closed\", logger_1.field(\"code\", event.code), logger_1.field(\"reason\", event.reason), logger_1.field(\"wasClean\", event.wasClean));\n                    if (!this.closed) {\n                        this.retry.block();\n                        this.retry.run();\n                    }\n                });\n                // Send any messages that were queued while we were waiting to connect.\n                while (this.messageBuffer.length > 0) {\n                    socket.send(this.messageBuffer.shift());\n                }\n                if (!this.isUp) {\n                    this.isUp = true;\n                    this.upEmitter.emit(undefined);\n                }\n            });\n        }\n        /**\n         * Open a web socket, disposing the previous connection if any.\n         */\n        openSocket() {\n            return __awaiter(this, void 0, void 0, function* () {\n                this.dispose();\n                const wsProto = location.protocol === \"https:\" ? \"wss\" : \"ws\";\n                const socket = new WebSocket(`${wsProto}://${location.host}${location.pathname}`);\n                socket.binaryType = \"arraybuffer\";\n                this.activeSocket = socket;\n                const socketWaitTimeout = window.setTimeout(() => {\n                    socket.close();\n                }, this.socketTimeoutDelay);\n                yield new Promise((resolve, reject) => {\n                    const doReject = () => {\n                        clearTimeout(socketWaitTimeout);\n                        socket.removeEventListener(\"error\", doReject);\n                        socket.removeEventListener(\"close\", doReject);\n                        reject();\n                    };\n                    socket.addEventListener(\"error\", doReject);\n                    socket.addEventListener(\"close\", doReject);\n                    socket.addEventListener(\"open\", () => {\n                        clearTimeout(socketWaitTimeout);\n                        socket.removeEventListener(\"error\", doReject);\n                        socket.removeEventListener(\"close\", doReject);\n                        resolve();\n                    });\n                });\n                return socket;\n            });\n        }\n        /**\n         * Dispose the current connection.\n         */\n        dispose() {\n            if (this.activeSocket) {\n                this.activeSocket.close();\n            }\n        }\n    }\n    // Global instance so all fills can use the same client.\n    exports.client = new protocol_1.Client(new WebsocketConnection());\n});\n",null]}