{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/themes/common/plistParser.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/themes/common/plistParser.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var ChCode;\n    (function (ChCode) {\n        ChCode[ChCode[\"BOM\"] = 65279] = \"BOM\";\n        ChCode[ChCode[\"SPACE\"] = 32] = \"SPACE\";\n        ChCode[ChCode[\"TAB\"] = 9] = \"TAB\";\n        ChCode[ChCode[\"CARRIAGE_RETURN\"] = 13] = \"CARRIAGE_RETURN\";\n        ChCode[ChCode[\"LINE_FEED\"] = 10] = \"LINE_FEED\";\n        ChCode[ChCode[\"SLASH\"] = 47] = \"SLASH\";\n        ChCode[ChCode[\"LESS_THAN\"] = 60] = \"LESS_THAN\";\n        ChCode[ChCode[\"QUESTION_MARK\"] = 63] = \"QUESTION_MARK\";\n        ChCode[ChCode[\"EXCLAMATION_MARK\"] = 33] = \"EXCLAMATION_MARK\";\n    })(ChCode || (ChCode = {}));\n    var State;\n    (function (State) {\n        State[State[\"ROOT_STATE\"] = 0] = \"ROOT_STATE\";\n        State[State[\"DICT_STATE\"] = 1] = \"DICT_STATE\";\n        State[State[\"ARR_STATE\"] = 2] = \"ARR_STATE\";\n    })(State || (State = {}));\n    function parseWithLocation(content, filename, locationKeyName) {\n        return _parse(content, filename, locationKeyName);\n    }\n    exports.parseWithLocation = parseWithLocation;\n    /**\n     * A very fast plist parser\n     */\n    function parse(content) {\n        return _parse(content, null, null);\n    }\n    exports.parse = parse;\n    function _parse(content, filename, locationKeyName) {\n        const len = content.length;\n        let pos = 0;\n        let line = 1;\n        let char = 0;\n        // Skip UTF8 BOM\n        if (len > 0 && content.charCodeAt(0) === ChCode.BOM) {\n            pos = 1;\n        }\n        function advancePosBy(by) {\n            if (locationKeyName === null) {\n                pos = pos + by;\n            }\n            else {\n                while (by > 0) {\n                    let chCode = content.charCodeAt(pos);\n                    if (chCode === ChCode.LINE_FEED) {\n                        pos++;\n                        line++;\n                        char = 0;\n                    }\n                    else {\n                        pos++;\n                        char++;\n                    }\n                    by--;\n                }\n            }\n        }\n        function advancePosTo(to) {\n            if (locationKeyName === null) {\n                pos = to;\n            }\n            else {\n                advancePosBy(to - pos);\n            }\n        }\n        function skipWhitespace() {\n            while (pos < len) {\n                let chCode = content.charCodeAt(pos);\n                if (chCode !== ChCode.SPACE && chCode !== ChCode.TAB && chCode !== ChCode.CARRIAGE_RETURN && chCode !== ChCode.LINE_FEED) {\n                    break;\n                }\n                advancePosBy(1);\n            }\n        }\n        function advanceIfStartsWith(str) {\n            if (content.substr(pos, str.length) === str) {\n                advancePosBy(str.length);\n                return true;\n            }\n            return false;\n        }\n        function advanceUntil(str) {\n            let nextOccurence = content.indexOf(str, pos);\n            if (nextOccurence !== -1) {\n                advancePosTo(nextOccurence + str.length);\n            }\n            else {\n                // EOF\n                advancePosTo(len);\n            }\n        }\n        function captureUntil(str) {\n            let nextOccurence = content.indexOf(str, pos);\n            if (nextOccurence !== -1) {\n                let r = content.substring(pos, nextOccurence);\n                advancePosTo(nextOccurence + str.length);\n                return r;\n            }\n            else {\n                // EOF\n                let r = content.substr(pos);\n                advancePosTo(len);\n                return r;\n            }\n        }\n        let state = State.ROOT_STATE;\n        let cur = null;\n        let stateStack = [];\n        let objStack = [];\n        let curKey = null;\n        function pushState(newState, newCur) {\n            stateStack.push(state);\n            objStack.push(cur);\n            state = newState;\n            cur = newCur;\n        }\n        function popState() {\n            if (stateStack.length === 0) {\n                return fail('illegal state stack');\n            }\n            state = stateStack.pop();\n            cur = objStack.pop();\n        }\n        function fail(msg) {\n            throw new Error('Near offset ' + pos + ': ' + msg + ' ~~~' + content.substr(pos, 50) + '~~~');\n        }\n        const dictState = {\n            enterDict: function () {\n                if (curKey === null) {\n                    return fail('missing <key>');\n                }\n                let newDict = {};\n                if (locationKeyName !== null) {\n                    newDict[locationKeyName] = {\n                        filename: filename,\n                        line: line,\n                        char: char\n                    };\n                }\n                cur[curKey] = newDict;\n                curKey = null;\n                pushState(State.DICT_STATE, newDict);\n            },\n            enterArray: function () {\n                if (curKey === null) {\n                    return fail('missing <key>');\n                }\n                let newArr = [];\n                cur[curKey] = newArr;\n                curKey = null;\n                pushState(State.ARR_STATE, newArr);\n            }\n        };\n        const arrState = {\n            enterDict: function () {\n                let newDict = {};\n                if (locationKeyName !== null) {\n                    newDict[locationKeyName] = {\n                        filename: filename,\n                        line: line,\n                        char: char\n                    };\n                }\n                cur.push(newDict);\n                pushState(State.DICT_STATE, newDict);\n            },\n            enterArray: function () {\n                let newArr = [];\n                cur.push(newArr);\n                pushState(State.ARR_STATE, newArr);\n            }\n        };\n        function enterDict() {\n            if (state === State.DICT_STATE) {\n                dictState.enterDict();\n            }\n            else if (state === State.ARR_STATE) {\n                arrState.enterDict();\n            }\n            else { // ROOT_STATE\n                cur = {};\n                if (locationKeyName !== null) {\n                    cur[locationKeyName] = {\n                        filename: filename,\n                        line: line,\n                        char: char\n                    };\n                }\n                pushState(State.DICT_STATE, cur);\n            }\n        }\n        function leaveDict() {\n            if (state === State.DICT_STATE) {\n                popState();\n            }\n            else if (state === State.ARR_STATE) {\n                return fail('unexpected </dict>');\n            }\n            else { // ROOT_STATE\n                return fail('unexpected </dict>');\n            }\n        }\n        function enterArray() {\n            if (state === State.DICT_STATE) {\n                dictState.enterArray();\n            }\n            else if (state === State.ARR_STATE) {\n                arrState.enterArray();\n            }\n            else { // ROOT_STATE\n                cur = [];\n                pushState(State.ARR_STATE, cur);\n            }\n        }\n        function leaveArray() {\n            if (state === State.DICT_STATE) {\n                return fail('unexpected </array>');\n            }\n            else if (state === State.ARR_STATE) {\n                popState();\n            }\n            else { // ROOT_STATE\n                return fail('unexpected </array>');\n            }\n        }\n        function acceptKey(val) {\n            if (state === State.DICT_STATE) {\n                if (curKey !== null) {\n                    return fail('too many <key>');\n                }\n                curKey = val;\n            }\n            else if (state === State.ARR_STATE) {\n                return fail('unexpected <key>');\n            }\n            else { // ROOT_STATE\n                return fail('unexpected <key>');\n            }\n        }\n        function acceptString(val) {\n            if (state === State.DICT_STATE) {\n                if (curKey === null) {\n                    return fail('missing <key>');\n                }\n                cur[curKey] = val;\n                curKey = null;\n            }\n            else if (state === State.ARR_STATE) {\n                cur.push(val);\n            }\n            else { // ROOT_STATE\n                cur = val;\n            }\n        }\n        function acceptReal(val) {\n            if (isNaN(val)) {\n                return fail('cannot parse float');\n            }\n            if (state === State.DICT_STATE) {\n                if (curKey === null) {\n                    return fail('missing <key>');\n                }\n                cur[curKey] = val;\n                curKey = null;\n            }\n            else if (state === State.ARR_STATE) {\n                cur.push(val);\n            }\n            else { // ROOT_STATE\n                cur = val;\n            }\n        }\n        function acceptInteger(val) {\n            if (isNaN(val)) {\n                return fail('cannot parse integer');\n            }\n            if (state === State.DICT_STATE) {\n                if (curKey === null) {\n                    return fail('missing <key>');\n                }\n                cur[curKey] = val;\n                curKey = null;\n            }\n            else if (state === State.ARR_STATE) {\n                cur.push(val);\n            }\n            else { // ROOT_STATE\n                cur = val;\n            }\n        }\n        function acceptDate(val) {\n            if (state === State.DICT_STATE) {\n                if (curKey === null) {\n                    return fail('missing <key>');\n                }\n                cur[curKey] = val;\n                curKey = null;\n            }\n            else if (state === State.ARR_STATE) {\n                cur.push(val);\n            }\n            else { // ROOT_STATE\n                cur = val;\n            }\n        }\n        function acceptData(val) {\n            if (state === State.DICT_STATE) {\n                if (curKey === null) {\n                    return fail('missing <key>');\n                }\n                cur[curKey] = val;\n                curKey = null;\n            }\n            else if (state === State.ARR_STATE) {\n                cur.push(val);\n            }\n            else { // ROOT_STATE\n                cur = val;\n            }\n        }\n        function acceptBool(val) {\n            if (state === State.DICT_STATE) {\n                if (curKey === null) {\n                    return fail('missing <key>');\n                }\n                cur[curKey] = val;\n                curKey = null;\n            }\n            else if (state === State.ARR_STATE) {\n                cur.push(val);\n            }\n            else { // ROOT_STATE\n                cur = val;\n            }\n        }\n        function escapeVal(str) {\n            return str.replace(/&#([0-9]+);/g, function (_, m0) {\n                return String.fromCodePoint(parseInt(m0, 10));\n            }).replace(/&#x([0-9a-f]+);/g, function (_, m0) {\n                return String.fromCodePoint(parseInt(m0, 16));\n            }).replace(/&amp;|&lt;|&gt;|&quot;|&apos;/g, function (_) {\n                switch (_) {\n                    case '&amp;': return '&';\n                    case '&lt;': return '<';\n                    case '&gt;': return '>';\n                    case '&quot;': return '\"';\n                    case '&apos;': return '\\'';\n                }\n                return _;\n            });\n        }\n        function parseOpenTag() {\n            let r = captureUntil('>');\n            let isClosed = false;\n            if (r.charCodeAt(r.length - 1) === ChCode.SLASH) {\n                isClosed = true;\n                r = r.substring(0, r.length - 1);\n            }\n            return {\n                name: r.trim(),\n                isClosed: isClosed\n            };\n        }\n        function parseTagValue(tag) {\n            if (tag.isClosed) {\n                return '';\n            }\n            let val = captureUntil('</');\n            advanceUntil('>');\n            return escapeVal(val);\n        }\n        while (pos < len) {\n            skipWhitespace();\n            if (pos >= len) {\n                break;\n            }\n            const chCode = content.charCodeAt(pos);\n            advancePosBy(1);\n            if (chCode !== ChCode.LESS_THAN) {\n                return fail('expected <');\n            }\n            if (pos >= len) {\n                return fail('unexpected end of input');\n            }\n            const peekChCode = content.charCodeAt(pos);\n            if (peekChCode === ChCode.QUESTION_MARK) {\n                advancePosBy(1);\n                advanceUntil('?>');\n                continue;\n            }\n            if (peekChCode === ChCode.EXCLAMATION_MARK) {\n                advancePosBy(1);\n                if (advanceIfStartsWith('--')) {\n                    advanceUntil('-->');\n                    continue;\n                }\n                advanceUntil('>');\n                continue;\n            }\n            if (peekChCode === ChCode.SLASH) {\n                advancePosBy(1);\n                skipWhitespace();\n                if (advanceIfStartsWith('plist')) {\n                    advanceUntil('>');\n                    continue;\n                }\n                if (advanceIfStartsWith('dict')) {\n                    advanceUntil('>');\n                    leaveDict();\n                    continue;\n                }\n                if (advanceIfStartsWith('array')) {\n                    advanceUntil('>');\n                    leaveArray();\n                    continue;\n                }\n                return fail('unexpected closed tag');\n            }\n            let tag = parseOpenTag();\n            switch (tag.name) {\n                case 'dict':\n                    enterDict();\n                    if (tag.isClosed) {\n                        leaveDict();\n                    }\n                    continue;\n                case 'array':\n                    enterArray();\n                    if (tag.isClosed) {\n                        leaveArray();\n                    }\n                    continue;\n                case 'key':\n                    acceptKey(parseTagValue(tag));\n                    continue;\n                case 'string':\n                    acceptString(parseTagValue(tag));\n                    continue;\n                case 'real':\n                    acceptReal(parseFloat(parseTagValue(tag)));\n                    continue;\n                case 'integer':\n                    acceptInteger(parseInt(parseTagValue(tag), 10));\n                    continue;\n                case 'date':\n                    acceptDate(new Date(parseTagValue(tag)));\n                    continue;\n                case 'data':\n                    acceptData(parseTagValue(tag));\n                    continue;\n                case 'true':\n                    parseTagValue(tag);\n                    acceptBool(true);\n                    continue;\n                case 'false':\n                    parseTagValue(tag);\n                    acceptBool(false);\n                    continue;\n            }\n            if (/^plist/.test(tag.name)) {\n                continue;\n            }\n            return fail('unexpected opened tag ' + tag.name);\n        }\n        return cur;\n    }\n});\n",null]}