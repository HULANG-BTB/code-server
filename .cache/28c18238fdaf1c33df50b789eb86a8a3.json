{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/supports/electricCharacter.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/supports/electricCharacter.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar languageConfiguration_1 = require(\"vs/editor/common/modes/languageConfiguration\");\nvar supports_1 = require(\"vs/editor/common/modes/supports\");\nvar richEditBrackets_1 = require(\"vs/editor/common/modes/supports/richEditBrackets\");\nvar BracketElectricCharacterSupport = /** @class */ (function () {\n    function BracketElectricCharacterSupport(richEditBrackets, autoClosePairs, contribution) {\n        contribution = contribution || {};\n        this._richEditBrackets = richEditBrackets;\n        this._complexAutoClosePairs = autoClosePairs.filter(function (pair) { return pair.open.length > 1 && !!pair.close; }).map(function (el) { return new languageConfiguration_1.StandardAutoClosingPairConditional(el); });\n        if (contribution.docComment) {\n            // IDocComment is legacy, only partially supported\n            this._complexAutoClosePairs.push(new languageConfiguration_1.StandardAutoClosingPairConditional({ open: contribution.docComment.open, close: contribution.docComment.close || '' }));\n        }\n    }\n    BracketElectricCharacterSupport.prototype.getElectricCharacters = function () {\n        var result = [];\n        if (this._richEditBrackets) {\n            for (var i = 0, len = this._richEditBrackets.brackets.length; i < len; i++) {\n                var bracketPair = this._richEditBrackets.brackets[i];\n                var lastChar = bracketPair.close.charAt(bracketPair.close.length - 1);\n                result.push(lastChar);\n            }\n        }\n        // auto close\n        for (var _i = 0, _a = this._complexAutoClosePairs; _i < _a.length; _i++) {\n            var pair = _a[_i];\n            result.push(pair.open.charAt(pair.open.length - 1));\n        }\n        // Filter duplicate entries\n        result = result.filter(function (item, pos, array) {\n            return array.indexOf(item) === pos;\n        });\n        return result;\n    };\n    BracketElectricCharacterSupport.prototype.onElectricCharacter = function (character, context, column) {\n        return (this._onElectricAutoClose(character, context, column) ||\n            this._onElectricAutoIndent(character, context, column));\n    };\n    BracketElectricCharacterSupport.prototype._onElectricAutoIndent = function (character, context, column) {\n        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n            return null;\n        }\n        var tokenIndex = context.findTokenIndexAtOffset(column - 1);\n        if (supports_1.ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n            return null;\n        }\n        var reversedBracketRegex = this._richEditBrackets.reversedRegex;\n        var text = context.getLineContent().substring(0, column - 1) + character;\n        var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(reversedBracketRegex, 1, text, 0, text.length);\n        if (!r) {\n            return null;\n        }\n        var bracketText = text.substring(r.startColumn - 1, r.endColumn - 1);\n        bracketText = bracketText.toLowerCase();\n        var isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n        if (isOpen) {\n            return null;\n        }\n        var textBeforeBracket = text.substring(0, r.startColumn - 1);\n        if (!/^\\s*$/.test(textBeforeBracket)) {\n            // There is other text on the line before the bracket\n            return null;\n        }\n        return {\n            matchOpenBracket: bracketText\n        };\n    };\n    BracketElectricCharacterSupport.prototype._onElectricAutoClose = function (character, context, column) {\n        if (!this._complexAutoClosePairs.length) {\n            return null;\n        }\n        var line = context.getLineContent();\n        for (var i = 0, len = this._complexAutoClosePairs.length; i < len; i++) {\n            var pair = this._complexAutoClosePairs[i];\n            // See if the right electric character was pressed\n            if (character !== pair.open.charAt(pair.open.length - 1)) {\n                continue;\n            }\n            // check if the full open bracket matches\n            var start = column - pair.open.length + 1;\n            var actual = line.substring(start - 1, column - 1) + character;\n            if (actual !== pair.open) {\n                continue;\n            }\n            var lastTokenIndex = context.findTokenIndexAtOffset(column - 1);\n            var lastTokenStandardType = context.getStandardTokenType(lastTokenIndex);\n            // If we're in a scope listed in 'notIn', do nothing\n            if (!pair.isOK(lastTokenStandardType)) {\n                continue;\n            }\n            // If this line already contains the closing tag, do nothing.\n            if (line.indexOf(pair.close, column - 1) >= 0) {\n                continue;\n            }\n            return { appendText: pair.close };\n        }\n        return null;\n    };\n    return BracketElectricCharacterSupport;\n}());\nexports.BracketElectricCharacterSupport = BracketElectricCharacterSupport;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/supports/electricCharacter.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/supports/electricCharacter.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IAutoClosingPairConditional, IBracketElectricCharacterContribution, StandardAutoClosingPairConditional } from 'vs/editor/common/modes/languageConfiguration';\nimport { ScopedLineTokens, ignoreBracketsInToken } from 'vs/editor/common/modes/supports';\nimport { BracketsUtils, RichEditBrackets } from 'vs/editor/common/modes/supports/richEditBrackets';\n\n/**\n * Interface used to support electric characters\n * @internal\n */\nexport interface IElectricAction {\n\t// Only one of the following properties should be defined:\n\n\t// The line will be indented at the same level of the line\n\t// which contains the matching given bracket type.\n\tmatchOpenBracket?: string;\n\n\t// The text will be appended after the electric character.\n\tappendText?: string;\n}\n\nexport class BracketElectricCharacterSupport {\n\n\tprivate readonly _richEditBrackets: RichEditBrackets | null;\n\tprivate readonly _complexAutoClosePairs: StandardAutoClosingPairConditional[];\n\n\tconstructor(richEditBrackets: RichEditBrackets | null, autoClosePairs: IAutoClosingPairConditional[], contribution: IBracketElectricCharacterContribution | null | undefined) {\n\t\tcontribution = contribution || {};\n\t\tthis._richEditBrackets = richEditBrackets;\n\t\tthis._complexAutoClosePairs = autoClosePairs.filter(pair => pair.open.length > 1 && !!pair.close).map(el => new StandardAutoClosingPairConditional(el));\n\t\tif (contribution.docComment) {\n\t\t\t// IDocComment is legacy, only partially supported\n\t\t\tthis._complexAutoClosePairs.push(new StandardAutoClosingPairConditional({ open: contribution.docComment.open, close: contribution.docComment.close || '' }));\n\t\t}\n\t}\n\n\tpublic getElectricCharacters(): string[] {\n\t\tlet result: string[] = [];\n\n\t\tif (this._richEditBrackets) {\n\t\t\tfor (let i = 0, len = this._richEditBrackets.brackets.length; i < len; i++) {\n\t\t\t\tlet bracketPair = this._richEditBrackets.brackets[i];\n\t\t\t\tlet lastChar = bracketPair.close.charAt(bracketPair.close.length - 1);\n\t\t\t\tresult.push(lastChar);\n\t\t\t}\n\t\t}\n\n\t\t// auto close\n\t\tfor (let pair of this._complexAutoClosePairs) {\n\t\t\tresult.push(pair.open.charAt(pair.open.length - 1));\n\t\t}\n\n\t\t// Filter duplicate entries\n\t\tresult = result.filter((item, pos, array) => {\n\t\t\treturn array.indexOf(item) === pos;\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tpublic onElectricCharacter(character: string, context: ScopedLineTokens, column: number): IElectricAction | null {\n\t\treturn (this._onElectricAutoClose(character, context, column) ||\n\t\t\tthis._onElectricAutoIndent(character, context, column));\n\t}\n\n\tprivate _onElectricAutoIndent(character: string, context: ScopedLineTokens, column: number): IElectricAction | null {\n\n\t\tif (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet tokenIndex = context.findTokenIndexAtOffset(column - 1);\n\t\tif (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet reversedBracketRegex = this._richEditBrackets.reversedRegex;\n\t\tlet text = context.getLineContent().substring(0, column - 1) + character;\n\n\t\tlet r = BracketsUtils.findPrevBracketInToken(reversedBracketRegex, 1, text, 0, text.length);\n\t\tif (!r) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet bracketText = text.substring(r.startColumn - 1, r.endColumn - 1);\n\t\tbracketText = bracketText.toLowerCase();\n\n\t\tlet isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n\t\tif (isOpen) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet textBeforeBracket = text.substring(0, r.startColumn - 1);\n\t\tif (!/^\\s*$/.test(textBeforeBracket)) {\n\t\t\t// There is other text on the line before the bracket\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tmatchOpenBracket: bracketText\n\t\t};\n\t}\n\n\tprivate _onElectricAutoClose(character: string, context: ScopedLineTokens, column: number): IElectricAction | null {\n\t\tif (!this._complexAutoClosePairs.length) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet line = context.getLineContent();\n\n\t\tfor (let i = 0, len = this._complexAutoClosePairs.length; i < len; i++) {\n\t\t\tlet pair = this._complexAutoClosePairs[i];\n\n\t\t\t// See if the right electric character was pressed\n\t\t\tif (character !== pair.open.charAt(pair.open.length - 1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// check if the full open bracket matches\n\t\t\tlet start = column - pair.open.length + 1;\n\t\t\tlet actual = line.substring(start - 1, column - 1) + character;\n\t\t\tif (actual !== pair.open) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet lastTokenIndex = context.findTokenIndexAtOffset(column - 1);\n\t\t\tlet lastTokenStandardType = context.getStandardTokenType(lastTokenIndex);\n\t\t\t// If we're in a scope listed in 'notIn', do nothing\n\t\t\tif (!pair.isOK(lastTokenStandardType)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If this line already contains the closing tag, do nothing.\n\t\t\tif (line.indexOf(pair.close, column - 1) >= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn { appendText: pair.close };\n\t\t}\n\n\t\treturn null;\n\t}\n}\n"]}]}