{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/uint.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/uint.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function toUint8ArrayBuffer(str) {\n        if (typeof TextEncoder !== 'undefined') {\n            return new TextEncoder().encode(str).buffer;\n        }\n        let i, len, length = 0, charCode = 0, trailCharCode = 0, codepoint = 0;\n        // First pass, for the size\n        for (i = 0, len = str.length; i < len; i++) {\n            charCode = str.charCodeAt(i);\n            // Surrogate pair\n            if (charCode >= 0xD800 && charCode < 0xDC00) {\n                trailCharCode = str.charCodeAt(++i);\n                if (!(trailCharCode >= 0xDC00 && trailCharCode < 0xE000)) {\n                    throw new Error('Invalid char code');\n                }\n                // Code point can be obtained by subtracting 0xD800 and 0xDC00 from both char codes respectively\n                // and joining the 10 least significant bits from each, finally adding 0x10000.\n                codepoint = ((((charCode - 0xD800) & 0x3FF) << 10) | ((trailCharCode - 0xDC00) & 0x3FF)) + 0x10000;\n            }\n            else {\n                codepoint = charCode;\n            }\n            length += byteSizeInUTF8(codepoint);\n        }\n        let result = new ArrayBuffer(length);\n        let view = new Uint8Array(result);\n        let pos = 0;\n        // Second pass, for the data\n        for (i = 0, len = str.length; i < len; i++) {\n            charCode = str.charCodeAt(i);\n            if (charCode >= 0xD800 && charCode < 0xDC00) {\n                trailCharCode = str.charCodeAt(++i);\n                codepoint = ((((charCode - 0xD800) & 0x3FF) << 10) | ((trailCharCode - 0xDC00) & 0x3FF)) + 0x10000;\n            }\n            else {\n                codepoint = charCode;\n            }\n            pos += writeUTF8(codepoint, view, pos);\n        }\n        return result;\n    }\n    exports.toUint8ArrayBuffer = toUint8ArrayBuffer;\n    function byteSizeInUTF8(codePoint) {\n        codePoint = codePoint >>> 0;\n        if (codePoint < 0x80) {\n            return 1;\n        }\n        else if (codePoint < 0x800) {\n            return 2;\n        }\n        else if (codePoint < 0x10000) {\n            return 3;\n        }\n        else if (codePoint < 0x200000) {\n            return 4;\n        }\n        else if (codePoint < 0x4000000) {\n            return 5;\n        }\n        else if (codePoint < 0x80000000) {\n            return 6;\n        }\n        else {\n            throw new Error('Code point 0x' + toHexString(codePoint) + ' not encodable in UTF8.');\n        }\n    }\n    function writeUTF8(codePoint, buffer, pos) {\n        // How many bits needed for codePoint\n        let byteSize = byteSizeInUTF8(codePoint);\n        // 0xxxxxxx\n        if (byteSize === 1) {\n            buffer[pos] = codePoint;\n            return 1;\n        }\n        // 110xxxxx 10xxxxxx\n        // 1110xxxx 10xxxxxx 10xxxxxx\n        // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n        // 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n        // first byte\n        buffer[pos] = ((0xFC << (6 - byteSize)) | (codePoint >>> (6 * (byteSize - 1)))) & 0xFF;\n        // successive bytes\n        for (let i = 1; i < byteSize; i++) {\n            buffer[pos + i] = (0x80 | (0x3F & (codePoint >>> (6 * (byteSize - i - 1))))) & 0xFF;\n        }\n        return byteSize;\n    }\n    function leftPad(value, length, char = '0') {\n        return new Array(length - value.length + 1).join(char) + value;\n    }\n    function toHexString(value, bitsize = 32) {\n        return leftPad((value >>> 0).toString(16), bitsize / 4);\n    }\n});\n",null]}