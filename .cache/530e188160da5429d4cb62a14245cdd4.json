{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/menubar/electron-main/menubar.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/menubar/electron-main/menubar.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/platform\", \"vs/platform/environment/common/environment\", \"electron\", \"vs/platform/windows/common/windows\", \"vs/platform/configuration/common/configuration\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/update/common/update\", \"vs/platform/product/node/product\", \"vs/base/common/async\", \"vs/platform/instantiation/common/instantiation\", \"vs/base/common/labels\", \"vs/platform/windows/electron-main/windows\", \"vs/platform/history/common/history\", \"vs/platform/menubar/common/menubar\", \"vs/base/common/uri\", \"vs/platform/state/common/state\", \"vs/platform/lifecycle/electron-main/lifecycleMain\"], function (require, exports, nls, platform_1, environment_1, electron_1, windows_1, configuration_1, telemetry_1, update_1, product_1, async_1, instantiation_1, labels_1, windows_2, history_1, menubar_1, uri_1, state_1, lifecycleMain_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const telemetryFrom = 'menu';\n    let Menubar = class Menubar {\n        constructor(updateService, instantiationService, configurationService, windowsMainService, environmentService, telemetryService, historyMainService, stateService, lifecycleService) {\n            this.updateService = updateService;\n            this.configurationService = configurationService;\n            this.windowsMainService = windowsMainService;\n            this.environmentService = environmentService;\n            this.telemetryService = telemetryService;\n            this.historyMainService = historyMainService;\n            this.stateService = stateService;\n            this.lifecycleService = lifecycleService;\n            this.fallbackMenuHandlers = {};\n            this.menuUpdater = new async_1.RunOnceScheduler(() => this.doUpdateMenu(), 0);\n            this.menuGC = new async_1.RunOnceScheduler(() => { this.oldMenus = []; }, 10000);\n            this.menubarMenus = Object.create(null);\n            this.keybindings = Object.create(null);\n            if (platform_1.isMacintosh || windows_1.getTitleBarStyle(this.configurationService, this.environmentService) === 'native') {\n                this.restoreCachedMenubarData();\n            }\n            this.addFallbackHandlers();\n            this.closedLastWindow = false;\n            this.oldMenus = [];\n            this.install();\n            this.registerListeners();\n        }\n        restoreCachedMenubarData() {\n            const menubarData = this.stateService.getItem(Menubar.lastKnownMenubarStorageKey);\n            if (menubarData) {\n                if (menubarData.menus) {\n                    this.menubarMenus = menubarData.menus;\n                }\n                if (menubarData.keybindings) {\n                    this.keybindings = menubarData.keybindings;\n                }\n            }\n        }\n        addFallbackHandlers() {\n            // File Menu Items\n            this.fallbackMenuHandlers['workbench.action.files.newUntitledFile'] = () => this.windowsMainService.openNewWindow(windows_1.OpenContext.MENU);\n            this.fallbackMenuHandlers['workbench.action.newWindow'] = () => this.windowsMainService.openNewWindow(windows_1.OpenContext.MENU);\n            this.fallbackMenuHandlers['workbench.action.files.openFileFolder'] = (menuItem, win, event) => this.windowsMainService.pickFileFolderAndOpen({ forceNewWindow: this.isOptionClick(event), telemetryExtraData: { from: telemetryFrom } });\n            this.fallbackMenuHandlers['workbench.action.openWorkspace'] = (menuItem, win, event) => this.windowsMainService.pickWorkspaceAndOpen({ forceNewWindow: this.isOptionClick(event), telemetryExtraData: { from: telemetryFrom } });\n            // Recent Menu Items\n            this.fallbackMenuHandlers['workbench.action.clearRecentFiles'] = () => this.historyMainService.clearRecentlyOpened();\n            // Help Menu Items\n            if (product_1.default.twitterUrl) {\n                this.fallbackMenuHandlers['workbench.action.openTwitterUrl'] = () => this.openUrl(product_1.default.twitterUrl, 'openTwitterUrl');\n            }\n            if (product_1.default.requestFeatureUrl) {\n                this.fallbackMenuHandlers['workbench.action.openRequestFeatureUrl'] = () => this.openUrl(product_1.default.requestFeatureUrl, 'openUserVoiceUrl');\n            }\n            if (product_1.default.reportIssueUrl) {\n                this.fallbackMenuHandlers['workbench.action.openIssueReporter'] = () => this.openUrl(product_1.default.reportIssueUrl, 'openReportIssues');\n            }\n            if (product_1.default.licenseUrl) {\n                this.fallbackMenuHandlers['workbench.action.openLicenseUrl'] = () => {\n                    if (platform_1.language) {\n                        const queryArgChar = product_1.default.licenseUrl.indexOf('?') > 0 ? '&' : '?';\n                        this.openUrl(`${product_1.default.licenseUrl}${queryArgChar}lang=${platform_1.language}`, 'openLicenseUrl');\n                    }\n                    else {\n                        this.openUrl(product_1.default.licenseUrl, 'openLicenseUrl');\n                    }\n                };\n            }\n            if (product_1.default.privacyStatementUrl) {\n                this.fallbackMenuHandlers['workbench.action.openPrivacyStatementUrl'] = () => {\n                    if (platform_1.language) {\n                        const queryArgChar = product_1.default.licenseUrl.indexOf('?') > 0 ? '&' : '?';\n                        this.openUrl(`${product_1.default.privacyStatementUrl}${queryArgChar}lang=${platform_1.language}`, 'openPrivacyStatement');\n                    }\n                    else {\n                        this.openUrl(product_1.default.privacyStatementUrl, 'openPrivacyStatement');\n                    }\n                };\n            }\n        }\n        registerListeners() {\n            // Keep flag when app quits\n            this.lifecycleService.onWillShutdown(() => this.willShutdown = true);\n            // // Listen to some events from window service to update menu\n            this.windowsMainService.onWindowsCountChanged(e => this.onWindowsCountChanged(e));\n        }\n        get currentEnableMenuBarMnemonics() {\n            let enableMenuBarMnemonics = this.configurationService.getValue('window.enableMenuBarMnemonics');\n            if (typeof enableMenuBarMnemonics !== 'boolean') {\n                enableMenuBarMnemonics = true;\n            }\n            return enableMenuBarMnemonics;\n        }\n        get currentEnableNativeTabs() {\n            if (!platform_1.isMacintosh) {\n                return false;\n            }\n            let enableNativeTabs = this.configurationService.getValue('window.nativeTabs');\n            if (typeof enableNativeTabs !== 'boolean') {\n                enableNativeTabs = false;\n            }\n            return enableNativeTabs;\n        }\n        updateMenu(menubarData, windowId) {\n            this.menubarMenus = menubarData.menus;\n            this.keybindings = menubarData.keybindings;\n            // Save off new menu and keybindings\n            this.stateService.setItem(Menubar.lastKnownMenubarStorageKey, menubarData);\n            this.scheduleUpdateMenu();\n        }\n        scheduleUpdateMenu() {\n            this.menuUpdater.schedule(); // buffer multiple attempts to update the menu\n        }\n        doUpdateMenu() {\n            // Due to limitations in Electron, it is not possible to update menu items dynamically. The suggested\n            // workaround from Electron is to set the application menu again.\n            // See also https://github.com/electron/electron/issues/846\n            //\n            // Run delayed to prevent updating menu while it is open\n            if (!this.willShutdown) {\n                setTimeout(() => {\n                    if (!this.willShutdown) {\n                        this.install();\n                    }\n                }, 10 /* delay this because there is an issue with updating a menu when it is open */);\n            }\n        }\n        onWindowsCountChanged(e) {\n            if (!platform_1.isMacintosh) {\n                return;\n            }\n            // Update menu if window count goes from N > 0 or 0 > N to update menu item enablement\n            if ((e.oldCount === 0 && e.newCount > 0) || (e.oldCount > 0 && e.newCount === 0)) {\n                this.closedLastWindow = e.newCount === 0;\n                this.scheduleUpdateMenu();\n            }\n        }\n        install() {\n            // Store old menu in our array to avoid GC to collect the menu and crash. See #55347\n            // TODO@sbatten Remove this when fixed upstream by Electron\n            const oldMenu = electron_1.Menu.getApplicationMenu();\n            if (oldMenu) {\n                this.oldMenus.push(oldMenu);\n            }\n            // If we don't have a menu yet, set it to null to avoid the electron menu.\n            // This should only happen on the first launch ever\n            if (Object.keys(this.menubarMenus).length === 0) {\n                electron_1.Menu.setApplicationMenu(platform_1.isMacintosh ? new electron_1.Menu() : null);\n                return;\n            }\n            // Menus\n            const menubar = new electron_1.Menu();\n            // Mac: Application\n            let macApplicationMenuItem;\n            if (platform_1.isMacintosh) {\n                const applicationMenu = new electron_1.Menu();\n                macApplicationMenuItem = new electron_1.MenuItem({ label: product_1.default.nameShort, submenu: applicationMenu });\n                this.setMacApplicationMenu(applicationMenu);\n                menubar.append(macApplicationMenuItem);\n            }\n            // Mac: Dock\n            if (platform_1.isMacintosh && !this.appMenuInstalled) {\n                this.appMenuInstalled = true;\n                const dockMenu = new electron_1.Menu();\n                dockMenu.append(new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize({ key: 'miNewWindow', comment: ['&& denotes a mnemonic'] }, \"New &&Window\")), click: () => this.windowsMainService.openNewWindow(windows_1.OpenContext.DOCK) }));\n                electron_1.app.dock.setMenu(dockMenu);\n            }\n            // File\n            const fileMenu = new electron_1.Menu();\n            const fileMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize({ key: 'mFile', comment: ['&& denotes a mnemonic'] }, \"&&File\")), submenu: fileMenu });\n            this.setMenuById(fileMenu, 'File');\n            menubar.append(fileMenuItem);\n            // Edit\n            const editMenu = new electron_1.Menu();\n            const editMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize({ key: 'mEdit', comment: ['&& denotes a mnemonic'] }, \"&&Edit\")), submenu: editMenu });\n            this.setMenuById(editMenu, 'Edit');\n            menubar.append(editMenuItem);\n            // Selection\n            const selectionMenu = new electron_1.Menu();\n            const selectionMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize({ key: 'mSelection', comment: ['&& denotes a mnemonic'] }, \"&&Selection\")), submenu: selectionMenu });\n            this.setMenuById(selectionMenu, 'Selection');\n            menubar.append(selectionMenuItem);\n            // View\n            const viewMenu = new electron_1.Menu();\n            const viewMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize({ key: 'mView', comment: ['&& denotes a mnemonic'] }, \"&&View\")), submenu: viewMenu });\n            this.setMenuById(viewMenu, 'View');\n            menubar.append(viewMenuItem);\n            // Go\n            const gotoMenu = new electron_1.Menu();\n            const gotoMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize({ key: 'mGoto', comment: ['&& denotes a mnemonic'] }, \"&&Go\")), submenu: gotoMenu });\n            this.setMenuById(gotoMenu, 'Go');\n            menubar.append(gotoMenuItem);\n            // Debug\n            const debugMenu = new electron_1.Menu();\n            const debugMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize({ key: 'mDebug', comment: ['&& denotes a mnemonic'] }, \"&&Debug\")), submenu: debugMenu });\n            this.setMenuById(debugMenu, 'Debug');\n            menubar.append(debugMenuItem);\n            // Terminal\n            const terminalMenu = new electron_1.Menu();\n            const terminalMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize({ key: 'mTerminal', comment: ['&& denotes a mnemonic'] }, \"&&Terminal\")), submenu: terminalMenu });\n            this.setMenuById(terminalMenu, 'Terminal');\n            menubar.append(terminalMenuItem);\n            // Mac: Window\n            let macWindowMenuItem;\n            if (this.shouldDrawMenu('Window')) {\n                const windowMenu = new electron_1.Menu();\n                macWindowMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize('mWindow', \"Window\")), submenu: windowMenu, role: 'window' });\n                this.setMacWindowMenu(windowMenu);\n            }\n            if (macWindowMenuItem) {\n                menubar.append(macWindowMenuItem);\n            }\n            // Help\n            const helpMenu = new electron_1.Menu();\n            const helpMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize({ key: 'mHelp', comment: ['&& denotes a mnemonic'] }, \"&&Help\")), submenu: helpMenu, role: 'help' });\n            this.setMenuById(helpMenu, 'Help');\n            menubar.append(helpMenuItem);\n            if (menubar.items && menubar.items.length > 0) {\n                electron_1.Menu.setApplicationMenu(menubar);\n            }\n            else {\n                electron_1.Menu.setApplicationMenu(null);\n            }\n            // Dispose of older menus after some time\n            this.menuGC.schedule();\n        }\n        setMacApplicationMenu(macApplicationMenu) {\n            const about = new electron_1.MenuItem({ label: nls.localize('mAbout', \"About {0}\", product_1.default.nameLong), role: 'about' });\n            const checkForUpdates = this.getUpdateMenuItems();\n            let preferences;\n            if (this.shouldDrawMenu('Preferences')) {\n                const preferencesMenu = new electron_1.Menu();\n                this.setMenuById(preferencesMenu, 'Preferences');\n                preferences = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize({ key: 'miPreferences', comment: ['&& denotes a mnemonic'] }, \"&&Preferences\")), submenu: preferencesMenu });\n            }\n            const servicesMenu = new electron_1.Menu();\n            const services = new electron_1.MenuItem({ label: nls.localize('mServices', \"Services\"), role: 'services', submenu: servicesMenu });\n            const hide = new electron_1.MenuItem({ label: nls.localize('mHide', \"Hide {0}\", product_1.default.nameLong), role: 'hide', accelerator: 'Command+H' });\n            const hideOthers = new electron_1.MenuItem({ label: nls.localize('mHideOthers', \"Hide Others\"), role: 'hideothers', accelerator: 'Command+Alt+H' });\n            const showAll = new electron_1.MenuItem({ label: nls.localize('mShowAll', \"Show All\"), role: 'unhide' });\n            const quit = new electron_1.MenuItem(this.likeAction('workbench.action.quit', {\n                label: nls.localize('miQuit', \"Quit {0}\", product_1.default.nameLong), click: () => {\n                    if (this.windowsMainService.getWindowCount() === 0 || // allow to quit when no more windows are open\n                        !!this.windowsMainService.getFocusedWindow() || // allow to quit when window has focus (fix for https://github.com/Microsoft/vscode/issues/39191)\n                        this.windowsMainService.getLastActiveWindow().isMinimized() // allow to quit when window has no focus but is minimized (https://github.com/Microsoft/vscode/issues/63000)\n                    ) {\n                        this.windowsMainService.quit();\n                    }\n                }\n            }));\n            const actions = [about];\n            actions.push(...checkForUpdates);\n            if (preferences) {\n                actions.push(...[\n                    __separator__(),\n                    preferences\n                ]);\n            }\n            actions.push(...[\n                __separator__(),\n                services,\n                __separator__(),\n                hide,\n                hideOthers,\n                showAll,\n                __separator__(),\n                quit\n            ]);\n            actions.forEach(i => macApplicationMenu.append(i));\n        }\n        shouldDrawMenu(menuId) {\n            // We need to draw an empty menu to override the electron default\n            if (!platform_1.isMacintosh && windows_1.getTitleBarStyle(this.configurationService, this.environmentService) === 'custom') {\n                return false;\n            }\n            switch (menuId) {\n                case 'File':\n                case 'Help':\n                    if (platform_1.isMacintosh) {\n                        return (this.windowsMainService.getWindowCount() === 0 && this.closedLastWindow) || (!!this.menubarMenus && !!this.menubarMenus[menuId]);\n                    }\n                case 'Window':\n                    if (platform_1.isMacintosh) {\n                        return (this.windowsMainService.getWindowCount() === 0 && this.closedLastWindow) || !!this.menubarMenus;\n                    }\n                default:\n                    return this.windowsMainService.getWindowCount() > 0 && (!!this.menubarMenus && !!this.menubarMenus[menuId]);\n            }\n        }\n        setMenu(menu, items) {\n            items.forEach((item) => {\n                if (menubar_1.isMenubarMenuItemSeparator(item)) {\n                    menu.append(__separator__());\n                }\n                else if (menubar_1.isMenubarMenuItemSubmenu(item)) {\n                    const submenu = new electron_1.Menu();\n                    const submenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(item.label), submenu: submenu });\n                    this.setMenu(submenu, item.submenu.items);\n                    menu.append(submenuItem);\n                }\n                else if (menubar_1.isMenubarMenuItemUriAction(item)) {\n                    menu.append(this.createOpenRecentMenuItem(item.uri, item.label, item.id));\n                }\n                else if (menubar_1.isMenubarMenuItemAction(item)) {\n                    if (item.id === 'workbench.action.showAboutDialog') {\n                        this.insertCheckForUpdatesItems(menu);\n                    }\n                    if (platform_1.isMacintosh) {\n                        if (this.windowsMainService.getWindowCount() === 0 && this.closedLastWindow) {\n                            // In the fallback scenario, we are either disabled or using a fallback handler\n                            if (this.fallbackMenuHandlers[item.id]) {\n                                menu.append(new electron_1.MenuItem(this.likeAction(item.id, { label: this.mnemonicLabel(item.label), click: this.fallbackMenuHandlers[item.id] })));\n                            }\n                            else {\n                                menu.append(this.createMenuItem(item.label, item.id, false, item.checked));\n                            }\n                        }\n                        else {\n                            menu.append(this.createMenuItem(item.label, item.id, item.enabled === false ? false : true, !!item.checked));\n                        }\n                    }\n                    else {\n                        menu.append(this.createMenuItem(item.label, item.id, item.enabled === false ? false : true, !!item.checked));\n                    }\n                }\n            });\n        }\n        setMenuById(menu, menuId) {\n            if (this.menubarMenus && this.menubarMenus[menuId]) {\n                this.setMenu(menu, this.menubarMenus[menuId].items);\n            }\n        }\n        insertCheckForUpdatesItems(menu) {\n            const updateItems = this.getUpdateMenuItems();\n            if (updateItems.length) {\n                updateItems.forEach(i => menu.append(i));\n                menu.append(__separator__());\n            }\n        }\n        createOpenRecentMenuItem(uri, label, commandId) {\n            const revivedUri = uri_1.URI.revive(uri);\n            const typeHint = commandId === 'openRecentFile' || commandId === 'openRecentWorkspace' ? 'file' : 'folder';\n            return new electron_1.MenuItem(this.likeAction(commandId, {\n                label,\n                click: (menuItem, win, event) => {\n                    const openInNewWindow = this.isOptionClick(event);\n                    const success = this.windowsMainService.open({\n                        context: windows_1.OpenContext.MENU,\n                        cli: this.environmentService.args,\n                        urisToOpen: [{ uri: revivedUri, typeHint }],\n                        forceNewWindow: openInNewWindow,\n                        forceOpenWorkspaceAsFile: commandId === 'openRecentFile'\n                    }).length > 0;\n                    if (!success) {\n                        this.historyMainService.removeFromRecentlyOpened([revivedUri]);\n                    }\n                }\n            }, false));\n        }\n        isOptionClick(event) {\n            return !!(event && ((!platform_1.isMacintosh && (event.ctrlKey || event.shiftKey)) || (platform_1.isMacintosh && (event.metaKey || event.altKey))));\n        }\n        createRoleMenuItem(label, commandId, role) {\n            const options = {\n                label: this.mnemonicLabel(label),\n                role,\n                enabled: true\n            };\n            return new electron_1.MenuItem(this.withKeybinding(commandId, options));\n        }\n        setMacWindowMenu(macWindowMenu) {\n            const minimize = new electron_1.MenuItem({ label: nls.localize('mMinimize', \"Minimize\"), role: 'minimize', accelerator: 'Command+M', enabled: this.windowsMainService.getWindowCount() > 0 });\n            const zoom = new electron_1.MenuItem({ label: nls.localize('mZoom', \"Zoom\"), role: 'zoom', enabled: this.windowsMainService.getWindowCount() > 0 });\n            const bringAllToFront = new electron_1.MenuItem({ label: nls.localize('mBringToFront', \"Bring All to Front\"), role: 'front', enabled: this.windowsMainService.getWindowCount() > 0 });\n            const switchWindow = this.createMenuItem(nls.localize({ key: 'miSwitchWindow', comment: ['&& denotes a mnemonic'] }, \"Switch &&Window...\"), 'workbench.action.switchWindow');\n            const nativeTabMenuItems = [];\n            if (this.currentEnableNativeTabs) {\n                nativeTabMenuItems.push(__separator__());\n                nativeTabMenuItems.push(this.createMenuItem(nls.localize('mNewTab', \"New Tab\"), 'workbench.action.newWindowTab'));\n                nativeTabMenuItems.push(this.createRoleMenuItem(nls.localize('mShowPreviousTab', \"Show Previous Tab\"), 'workbench.action.showPreviousWindowTab', 'selectPreviousTab'));\n                nativeTabMenuItems.push(this.createRoleMenuItem(nls.localize('mShowNextTab', \"Show Next Tab\"), 'workbench.action.showNextWindowTab', 'selectNextTab'));\n                nativeTabMenuItems.push(this.createRoleMenuItem(nls.localize('mMoveTabToNewWindow', \"Move Tab to New Window\"), 'workbench.action.moveWindowTabToNewWindow', 'moveTabToNewWindow'));\n                nativeTabMenuItems.push(this.createRoleMenuItem(nls.localize('mMergeAllWindows', \"Merge All Windows\"), 'workbench.action.mergeAllWindowTabs', 'mergeAllWindows'));\n            }\n            [\n                minimize,\n                zoom,\n                switchWindow,\n                ...nativeTabMenuItems,\n                __separator__(),\n                bringAllToFront\n            ].forEach(item => macWindowMenu.append(item));\n        }\n        getUpdateMenuItems() {\n            const state = this.updateService.state;\n            switch (state.type) {\n                case update_1.StateType.Uninitialized:\n                    return [];\n                case update_1.StateType.Idle:\n                    return [new electron_1.MenuItem({\n                            label: this.mnemonicLabel(nls.localize('miCheckForUpdates', \"Check for &&Updates...\")), click: () => setTimeout(() => {\n                                this.reportMenuActionTelemetry('CheckForUpdate');\n                                const focusedWindow = this.windowsMainService.getFocusedWindow();\n                                const context = focusedWindow ? { windowId: focusedWindow.id } : null;\n                                this.updateService.checkForUpdates(context);\n                            }, 0)\n                        })];\n                case update_1.StateType.CheckingForUpdates:\n                    return [new electron_1.MenuItem({ label: nls.localize('miCheckingForUpdates', \"Checking For Updates...\"), enabled: false })];\n                case update_1.StateType.AvailableForDownload:\n                    return [new electron_1.MenuItem({\n                            label: this.mnemonicLabel(nls.localize('miDownloadUpdate', \"D&&ownload Available Update\")), click: () => {\n                                this.updateService.downloadUpdate();\n                            }\n                        })];\n                case update_1.StateType.Downloading:\n                    return [new electron_1.MenuItem({ label: nls.localize('miDownloadingUpdate', \"Downloading Update...\"), enabled: false })];\n                case update_1.StateType.Downloaded:\n                    return [new electron_1.MenuItem({\n                            label: this.mnemonicLabel(nls.localize('miInstallUpdate', \"Install &&Update...\")), click: () => {\n                                this.reportMenuActionTelemetry('InstallUpdate');\n                                this.updateService.applyUpdate();\n                            }\n                        })];\n                case update_1.StateType.Updating:\n                    return [new electron_1.MenuItem({ label: nls.localize('miInstallingUpdate', \"Installing Update...\"), enabled: false })];\n                case update_1.StateType.Ready:\n                    return [new electron_1.MenuItem({\n                            label: this.mnemonicLabel(nls.localize('miRestartToUpdate', \"Restart to &&Update\")), click: () => {\n                                this.reportMenuActionTelemetry('RestartToUpdate');\n                                this.updateService.quitAndInstall();\n                            }\n                        })];\n            }\n        }\n        static _menuItemIsTriggeredViaKeybinding(event, userSettingsLabel) {\n            // The event coming in from Electron will inform us only about the modifier keys pressed.\n            // The strategy here is to check if the modifier keys match those of the keybinding,\n            // since it is highly unlikely to use modifier keys when clicking with the mouse\n            if (!userSettingsLabel) {\n                // There is no keybinding\n                return false;\n            }\n            let ctrlRequired = /ctrl/.test(userSettingsLabel);\n            let shiftRequired = /shift/.test(userSettingsLabel);\n            let altRequired = /alt/.test(userSettingsLabel);\n            let metaRequired = /cmd/.test(userSettingsLabel) || /super/.test(userSettingsLabel);\n            if (!ctrlRequired && !shiftRequired && !altRequired && !metaRequired) {\n                // This keybinding does not use any modifier keys, so we cannot use this heuristic\n                return false;\n            }\n            return (ctrlRequired === event.ctrlKey\n                && shiftRequired === event.shiftKey\n                && altRequired === event.altKey\n                && metaRequired === event.metaKey);\n        }\n        createMenuItem(arg1, arg2, arg3, arg4) {\n            const label = this.mnemonicLabel(arg1);\n            const click = (typeof arg2 === 'function') ? arg2 : (menuItem, win, event) => {\n                const userSettingsLabel = menuItem ? menuItem.userSettingsLabel : null;\n                let commandId = arg2;\n                if (Array.isArray(arg2)) {\n                    commandId = this.isOptionClick(event) ? arg2[1] : arg2[0]; // support alternative action if we got multiple action Ids and the option key was pressed while invoking\n                }\n                if (userSettingsLabel && Menubar._menuItemIsTriggeredViaKeybinding(event, userSettingsLabel)) {\n                    this.runActionInRenderer({ type: 'keybinding', userSettingsLabel });\n                }\n                else {\n                    this.runActionInRenderer({ type: 'commandId', commandId });\n                }\n            };\n            const enabled = typeof arg3 === 'boolean' ? arg3 : this.windowsMainService.getWindowCount() > 0;\n            const checked = typeof arg4 === 'boolean' ? arg4 : false;\n            const options = {\n                label,\n                click,\n                enabled\n            };\n            if (checked) {\n                options['type'] = 'checkbox';\n                options['checked'] = checked;\n            }\n            let commandId;\n            if (typeof arg2 === 'string') {\n                commandId = arg2;\n            }\n            else if (Array.isArray(arg2)) {\n                commandId = arg2[0];\n            }\n            if (platform_1.isMacintosh) {\n                // Add role for special case menu items\n                if (commandId === 'editor.action.clipboardCutAction') {\n                    options['role'] = 'cut';\n                }\n                else if (commandId === 'editor.action.clipboardCopyAction') {\n                    options['role'] = 'copy';\n                }\n                else if (commandId === 'editor.action.clipboardPasteAction') {\n                    options['role'] = 'paste';\n                }\n                // Add context aware click handlers for special case menu items\n                if (commandId === 'undo') {\n                    options.click = this.makeContextAwareClickHandler(click, {\n                        inDevTools: devTools => devTools.undo(),\n                        inNoWindow: () => electron_1.Menu.sendActionToFirstResponder('undo:')\n                    });\n                }\n                else if (commandId === 'redo') {\n                    options.click = this.makeContextAwareClickHandler(click, {\n                        inDevTools: devTools => devTools.redo(),\n                        inNoWindow: () => electron_1.Menu.sendActionToFirstResponder('redo:')\n                    });\n                }\n                else if (commandId === 'editor.action.selectAll') {\n                    options.click = this.makeContextAwareClickHandler(click, {\n                        inDevTools: devTools => devTools.selectAll(),\n                        inNoWindow: () => electron_1.Menu.sendActionToFirstResponder('selectAll:')\n                    });\n                }\n            }\n            return new electron_1.MenuItem(this.withKeybinding(commandId, options));\n        }\n        makeContextAwareClickHandler(click, contextSpecificHandlers) {\n            return () => {\n                // No Active Window\n                const activeWindow = this.windowsMainService.getFocusedWindow();\n                if (!activeWindow) {\n                    return contextSpecificHandlers.inNoWindow();\n                }\n                // DevTools focused\n                if (activeWindow.win.webContents.isDevToolsFocused()) {\n                    return contextSpecificHandlers.inDevTools(activeWindow.win.webContents.devToolsWebContents);\n                }\n                // Finally execute command in Window\n                click();\n            };\n        }\n        runActionInRenderer(invocation) {\n            // We make sure to not run actions when the window has no focus, this helps\n            // for https://github.com/Microsoft/vscode/issues/25907 and specifically for\n            // https://github.com/Microsoft/vscode/issues/11928\n            // Still allow to run when the last active window is minimized though for\n            // https://github.com/Microsoft/vscode/issues/63000\n            let activeWindow = this.windowsMainService.getFocusedWindow();\n            if (!activeWindow) {\n                const lastActiveWindow = this.windowsMainService.getLastActiveWindow();\n                if (lastActiveWindow && lastActiveWindow.isMinimized()) {\n                    activeWindow = lastActiveWindow;\n                }\n            }\n            if (activeWindow) {\n                if (platform_1.isMacintosh && !this.environmentService.isBuilt && !activeWindow.isReady) {\n                    if ((invocation.type === 'commandId' && invocation.commandId === 'workbench.action.toggleDevTools') || (invocation.type !== 'commandId' && invocation.userSettingsLabel === 'alt+cmd+i')) {\n                        // prevent this action from running twice on macOS (https://github.com/Microsoft/vscode/issues/62719)\n                        // we already register a keybinding in bootstrap-window.js for opening developer tools in case something\n                        // goes wrong and that keybinding is only removed when the application has loaded (= window ready).\n                        return;\n                    }\n                }\n                if (invocation.type === 'commandId') {\n                    this.windowsMainService.sendToFocused('vscode:runAction', { id: invocation.commandId, from: 'menu' });\n                }\n                else {\n                    this.windowsMainService.sendToFocused('vscode:runKeybinding', { userSettingsLabel: invocation.userSettingsLabel });\n                }\n            }\n        }\n        withKeybinding(commandId, options) {\n            const binding = typeof commandId === 'string' ? this.keybindings[commandId] : undefined;\n            // Apply binding if there is one\n            if (binding && binding.label) {\n                // if the binding is native, we can just apply it\n                if (binding.isNative !== false) {\n                    options.accelerator = binding.label;\n                    options.userSettingsLabel = binding.userSettingsLabel;\n                }\n                // the keybinding is not native so we cannot show it as part of the accelerator of\n                // the menu item. we fallback to a different strategy so that we always display it\n                else if (typeof options.label === 'string') {\n                    const bindingIndex = options.label.indexOf('[');\n                    if (bindingIndex >= 0) {\n                        options.label = `${options.label.substr(0, bindingIndex)} [${binding.label}]`;\n                    }\n                    else {\n                        options.label = `${options.label} [${binding.label}]`;\n                    }\n                }\n            }\n            // Unset bindings if there is none\n            else {\n                options.accelerator = undefined;\n            }\n            return options;\n        }\n        likeAction(commandId, options, setAccelerator = !options.accelerator) {\n            if (setAccelerator) {\n                options = this.withKeybinding(commandId, options);\n            }\n            const originalClick = options.click;\n            options.click = (item, window, event) => {\n                this.reportMenuActionTelemetry(commandId);\n                if (originalClick) {\n                    originalClick(item, window, event);\n                }\n            };\n            return options;\n        }\n        openUrl(url, id) {\n            electron_1.shell.openExternal(url);\n            this.reportMenuActionTelemetry(id);\n        }\n        reportMenuActionTelemetry(id) {\n            /* __GDPR__\n                \"workbenchActionExecuted\" : {\n                    \"id\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                    \"from\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                }\n            */\n            this.telemetryService.publicLog('workbenchActionExecuted', { id, from: telemetryFrom });\n        }\n        mnemonicLabel(label) {\n            return labels_1.mnemonicMenuLabel(label, !this.currentEnableMenuBarMnemonics);\n        }\n    };\n    Menubar.lastKnownMenubarStorageKey = 'lastKnownMenubarData';\n    Menubar = __decorate([\n        __param(0, update_1.IUpdateService),\n        __param(1, instantiation_1.IInstantiationService),\n        __param(2, configuration_1.IConfigurationService),\n        __param(3, windows_2.IWindowsMainService),\n        __param(4, environment_1.IEnvironmentService),\n        __param(5, telemetry_1.ITelemetryService),\n        __param(6, history_1.IHistoryMainService),\n        __param(7, state_1.IStateService),\n        __param(8, lifecycleMain_1.ILifecycleService)\n    ], Menubar);\n    exports.Menubar = Menubar;\n    function __separator__() {\n        return new electron_1.MenuItem({ type: 'separator' });\n    }\n});\n",null]}