{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/node/config.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/config.ts","mtime":1555846338028},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"fs\", \"vs/base/common/path\", \"vs/base/common/objects\", \"vs/base/common/lifecycle\", \"vs/base/common/event\", \"vs/base/common/json\", \"vs/base/node/extfs\", \"vs/base/common/platform\"], function (require, exports, fs, path_1, objects, lifecycle_1, event_1, json, extfs, platform_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * A simple helper to watch a configured file for changes and process its contents as JSON object.\n     * Supports:\n     * - comments in JSON files and errors\n     * - symlinks for the config file itself\n     * - delayed processing of changes to accomodate for lots of changes\n     * - configurable defaults\n     */\n    class ConfigWatcher {\n        constructor(_path, options = { defaultConfig: Object.create(null), onError: error => console.error(error) }) {\n            this._path = _path;\n            this.options = options;\n            this.disposables = [];\n            this.configName = path_1.basename(this._path);\n            this._onDidUpdateConfiguration = new event_1.Emitter();\n            this.disposables.push(this._onDidUpdateConfiguration);\n            this.registerWatcher();\n            this.initAsync();\n        }\n        get path() {\n            return this._path;\n        }\n        get hasParseErrors() {\n            return this.parseErrors && this.parseErrors.length > 0;\n        }\n        get onDidUpdateConfiguration() {\n            return this._onDidUpdateConfiguration.event;\n        }\n        initAsync() {\n            this.loadAsync(config => {\n                if (!this.loaded) {\n                    this.updateCache(config); // prevent race condition if config was loaded sync already\n                }\n                else {\n                    this.cache = config; // update config\n                    this._onDidUpdateConfiguration.fire({ config });\n                }\n                if (this.options.initCallback) {\n                    this.options.initCallback(this.getConfig());\n                }\n            });\n        }\n        updateCache(value) {\n            this.cache = value;\n            this.loaded = true;\n        }\n        loadSync() {\n            try {\n                return this.parse(fs.readFileSync(this._path).toString());\n            }\n            catch (error) {\n                return this.options.defaultConfig;\n            }\n        }\n        loadAsync(callback) {\n            fs.readFile(this._path, (error, raw) => {\n                if (error) {\n                    return callback(this.options.defaultConfig);\n                }\n                return callback(this.parse(raw.toString()));\n            });\n        }\n        parse(raw) {\n            let res;\n            try {\n                this.parseErrors = [];\n                res = this.options.parse ? this.options.parse(raw, this.parseErrors) : json.parse(raw, this.parseErrors);\n                return res || this.options.defaultConfig;\n            }\n            catch (error) {\n                // Ignore parsing errors\n                return this.options.defaultConfig;\n            }\n        }\n        registerWatcher() {\n            // Watch the parent of the path so that we detect ADD and DELETES\n            const parentFolder = path_1.dirname(this._path);\n            this.watch(parentFolder, true);\n            // Check if the path is a symlink and watch its target if so\n            fs.lstat(this._path, (err, stat) => {\n                if (err || stat.isDirectory()) {\n                    return; // path is not a valid file\n                }\n                // We found a symlink\n                if (stat.isSymbolicLink()) {\n                    fs.readlink(this._path, (err, realPath) => {\n                        if (err) {\n                            return; // path is not a valid symlink\n                        }\n                        this.watch(realPath, false);\n                    });\n                }\n            });\n        }\n        watch(path, isParentFolder) {\n            if (this.disposed) {\n                return; // avoid watchers that will never get disposed by checking for being disposed\n            }\n            this.disposables.push(extfs.watch(path, (type, file) => this.onConfigFileChange(type, file, isParentFolder), (error) => this.options.onError(error)));\n        }\n        onConfigFileChange(eventType, filename, isParentFolder) {\n            if (isParentFolder) {\n                // Windows: in some cases the filename contains artifacts from the absolute path\n                // see https://github.com/nodejs/node/issues/19170\n                // As such, we have to ensure that the filename basename is used for comparison.\n                if (platform_1.isWindows && filename && filename !== this.configName) {\n                    filename = path_1.basename(filename);\n                }\n                if (filename !== this.configName) {\n                    return; // a change to a sibling file that is not our config file\n                }\n            }\n            if (this.timeoutHandle) {\n                global.clearTimeout(this.timeoutHandle);\n                this.timeoutHandle = null;\n            }\n            // we can get multiple change events for one change, so we buffer through a timeout\n            this.timeoutHandle = global.setTimeout(() => this.reload(), this.options.changeBufferDelay || 0);\n        }\n        reload(callback) {\n            this.loadAsync(currentConfig => {\n                if (!objects.equals(currentConfig, this.cache)) {\n                    this.updateCache(currentConfig);\n                    this._onDidUpdateConfiguration.fire({ config: this.cache });\n                }\n                if (callback) {\n                    return callback(currentConfig);\n                }\n            });\n        }\n        getConfig() {\n            this.ensureLoaded();\n            return this.cache;\n        }\n        ensureLoaded() {\n            if (!this.loaded) {\n                this.updateCache(this.loadSync());\n            }\n        }\n        dispose() {\n            this.disposed = true;\n            this.disposables = lifecycle_1.dispose(this.disposables);\n        }\n    }\n    exports.ConfigWatcher = ConfigWatcher;\n});\n",null]}