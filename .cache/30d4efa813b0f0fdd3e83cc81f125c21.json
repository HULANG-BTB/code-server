{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/stats/node/workspaceStats.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/stats/node/workspaceStats.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"crypto\", \"vs/base/common/errors\", \"vs/base/common/uri\", \"vs/platform/files/common/files\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/workspace/common/workspace\", \"vs/platform/environment/common/environment\", \"vs/platform/windows/common/windows\", \"vs/base/common/strings\", \"vs/base/common/network\", \"vs/platform/notification/common/notification\", \"vs/platform/workspaces/common/workspaces\", \"vs/platform/quickinput/common/quickInput\", \"vs/platform/storage/common/storage\", \"vs/base/common/resources\"], function (require, exports, nls_1, crypto, errors_1, uri_1, files_1, telemetry_1, workspace_1, environment_1, windows_1, strings_1, network_1, notification_1, workspaces_1, quickInput_1, storage_1, resources_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const SshProtocolMatcher = /^([^@:]+@)?([^:]+):/;\n    const SshUrlMatcher = /^([^@:]+@)?([^:]+):(.+)$/;\n    const AuthorityMatcher = /^([^@]+@)?([^:]+)(:\\d+)?$/;\n    const SecondLevelDomainMatcher = /([^@:.]+\\.[^@:.]+)(:\\d+)?$/;\n    const RemoteMatcher = /^\\s*url\\s*=\\s*(.+\\S)\\s*$/mg;\n    const AnyButDot = /[^.]/g;\n    const SecondLevelDomainWhitelist = [\n        'github.com',\n        'bitbucket.org',\n        'visualstudio.com',\n        'gitlab.com',\n        'heroku.com',\n        'azurewebsites.net',\n        'ibm.com',\n        'amazon.com',\n        'amazonaws.com',\n        'cloudapp.net',\n        'rhcloud.com',\n        'google.com'\n    ];\n    const ModulesToLookFor = [\n        // Packages that suggest a node server\n        'express',\n        'sails',\n        'koa',\n        'hapi',\n        'socket.io',\n        'restify',\n        // JS frameworks\n        'react',\n        'react-native',\n        '@angular/core',\n        '@ionic',\n        'vue',\n        'tns-core-modules',\n        // Other interesting packages\n        'aws-sdk',\n        'aws-amplify',\n        'azure',\n        'azure-storage',\n        'firebase',\n        '@google-cloud/common',\n        'heroku-cli'\n    ];\n    const PyModulesToLookFor = [\n        'azure',\n        'azure-storage-common',\n        'azure-storage-blob',\n        'azure-storage-file',\n        'azure-storage-queue',\n        'azure-shell',\n        'azure-cosmos',\n        'azure-devtools',\n        'azure-elasticluster',\n        'azure-eventgrid',\n        'azure-functions',\n        'azure-graphrbac',\n        'azure-keyvault',\n        'azure-loganalytics',\n        'azure-monitor',\n        'azure-servicebus',\n        'azure-servicefabric',\n        'azure-storage',\n        'azure-translator',\n        'azure-iothub-device-client',\n        'adal',\n        'pydocumentdb',\n        'botbuilder-core',\n        'botbuilder-schema',\n        'botframework-connector'\n    ];\n    function stripLowLevelDomains(domain) {\n        const match = domain.match(SecondLevelDomainMatcher);\n        return match ? match[1] : null;\n    }\n    function extractDomain(url) {\n        if (url.indexOf('://') === -1) {\n            const match = url.match(SshProtocolMatcher);\n            if (match) {\n                return stripLowLevelDomains(match[2]);\n            }\n            else {\n                return null;\n            }\n        }\n        try {\n            const uri = uri_1.URI.parse(url);\n            if (uri.authority) {\n                return stripLowLevelDomains(uri.authority);\n            }\n        }\n        catch (e) {\n            // ignore invalid URIs\n        }\n        return null;\n    }\n    function getDomainsOfRemotes(text, whitelist) {\n        const domains = new Set();\n        let match;\n        while (match = RemoteMatcher.exec(text)) {\n            const domain = extractDomain(match[1]);\n            if (domain) {\n                domains.add(domain);\n            }\n        }\n        const whitemap = whitelist.reduce((map, key) => {\n            map[key] = true;\n            return map;\n        }, Object.create(null));\n        const elements = [];\n        domains.forEach(e => elements.push(e));\n        return elements\n            .map(key => whitemap[key] ? key : key.replace(AnyButDot, 'a'));\n    }\n    exports.getDomainsOfRemotes = getDomainsOfRemotes;\n    function stripPort(authority) {\n        const match = authority.match(AuthorityMatcher);\n        return match ? match[2] : null;\n    }\n    function normalizeRemote(host, path, stripEndingDotGit) {\n        if (host && path) {\n            if (stripEndingDotGit && strings_1.endsWith(path, '.git')) {\n                path = path.substr(0, path.length - 4);\n            }\n            return (path.indexOf('/') === 0) ? `${host}${path}` : `${host}/${path}`;\n        }\n        return null;\n    }\n    function extractRemote(url, stripEndingDotGit) {\n        if (url.indexOf('://') === -1) {\n            const match = url.match(SshUrlMatcher);\n            if (match) {\n                return normalizeRemote(match[2], match[3], stripEndingDotGit);\n            }\n        }\n        try {\n            const uri = uri_1.URI.parse(url);\n            if (uri.authority) {\n                return normalizeRemote(stripPort(uri.authority), uri.path, stripEndingDotGit);\n            }\n        }\n        catch (e) {\n            // ignore invalid URIs\n        }\n        return null;\n    }\n    function getRemotes(text, stripEndingDotGit = false) {\n        const remotes = [];\n        let match;\n        while (match = RemoteMatcher.exec(text)) {\n            const remote = extractRemote(match[1], stripEndingDotGit);\n            if (remote) {\n                remotes.push(remote);\n            }\n        }\n        return remotes;\n    }\n    exports.getRemotes = getRemotes;\n    function getHashedRemotesFromConfig(text, stripEndingDotGit = false) {\n        return getRemotes(text, stripEndingDotGit).map(r => {\n            return crypto.createHash('sha1').update(r).digest('hex');\n        });\n    }\n    exports.getHashedRemotesFromConfig = getHashedRemotesFromConfig;\n    function getHashedRemotesFromUri(workspaceUri, fileService, stripEndingDotGit = false) {\n        const path = workspaceUri.path;\n        const uri = workspaceUri.with({ path: `${path !== '/' ? path : ''}/.git/config` });\n        return fileService.existsFile(uri).then(exists => {\n            if (!exists) {\n                return [];\n            }\n            return fileService.resolveContent(uri, { acceptTextOnly: true }).then(content => getHashedRemotesFromConfig(content.value, stripEndingDotGit), err => [] // ignore missing or binary file\n            );\n        });\n    }\n    exports.getHashedRemotesFromUri = getHashedRemotesFromUri;\n    let WorkspaceStats = class WorkspaceStats {\n        constructor(fileService, contextService, telemetryService, environmentService, windowService, notificationService, quickInputService, storageService) {\n            this.fileService = fileService;\n            this.contextService = contextService;\n            this.telemetryService = telemetryService;\n            this.environmentService = environmentService;\n            this.windowService = windowService;\n            this.notificationService = notificationService;\n            this.quickInputService = quickInputService;\n            this.storageService = storageService;\n            this.report();\n        }\n        report() {\n            // Workspace Stats\n            this.resolveWorkspaceTags(this.windowService.getConfiguration(), rootFiles => this.handleWorkspaceFiles(rootFiles))\n                .then(tags => this.reportWorkspaceTags(tags), error => errors_1.onUnexpectedError(error));\n            // Cloud Stats\n            this.reportCloudStats();\n            this.reportProxyStats();\n        }\n        static searchArray(arr, regEx) {\n            return arr.some(v => v.search(regEx) > -1) || undefined;\n        }\n        /* __GDPR__FRAGMENT__\n            \"WorkspaceTags\" : {\n                \"workbench.filesToOpen\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workbench.filesToCreate\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workbench.filesToDiff\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.id\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                \"workspace.roots\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.empty\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.grunt\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.gulp\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.jake\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.tsconfig\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.jsconfig\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.config.xml\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.vsc.extension\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.asp<NUMBER>\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.sln\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.unity\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.npm\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.npm.express\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.npm.sails\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.npm.koa\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.npm.hapi\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.npm.socket.io\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.npm.restify\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.npm.react\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.npm.@angular/core\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.npm.vue\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.npm.aws-sdk\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.npm.aws-amplify-sdk\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.npm.azure\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.npm.azure-storage\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.npm.@google-cloud/common\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.npm.firebase\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.npm.heroku-cli\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.bower\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.yeoman.code.ext\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.cordova.high\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.cordova.low\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.xamarin.android\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.xamarin.ios\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.android.cpp\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.reactNative\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.ionic\" : { \"classification\" : \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": \"true\" },\n                \"workspace.nativeScript\" : { \"classification\" : \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": \"true\" },\n                \"workspace.py.requirements\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.requirements.star\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.Pipfile\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.conda\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.any-azure\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-storage-common\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-storage-blob\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-storage-file\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-storage-queue\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-mgmt\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-shell\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.pulumi-azure\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-cosmos\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-devtools\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-elasticluster\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-eventgrid\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-functions\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-graphrbac\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-keyvault\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-loganalytics\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-monitor\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-servicebus\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-servicefabric\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-storage\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-translator\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-iothub-device-client\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-ml\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.azure-cognitiveservices\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.adal\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.pydocumentdb\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.botbuilder-core\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.botbuilder-schema\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                \"workspace.py.botframework-connector\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n    \n            }\n        */\n        resolveWorkspaceTags(configuration, participant) {\n            const tags = Object.create(null);\n            const state = this.contextService.getWorkbenchState();\n            const workspace = this.contextService.getWorkspace();\n            function createHash(uri) {\n                return crypto.createHash('sha1').update(uri.scheme === network_1.Schemas.file ? uri.fsPath : uri.toString()).digest('hex');\n            }\n            let workspaceId;\n            switch (state) {\n                case workspace_1.WorkbenchState.EMPTY:\n                    workspaceId = undefined;\n                    break;\n                case workspace_1.WorkbenchState.FOLDER:\n                    workspaceId = createHash(workspace.folders[0].uri);\n                    break;\n                case workspace_1.WorkbenchState.WORKSPACE:\n                    if (workspace.configuration) {\n                        workspaceId = createHash(workspace.configuration);\n                    }\n            }\n            tags['workspace.id'] = workspaceId;\n            const { filesToOpen, filesToCreate, filesToDiff } = configuration;\n            tags['workbench.filesToOpen'] = filesToOpen && filesToOpen.length || 0;\n            tags['workbench.filesToCreate'] = filesToCreate && filesToCreate.length || 0;\n            tags['workbench.filesToDiff'] = filesToDiff && filesToDiff.length || 0;\n            const isEmpty = state === workspace_1.WorkbenchState.EMPTY;\n            tags['workspace.roots'] = isEmpty ? 0 : workspace.folders.length;\n            tags['workspace.empty'] = isEmpty;\n            const folders = !isEmpty ? workspace.folders.map(folder => folder.uri) : this.environmentService.appQuality !== 'stable' && this.findFolders(configuration);\n            if (!folders || !folders.length || !this.fileService) {\n                return Promise.resolve(tags);\n            }\n            return this.fileService.resolveFiles(folders.map(resource => ({ resource }))).then((files) => {\n                const names = [].concat(...files.map(result => result.success ? (result.stat.children || []) : [])).map(c => c.name);\n                const nameSet = names.reduce((s, n) => s.add(n.toLowerCase()), new Set());\n                if (participant) {\n                    participant(names);\n                }\n                tags['workspace.grunt'] = nameSet.has('gruntfile.js');\n                tags['workspace.gulp'] = nameSet.has('gulpfile.js');\n                tags['workspace.jake'] = nameSet.has('jakefile.js');\n                tags['workspace.tsconfig'] = nameSet.has('tsconfig.json');\n                tags['workspace.jsconfig'] = nameSet.has('jsconfig.json');\n                tags['workspace.config.xml'] = nameSet.has('config.xml');\n                tags['workspace.vsc.extension'] = nameSet.has('vsc-extension-quickstart.md');\n                tags['workspace.ASP5'] = nameSet.has('project.json') && WorkspaceStats.searchArray(names, /^.+\\.cs$/i);\n                tags['workspace.sln'] = WorkspaceStats.searchArray(names, /^.+\\.sln$|^.+\\.csproj$/i);\n                tags['workspace.unity'] = nameSet.has('assets') && nameSet.has('library') && nameSet.has('projectsettings');\n                tags['workspace.npm'] = nameSet.has('package.json') || nameSet.has('node_modules');\n                tags['workspace.bower'] = nameSet.has('bower.json') || nameSet.has('bower_components');\n                tags['workspace.yeoman.code.ext'] = nameSet.has('vsc-extension-quickstart.md');\n                tags['workspace.py.requirements'] = nameSet.has('requirements.txt');\n                tags['workspace.py.requirements.star'] = WorkspaceStats.searchArray(names, /^(.*)requirements(.*)\\.txt$/i);\n                tags['workspace.py.Pipfile'] = nameSet.has('pipfile');\n                tags['workspace.py.conda'] = WorkspaceStats.searchArray(names, /^environment(\\.yml$|\\.yaml$)/i);\n                const mainActivity = nameSet.has('mainactivity.cs') || nameSet.has('mainactivity.fs');\n                const appDelegate = nameSet.has('appdelegate.cs') || nameSet.has('appdelegate.fs');\n                const androidManifest = nameSet.has('androidmanifest.xml');\n                const platforms = nameSet.has('platforms');\n                const plugins = nameSet.has('plugins');\n                const www = nameSet.has('www');\n                const properties = nameSet.has('properties');\n                const resources = nameSet.has('resources');\n                const jni = nameSet.has('jni');\n                if (tags['workspace.config.xml'] &&\n                    !tags['workspace.language.cs'] && !tags['workspace.language.vb'] && !tags['workspace.language.aspx']) {\n                    if (platforms && plugins && www) {\n                        tags['workspace.cordova.high'] = true;\n                    }\n                    else {\n                        tags['workspace.cordova.low'] = true;\n                    }\n                }\n                if (tags['workspace.config.xml'] &&\n                    !tags['workspace.language.cs'] && !tags['workspace.language.vb'] && !tags['workspace.language.aspx']) {\n                    if (nameSet.has('ionic.config.json')) {\n                        tags['workspace.ionic'] = true;\n                    }\n                }\n                if (mainActivity && properties && resources) {\n                    tags['workspace.xamarin.android'] = true;\n                }\n                if (appDelegate && resources) {\n                    tags['workspace.xamarin.ios'] = true;\n                }\n                if (androidManifest && jni) {\n                    tags['workspace.android.cpp'] = true;\n                }\n                function getFilePromises(filename, fileService, contentHandler) {\n                    return !nameSet.has(filename) ? [] : folders.map(workspaceUri => {\n                        const uri = workspaceUri.with({ path: `${workspaceUri.path !== '/' ? workspaceUri.path : ''}/${filename}` });\n                        return fileService.existsFile(uri).then(exists => {\n                            if (!exists) {\n                                return undefined;\n                            }\n                            return fileService.resolveContent(uri, { acceptTextOnly: true }).then(contentHandler);\n                        }, err => {\n                            // Ignore missing file\n                        });\n                    });\n                }\n                function addPythonTags(packageName) {\n                    if (PyModulesToLookFor.indexOf(packageName) > -1) {\n                        tags['workspace.py.' + packageName] = true;\n                    }\n                    // cognitive services has a lot of tiny packages. eg. 'azure-cognitiveservices-search-autosuggest'\n                    if (packageName.indexOf('azure-cognitiveservices') > -1) {\n                        tags['workspace.py.azure-cognitiveservices'] = true;\n                    }\n                    if (packageName.indexOf('azure-mgmt') > -1) {\n                        tags['workspace.py.azure-mgmt'] = true;\n                    }\n                    if (packageName.indexOf('azure-ml') > -1) {\n                        tags['workspace.py.azure-ml'] = true;\n                    }\n                    if (!tags['workspace.py.any-azure']) {\n                        tags['workspace.py.any-azure'] = /azure/i.test(packageName);\n                    }\n                }\n                const requirementsTxtPromises = getFilePromises('requirements.txt', this.fileService, content => {\n                    const dependencies = content.value.split(/\\r\\n|\\r|\\n/);\n                    for (let dependency of dependencies) {\n                        // Dependencies in requirements.txt can have 3 formats: `foo==3.1, foo>=3.1, foo`\n                        const format1 = dependency.split('==');\n                        const format2 = dependency.split('>=');\n                        const packageName = (format1.length === 2 ? format1[0] : format2[0]).trim();\n                        addPythonTags(packageName);\n                    }\n                });\n                const pipfilePromises = getFilePromises('pipfile', this.fileService, content => {\n                    let dependencies = content.value.split(/\\r\\n|\\r|\\n/);\n                    // We're only interested in the '[packages]' section of the Pipfile\n                    dependencies = dependencies.slice(dependencies.indexOf('[packages]') + 1);\n                    for (let dependency of dependencies) {\n                        if (dependency.trim().indexOf('[') > -1) {\n                            break;\n                        }\n                        // All dependencies in Pipfiles follow the format: `<package> = <version, or git repo, or something else>`\n                        if (dependency.indexOf('=') === -1) {\n                            continue;\n                        }\n                        const packageName = dependency.split('=')[0].trim();\n                        addPythonTags(packageName);\n                    }\n                });\n                const packageJsonPromises = getFilePromises('package.json', this.fileService, content => {\n                    try {\n                        const packageJsonContents = JSON.parse(content.value);\n                        if (packageJsonContents['dependencies']) {\n                            for (let module of ModulesToLookFor) {\n                                if ('react-native' === module) {\n                                    if (packageJsonContents['dependencies'][module]) {\n                                        tags['workspace.reactNative'] = true;\n                                    }\n                                }\n                                else if ('tns-core-modules' === module) {\n                                    if (packageJsonContents['dependencies'][module]) {\n                                        tags['workspace.nativescript'] = true;\n                                    }\n                                }\n                                else {\n                                    if (packageJsonContents['dependencies'][module]) {\n                                        tags['workspace.npm.' + module] = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    catch (e) {\n                        // Ignore errors when resolving file or parsing file contents\n                    }\n                });\n                return Promise.all([...packageJsonPromises, ...requirementsTxtPromises, ...pipfilePromises]).then(() => tags);\n            });\n        }\n        handleWorkspaceFiles(rootFiles) {\n            const state = this.contextService.getWorkbenchState();\n            const workspace = this.contextService.getWorkspace();\n            // Handle top-level workspace files for local single folder workspace\n            if (state === workspace_1.WorkbenchState.FOLDER && workspace.folders[0].uri.scheme === network_1.Schemas.file) {\n                const workspaceFiles = rootFiles.filter(workspaces_1.hasWorkspaceFileExtension);\n                if (workspaceFiles.length > 0) {\n                    this.doHandleWorkspaceFiles(workspace.folders[0].uri, workspaceFiles);\n                }\n            }\n        }\n        doHandleWorkspaceFiles(folder, workspaces) {\n            if (this.storageService.getBoolean(WorkspaceStats.DISABLE_WORKSPACE_PROMPT_KEY, storage_1.StorageScope.WORKSPACE)) {\n                return; // prompt disabled by user\n            }\n            const doNotShowAgain = {\n                label: nls_1.localize('never again', \"Don't Show Again\"),\n                isSecondary: true,\n                run: () => this.storageService.store(WorkspaceStats.DISABLE_WORKSPACE_PROMPT_KEY, true, storage_1.StorageScope.WORKSPACE)\n            };\n            // Prompt to open one workspace\n            if (workspaces.length === 1) {\n                const workspaceFile = workspaces[0];\n                this.notificationService.prompt(notification_1.Severity.Info, nls_1.localize('workspaceFound', \"This folder contains a workspace file '{0}'. Do you want to open it? [Learn more]({1}) about workspace files.\", workspaceFile, 'https://go.microsoft.com/fwlink/?linkid=2025315'), [{\n                        label: nls_1.localize('openWorkspace', \"Open Workspace\"),\n                        run: () => this.windowService.openWindow([{ uri: resources_1.joinPath(folder, workspaceFile), typeHint: 'file' }])\n                    }, doNotShowAgain]);\n            }\n            // Prompt to select a workspace from many\n            else if (workspaces.length > 1) {\n                this.notificationService.prompt(notification_1.Severity.Info, nls_1.localize('workspacesFound', \"This folder contains multiple workspace files. Do you want to open one? [Learn more]({0}) about workspace files.\", 'https://go.microsoft.com/fwlink/?linkid=2025315'), [{\n                        label: nls_1.localize('selectWorkspace', \"Select Workspace\"),\n                        run: () => {\n                            this.quickInputService.pick(workspaces.map(workspace => ({ label: workspace })), { placeHolder: nls_1.localize('selectToOpen', \"Select a workspace to open\") }).then(pick => {\n                                if (pick) {\n                                    this.windowService.openWindow([{ uri: resources_1.joinPath(folder, pick.label), typeHint: 'file' }]);\n                                }\n                            });\n                        }\n                    }, doNotShowAgain]);\n            }\n        }\n        findFolders(configuration) {\n            const folder = this.findFolder(configuration);\n            return folder && [folder];\n        }\n        findFolder({ filesToOpen, filesToCreate, filesToDiff }) {\n            if (filesToOpen && filesToOpen.length) {\n                return this.parentURI(filesToOpen[0].fileUri);\n            }\n            else if (filesToCreate && filesToCreate.length) {\n                return this.parentURI(filesToCreate[0].fileUri);\n            }\n            else if (filesToDiff && filesToDiff.length) {\n                return this.parentURI(filesToDiff[0].fileUri);\n            }\n            return undefined;\n        }\n        parentURI(uri) {\n            if (!uri) {\n                return undefined;\n            }\n            const path = uri.path;\n            const i = path.lastIndexOf('/');\n            return i !== -1 ? uri.with({ path: path.substr(0, i) }) : undefined;\n        }\n        reportWorkspaceTags(tags) {\n            /* __GDPR__\n                \"workspce.tags\" : {\n                    \"${include}\": [\n                        \"${WorkspaceTags}\"\n                    ]\n                }\n            */\n            this.telemetryService.publicLog('workspce.tags', tags);\n            WorkspaceStats.TAGS = tags;\n        }\n        reportRemoteDomains(workspaceUris) {\n            Promise.all(workspaceUris.map(workspaceUri => {\n                const path = workspaceUri.path;\n                const uri = workspaceUri.with({ path: `${path !== '/' ? path : ''}/.git/config` });\n                return this.fileService.existsFile(uri).then(exists => {\n                    if (!exists) {\n                        return [];\n                    }\n                    return this.fileService.resolveContent(uri, { acceptTextOnly: true }).then(content => getDomainsOfRemotes(content.value, SecondLevelDomainWhitelist), err => [] // ignore missing or binary file\n                    );\n                });\n            })).then(domains => {\n                const set = domains.reduce((set, list) => list.reduce((set, item) => set.add(item), set), new Set());\n                const list = [];\n                set.forEach(item => list.push(item));\n                /* __GDPR__\n                    \"workspace.remotes\" : {\n                        \"domains\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                    }\n                */\n                this.telemetryService.publicLog('workspace.remotes', { domains: list.sort() });\n            }, errors_1.onUnexpectedError);\n        }\n        reportRemotes(workspaceUris) {\n            Promise.all(workspaceUris.map(workspaceUri => {\n                return getHashedRemotesFromUri(workspaceUri, this.fileService, true);\n            })).then(hashedRemotes => {\n                /* __GDPR__\n                        \"workspace.hashedRemotes\" : {\n                            \"remotes\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                        }\n                    */\n                this.telemetryService.publicLog('workspace.hashedRemotes', { remotes: hashedRemotes });\n            }, errors_1.onUnexpectedError);\n        }\n        /* __GDPR__FRAGMENT__\n            \"AzureTags\" : {\n                \"node\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n            }\n        */\n        reportAzureNode(workspaceUris, tags) {\n            // TODO: should also work for `node_modules` folders several levels down\n            const uris = workspaceUris.map(workspaceUri => {\n                const path = workspaceUri.path;\n                return workspaceUri.with({ path: `${path !== '/' ? path : ''}/node_modules` });\n            });\n            return this.fileService.resolveFiles(uris.map(resource => ({ resource }))).then(results => {\n                const names = [].concat(...results.map(result => result.success ? (result.stat.children || []) : [])).map(c => c.name);\n                const referencesAzure = WorkspaceStats.searchArray(names, /azure/i);\n                if (referencesAzure) {\n                    tags['node'] = true;\n                }\n                return tags;\n            }, err => {\n                return tags;\n            });\n        }\n        /* __GDPR__FRAGMENT__\n            \"AzureTags\" : {\n                \"java\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n            }\n        */\n        reportAzureJava(workspaceUris, tags) {\n            return Promise.all(workspaceUris.map(workspaceUri => {\n                const path = workspaceUri.path;\n                const uri = workspaceUri.with({ path: `${path !== '/' ? path : ''}/pom.xml` });\n                return this.fileService.existsFile(uri).then(exists => {\n                    if (!exists) {\n                        return false;\n                    }\n                    return this.fileService.resolveContent(uri, { acceptTextOnly: true }).then(content => !!content.value.match(/azure/i), err => false);\n                });\n            })).then(javas => {\n                if (javas.indexOf(true) !== -1) {\n                    tags['java'] = true;\n                }\n                return tags;\n            });\n        }\n        reportAzure(uris) {\n            const tags = Object.create(null);\n            this.reportAzureNode(uris, tags).then((tags) => {\n                return this.reportAzureJava(uris, tags);\n            }).then((tags) => {\n                if (Object.keys(tags).length) {\n                    /* __GDPR__\n                        \"workspace.azure\" : {\n                            \"${include}\": [\n                                \"${AzureTags}\"\n                            ]\n                        }\n                    */\n                    this.telemetryService.publicLog('workspace.azure', tags);\n                }\n            }).then(undefined, errors_1.onUnexpectedError);\n        }\n        reportCloudStats() {\n            const uris = this.contextService.getWorkspace().folders.map(folder => folder.uri);\n            if (uris.length && this.fileService) {\n                this.reportRemoteDomains(uris);\n                this.reportRemotes(uris);\n                this.reportAzure(uris);\n            }\n        }\n        reportProxyStats() {\n            this.windowService.resolveProxy('https://www.example.com/')\n                .then(proxy => {\n                let type = proxy ? String(proxy).trim().split(/\\s+/, 1)[0] : 'EMPTY';\n                if (['DIRECT', 'PROXY', 'HTTPS', 'SOCKS', 'EMPTY'].indexOf(type) === -1) {\n                    type = 'UNKNOWN';\n                }\n                /* __GDPR__\n                    \"resolveProxy.stats\" : {\n                        \"type\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" }\n                    }\n                */\n                this.telemetryService.publicLog('resolveProxy.stats', { type });\n            }).then(undefined, errors_1.onUnexpectedError);\n        }\n    };\n    WorkspaceStats.DISABLE_WORKSPACE_PROMPT_KEY = 'workspaces.dontPromptToOpen';\n    WorkspaceStats = __decorate([\n        __param(0, files_1.IFileService),\n        __param(1, workspace_1.IWorkspaceContextService),\n        __param(2, telemetry_1.ITelemetryService),\n        __param(3, environment_1.IEnvironmentService),\n        __param(4, windows_1.IWindowService),\n        __param(5, notification_1.INotificationService),\n        __param(6, quickInput_1.IQuickInputService),\n        __param(7, storage_1.IStorageService)\n    ], WorkspaceStats);\n    exports.WorkspaceStats = WorkspaceStats;\n});\n",null]}