{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true}!/home/coding/workspace/packages/server/src/portScanner.ts","dependencies":[{"path":"/home/coding/workspace/packages/server/src/portScanner.ts","mtime":1555841535694},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//@ts-ignore\nconst netstat = require(\"node-netstat\");\nconst events_1 = require(\"@coder/events\");\nconst logger_1 = require(\"@coder/logger\");\n/**\n * Creates a disposable port scanner.\n * Will scan local ports and emit events when ports are added or removed.\n * Currently only scans TCP ports.\n */\nexports.createPortScanner = (scanInterval = 5000) => {\n    const ports = new Map();\n    const addEmitter = new events_1.Emitter();\n    const removeEmitter = new events_1.Emitter();\n    const scan = (onCompleted) => {\n        const scanTime = Date.now();\n        const added = [];\n        netstat({\n            done: (err) => {\n                const removed = [];\n                ports.forEach((value, key) => {\n                    if (value !== scanTime) {\n                        // Remove port\n                        removed.push(key);\n                        ports.delete(key);\n                    }\n                });\n                if (removed.length > 0) {\n                    removeEmitter.emit(removed);\n                }\n                if (added.length > 0) {\n                    addEmitter.emit(added);\n                }\n                onCompleted(err);\n            },\n            filter: {\n                state: \"LISTEN\",\n            },\n        }, (data) => {\n            // https://en.wikipedia.org/wiki/Registered_port\n            if (data.local.port <= 1023 || data.local.port >= 49151) {\n                return;\n            }\n            // Only forward TCP ports\n            if (!data.protocol.startsWith(\"tcp\")) {\n                return;\n            }\n            if (!ports.has(data.local.port)) {\n                added.push(data.local.port);\n            }\n            ports.set(data.local.port, scanTime);\n        });\n    };\n    let lastTimeout;\n    let disposed = false;\n    const doInterval = () => {\n        logger_1.logger.trace(\"scanning ports\");\n        scan((error) => {\n            if (error) {\n                if (error.code === \"ENOENT\") {\n                    logger_1.logger.warn(\"Port scanning will not be available because netstat is not installed\");\n                }\n                else {\n                    logger_1.logger.warn(`Port scanning will not be available: ${error.message}`);\n                }\n                disposed = true;\n            }\n            else if (!disposed) {\n                lastTimeout = setTimeout(doInterval, scanInterval);\n            }\n        });\n    };\n    doInterval();\n    return {\n        get ports() {\n            return Array.from(ports.keys());\n        },\n        get onAdded() {\n            return addEmitter.event;\n        },\n        get onRemoved() {\n            return removeEmitter.event;\n        },\n        dispose() {\n            if (typeof lastTimeout !== \"undefined\") {\n                clearTimeout(lastTimeout);\n            }\n            disposed = true;\n        },\n    };\n};\n",{"version":3,"file":"/home/coding/workspace/packages/server/src/portScanner.ts","sourceRoot":"","sources":["/home/coding/workspace/packages/server/src/portScanner.ts"],"names":[],"mappings":"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","sourcesContent":["//@ts-ignore\nimport * as netstat from \"node-netstat\";\nimport { Event, Emitter } from \"@coder/events\";\nimport { logger } from \"@coder/logger\";\n\nexport interface PortScanner {\n\treadonly ports: ReadonlyArray<number>;\n\n\treadonly onAdded: Event<ReadonlyArray<number>>;\n\treadonly onRemoved: Event<ReadonlyArray<number>>;\n\n\tdispose(): void;\n}\n\n/**\n * Creates a disposable port scanner.\n * Will scan local ports and emit events when ports are added or removed.\n * Currently only scans TCP ports.\n */\nexport const createPortScanner = (scanInterval: number = 5000): PortScanner => {\n\tconst ports = new Map<number, number>();\n\n\tconst addEmitter = new Emitter<number[]>();\n\tconst removeEmitter = new Emitter<number[]>();\n\n\tconst scan = (onCompleted: (err?: Error) => void): void => {\n\t\tconst scanTime = Date.now();\n\t\tconst added: number[] = [];\n\t\tnetstat({\n\t\t\tdone: (err: Error): void => {\n\t\t\t\tconst removed: number[] = [];\n\t\t\t\tports.forEach((value, key) => {\n\t\t\t\t\tif (value !== scanTime) {\n\t\t\t\t\t\t// Remove port\n\t\t\t\t\t\tremoved.push(key);\n\t\t\t\t\t\tports.delete(key);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (removed.length > 0) {\n\t\t\t\t\tremoveEmitter.emit(removed);\n\t\t\t\t}\n\n\t\t\t\tif (added.length > 0) {\n\t\t\t\t\taddEmitter.emit(added);\n\t\t\t\t}\n\n\t\t\t\tonCompleted(err);\n\t\t\t},\n\t\t\tfilter: {\n\t\t\t\tstate: \"LISTEN\",\n\t\t\t},\n\t\t}, (data: {\n\t\t\treadonly protocol: string;\n\t\t\treadonly local: {\n\t\t\t\treadonly port: number;\n\t\t\t\treadonly address: string;\n\t\t\t};\n\t\t}) => {\n\t\t\t\t// https://en.wikipedia.org/wiki/Registered_port\n\t\t\t\tif (data.local.port <= 1023 || data.local.port >= 49151) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// Only forward TCP ports\n\t\t\t\tif (!data.protocol.startsWith(\"tcp\")) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!ports.has(data.local.port)) {\n\t\t\t\t\tadded.push(data.local.port);\n\t\t\t\t}\n\t\t\t\tports.set(data.local.port, scanTime);\n\t\t\t});\n\t};\n\n\tlet lastTimeout: NodeJS.Timer | undefined;\n\tlet disposed: boolean = false;\n\n\tconst doInterval = (): void => {\n\t\tlogger.trace(\"scanning ports\");\n\t\tscan((error) => {\n\t\t\tif (error) {\n\t\t\t\tif ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\n\t\t\t\t\tlogger.warn(\"Port scanning will not be available because netstat is not installed\");\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn(`Port scanning will not be available: ${error.message}`);\n\t\t\t\t}\n\t\t\t\tdisposed = true;\n\t\t\t} else if (!disposed) {\n\t\t\t\tlastTimeout = setTimeout(doInterval, scanInterval);\n\t\t\t}\n\t\t});\n\t};\n\n\tdoInterval();\n\n\treturn {\n\t\tget ports(): number[] {\n\t\t\treturn Array.from(ports.keys());\n\t\t},\n\t\tget onAdded(): Event<number[]> {\n\t\t\treturn addEmitter.event;\n\t\t},\n\t\tget onRemoved(): Event<number[]> {\n\t\t\treturn removeEmitter.event;\n\t\t},\n\t\tdispose(): void {\n\t\t\tif (typeof lastTimeout !== \"undefined\") {\n\t\t\t\tclearTimeout(lastTimeout);\n\t\t\t}\n\t\t\tdisposed = true;\n\t\t},\n\t};\n};\n"]}]}