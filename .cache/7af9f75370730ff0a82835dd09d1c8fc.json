{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/preferences/electron-browser/preferencesSearch.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/preferences/electron-browser/preferencesSearch.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/arrays\", \"vs/base/common/strings\", \"vs/platform/registry/common/platform\", \"vs/platform/configuration/common/configurationRegistry\", \"vs/base/common/filters\", \"vs/platform/environment/common/environment\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/request/node/request\", \"vs/base/node/request\", \"vs/base/common/lifecycle\", \"vs/platform/extensionManagement/common/extensionManagement\", \"vs/platform/log/common/log\", \"vs/base/common/cancellation\", \"vs/base/common/errors\", \"vs/platform/extensions/common/extensions\", \"vs/workbench/services/preferences/common/preferencesModels\", \"vs/platform/configuration/common/configuration\"], function (require, exports, arrays_1, strings, platform_1, configurationRegistry_1, filters_1, environment_1, instantiation_1, request_1, request_2, lifecycle_1, extensionManagement_1, log_1, cancellation_1, errors_1, extensions_1, preferencesModels_1, configuration_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let PreferencesSearchService = class PreferencesSearchService extends lifecycle_1.Disposable {\n        constructor(configurationService, environmentService, instantiationService, extensionManagementService, extensionEnablementService) {\n            super();\n            this.configurationService = configurationService;\n            this.environmentService = environmentService;\n            this.instantiationService = instantiationService;\n            this.extensionManagementService = extensionManagementService;\n            this.extensionEnablementService = extensionEnablementService;\n            // This request goes to the shared process but results won't change during a window's lifetime, so cache the results.\n            this._installedExtensions = this.extensionManagementService.getInstalled(extensions_1.ExtensionType.User).then(exts => {\n                // Filter to enabled extensions that have settings\n                return exts\n                    .filter(ext => this.extensionEnablementService.isEnabled(ext))\n                    .filter(ext => ext.manifest && ext.manifest.contributes && ext.manifest.contributes.configuration)\n                    .filter(ext => !!ext.identifier.uuid);\n            });\n        }\n        get remoteSearchAllowed() {\n            const workbenchSettings = this.configurationService.getValue().workbench.settings;\n            if (!workbenchSettings.enableNaturalLanguageSearch) {\n                return false;\n            }\n            return !!this._endpoint.urlBase;\n        }\n        get _endpoint() {\n            const workbenchSettings = this.configurationService.getValue().workbench.settings;\n            if (workbenchSettings.naturalLanguageSearchEndpoint) {\n                return {\n                    urlBase: workbenchSettings.naturalLanguageSearchEndpoint,\n                    key: workbenchSettings.naturalLanguageSearchKey\n                };\n            }\n            else {\n                return {\n                    urlBase: this.environmentService.settingsSearchUrl\n                };\n            }\n        }\n        getRemoteSearchProvider(filter, newExtensionsOnly = false) {\n            const opts = {\n                filter,\n                newExtensionsOnly,\n                endpoint: this._endpoint\n            };\n            return this.remoteSearchAllowed ? this.instantiationService.createInstance(RemoteSearchProvider, opts, this._installedExtensions) : undefined;\n        }\n        getLocalSearchProvider(filter) {\n            return this.instantiationService.createInstance(LocalSearchProvider, filter);\n        }\n    };\n    PreferencesSearchService = __decorate([\n        __param(0, configuration_1.IConfigurationService),\n        __param(1, environment_1.IEnvironmentService),\n        __param(2, instantiation_1.IInstantiationService),\n        __param(3, extensionManagement_1.IExtensionManagementService),\n        __param(4, extensionManagement_1.IExtensionEnablementService)\n    ], PreferencesSearchService);\n    exports.PreferencesSearchService = PreferencesSearchService;\n    class LocalSearchProvider {\n        constructor(_filter) {\n            this._filter = _filter;\n            // Remove \" and : which are likely to be copypasted as part of a setting name.\n            // Leave other special characters which the user might want to search for.\n            this._filter = this._filter\n                .replace(/[\":]/g, ' ')\n                .replace(/  /g, ' ')\n                .trim();\n        }\n        searchModel(preferencesModel, token) {\n            if (!this._filter) {\n                return Promise.resolve(null);\n            }\n            let orderedScore = LocalSearchProvider.START_SCORE; // Sort is not stable\n            const settingMatcher = (setting) => {\n                const matches = new SettingMatches(this._filter, setting, true, true, (filter, setting) => preferencesModel.findValueMatches(filter, setting)).matches;\n                const score = this._filter === setting.key ?\n                    LocalSearchProvider.EXACT_MATCH_SCORE :\n                    orderedScore--;\n                return matches && matches.length ?\n                    {\n                        matches,\n                        score\n                    } :\n                    null;\n            };\n            const filterMatches = preferencesModel.filterSettings(this._filter, this.getGroupFilter(this._filter), settingMatcher);\n            if (filterMatches[0] && filterMatches[0].score === LocalSearchProvider.EXACT_MATCH_SCORE) {\n                return Promise.resolve({\n                    filterMatches: filterMatches.slice(0, 1),\n                    exactMatch: true\n                });\n            }\n            else {\n                return Promise.resolve({\n                    filterMatches\n                });\n            }\n        }\n        getGroupFilter(filter) {\n            const regex = strings.createRegExp(filter, false, { global: true });\n            return (group) => {\n                return regex.test(group.title);\n            };\n        }\n    }\n    LocalSearchProvider.EXACT_MATCH_SCORE = 10000;\n    LocalSearchProvider.START_SCORE = 1000;\n    exports.LocalSearchProvider = LocalSearchProvider;\n    let RemoteSearchProvider = class RemoteSearchProvider {\n        constructor(options, installedExtensions, environmentService, requestService, logService) {\n            this.options = options;\n            this.installedExtensions = installedExtensions;\n            this.environmentService = environmentService;\n            this.requestService = requestService;\n            this.logService = logService;\n            this._remoteSearchP = this.options.filter ?\n                Promise.resolve(this.getSettingsForFilter(this.options.filter)) :\n                Promise.resolve(null);\n        }\n        searchModel(preferencesModel, token) {\n            return this._remoteSearchP.then((remoteResult) => {\n                if (!remoteResult) {\n                    return null;\n                }\n                if (token && token.isCancellationRequested) {\n                    throw errors_1.canceled();\n                }\n                const resultKeys = Object.keys(remoteResult.scoredResults);\n                const highScoreKey = arrays_1.top(resultKeys, (a, b) => remoteResult.scoredResults[b].score - remoteResult.scoredResults[a].score, 1)[0];\n                const highScore = highScoreKey ? remoteResult.scoredResults[highScoreKey].score : 0;\n                const minScore = highScore / 5;\n                if (this.options.newExtensionsOnly) {\n                    return this.installedExtensions.then(installedExtensions => {\n                        const newExtsMinScore = Math.max(RemoteSearchProvider.NEW_EXTENSIONS_MIN_SCORE, minScore);\n                        const passingScoreKeys = resultKeys\n                            .filter(k => {\n                            const result = remoteResult.scoredResults[k];\n                            const resultExtId = (result.extensionPublisher + '.' + result.extensionName).toLowerCase();\n                            return !installedExtensions.some(ext => ext.identifier.id.toLowerCase() === resultExtId);\n                        })\n                            .filter(k => remoteResult.scoredResults[k].score >= newExtsMinScore);\n                        const filterMatches = passingScoreKeys.map(k => {\n                            const remoteSetting = remoteResult.scoredResults[k];\n                            const setting = remoteSettingToISetting(remoteSetting);\n                            return {\n                                setting,\n                                score: remoteSetting.score,\n                                matches: [] // TODO\n                            };\n                        });\n                        return {\n                            filterMatches,\n                            metadata: remoteResult\n                        };\n                    });\n                }\n                else {\n                    const settingMatcher = this.getRemoteSettingMatcher(remoteResult.scoredResults, minScore, preferencesModel);\n                    const filterMatches = preferencesModel.filterSettings(this.options.filter, group => null, settingMatcher);\n                    return {\n                        filterMatches,\n                        metadata: remoteResult\n                    };\n                }\n            });\n        }\n        getSettingsForFilter(filter) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const allRequestDetails = [];\n                // Only send MAX_REQUESTS requests in total just to keep it sane\n                for (let i = 0; i < RemoteSearchProvider.MAX_REQUESTS; i++) {\n                    const details = yield this.prepareRequest(filter, i);\n                    allRequestDetails.push(details);\n                    if (!details.hasMoreFilters) {\n                        break;\n                    }\n                }\n                return Promise.all(allRequestDetails.map(details => this.getSettingsFromBing(details))).then(allResponses => {\n                    // Merge all IFilterMetadata\n                    const metadata = allResponses[0];\n                    metadata.requestCount = 1;\n                    for (const response of allResponses.slice(1)) {\n                        metadata.requestCount++;\n                        metadata.scoredResults = Object.assign({}, metadata.scoredResults, response.scoredResults);\n                    }\n                    return metadata;\n                });\n            });\n        }\n        getSettingsFromBing(details) {\n            this.logService.debug(`Searching settings via ${details.url}`);\n            if (details.body) {\n                this.logService.debug(`Body: ${details.body}`);\n            }\n            const requestType = details.body ? 'post' : 'get';\n            const headers = {\n                'User-Agent': 'request',\n                'Content-Type': 'application/json; charset=utf-8',\n            };\n            if (this.options.endpoint.key) {\n                headers['api-key'] = this.options.endpoint.key;\n            }\n            const start = Date.now();\n            return this.requestService.request({\n                type: requestType,\n                url: details.url,\n                data: details.body,\n                headers,\n                timeout: 5000\n            }, cancellation_1.CancellationToken.None).then(context => {\n                if (typeof context.res.statusCode === 'number' && context.res.statusCode >= 300) {\n                    throw new Error(`${JSON.stringify(details)} returned status code: ${context.res.statusCode}`);\n                }\n                return request_2.asJson(context);\n            }).then((result) => {\n                const timestamp = Date.now();\n                const duration = timestamp - start;\n                const remoteSettings = (result.value || [])\n                    .map((r) => {\n                    const key = JSON.parse(r.setting || r.Setting);\n                    const packageId = r['packageid'];\n                    const id = getSettingKey(key, packageId);\n                    const value = r['value'];\n                    const defaultValue = value ? JSON.parse(value) : value;\n                    const packageName = r['packagename'];\n                    let extensionName;\n                    let extensionPublisher;\n                    if (packageName && packageName.indexOf('##') >= 0) {\n                        [extensionPublisher, extensionName] = packageName.split('##');\n                    }\n                    return {\n                        key,\n                        id,\n                        defaultValue,\n                        score: r['@search.score'],\n                        description: JSON.parse(r['details']),\n                        packageId,\n                        extensionName,\n                        extensionPublisher\n                    };\n                });\n                const scoredResults = Object.create(null);\n                remoteSettings.forEach(s => {\n                    scoredResults[s.id] = s;\n                });\n                return {\n                    requestUrl: details.url,\n                    requestBody: details.body,\n                    duration,\n                    timestamp,\n                    scoredResults,\n                    context: result['@odata.context']\n                };\n            });\n        }\n        getRemoteSettingMatcher(scoredResults, minScore, preferencesModel) {\n            return (setting, group) => {\n                const remoteSetting = scoredResults[getSettingKey(setting.key, group.id)] || // extension setting\n                    scoredResults[getSettingKey(setting.key, 'core')] || // core setting\n                    scoredResults[getSettingKey(setting.key)]; // core setting from original prod endpoint\n                if (remoteSetting && remoteSetting.score >= minScore) {\n                    const settingMatches = new SettingMatches(this.options.filter, setting, false, true, (filter, setting) => preferencesModel.findValueMatches(filter, setting)).matches;\n                    return { matches: settingMatches, score: remoteSetting.score };\n                }\n                return null;\n            };\n        }\n        prepareRequest(query, filterPage = 0) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const verbatimQuery = query;\n                query = escapeSpecialChars(query);\n                const boost = 10;\n                const boostedQuery = `(${query})^${boost}`;\n                // Appending Fuzzy after each word.\n                query = query.replace(/\\ +/g, '~ ') + '~';\n                const encodedQuery = encodeURIComponent(boostedQuery + ' || ' + query);\n                let url = `${this.options.endpoint.urlBase}`;\n                if (this.options.endpoint.key) {\n                    url += `${API_VERSION}&${QUERY_TYPE}`;\n                }\n                const extensions = yield this.installedExtensions;\n                const filters = this.options.newExtensionsOnly ?\n                    [`diminish eq 'latest'`] :\n                    this.getVersionFilters(extensions, this.environmentService.settingsSearchBuildId);\n                const filterStr = filters\n                    .slice(filterPage * RemoteSearchProvider.MAX_REQUEST_FILTERS, (filterPage + 1) * RemoteSearchProvider.MAX_REQUEST_FILTERS)\n                    .join(' or ');\n                const hasMoreFilters = filters.length > (filterPage + 1) * RemoteSearchProvider.MAX_REQUEST_FILTERS;\n                const body = JSON.stringify({\n                    query: encodedQuery,\n                    filters: encodeURIComponent(filterStr),\n                    rawQuery: encodeURIComponent(verbatimQuery)\n                });\n                return {\n                    url,\n                    body,\n                    hasMoreFilters\n                };\n            });\n        }\n        getVersionFilters(exts, buildNumber) {\n            // Only search extensions that contribute settings\n            const filters = exts\n                .filter(ext => ext.manifest.contributes && ext.manifest.contributes.configuration)\n                .map(ext => this.getExtensionFilter(ext));\n            if (buildNumber) {\n                filters.push(`(packageid eq 'core' and startbuildno le '${buildNumber}' and endbuildno ge '${buildNumber}')`);\n            }\n            return filters;\n        }\n        getExtensionFilter(ext) {\n            const uuid = ext.identifier.uuid;\n            const versionString = ext.manifest.version\n                .split('.')\n                .map(versionPart => strings.pad(versionPart, 10))\n                .join('');\n            return `(packageid eq '${uuid}' and startbuildno le '${versionString}' and endbuildno ge '${versionString}')`;\n        }\n    };\n    // Must keep extension filter size under 8kb. 42 filters puts us there.\n    RemoteSearchProvider.MAX_REQUEST_FILTERS = 42;\n    RemoteSearchProvider.MAX_REQUESTS = 10;\n    RemoteSearchProvider.NEW_EXTENSIONS_MIN_SCORE = 1;\n    RemoteSearchProvider = __decorate([\n        __param(2, environment_1.IEnvironmentService),\n        __param(3, request_1.IRequestService),\n        __param(4, log_1.ILogService)\n    ], RemoteSearchProvider);\n    function getSettingKey(name, packageId) {\n        return packageId ?\n            packageId + '##' + name :\n            name;\n    }\n    const API_VERSION = 'api-version=2016-09-01-Preview';\n    const QUERY_TYPE = 'querytype=full';\n    function escapeSpecialChars(query) {\n        return query.replace(/\\./g, ' ')\n            .replace(/[\\\\/+\\-&|!\"~*?:(){}\\[\\]\\^]/g, '\\\\$&')\n            .replace(/  /g, ' ') // collapse spaces\n            .trim();\n    }\n    function remoteSettingToISetting(remoteSetting) {\n        return {\n            description: remoteSetting.description.split('\\n'),\n            descriptionIsMarkdown: false,\n            descriptionRanges: [],\n            key: remoteSetting.key,\n            keyRange: preferencesModels_1.nullRange,\n            value: remoteSetting.defaultValue,\n            range: preferencesModels_1.nullRange,\n            valueRange: preferencesModels_1.nullRange,\n            overrides: [],\n            extensionName: remoteSetting.extensionName,\n            extensionPublisher: remoteSetting.extensionPublisher\n        };\n    }\n    class SettingMatches {\n        constructor(searchString, setting, requireFullQueryMatch, searchDescription, valuesMatcher) {\n            this.requireFullQueryMatch = requireFullQueryMatch;\n            this.searchDescription = searchDescription;\n            this.valuesMatcher = valuesMatcher;\n            this.descriptionMatchingWords = new Map();\n            this.keyMatchingWords = new Map();\n            this.valueMatchingWords = new Map();\n            this.matches = arrays_1.distinct(this._findMatchesInSetting(searchString, setting), (match) => `${match.startLineNumber}_${match.startColumn}_${match.endLineNumber}_${match.endColumn}_`);\n        }\n        _findMatchesInSetting(searchString, setting) {\n            const result = this._doFindMatchesInSetting(searchString, setting);\n            if (setting.overrides && setting.overrides.length) {\n                for (const subSetting of setting.overrides) {\n                    const subSettingMatches = new SettingMatches(searchString, subSetting, this.requireFullQueryMatch, this.searchDescription, this.valuesMatcher);\n                    const words = searchString.split(' ');\n                    const descriptionRanges = this.getRangesForWords(words, this.descriptionMatchingWords, [subSettingMatches.descriptionMatchingWords, subSettingMatches.keyMatchingWords, subSettingMatches.valueMatchingWords]);\n                    const keyRanges = this.getRangesForWords(words, this.keyMatchingWords, [subSettingMatches.descriptionMatchingWords, subSettingMatches.keyMatchingWords, subSettingMatches.valueMatchingWords]);\n                    const subSettingKeyRanges = this.getRangesForWords(words, subSettingMatches.keyMatchingWords, [this.descriptionMatchingWords, this.keyMatchingWords, subSettingMatches.valueMatchingWords]);\n                    const subSettinValueRanges = this.getRangesForWords(words, subSettingMatches.valueMatchingWords, [this.descriptionMatchingWords, this.keyMatchingWords, subSettingMatches.keyMatchingWords]);\n                    result.push(...descriptionRanges, ...keyRanges, ...subSettingKeyRanges, ...subSettinValueRanges);\n                    result.push(...subSettingMatches.matches);\n                }\n            }\n            return result;\n        }\n        _doFindMatchesInSetting(searchString, setting) {\n            const registry = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();\n            const schema = registry[setting.key];\n            const words = searchString.split(' ');\n            const settingKeyAsWords = setting.key.split('.').join(' ');\n            for (const word of words) {\n                if (this.searchDescription) {\n                    for (let lineIndex = 0; lineIndex < setting.description.length; lineIndex++) {\n                        const descriptionMatches = filters_1.matchesWords(word, setting.description[lineIndex], true);\n                        if (descriptionMatches) {\n                            this.descriptionMatchingWords.set(word, descriptionMatches.map(match => this.toDescriptionRange(setting, match, lineIndex)));\n                        }\n                    }\n                }\n                const keyMatches = filters_1.or(filters_1.matchesWords, filters_1.matchesCamelCase)(word, settingKeyAsWords);\n                if (keyMatches) {\n                    this.keyMatchingWords.set(word, keyMatches.map(match => this.toKeyRange(setting, match)));\n                }\n                const valueMatches = typeof setting.value === 'string' ? filters_1.matchesContiguousSubString(word, setting.value) : null;\n                if (valueMatches) {\n                    this.valueMatchingWords.set(word, valueMatches.map(match => this.toValueRange(setting, match)));\n                }\n                else if (schema && schema.enum && schema.enum.some(enumValue => typeof enumValue === 'string' && !!filters_1.matchesContiguousSubString(word, enumValue))) {\n                    this.valueMatchingWords.set(word, []);\n                }\n            }\n            const descriptionRanges = [];\n            if (this.searchDescription) {\n                for (let lineIndex = 0; lineIndex < setting.description.length; lineIndex++) {\n                    const matches = filters_1.or(filters_1.matchesContiguousSubString)(searchString, setting.description[lineIndex] || '') || [];\n                    descriptionRanges.push(...matches.map(match => this.toDescriptionRange(setting, match, lineIndex)));\n                }\n                if (descriptionRanges.length === 0) {\n                    descriptionRanges.push(...this.getRangesForWords(words, this.descriptionMatchingWords, [this.keyMatchingWords, this.valueMatchingWords]));\n                }\n            }\n            const keyMatches = filters_1.or(filters_1.matchesPrefix, filters_1.matchesContiguousSubString)(searchString, setting.key);\n            const keyRanges = keyMatches ? keyMatches.map(match => this.toKeyRange(setting, match)) : this.getRangesForWords(words, this.keyMatchingWords, [this.descriptionMatchingWords, this.valueMatchingWords]);\n            let valueRanges = [];\n            if (setting.value && typeof setting.value === 'string') {\n                const valueMatches = filters_1.or(filters_1.matchesPrefix, filters_1.matchesContiguousSubString)(searchString, setting.value);\n                valueRanges = valueMatches ? valueMatches.map(match => this.toValueRange(setting, match)) : this.getRangesForWords(words, this.valueMatchingWords, [this.keyMatchingWords, this.descriptionMatchingWords]);\n            }\n            else {\n                valueRanges = this.valuesMatcher ? this.valuesMatcher(searchString, setting) : [];\n            }\n            return [...descriptionRanges, ...keyRanges, ...valueRanges];\n        }\n        getRangesForWords(words, from, others) {\n            const result = [];\n            for (const word of words) {\n                const ranges = from.get(word);\n                if (ranges) {\n                    result.push(...ranges);\n                }\n                else if (this.requireFullQueryMatch && others.every(o => !o.has(word))) {\n                    return [];\n                }\n            }\n            return result;\n        }\n        toKeyRange(setting, match) {\n            return {\n                startLineNumber: setting.keyRange.startLineNumber,\n                startColumn: setting.keyRange.startColumn + match.start,\n                endLineNumber: setting.keyRange.startLineNumber,\n                endColumn: setting.keyRange.startColumn + match.end\n            };\n        }\n        toDescriptionRange(setting, match, lineIndex) {\n            return {\n                startLineNumber: setting.descriptionRanges[lineIndex].startLineNumber,\n                startColumn: setting.descriptionRanges[lineIndex].startColumn + match.start,\n                endLineNumber: setting.descriptionRanges[lineIndex].endLineNumber,\n                endColumn: setting.descriptionRanges[lineIndex].startColumn + match.end\n            };\n        }\n        toValueRange(setting, match) {\n            return {\n                startLineNumber: setting.valueRange.startLineNumber,\n                startColumn: setting.valueRange.startColumn + match.start + 1,\n                endLineNumber: setting.valueRange.startLineNumber,\n                endColumn: setting.valueRange.startColumn + match.end + 1\n            };\n        }\n    }\n});\n",null]}