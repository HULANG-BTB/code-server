{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/debugUtils.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/debugUtils.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/strings\", \"vs/base/common/uri\", \"vs/base/common/path\", \"vs/base/common/objects\", \"vs/base/common/arrays\"], function (require, exports, strings_1, uri_1, path_1, objects_1, arrays_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const _formatPIIRegexp = /{([^}]+)}/g;\n    function startDebugging(debugService, historyService, noDebug) {\n        const configurationManager = debugService.getConfigurationManager();\n        let launch = configurationManager.selectedConfiguration.launch;\n        if (!launch || launch.getConfigurationNames().length === 0) {\n            const rootUri = historyService.getLastActiveWorkspaceRoot();\n            launch = configurationManager.getLaunch(rootUri);\n            if (!launch || launch.getConfigurationNames().length === 0) {\n                const launches = configurationManager.getLaunches();\n                launch = arrays_1.first(launches, l => !!(l && l.getConfigurationNames().length), launch);\n            }\n            configurationManager.selectConfiguration(launch);\n        }\n        return debugService.startDebugging(launch, undefined, noDebug);\n    }\n    exports.startDebugging = startDebugging;\n    function formatPII(value, excludePII, args) {\n        return value.replace(_formatPIIRegexp, function (match, group) {\n            if (excludePII && group.length > 0 && group[0] !== '_') {\n                return match;\n            }\n            return args && args.hasOwnProperty(group) ?\n                args[group] :\n                match;\n        });\n    }\n    exports.formatPII = formatPII;\n    function isExtensionHostDebugging(config) {\n        return config.type && strings_1.equalsIgnoreCase(config.type === 'vslsShare' ? config.adapterProxy.configuration.type : config.type, 'extensionhost');\n    }\n    exports.isExtensionHostDebugging = isExtensionHostDebugging;\n    // only a debugger contributions with a label, program, or runtime attribute is considered a \"defining\" or \"main\" debugger contribution\n    function isDebuggerMainContribution(dbg) {\n        return dbg.type && (dbg.label || dbg.program || dbg.runtime);\n    }\n    exports.isDebuggerMainContribution = isDebuggerMainContribution;\n    function getExactExpressionStartAndEnd(lineContent, looseStart, looseEnd) {\n        let matchingExpression = undefined;\n        let startOffset = 0;\n        // Some example supported expressions: myVar.prop, a.b.c.d, myVar?.prop, myVar->prop, MyClass::StaticProp, *myVar\n        // Match any character except a set of characters which often break interesting sub-expressions\n        let expression = /([^()\\[\\]{}<>\\s+\\-/%~#^;=|,`!]|\\->)+/g;\n        let result = null;\n        // First find the full expression under the cursor\n        while (result = expression.exec(lineContent)) {\n            let start = result.index + 1;\n            let end = start + result[0].length;\n            if (start <= looseStart && end >= looseEnd) {\n                matchingExpression = result[0];\n                startOffset = start;\n                break;\n            }\n        }\n        // If there are non-word characters after the cursor, we want to truncate the expression then.\n        // For example in expression 'a.b.c.d', if the focus was under 'b', 'a.b' would be evaluated.\n        if (matchingExpression) {\n            let subExpression = /\\w+/g;\n            let subExpressionResult = null;\n            while (subExpressionResult = subExpression.exec(matchingExpression)) {\n                let subEnd = subExpressionResult.index + 1 + startOffset + subExpressionResult[0].length;\n                if (subEnd >= looseEnd) {\n                    break;\n                }\n            }\n            if (subExpressionResult) {\n                matchingExpression = matchingExpression.substring(0, subExpression.lastIndex);\n            }\n        }\n        return matchingExpression ?\n            { start: startOffset, end: startOffset + matchingExpression.length - 1 } :\n            { start: 0, end: 0 };\n    }\n    exports.getExactExpressionStartAndEnd = getExactExpressionStartAndEnd;\n    // RFC 2396, Appendix A: https://www.ietf.org/rfc/rfc2396.txt\n    const _schemePattern = /^[a-zA-Z][a-zA-Z0-9\\+\\-\\.]+:/;\n    function isUri(s) {\n        // heuristics: a valid uri starts with a scheme and\n        // the scheme has at least 2 characters so that it doesn't look like a drive letter.\n        return !!(s && s.match(_schemePattern));\n    }\n    exports.isUri = isUri;\n    function stringToUri(path) {\n        if (typeof path === 'string') {\n            if (isUri(path)) {\n                return uri_1.URI.parse(path);\n            }\n            else {\n                // assume path\n                if (path_1.isAbsolute(path)) {\n                    return uri_1.URI.file(path);\n                }\n                else {\n                    // leave relative path as is\n                }\n            }\n        }\n        return path;\n    }\n    function uriToString(path) {\n        if (typeof path === 'object') {\n            const u = uri_1.URI.revive(path);\n            if (u.scheme === 'file') {\n                return u.fsPath;\n            }\n            else {\n                return u.toString();\n            }\n        }\n        return path;\n    }\n    function convertToDAPaths(message, toUri) {\n        const fixPath = toUri ? stringToUri : uriToString;\n        // since we modify Source.paths in the message in place, we need to make a copy of it (see #61129)\n        const msg = objects_1.deepClone(message);\n        convertPaths(msg, (toDA, source) => {\n            if (toDA && source) {\n                source.path = source.path ? fixPath(source.path) : undefined;\n            }\n        });\n        return msg;\n    }\n    exports.convertToDAPaths = convertToDAPaths;\n    function convertToVSCPaths(message, toUri) {\n        const fixPath = toUri ? stringToUri : uriToString;\n        // since we modify Source.paths in the message in place, we need to make a copy of it (see #61129)\n        const msg = objects_1.deepClone(message);\n        convertPaths(msg, (toDA, source) => {\n            if (!toDA && source) {\n                source.path = source.path ? fixPath(source.path) : undefined;\n            }\n        });\n        return msg;\n    }\n    exports.convertToVSCPaths = convertToVSCPaths;\n    function convertPaths(msg, fixSourcePath) {\n        switch (msg.type) {\n            case 'event':\n                const event = msg;\n                switch (event.event) {\n                    case 'output':\n                        fixSourcePath(false, event.body.source);\n                        break;\n                    case 'loadedSource':\n                        fixSourcePath(false, event.body.source);\n                        break;\n                    case 'breakpoint':\n                        fixSourcePath(false, event.body.breakpoint.source);\n                        break;\n                    default:\n                        break;\n                }\n                break;\n            case 'request':\n                const request = msg;\n                switch (request.command) {\n                    case 'setBreakpoints':\n                        fixSourcePath(true, request.arguments.source);\n                        break;\n                    case 'source':\n                        fixSourcePath(true, request.arguments.source);\n                        break;\n                    case 'gotoTargets':\n                        fixSourcePath(true, request.arguments.source);\n                        break;\n                    case 'launchVSCode':\n                        request.arguments.args.forEach((arg) => fixSourcePath(false, arg));\n                        break;\n                    default:\n                        break;\n                }\n                break;\n            case 'response':\n                const response = msg;\n                if (response.success) {\n                    switch (response.command) {\n                        case 'stackTrace':\n                            response.body.stackFrames.forEach(frame => fixSourcePath(false, frame.source));\n                            break;\n                        case 'loadedSources':\n                            response.body.sources.forEach(source => fixSourcePath(false, source));\n                            break;\n                        case 'scopes':\n                            response.body.scopes.forEach(scope => fixSourcePath(false, scope.source));\n                            break;\n                        case 'setFunctionBreakpoints':\n                            response.body.breakpoints.forEach(bp => fixSourcePath(false, bp.source));\n                            break;\n                        case 'setBreakpoints':\n                            response.body.breakpoints.forEach(bp => fixSourcePath(false, bp.source));\n                            break;\n                        default:\n                            break;\n                    }\n                }\n                break;\n        }\n    }\n});\n",null]}