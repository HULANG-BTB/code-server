{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/linkComputer.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/linkComputer.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/charCode\", \"vs/editor/common/core/characterClassifier\", \"vs/editor/common/core/uint\"], function (require, exports, charCode_1, characterClassifier_1, uint_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var State;\n    (function (State) {\n        State[State[\"Invalid\"] = 0] = \"Invalid\";\n        State[State[\"Start\"] = 1] = \"Start\";\n        State[State[\"H\"] = 2] = \"H\";\n        State[State[\"HT\"] = 3] = \"HT\";\n        State[State[\"HTT\"] = 4] = \"HTT\";\n        State[State[\"HTTP\"] = 5] = \"HTTP\";\n        State[State[\"F\"] = 6] = \"F\";\n        State[State[\"FI\"] = 7] = \"FI\";\n        State[State[\"FIL\"] = 8] = \"FIL\";\n        State[State[\"BeforeColon\"] = 9] = \"BeforeColon\";\n        State[State[\"AfterColon\"] = 10] = \"AfterColon\";\n        State[State[\"AlmostThere\"] = 11] = \"AlmostThere\";\n        State[State[\"End\"] = 12] = \"End\";\n        State[State[\"Accept\"] = 13] = \"Accept\";\n        State[State[\"LastKnownState\"] = 14] = \"LastKnownState\"; // marker, custom states may follow\n    })(State = exports.State || (exports.State = {}));\n    class StateMachine {\n        constructor(edges) {\n            let maxCharCode = 0;\n            let maxState = State.Invalid;\n            for (let i = 0, len = edges.length; i < len; i++) {\n                let [from, chCode, to] = edges[i];\n                if (chCode > maxCharCode) {\n                    maxCharCode = chCode;\n                }\n                if (from > maxState) {\n                    maxState = from;\n                }\n                if (to > maxState) {\n                    maxState = to;\n                }\n            }\n            maxCharCode++;\n            maxState++;\n            let states = new uint_1.Uint8Matrix(maxState, maxCharCode, State.Invalid);\n            for (let i = 0, len = edges.length; i < len; i++) {\n                let [from, chCode, to] = edges[i];\n                states.set(from, chCode, to);\n            }\n            this._states = states;\n            this._maxCharCode = maxCharCode;\n        }\n        nextState(currentState, chCode) {\n            if (chCode < 0 || chCode >= this._maxCharCode) {\n                return State.Invalid;\n            }\n            return this._states.get(currentState, chCode);\n        }\n    }\n    exports.StateMachine = StateMachine;\n    // State machine for http:// or https:// or file://\n    let _stateMachine = null;\n    function getStateMachine() {\n        if (_stateMachine === null) {\n            _stateMachine = new StateMachine([\n                [State.Start, charCode_1.CharCode.h, State.H],\n                [State.Start, charCode_1.CharCode.H, State.H],\n                [State.Start, charCode_1.CharCode.f, State.F],\n                [State.Start, charCode_1.CharCode.F, State.F],\n                [State.H, charCode_1.CharCode.t, State.HT],\n                [State.H, charCode_1.CharCode.T, State.HT],\n                [State.HT, charCode_1.CharCode.t, State.HTT],\n                [State.HT, charCode_1.CharCode.T, State.HTT],\n                [State.HTT, charCode_1.CharCode.p, State.HTTP],\n                [State.HTT, charCode_1.CharCode.P, State.HTTP],\n                [State.HTTP, charCode_1.CharCode.s, State.BeforeColon],\n                [State.HTTP, charCode_1.CharCode.S, State.BeforeColon],\n                [State.HTTP, charCode_1.CharCode.Colon, State.AfterColon],\n                [State.F, charCode_1.CharCode.i, State.FI],\n                [State.F, charCode_1.CharCode.I, State.FI],\n                [State.FI, charCode_1.CharCode.l, State.FIL],\n                [State.FI, charCode_1.CharCode.L, State.FIL],\n                [State.FIL, charCode_1.CharCode.e, State.BeforeColon],\n                [State.FIL, charCode_1.CharCode.E, State.BeforeColon],\n                [State.BeforeColon, charCode_1.CharCode.Colon, State.AfterColon],\n                [State.AfterColon, charCode_1.CharCode.Slash, State.AlmostThere],\n                [State.AlmostThere, charCode_1.CharCode.Slash, State.End],\n            ]);\n        }\n        return _stateMachine;\n    }\n    var CharacterClass;\n    (function (CharacterClass) {\n        CharacterClass[CharacterClass[\"None\"] = 0] = \"None\";\n        CharacterClass[CharacterClass[\"ForceTermination\"] = 1] = \"ForceTermination\";\n        CharacterClass[CharacterClass[\"CannotEndIn\"] = 2] = \"CannotEndIn\";\n    })(CharacterClass || (CharacterClass = {}));\n    let _classifier = null;\n    function getClassifier() {\n        if (_classifier === null) {\n            _classifier = new characterClassifier_1.CharacterClassifier(CharacterClass.None);\n            const FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"、。｡､，．：；？！＠＃＄％＆＊‘“〈《「『【〔（［｛｢｣｝］）〕】』」》〉”’｀～…';\n            for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\n                _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), CharacterClass.ForceTermination);\n            }\n            const CANNOT_END_WITH_CHARACTERS = '.,;';\n            for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\n                _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), CharacterClass.CannotEndIn);\n            }\n        }\n        return _classifier;\n    }\n    class LinkComputer {\n        static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {\n            // Do not allow to end link in certain characters...\n            let lastIncludedCharIndex = linkEndIndex - 1;\n            do {\n                const chCode = line.charCodeAt(lastIncludedCharIndex);\n                const chClass = classifier.get(chCode);\n                if (chClass !== CharacterClass.CannotEndIn) {\n                    break;\n                }\n                lastIncludedCharIndex--;\n            } while (lastIncludedCharIndex > linkBeginIndex);\n            // Handle links enclosed in parens, square brackets and curlys.\n            if (linkBeginIndex > 0) {\n                const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);\n                const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);\n                if ((charCodeBeforeLink === charCode_1.CharCode.OpenParen && lastCharCodeInLink === charCode_1.CharCode.CloseParen)\n                    || (charCodeBeforeLink === charCode_1.CharCode.OpenSquareBracket && lastCharCodeInLink === charCode_1.CharCode.CloseSquareBracket)\n                    || (charCodeBeforeLink === charCode_1.CharCode.OpenCurlyBrace && lastCharCodeInLink === charCode_1.CharCode.CloseCurlyBrace)) {\n                    // Do not end in ) if ( is before the link start\n                    // Do not end in ] if [ is before the link start\n                    // Do not end in } if { is before the link start\n                    lastIncludedCharIndex--;\n                }\n            }\n            return {\n                range: {\n                    startLineNumber: lineNumber,\n                    startColumn: linkBeginIndex + 1,\n                    endLineNumber: lineNumber,\n                    endColumn: lastIncludedCharIndex + 2\n                },\n                url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)\n            };\n        }\n        static computeLinks(model, stateMachine = getStateMachine()) {\n            const classifier = getClassifier();\n            let result = [];\n            for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\n                const line = model.getLineContent(i);\n                const len = line.length;\n                let j = 0;\n                let linkBeginIndex = 0;\n                let linkBeginChCode = 0;\n                let state = State.Start;\n                let hasOpenParens = false;\n                let hasOpenSquareBracket = false;\n                let hasOpenCurlyBracket = false;\n                while (j < len) {\n                    let resetStateMachine = false;\n                    const chCode = line.charCodeAt(j);\n                    if (state === State.Accept) {\n                        let chClass;\n                        switch (chCode) {\n                            case charCode_1.CharCode.OpenParen:\n                                hasOpenParens = true;\n                                chClass = CharacterClass.None;\n                                break;\n                            case charCode_1.CharCode.CloseParen:\n                                chClass = (hasOpenParens ? CharacterClass.None : CharacterClass.ForceTermination);\n                                break;\n                            case charCode_1.CharCode.OpenSquareBracket:\n                                hasOpenSquareBracket = true;\n                                chClass = CharacterClass.None;\n                                break;\n                            case charCode_1.CharCode.CloseSquareBracket:\n                                chClass = (hasOpenSquareBracket ? CharacterClass.None : CharacterClass.ForceTermination);\n                                break;\n                            case charCode_1.CharCode.OpenCurlyBrace:\n                                hasOpenCurlyBracket = true;\n                                chClass = CharacterClass.None;\n                                break;\n                            case charCode_1.CharCode.CloseCurlyBrace:\n                                chClass = (hasOpenCurlyBracket ? CharacterClass.None : CharacterClass.ForceTermination);\n                                break;\n                            /* The following three rules make it that ' or \" or ` are allowed inside links if the link began with a different one */\n                            case charCode_1.CharCode.SingleQuote:\n                                chClass = (linkBeginChCode === charCode_1.CharCode.DoubleQuote || linkBeginChCode === charCode_1.CharCode.BackTick) ? CharacterClass.None : CharacterClass.ForceTermination;\n                                break;\n                            case charCode_1.CharCode.DoubleQuote:\n                                chClass = (linkBeginChCode === charCode_1.CharCode.SingleQuote || linkBeginChCode === charCode_1.CharCode.BackTick) ? CharacterClass.None : CharacterClass.ForceTermination;\n                                break;\n                            case charCode_1.CharCode.BackTick:\n                                chClass = (linkBeginChCode === charCode_1.CharCode.SingleQuote || linkBeginChCode === charCode_1.CharCode.DoubleQuote) ? CharacterClass.None : CharacterClass.ForceTermination;\n                                break;\n                            default:\n                                chClass = classifier.get(chCode);\n                        }\n                        // Check if character terminates link\n                        if (chClass === CharacterClass.ForceTermination) {\n                            result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));\n                            resetStateMachine = true;\n                        }\n                    }\n                    else if (state === State.End) {\n                        let chClass;\n                        if (chCode === charCode_1.CharCode.OpenSquareBracket) {\n                            // Allow for the authority part to contain ipv6 addresses which contain [ and ]\n                            hasOpenSquareBracket = true;\n                            chClass = CharacterClass.None;\n                        }\n                        else {\n                            chClass = classifier.get(chCode);\n                        }\n                        // Check if character terminates link\n                        if (chClass === CharacterClass.ForceTermination) {\n                            resetStateMachine = true;\n                        }\n                        else {\n                            state = State.Accept;\n                        }\n                    }\n                    else {\n                        state = stateMachine.nextState(state, chCode);\n                        if (state === State.Invalid) {\n                            resetStateMachine = true;\n                        }\n                    }\n                    if (resetStateMachine) {\n                        state = State.Start;\n                        hasOpenParens = false;\n                        hasOpenSquareBracket = false;\n                        hasOpenCurlyBracket = false;\n                        // Record where the link started\n                        linkBeginIndex = j + 1;\n                        linkBeginChCode = chCode;\n                    }\n                    j++;\n                }\n                if (state === State.Accept) {\n                    result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));\n                }\n            }\n            return result;\n        }\n    }\n    exports.LinkComputer = LinkComputer;\n    /**\n     * Returns an array of all links contains in the provided\n     * document. *Note* that this operation is computational\n     * expensive and should not run in the UI thread.\n     */\n    function computeLinks(model) {\n        if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\n            // Unknown caller!\n            return [];\n        }\n        return LinkComputer.computeLinks(model);\n    }\n    exports.computeLinks = computeLinks;\n});\n",null]}