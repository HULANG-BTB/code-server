{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/model/wordHelper.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/wordHelper.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords) {\n    if (allowInWords === void 0) { allowInWords = ''; }\n    var source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (var _i = 0, USUAL_WORD_SEPARATORS_1 = exports.USUAL_WORD_SEPARATORS; _i < USUAL_WORD_SEPARATORS_1.length; _i++) {\n        var sep = USUAL_WORD_SEPARATORS_1[_i];\n        if (allowInWords.indexOf(sep) >= 0) {\n            continue;\n        }\n        source += '\\\\' + sep;\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexports.DEFAULT_WORD_REGEXP = createWordRegExp();\nfunction ensureValidWordDefinition(wordDefinition) {\n    var result = exports.DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            var flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            if (wordDefinition.unicode) {\n                flags += 'u';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nexports.ensureValidWordDefinition = ensureValidWordDefinition;\nfunction getWordAtPosFast(column, wordDefinition, text, textOffset) {\n    // find whitespace enclosed text around column and match from there\n    var pos = column - 1 - textOffset;\n    var start = text.lastIndexOf(' ', pos - 1) + 1;\n    wordDefinition.lastIndex = start;\n    var match;\n    while (match = wordDefinition.exec(text)) {\n        var matchIndex = match.index || 0;\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n            return {\n                word: match[0],\n                startColumn: textOffset + 1 + matchIndex,\n                endColumn: textOffset + 1 + wordDefinition.lastIndex\n            };\n        }\n    }\n    return null;\n}\nfunction getWordAtPosSlow(column, wordDefinition, text, textOffset) {\n    // matches all words starting at the beginning\n    // of the input until it finds a match that encloses\n    // the desired column. slow but correct\n    var pos = column - 1 - textOffset;\n    wordDefinition.lastIndex = 0;\n    var match;\n    while (match = wordDefinition.exec(text)) {\n        var matchIndex = match.index || 0;\n        if (matchIndex > pos) {\n            // |nW -> matched only after the pos\n            return null;\n        }\n        else if (wordDefinition.lastIndex >= pos) {\n            // W|W -> match encloses pos\n            return {\n                word: match[0],\n                startColumn: textOffset + 1 + matchIndex,\n                endColumn: textOffset + 1 + wordDefinition.lastIndex\n            };\n        }\n    }\n    return null;\n}\nfunction getWordAtText(column, wordDefinition, text, textOffset) {\n    // if `words` can contain whitespace character we have to use the slow variant\n    // otherwise we use the fast variant of finding a word\n    wordDefinition.lastIndex = 0;\n    var match = wordDefinition.exec(text);\n    if (!match) {\n        return null;\n    }\n    // todo@joh the `match` could already be the (first) word\n    var ret = match[0].indexOf(' ') >= 0\n        // did match a word which contains a space character -> use slow word find\n        ? getWordAtPosSlow(column, wordDefinition, text, textOffset)\n        // sane word definition -> use fast word find\n        : getWordAtPosFast(column, wordDefinition, text, textOffset);\n    // both (getWordAtPosFast and getWordAtPosSlow) leave the wordDefinition-RegExp\n    // in an undefined state and to not confuse other users of the wordDefinition\n    // we reset the lastIndex\n    wordDefinition.lastIndex = 0;\n    return ret;\n}\nexports.getWordAtText = getWordAtText;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/wordHelper.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/model/wordHelper.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IWordAtPosition } from 'vs/editor/common/model';\n\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords: string = ''): RegExp {\n\tlet source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n\tfor (const sep of USUAL_WORD_SEPARATORS) {\n\t\tif (allowInWords.indexOf(sep) >= 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tsource += '\\\\' + sep;\n\t}\n\tsource += '\\\\s]+)';\n\treturn new RegExp(source, 'g');\n}\n\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\n\nexport function ensureValidWordDefinition(wordDefinition?: RegExp | null): RegExp {\n\tlet result: RegExp = DEFAULT_WORD_REGEXP;\n\n\tif (wordDefinition && (wordDefinition instanceof RegExp)) {\n\t\tif (!wordDefinition.global) {\n\t\t\tlet flags = 'g';\n\t\t\tif (wordDefinition.ignoreCase) {\n\t\t\t\tflags += 'i';\n\t\t\t}\n\t\t\tif (wordDefinition.multiline) {\n\t\t\t\tflags += 'm';\n\t\t\t}\n\t\t\tif ((wordDefinition as any).unicode) {\n\t\t\t\tflags += 'u';\n\t\t\t}\n\t\t\tresult = new RegExp(wordDefinition.source, flags);\n\t\t} else {\n\t\t\tresult = wordDefinition;\n\t\t}\n\t}\n\n\tresult.lastIndex = 0;\n\n\treturn result;\n}\n\nfunction getWordAtPosFast(column: number, wordDefinition: RegExp, text: string, textOffset: number): IWordAtPosition | null {\n\t// find whitespace enclosed text around column and match from there\n\n\tlet pos = column - 1 - textOffset;\n\tlet start = text.lastIndexOf(' ', pos - 1) + 1;\n\n\twordDefinition.lastIndex = start;\n\tlet match: RegExpMatchArray | null;\n\twhile (match = wordDefinition.exec(text)) {\n\t\tconst matchIndex = match.index || 0;\n\t\tif (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n\t\t\treturn {\n\t\t\t\tword: match[0],\n\t\t\t\tstartColumn: textOffset + 1 + matchIndex,\n\t\t\t\tendColumn: textOffset + 1 + wordDefinition.lastIndex\n\t\t\t};\n\t\t}\n\t}\n\n\treturn null;\n}\n\n\nfunction getWordAtPosSlow(column: number, wordDefinition: RegExp, text: string, textOffset: number): IWordAtPosition | null {\n\t// matches all words starting at the beginning\n\t// of the input until it finds a match that encloses\n\t// the desired column. slow but correct\n\n\tlet pos = column - 1 - textOffset;\n\twordDefinition.lastIndex = 0;\n\n\tlet match: RegExpMatchArray | null;\n\twhile (match = wordDefinition.exec(text)) {\n\t\tconst matchIndex = match.index || 0;\n\t\tif (matchIndex > pos) {\n\t\t\t// |nW -> matched only after the pos\n\t\t\treturn null;\n\n\t\t} else if (wordDefinition.lastIndex >= pos) {\n\t\t\t// W|W -> match encloses pos\n\t\t\treturn {\n\t\t\t\tword: match[0],\n\t\t\t\tstartColumn: textOffset + 1 + matchIndex,\n\t\t\t\tendColumn: textOffset + 1 + wordDefinition.lastIndex\n\t\t\t};\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function getWordAtText(column: number, wordDefinition: RegExp, text: string, textOffset: number): IWordAtPosition | null {\n\n\t// if `words` can contain whitespace character we have to use the slow variant\n\t// otherwise we use the fast variant of finding a word\n\twordDefinition.lastIndex = 0;\n\tlet match = wordDefinition.exec(text);\n\tif (!match) {\n\t\treturn null;\n\t}\n\t// todo@joh the `match` could already be the (first) word\n\tconst ret = match[0].indexOf(' ') >= 0\n\t\t// did match a word which contains a space character -> use slow word find\n\t\t? getWordAtPosSlow(column, wordDefinition, text, textOffset)\n\t\t// sane word definition -> use fast word find\n\t\t: getWordAtPosFast(column, wordDefinition, text, textOffset);\n\n\t// both (getWordAtPosFast and getWordAtPosSlow) leave the wordDefinition-RegExp\n\t// in an undefined state and to not confuse other users of the wordDefinition\n\t// we reset the lastIndex\n\twordDefinition.lastIndex = 0;\n\n\treturn ret;\n}\n"]}]}