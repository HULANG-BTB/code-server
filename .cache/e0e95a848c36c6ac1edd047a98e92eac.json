{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/platform/extensions/common/extensions.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/extensions/common/extensions.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extensionManagementUtil_1 = require(\"vs/platform/extensionManagement/common/extensionManagementUtil\");\nvar strings = require(\"vs/base/common/strings\");\nexports.MANIFEST_CACHE_FOLDER = 'CachedExtensions';\nexports.USER_MANIFEST_CACHE_FILE = 'user';\nexports.BUILTIN_MANIFEST_CACHE_FILE = 'builtin';\nvar ExtensionIdentifierWithVersion = /** @class */ (function () {\n    function ExtensionIdentifierWithVersion(identifier, version) {\n        this.identifier = identifier;\n        this.version = version;\n    }\n    ExtensionIdentifierWithVersion.prototype.key = function () {\n        return this.identifier.id + \"-\" + this.version;\n    };\n    ExtensionIdentifierWithVersion.prototype.equals = function (o) {\n        if (!(o instanceof ExtensionIdentifierWithVersion)) {\n            return false;\n        }\n        return extensionManagementUtil_1.areSameExtensions(this.identifier, o.identifier) && this.version === o.version;\n    };\n    return ExtensionIdentifierWithVersion;\n}());\nexports.ExtensionIdentifierWithVersion = ExtensionIdentifierWithVersion;\nfunction isIExtensionIdentifier(thing) {\n    return thing\n        && typeof thing === 'object'\n        && typeof thing.id === 'string'\n        && (!thing.uuid || typeof thing.uuid === 'string');\n}\nexports.isIExtensionIdentifier = isIExtensionIdentifier;\nvar ExtensionType;\n(function (ExtensionType) {\n    ExtensionType[ExtensionType[\"System\"] = 0] = \"System\";\n    ExtensionType[ExtensionType[\"User\"] = 1] = \"User\";\n})(ExtensionType = exports.ExtensionType || (exports.ExtensionType = {}));\n/**\n * **!Do not construct directly!**\n *\n * **!Only static methods because it gets serialized!**\n *\n * This represents the \"canonical\" version for an extension identifier. Extension ids\n * have to be case-insensitive (due to the marketplace), but we must ensure case\n * preservation because the extension API is already public at this time.\n *\n * For example, given an extension with the publisher `\"Hello\"` and the name `\"World\"`,\n * its canonical extension identifier is `\"Hello.World\"`. This extension could be\n * referenced in some other extension's dependencies using the string `\"hello.world\"`.\n *\n * To make matters more complicated, an extension can optionally have an UUID. When two\n * extensions have the same UUID, they are considered equal even if their identifier is different.\n */\nvar ExtensionIdentifier = /** @class */ (function () {\n    function ExtensionIdentifier(value) {\n        this.value = value;\n        this._lower = value.toLowerCase();\n    }\n    ExtensionIdentifier.equals = function (a, b) {\n        if (typeof a === 'undefined' || a === null) {\n            return (typeof b === 'undefined' || b === null);\n        }\n        if (typeof b === 'undefined' || b === null) {\n            return false;\n        }\n        if (typeof a === 'string' || typeof b === 'string') {\n            // At least one of the arguments is an extension id in string form,\n            // so we have to use the string comparison which ignores case.\n            var aValue = (typeof a === 'string' ? a : a.value);\n            var bValue = (typeof b === 'string' ? b : b.value);\n            return strings.equalsIgnoreCase(aValue, bValue);\n        }\n        // Now we know both arguments are ExtensionIdentifier\n        return (a._lower === b._lower);\n    };\n    /**\n     * Gives the value by which to index (for equality).\n     */\n    ExtensionIdentifier.toKey = function (id) {\n        if (typeof id === 'string') {\n            return id.toLowerCase();\n        }\n        return id._lower;\n    };\n    return ExtensionIdentifier;\n}());\nexports.ExtensionIdentifier = ExtensionIdentifier;\nfunction isLanguagePackExtension(manifest) {\n    return manifest.contributes && manifest.contributes.localizations ? manifest.contributes.localizations.length > 0 : false;\n}\nexports.isLanguagePackExtension = isLanguagePackExtension;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/platform/extensions/common/extensions.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/platform/extensions/common/extensions.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { areSameExtensions } from 'vs/platform/extensionManagement/common/extensionManagementUtil';\nimport * as strings from 'vs/base/common/strings';\nimport { ILocalization } from 'vs/platform/localizations/common/localizations';\nimport { URI } from 'vs/base/common/uri';\n\nexport const MANIFEST_CACHE_FOLDER = 'CachedExtensions';\nexport const USER_MANIFEST_CACHE_FILE = 'user';\nexport const BUILTIN_MANIFEST_CACHE_FILE = 'builtin';\n\nexport interface ICommand {\n\tcommand: string;\n\ttitle: string;\n\tcategory?: string;\n}\n\nexport interface IConfigurationProperty {\n\tdescription: string;\n\ttype: string | string[];\n\tdefault?: any;\n}\n\nexport interface IConfiguration {\n\tproperties: { [key: string]: IConfigurationProperty; };\n}\n\nexport interface IDebugger {\n\tlabel?: string;\n\ttype: string;\n\truntime?: string;\n}\n\nexport interface IGrammar {\n\tlanguage: string;\n}\n\nexport interface IJSONValidation {\n\tfileMatch: string;\n\turl: string;\n}\n\nexport interface IKeyBinding {\n\tcommand: string;\n\tkey: string;\n\twhen?: string;\n\tmac?: string;\n\tlinux?: string;\n\twin?: string;\n}\n\nexport interface ILanguage {\n\tid: string;\n\textensions: string[];\n\taliases: string[];\n}\n\nexport interface IMenu {\n\tcommand: string;\n\talt?: string;\n\twhen?: string;\n\tgroup?: string;\n}\n\nexport interface ISnippet {\n\tlanguage: string;\n}\n\nexport interface ITheme {\n\tlabel: string;\n}\n\nexport interface IViewContainer {\n\tid: string;\n\ttitle: string;\n}\n\nexport interface IView {\n\tid: string;\n\tname: string;\n}\n\nexport interface IColor {\n\tid: string;\n\tdescription: string;\n\tdefaults: { light: string, dark: string, highContrast: string };\n}\n\nexport interface IExtensionContributions {\n\tcommands?: ICommand[];\n\tconfiguration?: IConfiguration | IConfiguration[];\n\tdebuggers?: IDebugger[];\n\tgrammars?: IGrammar[];\n\tjsonValidation?: IJSONValidation[];\n\tkeybindings?: IKeyBinding[];\n\tlanguages?: ILanguage[];\n\tmenus?: { [context: string]: IMenu[] };\n\tsnippets?: ISnippet[];\n\tthemes?: ITheme[];\n\ticonThemes?: ITheme[];\n\tviewsContainers?: { [location: string]: IViewContainer[] };\n\tviews?: { [location: string]: IView[] };\n\tcolors?: IColor[];\n\tlocalizations?: ILocalization[];\n}\n\nexport type ExtensionKind = 'ui' | 'workspace';\n\nexport class ExtensionIdentifierWithVersion {\n\tconstructor(\n\t\treadonly identifier: IExtensionIdentifier,\n\t\treadonly version: string\n\t) { }\n\n\tkey(): string {\n\t\treturn `${this.identifier.id}-${this.version}`;\n\t}\n\n\tequals(o: any): boolean {\n\t\tif (!(o instanceof ExtensionIdentifierWithVersion)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn areSameExtensions(this.identifier, o.identifier) && this.version === o.version;\n\t}\n}\n\nexport function isIExtensionIdentifier(thing: any): thing is IExtensionIdentifier {\n\treturn thing\n\t\t&& typeof thing === 'object'\n\t\t&& typeof thing.id === 'string'\n\t\t&& (!thing.uuid || typeof thing.uuid === 'string');\n}\n\nexport interface IExtensionIdentifier {\n\tid: string;\n\tuuid?: string;\n}\n\nexport interface IExtensionManifest {\n\treadonly name: string;\n\treadonly displayName?: string;\n\treadonly publisher: string;\n\treadonly version: string;\n\treadonly engines: { vscode: string };\n\treadonly description?: string;\n\treadonly main?: string;\n\treadonly icon?: string;\n\treadonly categories?: string[];\n\treadonly keywords?: string[];\n\treadonly activationEvents?: string[];\n\treadonly extensionDependencies?: string[];\n\treadonly extensionPack?: string[];\n\treadonly extensionKind?: ExtensionKind;\n\treadonly contributes?: IExtensionContributions;\n\treadonly repository?: { url: string; };\n\treadonly bugs?: { url: string; };\n\treadonly enableProposedApi?: boolean;\n\treadonly api?: string;\n}\n\nexport const enum ExtensionType {\n\tSystem,\n\tUser\n}\n\nexport interface IExtension {\n\treadonly type: ExtensionType;\n\treadonly identifier: IExtensionIdentifier;\n\treadonly manifest: IExtensionManifest;\n\treadonly location: URI;\n}\n\n/**\n * **!Do not construct directly!**\n *\n * **!Only static methods because it gets serialized!**\n *\n * This represents the \"canonical\" version for an extension identifier. Extension ids\n * have to be case-insensitive (due to the marketplace), but we must ensure case\n * preservation because the extension API is already public at this time.\n *\n * For example, given an extension with the publisher `\"Hello\"` and the name `\"World\"`,\n * its canonical extension identifier is `\"Hello.World\"`. This extension could be\n * referenced in some other extension's dependencies using the string `\"hello.world\"`.\n *\n * To make matters more complicated, an extension can optionally have an UUID. When two\n * extensions have the same UUID, they are considered equal even if their identifier is different.\n */\nexport class ExtensionIdentifier {\n\tpublic readonly value: string;\n\tprivate readonly _lower: string;\n\n\tconstructor(value: string) {\n\t\tthis.value = value;\n\t\tthis._lower = value.toLowerCase();\n\t}\n\n\tpublic static equals(a: ExtensionIdentifier | string | null | undefined, b: ExtensionIdentifier | string | null | undefined) {\n\t\tif (typeof a === 'undefined' || a === null) {\n\t\t\treturn (typeof b === 'undefined' || b === null);\n\t\t}\n\t\tif (typeof b === 'undefined' || b === null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof a === 'string' || typeof b === 'string') {\n\t\t\t// At least one of the arguments is an extension id in string form,\n\t\t\t// so we have to use the string comparison which ignores case.\n\t\t\tlet aValue = (typeof a === 'string' ? a : a.value);\n\t\t\tlet bValue = (typeof b === 'string' ? b : b.value);\n\t\t\treturn strings.equalsIgnoreCase(aValue, bValue);\n\t\t}\n\n\t\t// Now we know both arguments are ExtensionIdentifier\n\t\treturn (a._lower === b._lower);\n\t}\n\n\t/**\n\t * Gives the value by which to index (for equality).\n\t */\n\tpublic static toKey(id: ExtensionIdentifier | string): string {\n\t\tif (typeof id === 'string') {\n\t\t\treturn id.toLowerCase();\n\t\t}\n\t\treturn id._lower;\n\t}\n}\n\nexport interface IExtensionDescription extends IExtensionManifest {\n\treadonly identifier: ExtensionIdentifier;\n\treadonly uuid?: string;\n\treadonly isBuiltin: boolean;\n\treadonly isUnderDevelopment: boolean;\n\treadonly extensionLocation: URI;\n\tenableProposedApi?: boolean;\n}\n\nexport function isLanguagePackExtension(manifest: IExtensionManifest): boolean {\n\treturn manifest.contributes && manifest.contributes.localizations ? manifest.contributes.localizations.length > 0 : false;\n}"]}]}