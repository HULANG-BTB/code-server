{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/configuration/common/configuration.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/configuration/common/configuration.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/objects\", \"vs/base/common/types\", \"vs/base/common/uri\", \"vs/platform/registry/common/platform\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/configuration/common/configurationRegistry\"], function (require, exports, objects, types, uri_1, platform_1, instantiation_1, configurationRegistry_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.IConfigurationService = instantiation_1.createDecorator('configurationService');\n    function isConfigurationOverrides(thing) {\n        return thing\n            && typeof thing === 'object'\n            && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')\n            && (!thing.resource || thing.resource instanceof uri_1.URI);\n    }\n    exports.isConfigurationOverrides = isConfigurationOverrides;\n    var ConfigurationTarget;\n    (function (ConfigurationTarget) {\n        ConfigurationTarget[ConfigurationTarget[\"USER\"] = 1] = \"USER\";\n        ConfigurationTarget[ConfigurationTarget[\"USER_LOCAL\"] = 2] = \"USER_LOCAL\";\n        ConfigurationTarget[ConfigurationTarget[\"USER_REMOTE\"] = 3] = \"USER_REMOTE\";\n        ConfigurationTarget[ConfigurationTarget[\"WORKSPACE\"] = 4] = \"WORKSPACE\";\n        ConfigurationTarget[ConfigurationTarget[\"WORKSPACE_FOLDER\"] = 5] = \"WORKSPACE_FOLDER\";\n        ConfigurationTarget[ConfigurationTarget[\"DEFAULT\"] = 6] = \"DEFAULT\";\n        ConfigurationTarget[ConfigurationTarget[\"MEMORY\"] = 7] = \"MEMORY\";\n    })(ConfigurationTarget = exports.ConfigurationTarget || (exports.ConfigurationTarget = {}));\n    function ConfigurationTargetToString(configurationTarget) {\n        switch (configurationTarget) {\n            case ConfigurationTarget.USER: return 'USER';\n            case ConfigurationTarget.USER_LOCAL: return 'USER_LOCAL';\n            case ConfigurationTarget.USER_REMOTE: return 'USER_REMOTE';\n            case ConfigurationTarget.WORKSPACE: return 'WORKSPACE';\n            case ConfigurationTarget.WORKSPACE_FOLDER: return 'WORKSPACE_FOLDER';\n            case ConfigurationTarget.DEFAULT: return 'DEFAULT';\n            case ConfigurationTarget.MEMORY: return 'MEMORY';\n        }\n    }\n    exports.ConfigurationTargetToString = ConfigurationTargetToString;\n    function compare(from, to) {\n        const added = to.keys.filter(key => from.keys.indexOf(key) === -1);\n        const removed = from.keys.filter(key => to.keys.indexOf(key) === -1);\n        const updated = [];\n        for (const key of from.keys) {\n            const value1 = getConfigurationValue(from.contents, key);\n            const value2 = getConfigurationValue(to.contents, key);\n            if (!objects.equals(value1, value2)) {\n                updated.push(key);\n            }\n        }\n        return { added, removed, updated };\n    }\n    exports.compare = compare;\n    function toOverrides(raw, conflictReporter) {\n        const overrides = [];\n        const configurationProperties = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();\n        for (const key of Object.keys(raw)) {\n            if (configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(key)) {\n                const overrideRaw = {};\n                for (const keyInOverrideRaw in raw[key]) {\n                    if (configurationProperties[keyInOverrideRaw] && configurationProperties[keyInOverrideRaw].overridable) {\n                        overrideRaw[keyInOverrideRaw] = raw[key][keyInOverrideRaw];\n                    }\n                }\n                overrides.push({\n                    identifiers: [overrideIdentifierFromKey(key).trim()],\n                    contents: toValuesTree(overrideRaw, conflictReporter)\n                });\n            }\n        }\n        return overrides;\n    }\n    exports.toOverrides = toOverrides;\n    function toValuesTree(properties, conflictReporter) {\n        const root = Object.create(null);\n        for (let key in properties) {\n            addToValueTree(root, key, properties[key], conflictReporter);\n        }\n        return root;\n    }\n    exports.toValuesTree = toValuesTree;\n    function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {\n        const segments = key.split('.');\n        const last = segments.pop();\n        let curr = settingsTreeRoot;\n        for (let i = 0; i < segments.length; i++) {\n            let s = segments[i];\n            let obj = curr[s];\n            switch (typeof obj) {\n                case 'undefined':\n                    obj = curr[s] = Object.create(null);\n                    break;\n                case 'object':\n                    break;\n                default:\n                    conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join('.')} is ${JSON.stringify(obj)}`);\n                    return;\n            }\n            curr = obj;\n        }\n        if (typeof curr === 'object') {\n            curr[last] = value; // workaround https://github.com/Microsoft/vscode/issues/13606\n        }\n        else {\n            conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);\n        }\n    }\n    exports.addToValueTree = addToValueTree;\n    function removeFromValueTree(valueTree, key) {\n        const segments = key.split('.');\n        doRemoveFromValueTree(valueTree, segments);\n    }\n    exports.removeFromValueTree = removeFromValueTree;\n    function doRemoveFromValueTree(valueTree, segments) {\n        const first = segments.shift();\n        if (segments.length === 0) {\n            // Reached last segment\n            delete valueTree[first];\n            return;\n        }\n        if (Object.keys(valueTree).indexOf(first) !== -1) {\n            const value = valueTree[first];\n            if (typeof value === 'object' && !Array.isArray(value)) {\n                doRemoveFromValueTree(value, segments);\n                if (Object.keys(value).length === 0) {\n                    delete valueTree[first];\n                }\n            }\n        }\n    }\n    /**\n     * A helper function to get the configuration value with a specific settings path (e.g. config.some.setting)\n     */\n    function getConfigurationValue(config, settingPath, defaultValue) {\n        function accessSetting(config, path) {\n            let current = config;\n            for (const component of path) {\n                if (typeof current !== 'object' || current === null) {\n                    return undefined;\n                }\n                current = current[component];\n            }\n            return current;\n        }\n        const path = settingPath.split('.');\n        const result = accessSetting(config, path);\n        return typeof result === 'undefined' ? defaultValue : result;\n    }\n    exports.getConfigurationValue = getConfigurationValue;\n    function merge(base, add, overwrite) {\n        Object.keys(add).forEach(key => {\n            if (key in base) {\n                if (types.isObject(base[key]) && types.isObject(add[key])) {\n                    merge(base[key], add[key], overwrite);\n                }\n                else if (overwrite) {\n                    base[key] = add[key];\n                }\n            }\n            else {\n                base[key] = add[key];\n            }\n        });\n    }\n    exports.merge = merge;\n    function getConfigurationKeys() {\n        const properties = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();\n        return Object.keys(properties);\n    }\n    exports.getConfigurationKeys = getConfigurationKeys;\n    function getDefaultValues() {\n        const valueTreeRoot = Object.create(null);\n        const properties = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();\n        for (let key in properties) {\n            let value = properties[key].default;\n            addToValueTree(valueTreeRoot, key, value, message => console.error(`Conflict in default settings: ${message}`));\n        }\n        return valueTreeRoot;\n    }\n    exports.getDefaultValues = getDefaultValues;\n    function overrideIdentifierFromKey(key) {\n        return key.substring(1, key.length - 1);\n    }\n    exports.overrideIdentifierFromKey = overrideIdentifierFromKey;\n    function keyFromOverrideIdentifier(overrideIdentifier) {\n        return `[${overrideIdentifier}]`;\n    }\n    exports.keyFromOverrideIdentifier = keyFromOverrideIdentifier;\n    function getMigratedSettingValue(configurationService, currentSettingName, legacySettingName) {\n        const setting = configurationService.inspect(currentSettingName);\n        const legacySetting = configurationService.inspect(legacySettingName);\n        if (typeof setting.user !== 'undefined' || typeof setting.workspace !== 'undefined' || typeof setting.workspaceFolder !== 'undefined') {\n            return setting.value;\n        }\n        else if (typeof legacySetting.user !== 'undefined' || typeof legacySetting.workspace !== 'undefined' || typeof legacySetting.workspaceFolder !== 'undefined') {\n            return legacySetting.value;\n        }\n        else {\n            return setting.default;\n        }\n    }\n    exports.getMigratedSettingValue = getMigratedSettingValue;\n});\n",null]}