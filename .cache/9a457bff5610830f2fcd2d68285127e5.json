{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/lineDecorations.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/lineDecorations.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/strings\", \"vs/editor/common/core/uint\", \"vs/editor/common/viewModel/viewModel\"], function (require, exports, strings, uint_1, viewModel_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class LineDecoration {\n        constructor(startColumn, endColumn, className, type) {\n            this.startColumn = startColumn;\n            this.endColumn = endColumn;\n            this.className = className;\n            this.type = type;\n        }\n        static _equals(a, b) {\n            return (a.startColumn === b.startColumn\n                && a.endColumn === b.endColumn\n                && a.className === b.className\n                && a.type === b.type);\n        }\n        static equalsArr(a, b) {\n            let aLen = a.length;\n            let bLen = b.length;\n            if (aLen !== bLen) {\n                return false;\n            }\n            for (let i = 0; i < aLen; i++) {\n                if (!LineDecoration._equals(a[i], b[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        static filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\n            if (lineDecorations.length === 0) {\n                return [];\n            }\n            let result = [], resultLen = 0;\n            for (let i = 0, len = lineDecorations.length; i < len; i++) {\n                let d = lineDecorations[i];\n                let range = d.range;\n                if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n                    // Ignore decorations that sit outside this line\n                    continue;\n                }\n                if (range.isEmpty() && (d.type === viewModel_1.InlineDecorationType.Regular || d.type === viewModel_1.InlineDecorationType.RegularAffectingLetterSpacing)) {\n                    // Ignore empty range decorations\n                    continue;\n                }\n                let startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\n                let endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\n                result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n            }\n            return result;\n        }\n        static compare(a, b) {\n            if (a.startColumn === b.startColumn) {\n                if (a.endColumn === b.endColumn) {\n                    if (a.className < b.className) {\n                        return -1;\n                    }\n                    if (a.className > b.className) {\n                        return 1;\n                    }\n                    return 0;\n                }\n                return a.endColumn - b.endColumn;\n            }\n            return a.startColumn - b.startColumn;\n        }\n    }\n    exports.LineDecoration = LineDecoration;\n    class DecorationSegment {\n        constructor(startOffset, endOffset, className) {\n            this.startOffset = startOffset;\n            this.endOffset = endOffset;\n            this.className = className;\n        }\n    }\n    exports.DecorationSegment = DecorationSegment;\n    class Stack {\n        constructor() {\n            this.stopOffsets = [];\n            this.classNames = [];\n            this.count = 0;\n        }\n        consumeLowerThan(maxStopOffset, nextStartOffset, result) {\n            while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n                let i = 0;\n                // Take all equal stopping offsets\n                while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n                    i++;\n                }\n                // Basically we are consuming the first i + 1 elements of the stack\n                result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' ')));\n                nextStartOffset = this.stopOffsets[i] + 1;\n                // Consume them\n                this.stopOffsets.splice(0, i + 1);\n                this.classNames.splice(0, i + 1);\n                this.count -= (i + 1);\n            }\n            if (this.count > 0 && nextStartOffset < maxStopOffset) {\n                result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' ')));\n                nextStartOffset = maxStopOffset;\n            }\n            return nextStartOffset;\n        }\n        insert(stopOffset, className) {\n            if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n                // Insert at the end\n                this.stopOffsets.push(stopOffset);\n                this.classNames.push(className);\n            }\n            else {\n                // Find the insertion position for `stopOffset`\n                for (let i = 0; i < this.count; i++) {\n                    if (this.stopOffsets[i] >= stopOffset) {\n                        this.stopOffsets.splice(i, 0, stopOffset);\n                        this.classNames.splice(i, 0, className);\n                        break;\n                    }\n                }\n            }\n            this.count++;\n            return;\n        }\n    }\n    class LineDecorationsNormalizer {\n        /**\n         * Normalize line decorations. Overlapping decorations will generate multiple segments\n         */\n        static normalize(lineContent, lineDecorations) {\n            if (lineDecorations.length === 0) {\n                return [];\n            }\n            let result = [];\n            let stack = new Stack();\n            let nextStartOffset = 0;\n            for (let i = 0, len = lineDecorations.length; i < len; i++) {\n                let d = lineDecorations[i];\n                let startColumn = d.startColumn;\n                let endColumn = d.endColumn;\n                let className = d.className;\n                // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n                if (startColumn > 1) {\n                    const charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n                    if (strings.isHighSurrogate(charCodeBefore)) {\n                        startColumn--;\n                    }\n                }\n                if (endColumn > 1) {\n                    const charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n                    if (strings.isHighSurrogate(charCodeBefore)) {\n                        endColumn--;\n                    }\n                }\n                let currentStartOffset = startColumn - 1;\n                let currentEndOffset = endColumn - 2;\n                nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n                if (stack.count === 0) {\n                    nextStartOffset = currentStartOffset;\n                }\n                stack.insert(currentEndOffset, className);\n            }\n            stack.consumeLowerThan(uint_1.Constants.MAX_SAFE_SMALL_INTEGER, nextStartOffset, result);\n            return result;\n        }\n    }\n    exports.LineDecorationsNormalizer = LineDecorationsNormalizer;\n});\n",null]}