{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/webview/electron-browser/webviewElement.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/webview/electron-browser/webviewElement.ts","mtime":1555846338044},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/browser/dom\", \"vs/base/common/event\", \"vs/base/common/functional\", \"vs/base/common/lifecycle\", \"vs/base/browser/browser\", \"vs/base/common/strings\", \"vs/base/common/uri\", \"vs/platform/environment/common/environment\", \"vs/platform/files/common/files\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/theme/common/colorRegistry\", \"vs/platform/theme/common/themeService\", \"vs/workbench/contrib/webview/electron-browser/webviewProtocols\", \"./webviewEditorService\", \"./webviewFindWidget\", \"vs/platform/telemetry/common/telemetry\"], function (require, exports, dom_1, event_1, functional_1, lifecycle_1, browser_1, strings_1, uri_1, environment_1, files_1, instantiation_1, colorRegistry, themeService_1, webviewProtocols_1, webviewEditorService_1, webviewFindWidget_1, telemetry_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class WebviewSession extends lifecycle_1.Disposable {\n        constructor(webview) {\n            super();\n            this._onBeforeRequestDelegates = [];\n            this._onHeadersReceivedDelegates = [];\n            this._register(dom_1.addDisposableListener(webview, 'did-start-loading', functional_1.once(() => {\n                const contents = webview.getWebContents();\n                if (!contents) {\n                    return;\n                }\n                contents.session.webRequest.onBeforeRequest((details, callback) => __awaiter(this, void 0, void 0, function* () {\n                    for (const delegate of this._onBeforeRequestDelegates) {\n                        const result = yield delegate(details);\n                        if (typeof result !== 'undefined') {\n                            callback(result);\n                            return;\n                        }\n                    }\n                    callback({});\n                }));\n                contents.session.webRequest.onHeadersReceived((details, callback) => {\n                    for (const delegate of this._onHeadersReceivedDelegates) {\n                        const result = delegate(details);\n                        if (typeof result !== 'undefined') {\n                            callback(result);\n                            return;\n                        }\n                    }\n                    callback({ cancel: false, responseHeaders: details.responseHeaders });\n                });\n            })));\n        }\n        onBeforeRequest(delegate) {\n            this._onBeforeRequestDelegates.push(delegate);\n        }\n        onHeadersReceived(delegate) {\n            this._onHeadersReceivedDelegates.push(delegate);\n        }\n    }\n    class WebviewProtocolProvider extends lifecycle_1.Disposable {\n        constructor(webview, _extensionLocation, _getLocalResourceRoots, _environmentService, _fileService) {\n            super();\n            this._extensionLocation = _extensionLocation;\n            this._getLocalResourceRoots = _getLocalResourceRoots;\n            this._environmentService = _environmentService;\n            this._fileService = _fileService;\n            this._register(dom_1.addDisposableListener(webview, 'did-start-loading', functional_1.once(() => {\n                const contents = webview.getWebContents();\n                if (contents) {\n                    this.registerProtocols(contents);\n                }\n            })));\n        }\n        registerProtocols(contents) {\n            if (contents.isDestroyed()) {\n                return;\n            }\n            const appRootUri = uri_1.URI.file(this._environmentService.appRoot);\n            webviewProtocols_1.registerFileProtocol(contents, webviewProtocols_1.WebviewProtocol.CoreResource, this._fileService, undefined, () => [\n                appRootUri\n            ]);\n            webviewProtocols_1.registerFileProtocol(contents, webviewProtocols_1.WebviewProtocol.VsCodeResource, this._fileService, this._extensionLocation, () => this._getLocalResourceRoots());\n        }\n    }\n    let WebviewPortMappingProvider = class WebviewPortMappingProvider extends lifecycle_1.Disposable {\n        constructor(session, mappings, extensionId, telemetryService) {\n            super();\n            let hasLogged = false;\n            session.onBeforeRequest((details) => __awaiter(this, void 0, void 0, function* () {\n                const uri = uri_1.URI.parse(details.url);\n                if (uri.scheme !== 'http' && uri.scheme !== 'https') {\n                    return undefined;\n                }\n                const localhostMatch = /^localhost:(\\d+)$/.exec(uri.authority);\n                if (localhostMatch) {\n                    if (!hasLogged && extensionId) {\n                        hasLogged = true;\n                        /* __GDPR__\n                        \"webview.accessLocalhost\" : {\n                                \"extension\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                            }\n                        */\n                        telemetryService.publicLog('webview.accessLocalhost', { extension: extensionId.value });\n                    }\n                    const port = +localhostMatch[1];\n                    for (const mapping of mappings()) {\n                        if (mapping.port === port && mapping.port !== mapping.resolvedPort) {\n                            return {\n                                redirectURL: details.url.replace(new RegExp(`^${uri.scheme}://localhost:${mapping.port}/`), `${uri.scheme}://localhost:${mapping.resolvedPort}/`)\n                            };\n                        }\n                    }\n                }\n                return undefined;\n            }));\n        }\n    };\n    WebviewPortMappingProvider = __decorate([\n        __param(3, telemetry_1.ITelemetryService)\n    ], WebviewPortMappingProvider);\n    class SvgBlocker extends lifecycle_1.Disposable {\n        constructor(session, _options) {\n            super();\n            this._options = _options;\n            this._onDidBlockSvg = this._register(new event_1.Emitter());\n            this.onDidBlockSvg = this._onDidBlockSvg.event;\n            session.onBeforeRequest((details) => __awaiter(this, void 0, void 0, function* () {\n                if (details.url.indexOf('.svg') > 0) {\n                    const uri = uri_1.URI.parse(details.url);\n                    if (uri && !uri.scheme.match(/file/i) && strings_1.endsWith(uri.path, '.svg') && !this.isAllowedSvg(uri)) {\n                        this._onDidBlockSvg.fire();\n                        return { cancel: true };\n                    }\n                }\n                return undefined;\n            }));\n            session.onHeadersReceived((details) => {\n                const contentType = details.responseHeaders['content-type'] || details.responseHeaders['Content-Type'];\n                if (contentType && Array.isArray(contentType) && contentType.some(x => x.toLowerCase().indexOf('image/svg') >= 0)) {\n                    const uri = uri_1.URI.parse(details.url);\n                    if (uri && !this.isAllowedSvg(uri)) {\n                        this._onDidBlockSvg.fire();\n                        return { cancel: true };\n                    }\n                }\n                return undefined;\n            });\n        }\n        isAllowedSvg(uri) {\n            if (this._options.svgWhiteList) {\n                return this._options.svgWhiteList.indexOf(uri.authority.toLowerCase()) >= 0;\n            }\n            return false;\n        }\n    }\n    class WebviewKeyboardHandler extends lifecycle_1.Disposable {\n        constructor(_webview) {\n            super();\n            this._webview = _webview;\n            this._ignoreMenuShortcut = false;\n            if (this.shouldToggleMenuShortcutsEnablement) {\n                this._register(dom_1.addDisposableListener(this._webview, 'did-start-loading', () => {\n                    const contents = this.getWebContents();\n                    if (contents) {\n                        contents.on('before-input-event', (_event, input) => {\n                            if (input.type === 'keyDown' && document.activeElement === this._webview) {\n                                this._ignoreMenuShortcut = input.control || input.meta;\n                                this.setIgnoreMenuShortcuts(this._ignoreMenuShortcut);\n                            }\n                        });\n                    }\n                }));\n            }\n            this._register(dom_1.addDisposableListener(this._webview, 'ipc-message', (event) => {\n                switch (event.channel) {\n                    case 'did-keydown':\n                        // Electron: workaround for https://github.com/electron/electron/issues/14258\n                        // We have to detect keyboard events in the <webview> and dispatch them to our\n                        // keybinding service because these events do not bubble to the parent window anymore.\n                        this.handleKeydown(event.args[0]);\n                        return;\n                    case 'did-focus':\n                        this.setIgnoreMenuShortcuts(this._ignoreMenuShortcut);\n                        break;\n                    case 'did-blur':\n                        this.setIgnoreMenuShortcuts(false);\n                        return;\n                }\n            }));\n        }\n        get shouldToggleMenuShortcutsEnablement() {\n            return browser_1.isMacintosh;\n        }\n        setIgnoreMenuShortcuts(value) {\n            if (!this.shouldToggleMenuShortcutsEnablement) {\n                return;\n            }\n            const contents = this.getWebContents();\n            if (contents) {\n                contents.setIgnoreMenuShortcuts(value);\n            }\n        }\n        getWebContents() {\n            const contents = this._webview.getWebContents();\n            if (contents && !contents.isDestroyed()) {\n                return contents;\n            }\n            return undefined;\n        }\n        handleKeydown(event) {\n            // Create a fake KeyboardEvent from the data provided\n            const emulatedKeyboardEvent = new KeyboardEvent('keydown', event);\n            // Force override the target\n            Object.defineProperty(emulatedKeyboardEvent, 'target', {\n                get: () => this._webview\n            });\n            // And re-dispatch\n            window.dispatchEvent(emulatedKeyboardEvent);\n        }\n    }\n    let WebviewElement = class WebviewElement extends lifecycle_1.Disposable {\n        constructor(_styleElement, _options, _contentOptions, instantiationService, themeService, environmentService, fileService, telemetryService) {\n            super();\n            this._styleElement = _styleElement;\n            this._options = _options;\n            this._contentOptions = _contentOptions;\n            this._findStarted = false;\n            this._contents = '';\n            this._state = undefined;\n            this._focused = false;\n            this._onDidFocus = this._register(new event_1.Emitter());\n            this._onDidClickLink = this._register(new event_1.Emitter());\n            this.onDidClickLink = this._onDidClickLink.event;\n            this._onDidScroll = this._register(new event_1.Emitter());\n            this.onDidScroll = this._onDidScroll.event;\n            this._onDidUpdateState = this._register(new event_1.Emitter());\n            this.onDidUpdateState = this._onDidUpdateState.event;\n            this._onMessage = this._register(new event_1.Emitter());\n            this.onMessage = this._onMessage.event;\n            this._webview = document.createElement('webview');\n            this._webview.setAttribute('partition', `webview${Date.now()}`);\n            this._webview.setAttribute('webpreferences', 'contextIsolation=yes');\n            this._webview.style.flex = '0 1';\n            this._webview.style.width = '0';\n            this._webview.style.height = '0';\n            this._webview.style.outline = '0';\n            this._webview.preload = require.toUrl('./webview-pre.js');\n            this._webview.src = 'data:text/html;charset=utf-8,%3C%21DOCTYPE%20html%3E%0D%0A%3Chtml%20lang%3D%22en%22%20style%3D%22width%3A%20100%25%3B%20height%3A%20100%25%22%3E%0D%0A%3Chead%3E%0D%0A%09%3Ctitle%3EVirtual%20Document%3C%2Ftitle%3E%0D%0A%3C%2Fhead%3E%0D%0A%3Cbody%20style%3D%22margin%3A%200%3B%20overflow%3A%20hidden%3B%20width%3A%20100%25%3B%20height%3A%20100%25%22%3E%0D%0A%3C%2Fbody%3E%0D%0A%3C%2Fhtml%3E';\n            this._ready = new Promise(resolve => {\n                const subscription = this._register(dom_1.addDisposableListener(this._webview, 'ipc-message', (event) => {\n                    if (event.channel === 'webview-ready') {\n                        // console.info('[PID Webview] ' event.args[0]);\n                        dom_1.addClass(this._webview, 'ready'); // can be found by debug command\n                        subscription.dispose();\n                        resolve();\n                    }\n                }));\n            });\n            const session = this._register(new WebviewSession(this._webview));\n            this._register(new WebviewProtocolProvider(this._webview, this._options.extension ? this._options.extension.location : undefined, () => (this._contentOptions.localResourceRoots || []), environmentService, fileService));\n            this._register(new WebviewPortMappingProvider(session, () => (this._contentOptions.portMappings || []), _options.extension ? _options.extension.id : undefined, telemetryService));\n            if (!this._options.allowSvgs) {\n                const svgBlocker = this._register(new SvgBlocker(session, this._contentOptions));\n                svgBlocker.onDidBlockSvg(() => this.onDidBlockSvg());\n            }\n            this._register(new WebviewKeyboardHandler(this._webview));\n            this._register(dom_1.addDisposableListener(this._webview, 'console-message', function (e) {\n                console.log(`[Embedded Page] ${e.message}`);\n            }));\n            this._register(dom_1.addDisposableListener(this._webview, 'dom-ready', () => {\n                this.layout();\n                // Workaround for https://github.com/electron/electron/issues/14474\n                if (this._focused || document.activeElement === this._webview) {\n                    this._webview.blur();\n                    this._webview.focus();\n                }\n            }));\n            this._register(dom_1.addDisposableListener(this._webview, 'crashed', () => {\n                console.error('embedded page crashed');\n            }));\n            this._register(dom_1.addDisposableListener(this._webview, 'ipc-message', (event) => {\n                switch (event.channel) {\n                    case 'onmessage':\n                        if (event.args && event.args.length) {\n                            this._onMessage.fire(event.args[0]);\n                        }\n                        return;\n                    case 'did-click-link':\n                        let [uri] = event.args;\n                        this._onDidClickLink.fire(uri_1.URI.parse(uri));\n                        return;\n                    case 'did-set-content':\n                        this._webview.style.flex = '';\n                        this._webview.style.width = '100%';\n                        this._webview.style.height = '100%';\n                        this.layout();\n                        return;\n                    case 'did-scroll':\n                        if (event.args && typeof event.args[0] === 'number') {\n                            this._onDidScroll.fire({ scrollYPercentage: event.args[0] });\n                        }\n                        return;\n                    case 'do-reload':\n                        this.reload();\n                        return;\n                    case 'do-update-state':\n                        this._state = event.args[0];\n                        this._onDidUpdateState.fire(this._state);\n                        return;\n                    case 'did-focus':\n                        this.handleFocusChange(true);\n                        return;\n                    case 'did-blur':\n                        this.handleFocusChange(false);\n                        return;\n                }\n            }));\n            this._register(dom_1.addDisposableListener(this._webview, 'devtools-opened', () => {\n                this._send('devtools-opened');\n            }));\n            if (_options.enableFindWidget) {\n                this._webviewFindWidget = this._register(instantiationService.createInstance(webviewFindWidget_1.WebviewFindWidget, this));\n            }\n            this.style(themeService.getTheme());\n            themeService.onThemeChange(this.style, this, this._toDispose);\n        }\n        get onDidFocus() { return this._onDidFocus.event; }\n        mountTo(parent) {\n            if (this._webviewFindWidget) {\n                parent.appendChild(this._webviewFindWidget.getDomNode());\n            }\n            parent.appendChild(this._webview);\n        }\n        dispose() {\n            if (this._webview) {\n                if (this._webview.parentElement) {\n                    this._webview.parentElement.removeChild(this._webview);\n                }\n            }\n            this._webview = undefined;\n            this._webviewFindWidget = undefined;\n            super.dispose();\n        }\n        _send(channel, ...args) {\n            this._ready\n                .then(() => this._webview.send(channel, ...args))\n                .catch(err => console.error(err));\n        }\n        set initialScrollProgress(value) {\n            this._send('initial-scroll-position', value);\n        }\n        set state(value) {\n            this._state = value;\n        }\n        set options(value) {\n            if (this._contentOptions && webviewEditorService_1.areWebviewInputOptionsEqual(value, this._contentOptions)) {\n                return;\n            }\n            this._contentOptions = value;\n            this._send('content', {\n                contents: this._contents,\n                options: this._contentOptions,\n                state: this._state\n            });\n        }\n        set contents(value) {\n            this._contents = value;\n            this._send('content', {\n                contents: value,\n                options: this._contentOptions,\n                state: this._state\n            });\n        }\n        update(value, options, retainContextWhenHidden) {\n            if (retainContextWhenHidden && value === this._contents && this._contentOptions && webviewEditorService_1.areWebviewInputOptionsEqual(options, this._contentOptions)) {\n                return;\n            }\n            this._contents = value;\n            this._contentOptions = options;\n            this._send('content', {\n                contents: this._contents,\n                options: this._contentOptions,\n                state: this._state\n            });\n        }\n        set baseUrl(value) {\n            this._send('baseUrl', value);\n        }\n        focus() {\n            this._webview.focus();\n            this._send('focus');\n            // Handle focus change programmatically (do not rely on event from <webview>)\n            this.handleFocusChange(true);\n        }\n        handleFocusChange(isFocused) {\n            this._focused = isFocused;\n            if (isFocused) {\n                this._onDidFocus.fire();\n            }\n        }\n        sendMessage(data) {\n            this._send('message', data);\n        }\n        onDidBlockSvg() {\n            this.sendMessage({\n                name: 'vscode-did-block-svg'\n            });\n        }\n        style(theme) {\n            const { fontFamily, fontWeight, fontSize } = window.getComputedStyle(this._styleElement); // TODO@theme avoid styleElement\n            const exportedColors = colorRegistry.getColorRegistry().getColors().reduce((colors, entry) => {\n                const color = theme.getColor(entry.id);\n                if (color) {\n                    colors['vscode-' + entry.id.replace('.', '-')] = color.toString();\n                }\n                return colors;\n            }, {});\n            const styles = Object.assign({ 'vscode-editor-font-family': fontFamily, 'vscode-editor-font-weight': fontWeight, 'vscode-editor-font-size': fontSize }, exportedColors);\n            const activeTheme = ApiThemeClassName.fromTheme(theme);\n            this._send('styles', styles, activeTheme);\n            if (this._webviewFindWidget) {\n                this._webviewFindWidget.updateTheme(theme);\n            }\n        }\n        layout() {\n            const contents = this._webview.getWebContents();\n            if (!contents || contents.isDestroyed()) {\n                return;\n            }\n            const window = contents.getOwnerBrowserWindow();\n            if (!window || !window.webContents || window.webContents.isDestroyed()) {\n                return;\n            }\n            window.webContents.getZoomFactor((factor) => {\n                if (contents.isDestroyed()) {\n                    return;\n                }\n                contents.setZoomFactor(factor);\n            });\n        }\n        startFind(value, options) {\n            if (!value) {\n                return;\n            }\n            // ensure options is defined without modifying the original\n            options = options || {};\n            // FindNext must be false for a first request\n            const findOptions = {\n                forward: options.forward,\n                findNext: false,\n                matchCase: options.matchCase,\n                medialCapitalAsWordStart: options.medialCapitalAsWordStart\n            };\n            this._findStarted = true;\n            this._webview.findInPage(value, findOptions);\n        }\n        /**\n         * Webviews expose a stateful find API.\n         * Successive calls to find will move forward or backward through onFindResults\n         * depending on the supplied options.\n         *\n         * @param value The string to search for. Empty strings are ignored.\n         */\n        find(value, options) {\n            // Searching with an empty value will throw an exception\n            if (!value) {\n                return;\n            }\n            if (!this._findStarted) {\n                this.startFind(value, options);\n                return;\n            }\n            this._webview.findInPage(value, options);\n        }\n        stopFind(keepSelection) {\n            this._findStarted = false;\n            this._webview.stopFindInPage(keepSelection ? 'keepSelection' : 'clearSelection');\n        }\n        showFind() {\n            if (this._webviewFindWidget) {\n                this._webviewFindWidget.reveal();\n            }\n        }\n        hideFind() {\n            if (this._webviewFindWidget) {\n                this._webviewFindWidget.hide();\n            }\n        }\n        reload() {\n            this.contents = this._contents;\n        }\n        selectAll() {\n            this._webview.selectAll();\n        }\n        copy() {\n            this._webview.copy();\n        }\n        paste() {\n            this._webview.paste();\n        }\n        cut() {\n            this._webview.cut();\n        }\n        undo() {\n            this._webview.undo();\n        }\n        redo() {\n            this._webview.redo();\n        }\n    };\n    WebviewElement = __decorate([\n        __param(3, instantiation_1.IInstantiationService),\n        __param(4, themeService_1.IThemeService),\n        __param(5, environment_1.IEnvironmentService),\n        __param(6, files_1.IFileService),\n        __param(7, telemetry_1.ITelemetryService)\n    ], WebviewElement);\n    exports.WebviewElement = WebviewElement;\n    var ApiThemeClassName;\n    (function (ApiThemeClassName) {\n        ApiThemeClassName[\"light\"] = \"vscode-light\";\n        ApiThemeClassName[\"dark\"] = \"vscode-dark\";\n        ApiThemeClassName[\"highContrast\"] = \"vscode-high-contrast\";\n    })(ApiThemeClassName || (ApiThemeClassName = {}));\n    (function (ApiThemeClassName) {\n        function fromTheme(theme) {\n            if (theme.type === themeService_1.LIGHT) {\n                return ApiThemeClassName.light;\n            }\n            else if (theme.type === themeService_1.DARK) {\n                return ApiThemeClassName.dark;\n            }\n            else {\n                return ApiThemeClassName.highContrast;\n            }\n        }\n        ApiThemeClassName.fromTheme = fromTheme;\n    })(ApiThemeClassName || (ApiThemeClassName = {}));\n});\n",null]}