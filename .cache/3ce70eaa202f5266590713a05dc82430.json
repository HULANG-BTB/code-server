{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/charCode\", \"vs/base/common/strings\", \"vs/editor/common/model\", \"vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase\", \"vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer\"], function (require, exports, charCode_1, strings, model_1, pieceTreeBase_1, pieceTreeTextBuffer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class PieceTreeTextBufferFactory {\n        constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _isBasicASCII, _normalizeEOL) {\n            this._chunks = _chunks;\n            this._bom = _bom;\n            this._cr = _cr;\n            this._lf = _lf;\n            this._crlf = _crlf;\n            this._containsRTL = _containsRTL;\n            this._isBasicASCII = _isBasicASCII;\n            this._normalizeEOL = _normalizeEOL;\n        }\n        _getEOL(defaultEOL) {\n            const totalEOLCount = this._cr + this._lf + this._crlf;\n            const totalCRCount = this._cr + this._crlf;\n            if (totalEOLCount === 0) {\n                // This is an empty file or a file with precisely one line\n                return (defaultEOL === model_1.DefaultEndOfLine.LF ? '\\n' : '\\r\\n');\n            }\n            if (totalCRCount > totalEOLCount / 2) {\n                // More than half of the file contains \\r\\n ending lines\n                return '\\r\\n';\n            }\n            // At least one line more ends in \\n\n            return '\\n';\n        }\n        create(defaultEOL) {\n            const eol = this._getEOL(defaultEOL);\n            let chunks = this._chunks;\n            if (this._normalizeEOL &&\n                ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                    || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n                // Normalize pieces\n                for (let i = 0, len = chunks.length; i < len; i++) {\n                    let str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                    let newLineStart = pieceTreeBase_1.createLineStartsFast(str);\n                    chunks[i] = new pieceTreeBase_1.StringBuffer(str, newLineStart);\n                }\n            }\n            return new pieceTreeTextBuffer_1.PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._isBasicASCII, this._normalizeEOL);\n        }\n        getFirstLineText(lengthLimit) {\n            return this._chunks[0].buffer.substr(0, 100).split(/\\r\\n|\\r|\\n/)[0];\n        }\n    }\n    exports.PieceTreeTextBufferFactory = PieceTreeTextBufferFactory;\n    class PieceTreeTextBufferBuilder {\n        constructor() {\n            this.chunks = [];\n            this.BOM = '';\n            this._hasPreviousChar = false;\n            this._previousChar = 0;\n            this._tmpLineStarts = [];\n            this.cr = 0;\n            this.lf = 0;\n            this.crlf = 0;\n            this.containsRTL = false;\n            this.isBasicASCII = true;\n        }\n        acceptChunk(chunk) {\n            if (chunk.length === 0) {\n                return;\n            }\n            if (this.chunks.length === 0) {\n                if (strings.startsWithUTF8BOM(chunk)) {\n                    this.BOM = strings.UTF8_BOM_CHARACTER;\n                    chunk = chunk.substr(1);\n                }\n            }\n            const lastChar = chunk.charCodeAt(chunk.length - 1);\n            if (lastChar === charCode_1.CharCode.CarriageReturn || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                // last character is \\r or a high surrogate => keep it back\n                this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n                this._hasPreviousChar = true;\n                this._previousChar = lastChar;\n            }\n            else {\n                this._acceptChunk1(chunk, false);\n                this._hasPreviousChar = false;\n                this._previousChar = lastChar;\n            }\n        }\n        _acceptChunk1(chunk, allowEmptyStrings) {\n            if (!allowEmptyStrings && chunk.length === 0) {\n                // Nothing to do\n                return;\n            }\n            if (this._hasPreviousChar) {\n                this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n            }\n            else {\n                this._acceptChunk2(chunk);\n            }\n        }\n        _acceptChunk2(chunk) {\n            const lineStarts = pieceTreeBase_1.createLineStarts(this._tmpLineStarts, chunk);\n            this.chunks.push(new pieceTreeBase_1.StringBuffer(chunk, lineStarts.lineStarts));\n            this.cr += lineStarts.cr;\n            this.lf += lineStarts.lf;\n            this.crlf += lineStarts.crlf;\n            if (this.isBasicASCII) {\n                this.isBasicASCII = lineStarts.isBasicASCII;\n            }\n            if (!this.isBasicASCII && !this.containsRTL) {\n                // No need to check if is basic ASCII\n                this.containsRTL = strings.containsRTL(chunk);\n            }\n        }\n        finish(normalizeEOL = true) {\n            this._finish();\n            return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.isBasicASCII, normalizeEOL);\n        }\n        _finish() {\n            if (this.chunks.length === 0) {\n                this._acceptChunk1('', true);\n            }\n            if (this._hasPreviousChar) {\n                this._hasPreviousChar = false;\n                // recreate last chunk\n                let lastChunk = this.chunks[this.chunks.length - 1];\n                lastChunk.buffer += String.fromCharCode(this._previousChar);\n                let newLineStarts = pieceTreeBase_1.createLineStartsFast(lastChunk.buffer);\n                lastChunk.lineStarts = newLineStarts;\n                if (this._previousChar === charCode_1.CharCode.CarriageReturn) {\n                    this.cr++;\n                }\n            }\n        }\n    }\n    exports.PieceTreeTextBufferBuilder = PieceTreeTextBufferBuilder;\n});\n",null]}