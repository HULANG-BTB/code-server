{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/rename/rename.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/rename/rename.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/errors\", \"vs/base/common/keyCodes\", \"vs/platform/contextkey/common/contextkey\", \"vs/platform/progress/common/progress\", \"vs/editor/browser/editorExtensions\", \"vs/editor/common/editorContextKeys\", \"./renameInputField\", \"vs/platform/theme/common/themeService\", \"vs/editor/common/modes\", \"vs/editor/common/core/position\", \"vs/base/browser/ui/aria/aria\", \"vs/editor/common/core/range\", \"vs/editor/contrib/message/messageController\", \"vs/editor/browser/core/editorState\", \"vs/platform/keybinding/common/keybindingsRegistry\", \"vs/platform/notification/common/notification\", \"vs/editor/browser/services/bulkEditService\", \"vs/base/common/uri\", \"vs/editor/browser/services/codeEditorService\", \"vs/base/common/cancellation\", \"vs/base/common/lifecycle\", \"vs/base/common/async\"], function (require, exports, nls, errors_1, keyCodes_1, contextkey_1, progress_1, editorExtensions_1, editorContextKeys_1, renameInputField_1, themeService_1, modes_1, position_1, aria_1, range_1, messageController_1, editorState_1, keybindingsRegistry_1, notification_1, bulkEditService_1, uri_1, codeEditorService_1, cancellation_1, lifecycle_1, async_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class RenameSkeleton {\n        constructor(model, position) {\n            this.model = model;\n            this.position = position;\n            this._providers = modes_1.RenameProviderRegistry.ordered(model);\n        }\n        hasProvider() {\n            return this._providers.length > 0;\n        }\n        resolveRenameLocation(token) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const firstProvider = this._providers[0];\n                if (!firstProvider) {\n                    return undefined;\n                }\n                let res;\n                if (firstProvider.resolveRenameLocation) {\n                    res = yield firstProvider.resolveRenameLocation(this.model, this.position, token);\n                }\n                if (!res) {\n                    const word = this.model.getWordAtPosition(this.position);\n                    if (word) {\n                        return {\n                            range: new range_1.Range(this.position.lineNumber, word.startColumn, this.position.lineNumber, word.endColumn),\n                            text: word.word\n                        };\n                    }\n                }\n                return res;\n            });\n        }\n        provideRenameEdits(newName, i, rejects, token) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const provider = this._providers[i];\n                if (!provider) {\n                    return {\n                        edits: [],\n                        rejectReason: rejects.join('\\n')\n                    };\n                }\n                const result = yield provider.provideRenameEdits(this.model, this.position, newName, token);\n                if (!result) {\n                    return this.provideRenameEdits(newName, i + 1, rejects.concat(nls.localize('no result', \"No result.\")), token);\n                }\n                else if (result.rejectReason) {\n                    return this.provideRenameEdits(newName, i + 1, rejects.concat(result.rejectReason), token);\n                }\n                return result;\n            });\n        }\n    }\n    function rename(model, position, newName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new RenameSkeleton(model, position).provideRenameEdits(newName, 0, [], cancellation_1.CancellationToken.None);\n        });\n    }\n    exports.rename = rename;\n    // ---  register actions and commands\n    let RenameController = class RenameController extends lifecycle_1.Disposable {\n        constructor(editor, _notificationService, _bulkEditService, _progressService, _contextKeyService, _themeService) {\n            super();\n            this.editor = editor;\n            this._notificationService = _notificationService;\n            this._bulkEditService = _bulkEditService;\n            this._progressService = _progressService;\n            this._contextKeyService = _contextKeyService;\n            this._themeService = _themeService;\n            this._renameOperationIdPool = 1;\n            this._register(this.editor.onDidChangeModel(() => this.onModelChanged()));\n            this._register(this.editor.onDidChangeModelLanguage(() => this.onModelChanged()));\n            this._register(this.editor.onDidChangeCursorSelection(() => this.onModelChanged()));\n        }\n        static get(editor) {\n            return editor.getContribution(RenameController.ID);\n        }\n        get renameInputField() {\n            if (!this._renameInputField) {\n                this._renameInputField = this._register(new renameInputField_1.RenameInputField(this.editor, this._themeService, this._contextKeyService));\n            }\n            return this._renameInputField;\n        }\n        getId() {\n            return RenameController.ID;\n        }\n        run() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (this._activeRename) {\n                    this._activeRename.operation.cancel();\n                }\n                const id = this._renameOperationIdPool++;\n                this._activeRename = {\n                    id,\n                    operation: async_1.createCancelablePromise(token => this.doRename(token, id))\n                };\n                return this._activeRename.operation;\n            });\n        }\n        doRename(token, id) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!this.editor.hasModel()) {\n                    return undefined;\n                }\n                const position = this.editor.getPosition();\n                const skeleton = new RenameSkeleton(this.editor.getModel(), position);\n                if (!skeleton.hasProvider()) {\n                    return undefined;\n                }\n                let loc;\n                try {\n                    const resolveLocationOperation = skeleton.resolveRenameLocation(token);\n                    this._progressService.showWhile(resolveLocationOperation, 250);\n                    loc = yield resolveLocationOperation;\n                }\n                catch (e) {\n                    messageController_1.MessageController.get(this.editor).showMessage(e || nls.localize('resolveRenameLocationFailed', \"An unknown error occurred while resolving rename location\"), position);\n                    return undefined;\n                }\n                if (!loc) {\n                    return undefined;\n                }\n                if (loc.rejectReason) {\n                    messageController_1.MessageController.get(this.editor).showMessage(loc.rejectReason, position);\n                    return undefined;\n                }\n                if (!this._activeRename || this._activeRename.id !== id) {\n                    return undefined;\n                }\n                let selection = this.editor.getSelection();\n                let selectionStart = 0;\n                let selectionEnd = loc.text.length;\n                if (!range_1.Range.isEmpty(selection) && !range_1.Range.spansMultipleLines(selection) && range_1.Range.containsRange(loc.range, selection)) {\n                    selectionStart = Math.max(0, selection.startColumn - loc.range.startColumn);\n                    selectionEnd = Math.min(loc.range.endColumn, selection.endColumn) - loc.range.startColumn;\n                }\n                return this.renameInputField.getInput(loc.range, loc.text, selectionStart, selectionEnd).then(newNameOrFocusFlag => {\n                    if (typeof newNameOrFocusFlag === 'boolean') {\n                        if (newNameOrFocusFlag) {\n                            this.editor.focus();\n                        }\n                        return undefined;\n                    }\n                    this.editor.focus();\n                    const state = new editorState_1.EditorState(this.editor, editorState_1.CodeEditorStateFlag.Position | editorState_1.CodeEditorStateFlag.Value | editorState_1.CodeEditorStateFlag.Selection | editorState_1.CodeEditorStateFlag.Scroll);\n                    const renameOperation = Promise.resolve(skeleton.provideRenameEdits(newNameOrFocusFlag, 0, [], token).then(result => {\n                        if (!this.editor.hasModel()) {\n                            return undefined;\n                        }\n                        if (result.rejectReason) {\n                            if (state.validate(this.editor)) {\n                                messageController_1.MessageController.get(this.editor).showMessage(result.rejectReason, this.editor.getPosition());\n                            }\n                            else {\n                                this._notificationService.info(result.rejectReason);\n                            }\n                            return undefined;\n                        }\n                        return this._bulkEditService.apply(result, { editor: this.editor }).then(result => {\n                            // alert\n                            if (result.ariaSummary) {\n                                aria_1.alert(nls.localize('aria', \"Successfully renamed '{0}' to '{1}'. Summary: {2}\", loc.text, newNameOrFocusFlag, result.ariaSummary));\n                            }\n                        });\n                    }, err => {\n                        this._notificationService.error(nls.localize('rename.failed', \"Rename failed to execute.\"));\n                        return Promise.reject(err);\n                    }));\n                    this._progressService.showWhile(renameOperation, 250);\n                    return renameOperation;\n                });\n            });\n        }\n        acceptRenameInput() {\n            if (this._renameInputField) {\n                this._renameInputField.acceptInput();\n            }\n        }\n        cancelRenameInput() {\n            if (this._renameInputField) {\n                this._renameInputField.cancelInput(true);\n            }\n        }\n        onModelChanged() {\n            if (this._activeRename) {\n                this._activeRename.operation.cancel();\n                this._activeRename = undefined;\n            }\n        }\n    };\n    RenameController.ID = 'editor.contrib.renameController';\n    RenameController = __decorate([\n        __param(1, notification_1.INotificationService),\n        __param(2, bulkEditService_1.IBulkEditService),\n        __param(3, progress_1.IProgressService),\n        __param(4, contextkey_1.IContextKeyService),\n        __param(5, themeService_1.IThemeService)\n    ], RenameController);\n    // ---- action implementation\n    class RenameAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.rename',\n                label: nls.localize('rename.label', \"Rename Symbol\"),\n                alias: 'Rename Symbol',\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, editorContextKeys_1.EditorContextKeys.hasRenameProvider),\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyCode.F2,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                menuOpts: {\n                    group: '1_modification',\n                    order: 1.1\n                }\n            });\n        }\n        runCommand(accessor, args) {\n            const editorService = accessor.get(codeEditorService_1.ICodeEditorService);\n            const [uri, pos] = Array.isArray(args) && args || [undefined, undefined];\n            if (uri_1.URI.isUri(uri) && position_1.Position.isIPosition(pos)) {\n                return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then(editor => {\n                    if (!editor) {\n                        return;\n                    }\n                    editor.setPosition(pos);\n                    editor.invokeWithinContext(accessor => {\n                        this.reportTelemetry(accessor, editor);\n                        return this.run(accessor, editor);\n                    });\n                }, errors_1.onUnexpectedError);\n            }\n            return super.runCommand(accessor, args);\n        }\n        run(accessor, editor) {\n            const controller = RenameController.get(editor);\n            if (controller) {\n                return controller.run();\n            }\n            return Promise.resolve();\n        }\n    }\n    exports.RenameAction = RenameAction;\n    editorExtensions_1.registerEditorContribution(RenameController);\n    editorExtensions_1.registerEditorAction(RenameAction);\n    const RenameCommand = editorExtensions_1.EditorCommand.bindToContribution(RenameController.get);\n    editorExtensions_1.registerEditorCommand(new RenameCommand({\n        id: 'acceptRenameInput',\n        precondition: renameInputField_1.CONTEXT_RENAME_INPUT_VISIBLE,\n        handler: x => x.acceptRenameInput(),\n        kbOpts: {\n            weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib + 99,\n            kbExpr: editorContextKeys_1.EditorContextKeys.focus,\n            primary: keyCodes_1.KeyCode.Enter\n        }\n    }));\n    editorExtensions_1.registerEditorCommand(new RenameCommand({\n        id: 'cancelRenameInput',\n        precondition: renameInputField_1.CONTEXT_RENAME_INPUT_VISIBLE,\n        handler: x => x.cancelRenameInput(),\n        kbOpts: {\n            weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib + 99,\n            kbExpr: editorContextKeys_1.EditorContextKeys.focus,\n            primary: keyCodes_1.KeyCode.Escape,\n            secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape]\n        }\n    }));\n    // ---- api bridge command\n    editorExtensions_1.registerDefaultLanguageCommand('_executeDocumentRenameProvider', function (model, position, args) {\n        let { newName } = args;\n        if (typeof newName !== 'string') {\n            throw errors_1.illegalArgument('newName');\n        }\n        return rename(model, position, newName);\n    });\n});\n",null]}