{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/debug.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/debug.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar nls = require(\"vs/nls\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar contextkey_1 = require(\"vs/platform/contextkey/common/contextkey\");\nvar views_1 = require(\"vs/workbench/common/views\");\nvar platform_1 = require(\"vs/platform/registry/common/platform\");\nexports.VIEWLET_ID = 'workbench.view.debug';\nexports.VIEW_CONTAINER = platform_1.Registry.as(views_1.Extensions.ViewContainersRegistry).registerViewContainer(exports.VIEWLET_ID);\nexports.VARIABLES_VIEW_ID = 'workbench.debug.variablesView';\nexports.WATCH_VIEW_ID = 'workbench.debug.watchExpressionsView';\nexports.CALLSTACK_VIEW_ID = 'workbench.debug.callStackView';\nexports.LOADED_SCRIPTS_VIEW_ID = 'workbench.debug.loadedScriptsView';\nexports.BREAKPOINTS_VIEW_ID = 'workbench.debug.breakPointsView';\nexports.REPL_ID = 'workbench.panel.repl';\nexports.DEBUG_SERVICE_ID = 'debugService';\nexports.CONTEXT_DEBUG_TYPE = new contextkey_1.RawContextKey('debugType', undefined);\nexports.CONTEXT_DEBUG_CONFIGURATION_TYPE = new contextkey_1.RawContextKey('debugConfigurationType', undefined);\nexports.CONTEXT_DEBUG_STATE = new contextkey_1.RawContextKey('debugState', 'inactive');\nexports.CONTEXT_IN_DEBUG_MODE = new contextkey_1.RawContextKey('inDebugMode', false);\nexports.CONTEXT_IN_DEBUG_REPL = new contextkey_1.RawContextKey('inDebugRepl', false);\nexports.CONTEXT_BREAKPOINT_WIDGET_VISIBLE = new contextkey_1.RawContextKey('breakpointWidgetVisible', false);\nexports.CONTEXT_IN_BREAKPOINT_WIDGET = new contextkey_1.RawContextKey('inBreakpointWidget', false);\nexports.CONTEXT_BREAKPOINTS_FOCUSED = new contextkey_1.RawContextKey('breakpointsFocused', true);\nexports.CONTEXT_WATCH_EXPRESSIONS_FOCUSED = new contextkey_1.RawContextKey('watchExpressionsFocused', true);\nexports.CONTEXT_VARIABLES_FOCUSED = new contextkey_1.RawContextKey('variablesFocused', true);\nexports.CONTEXT_EXPRESSION_SELECTED = new contextkey_1.RawContextKey('expressionSelected', false);\nexports.CONTEXT_BREAKPOINT_SELECTED = new contextkey_1.RawContextKey('breakpointSelected', false);\nexports.CONTEXT_CALLSTACK_ITEM_TYPE = new contextkey_1.RawContextKey('callStackItemType', undefined);\nexports.CONTEXT_LOADED_SCRIPTS_SUPPORTED = new contextkey_1.RawContextKey('loadedScriptsSupported', false);\nexports.CONTEXT_LOADED_SCRIPTS_ITEM_TYPE = new contextkey_1.RawContextKey('loadedScriptsItemType', undefined);\nexports.CONTEXT_FOCUSED_SESSION_IS_ATTACH = new contextkey_1.RawContextKey('focusedSessionIsAttach', false);\nexports.CONTEXT_STEP_BACK_SUPPORTED = new contextkey_1.RawContextKey('stepBackSupported', false);\nexports.CONTEXT_RESTART_FRAME_SUPPORTED = new contextkey_1.RawContextKey('restartFrameSupported', false);\nexports.EDITOR_CONTRIBUTION_ID = 'editor.contrib.debug';\nexports.DEBUG_SCHEME = 'debug';\nexports.INTERNAL_CONSOLE_OPTIONS_SCHEMA = {\n    enum: ['neverOpen', 'openOnSessionStart', 'openOnFirstSessionStart'],\n    default: 'openOnFirstSessionStart',\n    description: nls.localize('internalConsoleOptions', \"Controls when the internal debug console should open.\")\n};\nvar State;\n(function (State) {\n    State[State[\"Inactive\"] = 0] = \"Inactive\";\n    State[State[\"Initializing\"] = 1] = \"Initializing\";\n    State[State[\"Stopped\"] = 2] = \"Stopped\";\n    State[State[\"Running\"] = 3] = \"Running\";\n})(State = exports.State || (exports.State = {}));\nfunction getStateLabel(state) {\n    switch (state) {\n        case State.Initializing: return 'initializing';\n        case State.Stopped: return 'stopped';\n        case State.Running: return 'running';\n        default: return 'inactive';\n    }\n}\nexports.getStateLabel = getStateLabel;\nvar AdapterEndEvent = /** @class */ (function () {\n    function AdapterEndEvent() {\n    }\n    return AdapterEndEvent;\n}());\nexports.AdapterEndEvent = AdapterEndEvent;\n// Debug service interfaces\nexports.IDebugService = instantiation_1.createDecorator(exports.DEBUG_SERVICE_ID);\n// Editor interfaces\nvar BreakpointWidgetContext;\n(function (BreakpointWidgetContext) {\n    BreakpointWidgetContext[BreakpointWidgetContext[\"CONDITION\"] = 0] = \"CONDITION\";\n    BreakpointWidgetContext[BreakpointWidgetContext[\"HIT_COUNT\"] = 1] = \"HIT_COUNT\";\n    BreakpointWidgetContext[BreakpointWidgetContext[\"LOG_MESSAGE\"] = 2] = \"LOG_MESSAGE\";\n})(BreakpointWidgetContext = exports.BreakpointWidgetContext || (exports.BreakpointWidgetContext = {}));\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/debug.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/debug.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\nimport { URI as uri } from 'vs/base/common/uri';\nimport severity from 'vs/base/common/severity';\nimport { Event } from 'vs/base/common/event';\nimport { IJSONSchemaSnippet } from 'vs/base/common/jsonSchema';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IEditorContribution } from 'vs/editor/common/editorCommon';\nimport { ITextModel as EditorIModel } from 'vs/editor/common/model';\nimport { IEditor } from 'vs/workbench/common/editor';\nimport { Position } from 'vs/editor/common/core/position';\nimport { CompletionItem } from 'vs/editor/common/modes';\nimport { Source } from 'vs/workbench/contrib/debug/common/debugSource';\nimport { Range, IRange } from 'vs/editor/common/core/range';\nimport { RawContextKey } from 'vs/platform/contextkey/common/contextkey';\nimport { IWorkspaceFolder } from 'vs/platform/workspace/common/workspace';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { IViewContainersRegistry, ViewContainer, Extensions as ViewContainerExtensions } from 'vs/workbench/common/views';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport { TaskIdentifier } from 'vs/workbench/contrib/tasks/common/tasks';\nimport { TelemetryService } from 'vs/platform/telemetry/common/telemetryService';\nimport { IOutputService } from 'vs/workbench/contrib/output/common/output';\n\nexport const VIEWLET_ID = 'workbench.view.debug';\nexport const VIEW_CONTAINER: ViewContainer = Registry.as<IViewContainersRegistry>(ViewContainerExtensions.ViewContainersRegistry).registerViewContainer(VIEWLET_ID);\n\nexport const VARIABLES_VIEW_ID = 'workbench.debug.variablesView';\nexport const WATCH_VIEW_ID = 'workbench.debug.watchExpressionsView';\nexport const CALLSTACK_VIEW_ID = 'workbench.debug.callStackView';\nexport const LOADED_SCRIPTS_VIEW_ID = 'workbench.debug.loadedScriptsView';\nexport const BREAKPOINTS_VIEW_ID = 'workbench.debug.breakPointsView';\nexport const REPL_ID = 'workbench.panel.repl';\nexport const DEBUG_SERVICE_ID = 'debugService';\nexport const CONTEXT_DEBUG_TYPE = new RawContextKey<string>('debugType', undefined);\nexport const CONTEXT_DEBUG_CONFIGURATION_TYPE = new RawContextKey<string>('debugConfigurationType', undefined);\nexport const CONTEXT_DEBUG_STATE = new RawContextKey<string>('debugState', 'inactive');\nexport const CONTEXT_IN_DEBUG_MODE = new RawContextKey<boolean>('inDebugMode', false);\nexport const CONTEXT_IN_DEBUG_REPL = new RawContextKey<boolean>('inDebugRepl', false);\nexport const CONTEXT_BREAKPOINT_WIDGET_VISIBLE = new RawContextKey<boolean>('breakpointWidgetVisible', false);\nexport const CONTEXT_IN_BREAKPOINT_WIDGET = new RawContextKey<boolean>('inBreakpointWidget', false);\nexport const CONTEXT_BREAKPOINTS_FOCUSED = new RawContextKey<boolean>('breakpointsFocused', true);\nexport const CONTEXT_WATCH_EXPRESSIONS_FOCUSED = new RawContextKey<boolean>('watchExpressionsFocused', true);\nexport const CONTEXT_VARIABLES_FOCUSED = new RawContextKey<boolean>('variablesFocused', true);\nexport const CONTEXT_EXPRESSION_SELECTED = new RawContextKey<boolean>('expressionSelected', false);\nexport const CONTEXT_BREAKPOINT_SELECTED = new RawContextKey<boolean>('breakpointSelected', false);\nexport const CONTEXT_CALLSTACK_ITEM_TYPE = new RawContextKey<string>('callStackItemType', undefined);\nexport const CONTEXT_LOADED_SCRIPTS_SUPPORTED = new RawContextKey<boolean>('loadedScriptsSupported', false);\nexport const CONTEXT_LOADED_SCRIPTS_ITEM_TYPE = new RawContextKey<string>('loadedScriptsItemType', undefined);\nexport const CONTEXT_FOCUSED_SESSION_IS_ATTACH = new RawContextKey<boolean>('focusedSessionIsAttach', false);\nexport const CONTEXT_STEP_BACK_SUPPORTED = new RawContextKey<boolean>('stepBackSupported', false);\nexport const CONTEXT_RESTART_FRAME_SUPPORTED = new RawContextKey<boolean>('restartFrameSupported', false);\n\nexport const EDITOR_CONTRIBUTION_ID = 'editor.contrib.debug';\nexport const DEBUG_SCHEME = 'debug';\nexport const INTERNAL_CONSOLE_OPTIONS_SCHEMA = {\n\tenum: ['neverOpen', 'openOnSessionStart', 'openOnFirstSessionStart'],\n\tdefault: 'openOnFirstSessionStart',\n\tdescription: nls.localize('internalConsoleOptions', \"Controls when the internal debug console should open.\")\n};\n\n// raw\n\nexport interface IRawModelUpdate {\n\tsessionId: string;\n\tthreads: DebugProtocol.Thread[];\n\tstoppedDetails?: IRawStoppedDetails;\n}\n\nexport interface IRawStoppedDetails {\n\treason?: string;\n\tdescription?: string;\n\tthreadId?: number;\n\ttext?: string;\n\ttotalFrames?: number;\n\tallThreadsStopped?: boolean;\n\tframesErrorMessage?: string;\n}\n\n// model\n\nexport interface ITreeElement {\n\tgetId(): string;\n}\n\nexport interface IReplElement extends ITreeElement {\n\ttoString(): string;\n\treadonly sourceData?: IReplElementSource;\n}\n\nexport interface IReplElementSource {\n\treadonly source: Source;\n\treadonly lineNumber: number;\n\treadonly column: number;\n}\n\nexport interface IExpressionContainer extends ITreeElement {\n\treadonly hasChildren: boolean;\n\tgetChildren(): Promise<IExpression[]>;\n}\n\nexport interface IExpression extends IReplElement, IExpressionContainer {\n\tname: string;\n\treadonly value: string;\n\tvalueChanged?: boolean;\n\treadonly type?: string;\n}\n\nexport interface IDebugger {\n\tcreateDebugAdapter(session: IDebugSession, outputService: IOutputService): Promise<IDebugAdapter>;\n\trunInTerminal(args: DebugProtocol.RunInTerminalRequestArguments): Promise<number | undefined>;\n\tgetCustomTelemetryService(): Promise<TelemetryService | undefined>;\n}\n\nexport const enum State {\n\tInactive,\n\tInitializing,\n\tStopped,\n\tRunning\n}\n\nexport function getStateLabel(state: State): string {\n\tswitch (state) {\n\t\tcase State.Initializing: return 'initializing';\n\t\tcase State.Stopped: return 'stopped';\n\t\tcase State.Running: return 'running';\n\t\tdefault: return 'inactive';\n\t}\n}\n\nexport class AdapterEndEvent {\n\terror?: Error;\n\tsessionLengthInSeconds: number;\n\temittedStopped: boolean;\n}\n\nexport interface LoadedSourceEvent {\n\treason: 'new' | 'changed' | 'removed';\n\tsource: Source;\n}\n\nexport interface IDebugSession extends ITreeElement {\n\n\treadonly configuration: IConfig;\n\treadonly unresolvedConfiguration: IConfig | undefined;\n\treadonly state: State;\n\treadonly root: IWorkspaceFolder;\n\treadonly parentSession: IDebugSession | undefined;\n\n\tgetLabel(): string;\n\n\tgetSourceForUri(modelUri: uri): Source | undefined;\n\tgetSource(raw?: DebugProtocol.Source): Source;\n\n\tsetConfiguration(configuration: { resolved: IConfig, unresolved: IConfig | undefined }): void;\n\trawUpdate(data: IRawModelUpdate): void;\n\n\tgetThread(threadId: number): IThread | undefined;\n\tgetAllThreads(): IThread[];\n\tclearThreads(removeThreads: boolean, reference?: number): void;\n\n\tgetReplElements(): IReplElement[];\n\n\tremoveReplExpressions(): void;\n\taddReplExpression(stackFrame: IStackFrame | undefined, name: string): Promise<void>;\n\tappendToRepl(data: string | IExpression, severity: severity, source?: IReplElementSource): void;\n\tlogToRepl(sev: severity, args: any[], frame?: { uri: uri, line: number, column: number }): void;\n\n\t// session events\n\treadonly onDidEndAdapter: Event<AdapterEndEvent>;\n\treadonly onDidChangeState: Event<void>;\n\treadonly onDidChangeReplElements: Event<void>;\n\n\t// DA capabilities\n\treadonly capabilities: DebugProtocol.Capabilities;\n\n\t// DAP events\n\n\treadonly onDidLoadedSource: Event<LoadedSourceEvent>;\n\treadonly onDidCustomEvent: Event<DebugProtocol.Event>;\n\n\t// Disconnects and clears state. Session can be initialized again for a new connection.\n\tshutdown(): void;\n\n\t// DAP request\n\n\tinitialize(dbgr: IDebugger): Promise<void>;\n\tlaunchOrAttach(config: IConfig): Promise<void>;\n\trestart(): Promise<void>;\n\tterminate(restart?: boolean /* false */): Promise<void>;\n\tdisconnect(restart?: boolean /* false */): Promise<void>;\n\n\tsendBreakpoints(modelUri: uri, bpts: IBreakpoint[], sourceModified: boolean): Promise<void>;\n\tsendFunctionBreakpoints(fbps: IFunctionBreakpoint[]): Promise<void>;\n\tsendExceptionBreakpoints(exbpts: IExceptionBreakpoint[]): Promise<void>;\n\n\tstackTrace(threadId: number, startFrame: number, levels: number): Promise<DebugProtocol.StackTraceResponse>;\n\texceptionInfo(threadId: number): Promise<IExceptionInfo | undefined>;\n\tscopes(frameId: number): Promise<DebugProtocol.ScopesResponse>;\n\tvariables(variablesReference: number, filter: 'indexed' | 'named' | undefined, start: number | undefined, count: number | undefined): Promise<DebugProtocol.VariablesResponse>;\n\tevaluate(expression: string, frameId?: number, context?: string): Promise<DebugProtocol.EvaluateResponse>;\n\tcustomRequest(request: string, args: any): Promise<DebugProtocol.Response>;\n\n\trestartFrame(frameId: number, threadId: number): Promise<void>;\n\tnext(threadId: number): Promise<void>;\n\tstepIn(threadId: number): Promise<void>;\n\tstepOut(threadId: number): Promise<void>;\n\tstepBack(threadId: number): Promise<void>;\n\tcontinue(threadId: number): Promise<void>;\n\treverseContinue(threadId: number): Promise<void>;\n\tpause(threadId: number): Promise<void>;\n\tterminateThreads(threadIds: number[]): Promise<void>;\n\n\tcompletions(frameId: number | undefined, text: string, position: Position, overwriteBefore: number): Promise<CompletionItem[]>;\n\tsetVariable(variablesReference: number | undefined, name: string, value: string): Promise<DebugProtocol.SetVariableResponse>;\n\tloadSource(resource: uri): Promise<DebugProtocol.SourceResponse>;\n\tgetLoadedSources(): Promise<Source[]>;\n}\n\nexport interface IThread extends ITreeElement {\n\n\t/**\n\t * Process the thread belongs to\n\t */\n\treadonly session: IDebugSession;\n\n\t/**\n\t * Id of the thread generated by the debug adapter backend.\n\t */\n\treadonly threadId: number;\n\n\t/**\n\t * Name of the thread.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Information about the current thread stop event. Undefined if thread is not stopped.\n\t */\n\treadonly stoppedDetails: IRawStoppedDetails | undefined;\n\n\t/**\n\t * Information about the exception if an 'exception' stopped event raised and DA supports the 'exceptionInfo' request, otherwise undefined.\n\t */\n\treadonly exceptionInfo: Promise<IExceptionInfo | undefined>;\n\n\treadonly stateLabel: string;\n\n\t/**\n\t * Gets the callstack if it has already been received from the debug\n\t * adapter.\n\t */\n\tgetCallStack(): ReadonlyArray<IStackFrame>;\n\n\t/**\n\t * Invalidates the callstack cache\n\t */\n\tclearCallStack(): void;\n\n\t/**\n\t * Indicates whether this thread is stopped. The callstack for stopped\n\t * threads can be retrieved from the debug adapter.\n\t */\n\treadonly stopped: boolean;\n\n\tnext(): Promise<any>;\n\tstepIn(): Promise<any>;\n\tstepOut(): Promise<any>;\n\tstepBack(): Promise<any>;\n\tcontinue(): Promise<any>;\n\tpause(): Promise<any>;\n\tterminate(): Promise<any>;\n\treverseContinue(): Promise<any>;\n}\n\nexport interface IScope extends IExpressionContainer {\n\treadonly name: string;\n\treadonly expensive: boolean;\n\treadonly range?: IRange;\n}\n\nexport interface IStackFrame extends ITreeElement {\n\treadonly thread: IThread;\n\treadonly name: string;\n\treadonly presentationHint: string | undefined;\n\treadonly frameId: number;\n\treadonly range: IRange;\n\treadonly source: Source;\n\tgetScopes(): Promise<IScope[]>;\n\tgetMostSpecificScopes(range: IRange): Promise<ReadonlyArray<IScope>>;\n\tgetSpecificSourceName(): string;\n\trestart(): Promise<any>;\n\ttoString(): string;\n\topenInEditor(editorService: IEditorService, preserveFocus?: boolean, sideBySide?: boolean): Promise<any>;\n}\n\nexport interface IEnablement extends ITreeElement {\n\treadonly enabled: boolean;\n}\n\nexport interface IBreakpointData {\n\treadonly id?: string;\n\treadonly lineNumber: number;\n\treadonly column?: number;\n\treadonly enabled?: boolean;\n\treadonly condition?: string;\n\treadonly logMessage?: string;\n\treadonly hitCondition?: string;\n}\n\nexport interface IBreakpointUpdateData {\n\treadonly condition?: string;\n\treadonly hitCondition?: string;\n\treadonly logMessage?: string;\n\treadonly lineNumber?: number;\n\treadonly column?: number;\n}\n\nexport interface IBaseBreakpoint extends IEnablement {\n\treadonly condition?: string;\n\treadonly hitCondition?: string;\n\treadonly logMessage?: string;\n\treadonly verified: boolean;\n\treadonly idFromAdapter: number | undefined;\n}\n\nexport interface IBreakpoint extends IBaseBreakpoint {\n\treadonly uri: uri;\n\treadonly lineNumber: number;\n\treadonly endLineNumber?: number;\n\treadonly column?: number;\n\treadonly endColumn?: number;\n\treadonly message?: string;\n\treadonly adapterData: any;\n}\n\nexport interface IFunctionBreakpoint extends IBaseBreakpoint {\n\treadonly name: string;\n}\n\nexport interface IExceptionBreakpoint extends IEnablement {\n\treadonly filter: string;\n\treadonly label: string;\n}\n\nexport interface IExceptionInfo {\n\treadonly id?: string;\n\treadonly description?: string;\n\treadonly breakMode: string | null;\n\treadonly details?: DebugProtocol.ExceptionDetails;\n}\n\n// model interfaces\n\nexport interface IViewModel extends ITreeElement {\n\t/**\n\t * Returns the focused debug session or undefined if no session is stopped.\n\t */\n\treadonly focusedSession: IDebugSession | undefined;\n\n\t/**\n\t * Returns the focused thread or undefined if no thread is stopped.\n\t */\n\treadonly focusedThread: IThread | undefined;\n\n\t/**\n\t * Returns the focused stack frame or undefined if there are no stack frames.\n\t */\n\treadonly focusedStackFrame: IStackFrame | undefined;\n\n\tgetSelectedExpression(): IExpression | undefined;\n\tgetSelectedFunctionBreakpoint(): IFunctionBreakpoint | undefined;\n\tsetSelectedExpression(expression: IExpression | undefined): void;\n\tsetSelectedFunctionBreakpoint(functionBreakpoint: IFunctionBreakpoint | undefined): void;\n\n\tisMultiSessionView(): boolean;\n\n\tonDidFocusSession: Event<IDebugSession | undefined>;\n\tonDidFocusStackFrame: Event<{ stackFrame: IStackFrame | undefined, explicit: boolean }>;\n\tonDidSelectExpression: Event<IExpression | undefined>;\n}\n\nexport interface IEvaluate {\n\tevaluate(session: IDebugSession, stackFrame: IStackFrame, context: string): Promise<void>;\n}\n\nexport interface IDebugModel extends ITreeElement {\n\tgetSession(sessionId: string | undefined, includeInactive?: boolean): IDebugSession | undefined;\n\tgetSessions(includeInactive?: boolean): IDebugSession[];\n\tgetBreakpoints(filter?: { uri?: uri, lineNumber?: number, column?: number, enabledOnly?: boolean }): ReadonlyArray<IBreakpoint>;\n\tareBreakpointsActivated(): boolean;\n\tgetFunctionBreakpoints(): ReadonlyArray<IFunctionBreakpoint>;\n\tgetExceptionBreakpoints(): ReadonlyArray<IExceptionBreakpoint>;\n\tgetWatchExpressions(): ReadonlyArray<IExpression & IEvaluate>;\n\n\tonDidChangeBreakpoints: Event<IBreakpointsChangeEvent | undefined>;\n\tonDidChangeCallStack: Event<void>;\n\tonDidChangeWatchExpressions: Event<IExpression | undefined>;\n}\n\n/**\n * An event describing a change to the set of [breakpoints](#debug.Breakpoint).\n */\nexport interface IBreakpointsChangeEvent {\n\tadded?: Array<IBreakpoint | IFunctionBreakpoint>;\n\tremoved?: Array<IBreakpoint | IFunctionBreakpoint>;\n\tchanged?: Array<IBreakpoint | IFunctionBreakpoint>;\n\tsessionOnly?: boolean;\n}\n\n// Debug configuration interfaces\n\nexport interface IDebugConfiguration {\n\tallowBreakpointsEverywhere: boolean;\n\topenDebug: 'neverOpen' | 'openOnSessionStart' | 'openOnFirstSessionStart' | 'openOnDebugBreak';\n\topenExplorerOnEnd: boolean;\n\tinlineValues: boolean;\n\ttoolBarLocation: 'floating' | 'docked' | 'hidden';\n\tshowInStatusBar: 'never' | 'always' | 'onFirstSessionStart';\n\tinternalConsoleOptions: 'neverOpen' | 'openOnSessionStart' | 'openOnFirstSessionStart';\n\textensionHostDebugAdapter: boolean;\n\tenableAllHovers: boolean;\n\tconsole: {\n\t\tfontSize: number;\n\t\tfontFamily: string;\n\t\tlineHeight: number;\n\t};\n}\n\nexport interface IGlobalConfig {\n\tversion: string;\n\tcompounds: ICompound[];\n\tconfigurations: IConfig[];\n}\n\nexport interface IEnvConfig {\n\tinternalConsoleOptions?: 'neverOpen' | 'openOnSessionStart' | 'openOnFirstSessionStart';\n\tpreLaunchTask?: string | TaskIdentifier;\n\tpostDebugTask?: string | TaskIdentifier;\n\tdebugServer?: number;\n\tnoDebug?: boolean;\n}\n\nexport interface IConfig extends IEnvConfig {\n\n\t// fundamental attributes\n\ttype: string;\n\trequest: string;\n\tname: string;\n\n\t// platform specifics\n\twindows?: IEnvConfig;\n\tosx?: IEnvConfig;\n\tlinux?: IEnvConfig;\n\n\t// internals\n\t__sessionId?: string;\n\t__restart?: any;\n\t__autoAttach?: boolean;\n\tport?: number; // TODO\n}\n\nexport interface ICompound {\n\tname: string;\n\tconfigurations: (string | { name: string, folder: string })[];\n}\n\nexport interface IDebugAdapter extends IDisposable {\n\treadonly onError: Event<Error>;\n\treadonly onExit: Event<number | null>;\n\tonRequest(callback: (request: DebugProtocol.Request) => void): void;\n\tonEvent(callback: (event: DebugProtocol.Event) => void): void;\n\tstartSession(): Promise<void>;\n\tsendMessage(message: DebugProtocol.ProtocolMessage): void;\n\tsendResponse(response: DebugProtocol.Response): void;\n\tsendRequest(command: string, args: any, clb: (result: DebugProtocol.Response) => void, timemout?: number): void;\n\tstopSession(): Promise<void>;\n}\n\nexport interface IDebugAdapterFactory extends ITerminalLauncher {\n\tcreateDebugAdapter(session: IDebugSession): IDebugAdapter;\n\tsubstituteVariables(folder: IWorkspaceFolder | undefined, config: IConfig): Promise<IConfig>;\n}\n\nexport interface IDebugAdapterExecutableOptions {\n\tcwd?: string;\n\tenv?: { [key: string]: string };\n}\n\nexport interface IDebugAdapterExecutable {\n\treadonly type: 'executable';\n\treadonly command: string;\n\treadonly args: string[];\n\treadonly options?: IDebugAdapterExecutableOptions;\n}\n\nexport interface IDebugAdapterServer {\n\treadonly type: 'server';\n\treadonly port: number;\n\treadonly host?: string;\n}\n\nexport interface IDebugAdapterImplementation {\n\treadonly type: 'implementation';\n\treadonly implementation: any;\n}\n\nexport type IAdapterDescriptor = IDebugAdapterExecutable | IDebugAdapterServer | IDebugAdapterImplementation;\n\nexport interface IPlatformSpecificAdapterContribution {\n\tprogram?: string;\n\targs?: string[];\n\truntime?: string;\n\truntimeArgs?: string[];\n}\n\nexport interface IDebuggerContribution extends IPlatformSpecificAdapterContribution {\n\ttype: string;\n\tlabel?: string;\n\t// debug adapter executable\n\tadapterExecutableCommand?: string;\n\twin?: IPlatformSpecificAdapterContribution;\n\twinx86?: IPlatformSpecificAdapterContribution;\n\twindows?: IPlatformSpecificAdapterContribution;\n\tosx?: IPlatformSpecificAdapterContribution;\n\tlinux?: IPlatformSpecificAdapterContribution;\n\n\t// internal\n\taiKey?: string;\n\n\t// supported languages\n\tlanguages?: string[];\n\tenableBreakpointsFor?: { languageIds: string[] };\n\n\t// debug configuration support\n\tconfigurationAttributes?: any;\n\tinitialConfigurations?: any[];\n\tconfigurationSnippets?: IJSONSchemaSnippet[];\n\tvariables?: { [key: string]: string };\n}\n\nexport interface IDebugConfigurationProvider {\n\treadonly type: string;\n\tresolveDebugConfiguration?(folderUri: uri | undefined, debugConfiguration: IConfig): Promise<IConfig | null | undefined>;\n\tprovideDebugConfigurations?(folderUri: uri | undefined): Promise<IConfig[]>;\n\tdebugAdapterExecutable?(folderUri: uri | undefined): Promise<IAdapterDescriptor>;\t\t// TODO@AW legacy\n}\n\nexport interface IDebugAdapterDescriptorFactory {\n\treadonly type: string;\n\tcreateDebugAdapterDescriptor(session: IDebugSession): Promise<IAdapterDescriptor>;\n}\n\nexport interface IDebugAdapterTrackerFactory {\n\treadonly type: string;\n}\n\nexport interface ITerminalLauncher {\n\trunInTerminal(args: DebugProtocol.RunInTerminalRequestArguments, config: ITerminalSettings): Promise<number | undefined>;\n}\n\nexport interface ITerminalSettings {\n\texternal: {\n\t\twindowsExec: string,\n\t\tosxExec: string,\n\t\tlinuxExec: string\n\t};\n\tintegrated: {\n\t\tshell: {\n\t\t\tosx: string,\n\t\t\twindows: string,\n\t\t\tlinux: string\n\t\t}\n\t};\n}\n\nexport interface IConfigurationManager {\n\t/**\n\t * Returns true if breakpoints can be set for a given editor model. Depends on mode.\n\t */\n\tcanSetBreakpointsIn(model: EditorIModel): boolean;\n\n\t/**\n\t * Returns an object containing the selected launch configuration and the selected configuration name. Both these fields can be null (no folder workspace).\n\t */\n\treadonly selectedConfiguration: {\n\t\tlaunch: ILaunch | undefined;\n\t\tname: string | undefined;\n\t};\n\n\tselectConfiguration(launch: ILaunch | undefined, name?: string, debugStarted?: boolean): void;\n\n\tgetLaunches(): ReadonlyArray<ILaunch>;\n\n\tgetLaunch(workspaceUri: uri | undefined): ILaunch | undefined;\n\n\t/**\n\t * Allows to register on change of selected debug configuration.\n\t */\n\tonDidSelectConfiguration: Event<void>;\n\n\tactivateDebuggers(activationEvent: string, debugType?: string): Promise<void>;\n\n\tneedsToRunInExtHost(debugType: string): boolean;\n\thasDebugConfigurationProvider(debugType: string): boolean;\n\n\tregisterDebugConfigurationProvider(debugConfigurationProvider: IDebugConfigurationProvider): IDisposable;\n\tunregisterDebugConfigurationProvider(debugConfigurationProvider: IDebugConfigurationProvider): void;\n\n\tregisterDebugAdapterDescriptorFactory(debugAdapterDescriptorFactory: IDebugAdapterDescriptorFactory): IDisposable;\n\tunregisterDebugAdapterDescriptorFactory(debugAdapterDescriptorFactory: IDebugAdapterDescriptorFactory): void;\n\n\tregisterDebugAdapterTrackerFactory(debugAdapterTrackerFactory: IDebugAdapterTrackerFactory): IDisposable;\n\tunregisterDebugAdapterTrackerFactory(debugAdapterTrackerFactory: IDebugAdapterTrackerFactory): void;\n\n\tresolveConfigurationByProviders(folderUri: uri | undefined, type: string | undefined, debugConfiguration: any): Promise<any>;\n\tgetDebugAdapterDescriptor(session: IDebugSession): Promise<IAdapterDescriptor | undefined>;\n\n\tregisterDebugAdapterFactory(debugTypes: string[], debugAdapterFactory: IDebugAdapterFactory): IDisposable;\n\tcreateDebugAdapter(session: IDebugSession): IDebugAdapter | undefined;\n\n\tsubstituteVariables(debugType: string, folder: IWorkspaceFolder | undefined, config: IConfig): Promise<IConfig>;\n\trunInTerminal(debugType: string, args: DebugProtocol.RunInTerminalRequestArguments, config: ITerminalSettings): Promise<number | undefined>;\n}\n\nexport interface ILaunch {\n\n\t/**\n\t * Resource pointing to the launch.json this object is wrapping.\n\t */\n\treadonly uri: uri;\n\n\t/**\n\t * Name of the launch.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Workspace of the launch. Can be undefined.\n\t */\n\treadonly workspace: IWorkspaceFolder | undefined;\n\n\t/**\n\t * Should this launch be shown in the debug dropdown.\n\t */\n\treadonly hidden: boolean;\n\n\t/**\n\t * Returns a configuration with the specified name.\n\t * Returns undefined if there is no configuration with the specified name.\n\t */\n\tgetConfiguration(name: string): IConfig | undefined;\n\n\t/**\n\t * Returns a compound with the specified name.\n\t * Returns undefined if there is no compound with the specified name.\n\t */\n\tgetCompound(name: string): ICompound | undefined;\n\n\t/**\n\t * Returns the names of all configurations and compounds.\n\t * Ignores configurations which are invalid.\n\t */\n\tgetConfigurationNames(includeCompounds?: boolean): string[];\n\n\t/**\n\t * Opens the launch.json file. Creates if it does not exist.\n\t */\n\topenConfigFile(sideBySide: boolean, preserveFocus: boolean, type?: string): Promise<{ editor: IEditor | null, created: boolean }>;\n}\n\n// Debug service interfaces\n\nexport const IDebugService = createDecorator<IDebugService>(DEBUG_SERVICE_ID);\n\nexport interface IDebugService {\n\t_serviceBrand: any;\n\n\t/**\n\t * Gets the current debug state.\n\t */\n\treadonly state: State;\n\n\t/**\n\t * Allows to register on debug state changes.\n\t */\n\tonDidChangeState: Event<State>;\n\n\t/**\n\t * Allows to register on new session events.\n\t */\n\tonDidNewSession: Event<IDebugSession>;\n\n\t/**\n\t * Allows to register on sessions about to be created (not yet fully initialised)\n\t */\n\tonWillNewSession: Event<IDebugSession>;\n\n\t/**\n\t * Allows to register on end session events.\n\t */\n\tonDidEndSession: Event<IDebugSession>;\n\n\t/**\n\t * Gets the current configuration manager.\n\t */\n\tgetConfigurationManager(): IConfigurationManager;\n\n\t/**\n\t * Sets the focused stack frame and evaluates all expressions against the newly focused stack frame,\n\t */\n\tfocusStackFrame(focusedStackFrame: IStackFrame | undefined, thread?: IThread, session?: IDebugSession, explicit?: boolean): void;\n\n\t/**\n\t * Adds new breakpoints to the model for the file specified with the uri. Notifies debug adapter of breakpoint changes.\n\t */\n\taddBreakpoints(uri: uri, rawBreakpoints: IBreakpointData[], context: string): Promise<IBreakpoint[]>;\n\n\t/**\n\t * Updates the breakpoints.\n\t */\n\tupdateBreakpoints(uri: uri, data: { [id: string]: IBreakpointUpdateData }, sendOnResourceSaved: boolean): void;\n\n\t/**\n\t * Enables or disables all breakpoints. If breakpoint is passed only enables or disables the passed breakpoint.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tenableOrDisableBreakpoints(enable: boolean, breakpoint?: IEnablement): Promise<void>;\n\n\t/**\n\t * Sets the global activated property for all breakpoints.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tsetBreakpointsActivated(activated: boolean): Promise<void>;\n\n\t/**\n\t * Removes all breakpoints. If id is passed only removes the breakpoint associated with that id.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveBreakpoints(id?: string): Promise<any>;\n\n\t/**\n\t * Adds a new function breakpoint for the given name.\n\t */\n\taddFunctionBreakpoint(name?: string, id?: string): void;\n\n\t/**\n\t * Renames an already existing function breakpoint.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\trenameFunctionBreakpoint(id: string, newFunctionName: string): Promise<void>;\n\n\t/**\n\t * Removes all function breakpoints. If id is passed only removes the function breakpoint with the passed id.\n\t * Notifies debug adapter of breakpoint changes.\n\t */\n\tremoveFunctionBreakpoints(id?: string): Promise<void>;\n\n\t/**\n\t * Sends all breakpoints to the passed session.\n\t * If session is not passed, sends all breakpoints to each session.\n\t */\n\tsendAllBreakpoints(session?: IDebugSession): Promise<any>;\n\n\t/**\n\t * Adds a new watch expression and evaluates it against the debug adapter.\n\t */\n\taddWatchExpression(name?: string): void;\n\n\t/**\n\t * Renames a watch expression and evaluates it against the debug adapter.\n\t */\n\trenameWatchExpression(id: string, newName: string): void;\n\n\t/**\n\t * Moves a watch expression to a new possition. Used for reordering watch expressions.\n\t */\n\tmoveWatchExpression(id: string, position: number): void;\n\n\t/**\n\t * Removes all watch expressions. If id is passed only removes the watch expression with the passed id.\n\t */\n\tremoveWatchExpressions(id?: string): void;\n\n\t/**\n\t * Starts debugging. If the configOrName is not passed uses the selected configuration in the debug dropdown.\n\t * Also saves all files, manages if compounds are present in the configuration\n\t * and resolveds configurations via DebugConfigurationProviders.\n\t *\n\t * Returns true if the start debugging was successfull. For compound launches, all configurations have to start successfuly for it to return success.\n\t * On errors the startDebugging will throw an error, however some error and cancelations are handled and in that case will simply return false.\n\t */\n\tstartDebugging(launch: ILaunch | undefined, configOrName?: IConfig | string, noDebug?: boolean, parentSession?: IDebugSession): Promise<boolean>;\n\n\t/**\n\t * Restarts a session or creates a new one if there is no active session.\n\t */\n\trestartSession(session: IDebugSession, restartData?: any): Promise<any>;\n\n\t/**\n\t * Stops the session. If the session does not exist then stops all sessions.\n\t */\n\tstopSession(session: IDebugSession | undefined): Promise<any>;\n\n\t/**\n\t * Makes unavailable all sources with the passed uri. Source will appear as grayed out in callstack view.\n\t */\n\tsourceIsNotAvailable(uri: uri): void;\n\n\t/**\n\t * Gets the current debug model.\n\t */\n\tgetModel(): IDebugModel;\n\n\t/**\n\t * Gets the current view model.\n\t */\n\tgetViewModel(): IViewModel;\n}\n\n// Editor interfaces\nexport const enum BreakpointWidgetContext {\n\tCONDITION = 0,\n\tHIT_COUNT = 1,\n\tLOG_MESSAGE = 2\n}\n\nexport interface IDebugEditorContribution extends IEditorContribution {\n\tshowHover(range: Range, focus: boolean): Promise<void>;\n\tshowBreakpointWidget(lineNumber: number, column: number | undefined, context?: BreakpointWidgetContext): void;\n\tcloseBreakpointWidget(): void;\n\taddLaunchConfiguration(): Promise<any>;\n}\n"]}]}