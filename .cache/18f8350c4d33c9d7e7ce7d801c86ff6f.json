{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/errors.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/errors.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // Avoid circular dependency on EventEmitter by implementing a subset of the interface.\n    class ErrorHandler {\n        constructor() {\n            this.listeners = [];\n            this.unexpectedErrorHandler = function (e) {\n                setTimeout(() => {\n                    if (e.stack) {\n                        throw new Error(e.message + '\\n\\n' + e.stack);\n                    }\n                    throw e;\n                }, 0);\n            };\n        }\n        addListener(listener) {\n            this.listeners.push(listener);\n            return () => {\n                this._removeListener(listener);\n            };\n        }\n        emit(e) {\n            this.listeners.forEach((listener) => {\n                listener(e);\n            });\n        }\n        _removeListener(listener) {\n            this.listeners.splice(this.listeners.indexOf(listener), 1);\n        }\n        setUnexpectedErrorHandler(newUnexpectedErrorHandler) {\n            this.unexpectedErrorHandler = newUnexpectedErrorHandler;\n        }\n        getUnexpectedErrorHandler() {\n            return this.unexpectedErrorHandler;\n        }\n        onUnexpectedError(e) {\n            this.unexpectedErrorHandler(e);\n            this.emit(e);\n        }\n        // For external errors, we don't want the listeners to be called\n        onUnexpectedExternalError(e) {\n            this.unexpectedErrorHandler(e);\n        }\n    }\n    exports.ErrorHandler = ErrorHandler;\n    exports.errorHandler = new ErrorHandler();\n    function setUnexpectedErrorHandler(newUnexpectedErrorHandler) {\n        exports.errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);\n    }\n    exports.setUnexpectedErrorHandler = setUnexpectedErrorHandler;\n    function onUnexpectedError(e) {\n        // ignore errors from cancelled promises\n        if (!isPromiseCanceledError(e)) {\n            exports.errorHandler.onUnexpectedError(e);\n        }\n        return undefined;\n    }\n    exports.onUnexpectedError = onUnexpectedError;\n    function onUnexpectedExternalError(e) {\n        // ignore errors from cancelled promises\n        if (!isPromiseCanceledError(e)) {\n            exports.errorHandler.onUnexpectedExternalError(e);\n        }\n        return undefined;\n    }\n    exports.onUnexpectedExternalError = onUnexpectedExternalError;\n    function transformErrorForSerialization(error) {\n        if (error instanceof Error) {\n            let { name, message } = error;\n            const stack = error.stacktrace || error.stack;\n            return {\n                $isError: true,\n                name,\n                message,\n                stack\n            };\n        }\n        // return as is\n        return error;\n    }\n    exports.transformErrorForSerialization = transformErrorForSerialization;\n    const canceledName = 'Canceled';\n    /**\n     * Checks if the given error is a promise in canceled state\n     */\n    function isPromiseCanceledError(error) {\n        return error instanceof Error && error.name === canceledName && error.message === canceledName;\n    }\n    exports.isPromiseCanceledError = isPromiseCanceledError;\n    /**\n     * Returns an error that signals cancellation.\n     */\n    function canceled() {\n        const error = new Error(canceledName);\n        error.name = error.message;\n        return error;\n    }\n    exports.canceled = canceled;\n    function illegalArgument(name) {\n        if (name) {\n            return new Error(`Illegal argument: ${name}`);\n        }\n        else {\n            return new Error('Illegal argument');\n        }\n    }\n    exports.illegalArgument = illegalArgument;\n    function illegalState(name) {\n        if (name) {\n            return new Error(`Illegal state: ${name}`);\n        }\n        else {\n            return new Error('Illegal state');\n        }\n    }\n    exports.illegalState = illegalState;\n    function readonly(name) {\n        return name\n            ? new Error(`readonly property '${name} cannot be changed'`)\n            : new Error('readonly property cannot be changed');\n    }\n    exports.readonly = readonly;\n    function disposed(what) {\n        const result = new Error(`${what} has been disposed`);\n        result.name = 'DISPOSED';\n        return result;\n    }\n    exports.disposed = disposed;\n    function getErrorMessage(err) {\n        if (!err) {\n            return 'Error';\n        }\n        if (err.message) {\n            return err.message;\n        }\n        if (err.stack) {\n            return err.stack.split('\\n')[0];\n        }\n        return String(err);\n    }\n    exports.getErrorMessage = getErrorMessage;\n});\n",null]}