{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/browser/debugEditorModelManager.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/browser/debugEditorModelManager.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar lifecycle = require(\"vs/base/common/lifecycle\");\nvar uint_1 = require(\"vs/editor/common/core/uint\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar model_1 = require(\"vs/editor/common/model\");\nvar debug_1 = require(\"vs/workbench/contrib/debug/common/debug\");\nvar modelService_1 = require(\"vs/editor/common/services/modelService\");\nvar htmlContent_1 = require(\"vs/base/common/htmlContent\");\nvar breakpointsView_1 = require(\"vs/workbench/contrib/debug/browser/breakpointsView\");\nvar themeService_1 = require(\"vs/platform/theme/common/themeService\");\nvar colorRegistry_1 = require(\"vs/platform/theme/common/colorRegistry\");\nvar nls_1 = require(\"vs/nls\");\nvar DebugEditorModelManager = /** @class */ (function () {\n    function DebugEditorModelManager(modelService, debugService) {\n        this.modelService = modelService;\n        this.debugService = debugService;\n        this.modelDataMap = new Map();\n        this.toDispose = [];\n        this.registerListeners();\n    }\n    DebugEditorModelManager.prototype.dispose = function () {\n        this.modelDataMap.forEach(function (modelData) {\n            lifecycle.dispose(modelData.toDispose);\n            modelData.model.deltaDecorations(modelData.breakpointDecorations.map(function (bpd) { return bpd.decorationId; }), []);\n            modelData.model.deltaDecorations(modelData.currentStackDecorations, []);\n        });\n        this.toDispose = lifecycle.dispose(this.toDispose);\n        this.modelDataMap.clear();\n    };\n    DebugEditorModelManager.prototype.registerListeners = function () {\n        var _this = this;\n        this.toDispose.push(this.modelService.onModelAdded(this.onModelAdded, this));\n        this.modelService.getModels().forEach(function (model) { return _this.onModelAdded(model); });\n        this.toDispose.push(this.modelService.onModelRemoved(this.onModelRemoved, this));\n        this.toDispose.push(this.debugService.getModel().onDidChangeBreakpoints(function () { return _this.onBreakpointsChange(); }));\n        this.toDispose.push(this.debugService.getViewModel().onDidFocusStackFrame(function () { return _this.onFocusStackFrame(); }));\n        this.toDispose.push(this.debugService.onDidChangeState(function (state) {\n            if (state === debug_1.State.Inactive) {\n                _this.modelDataMap.forEach(function (modelData) {\n                    modelData.topStackFrameRange = undefined;\n                });\n            }\n        }));\n    };\n    DebugEditorModelManager.prototype.onModelAdded = function (model) {\n        var _this = this;\n        var modelUriStr = model.uri.toString();\n        var breakpoints = this.debugService.getModel().getBreakpoints({ uri: model.uri });\n        var currentStackDecorations = model.deltaDecorations([], this.createCallStackDecorations(modelUriStr));\n        var desiredDecorations = this.createBreakpointDecorations(model, breakpoints);\n        var breakpointDecorationIds = model.deltaDecorations([], desiredDecorations);\n        var toDispose = [model.onDidChangeDecorations(function (e) { return _this.onModelDecorationsChanged(modelUriStr); })];\n        this.modelDataMap.set(modelUriStr, {\n            model: model,\n            toDispose: toDispose,\n            breakpointDecorations: breakpointDecorationIds.map(function (decorationId, index) { return ({ decorationId: decorationId, modelId: breakpoints[index].getId(), range: desiredDecorations[index].range }); }),\n            currentStackDecorations: currentStackDecorations,\n            topStackFrameRange: undefined\n        });\n    };\n    DebugEditorModelManager.prototype.onModelRemoved = function (model) {\n        var modelUriStr = model.uri.toString();\n        var data = this.modelDataMap.get(modelUriStr);\n        if (data) {\n            lifecycle.dispose(data.toDispose);\n            this.modelDataMap.delete(modelUriStr);\n        }\n    };\n    // call stack management. Represent data coming from the debug service.\n    DebugEditorModelManager.prototype.onFocusStackFrame = function () {\n        var _this = this;\n        this.modelDataMap.forEach(function (modelData, uri) {\n            modelData.currentStackDecorations = modelData.model.deltaDecorations(modelData.currentStackDecorations, _this.createCallStackDecorations(uri));\n        });\n    };\n    DebugEditorModelManager.prototype.createCallStackDecorations = function (modelUriStr) {\n        var result = [];\n        var stackFrame = this.debugService.getViewModel().focusedStackFrame;\n        if (!stackFrame || stackFrame.source.uri.toString() !== modelUriStr) {\n            return result;\n        }\n        // only show decorations for the currently focused thread.\n        var columnUntilEOLRange = new range_1.Range(stackFrame.range.startLineNumber, stackFrame.range.startColumn, stackFrame.range.startLineNumber, uint_1.Constants.MAX_SAFE_SMALL_INTEGER);\n        var range = new range_1.Range(stackFrame.range.startLineNumber, stackFrame.range.startColumn, stackFrame.range.startLineNumber, stackFrame.range.startColumn + 1);\n        // compute how to decorate the editor. Different decorations are used if this is a top stack frame, focused stack frame,\n        // an exception or a stack frame that did not change the line number (we only decorate the columns, not the whole line).\n        var callStack = stackFrame.thread.getCallStack();\n        if (callStack && callStack.length && stackFrame === callStack[0]) {\n            result.push({\n                options: DebugEditorModelManager.TOP_STACK_FRAME_MARGIN,\n                range: range\n            });\n            result.push({\n                options: DebugEditorModelManager.TOP_STACK_FRAME_DECORATION,\n                range: columnUntilEOLRange\n            });\n            var modelData = this.modelDataMap.get(modelUriStr);\n            if (modelData) {\n                if (modelData.topStackFrameRange && modelData.topStackFrameRange.startLineNumber === stackFrame.range.startLineNumber && modelData.topStackFrameRange.startColumn !== stackFrame.range.startColumn) {\n                    result.push({\n                        options: DebugEditorModelManager.TOP_STACK_FRAME_INLINE_DECORATION,\n                        range: columnUntilEOLRange\n                    });\n                }\n                modelData.topStackFrameRange = columnUntilEOLRange;\n            }\n        }\n        else {\n            result.push({\n                options: DebugEditorModelManager.FOCUSED_STACK_FRAME_MARGIN,\n                range: range\n            });\n            result.push({\n                options: DebugEditorModelManager.FOCUSED_STACK_FRAME_DECORATION,\n                range: columnUntilEOLRange\n            });\n        }\n        return result;\n    };\n    // breakpoints management. Represent data coming from the debug service and also send data back.\n    DebugEditorModelManager.prototype.onModelDecorationsChanged = function (modelUrlStr) {\n        var modelData = this.modelDataMap.get(modelUrlStr);\n        if (!modelData || modelData.breakpointDecorations.length === 0 || this.ignoreDecorationsChangedEvent) {\n            // I have no decorations\n            return;\n        }\n        var somethingChanged = false;\n        modelData.breakpointDecorations.forEach(function (breakpointDecoration) {\n            if (somethingChanged) {\n                return;\n            }\n            var newBreakpointRange = modelData.model.getDecorationRange(breakpointDecoration.decorationId);\n            if (newBreakpointRange && (!breakpointDecoration.range.equalsRange(newBreakpointRange))) {\n                somethingChanged = true;\n            }\n        });\n        if (!somethingChanged) {\n            // nothing to do, my decorations did not change.\n            return;\n        }\n        var data = Object.create(null);\n        var breakpoints = this.debugService.getModel().getBreakpoints();\n        var modelUri = modelData.model.uri;\n        var _loop_1 = function (i, len) {\n            var breakpointDecoration = modelData.breakpointDecorations[i];\n            var decorationRange = modelData.model.getDecorationRange(breakpointDecoration.decorationId);\n            // check if the line got deleted.\n            if (decorationRange) {\n                var breakpoint = breakpoints.filter(function (bp) { return bp.getId() === breakpointDecoration.modelId; }).pop();\n                // since we know it is collapsed, it cannot grow to multiple lines\n                if (breakpoint) {\n                    data[breakpoint.getId()] = {\n                        lineNumber: decorationRange.startLineNumber,\n                        column: breakpoint.column ? decorationRange.startColumn : undefined,\n                    };\n                }\n            }\n        };\n        for (var i = 0, len = modelData.breakpointDecorations.length; i < len; i++) {\n            _loop_1(i, len);\n        }\n        this.debugService.updateBreakpoints(modelUri, data, true);\n    };\n    DebugEditorModelManager.prototype.onBreakpointsChange = function () {\n        var _this = this;\n        var breakpointsMap = new Map();\n        this.debugService.getModel().getBreakpoints().forEach(function (bp) {\n            var uriStr = bp.uri.toString();\n            var breakpoints = breakpointsMap.get(uriStr);\n            if (breakpoints) {\n                breakpoints.push(bp);\n            }\n            else {\n                breakpointsMap.set(uriStr, [bp]);\n            }\n        });\n        breakpointsMap.forEach(function (bps, uri) {\n            var data = _this.modelDataMap.get(uri);\n            if (data) {\n                _this.updateBreakpoints(data, breakpointsMap.get(uri));\n            }\n        });\n        this.modelDataMap.forEach(function (modelData, uri) {\n            if (!breakpointsMap.has(uri)) {\n                _this.updateBreakpoints(modelData, []);\n            }\n        });\n    };\n    DebugEditorModelManager.prototype.updateBreakpoints = function (modelData, newBreakpoints) {\n        var desiredDecorations = this.createBreakpointDecorations(modelData.model, newBreakpoints);\n        try {\n            this.ignoreDecorationsChangedEvent = true;\n            var breakpointDecorationIds = modelData.model.deltaDecorations(modelData.breakpointDecorations.map(function (bpd) { return bpd.decorationId; }), desiredDecorations);\n            modelData.breakpointDecorations = breakpointDecorationIds.map(function (decorationId, index) { return ({\n                decorationId: decorationId,\n                modelId: newBreakpoints[index].getId(),\n                range: desiredDecorations[index].range\n            }); });\n        }\n        finally {\n            this.ignoreDecorationsChangedEvent = false;\n        }\n    };\n    DebugEditorModelManager.prototype.createBreakpointDecorations = function (model, breakpoints) {\n        var _this = this;\n        var result = [];\n        breakpoints.forEach(function (breakpoint) {\n            if (breakpoint.lineNumber <= model.getLineCount()) {\n                var column = model.getLineFirstNonWhitespaceColumn(breakpoint.lineNumber);\n                var range = model.validateRange(breakpoint.column ? new range_1.Range(breakpoint.lineNumber, breakpoint.column, breakpoint.lineNumber, breakpoint.column + 1)\n                    : new range_1.Range(breakpoint.lineNumber, column, breakpoint.lineNumber, column + 1) // Decoration has to have a width #20688\n                );\n                result.push({\n                    options: _this.getBreakpointDecorationOptions(breakpoint),\n                    range: range\n                });\n            }\n        });\n        return result;\n    };\n    DebugEditorModelManager.prototype.getBreakpointDecorationOptions = function (breakpoint) {\n        var _a = breakpointsView_1.getBreakpointMessageAndClassName(this.debugService, breakpoint), className = _a.className, message = _a.message;\n        var glyphMarginHoverMessage;\n        if (message) {\n            if (breakpoint.condition || breakpoint.hitCondition) {\n                var modelData = this.modelDataMap.get(breakpoint.uri.toString());\n                var modeId = modelData ? modelData.model.getLanguageIdentifier().language : '';\n                glyphMarginHoverMessage = new htmlContent_1.MarkdownString().appendCodeblock(modeId, message);\n            }\n            else {\n                glyphMarginHoverMessage = new htmlContent_1.MarkdownString().appendText(message);\n            }\n        }\n        return {\n            glyphMarginClassName: className,\n            glyphMarginHoverMessage: glyphMarginHoverMessage,\n            stickiness: DebugEditorModelManager.STICKINESS,\n            beforeContentClassName: breakpoint.column ? \"debug-breakpoint-column \" + className + \"-column\" : undefined\n        };\n    };\n    DebugEditorModelManager.ID = 'breakpointManager';\n    DebugEditorModelManager.STICKINESS = model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges;\n    // editor decorations\n    // we need a separate decoration for glyph margin, since we do not want it on each line of a multi line statement.\n    DebugEditorModelManager.TOP_STACK_FRAME_MARGIN = {\n        glyphMarginClassName: 'debug-top-stack-frame',\n        stickiness: DebugEditorModelManager.STICKINESS\n    };\n    DebugEditorModelManager.FOCUSED_STACK_FRAME_MARGIN = {\n        glyphMarginClassName: 'debug-focused-stack-frame',\n        stickiness: DebugEditorModelManager.STICKINESS\n    };\n    DebugEditorModelManager.TOP_STACK_FRAME_DECORATION = {\n        isWholeLine: true,\n        inlineClassName: 'debug-remove-token-colors',\n        className: 'debug-top-stack-frame-line',\n        stickiness: DebugEditorModelManager.STICKINESS\n    };\n    DebugEditorModelManager.TOP_STACK_FRAME_INLINE_DECORATION = {\n        beforeContentClassName: 'debug-top-stack-frame-column'\n    };\n    DebugEditorModelManager.FOCUSED_STACK_FRAME_DECORATION = {\n        isWholeLine: true,\n        inlineClassName: 'debug-remove-token-colors',\n        className: 'debug-focused-stack-frame-line',\n        stickiness: DebugEditorModelManager.STICKINESS\n    };\n    DebugEditorModelManager = tslib_1.__decorate([\n        tslib_1.__param(0, modelService_1.IModelService),\n        tslib_1.__param(1, debug_1.IDebugService)\n    ], DebugEditorModelManager);\n    return DebugEditorModelManager;\n}());\nexports.DebugEditorModelManager = DebugEditorModelManager;\nthemeService_1.registerThemingParticipant(function (theme, collector) {\n    var topStackFrame = theme.getColor(topStackFrameColor);\n    if (topStackFrame) {\n        collector.addRule(\".monaco-editor .view-overlays .debug-top-stack-frame-line { background: \" + topStackFrame + \"; }\");\n        collector.addRule(\".monaco-editor .view-overlays .debug-top-stack-frame-line { background: \" + topStackFrame + \"; }\");\n    }\n    var focusedStackFrame = theme.getColor(focusedStackFrameColor);\n    if (focusedStackFrame) {\n        collector.addRule(\".monaco-editor .view-overlays .debug-focused-stack-frame-line { background: \" + focusedStackFrame + \"; }\");\n    }\n});\nvar topStackFrameColor = colorRegistry_1.registerColor('editor.stackFrameHighlightBackground', { dark: '#ffff0033', light: '#ffff6673', hc: '#fff600' }, nls_1.localize('topStackFrameLineHighlight', 'Background color for the highlight of line at the top stack frame position.'));\nvar focusedStackFrameColor = colorRegistry_1.registerColor('editor.focusedStackFrameHighlightBackground', { dark: '#7abd7a4d', light: '#cee7ce73', hc: '#cee7ce' }, nls_1.localize('focusedStackFrameLineHighlight', 'Background color for the highlight of line at focused stack frame position.'));\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/browser/debugEditorModelManager.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/browser/debugEditorModelManager.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as lifecycle from 'vs/base/common/lifecycle';\nimport { Constants } from 'vs/editor/common/core/uint';\nimport { Range } from 'vs/editor/common/core/range';\nimport { ITextModel, TrackedRangeStickiness, IModelDeltaDecoration, IModelDecorationOptions } from 'vs/editor/common/model';\nimport { IWorkbenchContribution } from 'vs/workbench/common/contributions';\nimport { IDebugService, IBreakpoint, State, IBreakpointUpdateData } from 'vs/workbench/contrib/debug/common/debug';\nimport { IModelService } from 'vs/editor/common/services/modelService';\nimport { MarkdownString } from 'vs/base/common/htmlContent';\nimport { getBreakpointMessageAndClassName } from 'vs/workbench/contrib/debug/browser/breakpointsView';\nimport { registerThemingParticipant } from 'vs/platform/theme/common/themeService';\nimport { registerColor } from 'vs/platform/theme/common/colorRegistry';\nimport { localize } from 'vs/nls';\n\ninterface IBreakpointDecoration {\n\tdecorationId: string;\n\tmodelId: string;\n\trange: Range;\n}\n\ninterface IDebugEditorModelData {\n\tmodel: ITextModel;\n\ttoDispose: lifecycle.IDisposable[];\n\tbreakpointDecorations: IBreakpointDecoration[];\n\tcurrentStackDecorations: string[];\n\ttopStackFrameRange: Range | undefined;\n}\n\nexport class DebugEditorModelManager implements IWorkbenchContribution {\n\tstatic readonly ID = 'breakpointManager';\n\tstatic readonly STICKINESS = TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges;\n\tprivate modelDataMap: Map<string, IDebugEditorModelData>;\n\tprivate toDispose: lifecycle.IDisposable[];\n\tprivate ignoreDecorationsChangedEvent: boolean;\n\n\tconstructor(\n\t\t@IModelService private readonly modelService: IModelService,\n\t\t@IDebugService private readonly debugService: IDebugService,\n\t) {\n\t\tthis.modelDataMap = new Map<string, IDebugEditorModelData>();\n\t\tthis.toDispose = [];\n\t\tthis.registerListeners();\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.modelDataMap.forEach(modelData => {\n\t\t\tlifecycle.dispose(modelData.toDispose);\n\t\t\tmodelData.model.deltaDecorations(modelData.breakpointDecorations.map(bpd => bpd.decorationId), []);\n\t\t\tmodelData.model.deltaDecorations(modelData.currentStackDecorations, []);\n\t\t});\n\t\tthis.toDispose = lifecycle.dispose(this.toDispose);\n\n\t\tthis.modelDataMap.clear();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis.toDispose.push(this.modelService.onModelAdded(this.onModelAdded, this));\n\t\tthis.modelService.getModels().forEach(model => this.onModelAdded(model));\n\t\tthis.toDispose.push(this.modelService.onModelRemoved(this.onModelRemoved, this));\n\n\t\tthis.toDispose.push(this.debugService.getModel().onDidChangeBreakpoints(() => this.onBreakpointsChange()));\n\t\tthis.toDispose.push(this.debugService.getViewModel().onDidFocusStackFrame(() => this.onFocusStackFrame()));\n\t\tthis.toDispose.push(this.debugService.onDidChangeState(state => {\n\t\t\tif (state === State.Inactive) {\n\t\t\t\tthis.modelDataMap.forEach(modelData => {\n\t\t\t\t\tmodelData.topStackFrameRange = undefined;\n\t\t\t\t});\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate onModelAdded(model: ITextModel): void {\n\t\tconst modelUriStr = model.uri.toString();\n\t\tconst breakpoints = this.debugService.getModel().getBreakpoints({ uri: model.uri });\n\n\t\tconst currentStackDecorations = model.deltaDecorations([], this.createCallStackDecorations(modelUriStr));\n\t\tconst desiredDecorations = this.createBreakpointDecorations(model, breakpoints);\n\t\tconst breakpointDecorationIds = model.deltaDecorations([], desiredDecorations);\n\t\tconst toDispose: lifecycle.IDisposable[] = [model.onDidChangeDecorations((e) => this.onModelDecorationsChanged(modelUriStr))];\n\n\t\tthis.modelDataMap.set(modelUriStr, {\n\t\t\tmodel: model,\n\t\t\ttoDispose: toDispose,\n\t\t\tbreakpointDecorations: breakpointDecorationIds.map((decorationId, index) => ({ decorationId, modelId: breakpoints[index].getId(), range: desiredDecorations[index].range })),\n\t\t\tcurrentStackDecorations: currentStackDecorations,\n\t\t\ttopStackFrameRange: undefined\n\t\t});\n\t}\n\n\tprivate onModelRemoved(model: ITextModel): void {\n\t\tconst modelUriStr = model.uri.toString();\n\t\tconst data = this.modelDataMap.get(modelUriStr);\n\t\tif (data) {\n\t\t\tlifecycle.dispose(data.toDispose);\n\t\t\tthis.modelDataMap.delete(modelUriStr);\n\t\t}\n\t}\n\n\t// call stack management. Represent data coming from the debug service.\n\n\tprivate onFocusStackFrame(): void {\n\t\tthis.modelDataMap.forEach((modelData, uri) => {\n\t\t\tmodelData.currentStackDecorations = modelData.model.deltaDecorations(modelData.currentStackDecorations, this.createCallStackDecorations(uri));\n\t\t});\n\t}\n\n\tprivate createCallStackDecorations(modelUriStr: string): IModelDeltaDecoration[] {\n\t\tconst result: IModelDeltaDecoration[] = [];\n\t\tconst stackFrame = this.debugService.getViewModel().focusedStackFrame;\n\t\tif (!stackFrame || stackFrame.source.uri.toString() !== modelUriStr) {\n\t\t\treturn result;\n\t\t}\n\n\t\t// only show decorations for the currently focused thread.\n\t\tconst columnUntilEOLRange = new Range(stackFrame.range.startLineNumber, stackFrame.range.startColumn, stackFrame.range.startLineNumber, Constants.MAX_SAFE_SMALL_INTEGER);\n\t\tconst range = new Range(stackFrame.range.startLineNumber, stackFrame.range.startColumn, stackFrame.range.startLineNumber, stackFrame.range.startColumn + 1);\n\n\t\t// compute how to decorate the editor. Different decorations are used if this is a top stack frame, focused stack frame,\n\t\t// an exception or a stack frame that did not change the line number (we only decorate the columns, not the whole line).\n\t\tconst callStack = stackFrame.thread.getCallStack();\n\t\tif (callStack && callStack.length && stackFrame === callStack[0]) {\n\t\t\tresult.push({\n\t\t\t\toptions: DebugEditorModelManager.TOP_STACK_FRAME_MARGIN,\n\t\t\t\trange\n\t\t\t});\n\n\t\t\tresult.push({\n\t\t\t\toptions: DebugEditorModelManager.TOP_STACK_FRAME_DECORATION,\n\t\t\t\trange: columnUntilEOLRange\n\t\t\t});\n\n\t\t\tconst modelData = this.modelDataMap.get(modelUriStr);\n\t\t\tif (modelData) {\n\t\t\t\tif (modelData.topStackFrameRange && modelData.topStackFrameRange.startLineNumber === stackFrame.range.startLineNumber && modelData.topStackFrameRange.startColumn !== stackFrame.range.startColumn) {\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\toptions: DebugEditorModelManager.TOP_STACK_FRAME_INLINE_DECORATION,\n\t\t\t\t\t\trange: columnUntilEOLRange\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tmodelData.topStackFrameRange = columnUntilEOLRange;\n\t\t\t}\n\t\t} else {\n\t\t\tresult.push({\n\t\t\t\toptions: DebugEditorModelManager.FOCUSED_STACK_FRAME_MARGIN,\n\t\t\t\trange\n\t\t\t});\n\n\t\t\tresult.push({\n\t\t\t\toptions: DebugEditorModelManager.FOCUSED_STACK_FRAME_DECORATION,\n\t\t\t\trange: columnUntilEOLRange\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// breakpoints management. Represent data coming from the debug service and also send data back.\n\tprivate onModelDecorationsChanged(modelUrlStr: string): void {\n\t\tconst modelData = this.modelDataMap.get(modelUrlStr);\n\t\tif (!modelData || modelData.breakpointDecorations.length === 0 || this.ignoreDecorationsChangedEvent) {\n\t\t\t// I have no decorations\n\t\t\treturn;\n\t\t}\n\t\tlet somethingChanged = false;\n\t\tmodelData.breakpointDecorations.forEach(breakpointDecoration => {\n\t\t\tif (somethingChanged) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst newBreakpointRange = modelData.model.getDecorationRange(breakpointDecoration.decorationId);\n\t\t\tif (newBreakpointRange && (!breakpointDecoration.range.equalsRange(newBreakpointRange))) {\n\t\t\t\tsomethingChanged = true;\n\t\t\t}\n\t\t});\n\t\tif (!somethingChanged) {\n\t\t\t// nothing to do, my decorations did not change.\n\t\t\treturn;\n\t\t}\n\n\t\tconst data: { [id: string]: IBreakpointUpdateData } = Object.create(null);\n\t\tconst breakpoints = this.debugService.getModel().getBreakpoints();\n\t\tconst modelUri = modelData.model.uri;\n\t\tfor (let i = 0, len = modelData.breakpointDecorations.length; i < len; i++) {\n\t\t\tconst breakpointDecoration = modelData.breakpointDecorations[i];\n\t\t\tconst decorationRange = modelData.model.getDecorationRange(breakpointDecoration.decorationId);\n\t\t\t// check if the line got deleted.\n\t\t\tif (decorationRange) {\n\t\t\t\tconst breakpoint = breakpoints.filter(bp => bp.getId() === breakpointDecoration.modelId).pop();\n\t\t\t\t// since we know it is collapsed, it cannot grow to multiple lines\n\t\t\t\tif (breakpoint) {\n\t\t\t\t\tdata[breakpoint.getId()] = {\n\t\t\t\t\t\tlineNumber: decorationRange.startLineNumber,\n\t\t\t\t\t\tcolumn: breakpoint.column ? decorationRange.startColumn : undefined,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.debugService.updateBreakpoints(modelUri, data, true);\n\t}\n\n\tprivate onBreakpointsChange(): void {\n\t\tconst breakpointsMap = new Map<string, IBreakpoint[]>();\n\t\tthis.debugService.getModel().getBreakpoints().forEach(bp => {\n\t\t\tconst uriStr = bp.uri.toString();\n\t\t\tconst breakpoints = breakpointsMap.get(uriStr);\n\t\t\tif (breakpoints) {\n\t\t\t\tbreakpoints.push(bp);\n\t\t\t} else {\n\t\t\t\tbreakpointsMap.set(uriStr, [bp]);\n\t\t\t}\n\t\t});\n\n\t\tbreakpointsMap.forEach((bps, uri) => {\n\t\t\tconst data = this.modelDataMap.get(uri);\n\t\t\tif (data) {\n\t\t\t\tthis.updateBreakpoints(data, breakpointsMap.get(uri)!);\n\t\t\t}\n\t\t});\n\t\tthis.modelDataMap.forEach((modelData, uri) => {\n\t\t\tif (!breakpointsMap.has(uri)) {\n\t\t\t\tthis.updateBreakpoints(modelData, []);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate updateBreakpoints(modelData: IDebugEditorModelData, newBreakpoints: IBreakpoint[]): void {\n\t\tconst desiredDecorations = this.createBreakpointDecorations(modelData.model, newBreakpoints);\n\t\ttry {\n\t\t\tthis.ignoreDecorationsChangedEvent = true;\n\t\t\tconst breakpointDecorationIds = modelData.model.deltaDecorations(modelData.breakpointDecorations.map(bpd => bpd.decorationId), desiredDecorations);\n\t\t\tmodelData.breakpointDecorations = breakpointDecorationIds.map((decorationId, index) => ({\n\t\t\t\tdecorationId,\n\t\t\t\tmodelId: newBreakpoints[index].getId(),\n\t\t\t\trange: desiredDecorations[index].range\n\t\t\t}));\n\t\t} finally {\n\t\t\tthis.ignoreDecorationsChangedEvent = false;\n\t\t}\n\t}\n\n\tprivate createBreakpointDecorations(model: ITextModel, breakpoints: ReadonlyArray<IBreakpoint>): { range: Range; options: IModelDecorationOptions; }[] {\n\t\tconst result: { range: Range; options: IModelDecorationOptions; }[] = [];\n\t\tbreakpoints.forEach((breakpoint) => {\n\t\t\tif (breakpoint.lineNumber <= model.getLineCount()) {\n\t\t\t\tconst column = model.getLineFirstNonWhitespaceColumn(breakpoint.lineNumber);\n\t\t\t\tconst range = model.validateRange(\n\t\t\t\t\tbreakpoint.column ? new Range(breakpoint.lineNumber, breakpoint.column, breakpoint.lineNumber, breakpoint.column + 1)\n\t\t\t\t\t\t: new Range(breakpoint.lineNumber, column, breakpoint.lineNumber, column + 1) // Decoration has to have a width #20688\n\t\t\t\t);\n\n\t\t\t\tresult.push({\n\t\t\t\t\toptions: this.getBreakpointDecorationOptions(breakpoint),\n\t\t\t\t\trange\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tprivate getBreakpointDecorationOptions(breakpoint: IBreakpoint): IModelDecorationOptions {\n\t\tconst { className, message } = getBreakpointMessageAndClassName(this.debugService, breakpoint);\n\t\tlet glyphMarginHoverMessage: MarkdownString | undefined;\n\n\t\tif (message) {\n\t\t\tif (breakpoint.condition || breakpoint.hitCondition) {\n\t\t\t\tconst modelData = this.modelDataMap.get(breakpoint.uri.toString());\n\t\t\t\tconst modeId = modelData ? modelData.model.getLanguageIdentifier().language : '';\n\t\t\t\tglyphMarginHoverMessage = new MarkdownString().appendCodeblock(modeId, message);\n\t\t\t} else {\n\t\t\t\tglyphMarginHoverMessage = new MarkdownString().appendText(message);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tglyphMarginClassName: className,\n\t\t\tglyphMarginHoverMessage,\n\t\t\tstickiness: DebugEditorModelManager.STICKINESS,\n\t\t\tbeforeContentClassName: breakpoint.column ? `debug-breakpoint-column ${className}-column` : undefined\n\t\t};\n\t}\n\n\t// editor decorations\n\n\t// we need a separate decoration for glyph margin, since we do not want it on each line of a multi line statement.\n\tprivate static TOP_STACK_FRAME_MARGIN: IModelDecorationOptions = {\n\t\tglyphMarginClassName: 'debug-top-stack-frame',\n\t\tstickiness: DebugEditorModelManager.STICKINESS\n\t};\n\n\tprivate static FOCUSED_STACK_FRAME_MARGIN: IModelDecorationOptions = {\n\t\tglyphMarginClassName: 'debug-focused-stack-frame',\n\t\tstickiness: DebugEditorModelManager.STICKINESS\n\t};\n\n\tprivate static TOP_STACK_FRAME_DECORATION: IModelDecorationOptions = {\n\t\tisWholeLine: true,\n\t\tinlineClassName: 'debug-remove-token-colors',\n\t\tclassName: 'debug-top-stack-frame-line',\n\t\tstickiness: DebugEditorModelManager.STICKINESS\n\t};\n\n\tprivate static TOP_STACK_FRAME_INLINE_DECORATION: IModelDecorationOptions = {\n\t\tbeforeContentClassName: 'debug-top-stack-frame-column'\n\t};\n\n\tprivate static FOCUSED_STACK_FRAME_DECORATION: IModelDecorationOptions = {\n\t\tisWholeLine: true,\n\t\tinlineClassName: 'debug-remove-token-colors',\n\t\tclassName: 'debug-focused-stack-frame-line',\n\t\tstickiness: DebugEditorModelManager.STICKINESS\n\t};\n}\n\nregisterThemingParticipant((theme, collector) => {\n\tconst topStackFrame = theme.getColor(topStackFrameColor);\n\tif (topStackFrame) {\n\t\tcollector.addRule(`.monaco-editor .view-overlays .debug-top-stack-frame-line { background: ${topStackFrame}; }`);\n\t\tcollector.addRule(`.monaco-editor .view-overlays .debug-top-stack-frame-line { background: ${topStackFrame}; }`);\n\t}\n\n\tconst focusedStackFrame = theme.getColor(focusedStackFrameColor);\n\tif (focusedStackFrame) {\n\t\tcollector.addRule(`.monaco-editor .view-overlays .debug-focused-stack-frame-line { background: ${focusedStackFrame}; }`);\n\t}\n});\n\nconst topStackFrameColor = registerColor('editor.stackFrameHighlightBackground', { dark: '#ffff0033', light: '#ffff6673', hc: '#fff600' }, localize('topStackFrameLineHighlight', 'Background color for the highlight of line at the top stack frame position.'));\nconst focusedStackFrameColor = registerColor('editor.focusedStackFrameHighlightBackground', { dark: '#7abd7a4d', light: '#cee7ce73', hc: '#cee7ce' }, localize('focusedStackFrameLineHighlight', 'Background color for the highlight of line at focused stack frame position.'));\n"]}]}