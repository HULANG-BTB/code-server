{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/textfile/common/textFileEditorModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/textfile/common/textFileEditorModel.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar path_1 = require(\"vs/base/common/path\");\nvar nls = require(\"vs/nls\");\nvar event_1 = require(\"vs/base/common/event\");\nvar mime_1 = require(\"vs/base/common/mime\");\nvar errorMessage_1 = require(\"vs/base/common/errorMessage\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar types_1 = require(\"vs/base/common/types\");\nvar workspace_1 = require(\"vs/platform/workspace/common/workspace\");\nvar environment_1 = require(\"vs/platform/environment/common/environment\");\nvar textfiles_1 = require(\"vs/workbench/services/textfile/common/textfiles\");\nvar editor_1 = require(\"vs/workbench/common/editor\");\nvar textEditorModel_1 = require(\"vs/workbench/common/editor/textEditorModel\");\nvar backup_1 = require(\"vs/workbench/services/backup/common/backup\");\nvar files_1 = require(\"vs/platform/files/common/files\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar modeService_1 = require(\"vs/editor/common/services/modeService\");\nvar modelService_1 = require(\"vs/editor/common/services/modelService\");\nvar telemetry_1 = require(\"vs/platform/telemetry/common/telemetry\");\nvar async_1 = require(\"vs/base/common/async\");\nvar hashService_1 = require(\"vs/workbench/services/hash/common/hashService\");\nvar textModel_1 = require(\"vs/editor/common/model/textModel\");\nvar notification_1 = require(\"vs/platform/notification/common/notification\");\nvar platform_1 = require(\"vs/base/common/platform\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar log_1 = require(\"vs/platform/log/common/log\");\nvar resources_1 = require(\"vs/base/common/resources\");\nvar errors_1 = require(\"vs/base/common/errors\");\n/**\n * The text file editor model listens to changes to its underlying code editor model and saves these changes through the file service back to the disk.\n */\nvar TextFileEditorModel = /** @class */ (function (_super) {\n    tslib_1.__extends(TextFileEditorModel, _super);\n    function TextFileEditorModel(resource, preferredEncoding, notificationService, modeService, modelService, fileService, instantiationService, telemetryService, textFileService, backupFileService, environmentService, contextService, hashService, logService) {\n        var _this = _super.call(this, modelService, modeService) || this;\n        _this.notificationService = notificationService;\n        _this.fileService = fileService;\n        _this.instantiationService = instantiationService;\n        _this.telemetryService = telemetryService;\n        _this.textFileService = textFileService;\n        _this.backupFileService = backupFileService;\n        _this.environmentService = environmentService;\n        _this.contextService = contextService;\n        _this.hashService = hashService;\n        _this.logService = logService;\n        _this._onDidContentChange = _this._register(new event_1.Emitter());\n        _this._onDidStateChange = _this._register(new event_1.Emitter());\n        _this.resource = resource;\n        _this.preferredEncoding = preferredEncoding;\n        _this.inOrphanMode = false;\n        _this.dirty = false;\n        _this.versionId = 0;\n        _this.lastSaveAttemptTime = 0;\n        _this.saveSequentializer = new SaveSequentializer();\n        _this.contentChangeEventScheduler = _this._register(new async_1.RunOnceScheduler(function () { return _this._onDidContentChange.fire(textfiles_1.StateChange.CONTENT_CHANGE); }, TextFileEditorModel.DEFAULT_CONTENT_CHANGE_BUFFER_DELAY));\n        _this.orphanedChangeEventScheduler = _this._register(new async_1.RunOnceScheduler(function () { return _this._onDidStateChange.fire(textfiles_1.StateChange.ORPHANED_CHANGE); }, TextFileEditorModel.DEFAULT_ORPHANED_CHANGE_BUFFER_DELAY));\n        _this.updateAutoSaveConfiguration(textFileService.getAutoSaveConfiguration());\n        _this.registerListeners();\n        return _this;\n    }\n    TextFileEditorModel.setSaveErrorHandler = function (handler) { TextFileEditorModel.saveErrorHandler = handler; };\n    TextFileEditorModel.setSaveParticipant = function (handler) { TextFileEditorModel.saveParticipant = handler; };\n    Object.defineProperty(TextFileEditorModel.prototype, \"onDidContentChange\", {\n        get: function () { return this._onDidContentChange.event; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TextFileEditorModel.prototype, \"onDidStateChange\", {\n        get: function () { return this._onDidStateChange.event; },\n        enumerable: true,\n        configurable: true\n    });\n    TextFileEditorModel.prototype.registerListeners = function () {\n        var _this = this;\n        this._register(this.fileService.onFileChanges(function (e) { return _this.onFileChanges(e); }));\n        this._register(this.textFileService.onAutoSaveConfigurationChange(function (config) { return _this.updateAutoSaveConfiguration(config); }));\n        this._register(this.textFileService.onFilesAssociationChange(function (e) { return _this.onFilesAssociationChange(); }));\n        this._register(this.onDidStateChange(function (e) { return _this.onStateChange(e); }));\n    };\n    TextFileEditorModel.prototype.onStateChange = function (e) {\n        if (e === textfiles_1.StateChange.REVERTED) {\n            // Cancel any content change event promises as they are no longer valid.\n            this.contentChangeEventScheduler.cancel();\n            // Refire state change reverted events as content change events\n            this._onDidContentChange.fire(textfiles_1.StateChange.REVERTED);\n        }\n    };\n    TextFileEditorModel.prototype.onFileChanges = function (e) {\n        var _this = this;\n        var fileEventImpactsModel = false;\n        var newInOrphanModeGuess;\n        // If we are currently orphaned, we check if the model file was added back\n        if (this.inOrphanMode) {\n            var modelFileAdded = e.contains(this.resource, files_1.FileChangeType.ADDED);\n            if (modelFileAdded) {\n                newInOrphanModeGuess = false;\n                fileEventImpactsModel = true;\n            }\n        }\n        // Otherwise we check if the model file was deleted\n        else {\n            var modelFileDeleted = e.contains(this.resource, files_1.FileChangeType.DELETED);\n            if (modelFileDeleted) {\n                newInOrphanModeGuess = true;\n                fileEventImpactsModel = true;\n            }\n        }\n        if (fileEventImpactsModel && this.inOrphanMode !== newInOrphanModeGuess) {\n            var checkOrphanedPromise = void 0;\n            if (newInOrphanModeGuess) {\n                // We have received reports of users seeing delete events even though the file still\n                // exists (network shares issue: https://github.com/Microsoft/vscode/issues/13665).\n                // Since we do not want to mark the model as orphaned, we have to check if the\n                // file is really gone and not just a faulty file event.\n                checkOrphanedPromise = async_1.timeout(100).then(function () {\n                    if (_this.disposed) {\n                        return true;\n                    }\n                    return _this.fileService.existsFile(_this.resource).then(function (exists) { return !exists; });\n                });\n            }\n            else {\n                checkOrphanedPromise = Promise.resolve(false);\n            }\n            checkOrphanedPromise.then(function (newInOrphanModeValidated) {\n                if (_this.inOrphanMode !== newInOrphanModeValidated && !_this.disposed) {\n                    _this.setOrphaned(newInOrphanModeValidated);\n                }\n            });\n        }\n    };\n    TextFileEditorModel.prototype.setOrphaned = function (orphaned) {\n        if (this.inOrphanMode !== orphaned) {\n            this.inOrphanMode = orphaned;\n            this.orphanedChangeEventScheduler.schedule();\n        }\n    };\n    TextFileEditorModel.prototype.updateAutoSaveConfiguration = function (config) {\n        var autoSaveAfterMilliesEnabled = (typeof config.autoSaveDelay === 'number') && config.autoSaveDelay > 0;\n        this.autoSaveAfterMilliesEnabled = autoSaveAfterMilliesEnabled;\n        this.autoSaveAfterMillies = autoSaveAfterMilliesEnabled ? config.autoSaveDelay : undefined;\n    };\n    TextFileEditorModel.prototype.onFilesAssociationChange = function () {\n        if (!this.textEditorModel) {\n            return;\n        }\n        var firstLineText = this.getFirstLineText(this.textEditorModel);\n        var languageSelection = this.getOrCreateMode(this.modeService, undefined, firstLineText);\n        this.modelService.setMode(this.textEditorModel, languageSelection);\n    };\n    TextFileEditorModel.prototype.getVersionId = function () {\n        return this.versionId;\n    };\n    TextFileEditorModel.prototype.revert = function (soft) {\n        var _this = this;\n        if (!this.isResolved()) {\n            return Promise.resolve(undefined);\n        }\n        // Cancel any running auto-save\n        this.cancelPendingAutoSave();\n        // Unset flags\n        var undo = this.setDirty(false);\n        var loadPromise;\n        if (soft) {\n            loadPromise = Promise.resolve();\n        }\n        else {\n            loadPromise = this.load({ forceReadFromDisk: true });\n        }\n        return loadPromise.then(function () {\n            // Emit file change event\n            _this._onDidStateChange.fire(textfiles_1.StateChange.REVERTED);\n        }, function (error) {\n            // Set flags back to previous values, we are still dirty if revert failed\n            undo();\n            return Promise.reject(error);\n        });\n    };\n    TextFileEditorModel.prototype.load = function (options) {\n        this.logService.trace('load() - enter', this.resource);\n        // It is very important to not reload the model when the model is dirty.\n        // We also only want to reload the model from the disk if no save is pending\n        // to avoid data loss.\n        if (this.dirty || this.saveSequentializer.hasPendingSave()) {\n            this.logService.trace('load() - exit - without loading because model is dirty or being saved', this.resource);\n            return Promise.resolve(this);\n        }\n        // Only for new models we support to load from backup\n        if (!this.textEditorModel && !this.createTextEditorModelPromise) {\n            return this.loadFromBackup(options);\n        }\n        // Otherwise load from file resource\n        return this.loadFromFile(options);\n    };\n    TextFileEditorModel.prototype.loadFromBackup = function (options) {\n        var _this = this;\n        return this.backupFileService.loadBackupResource(this.resource).then(function (backup) {\n            // Make sure meanwhile someone else did not suceed or start loading\n            if (_this.createTextEditorModelPromise || _this.textEditorModel) {\n                return _this.createTextEditorModelPromise || _this;\n            }\n            // If we have a backup, continue loading with it\n            if (!!backup) {\n                var content = {\n                    resource: _this.resource,\n                    name: resources_1.basename(_this.resource),\n                    mtime: Date.now(),\n                    size: 0,\n                    etag: files_1.etag(Date.now(), 0),\n                    value: textModel_1.createTextBufferFactory(''),\n                    encoding: _this.fileService.encoding.getWriteEncoding(_this.resource, _this.preferredEncoding).encoding,\n                    isReadonly: false\n                };\n                return _this.loadWithContent(content, options, backup);\n            }\n            // Otherwise load from file\n            return _this.loadFromFile(options);\n        });\n    };\n    TextFileEditorModel.prototype.loadFromFile = function (options) {\n        var _this = this;\n        var forceReadFromDisk = options && options.forceReadFromDisk;\n        var allowBinary = this.isResolved() /* always allow if we resolved previously */ || (options && options.allowBinary);\n        // Decide on etag\n        var etag;\n        if (forceReadFromDisk) {\n            etag = undefined; // reset ETag if we enforce to read from disk\n        }\n        else if (this.lastResolvedDiskStat) {\n            etag = this.lastResolvedDiskStat.etag; // otherwise respect etag to support caching\n        }\n        // Ensure to track the versionId before doing a long running operation\n        // to make sure the model was not changed in the meantime which would\n        // indicate that the user or program has made edits. If we would ignore\n        // this, we could potentially loose the changes that were made because\n        // after resolving the content we update the model and reset the dirty\n        // flag.\n        var currentVersionId = this.versionId;\n        // Resolve Content\n        return this.textFileService\n            .resolveTextContent(this.resource, { acceptTextOnly: !allowBinary, etag: etag, encoding: this.preferredEncoding })\n            .then(function (content) {\n            // Clear orphaned state when loading was successful\n            _this.setOrphaned(false);\n            // Guard against the model having changed in the meantime\n            if (currentVersionId === _this.versionId) {\n                return _this.loadWithContent(content, options);\n            }\n            return _this;\n        }, function (error) {\n            var result = error.fileOperationResult;\n            // Apply orphaned state based on error code\n            _this.setOrphaned(result === files_1.FileOperationResult.FILE_NOT_FOUND);\n            // NotModified status is expected and can be handled gracefully\n            if (result === files_1.FileOperationResult.FILE_NOT_MODIFIED_SINCE) {\n                // Guard against the model having changed in the meantime\n                if (currentVersionId === _this.versionId) {\n                    _this.setDirty(false); // Ensure we are not tracking a stale state\n                }\n                return _this;\n            }\n            // Ignore when a model has been resolved once and the file was deleted meanwhile. Since\n            // we already have the model loaded, we can return to this state and update the orphaned\n            // flag to indicate that this model has no version on disk anymore.\n            if (_this.isResolved() && result === files_1.FileOperationResult.FILE_NOT_FOUND) {\n                return _this;\n            }\n            // Otherwise bubble up the error\n            return Promise.reject(error);\n        });\n    };\n    TextFileEditorModel.prototype.loadWithContent = function (content, options, backup) {\n        var _this = this;\n        return this.doLoadWithContent(content, backup).then(function (model) {\n            // Telemetry: We log the fileGet telemetry event after the model has been loaded to ensure a good mimetype\n            var settingsType = _this.getTypeIfSettings();\n            if (settingsType) {\n                /* __GDPR__\n                    \"settingsRead\" : {\n                        \"settingsType\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                    }\n                */\n                _this.telemetryService.publicLog('settingsRead', { settingsType: settingsType }); // Do not log read to user settings.json and .vscode folder as a fileGet event as it ruins our JSON usage data\n            }\n            else {\n                /* __GDPR__\n                    \"fileGet\" : {\n                        \"${include}\": [\n                            \"${FileTelemetryData}\"\n                        ]\n                    }\n                */\n                _this.telemetryService.publicLog('fileGet', _this.getTelemetryData(options && options.reason ? options.reason : textfiles_1.LoadReason.OTHER));\n            }\n            return model;\n        });\n    };\n    TextFileEditorModel.prototype.doLoadWithContent = function (content, backup) {\n        this.logService.trace('load() - resolved content', this.resource);\n        // Update our resolved disk stat model\n        this.updateLastResolvedDiskStat({\n            resource: this.resource,\n            name: content.name,\n            mtime: content.mtime,\n            size: content.size,\n            etag: content.etag,\n            isDirectory: false,\n            isSymbolicLink: false,\n            isReadonly: content.isReadonly\n        });\n        // Keep the original encoding to not loose it when saving\n        var oldEncoding = this.contentEncoding;\n        this.contentEncoding = content.encoding;\n        // Handle events if encoding changed\n        if (this.preferredEncoding) {\n            this.updatePreferredEncoding(this.contentEncoding); // make sure to reflect the real encoding of the file (never out of sync)\n        }\n        else if (oldEncoding !== this.contentEncoding) {\n            this._onDidStateChange.fire(textfiles_1.StateChange.ENCODING);\n        }\n        // Update Existing Model\n        if (this.textEditorModel) {\n            this.doUpdateTextModel(content.value);\n            return Promise.resolve(this);\n        }\n        // Join an existing request to create the editor model to avoid race conditions\n        else if (this.createTextEditorModelPromise) {\n            this.logService.trace('load() - join existing text editor model promise', this.resource);\n            return this.createTextEditorModelPromise;\n        }\n        // Create New Model\n        return this.doCreateTextModel(content.resource, content.value, backup);\n    };\n    TextFileEditorModel.prototype.doUpdateTextModel = function (value) {\n        this.logService.trace('load() - updated text editor model', this.resource);\n        // Ensure we are not tracking a stale state\n        this.setDirty(false);\n        // Update model value in a block that ignores model content change events\n        this.blockModelContentChange = true;\n        try {\n            this.updateTextEditorModel(value);\n        }\n        finally {\n            this.blockModelContentChange = false;\n        }\n        // Ensure we track the latest saved version ID given that the contents changed\n        this.updateSavedVersionId();\n    };\n    TextFileEditorModel.prototype.doCreateTextModel = function (resource, value, backup) {\n        var _this = this;\n        this.logService.trace('load() - created text editor model', this.resource);\n        this.createTextEditorModelPromise = this.doLoadBackup(backup).then(function (backupContent) {\n            _this.createTextEditorModelPromise = null;\n            // Create model\n            var hasBackupContent = !!backupContent;\n            _this.createTextEditorModel(backupContent ? backupContent : value, resource);\n            // We restored a backup so we have to set the model as being dirty\n            // We also want to trigger auto save if it is enabled to simulate the exact same behaviour\n            // you would get if manually making the model dirty (fixes https://github.com/Microsoft/vscode/issues/16977)\n            if (hasBackupContent) {\n                _this.makeDirty();\n                if (_this.autoSaveAfterMilliesEnabled) {\n                    _this.doAutoSave(_this.versionId);\n                }\n            }\n            // Ensure we are not tracking a stale state\n            else {\n                _this.setDirty(false);\n            }\n            // Model Listeners\n            _this.installModelListeners();\n            return _this;\n        }, function (error) {\n            _this.createTextEditorModelPromise = null;\n            return Promise.reject(error);\n        });\n        return this.createTextEditorModelPromise;\n    };\n    TextFileEditorModel.prototype.installModelListeners = function () {\n        // See https://github.com/Microsoft/vscode/issues/30189\n        // This code has been extracted to a different method because it caused a memory leak\n        // where `value` was captured in the content change listener closure scope.\n        var _this = this;\n        // Content Change\n        if (this.textEditorModel) {\n            this._register(this.textEditorModel.onDidChangeContent(function () { return _this.onModelContentChanged(); }));\n        }\n    };\n    TextFileEditorModel.prototype.doLoadBackup = function (backup) {\n        if (!backup) {\n            return Promise.resolve(null);\n        }\n        return this.backupFileService.resolveBackupContent(backup).then(types_1.withUndefinedAsNull, function (error) { return null; } /* ignore errors */);\n    };\n    TextFileEditorModel.prototype.getOrCreateMode = function (modeService, preferredModeIds, firstLineText) {\n        return modeService.createByFilepathOrFirstLine(this.resource.fsPath, firstLineText);\n    };\n    TextFileEditorModel.prototype.onModelContentChanged = function () {\n        this.logService.trace(\"onModelContentChanged() - enter\", this.resource);\n        // In any case increment the version id because it tracks the textual content state of the model at all times\n        this.versionId++;\n        this.logService.trace(\"onModelContentChanged() - new versionId \" + this.versionId, this.resource);\n        // Ignore if blocking model changes\n        if (this.blockModelContentChange) {\n            return;\n        }\n        // The contents changed as a matter of Undo and the version reached matches the saved one\n        // In this case we clear the dirty flag and emit a SAVED event to indicate this state.\n        // Note: we currently only do this check when auto-save is turned off because there you see\n        // a dirty indicator that you want to get rid of when undoing to the saved version.\n        if (!this.autoSaveAfterMilliesEnabled && this.textEditorModel && this.textEditorModel.getAlternativeVersionId() === this.bufferSavedVersionId) {\n            this.logService.trace('onModelContentChanged() - model content changed back to last saved version', this.resource);\n            // Clear flags\n            var wasDirty = this.dirty;\n            this.setDirty(false);\n            // Emit event\n            if (wasDirty) {\n                this._onDidStateChange.fire(textfiles_1.StateChange.REVERTED);\n            }\n            return;\n        }\n        this.logService.trace('onModelContentChanged() - model content changed and marked as dirty', this.resource);\n        // Mark as dirty\n        this.makeDirty();\n        // Start auto save process unless we are in conflict resolution mode and unless it is disabled\n        if (this.autoSaveAfterMilliesEnabled) {\n            if (!this.inConflictMode) {\n                this.doAutoSave(this.versionId);\n            }\n            else {\n                this.logService.trace('makeDirty() - prevented save because we are in conflict resolution mode', this.resource);\n            }\n        }\n        // Handle content change events\n        this.contentChangeEventScheduler.schedule();\n    };\n    TextFileEditorModel.prototype.makeDirty = function () {\n        // Track dirty state and version id\n        var wasDirty = this.dirty;\n        this.setDirty(true);\n        // Emit as Event if we turned dirty\n        if (!wasDirty) {\n            this._onDidStateChange.fire(textfiles_1.StateChange.DIRTY);\n        }\n    };\n    TextFileEditorModel.prototype.doAutoSave = function (versionId) {\n        var _this = this;\n        this.logService.trace(\"doAutoSave() - enter for versionId \" + versionId, this.resource);\n        // Cancel any currently running auto saves to make this the one that succeeds\n        this.cancelPendingAutoSave();\n        // Create new save timer and store it for disposal as needed\n        var handle = setTimeout(function () {\n            // Only trigger save if the version id has not changed meanwhile\n            if (versionId === _this.versionId) {\n                _this.doSave(versionId, { reason: textfiles_1.SaveReason.AUTO }); // Very important here to not return the promise because if the timeout promise is canceled it will bubble up the error otherwise - do not change\n            }\n        }, this.autoSaveAfterMillies);\n        this.autoSaveDisposable = lifecycle_1.toDisposable(function () { return clearTimeout(handle); });\n    };\n    TextFileEditorModel.prototype.cancelPendingAutoSave = function () {\n        if (this.autoSaveDisposable) {\n            this.autoSaveDisposable.dispose();\n            this.autoSaveDisposable = undefined;\n        }\n    };\n    TextFileEditorModel.prototype.save = function (options) {\n        if (options === void 0) { options = Object.create(null); }\n        if (!this.isResolved()) {\n            return Promise.resolve(undefined);\n        }\n        this.logService.trace('save() - enter', this.resource);\n        // Cancel any currently running auto saves to make this the one that succeeds\n        this.cancelPendingAutoSave();\n        return this.doSave(this.versionId, options);\n    };\n    TextFileEditorModel.prototype.doSave = function (versionId, options) {\n        var _this = this;\n        if (types_1.isUndefinedOrNull(options.reason)) {\n            options.reason = textfiles_1.SaveReason.EXPLICIT;\n        }\n        this.logService.trace(\"doSave(\" + versionId + \") - enter with versionId ' + versionId\", this.resource);\n        // Lookup any running pending save for this versionId and return it if found\n        //\n        // Scenario: user invoked the save action multiple times quickly for the same contents\n        //           while the save was not yet finished to disk\n        //\n        if (this.saveSequentializer.hasPendingSave(versionId)) {\n            this.logService.trace(\"doSave(\" + versionId + \") - exit - found a pending save for versionId \" + versionId, this.resource);\n            return this.saveSequentializer.pendingSave || Promise.resolve(undefined);\n        }\n        // Return early if not dirty (unless forced) or version changed meanwhile\n        //\n        // Scenario A: user invoked save action even though the model is not dirty\n        // Scenario B: auto save was triggered for a certain change by the user but meanwhile the user changed\n        //             the contents and the version for which auto save was started is no longer the latest.\n        //             Thus we avoid spawning multiple auto saves and only take the latest.\n        //\n        if ((!options.force && !this.dirty) || versionId !== this.versionId) {\n            this.logService.trace(\"doSave(\" + versionId + \") - exit - because not dirty and/or versionId is different (this.isDirty: \" + this.dirty + \", this.versionId: \" + this.versionId + \")\", this.resource);\n            return Promise.resolve(undefined);\n        }\n        // Return if currently saving by storing this save request as the next save that should happen.\n        // Never ever must 2 saves execute at the same time because this can lead to dirty writes and race conditions.\n        //\n        // Scenario A: auto save was triggered and is currently busy saving to disk. this takes long enough that another auto save\n        //             kicks in.\n        // Scenario B: save is very slow (e.g. network share) and the user manages to change the buffer and trigger another save\n        //             while the first save has not returned yet.\n        //\n        if (this.saveSequentializer.hasPendingSave()) {\n            this.logService.trace(\"doSave(\" + versionId + \") - exit - because busy saving\", this.resource);\n            // Register this as the next upcoming save and return\n            return this.saveSequentializer.setNext(function () { return _this.doSave(_this.versionId /* make sure to use latest version id here */, options); });\n        }\n        // Push all edit operations to the undo stack so that the user has a chance to\n        // Ctrl+Z back to the saved version. We only do this when auto-save is turned off\n        if (!this.autoSaveAfterMilliesEnabled && this.textEditorModel) {\n            this.textEditorModel.pushStackElement();\n        }\n        // A save participant can still change the model now and since we are so close to saving\n        // we do not want to trigger another auto save or similar, so we block this\n        // In addition we update our version right after in case it changed because of a model change\n        // Save participants can also be skipped through API.\n        var saveParticipantPromise = Promise.resolve(versionId);\n        if (TextFileEditorModel.saveParticipant && !options.skipSaveParticipants) {\n            var onCompleteOrError = function () {\n                _this.blockModelContentChange = false;\n                return _this.versionId;\n            };\n            this.blockModelContentChange = true;\n            saveParticipantPromise = TextFileEditorModel.saveParticipant.participate(this, { reason: options.reason }).then(onCompleteOrError, onCompleteOrError);\n        }\n        // mark the save participant as current pending save operation\n        return this.saveSequentializer.setPending(versionId, saveParticipantPromise.then(function (newVersionId) {\n            // We have to protect against being disposed at this point. It could be that the save() operation\n            // was triggerd followed by a dispose() operation right after without waiting. Typically we cannot\n            // be disposed if we are dirty, but if we are not dirty, save() and dispose() can still be triggered\n            // one after the other without waiting for the save() to complete. If we are disposed(), we risk\n            // saving contents to disk that are stale (see https://github.com/Microsoft/vscode/issues/50942).\n            // To fix this issue, we will not store the contents to disk when we got disposed.\n            if (_this.disposed) {\n                return undefined;\n            }\n            // Under certain conditions we do a short-cut of flushing contents to disk when we can assume that\n            // the file has not changed and as such was not dirty before.\n            // The conditions are all of:\n            // - a forced, explicit save (Ctrl+S)\n            // - the model is not dirty (otherwise we know there are changed which needs to go to the file)\n            // - the model is not in orphan mode (because in that case we know the file does not exist on disk)\n            // - the model version did not change due to save participants running\n            if (options.force && !_this.dirty && !_this.inOrphanMode && options.reason === textfiles_1.SaveReason.EXPLICIT && versionId === newVersionId) {\n                return _this.doTouch(newVersionId);\n            }\n            // update versionId with its new value (if pre-save changes happened)\n            versionId = newVersionId;\n            // Clear error flag since we are trying to save again\n            _this.inErrorMode = false;\n            // Remember when this model was saved last\n            _this.lastSaveAttemptTime = Date.now();\n            // Save to Disk\n            // mark the save operation as currently pending with the versionId (it might have changed from a save participant triggering)\n            _this.logService.trace(\"doSave(\" + versionId + \") - before updateContent()\", _this.resource);\n            var snapshot = _this.createSnapshot();\n            if (!snapshot) {\n                throw new Error('Invalid snapshot');\n            }\n            return _this.saveSequentializer.setPending(newVersionId, _this.fileService.updateContent(_this.lastResolvedDiskStat.resource, snapshot, {\n                overwriteReadonly: options.overwriteReadonly,\n                overwriteEncoding: options.overwriteEncoding,\n                mtime: _this.lastResolvedDiskStat.mtime,\n                encoding: _this.getEncoding(),\n                etag: _this.lastResolvedDiskStat.etag,\n                writeElevated: options.writeElevated\n            }).then(function (stat) {\n                _this.logService.trace(\"doSave(\" + versionId + \") - after updateContent()\", _this.resource);\n                // Update dirty state unless model has changed meanwhile\n                if (versionId === _this.versionId) {\n                    _this.logService.trace(\"doSave(\" + versionId + \") - setting dirty to false because versionId did not change\", _this.resource);\n                    _this.setDirty(false);\n                }\n                else {\n                    _this.logService.trace(\"doSave(\" + versionId + \") - not setting dirty to false because versionId did change meanwhile\", _this.resource);\n                }\n                // Updated resolved stat with updated stat\n                _this.updateLastResolvedDiskStat(stat);\n                // Cancel any content change event promises as they are no longer valid\n                _this.contentChangeEventScheduler.cancel();\n                // Emit File Saved Event\n                _this._onDidStateChange.fire(textfiles_1.StateChange.SAVED);\n                // Telemetry\n                var telemetryPromise;\n                var settingsType = _this.getTypeIfSettings();\n                if (settingsType) {\n                    /* __GDPR__\n                        \"settingsWritten\" : {\n                            \"settingsType\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                        }\n                    */\n                    _this.telemetryService.publicLog('settingsWritten', { settingsType: settingsType }); // Do not log write to user settings.json and .vscode folder as a filePUT event as it ruins our JSON usage data\n                    telemetryPromise = Promise.resolve();\n                }\n                else {\n                    telemetryPromise = _this.getTelemetryData(options.reason).then(function (data) {\n                        /* __GDPR__\n                            \"filePUT\" : {\n                                \"${include}\": [\n                                    \"${FileTelemetryData}\"\n                                ]\n                            }\n                        */\n                        _this.telemetryService.publicLog('filePUT', data);\n                    });\n                }\n                return telemetryPromise;\n            }, function (error) {\n                if (!error) {\n                    error = new Error('Unknown Save Error'); // TODO@remote we should never get null as error (https://github.com/Microsoft/vscode/issues/55051)\n                }\n                _this.logService.error(\"doSave(\" + versionId + \") - exit - resulted in a save error: \" + error.toString(), _this.resource);\n                // Flag as error state in the model\n                _this.inErrorMode = true;\n                // Look out for a save conflict\n                if (error.fileOperationResult === files_1.FileOperationResult.FILE_MODIFIED_SINCE) {\n                    _this.inConflictMode = true;\n                }\n                // Show to user\n                _this.onSaveError(error);\n                // Emit as event\n                _this._onDidStateChange.fire(textfiles_1.StateChange.SAVE_ERROR);\n            }));\n        }));\n    };\n    TextFileEditorModel.prototype.getTypeIfSettings = function () {\n        if (resources_1.extname(this.resource) !== '.json') {\n            return '';\n        }\n        // Check for global settings file\n        if (resources_1.isEqual(this.resource, uri_1.URI.file(this.environmentService.appSettingsPath), !platform_1.isLinux)) {\n            return 'global-settings';\n        }\n        // Check for keybindings file\n        if (resources_1.isEqual(this.resource, uri_1.URI.file(this.environmentService.appKeybindingsPath), !platform_1.isLinux)) {\n            return 'keybindings';\n        }\n        // Check for locale file\n        if (resources_1.isEqual(this.resource, uri_1.URI.file(path_1.join(this.environmentService.appSettingsHome, 'locale.json')), !platform_1.isLinux)) {\n            return 'locale';\n        }\n        // Check for snippets\n        if (resources_1.isEqualOrParent(this.resource, uri_1.URI.file(path_1.join(this.environmentService.appSettingsHome, 'snippets')))) {\n            return 'snippets';\n        }\n        // Check for workspace settings file\n        var folders = this.contextService.getWorkspace().folders;\n        for (var _i = 0, folders_1 = folders; _i < folders_1.length; _i++) {\n            var folder = folders_1[_i];\n            if (resources_1.isEqualOrParent(this.resource, folder.toResource('.vscode'))) {\n                var filename = resources_1.basename(this.resource);\n                if (TextFileEditorModel.WHITELIST_WORKSPACE_JSON.indexOf(filename) > -1) {\n                    return \".vscode/\" + filename;\n                }\n            }\n        }\n        return '';\n    };\n    TextFileEditorModel.prototype.getTelemetryData = function (reason) {\n        var _this = this;\n        return this.hashService.createSHA1(this.resource.fsPath).then(function (hashedPath) {\n            var ext = resources_1.extname(_this.resource);\n            var fileName = resources_1.basename(_this.resource);\n            var telemetryData = {\n                mimeType: mime_1.guessMimeTypes(_this.resource.fsPath).join(', '),\n                ext: ext,\n                path: hashedPath,\n                reason: reason\n            };\n            if (ext === '.json' && TextFileEditorModel.WHITELIST_JSON.indexOf(fileName) > -1) {\n                telemetryData['whitelistedjson'] = fileName;\n            }\n            /* __GDPR__FRAGMENT__\n                \"FileTelemetryData\" : {\n                    \"mimeType\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                    \"ext\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                    \"path\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                    \"reason\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                    \"whitelistedjson\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                }\n            */\n            return telemetryData;\n        });\n    };\n    TextFileEditorModel.prototype.doTouch = function (versionId) {\n        var _this = this;\n        var snapshot = this.createSnapshot();\n        if (!snapshot) {\n            throw new Error('invalid snapshot');\n        }\n        return this.saveSequentializer.setPending(versionId, this.fileService.updateContent(this.lastResolvedDiskStat.resource, snapshot, {\n            mtime: this.lastResolvedDiskStat.mtime,\n            encoding: this.getEncoding(),\n            etag: this.lastResolvedDiskStat.etag\n        }).then(function (stat) {\n            // Updated resolved stat with updated stat since touching it might have changed mtime\n            _this.updateLastResolvedDiskStat(stat);\n        }, function (error) { return errors_1.onUnexpectedError(error); } /* just log any error but do not notify the user since the file was not dirty */));\n    };\n    TextFileEditorModel.prototype.setDirty = function (dirty) {\n        var _this = this;\n        var wasDirty = this.dirty;\n        var wasInConflictMode = this.inConflictMode;\n        var wasInErrorMode = this.inErrorMode;\n        var oldBufferSavedVersionId = this.bufferSavedVersionId;\n        if (!dirty) {\n            this.dirty = false;\n            this.inConflictMode = false;\n            this.inErrorMode = false;\n            this.updateSavedVersionId();\n        }\n        else {\n            this.dirty = true;\n        }\n        // Return function to revert this call\n        return function () {\n            _this.dirty = wasDirty;\n            _this.inConflictMode = wasInConflictMode;\n            _this.inErrorMode = wasInErrorMode;\n            _this.bufferSavedVersionId = oldBufferSavedVersionId;\n        };\n    };\n    TextFileEditorModel.prototype.updateSavedVersionId = function () {\n        // we remember the models alternate version id to remember when the version\n        // of the model matches with the saved version on disk. we need to keep this\n        // in order to find out if the model changed back to a saved version (e.g.\n        // when undoing long enough to reach to a version that is saved and then to\n        // clear the dirty flag)\n        if (this.textEditorModel) {\n            this.bufferSavedVersionId = this.textEditorModel.getAlternativeVersionId();\n        }\n    };\n    TextFileEditorModel.prototype.updateLastResolvedDiskStat = function (newVersionOnDiskStat) {\n        // First resolve - just take\n        if (!this.lastResolvedDiskStat) {\n            this.lastResolvedDiskStat = newVersionOnDiskStat;\n        }\n        // Subsequent resolve - make sure that we only assign it if the mtime is equal or has advanced.\n        // This prevents race conditions from loading and saving. If a save comes in late after a revert\n        // was called, the mtime could be out of sync.\n        else if (this.lastResolvedDiskStat.mtime <= newVersionOnDiskStat.mtime) {\n            this.lastResolvedDiskStat = newVersionOnDiskStat;\n        }\n    };\n    TextFileEditorModel.prototype.onSaveError = function (error) {\n        // Prepare handler\n        if (!TextFileEditorModel.saveErrorHandler) {\n            TextFileEditorModel.setSaveErrorHandler(this.instantiationService.createInstance(DefaultSaveErrorHandler));\n        }\n        // Handle\n        TextFileEditorModel.saveErrorHandler.onSaveError(error, this);\n    };\n    TextFileEditorModel.prototype.isDirty = function () {\n        return this.dirty;\n    };\n    TextFileEditorModel.prototype.getLastSaveAttemptTime = function () {\n        return this.lastSaveAttemptTime;\n    };\n    TextFileEditorModel.prototype.getETag = function () {\n        return this.lastResolvedDiskStat ? this.lastResolvedDiskStat.etag || null : null;\n    };\n    TextFileEditorModel.prototype.hasState = function (state) {\n        switch (state) {\n            case textfiles_1.ModelState.CONFLICT:\n                return this.inConflictMode;\n            case textfiles_1.ModelState.DIRTY:\n                return this.dirty;\n            case textfiles_1.ModelState.ERROR:\n                return this.inErrorMode;\n            case textfiles_1.ModelState.ORPHAN:\n                return this.inOrphanMode;\n            case textfiles_1.ModelState.PENDING_SAVE:\n                return this.saveSequentializer.hasPendingSave();\n            case textfiles_1.ModelState.SAVED:\n                return !this.dirty;\n        }\n    };\n    TextFileEditorModel.prototype.getEncoding = function () {\n        return this.preferredEncoding || this.contentEncoding;\n    };\n    TextFileEditorModel.prototype.setEncoding = function (encoding, mode) {\n        if (!this.isNewEncoding(encoding)) {\n            return; // return early if the encoding is already the same\n        }\n        // Encode: Save with encoding\n        if (mode === editor_1.EncodingMode.Encode) {\n            this.updatePreferredEncoding(encoding);\n            // Save\n            if (!this.isDirty()) {\n                this.versionId++; // needs to increment because we change the model potentially\n                this.makeDirty();\n            }\n            if (!this.inConflictMode) {\n                this.save({ overwriteEncoding: true });\n            }\n        }\n        // Decode: Load with encoding\n        else {\n            if (this.isDirty()) {\n                this.notificationService.info(nls.localize('saveFileFirst', \"The file is dirty. Please save it first before reopening it with another encoding.\"));\n                return;\n            }\n            this.updatePreferredEncoding(encoding);\n            // Load\n            this.load({\n                forceReadFromDisk: true // because encoding has changed\n            });\n        }\n    };\n    TextFileEditorModel.prototype.updatePreferredEncoding = function (encoding) {\n        if (!this.isNewEncoding(encoding)) {\n            return;\n        }\n        this.preferredEncoding = encoding;\n        // Emit\n        this._onDidStateChange.fire(textfiles_1.StateChange.ENCODING);\n    };\n    TextFileEditorModel.prototype.isNewEncoding = function (encoding) {\n        if (this.preferredEncoding === encoding) {\n            return false; // return early if the encoding is already the same\n        }\n        if (!this.preferredEncoding && this.contentEncoding === encoding) {\n            return false; // also return if we don't have a preferred encoding but the content encoding is already the same\n        }\n        return true;\n    };\n    TextFileEditorModel.prototype.isResolved = function () {\n        return !types_1.isUndefinedOrNull(this.lastResolvedDiskStat);\n    };\n    TextFileEditorModel.prototype.isReadonly = function () {\n        return !!(this.lastResolvedDiskStat && this.lastResolvedDiskStat.isReadonly);\n    };\n    TextFileEditorModel.prototype.isDisposed = function () {\n        return this.disposed;\n    };\n    TextFileEditorModel.prototype.getResource = function () {\n        return this.resource;\n    };\n    TextFileEditorModel.prototype.getStat = function () {\n        return this.lastResolvedDiskStat;\n    };\n    TextFileEditorModel.prototype.dispose = function () {\n        this.disposed = true;\n        this.inConflictMode = false;\n        this.inOrphanMode = false;\n        this.inErrorMode = false;\n        this.createTextEditorModelPromise = null;\n        this.cancelPendingAutoSave();\n        _super.prototype.dispose.call(this);\n    };\n    TextFileEditorModel.DEFAULT_CONTENT_CHANGE_BUFFER_DELAY = files_1.CONTENT_CHANGE_EVENT_BUFFER_DELAY;\n    TextFileEditorModel.DEFAULT_ORPHANED_CHANGE_BUFFER_DELAY = 100;\n    TextFileEditorModel.WHITELIST_JSON = ['package.json', 'package-lock.json', 'tsconfig.json', 'jsconfig.json', 'bower.json', '.eslintrc.json', 'tslint.json', 'composer.json'];\n    TextFileEditorModel.WHITELIST_WORKSPACE_JSON = ['settings.json', 'extensions.json', 'tasks.json', 'launch.json'];\n    TextFileEditorModel = tslib_1.__decorate([\n        tslib_1.__param(2, notification_1.INotificationService),\n        tslib_1.__param(3, modeService_1.IModeService),\n        tslib_1.__param(4, modelService_1.IModelService),\n        tslib_1.__param(5, files_1.IFileService),\n        tslib_1.__param(6, instantiation_1.IInstantiationService),\n        tslib_1.__param(7, telemetry_1.ITelemetryService),\n        tslib_1.__param(8, textfiles_1.ITextFileService),\n        tslib_1.__param(9, backup_1.IBackupFileService),\n        tslib_1.__param(10, environment_1.IEnvironmentService),\n        tslib_1.__param(11, workspace_1.IWorkspaceContextService),\n        tslib_1.__param(12, hashService_1.IHashService),\n        tslib_1.__param(13, log_1.ILogService)\n    ], TextFileEditorModel);\n    return TextFileEditorModel;\n}(textEditorModel_1.BaseTextEditorModel));\nexports.TextFileEditorModel = TextFileEditorModel;\nvar SaveSequentializer = /** @class */ (function () {\n    function SaveSequentializer() {\n    }\n    SaveSequentializer.prototype.hasPendingSave = function (versionId) {\n        if (!this._pendingSave) {\n            return false;\n        }\n        if (typeof versionId === 'number') {\n            return this._pendingSave.versionId === versionId;\n        }\n        return !!this._pendingSave;\n    };\n    Object.defineProperty(SaveSequentializer.prototype, \"pendingSave\", {\n        get: function () {\n            return this._pendingSave ? this._pendingSave.promise : undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SaveSequentializer.prototype.setPending = function (versionId, promise) {\n        var _this = this;\n        this._pendingSave = { versionId: versionId, promise: promise };\n        promise.then(function () { return _this.donePending(versionId); }, function () { return _this.donePending(versionId); });\n        return promise;\n    };\n    SaveSequentializer.prototype.donePending = function (versionId) {\n        if (this._pendingSave && versionId === this._pendingSave.versionId) {\n            // only set pending to done if the promise finished that is associated with that versionId\n            this._pendingSave = undefined;\n            // schedule the next save now that we are free if we have any\n            this.triggerNextSave();\n        }\n    };\n    SaveSequentializer.prototype.triggerNextSave = function () {\n        if (this._nextSave) {\n            var saveOperation = this._nextSave;\n            this._nextSave = undefined;\n            // Run next save and complete on the associated promise\n            saveOperation.run().then(saveOperation.promiseResolve, saveOperation.promiseReject);\n        }\n    };\n    SaveSequentializer.prototype.setNext = function (run) {\n        // this is our first next save, so we create associated promise with it\n        // so that we can return a promise that completes when the save operation\n        // has completed.\n        if (!this._nextSave) {\n            var promiseResolve_1;\n            var promiseReject_1;\n            var promise = new Promise(function (resolve, reject) {\n                promiseResolve_1 = resolve;\n                promiseReject_1 = reject;\n            });\n            this._nextSave = {\n                run: run,\n                promise: promise,\n                promiseResolve: promiseResolve_1,\n                promiseReject: promiseReject_1\n            };\n        }\n        // we have a previous next save, just overwrite it\n        else {\n            this._nextSave.run = run;\n        }\n        return this._nextSave.promise;\n    };\n    return SaveSequentializer;\n}());\nexports.SaveSequentializer = SaveSequentializer;\nvar DefaultSaveErrorHandler = /** @class */ (function () {\n    function DefaultSaveErrorHandler(notificationService) {\n        this.notificationService = notificationService;\n    }\n    DefaultSaveErrorHandler.prototype.onSaveError = function (error, model) {\n        this.notificationService.error(nls.localize('genericSaveError', \"Failed to save '{0}': {1}\", resources_1.basename(model.getResource()), errorMessage_1.toErrorMessage(error, false)));\n    };\n    DefaultSaveErrorHandler = tslib_1.__decorate([\n        tslib_1.__param(0, notification_1.INotificationService)\n    ], DefaultSaveErrorHandler);\n    return DefaultSaveErrorHandler;\n}());\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/textfile/common/textFileEditorModel.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/textfile/common/textFileEditorModel.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { join } from 'vs/base/common/path';\nimport * as nls from 'vs/nls';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { guessMimeTypes } from 'vs/base/common/mime';\nimport { toErrorMessage } from 'vs/base/common/errorMessage';\nimport { URI } from 'vs/base/common/uri';\nimport { isUndefinedOrNull, withUndefinedAsNull } from 'vs/base/common/types';\nimport { IWorkspaceContextService } from 'vs/platform/workspace/common/workspace';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { ITextFileService, IAutoSaveConfiguration, ModelState, ITextFileEditorModel, ISaveOptions, ISaveErrorHandler, ISaveParticipant, StateChange, SaveReason, IRawTextContent, ILoadOptions, LoadReason, IResolvedTextFileEditorModel } from 'vs/workbench/services/textfile/common/textfiles';\nimport { EncodingMode } from 'vs/workbench/common/editor';\nimport { BaseTextEditorModel } from 'vs/workbench/common/editor/textEditorModel';\nimport { IBackupFileService } from 'vs/workbench/services/backup/common/backup';\nimport { IFileService, FileOperationError, FileOperationResult, CONTENT_CHANGE_EVENT_BUFFER_DELAY, FileChangesEvent, FileChangeType, IFileStatWithMetadata, etag } from 'vs/platform/files/common/files';\nimport { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';\nimport { IModeService, ILanguageSelection } from 'vs/editor/common/services/modeService';\nimport { IModelService } from 'vs/editor/common/services/modelService';\nimport { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';\nimport { RunOnceScheduler, timeout } from 'vs/base/common/async';\nimport { ITextBufferFactory } from 'vs/editor/common/model';\nimport { IHashService } from 'vs/workbench/services/hash/common/hashService';\nimport { createTextBufferFactory } from 'vs/editor/common/model/textModel';\nimport { INotificationService } from 'vs/platform/notification/common/notification';\nimport { isLinux } from 'vs/base/common/platform';\nimport { IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { isEqual, isEqualOrParent, extname, basename } from 'vs/base/common/resources';\nimport { onUnexpectedError } from 'vs/base/common/errors';\n\n/**\n * The text file editor model listens to changes to its underlying code editor model and saves these changes through the file service back to the disk.\n */\nexport class TextFileEditorModel extends BaseTextEditorModel implements ITextFileEditorModel {\n\n\tstatic DEFAULT_CONTENT_CHANGE_BUFFER_DELAY = CONTENT_CHANGE_EVENT_BUFFER_DELAY;\n\tstatic DEFAULT_ORPHANED_CHANGE_BUFFER_DELAY = 100;\n\tstatic WHITELIST_JSON = ['package.json', 'package-lock.json', 'tsconfig.json', 'jsconfig.json', 'bower.json', '.eslintrc.json', 'tslint.json', 'composer.json'];\n\tstatic WHITELIST_WORKSPACE_JSON = ['settings.json', 'extensions.json', 'tasks.json', 'launch.json'];\n\n\tprivate static saveErrorHandler: ISaveErrorHandler;\n\tstatic setSaveErrorHandler(handler: ISaveErrorHandler): void { TextFileEditorModel.saveErrorHandler = handler; }\n\n\tprivate static saveParticipant: ISaveParticipant | null;\n\tstatic setSaveParticipant(handler: ISaveParticipant | null): void { TextFileEditorModel.saveParticipant = handler; }\n\n\tprivate readonly _onDidContentChange: Emitter<StateChange> = this._register(new Emitter<StateChange>());\n\tget onDidContentChange(): Event<StateChange> { return this._onDidContentChange.event; }\n\n\tprivate readonly _onDidStateChange: Emitter<StateChange> = this._register(new Emitter<StateChange>());\n\tget onDidStateChange(): Event<StateChange> { return this._onDidStateChange.event; }\n\n\tprivate resource: URI;\n\tprivate contentEncoding: string; \t\t\t// encoding as reported from disk\n\tprivate preferredEncoding: string;\t\t\t// encoding as chosen by the user\n\tprivate dirty: boolean;\n\tprivate versionId: number;\n\tprivate bufferSavedVersionId: number;\n\tprivate lastResolvedDiskStat: IFileStatWithMetadata;\n\tprivate blockModelContentChange: boolean;\n\tprivate autoSaveAfterMillies?: number;\n\tprivate autoSaveAfterMilliesEnabled: boolean;\n\tprivate autoSaveDisposable?: IDisposable;\n\tprivate contentChangeEventScheduler: RunOnceScheduler;\n\tprivate orphanedChangeEventScheduler: RunOnceScheduler;\n\tprivate saveSequentializer: SaveSequentializer;\n\tprivate disposed: boolean;\n\tprivate lastSaveAttemptTime: number;\n\tprivate createTextEditorModelPromise: Promise<TextFileEditorModel> | null;\n\tprivate inConflictMode: boolean;\n\tprivate inOrphanMode: boolean;\n\tprivate inErrorMode: boolean;\n\n\tconstructor(\n\t\tresource: URI,\n\t\tpreferredEncoding: string,\n\t\t@INotificationService private readonly notificationService: INotificationService,\n\t\t@IModeService modeService: IModeService,\n\t\t@IModelService modelService: IModelService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@ITelemetryService private readonly telemetryService: ITelemetryService,\n\t\t@ITextFileService private readonly textFileService: ITextFileService,\n\t\t@IBackupFileService private readonly backupFileService: IBackupFileService,\n\t\t@IEnvironmentService private readonly environmentService: IEnvironmentService,\n\t\t@IWorkspaceContextService private readonly contextService: IWorkspaceContextService,\n\t\t@IHashService private readonly hashService: IHashService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper(modelService, modeService);\n\n\t\tthis.resource = resource;\n\t\tthis.preferredEncoding = preferredEncoding;\n\t\tthis.inOrphanMode = false;\n\t\tthis.dirty = false;\n\t\tthis.versionId = 0;\n\t\tthis.lastSaveAttemptTime = 0;\n\t\tthis.saveSequentializer = new SaveSequentializer();\n\n\t\tthis.contentChangeEventScheduler = this._register(new RunOnceScheduler(() => this._onDidContentChange.fire(StateChange.CONTENT_CHANGE), TextFileEditorModel.DEFAULT_CONTENT_CHANGE_BUFFER_DELAY));\n\t\tthis.orphanedChangeEventScheduler = this._register(new RunOnceScheduler(() => this._onDidStateChange.fire(StateChange.ORPHANED_CHANGE), TextFileEditorModel.DEFAULT_ORPHANED_CHANGE_BUFFER_DELAY));\n\n\t\tthis.updateAutoSaveConfiguration(textFileService.getAutoSaveConfiguration());\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.fileService.onFileChanges(e => this.onFileChanges(e)));\n\t\tthis._register(this.textFileService.onAutoSaveConfigurationChange(config => this.updateAutoSaveConfiguration(config)));\n\t\tthis._register(this.textFileService.onFilesAssociationChange(e => this.onFilesAssociationChange()));\n\t\tthis._register(this.onDidStateChange(e => this.onStateChange(e)));\n\t}\n\n\tprivate onStateChange(e: StateChange): void {\n\t\tif (e === StateChange.REVERTED) {\n\n\t\t\t// Cancel any content change event promises as they are no longer valid.\n\t\t\tthis.contentChangeEventScheduler.cancel();\n\n\t\t\t// Refire state change reverted events as content change events\n\t\t\tthis._onDidContentChange.fire(StateChange.REVERTED);\n\t\t}\n\t}\n\n\tprivate onFileChanges(e: FileChangesEvent): void {\n\t\tlet fileEventImpactsModel = false;\n\t\tlet newInOrphanModeGuess: boolean | undefined;\n\n\t\t// If we are currently orphaned, we check if the model file was added back\n\t\tif (this.inOrphanMode) {\n\t\t\tconst modelFileAdded = e.contains(this.resource, FileChangeType.ADDED);\n\t\t\tif (modelFileAdded) {\n\t\t\t\tnewInOrphanModeGuess = false;\n\t\t\t\tfileEventImpactsModel = true;\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise we check if the model file was deleted\n\t\telse {\n\t\t\tconst modelFileDeleted = e.contains(this.resource, FileChangeType.DELETED);\n\t\t\tif (modelFileDeleted) {\n\t\t\t\tnewInOrphanModeGuess = true;\n\t\t\t\tfileEventImpactsModel = true;\n\t\t\t}\n\t\t}\n\n\t\tif (fileEventImpactsModel && this.inOrphanMode !== newInOrphanModeGuess) {\n\t\t\tlet checkOrphanedPromise: Promise<boolean>;\n\t\t\tif (newInOrphanModeGuess) {\n\t\t\t\t// We have received reports of users seeing delete events even though the file still\n\t\t\t\t// exists (network shares issue: https://github.com/Microsoft/vscode/issues/13665).\n\t\t\t\t// Since we do not want to mark the model as orphaned, we have to check if the\n\t\t\t\t// file is really gone and not just a faulty file event.\n\t\t\t\tcheckOrphanedPromise = timeout(100).then(() => {\n\t\t\t\t\tif (this.disposed) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.fileService.existsFile(this.resource).then(exists => !exists);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcheckOrphanedPromise = Promise.resolve(false);\n\t\t\t}\n\n\t\t\tcheckOrphanedPromise.then(newInOrphanModeValidated => {\n\t\t\t\tif (this.inOrphanMode !== newInOrphanModeValidated && !this.disposed) {\n\t\t\t\t\tthis.setOrphaned(newInOrphanModeValidated);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate setOrphaned(orphaned: boolean): void {\n\t\tif (this.inOrphanMode !== orphaned) {\n\t\t\tthis.inOrphanMode = orphaned;\n\t\t\tthis.orphanedChangeEventScheduler.schedule();\n\t\t}\n\t}\n\n\tprivate updateAutoSaveConfiguration(config: IAutoSaveConfiguration): void {\n\t\tconst autoSaveAfterMilliesEnabled = (typeof config.autoSaveDelay === 'number') && config.autoSaveDelay > 0;\n\n\t\tthis.autoSaveAfterMilliesEnabled = autoSaveAfterMilliesEnabled;\n\t\tthis.autoSaveAfterMillies = autoSaveAfterMilliesEnabled ? config.autoSaveDelay : undefined;\n\t}\n\n\tprivate onFilesAssociationChange(): void {\n\t\tif (!this.textEditorModel) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst firstLineText = this.getFirstLineText(this.textEditorModel);\n\t\tconst languageSelection = this.getOrCreateMode(this.modeService, undefined, firstLineText);\n\n\t\tthis.modelService.setMode(this.textEditorModel, languageSelection);\n\t}\n\n\tgetVersionId(): number {\n\t\treturn this.versionId;\n\t}\n\n\trevert(soft?: boolean): Promise<void> {\n\t\tif (!this.isResolved()) {\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\n\t\t// Cancel any running auto-save\n\t\tthis.cancelPendingAutoSave();\n\n\t\t// Unset flags\n\t\tconst undo = this.setDirty(false);\n\n\t\tlet loadPromise: Promise<any>;\n\t\tif (soft) {\n\t\t\tloadPromise = Promise.resolve();\n\t\t} else {\n\t\t\tloadPromise = this.load({ forceReadFromDisk: true });\n\t\t}\n\n\t\treturn loadPromise.then(() => {\n\n\t\t\t// Emit file change event\n\t\t\tthis._onDidStateChange.fire(StateChange.REVERTED);\n\t\t}, error => {\n\n\t\t\t// Set flags back to previous values, we are still dirty if revert failed\n\t\t\tundo();\n\n\t\t\treturn Promise.reject(error);\n\t\t});\n\t}\n\n\tload(options?: ILoadOptions): Promise<ITextFileEditorModel> {\n\t\tthis.logService.trace('load() - enter', this.resource);\n\n\t\t// It is very important to not reload the model when the model is dirty.\n\t\t// We also only want to reload the model from the disk if no save is pending\n\t\t// to avoid data loss.\n\t\tif (this.dirty || this.saveSequentializer.hasPendingSave()) {\n\t\t\tthis.logService.trace('load() - exit - without loading because model is dirty or being saved', this.resource);\n\n\t\t\treturn Promise.resolve(this);\n\t\t}\n\n\t\t// Only for new models we support to load from backup\n\t\tif (!this.textEditorModel && !this.createTextEditorModelPromise) {\n\t\t\treturn this.loadFromBackup(options);\n\t\t}\n\n\t\t// Otherwise load from file resource\n\t\treturn this.loadFromFile(options);\n\t}\n\n\tprivate loadFromBackup(options?: ILoadOptions): Promise<TextFileEditorModel> {\n\t\treturn this.backupFileService.loadBackupResource(this.resource).then(backup => {\n\n\t\t\t// Make sure meanwhile someone else did not suceed or start loading\n\t\t\tif (this.createTextEditorModelPromise || this.textEditorModel) {\n\t\t\t\treturn this.createTextEditorModelPromise || this;\n\t\t\t}\n\n\t\t\t// If we have a backup, continue loading with it\n\t\t\tif (!!backup) {\n\t\t\t\tconst content: IRawTextContent = {\n\t\t\t\t\tresource: this.resource,\n\t\t\t\t\tname: basename(this.resource),\n\t\t\t\t\tmtime: Date.now(),\n\t\t\t\t\tsize: 0,\n\t\t\t\t\tetag: etag(Date.now(), 0),\n\t\t\t\t\tvalue: createTextBufferFactory(''), /* will be filled later from backup */\n\t\t\t\t\tencoding: this.fileService.encoding.getWriteEncoding(this.resource, this.preferredEncoding).encoding,\n\t\t\t\t\tisReadonly: false\n\t\t\t\t};\n\n\t\t\t\treturn this.loadWithContent(content, options, backup);\n\t\t\t}\n\n\t\t\t// Otherwise load from file\n\t\t\treturn this.loadFromFile(options);\n\t\t});\n\t}\n\n\tprivate loadFromFile(options?: ILoadOptions): Promise<TextFileEditorModel> {\n\t\tconst forceReadFromDisk = options && options.forceReadFromDisk;\n\t\tconst allowBinary = this.isResolved() /* always allow if we resolved previously */ || (options && options.allowBinary);\n\n\t\t// Decide on etag\n\t\tlet etag: string | undefined;\n\t\tif (forceReadFromDisk) {\n\t\t\tetag = undefined; // reset ETag if we enforce to read from disk\n\t\t} else if (this.lastResolvedDiskStat) {\n\t\t\tetag = this.lastResolvedDiskStat.etag; // otherwise respect etag to support caching\n\t\t}\n\n\t\t// Ensure to track the versionId before doing a long running operation\n\t\t// to make sure the model was not changed in the meantime which would\n\t\t// indicate that the user or program has made edits. If we would ignore\n\t\t// this, we could potentially loose the changes that were made because\n\t\t// after resolving the content we update the model and reset the dirty\n\t\t// flag.\n\t\tconst currentVersionId = this.versionId;\n\n\t\t// Resolve Content\n\t\treturn this.textFileService\n\t\t\t.resolveTextContent(this.resource, { acceptTextOnly: !allowBinary, etag, encoding: this.preferredEncoding })\n\t\t\t.then(content => {\n\n\t\t\t\t// Clear orphaned state when loading was successful\n\t\t\t\tthis.setOrphaned(false);\n\n\t\t\t\t// Guard against the model having changed in the meantime\n\t\t\t\tif (currentVersionId === this.versionId) {\n\t\t\t\t\treturn this.loadWithContent(content, options);\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t}, error => {\n\t\t\t\tconst result = error.fileOperationResult;\n\n\t\t\t\t// Apply orphaned state based on error code\n\t\t\t\tthis.setOrphaned(result === FileOperationResult.FILE_NOT_FOUND);\n\n\t\t\t\t// NotModified status is expected and can be handled gracefully\n\t\t\t\tif (result === FileOperationResult.FILE_NOT_MODIFIED_SINCE) {\n\n\t\t\t\t\t// Guard against the model having changed in the meantime\n\t\t\t\t\tif (currentVersionId === this.versionId) {\n\t\t\t\t\t\tthis.setDirty(false); // Ensure we are not tracking a stale state\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\t// Ignore when a model has been resolved once and the file was deleted meanwhile. Since\n\t\t\t\t// we already have the model loaded, we can return to this state and update the orphaned\n\t\t\t\t// flag to indicate that this model has no version on disk anymore.\n\t\t\t\tif (this.isResolved() && result === FileOperationResult.FILE_NOT_FOUND) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise bubble up the error\n\t\t\t\treturn Promise.reject<TextFileEditorModel>(error);\n\t\t\t});\n\t}\n\n\tprivate loadWithContent(content: IRawTextContent, options?: ILoadOptions, backup?: URI): Promise<TextFileEditorModel> {\n\t\treturn this.doLoadWithContent(content, backup).then(model => {\n\n\t\t\t// Telemetry: We log the fileGet telemetry event after the model has been loaded to ensure a good mimetype\n\t\t\tconst settingsType = this.getTypeIfSettings();\n\t\t\tif (settingsType) {\n\t\t\t\t/* __GDPR__\n\t\t\t\t\t\"settingsRead\" : {\n\t\t\t\t\t\t\"settingsType\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tthis.telemetryService.publicLog('settingsRead', { settingsType }); // Do not log read to user settings.json and .vscode folder as a fileGet event as it ruins our JSON usage data\n\t\t\t} else {\n\t\t\t\t/* __GDPR__\n\t\t\t\t\t\"fileGet\" : {\n\t\t\t\t\t\t\"${include}\": [\n\t\t\t\t\t\t\t\"${FileTelemetryData}\"\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tthis.telemetryService.publicLog('fileGet', this.getTelemetryData(options && options.reason ? options.reason : LoadReason.OTHER));\n\t\t\t}\n\n\t\t\treturn model;\n\t\t});\n\t}\n\n\tprivate doLoadWithContent(content: IRawTextContent, backup?: URI): Promise<TextFileEditorModel> {\n\t\tthis.logService.trace('load() - resolved content', this.resource);\n\n\t\t// Update our resolved disk stat model\n\t\tthis.updateLastResolvedDiskStat({\n\t\t\tresource: this.resource,\n\t\t\tname: content.name,\n\t\t\tmtime: content.mtime,\n\t\t\tsize: content.size,\n\t\t\tetag: content.etag,\n\t\t\tisDirectory: false,\n\t\t\tisSymbolicLink: false,\n\t\t\tisReadonly: content.isReadonly\n\t\t});\n\n\t\t// Keep the original encoding to not loose it when saving\n\t\tconst oldEncoding = this.contentEncoding;\n\t\tthis.contentEncoding = content.encoding;\n\n\t\t// Handle events if encoding changed\n\t\tif (this.preferredEncoding) {\n\t\t\tthis.updatePreferredEncoding(this.contentEncoding); // make sure to reflect the real encoding of the file (never out of sync)\n\t\t} else if (oldEncoding !== this.contentEncoding) {\n\t\t\tthis._onDidStateChange.fire(StateChange.ENCODING);\n\t\t}\n\n\t\t// Update Existing Model\n\t\tif (this.textEditorModel) {\n\t\t\tthis.doUpdateTextModel(content.value);\n\n\t\t\treturn Promise.resolve(this);\n\t\t}\n\n\t\t// Join an existing request to create the editor model to avoid race conditions\n\t\telse if (this.createTextEditorModelPromise) {\n\t\t\tthis.logService.trace('load() - join existing text editor model promise', this.resource);\n\n\t\t\treturn this.createTextEditorModelPromise;\n\t\t}\n\n\t\t// Create New Model\n\t\treturn this.doCreateTextModel(content.resource, content.value, backup);\n\t}\n\n\tprivate doUpdateTextModel(value: ITextBufferFactory): void {\n\t\tthis.logService.trace('load() - updated text editor model', this.resource);\n\n\t\t// Ensure we are not tracking a stale state\n\t\tthis.setDirty(false);\n\n\t\t// Update model value in a block that ignores model content change events\n\t\tthis.blockModelContentChange = true;\n\t\ttry {\n\t\t\tthis.updateTextEditorModel(value);\n\t\t} finally {\n\t\t\tthis.blockModelContentChange = false;\n\t\t}\n\n\t\t// Ensure we track the latest saved version ID given that the contents changed\n\t\tthis.updateSavedVersionId();\n\t}\n\n\tprivate doCreateTextModel(resource: URI, value: ITextBufferFactory, backup: URI | undefined): Promise<TextFileEditorModel> {\n\t\tthis.logService.trace('load() - created text editor model', this.resource);\n\n\t\tthis.createTextEditorModelPromise = this.doLoadBackup(backup).then(backupContent => {\n\t\t\tthis.createTextEditorModelPromise = null;\n\n\t\t\t// Create model\n\t\t\tconst hasBackupContent = !!backupContent;\n\t\t\tthis.createTextEditorModel(backupContent ? backupContent : value, resource);\n\n\t\t\t// We restored a backup so we have to set the model as being dirty\n\t\t\t// We also want to trigger auto save if it is enabled to simulate the exact same behaviour\n\t\t\t// you would get if manually making the model dirty (fixes https://github.com/Microsoft/vscode/issues/16977)\n\t\t\tif (hasBackupContent) {\n\t\t\t\tthis.makeDirty();\n\t\t\t\tif (this.autoSaveAfterMilliesEnabled) {\n\t\t\t\t\tthis.doAutoSave(this.versionId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Ensure we are not tracking a stale state\n\t\t\telse {\n\t\t\t\tthis.setDirty(false);\n\t\t\t}\n\n\t\t\t// Model Listeners\n\t\t\tthis.installModelListeners();\n\n\t\t\treturn this;\n\t\t}, error => {\n\t\t\tthis.createTextEditorModelPromise = null;\n\n\t\t\treturn Promise.reject<TextFileEditorModel>(error);\n\t\t});\n\n\t\treturn this.createTextEditorModelPromise;\n\t}\n\n\tprivate installModelListeners(): void {\n\n\t\t// See https://github.com/Microsoft/vscode/issues/30189\n\t\t// This code has been extracted to a different method because it caused a memory leak\n\t\t// where `value` was captured in the content change listener closure scope.\n\n\t\t// Content Change\n\t\tif (this.textEditorModel) {\n\t\t\tthis._register(this.textEditorModel.onDidChangeContent(() => this.onModelContentChanged()));\n\t\t}\n\t}\n\n\tprivate doLoadBackup(backup: URI | undefined): Promise<ITextBufferFactory | null> {\n\t\tif (!backup) {\n\t\t\treturn Promise.resolve(null);\n\t\t}\n\n\t\treturn this.backupFileService.resolveBackupContent(backup).then(withUndefinedAsNull, error => null /* ignore errors */);\n\t}\n\n\tprotected getOrCreateMode(modeService: IModeService, preferredModeIds: string | undefined, firstLineText?: string): ILanguageSelection {\n\t\treturn modeService.createByFilepathOrFirstLine(this.resource.fsPath, firstLineText);\n\t}\n\n\tprivate onModelContentChanged(): void {\n\t\tthis.logService.trace(`onModelContentChanged() - enter`, this.resource);\n\n\t\t// In any case increment the version id because it tracks the textual content state of the model at all times\n\t\tthis.versionId++;\n\t\tthis.logService.trace(`onModelContentChanged() - new versionId ${this.versionId}`, this.resource);\n\n\t\t// Ignore if blocking model changes\n\t\tif (this.blockModelContentChange) {\n\t\t\treturn;\n\t\t}\n\n\t\t// The contents changed as a matter of Undo and the version reached matches the saved one\n\t\t// In this case we clear the dirty flag and emit a SAVED event to indicate this state.\n\t\t// Note: we currently only do this check when auto-save is turned off because there you see\n\t\t// a dirty indicator that you want to get rid of when undoing to the saved version.\n\t\tif (!this.autoSaveAfterMilliesEnabled && this.textEditorModel && this.textEditorModel.getAlternativeVersionId() === this.bufferSavedVersionId) {\n\t\t\tthis.logService.trace('onModelContentChanged() - model content changed back to last saved version', this.resource);\n\n\t\t\t// Clear flags\n\t\t\tconst wasDirty = this.dirty;\n\t\t\tthis.setDirty(false);\n\n\t\t\t// Emit event\n\t\t\tif (wasDirty) {\n\t\t\t\tthis._onDidStateChange.fire(StateChange.REVERTED);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis.logService.trace('onModelContentChanged() - model content changed and marked as dirty', this.resource);\n\n\t\t// Mark as dirty\n\t\tthis.makeDirty();\n\n\t\t// Start auto save process unless we are in conflict resolution mode and unless it is disabled\n\t\tif (this.autoSaveAfterMilliesEnabled) {\n\t\t\tif (!this.inConflictMode) {\n\t\t\t\tthis.doAutoSave(this.versionId);\n\t\t\t} else {\n\t\t\t\tthis.logService.trace('makeDirty() - prevented save because we are in conflict resolution mode', this.resource);\n\t\t\t}\n\t\t}\n\n\t\t// Handle content change events\n\t\tthis.contentChangeEventScheduler.schedule();\n\t}\n\n\tprivate makeDirty(): void {\n\n\t\t// Track dirty state and version id\n\t\tconst wasDirty = this.dirty;\n\t\tthis.setDirty(true);\n\n\t\t// Emit as Event if we turned dirty\n\t\tif (!wasDirty) {\n\t\t\tthis._onDidStateChange.fire(StateChange.DIRTY);\n\t\t}\n\t}\n\n\tprivate doAutoSave(versionId: number): void {\n\t\tthis.logService.trace(`doAutoSave() - enter for versionId ${versionId}`, this.resource);\n\n\t\t// Cancel any currently running auto saves to make this the one that succeeds\n\t\tthis.cancelPendingAutoSave();\n\n\t\t// Create new save timer and store it for disposal as needed\n\t\tconst handle = setTimeout(() => {\n\n\t\t\t// Only trigger save if the version id has not changed meanwhile\n\t\t\tif (versionId === this.versionId) {\n\t\t\t\tthis.doSave(versionId, { reason: SaveReason.AUTO }); // Very important here to not return the promise because if the timeout promise is canceled it will bubble up the error otherwise - do not change\n\t\t\t}\n\t\t}, this.autoSaveAfterMillies);\n\n\t\tthis.autoSaveDisposable = toDisposable(() => clearTimeout(handle));\n\t}\n\n\tprivate cancelPendingAutoSave(): void {\n\t\tif (this.autoSaveDisposable) {\n\t\t\tthis.autoSaveDisposable.dispose();\n\t\t\tthis.autoSaveDisposable = undefined;\n\t\t}\n\t}\n\n\tsave(options: ISaveOptions = Object.create(null)): Promise<void> {\n\t\tif (!this.isResolved()) {\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\n\t\tthis.logService.trace('save() - enter', this.resource);\n\n\t\t// Cancel any currently running auto saves to make this the one that succeeds\n\t\tthis.cancelPendingAutoSave();\n\n\t\treturn this.doSave(this.versionId, options);\n\t}\n\n\tprivate doSave(versionId: number, options: ISaveOptions): Promise<void> {\n\t\tif (isUndefinedOrNull(options.reason)) {\n\t\t\toptions.reason = SaveReason.EXPLICIT;\n\t\t}\n\n\t\tthis.logService.trace(`doSave(${versionId}) - enter with versionId ' + versionId`, this.resource);\n\n\t\t// Lookup any running pending save for this versionId and return it if found\n\t\t//\n\t\t// Scenario: user invoked the save action multiple times quickly for the same contents\n\t\t//           while the save was not yet finished to disk\n\t\t//\n\t\tif (this.saveSequentializer.hasPendingSave(versionId)) {\n\t\t\tthis.logService.trace(`doSave(${versionId}) - exit - found a pending save for versionId ${versionId}`, this.resource);\n\n\t\t\treturn this.saveSequentializer.pendingSave || Promise.resolve(undefined);\n\t\t}\n\n\t\t// Return early if not dirty (unless forced) or version changed meanwhile\n\t\t//\n\t\t// Scenario A: user invoked save action even though the model is not dirty\n\t\t// Scenario B: auto save was triggered for a certain change by the user but meanwhile the user changed\n\t\t//             the contents and the version for which auto save was started is no longer the latest.\n\t\t//             Thus we avoid spawning multiple auto saves and only take the latest.\n\t\t//\n\t\tif ((!options.force && !this.dirty) || versionId !== this.versionId) {\n\t\t\tthis.logService.trace(`doSave(${versionId}) - exit - because not dirty and/or versionId is different (this.isDirty: ${this.dirty}, this.versionId: ${this.versionId})`, this.resource);\n\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\n\t\t// Return if currently saving by storing this save request as the next save that should happen.\n\t\t// Never ever must 2 saves execute at the same time because this can lead to dirty writes and race conditions.\n\t\t//\n\t\t// Scenario A: auto save was triggered and is currently busy saving to disk. this takes long enough that another auto save\n\t\t//             kicks in.\n\t\t// Scenario B: save is very slow (e.g. network share) and the user manages to change the buffer and trigger another save\n\t\t//             while the first save has not returned yet.\n\t\t//\n\t\tif (this.saveSequentializer.hasPendingSave()) {\n\t\t\tthis.logService.trace(`doSave(${versionId}) - exit - because busy saving`, this.resource);\n\n\t\t\t// Register this as the next upcoming save and return\n\t\t\treturn this.saveSequentializer.setNext(() => this.doSave(this.versionId /* make sure to use latest version id here */, options));\n\t\t}\n\n\t\t// Push all edit operations to the undo stack so that the user has a chance to\n\t\t// Ctrl+Z back to the saved version. We only do this when auto-save is turned off\n\t\tif (!this.autoSaveAfterMilliesEnabled && this.textEditorModel) {\n\t\t\tthis.textEditorModel.pushStackElement();\n\t\t}\n\n\t\t// A save participant can still change the model now and since we are so close to saving\n\t\t// we do not want to trigger another auto save or similar, so we block this\n\t\t// In addition we update our version right after in case it changed because of a model change\n\t\t// Save participants can also be skipped through API.\n\t\tlet saveParticipantPromise: Promise<number> = Promise.resolve(versionId);\n\t\tif (TextFileEditorModel.saveParticipant && !options.skipSaveParticipants) {\n\t\t\tconst onCompleteOrError = () => {\n\t\t\t\tthis.blockModelContentChange = false;\n\n\t\t\t\treturn this.versionId;\n\t\t\t};\n\n\t\t\tthis.blockModelContentChange = true;\n\t\t\tsaveParticipantPromise = TextFileEditorModel.saveParticipant.participate(this as IResolvedTextFileEditorModel, { reason: options.reason }).then(onCompleteOrError, onCompleteOrError);\n\t\t}\n\n\t\t// mark the save participant as current pending save operation\n\t\treturn this.saveSequentializer.setPending(versionId, saveParticipantPromise.then(newVersionId => {\n\n\t\t\t// We have to protect against being disposed at this point. It could be that the save() operation\n\t\t\t// was triggerd followed by a dispose() operation right after without waiting. Typically we cannot\n\t\t\t// be disposed if we are dirty, but if we are not dirty, save() and dispose() can still be triggered\n\t\t\t// one after the other without waiting for the save() to complete. If we are disposed(), we risk\n\t\t\t// saving contents to disk that are stale (see https://github.com/Microsoft/vscode/issues/50942).\n\t\t\t// To fix this issue, we will not store the contents to disk when we got disposed.\n\t\t\tif (this.disposed) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\t// Under certain conditions we do a short-cut of flushing contents to disk when we can assume that\n\t\t\t// the file has not changed and as such was not dirty before.\n\t\t\t// The conditions are all of:\n\t\t\t// - a forced, explicit save (Ctrl+S)\n\t\t\t// - the model is not dirty (otherwise we know there are changed which needs to go to the file)\n\t\t\t// - the model is not in orphan mode (because in that case we know the file does not exist on disk)\n\t\t\t// - the model version did not change due to save participants running\n\t\t\tif (options.force && !this.dirty && !this.inOrphanMode && options.reason === SaveReason.EXPLICIT && versionId === newVersionId) {\n\t\t\t\treturn this.doTouch(newVersionId);\n\t\t\t}\n\n\t\t\t// update versionId with its new value (if pre-save changes happened)\n\t\t\tversionId = newVersionId;\n\n\t\t\t// Clear error flag since we are trying to save again\n\t\t\tthis.inErrorMode = false;\n\n\t\t\t// Remember when this model was saved last\n\t\t\tthis.lastSaveAttemptTime = Date.now();\n\n\t\t\t// Save to Disk\n\t\t\t// mark the save operation as currently pending with the versionId (it might have changed from a save participant triggering)\n\t\t\tthis.logService.trace(`doSave(${versionId}) - before updateContent()`, this.resource);\n\t\t\tconst snapshot = this.createSnapshot();\n\t\t\tif (!snapshot) {\n\t\t\t\tthrow new Error('Invalid snapshot');\n\t\t\t}\n\t\t\treturn this.saveSequentializer.setPending(newVersionId, this.fileService.updateContent(this.lastResolvedDiskStat.resource, snapshot, {\n\t\t\t\toverwriteReadonly: options.overwriteReadonly,\n\t\t\t\toverwriteEncoding: options.overwriteEncoding,\n\t\t\t\tmtime: this.lastResolvedDiskStat.mtime,\n\t\t\t\tencoding: this.getEncoding(),\n\t\t\t\tetag: this.lastResolvedDiskStat.etag,\n\t\t\t\twriteElevated: options.writeElevated\n\t\t\t}).then(stat => {\n\t\t\t\tthis.logService.trace(`doSave(${versionId}) - after updateContent()`, this.resource);\n\n\t\t\t\t// Update dirty state unless model has changed meanwhile\n\t\t\t\tif (versionId === this.versionId) {\n\t\t\t\t\tthis.logService.trace(`doSave(${versionId}) - setting dirty to false because versionId did not change`, this.resource);\n\t\t\t\t\tthis.setDirty(false);\n\t\t\t\t} else {\n\t\t\t\t\tthis.logService.trace(`doSave(${versionId}) - not setting dirty to false because versionId did change meanwhile`, this.resource);\n\t\t\t\t}\n\n\t\t\t\t// Updated resolved stat with updated stat\n\t\t\t\tthis.updateLastResolvedDiskStat(stat);\n\n\t\t\t\t// Cancel any content change event promises as they are no longer valid\n\t\t\t\tthis.contentChangeEventScheduler.cancel();\n\n\t\t\t\t// Emit File Saved Event\n\t\t\t\tthis._onDidStateChange.fire(StateChange.SAVED);\n\n\t\t\t\t// Telemetry\n\t\t\t\tlet telemetryPromise: Thenable<void>;\n\t\t\t\tconst settingsType = this.getTypeIfSettings();\n\t\t\t\tif (settingsType) {\n\t\t\t\t\t/* __GDPR__\n\t\t\t\t\t\t\"settingsWritten\" : {\n\t\t\t\t\t\t\t\"settingsType\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\tthis.telemetryService.publicLog('settingsWritten', { settingsType }); // Do not log write to user settings.json and .vscode folder as a filePUT event as it ruins our JSON usage data\n\n\t\t\t\t\ttelemetryPromise = Promise.resolve();\n\t\t\t\t} else {\n\t\t\t\t\ttelemetryPromise = this.getTelemetryData(options.reason).then(data => {\n\t\t\t\t\t\t/* __GDPR__\n\t\t\t\t\t\t\t\"filePUT\" : {\n\t\t\t\t\t\t\t\t\"${include}\": [\n\t\t\t\t\t\t\t\t\t\"${FileTelemetryData}\"\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tthis.telemetryService.publicLog('filePUT', data);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn telemetryPromise;\n\t\t\t}, error => {\n\t\t\t\tif (!error) {\n\t\t\t\t\terror = new Error('Unknown Save Error'); // TODO@remote we should never get null as error (https://github.com/Microsoft/vscode/issues/55051)\n\t\t\t\t}\n\n\t\t\t\tthis.logService.error(`doSave(${versionId}) - exit - resulted in a save error: ${error.toString()}`, this.resource);\n\n\t\t\t\t// Flag as error state in the model\n\t\t\t\tthis.inErrorMode = true;\n\n\t\t\t\t// Look out for a save conflict\n\t\t\t\tif ((<FileOperationError>error).fileOperationResult === FileOperationResult.FILE_MODIFIED_SINCE) {\n\t\t\t\t\tthis.inConflictMode = true;\n\t\t\t\t}\n\n\t\t\t\t// Show to user\n\t\t\t\tthis.onSaveError(error);\n\n\t\t\t\t// Emit as event\n\t\t\t\tthis._onDidStateChange.fire(StateChange.SAVE_ERROR);\n\t\t\t}));\n\t\t}));\n\t}\n\n\tprivate getTypeIfSettings(): string {\n\t\tif (extname(this.resource) !== '.json') {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Check for global settings file\n\t\tif (isEqual(this.resource, URI.file(this.environmentService.appSettingsPath), !isLinux)) {\n\t\t\treturn 'global-settings';\n\t\t}\n\n\t\t// Check for keybindings file\n\t\tif (isEqual(this.resource, URI.file(this.environmentService.appKeybindingsPath), !isLinux)) {\n\t\t\treturn 'keybindings';\n\t\t}\n\n\t\t// Check for locale file\n\t\tif (isEqual(this.resource, URI.file(join(this.environmentService.appSettingsHome, 'locale.json')), !isLinux)) {\n\t\t\treturn 'locale';\n\t\t}\n\n\t\t// Check for snippets\n\t\tif (isEqualOrParent(this.resource, URI.file(join(this.environmentService.appSettingsHome, 'snippets')))) {\n\t\t\treturn 'snippets';\n\t\t}\n\n\t\t// Check for workspace settings file\n\t\tconst folders = this.contextService.getWorkspace().folders;\n\t\tfor (const folder of folders) {\n\t\t\tif (isEqualOrParent(this.resource, folder.toResource('.vscode'))) {\n\t\t\t\tconst filename = basename(this.resource);\n\t\t\t\tif (TextFileEditorModel.WHITELIST_WORKSPACE_JSON.indexOf(filename) > -1) {\n\t\t\t\t\treturn `.vscode/${filename}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn '';\n\t}\n\n\tprivate getTelemetryData(reason: number | undefined): Thenable<object> {\n\t\treturn this.hashService.createSHA1(this.resource.fsPath).then(hashedPath => {\n\t\t\tconst ext = extname(this.resource);\n\t\t\tconst fileName = basename(this.resource);\n\t\t\tconst telemetryData = {\n\t\t\t\tmimeType: guessMimeTypes(this.resource.fsPath).join(', '),\n\t\t\t\text,\n\t\t\t\tpath: hashedPath,\n\t\t\t\treason\n\t\t\t};\n\n\t\t\tif (ext === '.json' && TextFileEditorModel.WHITELIST_JSON.indexOf(fileName) > -1) {\n\t\t\t\ttelemetryData['whitelistedjson'] = fileName;\n\t\t\t}\n\n\t\t\t/* __GDPR__FRAGMENT__\n\t\t\t\t\"FileTelemetryData\" : {\n\t\t\t\t\t\"mimeType\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\t\t\t\"ext\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\t\t\t\"path\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\t\t\t\"reason\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\t\t\t\"whitelistedjson\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t\t\t}\n\t\t\t*/\n\t\t\treturn telemetryData;\n\t\t});\n\t}\n\n\tprivate doTouch(versionId: number): Promise<void> {\n\t\tconst snapshot = this.createSnapshot();\n\t\tif (!snapshot) {\n\t\t\tthrow new Error('invalid snapshot');\n\t\t}\n\t\treturn this.saveSequentializer.setPending(versionId, this.fileService.updateContent(this.lastResolvedDiskStat.resource, snapshot, {\n\t\t\tmtime: this.lastResolvedDiskStat.mtime,\n\t\t\tencoding: this.getEncoding(),\n\t\t\tetag: this.lastResolvedDiskStat.etag\n\t\t}).then(stat => {\n\n\t\t\t// Updated resolved stat with updated stat since touching it might have changed mtime\n\t\t\tthis.updateLastResolvedDiskStat(stat);\n\t\t}, error => onUnexpectedError(error) /* just log any error but do not notify the user since the file was not dirty */));\n\t}\n\n\tprivate setDirty(dirty: boolean): () => void {\n\t\tconst wasDirty = this.dirty;\n\t\tconst wasInConflictMode = this.inConflictMode;\n\t\tconst wasInErrorMode = this.inErrorMode;\n\t\tconst oldBufferSavedVersionId = this.bufferSavedVersionId;\n\n\t\tif (!dirty) {\n\t\t\tthis.dirty = false;\n\t\t\tthis.inConflictMode = false;\n\t\t\tthis.inErrorMode = false;\n\t\t\tthis.updateSavedVersionId();\n\t\t} else {\n\t\t\tthis.dirty = true;\n\t\t}\n\n\t\t// Return function to revert this call\n\t\treturn () => {\n\t\t\tthis.dirty = wasDirty;\n\t\t\tthis.inConflictMode = wasInConflictMode;\n\t\t\tthis.inErrorMode = wasInErrorMode;\n\t\t\tthis.bufferSavedVersionId = oldBufferSavedVersionId;\n\t\t};\n\t}\n\n\tprivate updateSavedVersionId(): void {\n\t\t// we remember the models alternate version id to remember when the version\n\t\t// of the model matches with the saved version on disk. we need to keep this\n\t\t// in order to find out if the model changed back to a saved version (e.g.\n\t\t// when undoing long enough to reach to a version that is saved and then to\n\t\t// clear the dirty flag)\n\t\tif (this.textEditorModel) {\n\t\t\tthis.bufferSavedVersionId = this.textEditorModel.getAlternativeVersionId();\n\t\t}\n\t}\n\n\tprivate updateLastResolvedDiskStat(newVersionOnDiskStat: IFileStatWithMetadata): void {\n\n\t\t// First resolve - just take\n\t\tif (!this.lastResolvedDiskStat) {\n\t\t\tthis.lastResolvedDiskStat = newVersionOnDiskStat;\n\t\t}\n\n\t\t// Subsequent resolve - make sure that we only assign it if the mtime is equal or has advanced.\n\t\t// This prevents race conditions from loading and saving. If a save comes in late after a revert\n\t\t// was called, the mtime could be out of sync.\n\t\telse if (this.lastResolvedDiskStat.mtime <= newVersionOnDiskStat.mtime) {\n\t\t\tthis.lastResolvedDiskStat = newVersionOnDiskStat;\n\t\t}\n\t}\n\n\tprivate onSaveError(error: any): void {\n\n\t\t// Prepare handler\n\t\tif (!TextFileEditorModel.saveErrorHandler) {\n\t\t\tTextFileEditorModel.setSaveErrorHandler(this.instantiationService.createInstance(DefaultSaveErrorHandler));\n\t\t}\n\n\t\t// Handle\n\t\tTextFileEditorModel.saveErrorHandler.onSaveError(error, this);\n\t}\n\n\tisDirty(): boolean {\n\t\treturn this.dirty;\n\t}\n\n\tgetLastSaveAttemptTime(): number {\n\t\treturn this.lastSaveAttemptTime;\n\t}\n\n\tgetETag(): string | null {\n\t\treturn this.lastResolvedDiskStat ? this.lastResolvedDiskStat.etag || null : null;\n\t}\n\n\thasState(state: ModelState): boolean {\n\t\tswitch (state) {\n\t\t\tcase ModelState.CONFLICT:\n\t\t\t\treturn this.inConflictMode;\n\t\t\tcase ModelState.DIRTY:\n\t\t\t\treturn this.dirty;\n\t\t\tcase ModelState.ERROR:\n\t\t\t\treturn this.inErrorMode;\n\t\t\tcase ModelState.ORPHAN:\n\t\t\t\treturn this.inOrphanMode;\n\t\t\tcase ModelState.PENDING_SAVE:\n\t\t\t\treturn this.saveSequentializer.hasPendingSave();\n\t\t\tcase ModelState.SAVED:\n\t\t\t\treturn !this.dirty;\n\t\t}\n\t}\n\n\tgetEncoding(): string {\n\t\treturn this.preferredEncoding || this.contentEncoding;\n\t}\n\n\tsetEncoding(encoding: string, mode: EncodingMode): void {\n\t\tif (!this.isNewEncoding(encoding)) {\n\t\t\treturn; // return early if the encoding is already the same\n\t\t}\n\n\t\t// Encode: Save with encoding\n\t\tif (mode === EncodingMode.Encode) {\n\t\t\tthis.updatePreferredEncoding(encoding);\n\n\t\t\t// Save\n\t\t\tif (!this.isDirty()) {\n\t\t\t\tthis.versionId++; // needs to increment because we change the model potentially\n\t\t\t\tthis.makeDirty();\n\t\t\t}\n\n\t\t\tif (!this.inConflictMode) {\n\t\t\t\tthis.save({ overwriteEncoding: true });\n\t\t\t}\n\t\t}\n\n\t\t// Decode: Load with encoding\n\t\telse {\n\t\t\tif (this.isDirty()) {\n\t\t\t\tthis.notificationService.info(nls.localize('saveFileFirst', \"The file is dirty. Please save it first before reopening it with another encoding.\"));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.updatePreferredEncoding(encoding);\n\n\t\t\t// Load\n\t\t\tthis.load({\n\t\t\t\tforceReadFromDisk: true\t// because encoding has changed\n\t\t\t});\n\t\t}\n\t}\n\n\tupdatePreferredEncoding(encoding: string): void {\n\t\tif (!this.isNewEncoding(encoding)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.preferredEncoding = encoding;\n\n\t\t// Emit\n\t\tthis._onDidStateChange.fire(StateChange.ENCODING);\n\t}\n\n\tprivate isNewEncoding(encoding: string): boolean {\n\t\tif (this.preferredEncoding === encoding) {\n\t\t\treturn false; // return early if the encoding is already the same\n\t\t}\n\n\t\tif (!this.preferredEncoding && this.contentEncoding === encoding) {\n\t\t\treturn false; // also return if we don't have a preferred encoding but the content encoding is already the same\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tisResolved(): boolean {\n\t\treturn !isUndefinedOrNull(this.lastResolvedDiskStat);\n\t}\n\n\tisReadonly(): boolean {\n\t\treturn !!(this.lastResolvedDiskStat && this.lastResolvedDiskStat.isReadonly);\n\t}\n\n\tisDisposed(): boolean {\n\t\treturn this.disposed;\n\t}\n\n\tgetResource(): URI {\n\t\treturn this.resource;\n\t}\n\n\tgetStat(): IFileStatWithMetadata {\n\t\treturn this.lastResolvedDiskStat;\n\t}\n\n\tdispose(): void {\n\t\tthis.disposed = true;\n\t\tthis.inConflictMode = false;\n\t\tthis.inOrphanMode = false;\n\t\tthis.inErrorMode = false;\n\n\t\tthis.createTextEditorModelPromise = null;\n\n\t\tthis.cancelPendingAutoSave();\n\n\t\tsuper.dispose();\n\t}\n}\n\ninterface IPendingSave {\n\tversionId: number;\n\tpromise: Promise<void>;\n}\n\ninterface ISaveOperation {\n\tpromise: Promise<void>;\n\tpromiseResolve: () => void;\n\tpromiseReject: (error: Error) => void;\n\trun: () => Promise<void>;\n}\n\nexport class SaveSequentializer {\n\tprivate _pendingSave?: IPendingSave;\n\tprivate _nextSave?: ISaveOperation;\n\n\thasPendingSave(versionId?: number): boolean {\n\t\tif (!this._pendingSave) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof versionId === 'number') {\n\t\t\treturn this._pendingSave.versionId === versionId;\n\t\t}\n\n\t\treturn !!this._pendingSave;\n\t}\n\n\tget pendingSave(): Promise<void> | undefined {\n\t\treturn this._pendingSave ? this._pendingSave.promise : undefined;\n\t}\n\n\tsetPending(versionId: number, promise: Promise<void>): Promise<void> {\n\t\tthis._pendingSave = { versionId, promise };\n\n\t\tpromise.then(() => this.donePending(versionId), () => this.donePending(versionId));\n\n\t\treturn promise;\n\t}\n\n\tprivate donePending(versionId: number): void {\n\t\tif (this._pendingSave && versionId === this._pendingSave.versionId) {\n\n\t\t\t// only set pending to done if the promise finished that is associated with that versionId\n\t\t\tthis._pendingSave = undefined;\n\n\t\t\t// schedule the next save now that we are free if we have any\n\t\t\tthis.triggerNextSave();\n\t\t}\n\t}\n\n\tprivate triggerNextSave(): void {\n\t\tif (this._nextSave) {\n\t\t\tconst saveOperation = this._nextSave;\n\t\t\tthis._nextSave = undefined;\n\n\t\t\t// Run next save and complete on the associated promise\n\t\t\tsaveOperation.run().then(saveOperation.promiseResolve, saveOperation.promiseReject);\n\t\t}\n\t}\n\n\tsetNext(run: () => Promise<void>): Promise<void> {\n\n\t\t// this is our first next save, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the save operation\n\t\t// has completed.\n\t\tif (!this._nextSave) {\n\t\t\tlet promiseResolve: () => void;\n\t\t\tlet promiseReject: (error: Error) => void;\n\t\t\tconst promise = new Promise<void>((resolve, reject) => {\n\t\t\t\tpromiseResolve = resolve;\n\t\t\t\tpromiseReject = reject;\n\t\t\t});\n\n\t\t\tthis._nextSave = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous next save, just overwrite it\n\t\telse {\n\t\t\tthis._nextSave.run = run;\n\t\t}\n\n\t\treturn this._nextSave.promise;\n\t}\n}\n\nclass DefaultSaveErrorHandler implements ISaveErrorHandler {\n\n\tconstructor(@INotificationService private readonly notificationService: INotificationService) { }\n\n\tonSaveError(error: any, model: TextFileEditorModel): void {\n\t\tthis.notificationService.error(nls.localize('genericSaveError', \"Failed to save '{0}': {1}\", basename(model.getResource()), toErrorMessage(error, false)));\n\t}\n}\n"]}]}