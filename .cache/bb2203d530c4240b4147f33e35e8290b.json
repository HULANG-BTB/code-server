{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/common/extensions.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/common/extensions.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar event_1 = require(\"vs/base/common/event\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar extensions_1 = require(\"vs/platform/extensions/common/extensions\");\nvar extensionManagementUtil_1 = require(\"vs/platform/extensionManagement/common/extensionManagementUtil\");\nexports.nullExtensionDescription = Object.freeze({\n    identifier: new extensions_1.ExtensionIdentifier('nullExtensionDescription'),\n    name: 'Null Extension Description',\n    version: '0.0.0',\n    publisher: 'vscode',\n    enableProposedApi: false,\n    engines: { vscode: '' },\n    extensionLocation: uri_1.URI.parse('void:location'),\n    isBuiltin: false,\n});\nexports.IExtensionService = instantiation_1.createDecorator('extensionService');\nvar MissingDependencyError = /** @class */ (function () {\n    function MissingDependencyError(dependency) {\n        this.dependency = dependency;\n    }\n    return MissingDependencyError;\n}());\nexports.MissingDependencyError = MissingDependencyError;\nvar ActivationTimes = /** @class */ (function () {\n    function ActivationTimes(startup, codeLoadingTime, activateCallTime, activateResolvedTime, activationEvent) {\n        this.startup = startup;\n        this.codeLoadingTime = codeLoadingTime;\n        this.activateCallTime = activateCallTime;\n        this.activateResolvedTime = activateResolvedTime;\n        this.activationEvent = activationEvent;\n    }\n    return ActivationTimes;\n}());\nexports.ActivationTimes = ActivationTimes;\nvar ExtensionPointContribution = /** @class */ (function () {\n    function ExtensionPointContribution(description, value) {\n        this.description = description;\n        this.value = value;\n    }\n    return ExtensionPointContribution;\n}());\nexports.ExtensionPointContribution = ExtensionPointContribution;\nexports.ExtensionHostLogFileName = 'exthost';\nfunction checkProposedApiEnabled(extension) {\n    if (!extension.enableProposedApi) {\n        throwProposedApiError(extension);\n    }\n}\nexports.checkProposedApiEnabled = checkProposedApiEnabled;\nfunction throwProposedApiError(extension) {\n    throw new Error(\"[\" + extension.identifier.value + \"]: Proposed API is only available when running out of dev or with the following command line switch: --enable-proposed-api \" + extension.identifier.value);\n}\nexports.throwProposedApiError = throwProposedApiError;\nfunction toExtension(extensionDescription) {\n    return {\n        type: extensionDescription.isBuiltin ? extensions_1.ExtensionType.System : extensions_1.ExtensionType.User,\n        identifier: { id: extensionManagementUtil_1.getGalleryExtensionId(extensionDescription.publisher, extensionDescription.name), uuid: extensionDescription.uuid },\n        manifest: extensionDescription,\n        location: extensionDescription.extensionLocation,\n    };\n}\nexports.toExtension = toExtension;\nvar NullExtensionService = /** @class */ (function () {\n    function NullExtensionService() {\n        this.onDidRegisterExtensions = event_1.Event.None;\n        this.onDidChangeExtensionsStatus = event_1.Event.None;\n        this.onDidChangeExtensions = event_1.Event.None;\n        this.onWillActivateByEvent = event_1.Event.None;\n        this.onDidChangeResponsiveChange = event_1.Event.None;\n    }\n    NullExtensionService.prototype.activateByEvent = function (_activationEvent) { return Promise.resolve(undefined); };\n    NullExtensionService.prototype.whenInstalledExtensionsRegistered = function () { return Promise.resolve(true); };\n    NullExtensionService.prototype.getExtensions = function () { return Promise.resolve([]); };\n    NullExtensionService.prototype.getExtension = function () { return Promise.resolve(undefined); };\n    NullExtensionService.prototype.readExtensionPointContributions = function (_extPoint) { return Promise.resolve(Object.create(null)); };\n    NullExtensionService.prototype.getExtensionsStatus = function () { return Object.create(null); };\n    NullExtensionService.prototype.canProfileExtensionHost = function () { return false; };\n    NullExtensionService.prototype.getInspectPort = function () { return 0; };\n    NullExtensionService.prototype.startExtensionHostProfile = function () { return Promise.resolve(Object.create(null)); };\n    NullExtensionService.prototype.restartExtensionHost = function () { };\n    NullExtensionService.prototype.startExtensionHost = function () { };\n    NullExtensionService.prototype.stopExtensionHost = function () { };\n    NullExtensionService.prototype.canAddExtension = function () { return false; };\n    NullExtensionService.prototype.canRemoveExtension = function () { return false; };\n    NullExtensionService.prototype._logOrShowMessage = function (_severity, _msg) { };\n    NullExtensionService.prototype._activateById = function (_extensionId, _activationEvent) { return Promise.resolve(); };\n    NullExtensionService.prototype._onWillActivateExtension = function (_extensionId) { };\n    NullExtensionService.prototype._onDidActivateExtension = function (_extensionId, _startup, _codeLoadingTime, _activateCallTime, _activateResolvedTime, _activationEvent) { };\n    NullExtensionService.prototype._onExtensionRuntimeError = function (_extensionId, _err) { };\n    NullExtensionService.prototype._onExtensionHostExit = function (code) { };\n    return NullExtensionService;\n}());\nexports.NullExtensionService = NullExtensionService;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/common/extensions.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/common/extensions.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport Severity from 'vs/base/common/severity';\nimport { URI } from 'vs/base/common/uri';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IExtensionPoint } from 'vs/workbench/services/extensions/common/extensionsRegistry';\nimport { ExtensionIdentifier, IExtension, ExtensionType, IExtensionDescription } from 'vs/platform/extensions/common/extensions';\nimport { getGalleryExtensionId } from 'vs/platform/extensionManagement/common/extensionManagementUtil';\n\nexport const nullExtensionDescription = Object.freeze(<IExtensionDescription>{\n\tidentifier: new ExtensionIdentifier('nullExtensionDescription'),\n\tname: 'Null Extension Description',\n\tversion: '0.0.0',\n\tpublisher: 'vscode',\n\tenableProposedApi: false,\n\tengines: { vscode: '' },\n\textensionLocation: URI.parse('void:location'),\n\tisBuiltin: false,\n});\n\nexport const IExtensionService = createDecorator<IExtensionService>('extensionService');\n\nexport interface IMessage {\n\ttype: Severity;\n\tmessage: string;\n\textensionId: ExtensionIdentifier;\n\textensionPointId: string;\n}\n\nexport interface IExtensionsStatus {\n\tmessages: IMessage[];\n\tactivationTimes: ActivationTimes | undefined;\n\truntimeErrors: Error[];\n}\n\nexport type ExtensionActivationError = string | MissingDependencyError;\nexport class MissingDependencyError {\n\tconstructor(readonly dependency: string) { }\n}\n\n/**\n * e.g.\n * ```\n * {\n *    startTime: 1511954813493000,\n *    endTime: 1511954835590000,\n *    deltas: [ 100, 1500, 123456, 1500, 100000 ],\n *    ids: [ 'idle', 'self', 'extension1', 'self', 'idle' ]\n * }\n * ```\n */\nexport interface IExtensionHostProfile {\n\t/**\n\t * Profiling start timestamp in microseconds.\n\t */\n\tstartTime: number;\n\t/**\n\t * Profiling end timestamp in microseconds.\n\t */\n\tendTime: number;\n\t/**\n\t * Duration of segment in microseconds.\n\t */\n\tdeltas: number[];\n\t/**\n\t * Segment identifier: extension id or one of the four known strings.\n\t */\n\tids: ProfileSegmentId[];\n\n\t/**\n\t * Get the information as a .cpuprofile.\n\t */\n\tdata: object;\n\n\t/**\n\t * Get the aggregated time per segmentId\n\t */\n\tgetAggregatedTimes(): Map<ProfileSegmentId, number>;\n}\n\n/**\n * Extension id or one of the four known program states.\n */\nexport type ProfileSegmentId = string | 'idle' | 'program' | 'gc' | 'self';\n\nexport class ActivationTimes {\n\tconstructor(\n\t\tpublic readonly startup: boolean,\n\t\tpublic readonly codeLoadingTime: number,\n\t\tpublic readonly activateCallTime: number,\n\t\tpublic readonly activateResolvedTime: number,\n\t\tpublic readonly activationEvent: string\n\t) {\n\t}\n}\n\nexport class ExtensionPointContribution<T> {\n\treadonly description: IExtensionDescription;\n\treadonly value: T;\n\n\tconstructor(description: IExtensionDescription, value: T) {\n\t\tthis.description = description;\n\t\tthis.value = value;\n\t}\n}\n\nexport const ExtensionHostLogFileName = 'exthost';\n\nexport interface IWillActivateEvent {\n\treadonly event: string;\n\treadonly activation: Promise<void>;\n}\n\nexport interface IResponsiveStateChangeEvent {\n\ttarget: ICpuProfilerTarget;\n\tisResponsive: boolean;\n}\n\nexport interface IExtensionService extends ICpuProfilerTarget {\n\t_serviceBrand: any;\n\n\t/**\n\t * An event emitted when extensions are registered after their extension points got handled.\n\t *\n\t * This event will also fire on startup to signal the installed extensions.\n\t *\n\t * @returns the extensions that got registered\n\t */\n\tonDidRegisterExtensions: Event<void>;\n\n\t/**\n\t * @event\n\t * Fired when extensions status changes.\n\t * The event contains the ids of the extensions that have changed.\n\t */\n\tonDidChangeExtensionsStatus: Event<ExtensionIdentifier[]>;\n\n\t/**\n\t * Fired when the available extensions change (i.e. when extensions are added or removed).\n\t */\n\tonDidChangeExtensions: Event<void>;\n\n\t/**\n\t * An event that is fired when activation happens.\n\t */\n\tonWillActivateByEvent: Event<IWillActivateEvent>;\n\n\t/**\n\t * An event that is fired when an extension host changes its\n\t * responsive-state.\n\t */\n\tonDidChangeResponsiveChange: Event<IResponsiveStateChangeEvent>;\n\n\t/**\n\t * Send an activation event and activate interested extensions.\n\t */\n\tactivateByEvent(activationEvent: string): Promise<void>;\n\n\t/**\n\t * An promise that resolves when the installed extensions are registered after\n\t * their extension points got handled.\n\t */\n\twhenInstalledExtensionsRegistered(): Promise<boolean>;\n\n\t/**\n\t * Return all registered extensions\n\t */\n\tgetExtensions(): Promise<IExtensionDescription[]>;\n\n\t/**\n\t * Return a specific extension\n\t * @param id An extension id\n\t */\n\tgetExtension(id: string): Promise<IExtensionDescription | undefined>;\n\n\t/**\n\t * Returns `true` if the given extension can be added. Otherwise `false`.\n\t * @param extension An extension\n\t */\n\tcanAddExtension(extension: IExtensionDescription): boolean;\n\n\t/**\n\t * Returns `true` if the given extension can be removed. Otherwise `false`.\n\t * @param extension An extension\n\t */\n\tcanRemoveExtension(extension: IExtensionDescription): boolean;\n\n\t/**\n\t * Read all contributions to an extension point.\n\t */\n\treadExtensionPointContributions<T>(extPoint: IExtensionPoint<T>): Promise<ExtensionPointContribution<T>[]>;\n\n\t/**\n\t * Get information about extensions status.\n\t */\n\tgetExtensionsStatus(): { [id: string]: IExtensionsStatus };\n\n\t/**\n\t * Return the inspect port or 0.\n\t */\n\tgetInspectPort(): number;\n\n\t/**\n\t * Restarts the extension host.\n\t */\n\trestartExtensionHost(): void;\n\n\t/**\n\t * Starts the extension host.\n\t */\n\tstartExtensionHost(): void;\n\n\t/**\n\t * Stops the extension host.\n\t */\n\tstopExtensionHost(): void;\n\n\t_logOrShowMessage(severity: Severity, msg: string): void;\n\t_activateById(extensionId: ExtensionIdentifier, activationEvent: string): Promise<void>;\n\t_onWillActivateExtension(extensionId: ExtensionIdentifier): void;\n\t_onDidActivateExtension(extensionId: ExtensionIdentifier, startup: boolean, codeLoadingTime: number, activateCallTime: number, activateResolvedTime: number, activationEvent: string): void;\n\t_onExtensionRuntimeError(extensionId: ExtensionIdentifier, err: Error): void;\n\t_onExtensionHostExit(code: number): void;\n}\n\nexport interface ICpuProfilerTarget {\n\n\t/**\n\t * Check if the extension host can be profiled.\n\t */\n\tcanProfileExtensionHost(): boolean;\n\n\t/**\n\t * Begin an extension host process profile session.\n\t */\n\tstartExtensionHostProfile(): Promise<ProfileSession>;\n}\n\nexport interface ProfileSession {\n\tstop(): Promise<IExtensionHostProfile>;\n}\n\nexport function checkProposedApiEnabled(extension: IExtensionDescription): void {\n\tif (!extension.enableProposedApi) {\n\t\tthrowProposedApiError(extension);\n\t}\n}\n\nexport function throwProposedApiError(extension: IExtensionDescription): never {\n\tthrow new Error(`[${extension.identifier.value}]: Proposed API is only available when running out of dev or with the following command line switch: --enable-proposed-api ${extension.identifier.value}`);\n}\n\nexport function toExtension(extensionDescription: IExtensionDescription): IExtension {\n\treturn {\n\t\ttype: extensionDescription.isBuiltin ? ExtensionType.System : ExtensionType.User,\n\t\tidentifier: { id: getGalleryExtensionId(extensionDescription.publisher, extensionDescription.name), uuid: extensionDescription.uuid },\n\t\tmanifest: extensionDescription,\n\t\tlocation: extensionDescription.extensionLocation,\n\t};\n}\n\n\nexport class NullExtensionService implements IExtensionService {\n\t_serviceBrand: any;\n\tonDidRegisterExtensions: Event<void> = Event.None;\n\tonDidChangeExtensionsStatus: Event<ExtensionIdentifier[]> = Event.None;\n\tonDidChangeExtensions: Event<void> = Event.None;\n\tonWillActivateByEvent: Event<IWillActivateEvent> = Event.None;\n\tonDidChangeResponsiveChange: Event<IResponsiveStateChangeEvent> = Event.None;\n\tactivateByEvent(_activationEvent: string): Promise<void> { return Promise.resolve(undefined); }\n\twhenInstalledExtensionsRegistered(): Promise<boolean> { return Promise.resolve(true); }\n\tgetExtensions(): Promise<IExtensionDescription[]> { return Promise.resolve([]); }\n\tgetExtension() { return Promise.resolve(undefined); }\n\treadExtensionPointContributions<T>(_extPoint: IExtensionPoint<T>): Promise<ExtensionPointContribution<T>[]> { return Promise.resolve(Object.create(null)); }\n\tgetExtensionsStatus(): { [id: string]: IExtensionsStatus; } { return Object.create(null); }\n\tcanProfileExtensionHost(): boolean { return false; }\n\tgetInspectPort(): number { return 0; }\n\tstartExtensionHostProfile(): Promise<ProfileSession> { return Promise.resolve(Object.create(null)); }\n\trestartExtensionHost(): void { }\n\tstartExtensionHost(): void { }\n\tstopExtensionHost(): void { }\n\tcanAddExtension(): boolean { return false; }\n\tcanRemoveExtension(): boolean { return false; }\n\t_logOrShowMessage(_severity: Severity, _msg: string): void { }\n\t_activateById(_extensionId: ExtensionIdentifier, _activationEvent: string): Promise<void> { return Promise.resolve(); }\n\t_onWillActivateExtension(_extensionId: ExtensionIdentifier): void { }\n\t_onDidActivateExtension(_extensionId: ExtensionIdentifier, _startup: boolean, _codeLoadingTime: number, _activateCallTime: number, _activateResolvedTime: number, _activationEvent: string): void { }\n\t_onExtensionRuntimeError(_extensionId: ExtensionIdentifier, _err: Error): void { }\n\t_onExtensionHostExit(code: number): void { }\n}\n"]}]}