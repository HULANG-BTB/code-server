{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/history/browser/history.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/history/browser/history.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar errors_1 = require(\"vs/base/common/errors\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar editor_1 = require(\"vs/workbench/common/editor\");\nvar editorService_1 = require(\"vs/workbench/services/editor/common/editorService\");\nvar history_1 = require(\"vs/workbench/services/history/common/history\");\nvar files_1 = require(\"vs/platform/files/common/files\");\nvar selection_1 = require(\"vs/editor/common/core/selection\");\nvar workspace_1 = require(\"vs/platform/workspace/common/workspace\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar storage_1 = require(\"vs/platform/storage/common/storage\");\nvar platform_1 = require(\"vs/platform/registry/common/platform\");\nvar event_1 = require(\"vs/base/common/event\");\nvar configuration_1 = require(\"vs/platform/configuration/common/configuration\");\nvar editorGroupsService_1 = require(\"vs/workbench/services/editor/common/editorGroupsService\");\nvar windows_1 = require(\"vs/platform/windows/common/windows\");\nvar editorBrowser_1 = require(\"vs/editor/browser/editorBrowser\");\nvar search_1 = require(\"vs/workbench/services/search/common/search\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar resources_1 = require(\"vs/workbench/common/resources\");\nvar layoutService_1 = require(\"vs/workbench/services/layout/browser/layoutService\");\nvar contextkey_1 = require(\"vs/platform/contextkey/common/contextkey\");\nvar arrays_1 = require(\"vs/base/common/arrays\");\nvar extensions_1 = require(\"vs/platform/instantiation/common/extensions\");\nvar types_1 = require(\"vs/base/common/types\");\n/**\n * Stores the selection & view state of an editor and allows to compare it to other selection states.\n */\nvar TextEditorState = /** @class */ (function () {\n    function TextEditorState(_editorInput, _selection) {\n        this._editorInput = _editorInput;\n        this._selection = _selection;\n        this.textEditorSelection = selection_1.Selection.isISelection(_selection) ? {\n            startLineNumber: _selection.startLineNumber,\n            startColumn: _selection.startColumn\n        } : undefined;\n    }\n    Object.defineProperty(TextEditorState.prototype, \"editorInput\", {\n        get: function () {\n            return this._editorInput;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TextEditorState.prototype, \"selection\", {\n        get: function () {\n            return this.textEditorSelection;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TextEditorState.prototype.justifiesNewPushState = function (other, event) {\n        if (event && event.source === 'api') {\n            return true; // always let API source win (e.g. \"Go to definition\" should add a history entry)\n        }\n        if (!this._editorInput.matches(other._editorInput)) {\n            return true; // different editor inputs\n        }\n        if (!selection_1.Selection.isISelection(this._selection) || !selection_1.Selection.isISelection(other._selection)) {\n            return true; // unknown selections\n        }\n        var thisLineNumber = Math.min(this._selection.selectionStartLineNumber, this._selection.positionLineNumber);\n        var otherLineNumber = Math.min(other._selection.selectionStartLineNumber, other._selection.positionLineNumber);\n        if (Math.abs(thisLineNumber - otherLineNumber) < TextEditorState.EDITOR_SELECTION_THRESHOLD) {\n            return false; // ignore selection changes in the range of EditorState.EDITOR_SELECTION_THRESHOLD lines\n        }\n        return true;\n    };\n    TextEditorState.EDITOR_SELECTION_THRESHOLD = 10; // number of lines to move in editor to justify for new state\n    return TextEditorState;\n}());\nexports.TextEditorState = TextEditorState;\nvar HistoryService = /** @class */ (function (_super) {\n    tslib_1.__extends(HistoryService, _super);\n    function HistoryService(editorService, editorGroupService, contextService, storageService, configurationService, fileService, windowService, instantiationService, layoutService, contextKeyService) {\n        var _this = _super.call(this) || this;\n        _this.editorService = editorService;\n        _this.editorGroupService = editorGroupService;\n        _this.contextService = contextService;\n        _this.storageService = storageService;\n        _this.configurationService = configurationService;\n        _this.fileService = fileService;\n        _this.windowService = windowService;\n        _this.instantiationService = instantiationService;\n        _this.layoutService = layoutService;\n        _this.contextKeyService = contextKeyService;\n        _this.editorHistoryListeners = new Map();\n        _this.editorStackListeners = new Map();\n        _this.activeEditorListeners = [];\n        _this.canNavigateBackContextKey = (new contextkey_1.RawContextKey('canNavigateBack', false)).bindTo(_this.contextKeyService);\n        _this.canNavigateForwardContextKey = (new contextkey_1.RawContextKey('canNavigateForward', false)).bindTo(_this.contextKeyService);\n        _this.canNavigateToLastEditLocationContextKey = (new contextkey_1.RawContextKey('canNavigateToLastEditLocation', false)).bindTo(_this.contextKeyService);\n        _this.fileInputFactory = platform_1.Registry.as(editor_1.Extensions.EditorInputFactories).getFileInputFactory();\n        _this.index = -1;\n        _this.lastIndex = -1;\n        _this.stack = [];\n        _this.recentlyClosedFiles = [];\n        _this.loaded = false;\n        _this.resourceFilter = _this._register(instantiationService.createInstance(resources_1.ResourceGlobMatcher, function (root) { return _this.getExcludes(root); }, function (event) { return event.affectsConfiguration(files_1.FILES_EXCLUDE_CONFIG) || event.affectsConfiguration('search.exclude'); }));\n        _this.registerListeners();\n        return _this;\n    }\n    HistoryService.prototype.getExcludes = function (root) {\n        var scope = root ? { resource: root } : undefined;\n        return search_1.getExcludes(scope ? this.configurationService.getValue(scope) : this.configurationService.getValue());\n    };\n    HistoryService.prototype.registerListeners = function () {\n        var _this = this;\n        this._register(this.editorService.onDidActiveEditorChange(function () { return _this.onActiveEditorChanged(); }));\n        this._register(this.editorService.onDidOpenEditorFail(function (event) { return _this.remove(event.editor); }));\n        this._register(this.editorService.onDidCloseEditor(function (event) { return _this.onEditorClosed(event); }));\n        this._register(this.storageService.onWillSaveState(function () { return _this.saveState(); }));\n        this._register(this.fileService.onFileChanges(function (event) { return _this.onFileChanges(event); }));\n        this._register(this.resourceFilter.onExpressionChange(function () { return _this.handleExcludesChange(); }));\n        // if the service is created late enough that an editor is already opened\n        // make sure to trigger the onActiveEditorChanged() to track the editor\n        // properly (fixes https://github.com/Microsoft/vscode/issues/59908)\n        if (this.editorService.activeControl) {\n            this.onActiveEditorChanged();\n        }\n    };\n    HistoryService.prototype.onActiveEditorChanged = function () {\n        var _this = this;\n        var activeControl = this.editorService.activeControl;\n        if (this.lastActiveEditor && this.matchesEditor(this.lastActiveEditor, activeControl)) {\n            return; // return if the active editor is still the same\n        }\n        // Remember as last active editor (can be undefined if none opened)\n        this.lastActiveEditor = activeControl && activeControl.input && activeControl.group ? { editor: activeControl.input, groupId: activeControl.group.id } : undefined;\n        // Dispose old listeners\n        lifecycle_1.dispose(this.activeEditorListeners);\n        this.activeEditorListeners = [];\n        // Propagate to history\n        this.handleActiveEditorChange(activeControl);\n        // Apply listener for selection changes if this is a text editor\n        var activeTextEditorWidget = editorBrowser_1.getCodeEditor(this.editorService.activeTextEditorWidget);\n        var activeEditor = this.editorService.activeEditor;\n        if (activeTextEditorWidget) {\n            // Debounce the event with a timeout of 0ms so that multiple calls to\n            // editor.setSelection() are folded into one. We do not want to record\n            // subsequent history navigations for such API calls.\n            this.activeEditorListeners.push(event_1.Event.debounce(activeTextEditorWidget.onDidChangeCursorPosition, function (last, event) { return event; }, 0)((function (event) {\n                _this.handleEditorSelectionChangeEvent(activeControl, event);\n            })));\n            // Track the last edit location by tracking model content change events\n            // Use a debouncer to make sure to capture the correct cursor position\n            // after the model content has changed.\n            this.activeEditorListeners.push(event_1.Event.debounce(activeTextEditorWidget.onDidChangeModelContent, function (last, event) { return event; }, 0)((function (event) { return _this.rememberLastEditLocation(activeEditor, activeTextEditorWidget); })));\n        }\n    };\n    HistoryService.prototype.rememberLastEditLocation = function (activeEditor, activeTextEditorWidget) {\n        this.lastEditLocation = { input: activeEditor };\n        this.canNavigateToLastEditLocationContextKey.set(true);\n        var position = activeTextEditorWidget.getPosition();\n        if (position) {\n            this.lastEditLocation.selection = {\n                startLineNumber: position.lineNumber,\n                startColumn: position.column\n            };\n        }\n    };\n    HistoryService.prototype.matchesEditor = function (identifier, editor) {\n        if (!editor || !editor.group) {\n            return false;\n        }\n        if (identifier.groupId !== editor.group.id) {\n            return false;\n        }\n        return identifier.editor.matches(editor.input);\n    };\n    HistoryService.prototype.onFileChanges = function (e) {\n        if (e.gotDeleted()) {\n            this.remove(e); // remove from history files that got deleted or moved\n        }\n    };\n    HistoryService.prototype.onEditorClosed = function (event) {\n        // Track closing of editor to support to reopen closed editors (unless editor was replaced)\n        if (!event.replaced) {\n            var resource = event.editor ? event.editor.getResource() : undefined;\n            var supportsReopen = resource && this.fileService.canHandleResource(resource); // we only support file'ish things to reopen\n            if (resource && supportsReopen) {\n                // Remove all inputs matching and add as last recently closed\n                this.removeFromRecentlyClosedFiles(event.editor);\n                this.recentlyClosedFiles.push({ resource: resource, index: event.index });\n                // Bounding\n                if (this.recentlyClosedFiles.length > HistoryService.MAX_RECENTLY_CLOSED_EDITORS) {\n                    this.recentlyClosedFiles.shift();\n                }\n            }\n        }\n    };\n    HistoryService.prototype.reopenLastClosedEditor = function () {\n        var _this = this;\n        this.ensureHistoryLoaded();\n        var lastClosedFile = this.recentlyClosedFiles.pop();\n        while (lastClosedFile && this.isFileOpened(lastClosedFile.resource, this.editorGroupService.activeGroup)) {\n            lastClosedFile = this.recentlyClosedFiles.pop(); // pop until we find a file that is not opened\n        }\n        if (lastClosedFile) {\n            this.editorService.openEditor({ resource: lastClosedFile.resource, options: { pinned: true, index: lastClosedFile.index } }).then(function (editor) {\n                // Fix for https://github.com/Microsoft/vscode/issues/67882\n                // If opening of the editor fails, make sure to try the next one\n                // but make sure to remove this one from the list to prevent\n                // endless loops.\n                if (!editor) {\n                    _this.recentlyClosedFiles.pop();\n                    _this.reopenLastClosedEditor();\n                }\n            });\n        }\n    };\n    HistoryService.prototype.openLastEditLocation = function () {\n        if (this.lastEditLocation) {\n            this.doNavigate(this.lastEditLocation, true);\n        }\n    };\n    HistoryService.prototype.forward = function (acrossEditors) {\n        if (this.stack.length > this.index + 1) {\n            if (acrossEditors) {\n                this.doForwardAcrossEditors();\n            }\n            else {\n                this.doForwardInEditors();\n            }\n        }\n    };\n    HistoryService.prototype.doForwardInEditors = function () {\n        this.setIndex(this.index + 1);\n        this.navigate();\n    };\n    HistoryService.prototype.setIndex = function (value) {\n        this.lastIndex = this.index;\n        this.index = value;\n        this.updateContextKeys();\n    };\n    HistoryService.prototype.doForwardAcrossEditors = function () {\n        var currentIndex = this.index;\n        var currentEntry = this.stack[this.index];\n        // Find the next entry that does not match our current entry\n        while (this.stack.length > currentIndex + 1) {\n            currentIndex++;\n            var previousEntry = this.stack[currentIndex];\n            if (!this.matches(currentEntry.input, previousEntry.input)) {\n                this.setIndex(currentIndex);\n                this.navigate(true /* across editors */);\n                break;\n            }\n        }\n    };\n    HistoryService.prototype.back = function (acrossEditors) {\n        if (this.index > 0) {\n            if (acrossEditors) {\n                this.doBackAcrossEditors();\n            }\n            else {\n                this.doBackInEditors();\n            }\n        }\n    };\n    HistoryService.prototype.last = function () {\n        if (this.lastIndex === -1) {\n            this.back();\n        }\n        else {\n            this.setIndex(this.lastIndex);\n            this.navigate();\n        }\n    };\n    HistoryService.prototype.doBackInEditors = function () {\n        this.setIndex(this.index - 1);\n        this.navigate();\n    };\n    HistoryService.prototype.doBackAcrossEditors = function () {\n        var currentIndex = this.index;\n        var currentEntry = this.stack[this.index];\n        // Find the next previous entry that does not match our current entry\n        while (currentIndex > 0) {\n            currentIndex--;\n            var previousEntry = this.stack[currentIndex];\n            if (!this.matches(currentEntry.input, previousEntry.input)) {\n                this.setIndex(currentIndex);\n                this.navigate(true /* across editors */);\n                break;\n            }\n        }\n    };\n    HistoryService.prototype.clear = function () {\n        this.ensureHistoryLoaded();\n        // Navigation (next, previous)\n        this.index = -1;\n        this.lastIndex = -1;\n        this.stack.splice(0);\n        this.editorStackListeners.forEach(function (listeners) { return lifecycle_1.dispose(listeners); });\n        this.editorStackListeners.clear();\n        // Closed files\n        this.recentlyClosedFiles = [];\n        // History\n        this.clearRecentlyOpened();\n        this.updateContextKeys();\n    };\n    HistoryService.prototype.clearRecentlyOpened = function () {\n        this.history = [];\n        this.editorHistoryListeners.forEach(function (listeners) { return lifecycle_1.dispose(listeners); });\n        this.editorHistoryListeners.clear();\n    };\n    HistoryService.prototype.updateContextKeys = function () {\n        this.canNavigateBackContextKey.set(this.stack.length > 0 && this.index > 0);\n        this.canNavigateForwardContextKey.set(this.stack.length > 0 && this.index < this.stack.length - 1);\n    };\n    HistoryService.prototype.navigate = function (acrossEditors) {\n        var _this = this;\n        this.navigatingInStack = true;\n        this.doNavigate(this.stack[this.index], !acrossEditors).finally(function () { return _this.navigatingInStack = false; });\n    };\n    HistoryService.prototype.doNavigate = function (location, withSelection) {\n        var options = {\n            revealIfOpened: true // support to navigate across editor groups\n        };\n        // Unless we navigate across editors, support selection and\n        // minimize scrolling by setting revealInCenterIfOutsideViewport\n        if (location.selection && withSelection) {\n            options.selection = location.selection;\n            options.revealInCenterIfOutsideViewport = true;\n        }\n        if (location.input instanceof editor_1.EditorInput) {\n            return this.editorService.openEditor(location.input, options);\n        }\n        return this.editorService.openEditor({ resource: location.input.resource, options: options });\n    };\n    HistoryService.prototype.handleEditorSelectionChangeEvent = function (editor, event) {\n        this.handleEditorEventInStack(editor, event);\n    };\n    HistoryService.prototype.handleActiveEditorChange = function (editor) {\n        this.handleEditorEventInHistory(editor);\n        this.handleEditorEventInStack(editor);\n    };\n    HistoryService.prototype.handleEditorEventInHistory = function (editor) {\n        var _this = this;\n        var input = editor ? editor.input : undefined;\n        // Ensure we have at least a name to show and not configured to exclude input\n        if (!input || !input.getName() || !this.include(input)) {\n            return;\n        }\n        this.ensureHistoryLoaded();\n        var historyInput = this.preferResourceInput(input);\n        // Remove any existing entry and add to the beginning\n        this.removeFromHistory(input);\n        this.history.unshift(historyInput);\n        // Respect max entries setting\n        if (this.history.length > HistoryService.MAX_HISTORY_ITEMS) {\n            this.clearOnEditorDispose(this.history.pop(), this.editorHistoryListeners);\n        }\n        // Remove this from the history unless the history input is a resource\n        // that can easily be restored even when the input gets disposed\n        if (historyInput instanceof editor_1.EditorInput) {\n            this.onEditorDispose(historyInput, function () { return _this.removeFromHistory(historyInput); }, this.editorHistoryListeners);\n        }\n    };\n    HistoryService.prototype.onEditorDispose = function (editor, listener, mapEditorToDispose) {\n        var toDispose = event_1.Event.once(editor.onDispose)(function () { return listener(); });\n        var disposables = mapEditorToDispose.get(editor);\n        if (!disposables) {\n            disposables = [];\n            mapEditorToDispose.set(editor, disposables);\n        }\n        disposables.push(toDispose);\n    };\n    HistoryService.prototype.clearOnEditorDispose = function (editor, mapEditorToDispose) {\n        if (editor instanceof editor_1.EditorInput) {\n            var disposables = mapEditorToDispose.get(editor);\n            if (disposables) {\n                lifecycle_1.dispose(disposables);\n                mapEditorToDispose.delete(editor);\n            }\n        }\n    };\n    HistoryService.prototype.include = function (input) {\n        if (input instanceof editor_1.EditorInput) {\n            return true; // include any non files\n        }\n        var resourceInput = input;\n        return !this.resourceFilter.matches(resourceInput.resource);\n    };\n    HistoryService.prototype.handleExcludesChange = function () {\n        this.removeExcludedFromHistory();\n    };\n    HistoryService.prototype.remove = function (arg1) {\n        this.removeFromHistory(arg1);\n        this.removeFromStack(arg1);\n        this.removeFromRecentlyClosedFiles(arg1);\n        this.removeFromRecentlyOpened(arg1);\n    };\n    HistoryService.prototype.removeExcludedFromHistory = function () {\n        var _this = this;\n        this.ensureHistoryLoaded();\n        this.history = this.history.filter(function (e) {\n            var include = _this.include(e);\n            // Cleanup any listeners associated with the input when removing from history\n            if (!include) {\n                _this.clearOnEditorDispose(e, _this.editorHistoryListeners);\n            }\n            return include;\n        });\n    };\n    HistoryService.prototype.removeFromHistory = function (arg1) {\n        var _this = this;\n        this.ensureHistoryLoaded();\n        this.history = this.history.filter(function (e) {\n            var matches = _this.matches(arg1, e);\n            // Cleanup any listeners associated with the input when removing from history\n            if (matches) {\n                _this.clearOnEditorDispose(arg1, _this.editorHistoryListeners);\n            }\n            return !matches;\n        });\n    };\n    HistoryService.prototype.handleEditorEventInStack = function (control, event) {\n        var codeEditor = control ? editorBrowser_1.getCodeEditor(control.getControl()) : undefined;\n        // treat editor changes that happen as part of stack navigation specially\n        // we do not want to add a new stack entry as a matter of navigating the\n        // stack but we need to keep our currentTextEditorState up to date with\n        // the navigtion that occurs.\n        if (this.navigatingInStack) {\n            if (codeEditor && control && control.input) {\n                this.currentTextEditorState = new TextEditorState(control.input, codeEditor.getSelection());\n            }\n            else {\n                this.currentTextEditorState = null; // we navigated to a non text editor\n            }\n        }\n        // normal navigation not part of history navigation\n        else {\n            // navigation inside text editor\n            if (codeEditor && control && control.input) {\n                this.handleTextEditorEvent(control, codeEditor, event);\n            }\n            // navigation to non-text editor\n            else {\n                this.currentTextEditorState = null; // at this time we have no active text editor view state\n                if (control && control.input) {\n                    this.handleNonTextEditorEvent(control);\n                }\n            }\n        }\n    };\n    HistoryService.prototype.handleTextEditorEvent = function (editor, editorControl, event) {\n        if (!editor.input) {\n            return;\n        }\n        var stateCandidate = new TextEditorState(editor.input, editorControl.getSelection());\n        // Add to stack if we dont have a current state or this new state justifies a push\n        if (!this.currentTextEditorState || this.currentTextEditorState.justifiesNewPushState(stateCandidate, event)) {\n            this.add(editor.input, stateCandidate.selection);\n        }\n        // Otherwise we replace the current stack entry with this one\n        else {\n            this.replace(editor.input, stateCandidate.selection);\n        }\n        // Update our current text editor state\n        this.currentTextEditorState = stateCandidate;\n    };\n    HistoryService.prototype.handleNonTextEditorEvent = function (editor) {\n        if (!editor.input) {\n            return;\n        }\n        var currentStack = this.stack[this.index];\n        if (currentStack && this.matches(editor.input, currentStack.input)) {\n            return; // do not push same editor input again\n        }\n        this.add(editor.input);\n    };\n    HistoryService.prototype.add = function (input, selection) {\n        if (!this.navigatingInStack) {\n            this.addOrReplaceInStack(input, selection);\n        }\n    };\n    HistoryService.prototype.replace = function (input, selection) {\n        if (!this.navigatingInStack) {\n            this.addOrReplaceInStack(input, selection, true /* force replace */);\n        }\n    };\n    HistoryService.prototype.addOrReplaceInStack = function (input, selection, forceReplace) {\n        var _this = this;\n        // Overwrite an entry in the stack if we have a matching input that comes\n        // with editor options to indicate that this entry is more specific. Also\n        // prevent entries that have the exact same options. Finally, Overwrite\n        // entries if we detect that the change came in very fast which indicates\n        // that it was not coming in from a user change but rather rapid programmatic\n        // changes. We just take the last of the changes to not cause too many entries\n        // on the stack.\n        // We can also be instructed to force replace the last entry.\n        var replace = false;\n        var currentEntry = this.stack[this.index];\n        if (currentEntry) {\n            if (forceReplace) {\n                replace = true; // replace if we are forced to\n            }\n            else if (this.matches(input, currentEntry.input) && this.sameSelection(currentEntry.selection, selection)) {\n                replace = true; // replace if the input is the same as the current one and the selection as well\n            }\n        }\n        var stackInput = this.preferResourceInput(input);\n        var entry = { input: stackInput, selection: selection };\n        // Replace at current position\n        var removedEntries = [];\n        if (replace) {\n            removedEntries.push(this.stack[this.index]);\n            this.stack[this.index] = entry;\n        }\n        // Add to stack at current position\n        else {\n            // If we are not at the end of history, we remove anything after\n            if (this.stack.length > this.index + 1) {\n                for (var i = this.index + 1; i < this.stack.length; i++) {\n                    removedEntries.push(this.stack[i]);\n                }\n                this.stack = this.stack.slice(0, this.index + 1);\n            }\n            // Insert entry at index\n            this.stack.splice(this.index + 1, 0, entry);\n            // Check for limit\n            if (this.stack.length > HistoryService.MAX_STACK_ITEMS) {\n                removedEntries.push(this.stack.shift()); // remove first\n                if (this.lastIndex >= 0) {\n                    this.lastIndex--;\n                }\n            }\n            else {\n                this.setIndex(this.index + 1);\n            }\n        }\n        // Clear editor listeners from removed entries\n        removedEntries.forEach(function (removedEntry) { return _this.clearOnEditorDispose(removedEntry.input, _this.editorStackListeners); });\n        // Remove this from the stack unless the stack input is a resource\n        // that can easily be restored even when the input gets disposed\n        if (stackInput instanceof editor_1.EditorInput) {\n            this.onEditorDispose(stackInput, function () { return _this.removeFromStack(stackInput); }, this.editorStackListeners);\n        }\n        // Context\n        this.updateContextKeys();\n    };\n    HistoryService.prototype.preferResourceInput = function (input) {\n        if (this.fileInputFactory.isFileInput(input)) {\n            return { resource: input.getResource() };\n        }\n        return input;\n    };\n    HistoryService.prototype.sameSelection = function (selectionA, selectionB) {\n        if (!selectionA && !selectionB) {\n            return true;\n        }\n        if (!selectionA || !selectionB) {\n            return false;\n        }\n        return selectionA.startLineNumber === selectionB.startLineNumber; // we consider the history entry same if we are on the same line\n    };\n    HistoryService.prototype.removeFromStack = function (arg1) {\n        var _this = this;\n        this.stack = this.stack.filter(function (e) {\n            var matches = _this.matches(arg1, e.input);\n            // Cleanup any listeners associated with the input when removing\n            if (matches) {\n                _this.clearOnEditorDispose(arg1, _this.editorStackListeners);\n            }\n            return !matches;\n        });\n        this.index = this.stack.length - 1; // reset index\n        this.lastIndex = -1;\n        this.updateContextKeys();\n    };\n    HistoryService.prototype.removeFromRecentlyClosedFiles = function (arg1) {\n        var _this = this;\n        this.recentlyClosedFiles = this.recentlyClosedFiles.filter(function (e) { return !_this.matchesFile(e.resource, arg1); });\n    };\n    HistoryService.prototype.removeFromRecentlyOpened = function (arg1) {\n        if (arg1 instanceof editor_1.EditorInput || arg1 instanceof files_1.FileChangesEvent) {\n            return; // for now do not delete from file events since recently open are likely out of workspace files for which there are no delete events\n        }\n        var input = arg1;\n        this.windowService.removeFromRecentlyOpened([input.resource]);\n    };\n    HistoryService.prototype.isFileOpened = function (resource, group) {\n        var _this = this;\n        if (!group) {\n            return false;\n        }\n        if (!this.editorService.isOpen({ resource: resource }, group)) {\n            return false; // fast check\n        }\n        return group.editors.some(function (e) { return _this.matchesFile(resource, e); });\n    };\n    HistoryService.prototype.matches = function (arg1, inputB) {\n        if (arg1 instanceof files_1.FileChangesEvent) {\n            if (inputB instanceof editor_1.EditorInput) {\n                return false; // we only support this for IResourceInput\n            }\n            var resourceInputB_1 = inputB;\n            return arg1.contains(resourceInputB_1.resource, files_1.FileChangeType.DELETED);\n        }\n        if (arg1 instanceof editor_1.EditorInput && inputB instanceof editor_1.EditorInput) {\n            return arg1.matches(inputB);\n        }\n        if (arg1 instanceof editor_1.EditorInput) {\n            return this.matchesFile(inputB.resource, arg1);\n        }\n        if (inputB instanceof editor_1.EditorInput) {\n            return this.matchesFile(arg1.resource, inputB);\n        }\n        var resourceInputA = arg1;\n        var resourceInputB = inputB;\n        return resourceInputA && resourceInputB && resourceInputA.resource.toString() === resourceInputB.resource.toString();\n    };\n    HistoryService.prototype.matchesFile = function (resource, arg2) {\n        if (arg2 instanceof files_1.FileChangesEvent) {\n            return arg2.contains(resource, files_1.FileChangeType.DELETED);\n        }\n        if (arg2 instanceof editor_1.EditorInput) {\n            var inputResource = arg2.getResource();\n            if (!inputResource) {\n                return false;\n            }\n            if (this.layoutService.isRestored() && !this.fileService.canHandleResource(inputResource)) {\n                return false; // make sure to only check this when workbench has restored (for https://github.com/Microsoft/vscode/issues/48275)\n            }\n            return inputResource.toString() === resource.toString();\n        }\n        var resourceInput = arg2;\n        return resourceInput && resourceInput.resource.toString() === resource.toString();\n    };\n    HistoryService.prototype.getHistory = function () {\n        this.ensureHistoryLoaded();\n        return this.history.slice(0);\n    };\n    HistoryService.prototype.ensureHistoryLoaded = function () {\n        if (!this.loaded) {\n            this.loadHistory();\n        }\n        this.loaded = true;\n    };\n    HistoryService.prototype.saveState = function () {\n        if (!this.history) {\n            return; // nothing to save because history was not used\n        }\n        var registry = platform_1.Registry.as(editor_1.Extensions.EditorInputFactories);\n        var entries = arrays_1.coalesce(this.history.map(function (input) {\n            // Editor input: try via factory\n            if (input instanceof editor_1.EditorInput) {\n                var factory = registry.getEditorInputFactory(input.getTypeId());\n                if (factory) {\n                    var deserialized = factory.serialize(input);\n                    if (deserialized) {\n                        return { editorInputJSON: { typeId: input.getTypeId(), deserialized: deserialized } };\n                    }\n                }\n            }\n            // File resource: via URI.toJSON()\n            else {\n                return { resourceJSON: input.resource.toJSON() };\n            }\n            return undefined;\n        }));\n        this.storageService.store(HistoryService.STORAGE_KEY, JSON.stringify(entries), storage_1.StorageScope.WORKSPACE);\n    };\n    HistoryService.prototype.loadHistory = function () {\n        var _this = this;\n        var entries = [];\n        var entriesRaw = this.storageService.get(HistoryService.STORAGE_KEY, storage_1.StorageScope.WORKSPACE);\n        if (entriesRaw) {\n            entries = arrays_1.coalesce(JSON.parse(entriesRaw));\n        }\n        var registry = platform_1.Registry.as(editor_1.Extensions.EditorInputFactories);\n        this.history = arrays_1.coalesce(entries.map(function (entry) {\n            try {\n                return _this.safeLoadHistoryEntry(registry, entry);\n            }\n            catch (error) {\n                errors_1.onUnexpectedError(error);\n                return undefined; // https://github.com/Microsoft/vscode/issues/60960\n            }\n        }));\n    };\n    HistoryService.prototype.safeLoadHistoryEntry = function (registry, entry) {\n        var _this = this;\n        var serializedEditorHistoryEntry = entry;\n        // File resource: via URI.revive()\n        if (serializedEditorHistoryEntry.resourceJSON) {\n            return { resource: uri_1.URI.revive(serializedEditorHistoryEntry.resourceJSON) };\n        }\n        // Editor input: via factory\n        var editorInputJSON = serializedEditorHistoryEntry.editorInputJSON;\n        if (editorInputJSON && editorInputJSON.deserialized) {\n            var factory = registry.getEditorInputFactory(editorInputJSON.typeId);\n            if (factory) {\n                var input_1 = factory.deserialize(this.instantiationService, editorInputJSON.deserialized);\n                if (input_1) {\n                    this.onEditorDispose(input_1, function () { return _this.removeFromHistory(input_1); }, this.editorHistoryListeners);\n                }\n                return types_1.withNullAsUndefined(input_1);\n            }\n        }\n        return undefined;\n    };\n    HistoryService.prototype.getLastActiveWorkspaceRoot = function (schemeFilter) {\n        // No Folder: return early\n        var folders = this.contextService.getWorkspace().folders;\n        if (folders.length === 0) {\n            return undefined;\n        }\n        // Single Folder: return early\n        if (folders.length === 1) {\n            var resource = folders[0].uri;\n            if (!schemeFilter || resource.scheme === schemeFilter) {\n                return resource;\n            }\n            return undefined;\n        }\n        // Multiple folders: find the last active one\n        var history = this.getHistory();\n        for (var _i = 0, history_2 = history; _i < history_2.length; _i++) {\n            var input = history_2[_i];\n            if (input instanceof editor_1.EditorInput) {\n                continue;\n            }\n            var resourceInput = input;\n            if (schemeFilter && resourceInput.resource.scheme !== schemeFilter) {\n                continue;\n            }\n            var resourceWorkspace = this.contextService.getWorkspaceFolder(resourceInput.resource);\n            if (resourceWorkspace) {\n                return resourceWorkspace.uri;\n            }\n        }\n        // fallback to first workspace matching scheme filter if any\n        for (var _a = 0, folders_1 = folders; _a < folders_1.length; _a++) {\n            var folder = folders_1[_a];\n            var resource = folder.uri;\n            if (!schemeFilter || resource.scheme === schemeFilter) {\n                return resource;\n            }\n        }\n        return undefined;\n    };\n    HistoryService.prototype.getLastActiveFile = function (schemeFilter) {\n        var history = this.getHistory();\n        for (var _i = 0, history_3 = history; _i < history_3.length; _i++) {\n            var input = history_3[_i];\n            var resource = void 0;\n            if (input instanceof editor_1.EditorInput) {\n                resource = editor_1.toResource(input, { filter: schemeFilter });\n            }\n            else {\n                resource = input.resource;\n            }\n            if (resource && resource.scheme === schemeFilter) {\n                return resource;\n            }\n        }\n        return undefined;\n    };\n    HistoryService.STORAGE_KEY = 'history.entries';\n    HistoryService.MAX_HISTORY_ITEMS = 200;\n    HistoryService.MAX_STACK_ITEMS = 50;\n    HistoryService.MAX_RECENTLY_CLOSED_EDITORS = 20;\n    HistoryService = tslib_1.__decorate([\n        tslib_1.__param(0, editorService_1.IEditorService),\n        tslib_1.__param(1, editorGroupsService_1.IEditorGroupsService),\n        tslib_1.__param(2, workspace_1.IWorkspaceContextService),\n        tslib_1.__param(3, storage_1.IStorageService),\n        tslib_1.__param(4, configuration_1.IConfigurationService),\n        tslib_1.__param(5, files_1.IFileService),\n        tslib_1.__param(6, windows_1.IWindowsService),\n        tslib_1.__param(7, instantiation_1.IInstantiationService),\n        tslib_1.__param(8, layoutService_1.IWorkbenchLayoutService),\n        tslib_1.__param(9, contextkey_1.IContextKeyService)\n    ], HistoryService);\n    return HistoryService;\n}(lifecycle_1.Disposable));\nexports.HistoryService = HistoryService;\nextensions_1.registerSingleton(history_1.IHistoryService, HistoryService);\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/history/browser/history.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/history/browser/history.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { URI } from 'vs/base/common/uri';\nimport { IEditor } from 'vs/editor/common/editorCommon';\nimport { ITextEditorOptions, IResourceInput, ITextEditorSelection } from 'vs/platform/editor/common/editor';\nimport { IEditorInput, IEditor as IBaseEditor, Extensions as EditorExtensions, EditorInput, IEditorCloseEvent, IEditorInputFactoryRegistry, toResource, Extensions as EditorInputExtensions, IFileInputFactory, IEditorIdentifier } from 'vs/workbench/common/editor';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\nimport { IHistoryService } from 'vs/workbench/services/history/common/history';\nimport { FileChangesEvent, IFileService, FileChangeType, FILES_EXCLUDE_CONFIG } from 'vs/platform/files/common/files';\nimport { Selection } from 'vs/editor/common/core/selection';\nimport { IWorkspaceContextService } from 'vs/platform/workspace/common/workspace';\nimport { IDisposable, dispose, Disposable } from 'vs/base/common/lifecycle';\nimport { IStorageService, StorageScope } from 'vs/platform/storage/common/storage';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport { Event } from 'vs/base/common/event';\nimport { IConfigurationService, IConfigurationChangeEvent } from 'vs/platform/configuration/common/configuration';\nimport { IEditorGroupsService, IEditorGroup } from 'vs/workbench/services/editor/common/editorGroupsService';\nimport { IWindowsService } from 'vs/platform/windows/common/windows';\nimport { getCodeEditor, ICodeEditor } from 'vs/editor/browser/editorBrowser';\nimport { getExcludes, ISearchConfiguration } from 'vs/workbench/services/search/common/search';\nimport { IExpression } from 'vs/base/common/glob';\nimport { ICursorPositionChangedEvent } from 'vs/editor/common/controller/cursorEvents';\nimport { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';\nimport { ResourceGlobMatcher } from 'vs/workbench/common/resources';\nimport { EditorServiceImpl } from 'vs/workbench/browser/parts/editor/editor';\nimport { IWorkbenchLayoutService } from 'vs/workbench/services/layout/browser/layoutService';\nimport { IContextKeyService, RawContextKey, IContextKey } from 'vs/platform/contextkey/common/contextkey';\nimport { coalesce } from 'vs/base/common/arrays';\nimport { registerSingleton } from 'vs/platform/instantiation/common/extensions';\nimport { withNullAsUndefined } from 'vs/base/common/types';\n\n/**\n * Stores the selection & view state of an editor and allows to compare it to other selection states.\n */\nexport class TextEditorState {\n\n\tprivate static readonly EDITOR_SELECTION_THRESHOLD = 10; // number of lines to move in editor to justify for new state\n\n\tprivate textEditorSelection?: ITextEditorSelection;\n\n\tconstructor(private _editorInput: IEditorInput, private _selection: Selection | null) {\n\t\tthis.textEditorSelection = Selection.isISelection(_selection) ? {\n\t\t\tstartLineNumber: _selection.startLineNumber,\n\t\t\tstartColumn: _selection.startColumn\n\t\t} : undefined;\n\t}\n\n\tget editorInput(): IEditorInput {\n\t\treturn this._editorInput;\n\t}\n\n\tget selection(): ITextEditorSelection | undefined {\n\t\treturn this.textEditorSelection;\n\t}\n\n\tjustifiesNewPushState(other: TextEditorState, event?: ICursorPositionChangedEvent): boolean {\n\t\tif (event && event.source === 'api') {\n\t\t\treturn true; // always let API source win (e.g. \"Go to definition\" should add a history entry)\n\t\t}\n\n\t\tif (!this._editorInput.matches(other._editorInput)) {\n\t\t\treturn true; // different editor inputs\n\t\t}\n\n\t\tif (!Selection.isISelection(this._selection) || !Selection.isISelection(other._selection)) {\n\t\t\treturn true; // unknown selections\n\t\t}\n\n\t\tconst thisLineNumber = Math.min(this._selection.selectionStartLineNumber, this._selection.positionLineNumber);\n\t\tconst otherLineNumber = Math.min(other._selection.selectionStartLineNumber, other._selection.positionLineNumber);\n\n\t\tif (Math.abs(thisLineNumber - otherLineNumber) < TextEditorState.EDITOR_SELECTION_THRESHOLD) {\n\t\t\treturn false; // ignore selection changes in the range of EditorState.EDITOR_SELECTION_THRESHOLD lines\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\ninterface ISerializedEditorHistoryEntry {\n\tresourceJSON?: object;\n\teditorInputJSON?: { typeId: string; deserialized: string; };\n}\n\ninterface IStackEntry {\n\tinput: IEditorInput | IResourceInput;\n\tselection?: ITextEditorSelection;\n}\n\ninterface IRecentlyClosedFile {\n\tresource: URI;\n\tindex: number;\n}\n\nexport class HistoryService extends Disposable implements IHistoryService {\n\n\t_serviceBrand: any;\n\n\tprivate static readonly STORAGE_KEY = 'history.entries';\n\tprivate static readonly MAX_HISTORY_ITEMS = 200;\n\tprivate static readonly MAX_STACK_ITEMS = 50;\n\tprivate static readonly MAX_RECENTLY_CLOSED_EDITORS = 20;\n\n\tprivate activeEditorListeners: IDisposable[];\n\tprivate lastActiveEditor?: IEditorIdentifier;\n\n\tprivate editorHistoryListeners: Map<EditorInput, IDisposable[]> = new Map();\n\tprivate editorStackListeners: Map<EditorInput, IDisposable[]> = new Map();\n\n\tprivate stack: IStackEntry[];\n\tprivate index: number;\n\tprivate lastIndex: number;\n\tprivate navigatingInStack: boolean;\n\tprivate currentTextEditorState: TextEditorState | null;\n\n\tprivate lastEditLocation: IStackEntry;\n\n\tprivate history: Array<IEditorInput | IResourceInput>;\n\tprivate recentlyClosedFiles: IRecentlyClosedFile[];\n\tprivate loaded: boolean;\n\tprivate resourceFilter: ResourceGlobMatcher;\n\n\tprivate fileInputFactory: IFileInputFactory;\n\n\tprivate canNavigateBackContextKey: IContextKey<boolean>;\n\tprivate canNavigateForwardContextKey: IContextKey<boolean>;\n\tprivate canNavigateToLastEditLocationContextKey: IContextKey<boolean>;\n\n\tconstructor(\n\t\t@IEditorService private readonly editorService: EditorServiceImpl,\n\t\t@IEditorGroupsService private readonly editorGroupService: IEditorGroupsService,\n\t\t@IWorkspaceContextService private readonly contextService: IWorkspaceContextService,\n\t\t@IStorageService private readonly storageService: IStorageService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IWindowsService private readonly windowService: IWindowsService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IWorkbenchLayoutService private readonly layoutService: IWorkbenchLayoutService,\n\t\t@IContextKeyService private readonly contextKeyService: IContextKeyService\n\t) {\n\t\tsuper();\n\n\t\tthis.activeEditorListeners = [];\n\n\t\tthis.canNavigateBackContextKey = (new RawContextKey<boolean>('canNavigateBack', false)).bindTo(this.contextKeyService);\n\t\tthis.canNavigateForwardContextKey = (new RawContextKey<boolean>('canNavigateForward', false)).bindTo(this.contextKeyService);\n\t\tthis.canNavigateToLastEditLocationContextKey = (new RawContextKey<boolean>('canNavigateToLastEditLocation', false)).bindTo(this.contextKeyService);\n\n\t\tthis.fileInputFactory = Registry.as<IEditorInputFactoryRegistry>(EditorInputExtensions.EditorInputFactories).getFileInputFactory();\n\n\t\tthis.index = -1;\n\t\tthis.lastIndex = -1;\n\t\tthis.stack = [];\n\t\tthis.recentlyClosedFiles = [];\n\t\tthis.loaded = false;\n\t\tthis.resourceFilter = this._register(instantiationService.createInstance(\n\t\t\tResourceGlobMatcher,\n\t\t\t(root?: URI) => this.getExcludes(root),\n\t\t\t(event: IConfigurationChangeEvent) => event.affectsConfiguration(FILES_EXCLUDE_CONFIG) || event.affectsConfiguration('search.exclude')\n\t\t));\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate getExcludes(root?: URI): IExpression {\n\t\tconst scope = root ? { resource: root } : undefined;\n\n\t\treturn getExcludes(scope ? this.configurationService.getValue<ISearchConfiguration>(scope) : this.configurationService.getValue<ISearchConfiguration>())!;\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.editorService.onDidActiveEditorChange(() => this.onActiveEditorChanged()));\n\t\tthis._register(this.editorService.onDidOpenEditorFail(event => this.remove(event.editor)));\n\t\tthis._register(this.editorService.onDidCloseEditor(event => this.onEditorClosed(event)));\n\t\tthis._register(this.storageService.onWillSaveState(() => this.saveState()));\n\t\tthis._register(this.fileService.onFileChanges(event => this.onFileChanges(event)));\n\t\tthis._register(this.resourceFilter.onExpressionChange(() => this.handleExcludesChange()));\n\n\t\t// if the service is created late enough that an editor is already opened\n\t\t// make sure to trigger the onActiveEditorChanged() to track the editor\n\t\t// properly (fixes https://github.com/Microsoft/vscode/issues/59908)\n\t\tif (this.editorService.activeControl) {\n\t\t\tthis.onActiveEditorChanged();\n\t\t}\n\t}\n\n\tprivate onActiveEditorChanged(): void {\n\t\tconst activeControl = this.editorService.activeControl;\n\t\tif (this.lastActiveEditor && this.matchesEditor(this.lastActiveEditor, activeControl)) {\n\t\t\treturn; // return if the active editor is still the same\n\t\t}\n\n\t\t// Remember as last active editor (can be undefined if none opened)\n\t\tthis.lastActiveEditor = activeControl && activeControl.input && activeControl.group ? { editor: activeControl.input, groupId: activeControl.group.id } : undefined;\n\n\t\t// Dispose old listeners\n\t\tdispose(this.activeEditorListeners);\n\t\tthis.activeEditorListeners = [];\n\n\t\t// Propagate to history\n\t\tthis.handleActiveEditorChange(activeControl);\n\n\t\t// Apply listener for selection changes if this is a text editor\n\t\tconst activeTextEditorWidget = getCodeEditor(this.editorService.activeTextEditorWidget);\n\t\tconst activeEditor = this.editorService.activeEditor;\n\t\tif (activeTextEditorWidget) {\n\n\t\t\t// Debounce the event with a timeout of 0ms so that multiple calls to\n\t\t\t// editor.setSelection() are folded into one. We do not want to record\n\t\t\t// subsequent history navigations for such API calls.\n\t\t\tthis.activeEditorListeners.push(Event.debounce(activeTextEditorWidget.onDidChangeCursorPosition, (last, event) => event, 0)((event => {\n\t\t\t\tthis.handleEditorSelectionChangeEvent(activeControl, event);\n\t\t\t})));\n\n\t\t\t// Track the last edit location by tracking model content change events\n\t\t\t// Use a debouncer to make sure to capture the correct cursor position\n\t\t\t// after the model content has changed.\n\t\t\tthis.activeEditorListeners.push(Event.debounce(activeTextEditorWidget.onDidChangeModelContent, (last, event) => event, 0)((event => this.rememberLastEditLocation(activeEditor!, activeTextEditorWidget))));\n\t\t}\n\t}\n\n\tprivate rememberLastEditLocation(activeEditor: IEditorInput, activeTextEditorWidget: ICodeEditor): void {\n\t\tthis.lastEditLocation = { input: activeEditor };\n\t\tthis.canNavigateToLastEditLocationContextKey.set(true);\n\n\t\tconst position = activeTextEditorWidget.getPosition();\n\t\tif (position) {\n\t\t\tthis.lastEditLocation.selection = {\n\t\t\t\tstartLineNumber: position.lineNumber,\n\t\t\t\tstartColumn: position.column\n\t\t\t};\n\t\t}\n\t}\n\n\tprivate matchesEditor(identifier: IEditorIdentifier, editor?: IBaseEditor): boolean {\n\t\tif (!editor || !editor.group) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (identifier.groupId !== editor.group.id) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn identifier.editor.matches(editor.input);\n\t}\n\n\tprivate onFileChanges(e: FileChangesEvent): void {\n\t\tif (e.gotDeleted()) {\n\t\t\tthis.remove(e); // remove from history files that got deleted or moved\n\t\t}\n\t}\n\n\tprivate onEditorClosed(event: IEditorCloseEvent): void {\n\n\t\t// Track closing of editor to support to reopen closed editors (unless editor was replaced)\n\t\tif (!event.replaced) {\n\t\t\tconst resource = event.editor ? event.editor.getResource() : undefined;\n\t\t\tconst supportsReopen = resource && this.fileService.canHandleResource(resource); // we only support file'ish things to reopen\n\t\t\tif (resource && supportsReopen) {\n\n\t\t\t\t// Remove all inputs matching and add as last recently closed\n\t\t\t\tthis.removeFromRecentlyClosedFiles(event.editor);\n\t\t\t\tthis.recentlyClosedFiles.push({ resource, index: event.index });\n\n\t\t\t\t// Bounding\n\t\t\t\tif (this.recentlyClosedFiles.length > HistoryService.MAX_RECENTLY_CLOSED_EDITORS) {\n\t\t\t\t\tthis.recentlyClosedFiles.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treopenLastClosedEditor(): void {\n\t\tthis.ensureHistoryLoaded();\n\n\t\tlet lastClosedFile = this.recentlyClosedFiles.pop();\n\t\twhile (lastClosedFile && this.isFileOpened(lastClosedFile.resource, this.editorGroupService.activeGroup)) {\n\t\t\tlastClosedFile = this.recentlyClosedFiles.pop(); // pop until we find a file that is not opened\n\t\t}\n\n\t\tif (lastClosedFile) {\n\t\t\tthis.editorService.openEditor({ resource: lastClosedFile.resource, options: { pinned: true, index: lastClosedFile.index } }).then(editor => {\n\n\t\t\t\t// Fix for https://github.com/Microsoft/vscode/issues/67882\n\t\t\t\t// If opening of the editor fails, make sure to try the next one\n\t\t\t\t// but make sure to remove this one from the list to prevent\n\t\t\t\t// endless loops.\n\t\t\t\tif (!editor) {\n\t\t\t\t\tthis.recentlyClosedFiles.pop();\n\t\t\t\t\tthis.reopenLastClosedEditor();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\topenLastEditLocation(): void {\n\t\tif (this.lastEditLocation) {\n\t\t\tthis.doNavigate(this.lastEditLocation, true);\n\t\t}\n\t}\n\n\tforward(acrossEditors?: boolean): void {\n\t\tif (this.stack.length > this.index + 1) {\n\t\t\tif (acrossEditors) {\n\t\t\t\tthis.doForwardAcrossEditors();\n\t\t\t} else {\n\t\t\t\tthis.doForwardInEditors();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate doForwardInEditors(): void {\n\t\tthis.setIndex(this.index + 1);\n\t\tthis.navigate();\n\t}\n\n\tprivate setIndex(value: number): void {\n\t\tthis.lastIndex = this.index;\n\t\tthis.index = value;\n\n\t\tthis.updateContextKeys();\n\t}\n\n\tprivate doForwardAcrossEditors(): void {\n\t\tlet currentIndex = this.index;\n\t\tconst currentEntry = this.stack[this.index];\n\n\t\t// Find the next entry that does not match our current entry\n\t\twhile (this.stack.length > currentIndex + 1) {\n\t\t\tcurrentIndex++;\n\n\t\t\tconst previousEntry = this.stack[currentIndex];\n\t\t\tif (!this.matches(currentEntry.input, previousEntry.input)) {\n\t\t\t\tthis.setIndex(currentIndex);\n\t\t\t\tthis.navigate(true /* across editors */);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tback(acrossEditors?: boolean): void {\n\t\tif (this.index > 0) {\n\t\t\tif (acrossEditors) {\n\t\t\t\tthis.doBackAcrossEditors();\n\t\t\t} else {\n\t\t\t\tthis.doBackInEditors();\n\t\t\t}\n\t\t}\n\t}\n\n\tlast(): void {\n\t\tif (this.lastIndex === -1) {\n\t\t\tthis.back();\n\t\t} else {\n\t\t\tthis.setIndex(this.lastIndex);\n\t\t\tthis.navigate();\n\t\t}\n\t}\n\n\tprivate doBackInEditors(): void {\n\t\tthis.setIndex(this.index - 1);\n\t\tthis.navigate();\n\t}\n\n\tprivate doBackAcrossEditors(): void {\n\t\tlet currentIndex = this.index;\n\t\tconst currentEntry = this.stack[this.index];\n\n\t\t// Find the next previous entry that does not match our current entry\n\t\twhile (currentIndex > 0) {\n\t\t\tcurrentIndex--;\n\n\t\t\tconst previousEntry = this.stack[currentIndex];\n\t\t\tif (!this.matches(currentEntry.input, previousEntry.input)) {\n\t\t\t\tthis.setIndex(currentIndex);\n\t\t\t\tthis.navigate(true /* across editors */);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tthis.ensureHistoryLoaded();\n\n\t\t// Navigation (next, previous)\n\t\tthis.index = -1;\n\t\tthis.lastIndex = -1;\n\t\tthis.stack.splice(0);\n\t\tthis.editorStackListeners.forEach(listeners => dispose(listeners));\n\t\tthis.editorStackListeners.clear();\n\n\t\t// Closed files\n\t\tthis.recentlyClosedFiles = [];\n\n\t\t// History\n\t\tthis.clearRecentlyOpened();\n\n\t\tthis.updateContextKeys();\n\t}\n\n\tclearRecentlyOpened(): void {\n\t\tthis.history = [];\n\n\t\tthis.editorHistoryListeners.forEach(listeners => dispose(listeners));\n\t\tthis.editorHistoryListeners.clear();\n\t}\n\n\tprivate updateContextKeys(): void {\n\t\tthis.canNavigateBackContextKey.set(this.stack.length > 0 && this.index > 0);\n\t\tthis.canNavigateForwardContextKey.set(this.stack.length > 0 && this.index < this.stack.length - 1);\n\t}\n\n\tprivate navigate(acrossEditors?: boolean): void {\n\t\tthis.navigatingInStack = true;\n\n\t\tthis.doNavigate(this.stack[this.index], !acrossEditors).finally(() => this.navigatingInStack = false);\n\t}\n\n\tprivate doNavigate(location: IStackEntry, withSelection: boolean): Promise<IBaseEditor | null> {\n\t\tconst options: ITextEditorOptions = {\n\t\t\trevealIfOpened: true // support to navigate across editor groups\n\t\t};\n\n\t\t// Unless we navigate across editors, support selection and\n\t\t// minimize scrolling by setting revealInCenterIfOutsideViewport\n\t\tif (location.selection && withSelection) {\n\t\t\toptions.selection = location.selection;\n\t\t\toptions.revealInCenterIfOutsideViewport = true;\n\t\t}\n\n\t\tif (location.input instanceof EditorInput) {\n\t\t\treturn this.editorService.openEditor(location.input, options);\n\t\t}\n\n\t\treturn this.editorService.openEditor({ resource: (location.input as IResourceInput).resource, options });\n\t}\n\n\tprotected handleEditorSelectionChangeEvent(editor?: IBaseEditor, event?: ICursorPositionChangedEvent): void {\n\t\tthis.handleEditorEventInStack(editor, event);\n\t}\n\n\tprotected handleActiveEditorChange(editor?: IBaseEditor): void {\n\t\tthis.handleEditorEventInHistory(editor);\n\t\tthis.handleEditorEventInStack(editor);\n\t}\n\n\tprivate handleEditorEventInHistory(editor?: IBaseEditor): void {\n\t\tconst input = editor ? editor.input : undefined;\n\n\t\t// Ensure we have at least a name to show and not configured to exclude input\n\t\tif (!input || !input.getName() || !this.include(input)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.ensureHistoryLoaded();\n\n\t\tconst historyInput = this.preferResourceInput(input);\n\n\t\t// Remove any existing entry and add to the beginning\n\t\tthis.removeFromHistory(input);\n\t\tthis.history.unshift(historyInput);\n\n\t\t// Respect max entries setting\n\t\tif (this.history.length > HistoryService.MAX_HISTORY_ITEMS) {\n\t\t\tthis.clearOnEditorDispose(this.history.pop()!, this.editorHistoryListeners);\n\t\t}\n\n\t\t// Remove this from the history unless the history input is a resource\n\t\t// that can easily be restored even when the input gets disposed\n\t\tif (historyInput instanceof EditorInput) {\n\t\t\tthis.onEditorDispose(historyInput, () => this.removeFromHistory(historyInput), this.editorHistoryListeners);\n\t\t}\n\t}\n\n\tprivate onEditorDispose(editor: EditorInput, listener: Function, mapEditorToDispose: Map<EditorInput, IDisposable[]>): void {\n\t\tconst toDispose = Event.once(editor.onDispose)(() => listener());\n\n\t\tlet disposables = mapEditorToDispose.get(editor);\n\t\tif (!disposables) {\n\t\t\tdisposables = [];\n\t\t\tmapEditorToDispose.set(editor, disposables);\n\t\t}\n\n\t\tdisposables.push(toDispose);\n\t}\n\n\tprivate clearOnEditorDispose(editor: IEditorInput | IResourceInput | FileChangesEvent, mapEditorToDispose: Map<EditorInput, IDisposable[]>): void {\n\t\tif (editor instanceof EditorInput) {\n\t\t\tconst disposables = mapEditorToDispose.get(editor);\n\t\t\tif (disposables) {\n\t\t\t\tdispose(disposables);\n\t\t\t\tmapEditorToDispose.delete(editor);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate include(input: IEditorInput | IResourceInput): boolean {\n\t\tif (input instanceof EditorInput) {\n\t\t\treturn true; // include any non files\n\t\t}\n\n\t\tconst resourceInput = input as IResourceInput;\n\n\t\treturn !this.resourceFilter.matches(resourceInput.resource);\n\t}\n\n\tprotected handleExcludesChange(): void {\n\t\tthis.removeExcludedFromHistory();\n\t}\n\n\tremove(input: IEditorInput | IResourceInput): void;\n\tremove(input: FileChangesEvent): void;\n\tremove(arg1: IEditorInput | IResourceInput | FileChangesEvent): void {\n\t\tthis.removeFromHistory(arg1);\n\t\tthis.removeFromStack(arg1);\n\t\tthis.removeFromRecentlyClosedFiles(arg1);\n\t\tthis.removeFromRecentlyOpened(arg1);\n\t}\n\n\tprivate removeExcludedFromHistory(): void {\n\t\tthis.ensureHistoryLoaded();\n\n\t\tthis.history = this.history.filter(e => {\n\t\t\tconst include = this.include(e);\n\n\t\t\t// Cleanup any listeners associated with the input when removing from history\n\t\t\tif (!include) {\n\t\t\t\tthis.clearOnEditorDispose(e, this.editorHistoryListeners);\n\t\t\t}\n\n\t\t\treturn include;\n\t\t});\n\t}\n\n\tprivate removeFromHistory(arg1: IEditorInput | IResourceInput | FileChangesEvent): void {\n\t\tthis.ensureHistoryLoaded();\n\n\t\tthis.history = this.history.filter(e => {\n\t\t\tconst matches = this.matches(arg1, e);\n\n\t\t\t// Cleanup any listeners associated with the input when removing from history\n\t\t\tif (matches) {\n\t\t\t\tthis.clearOnEditorDispose(arg1, this.editorHistoryListeners);\n\t\t\t}\n\n\t\t\treturn !matches;\n\t\t});\n\t}\n\n\tprivate handleEditorEventInStack(control: IBaseEditor | undefined, event?: ICursorPositionChangedEvent): void {\n\t\tconst codeEditor = control ? getCodeEditor(control.getControl()) : undefined;\n\n\t\t// treat editor changes that happen as part of stack navigation specially\n\t\t// we do not want to add a new stack entry as a matter of navigating the\n\t\t// stack but we need to keep our currentTextEditorState up to date with\n\t\t// the navigtion that occurs.\n\t\tif (this.navigatingInStack) {\n\t\t\tif (codeEditor && control && control.input) {\n\t\t\t\tthis.currentTextEditorState = new TextEditorState(control.input, codeEditor.getSelection());\n\t\t\t} else {\n\t\t\t\tthis.currentTextEditorState = null; // we navigated to a non text editor\n\t\t\t}\n\t\t}\n\n\t\t// normal navigation not part of history navigation\n\t\telse {\n\n\t\t\t// navigation inside text editor\n\t\t\tif (codeEditor && control && control.input) {\n\t\t\t\tthis.handleTextEditorEvent(control, codeEditor, event);\n\t\t\t}\n\n\t\t\t// navigation to non-text editor\n\t\t\telse {\n\t\t\t\tthis.currentTextEditorState = null; // at this time we have no active text editor view state\n\n\t\t\t\tif (control && control.input) {\n\t\t\t\t\tthis.handleNonTextEditorEvent(control);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate handleTextEditorEvent(editor: IBaseEditor, editorControl: IEditor, event?: ICursorPositionChangedEvent): void {\n\t\tif (!editor.input) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst stateCandidate = new TextEditorState(editor.input, editorControl.getSelection());\n\n\t\t// Add to stack if we dont have a current state or this new state justifies a push\n\t\tif (!this.currentTextEditorState || this.currentTextEditorState.justifiesNewPushState(stateCandidate, event)) {\n\t\t\tthis.add(editor.input, stateCandidate.selection);\n\t\t}\n\n\t\t// Otherwise we replace the current stack entry with this one\n\t\telse {\n\t\t\tthis.replace(editor.input, stateCandidate.selection);\n\t\t}\n\n\t\t// Update our current text editor state\n\t\tthis.currentTextEditorState = stateCandidate;\n\t}\n\n\tprivate handleNonTextEditorEvent(editor: IBaseEditor): void {\n\t\tif (!editor.input) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentStack = this.stack[this.index];\n\t\tif (currentStack && this.matches(editor.input, currentStack.input)) {\n\t\t\treturn; // do not push same editor input again\n\t\t}\n\n\t\tthis.add(editor.input);\n\t}\n\n\tadd(input: IEditorInput, selection?: ITextEditorSelection): void {\n\t\tif (!this.navigatingInStack) {\n\t\t\tthis.addOrReplaceInStack(input, selection);\n\t\t}\n\t}\n\n\tprivate replace(input: IEditorInput, selection?: ITextEditorSelection): void {\n\t\tif (!this.navigatingInStack) {\n\t\t\tthis.addOrReplaceInStack(input, selection, true /* force replace */);\n\t\t}\n\t}\n\n\tprivate addOrReplaceInStack(input: IEditorInput, selection?: ITextEditorSelection, forceReplace?: boolean): void {\n\n\t\t// Overwrite an entry in the stack if we have a matching input that comes\n\t\t// with editor options to indicate that this entry is more specific. Also\n\t\t// prevent entries that have the exact same options. Finally, Overwrite\n\t\t// entries if we detect that the change came in very fast which indicates\n\t\t// that it was not coming in from a user change but rather rapid programmatic\n\t\t// changes. We just take the last of the changes to not cause too many entries\n\t\t// on the stack.\n\t\t// We can also be instructed to force replace the last entry.\n\t\tlet replace = false;\n\t\tconst currentEntry = this.stack[this.index];\n\t\tif (currentEntry) {\n\t\t\tif (forceReplace) {\n\t\t\t\treplace = true; // replace if we are forced to\n\t\t\t} else if (this.matches(input, currentEntry.input) && this.sameSelection(currentEntry.selection, selection)) {\n\t\t\t\treplace = true; // replace if the input is the same as the current one and the selection as well\n\t\t\t}\n\t\t}\n\n\t\tconst stackInput = this.preferResourceInput(input);\n\t\tconst entry = { input: stackInput, selection };\n\n\t\t// Replace at current position\n\t\tlet removedEntries: IStackEntry[] = [];\n\t\tif (replace) {\n\t\t\tremovedEntries.push(this.stack[this.index]);\n\t\t\tthis.stack[this.index] = entry;\n\t\t}\n\n\t\t// Add to stack at current position\n\t\telse {\n\n\t\t\t// If we are not at the end of history, we remove anything after\n\t\t\tif (this.stack.length > this.index + 1) {\n\t\t\t\tfor (let i = this.index + 1; i < this.stack.length; i++) {\n\t\t\t\t\tremovedEntries.push(this.stack[i]);\n\t\t\t\t}\n\n\t\t\t\tthis.stack = this.stack.slice(0, this.index + 1);\n\t\t\t}\n\n\t\t\t// Insert entry at index\n\t\t\tthis.stack.splice(this.index + 1, 0, entry);\n\n\t\t\t// Check for limit\n\t\t\tif (this.stack.length > HistoryService.MAX_STACK_ITEMS) {\n\t\t\t\tremovedEntries.push(this.stack.shift()!); // remove first\n\t\t\t\tif (this.lastIndex >= 0) {\n\t\t\t\t\tthis.lastIndex--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.setIndex(this.index + 1);\n\t\t\t}\n\t\t}\n\n\t\t// Clear editor listeners from removed entries\n\t\tremovedEntries.forEach(removedEntry => this.clearOnEditorDispose(removedEntry.input, this.editorStackListeners));\n\n\t\t// Remove this from the stack unless the stack input is a resource\n\t\t// that can easily be restored even when the input gets disposed\n\t\tif (stackInput instanceof EditorInput) {\n\t\t\tthis.onEditorDispose(stackInput, () => this.removeFromStack(stackInput), this.editorStackListeners);\n\t\t}\n\n\t\t// Context\n\t\tthis.updateContextKeys();\n\t}\n\n\tprivate preferResourceInput(input: IEditorInput): IEditorInput | IResourceInput {\n\t\tif (this.fileInputFactory.isFileInput(input)) {\n\t\t\treturn { resource: input.getResource() };\n\t\t}\n\n\t\treturn input;\n\t}\n\n\tprivate sameSelection(selectionA?: ITextEditorSelection, selectionB?: ITextEditorSelection): boolean {\n\t\tif (!selectionA && !selectionB) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!selectionA || !selectionB) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn selectionA.startLineNumber === selectionB.startLineNumber; // we consider the history entry same if we are on the same line\n\t}\n\n\tprivate removeFromStack(arg1: IEditorInput | IResourceInput | FileChangesEvent): void {\n\t\tthis.stack = this.stack.filter(e => {\n\t\t\tconst matches = this.matches(arg1, e.input);\n\n\t\t\t// Cleanup any listeners associated with the input when removing\n\t\t\tif (matches) {\n\t\t\t\tthis.clearOnEditorDispose(arg1, this.editorStackListeners);\n\t\t\t}\n\n\t\t\treturn !matches;\n\t\t});\n\t\tthis.index = this.stack.length - 1; // reset index\n\t\tthis.lastIndex = -1;\n\n\t\tthis.updateContextKeys();\n\t}\n\n\tprivate removeFromRecentlyClosedFiles(arg1: IEditorInput | IResourceInput | FileChangesEvent): void {\n\t\tthis.recentlyClosedFiles = this.recentlyClosedFiles.filter(e => !this.matchesFile(e.resource, arg1));\n\t}\n\n\tprivate removeFromRecentlyOpened(arg1: IEditorInput | IResourceInput | FileChangesEvent): void {\n\t\tif (arg1 instanceof EditorInput || arg1 instanceof FileChangesEvent) {\n\t\t\treturn; // for now do not delete from file events since recently open are likely out of workspace files for which there are no delete events\n\t\t}\n\n\t\tconst input = arg1 as IResourceInput;\n\n\t\tthis.windowService.removeFromRecentlyOpened([input.resource]);\n\t}\n\n\tprivate isFileOpened(resource: URI, group: IEditorGroup): boolean {\n\t\tif (!group) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.editorService.isOpen({ resource }, group)) {\n\t\t\treturn false; // fast check\n\t\t}\n\n\t\treturn group.editors.some(e => this.matchesFile(resource, e));\n\t}\n\n\tprivate matches(arg1: IEditorInput | IResourceInput | FileChangesEvent, inputB: IEditorInput | IResourceInput): boolean {\n\t\tif (arg1 instanceof FileChangesEvent) {\n\t\t\tif (inputB instanceof EditorInput) {\n\t\t\t\treturn false; // we only support this for IResourceInput\n\t\t\t}\n\n\t\t\tconst resourceInputB = inputB as IResourceInput;\n\n\t\t\treturn arg1.contains(resourceInputB.resource, FileChangeType.DELETED);\n\t\t}\n\n\t\tif (arg1 instanceof EditorInput && inputB instanceof EditorInput) {\n\t\t\treturn arg1.matches(inputB);\n\t\t}\n\n\t\tif (arg1 instanceof EditorInput) {\n\t\t\treturn this.matchesFile((inputB as IResourceInput).resource, arg1);\n\t\t}\n\n\t\tif (inputB instanceof EditorInput) {\n\t\t\treturn this.matchesFile((arg1 as IResourceInput).resource, inputB);\n\t\t}\n\n\t\tconst resourceInputA = arg1 as IResourceInput;\n\t\tconst resourceInputB = inputB as IResourceInput;\n\n\t\treturn resourceInputA && resourceInputB && resourceInputA.resource.toString() === resourceInputB.resource.toString();\n\t}\n\n\tprivate matchesFile(resource: URI, arg2: IEditorInput | IResourceInput | FileChangesEvent): boolean {\n\t\tif (arg2 instanceof FileChangesEvent) {\n\t\t\treturn arg2.contains(resource, FileChangeType.DELETED);\n\t\t}\n\n\t\tif (arg2 instanceof EditorInput) {\n\t\t\tconst inputResource = arg2.getResource();\n\t\t\tif (!inputResource) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (this.layoutService.isRestored() && !this.fileService.canHandleResource(inputResource)) {\n\t\t\t\treturn false; // make sure to only check this when workbench has restored (for https://github.com/Microsoft/vscode/issues/48275)\n\t\t\t}\n\n\t\t\treturn inputResource.toString() === resource.toString();\n\t\t}\n\n\t\tconst resourceInput = arg2 as IResourceInput;\n\n\t\treturn resourceInput && resourceInput.resource.toString() === resource.toString();\n\t}\n\n\tgetHistory(): Array<IEditorInput | IResourceInput> {\n\t\tthis.ensureHistoryLoaded();\n\n\t\treturn this.history.slice(0);\n\t}\n\n\tprivate ensureHistoryLoaded(): void {\n\t\tif (!this.loaded) {\n\t\t\tthis.loadHistory();\n\t\t}\n\n\t\tthis.loaded = true;\n\t}\n\n\tprivate saveState(): void {\n\t\tif (!this.history) {\n\t\t\treturn; // nothing to save because history was not used\n\t\t}\n\n\t\tconst registry = Registry.as<IEditorInputFactoryRegistry>(EditorExtensions.EditorInputFactories);\n\n\t\tconst entries: ISerializedEditorHistoryEntry[] = coalesce(this.history.map(input => {\n\n\t\t\t// Editor input: try via factory\n\t\t\tif (input instanceof EditorInput) {\n\t\t\t\tconst factory = registry.getEditorInputFactory(input.getTypeId());\n\t\t\t\tif (factory) {\n\t\t\t\t\tconst deserialized = factory.serialize(input);\n\t\t\t\t\tif (deserialized) {\n\t\t\t\t\t\treturn { editorInputJSON: { typeId: input.getTypeId(), deserialized } } as ISerializedEditorHistoryEntry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// File resource: via URI.toJSON()\n\t\t\telse {\n\t\t\t\treturn { resourceJSON: (input as IResourceInput).resource.toJSON() } as ISerializedEditorHistoryEntry;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}));\n\n\t\tthis.storageService.store(HistoryService.STORAGE_KEY, JSON.stringify(entries), StorageScope.WORKSPACE);\n\t}\n\n\tprivate loadHistory(): void {\n\t\tlet entries: ISerializedEditorHistoryEntry[] = [];\n\n\t\tconst entriesRaw = this.storageService.get(HistoryService.STORAGE_KEY, StorageScope.WORKSPACE);\n\t\tif (entriesRaw) {\n\t\t\tentries = coalesce(JSON.parse(entriesRaw));\n\t\t}\n\n\t\tconst registry = Registry.as<IEditorInputFactoryRegistry>(EditorExtensions.EditorInputFactories);\n\n\t\tthis.history = coalesce(entries.map(entry => {\n\t\t\ttry {\n\t\t\t\treturn this.safeLoadHistoryEntry(registry, entry);\n\t\t\t} catch (error) {\n\t\t\t\tonUnexpectedError(error);\n\n\t\t\t\treturn undefined; // https://github.com/Microsoft/vscode/issues/60960\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate safeLoadHistoryEntry(registry: IEditorInputFactoryRegistry, entry: ISerializedEditorHistoryEntry): IEditorInput | IResourceInput | undefined {\n\t\tconst serializedEditorHistoryEntry = entry as ISerializedEditorHistoryEntry;\n\n\t\t// File resource: via URI.revive()\n\t\tif (serializedEditorHistoryEntry.resourceJSON) {\n\t\t\treturn { resource: URI.revive(serializedEditorHistoryEntry.resourceJSON) } as IResourceInput;\n\t\t}\n\n\t\t// Editor input: via factory\n\t\tconst { editorInputJSON } = serializedEditorHistoryEntry;\n\t\tif (editorInputJSON && editorInputJSON.deserialized) {\n\t\t\tconst factory = registry.getEditorInputFactory(editorInputJSON.typeId);\n\t\t\tif (factory) {\n\t\t\t\tconst input = factory.deserialize(this.instantiationService, editorInputJSON.deserialized);\n\t\t\t\tif (input) {\n\t\t\t\t\tthis.onEditorDispose(input, () => this.removeFromHistory(input), this.editorHistoryListeners);\n\t\t\t\t}\n\n\t\t\t\treturn withNullAsUndefined(input);\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tgetLastActiveWorkspaceRoot(schemeFilter?: string): URI | undefined {\n\n\t\t// No Folder: return early\n\t\tconst folders = this.contextService.getWorkspace().folders;\n\t\tif (folders.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Single Folder: return early\n\t\tif (folders.length === 1) {\n\t\t\tconst resource = folders[0].uri;\n\t\t\tif (!schemeFilter || resource.scheme === schemeFilter) {\n\t\t\t\treturn resource;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Multiple folders: find the last active one\n\t\tconst history = this.getHistory();\n\t\tfor (const input of history) {\n\t\t\tif (input instanceof EditorInput) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst resourceInput = input as IResourceInput;\n\t\t\tif (schemeFilter && resourceInput.resource.scheme !== schemeFilter) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst resourceWorkspace = this.contextService.getWorkspaceFolder(resourceInput.resource);\n\t\t\tif (resourceWorkspace) {\n\t\t\t\treturn resourceWorkspace.uri;\n\t\t\t}\n\t\t}\n\n\t\t// fallback to first workspace matching scheme filter if any\n\t\tfor (const folder of folders) {\n\t\t\tconst resource = folder.uri;\n\t\t\tif (!schemeFilter || resource.scheme === schemeFilter) {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tgetLastActiveFile(schemeFilter: string): URI | undefined {\n\t\tconst history = this.getHistory();\n\t\tfor (const input of history) {\n\t\t\tlet resource: URI | null;\n\t\t\tif (input instanceof EditorInput) {\n\t\t\t\tresource = toResource(input, { filter: schemeFilter });\n\t\t\t} else {\n\t\t\t\tresource = (input as IResourceInput).resource;\n\t\t\t}\n\n\t\t\tif (resource && resource.scheme === schemeFilter) {\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n}\n\nregisterSingleton(IHistoryService, HistoryService);"]}]}