{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/commands/shiftCommand.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/commands/shiftCommand.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/charCode\", \"vs/base/common/strings\", \"vs/editor/common/controller/cursorCommon\", \"vs/editor/common/core/range\", \"vs/editor/common/core/selection\", \"vs/editor/common/modes/languageConfigurationRegistry\"], function (require, exports, charCode_1, strings, cursorCommon_1, range_1, selection_1, languageConfigurationRegistry_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const repeatCache = Object.create(null);\n    function cachedStringRepeat(str, count) {\n        if (!repeatCache[str]) {\n            repeatCache[str] = ['', str];\n        }\n        const cache = repeatCache[str];\n        for (let i = cache.length; i <= count; i++) {\n            cache[i] = cache[i - 1] + str;\n        }\n        return cache[count];\n    }\n    exports.cachedStringRepeat = cachedStringRepeat;\n    class ShiftCommand {\n        static unshiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n            // Determine the visible column where the content starts\n            const contentStartVisibleColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n            if (insertSpaces) {\n                const indent = cachedStringRepeat(' ', indentSize);\n                const desiredTabStop = cursorCommon_1.CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\n                const indentCount = desiredTabStop / indentSize; // will be an integer\n                return cachedStringRepeat(indent, indentCount);\n            }\n            else {\n                const indent = '\\t';\n                const desiredTabStop = cursorCommon_1.CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\n                const indentCount = desiredTabStop / tabSize; // will be an integer\n                return cachedStringRepeat(indent, indentCount);\n            }\n        }\n        static shiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n            // Determine the visible column where the content starts\n            const contentStartVisibleColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n            if (insertSpaces) {\n                const indent = cachedStringRepeat(' ', indentSize);\n                const desiredTabStop = cursorCommon_1.CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\n                const indentCount = desiredTabStop / indentSize; // will be an integer\n                return cachedStringRepeat(indent, indentCount);\n            }\n            else {\n                const indent = '\\t';\n                const desiredTabStop = cursorCommon_1.CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\n                const indentCount = desiredTabStop / tabSize; // will be an integer\n                return cachedStringRepeat(indent, indentCount);\n            }\n        }\n        constructor(range, opts) {\n            this._opts = opts;\n            this._selection = range;\n            this._useLastEditRangeForCursorEndPosition = false;\n            this._selectionStartColumnStaysPut = false;\n        }\n        _addEditOperation(builder, range, text) {\n            if (this._useLastEditRangeForCursorEndPosition) {\n                builder.addTrackedEditOperation(range, text);\n            }\n            else {\n                builder.addEditOperation(range, text);\n            }\n        }\n        getEditOperations(model, builder) {\n            const startLine = this._selection.startLineNumber;\n            let endLine = this._selection.endLineNumber;\n            if (this._selection.endColumn === 1 && startLine !== endLine) {\n                endLine = endLine - 1;\n            }\n            const { tabSize, indentSize, insertSpaces } = this._opts;\n            const shouldIndentEmptyLines = (startLine === endLine);\n            // if indenting or outdenting on a whitespace only line\n            if (this._selection.isEmpty()) {\n                if (/^\\s*$/.test(model.getLineContent(startLine))) {\n                    this._useLastEditRangeForCursorEndPosition = true;\n                }\n            }\n            if (this._opts.useTabStops) {\n                // keep track of previous line's \"miss-alignment\"\n                let previousLineExtraSpaces = 0, extraSpaces = 0;\n                for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\n                    extraSpaces = 0;\n                    let lineText = model.getLineContent(lineNumber);\n                    let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n                    if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n                        // empty line or line with no leading whitespace => nothing to do\n                        continue;\n                    }\n                    if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n                        // do not indent empty lines => nothing to do\n                        continue;\n                    }\n                    if (indentationEndIndex === -1) {\n                        // the entire line is whitespace\n                        indentationEndIndex = lineText.length;\n                    }\n                    if (lineNumber > 1) {\n                        let contentStartVisibleColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\n                        if (contentStartVisibleColumn % indentSize !== 0) {\n                            // The current line is \"miss-aligned\", so let's see if this is expected...\n                            // This can only happen when it has trailing commas in the indent\n                            if (model.isCheapToTokenize(lineNumber - 1)) {\n                                let enterAction = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getRawEnterActionAtPosition(model, lineNumber - 1, model.getLineMaxColumn(lineNumber - 1));\n                                if (enterAction) {\n                                    extraSpaces = previousLineExtraSpaces;\n                                    if (enterAction.appendText) {\n                                        for (let j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\n                                            if (enterAction.appendText.charCodeAt(j) === charCode_1.CharCode.Space) {\n                                                extraSpaces++;\n                                            }\n                                            else {\n                                                break;\n                                            }\n                                        }\n                                    }\n                                    if (enterAction.removeText) {\n                                        extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\n                                    }\n                                    // Act as if `prefixSpaces` is not part of the indentation\n                                    for (let j = 0; j < extraSpaces; j++) {\n                                        if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== charCode_1.CharCode.Space) {\n                                            break;\n                                        }\n                                        indentationEndIndex--;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (this._opts.isUnshift && indentationEndIndex === 0) {\n                        // line with no leading whitespace => nothing to do\n                        continue;\n                    }\n                    let desiredIndent;\n                    if (this._opts.isUnshift) {\n                        desiredIndent = ShiftCommand.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n                    }\n                    else {\n                        desiredIndent = ShiftCommand.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n                    }\n                    this._addEditOperation(builder, new range_1.Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\n                    if (lineNumber === startLine) {\n                        // Force the startColumn to stay put because we're inserting after it\n                        this._selectionStartColumnStaysPut = (this._selection.startColumn <= indentationEndIndex + 1);\n                    }\n                }\n            }\n            else {\n                const oneIndent = (insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t');\n                for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++) {\n                    const lineText = model.getLineContent(lineNumber);\n                    let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n                    if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n                        // empty line or line with no leading whitespace => nothing to do\n                        continue;\n                    }\n                    if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n                        // do not indent empty lines => nothing to do\n                        continue;\n                    }\n                    if (indentationEndIndex === -1) {\n                        // the entire line is whitespace\n                        indentationEndIndex = lineText.length;\n                    }\n                    if (this._opts.isUnshift && indentationEndIndex === 0) {\n                        // line with no leading whitespace => nothing to do\n                        continue;\n                    }\n                    if (this._opts.isUnshift) {\n                        indentationEndIndex = Math.min(indentationEndIndex, indentSize);\n                        for (let i = 0; i < indentationEndIndex; i++) {\n                            const chr = lineText.charCodeAt(i);\n                            if (chr === charCode_1.CharCode.Tab) {\n                                indentationEndIndex = i + 1;\n                                break;\n                            }\n                        }\n                        this._addEditOperation(builder, new range_1.Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');\n                    }\n                    else {\n                        this._addEditOperation(builder, new range_1.Range(lineNumber, 1, lineNumber, 1), oneIndent);\n                        if (lineNumber === startLine) {\n                            // Force the startColumn to stay put because we're inserting after it\n                            this._selectionStartColumnStaysPut = (this._selection.startColumn === 1);\n                        }\n                    }\n                }\n            }\n            this._selectionId = builder.trackSelection(this._selection);\n        }\n        computeCursorState(model, helper) {\n            if (this._useLastEditRangeForCursorEndPosition) {\n                let lastOp = helper.getInverseEditOperations()[0];\n                return new selection_1.Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\n            }\n            const result = helper.getTrackedSelection(this._selectionId);\n            if (this._selectionStartColumnStaysPut) {\n                // The selection start should not move\n                let initialStartColumn = this._selection.startColumn;\n                let resultStartColumn = result.startColumn;\n                if (resultStartColumn <= initialStartColumn) {\n                    return result;\n                }\n                if (result.getDirection() === selection_1.SelectionDirection.LTR) {\n                    return new selection_1.Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\n                }\n                return new selection_1.Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\n            }\n            return result;\n        }\n    }\n    exports.ShiftCommand = ShiftCommand;\n});\n",null]}