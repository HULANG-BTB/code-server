{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/request/electron-browser/requestService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/request/electron-browser/requestService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"stream\", \"vs/platform/request/node/requestService\", \"vs/base/common/errors\"], function (require, exports, stream_1, requestService_1, errors_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * This service exposes the `request` API, while using the global\n     * or configured proxy settings.\n     */\n    class RequestService extends requestService_1.RequestService {\n        request(options, token) {\n            return super.request(options, token, exports.xhrRequest);\n        }\n    }\n    exports.RequestService = RequestService;\n    exports.xhrRequest = (options, token) => {\n        const xhr = new XMLHttpRequest();\n        return new Promise((resolve, reject) => {\n            xhr.open(options.type || 'GET', options.url || '', true, options.user, options.password);\n            setRequestHeaders(xhr, options);\n            xhr.responseType = 'arraybuffer';\n            xhr.onerror = e => reject(new Error(xhr.statusText && ('XHR failed: ' + xhr.statusText)));\n            xhr.onload = (e) => {\n                resolve({\n                    res: {\n                        statusCode: xhr.status,\n                        headers: getResponseHeaders(xhr)\n                    },\n                    stream: new class ArrayBufferStream extends stream_1.Readable {\n                        constructor(arraybuffer) {\n                            super();\n                            this._buffer = Buffer.from(new Uint8Array(arraybuffer));\n                            this._offset = 0;\n                            this._length = this._buffer.length;\n                        }\n                        _read(size) {\n                            if (this._offset < this._length) {\n                                this.push(this._buffer.slice(this._offset, (this._offset + size)));\n                                this._offset += size;\n                            }\n                            else {\n                                this.push(null);\n                            }\n                        }\n                    }(xhr.response)\n                });\n            };\n            xhr.ontimeout = e => reject(new Error(`XHR timeout: ${options.timeout}ms`));\n            if (options.timeout) {\n                xhr.timeout = options.timeout;\n            }\n            // TODO: remove any\n            xhr.send(options.data);\n            // cancel\n            token.onCancellationRequested(() => {\n                xhr.abort();\n                reject(errors_1.canceled());\n            });\n        });\n    };\n    function setRequestHeaders(xhr, options) {\n        if (options.headers) {\n            outer: for (let k in options.headers) {\n                switch (k) {\n                    case 'User-Agent':\n                    case 'Accept-Encoding':\n                    case 'Content-Length':\n                        // unsafe headers\n                        continue outer;\n                }\n                xhr.setRequestHeader(k, options.headers[k]);\n            }\n        }\n    }\n    function getResponseHeaders(xhr) {\n        const headers = Object.create(null);\n        for (const line of xhr.getAllResponseHeaders().split(/\\r\\n|\\n|\\r/g)) {\n            if (line) {\n                const idx = line.indexOf(':');\n                headers[line.substr(0, idx).trim().toLowerCase()] = line.substr(idx + 1).trim();\n            }\n        }\n        return headers;\n    }\n});\n",null]}