{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/node/ripgrepFileSearch.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/node/ripgrepFileSearch.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"child_process\", \"vs/base/common/path\", \"vs/base/common/normalization\", \"vs/base/common/objects\", \"vs/base/common/extpath\", \"vs/base/common/platform\", \"vs/base/common/strings\", \"vs/workbench/services/search/node/ripgrepSearchUtils\", \"vscode-ripgrep\"], function (require, exports, cp, path, normalization_1, objects, extpath, platform_1, strings, ripgrepSearchUtils_1, vscode_ripgrep_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // If vscode-ripgrep is in an .asar file, then the binary is unpacked.\n    const rgDiskPath = vscode_ripgrep_1.rgPath.replace(/\\bnode_modules\\.asar\\b/, 'node_modules.asar.unpacked');\n    function spawnRipgrepCmd(config, folderQuery, includePattern, excludePattern) {\n        const rgArgs = getRgArgs(config, folderQuery, includePattern, excludePattern);\n        const cwd = folderQuery.folder.fsPath;\n        return {\n            cmd: cp.spawn(rgDiskPath, rgArgs.args, { cwd }),\n            siblingClauses: rgArgs.siblingClauses,\n            rgArgs,\n            cwd\n        };\n    }\n    exports.spawnRipgrepCmd = spawnRipgrepCmd;\n    function getRgArgs(config, folderQuery, includePattern, excludePattern) {\n        const args = ['--files', '--hidden', '--case-sensitive'];\n        // includePattern can't have siblingClauses\n        foldersToIncludeGlobs([folderQuery], includePattern, false).forEach(globArg => {\n            const inclusion = ripgrepSearchUtils_1.anchorGlob(globArg);\n            args.push('-g', inclusion);\n            if (platform_1.isMacintosh) {\n                const normalized = normalization_1.normalizeNFD(inclusion);\n                if (normalized !== inclusion) {\n                    args.push('-g', normalized);\n                }\n            }\n        });\n        const rgGlobs = foldersToRgExcludeGlobs([folderQuery], excludePattern, undefined, false);\n        rgGlobs.globArgs.forEach(globArg => {\n            const exclusion = `!${ripgrepSearchUtils_1.anchorGlob(globArg)}`;\n            args.push('-g', exclusion);\n            if (platform_1.isMacintosh) {\n                const normalized = normalization_1.normalizeNFD(exclusion);\n                if (normalized !== exclusion) {\n                    args.push('-g', normalized);\n                }\n            }\n        });\n        if (folderQuery.disregardIgnoreFiles !== false) {\n            // Don't use .gitignore or .ignore\n            args.push('--no-ignore');\n        }\n        else {\n            args.push('--no-ignore-parent');\n        }\n        // Follow symlinks\n        if (!folderQuery.ignoreSymlinks) {\n            args.push('--follow');\n        }\n        if (config.exists) {\n            args.push('--quiet');\n        }\n        args.push('--no-config');\n        if (folderQuery.disregardGlobalIgnoreFiles) {\n            args.push('--no-ignore-global');\n        }\n        return {\n            args,\n            siblingClauses: rgGlobs.siblingClauses\n        };\n    }\n    function foldersToRgExcludeGlobs(folderQueries, globalExclude, excludesToSkip, absoluteGlobs = true) {\n        const globArgs = [];\n        let siblingClauses = {};\n        folderQueries.forEach(folderQuery => {\n            const totalExcludePattern = objects.assign({}, folderQuery.excludePattern || {}, globalExclude || {});\n            const result = globExprsToRgGlobs(totalExcludePattern, absoluteGlobs ? folderQuery.folder.fsPath : undefined, excludesToSkip);\n            globArgs.push(...result.globArgs);\n            if (result.siblingClauses) {\n                siblingClauses = objects.assign(siblingClauses, result.siblingClauses);\n            }\n        });\n        return { globArgs, siblingClauses };\n    }\n    exports.foldersToRgExcludeGlobs = foldersToRgExcludeGlobs;\n    function foldersToIncludeGlobs(folderQueries, globalInclude, absoluteGlobs = true) {\n        const globArgs = [];\n        folderQueries.forEach(folderQuery => {\n            const totalIncludePattern = objects.assign({}, globalInclude || {}, folderQuery.includePattern || {});\n            const result = globExprsToRgGlobs(totalIncludePattern, absoluteGlobs ? folderQuery.folder.fsPath : undefined);\n            globArgs.push(...result.globArgs);\n        });\n        return globArgs;\n    }\n    exports.foldersToIncludeGlobs = foldersToIncludeGlobs;\n    function globExprsToRgGlobs(patterns, folder, excludesToSkip) {\n        const globArgs = [];\n        const siblingClauses = {};\n        Object.keys(patterns)\n            .forEach(key => {\n            if (excludesToSkip && excludesToSkip.has(key)) {\n                return;\n            }\n            if (!key) {\n                return;\n            }\n            const value = patterns[key];\n            key = trimTrailingSlash(folder ? getAbsoluteGlob(folder, key) : key);\n            // glob.ts requires forward slashes, but a UNC path still must start with \\\\\n            // #38165 and #38151\n            if (strings.startsWith(key, '\\\\\\\\')) {\n                key = '\\\\\\\\' + key.substr(2).replace(/\\\\/g, '/');\n            }\n            else {\n                key = key.replace(/\\\\/g, '/');\n            }\n            if (typeof value === 'boolean' && value) {\n                if (strings.startsWith(key, '\\\\\\\\')) {\n                    // Absolute globs UNC paths don't work properly, see #58758\n                    key += '**';\n                }\n                globArgs.push(fixDriveC(key));\n            }\n            else if (value && value.when) {\n                siblingClauses[key] = value;\n            }\n        });\n        return { globArgs, siblingClauses };\n    }\n    /**\n     * Resolves a glob like \"node_modules/**\" in \"/foo/bar\" to \"/foo/bar/node_modules/**\".\n     * Special cases C:/foo paths to write the glob like /foo instead - see https://github.com/BurntSushi/ripgrep/issues/530.\n     *\n     * Exported for testing\n     */\n    function getAbsoluteGlob(folder, key) {\n        return path.isAbsolute(key) ?\n            key :\n            path.join(folder, key);\n    }\n    exports.getAbsoluteGlob = getAbsoluteGlob;\n    function trimTrailingSlash(str) {\n        str = strings.rtrim(str, '\\\\');\n        return strings.rtrim(str, '/');\n    }\n    function fixDriveC(path) {\n        const root = extpath.getRoot(path);\n        return root.toLowerCase() === 'c:/' ?\n            path.replace(/^c:[/\\\\]/i, '/') :\n            path;\n    }\n    exports.fixDriveC = fixDriveC;\n});\n",null]}