{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/electron-browser/extensionHostProcessManager.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/electron-browser/extensionHostProcessManager.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/errors\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/base/common/strings\", \"vs/platform/environment/common/environment\", \"vs/platform/instantiation/common/instantiation\", \"vs/workbench/api/common/extHostCustomers\", \"vs/workbench/api/common/extHost.protocol\", \"vs/workbench/services/extensions/electron-browser/extensionHostProfiler\", \"vs/workbench/services/extensions/node/rpcProtocol\", \"vs/nls\", \"vs/base/common/actions\", \"vs/platform/actions/common/actions\", \"vs/platform/registry/common/platform\", \"vs/workbench/common/actions\", \"vs/workbench/services/editor/common/editorService\", \"vs/base/common/stopwatch\"], function (require, exports, errors, event_1, lifecycle_1, strings, environment_1, instantiation_1, extHostCustomers_1, extHost_protocol_1, extensionHostProfiler_1, rpcProtocol_1, nls, actions_1, actions_2, platform_1, actions_3, editorService_1, stopwatch_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // Enable to see detailed message communication between window and extension host\n    const LOG_EXTENSION_HOST_COMMUNICATION = false;\n    const LOG_USE_COLORS = true;\n    const NO_OP_VOID_PROMISE = Promise.resolve(undefined);\n    let ExtensionHostProcessManager = class ExtensionHostProcessManager extends lifecycle_1.Disposable {\n        constructor(extensionHostProcessWorker, _remoteAuthority, initialActivationEvents, _instantiationService, _environmentService) {\n            super();\n            this._remoteAuthority = _remoteAuthority;\n            this._instantiationService = _instantiationService;\n            this._environmentService = _environmentService;\n            this._onDidChangeResponsiveState = this._register(new event_1.Emitter());\n            this.onDidChangeResponsiveState = this._onDidChangeResponsiveState.event;\n            this._extensionHostProcessFinishedActivateEvents = Object.create(null);\n            this._extensionHostProcessRPCProtocol = null;\n            this._extensionHostProcessCustomers = [];\n            this._extensionHostProcessWorker = extensionHostProcessWorker;\n            this.onDidCrash = this._extensionHostProcessWorker.onCrashed;\n            this._extensionHostProcessProxy = this._extensionHostProcessWorker.start().then((protocol) => {\n                return { value: this._createExtensionHostCustomers(protocol) };\n            }, (err) => {\n                console.error('Error received from starting extension host');\n                console.error(err);\n                return null;\n            });\n            this._extensionHostProcessProxy.then(() => {\n                initialActivationEvents.forEach((activationEvent) => this.activateByEvent(activationEvent));\n                this._register(registerLatencyTestProvider({\n                    measure: () => this.measure()\n                }));\n            });\n        }\n        dispose() {\n            if (this._extensionHostProcessWorker) {\n                this._extensionHostProcessWorker.dispose();\n            }\n            if (this._extensionHostProcessRPCProtocol) {\n                this._extensionHostProcessRPCProtocol.dispose();\n            }\n            for (let i = 0, len = this._extensionHostProcessCustomers.length; i < len; i++) {\n                const customer = this._extensionHostProcessCustomers[i];\n                try {\n                    customer.dispose();\n                }\n                catch (err) {\n                    errors.onUnexpectedError(err);\n                }\n            }\n            this._extensionHostProcessProxy = null;\n            super.dispose();\n        }\n        measure() {\n            return __awaiter(this, void 0, void 0, function* () {\n                const proxy = yield this._getExtensionHostProcessProxy();\n                if (!proxy) {\n                    return null;\n                }\n                const latency = yield this._measureLatency(proxy);\n                const down = yield this._measureDown(proxy);\n                const up = yield this._measureUp(proxy);\n                return {\n                    remoteAuthority: this._remoteAuthority,\n                    latency,\n                    down,\n                    up\n                };\n            });\n        }\n        _getExtensionHostProcessProxy() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!this._extensionHostProcessProxy) {\n                    return null;\n                }\n                const p = yield this._extensionHostProcessProxy;\n                if (!p) {\n                    return null;\n                }\n                return p.value;\n            });\n        }\n        _measureLatency(proxy) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const COUNT = 10;\n                let sum = 0;\n                for (let i = 0; i < COUNT; i++) {\n                    const sw = stopwatch_1.StopWatch.create(true);\n                    yield proxy.$test_latency(i);\n                    sw.stop();\n                    sum += sw.elapsed();\n                }\n                return (sum / COUNT);\n            });\n        }\n        static _convert(byteCount, elapsedMillis) {\n            return (byteCount * 1000 * 8) / elapsedMillis;\n        }\n        _measureUp(proxy) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const SIZE = 10 * 1024 * 1024; // 10MB\n                let b = Buffer.alloc(SIZE, Math.random() % 256);\n                const sw = stopwatch_1.StopWatch.create(true);\n                yield proxy.$test_up(b);\n                sw.stop();\n                return ExtensionHostProcessManager._convert(SIZE, sw.elapsed());\n            });\n        }\n        _measureDown(proxy) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const SIZE = 10 * 1024 * 1024; // 10MB\n                const sw = stopwatch_1.StopWatch.create(true);\n                yield proxy.$test_down(SIZE);\n                sw.stop();\n                return ExtensionHostProcessManager._convert(SIZE, sw.elapsed());\n            });\n        }\n        canProfileExtensionHost() {\n            return this._extensionHostProcessWorker && Boolean(this._extensionHostProcessWorker.getInspectPort());\n        }\n        _createExtensionHostCustomers(protocol) {\n            let logger = null;\n            if (LOG_EXTENSION_HOST_COMMUNICATION || this._environmentService.logExtensionHostCommunication) {\n                logger = new RPCLogger();\n            }\n            this._extensionHostProcessRPCProtocol = new rpcProtocol_1.RPCProtocol(protocol, logger);\n            this._register(this._extensionHostProcessRPCProtocol.onDidChangeResponsiveState((responsiveState) => this._onDidChangeResponsiveState.fire(responsiveState)));\n            const extHostContext = {\n                remoteAuthority: this._remoteAuthority,\n                getProxy: (identifier) => this._extensionHostProcessRPCProtocol.getProxy(identifier),\n                set: (identifier, instance) => this._extensionHostProcessRPCProtocol.set(identifier, instance),\n                assertRegistered: (identifiers) => this._extensionHostProcessRPCProtocol.assertRegistered(identifiers),\n            };\n            // Named customers\n            const namedCustomers = extHostCustomers_1.ExtHostCustomersRegistry.getNamedCustomers();\n            for (let i = 0, len = namedCustomers.length; i < len; i++) {\n                const [id, ctor] = namedCustomers[i];\n                const instance = this._instantiationService.createInstance(ctor, extHostContext);\n                this._extensionHostProcessCustomers.push(instance);\n                this._extensionHostProcessRPCProtocol.set(id, instance);\n            }\n            // Customers\n            const customers = extHostCustomers_1.ExtHostCustomersRegistry.getCustomers();\n            for (const ctor of customers) {\n                const instance = this._instantiationService.createInstance(ctor, extHostContext);\n                this._extensionHostProcessCustomers.push(instance);\n            }\n            // Check that no named customers are missing\n            const expected = Object.keys(extHost_protocol_1.MainContext).map((key) => extHost_protocol_1.MainContext[key]);\n            this._extensionHostProcessRPCProtocol.assertRegistered(expected);\n            return this._extensionHostProcessRPCProtocol.getProxy(extHost_protocol_1.ExtHostContext.ExtHostExtensionService);\n        }\n        activate(extension, activationEvent) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const proxy = yield this._getExtensionHostProcessProxy();\n                if (!proxy) {\n                    return false;\n                }\n                return proxy.$activate(extension, activationEvent);\n            });\n        }\n        activateByEvent(activationEvent) {\n            if (this._extensionHostProcessFinishedActivateEvents[activationEvent] || !this._extensionHostProcessProxy) {\n                return NO_OP_VOID_PROMISE;\n            }\n            return this._extensionHostProcessProxy.then((proxy) => {\n                if (!proxy) {\n                    // this case is already covered above and logged.\n                    // i.e. the extension host could not be started\n                    return NO_OP_VOID_PROMISE;\n                }\n                return proxy.value.$activateByEvent(activationEvent);\n            }).then(() => {\n                this._extensionHostProcessFinishedActivateEvents[activationEvent] = true;\n            });\n        }\n        startExtensionHostProfile() {\n            if (this._extensionHostProcessWorker) {\n                let port = this._extensionHostProcessWorker.getInspectPort();\n                if (port) {\n                    return this._instantiationService.createInstance(extensionHostProfiler_1.ExtensionHostProfiler, port).start();\n                }\n            }\n            throw new Error('Extension host not running or no inspect port available');\n        }\n        getInspectPort() {\n            if (this._extensionHostProcessWorker) {\n                let port = this._extensionHostProcessWorker.getInspectPort();\n                if (port) {\n                    return port;\n                }\n            }\n            return 0;\n        }\n        resolveAuthority(remoteAuthority) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const authorityPlusIndex = remoteAuthority.indexOf('+');\n                if (authorityPlusIndex === -1) {\n                    // This authority does not need to be resolved, simply parse the port number\n                    const pieces = remoteAuthority.split(':');\n                    return Promise.resolve({\n                        authority: remoteAuthority,\n                        host: pieces[0],\n                        port: parseInt(pieces[1], 10)\n                    });\n                }\n                const proxy = yield this._getExtensionHostProcessProxy();\n                if (!proxy) {\n                    throw new Error(`Cannot resolve authority`);\n                }\n                return proxy.$resolveAuthority(remoteAuthority);\n            });\n        }\n        start(enabledExtensionIds) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const proxy = yield this._getExtensionHostProcessProxy();\n                if (!proxy) {\n                    return;\n                }\n                return proxy.$startExtensionHost(enabledExtensionIds);\n            });\n        }\n        deltaExtensions(toAdd, toRemove) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const proxy = yield this._getExtensionHostProcessProxy();\n                if (!proxy) {\n                    return;\n                }\n                return proxy.$deltaExtensions(toAdd, toRemove);\n            });\n        }\n    };\n    ExtensionHostProcessManager = __decorate([\n        __param(3, instantiation_1.IInstantiationService),\n        __param(4, environment_1.IEnvironmentService)\n    ], ExtensionHostProcessManager);\n    exports.ExtensionHostProcessManager = ExtensionHostProcessManager;\n    const colorTables = [\n        ['#2977B1', '#FC802D', '#34A13A', '#D3282F', '#9366BA'],\n        ['#8B564C', '#E177C0', '#7F7F7F', '#BBBE3D', '#2EBECD']\n    ];\n    function prettyWithoutArrays(data) {\n        if (Array.isArray(data)) {\n            return data;\n        }\n        if (data && typeof data === 'object' && typeof data.toString === 'function') {\n            let result = data.toString();\n            if (result !== '[object Object]') {\n                return result;\n            }\n        }\n        return data;\n    }\n    function pretty(data) {\n        if (Array.isArray(data)) {\n            return data.map(prettyWithoutArrays);\n        }\n        return prettyWithoutArrays(data);\n    }\n    class RPCLogger {\n        constructor() {\n            this._totalIncoming = 0;\n            this._totalOutgoing = 0;\n        }\n        _log(direction, totalLength, msgLength, req, initiator, str, data) {\n            data = pretty(data);\n            const colorTable = colorTables[initiator];\n            const color = LOG_USE_COLORS ? colorTable[req % colorTable.length] : '#000000';\n            let args = [`%c[${direction}]%c[${strings.pad(totalLength, 7, ' ')}]%c[len: ${strings.pad(msgLength, 5, ' ')}]%c${strings.pad(req, 5, ' ')} - ${str}`, 'color: darkgreen', 'color: grey', 'color: grey', `color: ${color}`];\n            if (/\\($/.test(str)) {\n                args = args.concat(data);\n                args.push(')');\n            }\n            else {\n                args.push(data);\n            }\n            console.log.apply(console, args);\n        }\n        logIncoming(msgLength, req, initiator, str, data) {\n            this._totalIncoming += msgLength;\n            this._log('Ext \\u2192 Win', this._totalIncoming, msgLength, req, initiator, str, data);\n        }\n        logOutgoing(msgLength, req, initiator, str, data) {\n            this._totalOutgoing += msgLength;\n            this._log('Win \\u2192 Ext', this._totalOutgoing, msgLength, req, initiator, str, data);\n        }\n    }\n    let providers = [];\n    function registerLatencyTestProvider(provider) {\n        providers.push(provider);\n        return {\n            dispose: () => {\n                for (let i = 0; i < providers.length; i++) {\n                    if (providers[i] === provider) {\n                        providers.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n        };\n    }\n    function getLatencyTestProviders() {\n        return providers.slice(0);\n    }\n    let MeasureExtHostLatencyAction = class MeasureExtHostLatencyAction extends actions_1.Action {\n        constructor(id, label, _editorService) {\n            super(id, label);\n            this._editorService = _editorService;\n        }\n        run() {\n            return __awaiter(this, void 0, void 0, function* () {\n                const measurements = yield Promise.all(getLatencyTestProviders().map(provider => provider.measure()));\n                this._editorService.openEditor({ contents: measurements.map(MeasureExtHostLatencyAction._print).join('\\n\\n'), options: { pinned: true } });\n            });\n        }\n        static _print(m) {\n            return `${m.remoteAuthority ? `Authority: ${m.remoteAuthority}\\n` : ``}Roundtrip latency: ${m.latency.toFixed(3)}ms\\nUp: ${MeasureExtHostLatencyAction._printSpeed(m.up)}\\nDown: ${MeasureExtHostLatencyAction._printSpeed(m.down)}\\n`;\n        }\n        static _printSpeed(n) {\n            if (n <= 1024) {\n                return `${n} bps`;\n            }\n            if (n < 1024 * 1024) {\n                return `${(n / 1024).toFixed(1)} kbps`;\n            }\n            return `${(n / 1024 / 1024).toFixed(1)} Mbps`;\n        }\n    };\n    MeasureExtHostLatencyAction.ID = 'editor.action.measureExtHostLatency';\n    MeasureExtHostLatencyAction.LABEL = nls.localize('measureExtHostLatency', \"Measure Extension Host Latency\");\n    MeasureExtHostLatencyAction = __decorate([\n        __param(2, editorService_1.IEditorService)\n    ], MeasureExtHostLatencyAction);\n    exports.MeasureExtHostLatencyAction = MeasureExtHostLatencyAction;\n    const registry = platform_1.Registry.as(actions_3.Extensions.WorkbenchActions);\n    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(MeasureExtHostLatencyAction, MeasureExtHostLatencyAction.ID, MeasureExtHostLatencyAction.LABEL), 'Developer: Measure Extension Host Latency', nls.localize('developer', \"Developer\"));\n});\n",null]}