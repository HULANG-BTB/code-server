{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/code/node/cli.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/code/node/cli.ts","mtime":1555846338028},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"child_process\", \"vs/base/common/objects\", \"vs/platform/environment/node/argv\", \"vs/platform/environment/node/argvHelper\", \"vs/platform/product/node/product\", \"vs/platform/product/node/package\", \"vs/base/common/path\", \"os\", \"fs\", \"vs/base/node/pfs\", \"vs/base/node/ports\", \"vs/base/node/encoding\", \"iconv-lite\", \"vs/base/node/extfs\", \"vs/base/common/platform\"], function (require, exports, child_process_1, objects_1, argv_1, argvHelper_1, product_1, package_1, paths, os, fs, pfs_1, ports_1, encoding_1, iconv, extfs_1, platform_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function shouldSpawnCliProcess(argv) {\n        return !!argv['install-source']\n            || !!argv['list-extensions']\n            || !!argv['install-extension']\n            || !!argv['uninstall-extension'];\n    }\n    function main(argv) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let args;\n            try {\n                args = argvHelper_1.parseCLIProcessArgv(argv);\n            }\n            catch (err) {\n                console.error(err.message);\n                return;\n            }\n            const cli = yield new Promise((c, e) => require(['vs/code/node/cliProcessMain'], c, e));\n            yield cli.main(args);\n            return; // Always just do this for now.\n            // Help\n            if (args.help) {\n                const executable = `${product_1.default.applicationName}${os.platform() === 'win32' ? '.exe' : ''}`;\n                console.log(argv_1.buildHelpMessage(product_1.default.nameLong, executable, package_1.default.version));\n            }\n            // Version Info\n            else if (args.version) {\n                console.log(argv_1.buildVersionMessage(package_1.default.version, product_1.default.commit));\n            }\n            // Extensions Management\n            else if (shouldSpawnCliProcess(args)) {\n                const cli = yield new Promise((c, e) => require(['vs/code/node/cliProcessMain'], c, e));\n                yield cli.main(args);\n                return;\n            }\n            // Write File\n            else if (args['file-write']) {\n                const source = args._[0];\n                const target = args._[1];\n                // Validate\n                if (!source || !target || source === target || // make sure source and target are provided and are not the same\n                    !paths.isAbsolute(source) || !paths.isAbsolute(target) || // make sure both source and target are absolute paths\n                    !fs.existsSync(source) || !fs.statSync(source).isFile() || // make sure source exists as file\n                    !fs.existsSync(target) || !fs.statSync(target).isFile() // make sure target exists as file\n                ) {\n                    throw new Error('Using --file-write with invalid arguments.');\n                }\n                try {\n                    // Check for readonly status and chmod if so if we are told so\n                    let targetMode = 0;\n                    let restoreMode = false;\n                    if (!!args['file-chmod']) {\n                        targetMode = fs.statSync(target).mode;\n                        if (!(targetMode & 128) /* readonly */) {\n                            fs.chmodSync(target, targetMode | 128);\n                            restoreMode = true;\n                        }\n                    }\n                    // Write source to target\n                    const data = fs.readFileSync(source);\n                    if (platform_1.isWindows) {\n                        // On Windows we use a different strategy of saving the file\n                        // by first truncating the file and then writing with r+ mode.\n                        // This helps to save hidden files on Windows\n                        // (see https://github.com/Microsoft/vscode/issues/931) and\n                        // prevent removing alternate data streams\n                        // (see https://github.com/Microsoft/vscode/issues/6363)\n                        fs.truncateSync(target, 0);\n                        extfs_1.writeFileAndFlushSync(target, data, { flag: 'r+' });\n                    }\n                    else {\n                        extfs_1.writeFileAndFlushSync(target, data);\n                    }\n                    // Restore previous mode as needed\n                    if (restoreMode) {\n                        fs.chmodSync(target, targetMode);\n                    }\n                }\n                catch (error) {\n                    error.message = `Error using --file-write: ${error.message}`;\n                    throw error;\n                }\n            }\n            // Just Code\n            else {\n                const env = objects_1.assign({}, process.env, {\n                    'VSCODE_CLI': '1',\n                    'ELECTRON_NO_ATTACH_CONSOLE': '1'\n                });\n                delete env['ELECTRON_RUN_AS_NODE'];\n                const processCallbacks = [];\n                const verbose = args.verbose || args.status || typeof args['upload-logs'] !== 'undefined';\n                if (verbose) {\n                    env['ELECTRON_ENABLE_LOGGING'] = '1';\n                    processCallbacks.push((child) => __awaiter(this, void 0, void 0, function* () {\n                        child.stdout.on('data', (data) => console.log(data.toString('utf8').trim()));\n                        child.stderr.on('data', (data) => console.log(data.toString('utf8').trim()));\n                        yield new Promise(c => child.once('exit', () => c()));\n                    }));\n                }\n                let stdinWithoutTty = false;\n                try {\n                    stdinWithoutTty = !process.stdin.isTTY; // Via https://twitter.com/MylesBorins/status/782009479382626304\n                }\n                catch (error) {\n                    // Windows workaround for https://github.com/nodejs/node/issues/11656\n                }\n                const readFromStdin = args._.some(a => a === '-');\n                if (readFromStdin) {\n                    // remove the \"-\" argument when we read from stdin\n                    args._ = args._.filter(a => a !== '-');\n                    argv = argv.filter(a => a !== '-');\n                }\n                let stdinFilePath;\n                if (stdinWithoutTty) {\n                    // Read from stdin: we require a single \"-\" argument to be passed in order to start reading from\n                    // stdin. We do this because there is no reliable way to find out if data is piped to stdin. Just\n                    // checking for stdin being connected to a TTY is not enough (https://github.com/Microsoft/vscode/issues/40351)\n                    if (args._.length === 0 && readFromStdin) {\n                        // prepare temp file to read stdin to\n                        stdinFilePath = paths.join(os.tmpdir(), `code-stdin-${Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 3)}.txt`);\n                        // open tmp file for writing\n                        let stdinFileError;\n                        let stdinFileStream;\n                        try {\n                            stdinFileStream = fs.createWriteStream(stdinFilePath);\n                        }\n                        catch (error) {\n                            stdinFileError = error;\n                        }\n                        if (!stdinFileError) {\n                            // Pipe into tmp file using terminals encoding\n                            encoding_1.resolveTerminalEncoding(verbose).then(encoding => {\n                                const converterStream = iconv.decodeStream(encoding);\n                                process.stdin.pipe(converterStream).pipe(stdinFileStream);\n                            });\n                            // Make sure to open tmp file\n                            argv_1.addArg(argv, stdinFilePath);\n                            // Enable --wait to get all data and ignore adding this to history\n                            argv_1.addArg(argv, '--wait');\n                            argv_1.addArg(argv, '--skip-add-to-recently-opened');\n                            args.wait = true;\n                        }\n                        if (verbose) {\n                            if (stdinFileError) {\n                                console.error(`Failed to create file to read via stdin: ${stdinFileError.toString()}`);\n                            }\n                            else {\n                                console.log(`Reading from stdin via: ${stdinFilePath}`);\n                            }\n                        }\n                    }\n                    // If the user pipes data via stdin but forgot to add the \"-\" argument, help by printing a message\n                    // if we detect that data flows into via stdin after a certain timeout.\n                    else if (args._.length === 0) {\n                        processCallbacks.push(child => new Promise(c => {\n                            const dataListener = () => {\n                                if (platform_1.isWindows) {\n                                    console.log(`Run with '${product_1.default.applicationName} -' to read output from another program (e.g. 'echo Hello World | ${product_1.default.applicationName} -').`);\n                                }\n                                else {\n                                    console.log(`Run with '${product_1.default.applicationName} -' to read from stdin (e.g. 'ps aux | grep code | ${product_1.default.applicationName} -').`);\n                                }\n                                c(undefined);\n                            };\n                            // wait for 1s maximum...\n                            setTimeout(() => {\n                                process.stdin.removeListener('data', dataListener);\n                                c(undefined);\n                            }, 1000);\n                            // ...but finish early if we detect data\n                            process.stdin.once('data', dataListener);\n                        }));\n                    }\n                }\n                // If we are started with --wait create a random temporary file\n                // and pass it over to the starting instance. We can use this file\n                // to wait for it to be deleted to monitor that the edited file\n                // is closed and then exit the waiting process.\n                let waitMarkerFilePath;\n                if (args.wait) {\n                    waitMarkerFilePath = argv_1.createWaitMarkerFile(verbose);\n                    if (waitMarkerFilePath) {\n                        argv_1.addArg(argv, '--waitMarkerFilePath', waitMarkerFilePath);\n                    }\n                }\n                // If we have been started with `--prof-startup` we need to find free ports to profile\n                // the main process, the renderer, and the extension host. We also disable v8 cached data\n                // to get better profile traces. Last, we listen on stdout for a signal that tells us to\n                // stop profiling.\n                if (args['prof-startup']) {\n                    const portMain = yield ports_1.findFreePort(ports_1.randomPort(), 10, 3000);\n                    const portRenderer = yield ports_1.findFreePort(portMain + 1, 10, 3000);\n                    const portExthost = yield ports_1.findFreePort(portRenderer + 1, 10, 3000);\n                    // fail the operation when one of the ports couldn't be accquired.\n                    if (portMain * portRenderer * portExthost === 0) {\n                        throw new Error('Failed to find free ports for profiler. Make sure to shutdown all instances of the editor first.');\n                    }\n                    const filenamePrefix = paths.join(os.homedir(), 'prof-' + Math.random().toString(16).slice(-4));\n                    argv_1.addArg(argv, `--inspect-brk=${portMain}`);\n                    argv_1.addArg(argv, `--remote-debugging-port=${portRenderer}`);\n                    argv_1.addArg(argv, `--inspect-brk-extensions=${portExthost}`);\n                    argv_1.addArg(argv, `--prof-startup-prefix`, filenamePrefix);\n                    argv_1.addArg(argv, `--no-cached-data`);\n                    fs.writeFileSync(filenamePrefix, argv.slice(-6).join('|'));\n                    processCallbacks.push((_child) => __awaiter(this, void 0, void 0, function* () {\n                        class Profiler {\n                            static start(name, filenamePrefix, opts) {\n                                return __awaiter(this, void 0, void 0, function* () {\n                                    const profiler = yield new Promise((resolve_1, reject_1) => { require(['v8-inspect-profiler'], resolve_1, reject_1); });\n                                    let session;\n                                    try {\n                                        session = yield profiler.startProfiling(opts);\n                                    }\n                                    catch (err) {\n                                        console.error(`FAILED to start profiling for '${name}' on port '${opts.port}'`);\n                                    }\n                                    return {\n                                        stop() {\n                                            return __awaiter(this, void 0, void 0, function* () {\n                                                if (!session) {\n                                                    return;\n                                                }\n                                                let suffix = '';\n                                                let profile = yield session.stop();\n                                                if (!process.env['VSCODE_DEV']) {\n                                                    // when running from a not-development-build we remove\n                                                    // absolute filenames because we don't want to reveal anything\n                                                    // about users. We also append the `.txt` suffix to make it\n                                                    // easier to attach these files to GH issues\n                                                    profile = profiler.rewriteAbsolutePaths(profile, 'piiRemoved');\n                                                    suffix = '.txt';\n                                                }\n                                                yield profiler.writeProfile(profile, `${filenamePrefix}.${name}.cpuprofile${suffix}`);\n                                            });\n                                        }\n                                    };\n                                });\n                            }\n                        }\n                        try {\n                            // load and start profiler\n                            const mainProfileRequest = Profiler.start('main', filenamePrefix, { port: portMain });\n                            const extHostProfileRequest = Profiler.start('extHost', filenamePrefix, { port: portExthost, tries: 300 });\n                            const rendererProfileRequest = Profiler.start('renderer', filenamePrefix, {\n                                port: portRenderer,\n                                tries: 200,\n                                target: function (targets) {\n                                    return targets.filter(target => {\n                                        if (!target.webSocketDebuggerUrl) {\n                                            return false;\n                                        }\n                                        if (target.type === 'page') {\n                                            return target.url.indexOf('workbench/workbench.html') > 0;\n                                        }\n                                        else {\n                                            return true;\n                                        }\n                                    })[0];\n                                }\n                            });\n                            const main = yield mainProfileRequest;\n                            const extHost = yield extHostProfileRequest;\n                            const renderer = yield rendererProfileRequest;\n                            // wait for the renderer to delete the\n                            // marker file\n                            yield pfs_1.whenDeleted(filenamePrefix);\n                            // stop profiling\n                            yield main.stop();\n                            yield renderer.stop();\n                            yield extHost.stop();\n                            // re-create the marker file to signal that profiling is done\n                            fs.writeFileSync(filenamePrefix, '');\n                        }\n                        catch (e) {\n                            console.error('Failed to profile startup. Make sure to quit Code first.');\n                        }\n                    }));\n                }\n                if (args['js-flags']) {\n                    const match = /max_old_space_size=(\\d+)/g.exec(args['js-flags']);\n                    if (match && !args['max-memory']) {\n                        argv_1.addArg(argv, `--max-memory=${match[1]}`);\n                    }\n                }\n                const options = {\n                    detached: true,\n                    env\n                };\n                if (typeof args['upload-logs'] !== 'undefined') {\n                    options['stdio'] = ['pipe', 'pipe', 'pipe'];\n                }\n                else if (!verbose) {\n                    options['stdio'] = 'ignore';\n                }\n                const child = child_process_1.spawn(process.execPath, argv.slice(2), options);\n                if (args.wait && waitMarkerFilePath) {\n                    return new Promise(c => {\n                        // Complete when process exits\n                        child.once('exit', () => c(undefined));\n                        // Complete when wait marker file is deleted\n                        pfs_1.whenDeleted(waitMarkerFilePath).then(c, c);\n                    }).then(() => {\n                        // Make sure to delete the tmp stdin file if we have any\n                        if (stdinFilePath) {\n                            fs.unlinkSync(stdinFilePath);\n                        }\n                    });\n                }\n                return Promise.all(processCallbacks.map(callback => callback(child)));\n            }\n        });\n    }\n    exports.main = main;\n    function eventuallyExit(code) {\n        setTimeout(() => process.exit(code), 0);\n    }\n    main(process.argv)\n        .then(() => eventuallyExit(0))\n        .then(null, err => {\n        console.error(err.message || err.stack || err);\n        eventuallyExit(1);\n    });\n});\n",null]}