{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/textfile/common/textFileService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/textfile/common/textFileService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar nls = require(\"vs/nls\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar errors = require(\"vs/base/common/errors\");\nvar objects = require(\"vs/base/common/objects\");\nvar event_1 = require(\"vs/base/common/event\");\nvar platform = require(\"vs/base/common/platform\");\nvar windows_1 = require(\"vs/platform/windows/common/windows\");\nvar backup_1 = require(\"vs/workbench/services/backup/common/backup\");\nvar textfiles_1 = require(\"vs/workbench/services/textfile/common/textfiles\");\nvar editor_1 = require(\"vs/workbench/common/editor\");\nvar lifecycle_1 = require(\"vs/platform/lifecycle/common/lifecycle\");\nvar workspace_1 = require(\"vs/platform/workspace/common/workspace\");\nvar files_1 = require(\"vs/platform/files/common/files\");\nvar configuration_1 = require(\"vs/platform/configuration/common/configuration\");\nvar lifecycle_2 = require(\"vs/base/common/lifecycle\");\nvar environment_1 = require(\"vs/platform/environment/common/environment\");\nvar untitledEditorService_1 = require(\"vs/workbench/services/untitled/common/untitledEditorService\");\nvar untitledEditorModel_1 = require(\"vs/workbench/common/editor/untitledEditorModel\");\nvar textFileEditorModelManager_1 = require(\"vs/workbench/services/textfile/common/textFileEditorModelManager\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar map_1 = require(\"vs/base/common/map\");\nvar network_1 = require(\"vs/base/common/network\");\nvar history_1 = require(\"vs/workbench/services/history/common/history\");\nvar contextkey_1 = require(\"vs/platform/contextkey/common/contextkey\");\nvar textModel_1 = require(\"vs/editor/common/model/textModel\");\nvar modelService_1 = require(\"vs/editor/common/services/modelService\");\nvar notification_1 = require(\"vs/platform/notification/common/notification\");\nvar resources_1 = require(\"vs/base/common/resources\");\nvar remoteHosts_1 = require(\"vs/platform/remote/common/remoteHosts\");\nvar dialogs_1 = require(\"vs/platform/dialogs/common/dialogs\");\nvar modeService_1 = require(\"vs/editor/common/services/modeService\");\nvar editorService_1 = require(\"vs/workbench/services/editor/common/editorService\");\nvar arrays_1 = require(\"vs/base/common/arrays\");\nvar strings_1 = require(\"vs/base/common/strings\");\nvar extensions_1 = require(\"vs/platform/instantiation/common/extensions\");\n/**\n * The workbench file service implementation implements the raw file service spec and adds additional methods on top.\n *\n * It also adds diagnostics and logging around file system operations.\n */\nvar TextFileService = /** @class */ (function (_super) {\n    tslib_1.__extends(TextFileService, _super);\n    function TextFileService(contextService, fileService, untitledEditorService, lifecycleService, instantiationService, configurationService, modeService, modelService, windowService, environmentService, notificationService, backupFileService, windowsService, historyService, contextKeyService, dialogService, fileDialogService, editorService) {\n        var _this = _super.call(this) || this;\n        _this.contextService = contextService;\n        _this.fileService = fileService;\n        _this.untitledEditorService = untitledEditorService;\n        _this.lifecycleService = lifecycleService;\n        _this.configurationService = configurationService;\n        _this.modeService = modeService;\n        _this.modelService = modelService;\n        _this.windowService = windowService;\n        _this.environmentService = environmentService;\n        _this.notificationService = notificationService;\n        _this.backupFileService = backupFileService;\n        _this.windowsService = windowsService;\n        _this.historyService = historyService;\n        _this.dialogService = dialogService;\n        _this.fileDialogService = fileDialogService;\n        _this.editorService = editorService;\n        _this._onAutoSaveConfigurationChange = _this._register(new event_1.Emitter());\n        _this._onFilesAssociationChange = _this._register(new event_1.Emitter());\n        _this._onWillMove = _this._register(new event_1.Emitter());\n        _this._models = instantiationService.createInstance(textFileEditorModelManager_1.TextFileEditorModelManager);\n        _this.autoSaveContext = textfiles_1.AutoSaveContext.bindTo(contextKeyService);\n        var configuration = configurationService.getValue();\n        _this.currentFilesAssociationConfig = configuration && configuration.files && configuration.files.associations;\n        _this.onFilesConfigurationChange(configuration);\n        _this.registerListeners();\n        return _this;\n    }\n    Object.defineProperty(TextFileService.prototype, \"onAutoSaveConfigurationChange\", {\n        get: function () { return this._onAutoSaveConfigurationChange.event; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TextFileService.prototype, \"onFilesAssociationChange\", {\n        get: function () { return this._onFilesAssociationChange.event; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TextFileService.prototype, \"onWillMove\", {\n        get: function () { return this._onWillMove.event; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TextFileService.prototype, \"models\", {\n        get: function () {\n            return this._models;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TextFileService.prototype.resolveTextContent = function (resource, options) {\n        return this.fileService.resolveStreamContent(resource, options).then(function (streamContent) {\n            return textModel_1.createTextBufferFactoryFromStream(streamContent.value).then(function (res) {\n                return {\n                    resource: streamContent.resource,\n                    name: streamContent.name,\n                    mtime: streamContent.mtime,\n                    etag: streamContent.etag,\n                    encoding: streamContent.encoding,\n                    isReadonly: streamContent.isReadonly,\n                    size: streamContent.size,\n                    value: res\n                };\n            });\n        });\n    };\n    TextFileService.prototype.promptForPath = function (resource, defaultUri) {\n        var _this = this;\n        // Help user to find a name for the file by opening it first\n        return this.editorService.openEditor({ resource: resource, options: { revealIfOpened: true, preserveFocus: true, } }).then(function () {\n            return _this.fileDialogService.showSaveDialog(_this.getSaveDialogOptions(defaultUri));\n        });\n    };\n    TextFileService.prototype.getSaveDialogOptions = function (defaultUri) {\n        var _this = this;\n        var options = {\n            defaultUri: defaultUri,\n            title: nls.localize('saveAsTitle', \"Save As\")\n        };\n        // Filters are only enabled on Windows where they work properly\n        if (!platform.isWindows) {\n            return options;\n        }\n        // Build the file filter by using our known languages\n        var ext = defaultUri ? resources_1.extname(defaultUri) : undefined;\n        var matchingFilter;\n        var filters = arrays_1.coalesce(this.modeService.getRegisteredLanguageNames().map(function (languageName) {\n            var extensions = _this.modeService.getExtensions(languageName);\n            if (!extensions || !extensions.length) {\n                return null;\n            }\n            var filter = { name: languageName, extensions: extensions.slice(0, 10).map(function (e) { return strings_1.trim(e, '.'); }) };\n            if (ext && extensions.indexOf(ext) >= 0) {\n                matchingFilter = filter;\n                return null; // matching filter will be added last to the top\n            }\n            return filter;\n        }));\n        // Filters are a bit weird on Windows, based on having a match or not:\n        // Match: we put the matching filter first so that it shows up selected and the all files last\n        // No match: we put the all files filter first\n        var allFilesFilter = { name: nls.localize('allFiles', \"All Files\"), extensions: ['*'] };\n        if (matchingFilter) {\n            filters.unshift(matchingFilter);\n            filters.unshift(allFilesFilter);\n        }\n        else {\n            filters.unshift(allFilesFilter);\n        }\n        // Allow to save file without extension\n        filters.push({ name: nls.localize('noExt', \"No Extension\"), extensions: [''] });\n        options.filters = filters;\n        return options;\n    };\n    TextFileService.prototype.confirmSave = function (resources) {\n        if (this.environmentService.isExtensionDevelopment) {\n            return Promise.resolve(editor_1.ConfirmResult.DONT_SAVE); // no veto when we are in extension dev mode because we cannot assum we run interactive (e.g. tests)\n        }\n        var resourcesToConfirm = this.getDirty(resources);\n        if (resourcesToConfirm.length === 0) {\n            return Promise.resolve(editor_1.ConfirmResult.DONT_SAVE);\n        }\n        var message = resourcesToConfirm.length === 1 ? nls.localize('saveChangesMessage', \"Do you want to save the changes you made to {0}?\", resources_1.basename(resourcesToConfirm[0]))\n            : dialogs_1.getConfirmMessage(nls.localize('saveChangesMessages', \"Do you want to save the changes to the following {0} files?\", resourcesToConfirm.length), resourcesToConfirm);\n        var buttons = [\n            resourcesToConfirm.length > 1 ? nls.localize({ key: 'saveAll', comment: ['&& denotes a mnemonic'] }, \"&&Save All\") : nls.localize({ key: 'save', comment: ['&& denotes a mnemonic'] }, \"&&Save\"),\n            nls.localize({ key: 'dontSave', comment: ['&& denotes a mnemonic'] }, \"Do&&n't Save\"),\n            nls.localize('cancel', \"Cancel\")\n        ];\n        return this.dialogService.show(notification_1.Severity.Warning, message, buttons, {\n            cancelId: 2,\n            detail: nls.localize('saveChangesDetail', \"Your changes will be lost if you don't save them.\")\n        }).then(function (index) {\n            switch (index) {\n                case 0: return editor_1.ConfirmResult.SAVE;\n                case 1: return editor_1.ConfirmResult.DONT_SAVE;\n                default: return editor_1.ConfirmResult.CANCEL;\n            }\n        });\n    };\n    TextFileService.prototype.confirmOverwrite = function (resource) {\n        var confirm = {\n            message: nls.localize('confirmOverwrite', \"'{0}' already exists. Do you want to replace it?\", resources_1.basename(resource)),\n            detail: nls.localize('irreversible', \"A file or folder with the same name already exists in the folder {0}. Replacing it will overwrite its current contents.\", resources_1.basename(resources_1.dirname(resource))),\n            primaryButton: nls.localize({ key: 'replaceButtonLabel', comment: ['&& denotes a mnemonic'] }, \"&&Replace\"),\n            type: 'warning'\n        };\n        return this.dialogService.confirm(confirm).then(function (result) { return result.confirmed; });\n    };\n    TextFileService.prototype.registerListeners = function () {\n        var _this = this;\n        // Lifecycle\n        this.lifecycleService.onBeforeShutdown(function (event) { return event.veto(_this.beforeShutdown(event.reason)); });\n        this.lifecycleService.onShutdown(this.dispose, this);\n        // Files configuration changes\n        this._register(this.configurationService.onDidChangeConfiguration(function (e) {\n            if (e.affectsConfiguration('files')) {\n                _this.onFilesConfigurationChange(_this.configurationService.getValue());\n            }\n        }));\n    };\n    TextFileService.prototype.beforeShutdown = function (reason) {\n        var _this = this;\n        // Dirty files need treatment on shutdown\n        var dirty = this.getDirty();\n        if (dirty.length) {\n            // If auto save is enabled, save all files and then check again for dirty files\n            // We DO NOT run any save participant if we are in the shutdown phase for performance reasons\n            if (this.getAutoSaveMode() !== textfiles_1.AutoSaveMode.OFF) {\n                return this.saveAll(false /* files only */, { skipSaveParticipants: true }).then(function () {\n                    // If we still have dirty files, we either have untitled ones or files that cannot be saved\n                    var remainingDirty = _this.getDirty();\n                    if (remainingDirty.length) {\n                        return _this.handleDirtyBeforeShutdown(remainingDirty, reason);\n                    }\n                    return false;\n                });\n            }\n            // Auto save is not enabled\n            return this.handleDirtyBeforeShutdown(dirty, reason);\n        }\n        // No dirty files: no veto\n        return this.noVeto({ cleanUpBackups: true });\n    };\n    TextFileService.prototype.handleDirtyBeforeShutdown = function (dirty, reason) {\n        var _this = this;\n        // If hot exit is enabled, backup dirty files and allow to exit without confirmation\n        if (this.isHotExitEnabled) {\n            return this.backupBeforeShutdown(dirty, this.models, reason).then(function (result) {\n                if (result.didBackup) {\n                    return _this.noVeto({ cleanUpBackups: false }); // no veto and no backup cleanup (since backup was successful)\n                }\n                // since a backup did not happen, we have to confirm for the dirty files now\n                return _this.confirmBeforeShutdown();\n            }, function (errors) {\n                var firstError = errors[0];\n                _this.notificationService.error(nls.localize('files.backup.failSave', \"Files that are dirty could not be written to the backup location (Error: {0}). Try saving your files first and then exit.\", firstError.message));\n                return true; // veto, the backups failed\n            });\n        }\n        // Otherwise just confirm from the user what to do with the dirty files\n        return this.confirmBeforeShutdown();\n    };\n    TextFileService.prototype.backupBeforeShutdown = function (dirtyToBackup, textFileEditorModelManager, reason) {\n        var _this = this;\n        return this.windowsService.getWindowCount().then(function (windowCount) {\n            // When quit is requested skip the confirm callback and attempt to backup all workspaces.\n            // When quit is not requested the confirm callback should be shown when the window being\n            // closed is the only VS Code window open, except for on Mac where hot exit is only\n            // ever activated when quit is requested.\n            var doBackup;\n            switch (reason) {\n                case lifecycle_1.ShutdownReason.CLOSE:\n                    if (_this.contextService.getWorkbenchState() !== workspace_1.WorkbenchState.EMPTY && _this.configuredHotExit === files_1.HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {\n                        doBackup = true; // backup if a folder is open and onExitAndWindowClose is configured\n                    }\n                    else if (windowCount > 1 || platform.isMacintosh) {\n                        doBackup = false; // do not backup if a window is closed that does not cause quitting of the application\n                    }\n                    else {\n                        doBackup = true; // backup if last window is closed on win/linux where the application quits right after\n                    }\n                    break;\n                case lifecycle_1.ShutdownReason.QUIT:\n                    doBackup = true; // backup because next start we restore all backups\n                    break;\n                case lifecycle_1.ShutdownReason.RELOAD:\n                    doBackup = true; // backup because after window reload, backups restore\n                    break;\n                case lifecycle_1.ShutdownReason.LOAD:\n                    if (_this.contextService.getWorkbenchState() !== workspace_1.WorkbenchState.EMPTY && _this.configuredHotExit === files_1.HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {\n                        doBackup = true; // backup if a folder is open and onExitAndWindowClose is configured\n                    }\n                    else {\n                        doBackup = false; // do not backup because we are switching contexts\n                    }\n                    break;\n            }\n            if (!doBackup) {\n                return { didBackup: false };\n            }\n            // Backup\n            return _this.backupAll(dirtyToBackup, textFileEditorModelManager).then(function () { return { didBackup: true }; });\n        });\n    };\n    TextFileService.prototype.backupAll = function (dirtyToBackup, textFileEditorModelManager) {\n        var _this = this;\n        // split up between files and untitled\n        var filesToBackup = [];\n        var untitledToBackup = [];\n        dirtyToBackup.forEach(function (s) {\n            if (_this.fileService.canHandleResource(s)) {\n                var model = textFileEditorModelManager.get(s);\n                if (model) {\n                    filesToBackup.push(model);\n                }\n            }\n            else if (s.scheme === network_1.Schemas.untitled) {\n                untitledToBackup.push(s);\n            }\n        });\n        return this.doBackupAll(filesToBackup, untitledToBackup);\n    };\n    TextFileService.prototype.doBackupAll = function (dirtyFileModels, untitledResources) {\n        var _this = this;\n        var promises = dirtyFileModels.map(function (model) {\n            var snapshot = model.createSnapshot();\n            if (snapshot) {\n                return _this.backupFileService.backupResource(model.getResource(), snapshot, model.getVersionId());\n            }\n            return Promise.resolve();\n        });\n        // Handle file resources first\n        return Promise.all(promises).then(function (results) {\n            // Handle untitled resources\n            var untitledModelPromises = untitledResources\n                .filter(function (untitled) { return _this.untitledEditorService.exists(untitled); })\n                .map(function (untitled) { return _this.untitledEditorService.loadOrCreate({ resource: untitled }); });\n            return Promise.all(untitledModelPromises).then(function (untitledModels) {\n                var untitledBackupPromises = untitledModels.map(function (model) {\n                    var snapshot = model.createSnapshot();\n                    if (snapshot) {\n                        return _this.backupFileService.backupResource(model.getResource(), snapshot, model.getVersionId());\n                    }\n                    return Promise.resolve();\n                });\n                return Promise.all(untitledBackupPromises).then(function () { return undefined; });\n            });\n        });\n    };\n    TextFileService.prototype.confirmBeforeShutdown = function () {\n        var _this = this;\n        return this.confirmSave().then(function (confirm) {\n            // Save\n            if (confirm === editor_1.ConfirmResult.SAVE) {\n                return _this.saveAll(true /* includeUntitled */, { skipSaveParticipants: true }).then(function (result) {\n                    if (result.results.some(function (r) { return !r.success; })) {\n                        return true; // veto if some saves failed\n                    }\n                    return _this.noVeto({ cleanUpBackups: true });\n                });\n            }\n            // Don't Save\n            else if (confirm === editor_1.ConfirmResult.DONT_SAVE) {\n                // Make sure to revert untitled so that they do not restore\n                // see https://github.com/Microsoft/vscode/issues/29572\n                _this.untitledEditorService.revertAll();\n                return _this.noVeto({ cleanUpBackups: true });\n            }\n            // Cancel\n            else if (confirm === editor_1.ConfirmResult.CANCEL) {\n                return true; // veto\n            }\n            return false;\n        });\n    };\n    TextFileService.prototype.noVeto = function (options) {\n        if (!options.cleanUpBackups) {\n            return false;\n        }\n        if (this.lifecycleService.phase < lifecycle_1.LifecyclePhase.Restored) {\n            return false; // if editors have not restored, we are not up to speed with backups and thus should not clean them\n        }\n        return this.cleanupBackupsBeforeShutdown().then(function () { return false; }, function () { return false; });\n    };\n    TextFileService.prototype.cleanupBackupsBeforeShutdown = function () {\n        if (this.environmentService.isExtensionDevelopment) {\n            return Promise.resolve(undefined);\n        }\n        return this.backupFileService.discardAllWorkspaceBackups();\n    };\n    TextFileService.prototype.onFilesConfigurationChange = function (configuration) {\n        var wasAutoSaveEnabled = (this.getAutoSaveMode() !== textfiles_1.AutoSaveMode.OFF);\n        var autoSaveMode = (configuration && configuration.files && configuration.files.autoSave) || files_1.AutoSaveConfiguration.OFF;\n        this.autoSaveContext.set(autoSaveMode);\n        switch (autoSaveMode) {\n            case files_1.AutoSaveConfiguration.AFTER_DELAY:\n                this.configuredAutoSaveDelay = configuration && configuration.files && configuration.files.autoSaveDelay;\n                this.configuredAutoSaveOnFocusChange = false;\n                this.configuredAutoSaveOnWindowChange = false;\n                break;\n            case files_1.AutoSaveConfiguration.ON_FOCUS_CHANGE:\n                this.configuredAutoSaveDelay = undefined;\n                this.configuredAutoSaveOnFocusChange = true;\n                this.configuredAutoSaveOnWindowChange = false;\n                break;\n            case files_1.AutoSaveConfiguration.ON_WINDOW_CHANGE:\n                this.configuredAutoSaveDelay = undefined;\n                this.configuredAutoSaveOnFocusChange = false;\n                this.configuredAutoSaveOnWindowChange = true;\n                break;\n            default:\n                this.configuredAutoSaveDelay = undefined;\n                this.configuredAutoSaveOnFocusChange = false;\n                this.configuredAutoSaveOnWindowChange = false;\n                break;\n        }\n        // Emit as event\n        this._onAutoSaveConfigurationChange.fire(this.getAutoSaveConfiguration());\n        // save all dirty when enabling auto save\n        if (!wasAutoSaveEnabled && this.getAutoSaveMode() !== textfiles_1.AutoSaveMode.OFF) {\n            this.saveAll();\n        }\n        // Check for change in files associations\n        var filesAssociation = configuration && configuration.files && configuration.files.associations;\n        if (!objects.equals(this.currentFilesAssociationConfig, filesAssociation)) {\n            this.currentFilesAssociationConfig = filesAssociation;\n            this._onFilesAssociationChange.fire();\n        }\n        // Hot exit\n        var hotExitMode = configuration && configuration.files && configuration.files.hotExit;\n        if (hotExitMode === files_1.HotExitConfiguration.OFF || hotExitMode === files_1.HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {\n            this.configuredHotExit = hotExitMode;\n        }\n        else {\n            this.configuredHotExit = files_1.HotExitConfiguration.ON_EXIT;\n        }\n    };\n    TextFileService.prototype.getDirty = function (resources) {\n        // Collect files\n        var dirty = this.getDirtyFileModels(resources).map(function (m) { return m.getResource(); });\n        // Add untitled ones\n        dirty.push.apply(dirty, this.untitledEditorService.getDirty(resources));\n        return dirty;\n    };\n    TextFileService.prototype.isDirty = function (resource) {\n        // Check for dirty file\n        if (this._models.getAll(resource).some(function (model) { return model.isDirty(); })) {\n            return true;\n        }\n        // Check for dirty untitled\n        return this.untitledEditorService.getDirty().some(function (dirty) { return !resource || dirty.toString() === resource.toString(); });\n    };\n    TextFileService.prototype.save = function (resource, options) {\n        // Run a forced save if we detect the file is not dirty so that save participants can still run\n        if (options && options.force && this.fileService.canHandleResource(resource) && !this.isDirty(resource)) {\n            var model_1 = this._models.get(resource);\n            if (model_1) {\n                options.reason = textfiles_1.SaveReason.EXPLICIT;\n                return model_1.save(options).then(function () { return !model_1.isDirty(); });\n            }\n        }\n        return this.saveAll([resource], options).then(function (result) { return result.results.length === 1 && !!result.results[0].success; });\n    };\n    TextFileService.prototype.saveAll = function (arg1, options) {\n        // get all dirty\n        var toSave = [];\n        if (Array.isArray(arg1)) {\n            toSave = this.getDirty(arg1);\n        }\n        else {\n            toSave = this.getDirty();\n        }\n        // split up between files and untitled\n        var filesToSave = [];\n        var untitledToSave = [];\n        toSave.forEach(function (s) {\n            if ((Array.isArray(arg1) || arg1 === true /* includeUntitled */) && s.scheme === network_1.Schemas.untitled) {\n                untitledToSave.push(s);\n            }\n            else {\n                filesToSave.push(s);\n            }\n        });\n        return this.doSaveAll(filesToSave, untitledToSave, options);\n    };\n    TextFileService.prototype.doSaveAll = function (fileResources, untitledResources, options) {\n        var _this = this;\n        // Handle files first that can just be saved\n        return this.doSaveAllFiles(fileResources, options).then(function (result) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n            var targetsForUntitled, _i, untitledResources_1, untitled, targetUri, targetPath, untitledSaveAsPromises;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        targetsForUntitled = [];\n                        _i = 0, untitledResources_1 = untitledResources;\n                        _a.label = 1;\n                    case 1:\n                        if (!(_i < untitledResources_1.length)) return [3 /*break*/, 6];\n                        untitled = untitledResources_1[_i];\n                        if (!this.untitledEditorService.exists(untitled)) return [3 /*break*/, 5];\n                        targetUri = void 0;\n                        if (!this.untitledEditorService.hasAssociatedFilePath(untitled)) return [3 /*break*/, 2];\n                        targetUri = this.untitledToAssociatedFileResource(untitled);\n                        return [3 /*break*/, 4];\n                    case 2: return [4 /*yield*/, this.promptForPath(untitled, this.suggestFileName(untitled))];\n                    case 3:\n                        targetPath = _a.sent();\n                        if (!targetPath) {\n                            return [2 /*return*/, Promise.resolve({\n                                    results: fileResources.concat(untitledResources).map(function (r) { return ({ source: r }); })\n                                })];\n                        }\n                        targetUri = targetPath;\n                        _a.label = 4;\n                    case 4:\n                        targetsForUntitled.push(targetUri);\n                        _a.label = 5;\n                    case 5:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 6:\n                        untitledSaveAsPromises = [];\n                        targetsForUntitled.forEach(function (target, index) {\n                            var untitledSaveAsPromise = _this.saveAs(untitledResources[index], target).then(function (uri) {\n                                result.results.push({\n                                    source: untitledResources[index],\n                                    target: uri,\n                                    success: !!uri\n                                });\n                            });\n                            untitledSaveAsPromises.push(untitledSaveAsPromise);\n                        });\n                        return [2 /*return*/, Promise.all(untitledSaveAsPromises).then(function () { return result; })];\n                }\n            });\n        }); });\n    };\n    TextFileService.prototype.untitledToAssociatedFileResource = function (untitled) {\n        var authority = this.windowService.getConfiguration().remoteAuthority;\n        if (authority) {\n            var path = untitled.path;\n            if (path && path[0] !== '/') {\n                path = '/' + path;\n            }\n            return untitled.with({ scheme: remoteHosts_1.REMOTE_HOST_SCHEME, authority: authority, path: path });\n        }\n        return untitled.with({ scheme: network_1.Schemas.file });\n    };\n    TextFileService.prototype.doSaveAllFiles = function (resources, options) {\n        if (options === void 0) { options = Object.create(null); }\n        var dirtyFileModels = this.getDirtyFileModels(Array.isArray(resources) ? resources : undefined /* Save All */)\n            .filter(function (model) {\n            if ((model.hasState(textfiles_1.ModelState.CONFLICT) || model.hasState(textfiles_1.ModelState.ERROR)) && (options.reason === textfiles_1.SaveReason.AUTO || options.reason === textfiles_1.SaveReason.FOCUS_CHANGE || options.reason === textfiles_1.SaveReason.WINDOW_CHANGE)) {\n                return false; // if model is in save conflict or error, do not save unless save reason is explicit or not provided at all\n            }\n            return true;\n        });\n        var mapResourceToResult = new map_1.ResourceMap();\n        dirtyFileModels.forEach(function (m) {\n            mapResourceToResult.set(m.getResource(), {\n                source: m.getResource()\n            });\n        });\n        return Promise.all(dirtyFileModels.map(function (model) {\n            return model.save(options).then(function () {\n                if (!model.isDirty()) {\n                    var result = mapResourceToResult.get(model.getResource());\n                    if (result) {\n                        result.success = true;\n                    }\n                }\n            });\n        })).then(function (r) { return ({ results: mapResourceToResult.values() }); });\n    };\n    TextFileService.prototype.getFileModels = function (arg1) {\n        var _this = this;\n        if (Array.isArray(arg1)) {\n            var models_1 = [];\n            arg1.forEach(function (resource) {\n                models_1.push.apply(models_1, _this.getFileModels(resource));\n            });\n            return models_1;\n        }\n        return this._models.getAll(arg1);\n    };\n    TextFileService.prototype.getDirtyFileModels = function (arg1) {\n        return this.getFileModels(arg1).filter(function (model) { return model.isDirty(); });\n    };\n    TextFileService.prototype.saveAs = function (resource, target, options) {\n        var _this = this;\n        // Get to target resource\n        var targetPromise;\n        if (target) {\n            targetPromise = Promise.resolve(target);\n        }\n        else {\n            var dialogPath = resource;\n            if (resource.scheme === network_1.Schemas.untitled) {\n                dialogPath = this.suggestFileName(resource);\n            }\n            targetPromise = this.promptForPath(resource, dialogPath);\n        }\n        return targetPromise.then(function (target) {\n            if (!target) {\n                return undefined; // user canceled\n            }\n            // Just save if target is same as models own resource\n            if (resource.toString() === target.toString()) {\n                return _this.save(resource, options).then(function () { return resource; });\n            }\n            // Do it\n            return _this.doSaveAs(resource, target, options);\n        });\n    };\n    TextFileService.prototype.doSaveAs = function (resource, target, options) {\n        var _this = this;\n        // Retrieve text model from provided resource if any\n        var modelPromise = Promise.resolve(undefined);\n        if (this.fileService.canHandleResource(resource)) {\n            modelPromise = Promise.resolve(this._models.get(resource));\n        }\n        else if (resource.scheme === network_1.Schemas.untitled && this.untitledEditorService.exists(resource)) {\n            modelPromise = this.untitledEditorService.loadOrCreate({ resource: resource });\n        }\n        return modelPromise.then(function (model) {\n            // We have a model: Use it (can be null e.g. if this file is binary and not a text file or was never opened before)\n            if (model) {\n                return _this.doSaveTextFileAs(model, resource, target, options);\n            }\n            // Otherwise we can only copy\n            return _this.fileService.copyFile(resource, target).then(function () { return true; });\n        }).then(function (result) {\n            // Return early if the operation was not running\n            if (!result) {\n                return target;\n            }\n            // Revert the source\n            return _this.revert(resource).then(function () {\n                // Done: return target\n                return target;\n            });\n        });\n    };\n    TextFileService.prototype.doSaveTextFileAs = function (sourceModel, resource, target, options) {\n        var _this = this;\n        var targetModelResolver;\n        var targetExists = false;\n        // Prefer an existing model if it is already loaded for the given target resource\n        var targetModel = this.models.get(target);\n        if (targetModel && targetModel.isResolved()) {\n            targetModelResolver = Promise.resolve(targetModel);\n            targetExists = true;\n        }\n        // Otherwise create the target file empty if it does not exist already and resolve it from there\n        else {\n            targetModelResolver = this.fileService.existsFile(target).then(function (exists) {\n                targetExists = exists;\n                // create target model adhoc if file does not exist yet\n                if (!targetExists) {\n                    return _this.fileService.updateContent(target, '');\n                }\n                return undefined;\n            }).then(function () { return _this.models.loadOrCreate(target); });\n        }\n        return targetModelResolver.then(function (targetModel) {\n            // Confirm to overwrite if we have an untitled file with associated file where\n            // the file actually exists on disk and we are instructed to save to that file\n            // path. This can happen if the file was created after the untitled file was opened.\n            // See https://github.com/Microsoft/vscode/issues/67946\n            var confirmWrite;\n            if (sourceModel instanceof untitledEditorModel_1.UntitledEditorModel && sourceModel.hasAssociatedFilePath && targetExists && resources_1.isEqual(target, _this.untitledToAssociatedFileResource(sourceModel.getResource()))) {\n                confirmWrite = _this.confirmOverwrite(target);\n            }\n            else {\n                confirmWrite = Promise.resolve(true);\n            }\n            return confirmWrite.then(function (write) {\n                if (!write) {\n                    return false;\n                }\n                // take over encoding and model value from source model\n                targetModel.updatePreferredEncoding(sourceModel.getEncoding());\n                if (targetModel.textEditorModel) {\n                    var snapshot = sourceModel.createSnapshot();\n                    if (snapshot) {\n                        _this.modelService.updateModel(targetModel.textEditorModel, textModel_1.createTextBufferFactoryFromSnapshot(snapshot));\n                    }\n                }\n                // save model\n                return targetModel.save(options).then(function () { return true; });\n            });\n        }, function (error) {\n            // binary model: delete the file and run the operation again\n            if (error.fileOperationResult === files_1.FileOperationResult.FILE_IS_BINARY || error.fileOperationResult === files_1.FileOperationResult.FILE_TOO_LARGE) {\n                return _this.fileService.del(target).then(function () { return _this.doSaveTextFileAs(sourceModel, resource, target, options); });\n            }\n            return Promise.reject(error);\n        });\n    };\n    TextFileService.prototype.suggestFileName = function (untitledResource) {\n        var untitledFileName = this.untitledEditorService.suggestFileName(untitledResource);\n        var remoteAuthority = this.windowService.getConfiguration().remoteAuthority;\n        var schemeFilter = remoteAuthority ? remoteHosts_1.REMOTE_HOST_SCHEME : network_1.Schemas.file;\n        var lastActiveFile = this.historyService.getLastActiveFile(schemeFilter);\n        if (lastActiveFile) {\n            var lastDir = resources_1.dirname(lastActiveFile);\n            return resources_1.joinPath(lastDir, untitledFileName);\n        }\n        var lastActiveFolder = this.historyService.getLastActiveWorkspaceRoot(schemeFilter);\n        if (lastActiveFolder) {\n            return resources_1.joinPath(lastActiveFolder, untitledFileName);\n        }\n        return schemeFilter === network_1.Schemas.file ? uri_1.URI.file(untitledFileName) : uri_1.URI.from({ scheme: schemeFilter, authority: remoteAuthority, path: '/' + untitledFileName });\n    };\n    TextFileService.prototype.revert = function (resource, options) {\n        return this.revertAll([resource], options).then(function (result) { return result.results.length === 1 && !!result.results[0].success; });\n    };\n    TextFileService.prototype.revertAll = function (resources, options) {\n        var _this = this;\n        // Revert files first\n        return this.doRevertAllFiles(resources, options).then(function (operation) {\n            // Revert untitled\n            var reverted = _this.untitledEditorService.revertAll(resources);\n            reverted.forEach(function (res) { return operation.results.push({ source: res, success: true }); });\n            return operation;\n        });\n    };\n    TextFileService.prototype.doRevertAllFiles = function (resources, options) {\n        var fileModels = options && options.force ? this.getFileModels(resources) : this.getDirtyFileModels(resources);\n        var mapResourceToResult = new map_1.ResourceMap();\n        fileModels.forEach(function (m) {\n            mapResourceToResult.set(m.getResource(), {\n                source: m.getResource()\n            });\n        });\n        return Promise.all(fileModels.map(function (model) {\n            return model.revert(options && options.soft).then(function () {\n                if (!model.isDirty()) {\n                    var result = mapResourceToResult.get(model.getResource());\n                    if (result) {\n                        result.success = true;\n                    }\n                }\n            }, function (error) {\n                // FileNotFound means the file got deleted meanwhile, so still record as successful revert\n                if (error.fileOperationResult === files_1.FileOperationResult.FILE_NOT_FOUND) {\n                    var result = mapResourceToResult.get(model.getResource());\n                    if (result) {\n                        result.success = true;\n                    }\n                }\n                // Otherwise bubble up the error\n                else {\n                    return Promise.reject(error);\n                }\n                return undefined;\n            });\n        })).then(function (r) { return ({ results: mapResourceToResult.values() }); });\n    };\n    TextFileService.prototype.create = function (resource, contents, options) {\n        var existingModel = this.models.get(resource);\n        return this.fileService.createFile(resource, contents, options).then(function () {\n            // If we had an existing model for the given resource, load\n            // it again to make sure it is up to date with the contents\n            // we just wrote into the underlying resource by calling\n            // revert()\n            if (existingModel && !existingModel.isDisposed()) {\n                return existingModel.revert();\n            }\n            return undefined;\n        });\n    };\n    TextFileService.prototype.delete = function (resource, options) {\n        var _this = this;\n        var dirtyFiles = this.getDirty().filter(function (dirty) { return resources_1.isEqualOrParent(dirty, resource, !platform.isLinux /* ignorecase */); });\n        return this.revertAll(dirtyFiles, { soft: true }).then(function () { return _this.fileService.del(resource, options); });\n    };\n    TextFileService.prototype.move = function (source, target, overwrite) {\n        var _this = this;\n        var waitForPromises = [];\n        // Event\n        this._onWillMove.fire({\n            oldResource: source,\n            newResource: target,\n            waitUntil: function (promise) {\n                waitForPromises.push(promise.then(undefined, errors.onUnexpectedError));\n            }\n        });\n        // prevent async waitUntil-calls\n        Object.freeze(waitForPromises);\n        return Promise.all(waitForPromises).then(function () {\n            // Handle target models if existing (if target URI is a folder, this can be multiple)\n            var handleTargetModelPromise = Promise.resolve();\n            var dirtyTargetModels = _this.getDirtyFileModels().filter(function (model) { return resources_1.isEqualOrParent(model.getResource(), target, false /* do not ignorecase, see https://github.com/Microsoft/vscode/issues/56384 */); });\n            if (dirtyTargetModels.length) {\n                handleTargetModelPromise = _this.revertAll(dirtyTargetModels.map(function (targetModel) { return targetModel.getResource(); }), { soft: true });\n            }\n            return handleTargetModelPromise.then(function () {\n                // Handle dirty source models if existing (if source URI is a folder, this can be multiple)\n                var handleDirtySourceModels;\n                var dirtySourceModels = _this.getDirtyFileModels().filter(function (model) { return resources_1.isEqualOrParent(model.getResource(), source, !platform.isLinux /* ignorecase */); });\n                var dirtyTargetModels = [];\n                if (dirtySourceModels.length) {\n                    handleDirtySourceModels = Promise.all(dirtySourceModels.map(function (sourceModel) {\n                        var sourceModelResource = sourceModel.getResource();\n                        var targetModelResource;\n                        // If the source is the actual model, just use target as new resource\n                        if (resources_1.isEqual(sourceModelResource, source, !platform.isLinux /* ignorecase */)) {\n                            targetModelResource = target;\n                        }\n                        // Otherwise a parent folder of the source is being moved, so we need\n                        // to compute the target resource based on that\n                        else {\n                            targetModelResource = sourceModelResource.with({ path: resources_1.joinPath(target, sourceModelResource.path.substr(source.path.length + 1)).path });\n                        }\n                        // Remember as dirty target model to load after the operation\n                        dirtyTargetModels.push(targetModelResource);\n                        // Backup dirty source model to the target resource it will become later\n                        var snapshot = sourceModel.createSnapshot();\n                        if (snapshot) {\n                            return _this.backupFileService.backupResource(targetModelResource, snapshot, sourceModel.getVersionId());\n                        }\n                        return Promise.resolve();\n                    }));\n                }\n                else {\n                    handleDirtySourceModels = Promise.resolve();\n                }\n                return handleDirtySourceModels.then(function () {\n                    // Soft revert the dirty source files if any\n                    return _this.revertAll(dirtySourceModels.map(function (dirtySourceModel) { return dirtySourceModel.getResource(); }), { soft: true }).then(function () {\n                        // Rename to target\n                        return _this.fileService.moveFile(source, target, overwrite).then(function () {\n                            // Load models that were dirty before\n                            return Promise.all(dirtyTargetModels.map(function (dirtyTargetModel) { return _this.models.loadOrCreate(dirtyTargetModel); })).then(function () { return undefined; });\n                        }, function (error) {\n                            // In case of an error, discard any dirty target backups that were made\n                            return Promise.all(dirtyTargetModels.map(function (dirtyTargetModel) { return _this.backupFileService.discardResourceBackup(dirtyTargetModel); }))\n                                .then(function () { return Promise.reject(error); });\n                        });\n                    });\n                });\n            });\n        });\n    };\n    TextFileService.prototype.getAutoSaveMode = function () {\n        if (this.configuredAutoSaveOnFocusChange) {\n            return textfiles_1.AutoSaveMode.ON_FOCUS_CHANGE;\n        }\n        if (this.configuredAutoSaveOnWindowChange) {\n            return textfiles_1.AutoSaveMode.ON_WINDOW_CHANGE;\n        }\n        if (this.configuredAutoSaveDelay && this.configuredAutoSaveDelay > 0) {\n            return this.configuredAutoSaveDelay <= 1000 ? textfiles_1.AutoSaveMode.AFTER_SHORT_DELAY : textfiles_1.AutoSaveMode.AFTER_LONG_DELAY;\n        }\n        return textfiles_1.AutoSaveMode.OFF;\n    };\n    TextFileService.prototype.getAutoSaveConfiguration = function () {\n        return {\n            autoSaveDelay: this.configuredAutoSaveDelay && this.configuredAutoSaveDelay > 0 ? this.configuredAutoSaveDelay : undefined,\n            autoSaveFocusChange: this.configuredAutoSaveOnFocusChange,\n            autoSaveApplicationChange: this.configuredAutoSaveOnWindowChange\n        };\n    };\n    Object.defineProperty(TextFileService.prototype, \"isHotExitEnabled\", {\n        get: function () {\n            return !this.environmentService.isExtensionDevelopment && this.configuredHotExit !== files_1.HotExitConfiguration.OFF;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TextFileService.prototype.dispose = function () {\n        // Clear all caches\n        this._models.clear();\n        _super.prototype.dispose.call(this);\n    };\n    TextFileService = tslib_1.__decorate([\n        tslib_1.__param(0, workspace_1.IWorkspaceContextService),\n        tslib_1.__param(1, files_1.IFileService),\n        tslib_1.__param(2, untitledEditorService_1.IUntitledEditorService),\n        tslib_1.__param(3, lifecycle_1.ILifecycleService),\n        tslib_1.__param(4, instantiation_1.IInstantiationService),\n        tslib_1.__param(5, configuration_1.IConfigurationService),\n        tslib_1.__param(6, modeService_1.IModeService),\n        tslib_1.__param(7, modelService_1.IModelService),\n        tslib_1.__param(8, windows_1.IWindowService),\n        tslib_1.__param(9, environment_1.IEnvironmentService),\n        tslib_1.__param(10, notification_1.INotificationService),\n        tslib_1.__param(11, backup_1.IBackupFileService),\n        tslib_1.__param(12, windows_1.IWindowsService),\n        tslib_1.__param(13, history_1.IHistoryService),\n        tslib_1.__param(14, contextkey_1.IContextKeyService),\n        tslib_1.__param(15, dialogs_1.IDialogService),\n        tslib_1.__param(16, dialogs_1.IFileDialogService),\n        tslib_1.__param(17, editorService_1.IEditorService)\n    ], TextFileService);\n    return TextFileService;\n}(lifecycle_2.Disposable));\nexports.TextFileService = TextFileService;\nextensions_1.registerSingleton(textfiles_1.ITextFileService, TextFileService);\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/textfile/common/textFileService.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/textfile/common/textFileService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\nimport { URI } from 'vs/base/common/uri';\nimport * as errors from 'vs/base/common/errors';\nimport * as objects from 'vs/base/common/objects';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport * as platform from 'vs/base/common/platform';\nimport { IWindowsService, IWindowService } from 'vs/platform/windows/common/windows';\nimport { IBackupFileService } from 'vs/workbench/services/backup/common/backup';\nimport { IResult, ITextFileOperationResult, ITextFileService, IRawTextContent, IAutoSaveConfiguration, AutoSaveMode, SaveReason, ITextFileEditorModelManager, ITextFileEditorModel, ModelState, ISaveOptions, AutoSaveContext, IWillMoveEvent } from 'vs/workbench/services/textfile/common/textfiles';\nimport { ConfirmResult, IRevertOptions } from 'vs/workbench/common/editor';\nimport { ILifecycleService, ShutdownReason, LifecyclePhase } from 'vs/platform/lifecycle/common/lifecycle';\nimport { IWorkspaceContextService, WorkbenchState } from 'vs/platform/workspace/common/workspace';\nimport { IFileService, IResolveContentOptions, IFilesConfiguration, FileOperationError, FileOperationResult, AutoSaveConfiguration, HotExitConfiguration } from 'vs/platform/files/common/files';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { IUntitledEditorService } from 'vs/workbench/services/untitled/common/untitledEditorService';\nimport { UntitledEditorModel } from 'vs/workbench/common/editor/untitledEditorModel';\nimport { TextFileEditorModelManager } from 'vs/workbench/services/textfile/common/textFileEditorModelManager';\nimport { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';\nimport { ResourceMap } from 'vs/base/common/map';\nimport { Schemas } from 'vs/base/common/network';\nimport { IHistoryService } from 'vs/workbench/services/history/common/history';\nimport { IContextKey, IContextKeyService } from 'vs/platform/contextkey/common/contextkey';\nimport { createTextBufferFactoryFromSnapshot, createTextBufferFactoryFromStream } from 'vs/editor/common/model/textModel';\nimport { IModelService } from 'vs/editor/common/services/modelService';\nimport { INotificationService, Severity } from 'vs/platform/notification/common/notification';\nimport { isEqualOrParent, isEqual, joinPath, dirname, extname, basename } from 'vs/base/common/resources';\nimport { REMOTE_HOST_SCHEME } from 'vs/platform/remote/common/remoteHosts';\nimport { getConfirmMessage, IDialogService, IFileDialogService, ISaveDialogOptions, IConfirmation } from 'vs/platform/dialogs/common/dialogs';\nimport { IModeService } from 'vs/editor/common/services/modeService';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\nimport { coalesce } from 'vs/base/common/arrays';\nimport { trim } from 'vs/base/common/strings';\nimport { registerSingleton } from 'vs/platform/instantiation/common/extensions';\n\nexport interface IBackupResult {\n\tdidBackup: boolean;\n}\n\n/**\n * The workbench file service implementation implements the raw file service spec and adds additional methods on top.\n *\n * It also adds diagnostics and logging around file system operations.\n */\nexport class TextFileService extends Disposable implements ITextFileService {\n\n\t_serviceBrand: any;\n\n\tprivate readonly _onAutoSaveConfigurationChange: Emitter<IAutoSaveConfiguration> = this._register(new Emitter<IAutoSaveConfiguration>());\n\tget onAutoSaveConfigurationChange(): Event<IAutoSaveConfiguration> { return this._onAutoSaveConfigurationChange.event; }\n\n\tprivate readonly _onFilesAssociationChange: Emitter<void> = this._register(new Emitter<void>());\n\tget onFilesAssociationChange(): Event<void> { return this._onFilesAssociationChange.event; }\n\n\tprivate readonly _onWillMove = this._register(new Emitter<IWillMoveEvent>());\n\tget onWillMove(): Event<IWillMoveEvent> { return this._onWillMove.event; }\n\n\tprivate _models: TextFileEditorModelManager;\n\tprivate currentFilesAssociationConfig: { [key: string]: string; };\n\tprivate configuredAutoSaveDelay?: number;\n\tprivate configuredAutoSaveOnFocusChange: boolean;\n\tprivate configuredAutoSaveOnWindowChange: boolean;\n\tprivate configuredHotExit: string;\n\tprivate autoSaveContext: IContextKey<string>;\n\n\tconstructor(\n\t\t@IWorkspaceContextService private readonly contextService: IWorkspaceContextService,\n\t\t@IFileService protected readonly fileService: IFileService,\n\t\t@IUntitledEditorService private readonly untitledEditorService: IUntitledEditorService,\n\t\t@ILifecycleService private readonly lifecycleService: ILifecycleService,\n\t\t@IInstantiationService instantiationService: IInstantiationService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IModeService private readonly modeService: IModeService,\n\t\t@IModelService private readonly modelService: IModelService,\n\t\t@IWindowService private readonly windowService: IWindowService,\n\t\t@IEnvironmentService private readonly environmentService: IEnvironmentService,\n\t\t@INotificationService private readonly notificationService: INotificationService,\n\t\t@IBackupFileService private readonly backupFileService: IBackupFileService,\n\t\t@IWindowsService private readonly windowsService: IWindowsService,\n\t\t@IHistoryService private readonly historyService: IHistoryService,\n\t\t@IContextKeyService contextKeyService: IContextKeyService,\n\t\t@IDialogService private readonly dialogService: IDialogService,\n\t\t@IFileDialogService private readonly fileDialogService: IFileDialogService,\n\t\t@IEditorService private readonly editorService: IEditorService\n\t) {\n\t\tsuper();\n\n\t\tthis._models = instantiationService.createInstance(TextFileEditorModelManager);\n\t\tthis.autoSaveContext = AutoSaveContext.bindTo(contextKeyService);\n\n\t\tconst configuration = configurationService.getValue<IFilesConfiguration>();\n\t\tthis.currentFilesAssociationConfig = configuration && configuration.files && configuration.files.associations;\n\n\t\tthis.onFilesConfigurationChange(configuration);\n\n\t\tthis.registerListeners();\n\t}\n\n\tget models(): ITextFileEditorModelManager {\n\t\treturn this._models;\n\t}\n\n\tresolveTextContent(resource: URI, options?: IResolveContentOptions): Promise<IRawTextContent> {\n\t\treturn this.fileService.resolveStreamContent(resource, options).then(streamContent => {\n\t\t\treturn createTextBufferFactoryFromStream(streamContent.value).then(res => {\n\t\t\t\treturn {\n\t\t\t\t\tresource: streamContent.resource,\n\t\t\t\t\tname: streamContent.name,\n\t\t\t\t\tmtime: streamContent.mtime,\n\t\t\t\t\tetag: streamContent.etag,\n\t\t\t\t\tencoding: streamContent.encoding,\n\t\t\t\t\tisReadonly: streamContent.isReadonly,\n\t\t\t\t\tsize: streamContent.size,\n\t\t\t\t\tvalue: res\n\t\t\t\t} as IRawTextContent;\n\t\t\t});\n\t\t});\n\t}\n\n\tpromptForPath(resource: URI, defaultUri: URI): Promise<URI | undefined> {\n\n\t\t// Help user to find a name for the file by opening it first\n\t\treturn this.editorService.openEditor({ resource, options: { revealIfOpened: true, preserveFocus: true, } }).then(() => {\n\t\t\treturn this.fileDialogService.showSaveDialog(this.getSaveDialogOptions(defaultUri));\n\t\t});\n\t}\n\n\tprivate getSaveDialogOptions(defaultUri: URI): ISaveDialogOptions {\n\t\tconst options: ISaveDialogOptions = {\n\t\t\tdefaultUri,\n\t\t\ttitle: nls.localize('saveAsTitle', \"Save As\")\n\t\t};\n\n\t\t// Filters are only enabled on Windows where they work properly\n\t\tif (!platform.isWindows) {\n\t\t\treturn options;\n\t\t}\n\n\t\tinterface IFilter { name: string; extensions: string[]; }\n\n\t\t// Build the file filter by using our known languages\n\t\tconst ext: string | undefined = defaultUri ? extname(defaultUri) : undefined;\n\t\tlet matchingFilter: IFilter | undefined;\n\t\tconst filters: IFilter[] = coalesce(this.modeService.getRegisteredLanguageNames().map(languageName => {\n\t\t\tconst extensions = this.modeService.getExtensions(languageName);\n\t\t\tif (!extensions || !extensions.length) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst filter: IFilter = { name: languageName, extensions: extensions.slice(0, 10).map(e => trim(e, '.')) };\n\n\t\t\tif (ext && extensions.indexOf(ext) >= 0) {\n\t\t\t\tmatchingFilter = filter;\n\n\t\t\t\treturn null; // matching filter will be added last to the top\n\t\t\t}\n\n\t\t\treturn filter;\n\t\t}));\n\n\t\t// Filters are a bit weird on Windows, based on having a match or not:\n\t\t// Match: we put the matching filter first so that it shows up selected and the all files last\n\t\t// No match: we put the all files filter first\n\t\tconst allFilesFilter = { name: nls.localize('allFiles', \"All Files\"), extensions: ['*'] };\n\t\tif (matchingFilter) {\n\t\t\tfilters.unshift(matchingFilter);\n\t\t\tfilters.unshift(allFilesFilter);\n\t\t} else {\n\t\t\tfilters.unshift(allFilesFilter);\n\t\t}\n\n\t\t// Allow to save file without extension\n\t\tfilters.push({ name: nls.localize('noExt', \"No Extension\"), extensions: [''] });\n\n\t\toptions.filters = filters;\n\n\t\treturn options;\n\t}\n\n\tconfirmSave(resources?: URI[]): Promise<ConfirmResult> {\n\t\tif (this.environmentService.isExtensionDevelopment) {\n\t\t\treturn Promise.resolve(ConfirmResult.DONT_SAVE); // no veto when we are in extension dev mode because we cannot assum we run interactive (e.g. tests)\n\t\t}\n\n\t\tconst resourcesToConfirm = this.getDirty(resources);\n\t\tif (resourcesToConfirm.length === 0) {\n\t\t\treturn Promise.resolve(ConfirmResult.DONT_SAVE);\n\t\t}\n\n\t\tconst message = resourcesToConfirm.length === 1 ? nls.localize('saveChangesMessage', \"Do you want to save the changes you made to {0}?\", basename(resourcesToConfirm[0]))\n\t\t\t: getConfirmMessage(nls.localize('saveChangesMessages', \"Do you want to save the changes to the following {0} files?\", resourcesToConfirm.length), resourcesToConfirm);\n\n\t\tconst buttons: string[] = [\n\t\t\tresourcesToConfirm.length > 1 ? nls.localize({ key: 'saveAll', comment: ['&& denotes a mnemonic'] }, \"&&Save All\") : nls.localize({ key: 'save', comment: ['&& denotes a mnemonic'] }, \"&&Save\"),\n\t\t\tnls.localize({ key: 'dontSave', comment: ['&& denotes a mnemonic'] }, \"Do&&n't Save\"),\n\t\t\tnls.localize('cancel', \"Cancel\")\n\t\t];\n\n\t\treturn this.dialogService.show(Severity.Warning, message, buttons, {\n\t\t\tcancelId: 2,\n\t\t\tdetail: nls.localize('saveChangesDetail', \"Your changes will be lost if you don't save them.\")\n\t\t}).then(index => {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0: return ConfirmResult.SAVE;\n\t\t\t\tcase 1: return ConfirmResult.DONT_SAVE;\n\t\t\t\tdefault: return ConfirmResult.CANCEL;\n\t\t\t}\n\t\t});\n\t}\n\n\tconfirmOverwrite(resource: URI): Promise<boolean> {\n\t\tconst confirm: IConfirmation = {\n\t\t\tmessage: nls.localize('confirmOverwrite', \"'{0}' already exists. Do you want to replace it?\", basename(resource)),\n\t\t\tdetail: nls.localize('irreversible', \"A file or folder with the same name already exists in the folder {0}. Replacing it will overwrite its current contents.\", basename(dirname(resource))),\n\t\t\tprimaryButton: nls.localize({ key: 'replaceButtonLabel', comment: ['&& denotes a mnemonic'] }, \"&&Replace\"),\n\t\t\ttype: 'warning'\n\t\t};\n\n\t\treturn this.dialogService.confirm(confirm).then(result => result.confirmed);\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Lifecycle\n\t\tthis.lifecycleService.onBeforeShutdown(event => event.veto(this.beforeShutdown(event.reason)));\n\t\tthis.lifecycleService.onShutdown(this.dispose, this);\n\n\t\t// Files configuration changes\n\t\tthis._register(this.configurationService.onDidChangeConfiguration(e => {\n\t\t\tif (e.affectsConfiguration('files')) {\n\t\t\t\tthis.onFilesConfigurationChange(this.configurationService.getValue<IFilesConfiguration>());\n\t\t\t}\n\t\t}));\n\t}\n\n\tprivate beforeShutdown(reason: ShutdownReason): boolean | Promise<boolean> {\n\n\t\t// Dirty files need treatment on shutdown\n\t\tconst dirty = this.getDirty();\n\t\tif (dirty.length) {\n\n\t\t\t// If auto save is enabled, save all files and then check again for dirty files\n\t\t\t// We DO NOT run any save participant if we are in the shutdown phase for performance reasons\n\t\t\tif (this.getAutoSaveMode() !== AutoSaveMode.OFF) {\n\t\t\t\treturn this.saveAll(false /* files only */, { skipSaveParticipants: true }).then(() => {\n\n\t\t\t\t\t// If we still have dirty files, we either have untitled ones or files that cannot be saved\n\t\t\t\t\tconst remainingDirty = this.getDirty();\n\t\t\t\t\tif (remainingDirty.length) {\n\t\t\t\t\t\treturn this.handleDirtyBeforeShutdown(remainingDirty, reason);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Auto save is not enabled\n\t\t\treturn this.handleDirtyBeforeShutdown(dirty, reason);\n\t\t}\n\n\t\t// No dirty files: no veto\n\t\treturn this.noVeto({ cleanUpBackups: true });\n\t}\n\n\tprivate handleDirtyBeforeShutdown(dirty: URI[], reason: ShutdownReason): boolean | Promise<boolean> {\n\n\t\t// If hot exit is enabled, backup dirty files and allow to exit without confirmation\n\t\tif (this.isHotExitEnabled) {\n\t\t\treturn this.backupBeforeShutdown(dirty, this.models, reason).then(result => {\n\t\t\t\tif (result.didBackup) {\n\t\t\t\t\treturn this.noVeto({ cleanUpBackups: false }); // no veto and no backup cleanup (since backup was successful)\n\t\t\t\t}\n\n\t\t\t\t// since a backup did not happen, we have to confirm for the dirty files now\n\t\t\t\treturn this.confirmBeforeShutdown();\n\t\t\t}, errors => {\n\t\t\t\tconst firstError = errors[0];\n\t\t\t\tthis.notificationService.error(nls.localize('files.backup.failSave', \"Files that are dirty could not be written to the backup location (Error: {0}). Try saving your files first and then exit.\", firstError.message));\n\n\t\t\t\treturn true; // veto, the backups failed\n\t\t\t});\n\t\t}\n\n\t\t// Otherwise just confirm from the user what to do with the dirty files\n\t\treturn this.confirmBeforeShutdown();\n\t}\n\n\tprivate backupBeforeShutdown(dirtyToBackup: URI[], textFileEditorModelManager: ITextFileEditorModelManager, reason: ShutdownReason): Promise<IBackupResult> {\n\t\treturn this.windowsService.getWindowCount().then(windowCount => {\n\n\t\t\t// When quit is requested skip the confirm callback and attempt to backup all workspaces.\n\t\t\t// When quit is not requested the confirm callback should be shown when the window being\n\t\t\t// closed is the only VS Code window open, except for on Mac where hot exit is only\n\t\t\t// ever activated when quit is requested.\n\n\t\t\tlet doBackup: boolean | undefined;\n\t\t\tswitch (reason) {\n\t\t\t\tcase ShutdownReason.CLOSE:\n\t\t\t\t\tif (this.contextService.getWorkbenchState() !== WorkbenchState.EMPTY && this.configuredHotExit === HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {\n\t\t\t\t\t\tdoBackup = true; // backup if a folder is open and onExitAndWindowClose is configured\n\t\t\t\t\t} else if (windowCount > 1 || platform.isMacintosh) {\n\t\t\t\t\t\tdoBackup = false; // do not backup if a window is closed that does not cause quitting of the application\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdoBackup = true; // backup if last window is closed on win/linux where the application quits right after\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ShutdownReason.QUIT:\n\t\t\t\t\tdoBackup = true; // backup because next start we restore all backups\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ShutdownReason.RELOAD:\n\t\t\t\t\tdoBackup = true; // backup because after window reload, backups restore\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ShutdownReason.LOAD:\n\t\t\t\t\tif (this.contextService.getWorkbenchState() !== WorkbenchState.EMPTY && this.configuredHotExit === HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {\n\t\t\t\t\t\tdoBackup = true; // backup if a folder is open and onExitAndWindowClose is configured\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdoBackup = false; // do not backup because we are switching contexts\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!doBackup) {\n\t\t\t\treturn { didBackup: false };\n\t\t\t}\n\n\t\t\t// Backup\n\t\t\treturn this.backupAll(dirtyToBackup, textFileEditorModelManager).then(() => { return { didBackup: true }; });\n\t\t});\n\t}\n\n\tprivate backupAll(dirtyToBackup: URI[], textFileEditorModelManager: ITextFileEditorModelManager): Promise<void> {\n\n\t\t// split up between files and untitled\n\t\tconst filesToBackup: ITextFileEditorModel[] = [];\n\t\tconst untitledToBackup: URI[] = [];\n\t\tdirtyToBackup.forEach(s => {\n\t\t\tif (this.fileService.canHandleResource(s)) {\n\t\t\t\tconst model = textFileEditorModelManager.get(s);\n\t\t\t\tif (model) {\n\t\t\t\t\tfilesToBackup.push(model);\n\t\t\t\t}\n\t\t\t} else if (s.scheme === Schemas.untitled) {\n\t\t\t\tuntitledToBackup.push(s);\n\t\t\t}\n\t\t});\n\n\t\treturn this.doBackupAll(filesToBackup, untitledToBackup);\n\t}\n\n\tprivate doBackupAll(dirtyFileModels: ITextFileEditorModel[], untitledResources: URI[]): Promise<void> {\n\t\tconst promises = dirtyFileModels.map(model => {\n\t\t\tconst snapshot = model.createSnapshot();\n\t\t\tif (snapshot) {\n\t\t\t\treturn this.backupFileService.backupResource(model.getResource(), snapshot, model.getVersionId());\n\t\t\t}\n\t\t\treturn Promise.resolve();\n\t\t});\n\n\t\t// Handle file resources first\n\t\treturn Promise.all(promises).then(results => {\n\n\t\t\t// Handle untitled resources\n\t\t\tconst untitledModelPromises = untitledResources\n\t\t\t\t.filter(untitled => this.untitledEditorService.exists(untitled))\n\t\t\t\t.map(untitled => this.untitledEditorService.loadOrCreate({ resource: untitled }));\n\n\t\t\treturn Promise.all(untitledModelPromises).then(untitledModels => {\n\t\t\t\tconst untitledBackupPromises = untitledModels.map(model => {\n\t\t\t\t\tconst snapshot = model.createSnapshot();\n\t\t\t\t\tif (snapshot) {\n\t\t\t\t\t\treturn this.backupFileService.backupResource(model.getResource(), snapshot, model.getVersionId());\n\t\t\t\t\t}\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t});\n\n\t\t\t\treturn Promise.all(untitledBackupPromises).then(() => undefined);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate confirmBeforeShutdown(): boolean | Promise<boolean> {\n\t\treturn this.confirmSave().then(confirm => {\n\n\t\t\t// Save\n\t\t\tif (confirm === ConfirmResult.SAVE) {\n\t\t\t\treturn this.saveAll(true /* includeUntitled */, { skipSaveParticipants: true }).then(result => {\n\t\t\t\t\tif (result.results.some(r => !r.success)) {\n\t\t\t\t\t\treturn true; // veto if some saves failed\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.noVeto({ cleanUpBackups: true });\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Don't Save\n\t\t\telse if (confirm === ConfirmResult.DONT_SAVE) {\n\n\t\t\t\t// Make sure to revert untitled so that they do not restore\n\t\t\t\t// see https://github.com/Microsoft/vscode/issues/29572\n\t\t\t\tthis.untitledEditorService.revertAll();\n\n\t\t\t\treturn this.noVeto({ cleanUpBackups: true });\n\t\t\t}\n\n\t\t\t// Cancel\n\t\t\telse if (confirm === ConfirmResult.CANCEL) {\n\t\t\t\treturn true; // veto\n\t\t\t}\n\n\t\t\treturn false;\n\t\t});\n\t}\n\n\tprivate noVeto(options: { cleanUpBackups: boolean }): boolean | Promise<boolean> {\n\t\tif (!options.cleanUpBackups) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.lifecycleService.phase < LifecyclePhase.Restored) {\n\t\t\treturn false; // if editors have not restored, we are not up to speed with backups and thus should not clean them\n\t\t}\n\n\t\treturn this.cleanupBackupsBeforeShutdown().then(() => false, () => false);\n\t}\n\n\tprotected cleanupBackupsBeforeShutdown(): Promise<void> {\n\t\tif (this.environmentService.isExtensionDevelopment) {\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\n\t\treturn this.backupFileService.discardAllWorkspaceBackups();\n\t}\n\n\tprotected onFilesConfigurationChange(configuration: IFilesConfiguration): void {\n\t\tconst wasAutoSaveEnabled = (this.getAutoSaveMode() !== AutoSaveMode.OFF);\n\n\t\tconst autoSaveMode = (configuration && configuration.files && configuration.files.autoSave) || AutoSaveConfiguration.OFF;\n\t\tthis.autoSaveContext.set(autoSaveMode);\n\t\tswitch (autoSaveMode) {\n\t\t\tcase AutoSaveConfiguration.AFTER_DELAY:\n\t\t\t\tthis.configuredAutoSaveDelay = configuration && configuration.files && configuration.files.autoSaveDelay;\n\t\t\t\tthis.configuredAutoSaveOnFocusChange = false;\n\t\t\t\tthis.configuredAutoSaveOnWindowChange = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AutoSaveConfiguration.ON_FOCUS_CHANGE:\n\t\t\t\tthis.configuredAutoSaveDelay = undefined;\n\t\t\t\tthis.configuredAutoSaveOnFocusChange = true;\n\t\t\t\tthis.configuredAutoSaveOnWindowChange = false;\n\t\t\t\tbreak;\n\n\t\t\tcase AutoSaveConfiguration.ON_WINDOW_CHANGE:\n\t\t\t\tthis.configuredAutoSaveDelay = undefined;\n\t\t\t\tthis.configuredAutoSaveOnFocusChange = false;\n\t\t\t\tthis.configuredAutoSaveOnWindowChange = true;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthis.configuredAutoSaveDelay = undefined;\n\t\t\t\tthis.configuredAutoSaveOnFocusChange = false;\n\t\t\t\tthis.configuredAutoSaveOnWindowChange = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// Emit as event\n\t\tthis._onAutoSaveConfigurationChange.fire(this.getAutoSaveConfiguration());\n\n\t\t// save all dirty when enabling auto save\n\t\tif (!wasAutoSaveEnabled && this.getAutoSaveMode() !== AutoSaveMode.OFF) {\n\t\t\tthis.saveAll();\n\t\t}\n\n\t\t// Check for change in files associations\n\t\tconst filesAssociation = configuration && configuration.files && configuration.files.associations;\n\t\tif (!objects.equals(this.currentFilesAssociationConfig, filesAssociation)) {\n\t\t\tthis.currentFilesAssociationConfig = filesAssociation;\n\t\t\tthis._onFilesAssociationChange.fire();\n\t\t}\n\n\t\t// Hot exit\n\t\tconst hotExitMode = configuration && configuration.files && configuration.files.hotExit;\n\t\tif (hotExitMode === HotExitConfiguration.OFF || hotExitMode === HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {\n\t\t\tthis.configuredHotExit = hotExitMode;\n\t\t} else {\n\t\t\tthis.configuredHotExit = HotExitConfiguration.ON_EXIT;\n\t\t}\n\t}\n\n\tgetDirty(resources?: URI[]): URI[] {\n\n\t\t// Collect files\n\t\tconst dirty = this.getDirtyFileModels(resources).map(m => m.getResource());\n\n\t\t// Add untitled ones\n\t\tdirty.push(...this.untitledEditorService.getDirty(resources));\n\n\t\treturn dirty;\n\t}\n\n\tisDirty(resource?: URI): boolean {\n\n\t\t// Check for dirty file\n\t\tif (this._models.getAll(resource).some(model => model.isDirty())) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check for dirty untitled\n\t\treturn this.untitledEditorService.getDirty().some(dirty => !resource || dirty.toString() === resource.toString());\n\t}\n\n\tsave(resource: URI, options?: ISaveOptions): Promise<boolean> {\n\n\t\t// Run a forced save if we detect the file is not dirty so that save participants can still run\n\t\tif (options && options.force && this.fileService.canHandleResource(resource) && !this.isDirty(resource)) {\n\t\t\tconst model = this._models.get(resource);\n\t\t\tif (model) {\n\t\t\t\toptions.reason = SaveReason.EXPLICIT;\n\n\t\t\t\treturn model.save(options).then(() => !model.isDirty());\n\t\t\t}\n\t\t}\n\n\t\treturn this.saveAll([resource], options).then(result => result.results.length === 1 && !!result.results[0].success);\n\t}\n\n\tsaveAll(includeUntitled?: boolean, options?: ISaveOptions): Promise<ITextFileOperationResult>;\n\tsaveAll(resources: URI[], options?: ISaveOptions): Promise<ITextFileOperationResult>;\n\tsaveAll(arg1?: any, options?: ISaveOptions): Promise<ITextFileOperationResult> {\n\n\t\t// get all dirty\n\t\tlet toSave: URI[] = [];\n\t\tif (Array.isArray(arg1)) {\n\t\t\ttoSave = this.getDirty(arg1);\n\t\t} else {\n\t\t\ttoSave = this.getDirty();\n\t\t}\n\n\t\t// split up between files and untitled\n\t\tconst filesToSave: URI[] = [];\n\t\tconst untitledToSave: URI[] = [];\n\t\ttoSave.forEach(s => {\n\t\t\tif ((Array.isArray(arg1) || arg1 === true /* includeUntitled */) && s.scheme === Schemas.untitled) {\n\t\t\t\tuntitledToSave.push(s);\n\t\t\t} else {\n\t\t\t\tfilesToSave.push(s);\n\t\t\t}\n\t\t});\n\n\t\treturn this.doSaveAll(filesToSave, untitledToSave, options);\n\t}\n\n\tprivate doSaveAll(fileResources: URI[], untitledResources: URI[], options?: ISaveOptions): Promise<ITextFileOperationResult> {\n\n\t\t// Handle files first that can just be saved\n\t\treturn this.doSaveAllFiles(fileResources, options).then(async result => {\n\n\t\t\t// Preflight for untitled to handle cancellation from the dialog\n\t\t\tconst targetsForUntitled: URI[] = [];\n\t\t\tfor (const untitled of untitledResources) {\n\t\t\t\tif (this.untitledEditorService.exists(untitled)) {\n\t\t\t\t\tlet targetUri: URI;\n\n\t\t\t\t\t// Untitled with associated file path don't need to prompt\n\t\t\t\t\tif (this.untitledEditorService.hasAssociatedFilePath(untitled)) {\n\t\t\t\t\t\ttargetUri = this.untitledToAssociatedFileResource(untitled);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise ask user\n\t\t\t\t\telse {\n\t\t\t\t\t\tconst targetPath = await this.promptForPath(untitled, this.suggestFileName(untitled));\n\t\t\t\t\t\tif (!targetPath) {\n\t\t\t\t\t\t\treturn Promise.resolve({\n\t\t\t\t\t\t\t\tresults: [...fileResources, ...untitledResources].map(r => ({ source: r }))\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetUri = targetPath;\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetsForUntitled.push(targetUri);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Handle untitled\n\t\t\tconst untitledSaveAsPromises: Promise<void>[] = [];\n\t\t\ttargetsForUntitled.forEach((target, index) => {\n\t\t\t\tconst untitledSaveAsPromise = this.saveAs(untitledResources[index], target).then(uri => {\n\t\t\t\t\tresult.results.push({\n\t\t\t\t\t\tsource: untitledResources[index],\n\t\t\t\t\t\ttarget: uri,\n\t\t\t\t\t\tsuccess: !!uri\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tuntitledSaveAsPromises.push(untitledSaveAsPromise);\n\t\t\t});\n\n\t\t\treturn Promise.all(untitledSaveAsPromises).then(() => result);\n\t\t});\n\t}\n\n\tprivate untitledToAssociatedFileResource(untitled: URI): URI {\n\t\tconst authority = this.windowService.getConfiguration().remoteAuthority;\n\t\tif (authority) {\n\t\t\tlet path = untitled.path;\n\t\t\tif (path && path[0] !== '/') {\n\t\t\t\tpath = '/' + path;\n\t\t\t}\n\t\t\treturn untitled.with({ scheme: REMOTE_HOST_SCHEME, authority, path });\n\t\t}\n\t\treturn untitled.with({ scheme: Schemas.file });\n\t}\n\n\tprivate doSaveAllFiles(resources?: URI[], options: ISaveOptions = Object.create(null)): Promise<ITextFileOperationResult> {\n\t\tconst dirtyFileModels = this.getDirtyFileModels(Array.isArray(resources) ? resources : undefined /* Save All */)\n\t\t\t.filter(model => {\n\t\t\t\tif ((model.hasState(ModelState.CONFLICT) || model.hasState(ModelState.ERROR)) && (options.reason === SaveReason.AUTO || options.reason === SaveReason.FOCUS_CHANGE || options.reason === SaveReason.WINDOW_CHANGE)) {\n\t\t\t\t\treturn false; // if model is in save conflict or error, do not save unless save reason is explicit or not provided at all\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t});\n\n\t\tconst mapResourceToResult = new ResourceMap<IResult>();\n\t\tdirtyFileModels.forEach(m => {\n\t\t\tmapResourceToResult.set(m.getResource(), {\n\t\t\t\tsource: m.getResource()\n\t\t\t});\n\t\t});\n\n\t\treturn Promise.all(dirtyFileModels.map(model => {\n\t\t\treturn model.save(options).then(() => {\n\t\t\t\tif (!model.isDirty()) {\n\t\t\t\t\tconst result = mapResourceToResult.get(model.getResource());\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tresult.success = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t})).then(r => ({ results: mapResourceToResult.values() }));\n\t}\n\n\tprivate getFileModels(resources?: URI[]): ITextFileEditorModel[];\n\tprivate getFileModels(resource?: URI): ITextFileEditorModel[];\n\tprivate getFileModels(arg1?: any): ITextFileEditorModel[] {\n\t\tif (Array.isArray(arg1)) {\n\t\t\tconst models: ITextFileEditorModel[] = [];\n\t\t\t(<URI[]>arg1).forEach(resource => {\n\t\t\t\tmodels.push(...this.getFileModels(resource));\n\t\t\t});\n\n\t\t\treturn models;\n\t\t}\n\n\t\treturn this._models.getAll(<URI>arg1);\n\t}\n\n\tprivate getDirtyFileModels(resources?: URI[]): ITextFileEditorModel[];\n\tprivate getDirtyFileModels(resource?: URI): ITextFileEditorModel[];\n\tprivate getDirtyFileModels(arg1?: any): ITextFileEditorModel[] {\n\t\treturn this.getFileModels(arg1).filter(model => model.isDirty());\n\t}\n\n\tsaveAs(resource: URI, target?: URI, options?: ISaveOptions): Promise<URI | undefined> {\n\n\t\t// Get to target resource\n\t\tlet targetPromise: Promise<URI | undefined>;\n\t\tif (target) {\n\t\t\ttargetPromise = Promise.resolve(target);\n\t\t} else {\n\t\t\tlet dialogPath = resource;\n\t\t\tif (resource.scheme === Schemas.untitled) {\n\t\t\t\tdialogPath = this.suggestFileName(resource);\n\t\t\t}\n\n\t\t\ttargetPromise = this.promptForPath(resource, dialogPath);\n\t\t}\n\n\t\treturn targetPromise.then<URI | undefined>(target => {\n\t\t\tif (!target) {\n\t\t\t\treturn undefined; // user canceled\n\t\t\t}\n\n\t\t\t// Just save if target is same as models own resource\n\t\t\tif (resource.toString() === target.toString()) {\n\t\t\t\treturn this.save(resource, options).then(() => resource);\n\t\t\t}\n\n\t\t\t// Do it\n\t\t\treturn this.doSaveAs(resource, target, options);\n\t\t});\n\t}\n\n\tprivate doSaveAs(resource: URI, target: URI, options?: ISaveOptions): Promise<URI> {\n\n\t\t// Retrieve text model from provided resource if any\n\t\tlet modelPromise: Promise<ITextFileEditorModel | UntitledEditorModel | undefined> = Promise.resolve(undefined);\n\t\tif (this.fileService.canHandleResource(resource)) {\n\t\t\tmodelPromise = Promise.resolve(this._models.get(resource));\n\t\t} else if (resource.scheme === Schemas.untitled && this.untitledEditorService.exists(resource)) {\n\t\t\tmodelPromise = this.untitledEditorService.loadOrCreate({ resource });\n\t\t}\n\n\t\treturn modelPromise.then(model => {\n\n\t\t\t// We have a model: Use it (can be null e.g. if this file is binary and not a text file or was never opened before)\n\t\t\tif (model) {\n\t\t\t\treturn this.doSaveTextFileAs(model, resource, target, options);\n\t\t\t}\n\n\t\t\t// Otherwise we can only copy\n\t\t\treturn this.fileService.copyFile(resource, target).then(() => true);\n\t\t}).then(result => {\n\n\t\t\t// Return early if the operation was not running\n\t\t\tif (!result) {\n\t\t\t\treturn target;\n\t\t\t}\n\n\t\t\t// Revert the source\n\t\t\treturn this.revert(resource).then(() => {\n\n\t\t\t\t// Done: return target\n\t\t\t\treturn target;\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate doSaveTextFileAs(sourceModel: ITextFileEditorModel | UntitledEditorModel, resource: URI, target: URI, options?: ISaveOptions): Promise<boolean> {\n\t\tlet targetModelResolver: Promise<ITextFileEditorModel>;\n\t\tlet targetExists: boolean = false;\n\n\t\t// Prefer an existing model if it is already loaded for the given target resource\n\t\tconst targetModel = this.models.get(target);\n\t\tif (targetModel && targetModel.isResolved()) {\n\t\t\ttargetModelResolver = Promise.resolve(targetModel);\n\t\t\ttargetExists = true;\n\t\t}\n\n\t\t// Otherwise create the target file empty if it does not exist already and resolve it from there\n\t\telse {\n\t\t\ttargetModelResolver = this.fileService.existsFile(target).then<any>(exists => {\n\t\t\t\ttargetExists = exists;\n\n\t\t\t\t// create target model adhoc if file does not exist yet\n\t\t\t\tif (!targetExists) {\n\t\t\t\t\treturn this.fileService.updateContent(target, '');\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\t\t\t}).then(() => this.models.loadOrCreate(target));\n\t\t}\n\n\t\treturn targetModelResolver.then(targetModel => {\n\n\t\t\t// Confirm to overwrite if we have an untitled file with associated file where\n\t\t\t// the file actually exists on disk and we are instructed to save to that file\n\t\t\t// path. This can happen if the file was created after the untitled file was opened.\n\t\t\t// See https://github.com/Microsoft/vscode/issues/67946\n\t\t\tlet confirmWrite: Promise<boolean>;\n\t\t\tif (sourceModel instanceof UntitledEditorModel && sourceModel.hasAssociatedFilePath && targetExists && isEqual(target, this.untitledToAssociatedFileResource(sourceModel.getResource()))) {\n\t\t\t\tconfirmWrite = this.confirmOverwrite(target);\n\t\t\t} else {\n\t\t\t\tconfirmWrite = Promise.resolve(true);\n\t\t\t}\n\n\t\t\treturn confirmWrite.then(write => {\n\t\t\t\tif (!write) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// take over encoding and model value from source model\n\t\t\t\ttargetModel.updatePreferredEncoding(sourceModel.getEncoding());\n\t\t\t\tif (targetModel.textEditorModel) {\n\t\t\t\t\tconst snapshot = sourceModel.createSnapshot();\n\t\t\t\t\tif (snapshot) {\n\t\t\t\t\t\tthis.modelService.updateModel(targetModel.textEditorModel, createTextBufferFactoryFromSnapshot(snapshot));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// save model\n\t\t\t\treturn targetModel.save(options).then(() => true);\n\t\t\t});\n\t\t}, error => {\n\n\t\t\t// binary model: delete the file and run the operation again\n\t\t\tif ((<FileOperationError>error).fileOperationResult === FileOperationResult.FILE_IS_BINARY || (<FileOperationError>error).fileOperationResult === FileOperationResult.FILE_TOO_LARGE) {\n\t\t\t\treturn this.fileService.del(target).then(() => this.doSaveTextFileAs(sourceModel, resource, target, options));\n\t\t\t}\n\n\t\t\treturn Promise.reject(error);\n\t\t});\n\t}\n\n\tprivate suggestFileName(untitledResource: URI): URI {\n\t\tconst untitledFileName = this.untitledEditorService.suggestFileName(untitledResource);\n\t\tconst remoteAuthority = this.windowService.getConfiguration().remoteAuthority;\n\t\tconst schemeFilter = remoteAuthority ? REMOTE_HOST_SCHEME : Schemas.file;\n\n\t\tconst lastActiveFile = this.historyService.getLastActiveFile(schemeFilter);\n\t\tif (lastActiveFile) {\n\t\t\tconst lastDir = dirname(lastActiveFile);\n\t\t\treturn joinPath(lastDir, untitledFileName);\n\t\t}\n\n\t\tconst lastActiveFolder = this.historyService.getLastActiveWorkspaceRoot(schemeFilter);\n\t\tif (lastActiveFolder) {\n\t\t\treturn joinPath(lastActiveFolder, untitledFileName);\n\t\t}\n\n\t\treturn schemeFilter === Schemas.file ? URI.file(untitledFileName) : URI.from({ scheme: schemeFilter, authority: remoteAuthority, path: '/' + untitledFileName });\n\t}\n\n\trevert(resource: URI, options?: IRevertOptions): Promise<boolean> {\n\t\treturn this.revertAll([resource], options).then(result => result.results.length === 1 && !!result.results[0].success);\n\t}\n\n\trevertAll(resources?: URI[], options?: IRevertOptions): Promise<ITextFileOperationResult> {\n\n\t\t// Revert files first\n\t\treturn this.doRevertAllFiles(resources, options).then(operation => {\n\n\t\t\t// Revert untitled\n\t\t\tconst reverted = this.untitledEditorService.revertAll(resources);\n\t\t\treverted.forEach(res => operation.results.push({ source: res, success: true }));\n\n\t\t\treturn operation;\n\t\t});\n\t}\n\n\tprivate doRevertAllFiles(resources?: URI[], options?: IRevertOptions): Promise<ITextFileOperationResult> {\n\t\tconst fileModels = options && options.force ? this.getFileModels(resources) : this.getDirtyFileModels(resources);\n\n\t\tconst mapResourceToResult = new ResourceMap<IResult>();\n\t\tfileModels.forEach(m => {\n\t\t\tmapResourceToResult.set(m.getResource(), {\n\t\t\t\tsource: m.getResource()\n\t\t\t});\n\t\t});\n\n\t\treturn Promise.all(fileModels.map(model => {\n\t\t\treturn model.revert(options && options.soft).then(() => {\n\t\t\t\tif (!model.isDirty()) {\n\t\t\t\t\tconst result = mapResourceToResult.get(model.getResource());\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tresult.success = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, error => {\n\n\t\t\t\t// FileNotFound means the file got deleted meanwhile, so still record as successful revert\n\t\t\t\tif ((<FileOperationError>error).fileOperationResult === FileOperationResult.FILE_NOT_FOUND) {\n\t\t\t\t\tconst result = mapResourceToResult.get(model.getResource());\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tresult.success = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Otherwise bubble up the error\n\t\t\t\telse {\n\t\t\t\t\treturn Promise.reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t})).then(r => ({ results: mapResourceToResult.values() }));\n\t}\n\n\tcreate(resource: URI, contents?: string, options?: { overwrite?: boolean }): Promise<void> {\n\t\tconst existingModel = this.models.get(resource);\n\n\t\treturn this.fileService.createFile(resource, contents, options).then(() => {\n\n\t\t\t// If we had an existing model for the given resource, load\n\t\t\t// it again to make sure it is up to date with the contents\n\t\t\t// we just wrote into the underlying resource by calling\n\t\t\t// revert()\n\t\t\tif (existingModel && !existingModel.isDisposed()) {\n\t\t\t\treturn existingModel.revert();\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t});\n\t}\n\n\tdelete(resource: URI, options?: { useTrash?: boolean, recursive?: boolean }): Promise<void> {\n\t\tconst dirtyFiles = this.getDirty().filter(dirty => isEqualOrParent(dirty, resource, !platform.isLinux /* ignorecase */));\n\n\t\treturn this.revertAll(dirtyFiles, { soft: true }).then(() => this.fileService.del(resource, options));\n\t}\n\n\tmove(source: URI, target: URI, overwrite?: boolean): Promise<void> {\n\t\tconst waitForPromises: Promise<any>[] = [];\n\n\t\t// Event\n\t\tthis._onWillMove.fire({\n\t\t\toldResource: source,\n\t\t\tnewResource: target,\n\t\t\twaitUntil(promise: Promise<any>) {\n\t\t\t\twaitForPromises.push(promise.then(undefined, errors.onUnexpectedError));\n\t\t\t}\n\t\t});\n\n\t\t// prevent async waitUntil-calls\n\t\tObject.freeze(waitForPromises);\n\n\t\treturn Promise.all(waitForPromises).then(() => {\n\n\t\t\t// Handle target models if existing (if target URI is a folder, this can be multiple)\n\t\t\tlet handleTargetModelPromise: Promise<any> = Promise.resolve();\n\t\t\tconst dirtyTargetModels = this.getDirtyFileModels().filter(model => isEqualOrParent(model.getResource(), target, false /* do not ignorecase, see https://github.com/Microsoft/vscode/issues/56384 */));\n\t\t\tif (dirtyTargetModels.length) {\n\t\t\t\thandleTargetModelPromise = this.revertAll(dirtyTargetModels.map(targetModel => targetModel.getResource()), { soft: true });\n\t\t\t}\n\n\t\t\treturn handleTargetModelPromise.then(() => {\n\n\t\t\t\t// Handle dirty source models if existing (if source URI is a folder, this can be multiple)\n\t\t\t\tlet handleDirtySourceModels: Promise<any>;\n\t\t\t\tconst dirtySourceModels = this.getDirtyFileModels().filter(model => isEqualOrParent(model.getResource(), source, !platform.isLinux /* ignorecase */));\n\t\t\t\tconst dirtyTargetModels: URI[] = [];\n\t\t\t\tif (dirtySourceModels.length) {\n\t\t\t\t\thandleDirtySourceModels = Promise.all(dirtySourceModels.map(sourceModel => {\n\t\t\t\t\t\tconst sourceModelResource = sourceModel.getResource();\n\t\t\t\t\t\tlet targetModelResource: URI;\n\n\t\t\t\t\t\t// If the source is the actual model, just use target as new resource\n\t\t\t\t\t\tif (isEqual(sourceModelResource, source, !platform.isLinux /* ignorecase */)) {\n\t\t\t\t\t\t\ttargetModelResource = target;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise a parent folder of the source is being moved, so we need\n\t\t\t\t\t\t// to compute the target resource based on that\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttargetModelResource = sourceModelResource.with({ path: joinPath(target, sourceModelResource.path.substr(source.path.length + 1)).path });\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remember as dirty target model to load after the operation\n\t\t\t\t\t\tdirtyTargetModels.push(targetModelResource);\n\n\t\t\t\t\t\t// Backup dirty source model to the target resource it will become later\n\t\t\t\t\t\tconst snapshot = sourceModel.createSnapshot();\n\t\t\t\t\t\tif (snapshot) {\n\t\t\t\t\t\t\treturn this.backupFileService.backupResource(targetModelResource, snapshot, sourceModel.getVersionId());\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t\t}));\n\t\t\t\t} else {\n\t\t\t\t\thandleDirtySourceModels = Promise.resolve();\n\t\t\t\t}\n\n\t\t\t\treturn handleDirtySourceModels.then(() => {\n\n\t\t\t\t\t// Soft revert the dirty source files if any\n\t\t\t\t\treturn this.revertAll(dirtySourceModels.map(dirtySourceModel => dirtySourceModel.getResource()), { soft: true }).then(() => {\n\n\t\t\t\t\t\t// Rename to target\n\t\t\t\t\t\treturn this.fileService.moveFile(source, target, overwrite).then(() => {\n\n\t\t\t\t\t\t\t// Load models that were dirty before\n\t\t\t\t\t\t\treturn Promise.all(dirtyTargetModels.map(dirtyTargetModel => this.models.loadOrCreate(dirtyTargetModel))).then(() => undefined);\n\t\t\t\t\t\t}, error => {\n\n\t\t\t\t\t\t\t// In case of an error, discard any dirty target backups that were made\n\t\t\t\t\t\t\treturn Promise.all(dirtyTargetModels.map(dirtyTargetModel => this.backupFileService.discardResourceBackup(dirtyTargetModel)))\n\t\t\t\t\t\t\t\t.then(() => Promise.reject(error));\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tgetAutoSaveMode(): AutoSaveMode {\n\t\tif (this.configuredAutoSaveOnFocusChange) {\n\t\t\treturn AutoSaveMode.ON_FOCUS_CHANGE;\n\t\t}\n\n\t\tif (this.configuredAutoSaveOnWindowChange) {\n\t\t\treturn AutoSaveMode.ON_WINDOW_CHANGE;\n\t\t}\n\n\t\tif (this.configuredAutoSaveDelay && this.configuredAutoSaveDelay > 0) {\n\t\t\treturn this.configuredAutoSaveDelay <= 1000 ? AutoSaveMode.AFTER_SHORT_DELAY : AutoSaveMode.AFTER_LONG_DELAY;\n\t\t}\n\n\t\treturn AutoSaveMode.OFF;\n\t}\n\n\tgetAutoSaveConfiguration(): IAutoSaveConfiguration {\n\t\treturn {\n\t\t\tautoSaveDelay: this.configuredAutoSaveDelay && this.configuredAutoSaveDelay > 0 ? this.configuredAutoSaveDelay : undefined,\n\t\t\tautoSaveFocusChange: this.configuredAutoSaveOnFocusChange,\n\t\t\tautoSaveApplicationChange: this.configuredAutoSaveOnWindowChange\n\t\t};\n\t}\n\n\tget isHotExitEnabled(): boolean {\n\t\treturn !this.environmentService.isExtensionDevelopment && this.configuredHotExit !== HotExitConfiguration.OFF;\n\t}\n\n\tdispose(): void {\n\n\t\t// Clear all caches\n\t\tthis._models.clear();\n\n\t\tsuper.dispose();\n\t}\n}\n\nregisterSingleton(ITextFileService, TextFileService);"]}]}