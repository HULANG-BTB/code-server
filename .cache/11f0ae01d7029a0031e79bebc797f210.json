{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/node/decoder.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/decoder.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"string_decoder\", \"vs/base/common/charCode\"], function (require, exports, sd, charCode_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Convenient way to iterate over output line by line. This helper accommodates for the fact that\n     * a buffer might not end with new lines all the way.\n     *\n     * To use:\n     * - call the write method\n     * - forEach() over the result to get the lines\n     */\n    class LineDecoder {\n        constructor(encoding = 'utf8') {\n            this.stringDecoder = new sd.StringDecoder(encoding);\n            this.remaining = null;\n        }\n        write(buffer) {\n            const result = [];\n            const value = this.remaining\n                ? this.remaining + this.stringDecoder.write(buffer)\n                : this.stringDecoder.write(buffer);\n            if (value.length < 1) {\n                return result;\n            }\n            let start = 0;\n            let ch;\n            let idx = start;\n            while (idx < value.length) {\n                ch = value.charCodeAt(idx);\n                if (ch === charCode_1.CharCode.CarriageReturn || ch === charCode_1.CharCode.LineFeed) {\n                    result.push(value.substring(start, idx));\n                    idx++;\n                    if (idx < value.length) {\n                        const lastChar = ch;\n                        ch = value.charCodeAt(idx);\n                        if ((lastChar === charCode_1.CharCode.CarriageReturn && ch === charCode_1.CharCode.LineFeed) || (lastChar === charCode_1.CharCode.LineFeed && ch === charCode_1.CharCode.CarriageReturn)) {\n                            idx++;\n                        }\n                    }\n                    start = idx;\n                }\n                else {\n                    idx++;\n                }\n            }\n            this.remaining = start < value.length ? value.substr(start) : null;\n            return result;\n        }\n        end() {\n            return this.remaining;\n        }\n    }\n    exports.LineDecoder = LineDecoder;\n});\n",null]}