{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/lifecycle/electron-browser/lifecycleService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/lifecycle/electron-browser/lifecycleService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/errorMessage\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/platform/storage/common/storage\", \"electron\", \"vs/platform/windows/common/windows\", \"vs/platform/log/common/log\", \"vs/platform/notification/common/notification\", \"vs/base/common/errors\", \"vs/platform/lifecycle/common/lifecycleService\"], function (require, exports, errorMessage_1, lifecycle_1, storage_1, electron_1, windows_1, log_1, notification_1, errors_1, lifecycleService_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let LifecycleService = class LifecycleService extends lifecycleService_1.AbstractLifecycleService {\n        constructor(notificationService, windowService, storageService, logService) {\n            super(logService);\n            this.notificationService = notificationService;\n            this.windowService = windowService;\n            this.storageService = storageService;\n            this.logService = logService;\n            this._startupKind = this.resolveStartupKind();\n            this.registerListeners();\n        }\n        resolveStartupKind() {\n            const lastShutdownReason = this.storageService.getNumber(LifecycleService.LAST_SHUTDOWN_REASON_KEY, storage_1.StorageScope.WORKSPACE);\n            this.storageService.remove(LifecycleService.LAST_SHUTDOWN_REASON_KEY, storage_1.StorageScope.WORKSPACE);\n            let startupKind;\n            if (lastShutdownReason === lifecycle_1.ShutdownReason.RELOAD) {\n                startupKind = lifecycle_1.StartupKind.ReloadedWindow;\n            }\n            else if (lastShutdownReason === lifecycle_1.ShutdownReason.LOAD) {\n                startupKind = lifecycle_1.StartupKind.ReopenedWindow;\n            }\n            else {\n                startupKind = lifecycle_1.StartupKind.NewWindow;\n            }\n            this.logService.trace(`lifecycle: starting up (startup kind: ${this._startupKind})`);\n            return startupKind;\n        }\n        registerListeners() {\n            const windowId = this.windowService.getCurrentWindowId();\n            // Main side indicates that window is about to unload, check for vetos\n            electron_1.ipcRenderer.on('vscode:onBeforeUnload', (_event, reply) => {\n                this.logService.trace(`lifecycle: onBeforeUnload (reason: ${reply.reason})`);\n                // trigger onBeforeShutdown events and veto collecting\n                this.handleBeforeShutdown(reply.reason).then(veto => {\n                    if (veto) {\n                        this.logService.trace('lifecycle: onBeforeUnload prevented via veto');\n                        electron_1.ipcRenderer.send(reply.cancelChannel, windowId);\n                    }\n                    else {\n                        this.logService.trace('lifecycle: onBeforeUnload continues without veto');\n                        this.shutdownReason = reply.reason;\n                        electron_1.ipcRenderer.send(reply.okChannel, windowId);\n                    }\n                });\n            });\n            // Main side indicates that we will indeed shutdown\n            electron_1.ipcRenderer.on('vscode:onWillUnload', (_event, reply) => {\n                this.logService.trace(`lifecycle: onWillUnload (reason: ${reply.reason})`);\n                // trigger onWillShutdown events and joining\n                return this.handleWillShutdown(reply.reason).then(() => {\n                    // trigger onShutdown event now that we know we will quit\n                    this._onShutdown.fire();\n                    // acknowledge to main side\n                    electron_1.ipcRenderer.send(reply.replyChannel, windowId);\n                });\n            });\n            // Save shutdown reason to retrieve on next startup\n            this.storageService.onWillSaveState(() => {\n                this.storageService.store(LifecycleService.LAST_SHUTDOWN_REASON_KEY, this.shutdownReason, storage_1.StorageScope.WORKSPACE);\n            });\n        }\n        handleBeforeShutdown(reason) {\n            const vetos = [];\n            this._onBeforeShutdown.fire({\n                veto(value) {\n                    vetos.push(value);\n                },\n                reason\n            });\n            return lifecycle_1.handleVetos(vetos, err => {\n                this.notificationService.error(errorMessage_1.toErrorMessage(err));\n                errors_1.onUnexpectedError(err);\n            });\n        }\n        handleWillShutdown(reason) {\n            const joiners = [];\n            this._onWillShutdown.fire({\n                join(promise) {\n                    if (promise) {\n                        joiners.push(promise);\n                    }\n                },\n                reason\n            });\n            return Promise.all(joiners).then(() => undefined, err => {\n                this.notificationService.error(errorMessage_1.toErrorMessage(err));\n                errors_1.onUnexpectedError(err);\n            });\n        }\n    };\n    LifecycleService.LAST_SHUTDOWN_REASON_KEY = 'lifecyle.lastShutdownReason';\n    LifecycleService = __decorate([\n        __param(0, notification_1.INotificationService),\n        __param(1, windows_1.IWindowService),\n        __param(2, storage_1.IStorageService),\n        __param(3, log_1.ILogService)\n    ], LifecycleService);\n    exports.LifecycleService = LifecycleService;\n});\n",null]}