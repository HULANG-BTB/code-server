{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/console.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/console.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/uri\"], function (require, exports, uri_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isRemoteConsoleLog(obj) {\n        const entry = obj;\n        return entry && typeof entry.type === 'string' && typeof entry.severity === 'string';\n    }\n    exports.isRemoteConsoleLog = isRemoteConsoleLog;\n    function parse(entry) {\n        const args = [];\n        let stack;\n        // Parse Entry\n        try {\n            const parsedArguments = JSON.parse(entry.arguments);\n            // Check for special stack entry as last entry\n            const stackArgument = parsedArguments[parsedArguments.length - 1];\n            if (stackArgument && stackArgument.__$stack) {\n                parsedArguments.pop(); // stack is handled specially\n                stack = stackArgument.__$stack;\n            }\n            args.push(...parsedArguments);\n        }\n        catch (error) {\n            args.push('Unable to log remote console arguments', entry.arguments);\n        }\n        return { args, stack };\n    }\n    exports.parse = parse;\n    function getFirstFrame(arg0) {\n        if (typeof arg0 !== 'string') {\n            return getFirstFrame(parse(arg0).stack);\n        }\n        // Parse a source information out of the stack if we have one. Format can be:\n        // at vscode.commands.registerCommand (/Users/someone/Desktop/test-ts/out/src/extension.js:18:17)\n        // or\n        // at /Users/someone/Desktop/test-ts/out/src/extension.js:18:17\n        // or\n        // at c:\\Users\\someone\\Desktop\\end-js\\extension.js:19:17\n        // or\n        // at e.$executeContributedCommand(c:\\Users\\someone\\Desktop\\end-js\\extension.js:19:17)\n        const stack = arg0;\n        if (stack) {\n            const topFrame = findFirstFrame(stack);\n            // at [^\\/]* => line starts with \"at\" followed by any character except '/' (to not capture unix paths too late)\n            // (?:(?:[a-zA-Z]+:)|(?:[\\/])|(?:\\\\\\\\) => windows drive letter OR unix root OR unc root\n            // (?:.+) => simple pattern for the path, only works because of the line/col pattern after\n            // :(?:\\d+):(?:\\d+) => :line:column data\n            const matches = /at [^\\/]*((?:(?:[a-zA-Z]+:)|(?:[\\/])|(?:\\\\\\\\))(?:.+)):(\\d+):(\\d+)/.exec(topFrame || '');\n            if (matches && matches.length === 4) {\n                return {\n                    uri: uri_1.URI.file(matches[1]),\n                    line: Number(matches[2]),\n                    column: Number(matches[3])\n                };\n            }\n        }\n        return undefined;\n    }\n    exports.getFirstFrame = getFirstFrame;\n    function findFirstFrame(stack) {\n        if (!stack) {\n            return stack;\n        }\n        const newlineIndex = stack.indexOf('\\n');\n        if (newlineIndex === -1) {\n            return stack;\n        }\n        return stack.substring(0, newlineIndex);\n    }\n    function log(entry, label) {\n        const { args, stack } = parse(entry);\n        const isOneStringArg = typeof args[0] === 'string' && args.length === 1;\n        let topFrame = findFirstFrame(stack);\n        if (topFrame) {\n            topFrame = `(${topFrame.trim()})`;\n        }\n        let consoleArgs = [];\n        // First arg is a string\n        if (typeof args[0] === 'string') {\n            if (topFrame && isOneStringArg) {\n                consoleArgs = [`%c[${label}] %c${args[0]} %c${topFrame}`, color('blue'), color('black'), color('grey')];\n            }\n            else {\n                consoleArgs = [`%c[${label}] %c${args[0]}`, color('blue'), color('black'), ...args.slice(1)];\n            }\n        }\n        // First arg is something else, just apply all\n        else {\n            consoleArgs = [`%c[${label}]%`, color('blue'), ...args];\n        }\n        // Stack: add to args unless already aded\n        if (topFrame && !isOneStringArg) {\n            consoleArgs.push(topFrame);\n        }\n        // Log it\n        console[entry.severity].apply(console, consoleArgs);\n    }\n    exports.log = log;\n    function color(color) {\n        return `color: ${color}`;\n    }\n});\n",null]}