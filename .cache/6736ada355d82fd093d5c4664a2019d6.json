{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/history/electron-main/historyMainService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/history/electron-main/historyMainService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/arrays\", \"vs/platform/state/common/state\", \"electron\", \"vs/platform/log/common/log\", \"vs/base/common/labels\", \"vs/base/common/event\", \"vs/base/common/platform\", \"vs/platform/workspaces/common/workspaces\", \"vs/platform/history/common/history\", \"vs/base/common/async\", \"vs/base/common/resources\", \"vs/base/common/uri\", \"vs/base/common/network\", \"vs/platform/environment/common/environment\", \"vs/platform/label/common/label\", \"vs/platform/history/electron-main/historyStorage\", \"vs/base/node/pfs\"], function (require, exports, nls, arrays, state_1, electron_1, log_1, labels_1, event_1, platform_1, workspaces_1, history_1, async_1, resources_1, uri_1, network_1, environment_1, label_1, historyStorage_1, pfs_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let HistoryMainService = class HistoryMainService {\n        constructor(stateService, logService, workspacesMainService, environmentService) {\n            this.stateService = stateService;\n            this.logService = logService;\n            this.workspacesMainService = workspacesMainService;\n            this.environmentService = environmentService;\n            this._onRecentlyOpenedChange = new event_1.Emitter();\n            this.onRecentlyOpenedChange = this._onRecentlyOpenedChange.event;\n            this.macOSRecentDocumentsUpdater = new async_1.ThrottledDelayer(800);\n        }\n        addRecentlyOpened(newlyAdded) {\n            const workspaces = [];\n            const files = [];\n            for (let curr of newlyAdded) {\n                if (history_1.isRecentWorkspace(curr)) {\n                    if (!this.workspacesMainService.isUntitledWorkspace(curr.workspace) && indexOfWorkspace(workspaces, curr.workspace) === -1) {\n                        workspaces.push(curr);\n                    }\n                }\n                else if (history_1.isRecentFolder(curr)) {\n                    if (indexOfFolder(workspaces, curr.folderUri) === -1) {\n                        workspaces.push(curr);\n                    }\n                }\n                else {\n                    if (indexOfFile(files, curr.fileUri) === -1) {\n                        files.push(curr);\n                        // Add to recent documents (Windows only, macOS later)\n                        if (platform_1.isWindows && curr.fileUri.scheme === network_1.Schemas.file) {\n                            electron_1.app.addRecentDocument(curr.fileUri.fsPath);\n                        }\n                    }\n                }\n            }\n            this.addEntriesFromStorage(workspaces, files);\n            if (workspaces.length > HistoryMainService.MAX_TOTAL_RECENT_ENTRIES) {\n                workspaces.length = HistoryMainService.MAX_TOTAL_RECENT_ENTRIES;\n            }\n            if (files.length > HistoryMainService.MAX_TOTAL_RECENT_ENTRIES) {\n                files.length = HistoryMainService.MAX_TOTAL_RECENT_ENTRIES;\n            }\n            this.saveRecentlyOpened({ workspaces, files });\n            this._onRecentlyOpenedChange.fire();\n            // Schedule update to recent documents on macOS dock\n            if (platform_1.isMacintosh) {\n                this.macOSRecentDocumentsUpdater.trigger(() => this.updateMacOSRecentDocuments());\n            }\n        }\n        removeFromRecentlyOpened(toRemove) {\n            const keep = (recent) => {\n                const uri = location(recent);\n                for (const r of toRemove) {\n                    if (resources_1.isEqual(r, uri)) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            const mru = this.getRecentlyOpened();\n            const workspaces = mru.workspaces.filter(keep);\n            const files = mru.files.filter(keep);\n            if (workspaces.length !== mru.workspaces.length || files.length !== mru.files.length) {\n                this.saveRecentlyOpened({ files, workspaces });\n                this._onRecentlyOpenedChange.fire();\n                // Schedule update to recent documents on macOS dock\n                if (platform_1.isMacintosh) {\n                    this.macOSRecentDocumentsUpdater.trigger(() => this.updateMacOSRecentDocuments());\n                }\n            }\n        }\n        updateMacOSRecentDocuments() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!platform_1.isMacintosh) {\n                    return;\n                }\n                // macOS recent documents in the dock are behaving strangely. the entries seem to get\n                // out of sync quickly over time. the attempted fix is to always set the list fresh\n                // from our MRU history data. So we clear the documents first and then set the documents\n                // again.\n                electron_1.app.clearRecentDocuments();\n                const mru = this.getRecentlyOpened();\n                // Fill in workspaces\n                for (let i = 0, entries = 0; i < mru.workspaces.length && entries < HistoryMainService.MAX_MACOS_DOCK_RECENT_FOLDERS; i++) {\n                    const loc = location(mru.workspaces[i]);\n                    if (loc.scheme === network_1.Schemas.file) {\n                        const workspacePath = resources_1.originalFSPath(loc);\n                        if (yield pfs_1.exists(workspacePath)) {\n                            electron_1.app.addRecentDocument(workspacePath);\n                            entries++;\n                        }\n                    }\n                }\n                // Fill in files\n                for (let i = 0, entries = 0; i < mru.files.length && entries < HistoryMainService.MAX_MACOS_DOCK_RECENT_FILES; i++) {\n                    const loc = location(mru.files[i]);\n                    if (loc.scheme === network_1.Schemas.file) {\n                        const filePath = resources_1.originalFSPath(loc);\n                        if (yield pfs_1.exists(filePath)) {\n                            electron_1.app.addRecentDocument(filePath);\n                            entries++;\n                        }\n                    }\n                }\n            });\n        }\n        clearRecentlyOpened() {\n            this.saveRecentlyOpened({ workspaces: [], files: [] });\n            electron_1.app.clearRecentDocuments();\n            // Event\n            this._onRecentlyOpenedChange.fire();\n        }\n        getRecentlyOpened(currentWorkspace, currentFolder, currentFiles) {\n            const workspaces = [];\n            const files = [];\n            // Add current workspace to beginning if set\n            if (currentWorkspace && !this.workspacesMainService.isUntitledWorkspace(currentWorkspace)) {\n                workspaces.push({ workspace: currentWorkspace });\n            }\n            if (currentFolder) {\n                workspaces.push({ folderUri: currentFolder });\n            }\n            // Add currently files to open to the beginning if any\n            if (currentFiles) {\n                for (let currentFile of currentFiles) {\n                    const fileUri = currentFile.fileUri;\n                    if (fileUri && indexOfFile(files, fileUri) === -1) {\n                        files.push({ fileUri });\n                    }\n                }\n            }\n            this.addEntriesFromStorage(workspaces, files);\n            return { workspaces, files };\n        }\n        addEntriesFromStorage(workspaces, files) {\n            // Get from storage\n            let recents = this.getRecentlyOpenedFromStorage();\n            for (let recent of recents.workspaces) {\n                let index = history_1.isRecentFolder(recent) ? indexOfFolder(workspaces, recent.folderUri) : indexOfWorkspace(workspaces, recent.workspace);\n                if (index >= 0) {\n                    workspaces[index].label = workspaces[index].label || recent.label;\n                }\n                else {\n                    workspaces.push(recent);\n                }\n            }\n            for (let recent of recents.files) {\n                let index = indexOfFile(files, recent.fileUri);\n                if (index >= 0) {\n                    files[index].label = files[index].label || recent.label;\n                }\n                else {\n                    files.push(recent);\n                }\n            }\n        }\n        getRecentlyOpenedFromStorage() {\n            const storedRecents = this.stateService.getItem(HistoryMainService.recentlyOpenedStorageKey);\n            return historyStorage_1.restoreRecentlyOpened(storedRecents);\n        }\n        saveRecentlyOpened(recent) {\n            const serialized = historyStorage_1.toStoreData(recent);\n            this.stateService.setItem(HistoryMainService.recentlyOpenedStorageKey, serialized);\n        }\n        updateWindowsJumpList() {\n            if (!platform_1.isWindows) {\n                return; // only on windows\n            }\n            const jumpList = [];\n            // Tasks\n            jumpList.push({\n                type: 'tasks',\n                items: [\n                    {\n                        type: 'task',\n                        title: nls.localize('newWindow', \"New Window\"),\n                        description: nls.localize('newWindowDesc', \"Opens a new window\"),\n                        program: process.execPath,\n                        args: '-n',\n                        iconPath: process.execPath,\n                        iconIndex: 0\n                    }\n                ]\n            });\n            // Recent Workspaces\n            if (this.getRecentlyOpened().workspaces.length > 0) {\n                // The user might have meanwhile removed items from the jump list and we have to respect that\n                // so we need to update our list of recent paths with the choice of the user to not add them again\n                // Also: Windows will not show our custom category at all if there is any entry which was removed\n                // by the user! See https://github.com/Microsoft/vscode/issues/15052\n                let toRemove = [];\n                for (let item of electron_1.app.getJumpListSettings().removedItems) {\n                    const args = item.args;\n                    if (args) {\n                        const match = /^--(folder|file)-uri\\s+\"([^\"]+)\"$/.exec(args);\n                        if (match) {\n                            toRemove.push(uri_1.URI.parse(match[2]));\n                        }\n                    }\n                }\n                this.removeFromRecentlyOpened(toRemove);\n                // Add entries\n                jumpList.push({\n                    type: 'custom',\n                    name: nls.localize('recentFolders', \"Recent Workspaces\"),\n                    items: arrays.coalesce(this.getRecentlyOpened().workspaces.slice(0, 7 /* limit number of entries here */).map(recent => {\n                        const workspace = history_1.isRecentWorkspace(recent) ? recent.workspace : recent.folderUri;\n                        const title = recent.label || label_1.getSimpleWorkspaceLabel(workspace, this.environmentService.untitledWorkspacesHome);\n                        let description;\n                        let args;\n                        if (workspaces_1.isSingleFolderWorkspaceIdentifier(workspace)) {\n                            const parentFolder = resources_1.dirname(workspace);\n                            description = nls.localize('folderDesc', \"{0} {1}\", labels_1.getBaseLabel(workspace), labels_1.getPathLabel(parentFolder, this.environmentService));\n                            args = `--folder-uri \"${workspace.toString()}\"`;\n                        }\n                        else {\n                            description = nls.localize('codeWorkspace', \"Code Workspace\");\n                            args = `--file-uri \"${workspace.configPath.toString()}\"`;\n                        }\n                        return {\n                            type: 'task',\n                            title,\n                            description,\n                            program: process.execPath,\n                            args,\n                            iconPath: 'explorer.exe',\n                            iconIndex: 0\n                        };\n                    }))\n                });\n            }\n            // Recent\n            jumpList.push({\n                type: 'recent' // this enables to show files in the \"recent\" category\n            });\n            try {\n                electron_1.app.setJumpList(jumpList);\n            }\n            catch (error) {\n                this.logService.warn('#setJumpList', error); // since setJumpList is relatively new API, make sure to guard for errors\n            }\n        }\n    };\n    HistoryMainService.MAX_TOTAL_RECENT_ENTRIES = 100;\n    HistoryMainService.MAX_MACOS_DOCK_RECENT_FOLDERS = 10;\n    HistoryMainService.MAX_MACOS_DOCK_RECENT_FILES = 5;\n    HistoryMainService.recentlyOpenedStorageKey = 'openedPathsList';\n    HistoryMainService = __decorate([\n        __param(0, state_1.IStateService),\n        __param(1, log_1.ILogService),\n        __param(2, workspaces_1.IWorkspacesMainService),\n        __param(3, environment_1.IEnvironmentService)\n    ], HistoryMainService);\n    exports.HistoryMainService = HistoryMainService;\n    function location(recent) {\n        if (history_1.isRecentFolder(recent)) {\n            return recent.folderUri;\n        }\n        if (history_1.isRecentFile(recent)) {\n            return recent.fileUri;\n        }\n        return recent.workspace.configPath;\n    }\n    function indexOfWorkspace(arr, workspace) {\n        return arrays.firstIndex(arr, w => history_1.isRecentWorkspace(w) && w.workspace.id === workspace.id);\n    }\n    function indexOfFolder(arr, folderURI) {\n        return arrays.firstIndex(arr, f => history_1.isRecentFolder(f) && resources_1.isEqual(f.folderUri, folderURI));\n    }\n    function indexOfFile(arr, fileURI) {\n        return arrays.firstIndex(arr, f => resources_1.isEqual(f.fileUri, fileURI));\n    }\n});\n",null]}