{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensionManagement/node/multiExtensionManagement.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensionManagement/node/multiExtensionManagement.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/event\", \"vs/platform/extensionManagement/common/extensionManagement\", \"vs/base/common/arrays\", \"vs/platform/extensions/common/extensions\", \"vs/base/common/lifecycle\", \"vs/platform/configuration/common/configuration\", \"vs/base/common/cancellation\", \"vs/platform/extensionManagement/node/extensionManagementUtil\", \"vs/platform/extensionManagement/common/extensionManagementUtil\", \"vs/nls\", \"vs/workbench/services/extensions/node/extensionsUtil\", \"vs/platform/instantiation/common/extensions\", \"vs/workbench/services/remote/common/remoteAgentService\"], function (require, exports, event_1, extensionManagement_1, arrays_1, extensions_1, lifecycle_1, configuration_1, cancellation_1, extensionManagementUtil_1, extensionManagementUtil_2, nls_1, extensionsUtil_1, extensions_2, remoteAgentService_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let MultiExtensionManagementService = class MultiExtensionManagementService extends lifecycle_1.Disposable {\n        constructor(extensionManagementServerService, extensionGalleryService, configurationService, remoteAgentService) {\n            super();\n            this.extensionManagementServerService = extensionManagementServerService;\n            this.extensionGalleryService = extensionGalleryService;\n            this.configurationService = configurationService;\n            this.remoteAgentService = remoteAgentService;\n            this.servers = this.extensionManagementServerService.remoteExtensionManagementServer ? [this.extensionManagementServerService.localExtensionManagementServer, this.extensionManagementServerService.remoteExtensionManagementServer] : [this.extensionManagementServerService.localExtensionManagementServer];\n            this.onInstallExtension = this._register(this.servers.reduce((emitter, server) => { emitter.add(server.extensionManagementService.onInstallExtension); return emitter; }, new event_1.EventMultiplexer())).event;\n            this.onDidInstallExtension = this._register(this.servers.reduce((emitter, server) => { emitter.add(server.extensionManagementService.onDidInstallExtension); return emitter; }, new event_1.EventMultiplexer())).event;\n            this.onUninstallExtension = this._register(this.servers.reduce((emitter, server) => { emitter.add(server.extensionManagementService.onUninstallExtension); return emitter; }, new event_1.EventMultiplexer())).event;\n            this.onDidUninstallExtension = this._register(this.servers.reduce((emitter, server) => { emitter.add(server.extensionManagementService.onDidUninstallExtension); return emitter; }, new event_1.EventMultiplexer())).event;\n        }\n        getInstalled(type) {\n            return Promise.all(this.servers.map(({ extensionManagementService }) => extensionManagementService.getInstalled(type)))\n                .then(result => arrays_1.flatten(result));\n        }\n        uninstall(extension, force) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (this.extensionManagementServerService.remoteExtensionManagementServer) {\n                    const server = this.getServer(extension);\n                    if (!server) {\n                        return Promise.reject(`Invalid location ${extension.location.toString()}`);\n                    }\n                    const syncExtensions = yield this.hasToSyncExtensions();\n                    if (syncExtensions || extensions_1.isLanguagePackExtension(extension.manifest)) {\n                        return this.uninstallEverywhere(extension, force);\n                    }\n                    return this.uninstallInServer(extension, server, force);\n                }\n                return this.extensionManagementServerService.localExtensionManagementServer.extensionManagementService.uninstall(extension, force);\n            });\n        }\n        uninstallEverywhere(extension, force) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const server = this.getServer(extension);\n                if (!server) {\n                    return Promise.reject(`Invalid location ${extension.location.toString()}`);\n                }\n                const promise = server.extensionManagementService.uninstall(extension);\n                const anotherServer = server === this.extensionManagementServerService.localExtensionManagementServer ? this.extensionManagementServerService.remoteExtensionManagementServer : this.extensionManagementServerService.localExtensionManagementServer;\n                const installed = yield anotherServer.extensionManagementService.getInstalled(extensions_1.ExtensionType.User);\n                extension = installed.filter(i => extensionManagementUtil_2.areSameExtensions(i.identifier, extension.identifier))[0];\n                if (extension) {\n                    yield anotherServer.extensionManagementService.uninstall(extension);\n                }\n                return promise;\n            });\n        }\n        uninstallInServer(extension, server, force) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (server === this.extensionManagementServerService.localExtensionManagementServer) {\n                    const installedExtensions = yield this.extensionManagementServerService.remoteExtensionManagementServer.extensionManagementService.getInstalled(extensions_1.ExtensionType.User);\n                    const dependentNonUIExtensions = installedExtensions.filter(i => !extensionsUtil_1.isUIExtension(i.manifest, this.configurationService)\n                        && i.manifest.extensionDependencies && i.manifest.extensionDependencies.some(id => extensionManagementUtil_2.areSameExtensions({ id }, extension.identifier)));\n                    if (dependentNonUIExtensions.length) {\n                        return Promise.reject(new Error(this.getDependentsErrorMessage(extension, dependentNonUIExtensions)));\n                    }\n                }\n                return server.extensionManagementService.uninstall(extension, force);\n            });\n        }\n        getDependentsErrorMessage(extension, dependents) {\n            if (dependents.length === 1) {\n                return nls_1.localize('singleDependentError', \"Cannot uninstall extension '{0}'. Extension '{1}' depends on this.\", extension.manifest.displayName || extension.manifest.name, dependents[0].manifest.displayName || dependents[0].manifest.name);\n            }\n            if (dependents.length === 2) {\n                return nls_1.localize('twoDependentsError', \"Cannot uninstall extension '{0}'. Extensions '{1}' and '{2}' depend on this.\", extension.manifest.displayName || extension.manifest.name, dependents[0].manifest.displayName || dependents[0].manifest.name, dependents[1].manifest.displayName || dependents[1].manifest.name);\n            }\n            return nls_1.localize('multipleDependentsError', \"Cannot uninstall extension '{0}'. Extensions '{1}', '{2}' and others depend on this.\", extension.manifest.displayName || extension.manifest.name, dependents[0].manifest.displayName || dependents[0].manifest.name, dependents[1].manifest.displayName || dependents[1].manifest.name);\n        }\n        reinstallFromGallery(extension) {\n            const server = this.getServer(extension);\n            if (server) {\n                return server.extensionManagementService.reinstallFromGallery(extension);\n            }\n            return Promise.reject(`Invalid location ${extension.location.toString()}`);\n        }\n        updateMetadata(extension, metadata) {\n            const server = this.getServer(extension);\n            if (server) {\n                return server.extensionManagementService.updateMetadata(extension, metadata);\n            }\n            return Promise.reject(`Invalid location ${extension.location.toString()}`);\n        }\n        zip(extension) {\n            throw new Error('Not Supported');\n        }\n        unzip(zipLocation, type) {\n            return Promise.all(this.servers.map(({ extensionManagementService }) => extensionManagementService.unzip(zipLocation, type))).then(([extensionIdentifier]) => extensionIdentifier);\n        }\n        install(vsix) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (this.extensionManagementServerService.remoteExtensionManagementServer) {\n                    const syncExtensions = yield this.hasToSyncExtensions();\n                    const manifest = yield extensionManagementUtil_1.getManifest(vsix.fsPath);\n                    if (syncExtensions || extensions_1.isLanguagePackExtension(manifest)) {\n                        // Install on both servers\n                        const [extensionIdentifier] = yield Promise.all(this.servers.map(server => server.extensionManagementService.install(vsix)));\n                        return extensionIdentifier;\n                    }\n                    if (extensionsUtil_1.isUIExtension(manifest, this.configurationService)) {\n                        // Install only on local server\n                        return this.extensionManagementServerService.localExtensionManagementServer.extensionManagementService.install(vsix);\n                    }\n                    // Install only on remote server\n                    const promise = this.extensionManagementServerService.remoteExtensionManagementServer.extensionManagementService.install(vsix);\n                    // Install UI Dependencies on local server\n                    yield this.installUIDependencies(manifest);\n                    return promise;\n                }\n                return this.extensionManagementServerService.localExtensionManagementServer.extensionManagementService.install(vsix);\n            });\n        }\n        installFromGallery(gallery) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (this.extensionManagementServerService.remoteExtensionManagementServer) {\n                    const [manifest, syncExtensions] = yield Promise.all([this.extensionGalleryService.getManifest(gallery, cancellation_1.CancellationToken.None), this.hasToSyncExtensions()]);\n                    if (manifest) {\n                        if (syncExtensions || extensions_1.isLanguagePackExtension(manifest)) {\n                            // Install on both servers\n                            return Promise.all(this.servers.map(server => server.extensionManagementService.installFromGallery(gallery))).then(() => undefined);\n                        }\n                        if (extensionsUtil_1.isUIExtension(manifest, this.configurationService)) {\n                            // Install only on local server\n                            return this.extensionManagementServerService.localExtensionManagementServer.extensionManagementService.installFromGallery(gallery);\n                        }\n                        // Install only on remote server\n                        const promise = this.extensionManagementServerService.remoteExtensionManagementServer.extensionManagementService.installFromGallery(gallery);\n                        // Install UI Dependencies on local server\n                        yield this.installUIDependencies(manifest);\n                        return promise;\n                    }\n                    else {\n                        return Promise.reject(nls_1.localize('Manifest is not found', \"Installing Extension {0} failed: Manifest is not found.\", gallery.displayName || gallery.name));\n                    }\n                }\n                return this.extensionManagementServerService.localExtensionManagementServer.extensionManagementService.installFromGallery(gallery);\n            });\n        }\n        installUIDependencies(manifest) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (manifest.extensionDependencies && manifest.extensionDependencies.length) {\n                    const dependencies = yield this.extensionGalleryService.loadAllDependencies(manifest.extensionDependencies.map(id => ({ id })), cancellation_1.CancellationToken.None);\n                    if (dependencies.length) {\n                        yield Promise.all(dependencies.map((d) => __awaiter(this, void 0, void 0, function* () {\n                            const manifest = yield this.extensionGalleryService.getManifest(d, cancellation_1.CancellationToken.None);\n                            if (manifest && extensionsUtil_1.isUIExtension(manifest, this.configurationService)) {\n                                yield this.extensionManagementServerService.localExtensionManagementServer.extensionManagementService.installFromGallery(d);\n                            }\n                        })));\n                    }\n                }\n            });\n        }\n        getExtensionsReport() {\n            return this.extensionManagementServerService.localExtensionManagementServer.extensionManagementService.getExtensionsReport();\n        }\n        getServer(extension) {\n            return this.extensionManagementServerService.getExtensionManagementServer(extension.location);\n        }\n        hasToSyncExtensions() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!this.extensionManagementServerService.remoteExtensionManagementServer) {\n                    return false;\n                }\n                const remoteEnv = yield this.remoteAgentService.getEnvironment();\n                if (!remoteEnv) {\n                    return false;\n                }\n                return remoteEnv.syncExtensions;\n            });\n        }\n    };\n    MultiExtensionManagementService = __decorate([\n        __param(0, extensionManagement_1.IExtensionManagementServerService),\n        __param(1, extensionManagement_1.IExtensionGalleryService),\n        __param(2, configuration_1.IConfigurationService),\n        __param(3, remoteAgentService_1.IRemoteAgentService)\n    ], MultiExtensionManagementService);\n    exports.MultiExtensionManagementService = MultiExtensionManagementService;\n    extensions_2.registerSingleton(extensionManagement_1.IExtensionManagementService, MultiExtensionManagementService);\n});\n",null]}