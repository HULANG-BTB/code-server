{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/browser/parts/editor/baseEditor.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/browser/parts/editor/baseEditor.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar panel_1 = require(\"vs/workbench/browser/panel\");\nvar editor_1 = require(\"vs/workbench/common/editor\");\nvar storage_1 = require(\"vs/platform/storage/common/storage\");\nvar map_1 = require(\"vs/base/common/map\");\nvar event_1 = require(\"vs/base/common/event\");\nvar types_1 = require(\"vs/base/common/types\");\nvar editor_2 = require(\"vs/workbench/browser/parts/editor/editor\");\n/**\n * The base class of editors in the workbench. Editors register themselves for specific editor inputs.\n * Editors are layed out in the editor part of the workbench in editor groups. Multiple editors can be\n * open at the same time. Each editor has a minimized representation that is good enough to provide some\n * information about the state of the editor data.\n *\n * The workbench will keep an editor alive after it has been created and show/hide it based on\n * user interaction. The lifecycle of a editor goes in the order create(), setVisible(true|false),\n * layout(), setInput(), focus(), dispose(). During use of the workbench, a editor will often receive a\n * clearInput, setVisible, layout and focus call, but only one create and dispose call.\n *\n * This class is only intended to be subclassed and not instantiated.\n */\nvar BaseEditor = /** @class */ (function (_super) {\n    tslib_1.__extends(BaseEditor, _super);\n    function BaseEditor(id, telemetryService, themeService, storageService) {\n        var _this = _super.call(this, id, telemetryService, themeService, storageService) || this;\n        _this.minimumWidth = editor_2.DEFAULT_EDITOR_MIN_DIMENSIONS.width;\n        _this.maximumWidth = editor_2.DEFAULT_EDITOR_MAX_DIMENSIONS.width;\n        _this.minimumHeight = editor_2.DEFAULT_EDITOR_MIN_DIMENSIONS.height;\n        _this.maximumHeight = editor_2.DEFAULT_EDITOR_MAX_DIMENSIONS.height;\n        _this.onDidSizeConstraintsChange = event_1.Event.None;\n        return _this;\n    }\n    Object.defineProperty(BaseEditor.prototype, \"input\", {\n        get: function () {\n            return this._input;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseEditor.prototype, \"options\", {\n        get: function () {\n            return this._options;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseEditor.prototype, \"group\", {\n        get: function () {\n            return this._group;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Note: Clients should not call this method, the workbench calls this\n     * method. Calling it otherwise may result in unexpected behavior.\n     *\n     * Sets the given input with the options to the editor. The input is guaranteed\n     * to be different from the previous input that was set using the input.matches()\n     * method.\n     *\n     * The provided cancellation token should be used to test if the operation\n     * was cancelled.\n     */\n    BaseEditor.prototype.setInput = function (input, options, token) {\n        this._input = input;\n        this._options = options;\n        return Promise.resolve();\n    };\n    /**\n     * Called to indicate to the editor that the input should be cleared and\n     * resources associated with the input should be freed.\n     */\n    BaseEditor.prototype.clearInput = function () {\n        this._input = null;\n        this._options = null;\n    };\n    /**\n     * Note: Clients should not call this method, the workbench calls this\n     * method. Calling it otherwise may result in unexpected behavior.\n     *\n     * Sets the given options to the editor. Clients should apply the options\n     * to the current input.\n     */\n    BaseEditor.prototype.setOptions = function (options) {\n        this._options = options;\n    };\n    BaseEditor.prototype.create = function (parent) {\n        _super.prototype.create.call(this, parent);\n        // Create Editor\n        this.createEditor(parent);\n    };\n    BaseEditor.prototype.setVisible = function (visible, group) {\n        _super.prototype.setVisible.call(this, visible);\n        // Propagate to Editor\n        this.setEditorVisible(visible, group);\n    };\n    /**\n     * Indicates that the editor control got visible or hidden in a specific group. A\n     * editor instance will only ever be visible in one editor group.\n     *\n     * @param visible the state of visibility of this editor\n     * @param group the editor group this editor is in.\n     */\n    BaseEditor.prototype.setEditorVisible = function (visible, group) {\n        this._group = group;\n    };\n    BaseEditor.prototype.getEditorMemento = function (editorGroupService, key, limit) {\n        if (limit === void 0) { limit = 10; }\n        var mementoKey = \"\" + this.getId() + key;\n        var editorMemento = BaseEditor.EDITOR_MEMENTOS.get(mementoKey);\n        if (!editorMemento) {\n            editorMemento = new EditorMemento(this.getId(), key, this.getMemento(storage_1.StorageScope.WORKSPACE), limit, editorGroupService);\n            BaseEditor.EDITOR_MEMENTOS.set(mementoKey, editorMemento);\n        }\n        return editorMemento;\n    };\n    BaseEditor.prototype.saveState = function () {\n        var _this = this;\n        // Save all editor memento for this editor type\n        BaseEditor.EDITOR_MEMENTOS.forEach(function (editorMemento) {\n            if (editorMemento.id === _this.getId()) {\n                editorMemento.saveState();\n            }\n        });\n        _super.prototype.saveState.call(this);\n    };\n    BaseEditor.prototype.dispose = function () {\n        this._input = null;\n        this._options = null;\n        _super.prototype.dispose.call(this);\n    };\n    BaseEditor.EDITOR_MEMENTOS = new Map();\n    return BaseEditor;\n}(panel_1.Panel));\nexports.BaseEditor = BaseEditor;\nvar EditorMemento = /** @class */ (function () {\n    function EditorMemento(_id, key, memento, limit, editorGroupService) {\n        this._id = _id;\n        this.key = key;\n        this.memento = memento;\n        this.limit = limit;\n        this.editorGroupService = editorGroupService;\n        this.cleanedUp = false;\n    }\n    Object.defineProperty(EditorMemento.prototype, \"id\", {\n        get: function () {\n            return this._id;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    EditorMemento.prototype.saveEditorState = function (group, resourceOrEditor, state) {\n        var _this = this;\n        var resource = this.doGetResource(resourceOrEditor);\n        if (!resource || !group) {\n            return; // we are not in a good state to save any state for a resource\n        }\n        var cache = this.doLoad();\n        var mementoForResource = cache.get(resource.toString());\n        if (!mementoForResource) {\n            mementoForResource = Object.create(null);\n            cache.set(resource.toString(), mementoForResource);\n        }\n        mementoForResource[group.id] = state;\n        // Automatically clear when editor input gets disposed if any\n        if (resourceOrEditor instanceof editor_1.EditorInput) {\n            event_1.Event.once(resourceOrEditor.onDispose)(function () {\n                _this.clearEditorState(resource);\n            });\n        }\n    };\n    EditorMemento.prototype.loadEditorState = function (group, resourceOrEditor) {\n        var resource = this.doGetResource(resourceOrEditor);\n        if (!resource || !group) {\n            return undefined; // we are not in a good state to load any state for a resource\n        }\n        var cache = this.doLoad();\n        var mementoForResource = cache.get(resource.toString());\n        if (mementoForResource) {\n            return mementoForResource[group.id];\n        }\n        return undefined;\n    };\n    EditorMemento.prototype.clearEditorState = function (resourceOrEditor, group) {\n        var resource = this.doGetResource(resourceOrEditor);\n        if (resource) {\n            var cache = this.doLoad();\n            if (group) {\n                var resourceViewState = cache.get(resource.toString());\n                if (resourceViewState) {\n                    delete resourceViewState[group.id];\n                }\n            }\n            else {\n                cache.delete(resource.toString());\n            }\n        }\n    };\n    EditorMemento.prototype.doGetResource = function (resourceOrEditor) {\n        if (resourceOrEditor instanceof editor_1.EditorInput) {\n            return resourceOrEditor.getResource();\n        }\n        return resourceOrEditor;\n    };\n    EditorMemento.prototype.doLoad = function () {\n        if (!this.cache) {\n            this.cache = new map_1.LRUCache(this.limit);\n            // Restore from serialized map state\n            var rawEditorMemento = this.memento[this.key];\n            if (Array.isArray(rawEditorMemento)) {\n                this.cache.fromJSON(rawEditorMemento);\n            }\n        }\n        return this.cache;\n    };\n    EditorMemento.prototype.saveState = function () {\n        var cache = this.doLoad();\n        // Cleanup once during shutdown\n        if (!this.cleanedUp) {\n            this.cleanUp();\n            this.cleanedUp = true;\n        }\n        this.memento[this.key] = cache.toJSON();\n    };\n    EditorMemento.prototype.cleanUp = function () {\n        var _this = this;\n        var cache = this.doLoad();\n        // Remove groups from states that no longer exist\n        cache.forEach(function (mapGroupToMemento, resource) {\n            Object.keys(mapGroupToMemento).forEach(function (group) {\n                var groupId = Number(group);\n                if (!_this.editorGroupService.getGroup(groupId)) {\n                    delete mapGroupToMemento[groupId];\n                    if (types_1.isEmptyObject(mapGroupToMemento)) {\n                        cache.delete(resource);\n                    }\n                }\n            });\n        });\n    };\n    return EditorMemento;\n}());\nexports.EditorMemento = EditorMemento;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/browser/parts/editor/baseEditor.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/browser/parts/editor/baseEditor.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Panel } from 'vs/workbench/browser/panel';\nimport { EditorInput, EditorOptions, IEditor, GroupIdentifier, IEditorMemento } from 'vs/workbench/common/editor';\nimport { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';\nimport { IThemeService } from 'vs/platform/theme/common/themeService';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { IEditorGroup, IEditorGroupsService } from 'vs/workbench/services/editor/common/editorGroupsService';\nimport { IStorageService, StorageScope } from 'vs/platform/storage/common/storage';\nimport { LRUCache } from 'vs/base/common/map';\nimport { URI } from 'vs/base/common/uri';\nimport { Event } from 'vs/base/common/event';\nimport { isEmptyObject } from 'vs/base/common/types';\nimport { DEFAULT_EDITOR_MIN_DIMENSIONS, DEFAULT_EDITOR_MAX_DIMENSIONS } from 'vs/workbench/browser/parts/editor/editor';\n\n/**\n * The base class of editors in the workbench. Editors register themselves for specific editor inputs.\n * Editors are layed out in the editor part of the workbench in editor groups. Multiple editors can be\n * open at the same time. Each editor has a minimized representation that is good enough to provide some\n * information about the state of the editor data.\n *\n * The workbench will keep an editor alive after it has been created and show/hide it based on\n * user interaction. The lifecycle of a editor goes in the order create(), setVisible(true|false),\n * layout(), setInput(), focus(), dispose(). During use of the workbench, a editor will often receive a\n * clearInput, setVisible, layout and focus call, but only one create and dispose call.\n *\n * This class is only intended to be subclassed and not instantiated.\n */\nexport abstract class BaseEditor extends Panel implements IEditor {\n\n\tprivate static readonly EDITOR_MEMENTOS: Map<string, EditorMemento<any>> = new Map<string, EditorMemento<any>>();\n\n\treadonly minimumWidth = DEFAULT_EDITOR_MIN_DIMENSIONS.width;\n\treadonly maximumWidth = DEFAULT_EDITOR_MAX_DIMENSIONS.width;\n\treadonly minimumHeight = DEFAULT_EDITOR_MIN_DIMENSIONS.height;\n\treadonly maximumHeight = DEFAULT_EDITOR_MAX_DIMENSIONS.height;\n\n\treadonly onDidSizeConstraintsChange: Event<{ width: number; height: number; } | undefined> = Event.None;\n\n\tprotected _input: EditorInput | null;\n\tprotected _options: EditorOptions | null;\n\n\tprivate _group?: IEditorGroup;\n\n\tconstructor(\n\t\tid: string,\n\t\ttelemetryService: ITelemetryService,\n\t\tthemeService: IThemeService,\n\t\tstorageService: IStorageService\n\t) {\n\t\tsuper(id, telemetryService, themeService, storageService);\n\t}\n\n\tget input(): EditorInput | null {\n\t\treturn this._input;\n\t}\n\n\tget options(): EditorOptions | null {\n\t\treturn this._options;\n\t}\n\n\tget group(): IEditorGroup | undefined {\n\t\treturn this._group;\n\t}\n\n\t/**\n\t * Note: Clients should not call this method, the workbench calls this\n\t * method. Calling it otherwise may result in unexpected behavior.\n\t *\n\t * Sets the given input with the options to the editor. The input is guaranteed\n\t * to be different from the previous input that was set using the input.matches()\n\t * method.\n\t *\n\t * The provided cancellation token should be used to test if the operation\n\t * was cancelled.\n\t */\n\tsetInput(input: EditorInput, options: EditorOptions | null, token: CancellationToken): Promise<void> {\n\t\tthis._input = input;\n\t\tthis._options = options;\n\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Called to indicate to the editor that the input should be cleared and\n\t * resources associated with the input should be freed.\n\t */\n\tclearInput(): void {\n\t\tthis._input = null;\n\t\tthis._options = null;\n\t}\n\n\t/**\n\t * Note: Clients should not call this method, the workbench calls this\n\t * method. Calling it otherwise may result in unexpected behavior.\n\t *\n\t * Sets the given options to the editor. Clients should apply the options\n\t * to the current input.\n\t */\n\tsetOptions(options: EditorOptions | null): void {\n\t\tthis._options = options;\n\t}\n\n\tcreate(parent: HTMLElement): void {\n\t\tsuper.create(parent);\n\n\t\t// Create Editor\n\t\tthis.createEditor(parent);\n\t}\n\n\t/**\n\t * Called to create the editor in the parent HTMLElement.\n\t */\n\tprotected abstract createEditor(parent: HTMLElement): void;\n\n\tsetVisible(visible: boolean, group?: IEditorGroup): void {\n\t\tsuper.setVisible(visible);\n\n\t\t// Propagate to Editor\n\t\tthis.setEditorVisible(visible, group);\n\t}\n\n\t/**\n\t * Indicates that the editor control got visible or hidden in a specific group. A\n\t * editor instance will only ever be visible in one editor group.\n\t *\n\t * @param visible the state of visibility of this editor\n\t * @param group the editor group this editor is in.\n\t */\n\tprotected setEditorVisible(visible: boolean, group: IEditorGroup | undefined): void {\n\t\tthis._group = group;\n\t}\n\n\tprotected getEditorMemento<T>(editorGroupService: IEditorGroupsService, key: string, limit: number = 10): IEditorMemento<T> {\n\t\tconst mementoKey = `${this.getId()}${key}`;\n\n\t\tlet editorMemento = BaseEditor.EDITOR_MEMENTOS.get(mementoKey);\n\t\tif (!editorMemento) {\n\t\t\teditorMemento = new EditorMemento(this.getId(), key, this.getMemento(StorageScope.WORKSPACE), limit, editorGroupService);\n\t\t\tBaseEditor.EDITOR_MEMENTOS.set(mementoKey, editorMemento);\n\t\t}\n\n\t\treturn editorMemento;\n\t}\n\n\tprotected saveState(): void {\n\n\t\t// Save all editor memento for this editor type\n\t\tBaseEditor.EDITOR_MEMENTOS.forEach(editorMemento => {\n\t\t\tif (editorMemento.id === this.getId()) {\n\t\t\t\teditorMemento.saveState();\n\t\t\t}\n\t\t});\n\n\t\tsuper.saveState();\n\t}\n\n\tdispose(): void {\n\t\tthis._input = null;\n\t\tthis._options = null;\n\n\t\tsuper.dispose();\n\t}\n}\n\ninterface MapGroupToMemento<T> {\n\t[group: number]: T;\n}\n\nexport class EditorMemento<T> implements IEditorMemento<T> {\n\tprivate cache: LRUCache<string, MapGroupToMemento<T>>;\n\tprivate cleanedUp = false;\n\n\tconstructor(\n\t\tprivate _id: string,\n\t\tprivate key: string,\n\t\tprivate memento: object,\n\t\tprivate limit: number,\n\t\tprivate editorGroupService: IEditorGroupsService\n\t) { }\n\n\tget id(): string {\n\t\treturn this._id;\n\t}\n\n\tsaveEditorState(group: IEditorGroup, resource: URI, state: T): void;\n\tsaveEditorState(group: IEditorGroup, editor: EditorInput, state: T): void;\n\tsaveEditorState(group: IEditorGroup, resourceOrEditor: URI | EditorInput, state: T): void {\n\t\tconst resource = this.doGetResource(resourceOrEditor);\n\t\tif (!resource || !group) {\n\t\t\treturn; // we are not in a good state to save any state for a resource\n\t\t}\n\n\t\tconst cache = this.doLoad();\n\n\t\tlet mementoForResource = cache.get(resource.toString());\n\t\tif (!mementoForResource) {\n\t\t\tmementoForResource = Object.create(null) as MapGroupToMemento<T>;\n\t\t\tcache.set(resource.toString(), mementoForResource);\n\t\t}\n\n\t\tmementoForResource[group.id] = state;\n\n\t\t// Automatically clear when editor input gets disposed if any\n\t\tif (resourceOrEditor instanceof EditorInput) {\n\t\t\tEvent.once(resourceOrEditor.onDispose)(() => {\n\t\t\t\tthis.clearEditorState(resource);\n\t\t\t});\n\t\t}\n\t}\n\n\tloadEditorState(group: IEditorGroup, resource: URI): T | undefined;\n\tloadEditorState(group: IEditorGroup, editor: EditorInput): T | undefined;\n\tloadEditorState(group: IEditorGroup, resourceOrEditor: URI | EditorInput): T | undefined {\n\t\tconst resource = this.doGetResource(resourceOrEditor);\n\t\tif (!resource || !group) {\n\t\t\treturn undefined; // we are not in a good state to load any state for a resource\n\t\t}\n\n\t\tconst cache = this.doLoad();\n\n\t\tconst mementoForResource = cache.get(resource.toString());\n\t\tif (mementoForResource) {\n\t\t\treturn mementoForResource[group.id];\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tclearEditorState(resource: URI, group?: IEditorGroup): void;\n\tclearEditorState(editor: EditorInput, group?: IEditorGroup): void;\n\tclearEditorState(resourceOrEditor: URI | EditorInput, group?: IEditorGroup): void {\n\t\tconst resource = this.doGetResource(resourceOrEditor);\n\t\tif (resource) {\n\t\t\tconst cache = this.doLoad();\n\n\t\t\tif (group) {\n\t\t\t\tconst resourceViewState = cache.get(resource.toString());\n\t\t\t\tif (resourceViewState) {\n\t\t\t\t\tdelete resourceViewState[group.id];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcache.delete(resource.toString());\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate doGetResource(resourceOrEditor: URI | EditorInput): URI | null {\n\t\tif (resourceOrEditor instanceof EditorInput) {\n\t\t\treturn resourceOrEditor.getResource();\n\t\t}\n\n\t\treturn resourceOrEditor;\n\t}\n\n\tprivate doLoad(): LRUCache<string, MapGroupToMemento<T>> {\n\t\tif (!this.cache) {\n\t\t\tthis.cache = new LRUCache<string, MapGroupToMemento<T>>(this.limit);\n\n\t\t\t// Restore from serialized map state\n\t\t\tconst rawEditorMemento = this.memento[this.key];\n\t\t\tif (Array.isArray(rawEditorMemento)) {\n\t\t\t\tthis.cache.fromJSON(rawEditorMemento);\n\t\t\t}\n\t\t}\n\n\t\treturn this.cache;\n\t}\n\n\tsaveState(): void {\n\t\tconst cache = this.doLoad();\n\n\t\t// Cleanup once during shutdown\n\t\tif (!this.cleanedUp) {\n\t\t\tthis.cleanUp();\n\t\t\tthis.cleanedUp = true;\n\t\t}\n\n\t\tthis.memento[this.key] = cache.toJSON();\n\t}\n\n\tprivate cleanUp(): void {\n\t\tconst cache = this.doLoad();\n\n\t\t// Remove groups from states that no longer exist\n\t\tcache.forEach((mapGroupToMemento, resource) => {\n\t\t\tObject.keys(mapGroupToMemento).forEach(group => {\n\t\t\t\tconst groupId: GroupIdentifier = Number(group);\n\t\t\t\tif (!this.editorGroupService.getGroup(groupId)) {\n\t\t\t\t\tdelete mapGroupToMemento[groupId];\n\n\t\t\t\t\tif (isEmptyObject(mapGroupToMemento)) {\n\t\t\t\t\t\tcache.delete(resource);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n"]}]}