{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/comment/blockCommentCommand.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/comment/blockCommentCommand.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/charCode\", \"vs/editor/common/core/editOperation\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\", \"vs/editor/common/core/selection\", \"vs/editor/common/modes/languageConfigurationRegistry\"], function (require, exports, charCode_1, editOperation_1, position_1, range_1, selection_1, languageConfigurationRegistry_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class BlockCommentCommand {\n        constructor(selection) {\n            this._selection = selection;\n            this._usedEndToken = null;\n        }\n        static _haystackHasNeedleAtOffset(haystack, needle, offset) {\n            if (offset < 0) {\n                return false;\n            }\n            const needleLength = needle.length;\n            const haystackLength = haystack.length;\n            if (offset + needleLength > haystackLength) {\n                return false;\n            }\n            for (let i = 0; i < needleLength; i++) {\n                const codeA = haystack.charCodeAt(offset + i);\n                const codeB = needle.charCodeAt(i);\n                if (codeA === codeB) {\n                    continue;\n                }\n                if (codeA >= charCode_1.CharCode.A && codeA <= charCode_1.CharCode.Z && codeA + 32 === codeB) {\n                    // codeA is upper-case variant of codeB\n                    continue;\n                }\n                if (codeB >= charCode_1.CharCode.A && codeB <= charCode_1.CharCode.Z && codeB + 32 === codeA) {\n                    // codeB is upper-case variant of codeA\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        _createOperationsForBlockComment(selection, startToken, endToken, model, builder) {\n            const startLineNumber = selection.startLineNumber;\n            const startColumn = selection.startColumn;\n            const endLineNumber = selection.endLineNumber;\n            const endColumn = selection.endColumn;\n            const startLineText = model.getLineContent(startLineNumber);\n            const endLineText = model.getLineContent(endLineNumber);\n            let startTokenIndex = startLineText.lastIndexOf(startToken, startColumn - 1 + startToken.length);\n            let endTokenIndex = endLineText.indexOf(endToken, endColumn - 1 - endToken.length);\n            if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n                if (startLineNumber === endLineNumber) {\n                    const lineBetweenTokens = startLineText.substring(startTokenIndex + startToken.length, endTokenIndex);\n                    if (lineBetweenTokens.indexOf(endToken) >= 0) {\n                        // force to add a block comment\n                        startTokenIndex = -1;\n                        endTokenIndex = -1;\n                    }\n                }\n                else {\n                    const startLineAfterStartToken = startLineText.substring(startTokenIndex + startToken.length);\n                    const endLineBeforeEndToken = endLineText.substring(0, endTokenIndex);\n                    if (startLineAfterStartToken.indexOf(endToken) >= 0 || endLineBeforeEndToken.indexOf(endToken) >= 0) {\n                        // force to add a block comment\n                        startTokenIndex = -1;\n                        endTokenIndex = -1;\n                    }\n                }\n            }\n            let ops;\n            if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n                // Consider spaces as part of the comment tokens\n                if (startTokenIndex + startToken.length < startLineText.length) {\n                    if (startLineText.charCodeAt(startTokenIndex + startToken.length) === charCode_1.CharCode.Space) {\n                        // Pretend the start token contains a trailing space\n                        startToken = startToken + ' ';\n                    }\n                }\n                if (endTokenIndex > 0) {\n                    if (endLineText.charCodeAt(endTokenIndex - 1) === charCode_1.CharCode.Space) {\n                        // Pretend the end token contains a leading space\n                        endToken = ' ' + endToken;\n                        endTokenIndex -= 1;\n                    }\n                }\n                ops = BlockCommentCommand._createRemoveBlockCommentOperations(new range_1.Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n            }\n            else {\n                ops = BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken);\n                this._usedEndToken = ops.length === 1 ? endToken : null;\n            }\n            for (const op of ops) {\n                builder.addTrackedEditOperation(op.range, op.text);\n            }\n        }\n        static _createRemoveBlockCommentOperations(r, startToken, endToken) {\n            let res = [];\n            if (!range_1.Range.isEmpty(r)) {\n                // Remove block comment start\n                res.push(editOperation_1.EditOperation.delete(new range_1.Range(r.startLineNumber, r.startColumn - startToken.length, r.startLineNumber, r.startColumn)));\n                // Remove block comment end\n                res.push(editOperation_1.EditOperation.delete(new range_1.Range(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn + endToken.length)));\n            }\n            else {\n                // Remove both continuously\n                res.push(editOperation_1.EditOperation.delete(new range_1.Range(r.startLineNumber, r.startColumn - startToken.length, r.endLineNumber, r.endColumn + endToken.length)));\n            }\n            return res;\n        }\n        static _createAddBlockCommentOperations(r, startToken, endToken) {\n            let res = [];\n            if (!range_1.Range.isEmpty(r)) {\n                // Insert block comment start\n                res.push(editOperation_1.EditOperation.insert(new position_1.Position(r.startLineNumber, r.startColumn), startToken + ' '));\n                // Insert block comment end\n                res.push(editOperation_1.EditOperation.insert(new position_1.Position(r.endLineNumber, r.endColumn), ' ' + endToken));\n            }\n            else {\n                // Insert both continuously\n                res.push(editOperation_1.EditOperation.replace(new range_1.Range(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn), startToken + '  ' + endToken));\n            }\n            return res;\n        }\n        getEditOperations(model, builder) {\n            const startLineNumber = this._selection.startLineNumber;\n            const startColumn = this._selection.startColumn;\n            model.tokenizeIfCheap(startLineNumber);\n            const languageId = model.getLanguageIdAtPosition(startLineNumber, startColumn);\n            const config = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getComments(languageId);\n            if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n                // Mode does not support block comments\n                return;\n            }\n            this._createOperationsForBlockComment(this._selection, config.blockCommentStartToken, config.blockCommentEndToken, model, builder);\n        }\n        computeCursorState(model, helper) {\n            const inverseEditOperations = helper.getInverseEditOperations();\n            if (inverseEditOperations.length === 2) {\n                const startTokenEditOperation = inverseEditOperations[0];\n                const endTokenEditOperation = inverseEditOperations[1];\n                return new selection_1.Selection(startTokenEditOperation.range.endLineNumber, startTokenEditOperation.range.endColumn, endTokenEditOperation.range.startLineNumber, endTokenEditOperation.range.startColumn);\n            }\n            else {\n                const srcRange = inverseEditOperations[0].range;\n                const deltaColumn = this._usedEndToken ? -this._usedEndToken.length - 1 : 0; // minus 1 space before endToken\n                return new selection_1.Selection(srcRange.endLineNumber, srcRange.endColumn + deltaColumn, srcRange.endLineNumber, srcRange.endColumn + deltaColumn);\n            }\n        }\n    }\n    exports.BlockCommentCommand = BlockCommentCommand;\n});\n",null]}