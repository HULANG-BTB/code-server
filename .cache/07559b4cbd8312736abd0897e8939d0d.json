{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/node/extensionHostProcess.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/node/extensionHostProcess.ts","mtime":1555846338048},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"net\", \"vs/base/common/errors\", \"vs/base/common/event\", \"vs/base/parts/ipc/common/ipc.net\", \"vs/base/parts/ipc/node/ipc.net\", \"vs/platform/product/node/product\", \"vs/workbench/services/extensions/node/extensionHostProtocol\", \"vs/workbench/services/extensions/node/extensionHostMain\", \"vs/base/common/buffer\"], function (require, exports, net, errors_1, event_1, ipc_net_1, ipc_net_2, product_1, extensionHostProtocol_1, extensionHostMain_1, buffer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // With Electron 2.x and node.js 8.x the \"natives\" module\n    // can cause a native crash (see https://github.com/nodejs/node/issues/19891 and\n    // https://github.com/electron/electron/issues/10905). To prevent this from\n    // happening we essentially blocklist this module from getting loaded in any\n    // extension by patching the node require() function.\n    (function () {\n        const Module = require.__$__nodeRequire('module');\n        const originalLoad = Module._load;\n        Module._load = function (request) {\n            if (request === 'natives') {\n                throw new Error('Either the extension or a NPM dependency is using the \"natives\" node module which is unsupported as it can cause a crash of the extension host. Click [here](https://go.microsoft.com/fwlink/?linkid=871887) to find out more');\n            }\n            return originalLoad.apply(this, arguments);\n        };\n    })();\n    // This calls exit directly in case the initialization is not finished and we need to exit\n    // Otherwise, if initialization completed we go to extensionHostMain.terminate()\n    let onTerminate = function () {\n        extensionHostMain_1.exit();\n    };\n    function _createExtHostProtocol() {\n        if (process.env.VSCODE_EXTHOST_WILL_SEND_SOCKET) {\n            return new Promise((resolve, reject) => {\n                let protocol = null;\n                let timer = setTimeout(() => {\n                    reject(new Error('VSCODE_EXTHOST_IPC_SOCKET timeout'));\n                }, 60000);\n                let disconnectWaitTimer = null;\n                process.on('message', (msg, handle) => {\n                    if (msg && msg.type === 'VSCODE_EXTHOST_IPC_SOCKET') {\n                        const initialDataChunk = buffer_1.VSBuffer.wrap(Buffer.from(msg.initialDataChunk, 'base64'));\n                        if (protocol) {\n                            // reconnection case\n                            if (disconnectWaitTimer) {\n                                clearTimeout(disconnectWaitTimer);\n                                disconnectWaitTimer = null;\n                            }\n                            protocol.beginAcceptReconnection(new ipc_net_2.NodeSocket(handle), initialDataChunk);\n                            protocol.endAcceptReconnection();\n                        }\n                        else {\n                            clearTimeout(timer);\n                            protocol = new ipc_net_1.PersistentProtocol(new ipc_net_2.NodeSocket(handle), initialDataChunk);\n                            protocol.onClose(() => onTerminate());\n                            resolve(protocol);\n                            protocol.onSocketClose(() => {\n                                // The socket has closed, let's give the renderer a certain amount of time to reconnect\n                                disconnectWaitTimer = setTimeout(() => {\n                                    disconnectWaitTimer = null;\n                                    onTerminate();\n                                }, ipc_net_1.ProtocolConstants.ReconnectionGraceTime);\n                            });\n                        }\n                    }\n                });\n                // Now that we have managed to install a message listener, ask the other side to send us the socket\n                const req = { type: 'VSCODE_EXTHOST_IPC_READY' };\n                if (process.send) {\n                    process.send(req);\n                }\n            });\n        }\n        else {\n            const pipeName = process.env.VSCODE_IPC_HOOK_EXTHOST;\n            return new Promise((resolve, reject) => {\n                const socket = net.createConnection(pipeName, () => {\n                    socket.removeListener('error', reject);\n                    resolve(new ipc_net_1.PersistentProtocol(new ipc_net_2.NodeSocket(socket)));\n                });\n                socket.once('error', reject);\n            });\n        }\n    }\n    function createExtHostProtocol() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const protocol = yield _createExtHostProtocol();\n            return new class {\n                constructor() {\n                    this._terminating = false;\n                    this.onMessage = event_1.Event.filter(protocol.onMessage, msg => {\n                        if (!extensionHostProtocol_1.isMessageOfType(msg, extensionHostProtocol_1.MessageType.Terminate)) {\n                            return true;\n                        }\n                        this._terminating = true;\n                        onTerminate();\n                        return false;\n                    });\n                }\n                send(msg) {\n                    if (!this._terminating) {\n                        protocol.send(msg);\n                    }\n                }\n            };\n        });\n    }\n    function connectToRenderer(protocol) {\n        return new Promise((c, e) => {\n            // Listen init data message\n            const first = protocol.onMessage(raw => {\n                first.dispose();\n                const initData = JSON.parse(raw.toString());\n                const rendererCommit = initData.commit;\n                const myCommit = product_1.default.commit;\n                if (rendererCommit && myCommit) {\n                    // Running in the built version where commits are defined\n                    if (rendererCommit !== myCommit) {\n                        extensionHostMain_1.exit(55);\n                    }\n                }\n                // Print a console message when rejection isn't handled within N seconds. For details:\n                // see https://nodejs.org/api/process.html#process_event_unhandledrejection\n                // and https://nodejs.org/api/process.html#process_event_rejectionhandled\n                const unhandledPromises = [];\n                process.on('unhandledRejection', (reason, promise) => {\n                    unhandledPromises.push(promise);\n                    setTimeout(() => {\n                        const idx = unhandledPromises.indexOf(promise);\n                        if (idx >= 0) {\n                            promise.catch(e => {\n                                unhandledPromises.splice(idx, 1);\n                                console.warn(`rejected promise not handled within 1 second: ${e}`);\n                                if (e.stack) {\n                                    console.warn(`stack trace: ${e.stack}`);\n                                }\n                                errors_1.onUnexpectedError(reason);\n                            });\n                        }\n                    }, 1000);\n                });\n                process.on('rejectionHandled', (promise) => {\n                    const idx = unhandledPromises.indexOf(promise);\n                    if (idx >= 0) {\n                        unhandledPromises.splice(idx, 1);\n                    }\n                });\n                // Print a console message when an exception isn't handled.\n                process.on('uncaughtException', function (err) {\n                    errors_1.onUnexpectedError(err);\n                });\n                // Kill oneself if one's parent dies. Much drama.\n                setInterval(function () {\n                    try {\n                        // process.kill(initData.parentPid, 0); // throws an exception if the main process doesn't exist anymore.\n                    }\n                    catch (e) {\n                        onTerminate();\n                    }\n                }, 1000);\n                // In certain cases, the event loop can become busy and never yield\n                // e.g. while-true or process.nextTick endless loops\n                // So also use the native node module to do it from a separate thread\n                let watchdog;\n                try {\n                    watchdog = require.__$__nodeRequire('native-watchdog');\n                    watchdog.start(initData.parentPid);\n                }\n                catch (err) {\n                    // no problem...\n                    errors_1.onUnexpectedError(err);\n                }\n                // Tell the outside that we are initialized\n                protocol.send(extensionHostProtocol_1.createMessageOfType(extensionHostProtocol_1.MessageType.Initialized));\n                c({ protocol, initData });\n            });\n            // Tell the outside that we are ready to receive messages\n            protocol.send(extensionHostProtocol_1.createMessageOfType(extensionHostProtocol_1.MessageType.Ready));\n        });\n    }\n    patchExecArgv();\n    createExtHostProtocol().then(protocol => {\n        // connect to main side\n        return connectToRenderer(protocol);\n    }).then(renderer => {\n        // setup things\n        const extensionHostMain = new extensionHostMain_1.ExtensionHostMain(renderer.protocol, renderer.initData);\n        onTerminate = () => extensionHostMain.terminate();\n    }).catch(err => console.error(err));\n    function patchExecArgv() {\n        // when encountering the prevent-inspect flag we delete this\n        // and the prior flag\n        if (process.env.VSCODE_PREVENT_FOREIGN_INSPECT) {\n            for (let i = 0; i < process.execArgv.length; i++) {\n                if (process.execArgv[i].match(/--inspect-brk=\\d+|--inspect=\\d+/)) {\n                    process.execArgv.splice(i, 1);\n                    break;\n                }\n            }\n        }\n    }\n});\n",null]}