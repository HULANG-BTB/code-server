{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/packages/protocol/src/common/proxy.ts","dependencies":[{"path":"/home/coding/workspace/packages/protocol/src/common/proxy.ts","mtime":1555841535686},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\nvar _this = this;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar events_1 = require(\"events\");\nvar util_1 = require(\"./util\");\n// tslint:disable no-any\n/**\n * Allow using a proxy like it's returned synchronously. This only works because\n * all proxy methods return promises.\n */\nvar unpromisify = function (proxyPromise) {\n    return new Proxy({}, {\n        get: function (target, name) {\n            if (typeof target[name] === \"undefined\") {\n                target[name] = function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    return tslib_1.__awaiter(_this, void 0, Promise, function () {\n                        var _a, proxy;\n                        return tslib_1.__generator(this, function (_b) {\n                            switch (_b.label) {\n                                case 0: return [4 /*yield*/, proxyPromise];\n                                case 1:\n                                    proxy = _b.sent();\n                                    return [2 /*return*/, proxy ? (_a = proxy)[name].apply(_a, args) : undefined];\n                            }\n                        });\n                    });\n                };\n            }\n            return target[name];\n        },\n    });\n};\n/**\n * Client-side emitter that just forwards proxy events to its own emitter.\n * It also turns a promisified proxy into a non-promisified proxy so we don't\n * need a bunch of `then` calls everywhere.\n */\nvar ClientProxy = /** @class */ (function (_super) {\n    tslib_1.__extends(ClientProxy, _super);\n    /**\n     * You can specify not to bind events in order to avoid emitting twice for\n     * duplex streams.\n     */\n    function ClientProxy(proxyPromise, bindEvents) {\n        if (bindEvents === void 0) { bindEvents = true; }\n        var _this = _super.call(this) || this;\n        _this.bindEvents = bindEvents;\n        _this.initialize(proxyPromise);\n        if (_this.bindEvents) {\n            _this.on(\"disconnected\", function (error) {\n                try {\n                    _this.emit(\"error\", error);\n                }\n                catch (error) {\n                    // If nothing is listening, EventEmitter will throw an error.\n                }\n                _this.handleDisconnect();\n            });\n        }\n        return _this;\n    }\n    /**\n     * Remove an event listener.\n     */\n    ClientProxy.prototype.off = function (event, cb) {\n        // Fill it here because the fill we're using to provide EventEmitter for the\n        // browser doesn't appear to include `off`.\n        this.removeListener(event, cb);\n        return this;\n    };\n    Object.defineProperty(ClientProxy.prototype, \"proxy\", {\n        get: function () {\n            if (!this._proxy) {\n                throw new Error(\"not initialized\");\n            }\n            return this._proxy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Initialize the proxy by unpromisifying if necessary and binding to its\n     * events.\n     */\n    ClientProxy.prototype.initialize = function (proxyPromise) {\n        var _this = this;\n        this._proxy = util_1.isPromise(proxyPromise) ? unpromisify(proxyPromise) : proxyPromise;\n        if (this.bindEvents) {\n            this.catch(this.proxy.onEvent(function (event) {\n                var args = [];\n                for (var _i = 1; _i < arguments.length; _i++) {\n                    args[_i - 1] = arguments[_i];\n                }\n                _this.emit.apply(_this, [event].concat(args));\n            }));\n        }\n    };\n    /**\n     * Emit an error event if the promise errors.\n     */\n    ClientProxy.prototype.catch = function (promise) {\n        var _this = this;\n        if (promise) {\n            promise.catch(function (e) { return _this.emit(\"error\", e); });\n        }\n        return this;\n    };\n    return ClientProxy;\n}(events_1.EventEmitter));\nexports.ClientProxy = ClientProxy;\n/**\n * Supported top-level module proxies.\n */\nvar Module;\n(function (Module) {\n    Module[\"Fs\"] = \"fs\";\n    Module[\"ChildProcess\"] = \"child_process\";\n    Module[\"Net\"] = \"net\";\n    Module[\"Spdlog\"] = \"spdlog\";\n    Module[\"NodePty\"] = \"node-pty\";\n    Module[\"Trash\"] = \"trash\";\n})(Module = exports.Module || (exports.Module = {}));\n/**\n * Batch remote calls.\n */\nvar Batch = /** @class */ (function () {\n    function Batch(\n    /**\n     * Flush after reaching this amount of time.\n     */\n    maxTime, \n    /**\n     * Flush after reaching this count.\n     */\n    maxCount, \n    /**\n     * Flush after not receiving more requests for this amount of time.\n     * This is pretty low by default so essentially we just end up batching\n     * requests that are all made at the same time.\n     */\n    idleTime) {\n        if (maxTime === void 0) { maxTime = 1000; }\n        if (maxCount === void 0) { maxCount = 100; }\n        if (idleTime === void 0) { idleTime = 1; }\n        var _this = this;\n        this.maxTime = maxTime;\n        this.maxCount = maxCount;\n        this.idleTime = idleTime;\n        this.batch = [];\n        this.add = function (args) {\n            return new Promise(function (resolve, reject) {\n                _this.batch.push({\n                    args: args,\n                    resolve: resolve,\n                    reject: reject,\n                });\n                if (_this.batch.length >= _this.maxCount) {\n                    _this.flush();\n                }\n                else {\n                    clearTimeout(_this.idleTimeout);\n                    _this.idleTimeout = setTimeout(_this.flush, _this.idleTime);\n                    if (typeof _this.maxTimeout === \"undefined\") {\n                        _this.maxTimeout = setTimeout(_this.flush, _this.maxTime);\n                    }\n                }\n            });\n        };\n        /**\n         * Flush out the current batch.\n         */\n        this.flush = function () {\n            clearTimeout(_this.idleTimeout);\n            clearTimeout(_this.maxTimeout);\n            _this.maxTimeout = undefined;\n            var batch = _this.batch;\n            _this.batch = [];\n            _this.remoteCall(batch.map(function (q) { return q.args; })).then(function (results) {\n                batch.forEach(function (item, i) {\n                    var result = results[i];\n                    if (result && result instanceof Error) {\n                        item.reject(result);\n                    }\n                    else {\n                        item.resolve(result);\n                    }\n                });\n            }).catch(function (error) { return batch.forEach(function (item) { return item.reject(error); }); });\n        };\n    }\n    return Batch;\n}());\nexports.Batch = Batch;\n",{"version":3,"file":"/home/coding/workspace/packages/protocol/src/common/proxy.ts","sourceRoot":"","sources":["/home/coding/workspace/packages/protocol/src/common/proxy.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from \"events\";\nimport { isPromise } from \"./util\";\n\n// tslint:disable no-any\n\n/**\n * Allow using a proxy like it's returned synchronously. This only works because\n * all proxy methods return promises.\n */\nconst unpromisify = <T extends ServerProxy>(proxyPromise: Promise<T>): T => {\n\treturn new Proxy({}, {\n\t\tget: (target: any, name: string): any => {\n\t\t\tif (typeof target[name] === \"undefined\") {\n\t\t\t\ttarget[name] = async (...args: any[]): Promise<any> => {\n\t\t\t\t\tconst proxy = await proxyPromise;\n\n\t\t\t\t\treturn proxy ? (proxy as any)[name](...args) : undefined;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn target[name];\n\t\t},\n\t});\n};\n\n/**\n * Client-side emitter that just forwards proxy events to its own emitter.\n * It also turns a promisified proxy into a non-promisified proxy so we don't\n * need a bunch of `then` calls everywhere.\n */\nexport abstract class ClientProxy<T extends ServerProxy> extends EventEmitter {\n\tprivate _proxy: T | undefined;\n\n\t/**\n\t * You can specify not to bind events in order to avoid emitting twice for\n\t * duplex streams.\n\t */\n\tpublic constructor(\n\t\tproxyPromise: Promise<T> | T,\n\t\tprivate readonly bindEvents: boolean = true,\n\t) {\n\t\tsuper();\n\t\tthis.initialize(proxyPromise);\n\t\tif (this.bindEvents) {\n\t\t\tthis.on(\"disconnected\", (error) => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.emit(\"error\", error);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// If nothing is listening, EventEmitter will throw an error.\n\t\t\t\t}\n\t\t\t\tthis.handleDisconnect();\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Remove an event listener.\n\t */\n\tpublic off(event: string, cb: (...args: any[]) => void): this {\n\t\t// Fill it here because the fill we're using to provide EventEmitter for the\n\t\t// browser doesn't appear to include `off`.\n\t\tthis.removeListener(event, cb);\n\n\t\treturn this;\n\t}\n\n\tprotected get proxy(): T {\n\t\tif (!this._proxy) {\n\t\t\tthrow new Error(\"not initialized\");\n\t\t}\n\n\t\treturn this._proxy;\n\t}\n\n\t/**\n\t * Initialize the proxy by unpromisifying if necessary and binding to its\n\t * events.\n\t */\n\tprotected initialize(proxyPromise: Promise<T> | T): void {\n\t\tthis._proxy = isPromise(proxyPromise) ? unpromisify(proxyPromise) : proxyPromise;\n\t\tif (this.bindEvents) {\n\t\t\tthis.catch(this.proxy.onEvent((event, ...args): void => {\n\t\t\t\tthis.emit(event, ...args);\n\t\t\t}));\n\t\t}\n\t}\n\n\t/**\n\t * Perform necessary cleanup on disconnect (or reconnect).\n\t */\n\tprotected abstract handleDisconnect(): void;\n\n\t/**\n\t * Emit an error event if the promise errors.\n\t */\n\tprotected catch(promise?: Promise<any>): this {\n\t\tif (promise) {\n\t\t\tpromise.catch((e) => this.emit(\"error\", e));\n\t\t}\n\n\t\treturn this;\n\t}\n}\n\n/**\n * Proxy to the actual instance on the server. Every method must only accept\n * serializable arguments and must return promises with serializable values. If\n * a proxy itself has proxies on creation (like how ChildProcess has stdin),\n * then it should return all of those at once, otherwise you will miss events\n * from those child proxies and fail to dispose them properly.\n */\nexport interface ServerProxy {\n\t/**\n\t * Dispose the proxy.\n\t */\n\tdispose(): Promise<void>;\n\n\t/**\n\t * This is used instead of an event to force it to be implemented since there\n\t * would be no guarantee the implementation would remember to emit the event.\n\t */\n\tonDone(cb: () => void): Promise<void>;\n\n\t/**\n\t * Listen to all possible events. On the client, this is to reduce boilerplate\n\t * that would just be a bunch of error-prone forwarding of each individual\n\t * event from the proxy to its own emitter. It also fixes a timing issue\n\t * because we just always send all events from the server, so we never miss\n\t * any due to listening too late.\n\t */\n\t// tslint:disable-next-line no-any\n\tonEvent(cb: (event: string, ...args: any[]) => void): Promise<void>;\n}\n\n/**\n * Supported top-level module proxies.\n */\nexport enum Module {\n\tFs = \"fs\",\n\tChildProcess = \"child_process\",\n\tNet = \"net\",\n\tSpdlog = \"spdlog\",\n\tNodePty = \"node-pty\",\n\tTrash = \"trash\",\n}\n\ninterface BatchItem<T, A> {\n\targs: A;\n\tresolve: (t: T) => void;\n\treject: (e: Error) => void;\n}\n\n/**\n * Batch remote calls.\n */\nexport abstract class Batch<T, A> {\n\tprivate idleTimeout: number | NodeJS.Timer | undefined;\n\tprivate maxTimeout: number | NodeJS.Timer | undefined;\n\tprivate batch = <BatchItem<T, A>[]>[];\n\n\tpublic constructor(\n\t\t/**\n\t\t * Flush after reaching this amount of time.\n\t\t */\n\t\tprivate readonly maxTime: number = 1000,\n\t\t/**\n\t\t * Flush after reaching this count.\n\t\t */\n\t\tprivate readonly maxCount: number = 100,\n\t\t/**\n\t\t * Flush after not receiving more requests for this amount of time.\n\t\t * This is pretty low by default so essentially we just end up batching\n\t\t * requests that are all made at the same time.\n\t\t */\n\t\tprivate readonly idleTime: number = 1,\n\t) {}\n\n\tpublic add = (args: A): Promise<T> => {\n\t\treturn new Promise((resolve, reject): void => {\n\t\t\tthis.batch.push({\n\t\t\t\targs,\n\t\t\t\tresolve,\n\t\t\t\treject,\n\t\t\t});\n\t\t\tif (this.batch.length >= this.maxCount) {\n\t\t\t\tthis.flush();\n\t\t\t} else {\n\t\t\t\tclearTimeout(this.idleTimeout as any);\n\t\t\t\tthis.idleTimeout = setTimeout(this.flush, this.idleTime);\n\t\t\t\tif (typeof this.maxTimeout === \"undefined\") {\n\t\t\t\t\tthis.maxTimeout = setTimeout(this.flush, this.maxTime);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Perform remote call for a batch.\n\t */\n\tprotected abstract remoteCall(batch: A[]): Promise<(T | Error)[]>;\n\n\t/**\n\t * Flush out the current batch.\n\t */\n\tprivate readonly flush = (): void => {\n\t\tclearTimeout(this.idleTimeout as any);\n\t\tclearTimeout(this.maxTimeout as any);\n\t\tthis.maxTimeout = undefined;\n\n\t\tconst batch = this.batch;\n\t\tthis.batch = [];\n\n\t\tthis.remoteCall(batch.map((q) => q.args)).then((results) => {\n\t\t\tbatch.forEach((item, i) => {\n\t\t\t\tconst result = results[i];\n\t\t\t\tif (result && result instanceof Error) {\n\t\t\t\t\titem.reject(result);\n\t\t\t\t} else {\n\t\t\t\t\titem.resolve(result);\n\t\t\t\t}\n\t\t\t});\n\t\t}).catch((error) => batch.forEach((item) => item.reject(error)));\n\t}\n}\n"]}]}