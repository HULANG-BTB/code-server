{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/externalTerminal/electron-browser/externalTerminal.contribution.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/externalTerminal/electron-browser/externalTerminal.contribution.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/platform\", \"vs/platform/registry/common/platform\", \"vs/platform/configuration/common/configuration\", \"vs/platform/instantiation/common/extensions\", \"vs/base/common/path\", \"vs/workbench/contrib/externalTerminal/common/externalTerminal\", \"vs/platform/actions/common/actions\", \"vs/base/common/keyCodes\", \"vs/platform/configuration/common/configurationRegistry\", \"vs/workbench/contrib/terminal/common/terminal\", \"vs/workbench/contrib/externalTerminal/electron-browser/externalTerminal\", \"vs/workbench/contrib/externalTerminal/electron-browser/externalTerminalService\", \"vs/workbench/services/history/common/history\", \"vs/workbench/common/resources\", \"vs/platform/keybinding/common/keybindingsRegistry\", \"vs/platform/files/common/files\", \"vs/platform/list/browser/listService\", \"vs/workbench/contrib/files/browser/files\", \"vs/platform/commands/common/commands\", \"vs/base/common/network\", \"vs/base/common/arrays\", \"vs/workbench/services/editor/common/editorService\"], function (require, exports, nls, env, platform_1, configuration_1, extensions_1, paths, externalTerminal_1, actions_1, keyCodes_1, configurationRegistry_1, terminal_1, externalTerminal_2, externalTerminalService_1, history_1, resources_1, keybindingsRegistry_1, files_1, listService_1, files_2, commands_1, network_1, arrays_1, editorService_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    if (env.isWindows) {\n        extensions_1.registerSingleton(externalTerminal_1.IExternalTerminalService, externalTerminalService_1.WindowsExternalTerminalService, true);\n    }\n    else if (env.isMacintosh) {\n        extensions_1.registerSingleton(externalTerminal_1.IExternalTerminalService, externalTerminalService_1.MacExternalTerminalService, true);\n    }\n    else if (env.isLinux) {\n        extensions_1.registerSingleton(externalTerminal_1.IExternalTerminalService, externalTerminalService_1.LinuxExternalTerminalService, true);\n    }\n    externalTerminal_2.getDefaultTerminalLinuxReady().then(defaultTerminalLinux => {\n        let configurationRegistry = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration);\n        configurationRegistry.registerConfiguration({\n            id: 'externalTerminal',\n            order: 100,\n            title: nls.localize('terminalConfigurationTitle', \"External Terminal\"),\n            type: 'object',\n            properties: {\n                'terminal.explorerKind': {\n                    type: 'string',\n                    enum: [\n                        'integrated',\n                        'external'\n                    ],\n                    enumDescriptions: [\n                        nls.localize('terminal.explorerKind.integrated', \"Use VS Code's integrated terminal.\"),\n                        nls.localize('terminal.explorerKind.external', \"Use the configured external terminal.\")\n                    ],\n                    description: nls.localize('explorer.openInTerminalKind', \"Customizes what kind of terminal to launch.\"),\n                    default: 'integrated'\n                },\n                'terminal.external.windowsExec': {\n                    type: 'string',\n                    description: nls.localize('terminal.external.windowsExec', \"Customizes which terminal to run on Windows.\"),\n                    default: externalTerminal_2.getDefaultTerminalWindows(),\n                    scope: configurationRegistry_1.ConfigurationScope.APPLICATION\n                },\n                'terminal.external.osxExec': {\n                    type: 'string',\n                    description: nls.localize('terminal.external.osxExec', \"Customizes which terminal application to run on macOS.\"),\n                    default: externalTerminal_2.DEFAULT_TERMINAL_OSX,\n                    scope: configurationRegistry_1.ConfigurationScope.APPLICATION\n                },\n                'terminal.external.linuxExec': {\n                    type: 'string',\n                    description: nls.localize('terminal.external.linuxExec', \"Customizes which terminal to run on Linux.\"),\n                    default: defaultTerminalLinux,\n                    scope: configurationRegistry_1.ConfigurationScope.APPLICATION\n                }\n            }\n        });\n    });\n    const OPEN_IN_TERMINAL_COMMAND_ID = 'openInTerminal';\n    commands_1.CommandsRegistry.registerCommand({\n        id: OPEN_IN_TERMINAL_COMMAND_ID,\n        handler: (accessor, resource) => {\n            const configurationService = accessor.get(configuration_1.IConfigurationService);\n            const editorService = accessor.get(editorService_1.IEditorService);\n            const fileService = accessor.get(files_1.IFileService);\n            const integratedTerminalService = accessor.get(terminal_1.ITerminalService);\n            const terminalService = accessor.get(externalTerminal_1.IExternalTerminalService);\n            const resources = files_2.getMultiSelectedResources(resource, accessor.get(listService_1.IListService), editorService);\n            return fileService.resolveFiles(resources.map(r => ({ resource: r }))).then(stats => {\n                const directoriesToOpen = arrays_1.distinct(stats.filter(data => data.success).map(({ stat }) => stat.isDirectory ? stat.resource.fsPath : paths.dirname(stat.resource.fsPath)));\n                return directoriesToOpen.map(dir => {\n                    if (configurationService.getValue().terminal.explorerKind === 'integrated') {\n                        const instance = integratedTerminalService.createTerminal({ cwd: dir }, true);\n                        if (instance && (resources.length === 1 || !resource || dir === resource.fsPath || dir === paths.dirname(resource.fsPath))) {\n                            integratedTerminalService.setActiveInstance(instance);\n                            integratedTerminalService.showPanel(true);\n                        }\n                    }\n                    else {\n                        terminalService.openTerminal(dir);\n                    }\n                });\n            });\n        }\n    });\n    const OPEN_NATIVE_CONSOLE_COMMAND_ID = 'workbench.action.terminal.openNativeConsole';\n    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({\n        id: OPEN_NATIVE_CONSOLE_COMMAND_ID,\n        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_C,\n        when: terminal_1.KEYBINDING_CONTEXT_TERMINAL_NOT_FOCUSED,\n        weight: keybindingsRegistry_1.KeybindingWeight.WorkbenchContrib,\n        handler: (accessor) => {\n            const historyService = accessor.get(history_1.IHistoryService);\n            const terminalService = accessor.get(externalTerminal_1.IExternalTerminalService);\n            const root = historyService.getLastActiveWorkspaceRoot(network_1.Schemas.file);\n            if (root) {\n                terminalService.openTerminal(root.fsPath);\n            }\n            else {\n                // Opens current file's folder, if no folder is open in editor\n                const activeFile = historyService.getLastActiveFile(network_1.Schemas.file);\n                if (activeFile) {\n                    terminalService.openTerminal(paths.dirname(activeFile.fsPath));\n                }\n            }\n        }\n    });\n    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.CommandPalette, {\n        command: {\n            id: OPEN_NATIVE_CONSOLE_COMMAND_ID,\n            title: { value: nls.localize('globalConsoleAction', \"Open New Terminal\"), original: 'Open New Terminal' }\n        }\n    });\n    const openConsoleCommand = {\n        id: OPEN_IN_TERMINAL_COMMAND_ID,\n        title: nls.localize('scopedConsoleAction', \"Open in Terminal\")\n    };\n    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.OpenEditorsContext, {\n        group: 'navigation',\n        order: 30,\n        command: openConsoleCommand,\n        when: resources_1.ResourceContextKey.Scheme.isEqualTo(network_1.Schemas.file)\n    });\n    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.ExplorerContext, {\n        group: 'navigation',\n        order: 30,\n        command: openConsoleCommand,\n        when: resources_1.ResourceContextKey.Scheme.isEqualTo(network_1.Schemas.file)\n    });\n});\n",null]}