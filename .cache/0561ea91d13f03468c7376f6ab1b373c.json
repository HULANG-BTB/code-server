{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/node/pfs.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/pfs.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extfs = require(\"vs/base/node/extfs\");\nvar path_1 = require(\"vs/base/common/path\");\nvar async_1 = require(\"vs/base/common/async\");\nvar fs = require(\"fs\");\nvar os = require(\"os\");\nvar platform = require(\"vs/base/common/platform\");\nvar event_1 = require(\"vs/base/common/event\");\nfunction readdir(path) {\n    return async_1.nfcall(extfs.readdir, path);\n}\nexports.readdir = readdir;\nfunction exists(path) {\n    return new Promise(function (c) { return fs.exists(path, c); });\n}\nexports.exists = exists;\nfunction chmod(path, mode) {\n    return async_1.nfcall(fs.chmod, path, mode);\n}\nexports.chmod = chmod;\nexports.mkdirp = extfs.mkdirp;\nfunction rimraf(path) {\n    return lstat(path).then(function (stat) {\n        if (stat.isDirectory() && !stat.isSymbolicLink()) {\n            return readdir(path)\n                .then(function (children) { return Promise.all(children.map(function (child) { return rimraf(path_1.join(path, child)); })); })\n                .then(function () { return rmdir(path); });\n        }\n        else {\n            return unlink(path);\n        }\n    }, function (err) {\n        if (err.code === 'ENOENT') {\n            return undefined;\n        }\n        return Promise.reject(err);\n    });\n}\nexports.rimraf = rimraf;\nfunction realpath(path) {\n    return async_1.nfcall(extfs.realpath, path);\n}\nexports.realpath = realpath;\nfunction stat(path) {\n    return async_1.nfcall(fs.stat, path);\n}\nexports.stat = stat;\nfunction statLink(path) {\n    return async_1.nfcall(extfs.statLink, path);\n}\nexports.statLink = statLink;\nfunction lstat(path) {\n    return async_1.nfcall(fs.lstat, path);\n}\nexports.lstat = lstat;\nfunction move(oldPath, newPath) {\n    return async_1.nfcall(extfs.mv, oldPath, newPath);\n}\nexports.move = move;\nfunction rename(oldPath, newPath) {\n    return async_1.nfcall(fs.rename, oldPath, newPath);\n}\nexports.rename = rename;\nfunction renameIgnoreError(oldPath, newPath) {\n    return new Promise(function (resolve) {\n        fs.rename(oldPath, newPath, function () { return resolve(); });\n    });\n}\nexports.renameIgnoreError = renameIgnoreError;\nfunction rmdir(path) {\n    return async_1.nfcall(fs.rmdir, path);\n}\nexports.rmdir = rmdir;\nfunction unlink(path) {\n    return async_1.nfcall(fs.unlink, path);\n}\nexports.unlink = unlink;\nfunction symlink(target, path, type) {\n    return async_1.nfcall(fs.symlink, target, path, type);\n}\nexports.symlink = symlink;\nfunction readlink(path) {\n    return async_1.nfcall(fs.readlink, path);\n}\nexports.readlink = readlink;\nfunction truncate(path, len) {\n    return async_1.nfcall(fs.truncate, path, len);\n}\nexports.truncate = truncate;\nfunction readFile(path, encoding) {\n    return async_1.nfcall(fs.readFile, path, encoding);\n}\nexports.readFile = readFile;\n// According to node.js docs (https://nodejs.org/docs/v6.5.0/api/fs.html#fs_fs_writefile_file_data_options_callback)\n// it is not safe to call writeFile() on the same path multiple times without waiting for the callback to return.\n// Therefor we use a Queue on the path that is given to us to sequentialize calls to the same path properly.\nvar writeFilePathQueue = Object.create(null);\nfunction writeFile(path, data, options) {\n    var queueKey = toQueueKey(path);\n    return ensureWriteFileQueue(queueKey).queue(function () { return async_1.nfcall(extfs.writeFileAndFlush, path, data, options); });\n}\nexports.writeFile = writeFile;\nfunction toQueueKey(path) {\n    var queueKey = path;\n    if (platform.isWindows || platform.isMacintosh) {\n        queueKey = queueKey.toLowerCase(); // accomodate for case insensitive file systems\n    }\n    return queueKey;\n}\nfunction ensureWriteFileQueue(queueKey) {\n    var writeFileQueue = writeFilePathQueue[queueKey];\n    if (!writeFileQueue) {\n        writeFileQueue = new async_1.Queue();\n        writeFilePathQueue[queueKey] = writeFileQueue;\n        var onFinish = event_1.Event.once(writeFileQueue.onFinished);\n        onFinish(function () {\n            delete writeFilePathQueue[queueKey];\n            writeFileQueue.dispose();\n        });\n    }\n    return writeFileQueue;\n}\n/**\n* Read a dir and return only subfolders\n*/\nfunction readDirsInDir(dirPath) {\n    return readdir(dirPath).then(function (children) {\n        return Promise.all(children.map(function (c) { return dirExists(path_1.join(dirPath, c)); })).then(function (exists) {\n            return children.filter(function (_, i) { return exists[i]; });\n        });\n    });\n}\nexports.readDirsInDir = readDirsInDir;\n/**\n* `path` exists and is a directory\n*/\nfunction dirExists(path) {\n    return stat(path).then(function (stat) { return stat.isDirectory(); }, function () { return false; });\n}\nexports.dirExists = dirExists;\n/**\n* `path` exists and is a file.\n*/\nfunction fileExists(path) {\n    return stat(path).then(function (stat) { return stat.isFile(); }, function () { return false; });\n}\nexports.fileExists = fileExists;\n/**\n * Deletes a path from disk.\n */\nvar _tmpDir = null;\nfunction getTmpDir() {\n    if (!_tmpDir) {\n        _tmpDir = os.tmpdir();\n    }\n    return _tmpDir;\n}\nfunction del(path, tmp) {\n    if (tmp === void 0) { tmp = getTmpDir(); }\n    return async_1.nfcall(extfs.del, path, tmp);\n}\nexports.del = del;\nfunction whenDeleted(path) {\n    // Complete when wait marker file is deleted\n    return new Promise(function (resolve) {\n        var running = false;\n        var interval = setInterval(function () {\n            if (!running) {\n                running = true;\n                fs.exists(path, function (exists) {\n                    running = false;\n                    if (!exists) {\n                        clearInterval(interval);\n                        resolve(undefined);\n                    }\n                });\n            }\n        }, 1000);\n    });\n}\nexports.whenDeleted = whenDeleted;\nfunction copy(source, target) {\n    return async_1.nfcall(extfs.copy, source, target);\n}\nexports.copy = copy;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/node/pfs.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/node/pfs.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as extfs from 'vs/base/node/extfs';\nimport { join } from 'vs/base/common/path';\nimport { nfcall, Queue } from 'vs/base/common/async';\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport * as platform from 'vs/base/common/platform';\nimport { Event } from 'vs/base/common/event';\n\nexport function readdir(path: string): Promise<string[]> {\n\treturn nfcall(extfs.readdir, path);\n}\n\nexport function exists(path: string): Promise<boolean> {\n\treturn new Promise(c => fs.exists(path, c));\n}\n\nexport function chmod(path: string, mode: number): Promise<boolean> {\n\treturn nfcall(fs.chmod, path, mode);\n}\n\nexport import mkdirp = extfs.mkdirp;\n\nexport function rimraf(path: string): Promise<void> {\n\treturn lstat(path).then(stat => {\n\t\tif (stat.isDirectory() && !stat.isSymbolicLink()) {\n\t\t\treturn readdir(path)\n\t\t\t\t.then(children => Promise.all(children.map(child => rimraf(join(path, child)))))\n\t\t\t\t.then(() => rmdir(path));\n\t\t} else {\n\t\t\treturn unlink(path);\n\t\t}\n\t}, (err: NodeJS.ErrnoException) => {\n\t\tif (err.code === 'ENOENT') {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn Promise.reject(err);\n\t});\n}\n\nexport function realpath(path: string): Promise<string> {\n\treturn nfcall(extfs.realpath, path);\n}\n\nexport function stat(path: string): Promise<fs.Stats> {\n\treturn nfcall(fs.stat, path);\n}\n\nexport function statLink(path: string): Promise<{ stat: fs.Stats, isSymbolicLink: boolean }> {\n\treturn nfcall(extfs.statLink, path);\n}\n\nexport function lstat(path: string): Promise<fs.Stats> {\n\treturn nfcall(fs.lstat, path);\n}\n\nexport function move(oldPath: string, newPath: string): Promise<void> {\n\treturn nfcall(extfs.mv, oldPath, newPath);\n}\n\nexport function rename(oldPath: string, newPath: string): Promise<void> {\n\treturn nfcall(fs.rename, oldPath, newPath);\n}\n\nexport function renameIgnoreError(oldPath: string, newPath: string): Promise<void> {\n\treturn new Promise(resolve => {\n\t\tfs.rename(oldPath, newPath, () => resolve());\n\t});\n}\n\nexport function rmdir(path: string): Promise<void> {\n\treturn nfcall(fs.rmdir, path);\n}\n\nexport function unlink(path: string): Promise<void> {\n\treturn nfcall(fs.unlink, path);\n}\n\nexport function symlink(target: string, path: string, type?: string): Promise<void> {\n\treturn nfcall<void>(fs.symlink, target, path, type);\n}\n\nexport function readlink(path: string): Promise<string> {\n\treturn nfcall<string>(fs.readlink, path);\n}\n\nexport function truncate(path: string, len: number): Promise<void> {\n\treturn nfcall(fs.truncate, path, len);\n}\n\nexport function readFile(path: string): Promise<Buffer>;\nexport function readFile(path: string, encoding: string): Promise<string>;\nexport function readFile(path: string, encoding?: string): Promise<Buffer | string> {\n\treturn nfcall(fs.readFile, path, encoding);\n}\n\n// According to node.js docs (https://nodejs.org/docs/v6.5.0/api/fs.html#fs_fs_writefile_file_data_options_callback)\n// it is not safe to call writeFile() on the same path multiple times without waiting for the callback to return.\n// Therefor we use a Queue on the path that is given to us to sequentialize calls to the same path properly.\nconst writeFilePathQueue: { [path: string]: Queue<void> } = Object.create(null);\n\nexport function writeFile(path: string, data: string, options?: extfs.IWriteFileOptions): Promise<void>;\nexport function writeFile(path: string, data: Buffer, options?: extfs.IWriteFileOptions): Promise<void>;\nexport function writeFile(path: string, data: Uint8Array, options?: extfs.IWriteFileOptions): Promise<void>;\nexport function writeFile(path: string, data: NodeJS.ReadableStream, options?: extfs.IWriteFileOptions): Promise<void>;\nexport function writeFile(path: string, data: any, options?: extfs.IWriteFileOptions): Promise<void>;\nexport function writeFile(path: string, data: any, options?: extfs.IWriteFileOptions): any {\n\tconst queueKey = toQueueKey(path);\n\n\treturn ensureWriteFileQueue(queueKey).queue(() => nfcall(extfs.writeFileAndFlush, path, data, options));\n}\n\nfunction toQueueKey(path: string): string {\n\tlet queueKey = path;\n\tif (platform.isWindows || platform.isMacintosh) {\n\t\tqueueKey = queueKey.toLowerCase(); // accomodate for case insensitive file systems\n\t}\n\n\treturn queueKey;\n}\n\nfunction ensureWriteFileQueue(queueKey: string): Queue<void> {\n\tlet writeFileQueue = writeFilePathQueue[queueKey];\n\tif (!writeFileQueue) {\n\t\twriteFileQueue = new Queue<void>();\n\t\twriteFilePathQueue[queueKey] = writeFileQueue;\n\n\t\tconst onFinish = Event.once(writeFileQueue.onFinished);\n\t\tonFinish(() => {\n\t\t\tdelete writeFilePathQueue[queueKey];\n\t\t\twriteFileQueue.dispose();\n\t\t});\n\t}\n\n\treturn writeFileQueue;\n}\n\n/**\n* Read a dir and return only subfolders\n*/\nexport function readDirsInDir(dirPath: string): Promise<string[]> {\n\treturn readdir(dirPath).then(children => {\n\t\treturn Promise.all(children.map(c => dirExists(join(dirPath, c)))).then(exists => {\n\t\t\treturn children.filter((_, i) => exists[i]);\n\t\t});\n\t});\n}\n\n/**\n* `path` exists and is a directory\n*/\nexport function dirExists(path: string): Promise<boolean> {\n\treturn stat(path).then(stat => stat.isDirectory(), () => false);\n}\n\n/**\n* `path` exists and is a file.\n*/\nexport function fileExists(path: string): Promise<boolean> {\n\treturn stat(path).then(stat => stat.isFile(), () => false);\n}\n\n/**\n * Deletes a path from disk.\n */\nlet _tmpDir: string | null = null;\nfunction getTmpDir(): string {\n\tif (!_tmpDir) {\n\t\t_tmpDir = os.tmpdir();\n\t}\n\treturn _tmpDir;\n}\nexport function del(path: string, tmp = getTmpDir()): Promise<void> {\n\treturn nfcall(extfs.del, path, tmp);\n}\n\nexport function whenDeleted(path: string): Promise<void> {\n\n\t// Complete when wait marker file is deleted\n\treturn new Promise<void>(resolve => {\n\t\tlet running = false;\n\t\tconst interval = setInterval(() => {\n\t\t\tif (!running) {\n\t\t\t\trunning = true;\n\t\t\t\tfs.exists(path, exists => {\n\t\t\t\t\trunning = false;\n\n\t\t\t\t\tif (!exists) {\n\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, 1000);\n\t});\n}\n\nexport function copy(source: string, target: string): Promise<void> {\n\treturn nfcall(extfs.copy, source, target);\n}\n"]}]}