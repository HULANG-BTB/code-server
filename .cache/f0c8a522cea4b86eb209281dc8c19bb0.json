{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/nsfw/nsfwWatcherService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/nsfw/nsfwWatcherService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/glob\", \"vs/base/common/extpath\", \"vs/base/common/path\", \"vs/base/common/platform\", \"vs/workbench/services/files/node/watcher/common\", \"vscode-nsfw\", \"vs/base/common/async\", \"vs/platform/files/common/files\", \"vs/base/common/normalization\", \"vs/base/common/event\", \"vs/base/node/extfs\"], function (require, exports, glob, extpath, path, platform, watcher, nsfw, async_1, files_1, normalization_1, event_1, extfs_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const nsfwActionToRawChangeType = [];\n    nsfwActionToRawChangeType[nsfw.actions.CREATED] = files_1.FileChangeType.ADDED;\n    nsfwActionToRawChangeType[nsfw.actions.MODIFIED] = files_1.FileChangeType.UPDATED;\n    nsfwActionToRawChangeType[nsfw.actions.DELETED] = files_1.FileChangeType.DELETED;\n    class NsfwWatcherService {\n        constructor() {\n            this._pathWatchers = {};\n            this._onWatchEvent = new event_1.Emitter();\n            this.onWatchEvent = this._onWatchEvent.event;\n        }\n        watch(options) {\n            this._verboseLogging = options.verboseLogging;\n            return this.onWatchEvent;\n        }\n        _watch(request) {\n            let undeliveredFileEvents = [];\n            const fileEventDelayer = new async_1.ThrottledDelayer(NsfwWatcherService.FS_EVENT_DELAY);\n            let readyPromiseResolve;\n            this._pathWatchers[request.basePath] = {\n                ready: new Promise(resolve => readyPromiseResolve = resolve),\n                ignored: Array.isArray(request.ignored) ? request.ignored.map(ignored => glob.parse(ignored)) : []\n            };\n            process.on('uncaughtException', (e) => {\n                // Specially handle ENOSPC errors that can happen when\n                // the watcher consumes so many file descriptors that\n                // we are running into a limit. We only want to warn\n                // once in this case to avoid log spam.\n                // See https://github.com/Microsoft/vscode/issues/7950\n                if (e === 'Inotify limit reached' && !this.enospcErrorLogged) {\n                    this.enospcErrorLogged = true;\n                    this._onWatchEvent.fire({ message: 'Inotify limit reached (ENOSPC)' });\n                }\n            });\n            // NSFW does not report file changes in the path provided on macOS if\n            // - the path uses wrong casing\n            // - the path is a symbolic link\n            // We have to detect this case and massage the events to correct this.\n            let realBasePathDiffers = false;\n            let realBasePathLength = request.basePath.length;\n            if (platform.isMacintosh) {\n                try {\n                    // First check for symbolic link\n                    let realBasePath = extfs_1.realpathSync(request.basePath);\n                    // Second check for casing difference\n                    if (request.basePath === realBasePath) {\n                        realBasePath = (extfs_1.realcaseSync(request.basePath) || request.basePath);\n                    }\n                    if (request.basePath !== realBasePath) {\n                        realBasePathLength = realBasePath.length;\n                        realBasePathDiffers = true;\n                        console.warn(`Watcher basePath does not match version on disk and will be corrected (original: ${request.basePath}, real: ${realBasePath})`);\n                    }\n                }\n                catch (error) {\n                    // ignore\n                }\n            }\n            nsfw(request.basePath, events => {\n                for (const e of events) {\n                    // Logging\n                    if (this._verboseLogging) {\n                        const logPath = e.action === nsfw.actions.RENAMED ? path.join(e.directory, e.oldFile || '') + ' -> ' + e.newFile : path.join(e.directory, e.file || '');\n                        console.log(`${e.action === nsfw.actions.CREATED ? '[CREATED]' : e.action === nsfw.actions.DELETED ? '[DELETED]' : e.action === nsfw.actions.MODIFIED ? '[CHANGED]' : '[RENAMED]'} ${logPath}`);\n                    }\n                    // Convert nsfw event to IRawFileChange and add to queue\n                    let absolutePath;\n                    if (e.action === nsfw.actions.RENAMED) {\n                        // Rename fires when a file's name changes within a single directory\n                        absolutePath = path.join(e.directory, e.oldFile || '');\n                        if (!this._isPathIgnored(absolutePath, this._pathWatchers[request.basePath].ignored)) {\n                            undeliveredFileEvents.push({ type: files_1.FileChangeType.DELETED, path: absolutePath });\n                        }\n                        else if (this._verboseLogging) {\n                            console.log(' >> ignored', absolutePath);\n                        }\n                        absolutePath = path.join(e.directory, e.newFile || '');\n                        if (!this._isPathIgnored(absolutePath, this._pathWatchers[request.basePath].ignored)) {\n                            undeliveredFileEvents.push({ type: files_1.FileChangeType.ADDED, path: absolutePath });\n                        }\n                        else if (this._verboseLogging) {\n                            console.log(' >> ignored', absolutePath);\n                        }\n                    }\n                    else {\n                        absolutePath = path.join(e.directory, e.file || '');\n                        if (!this._isPathIgnored(absolutePath, this._pathWatchers[request.basePath].ignored)) {\n                            undeliveredFileEvents.push({\n                                type: nsfwActionToRawChangeType[e.action],\n                                path: absolutePath\n                            });\n                        }\n                        else if (this._verboseLogging) {\n                            console.log(' >> ignored', absolutePath);\n                        }\n                    }\n                }\n                // Delay and send buffer\n                fileEventDelayer.trigger(() => {\n                    const events = undeliveredFileEvents;\n                    undeliveredFileEvents = [];\n                    if (platform.isMacintosh) {\n                        events.forEach(e => {\n                            // Mac uses NFD unicode form on disk, but we want NFC\n                            e.path = normalization_1.normalizeNFC(e.path);\n                            // Convert paths back to original form in case it differs\n                            if (realBasePathDiffers) {\n                                e.path = request.basePath + e.path.substr(realBasePathLength);\n                            }\n                        });\n                    }\n                    // Broadcast to clients normalized\n                    const res = watcher.normalize(events);\n                    this._onWatchEvent.fire(res);\n                    // Logging\n                    if (this._verboseLogging) {\n                        res.forEach(r => {\n                            console.log(` >> normalized ${r.type === files_1.FileChangeType.ADDED ? '[ADDED]' : r.type === files_1.FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${r.path}`);\n                        });\n                    }\n                    return Promise.resolve(undefined);\n                });\n            }).then(watcher => {\n                this._pathWatchers[request.basePath].watcher = watcher;\n                const startPromise = watcher.start();\n                startPromise.then(() => readyPromiseResolve(watcher));\n                return startPromise;\n            });\n        }\n        setRoots(roots) {\n            const promises = [];\n            const normalizedRoots = this._normalizeRoots(roots);\n            // Gather roots that are not currently being watched\n            const rootsToStartWatching = normalizedRoots.filter(r => {\n                return !(r.basePath in this._pathWatchers);\n            });\n            // Gather current roots that don't exist in the new roots array\n            const rootsToStopWatching = Object.keys(this._pathWatchers).filter(r => {\n                return normalizedRoots.every(normalizedRoot => normalizedRoot.basePath !== r);\n            });\n            // Logging\n            if (this._verboseLogging) {\n                console.log(`Start watching: [${rootsToStartWatching.map(r => r.basePath).join(',')}]\\nStop watching: [${rootsToStopWatching.join(',')}]`);\n            }\n            // Stop watching some roots\n            rootsToStopWatching.forEach(root => {\n                this._pathWatchers[root].ready.then(watcher => watcher.stop());\n                delete this._pathWatchers[root];\n            });\n            // Start watching some roots\n            rootsToStartWatching.forEach(root => this._watch(root));\n            // Refresh ignored arrays in case they changed\n            roots.forEach(root => {\n                if (root.basePath in this._pathWatchers) {\n                    this._pathWatchers[root.basePath].ignored = Array.isArray(root.ignored) ? root.ignored.map(ignored => glob.parse(ignored)) : [];\n                }\n            });\n            return Promise.all(promises).then(() => undefined);\n        }\n        setVerboseLogging(enabled) {\n            this._verboseLogging = enabled;\n            return Promise.resolve(undefined);\n        }\n        stop() {\n            for (let path in this._pathWatchers) {\n                let watcher = this._pathWatchers[path];\n                watcher.ready.then(watcher => watcher.stop());\n                delete this._pathWatchers[path];\n            }\n            this._pathWatchers = Object.create(null);\n            return Promise.resolve();\n        }\n        /**\n         * Normalizes a set of root paths by removing any root paths that are\n         * sub-paths of other roots.\n         */\n        _normalizeRoots(roots) {\n            return roots.filter(r => roots.every(other => {\n                return !(r.basePath.length > other.basePath.length && extpath.isEqualOrParent(r.basePath, other.basePath));\n            }));\n        }\n        _isPathIgnored(absolutePath, ignored) {\n            return ignored && ignored.some(i => i(absolutePath));\n        }\n    }\n    NsfwWatcherService.FS_EVENT_DELAY = 50; // aggregate and only emit events when changes have stopped for this duration (in ms)\n    exports.NsfwWatcherService = NsfwWatcherService;\n});\n",null]}