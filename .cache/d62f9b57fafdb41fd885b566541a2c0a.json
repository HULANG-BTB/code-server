{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/commands/shiftCommand.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/commands/shiftCommand.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar strings = require(\"vs/base/common/strings\");\nvar cursorCommon_1 = require(\"vs/editor/common/controller/cursorCommon\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar selection_1 = require(\"vs/editor/common/core/selection\");\nvar languageConfigurationRegistry_1 = require(\"vs/editor/common/modes/languageConfigurationRegistry\");\nvar repeatCache = Object.create(null);\nfunction cachedStringRepeat(str, count) {\n    if (!repeatCache[str]) {\n        repeatCache[str] = ['', str];\n    }\n    var cache = repeatCache[str];\n    for (var i = cache.length; i <= count; i++) {\n        cache[i] = cache[i - 1] + str;\n    }\n    return cache[count];\n}\nexports.cachedStringRepeat = cachedStringRepeat;\nvar ShiftCommand = /** @class */ (function () {\n    function ShiftCommand(range, opts) {\n        this._opts = opts;\n        this._selection = range;\n        this._useLastEditRangeForCursorEndPosition = false;\n        this._selectionStartColumnStaysPut = false;\n    }\n    ShiftCommand.unshiftIndent = function (line, column, tabSize, indentSize, insertSpaces) {\n        // Determine the visible column where the content starts\n        var contentStartVisibleColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n        if (insertSpaces) {\n            var indent = cachedStringRepeat(' ', indentSize);\n            var desiredTabStop = cursorCommon_1.CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\n            var indentCount = desiredTabStop / indentSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n        else {\n            var indent = '\\t';\n            var desiredTabStop = cursorCommon_1.CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\n            var indentCount = desiredTabStop / tabSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n    };\n    ShiftCommand.shiftIndent = function (line, column, tabSize, indentSize, insertSpaces) {\n        // Determine the visible column where the content starts\n        var contentStartVisibleColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n        if (insertSpaces) {\n            var indent = cachedStringRepeat(' ', indentSize);\n            var desiredTabStop = cursorCommon_1.CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\n            var indentCount = desiredTabStop / indentSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n        else {\n            var indent = '\\t';\n            var desiredTabStop = cursorCommon_1.CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\n            var indentCount = desiredTabStop / tabSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n    };\n    ShiftCommand.prototype._addEditOperation = function (builder, range, text) {\n        if (this._useLastEditRangeForCursorEndPosition) {\n            builder.addTrackedEditOperation(range, text);\n        }\n        else {\n            builder.addEditOperation(range, text);\n        }\n    };\n    ShiftCommand.prototype.getEditOperations = function (model, builder) {\n        var startLine = this._selection.startLineNumber;\n        var endLine = this._selection.endLineNumber;\n        if (this._selection.endColumn === 1 && startLine !== endLine) {\n            endLine = endLine - 1;\n        }\n        var _a = this._opts, tabSize = _a.tabSize, indentSize = _a.indentSize, insertSpaces = _a.insertSpaces;\n        var shouldIndentEmptyLines = (startLine === endLine);\n        // if indenting or outdenting on a whitespace only line\n        if (this._selection.isEmpty()) {\n            if (/^\\s*$/.test(model.getLineContent(startLine))) {\n                this._useLastEditRangeForCursorEndPosition = true;\n            }\n        }\n        if (this._opts.useTabStops) {\n            // keep track of previous line's \"miss-alignment\"\n            var previousLineExtraSpaces = 0, extraSpaces = 0;\n            for (var lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\n                extraSpaces = 0;\n                var lineText = model.getLineContent(lineNumber);\n                var indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n                    // empty line or line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n                    // do not indent empty lines => nothing to do\n                    continue;\n                }\n                if (indentationEndIndex === -1) {\n                    // the entire line is whitespace\n                    indentationEndIndex = lineText.length;\n                }\n                if (lineNumber > 1) {\n                    var contentStartVisibleColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\n                    if (contentStartVisibleColumn % indentSize !== 0) {\n                        // The current line is \"miss-aligned\", so let's see if this is expected...\n                        // This can only happen when it has trailing commas in the indent\n                        if (model.isCheapToTokenize(lineNumber - 1)) {\n                            var enterAction = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getRawEnterActionAtPosition(model, lineNumber - 1, model.getLineMaxColumn(lineNumber - 1));\n                            if (enterAction) {\n                                extraSpaces = previousLineExtraSpaces;\n                                if (enterAction.appendText) {\n                                    for (var j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\n                                        if (enterAction.appendText.charCodeAt(j) === charCode_1.CharCode.Space) {\n                                            extraSpaces++;\n                                        }\n                                        else {\n                                            break;\n                                        }\n                                    }\n                                }\n                                if (enterAction.removeText) {\n                                    extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\n                                }\n                                // Act as if `prefixSpaces` is not part of the indentation\n                                for (var j = 0; j < extraSpaces; j++) {\n                                    if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== charCode_1.CharCode.Space) {\n                                        break;\n                                    }\n                                    indentationEndIndex--;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\n                    // line with no leading whitespace => nothing to do\n                    continue;\n                }\n                var desiredIndent = void 0;\n                if (this._opts.isUnshift) {\n                    desiredIndent = ShiftCommand.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n                }\n                else {\n                    desiredIndent = ShiftCommand.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n                }\n                this._addEditOperation(builder, new range_1.Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\n                if (lineNumber === startLine) {\n                    // Force the startColumn to stay put because we're inserting after it\n                    this._selectionStartColumnStaysPut = (this._selection.startColumn <= indentationEndIndex + 1);\n                }\n            }\n        }\n        else {\n            var oneIndent = (insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t');\n            for (var lineNumber = startLine; lineNumber <= endLine; lineNumber++) {\n                var lineText = model.getLineContent(lineNumber);\n                var indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n                    // empty line or line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n                    // do not indent empty lines => nothing to do\n                    continue;\n                }\n                if (indentationEndIndex === -1) {\n                    // the entire line is whitespace\n                    indentationEndIndex = lineText.length;\n                }\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\n                    // line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (this._opts.isUnshift) {\n                    indentationEndIndex = Math.min(indentationEndIndex, indentSize);\n                    for (var i = 0; i < indentationEndIndex; i++) {\n                        var chr = lineText.charCodeAt(i);\n                        if (chr === charCode_1.CharCode.Tab) {\n                            indentationEndIndex = i + 1;\n                            break;\n                        }\n                    }\n                    this._addEditOperation(builder, new range_1.Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');\n                }\n                else {\n                    this._addEditOperation(builder, new range_1.Range(lineNumber, 1, lineNumber, 1), oneIndent);\n                    if (lineNumber === startLine) {\n                        // Force the startColumn to stay put because we're inserting after it\n                        this._selectionStartColumnStaysPut = (this._selection.startColumn === 1);\n                    }\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(this._selection);\n    };\n    ShiftCommand.prototype.computeCursorState = function (model, helper) {\n        if (this._useLastEditRangeForCursorEndPosition) {\n            var lastOp = helper.getInverseEditOperations()[0];\n            return new selection_1.Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\n        }\n        var result = helper.getTrackedSelection(this._selectionId);\n        if (this._selectionStartColumnStaysPut) {\n            // The selection start should not move\n            var initialStartColumn = this._selection.startColumn;\n            var resultStartColumn = result.startColumn;\n            if (resultStartColumn <= initialStartColumn) {\n                return result;\n            }\n            if (result.getDirection() === selection_1.SelectionDirection.LTR) {\n                return new selection_1.Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\n            }\n            return new selection_1.Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\n        }\n        return result;\n    };\n    return ShiftCommand;\n}());\nexports.ShiftCommand = ShiftCommand;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/commands/shiftCommand.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/commands/shiftCommand.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as strings from 'vs/base/common/strings';\nimport { CursorColumns } from 'vs/editor/common/controller/cursorCommon';\nimport { Range } from 'vs/editor/common/core/range';\nimport { Selection, SelectionDirection } from 'vs/editor/common/core/selection';\nimport { ICommand, ICursorStateComputerData, IEditOperationBuilder } from 'vs/editor/common/editorCommon';\nimport { ITextModel } from 'vs/editor/common/model';\nimport { LanguageConfigurationRegistry } from 'vs/editor/common/modes/languageConfigurationRegistry';\n\nexport interface IShiftCommandOpts {\n\tisUnshift: boolean;\n\ttabSize: number;\n\tindentSize: number;\n\tinsertSpaces: boolean;\n\tuseTabStops: boolean;\n}\n\nconst repeatCache: { [str: string]: string[]; } = Object.create(null);\nexport function cachedStringRepeat(str: string, count: number): string {\n\tif (!repeatCache[str]) {\n\t\trepeatCache[str] = ['', str];\n\t}\n\tconst cache = repeatCache[str];\n\tfor (let i = cache.length; i <= count; i++) {\n\t\tcache[i] = cache[i - 1] + str;\n\t}\n\treturn cache[count];\n}\n\nexport class ShiftCommand implements ICommand {\n\n\tpublic static unshiftIndent(line: string, column: number, tabSize: number, indentSize: number, insertSpaces: boolean): string {\n\t\t// Determine the visible column where the content starts\n\t\tconst contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n\n\t\tif (insertSpaces) {\n\t\t\tconst indent = cachedStringRepeat(' ', indentSize);\n\t\t\tconst desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\n\t\t\tconst indentCount = desiredTabStop / indentSize; // will be an integer\n\t\t\treturn cachedStringRepeat(indent, indentCount);\n\t\t} else {\n\t\t\tconst indent = '\\t';\n\t\t\tconst desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\n\t\t\tconst indentCount = desiredTabStop / tabSize; // will be an integer\n\t\t\treturn cachedStringRepeat(indent, indentCount);\n\t\t}\n\t}\n\n\tpublic static shiftIndent(line: string, column: number, tabSize: number, indentSize: number, insertSpaces: boolean): string {\n\t\t// Determine the visible column where the content starts\n\t\tconst contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n\n\t\tif (insertSpaces) {\n\t\t\tconst indent = cachedStringRepeat(' ', indentSize);\n\t\t\tconst desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\n\t\t\tconst indentCount = desiredTabStop / indentSize; // will be an integer\n\t\t\treturn cachedStringRepeat(indent, indentCount);\n\t\t} else {\n\t\t\tconst indent = '\\t';\n\t\t\tconst desiredTabStop = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\n\t\t\tconst indentCount = desiredTabStop / tabSize; // will be an integer\n\t\t\treturn cachedStringRepeat(indent, indentCount);\n\t\t}\n\t}\n\n\tprivate readonly _opts: IShiftCommandOpts;\n\tprivate readonly _selection: Selection;\n\tprivate _selectionId: string;\n\tprivate _useLastEditRangeForCursorEndPosition: boolean;\n\tprivate _selectionStartColumnStaysPut: boolean;\n\n\tconstructor(range: Selection, opts: IShiftCommandOpts) {\n\t\tthis._opts = opts;\n\t\tthis._selection = range;\n\t\tthis._useLastEditRangeForCursorEndPosition = false;\n\t\tthis._selectionStartColumnStaysPut = false;\n\t}\n\n\tprivate _addEditOperation(builder: IEditOperationBuilder, range: Range, text: string) {\n\t\tif (this._useLastEditRangeForCursorEndPosition) {\n\t\t\tbuilder.addTrackedEditOperation(range, text);\n\t\t} else {\n\t\t\tbuilder.addEditOperation(range, text);\n\t\t}\n\t}\n\n\tpublic getEditOperations(model: ITextModel, builder: IEditOperationBuilder): void {\n\t\tconst startLine = this._selection.startLineNumber;\n\n\t\tlet endLine = this._selection.endLineNumber;\n\t\tif (this._selection.endColumn === 1 && startLine !== endLine) {\n\t\t\tendLine = endLine - 1;\n\t\t}\n\n\t\tconst { tabSize, indentSize, insertSpaces } = this._opts;\n\t\tconst shouldIndentEmptyLines = (startLine === endLine);\n\n\t\t// if indenting or outdenting on a whitespace only line\n\t\tif (this._selection.isEmpty()) {\n\t\t\tif (/^\\s*$/.test(model.getLineContent(startLine))) {\n\t\t\t\tthis._useLastEditRangeForCursorEndPosition = true;\n\t\t\t}\n\t\t}\n\n\t\tif (this._opts.useTabStops) {\n\t\t\t// keep track of previous line's \"miss-alignment\"\n\t\t\tlet previousLineExtraSpaces = 0, extraSpaces = 0;\n\t\t\tfor (let lineNumber = startLine; lineNumber <= endLine; lineNumber++ , previousLineExtraSpaces = extraSpaces) {\n\t\t\t\textraSpaces = 0;\n\t\t\t\tlet lineText = model.getLineContent(lineNumber);\n\t\t\t\tlet indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n\n\t\t\t\tif (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n\t\t\t\t\t// empty line or line with no leading whitespace => nothing to do\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n\t\t\t\t\t// do not indent empty lines => nothing to do\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (indentationEndIndex === -1) {\n\t\t\t\t\t// the entire line is whitespace\n\t\t\t\t\tindentationEndIndex = lineText.length;\n\t\t\t\t}\n\n\t\t\t\tif (lineNumber > 1) {\n\t\t\t\t\tlet contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\n\t\t\t\t\tif (contentStartVisibleColumn % indentSize !== 0) {\n\t\t\t\t\t\t// The current line is \"miss-aligned\", so let's see if this is expected...\n\t\t\t\t\t\t// This can only happen when it has trailing commas in the indent\n\t\t\t\t\t\tif (model.isCheapToTokenize(lineNumber - 1)) {\n\t\t\t\t\t\t\tlet enterAction = LanguageConfigurationRegistry.getRawEnterActionAtPosition(model, lineNumber - 1, model.getLineMaxColumn(lineNumber - 1));\n\t\t\t\t\t\t\tif (enterAction) {\n\t\t\t\t\t\t\t\textraSpaces = previousLineExtraSpaces;\n\t\t\t\t\t\t\t\tif (enterAction.appendText) {\n\t\t\t\t\t\t\t\t\tfor (let j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\n\t\t\t\t\t\t\t\t\t\tif (enterAction.appendText.charCodeAt(j) === CharCode.Space) {\n\t\t\t\t\t\t\t\t\t\t\textraSpaces++;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (enterAction.removeText) {\n\t\t\t\t\t\t\t\t\textraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Act as if `prefixSpaces` is not part of the indentation\n\t\t\t\t\t\t\t\tfor (let j = 0; j < extraSpaces; j++) {\n\t\t\t\t\t\t\t\t\tif (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== CharCode.Space) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tindentationEndIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tif (this._opts.isUnshift && indentationEndIndex === 0) {\n\t\t\t\t\t// line with no leading whitespace => nothing to do\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet desiredIndent: string;\n\t\t\t\tif (this._opts.isUnshift) {\n\t\t\t\t\tdesiredIndent = ShiftCommand.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n\t\t\t\t} else {\n\t\t\t\t\tdesiredIndent = ShiftCommand.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n\t\t\t\t}\n\n\t\t\t\tthis._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\n\t\t\t\tif (lineNumber === startLine) {\n\t\t\t\t\t// Force the startColumn to stay put because we're inserting after it\n\t\t\t\t\tthis._selectionStartColumnStaysPut = (this._selection.startColumn <= indentationEndIndex + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\n\t\t\tconst oneIndent = (insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t');\n\n\t\t\tfor (let lineNumber = startLine; lineNumber <= endLine; lineNumber++) {\n\t\t\t\tconst lineText = model.getLineContent(lineNumber);\n\t\t\t\tlet indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n\n\t\t\t\tif (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n\t\t\t\t\t// empty line or line with no leading whitespace => nothing to do\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n\t\t\t\t\t// do not indent empty lines => nothing to do\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (indentationEndIndex === -1) {\n\t\t\t\t\t// the entire line is whitespace\n\t\t\t\t\tindentationEndIndex = lineText.length;\n\t\t\t\t}\n\n\t\t\t\tif (this._opts.isUnshift && indentationEndIndex === 0) {\n\t\t\t\t\t// line with no leading whitespace => nothing to do\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (this._opts.isUnshift) {\n\n\t\t\t\t\tindentationEndIndex = Math.min(indentationEndIndex, indentSize);\n\t\t\t\t\tfor (let i = 0; i < indentationEndIndex; i++) {\n\t\t\t\t\t\tconst chr = lineText.charCodeAt(i);\n\t\t\t\t\t\tif (chr === CharCode.Tab) {\n\t\t\t\t\t\t\tindentationEndIndex = i + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');\n\t\t\t\t} else {\n\t\t\t\t\tthis._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, 1), oneIndent);\n\t\t\t\t\tif (lineNumber === startLine) {\n\t\t\t\t\t\t// Force the startColumn to stay put because we're inserting after it\n\t\t\t\t\t\tthis._selectionStartColumnStaysPut = (this._selection.startColumn === 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._selectionId = builder.trackSelection(this._selection);\n\t}\n\n\tpublic computeCursorState(model: ITextModel, helper: ICursorStateComputerData): Selection {\n\t\tif (this._useLastEditRangeForCursorEndPosition) {\n\t\t\tlet lastOp = helper.getInverseEditOperations()[0];\n\t\t\treturn new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\n\t\t}\n\t\tconst result = helper.getTrackedSelection(this._selectionId);\n\n\t\tif (this._selectionStartColumnStaysPut) {\n\t\t\t// The selection start should not move\n\t\t\tlet initialStartColumn = this._selection.startColumn;\n\t\t\tlet resultStartColumn = result.startColumn;\n\t\t\tif (resultStartColumn <= initialStartColumn) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tif (result.getDirection() === SelectionDirection.LTR) {\n\t\t\t\treturn new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\n\t\t\t}\n\t\t\treturn new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n"]}]}