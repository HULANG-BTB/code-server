{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/syntaxRangeProvider.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/syntaxRangeProvider.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar errors_1 = require(\"vs/base/common/errors\");\nvar foldingRanges_1 = require(\"./foldingRanges\");\nvar MAX_FOLDING_REGIONS = 5000;\nvar foldingContext = {};\nexports.ID_SYNTAX_PROVIDER = 'syntax';\nvar SyntaxRangeProvider = /** @class */ (function () {\n    function SyntaxRangeProvider(editorModel, providers, limit) {\n        if (limit === void 0) { limit = MAX_FOLDING_REGIONS; }\n        this.editorModel = editorModel;\n        this.providers = providers;\n        this.limit = limit;\n        this.id = exports.ID_SYNTAX_PROVIDER;\n    }\n    SyntaxRangeProvider.prototype.compute = function (cancellationToken) {\n        var _this = this;\n        return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then(function (ranges) {\n            if (ranges) {\n                var res = sanitizeRanges(ranges, _this.limit);\n                return res;\n            }\n            return null;\n        });\n    };\n    SyntaxRangeProvider.prototype.dispose = function () {\n    };\n    return SyntaxRangeProvider;\n}());\nexports.SyntaxRangeProvider = SyntaxRangeProvider;\nfunction collectSyntaxRanges(providers, model, cancellationToken) {\n    var rangeData = null;\n    var promises = providers.map(function (provider, i) {\n        return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then(function (ranges) {\n            if (cancellationToken.isCancellationRequested) {\n                return;\n            }\n            if (Array.isArray(ranges)) {\n                if (!Array.isArray(rangeData)) {\n                    rangeData = [];\n                }\n                var nLines = model.getLineCount();\n                for (var _i = 0, ranges_1 = ranges; _i < ranges_1.length; _i++) {\n                    var r = ranges_1[_i];\n                    if (r.start > 0 && r.end > r.start && r.end <= nLines) {\n                        rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });\n                    }\n                }\n            }\n        }, errors_1.onUnexpectedExternalError);\n    });\n    return Promise.all(promises).then(function (_) {\n        return rangeData;\n    });\n}\nvar RangesCollector = /** @class */ (function () {\n    function RangesCollector(foldingRangesLimit) {\n        this._startIndexes = [];\n        this._endIndexes = [];\n        this._nestingLevels = [];\n        this._nestingLevelCounts = [];\n        this._types = [];\n        this._length = 0;\n        this._foldingRangesLimit = foldingRangesLimit;\n    }\n    RangesCollector.prototype.add = function (startLineNumber, endLineNumber, type, nestingLevel) {\n        if (startLineNumber > foldingRanges_1.MAX_LINE_NUMBER || endLineNumber > foldingRanges_1.MAX_LINE_NUMBER) {\n            return;\n        }\n        var index = this._length;\n        this._startIndexes[index] = startLineNumber;\n        this._endIndexes[index] = endLineNumber;\n        this._nestingLevels[index] = nestingLevel;\n        this._types[index] = type;\n        this._length++;\n        if (nestingLevel < 30) {\n            this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;\n        }\n    };\n    RangesCollector.prototype.toIndentRanges = function () {\n        if (this._length <= this._foldingRangesLimit) {\n            var startIndexes = new Uint32Array(this._length);\n            var endIndexes = new Uint32Array(this._length);\n            for (var i = 0; i < this._length; i++) {\n                startIndexes[i] = this._startIndexes[i];\n                endIndexes[i] = this._endIndexes[i];\n            }\n            return new foldingRanges_1.FoldingRegions(startIndexes, endIndexes, this._types);\n        }\n        else {\n            var entries = 0;\n            var maxLevel = this._nestingLevelCounts.length;\n            for (var i = 0; i < this._nestingLevelCounts.length; i++) {\n                var n = this._nestingLevelCounts[i];\n                if (n) {\n                    if (n + entries > this._foldingRangesLimit) {\n                        maxLevel = i;\n                        break;\n                    }\n                    entries += n;\n                }\n            }\n            var startIndexes = new Uint32Array(this._foldingRangesLimit);\n            var endIndexes = new Uint32Array(this._foldingRangesLimit);\n            var types = [];\n            for (var i = 0, k = 0; i < this._length; i++) {\n                var level = this._nestingLevels[i];\n                if (level < maxLevel || (level === maxLevel && entries++ < this._foldingRangesLimit)) {\n                    startIndexes[k] = this._startIndexes[i];\n                    endIndexes[k] = this._endIndexes[i];\n                    types[k] = this._types[i];\n                    k++;\n                }\n            }\n            return new foldingRanges_1.FoldingRegions(startIndexes, endIndexes, types);\n        }\n    };\n    return RangesCollector;\n}());\nexports.RangesCollector = RangesCollector;\nfunction sanitizeRanges(rangeData, limit) {\n    var sorted = rangeData.sort(function (d1, d2) {\n        var diff = d1.start - d2.start;\n        if (diff === 0) {\n            diff = d1.rank - d2.rank;\n        }\n        return diff;\n    });\n    var collector = new RangesCollector(limit);\n    var top = undefined;\n    var previous = [];\n    for (var _i = 0, sorted_1 = sorted; _i < sorted_1.length; _i++) {\n        var entry = sorted_1[_i];\n        if (!top) {\n            top = entry;\n            collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n        }\n        else {\n            if (entry.start > top.start) {\n                if (entry.end <= top.end) {\n                    previous.push(top);\n                    top = entry;\n                    collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n                }\n                else {\n                    if (entry.start > top.end) {\n                        do {\n                            top = previous.pop();\n                        } while (top && entry.start > top.end);\n                        if (top) {\n                            previous.push(top);\n                        }\n                        top = entry;\n                    }\n                    collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n                }\n            }\n        }\n    }\n    return collector.toIndentRanges();\n}\nexports.sanitizeRanges = sanitizeRanges;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/syntaxRangeProvider.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/syntaxRangeProvider.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { FoldingRangeProvider, FoldingRange, FoldingContext } from 'vs/editor/common/modes';\nimport { onUnexpectedExternalError } from 'vs/base/common/errors';\nimport { ITextModel } from 'vs/editor/common/model';\nimport { RangeProvider } from './folding';\nimport { MAX_LINE_NUMBER, FoldingRegions } from './foldingRanges';\nimport { CancellationToken } from 'vs/base/common/cancellation';\n\nconst MAX_FOLDING_REGIONS = 5000;\n\nexport interface IFoldingRangeData extends FoldingRange {\n\trank: number;\n}\n\nconst foldingContext: FoldingContext = {\n};\n\nexport const ID_SYNTAX_PROVIDER = 'syntax';\n\nexport class SyntaxRangeProvider implements RangeProvider {\n\n\treadonly id = ID_SYNTAX_PROVIDER;\n\n\tconstructor(private readonly editorModel: ITextModel, private providers: FoldingRangeProvider[], private limit = MAX_FOLDING_REGIONS) {\n\t}\n\n\tcompute(cancellationToken: CancellationToken): Promise<FoldingRegions | null> {\n\t\treturn collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then(ranges => {\n\t\t\tif (ranges) {\n\t\t\t\tlet res = sanitizeRanges(ranges, this.limit);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}\n\n\tdispose() {\n\t}\n\n}\n\nfunction collectSyntaxRanges(providers: FoldingRangeProvider[], model: ITextModel, cancellationToken: CancellationToken): Promise<IFoldingRangeData[] | null> {\n\tlet rangeData: IFoldingRangeData[] | null = null;\n\tlet promises = providers.map((provider, i) => {\n\t\treturn Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then(ranges => {\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (Array.isArray(ranges)) {\n\t\t\t\tif (!Array.isArray(rangeData)) {\n\t\t\t\t\trangeData = [];\n\t\t\t\t}\n\t\t\t\tlet nLines = model.getLineCount();\n\t\t\t\tfor (let r of ranges) {\n\t\t\t\t\tif (r.start > 0 && r.end > r.start && r.end <= nLines) {\n\t\t\t\t\t\trangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, onUnexpectedExternalError);\n\t});\n\treturn Promise.all(promises).then(_ => {\n\t\treturn rangeData;\n\t});\n}\n\nexport class RangesCollector {\n\tprivate readonly _startIndexes: number[];\n\tprivate readonly _endIndexes: number[];\n\tprivate readonly _nestingLevels: number[];\n\tprivate readonly _nestingLevelCounts: number[];\n\tprivate readonly _types: Array<string | undefined>;\n\tprivate _length: number;\n\tprivate readonly _foldingRangesLimit: number;\n\n\tconstructor(foldingRangesLimit: number) {\n\t\tthis._startIndexes = [];\n\t\tthis._endIndexes = [];\n\t\tthis._nestingLevels = [];\n\t\tthis._nestingLevelCounts = [];\n\t\tthis._types = [];\n\t\tthis._length = 0;\n\t\tthis._foldingRangesLimit = foldingRangesLimit;\n\t}\n\n\tpublic add(startLineNumber: number, endLineNumber: number, type: string | undefined, nestingLevel: number) {\n\t\tif (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n\t\t\treturn;\n\t\t}\n\t\tlet index = this._length;\n\t\tthis._startIndexes[index] = startLineNumber;\n\t\tthis._endIndexes[index] = endLineNumber;\n\t\tthis._nestingLevels[index] = nestingLevel;\n\t\tthis._types[index] = type;\n\t\tthis._length++;\n\t\tif (nestingLevel < 30) {\n\t\t\tthis._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;\n\t\t}\n\t}\n\n\tpublic toIndentRanges() {\n\t\tif (this._length <= this._foldingRangesLimit) {\n\t\t\tlet startIndexes = new Uint32Array(this._length);\n\t\t\tlet endIndexes = new Uint32Array(this._length);\n\t\t\tfor (let i = 0; i < this._length; i++) {\n\t\t\t\tstartIndexes[i] = this._startIndexes[i];\n\t\t\t\tendIndexes[i] = this._endIndexes[i];\n\t\t\t}\n\t\t\treturn new FoldingRegions(startIndexes, endIndexes, this._types);\n\t\t} else {\n\t\t\tlet entries = 0;\n\t\t\tlet maxLevel = this._nestingLevelCounts.length;\n\t\t\tfor (let i = 0; i < this._nestingLevelCounts.length; i++) {\n\t\t\t\tlet n = this._nestingLevelCounts[i];\n\t\t\t\tif (n) {\n\t\t\t\t\tif (n + entries > this._foldingRangesLimit) {\n\t\t\t\t\t\tmaxLevel = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tentries += n;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet startIndexes = new Uint32Array(this._foldingRangesLimit);\n\t\t\tlet endIndexes = new Uint32Array(this._foldingRangesLimit);\n\t\t\tlet types: Array<string | undefined> = [];\n\t\t\tfor (let i = 0, k = 0; i < this._length; i++) {\n\t\t\t\tlet level = this._nestingLevels[i];\n\t\t\t\tif (level < maxLevel || (level === maxLevel && entries++ < this._foldingRangesLimit)) {\n\t\t\t\t\tstartIndexes[k] = this._startIndexes[i];\n\t\t\t\t\tendIndexes[k] = this._endIndexes[i];\n\t\t\t\t\ttypes[k] = this._types[i];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new FoldingRegions(startIndexes, endIndexes, types);\n\t\t}\n\n\t}\n\n}\n\nexport function sanitizeRanges(rangeData: IFoldingRangeData[], limit: number): FoldingRegions {\n\n\tlet sorted = rangeData.sort((d1, d2) => {\n\t\tlet diff = d1.start - d2.start;\n\t\tif (diff === 0) {\n\t\t\tdiff = d1.rank - d2.rank;\n\t\t}\n\t\treturn diff;\n\t});\n\tlet collector = new RangesCollector(limit);\n\n\tlet top: IFoldingRangeData | undefined = undefined;\n\tlet previous: IFoldingRangeData[] = [];\n\tfor (let entry of sorted) {\n\t\tif (!top) {\n\t\t\ttop = entry;\n\t\t\tcollector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n\t\t} else {\n\t\t\tif (entry.start > top.start) {\n\t\t\t\tif (entry.end <= top.end) {\n\t\t\t\t\tprevious.push(top);\n\t\t\t\t\ttop = entry;\n\t\t\t\t\tcollector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n\t\t\t\t} else {\n\t\t\t\t\tif (entry.start > top.end) {\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\ttop = previous.pop();\n\t\t\t\t\t\t} while (top && entry.start > top.end);\n\t\t\t\t\t\tif (top) {\n\t\t\t\t\t\t\tprevious.push(top);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttop = entry;\n\t\t\t\t\t}\n\t\t\t\t\tcollector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn collector.toIndentRanges();\n}\n"]}]}