{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/textToHtmlTokenizer.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/textToHtmlTokenizer.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar strings = require(\"vs/base/common/strings\");\nvar lineTokens_1 = require(\"vs/editor/common/core/lineTokens\");\nvar modes_1 = require(\"vs/editor/common/modes\");\nvar nullMode_1 = require(\"vs/editor/common/modes/nullMode\");\nvar fallback = {\n    getInitialState: function () { return nullMode_1.NULL_STATE; },\n    tokenize2: function (buffer, state, deltaOffset) { return nullMode_1.nullTokenize2(modes_1.LanguageId.Null, buffer, state, deltaOffset); }\n};\nfunction tokenizeToString(text, tokenizationSupport) {\n    if (tokenizationSupport === void 0) { tokenizationSupport = fallback; }\n    return _tokenizeToString(text, tokenizationSupport || fallback);\n}\nexports.tokenizeToString = tokenizeToString;\nfunction tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize) {\n    var result = \"<div>\";\n    var charIndex = startOffset;\n    var tabsCharDelta = 0;\n    for (var tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n        var tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n        if (tokenEndIndex <= startOffset) {\n            continue;\n        }\n        var partContent = '';\n        for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n            var charCode = text.charCodeAt(charIndex);\n            switch (charCode) {\n                case charCode_1.CharCode.Tab:\n                    var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    while (insertSpacesCount > 0) {\n                        partContent += '&nbsp;';\n                        insertSpacesCount--;\n                    }\n                    break;\n                case charCode_1.CharCode.LessThan:\n                    partContent += '&lt;';\n                    break;\n                case charCode_1.CharCode.GreaterThan:\n                    partContent += '&gt;';\n                    break;\n                case charCode_1.CharCode.Ampersand:\n                    partContent += '&amp;';\n                    break;\n                case charCode_1.CharCode.Null:\n                    partContent += '&#00;';\n                    break;\n                case charCode_1.CharCode.UTF8_BOM:\n                case charCode_1.CharCode.LINE_SEPARATOR_2028:\n                    partContent += '\\ufffd';\n                    break;\n                case charCode_1.CharCode.CarriageReturn:\n                    // zero width space, because carriage return would introduce a line break\n                    partContent += '&#8203';\n                    break;\n                default:\n                    partContent += String.fromCharCode(charCode);\n            }\n        }\n        result += \"<span style=\\\"\" + viewLineTokens.getInlineStyle(tokenIndex, colorMap) + \"\\\">\" + partContent + \"</span>\";\n        if (tokenEndIndex > endOffset || charIndex >= endOffset) {\n            break;\n        }\n    }\n    result += \"</div>\";\n    return result;\n}\nexports.tokenizeLineToHTML = tokenizeLineToHTML;\nfunction _tokenizeToString(text, tokenizationSupport) {\n    var result = \"<div class=\\\"monaco-tokenized-source\\\">\";\n    var lines = text.split(/\\r\\n|\\r|\\n/);\n    var currentState = tokenizationSupport.getInitialState();\n    for (var i = 0, len = lines.length; i < len; i++) {\n        var line = lines[i];\n        if (i > 0) {\n            result += \"<br/>\";\n        }\n        var tokenizationResult = tokenizationSupport.tokenize2(line, currentState, 0);\n        lineTokens_1.LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n        var lineTokens = new lineTokens_1.LineTokens(tokenizationResult.tokens, line);\n        var viewLineTokens = lineTokens.inflate();\n        var startOffset = 0;\n        for (var j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n            var type = viewLineTokens.getClassName(j);\n            var endIndex = viewLineTokens.getEndOffset(j);\n            result += \"<span class=\\\"\" + type + \"\\\">\" + strings.escape(line.substring(startOffset, endIndex)) + \"</span>\";\n            startOffset = endIndex;\n        }\n        currentState = tokenizationResult.endState;\n    }\n    result += \"</div>\";\n    return result;\n}\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/textToHtmlTokenizer.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/textToHtmlTokenizer.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as strings from 'vs/base/common/strings';\nimport { IViewLineTokens, LineTokens } from 'vs/editor/common/core/lineTokens';\nimport { TokenizationResult2 } from 'vs/editor/common/core/token';\nimport { IState, LanguageId } from 'vs/editor/common/modes';\nimport { NULL_STATE, nullTokenize2 } from 'vs/editor/common/modes/nullMode';\n\nexport interface IReducedTokenizationSupport {\n\tgetInitialState(): IState;\n\ttokenize2(line: string, state: IState, offsetDelta: number): TokenizationResult2;\n}\n\nconst fallback: IReducedTokenizationSupport = {\n\tgetInitialState: () => NULL_STATE,\n\ttokenize2: (buffer: string, state: IState, deltaOffset: number) => nullTokenize2(LanguageId.Null, buffer, state, deltaOffset)\n};\n\nexport function tokenizeToString(text: string, tokenizationSupport: IReducedTokenizationSupport = fallback): string {\n\treturn _tokenizeToString(text, tokenizationSupport || fallback);\n}\n\nexport function tokenizeLineToHTML(text: string, viewLineTokens: IViewLineTokens, colorMap: string[], startOffset: number, endOffset: number, tabSize: number): string {\n\tlet result = `<div>`;\n\tlet charIndex = startOffset;\n\tlet tabsCharDelta = 0;\n\n\tfor (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n\t\tconst tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n\n\t\tif (tokenEndIndex <= startOffset) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet partContent = '';\n\n\t\tfor (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n\t\t\tconst charCode = text.charCodeAt(charIndex);\n\n\t\t\tswitch (charCode) {\n\t\t\t\tcase CharCode.Tab:\n\t\t\t\t\tlet insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n\t\t\t\t\ttabsCharDelta += insertSpacesCount - 1;\n\t\t\t\t\twhile (insertSpacesCount > 0) {\n\t\t\t\t\t\tpartContent += '&nbsp;';\n\t\t\t\t\t\tinsertSpacesCount--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.LessThan:\n\t\t\t\t\tpartContent += '&lt;';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.GreaterThan:\n\t\t\t\t\tpartContent += '&gt;';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.Ampersand:\n\t\t\t\t\tpartContent += '&amp;';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.Null:\n\t\t\t\t\tpartContent += '&#00;';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.UTF8_BOM:\n\t\t\t\tcase CharCode.LINE_SEPARATOR_2028:\n\t\t\t\t\tpartContent += '\\ufffd';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.CarriageReturn:\n\t\t\t\t\t// zero width space, because carriage return would introduce a line break\n\t\t\t\t\tpartContent += '&#8203';\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tpartContent += String.fromCharCode(charCode);\n\t\t\t}\n\t\t}\n\n\t\tresult += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n\n\t\tif (tokenEndIndex > endOffset || charIndex >= endOffset) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tresult += `</div>`;\n\treturn result;\n}\n\nfunction _tokenizeToString(text: string, tokenizationSupport: IReducedTokenizationSupport): string {\n\tlet result = `<div class=\"monaco-tokenized-source\">`;\n\tlet lines = text.split(/\\r\\n|\\r|\\n/);\n\tlet currentState = tokenizationSupport.getInitialState();\n\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\tlet line = lines[i];\n\n\t\tif (i > 0) {\n\t\t\tresult += `<br/>`;\n\t\t}\n\n\t\tlet tokenizationResult = tokenizationSupport.tokenize2(line, currentState, 0);\n\t\tLineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n\t\tlet lineTokens = new LineTokens(tokenizationResult.tokens, line);\n\t\tlet viewLineTokens = lineTokens.inflate();\n\n\t\tlet startOffset = 0;\n\t\tfor (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n\t\t\tconst type = viewLineTokens.getClassName(j);\n\t\t\tconst endIndex = viewLineTokens.getEndOffset(j);\n\t\t\tresult += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n\t\t\tstartOffset = endIndex;\n\t\t}\n\n\t\tcurrentState = tokenizationResult.endState;\n\t}\n\n\tresult += `</div>`;\n\treturn result;\n}\n"]}]}