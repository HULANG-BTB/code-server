{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/node/windowsShellHelper.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/node/windowsShellHelper.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/platform\", \"vs/base/common/event\"], function (require, exports, platform, event_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const SHELL_EXECUTABLES = [\n        'cmd.exe',\n        'powershell.exe',\n        'bash.exe',\n        'wsl.exe',\n        'ubuntu.exe',\n        'ubuntu1804.exe',\n        'kali.exe',\n        'debian.exe',\n        'opensuse-42.exe',\n        'sles-12.exe'\n    ];\n    let windowsProcessTree;\n    class WindowsShellHelper {\n        constructor(_rootProcessId, _terminalInstance, _xterm) {\n            this._rootProcessId = _rootProcessId;\n            this._terminalInstance = _terminalInstance;\n            this._xterm = _xterm;\n            if (!platform.isWindows) {\n                throw new Error(`WindowsShellHelper cannot be instantiated on ${platform.platform}`);\n            }\n            this._isDisposed = false;\n            (new Promise((resolve_1, reject_1) => { require(['windows-process-tree'], resolve_1, reject_1); })).then(mod => {\n                if (this._isDisposed) {\n                    return;\n                }\n                windowsProcessTree = mod;\n                this._onCheckShell = new event_1.Emitter();\n                // The debounce is necessary to prevent multiple processes from spawning when\n                // the enter key or output is spammed\n                event_1.Event.debounce(this._onCheckShell.event, (l, e) => e, 150, true)(() => {\n                    setTimeout(() => {\n                        this.checkShell();\n                    }, 50);\n                });\n                // We want to fire a new check for the shell on a linefeed, but only\n                // when parsing has finished which is indicated by the cursormove event.\n                // If this is done on every linefeed, parsing ends up taking\n                // significantly longer due to resetting timers. Note that this is\n                // private API.\n                this._xterm.on('linefeed', () => this._newLineFeed = true);\n                this._xterm.on('cursormove', () => {\n                    if (this._newLineFeed) {\n                        this._onCheckShell.fire(undefined);\n                    }\n                });\n                // Fire a new check for the shell when any key is pressed.\n                this._xterm.on('keypress', () => this._onCheckShell.fire(undefined));\n            });\n        }\n        checkShell() {\n            if (platform.isWindows && this._terminalInstance.isTitleSetByProcess) {\n                this.getShellName().then(title => {\n                    if (!this._isDisposed) {\n                        this._terminalInstance.setTitle(title, true);\n                    }\n                });\n            }\n        }\n        traverseTree(tree) {\n            if (!tree) {\n                return '';\n            }\n            if (SHELL_EXECUTABLES.indexOf(tree.name) === -1) {\n                return tree.name;\n            }\n            if (!tree.children || tree.children.length === 0) {\n                return tree.name;\n            }\n            let favouriteChild = 0;\n            for (; favouriteChild < tree.children.length; favouriteChild++) {\n                const child = tree.children[favouriteChild];\n                if (!child.children || child.children.length === 0) {\n                    break;\n                }\n                if (child.children[0].name !== 'conhost.exe') {\n                    break;\n                }\n            }\n            if (favouriteChild >= tree.children.length) {\n                return tree.name;\n            }\n            return this.traverseTree(tree.children[favouriteChild]);\n        }\n        dispose() {\n            this._isDisposed = true;\n        }\n        /**\n         * Returns the innermost shell executable running in the terminal\n         */\n        getShellName() {\n            if (this._isDisposed) {\n                return Promise.resolve('');\n            }\n            // Prevent multiple requests at once, instead return current request\n            if (this._currentRequest) {\n                return this._currentRequest;\n            }\n            this._currentRequest = new Promise(resolve => {\n                windowsProcessTree.getProcessTree(this._rootProcessId, (tree) => {\n                    const name = this.traverseTree(tree);\n                    this._currentRequest = null;\n                    resolve(name);\n                });\n            });\n            return this._currentRequest;\n        }\n    }\n    exports.WindowsShellHelper = WindowsShellHelper;\n});\n",null]}