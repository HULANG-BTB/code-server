{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/platform/driver/node/driver.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/driver/node/driver.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar ipc_net_1 = require(\"vs/base/parts/ipc/node/ipc.net\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nexports.ID = 'driverService';\nexports.IDriver = instantiation_1.createDecorator(exports.ID);\n//*END\nvar DriverChannel = /** @class */ (function () {\n    function DriverChannel(driver) {\n        this.driver = driver;\n    }\n    DriverChannel.prototype.listen = function (_, event) {\n        throw new Error('No event found');\n    };\n    DriverChannel.prototype.call = function (_, command, arg) {\n        switch (command) {\n            case 'getWindowIds': return this.driver.getWindowIds();\n            case 'capturePage': return this.driver.capturePage(arg);\n            case 'reloadWindow': return this.driver.reloadWindow(arg);\n            case 'exitApplication': return this.driver.exitApplication();\n            case 'dispatchKeybinding': return this.driver.dispatchKeybinding(arg[0], arg[1]);\n            case 'click': return this.driver.click(arg[0], arg[1], arg[2], arg[3]);\n            case 'doubleClick': return this.driver.doubleClick(arg[0], arg[1]);\n            case 'setValue': return this.driver.setValue(arg[0], arg[1], arg[2]);\n            case 'getTitle': return this.driver.getTitle(arg[0]);\n            case 'isActiveElement': return this.driver.isActiveElement(arg[0], arg[1]);\n            case 'getElements': return this.driver.getElements(arg[0], arg[1], arg[2]);\n            case 'typeInEditor': return this.driver.typeInEditor(arg[0], arg[1], arg[2]);\n            case 'getTerminalBuffer': return this.driver.getTerminalBuffer(arg[0], arg[1]);\n            case 'writeInTerminal': return this.driver.writeInTerminal(arg[0], arg[1], arg[2]);\n        }\n        throw new Error(\"Call not found: \" + command);\n    };\n    return DriverChannel;\n}());\nexports.DriverChannel = DriverChannel;\nvar DriverChannelClient = /** @class */ (function () {\n    function DriverChannelClient(channel) {\n        this.channel = channel;\n    }\n    DriverChannelClient.prototype.getWindowIds = function () {\n        return this.channel.call('getWindowIds');\n    };\n    DriverChannelClient.prototype.capturePage = function (windowId) {\n        return this.channel.call('capturePage', windowId);\n    };\n    DriverChannelClient.prototype.reloadWindow = function (windowId) {\n        return this.channel.call('reloadWindow', windowId);\n    };\n    DriverChannelClient.prototype.exitApplication = function () {\n        return this.channel.call('exitApplication');\n    };\n    DriverChannelClient.prototype.dispatchKeybinding = function (windowId, keybinding) {\n        return this.channel.call('dispatchKeybinding', [windowId, keybinding]);\n    };\n    DriverChannelClient.prototype.click = function (windowId, selector, xoffset, yoffset) {\n        return this.channel.call('click', [windowId, selector, xoffset, yoffset]);\n    };\n    DriverChannelClient.prototype.doubleClick = function (windowId, selector) {\n        return this.channel.call('doubleClick', [windowId, selector]);\n    };\n    DriverChannelClient.prototype.setValue = function (windowId, selector, text) {\n        return this.channel.call('setValue', [windowId, selector, text]);\n    };\n    DriverChannelClient.prototype.getTitle = function (windowId) {\n        return this.channel.call('getTitle', [windowId]);\n    };\n    DriverChannelClient.prototype.isActiveElement = function (windowId, selector) {\n        return this.channel.call('isActiveElement', [windowId, selector]);\n    };\n    DriverChannelClient.prototype.getElements = function (windowId, selector, recursive) {\n        return this.channel.call('getElements', [windowId, selector, recursive]);\n    };\n    DriverChannelClient.prototype.typeInEditor = function (windowId, selector, text) {\n        return this.channel.call('typeInEditor', [windowId, selector, text]);\n    };\n    DriverChannelClient.prototype.getTerminalBuffer = function (windowId, selector) {\n        return this.channel.call('getTerminalBuffer', [windowId, selector]);\n    };\n    DriverChannelClient.prototype.writeInTerminal = function (windowId, selector, text) {\n        return this.channel.call('writeInTerminal', [windowId, selector, text]);\n    };\n    return DriverChannelClient;\n}());\nexports.DriverChannelClient = DriverChannelClient;\nvar WindowDriverRegistryChannel = /** @class */ (function () {\n    function WindowDriverRegistryChannel(registry) {\n        this.registry = registry;\n    }\n    WindowDriverRegistryChannel.prototype.listen = function (_, event) {\n        throw new Error(\"Event not found: \" + event);\n    };\n    WindowDriverRegistryChannel.prototype.call = function (_, command, arg) {\n        switch (command) {\n            case 'registerWindowDriver': return this.registry.registerWindowDriver(arg);\n            case 'reloadWindowDriver': return this.registry.reloadWindowDriver(arg);\n        }\n        throw new Error(\"Call not found: \" + command);\n    };\n    return WindowDriverRegistryChannel;\n}());\nexports.WindowDriverRegistryChannel = WindowDriverRegistryChannel;\nvar WindowDriverRegistryChannelClient = /** @class */ (function () {\n    function WindowDriverRegistryChannelClient(channel) {\n        this.channel = channel;\n    }\n    WindowDriverRegistryChannelClient.prototype.registerWindowDriver = function (windowId) {\n        return this.channel.call('registerWindowDriver', windowId);\n    };\n    WindowDriverRegistryChannelClient.prototype.reloadWindowDriver = function (windowId) {\n        return this.channel.call('reloadWindowDriver', windowId);\n    };\n    return WindowDriverRegistryChannelClient;\n}());\nexports.WindowDriverRegistryChannelClient = WindowDriverRegistryChannelClient;\nvar WindowDriverChannel = /** @class */ (function () {\n    function WindowDriverChannel(driver) {\n        this.driver = driver;\n    }\n    WindowDriverChannel.prototype.listen = function (_, event) {\n        throw new Error(\"No event found: \" + event);\n    };\n    WindowDriverChannel.prototype.call = function (_, command, arg) {\n        switch (command) {\n            case 'click': return this.driver.click(arg[0], arg[1], arg[2]);\n            case 'doubleClick': return this.driver.doubleClick(arg);\n            case 'setValue': return this.driver.setValue(arg[0], arg[1]);\n            case 'getTitle': return this.driver.getTitle();\n            case 'isActiveElement': return this.driver.isActiveElement(arg);\n            case 'getElements': return this.driver.getElements(arg[0], arg[1]);\n            case 'typeInEditor': return this.driver.typeInEditor(arg[0], arg[1]);\n            case 'getTerminalBuffer': return this.driver.getTerminalBuffer(arg);\n            case 'writeInTerminal': return this.driver.writeInTerminal(arg[0], arg[1]);\n        }\n        throw new Error(\"Call not found: \" + command);\n    };\n    return WindowDriverChannel;\n}());\nexports.WindowDriverChannel = WindowDriverChannel;\nvar WindowDriverChannelClient = /** @class */ (function () {\n    function WindowDriverChannelClient(channel) {\n        this.channel = channel;\n    }\n    WindowDriverChannelClient.prototype.click = function (selector, xoffset, yoffset) {\n        return this.channel.call('click', [selector, xoffset, yoffset]);\n    };\n    WindowDriverChannelClient.prototype.doubleClick = function (selector) {\n        return this.channel.call('doubleClick', selector);\n    };\n    WindowDriverChannelClient.prototype.setValue = function (selector, text) {\n        return this.channel.call('setValue', [selector, text]);\n    };\n    WindowDriverChannelClient.prototype.getTitle = function () {\n        return this.channel.call('getTitle');\n    };\n    WindowDriverChannelClient.prototype.isActiveElement = function (selector) {\n        return this.channel.call('isActiveElement', selector);\n    };\n    WindowDriverChannelClient.prototype.getElements = function (selector, recursive) {\n        return this.channel.call('getElements', [selector, recursive]);\n    };\n    WindowDriverChannelClient.prototype.typeInEditor = function (selector, text) {\n        return this.channel.call('typeInEditor', [selector, text]);\n    };\n    WindowDriverChannelClient.prototype.getTerminalBuffer = function (selector) {\n        return this.channel.call('getTerminalBuffer', selector);\n    };\n    WindowDriverChannelClient.prototype.writeInTerminal = function (selector, text) {\n        return this.channel.call('writeInTerminal', [selector, text]);\n    };\n    return WindowDriverChannelClient;\n}());\nexports.WindowDriverChannelClient = WindowDriverChannelClient;\nfunction connect(handle) {\n    return tslib_1.__awaiter(this, void 0, Promise, function () {\n        var client, channel, driver;\n        return tslib_1.__generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, ipc_net_1.connect(handle, 'driverClient')];\n                case 1:\n                    client = _a.sent();\n                    channel = client.getChannel('driver');\n                    driver = new DriverChannelClient(channel);\n                    return [2 /*return*/, { client: client, driver: driver }];\n            }\n        });\n    });\n}\nexports.connect = connect;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/platform/driver/node/driver.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/platform/driver/node/driver.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Client } from 'vs/base/parts/ipc/common/ipc.net';\nimport { connect as connectNet } from 'vs/base/parts/ipc/node/ipc.net';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IChannel, IServerChannel } from 'vs/base/parts/ipc/common/ipc';\nimport { Event } from 'vs/base/common/event';\n\nexport const ID = 'driverService';\nexport const IDriver = createDecorator<IDriver>(ID);\n\n// !! Do not remove the following START and END markers, they are parsed by the smoketest build\n\n//*START\nexport interface IElement {\n\ttagName: string;\n\tclassName: string;\n\ttextContent: string;\n\tattributes: { [name: string]: string; };\n\tchildren: IElement[];\n\ttop: number;\n\tleft: number;\n}\n\nexport interface IDriver {\n\t_serviceBrand: any;\n\n\tgetWindowIds(): Promise<number[]>;\n\tcapturePage(windowId: number): Promise<string>;\n\treloadWindow(windowId: number): Promise<void>;\n\texitApplication(): Promise<void>;\n\tdispatchKeybinding(windowId: number, keybinding: string): Promise<void>;\n\tclick(windowId: number, selector: string, xoffset?: number | undefined, yoffset?: number | undefined): Promise<void>;\n\tdoubleClick(windowId: number, selector: string): Promise<void>;\n\tsetValue(windowId: number, selector: string, text: string): Promise<void>;\n\tgetTitle(windowId: number): Promise<string>;\n\tisActiveElement(windowId: number, selector: string): Promise<boolean>;\n\tgetElements(windowId: number, selector: string, recursive?: boolean): Promise<IElement[]>;\n\ttypeInEditor(windowId: number, selector: string, text: string): Promise<void>;\n\tgetTerminalBuffer(windowId: number, selector: string): Promise<string[]>;\n\twriteInTerminal(windowId: number, selector: string, text: string): Promise<void>;\n}\n//*END\n\nexport class DriverChannel implements IServerChannel {\n\n\tconstructor(private driver: IDriver) { }\n\n\tlisten<T>(_: unknown, event: string): Event<T> {\n\t\tthrow new Error('No event found');\n\t}\n\n\tcall(_: unknown, command: string, arg?: any): Promise<any> {\n\t\tswitch (command) {\n\t\t\tcase 'getWindowIds': return this.driver.getWindowIds();\n\t\t\tcase 'capturePage': return this.driver.capturePage(arg);\n\t\t\tcase 'reloadWindow': return this.driver.reloadWindow(arg);\n\t\t\tcase 'exitApplication': return this.driver.exitApplication();\n\t\t\tcase 'dispatchKeybinding': return this.driver.dispatchKeybinding(arg[0], arg[1]);\n\t\t\tcase 'click': return this.driver.click(arg[0], arg[1], arg[2], arg[3]);\n\t\t\tcase 'doubleClick': return this.driver.doubleClick(arg[0], arg[1]);\n\t\t\tcase 'setValue': return this.driver.setValue(arg[0], arg[1], arg[2]);\n\t\t\tcase 'getTitle': return this.driver.getTitle(arg[0]);\n\t\t\tcase 'isActiveElement': return this.driver.isActiveElement(arg[0], arg[1]);\n\t\t\tcase 'getElements': return this.driver.getElements(arg[0], arg[1], arg[2]);\n\t\t\tcase 'typeInEditor': return this.driver.typeInEditor(arg[0], arg[1], arg[2]);\n\t\t\tcase 'getTerminalBuffer': return this.driver.getTerminalBuffer(arg[0], arg[1]);\n\t\t\tcase 'writeInTerminal': return this.driver.writeInTerminal(arg[0], arg[1], arg[2]);\n\t\t}\n\n\t\tthrow new Error(`Call not found: ${command}`);\n\t}\n}\n\nexport class DriverChannelClient implements IDriver {\n\n\t_serviceBrand: any;\n\n\tconstructor(private channel: IChannel) { }\n\n\tgetWindowIds(): Promise<number[]> {\n\t\treturn this.channel.call('getWindowIds');\n\t}\n\n\tcapturePage(windowId: number): Promise<string> {\n\t\treturn this.channel.call('capturePage', windowId);\n\t}\n\n\treloadWindow(windowId: number): Promise<void> {\n\t\treturn this.channel.call('reloadWindow', windowId);\n\t}\n\n\texitApplication(): Promise<void> {\n\t\treturn this.channel.call('exitApplication');\n\t}\n\n\tdispatchKeybinding(windowId: number, keybinding: string): Promise<void> {\n\t\treturn this.channel.call('dispatchKeybinding', [windowId, keybinding]);\n\t}\n\n\tclick(windowId: number, selector: string, xoffset: number | undefined, yoffset: number | undefined): Promise<void> {\n\t\treturn this.channel.call('click', [windowId, selector, xoffset, yoffset]);\n\t}\n\n\tdoubleClick(windowId: number, selector: string): Promise<void> {\n\t\treturn this.channel.call('doubleClick', [windowId, selector]);\n\t}\n\n\tsetValue(windowId: number, selector: string, text: string): Promise<void> {\n\t\treturn this.channel.call('setValue', [windowId, selector, text]);\n\t}\n\n\tgetTitle(windowId: number): Promise<string> {\n\t\treturn this.channel.call('getTitle', [windowId]);\n\t}\n\n\tisActiveElement(windowId: number, selector: string): Promise<boolean> {\n\t\treturn this.channel.call('isActiveElement', [windowId, selector]);\n\t}\n\n\tgetElements(windowId: number, selector: string, recursive: boolean): Promise<IElement[]> {\n\t\treturn this.channel.call('getElements', [windowId, selector, recursive]);\n\t}\n\n\ttypeInEditor(windowId: number, selector: string, text: string): Promise<void> {\n\t\treturn this.channel.call('typeInEditor', [windowId, selector, text]);\n\t}\n\n\tgetTerminalBuffer(windowId: number, selector: string): Promise<string[]> {\n\t\treturn this.channel.call('getTerminalBuffer', [windowId, selector]);\n\t}\n\n\twriteInTerminal(windowId: number, selector: string, text: string): Promise<void> {\n\t\treturn this.channel.call('writeInTerminal', [windowId, selector, text]);\n\t}\n}\n\nexport interface IDriverOptions {\n\tverbose: boolean;\n}\n\nexport interface IWindowDriverRegistry {\n\tregisterWindowDriver(windowId: number): Promise<IDriverOptions>;\n\treloadWindowDriver(windowId: number): Promise<void>;\n}\n\nexport class WindowDriverRegistryChannel implements IServerChannel {\n\n\tconstructor(private registry: IWindowDriverRegistry) { }\n\n\tlisten<T>(_: unknown, event: string): Event<T> {\n\t\tthrow new Error(`Event not found: ${event}`);\n\t}\n\n\tcall(_: unknown, command: string, arg?: any): Promise<any> {\n\t\tswitch (command) {\n\t\t\tcase 'registerWindowDriver': return this.registry.registerWindowDriver(arg);\n\t\t\tcase 'reloadWindowDriver': return this.registry.reloadWindowDriver(arg);\n\t\t}\n\n\t\tthrow new Error(`Call not found: ${command}`);\n\t}\n}\n\nexport class WindowDriverRegistryChannelClient implements IWindowDriverRegistry {\n\n\t_serviceBrand: any;\n\n\tconstructor(private channel: IChannel) { }\n\n\tregisterWindowDriver(windowId: number): Promise<IDriverOptions> {\n\t\treturn this.channel.call('registerWindowDriver', windowId);\n\t}\n\n\treloadWindowDriver(windowId: number): Promise<void> {\n\t\treturn this.channel.call('reloadWindowDriver', windowId);\n\t}\n}\n\nexport interface IWindowDriver {\n\tclick(selector: string, xoffset?: number | undefined, yoffset?: number | undefined): Promise<void>;\n\tdoubleClick(selector: string): Promise<void>;\n\tsetValue(selector: string, text: string): Promise<void>;\n\tgetTitle(): Promise<string>;\n\tisActiveElement(selector: string): Promise<boolean>;\n\tgetElements(selector: string, recursive: boolean): Promise<IElement[]>;\n\ttypeInEditor(selector: string, text: string): Promise<void>;\n\tgetTerminalBuffer(selector: string): Promise<string[]>;\n\twriteInTerminal(selector: string, text: string): Promise<void>;\n}\n\nexport class WindowDriverChannel implements IServerChannel {\n\n\tconstructor(private driver: IWindowDriver) { }\n\n\tlisten<T>(_: unknown, event: string): Event<T> {\n\t\tthrow new Error(`No event found: ${event}`);\n\t}\n\n\tcall(_: unknown, command: string, arg?: any): Promise<any> {\n\t\tswitch (command) {\n\t\t\tcase 'click': return this.driver.click(arg[0], arg[1], arg[2]);\n\t\t\tcase 'doubleClick': return this.driver.doubleClick(arg);\n\t\t\tcase 'setValue': return this.driver.setValue(arg[0], arg[1]);\n\t\t\tcase 'getTitle': return this.driver.getTitle();\n\t\t\tcase 'isActiveElement': return this.driver.isActiveElement(arg);\n\t\t\tcase 'getElements': return this.driver.getElements(arg[0], arg[1]);\n\t\t\tcase 'typeInEditor': return this.driver.typeInEditor(arg[0], arg[1]);\n\t\t\tcase 'getTerminalBuffer': return this.driver.getTerminalBuffer(arg);\n\t\t\tcase 'writeInTerminal': return this.driver.writeInTerminal(arg[0], arg[1]);\n\t\t}\n\n\t\tthrow new Error(`Call not found: ${command}`);\n\t}\n}\n\nexport class WindowDriverChannelClient implements IWindowDriver {\n\n\t_serviceBrand: any;\n\n\tconstructor(private channel: IChannel) { }\n\n\tclick(selector: string, xoffset?: number, yoffset?: number): Promise<void> {\n\t\treturn this.channel.call('click', [selector, xoffset, yoffset]);\n\t}\n\n\tdoubleClick(selector: string): Promise<void> {\n\t\treturn this.channel.call('doubleClick', selector);\n\t}\n\n\tsetValue(selector: string, text: string): Promise<void> {\n\t\treturn this.channel.call('setValue', [selector, text]);\n\t}\n\n\tgetTitle(): Promise<string> {\n\t\treturn this.channel.call('getTitle');\n\t}\n\n\tisActiveElement(selector: string): Promise<boolean> {\n\t\treturn this.channel.call('isActiveElement', selector);\n\t}\n\n\tgetElements(selector: string, recursive: boolean): Promise<IElement[]> {\n\t\treturn this.channel.call('getElements', [selector, recursive]);\n\t}\n\n\ttypeInEditor(selector: string, text: string): Promise<void> {\n\t\treturn this.channel.call('typeInEditor', [selector, text]);\n\t}\n\n\tgetTerminalBuffer(selector: string): Promise<string[]> {\n\t\treturn this.channel.call('getTerminalBuffer', selector);\n\t}\n\n\twriteInTerminal(selector: string, text: string): Promise<void> {\n\t\treturn this.channel.call('writeInTerminal', [selector, text]);\n\t}\n}\n\nexport async function connect(handle: string): Promise<{ client: Client, driver: IDriver }> {\n\tconst client = await connectNet(handle, 'driverClient');\n\tconst channel = client.getChannel('driver');\n\tconst driver = new DriverChannelClient(channel);\n\treturn { client, driver };\n}\n"]}]}