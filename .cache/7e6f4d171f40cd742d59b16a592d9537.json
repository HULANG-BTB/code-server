{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/node/extensionPoints.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/node/extensionPoints.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/path\", \"semver\", \"vs/base/common/json\", \"vs/base/common/arrays\", \"vs/base/common/jsonErrorMessages\", \"vs/base/common/types\", \"vs/base/common/uri\", \"vs/base/node/pfs\", \"vs/platform/extensionManagement/common/extensionManagementUtil\", \"vs/platform/extensions/node/extensionValidator\", \"vs/platform/extensions/common/extensions\"], function (require, exports, nls, path, semver, json, arrays, jsonErrorMessages_1, types, uri_1, pfs, extensionManagementUtil_1, extensionValidator_1, extensions_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const MANIFEST_FILE = 'package.json';\n    var Translations;\n    (function (Translations) {\n        function equals(a, b) {\n            if (a === b) {\n                return true;\n            }\n            let aKeys = Object.keys(a);\n            let bKeys = new Set();\n            for (let key of Object.keys(b)) {\n                bKeys.add(key);\n            }\n            if (aKeys.length !== bKeys.size) {\n                return false;\n            }\n            for (let key of aKeys) {\n                if (a[key] !== b[key]) {\n                    return false;\n                }\n                bKeys.delete(key);\n            }\n            return bKeys.size === 0;\n        }\n        Translations.equals = equals;\n    })(Translations || (Translations = {}));\n    class ExtensionManifestHandler {\n        constructor(ourVersion, log, absoluteFolderPath, isBuiltin, isUnderDevelopment) {\n            this._ourVersion = ourVersion;\n            this._log = log;\n            this._absoluteFolderPath = absoluteFolderPath;\n            this._isBuiltin = isBuiltin;\n            this._isUnderDevelopment = isUnderDevelopment;\n            this._absoluteManifestPath = path.join(absoluteFolderPath, MANIFEST_FILE);\n        }\n    }\n    class ExtensionManifestParser extends ExtensionManifestHandler {\n        parse() {\n            return pfs.readFile(this._absoluteManifestPath).then((manifestContents) => {\n                try {\n                    const manifest = JSON.parse(manifestContents.toString());\n                    if (manifest.__metadata) {\n                        manifest.uuid = manifest.__metadata.id;\n                    }\n                    delete manifest.__metadata;\n                    return manifest;\n                }\n                catch (e) {\n                    this._log.error(this._absoluteFolderPath, nls.localize('jsonParseFail', \"Failed to parse {0}: {1}.\", this._absoluteManifestPath, jsonErrorMessages_1.getParseErrorMessage(e.message)));\n                }\n                return null;\n            }, (err) => {\n                if (err.code === 'ENOENT') {\n                    return null;\n                }\n                this._log.error(this._absoluteFolderPath, nls.localize('fileReadFail', \"Cannot read file {0}: {1}.\", this._absoluteManifestPath, err.message));\n                return null;\n            });\n        }\n    }\n    class ExtensionManifestNLSReplacer extends ExtensionManifestHandler {\n        constructor(ourVersion, log, absoluteFolderPath, isBuiltin, isUnderDevelopment, nlsConfig) {\n            super(ourVersion, log, absoluteFolderPath, isBuiltin, isUnderDevelopment);\n            this._nlsConfig = nlsConfig;\n        }\n        replaceNLS(extensionDescription) {\n            const reportErrors = (localized, errors) => {\n                errors.forEach((error) => {\n                    this._log.error(this._absoluteFolderPath, nls.localize('jsonsParseReportErrors', \"Failed to parse {0}: {1}.\", localized, jsonErrorMessages_1.getParseErrorMessage(error.error)));\n                });\n            };\n            let extension = path.extname(this._absoluteManifestPath);\n            let basename = this._absoluteManifestPath.substr(0, this._absoluteManifestPath.length - extension.length);\n            const translationId = `${extensionDescription.publisher}.${extensionDescription.name}`;\n            let translationPath = this._nlsConfig.translations[translationId];\n            let localizedMessages;\n            if (translationPath) {\n                localizedMessages = pfs.readFile(translationPath, 'utf8').then((content) => {\n                    let errors = [];\n                    let translationBundle = json.parse(content, errors);\n                    if (errors.length > 0) {\n                        reportErrors(translationPath, errors);\n                        return { values: undefined, default: `${basename}.nls.json` };\n                    }\n                    else {\n                        let values = translationBundle.contents ? translationBundle.contents.package : undefined;\n                        return { values: values, default: `${basename}.nls.json` };\n                    }\n                }, (error) => {\n                    return { values: undefined, default: `${basename}.nls.json` };\n                });\n            }\n            else {\n                localizedMessages = pfs.fileExists(basename + '.nls' + extension).then(exists => {\n                    if (!exists) {\n                        return undefined;\n                    }\n                    return ExtensionManifestNLSReplacer.findMessageBundles(this._nlsConfig, basename).then((messageBundle) => {\n                        if (!messageBundle.localized) {\n                            return { values: undefined, default: messageBundle.original };\n                        }\n                        return pfs.readFile(messageBundle.localized, 'utf8').then(messageBundleContent => {\n                            let errors = [];\n                            let messages = json.parse(messageBundleContent, errors);\n                            if (errors.length > 0) {\n                                reportErrors(messageBundle.localized, errors);\n                                return { values: undefined, default: messageBundle.original };\n                            }\n                            return { values: messages, default: messageBundle.original };\n                        }, (err) => {\n                            return { values: undefined, default: messageBundle.original };\n                        });\n                    }, (err) => {\n                        return undefined;\n                    });\n                });\n            }\n            return localizedMessages.then((localizedMessages) => {\n                if (localizedMessages === undefined) {\n                    return extensionDescription;\n                }\n                let errors = [];\n                // resolveOriginalMessageBundle returns null if localizedMessages.default === undefined;\n                return ExtensionManifestNLSReplacer.resolveOriginalMessageBundle(localizedMessages.default, errors).then((defaults) => {\n                    if (errors.length > 0) {\n                        reportErrors(localizedMessages.default, errors);\n                        return extensionDescription;\n                    }\n                    const localized = localizedMessages.values || Object.create(null);\n                    ExtensionManifestNLSReplacer._replaceNLStrings(this._nlsConfig, extensionDescription, localized, defaults, this._log, this._absoluteFolderPath);\n                    return extensionDescription;\n                });\n            }, (err) => {\n                return extensionDescription;\n            });\n        }\n        /**\n         * Parses original message bundle, returns null if the original message bundle is null.\n         */\n        static resolveOriginalMessageBundle(originalMessageBundle, errors) {\n            return new Promise((c, e) => {\n                if (originalMessageBundle) {\n                    pfs.readFile(originalMessageBundle).then(originalBundleContent => {\n                        c(json.parse(originalBundleContent.toString(), errors));\n                    }, (err) => {\n                        c(null);\n                    });\n                }\n                else {\n                    c(null);\n                }\n            });\n        }\n        /**\n         * Finds localized message bundle and the original (unlocalized) one.\n         * If the localized file is not present, returns null for the original and marks original as localized.\n         */\n        static findMessageBundles(nlsConfig, basename) {\n            return new Promise((c, e) => {\n                function loop(basename, locale) {\n                    let toCheck = `${basename}.nls.${locale}.json`;\n                    pfs.fileExists(toCheck).then(exists => {\n                        if (exists) {\n                            c({ localized: toCheck, original: `${basename}.nls.json` });\n                        }\n                        let index = locale.lastIndexOf('-');\n                        if (index === -1) {\n                            c({ localized: `${basename}.nls.json`, original: null });\n                        }\n                        else {\n                            locale = locale.substring(0, index);\n                            loop(basename, locale);\n                        }\n                    });\n                }\n                if (nlsConfig.devMode || nlsConfig.pseudo || !nlsConfig.locale) {\n                    return c({ localized: basename + '.nls.json', original: null });\n                }\n                loop(basename, nlsConfig.locale);\n            });\n        }\n        /**\n         * This routine makes the following assumptions:\n         * The root element is an object literal\n         */\n        static _replaceNLStrings(nlsConfig, literal, messages, originalMessages, log, messageScope) {\n            function processEntry(obj, key, command) {\n                let value = obj[key];\n                if (types.isString(value)) {\n                    let str = value;\n                    let length = str.length;\n                    if (length > 1 && str[0] === '%' && str[length - 1] === '%') {\n                        let messageKey = str.substr(1, length - 2);\n                        let message = messages[messageKey];\n                        // If the messages come from a language pack they might miss some keys\n                        // Fill them from the original messages.\n                        if (message === undefined && originalMessages) {\n                            message = originalMessages[messageKey];\n                        }\n                        if (message) {\n                            if (nlsConfig.pseudo) {\n                                // FF3B and FF3D is the Unicode zenkaku representation for [ and ]\n                                message = '\\uFF3B' + message.replace(/[aouei]/g, '$&$&') + '\\uFF3D';\n                            }\n                            obj[key] = command && (key === 'title' || key === 'category') && originalMessages ? { value: message, original: originalMessages[messageKey] } : message;\n                        }\n                        else {\n                            log.warn(messageScope, nls.localize('missingNLSKey', \"Couldn't find message for key {0}.\", messageKey));\n                        }\n                    }\n                }\n                else if (types.isObject(value)) {\n                    for (let k in value) {\n                        if (value.hasOwnProperty(k)) {\n                            k === 'commands' ? processEntry(value, k, true) : processEntry(value, k, command);\n                        }\n                    }\n                }\n                else if (types.isArray(value)) {\n                    for (let i = 0; i < value.length; i++) {\n                        processEntry(value, i, command);\n                    }\n                }\n            }\n            for (let key in literal) {\n                if (literal.hasOwnProperty(key)) {\n                    processEntry(literal, key);\n                }\n            }\n        }\n    }\n    class ExtensionManifestValidator extends ExtensionManifestHandler {\n        validate(_extensionDescription) {\n            let extensionDescription = _extensionDescription;\n            extensionDescription.isBuiltin = this._isBuiltin;\n            extensionDescription.isUnderDevelopment = this._isUnderDevelopment;\n            let notices = [];\n            if (!ExtensionManifestValidator.isValidExtensionDescription(this._ourVersion, this._absoluteFolderPath, extensionDescription, notices)) {\n                notices.forEach((error) => {\n                    this._log.error(this._absoluteFolderPath, error);\n                });\n                return null;\n            }\n            // in this case the notices are warnings\n            notices.forEach((error) => {\n                this._log.warn(this._absoluteFolderPath, error);\n            });\n            // allow publisher to be undefined to make the initial extension authoring experience smoother\n            if (!extensionDescription.publisher) {\n                extensionDescription.publisher = 'undefined_publisher';\n            }\n            // id := `publisher.name`\n            extensionDescription.id = `${extensionDescription.publisher}.${extensionDescription.name}`;\n            extensionDescription.identifier = new extensions_1.ExtensionIdentifier(extensionDescription.id);\n            // main := absolutePath(`main`)\n            if (extensionDescription.main) {\n                extensionDescription.main = path.join(this._absoluteFolderPath, extensionDescription.main);\n            }\n            extensionDescription.extensionLocation = uri_1.URI.file(this._absoluteFolderPath);\n            return extensionDescription;\n        }\n        static isValidExtensionDescription(version, extensionFolderPath, extensionDescription, notices) {\n            if (!ExtensionManifestValidator.baseIsValidExtensionDescription(extensionFolderPath, extensionDescription, notices)) {\n                return false;\n            }\n            if (!semver.valid(extensionDescription.version)) {\n                notices.push(nls.localize('notSemver', \"Extension version is not semver compatible.\"));\n                return false;\n            }\n            return extensionValidator_1.isValidExtensionVersion(version, extensionDescription, notices);\n        }\n        static baseIsValidExtensionDescription(extensionFolderPath, extensionDescription, notices) {\n            if (!extensionDescription) {\n                notices.push(nls.localize('extensionDescription.empty', \"Got empty extension description\"));\n                return false;\n            }\n            if (typeof extensionDescription.publisher !== 'undefined' && typeof extensionDescription.publisher !== 'string') {\n                notices.push(nls.localize('extensionDescription.publisher', \"property publisher must be of type `string`.\"));\n                return false;\n            }\n            if (typeof extensionDescription.name !== 'string') {\n                notices.push(nls.localize('extensionDescription.name', \"property `{0}` is mandatory and must be of type `string`\", 'name'));\n                return false;\n            }\n            if (typeof extensionDescription.version !== 'string') {\n                notices.push(nls.localize('extensionDescription.version', \"property `{0}` is mandatory and must be of type `string`\", 'version'));\n                return false;\n            }\n            if (!extensionDescription.engines) {\n                notices.push(nls.localize('extensionDescription.engines', \"property `{0}` is mandatory and must be of type `object`\", 'engines'));\n                return false;\n            }\n            if (typeof extensionDescription.engines.vscode !== 'string') {\n                notices.push(nls.localize('extensionDescription.engines.vscode', \"property `{0}` is mandatory and must be of type `string`\", 'engines.vscode'));\n                return false;\n            }\n            if (typeof extensionDescription.extensionDependencies !== 'undefined') {\n                if (!ExtensionManifestValidator._isStringArray(extensionDescription.extensionDependencies)) {\n                    notices.push(nls.localize('extensionDescription.extensionDependencies', \"property `{0}` can be omitted or must be of type `string[]`\", 'extensionDependencies'));\n                    return false;\n                }\n            }\n            if (typeof extensionDescription.activationEvents !== 'undefined') {\n                if (!ExtensionManifestValidator._isStringArray(extensionDescription.activationEvents)) {\n                    notices.push(nls.localize('extensionDescription.activationEvents1', \"property `{0}` can be omitted or must be of type `string[]`\", 'activationEvents'));\n                    return false;\n                }\n                if (typeof extensionDescription.main === 'undefined') {\n                    notices.push(nls.localize('extensionDescription.activationEvents2', \"properties `{0}` and `{1}` must both be specified or must both be omitted\", 'activationEvents', 'main'));\n                    return false;\n                }\n            }\n            if (typeof extensionDescription.main !== 'undefined') {\n                if (typeof extensionDescription.main !== 'string') {\n                    notices.push(nls.localize('extensionDescription.main1', \"property `{0}` can be omitted or must be of type `string`\", 'main'));\n                    return false;\n                }\n                else {\n                    let normalizedAbsolutePath = path.join(extensionFolderPath, extensionDescription.main);\n                    if (normalizedAbsolutePath.indexOf(extensionFolderPath)) {\n                        notices.push(nls.localize('extensionDescription.main2', \"Expected `main` ({0}) to be included inside extension's folder ({1}). This might make the extension non-portable.\", normalizedAbsolutePath, extensionFolderPath));\n                        // not a failure case\n                    }\n                }\n                if (typeof extensionDescription.activationEvents === 'undefined') {\n                    notices.push(nls.localize('extensionDescription.main3', \"properties `{0}` and `{1}` must both be specified or must both be omitted\", 'activationEvents', 'main'));\n                    return false;\n                }\n            }\n            return true;\n        }\n        static _isStringArray(arr) {\n            if (!Array.isArray(arr)) {\n                return false;\n            }\n            for (let i = 0, len = arr.length; i < len; i++) {\n                if (typeof arr[i] !== 'string') {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    class ExtensionScannerInput {\n        constructor(ourVersion, commit, locale, devMode, absoluteFolderPath, isBuiltin, isUnderDevelopment, tanslations) {\n            this.ourVersion = ourVersion;\n            this.commit = commit;\n            this.locale = locale;\n            this.devMode = devMode;\n            this.absoluteFolderPath = absoluteFolderPath;\n            this.isBuiltin = isBuiltin;\n            this.isUnderDevelopment = isUnderDevelopment;\n            this.tanslations = tanslations;\n            // Keep empty!! (JSON.parse)\n        }\n        static createNLSConfig(input) {\n            return {\n                devMode: input.devMode,\n                locale: input.locale,\n                pseudo: input.locale === 'pseudo',\n                translations: input.tanslations\n            };\n        }\n        static equals(a, b) {\n            return (a.ourVersion === b.ourVersion\n                && a.commit === b.commit\n                && a.locale === b.locale\n                && a.devMode === b.devMode\n                && a.absoluteFolderPath === b.absoluteFolderPath\n                && a.isBuiltin === b.isBuiltin\n                && a.isUnderDevelopment === b.isUnderDevelopment\n                && a.mtime === b.mtime\n                && Translations.equals(a.tanslations, b.tanslations));\n        }\n    }\n    exports.ExtensionScannerInput = ExtensionScannerInput;\n    class DefaultExtensionResolver {\n        constructor(root) {\n            this.root = root;\n        }\n        resolveExtensions() {\n            return pfs.readDirsInDir(this.root)\n                .then(folders => folders.map(name => ({ name, path: path.join(this.root, name) })));\n        }\n    }\n    class ExtensionScanner {\n        /**\n         * Read the extension defined in `absoluteFolderPath`\n         */\n        static scanExtension(version, log, absoluteFolderPath, isBuiltin, isUnderDevelopment, nlsConfig) {\n            absoluteFolderPath = path.normalize(absoluteFolderPath);\n            let parser = new ExtensionManifestParser(version, log, absoluteFolderPath, isBuiltin, isUnderDevelopment);\n            return parser.parse().then((extensionDescription) => {\n                if (extensionDescription === null) {\n                    return null;\n                }\n                let nlsReplacer = new ExtensionManifestNLSReplacer(version, log, absoluteFolderPath, isBuiltin, isUnderDevelopment, nlsConfig);\n                return nlsReplacer.replaceNLS(extensionDescription);\n            }).then((extensionDescription) => {\n                if (extensionDescription === null) {\n                    return null;\n                }\n                let validator = new ExtensionManifestValidator(version, log, absoluteFolderPath, isBuiltin, isUnderDevelopment);\n                return validator.validate(extensionDescription);\n            });\n        }\n        /**\n         * Scan a list of extensions defined in `absoluteFolderPath`\n         */\n        static scanExtensions(input, log, resolver = null) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const absoluteFolderPath = input.absoluteFolderPath;\n                const isBuiltin = input.isBuiltin;\n                const isUnderDevelopment = input.isUnderDevelopment;\n                if (!resolver) {\n                    resolver = new DefaultExtensionResolver(absoluteFolderPath);\n                }\n                try {\n                    let obsolete = {};\n                    if (!isBuiltin) {\n                        try {\n                            const obsoleteFileContents = yield pfs.readFile(path.join(absoluteFolderPath, '.obsolete'), 'utf8');\n                            obsolete = JSON.parse(obsoleteFileContents);\n                        }\n                        catch (err) {\n                            // Don't care\n                        }\n                    }\n                    let refs = yield resolver.resolveExtensions();\n                    // Ensure the same extension order\n                    refs.sort((a, b) => a.name < b.name ? -1 : 1);\n                    if (!isBuiltin) {\n                        refs = refs.filter(ref => ref.name.indexOf('.') !== 0); // Do not consider user extension folder starting with `.`\n                    }\n                    const nlsConfig = ExtensionScannerInput.createNLSConfig(input);\n                    let _extensionDescriptions = yield Promise.all(refs.map(r => this.scanExtension(input.ourVersion, log, r.path, isBuiltin, isUnderDevelopment, nlsConfig)));\n                    let extensionDescriptions = arrays.coalesce(_extensionDescriptions);\n                    extensionDescriptions = extensionDescriptions.filter(item => item !== null && !obsolete[new extensions_1.ExtensionIdentifierWithVersion({ id: extensionManagementUtil_1.getGalleryExtensionId(item.publisher, item.name) }, item.version).key()]);\n                    if (!isBuiltin) {\n                        // Filter out outdated extensions\n                        const byExtension = extensionManagementUtil_1.groupByExtension(extensionDescriptions, e => ({ id: e.identifier.value, uuid: e.uuid }));\n                        extensionDescriptions = byExtension.map(p => p.sort((a, b) => semver.rcompare(a.version, b.version))[0]);\n                    }\n                    extensionDescriptions.sort((a, b) => {\n                        if (a.extensionLocation.fsPath < b.extensionLocation.fsPath) {\n                            return -1;\n                        }\n                        return 1;\n                    });\n                    return extensionDescriptions;\n                }\n                catch (err) {\n                    log.error(absoluteFolderPath, err);\n                    return [];\n                }\n            });\n        }\n        /**\n         * Combination of scanExtension and scanExtensions: If an extension manifest is found at root, we load just this extension,\n         * otherwise we assume the folder contains multiple extensions.\n         */\n        static scanOneOrMultipleExtensions(input, log) {\n            const absoluteFolderPath = input.absoluteFolderPath;\n            const isBuiltin = input.isBuiltin;\n            const isUnderDevelopment = input.isUnderDevelopment;\n            return pfs.fileExists(path.join(absoluteFolderPath, MANIFEST_FILE)).then((exists) => {\n                if (exists) {\n                    const nlsConfig = ExtensionScannerInput.createNLSConfig(input);\n                    return this.scanExtension(input.ourVersion, log, absoluteFolderPath, isBuiltin, isUnderDevelopment, nlsConfig).then((extensionDescription) => {\n                        if (extensionDescription === null) {\n                            return [];\n                        }\n                        return [extensionDescription];\n                    });\n                }\n                return this.scanExtensions(input, log);\n            }, (err) => {\n                log.error(absoluteFolderPath, err);\n                return [];\n            });\n        }\n        static scanSingleExtension(input, log) {\n            const absoluteFolderPath = input.absoluteFolderPath;\n            const isBuiltin = input.isBuiltin;\n            const isUnderDevelopment = input.isUnderDevelopment;\n            const nlsConfig = ExtensionScannerInput.createNLSConfig(input);\n            return this.scanExtension(input.ourVersion, log, absoluteFolderPath, isBuiltin, isUnderDevelopment, nlsConfig);\n        }\n        static mergeBuiltinExtensions(builtinExtensions, extraBuiltinExtensions) {\n            return Promise.all([builtinExtensions, extraBuiltinExtensions]).then(([builtinExtensions, extraBuiltinExtensions]) => {\n                let resultMap = Object.create(null);\n                for (let i = 0, len = builtinExtensions.length; i < len; i++) {\n                    resultMap[extensions_1.ExtensionIdentifier.toKey(builtinExtensions[i].identifier)] = builtinExtensions[i];\n                }\n                // Overwrite with extensions found in extra\n                for (let i = 0, len = extraBuiltinExtensions.length; i < len; i++) {\n                    resultMap[extensions_1.ExtensionIdentifier.toKey(extraBuiltinExtensions[i].identifier)] = extraBuiltinExtensions[i];\n                }\n                let resultArr = Object.keys(resultMap).map((id) => resultMap[id]);\n                resultArr.sort((a, b) => {\n                    const aLastSegment = path.basename(a.extensionLocation.fsPath);\n                    const bLastSegment = path.basename(b.extensionLocation.fsPath);\n                    if (aLastSegment < bLastSegment) {\n                        return -1;\n                    }\n                    if (aLastSegment > bLastSegment) {\n                        return 1;\n                    }\n                    return 0;\n                });\n                return resultArr;\n            });\n        }\n    }\n    exports.ExtensionScanner = ExtensionScanner;\n});\n",null]}