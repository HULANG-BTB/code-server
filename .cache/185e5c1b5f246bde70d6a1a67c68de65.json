{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/format/format.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/format/format.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/browser/ui/aria/aria\", \"vs/base/common/arrays\", \"vs/base/common/cancellation\", \"vs/base/common/errors\", \"vs/base/common/uri\", \"vs/editor/browser/core/editorState\", \"vs/editor/browser/editorBrowser\", \"vs/editor/browser/editorExtensions\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\", \"vs/editor/common/core/selection\", \"vs/editor/common/editorCommon\", \"vs/editor/common/modes\", \"vs/editor/common/services/editorWorkerService\", \"vs/editor/common/services/modelService\", \"vs/editor/contrib/format/formattingEdit\", \"vs/nls\", \"vs/platform/extensions/common/extensions\", \"vs/platform/instantiation/common/instantiation\", \"vs/base/common/linkedList\"], function (require, exports, aria_1, arrays_1, cancellation_1, errors_1, uri_1, editorState_1, editorBrowser_1, editorExtensions_1, position_1, range_1, selection_1, editorCommon, modes_1, editorWorkerService_1, modelService_1, formattingEdit_1, nls, extensions_1, instantiation_1, linkedList_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function alertFormattingEdits(edits) {\n        edits = edits.filter(edit => edit.range);\n        if (!edits.length) {\n            return;\n        }\n        let { range } = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            range = range_1.Range.plusRange(range, edits[i].range);\n        }\n        const { startLineNumber, endLineNumber } = range;\n        if (startLineNumber === endLineNumber) {\n            if (edits.length === 1) {\n                aria_1.alert(nls.localize('hint11', \"Made 1 formatting edit on line {0}\", startLineNumber));\n            }\n            else {\n                aria_1.alert(nls.localize('hintn1', \"Made {0} formatting edits on line {1}\", edits.length, startLineNumber));\n            }\n        }\n        else {\n            if (edits.length === 1) {\n                aria_1.alert(nls.localize('hint1n', \"Made 1 formatting edit between lines {0} and {1}\", startLineNumber, endLineNumber));\n            }\n            else {\n                aria_1.alert(nls.localize('hintnn', \"Made {0} formatting edits between lines {1} and {2}\", edits.length, startLineNumber, endLineNumber));\n            }\n        }\n    }\n    exports.alertFormattingEdits = alertFormattingEdits;\n    function getRealAndSyntheticDocumentFormattersOrdered(model) {\n        const result = [];\n        const seen = new Set();\n        // (1) add all document formatter\n        const docFormatter = modes_1.DocumentFormattingEditProviderRegistry.ordered(model);\n        for (const formatter of docFormatter) {\n            result.push(formatter);\n            if (formatter.extensionId) {\n                seen.add(extensions_1.ExtensionIdentifier.toKey(formatter.extensionId));\n            }\n        }\n        // (2) add all range formatter as document formatter (unless the same extension already did that)\n        const rangeFormatter = modes_1.DocumentRangeFormattingEditProviderRegistry.ordered(model);\n        for (const formatter of rangeFormatter) {\n            if (formatter.extensionId) {\n                if (seen.has(extensions_1.ExtensionIdentifier.toKey(formatter.extensionId))) {\n                    continue;\n                }\n                seen.add(extensions_1.ExtensionIdentifier.toKey(formatter.extensionId));\n            }\n            result.push({\n                displayName: formatter.displayName,\n                extensionId: formatter.extensionId,\n                provideDocumentFormattingEdits(model, options, token) {\n                    return formatter.provideDocumentRangeFormattingEdits(model, model.getFullModelRange(), options, token);\n                }\n            });\n        }\n        return result;\n    }\n    exports.getRealAndSyntheticDocumentFormattersOrdered = getRealAndSyntheticDocumentFormattersOrdered;\n    var FormattingMode;\n    (function (FormattingMode) {\n        FormattingMode[FormattingMode[\"Explicit\"] = 1] = \"Explicit\";\n        FormattingMode[FormattingMode[\"Silent\"] = 2] = \"Silent\";\n    })(FormattingMode = exports.FormattingMode || (exports.FormattingMode = {}));\n    class FormattingConflicts {\n        static setFormatterSelector(selector) {\n            const remove = FormattingConflicts._selectors.unshift(selector);\n            return { dispose: remove };\n        }\n        static select(formatter, document, mode) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (formatter.length === 0) {\n                    return undefined;\n                }\n                const { value: selector } = FormattingConflicts._selectors.iterator().next();\n                if (selector) {\n                    return yield selector(formatter, document, mode);\n                }\n                return formatter[0];\n            });\n        }\n    }\n    FormattingConflicts._selectors = new linkedList_1.LinkedList();\n    exports.FormattingConflicts = FormattingConflicts;\n    function formatDocumentRangeWithSelectedProvider(accessor, editorOrModel, range, mode, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const instaService = accessor.get(instantiation_1.IInstantiationService);\n            const model = editorBrowser_1.isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n            const provider = modes_1.DocumentRangeFormattingEditProviderRegistry.ordered(model);\n            const selected = yield FormattingConflicts.select(provider, model, mode);\n            if (selected) {\n                yield instaService.invokeFunction(formatDocumentRangeWithProvider, selected, editorOrModel, range, token);\n            }\n        });\n    }\n    exports.formatDocumentRangeWithSelectedProvider = formatDocumentRangeWithSelectedProvider;\n    function formatDocumentRangeWithProvider(accessor, provider, editorOrModel, range, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const workerService = accessor.get(editorWorkerService_1.IEditorWorkerService);\n            let model;\n            let validate;\n            if (editorBrowser_1.isCodeEditor(editorOrModel)) {\n                model = editorOrModel.getModel();\n                const state = new editorState_1.EditorState(editorOrModel, editorState_1.CodeEditorStateFlag.Value | editorState_1.CodeEditorStateFlag.Position);\n                validate = () => state.validate(editorOrModel);\n            }\n            else {\n                model = editorOrModel;\n                const versionNow = editorOrModel.getVersionId();\n                validate = () => versionNow === editorOrModel.getVersionId();\n            }\n            const rawEdits = yield provider.provideDocumentRangeFormattingEdits(model, range, model.getFormattingOptions(), token);\n            const edits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n            if (!validate()) {\n                return true;\n            }\n            if (!edits || edits.length === 0) {\n                return false;\n            }\n            if (editorBrowser_1.isCodeEditor(editorOrModel)) {\n                // use editor to apply edits\n                formattingEdit_1.FormattingEdit.execute(editorOrModel, edits);\n                alertFormattingEdits(edits);\n                editorOrModel.pushUndoStop();\n                editorOrModel.focus();\n                editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), editorCommon.ScrollType.Immediate);\n            }\n            else {\n                // use model to apply edits\n                const [{ range }] = edits;\n                const initialSelection = new selection_1.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                model.pushEditOperations([initialSelection], edits.map(edit => {\n                    return {\n                        text: edit.text,\n                        range: range_1.Range.lift(edit.range),\n                        forceMoveMarkers: true\n                    };\n                }), undoEdits => {\n                    for (const { range } of undoEdits) {\n                        if (range_1.Range.areIntersectingOrTouching(range, initialSelection)) {\n                            return [new selection_1.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n                        }\n                    }\n                    return null;\n                });\n            }\n            return true;\n        });\n    }\n    exports.formatDocumentRangeWithProvider = formatDocumentRangeWithProvider;\n    function formatDocumentWithSelectedProvider(accessor, editorOrModel, mode, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const instaService = accessor.get(instantiation_1.IInstantiationService);\n            const model = editorBrowser_1.isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n            const provider = getRealAndSyntheticDocumentFormattersOrdered(model);\n            const selected = yield FormattingConflicts.select(provider, model, mode);\n            if (selected) {\n                yield instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token);\n            }\n        });\n    }\n    exports.formatDocumentWithSelectedProvider = formatDocumentWithSelectedProvider;\n    function formatDocumentWithProvider(accessor, provider, editorOrModel, mode, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const workerService = accessor.get(editorWorkerService_1.IEditorWorkerService);\n            let model;\n            let validate;\n            if (editorBrowser_1.isCodeEditor(editorOrModel)) {\n                model = editorOrModel.getModel();\n                const state = new editorState_1.EditorState(editorOrModel, editorState_1.CodeEditorStateFlag.Value | editorState_1.CodeEditorStateFlag.Position);\n                validate = () => state.validate(editorOrModel);\n            }\n            else {\n                model = editorOrModel;\n                const versionNow = editorOrModel.getVersionId();\n                validate = () => versionNow === editorOrModel.getVersionId();\n            }\n            const rawEdits = yield provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), token);\n            const edits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n            if (!validate()) {\n                return true;\n            }\n            if (!edits || edits.length === 0) {\n                return false;\n            }\n            if (editorBrowser_1.isCodeEditor(editorOrModel)) {\n                // use editor to apply edits\n                formattingEdit_1.FormattingEdit.execute(editorOrModel, edits);\n                if (mode !== FormattingMode.Silent) {\n                    alertFormattingEdits(edits);\n                    editorOrModel.pushUndoStop();\n                    editorOrModel.focus();\n                    editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), editorCommon.ScrollType.Immediate);\n                }\n            }\n            else {\n                // use model to apply edits\n                const [{ range }] = edits;\n                const initialSelection = new selection_1.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                model.pushEditOperations([initialSelection], edits.map(edit => {\n                    return {\n                        text: edit.text,\n                        range: range_1.Range.lift(edit.range),\n                        forceMoveMarkers: true\n                    };\n                }), undoEdits => {\n                    for (const { range } of undoEdits) {\n                        if (range_1.Range.areIntersectingOrTouching(range, initialSelection)) {\n                            return [new selection_1.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n                        }\n                    }\n                    return null;\n                });\n            }\n            return true;\n        });\n    }\n    exports.formatDocumentWithProvider = formatDocumentWithProvider;\n    function getDocumentRangeFormattingEditsUntilResult(workerService, model, range, options, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const providers = modes_1.DocumentRangeFormattingEditProviderRegistry.ordered(model);\n            for (const provider of providers) {\n                let rawEdits = yield Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(errors_1.onUnexpectedExternalError);\n                if (arrays_1.isNonEmptyArray(rawEdits)) {\n                    return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n                }\n            }\n            return undefined;\n        });\n    }\n    exports.getDocumentRangeFormattingEditsUntilResult = getDocumentRangeFormattingEditsUntilResult;\n    function getDocumentFormattingEditsUntilResult(workerService, model, options, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const providers = getRealAndSyntheticDocumentFormattersOrdered(model);\n            for (const provider of providers) {\n                let rawEdits = yield Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(errors_1.onUnexpectedExternalError);\n                if (arrays_1.isNonEmptyArray(rawEdits)) {\n                    return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n                }\n            }\n            return undefined;\n        });\n    }\n    exports.getDocumentFormattingEditsUntilResult = getDocumentFormattingEditsUntilResult;\n    function getOnTypeFormattingEdits(workerService, model, position, ch, options) {\n        const providers = modes_1.OnTypeFormattingEditProviderRegistry.ordered(model);\n        if (providers.length === 0) {\n            return Promise.resolve(undefined);\n        }\n        if (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {\n            return Promise.resolve(undefined);\n        }\n        return Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, cancellation_1.CancellationToken.None)).catch(errors_1.onUnexpectedExternalError).then(edits => {\n            return workerService.computeMoreMinimalEdits(model.uri, edits);\n        });\n    }\n    exports.getOnTypeFormattingEdits = getOnTypeFormattingEdits;\n    editorExtensions_1.registerLanguageCommand('_executeFormatRangeProvider', function (accessor, args) {\n        const { resource, range, options } = args;\n        if (!(resource instanceof uri_1.URI) || !range_1.Range.isIRange(range)) {\n            throw errors_1.illegalArgument();\n        }\n        const model = accessor.get(modelService_1.IModelService).getModel(resource);\n        if (!model) {\n            throw errors_1.illegalArgument('resource');\n        }\n        return getDocumentRangeFormattingEditsUntilResult(accessor.get(editorWorkerService_1.IEditorWorkerService), model, range_1.Range.lift(range), options, cancellation_1.CancellationToken.None);\n    });\n    editorExtensions_1.registerLanguageCommand('_executeFormatDocumentProvider', function (accessor, args) {\n        const { resource, options } = args;\n        if (!(resource instanceof uri_1.URI)) {\n            throw errors_1.illegalArgument('resource');\n        }\n        const model = accessor.get(modelService_1.IModelService).getModel(resource);\n        if (!model) {\n            throw errors_1.illegalArgument('resource');\n        }\n        return getDocumentFormattingEditsUntilResult(accessor.get(editorWorkerService_1.IEditorWorkerService), model, options, cancellation_1.CancellationToken.None);\n    });\n    editorExtensions_1.registerLanguageCommand('_executeFormatOnTypeProvider', function (accessor, args) {\n        const { resource, position, ch, options } = args;\n        if (!(resource instanceof uri_1.URI) || !position_1.Position.isIPosition(position) || typeof ch !== 'string') {\n            throw errors_1.illegalArgument();\n        }\n        const model = accessor.get(modelService_1.IModelService).getModel(resource);\n        if (!model) {\n            throw errors_1.illegalArgument('resource');\n        }\n        return getOnTypeFormattingEdits(accessor.get(editorWorkerService_1.IEditorWorkerService), model, position_1.Position.lift(position), ch, options);\n    });\n});\n",null]}