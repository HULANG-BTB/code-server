{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/common/async.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/async.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar cancellation_1 = require(\"vs/base/common/cancellation\");\nvar errors = require(\"vs/base/common/errors\");\nvar event_1 = require(\"vs/base/common/event\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nfunction isThenable(obj) {\n    return obj && typeof obj.then === 'function';\n}\nexports.isThenable = isThenable;\nfunction createCancelablePromise(callback) {\n    var source = new cancellation_1.CancellationTokenSource();\n    var thenable = callback(source.token);\n    var promise = new Promise(function (resolve, reject) {\n        source.token.onCancellationRequested(function () {\n            reject(errors.canceled());\n        });\n        Promise.resolve(thenable).then(function (value) {\n            source.dispose();\n            resolve(value);\n        }, function (err) {\n            source.dispose();\n            reject(err);\n        });\n    });\n    return new /** @class */ (function () {\n        function class_1() {\n        }\n        class_1.prototype.cancel = function () {\n            source.cancel();\n        };\n        class_1.prototype.then = function (resolve, reject) {\n            return promise.then(resolve, reject);\n        };\n        class_1.prototype.catch = function (reject) {\n            return this.then(undefined, reject);\n        };\n        class_1.prototype.finally = function (onfinally) {\n            return promise.finally(onfinally);\n        };\n        return class_1;\n    }());\n}\nexports.createCancelablePromise = createCancelablePromise;\nfunction asPromise(callback) {\n    return new Promise(function (resolve, reject) {\n        var item = callback();\n        if (isThenable(item)) {\n            item.then(resolve, reject);\n        }\n        else {\n            resolve(item);\n        }\n    });\n}\nexports.asPromise = asPromise;\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nvar Throttler = /** @class */ (function () {\n    function Throttler() {\n        this.activePromise = null;\n        this.queuedPromise = null;\n        this.queuedPromiseFactory = null;\n    }\n    Throttler.prototype.queue = function (promiseFactory) {\n        var _this = this;\n        if (this.activePromise) {\n            this.queuedPromiseFactory = promiseFactory;\n            if (!this.queuedPromise) {\n                var onComplete_1 = function () {\n                    _this.queuedPromise = null;\n                    var result = _this.queue(_this.queuedPromiseFactory);\n                    _this.queuedPromiseFactory = null;\n                    return result;\n                };\n                this.queuedPromise = new Promise(function (c) {\n                    _this.activePromise.then(onComplete_1, onComplete_1).then(c);\n                });\n            }\n            return new Promise(function (c, e) {\n                _this.queuedPromise.then(c, e);\n            });\n        }\n        this.activePromise = promiseFactory();\n        return new Promise(function (c, e) {\n            _this.activePromise.then(function (result) {\n                _this.activePromise = null;\n                c(result);\n            }, function (err) {\n                _this.activePromise = null;\n                e(err);\n            });\n        });\n    };\n    return Throttler;\n}());\nexports.Throttler = Throttler;\nvar Sequencer = /** @class */ (function () {\n    function Sequencer() {\n        this.current = Promise.resolve(null);\n    }\n    Sequencer.prototype.queue = function (promiseTask) {\n        return this.current = this.current.then(function () { return promiseTask(); });\n    };\n    return Sequencer;\n}());\nexports.Sequencer = Sequencer;\n/**\n * A helper to delay execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nvar Delayer = /** @class */ (function () {\n    function Delayer(defaultDelay) {\n        this.defaultDelay = defaultDelay;\n        this.timeout = null;\n        this.completionPromise = null;\n        this.doResolve = null;\n        this.task = null;\n    }\n    Delayer.prototype.trigger = function (task, delay) {\n        var _this = this;\n        if (delay === void 0) { delay = this.defaultDelay; }\n        this.task = task;\n        this.cancelTimeout();\n        if (!this.completionPromise) {\n            this.completionPromise = new Promise(function (c, e) {\n                _this.doResolve = c;\n                _this.doReject = e;\n            }).then(function () {\n                _this.completionPromise = null;\n                _this.doResolve = null;\n                var task = _this.task;\n                _this.task = null;\n                return task();\n            });\n        }\n        this.timeout = setTimeout(function () {\n            _this.timeout = null;\n            _this.doResolve(null);\n        }, delay);\n        return this.completionPromise;\n    };\n    Delayer.prototype.isTriggered = function () {\n        return this.timeout !== null;\n    };\n    Delayer.prototype.cancel = function () {\n        this.cancelTimeout();\n        if (this.completionPromise) {\n            this.doReject(errors.canceled());\n            this.completionPromise = null;\n        }\n    };\n    Delayer.prototype.cancelTimeout = function () {\n        if (this.timeout !== null) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n    };\n    Delayer.prototype.dispose = function () {\n        this.cancelTimeout();\n    };\n    return Delayer;\n}());\nexports.Delayer = Delayer;\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nvar ThrottledDelayer = /** @class */ (function () {\n    function ThrottledDelayer(defaultDelay) {\n        this.delayer = new Delayer(defaultDelay);\n        this.throttler = new Throttler();\n    }\n    ThrottledDelayer.prototype.trigger = function (promiseFactory, delay) {\n        var _this = this;\n        return this.delayer.trigger(function () { return _this.throttler.queue(promiseFactory); }, delay);\n    };\n    ThrottledDelayer.prototype.isTriggered = function () {\n        return this.delayer.isTriggered();\n    };\n    ThrottledDelayer.prototype.cancel = function () {\n        this.delayer.cancel();\n    };\n    ThrottledDelayer.prototype.dispose = function () {\n        this.delayer.dispose();\n    };\n    return ThrottledDelayer;\n}());\nexports.ThrottledDelayer = ThrottledDelayer;\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nvar Barrier = /** @class */ (function () {\n    function Barrier() {\n        var _this = this;\n        this._isOpen = false;\n        this._promise = new Promise(function (c, e) {\n            _this._completePromise = c;\n        });\n    }\n    Barrier.prototype.isOpen = function () {\n        return this._isOpen;\n    };\n    Barrier.prototype.open = function () {\n        this._isOpen = true;\n        this._completePromise(true);\n    };\n    Barrier.prototype.wait = function () {\n        return this._promise;\n    };\n    return Barrier;\n}());\nexports.Barrier = Barrier;\nfunction timeout(millis, token) {\n    if (!token) {\n        return createCancelablePromise(function (token) { return timeout(millis, token); });\n    }\n    return new Promise(function (resolve, reject) {\n        var handle = setTimeout(resolve, millis);\n        token.onCancellationRequested(function () {\n            clearTimeout(handle);\n            reject(errors.canceled());\n        });\n    });\n}\nexports.timeout = timeout;\nfunction disposableTimeout(handler, timeout) {\n    if (timeout === void 0) { timeout = 0; }\n    var timer = setTimeout(handler, timeout);\n    return lifecycle_1.toDisposable(function () { return clearTimeout(timer); });\n}\nexports.disposableTimeout = disposableTimeout;\nfunction ignoreErrors(promise) {\n    return promise.then(undefined, function (_) { return undefined; });\n}\nexports.ignoreErrors = ignoreErrors;\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\nfunction sequence(promiseFactories) {\n    var results = [];\n    var index = 0;\n    var len = promiseFactories.length;\n    function next() {\n        return index < len ? promiseFactories[index++]() : null;\n    }\n    function thenHandler(result) {\n        if (result !== undefined && result !== null) {\n            results.push(result);\n        }\n        var n = next();\n        if (n) {\n            return n.then(thenHandler);\n        }\n        return Promise.resolve(results);\n    }\n    return Promise.resolve(null).then(thenHandler);\n}\nexports.sequence = sequence;\nfunction first(promiseFactories, shouldStop, defaultValue) {\n    if (shouldStop === void 0) { shouldStop = function (t) { return !!t; }; }\n    if (defaultValue === void 0) { defaultValue = null; }\n    var index = 0;\n    var len = promiseFactories.length;\n    var loop = function () {\n        if (index >= len) {\n            return Promise.resolve(defaultValue);\n        }\n        var factory = promiseFactories[index++];\n        var promise = Promise.resolve(factory());\n        return promise.then(function (result) {\n            if (shouldStop(result)) {\n                return Promise.resolve(result);\n            }\n            return loop();\n        });\n    };\n    return loop();\n}\nexports.first = first;\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nvar Limiter = /** @class */ (function () {\n    function Limiter(maxDegreeOfParalellism) {\n        this._size = 0;\n        this.maxDegreeOfParalellism = maxDegreeOfParalellism;\n        this.outstandingPromises = [];\n        this.runningPromises = 0;\n        this._onFinished = new event_1.Emitter();\n    }\n    Object.defineProperty(Limiter.prototype, \"onFinished\", {\n        get: function () {\n            return this._onFinished.event;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Limiter.prototype, \"size\", {\n        get: function () {\n            return this._size;\n            // return this.runningPromises + this.outstandingPromises.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Limiter.prototype.queue = function (factory) {\n        var _this = this;\n        this._size++;\n        return new Promise(function (c, e) {\n            _this.outstandingPromises.push({ factory: factory, c: c, e: e });\n            _this.consume();\n        });\n    };\n    Limiter.prototype.consume = function () {\n        var _this = this;\n        while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n            var iLimitedTask = this.outstandingPromises.shift();\n            this.runningPromises++;\n            var promise = iLimitedTask.factory();\n            promise.then(iLimitedTask.c, iLimitedTask.e);\n            promise.then(function () { return _this.consumed(); }, function () { return _this.consumed(); });\n        }\n    };\n    Limiter.prototype.consumed = function () {\n        this._size--;\n        this.runningPromises--;\n        if (this.outstandingPromises.length > 0) {\n            this.consume();\n        }\n        else {\n            this._onFinished.fire();\n        }\n    };\n    Limiter.prototype.dispose = function () {\n        this._onFinished.dispose();\n    };\n    return Limiter;\n}());\nexports.Limiter = Limiter;\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nvar Queue = /** @class */ (function (_super) {\n    tslib_1.__extends(Queue, _super);\n    function Queue() {\n        return _super.call(this, 1) || this;\n    }\n    return Queue;\n}(Limiter));\nexports.Queue = Queue;\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nvar ResourceQueue = /** @class */ (function () {\n    function ResourceQueue() {\n        this.queues = Object.create(null);\n    }\n    ResourceQueue.prototype.queueFor = function (resource) {\n        var _this = this;\n        var key = resource.toString();\n        if (!this.queues[key]) {\n            var queue_1 = new Queue();\n            queue_1.onFinished(function () {\n                queue_1.dispose();\n                delete _this.queues[key];\n            });\n            this.queues[key] = queue_1;\n        }\n        return this.queues[key];\n    };\n    return ResourceQueue;\n}());\nexports.ResourceQueue = ResourceQueue;\nvar TimeoutTimer = /** @class */ (function (_super) {\n    tslib_1.__extends(TimeoutTimer, _super);\n    function TimeoutTimer(runner, timeout) {\n        var _this = _super.call(this) || this;\n        _this._token = -1;\n        if (typeof runner === 'function' && typeof timeout === 'number') {\n            _this.setIfNotSet(runner, timeout);\n        }\n        return _this;\n    }\n    TimeoutTimer.prototype.dispose = function () {\n        this.cancel();\n        _super.prototype.dispose.call(this);\n    };\n    TimeoutTimer.prototype.cancel = function () {\n        if (this._token !== -1) {\n            clearTimeout(this._token);\n            this._token = -1;\n        }\n    };\n    TimeoutTimer.prototype.cancelAndSet = function (runner, timeout) {\n        var _this = this;\n        this.cancel();\n        this._token = setTimeout(function () {\n            _this._token = -1;\n            runner();\n        }, timeout);\n    };\n    TimeoutTimer.prototype.setIfNotSet = function (runner, timeout) {\n        var _this = this;\n        if (this._token !== -1) {\n            // timer is already set\n            return;\n        }\n        this._token = setTimeout(function () {\n            _this._token = -1;\n            runner();\n        }, timeout);\n    };\n    return TimeoutTimer;\n}(lifecycle_1.Disposable));\nexports.TimeoutTimer = TimeoutTimer;\nvar IntervalTimer = /** @class */ (function (_super) {\n    tslib_1.__extends(IntervalTimer, _super);\n    function IntervalTimer() {\n        var _this = _super.call(this) || this;\n        _this._token = -1;\n        return _this;\n    }\n    IntervalTimer.prototype.dispose = function () {\n        this.cancel();\n        _super.prototype.dispose.call(this);\n    };\n    IntervalTimer.prototype.cancel = function () {\n        if (this._token !== -1) {\n            clearInterval(this._token);\n            this._token = -1;\n        }\n    };\n    IntervalTimer.prototype.cancelAndSet = function (runner, interval) {\n        this.cancel();\n        this._token = setInterval(function () {\n            runner();\n        }, interval);\n    };\n    return IntervalTimer;\n}(lifecycle_1.Disposable));\nexports.IntervalTimer = IntervalTimer;\nvar RunOnceScheduler = /** @class */ (function () {\n    function RunOnceScheduler(runner, timeout) {\n        this.timeoutToken = -1;\n        this.runner = runner;\n        this.timeout = timeout;\n        this.timeoutHandler = this.onTimeout.bind(this);\n    }\n    /**\n     * Dispose RunOnceScheduler\n     */\n    RunOnceScheduler.prototype.dispose = function () {\n        this.cancel();\n        this.runner = null;\n    };\n    /**\n     * Cancel current scheduled runner (if any).\n     */\n    RunOnceScheduler.prototype.cancel = function () {\n        if (this.isScheduled()) {\n            clearTimeout(this.timeoutToken);\n            this.timeoutToken = -1;\n        }\n    };\n    /**\n     * Cancel previous runner (if any) & schedule a new runner.\n     */\n    RunOnceScheduler.prototype.schedule = function (delay) {\n        if (delay === void 0) { delay = this.timeout; }\n        this.cancel();\n        this.timeoutToken = setTimeout(this.timeoutHandler, delay);\n    };\n    /**\n     * Returns true if scheduled.\n     */\n    RunOnceScheduler.prototype.isScheduled = function () {\n        return this.timeoutToken !== -1;\n    };\n    RunOnceScheduler.prototype.onTimeout = function () {\n        this.timeoutToken = -1;\n        if (this.runner) {\n            this.doRun();\n        }\n    };\n    RunOnceScheduler.prototype.doRun = function () {\n        if (this.runner) {\n            this.runner();\n        }\n    };\n    return RunOnceScheduler;\n}());\nexports.RunOnceScheduler = RunOnceScheduler;\nvar RunOnceWorker = /** @class */ (function (_super) {\n    tslib_1.__extends(RunOnceWorker, _super);\n    function RunOnceWorker(runner, timeout) {\n        var _this = _super.call(this, runner, timeout) || this;\n        _this.units = [];\n        return _this;\n    }\n    RunOnceWorker.prototype.work = function (unit) {\n        this.units.push(unit);\n        if (!this.isScheduled()) {\n            this.schedule();\n        }\n    };\n    RunOnceWorker.prototype.doRun = function () {\n        var units = this.units;\n        this.units = [];\n        if (this.runner) {\n            this.runner(units);\n        }\n    };\n    RunOnceWorker.prototype.dispose = function () {\n        this.units = [];\n        _super.prototype.dispose.call(this);\n    };\n    return RunOnceWorker;\n}(RunOnceScheduler));\nexports.RunOnceWorker = RunOnceWorker;\nfunction nfcall(fn) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    return new Promise(function (c, e) { return fn.apply(void 0, args.concat([function (err, result) { return err ? e(err) : c(result); }])); });\n}\nexports.nfcall = nfcall;\nfunction ninvoke(thisArg, fn) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n    }\n    return new Promise(function (resolve, reject) { return fn.call.apply(fn, [thisArg].concat(args, [function (err, result) { return err ? reject(err) : resolve(result); }])); });\n}\nexports.ninvoke = ninvoke;\n(function () {\n    if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n        var dummyIdle_1 = Object.freeze({\n            didTimeout: true,\n            timeRemaining: function () { return 15; }\n        });\n        exports.runWhenIdle = function (runner) {\n            var handle = setTimeout(function () { return runner(dummyIdle_1); });\n            var disposed = false;\n            return {\n                dispose: function () {\n                    if (disposed) {\n                        return;\n                    }\n                    disposed = true;\n                    clearTimeout(handle);\n                }\n            };\n        };\n    }\n    else {\n        exports.runWhenIdle = function (runner, timeout) {\n            var handle = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout: timeout } : undefined);\n            var disposed = false;\n            return {\n                dispose: function () {\n                    if (disposed) {\n                        return;\n                    }\n                    disposed = true;\n                    cancelIdleCallback(handle);\n                }\n            };\n        };\n    }\n})();\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nvar IdleValue = /** @class */ (function () {\n    function IdleValue(executor) {\n        var _this = this;\n        this._didRun = false;\n        this._executor = function () {\n            try {\n                _this._value = executor();\n            }\n            catch (err) {\n                _this._error = err;\n            }\n            finally {\n                _this._didRun = true;\n            }\n        };\n        this._handle = exports.runWhenIdle(function () { return _this._executor(); });\n    }\n    IdleValue.prototype.dispose = function () {\n        this._handle.dispose();\n    };\n    IdleValue.prototype.getValue = function () {\n        if (!this._didRun) {\n            this._handle.dispose();\n            this._executor();\n        }\n        if (this._error) {\n            throw this._error;\n        }\n        return this._value;\n    };\n    return IdleValue;\n}());\nexports.IdleValue = IdleValue;\n//#endregion\nfunction retry(task, delay, retries) {\n    return tslib_1.__awaiter(this, void 0, Promise, function () {\n        var lastError, i, error_1;\n        return tslib_1.__generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    i = 0;\n                    _a.label = 1;\n                case 1:\n                    if (!(i < retries)) return [3 /*break*/, 7];\n                    _a.label = 2;\n                case 2:\n                    _a.trys.push([2, 4, , 6]);\n                    return [4 /*yield*/, task()];\n                case 3: return [2 /*return*/, _a.sent()];\n                case 4:\n                    error_1 = _a.sent();\n                    lastError = error_1;\n                    return [4 /*yield*/, timeout(delay)];\n                case 5:\n                    _a.sent();\n                    return [3 /*break*/, 6];\n                case 6:\n                    i++;\n                    return [3 /*break*/, 1];\n                case 7: return [2 /*return*/, Promise.reject(lastError)];\n            }\n        });\n    });\n}\nexports.retry = retry;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/common/async.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/common/async.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\n\nexport function isThenable<T>(obj: any): obj is Promise<T> {\n\treturn obj && typeof (<Promise<any>>obj).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tsource.token.onCancellationRequested(() => {\n\t\t\treject(errors.canceled());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn new class implements CancelablePromise<T> {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(c => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(c);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((c, e) => {\n\t\t\t\tthis.queuedPromise!.then(c, e);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((c, e) => {\n\t\t\tthis.activePromise!.then((result: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tc(result);\n\t\t\t}, (err: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\te(err);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<any> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask());\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate timeout: any;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject?: (err: any) => void;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number) {\n\t\tthis.timeout = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay: number = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((c, e) => {\n\t\t\t\tthis.doResolve = c;\n\t\t\t\tthis.doReject = e;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tconst task = this.task!;\n\t\t\t\tthis.task = null;\n\n\t\t\t\treturn task();\n\t\t\t});\n\t\t}\n\n\t\tthis.timeout = setTimeout(() => {\n\t\t\tthis.timeout = null;\n\t\t\tthis.doResolve!(null);\n\t\t}, delay);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.timeout !== null;\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject!(errors.canceled());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tif (this.timeout !== null) {\n\t\t\tclearTimeout(this.timeout);\n\t\t\tthis.timeout = null;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancelTimeout();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as any as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(resolve, millis);\n\t\ttoken.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\treject(errors.canceled());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\nexport function ignoreErrors<T>(promise: Promise<T>): Promise<T | undefined> {\n\treturn promise.then(undefined, _ => undefined);\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value?: T | Promise<T>) => void;\n\te: (error?: any) => void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> {\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate maxDegreeOfParalellism: number;\n\tprivate outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onFinished: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onFinished = new Emitter<void>();\n\t}\n\n\tpublic get onFinished(): Event<void> {\n\t\treturn this._onFinished.event;\n\t}\n\n\tpublic get size(): number {\n\t\treturn this._size;\n\t\t// return this.runningPromises + this.outstandingPromises.length;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onFinished.fire();\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._onFinished.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue {\n\tprivate queues: { [path: string]: Queue<void> };\n\n\tconstructor() {\n\t\tthis.queues = Object.create(null);\n\t}\n\n\tpublic queueFor(resource: URI): Queue<void> {\n\t\tconst key = resource.toString();\n\t\tif (!this.queues[key]) {\n\t\t\tconst queue = new Queue<void>();\n\t\t\tqueue.onFinished(() => {\n\t\t\t\tqueue.dispose();\n\t\t\t\tdelete this.queues[key];\n\t\t\t});\n\n\t\t\tthis.queues[key] = queue;\n\t\t}\n\n\t\treturn this.queues[key];\n\t}\n}\n\nexport class TimeoutTimer extends Disposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tsuper();\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tsuper.dispose();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer extends Disposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tsuper.dispose();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler {\n\n\tprotected runner: ((...args: any[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, timeout: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = timeout;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tif (this.runner) {\n\t\t\tthis.runner();\n\t\t}\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tif (this.runner) {\n\t\t\tthis.runner(units);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport function nfcall(fn: Function, ...args: any[]): Promise<any>;\nexport function nfcall<T>(fn: Function, ...args: any[]): Promise<T>;\nexport function nfcall(fn: Function, ...args: any[]): any {\n\treturn new Promise((c, e) => fn(...args, (err: any, result: any) => err ? e(err) : c(result)));\n}\n\nexport function ninvoke(thisArg: any, fn: Function, ...args: any[]): Promise<any>;\nexport function ninvoke<T>(thisArg: any, fn: Function, ...args: any[]): Promise<T>;\nexport function ninvoke(thisArg: any, fn: Function, ...args: any[]): any {\n\treturn new Promise((resolve, reject) => fn.call(thisArg, ...args, (err: any, result: any) => err ? reject(err) : resolve(result)));\n}\n\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): DOMHighResTimeStamp;\n}\n/**\n * Execute the callback the next time the browser is idle\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\tconst dummyIdle: IdleDeadline = Object.freeze({\n\t\t\tdidTimeout: true,\n\t\t\ttimeRemaining() { return 15; }\n\t\t});\n\t\trunWhenIdle = (runner) => {\n\t\t\tconst handle = setTimeout(() => runner(dummyIdle));\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: any;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tgetValue(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\treturn Promise.reject(lastError);\n}"]}]}