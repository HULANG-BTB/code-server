{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/node/request.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/request.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/types\", \"url\", \"fs\", \"vs/base/common/objects\", \"zlib\", \"vs/base/common/errors\"], function (require, exports, types_1, url_1, fs_1, objects_1, zlib_1, errors_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function getNodeRequest(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const endpoint = url_1.parse(options.url);\n            const module = endpoint.protocol === 'https:' ? yield new Promise((resolve_1, reject_1) => { require(['https'], resolve_1, reject_1); }) : yield new Promise((resolve_2, reject_2) => { require(['http'], resolve_2, reject_2); });\n            return module.request;\n        });\n    }\n    function request(options, token) {\n        let req;\n        const rawRequestPromise = options.getRawRequest\n            ? Promise.resolve(options.getRawRequest(options))\n            : Promise.resolve(getNodeRequest(options));\n        return rawRequestPromise.then(rawRequest => {\n            return new Promise((c, e) => {\n                const endpoint = url_1.parse(options.url);\n                const opts = {\n                    hostname: endpoint.hostname,\n                    port: endpoint.port ? parseInt(endpoint.port) : (endpoint.protocol === 'https:' ? 443 : 80),\n                    protocol: endpoint.protocol,\n                    path: endpoint.path,\n                    method: options.type || 'GET',\n                    headers: options.headers,\n                    agent: options.agent,\n                    rejectUnauthorized: types_1.isBoolean(options.strictSSL) ? options.strictSSL : true\n                };\n                if (options.user && options.password) {\n                    opts.auth = options.user + ':' + options.password;\n                }\n                req = rawRequest(opts, (res) => {\n                    const followRedirects = types_1.isNumber(options.followRedirects) ? options.followRedirects : 3;\n                    if (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && followRedirects > 0 && res.headers['location']) {\n                        request(objects_1.assign({}, options, {\n                            url: res.headers['location'],\n                            followRedirects: followRedirects - 1\n                        }), token).then(c, e);\n                    }\n                    else {\n                        let stream = res;\n                        if (res.headers['content-encoding'] === 'gzip') {\n                            stream = stream.pipe(zlib_1.createGunzip());\n                        }\n                        c({ res, stream });\n                    }\n                });\n                req.on('error', e);\n                if (options.timeout) {\n                    req.setTimeout(options.timeout);\n                }\n                if (options.data) {\n                    if (typeof options.data === 'string') {\n                        req.write(options.data);\n                    }\n                    else {\n                        options.data.pipe(req);\n                        return;\n                    }\n                }\n                req.end();\n                token.onCancellationRequested(() => {\n                    req.abort();\n                    e(errors_1.canceled());\n                });\n            });\n        });\n    }\n    exports.request = request;\n    function isSuccess(context) {\n        return (context.res.statusCode && context.res.statusCode >= 200 && context.res.statusCode < 300) || context.res.statusCode === 1223;\n    }\n    function hasNoContent(context) {\n        return context.res.statusCode === 204;\n    }\n    function download(filePath, context) {\n        return new Promise((c, e) => {\n            const out = fs_1.createWriteStream(filePath);\n            out.once('finish', () => c(undefined));\n            context.stream.once('error', e);\n            context.stream.pipe(out);\n        });\n    }\n    exports.download = download;\n    function asText(context) {\n        return new Promise((c, e) => {\n            if (!isSuccess(context)) {\n                return e('Server returned ' + context.res.statusCode);\n            }\n            if (hasNoContent(context)) {\n                return c(null);\n            }\n            const buffer = [];\n            context.stream.on('data', (d) => buffer.push(d));\n            context.stream.on('end', () => c(buffer.join('')));\n            context.stream.on('error', e);\n        });\n    }\n    exports.asText = asText;\n    function asJson(context) {\n        return new Promise((c, e) => {\n            if (!isSuccess(context)) {\n                return e('Server returned ' + context.res.statusCode);\n            }\n            if (hasNoContent(context)) {\n                return c(null);\n            }\n            const buffer = [];\n            context.stream.on('data', (d) => buffer.push(d));\n            context.stream.on('end', () => {\n                try {\n                    c(JSON.parse(buffer.join('')));\n                }\n                catch (err) {\n                    e(err);\n                }\n            });\n            context.stream.on('error', e);\n        });\n    }\n    exports.asJson = asJson;\n});\n",null]}