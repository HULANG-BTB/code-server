{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/electron-browser/extensionHost.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/electron-browser/extensionHost.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"child_process\", \"electron\", \"net\", \"vs/base/common/amd\", \"vs/base/common/async\", \"vs/base/common/errorMessage\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/base/common/objects\", \"vs/base/common/platform\", \"vs/base/common/resources\", \"vs/base/common/uri\", \"vs/base/common/console\", \"vs/base/node/ports\", \"vs/base/parts/ipc/common/ipc.net\", \"vs/base/parts/ipc/node/ipc.net\", \"vs/workbench/services/broadcast/common/broadcast\", \"vs/platform/environment/common/environment\", \"vs/platform/extensions/common/extensionHost\", \"vs/platform/label/common/label\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/platform/log/common/log\", \"vs/platform/product/node/product\", \"vs/platform/notification/common/notification\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/windows/common/windows\", \"vs/platform/workspace/common/workspace\", \"vs/workbench/services/extensions/node/extensionHostProtocol\", \"vs/base/common/types\", \"../common/extensionDevOptions\", \"vs/base/common/buffer\"], function (require, exports, nls, child_process_1, electron_1, net_1, amd_1, async_1, errorMessage_1, event_1, lifecycle_1, objects, platform_1, resources_1, uri_1, console_1, ports_1, ipc_net_1, ipc_net_2, broadcast_1, environment_1, extensionHost_1, label_1, lifecycle_2, log_1, product_1, notification_1, telemetry_1, windows_1, workspace_1, extensionHostProtocol_1, types_1, extensionDevOptions_1, buffer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let ExtensionHostProcessWorker = class ExtensionHostProcessWorker {\n        constructor(_autoStart, _extensions, _extensionHostLogsLocation, _contextService, _notificationService, _windowsService, _windowService, _broadcastService, _lifecycleService, _environmentService, _telemetryService, _logService, _labelService) {\n            this._autoStart = _autoStart;\n            this._extensions = _extensions;\n            this._extensionHostLogsLocation = _extensionHostLogsLocation;\n            this._contextService = _contextService;\n            this._notificationService = _notificationService;\n            this._windowsService = _windowsService;\n            this._windowService = _windowService;\n            this._broadcastService = _broadcastService;\n            this._lifecycleService = _lifecycleService;\n            this._environmentService = _environmentService;\n            this._telemetryService = _telemetryService;\n            this._logService = _logService;\n            this._labelService = _labelService;\n            this._onCrashed = new event_1.Emitter();\n            this.onCrashed = this._onCrashed.event;\n            const devOpts = extensionDevOptions_1.parseExtensionDevOptions(this._environmentService);\n            this._isExtensionDevHost = devOpts.isExtensionDevHost;\n            this._isExtensionDevDebug = devOpts.isExtensionDevDebug;\n            this._isExtensionDevDebugBrk = devOpts.isExtensionDevDebugBrk;\n            this._isExtensionDevTestFromCli = devOpts.isExtensionDevTestFromCli;\n            this._lastExtensionHostError = null;\n            this._terminating = false;\n            this._namedPipeServer = null;\n            this._extensionHostProcess = null;\n            this._extensionHostConnection = null;\n            this._messageProtocol = null;\n            this._toDispose = [];\n            this._toDispose.push(this._onCrashed);\n            this._toDispose.push(this._lifecycleService.onWillShutdown(e => this._onWillShutdown(e)));\n            this._toDispose.push(this._lifecycleService.onShutdown(reason => this.terminate()));\n            this._toDispose.push(this._broadcastService.onBroadcast(b => this._onBroadcast(b)));\n            const globalExitListener = () => this.terminate();\n            process.once('exit', globalExitListener);\n            this._toDispose.push(lifecycle_1.toDisposable(() => {\n                process.removeListener('exit', globalExitListener);\n            }));\n        }\n        dispose() {\n            this.terminate();\n        }\n        _onBroadcast(broadcast) {\n            // Close Ext Host Window Request\n            if (broadcast.channel === extensionHost_1.EXTENSION_CLOSE_EXTHOST_BROADCAST_CHANNEL && this._isExtensionDevHost) {\n                const extensionLocations = broadcast.payload;\n                if (Array.isArray(extensionLocations) && extensionLocations.some(uriString => resources_1.isEqual(this._environmentService.extensionDevelopmentLocationURI, uri_1.URI.parse(uriString)))) {\n                    this._windowService.closeWindow();\n                }\n            }\n            if (broadcast.channel === extensionHost_1.EXTENSION_RELOAD_BROADCAST_CHANNEL && this._isExtensionDevHost) {\n                const extensionPaths = broadcast.payload;\n                if (Array.isArray(extensionPaths) && extensionPaths.some(uriString => resources_1.isEqual(this._environmentService.extensionDevelopmentLocationURI, uri_1.URI.parse(uriString)))) {\n                    this._windowService.reloadWindow();\n                }\n            }\n        }\n        start() {\n            if (this._terminating) {\n                // .terminate() was called\n                return null;\n            }\n            if (!this._messageProtocol) {\n                this._messageProtocol = Promise.all([this._tryListenOnPipe(), this._tryFindDebugPort()]).then(data => {\n                    const pipeName = data[0];\n                    const portData = data[1];\n                    const opts = {\n                        env: objects.mixin(objects.deepClone(process.env), {\n                            AMD_ENTRYPOINT: 'vs/workbench/services/extensions/node/extensionHostProcess',\n                            PIPE_LOGGING: 'true',\n                            VERBOSE_LOGGING: true,\n                            VSCODE_IPC_HOOK_EXTHOST: pipeName,\n                            VSCODE_HANDLES_UNCAUGHT_ERRORS: true,\n                            VSCODE_LOG_STACK: !this._isExtensionDevTestFromCli && (this._isExtensionDevHost || !this._environmentService.isBuilt || product_1.default.quality !== 'stable' || this._environmentService.verbose),\n                            VSCODE_LOG_LEVEL: this._environmentService.verbose ? 'trace' : this._environmentService.log\n                        }),\n                        // We only detach the extension host on windows. Linux and Mac orphan by default\n                        // and detach under Linux and Mac create another process group.\n                        // We detach because we have noticed that when the renderer exits, its child processes\n                        // (i.e. extension host) are taken down in a brutal fashion by the OS\n                        detached: !!platform_1.isWindows,\n                        execArgv: undefined,\n                        silent: true\n                    };\n                    if (portData.actual) {\n                        opts.execArgv = [\n                            '--nolazy',\n                            (this._isExtensionDevDebugBrk ? '--inspect-brk=' : '--inspect=') + portData.actual\n                        ];\n                        if (!portData.expected) {\n                            // No one asked for 'inspect' or 'inspect-brk', only us. We add another\n                            // option such that the extension host can manipulate the execArgv array\n                            opts.env.VSCODE_PREVENT_FOREIGN_INSPECT = true;\n                        }\n                    }\n                    const crashReporterOptions = undefined; // TODO@electron pass this in as options to the extension host after verifying this actually works\n                    if (crashReporterOptions) {\n                        opts.env.CRASH_REPORTER_START_OPTIONS = JSON.stringify(crashReporterOptions);\n                    }\n                    // Run Extension Host as fork of current process\n                    this._extensionHostProcess = child_process_1.fork(amd_1.getPathFromAmdModule(require, 'bootstrap-fork'), ['--type=extensionHost'], opts);\n                    this._extensionHostProcess.stdout.setEncoding('utf8');\n                    this._extensionHostProcess.stderr.setEncoding('utf8');\n                    const onStdout = event_1.Event.fromNodeEventEmitter(this._extensionHostProcess.stdout, 'data');\n                    const onStderr = event_1.Event.fromNodeEventEmitter(this._extensionHostProcess.stderr, 'data');\n                    const onOutput = event_1.Event.any(event_1.Event.map(onStdout, o => ({ data: `%c${o}`, format: [''] })), event_1.Event.map(onStderr, o => ({ data: `%c${o}`, format: ['color: red'] })));\n                    // Debounce all output, so we can render it in the Chrome console as a group\n                    const onDebouncedOutput = event_1.Event.debounce(onOutput, (r, o) => {\n                        return r\n                            ? { data: r.data + o.data, format: [...r.format, ...o.format] }\n                            : { data: o.data, format: o.format };\n                    }, 100);\n                    // Print out extension host output\n                    onDebouncedOutput(output => {\n                        const inspectorUrlMatch = output.data && output.data.match(/ws:\\/\\/([^\\s]+:(\\d+)\\/[^\\s]+)/);\n                        if (inspectorUrlMatch) {\n                            if (!this._environmentService.isBuilt) {\n                                console.log(`%c[Extension Host] %cdebugger inspector at chrome-devtools://devtools/bundled/inspector.html?experiments=true&v8only=true&ws=${inspectorUrlMatch[1]}`, 'color: blue', 'color: black');\n                            }\n                            if (!this._inspectPort) {\n                                this._inspectPort = Number(inspectorUrlMatch[2]);\n                            }\n                        }\n                        else {\n                            console.group('Extension Host');\n                            console.log(output.data, ...output.format);\n                            console.groupEnd();\n                        }\n                    });\n                    // Support logging from extension host\n                    this._extensionHostProcess.on('message', msg => {\n                        if (msg && msg.type === '__$console') {\n                            this._logExtensionHostMessage(msg);\n                        }\n                    });\n                    // Lifecycle\n                    this._extensionHostProcess.on('error', (err) => this._onExtHostProcessError(err));\n                    this._extensionHostProcess.on('exit', (code, signal) => this._onExtHostProcessExit(code, signal));\n                    // Notify debugger that we are ready to attach to the process if we run a development extension\n                    if (this._isExtensionDevHost && portData.actual && this._isExtensionDevDebug) {\n                        this._broadcastService.broadcast({\n                            channel: extensionHost_1.EXTENSION_ATTACH_BROADCAST_CHANNEL,\n                            payload: {\n                                debugId: this._environmentService.debugExtensionHost.debugId,\n                                port: portData.actual\n                            }\n                        });\n                    }\n                    this._inspectPort = portData.actual;\n                    // Help in case we fail to start it\n                    let startupTimeoutHandle;\n                    if (!this._environmentService.isBuilt && !this._windowService.getConfiguration().remoteAuthority || this._isExtensionDevHost) {\n                        startupTimeoutHandle = setTimeout(() => {\n                            const msg = this._isExtensionDevDebugBrk\n                                ? nls.localize('extensionHostProcess.startupFailDebug', \"Extension host did not start in 10 seconds, it might be stopped on the first line and needs a debugger to continue.\")\n                                : nls.localize('extensionHostProcess.startupFail', \"Extension host did not start in 10 seconds, that might be a problem.\");\n                            this._notificationService.prompt(notification_1.Severity.Warning, msg, [{\n                                    label: nls.localize('reloadWindow', \"Reload Window\"),\n                                    run: () => this._windowService.reloadWindow()\n                                }], { sticky: true });\n                        }, 10000);\n                    }\n                    // Initialize extension host process with hand shakes\n                    return this._tryExtHostHandshake().then((protocol) => {\n                        clearTimeout(startupTimeoutHandle);\n                        return protocol;\n                    });\n                });\n            }\n            return this._messageProtocol;\n        }\n        /**\n         * Start a server (`this._namedPipeServer`) that listens on a named pipe and return the named pipe name.\n         */\n        _tryListenOnPipe() {\n            return new Promise((resolve, reject) => {\n                const pipeName = ipc_net_2.generateRandomPipeName();\n                this._namedPipeServer = net_1.createServer();\n                this._namedPipeServer.on('error', reject);\n                this._namedPipeServer.listen(pipeName, () => {\n                    if (this._namedPipeServer) {\n                        this._namedPipeServer.removeListener('error', reject);\n                    }\n                    resolve(pipeName);\n                });\n            });\n        }\n        /**\n         * Find a free port if extension host debugging is enabled.\n         */\n        _tryFindDebugPort() {\n            let expected;\n            let startPort = ports_1.randomPort();\n            if (typeof this._environmentService.debugExtensionHost.port === 'number') {\n                startPort = expected = this._environmentService.debugExtensionHost.port;\n            }\n            return new Promise(resolve => {\n                return ports_1.findFreePort(startPort, 10 /* try 10 ports */, 5000 /* try up to 5 seconds */).then(port => {\n                    if (!port) {\n                        console.warn('%c[Extension Host] %cCould not find a free port for debugging', 'color: blue', 'color: black');\n                    }\n                    else {\n                        if (expected && port !== expected) {\n                            console.warn(`%c[Extension Host] %cProvided debugging port ${expected} is not free, using ${port} instead.`, 'color: blue', 'color: black');\n                        }\n                        if (this._isExtensionDevDebugBrk) {\n                            console.warn(`%c[Extension Host] %cSTOPPED on first line for debugging on port ${port}`, 'color: blue', 'color: black');\n                        }\n                        else {\n                            console.info(`%c[Extension Host] %cdebugger listening on port ${port}`, 'color: blue', 'color: black');\n                        }\n                    }\n                    return resolve({ expected, actual: port });\n                });\n            });\n        }\n        _tryExtHostHandshake() {\n            return new Promise((resolve, reject) => {\n                // Wait for the extension host to connect to our named pipe\n                // and wrap the socket in the message passing protocol\n                let handle = setTimeout(() => {\n                    if (this._namedPipeServer) {\n                        this._namedPipeServer.close();\n                        this._namedPipeServer = null;\n                    }\n                    reject('timeout');\n                }, 60 * 1000);\n                this._namedPipeServer.on('connection', socket => {\n                    clearTimeout(handle);\n                    if (this._namedPipeServer) {\n                        this._namedPipeServer.close();\n                        this._namedPipeServer = null;\n                    }\n                    this._extensionHostConnection = socket;\n                    // using a buffered message protocol here because between now\n                    // and the first time a `then` executes some messages might be lost\n                    // unless we immediately register a listener for `onMessage`.\n                    resolve(new ipc_net_1.PersistentProtocol(new ipc_net_2.NodeSocket(this._extensionHostConnection)));\n                });\n            }).then((protocol) => {\n                // 1) wait for the incoming `ready` event and send the initialization data.\n                // 2) wait for the incoming `initialized` event.\n                return new Promise((resolve, reject) => {\n                    let timeoutHandle;\n                    const installTimeoutCheck = () => {\n                        timeoutHandle = setTimeout(() => {\n                            reject('timeout');\n                        }, 60 * 1000);\n                    };\n                    const uninstallTimeoutCheck = () => {\n                        clearTimeout(timeoutHandle);\n                    };\n                    // Wait 60s for the ready message\n                    installTimeoutCheck();\n                    const disposable = protocol.onMessage(msg => {\n                        if (extensionHostProtocol_1.isMessageOfType(msg, extensionHostProtocol_1.MessageType.Ready)) {\n                            // 1) Extension Host is ready to receive messages, initialize it\n                            uninstallTimeoutCheck();\n                            this._createExtHostInitData().then(data => {\n                                // Wait 60s for the initialized message\n                                installTimeoutCheck();\n                                protocol.send(buffer_1.VSBuffer.fromString(JSON.stringify(data)));\n                            });\n                            return;\n                        }\n                        if (extensionHostProtocol_1.isMessageOfType(msg, extensionHostProtocol_1.MessageType.Initialized)) {\n                            // 2) Extension Host is initialized\n                            uninstallTimeoutCheck();\n                            // stop listening for messages here\n                            disposable.dispose();\n                            // release this promise\n                            resolve(protocol);\n                            return;\n                        }\n                        console.error(`received unexpected message during handshake phase from the extension host: `, msg);\n                    });\n                });\n            });\n        }\n        _createExtHostInitData() {\n            return Promise.all([this._telemetryService.getTelemetryInfo(), this._extensions])\n                .then(([telemetryInfo, extensionDescriptions]) => {\n                const workspace = this._contextService.getWorkspace();\n                const r = {\n                    commit: product_1.default.commit,\n                    parentPid: process.pid,\n                    environment: {\n                        isExtensionDevelopmentDebug: this._isExtensionDevDebug,\n                        appRoot: this._environmentService.appRoot ? uri_1.URI.file(this._environmentService.appRoot) : undefined,\n                        appSettingsHome: this._environmentService.appSettingsHome ? uri_1.URI.file(this._environmentService.appSettingsHome) : undefined,\n                        extensionDevelopmentLocationURI: this._environmentService.extensionDevelopmentLocationURI,\n                        extensionTestsLocationURI: this._environmentService.extensionTestsLocationURI,\n                        globalStorageHome: uri_1.URI.file(this._environmentService.globalStorageHome),\n                        userHome: uri_1.URI.file(this._environmentService.userHome)\n                    },\n                    workspace: this._contextService.getWorkbenchState() === workspace_1.WorkbenchState.EMPTY ? undefined : {\n                        configuration: types_1.withNullAsUndefined(workspace.configuration),\n                        id: workspace.id,\n                        name: this._labelService.getWorkspaceLabel(workspace)\n                    },\n                    resolvedExtensions: [],\n                    hostExtensions: [],\n                    extensions: extensionDescriptions,\n                    telemetryInfo,\n                    logLevel: this._logService.getLevel(),\n                    logsLocation: this._extensionHostLogsLocation,\n                    autoStart: this._autoStart\n                };\n                return r;\n            });\n        }\n        _logExtensionHostMessage(entry) {\n            // Send to local console unless we run tests from cli\n            if (!this._isExtensionDevTestFromCli) {\n                console_1.log(entry, 'Extension Host');\n            }\n            // Log on main side if running tests from cli\n            if (this._isExtensionDevTestFromCli) {\n                this._windowsService.log(entry.severity, ...console_1.parse(entry).args);\n            }\n            // Broadcast to other windows if we are in development mode\n            else if (!this._environmentService.isBuilt || this._isExtensionDevHost) {\n                this._broadcastService.broadcast({\n                    channel: extensionHost_1.EXTENSION_LOG_BROADCAST_CHANNEL,\n                    payload: {\n                        logEntry: entry,\n                        debugId: this._environmentService.debugExtensionHost.debugId\n                    }\n                });\n            }\n        }\n        _onExtHostProcessError(err) {\n            let errorMessage = errorMessage_1.toErrorMessage(err);\n            if (errorMessage === this._lastExtensionHostError) {\n                return; // prevent error spam\n            }\n            this._lastExtensionHostError = errorMessage;\n            this._notificationService.error(nls.localize('extensionHostProcess.error', \"Error from the extension host: {0}\", errorMessage));\n        }\n        _onExtHostProcessExit(code, signal) {\n            if (this._terminating) {\n                // Expected termination path (we asked the process to terminate)\n                return;\n            }\n            // Unexpected termination\n            if (!this._isExtensionDevHost) {\n                this._onCrashed.fire([code, signal]);\n            }\n            // Expected development extension termination: When the extension host goes down we also shutdown the window\n            else if (!this._isExtensionDevTestFromCli) {\n                this._windowService.closeWindow();\n            }\n            // When CLI testing make sure to exit with proper exit code\n            else {\n                electron_1.ipcRenderer.send('vscode:exit', code);\n            }\n        }\n        enableInspector() {\n            if (this._inspectPort) {\n                return Promise.resolve();\n            }\n            // send SIGUSR1 and wait a little the actual port is read from the process stdout which we\n            // scan here: https://github.com/Microsoft/vscode/blob/67ffab8dcd1a6752d8b62bcd13d7020101eef568/src/vs/workbench/services/extensions/electron-browser/extensionHost.ts#L225-L240\n            if (this._extensionHostProcess) {\n                this._extensionHostProcess.kill('SIGUSR1');\n            }\n            return async_1.timeout(1000);\n        }\n        getInspectPort() {\n            return this._inspectPort;\n        }\n        terminate() {\n            if (this._terminating) {\n                return;\n            }\n            this._terminating = true;\n            lifecycle_1.dispose(this._toDispose);\n            if (!this._messageProtocol) {\n                // .start() was not called\n                return;\n            }\n            this._messageProtocol.then((protocol) => {\n                // Send the extension host a request to terminate itself\n                // (graceful termination)\n                protocol.send(extensionHostProtocol_1.createMessageOfType(extensionHostProtocol_1.MessageType.Terminate));\n                protocol.dispose();\n                // Give the extension host 10s, after which we will\n                // try to kill the process and release any resources\n                setTimeout(() => this._cleanResources(), 10 * 1000);\n            }, (err) => {\n                // Establishing a protocol with the extension host failed, so\n                // try to kill the process and release any resources.\n                this._cleanResources();\n            });\n        }\n        _cleanResources() {\n            if (this._namedPipeServer) {\n                this._namedPipeServer.close();\n                this._namedPipeServer = null;\n            }\n            if (this._extensionHostConnection) {\n                this._extensionHostConnection.end();\n                this._extensionHostConnection = null;\n            }\n            if (this._extensionHostProcess) {\n                this._extensionHostProcess.kill();\n                this._extensionHostProcess = null;\n            }\n        }\n        _onWillShutdown(event) {\n            // If the extension development host was started without debugger attached we need\n            // to communicate this back to the main side to terminate the debug session\n            if (this._isExtensionDevHost && !this._isExtensionDevTestFromCli && !this._isExtensionDevDebug) {\n                this._broadcastService.broadcast({\n                    channel: extensionHost_1.EXTENSION_TERMINATE_BROADCAST_CHANNEL,\n                    payload: {\n                        debugId: this._environmentService.debugExtensionHost.debugId\n                    }\n                });\n                event.join(async_1.timeout(100 /* wait a bit for IPC to get delivered */));\n            }\n        }\n    };\n    ExtensionHostProcessWorker = __decorate([\n        __param(3, workspace_1.IWorkspaceContextService),\n        __param(4, notification_1.INotificationService),\n        __param(5, windows_1.IWindowsService),\n        __param(6, windows_1.IWindowService),\n        __param(7, broadcast_1.IBroadcastService),\n        __param(8, lifecycle_2.ILifecycleService),\n        __param(9, environment_1.IEnvironmentService),\n        __param(10, telemetry_1.ITelemetryService),\n        __param(11, log_1.ILogService),\n        __param(12, label_1.ILabelService)\n    ], ExtensionHostProcessWorker);\n    exports.ExtensionHostProcessWorker = ExtensionHostProcessWorker;\n});\n",null]}