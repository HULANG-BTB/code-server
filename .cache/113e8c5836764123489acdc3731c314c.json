{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/node/zip.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/zip.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/path\", \"fs\", \"vs/base/common/async\", \"vs/base/node/pfs\", \"yauzl\", \"yazl\", \"vs/base/common/event\"], function (require, exports, nls, path, fs_1, async_1, pfs_1, yauzl_1, yazl, event_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class ExtractError extends Error {\n        constructor(type, cause) {\n            let message = cause.message;\n            switch (type) {\n                case 'CorruptZip':\n                    message = `Corrupt ZIP: ${message}`;\n                    break;\n            }\n            super(message);\n            this.type = type;\n            this.cause = cause;\n        }\n    }\n    exports.ExtractError = ExtractError;\n    function modeFromEntry(entry) {\n        const attr = entry.externalFileAttributes >> 16 || 33188;\n        return [448 /* S_IRWXU */, 56 /* S_IRWXG */, 7 /* S_IRWXO */]\n            .map(mask => attr & mask)\n            .reduce((a, b) => a + b, attr & 61440 /* S_IFMT */);\n    }\n    function toExtractError(err) {\n        if (err instanceof ExtractError) {\n            return err;\n        }\n        let type = undefined;\n        if (/end of central directory record signature not found/.test(err.message)) {\n            type = 'CorruptZip';\n        }\n        return new ExtractError(type, err);\n    }\n    function extractEntry(stream, fileName, mode, targetPath, options, token) {\n        const dirName = path.dirname(fileName);\n        const targetDirName = path.join(targetPath, dirName);\n        if (targetDirName.indexOf(targetPath) !== 0) {\n            return Promise.reject(new Error(nls.localize('invalid file', \"Error extracting {0}. Invalid file.\", fileName)));\n        }\n        const targetFileName = path.join(targetPath, fileName);\n        let istream;\n        event_1.Event.once(token.onCancellationRequested)(() => {\n            if (istream) {\n                istream.destroy();\n            }\n        });\n        return Promise.resolve(pfs_1.mkdirp(targetDirName, undefined, token)).then(() => new Promise((c, e) => {\n            if (token.isCancellationRequested) {\n                return;\n            }\n            try {\n                istream = fs_1.createWriteStream(targetFileName, { mode });\n                istream.once('close', () => c());\n                istream.once('error', e);\n                stream.once('error', e);\n                stream.pipe(istream);\n            }\n            catch (error) {\n                e(error);\n            }\n        }));\n    }\n    function extractZip(zipfile, targetPath, options, token) {\n        let last = async_1.createCancelablePromise(() => Promise.resolve());\n        let extractedEntriesCount = 0;\n        event_1.Event.once(token.onCancellationRequested)(() => {\n            last.cancel();\n            zipfile.close();\n        });\n        return new Promise((c, e) => {\n            const throttler = new async_1.Sequencer();\n            const readNextEntry = (token) => {\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                extractedEntriesCount++;\n                zipfile.readEntry();\n            };\n            zipfile.once('error', e);\n            zipfile.once('close', () => last.then(() => {\n                if (token.isCancellationRequested || zipfile.entryCount === extractedEntriesCount) {\n                    c();\n                }\n                else {\n                    e(new ExtractError('Incomplete', new Error(nls.localize('incompleteExtract', \"Incomplete. Found {0} of {1} entries\", extractedEntriesCount, zipfile.entryCount))));\n                }\n            }, e));\n            zipfile.readEntry();\n            zipfile.on('entry', (entry) => {\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                if (!options.sourcePathRegex.test(entry.fileName)) {\n                    readNextEntry(token);\n                    return;\n                }\n                const fileName = entry.fileName.replace(options.sourcePathRegex, '');\n                // directory file names end with '/'\n                if (/\\/$/.test(fileName)) {\n                    const targetFileName = path.join(targetPath, fileName);\n                    last = async_1.createCancelablePromise(token => pfs_1.mkdirp(targetFileName, undefined, token).then(() => readNextEntry(token)).then(undefined, e));\n                    return;\n                }\n                const stream = async_1.ninvoke(zipfile, zipfile.openReadStream, entry);\n                const mode = modeFromEntry(entry);\n                last = async_1.createCancelablePromise(token => throttler.queue(() => stream.then(stream => extractEntry(stream, fileName, mode, targetPath, options, token).then(() => readNextEntry(token)))).then(null, e));\n            });\n        });\n    }\n    function openZip(zipFile, lazy = false) {\n        return async_1.nfcall(yauzl_1.open, zipFile, lazy ? { lazyEntries: true } : undefined)\n            .then(undefined, err => Promise.reject(toExtractError(err)));\n    }\n    function zip(zipPath, files) {\n        return new Promise((c, e) => {\n            const zip = new yazl.ZipFile();\n            files.forEach(f => {\n                if (f.contents) {\n                    zip.addBuffer(typeof f.contents === 'string' ? Buffer.from(f.contents, 'utf8') : f.contents, f.path);\n                }\n                else if (f.localPath) {\n                    zip.addFile(f.localPath, f.path);\n                }\n            });\n            zip.end();\n            const zipStream = fs_1.createWriteStream(zipPath);\n            zip.outputStream.pipe(zipStream);\n            zip.outputStream.once('error', e);\n            zipStream.once('error', e);\n            zipStream.once('finish', () => c(zipPath));\n        });\n    }\n    exports.zip = zip;\n    function extract(zipPath, targetPath, options = {}, token) {\n        const sourcePathRegex = new RegExp(options.sourcePath ? `^${options.sourcePath}` : '');\n        let promise = openZip(zipPath, true);\n        if (options.overwrite) {\n            promise = promise.then(zipfile => pfs_1.rimraf(targetPath).then(() => zipfile));\n        }\n        return promise.then(zipfile => extractZip(zipfile, targetPath, { sourcePathRegex }, token));\n    }\n    exports.extract = extract;\n    function read(zipPath, filePath) {\n        return openZip(zipPath).then(zipfile => {\n            return new Promise((c, e) => {\n                zipfile.on('entry', (entry) => {\n                    if (entry.fileName === filePath) {\n                        async_1.ninvoke(zipfile, zipfile.openReadStream, entry).then(stream => c(stream), err => e(err));\n                    }\n                });\n                zipfile.once('close', () => e(new Error(nls.localize('notFound', \"{0} not found inside zip.\", filePath))));\n            });\n        });\n    }\n    function buffer(zipPath, filePath) {\n        return read(zipPath, filePath).then(stream => {\n            return new Promise((c, e) => {\n                const buffers = [];\n                stream.once('error', e);\n                stream.on('data', b => buffers.push(b));\n                stream.on('end', () => c(Buffer.concat(buffers)));\n            });\n        });\n    }\n    exports.buffer = buffer;\n});\n",null]}