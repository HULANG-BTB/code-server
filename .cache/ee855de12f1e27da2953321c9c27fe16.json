{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/find/findWidget.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/find/findWidget.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/browser/dom\", \"vs/base/browser/ui/sash/sash\", \"vs/base/browser/ui/widget\", \"vs/base/common/async\", \"vs/base/common/errors\", \"vs/base/common/keyCodes\", \"vs/base/common/lifecycle\", \"vs/base/common/platform\", \"vs/base/common/strings\", \"vs/editor/browser/editorBrowser\", \"vs/editor/common/core/range\", \"vs/editor/contrib/find/findModel\", \"vs/platform/theme/common/colorRegistry\", \"vs/platform/theme/common/themeService\", \"vs/platform/browser/contextScopedHistoryWidget\", \"vs/platform/accessibility/common/accessibility\", \"vs/css!./findWidget\"], function (require, exports, nls, dom, sash_1, widget_1, async_1, errors_1, keyCodes_1, lifecycle_1, platform, strings, editorBrowser_1, range_1, findModel_1, colorRegistry_1, themeService_1, contextScopedHistoryWidget_1, accessibility_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const NLS_FIND_INPUT_LABEL = nls.localize('label.find', \"Find\");\n    const NLS_FIND_INPUT_PLACEHOLDER = nls.localize('placeholder.find', \"Find\");\n    const NLS_PREVIOUS_MATCH_BTN_LABEL = nls.localize('label.previousMatchButton', \"Previous match\");\n    const NLS_NEXT_MATCH_BTN_LABEL = nls.localize('label.nextMatchButton', \"Next match\");\n    const NLS_TOGGLE_SELECTION_FIND_TITLE = nls.localize('label.toggleSelectionFind', \"Find in selection\");\n    const NLS_CLOSE_BTN_LABEL = nls.localize('label.closeButton', \"Close\");\n    const NLS_REPLACE_INPUT_LABEL = nls.localize('label.replace', \"Replace\");\n    const NLS_REPLACE_INPUT_PLACEHOLDER = nls.localize('placeholder.replace', \"Replace\");\n    const NLS_REPLACE_BTN_LABEL = nls.localize('label.replaceButton', \"Replace\");\n    const NLS_REPLACE_ALL_BTN_LABEL = nls.localize('label.replaceAllButton', \"Replace All\");\n    const NLS_TOGGLE_REPLACE_MODE_BTN_LABEL = nls.localize('label.toggleReplaceButton', \"Toggle Replace mode\");\n    const NLS_MATCHES_COUNT_LIMIT_TITLE = nls.localize('title.matchesCountLimit', \"Only the first {0} results are highlighted, but all find operations work on the entire text.\", findModel_1.MATCHES_LIMIT);\n    const NLS_MATCHES_LOCATION = nls.localize('label.matchesLocation', \"{0} of {1}\");\n    const NLS_NO_RESULTS = nls.localize('label.noResults', \"No Results\");\n    const FIND_WIDGET_INITIAL_WIDTH = 411;\n    const PART_WIDTH = 275;\n    const FIND_INPUT_AREA_WIDTH = PART_WIDTH - 54;\n    const REPLACE_INPUT_AREA_WIDTH = FIND_INPUT_AREA_WIDTH;\n    let MAX_MATCHES_COUNT_WIDTH = 69;\n    let FIND_ALL_CONTROLS_WIDTH = 17 /** Find Input margin-left */ + (MAX_MATCHES_COUNT_WIDTH + 3 + 1) /** Match Results */ + 23 /** Button */ * 4 + 2 /** sash */;\n    const FIND_INPUT_AREA_HEIGHT = 34; // The height of Find Widget when Replace Input is not visible.\n    const FIND_REPLACE_AREA_HEIGHT = 64; // The height of Find Widget when Replace Input is  visible.\n    class FindWidgetViewZone {\n        constructor(afterLineNumber) {\n            this.afterLineNumber = afterLineNumber;\n            this.heightInPx = FIND_INPUT_AREA_HEIGHT;\n            this.suppressMouseDown = false;\n            this.domNode = document.createElement('div');\n            this.domNode.className = 'dock-find-viewzone';\n        }\n    }\n    exports.FindWidgetViewZone = FindWidgetViewZone;\n    class FindWidget extends widget_1.Widget {\n        constructor(codeEditor, controller, state, contextViewProvider, keybindingService, contextKeyService, themeService) {\n            super();\n            this._codeEditor = codeEditor;\n            this._controller = controller;\n            this._state = state;\n            this._contextViewProvider = contextViewProvider;\n            this._keybindingService = keybindingService;\n            this._contextKeyService = contextKeyService;\n            this._isVisible = false;\n            this._isReplaceVisible = false;\n            this._ignoreChangeEvent = false;\n            this._updateHistoryDelayer = new async_1.Delayer(500);\n            this._register(lifecycle_1.toDisposable(() => this._updateHistoryDelayer.cancel()));\n            this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));\n            this._buildDomNode();\n            this._updateButtons();\n            this._tryUpdateWidgetWidth();\n            this._register(this._codeEditor.onDidChangeConfiguration((e) => {\n                if (e.readOnly) {\n                    if (this._codeEditor.getConfiguration().readOnly) {\n                        // Hide replace part if editor becomes read only\n                        this._state.change({ isReplaceRevealed: false }, false);\n                    }\n                    this._updateButtons();\n                }\n                if (e.layoutInfo) {\n                    this._tryUpdateWidgetWidth();\n                }\n                if (e.accessibilitySupport) {\n                    this.updateAccessibilitySupport();\n                }\n                if (e.contribInfo) {\n                    const addExtraSpaceOnTop = this._codeEditor.getConfiguration().contribInfo.find.addExtraSpaceOnTop;\n                    if (addExtraSpaceOnTop && !this._viewZone) {\n                        this._viewZone = new FindWidgetViewZone(0);\n                        this._showViewZone();\n                    }\n                    if (!addExtraSpaceOnTop && this._viewZone) {\n                        this._removeViewZone();\n                    }\n                }\n            }));\n            this.updateAccessibilitySupport();\n            this._register(this._codeEditor.onDidChangeCursorSelection(() => {\n                if (this._isVisible) {\n                    this._updateToggleSelectionFindButton();\n                }\n            }));\n            this._register(this._codeEditor.onDidFocusEditorWidget(() => {\n                if (this._isVisible) {\n                    let globalBufferTerm = this._controller.getGlobalBufferTerm();\n                    if (globalBufferTerm && globalBufferTerm !== this._state.searchString) {\n                        this._state.change({ searchString: globalBufferTerm }, true);\n                        this._findInput.select();\n                    }\n                }\n            }));\n            this._findInputFocused = findModel_1.CONTEXT_FIND_INPUT_FOCUSED.bindTo(contextKeyService);\n            this._findFocusTracker = this._register(dom.trackFocus(this._findInput.inputBox.inputElement));\n            this._register(this._findFocusTracker.onDidFocus(() => {\n                this._findInputFocused.set(true);\n                this._updateSearchScope();\n            }));\n            this._register(this._findFocusTracker.onDidBlur(() => {\n                this._findInputFocused.set(false);\n            }));\n            this._replaceInputFocused = findModel_1.CONTEXT_REPLACE_INPUT_FOCUSED.bindTo(contextKeyService);\n            this._replaceFocusTracker = this._register(dom.trackFocus(this._replaceInputBox.inputElement));\n            this._register(this._replaceFocusTracker.onDidFocus(() => {\n                this._replaceInputFocused.set(true);\n                this._updateSearchScope();\n            }));\n            this._register(this._replaceFocusTracker.onDidBlur(() => {\n                this._replaceInputFocused.set(false);\n            }));\n            this._codeEditor.addOverlayWidget(this);\n            if (this._codeEditor.getConfiguration().contribInfo.find.addExtraSpaceOnTop) {\n                this._viewZone = new FindWidgetViewZone(0); // Put it before the first line then users can scroll beyond the first line.\n            }\n            this._applyTheme(themeService.getTheme());\n            this._register(themeService.onThemeChange(this._applyTheme.bind(this)));\n            this._register(this._codeEditor.onDidChangeModel(() => {\n                if (!this._isVisible) {\n                    return;\n                }\n                if (this._viewZoneId === undefined) {\n                    return;\n                }\n                this._codeEditor.changeViewZones((accessor) => {\n                    if (this._viewZoneId) {\n                        accessor.removeZone(this._viewZoneId);\n                    }\n                    this._viewZoneId = undefined;\n                });\n            }));\n            this._register(this._codeEditor.onDidScrollChange((e) => {\n                if (e.scrollTopChanged) {\n                    this._layoutViewZone();\n                    return;\n                }\n                // for other scroll changes, layout the viewzone in next tick to avoid ruining current rendering.\n                setTimeout(() => {\n                    this._layoutViewZone();\n                }, 0);\n            }));\n        }\n        // ----- IOverlayWidget API\n        getId() {\n            return FindWidget.ID;\n        }\n        getDomNode() {\n            return this._domNode;\n        }\n        getPosition() {\n            if (this._isVisible) {\n                return {\n                    preference: editorBrowser_1.OverlayWidgetPositionPreference.TOP_RIGHT_CORNER\n                };\n            }\n            return null;\n        }\n        // ----- React to state changes\n        _onStateChanged(e) {\n            if (e.searchString) {\n                try {\n                    this._ignoreChangeEvent = true;\n                    this._findInput.setValue(this._state.searchString);\n                }\n                finally {\n                    this._ignoreChangeEvent = false;\n                }\n                this._updateButtons();\n            }\n            if (e.replaceString) {\n                this._replaceInputBox.value = this._state.replaceString;\n            }\n            if (e.isRevealed) {\n                if (this._state.isRevealed) {\n                    this._reveal();\n                }\n                else {\n                    this._hide(true);\n                }\n            }\n            if (e.isReplaceRevealed) {\n                if (this._state.isReplaceRevealed) {\n                    if (!this._codeEditor.getConfiguration().readOnly && !this._isReplaceVisible) {\n                        this._isReplaceVisible = true;\n                        this._replaceInputBox.width = this._findInput.inputBox.width;\n                        this._updateButtons();\n                    }\n                }\n                else {\n                    if (this._isReplaceVisible) {\n                        this._isReplaceVisible = false;\n                        this._updateButtons();\n                    }\n                }\n            }\n            if (e.isRegex) {\n                this._findInput.setRegex(this._state.isRegex);\n            }\n            if (e.wholeWord) {\n                this._findInput.setWholeWords(this._state.wholeWord);\n            }\n            if (e.matchCase) {\n                this._findInput.setCaseSensitive(this._state.matchCase);\n            }\n            if (e.searchScope) {\n                if (this._state.searchScope) {\n                    this._toggleSelectionFind.checked = true;\n                }\n                else {\n                    this._toggleSelectionFind.checked = false;\n                }\n                this._updateToggleSelectionFindButton();\n            }\n            if (e.searchString || e.matchesCount || e.matchesPosition) {\n                let showRedOutline = (this._state.searchString.length > 0 && this._state.matchesCount === 0);\n                dom.toggleClass(this._domNode, 'no-results', showRedOutline);\n                this._updateMatchesCount();\n                this._updateButtons();\n            }\n            if (e.searchString || e.currentMatch) {\n                this._layoutViewZone();\n            }\n            if (e.updateHistory) {\n                this._delayedUpdateHistory();\n            }\n        }\n        _delayedUpdateHistory() {\n            this._updateHistoryDelayer.trigger(this._updateHistory.bind(this));\n        }\n        _updateHistory() {\n            if (this._state.searchString) {\n                this._findInput.inputBox.addToHistory();\n            }\n            if (this._state.replaceString) {\n                this._replaceInputBox.addToHistory();\n            }\n        }\n        _updateMatchesCount() {\n            this._matchesCount.style.minWidth = MAX_MATCHES_COUNT_WIDTH + 'px';\n            if (this._state.matchesCount >= findModel_1.MATCHES_LIMIT) {\n                this._matchesCount.title = NLS_MATCHES_COUNT_LIMIT_TITLE;\n            }\n            else {\n                this._matchesCount.title = '';\n            }\n            // remove previous content\n            if (this._matchesCount.firstChild) {\n                this._matchesCount.removeChild(this._matchesCount.firstChild);\n            }\n            let label;\n            if (this._state.matchesCount > 0) {\n                let matchesCount = String(this._state.matchesCount);\n                if (this._state.matchesCount >= findModel_1.MATCHES_LIMIT) {\n                    matchesCount += '+';\n                }\n                let matchesPosition = String(this._state.matchesPosition);\n                if (matchesPosition === '0') {\n                    matchesPosition = '?';\n                }\n                label = strings.format(NLS_MATCHES_LOCATION, matchesPosition, matchesCount);\n            }\n            else {\n                label = NLS_NO_RESULTS;\n            }\n            this._matchesCount.appendChild(document.createTextNode(label));\n            MAX_MATCHES_COUNT_WIDTH = Math.max(MAX_MATCHES_COUNT_WIDTH, this._matchesCount.clientWidth);\n        }\n        // ----- actions\n        /**\n         * If 'selection find' is ON we should not disable the button (its function is to cancel 'selection find').\n         * If 'selection find' is OFF we enable the button only if there is a selection.\n         */\n        _updateToggleSelectionFindButton() {\n            let selection = this._codeEditor.getSelection();\n            let isSelection = selection ? (selection.startLineNumber !== selection.endLineNumber || selection.startColumn !== selection.endColumn) : false;\n            let isChecked = this._toggleSelectionFind.checked;\n            this._toggleSelectionFind.setEnabled(this._isVisible && (isChecked || isSelection));\n        }\n        _updateButtons() {\n            this._findInput.setEnabled(this._isVisible);\n            this._replaceInputBox.setEnabled(this._isVisible && this._isReplaceVisible);\n            this._updateToggleSelectionFindButton();\n            this._closeBtn.setEnabled(this._isVisible);\n            let findInputIsNonEmpty = (this._state.searchString.length > 0);\n            let matchesCount = this._state.matchesCount ? true : false;\n            this._prevBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount);\n            this._nextBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount);\n            this._replaceBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);\n            this._replaceAllBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);\n            dom.toggleClass(this._domNode, 'replaceToggled', this._isReplaceVisible);\n            this._toggleReplaceBtn.toggleClass('collapse', !this._isReplaceVisible);\n            this._toggleReplaceBtn.toggleClass('expand', this._isReplaceVisible);\n            this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);\n            let canReplace = !this._codeEditor.getConfiguration().readOnly;\n            this._toggleReplaceBtn.setEnabled(this._isVisible && canReplace);\n        }\n        _reveal() {\n            if (!this._isVisible) {\n                this._isVisible = true;\n                const selection = this._codeEditor.getSelection();\n                const isSelection = selection ? (selection.startLineNumber !== selection.endLineNumber || selection.startColumn !== selection.endColumn) : false;\n                if (isSelection && this._codeEditor.getConfiguration().contribInfo.find.autoFindInSelection) {\n                    this._toggleSelectionFind.checked = true;\n                }\n                else {\n                    this._toggleSelectionFind.checked = false;\n                }\n                this._tryUpdateWidgetWidth();\n                this._updateButtons();\n                setTimeout(() => {\n                    dom.addClass(this._domNode, 'visible');\n                    this._domNode.setAttribute('aria-hidden', 'false');\n                }, 0);\n                // validate query again as it's being dismissed when we hide the find widget.\n                setTimeout(() => {\n                    this._findInput.validate();\n                }, 200);\n                this._codeEditor.layoutOverlayWidget(this);\n                let adjustEditorScrollTop = true;\n                if (this._codeEditor.getConfiguration().contribInfo.find.seedSearchStringFromSelection && selection) {\n                    const domNode = this._codeEditor.getDomNode();\n                    if (domNode) {\n                        const editorCoords = dom.getDomNodePagePosition(domNode);\n                        const startCoords = this._codeEditor.getScrolledVisiblePosition(selection.getStartPosition());\n                        const startLeft = editorCoords.left + (startCoords ? startCoords.left : 0);\n                        const startTop = startCoords ? startCoords.top : 0;\n                        if (this._viewZone && startTop < this._viewZone.heightInPx) {\n                            if (selection.endLineNumber > selection.startLineNumber) {\n                                adjustEditorScrollTop = false;\n                            }\n                            const leftOfFindWidget = dom.getTopLeftOffset(this._domNode).left;\n                            if (startLeft > leftOfFindWidget) {\n                                adjustEditorScrollTop = false;\n                            }\n                            const endCoords = this._codeEditor.getScrolledVisiblePosition(selection.getEndPosition());\n                            const endLeft = editorCoords.left + (endCoords ? endCoords.left : 0);\n                            if (endLeft > leftOfFindWidget) {\n                                adjustEditorScrollTop = false;\n                            }\n                        }\n                    }\n                }\n                this._showViewZone(adjustEditorScrollTop);\n            }\n        }\n        _hide(focusTheEditor) {\n            if (this._isVisible) {\n                this._isVisible = false;\n                this._updateButtons();\n                dom.removeClass(this._domNode, 'visible');\n                this._domNode.setAttribute('aria-hidden', 'true');\n                this._findInput.clearMessage();\n                if (focusTheEditor) {\n                    this._codeEditor.focus();\n                }\n                this._codeEditor.layoutOverlayWidget(this);\n                this._removeViewZone();\n            }\n        }\n        _layoutViewZone() {\n            const addExtraSpaceOnTop = this._codeEditor.getConfiguration().contribInfo.find.addExtraSpaceOnTop;\n            if (!addExtraSpaceOnTop) {\n                this._removeViewZone();\n                return;\n            }\n            if (!this._isVisible) {\n                return;\n            }\n            const viewZone = this._viewZone;\n            if (this._viewZoneId !== undefined || !viewZone) {\n                return;\n            }\n            this._codeEditor.changeViewZones((accessor) => {\n                if (this._state.isReplaceRevealed) {\n                    viewZone.heightInPx = FIND_REPLACE_AREA_HEIGHT;\n                }\n                else {\n                    viewZone.heightInPx = FIND_INPUT_AREA_HEIGHT;\n                }\n                this._viewZoneId = accessor.addZone(viewZone);\n                // scroll top adjust to make sure the editor doesn't scroll when adding viewzone at the beginning.\n                this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + viewZone.heightInPx);\n            });\n        }\n        _showViewZone(adjustScroll = true) {\n            const viewZone = this._viewZone;\n            if (!this._isVisible || !viewZone) {\n                return;\n            }\n            this._codeEditor.changeViewZones((accessor) => {\n                let scrollAdjustment = FIND_INPUT_AREA_HEIGHT;\n                if (this._viewZoneId !== undefined) {\n                    if (this._state.isReplaceRevealed) {\n                        viewZone.heightInPx = FIND_REPLACE_AREA_HEIGHT;\n                        scrollAdjustment = FIND_REPLACE_AREA_HEIGHT - FIND_INPUT_AREA_HEIGHT;\n                    }\n                    else {\n                        viewZone.heightInPx = FIND_INPUT_AREA_HEIGHT;\n                        scrollAdjustment = FIND_INPUT_AREA_HEIGHT - FIND_REPLACE_AREA_HEIGHT;\n                    }\n                    accessor.removeZone(this._viewZoneId);\n                }\n                else {\n                    viewZone.heightInPx = FIND_INPUT_AREA_HEIGHT;\n                }\n                this._viewZoneId = accessor.addZone(viewZone);\n                if (adjustScroll) {\n                    this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);\n                }\n            });\n        }\n        _removeViewZone() {\n            this._codeEditor.changeViewZones((accessor) => {\n                if (this._viewZoneId !== undefined) {\n                    accessor.removeZone(this._viewZoneId);\n                    this._viewZoneId = undefined;\n                    if (this._viewZone) {\n                        this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() - this._viewZone.heightInPx);\n                        this._viewZone = undefined;\n                    }\n                }\n            });\n        }\n        _applyTheme(theme) {\n            let inputStyles = {\n                inputActiveOptionBorder: theme.getColor(colorRegistry_1.inputActiveOptionBorder),\n                inputBackground: theme.getColor(colorRegistry_1.inputBackground),\n                inputForeground: theme.getColor(colorRegistry_1.inputForeground),\n                inputBorder: theme.getColor(colorRegistry_1.inputBorder),\n                inputValidationInfoBackground: theme.getColor(colorRegistry_1.inputValidationInfoBackground),\n                inputValidationInfoForeground: theme.getColor(colorRegistry_1.inputValidationInfoForeground),\n                inputValidationInfoBorder: theme.getColor(colorRegistry_1.inputValidationInfoBorder),\n                inputValidationWarningBackground: theme.getColor(colorRegistry_1.inputValidationWarningBackground),\n                inputValidationWarningForeground: theme.getColor(colorRegistry_1.inputValidationWarningForeground),\n                inputValidationWarningBorder: theme.getColor(colorRegistry_1.inputValidationWarningBorder),\n                inputValidationErrorBackground: theme.getColor(colorRegistry_1.inputValidationErrorBackground),\n                inputValidationErrorForeground: theme.getColor(colorRegistry_1.inputValidationErrorForeground),\n                inputValidationErrorBorder: theme.getColor(colorRegistry_1.inputValidationErrorBorder),\n            };\n            this._findInput.style(inputStyles);\n            this._replaceInputBox.style(inputStyles);\n        }\n        _tryUpdateWidgetWidth() {\n            if (!this._isVisible) {\n                return;\n            }\n            let editorWidth = this._codeEditor.getConfiguration().layoutInfo.width;\n            let minimapWidth = this._codeEditor.getConfiguration().layoutInfo.minimapWidth;\n            let collapsedFindWidget = false;\n            let reducedFindWidget = false;\n            let narrowFindWidget = false;\n            if (this._resized) {\n                let widgetWidth = dom.getTotalWidth(this._domNode);\n                if (widgetWidth > FIND_WIDGET_INITIAL_WIDTH) {\n                    // as the widget is resized by users, we may need to change the max width of the widget as the editor width changes.\n                    this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;\n                    this._replaceInputBox.inputElement.style.width = `${dom.getTotalWidth(this._findInput.inputBox.inputElement)}px`;\n                    return;\n                }\n            }\n            if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth >= editorWidth) {\n                reducedFindWidget = true;\n            }\n            if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth) {\n                narrowFindWidget = true;\n            }\n            if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth + 50) {\n                collapsedFindWidget = true;\n            }\n            dom.toggleClass(this._domNode, 'collapsed-find-widget', collapsedFindWidget);\n            dom.toggleClass(this._domNode, 'narrow-find-widget', narrowFindWidget);\n            dom.toggleClass(this._domNode, 'reduced-find-widget', reducedFindWidget);\n            if (!narrowFindWidget && !collapsedFindWidget) {\n                // the minimal left offset of findwidget is 15px.\n                this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;\n            }\n            if (this._resized) {\n                let findInputWidth = dom.getTotalWidth(this._findInput.inputBox.inputElement);\n                if (findInputWidth > 0) {\n                    this._replaceInputBox.inputElement.style.width = `${findInputWidth}px`;\n                }\n            }\n        }\n        // ----- Public\n        focusFindInput() {\n            this._findInput.select();\n            // Edge browser requires focus() in addition to select()\n            this._findInput.focus();\n        }\n        focusReplaceInput() {\n            this._replaceInputBox.select();\n            // Edge browser requires focus() in addition to select()\n            this._replaceInputBox.focus();\n        }\n        highlightFindOptions() {\n            this._findInput.highlightFindOptions();\n        }\n        _updateSearchScope() {\n            if (!this._codeEditor.hasModel()) {\n                return;\n            }\n            if (this._toggleSelectionFind.checked) {\n                let selection = this._codeEditor.getSelection();\n                if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {\n                    selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));\n                }\n                const currentMatch = this._state.currentMatch;\n                if (selection.startLineNumber !== selection.endLineNumber) {\n                    if (!range_1.Range.equalsRange(selection, currentMatch)) {\n                        // Reseed find scope\n                        this._state.change({ searchScope: selection }, true);\n                    }\n                }\n            }\n        }\n        _onFindInputMouseDown(e) {\n            // on linux, middle key does pasting.\n            if (e.middleButton) {\n                e.stopPropagation();\n            }\n        }\n        _onFindInputKeyDown(e) {\n            if (e.equals(keyCodes_1.KeyCode.Enter)) {\n                this._codeEditor.getAction(findModel_1.FIND_IDS.NextMatchFindAction).run().then(undefined, errors_1.onUnexpectedError);\n                e.preventDefault();\n                return;\n            }\n            if (e.equals(keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Enter)) {\n                this._codeEditor.getAction(findModel_1.FIND_IDS.PreviousMatchFindAction).run().then(undefined, errors_1.onUnexpectedError);\n                e.preventDefault();\n                return;\n            }\n            if (e.equals(keyCodes_1.KeyCode.Tab)) {\n                if (this._isReplaceVisible) {\n                    this._replaceInputBox.focus();\n                }\n                else {\n                    this._findInput.focusOnCaseSensitive();\n                }\n                e.preventDefault();\n                return;\n            }\n            if (e.equals(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.DownArrow)) {\n                this._codeEditor.focus();\n                e.preventDefault();\n                return;\n            }\n        }\n        _onReplaceInputKeyDown(e) {\n            if (e.equals(keyCodes_1.KeyCode.Enter)) {\n                this._controller.replace();\n                e.preventDefault();\n                return;\n            }\n            if (e.equals(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.Enter)) {\n                this._controller.replaceAll();\n                e.preventDefault();\n                return;\n            }\n            if (e.equals(keyCodes_1.KeyCode.Tab)) {\n                this._findInput.focusOnCaseSensitive();\n                e.preventDefault();\n                return;\n            }\n            if (e.equals(keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Tab)) {\n                this._findInput.focus();\n                e.preventDefault();\n                return;\n            }\n            if (e.equals(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.DownArrow)) {\n                this._codeEditor.focus();\n                e.preventDefault();\n                return;\n            }\n        }\n        // ----- sash\n        getHorizontalSashTop(_sash) {\n            return 0;\n        }\n        getHorizontalSashLeft(_sash) {\n            return 0;\n        }\n        getHorizontalSashWidth(_sash) {\n            return 500;\n        }\n        // ----- initialization\n        _keybindingLabelFor(actionId) {\n            let kb = this._keybindingService.lookupKeybinding(actionId);\n            if (!kb) {\n                return '';\n            }\n            return ` (${kb.getLabel()})`;\n        }\n        _buildFindPart() {\n            // Find input\n            this._findInput = this._register(new contextScopedHistoryWidget_1.ContextScopedFindInput(null, this._contextViewProvider, {\n                width: FIND_INPUT_AREA_WIDTH,\n                label: NLS_FIND_INPUT_LABEL,\n                placeholder: NLS_FIND_INPUT_PLACEHOLDER,\n                appendCaseSensitiveLabel: this._keybindingLabelFor(findModel_1.FIND_IDS.ToggleCaseSensitiveCommand),\n                appendWholeWordsLabel: this._keybindingLabelFor(findModel_1.FIND_IDS.ToggleWholeWordCommand),\n                appendRegexLabel: this._keybindingLabelFor(findModel_1.FIND_IDS.ToggleRegexCommand),\n                validation: (value) => {\n                    if (value.length === 0) {\n                        return null;\n                    }\n                    if (!this._findInput.getRegex()) {\n                        return null;\n                    }\n                    try {\n                        /* tslint:disable:no-unused-expression */\n                        new RegExp(value);\n                        /* tslint:enable:no-unused-expression */\n                        return null;\n                    }\n                    catch (e) {\n                        return { content: e.message };\n                    }\n                }\n            }, this._contextKeyService, true));\n            this._findInput.setRegex(!!this._state.isRegex);\n            this._findInput.setCaseSensitive(!!this._state.matchCase);\n            this._findInput.setWholeWords(!!this._state.wholeWord);\n            this._register(this._findInput.onKeyDown((e) => this._onFindInputKeyDown(e)));\n            this._register(this._findInput.inputBox.onDidChange(() => {\n                if (this._ignoreChangeEvent) {\n                    return;\n                }\n                this._state.change({ searchString: this._findInput.getValue() }, true);\n            }));\n            this._register(this._findInput.onDidOptionChange(() => {\n                this._state.change({\n                    isRegex: this._findInput.getRegex(),\n                    wholeWord: this._findInput.getWholeWords(),\n                    matchCase: this._findInput.getCaseSensitive()\n                }, true);\n            }));\n            this._register(this._findInput.onCaseSensitiveKeyDown((e) => {\n                if (e.equals(keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Tab)) {\n                    if (this._isReplaceVisible) {\n                        this._replaceInputBox.focus();\n                        e.preventDefault();\n                    }\n                }\n            }));\n            if (platform.isLinux) {\n                this._register(this._findInput.onMouseDown((e) => this._onFindInputMouseDown(e)));\n            }\n            this._matchesCount = document.createElement('div');\n            this._matchesCount.className = 'matchesCount';\n            this._updateMatchesCount();\n            // Previous button\n            this._prevBtn = this._register(new SimpleButton({\n                label: NLS_PREVIOUS_MATCH_BTN_LABEL + this._keybindingLabelFor(findModel_1.FIND_IDS.PreviousMatchFindAction),\n                className: 'previous',\n                onTrigger: () => {\n                    this._codeEditor.getAction(findModel_1.FIND_IDS.PreviousMatchFindAction).run().then(undefined, errors_1.onUnexpectedError);\n                }\n            }));\n            // Next button\n            this._nextBtn = this._register(new SimpleButton({\n                label: NLS_NEXT_MATCH_BTN_LABEL + this._keybindingLabelFor(findModel_1.FIND_IDS.NextMatchFindAction),\n                className: 'next',\n                onTrigger: () => {\n                    this._codeEditor.getAction(findModel_1.FIND_IDS.NextMatchFindAction).run().then(undefined, errors_1.onUnexpectedError);\n                }\n            }));\n            let findPart = document.createElement('div');\n            findPart.className = 'find-part';\n            findPart.appendChild(this._findInput.domNode);\n            findPart.appendChild(this._matchesCount);\n            findPart.appendChild(this._prevBtn.domNode);\n            findPart.appendChild(this._nextBtn.domNode);\n            // Toggle selection button\n            this._toggleSelectionFind = this._register(new SimpleCheckbox({\n                parent: findPart,\n                title: NLS_TOGGLE_SELECTION_FIND_TITLE + this._keybindingLabelFor(findModel_1.FIND_IDS.ToggleSearchScopeCommand),\n                onChange: () => {\n                    if (this._toggleSelectionFind.checked) {\n                        if (this._codeEditor.hasModel()) {\n                            let selection = this._codeEditor.getSelection();\n                            if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {\n                                selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));\n                            }\n                            if (!selection.isEmpty()) {\n                                this._state.change({ searchScope: selection }, true);\n                            }\n                        }\n                    }\n                    else {\n                        this._state.change({ searchScope: null }, true);\n                    }\n                }\n            }));\n            // Close button\n            this._closeBtn = this._register(new SimpleButton({\n                label: NLS_CLOSE_BTN_LABEL + this._keybindingLabelFor(findModel_1.FIND_IDS.CloseFindWidgetCommand),\n                className: 'close-fw',\n                onTrigger: () => {\n                    this._state.change({ isRevealed: false, searchScope: null }, false);\n                },\n                onKeyDown: (e) => {\n                    if (e.equals(keyCodes_1.KeyCode.Tab)) {\n                        if (this._isReplaceVisible) {\n                            if (this._replaceBtn.isEnabled()) {\n                                this._replaceBtn.focus();\n                            }\n                            else {\n                                this._codeEditor.focus();\n                            }\n                            e.preventDefault();\n                        }\n                    }\n                }\n            }));\n            findPart.appendChild(this._closeBtn.domNode);\n            return findPart;\n        }\n        _buildReplacePart() {\n            // Replace input\n            let replaceInput = document.createElement('div');\n            replaceInput.className = 'replace-input';\n            replaceInput.style.width = REPLACE_INPUT_AREA_WIDTH + 'px';\n            this._replaceInputBox = this._register(new contextScopedHistoryWidget_1.ContextScopedHistoryInputBox(replaceInput, undefined, {\n                ariaLabel: NLS_REPLACE_INPUT_LABEL,\n                placeholder: NLS_REPLACE_INPUT_PLACEHOLDER,\n                history: []\n            }, this._contextKeyService));\n            this._register(dom.addStandardDisposableListener(this._replaceInputBox.inputElement, 'keydown', (e) => this._onReplaceInputKeyDown(e)));\n            this._register(this._replaceInputBox.onDidChange(() => {\n                this._state.change({ replaceString: this._replaceInputBox.value }, false);\n            }));\n            // Replace one button\n            this._replaceBtn = this._register(new SimpleButton({\n                label: NLS_REPLACE_BTN_LABEL + this._keybindingLabelFor(findModel_1.FIND_IDS.ReplaceOneAction),\n                className: 'replace',\n                onTrigger: () => {\n                    this._controller.replace();\n                },\n                onKeyDown: (e) => {\n                    if (e.equals(keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Tab)) {\n                        this._closeBtn.focus();\n                        e.preventDefault();\n                    }\n                }\n            }));\n            // Replace all button\n            this._replaceAllBtn = this._register(new SimpleButton({\n                label: NLS_REPLACE_ALL_BTN_LABEL + this._keybindingLabelFor(findModel_1.FIND_IDS.ReplaceAllAction),\n                className: 'replace-all',\n                onTrigger: () => {\n                    this._controller.replaceAll();\n                }\n            }));\n            let replacePart = document.createElement('div');\n            replacePart.className = 'replace-part';\n            replacePart.appendChild(replaceInput);\n            replacePart.appendChild(this._replaceBtn.domNode);\n            replacePart.appendChild(this._replaceAllBtn.domNode);\n            return replacePart;\n        }\n        _buildDomNode() {\n            // Find part\n            let findPart = this._buildFindPart();\n            // Replace part\n            let replacePart = this._buildReplacePart();\n            // Toggle replace button\n            this._toggleReplaceBtn = this._register(new SimpleButton({\n                label: NLS_TOGGLE_REPLACE_MODE_BTN_LABEL,\n                className: 'toggle left',\n                onTrigger: () => {\n                    this._state.change({ isReplaceRevealed: !this._isReplaceVisible }, false);\n                    if (this._isReplaceVisible) {\n                        this._replaceInputBox.width = this._findInput.inputBox.width;\n                    }\n                    this._showViewZone();\n                }\n            }));\n            this._toggleReplaceBtn.toggleClass('expand', this._isReplaceVisible);\n            this._toggleReplaceBtn.toggleClass('collapse', !this._isReplaceVisible);\n            this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);\n            // Widget\n            this._domNode = document.createElement('div');\n            this._domNode.className = 'editor-widget find-widget';\n            this._domNode.setAttribute('aria-hidden', 'true');\n            // We need to set this explicitly, otherwise on IE11, the width inheritence of flex doesn't work.\n            this._domNode.style.width = `${FIND_WIDGET_INITIAL_WIDTH}px`;\n            this._domNode.appendChild(this._toggleReplaceBtn.domNode);\n            this._domNode.appendChild(findPart);\n            this._domNode.appendChild(replacePart);\n            this._buildSash();\n        }\n        _buildSash() {\n            this._resizeSash = new sash_1.Sash(this._domNode, this, { orientation: sash_1.Orientation.VERTICAL });\n            this._resized = false;\n            let originalWidth = FIND_WIDGET_INITIAL_WIDTH;\n            this._register(this._resizeSash.onDidStart(() => {\n                originalWidth = dom.getTotalWidth(this._domNode);\n            }));\n            this._register(this._resizeSash.onDidChange((evt) => {\n                this._resized = true;\n                let width = originalWidth + evt.startX - evt.currentX;\n                if (width < FIND_WIDGET_INITIAL_WIDTH) {\n                    // narrow down the find widget should be handled by CSS.\n                    return;\n                }\n                const inputBoxWidth = width - FIND_ALL_CONTROLS_WIDTH;\n                const maxWidth = parseFloat(dom.getComputedStyle(this._domNode).maxWidth) || 0;\n                if (width > maxWidth) {\n                    return;\n                }\n                this._domNode.style.width = `${width}px`;\n                if (this._isReplaceVisible) {\n                    this._replaceInputBox.width = inputBoxWidth;\n                }\n            }));\n        }\n        updateAccessibilitySupport() {\n            const value = this._codeEditor.getConfiguration().accessibilitySupport;\n            this._findInput.setFocusInputOnOptionClick(value !== accessibility_1.AccessibilitySupport.Enabled);\n        }\n    }\n    FindWidget.ID = 'editor.contrib.findWidget';\n    exports.FindWidget = FindWidget;\n    class SimpleCheckbox extends widget_1.Widget {\n        constructor(opts) {\n            super();\n            this._opts = opts;\n            this._domNode = document.createElement('div');\n            this._domNode.className = 'monaco-checkbox';\n            this._domNode.title = this._opts.title;\n            this._domNode.tabIndex = 0;\n            this._checkbox = document.createElement('input');\n            this._checkbox.type = 'checkbox';\n            this._checkbox.className = 'checkbox';\n            this._checkbox.id = 'checkbox-' + SimpleCheckbox._COUNTER++;\n            this._checkbox.tabIndex = -1;\n            this._label = document.createElement('label');\n            this._label.className = 'label';\n            // Connect the label and the checkbox. Checkbox will get checked when the label receives a click.\n            this._label.htmlFor = this._checkbox.id;\n            this._label.tabIndex = -1;\n            this._domNode.appendChild(this._checkbox);\n            this._domNode.appendChild(this._label);\n            this._opts.parent.appendChild(this._domNode);\n            this.onchange(this._checkbox, () => {\n                this._opts.onChange();\n            });\n        }\n        get domNode() {\n            return this._domNode;\n        }\n        get checked() {\n            return this._checkbox.checked;\n        }\n        set checked(newValue) {\n            this._checkbox.checked = newValue;\n        }\n        focus() {\n            this._checkbox.focus();\n        }\n        enable() {\n            this._checkbox.removeAttribute('disabled');\n        }\n        disable() {\n            this._checkbox.disabled = true;\n        }\n        setEnabled(enabled) {\n            if (enabled) {\n                this.enable();\n                this.domNode.tabIndex = 0;\n            }\n            else {\n                this.disable();\n                this.domNode.tabIndex = -1;\n            }\n        }\n    }\n    SimpleCheckbox._COUNTER = 0;\n    class SimpleButton extends widget_1.Widget {\n        constructor(opts) {\n            super();\n            this._opts = opts;\n            this._domNode = document.createElement('div');\n            this._domNode.title = this._opts.label;\n            this._domNode.tabIndex = 0;\n            this._domNode.className = 'button ' + this._opts.className;\n            this._domNode.setAttribute('role', 'button');\n            this._domNode.setAttribute('aria-label', this._opts.label);\n            this.onclick(this._domNode, (e) => {\n                this._opts.onTrigger();\n                e.preventDefault();\n            });\n            this.onkeydown(this._domNode, (e) => {\n                if (e.equals(keyCodes_1.KeyCode.Space) || e.equals(keyCodes_1.KeyCode.Enter)) {\n                    this._opts.onTrigger();\n                    e.preventDefault();\n                    return;\n                }\n                if (this._opts.onKeyDown) {\n                    this._opts.onKeyDown(e);\n                }\n            });\n        }\n        get domNode() {\n            return this._domNode;\n        }\n        isEnabled() {\n            return (this._domNode.tabIndex >= 0);\n        }\n        focus() {\n            this._domNode.focus();\n        }\n        setEnabled(enabled) {\n            dom.toggleClass(this._domNode, 'disabled', !enabled);\n            this._domNode.setAttribute('aria-disabled', String(!enabled));\n            this._domNode.tabIndex = enabled ? 0 : -1;\n        }\n        setExpanded(expanded) {\n            this._domNode.setAttribute('aria-expanded', String(!!expanded));\n        }\n        toggleClass(className, shouldHaveIt) {\n            dom.toggleClass(this._domNode, className, shouldHaveIt);\n        }\n    }\n    exports.SimpleButton = SimpleButton;\n    // theming\n    themeService_1.registerThemingParticipant((theme, collector) => {\n        const addBackgroundColorRule = (selector, color) => {\n            if (color) {\n                collector.addRule(`.monaco-editor ${selector} { background-color: ${color}; }`);\n            }\n        };\n        addBackgroundColorRule('.findMatch', theme.getColor(colorRegistry_1.editorFindMatchHighlight));\n        addBackgroundColorRule('.currentFindMatch', theme.getColor(colorRegistry_1.editorFindMatch));\n        addBackgroundColorRule('.findScope', theme.getColor(colorRegistry_1.editorFindRangeHighlight));\n        const widgetBackground = theme.getColor(colorRegistry_1.editorWidgetBackground);\n        addBackgroundColorRule('.find-widget', widgetBackground);\n        const widgetShadowColor = theme.getColor(colorRegistry_1.widgetShadow);\n        if (widgetShadowColor) {\n            collector.addRule(`.monaco-editor .find-widget { box-shadow: 0 2px 8px ${widgetShadowColor}; }`);\n        }\n        const findMatchHighlightBorder = theme.getColor(colorRegistry_1.editorFindMatchHighlightBorder);\n        if (findMatchHighlightBorder) {\n            collector.addRule(`.monaco-editor .findMatch { border: 1px ${theme.type === 'hc' ? 'dotted' : 'solid'} ${findMatchHighlightBorder}; box-sizing: border-box; }`);\n        }\n        const findMatchBorder = theme.getColor(colorRegistry_1.editorFindMatchBorder);\n        if (findMatchBorder) {\n            collector.addRule(`.monaco-editor .currentFindMatch { border: 2px solid ${findMatchBorder}; padding: 1px; box-sizing: border-box; }`);\n        }\n        const findRangeHighlightBorder = theme.getColor(colorRegistry_1.editorFindRangeHighlightBorder);\n        if (findRangeHighlightBorder) {\n            collector.addRule(`.monaco-editor .findScope { border: 1px ${theme.type === 'hc' ? 'dashed' : 'solid'} ${findRangeHighlightBorder}; }`);\n        }\n        const hcBorder = theme.getColor(colorRegistry_1.contrastBorder);\n        if (hcBorder) {\n            collector.addRule(`.monaco-editor .find-widget { border: 2px solid ${hcBorder}; }`);\n        }\n        const error = theme.getColor(colorRegistry_1.errorForeground);\n        if (error) {\n            collector.addRule(`.monaco-editor .find-widget.no-results .matchesCount { color: ${error}; }`);\n        }\n        const resizeBorderBackground = theme.getColor(colorRegistry_1.editorWidgetResizeBorder);\n        if (resizeBorderBackground) {\n            collector.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${resizeBorderBackground}; width: 3px !important; margin-left: -4px;}`);\n        }\n        else {\n            const border = theme.getColor(colorRegistry_1.editorWidgetBorder);\n            if (border) {\n                collector.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${border}; width: 3px !important; margin-left: -4px;}`);\n            }\n        }\n        const inputActiveBorder = theme.getColor(colorRegistry_1.inputActiveOptionBorder);\n        if (inputActiveBorder) {\n            collector.addRule(`.monaco-editor .find-widget .monaco-checkbox .checkbox:checked + .label { border: 1px solid ${inputActiveBorder.toString()}; }`);\n        }\n    });\n});\n",null]}