{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/files/common/explorerModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/files/common/explorerModel.ts","mtime":1555846338040},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar extpath_1 = require(\"vs/base/common/extpath\");\nvar path_1 = require(\"vs/base/common/path\");\nvar resources = require(\"vs/base/common/resources\");\nvar map_1 = require(\"vs/base/common/map\");\nvar platform_1 = require(\"vs/base/common/platform\");\nvar strings_1 = require(\"vs/base/common/strings\");\nvar arrays_1 = require(\"vs/base/common/arrays\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar decorators_1 = require(\"vs/base/common/decorators\");\nvar event_1 = require(\"vs/base/common/event\");\nvar ExplorerModel = /** @class */ (function () {\n    function ExplorerModel(contextService) {\n        var _this = this;\n        this.contextService = contextService;\n        this._onDidChangeRoots = new event_1.Emitter();\n        var setRoots = function () { return _this._roots = _this.contextService.getWorkspace().folders\n            .map(function (folder) { return new ExplorerItem(folder.uri, undefined, true, false, false, folder.name); }); };\n        setRoots();\n        this._listener = this.contextService.onDidChangeWorkspaceFolders(function () {\n            setRoots();\n            _this._onDidChangeRoots.fire();\n        });\n    }\n    Object.defineProperty(ExplorerModel.prototype, \"roots\", {\n        get: function () {\n            return this._roots;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ExplorerModel.prototype, \"onDidChangeRoots\", {\n        get: function () {\n            return this._onDidChangeRoots.event;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns an array of child stat from this stat that matches with the provided path.\n     * Starts matching from the first root.\n     * Will return empty array in case the FileStat does not exist.\n     */\n    ExplorerModel.prototype.findAll = function (resource) {\n        return arrays_1.coalesce(this.roots.map(function (root) { return root.find(resource); }));\n    };\n    /**\n     * Returns a FileStat that matches the passed resource.\n     * In case multiple FileStat are matching the resource (same folder opened multiple times) returns the FileStat that has the closest root.\n     * Will return undefined in case the FileStat does not exist.\n     */\n    ExplorerModel.prototype.findClosest = function (resource) {\n        var folder = this.contextService.getWorkspaceFolder(resource);\n        if (folder) {\n            var root = this.roots.filter(function (r) { return r.resource.toString() === folder.uri.toString(); }).pop();\n            if (root) {\n                return root.find(resource);\n            }\n        }\n        return null;\n    };\n    ExplorerModel.prototype.dispose = function () {\n        this._listener = lifecycle_1.dispose(this._listener);\n    };\n    return ExplorerModel;\n}());\nexports.ExplorerModel = ExplorerModel;\nvar ExplorerItem = /** @class */ (function () {\n    function ExplorerItem(resource, _parent, _isDirectory, _isSymbolicLink, _isReadonly, _name, _mtime) {\n        if (_name === void 0) { _name = resources.basenameOrAuthority(resource); }\n        this.resource = resource;\n        this._parent = _parent;\n        this._isDirectory = _isDirectory;\n        this._isSymbolicLink = _isSymbolicLink;\n        this._isReadonly = _isReadonly;\n        this._name = _name;\n        this._mtime = _mtime;\n        this.forgotChildren = false;\n        this._isDirectoryResolved = false;\n    }\n    Object.defineProperty(ExplorerItem.prototype, \"isDirectoryResolved\", {\n        get: function () {\n            return this._isDirectoryResolved;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ExplorerItem.prototype, \"isSymbolicLink\", {\n        get: function () {\n            return !!this._isSymbolicLink;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ExplorerItem.prototype, \"isDirectory\", {\n        get: function () {\n            return !!this._isDirectory;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ExplorerItem.prototype, \"isReadonly\", {\n        get: function () {\n            return !!this._isReadonly;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ExplorerItem.prototype, \"mtime\", {\n        get: function () {\n            return this._mtime;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ExplorerItem.prototype, \"name\", {\n        get: function () {\n            return this._name;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ExplorerItem.prototype, \"parent\", {\n        get: function () {\n            return this._parent;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ExplorerItem.prototype, \"root\", {\n        get: function () {\n            if (!this._parent) {\n                return this;\n            }\n            return this._parent.root;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ExplorerItem.prototype, \"children\", {\n        get: function () {\n            return new Map();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ExplorerItem.prototype.updateName = function (value) {\n        // Re-add to parent since the parent has a name map to children and the name might have changed\n        if (this._parent) {\n            this._parent.removeChild(this);\n        }\n        this._name = value;\n        if (this._parent) {\n            this._parent.addChild(this);\n        }\n    };\n    ExplorerItem.prototype.getId = function () {\n        return this.resource.toString();\n    };\n    Object.defineProperty(ExplorerItem.prototype, \"isRoot\", {\n        get: function () {\n            return this === this.root;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ExplorerItem.create = function (raw, parent, resolveTo) {\n        var stat = new ExplorerItem(raw.resource, parent, raw.isDirectory, raw.isSymbolicLink, raw.isReadonly, raw.name, raw.mtime);\n        // Recursively add children if present\n        if (stat.isDirectory) {\n            // isDirectoryResolved is a very important indicator in the stat model that tells if the folder was fully resolved\n            // the folder is fully resolved if either it has a list of children or the client requested this by using the resolveTo\n            // array of resource path to resolve.\n            stat._isDirectoryResolved = !!raw.children || (!!resolveTo && resolveTo.some(function (r) {\n                return resources.isEqualOrParent(r, stat.resource);\n            }));\n            // Recurse into children\n            if (raw.children) {\n                for (var i = 0, len = raw.children.length; i < len; i++) {\n                    var child = ExplorerItem.create(raw.children[i], stat, resolveTo);\n                    stat.addChild(child);\n                }\n            }\n        }\n        return stat;\n    };\n    /**\n     * Merges the stat which was resolved from the disk with the local stat by copying over properties\n     * and children. The merge will only consider resolved stat elements to avoid overwriting data which\n     * exists locally.\n     */\n    ExplorerItem.mergeLocalWithDisk = function (disk, local) {\n        if (disk.resource.toString() !== local.resource.toString()) {\n            return; // Merging only supported for stats with the same resource\n        }\n        // Stop merging when a folder is not resolved to avoid loosing local data\n        var mergingDirectories = disk.isDirectory || local.isDirectory;\n        if (mergingDirectories && local._isDirectoryResolved && !disk._isDirectoryResolved) {\n            return;\n        }\n        // Properties\n        local.resource = disk.resource;\n        local.updateName(disk.name);\n        local._isDirectory = disk.isDirectory;\n        local._mtime = disk.mtime;\n        local._isDirectoryResolved = disk._isDirectoryResolved;\n        local._isSymbolicLink = disk.isSymbolicLink;\n        local._isReadonly = disk.isReadonly;\n        local.isError = disk.isError;\n        // Merge Children if resolved\n        if (mergingDirectories && disk._isDirectoryResolved) {\n            // Map resource => stat\n            var oldLocalChildren_1 = new map_1.ResourceMap();\n            local.children.forEach(function (child) {\n                oldLocalChildren_1.set(child.resource, child);\n            });\n            // Clear current children\n            local.children.clear();\n            // Merge received children\n            disk.children.forEach(function (diskChild) {\n                var formerLocalChild = oldLocalChildren_1.get(diskChild.resource);\n                // Existing child: merge\n                if (formerLocalChild) {\n                    ExplorerItem.mergeLocalWithDisk(diskChild, formerLocalChild);\n                    local.addChild(formerLocalChild);\n                }\n                // New child: add\n                else {\n                    local.addChild(diskChild);\n                }\n            });\n        }\n    };\n    /**\n     * Adds a child element to this folder.\n     */\n    ExplorerItem.prototype.addChild = function (child) {\n        // Inherit some parent properties to child\n        child._parent = this;\n        child.updateResource(false);\n        this.children.set(this.getPlatformAwareName(child.name), child);\n    };\n    ExplorerItem.prototype.getChild = function (name) {\n        return this.children.get(this.getPlatformAwareName(name));\n    };\n    ExplorerItem.prototype.fetchChildren = function (fileService, explorerService) {\n        var _this = this;\n        var promise = Promise.resolve(undefined);\n        if (!this._isDirectoryResolved || this.forgotChildren) {\n            this.forgotChildren = false;\n            // Resolve metadata only when the mtime is needed since this can be expensive\n            // Mtime is only used when the sort order is 'modified'\n            var resolveMetadata = explorerService.sortOrder === 'modified';\n            promise = fileService.resolveFile(this.resource, { resolveSingleChildDescendants: true, resolveMetadata: resolveMetadata }).then(function (stat) {\n                var resolved = ExplorerItem.create(stat, _this);\n                ExplorerItem.mergeLocalWithDisk(resolved, _this);\n                _this._isDirectoryResolved = true;\n            });\n        }\n        return promise.then(function () {\n            var items = [];\n            _this.children.forEach(function (child) {\n                items.push(child);\n            });\n            return items;\n        });\n    };\n    /**\n     * Removes a child element from this folder.\n     */\n    ExplorerItem.prototype.removeChild = function (child) {\n        this.children.delete(this.getPlatformAwareName(child.name));\n    };\n    ExplorerItem.prototype.forgetChildren = function () {\n        this.children.clear();\n        this.forgotChildren = true;\n        this._isDirectoryResolved = false;\n    };\n    ExplorerItem.prototype.getPlatformAwareName = function (name) {\n        return (platform_1.isLinux || !name) ? name : name.toLowerCase();\n    };\n    /**\n     * Moves this element under a new parent element.\n     */\n    ExplorerItem.prototype.move = function (newParent) {\n        if (this._parent) {\n            this._parent.removeChild(this);\n        }\n        newParent.removeChild(this); // make sure to remove any previous version of the file if any\n        newParent.addChild(this);\n        this.updateResource(true);\n    };\n    ExplorerItem.prototype.updateResource = function (recursive) {\n        if (this._parent) {\n            this.resource = resources.joinPath(this._parent.resource, this.name);\n        }\n        if (recursive) {\n            if (this.isDirectory) {\n                this.children.forEach(function (child) {\n                    child.updateResource(true);\n                });\n            }\n        }\n    };\n    /**\n     * Tells this stat that it was renamed. This requires changes to all children of this stat (if any)\n     * so that the path property can be updated properly.\n     */\n    ExplorerItem.prototype.rename = function (renamedStat) {\n        // Merge a subset of Properties that can change on rename\n        this.updateName(renamedStat.name);\n        this._mtime = renamedStat.mtime;\n        // Update Paths including children\n        this.updateResource(true);\n    };\n    /**\n     * Returns a child stat from this stat that matches with the provided path.\n     * Will return \"null\" in case the child does not exist.\n     */\n    ExplorerItem.prototype.find = function (resource) {\n        // Return if path found\n        // For performance reasons try to do the comparison as fast as possible\n        if (resource && this.resource.scheme === resource.scheme && strings_1.equalsIgnoreCase(this.resource.authority, resource.authority) &&\n            (resources.hasToIgnoreCase(resource) ? strings_1.startsWithIgnoreCase(resource.path, this.resource.path) : strings_1.startsWith(resource.path, this.resource.path))) {\n            return this.findByPath(strings_1.rtrim(resource.path, path_1.posix.sep), this.resource.path.length);\n        }\n        return null; //Unable to find\n    };\n    ExplorerItem.prototype.findByPath = function (path, index) {\n        if (extpath_1.isEqual(strings_1.rtrim(this.resource.path, path_1.posix.sep), path, !platform_1.isLinux)) {\n            return this;\n        }\n        if (this.isDirectory) {\n            // Ignore separtor to more easily deduct the next name to search\n            while (index < path.length && path[index] === path_1.posix.sep) {\n                index++;\n            }\n            var indexOfNextSep = path.indexOf(path_1.posix.sep, index);\n            if (indexOfNextSep === -1) {\n                // If there is no separator take the remainder of the path\n                indexOfNextSep = path.length;\n            }\n            // The name to search is between two separators\n            var name = path.substring(index, indexOfNextSep);\n            var child = this.children.get(this.getPlatformAwareName(name));\n            if (child) {\n                // We found a child with the given name, search inside it\n                return child.findByPath(path, indexOfNextSep);\n            }\n        }\n        return null;\n    };\n    tslib_1.__decorate([\n        decorators_1.memoize\n    ], ExplorerItem.prototype, \"children\", null);\n    return ExplorerItem;\n}());\nexports.ExplorerItem = ExplorerItem;\nvar NewExplorerItem = /** @class */ (function (_super) {\n    tslib_1.__extends(NewExplorerItem, _super);\n    function NewExplorerItem(parent, isDirectory) {\n        return _super.call(this, uri_1.URI.file(''), parent, isDirectory) || this;\n    }\n    return NewExplorerItem;\n}(ExplorerItem));\nexports.NewExplorerItem = NewExplorerItem;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/files/common/explorerModel.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/files/common/explorerModel.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport { isEqual } from 'vs/base/common/extpath';\nimport { posix } from 'vs/base/common/path';\nimport * as resources from 'vs/base/common/resources';\nimport { ResourceMap } from 'vs/base/common/map';\nimport { isLinux } from 'vs/base/common/platform';\nimport { IFileStat, IFileService } from 'vs/platform/files/common/files';\nimport { rtrim, startsWithIgnoreCase, startsWith, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { coalesce } from 'vs/base/common/arrays';\nimport { IWorkspaceContextService } from 'vs/platform/workspace/common/workspace';\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { memoize } from 'vs/base/common/decorators';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IExplorerService } from 'vs/workbench/contrib/files/common/files';\n\nexport class ExplorerModel implements IDisposable {\n\n\tprivate _roots: ExplorerItem[];\n\tprivate _listener: IDisposable;\n\tprivate _onDidChangeRoots = new Emitter<void>();\n\n\tconstructor(private readonly contextService: IWorkspaceContextService) {\n\t\tconst setRoots = () => this._roots = this.contextService.getWorkspace().folders\n\t\t\t.map(folder => new ExplorerItem(folder.uri, undefined, true, false, false, folder.name));\n\t\tsetRoots();\n\n\t\tthis._listener = this.contextService.onDidChangeWorkspaceFolders(() => {\n\t\t\tsetRoots();\n\t\t\tthis._onDidChangeRoots.fire();\n\t\t});\n\t}\n\n\tget roots(): ExplorerItem[] {\n\t\treturn this._roots;\n\t}\n\n\tget onDidChangeRoots(): Event<void> {\n\t\treturn this._onDidChangeRoots.event;\n\t}\n\n\t/**\n\t * Returns an array of child stat from this stat that matches with the provided path.\n\t * Starts matching from the first root.\n\t * Will return empty array in case the FileStat does not exist.\n\t */\n\tfindAll(resource: URI): ExplorerItem[] {\n\t\treturn coalesce(this.roots.map(root => root.find(resource)));\n\t}\n\n\t/**\n\t * Returns a FileStat that matches the passed resource.\n\t * In case multiple FileStat are matching the resource (same folder opened multiple times) returns the FileStat that has the closest root.\n\t * Will return undefined in case the FileStat does not exist.\n\t */\n\tfindClosest(resource: URI): ExplorerItem | null {\n\t\tconst folder = this.contextService.getWorkspaceFolder(resource);\n\t\tif (folder) {\n\t\t\tconst root = this.roots.filter(r => r.resource.toString() === folder.uri.toString()).pop();\n\t\t\tif (root) {\n\t\t\t\treturn root.find(resource);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tdispose(): void {\n\t\tthis._listener = dispose(this._listener);\n\t}\n}\n\nexport class ExplorerItem {\n\tprivate forgotChildren: boolean = false;\n\tprivate _isDirectoryResolved: boolean;\n\tpublic isError: boolean;\n\n\tconstructor(\n\t\tpublic resource: URI,\n\t\tprivate _parent: ExplorerItem | undefined,\n\t\tprivate _isDirectory?: boolean,\n\t\tprivate _isSymbolicLink?: boolean,\n\t\tprivate _isReadonly?: boolean,\n\t\tprivate _name: string = resources.basenameOrAuthority(resource),\n\t\tprivate _mtime?: number,\n\t) {\n\t\tthis._isDirectoryResolved = false;\n\t}\n\n\tget isDirectoryResolved(): boolean {\n\t\treturn this._isDirectoryResolved;\n\t}\n\n\tget isSymbolicLink(): boolean {\n\t\treturn !!this._isSymbolicLink;\n\t}\n\n\tget isDirectory(): boolean {\n\t\treturn !!this._isDirectory;\n\t}\n\n\tget isReadonly(): boolean {\n\t\treturn !!this._isReadonly;\n\t}\n\n\tget mtime(): number | undefined {\n\t\treturn this._mtime;\n\t}\n\n\tget name(): string {\n\t\treturn this._name;\n\t}\n\n\tget parent(): ExplorerItem | undefined {\n\t\treturn this._parent;\n\t}\n\n\tget root(): ExplorerItem {\n\t\tif (!this._parent) {\n\t\t\treturn this;\n\t\t}\n\n\t\treturn this._parent.root;\n\t}\n\n\t@memoize get children(): Map<string, ExplorerItem> {\n\t\treturn new Map<string, ExplorerItem>();\n\t}\n\n\tprivate updateName(value: string): void {\n\t\t// Re-add to parent since the parent has a name map to children and the name might have changed\n\t\tif (this._parent) {\n\t\t\tthis._parent.removeChild(this);\n\t\t}\n\t\tthis._name = value;\n\t\tif (this._parent) {\n\t\t\tthis._parent.addChild(this);\n\t\t}\n\t}\n\n\tgetId(): string {\n\t\treturn this.resource.toString();\n\t}\n\n\tget isRoot(): boolean {\n\t\treturn this === this.root;\n\t}\n\n\tstatic create(raw: IFileStat, parent: ExplorerItem | undefined, resolveTo?: URI[]): ExplorerItem {\n\t\tconst stat = new ExplorerItem(raw.resource, parent, raw.isDirectory, raw.isSymbolicLink, raw.isReadonly, raw.name, raw.mtime);\n\n\t\t// Recursively add children if present\n\t\tif (stat.isDirectory) {\n\n\t\t\t// isDirectoryResolved is a very important indicator in the stat model that tells if the folder was fully resolved\n\t\t\t// the folder is fully resolved if either it has a list of children or the client requested this by using the resolveTo\n\t\t\t// array of resource path to resolve.\n\t\t\tstat._isDirectoryResolved = !!raw.children || (!!resolveTo && resolveTo.some((r) => {\n\t\t\t\treturn resources.isEqualOrParent(r, stat.resource);\n\t\t\t}));\n\n\t\t\t// Recurse into children\n\t\t\tif (raw.children) {\n\t\t\t\tfor (let i = 0, len = raw.children.length; i < len; i++) {\n\t\t\t\t\tconst child = ExplorerItem.create(raw.children[i], stat, resolveTo);\n\t\t\t\t\tstat.addChild(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn stat;\n\t}\n\n\t/**\n\t * Merges the stat which was resolved from the disk with the local stat by copying over properties\n\t * and children. The merge will only consider resolved stat elements to avoid overwriting data which\n\t * exists locally.\n\t */\n\tstatic mergeLocalWithDisk(disk: ExplorerItem, local: ExplorerItem): void {\n\t\tif (disk.resource.toString() !== local.resource.toString()) {\n\t\t\treturn; // Merging only supported for stats with the same resource\n\t\t}\n\n\t\t// Stop merging when a folder is not resolved to avoid loosing local data\n\t\tconst mergingDirectories = disk.isDirectory || local.isDirectory;\n\t\tif (mergingDirectories && local._isDirectoryResolved && !disk._isDirectoryResolved) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Properties\n\t\tlocal.resource = disk.resource;\n\t\tlocal.updateName(disk.name);\n\t\tlocal._isDirectory = disk.isDirectory;\n\t\tlocal._mtime = disk.mtime;\n\t\tlocal._isDirectoryResolved = disk._isDirectoryResolved;\n\t\tlocal._isSymbolicLink = disk.isSymbolicLink;\n\t\tlocal._isReadonly = disk.isReadonly;\n\t\tlocal.isError = disk.isError;\n\n\t\t// Merge Children if resolved\n\t\tif (mergingDirectories && disk._isDirectoryResolved) {\n\n\t\t\t// Map resource => stat\n\t\t\tconst oldLocalChildren = new ResourceMap<ExplorerItem>();\n\t\t\tlocal.children.forEach(child => {\n\t\t\t\toldLocalChildren.set(child.resource, child);\n\t\t\t});\n\n\t\t\t// Clear current children\n\t\t\tlocal.children.clear();\n\n\t\t\t// Merge received children\n\t\t\tdisk.children.forEach(diskChild => {\n\t\t\t\tconst formerLocalChild = oldLocalChildren.get(diskChild.resource);\n\t\t\t\t// Existing child: merge\n\t\t\t\tif (formerLocalChild) {\n\t\t\t\t\tExplorerItem.mergeLocalWithDisk(diskChild, formerLocalChild);\n\t\t\t\t\tlocal.addChild(formerLocalChild);\n\t\t\t\t}\n\n\t\t\t\t// New child: add\n\t\t\t\telse {\n\t\t\t\t\tlocal.addChild(diskChild);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Adds a child element to this folder.\n\t */\n\taddChild(child: ExplorerItem): void {\n\t\t// Inherit some parent properties to child\n\t\tchild._parent = this;\n\t\tchild.updateResource(false);\n\t\tthis.children.set(this.getPlatformAwareName(child.name), child);\n\t}\n\n\tgetChild(name: string): ExplorerItem | undefined {\n\t\treturn this.children.get(this.getPlatformAwareName(name));\n\t}\n\n\tfetchChildren(fileService: IFileService, explorerService: IExplorerService): Promise<ExplorerItem[]> {\n\t\tlet promise: Promise<any> = Promise.resolve(undefined);\n\t\tif (!this._isDirectoryResolved || this.forgotChildren) {\n\t\t\tthis.forgotChildren = false;\n\t\t\t// Resolve metadata only when the mtime is needed since this can be expensive\n\t\t\t// Mtime is only used when the sort order is 'modified'\n\t\t\tconst resolveMetadata = explorerService.sortOrder === 'modified';\n\t\t\tpromise = fileService.resolveFile(this.resource, { resolveSingleChildDescendants: true, resolveMetadata }).then(stat => {\n\t\t\t\tconst resolved = ExplorerItem.create(stat, this);\n\t\t\t\tExplorerItem.mergeLocalWithDisk(resolved, this);\n\t\t\t\tthis._isDirectoryResolved = true;\n\t\t\t});\n\t\t}\n\n\t\treturn promise.then(() => {\n\t\t\tconst items: ExplorerItem[] = [];\n\t\t\tthis.children.forEach(child => {\n\t\t\t\titems.push(child);\n\t\t\t});\n\n\t\t\treturn items;\n\t\t});\n\t}\n\n\t/**\n\t * Removes a child element from this folder.\n\t */\n\tremoveChild(child: ExplorerItem): void {\n\t\tthis.children.delete(this.getPlatformAwareName(child.name));\n\t}\n\n\tforgetChildren(): void {\n\t\tthis.children.clear();\n\t\tthis.forgotChildren = true;\n\t\tthis._isDirectoryResolved = false;\n\t}\n\n\tprivate getPlatformAwareName(name: string): string {\n\t\treturn (isLinux || !name) ? name : name.toLowerCase();\n\t}\n\n\t/**\n\t * Moves this element under a new parent element.\n\t */\n\tmove(newParent: ExplorerItem): void {\n\t\tif (this._parent) {\n\t\t\tthis._parent.removeChild(this);\n\t\t}\n\t\tnewParent.removeChild(this); // make sure to remove any previous version of the file if any\n\t\tnewParent.addChild(this);\n\t\tthis.updateResource(true);\n\t}\n\n\tprivate updateResource(recursive: boolean): void {\n\t\tif (this._parent) {\n\t\t\tthis.resource = resources.joinPath(this._parent.resource, this.name);\n\t\t}\n\n\t\tif (recursive) {\n\t\t\tif (this.isDirectory) {\n\t\t\t\tthis.children.forEach(child => {\n\t\t\t\t\tchild.updateResource(true);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Tells this stat that it was renamed. This requires changes to all children of this stat (if any)\n\t * so that the path property can be updated properly.\n\t */\n\trename(renamedStat: { name: string, mtime?: number }): void {\n\n\t\t// Merge a subset of Properties that can change on rename\n\t\tthis.updateName(renamedStat.name);\n\t\tthis._mtime = renamedStat.mtime;\n\n\t\t// Update Paths including children\n\t\tthis.updateResource(true);\n\t}\n\n\t/**\n\t * Returns a child stat from this stat that matches with the provided path.\n\t * Will return \"null\" in case the child does not exist.\n\t */\n\tfind(resource: URI): ExplorerItem | null {\n\t\t// Return if path found\n\t\t// For performance reasons try to do the comparison as fast as possible\n\t\tif (resource && this.resource.scheme === resource.scheme && equalsIgnoreCase(this.resource.authority, resource.authority) &&\n\t\t\t(resources.hasToIgnoreCase(resource) ? startsWithIgnoreCase(resource.path, this.resource.path) : startsWith(resource.path, this.resource.path))) {\n\t\t\treturn this.findByPath(rtrim(resource.path, posix.sep), this.resource.path.length);\n\t\t}\n\n\t\treturn null; //Unable to find\n\t}\n\n\tprivate findByPath(path: string, index: number): ExplorerItem | null {\n\t\tif (isEqual(rtrim(this.resource.path, posix.sep), path, !isLinux)) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (this.isDirectory) {\n\t\t\t// Ignore separtor to more easily deduct the next name to search\n\t\t\twhile (index < path.length && path[index] === posix.sep) {\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tlet indexOfNextSep = path.indexOf(posix.sep, index);\n\t\t\tif (indexOfNextSep === -1) {\n\t\t\t\t// If there is no separator take the remainder of the path\n\t\t\t\tindexOfNextSep = path.length;\n\t\t\t}\n\t\t\t// The name to search is between two separators\n\t\t\tconst name = path.substring(index, indexOfNextSep);\n\n\t\t\tconst child = this.children.get(this.getPlatformAwareName(name));\n\n\t\t\tif (child) {\n\t\t\t\t// We found a child with the given name, search inside it\n\t\t\t\treturn child.findByPath(path, indexOfNextSep);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n\nexport class NewExplorerItem extends ExplorerItem {\n\tconstructor(parent: ExplorerItem, isDirectory: boolean) {\n\t\tsuper(URI.file(''), parent, isDirectory);\n\t}\n}"]}]}