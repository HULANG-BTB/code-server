{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/services/editorSimpleWorker.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/services/editorSimpleWorker.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/arrays\", \"vs/base/common/diff/diff\", \"vs/base/common/iterator\", \"vs/base/common/platform\", \"vs/base/common/uri\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\", \"vs/editor/common/diff/diffComputer\", \"vs/editor/common/model/mirrorTextModel\", \"vs/editor/common/model/wordHelper\", \"vs/editor/common/modes\", \"vs/editor/common/modes/linkComputer\", \"vs/editor/common/modes/supports/inplaceReplaceSupport\", \"vs/editor/common/standalone/standaloneBase\", \"vs/base/common/types\"], function (require, exports, arrays_1, diff_1, iterator_1, platform_1, uri_1, position_1, range_1, diffComputer_1, mirrorTextModel_1, wordHelper_1, modes_1, linkComputer_1, inplaceReplaceSupport_1, standaloneBase_1, types_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @internal\n     */\n    class MirrorModel extends mirrorTextModel_1.MirrorTextModel {\n        get uri() {\n            return this._uri;\n        }\n        get version() {\n            return this._versionId;\n        }\n        get eol() {\n            return this._eol;\n        }\n        getValue() {\n            return this.getText();\n        }\n        getLinesContent() {\n            return this._lines.slice(0);\n        }\n        getLineCount() {\n            return this._lines.length;\n        }\n        getLineContent(lineNumber) {\n            return this._lines[lineNumber - 1];\n        }\n        getWordAtPosition(position, wordDefinition) {\n            let wordAtText = wordHelper_1.getWordAtText(position.column, wordHelper_1.ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\n            if (wordAtText) {\n                return new range_1.Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n            }\n            return null;\n        }\n        getWordUntilPosition(position, wordDefinition) {\n            const wordAtPosition = this.getWordAtPosition(position, wordDefinition);\n            if (!wordAtPosition) {\n                return {\n                    word: '',\n                    startColumn: position.column,\n                    endColumn: position.column\n                };\n            }\n            return {\n                word: this._lines[position.lineNumber - 1].substring(wordAtPosition.startColumn - 1, position.column - 1),\n                startColumn: wordAtPosition.startColumn,\n                endColumn: position.column\n            };\n        }\n        createWordIterator(wordDefinition) {\n            let obj;\n            let lineNumber = 0;\n            let lineText;\n            let wordRangesIdx = 0;\n            let wordRanges = [];\n            let next = () => {\n                if (wordRangesIdx < wordRanges.length) {\n                    const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n                    wordRangesIdx += 1;\n                    if (!obj) {\n                        obj = { done: false, value: value };\n                    }\n                    else {\n                        obj.value = value;\n                    }\n                    return obj;\n                }\n                else if (lineNumber >= this._lines.length) {\n                    return iterator_1.FIN;\n                }\n                else {\n                    lineText = this._lines[lineNumber];\n                    wordRanges = this._wordenize(lineText, wordDefinition);\n                    wordRangesIdx = 0;\n                    lineNumber += 1;\n                    return next();\n                }\n            };\n            return { next };\n        }\n        getLineWords(lineNumber, wordDefinition) {\n            let content = this._lines[lineNumber - 1];\n            let ranges = this._wordenize(content, wordDefinition);\n            let words = [];\n            for (const range of ranges) {\n                words.push({\n                    word: content.substring(range.start, range.end),\n                    startColumn: range.start + 1,\n                    endColumn: range.end + 1\n                });\n            }\n            return words;\n        }\n        _wordenize(content, wordDefinition) {\n            const result = [];\n            let match;\n            wordDefinition.lastIndex = 0; // reset lastIndex just to be sure\n            while (match = wordDefinition.exec(content)) {\n                if (match[0].length === 0) {\n                    // it did match the empty string\n                    break;\n                }\n                result.push({ start: match.index, end: match.index + match[0].length });\n            }\n            return result;\n        }\n        getValueInRange(range) {\n            range = this._validateRange(range);\n            if (range.startLineNumber === range.endLineNumber) {\n                return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n            }\n            let lineEnding = this._eol;\n            let startLineIndex = range.startLineNumber - 1;\n            let endLineIndex = range.endLineNumber - 1;\n            let resultLines = [];\n            resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n            for (let i = startLineIndex + 1; i < endLineIndex; i++) {\n                resultLines.push(this._lines[i]);\n            }\n            resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n            return resultLines.join(lineEnding);\n        }\n        offsetAt(position) {\n            position = this._validatePosition(position);\n            this._ensureLineStarts();\n            return this._lineStarts.getAccumulatedValue(position.lineNumber - 2) + (position.column - 1);\n        }\n        positionAt(offset) {\n            offset = Math.floor(offset);\n            offset = Math.max(0, offset);\n            this._ensureLineStarts();\n            let out = this._lineStarts.getIndexOf(offset);\n            let lineLength = this._lines[out.index].length;\n            // Ensure we return a valid position\n            return {\n                lineNumber: 1 + out.index,\n                column: 1 + Math.min(out.remainder, lineLength)\n            };\n        }\n        _validateRange(range) {\n            const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\n            const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\n            if (start.lineNumber !== range.startLineNumber\n                || start.column !== range.startColumn\n                || end.lineNumber !== range.endLineNumber\n                || end.column !== range.endColumn) {\n                return {\n                    startLineNumber: start.lineNumber,\n                    startColumn: start.column,\n                    endLineNumber: end.lineNumber,\n                    endColumn: end.column\n                };\n            }\n            return range;\n        }\n        _validatePosition(position) {\n            if (!position_1.Position.isIPosition(position)) {\n                throw new Error('bad position');\n            }\n            let { lineNumber, column } = position;\n            let hasChanged = false;\n            if (lineNumber < 1) {\n                lineNumber = 1;\n                column = 1;\n                hasChanged = true;\n            }\n            else if (lineNumber > this._lines.length) {\n                lineNumber = this._lines.length;\n                column = this._lines[lineNumber - 1].length + 1;\n                hasChanged = true;\n            }\n            else {\n                let maxCharacter = this._lines[lineNumber - 1].length + 1;\n                if (column < 1) {\n                    column = 1;\n                    hasChanged = true;\n                }\n                else if (column > maxCharacter) {\n                    column = maxCharacter;\n                    hasChanged = true;\n                }\n            }\n            if (!hasChanged) {\n                return position;\n            }\n            else {\n                return { lineNumber, column };\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    class BaseEditorSimpleWorker {\n        constructor(foreignModuleFactory) {\n            this._foreignModuleFactory = foreignModuleFactory;\n            this._foreignModule = null;\n        }\n        // ---- BEGIN diff --------------------------------------------------------------------------\n        computeDiff(originalUrl, modifiedUrl, ignoreTrimWhitespace) {\n            const original = this._getModel(originalUrl);\n            const modified = this._getModel(modifiedUrl);\n            if (!original || !modified) {\n                return Promise.resolve(null);\n            }\n            const originalLines = original.getLinesContent();\n            const modifiedLines = modified.getLinesContent();\n            const diffComputer = new diffComputer_1.DiffComputer(originalLines, modifiedLines, {\n                shouldComputeCharChanges: true,\n                shouldPostProcessCharChanges: true,\n                shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\n                shouldMakePrettyDiff: true\n            });\n            const changes = diffComputer.computeDiff();\n            let identical = (changes.length > 0 ? false : this._modelsAreIdentical(original, modified));\n            return Promise.resolve({\n                identical: identical,\n                changes: changes\n            });\n        }\n        _modelsAreIdentical(original, modified) {\n            const originalLineCount = original.getLineCount();\n            const modifiedLineCount = modified.getLineCount();\n            if (originalLineCount !== modifiedLineCount) {\n                return false;\n            }\n            for (let line = 1; line <= originalLineCount; line++) {\n                const originalLine = original.getLineContent(line);\n                const modifiedLine = modified.getLineContent(line);\n                if (originalLine !== modifiedLine) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        computeDirtyDiff(originalUrl, modifiedUrl, ignoreTrimWhitespace) {\n            let original = this._getModel(originalUrl);\n            let modified = this._getModel(modifiedUrl);\n            if (!original || !modified) {\n                return Promise.resolve(null);\n            }\n            let originalLines = original.getLinesContent();\n            let modifiedLines = modified.getLinesContent();\n            let diffComputer = new diffComputer_1.DiffComputer(originalLines, modifiedLines, {\n                shouldComputeCharChanges: false,\n                shouldPostProcessCharChanges: false,\n                shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\n                shouldMakePrettyDiff: true\n            });\n            return Promise.resolve(diffComputer.computeDiff());\n        }\n        computeMoreMinimalEdits(modelUrl, edits) {\n            const model = this._getModel(modelUrl);\n            if (!model) {\n                return Promise.resolve(edits);\n            }\n            const result = [];\n            let lastEol = undefined;\n            edits = arrays_1.mergeSort(edits, (a, b) => {\n                if (a.range && b.range) {\n                    return range_1.Range.compareRangesUsingStarts(a.range, b.range);\n                }\n                // eol only changes should go to the end\n                let aRng = a.range ? 0 : 1;\n                let bRng = b.range ? 0 : 1;\n                return aRng - bRng;\n            });\n            for (let { range, text, eol } of edits) {\n                if (typeof eol === 'number') {\n                    lastEol = eol;\n                }\n                if (range_1.Range.isEmpty(range) && !text) {\n                    // empty change\n                    continue;\n                }\n                const original = model.getValueInRange(range);\n                text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n                if (original === text) {\n                    // noop\n                    continue;\n                }\n                // make sure diff won't take too long\n                if (Math.max(text.length, original.length) > BaseEditorSimpleWorker._diffLimit) {\n                    result.push({ range, text });\n                    continue;\n                }\n                // compute diff between original and edit.text\n                const changes = diff_1.stringDiff(original, text, false);\n                const editOffset = model.offsetAt(range_1.Range.lift(range).getStartPosition());\n                for (const change of changes) {\n                    const start = model.positionAt(editOffset + change.originalStart);\n                    const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n                    const newEdit = {\n                        text: text.substr(change.modifiedStart, change.modifiedLength),\n                        range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\n                    };\n                    if (model.getValueInRange(newEdit.range) !== newEdit.text) {\n                        result.push(newEdit);\n                    }\n                }\n            }\n            if (typeof lastEol === 'number') {\n                result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n            }\n            return Promise.resolve(result);\n        }\n        // ---- END minimal edits ---------------------------------------------------------------\n        computeLinks(modelUrl) {\n            let model = this._getModel(modelUrl);\n            if (!model) {\n                return Promise.resolve(null);\n            }\n            return Promise.resolve(linkComputer_1.computeLinks(model));\n        }\n        textualSuggest(modelUrl, position, wordDef, wordDefFlags) {\n            const model = this._getModel(modelUrl);\n            if (!model) {\n                return Promise.resolve(null);\n            }\n            const seen = Object.create(null);\n            const suggestions = [];\n            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n            const wordUntil = model.getWordUntilPosition(position, wordDefRegExp);\n            const wordAt = model.getWordAtPosition(position, wordDefRegExp);\n            if (wordAt) {\n                seen[model.getValueInRange(wordAt)] = true;\n            }\n            for (let iter = model.createWordIterator(wordDefRegExp), e = iter.next(); !e.done && suggestions.length <= BaseEditorSimpleWorker._suggestionsLimit; e = iter.next()) {\n                const word = e.value;\n                if (seen[word]) {\n                    continue;\n                }\n                seen[word] = true;\n                if (!isNaN(Number(word))) {\n                    continue;\n                }\n                suggestions.push({\n                    kind: modes_1.CompletionItemKind.Text,\n                    label: word,\n                    insertText: word,\n                    range: { startLineNumber: position.lineNumber, startColumn: wordUntil.startColumn, endLineNumber: position.lineNumber, endColumn: wordUntil.endColumn }\n                });\n            }\n            return Promise.resolve({ suggestions });\n        }\n        // ---- END suggest --------------------------------------------------------------------------\n        //#region -- word ranges --\n        computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\n            let model = this._getModel(modelUrl);\n            if (!model) {\n                return Promise.resolve(Object.create(null));\n            }\n            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n            const result = Object.create(null);\n            for (let line = range.startLineNumber; line < range.endLineNumber; line++) {\n                let words = model.getLineWords(line, wordDefRegExp);\n                for (const word of words) {\n                    if (!isNaN(Number(word.word))) {\n                        continue;\n                    }\n                    let array = result[word.word];\n                    if (!array) {\n                        array = [];\n                        result[word.word] = array;\n                    }\n                    array.push({\n                        startLineNumber: line,\n                        startColumn: word.startColumn,\n                        endLineNumber: line,\n                        endColumn: word.endColumn\n                    });\n                }\n            }\n            return Promise.resolve(result);\n        }\n        //#endregion\n        navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\n            let model = this._getModel(modelUrl);\n            if (!model) {\n                return Promise.resolve(null);\n            }\n            let wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n            if (range.startColumn === range.endColumn) {\n                range = {\n                    startLineNumber: range.startLineNumber,\n                    startColumn: range.startColumn,\n                    endLineNumber: range.endLineNumber,\n                    endColumn: range.endColumn + 1\n                };\n            }\n            let selectionText = model.getValueInRange(range);\n            let wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n            if (!wordRange) {\n                return Promise.resolve(null);\n            }\n            let word = model.getValueInRange(wordRange);\n            let result = inplaceReplaceSupport_1.BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n            return Promise.resolve(result);\n        }\n        // ---- BEGIN foreign module support --------------------------------------------------------------------------\n        loadForeignModule(moduleId, createData) {\n            let ctx = {\n                getMirrorModels: () => {\n                    return this._getModels();\n                }\n            };\n            if (this._foreignModuleFactory) {\n                this._foreignModule = this._foreignModuleFactory(ctx, createData);\n                // static foreing module\n                let methods = [];\n                for (const prop of types_1.getAllPropertyNames(this._foreignModule)) {\n                    if (typeof this._foreignModule[prop] === 'function') {\n                        methods.push(prop);\n                    }\n                }\n                return Promise.resolve(methods);\n            }\n            // ESM-comment-begin\n            return new Promise((resolve, reject) => {\n                require([moduleId], (foreignModule) => {\n                    this._foreignModule = foreignModule.create(ctx, createData);\n                    let methods = [];\n                    for (const prop of types_1.getAllPropertyNames(this._foreignModule)) {\n                        if (typeof this._foreignModule[prop] === 'function') {\n                            methods.push(prop);\n                        }\n                    }\n                    resolve(methods);\n                }, reject);\n            });\n            // ESM-comment-end\n            // ESM-uncomment-begin\n            // return Promise.reject(new Error(`Unexpected usage`));\n            // ESM-uncomment-end\n        }\n        // foreign method request\n        fmr(method, args) {\n            if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n                return Promise.reject(new Error('Missing requestHandler or method: ' + method));\n            }\n            try {\n                return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n            }\n            catch (e) {\n                return Promise.reject(e);\n            }\n        }\n    }\n    // ---- END diff --------------------------------------------------------------------------\n    // ---- BEGIN minimal edits ---------------------------------------------------------------\n    BaseEditorSimpleWorker._diffLimit = 10000;\n    // ---- BEGIN suggest --------------------------------------------------------------------------\n    BaseEditorSimpleWorker._suggestionsLimit = 10000;\n    exports.BaseEditorSimpleWorker = BaseEditorSimpleWorker;\n    /**\n     * @internal\n     */\n    class EditorSimpleWorkerImpl extends BaseEditorSimpleWorker {\n        constructor(foreignModuleFactory) {\n            super(foreignModuleFactory);\n            this._models = Object.create(null);\n        }\n        dispose() {\n            this._models = Object.create(null);\n        }\n        _getModel(uri) {\n            return this._models[uri];\n        }\n        _getModels() {\n            let all = [];\n            Object.keys(this._models).forEach((key) => all.push(this._models[key]));\n            return all;\n        }\n        acceptNewModel(data) {\n            this._models[data.url] = new MirrorModel(uri_1.URI.parse(data.url), data.lines, data.EOL, data.versionId);\n        }\n        acceptModelChanged(strURL, e) {\n            if (!this._models[strURL]) {\n                return;\n            }\n            let model = this._models[strURL];\n            model.onEvents(e);\n        }\n        acceptRemovedModel(strURL) {\n            if (!this._models[strURL]) {\n                return;\n            }\n            delete this._models[strURL];\n        }\n    }\n    exports.EditorSimpleWorkerImpl = EditorSimpleWorkerImpl;\n    /**\n     * Called on the worker side\n     * @internal\n     */\n    function create() {\n        return new EditorSimpleWorkerImpl(null);\n    }\n    exports.create = create;\n    if (typeof importScripts === 'function') {\n        // Running in a web worker\n        platform_1.globals.monaco = standaloneBase_1.createMonacoBaseAPI();\n    }\n});\n",null]}