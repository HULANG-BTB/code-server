{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/model/intervalTree.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/intervalTree.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar model_1 = require(\"vs/editor/common/model\");\n//\n// The red-black tree is based on the \"Introduction to Algorithms\" by Cormen, Leiserson and Rivest.\n//\nvar ClassName;\n(function (ClassName) {\n    ClassName[\"EditorHintDecoration\"] = \"squiggly-hint\";\n    ClassName[\"EditorInfoDecoration\"] = \"squiggly-info\";\n    ClassName[\"EditorWarningDecoration\"] = \"squiggly-warning\";\n    ClassName[\"EditorErrorDecoration\"] = \"squiggly-error\";\n    ClassName[\"EditorUnnecessaryDecoration\"] = \"squiggly-unnecessary\";\n    ClassName[\"EditorUnnecessaryInlineDecoration\"] = \"squiggly-inline-unnecessary\";\n})(ClassName = exports.ClassName || (exports.ClassName = {}));\nvar NodeColor;\n(function (NodeColor) {\n    NodeColor[NodeColor[\"Black\"] = 0] = \"Black\";\n    NodeColor[NodeColor[\"Red\"] = 1] = \"Red\";\n})(NodeColor = exports.NodeColor || (exports.NodeColor = {}));\nvar Constants;\n(function (Constants) {\n    Constants[Constants[\"ColorMask\"] = 1] = \"ColorMask\";\n    Constants[Constants[\"ColorMaskInverse\"] = 254] = \"ColorMaskInverse\";\n    Constants[Constants[\"ColorOffset\"] = 0] = \"ColorOffset\";\n    Constants[Constants[\"IsVisitedMask\"] = 2] = \"IsVisitedMask\";\n    Constants[Constants[\"IsVisitedMaskInverse\"] = 253] = \"IsVisitedMaskInverse\";\n    Constants[Constants[\"IsVisitedOffset\"] = 1] = \"IsVisitedOffset\";\n    Constants[Constants[\"IsForValidationMask\"] = 4] = \"IsForValidationMask\";\n    Constants[Constants[\"IsForValidationMaskInverse\"] = 251] = \"IsForValidationMaskInverse\";\n    Constants[Constants[\"IsForValidationOffset\"] = 2] = \"IsForValidationOffset\";\n    Constants[Constants[\"IsInOverviewRulerMask\"] = 8] = \"IsInOverviewRulerMask\";\n    Constants[Constants[\"IsInOverviewRulerMaskInverse\"] = 247] = \"IsInOverviewRulerMaskInverse\";\n    Constants[Constants[\"IsInOverviewRulerOffset\"] = 3] = \"IsInOverviewRulerOffset\";\n    Constants[Constants[\"StickinessMask\"] = 48] = \"StickinessMask\";\n    Constants[Constants[\"StickinessMaskInverse\"] = 207] = \"StickinessMaskInverse\";\n    Constants[Constants[\"StickinessOffset\"] = 4] = \"StickinessOffset\";\n    Constants[Constants[\"CollapseOnReplaceEditMask\"] = 64] = \"CollapseOnReplaceEditMask\";\n    Constants[Constants[\"CollapseOnReplaceEditMaskInverse\"] = 191] = \"CollapseOnReplaceEditMaskInverse\";\n    Constants[Constants[\"CollapseOnReplaceEditOffset\"] = 6] = \"CollapseOnReplaceEditOffset\";\n    /**\n     * Due to how deletion works (in order to avoid always walking the right subtree of the deleted node),\n     * the deltas for nodes can grow and shrink dramatically. It has been observed, in practice, that unless\n     * the deltas are corrected, integer overflow will occur.\n     *\n     * The integer overflow occurs when 53 bits are used in the numbers, but we will try to avoid it as\n     * a node's delta gets below a negative 30 bits number.\n     *\n     * MIN SMI (SMall Integer) as defined in v8.\n     * one bit is lost for boxing/unboxing flag.\n     * one bit is lost for sign flag.\n     * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n     */\n    Constants[Constants[\"MIN_SAFE_DELTA\"] = -1073741824] = \"MIN_SAFE_DELTA\";\n    /**\n     * MAX SMI (SMall Integer) as defined in v8.\n     * one bit is lost for boxing/unboxing flag.\n     * one bit is lost for sign flag.\n     * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n     */\n    Constants[Constants[\"MAX_SAFE_DELTA\"] = 1073741824] = \"MAX_SAFE_DELTA\";\n})(Constants || (Constants = {}));\nfunction getNodeColor(node) {\n    return ((node.metadata & Constants.ColorMask) >>> Constants.ColorOffset);\n}\nexports.getNodeColor = getNodeColor;\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & Constants.ColorMaskInverse) | (color << Constants.ColorOffset));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & Constants.IsVisitedMask) >>> Constants.IsVisitedOffset) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & Constants.IsVisitedMaskInverse) | ((value ? 1 : 0) << Constants.IsVisitedOffset));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & Constants.IsForValidationMask) >>> Constants.IsForValidationOffset) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & Constants.IsForValidationMaskInverse) | ((value ? 1 : 0) << Constants.IsForValidationOffset));\n}\nfunction getNodeIsInOverviewRuler(node) {\n    return ((node.metadata & Constants.IsInOverviewRulerMask) >>> Constants.IsInOverviewRulerOffset) === 1;\n}\nexports.getNodeIsInOverviewRuler = getNodeIsInOverviewRuler;\nfunction setNodeIsInOverviewRuler(node, value) {\n    node.metadata = ((node.metadata & Constants.IsInOverviewRulerMaskInverse) | ((value ? 1 : 0) << Constants.IsInOverviewRulerOffset));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & Constants.StickinessMask) >>> Constants.StickinessOffset);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & Constants.StickinessMaskInverse) | (stickiness << Constants.StickinessOffset));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & Constants.CollapseOnReplaceEditMask) >>> Constants.CollapseOnReplaceEditOffset) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & Constants.CollapseOnReplaceEditMaskInverse) | ((value ? 1 : 0) << Constants.CollapseOnReplaceEditOffset));\n}\nfunction setNodeStickiness(node, stickiness) {\n    _setNodeStickiness(node, stickiness);\n}\nexports.setNodeStickiness = setNodeStickiness;\nvar IntervalNode = /** @class */ (function () {\n    function IntervalNode(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, NodeColor.Red);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        _setNodeStickiness(this, model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges);\n        setNodeIsInOverviewRuler(this, false);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    IntervalNode.prototype.reset = function (versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    };\n    IntervalNode.prototype.setOptions = function (options) {\n        this.options = options;\n        var className = this.options.className;\n        setNodeIsForValidation(this, (className === ClassName.EditorErrorDecoration\n            || className === ClassName.EditorWarningDecoration\n            || className === ClassName.EditorInfoDecoration));\n        _setNodeStickiness(this, this.options.stickiness);\n        setNodeIsInOverviewRuler(this, (this.options.overviewRuler && this.options.overviewRuler.color) ? true : false);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    };\n    IntervalNode.prototype.setCachedOffsets = function (absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    };\n    IntervalNode.prototype.detach = function () {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    };\n    return IntervalNode;\n}());\nexports.IntervalNode = IntervalNode;\nexports.SENTINEL = new IntervalNode(null, 0, 0);\nexports.SENTINEL.parent = exports.SENTINEL;\nexports.SENTINEL.left = exports.SENTINEL;\nexports.SENTINEL.right = exports.SENTINEL;\nsetNodeColor(exports.SENTINEL, NodeColor.Black);\nvar IntervalTree = /** @class */ (function () {\n    function IntervalTree() {\n        this.root = exports.SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    IntervalTree.prototype.intervalSearch = function (start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n        if (this.root === exports.SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n    };\n    IntervalTree.prototype.search = function (filterOwnerId, filterOutValidation, cachedVersionId) {\n        if (this.root === exports.SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\n    };\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    IntervalTree.prototype.collectNodesFromOwner = function (ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    };\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    IntervalTree.prototype.collectNodesPostOrder = function () {\n        return collectNodesPostOrder(this);\n    };\n    IntervalTree.prototype.insert = function (node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    };\n    IntervalTree.prototype.delete = function (node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    };\n    IntervalTree.prototype.resolveNode = function (node, cachedVersionId) {\n        var initialNode = node;\n        var delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        var nodeStart = initialNode.start + delta;\n        var nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    };\n    IntervalTree.prototype.acceptReplace = function (offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        var nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (var i = 0, len = nodesOfInterest.length; i < len; i++) {\n            var node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (var i = 0, len = nodesOfInterest.length; i < len; i++) {\n            var node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    };\n    IntervalTree.prototype.getAllInOrder = function () {\n        return search(this, 0, false, 0);\n    };\n    IntervalTree.prototype._normalizeDeltaIfNecessary = function () {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    };\n    return IntervalTree;\n}());\nexports.IntervalTree = IntervalTree;\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    var node = T.root;\n    var delta = 0;\n    while (node !== exports.SENTINEL) {\n        if (node.left !== exports.SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Editing\nvar MarkerMoveSemantics;\n(function (MarkerMoveSemantics) {\n    MarkerMoveSemantics[MarkerMoveSemantics[\"MarkerDefined\"] = 0] = \"MarkerDefined\";\n    MarkerMoveSemantics[MarkerMoveSemantics[\"ForceMove\"] = 1] = \"ForceMove\";\n    MarkerMoveSemantics[MarkerMoveSemantics[\"ForceStay\"] = 2] = \"ForceStay\";\n})(MarkerMoveSemantics || (MarkerMoveSemantics = {}));\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === MarkerMoveSemantics.ForceMove) {\n        return false;\n    }\n    if (moveSemantics === MarkerMoveSemantics.ForceStay) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nfunction nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    var nodeStickiness = getNodeStickiness(node);\n    var startStickToPreviousCharacter = (nodeStickiness === model_1.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges\n        || nodeStickiness === model_1.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore);\n    var endStickToPreviousCharacter = (nodeStickiness === model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges\n        || nodeStickiness === model_1.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore);\n    var deletingCnt = (end - start);\n    var insertingCnt = textLength;\n    var commonLength = Math.min(deletingCnt, insertingCnt);\n    var nodeStart = node.start;\n    var startDone = false;\n    var nodeEnd = node.end;\n    var endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        var moveSemantics = forceMoveMarkers ? MarkerMoveSemantics.ForceMove : (deletingCnt > 0 ? MarkerMoveSemantics.ForceStay : MarkerMoveSemantics.MarkerDefined);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        var moveSemantics = (deletingCnt > insertingCnt ? MarkerMoveSemantics.ForceStay : MarkerMoveSemantics.MarkerDefined);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        var moveSemantics = forceMoveMarkers ? MarkerMoveSemantics.ForceMove : MarkerMoveSemantics.MarkerDefined;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    var deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nexports.nodeAcceptEdit = nodeAcceptEdit;\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    var node = T.root;\n    var delta = 0;\n    var nodeMaxEnd = 0;\n    var nodeStart = 0;\n    var nodeEnd = 0;\n    var result = [];\n    var resultLen = 0;\n    while (node !== exports.SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== exports.SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    var node = T.root;\n    var delta = 0;\n    var nodeMaxEnd = 0;\n    var nodeStart = 0;\n    var editDelta = (textLength - (end - start));\n    while (node !== exports.SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== exports.SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < Constants.MIN_SAFE_DELTA || node.delta > Constants.MAX_SAFE_DELTA) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    var node = T.root;\n    var result = [];\n    var resultLen = 0;\n    while (node !== exports.SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== exports.SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    var node = T.root;\n    var result = [];\n    var resultLen = 0;\n    while (node !== exports.SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== exports.SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\n    var node = T.root;\n    var delta = 0;\n    var nodeStart = 0;\n    var nodeEnd = 0;\n    var result = [];\n    var resultLen = 0;\n    while (node !== exports.SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== exports.SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        var include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    var node = T.root;\n    var delta = 0;\n    var nodeMaxEnd = 0;\n    var nodeStart = 0;\n    var nodeEnd = 0;\n    var result = [];\n    var resultLen = 0;\n    while (node !== exports.SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== exports.SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            var include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === exports.SENTINEL) {\n        newNode.parent = exports.SENTINEL;\n        newNode.left = exports.SENTINEL;\n        newNode.right = exports.SENTINEL;\n        setNodeColor(newNode, NodeColor.Black);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    var x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === NodeColor.Red) {\n        if (x.parent === x.parent.parent.left) {\n            var y = x.parent.parent.right;\n            if (getNodeColor(y) === NodeColor.Red) {\n                setNodeColor(x.parent, NodeColor.Black);\n                setNodeColor(y, NodeColor.Black);\n                setNodeColor(x.parent.parent, NodeColor.Red);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, NodeColor.Black);\n                setNodeColor(x.parent.parent, NodeColor.Red);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            var y = x.parent.parent.left;\n            if (getNodeColor(y) === NodeColor.Red) {\n                setNodeColor(x.parent, NodeColor.Black);\n                setNodeColor(y, NodeColor.Black);\n                setNodeColor(x.parent.parent, NodeColor.Red);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, NodeColor.Black);\n                setNodeColor(x.parent.parent, NodeColor.Red);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, NodeColor.Black);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    var delta = 0;\n    var x = T.root;\n    var zAbsoluteStart = z.start;\n    var zAbsoluteEnd = z.end;\n    while (true) {\n        var cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === exports.SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === exports.SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = exports.SENTINEL;\n    z.right = exports.SENTINEL;\n    setNodeColor(z, NodeColor.Red);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    var x;\n    var y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === exports.SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === exports.SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, NodeColor.Black);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = exports.SENTINEL;\n        return;\n    }\n    var yWasRed = (getNodeColor(y) === NodeColor.Red);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== exports.SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== exports.SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    var w;\n    while (x !== T.root && getNodeColor(x) === NodeColor.Black) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === NodeColor.Red) {\n                setNodeColor(w, NodeColor.Black);\n                setNodeColor(x.parent, NodeColor.Red);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {\n                setNodeColor(w, NodeColor.Red);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === NodeColor.Black) {\n                    setNodeColor(w.left, NodeColor.Black);\n                    setNodeColor(w, NodeColor.Red);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, NodeColor.Black);\n                setNodeColor(w.right, NodeColor.Black);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === NodeColor.Red) {\n                setNodeColor(w, NodeColor.Black);\n                setNodeColor(x.parent, NodeColor.Red);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {\n                setNodeColor(w, NodeColor.Red);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === NodeColor.Black) {\n                    setNodeColor(w.right, NodeColor.Black);\n                    setNodeColor(w, NodeColor.Red);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, NodeColor.Black);\n                setNodeColor(w.left, NodeColor.Black);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, NodeColor.Black);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== exports.SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    exports.SENTINEL.parent = exports.SENTINEL;\n    exports.SENTINEL.delta = 0; // optional\n    exports.SENTINEL.start = 0; // optional\n    exports.SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    var y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== exports.SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === exports.SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    var x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== exports.SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === exports.SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    var maxEnd = node.end;\n    if (node.left !== exports.SENTINEL) {\n        var leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== exports.SENTINEL) {\n        var rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nfunction recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nexports.recomputeMaxEnd = recomputeMaxEnd;\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== exports.SENTINEL) {\n        var maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nfunction intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\nexports.intervalCompare = intervalCompare;\n//#endregion\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/intervalTree.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/model/intervalTree.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Range } from 'vs/editor/common/core/range';\nimport { IModelDecoration, TrackedRangeStickiness, TrackedRangeStickiness as ActualTrackedRangeStickiness } from 'vs/editor/common/model';\nimport { ModelDecorationOptions } from 'vs/editor/common/model/textModel';\n\n//\n// The red-black tree is based on the \"Introduction to Algorithms\" by Cormen, Leiserson and Rivest.\n//\n\nexport const enum ClassName {\n\tEditorHintDecoration = 'squiggly-hint',\n\tEditorInfoDecoration = 'squiggly-info',\n\tEditorWarningDecoration = 'squiggly-warning',\n\tEditorErrorDecoration = 'squiggly-error',\n\tEditorUnnecessaryDecoration = 'squiggly-unnecessary',\n\tEditorUnnecessaryInlineDecoration = 'squiggly-inline-unnecessary'\n}\n\nexport const enum NodeColor {\n\tBlack = 0,\n\tRed = 1,\n}\n\nconst enum Constants {\n\tColorMask = 0b00000001,\n\tColorMaskInverse = 0b11111110,\n\tColorOffset = 0,\n\n\tIsVisitedMask = 0b00000010,\n\tIsVisitedMaskInverse = 0b11111101,\n\tIsVisitedOffset = 1,\n\n\tIsForValidationMask = 0b00000100,\n\tIsForValidationMaskInverse = 0b11111011,\n\tIsForValidationOffset = 2,\n\n\tIsInOverviewRulerMask = 0b00001000,\n\tIsInOverviewRulerMaskInverse = 0b11110111,\n\tIsInOverviewRulerOffset = 3,\n\n\tStickinessMask = 0b00110000,\n\tStickinessMaskInverse = 0b11001111,\n\tStickinessOffset = 4,\n\n\tCollapseOnReplaceEditMask = 0b01000000,\n\tCollapseOnReplaceEditMaskInverse = 0b10111111,\n\tCollapseOnReplaceEditOffset = 6,\n\n\t/**\n\t * Due to how deletion works (in order to avoid always walking the right subtree of the deleted node),\n\t * the deltas for nodes can grow and shrink dramatically. It has been observed, in practice, that unless\n\t * the deltas are corrected, integer overflow will occur.\n\t *\n\t * The integer overflow occurs when 53 bits are used in the numbers, but we will try to avoid it as\n\t * a node's delta gets below a negative 30 bits number.\n\t *\n\t * MIN SMI (SMall Integer) as defined in v8.\n\t * one bit is lost for boxing/unboxing flag.\n\t * one bit is lost for sign flag.\n\t * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n\t */\n\tMIN_SAFE_DELTA = -(1 << 30),\n\t/**\n\t * MAX SMI (SMall Integer) as defined in v8.\n\t * one bit is lost for boxing/unboxing flag.\n\t * one bit is lost for sign flag.\n\t * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n\t */\n\tMAX_SAFE_DELTA = 1 << 30,\n}\n\nexport function getNodeColor(node: IntervalNode): NodeColor {\n\treturn ((node.metadata & Constants.ColorMask) >>> Constants.ColorOffset);\n}\nfunction setNodeColor(node: IntervalNode, color: NodeColor): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.ColorMaskInverse) | (color << Constants.ColorOffset)\n\t);\n}\nfunction getNodeIsVisited(node: IntervalNode): boolean {\n\treturn ((node.metadata & Constants.IsVisitedMask) >>> Constants.IsVisitedOffset) === 1;\n}\nfunction setNodeIsVisited(node: IntervalNode, value: boolean): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.IsVisitedMaskInverse) | ((value ? 1 : 0) << Constants.IsVisitedOffset)\n\t);\n}\nfunction getNodeIsForValidation(node: IntervalNode): boolean {\n\treturn ((node.metadata & Constants.IsForValidationMask) >>> Constants.IsForValidationOffset) === 1;\n}\nfunction setNodeIsForValidation(node: IntervalNode, value: boolean): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.IsForValidationMaskInverse) | ((value ? 1 : 0) << Constants.IsForValidationOffset)\n\t);\n}\nexport function getNodeIsInOverviewRuler(node: IntervalNode): boolean {\n\treturn ((node.metadata & Constants.IsInOverviewRulerMask) >>> Constants.IsInOverviewRulerOffset) === 1;\n}\nfunction setNodeIsInOverviewRuler(node: IntervalNode, value: boolean): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.IsInOverviewRulerMaskInverse) | ((value ? 1 : 0) << Constants.IsInOverviewRulerOffset)\n\t);\n}\nfunction getNodeStickiness(node: IntervalNode): TrackedRangeStickiness {\n\treturn ((node.metadata & Constants.StickinessMask) >>> Constants.StickinessOffset);\n}\nfunction _setNodeStickiness(node: IntervalNode, stickiness: TrackedRangeStickiness): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.StickinessMaskInverse) | (stickiness << Constants.StickinessOffset)\n\t);\n}\nfunction getCollapseOnReplaceEdit(node: IntervalNode): boolean {\n\treturn ((node.metadata & Constants.CollapseOnReplaceEditMask) >>> Constants.CollapseOnReplaceEditOffset) === 1;\n}\nfunction setCollapseOnReplaceEdit(node: IntervalNode, value: boolean): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.CollapseOnReplaceEditMaskInverse) | ((value ? 1 : 0) << Constants.CollapseOnReplaceEditOffset)\n\t);\n}\nexport function setNodeStickiness(node: IntervalNode, stickiness: ActualTrackedRangeStickiness): void {\n\t_setNodeStickiness(node, <number>stickiness);\n}\n\nexport class IntervalNode implements IModelDecoration {\n\n\t/**\n\t * contains binary encoded information for color, visited, isForValidation and stickiness.\n\t */\n\tpublic metadata: number;\n\n\tpublic parent: IntervalNode;\n\tpublic left: IntervalNode;\n\tpublic right: IntervalNode;\n\n\tpublic start: number;\n\tpublic end: number;\n\tpublic delta: number;\n\tpublic maxEnd: number;\n\n\tpublic id: string;\n\tpublic ownerId: number;\n\tpublic options: ModelDecorationOptions;\n\n\tpublic cachedVersionId: number;\n\tpublic cachedAbsoluteStart: number;\n\tpublic cachedAbsoluteEnd: number;\n\tpublic range: Range;\n\n\tconstructor(id: string, start: number, end: number) {\n\t\tthis.metadata = 0;\n\n\t\tthis.parent = this;\n\t\tthis.left = this;\n\t\tthis.right = this;\n\t\tsetNodeColor(this, NodeColor.Red);\n\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\t// FORCE_OVERFLOWING_TEST: this.delta = start;\n\t\tthis.delta = 0;\n\t\tthis.maxEnd = end;\n\n\t\tthis.id = id;\n\t\tthis.ownerId = 0;\n\t\tthis.options = null!;\n\t\tsetNodeIsForValidation(this, false);\n\t\t_setNodeStickiness(this, TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges);\n\t\tsetNodeIsInOverviewRuler(this, false);\n\t\tsetCollapseOnReplaceEdit(this, false);\n\n\t\tthis.cachedVersionId = 0;\n\t\tthis.cachedAbsoluteStart = start;\n\t\tthis.cachedAbsoluteEnd = end;\n\t\tthis.range = null!;\n\n\t\tsetNodeIsVisited(this, false);\n\t}\n\n\tpublic reset(versionId: number, start: number, end: number, range: Range): void {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.maxEnd = end;\n\t\tthis.cachedVersionId = versionId;\n\t\tthis.cachedAbsoluteStart = start;\n\t\tthis.cachedAbsoluteEnd = end;\n\t\tthis.range = range;\n\t}\n\n\tpublic setOptions(options: ModelDecorationOptions) {\n\t\tthis.options = options;\n\t\tlet className = this.options.className;\n\t\tsetNodeIsForValidation(this, (\n\t\t\tclassName === ClassName.EditorErrorDecoration\n\t\t\t|| className === ClassName.EditorWarningDecoration\n\t\t\t|| className === ClassName.EditorInfoDecoration\n\t\t));\n\t\t_setNodeStickiness(this, <number>this.options.stickiness);\n\t\tsetNodeIsInOverviewRuler(this, (this.options.overviewRuler && this.options.overviewRuler.color) ? true : false);\n\t\tsetCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n\t}\n\n\tpublic setCachedOffsets(absoluteStart: number, absoluteEnd: number, cachedVersionId: number): void {\n\t\tif (this.cachedVersionId !== cachedVersionId) {\n\t\t\tthis.range = null!;\n\t\t}\n\t\tthis.cachedVersionId = cachedVersionId;\n\t\tthis.cachedAbsoluteStart = absoluteStart;\n\t\tthis.cachedAbsoluteEnd = absoluteEnd;\n\t}\n\n\tpublic detach(): void {\n\t\tthis.parent = null!;\n\t\tthis.left = null!;\n\t\tthis.right = null!;\n\t}\n}\n\nexport const SENTINEL: IntervalNode = new IntervalNode(null!, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, NodeColor.Black);\n\nexport class IntervalTree {\n\n\tpublic root: IntervalNode;\n\tpublic requestNormalizeDelta: boolean;\n\n\tconstructor() {\n\t\tthis.root = SENTINEL;\n\t\tthis.requestNormalizeDelta = false;\n\t}\n\n\tpublic intervalSearch(start: number, end: number, filterOwnerId: number, filterOutValidation: boolean, cachedVersionId: number): IntervalNode[] {\n\t\tif (this.root === SENTINEL) {\n\t\t\treturn [];\n\t\t}\n\t\treturn intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n\t}\n\n\tpublic search(filterOwnerId: number, filterOutValidation: boolean, cachedVersionId: number): IntervalNode[] {\n\t\tif (this.root === SENTINEL) {\n\t\t\treturn [];\n\t\t}\n\t\treturn search(this, filterOwnerId, filterOutValidation, cachedVersionId);\n\t}\n\n\t/**\n\t * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n\t */\n\tpublic collectNodesFromOwner(ownerId: number): IntervalNode[] {\n\t\treturn collectNodesFromOwner(this, ownerId);\n\t}\n\n\t/**\n\t * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n\t */\n\tpublic collectNodesPostOrder(): IntervalNode[] {\n\t\treturn collectNodesPostOrder(this);\n\t}\n\n\tpublic insert(node: IntervalNode): void {\n\t\trbTreeInsert(this, node);\n\t\tthis._normalizeDeltaIfNecessary();\n\t}\n\n\tpublic delete(node: IntervalNode): void {\n\t\trbTreeDelete(this, node);\n\t\tthis._normalizeDeltaIfNecessary();\n\t}\n\n\tpublic resolveNode(node: IntervalNode, cachedVersionId: number): void {\n\t\tconst initialNode = node;\n\t\tlet delta = 0;\n\t\twhile (node !== this.root) {\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta += node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\tconst nodeStart = initialNode.start + delta;\n\t\tconst nodeEnd = initialNode.end + delta;\n\t\tinitialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n\t}\n\n\tpublic acceptReplace(offset: number, length: number, textLength: number, forceMoveMarkers: boolean): void {\n\t\t// Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n\n\t\t// (1) collect all nodes that are intersecting this edit as nodes of interest\n\t\tconst nodesOfInterest = searchForEditing(this, offset, offset + length);\n\n\t\t// (2) remove all nodes that are intersecting this edit\n\t\tfor (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n\t\t\tconst node = nodesOfInterest[i];\n\t\t\trbTreeDelete(this, node);\n\t\t}\n\t\tthis._normalizeDeltaIfNecessary();\n\n\t\t// (3) edit all tree nodes except the nodes of interest\n\t\tnoOverlapReplace(this, offset, offset + length, textLength);\n\t\tthis._normalizeDeltaIfNecessary();\n\n\t\t// (4) edit the nodes of interest and insert them back in the tree\n\t\tfor (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n\t\t\tconst node = nodesOfInterest[i];\n\t\t\tnode.start = node.cachedAbsoluteStart;\n\t\t\tnode.end = node.cachedAbsoluteEnd;\n\t\t\tnodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n\t\t\tnode.maxEnd = node.end;\n\t\t\trbTreeInsert(this, node);\n\t\t}\n\t\tthis._normalizeDeltaIfNecessary();\n\t}\n\n\tpublic getAllInOrder(): IntervalNode[] {\n\t\treturn search(this, 0, false, 0);\n\t}\n\n\tprivate _normalizeDeltaIfNecessary(): void {\n\t\tif (!this.requestNormalizeDelta) {\n\t\t\treturn;\n\t\t}\n\t\tthis.requestNormalizeDelta = false;\n\t\tnormalizeDelta(this);\n\t}\n}\n\n//#region Delta Normalization\nfunction normalizeDelta(T: IntervalTree): void {\n\tlet node = T.root;\n\tlet delta = 0;\n\twhile (node !== SENTINEL) {\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tnode.start = delta + node.start;\n\t\tnode.end = delta + node.end;\n\t\tnode.delta = 0;\n\t\trecomputeMaxEnd(node);\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\t// going up from this node\n\t\tsetNodeIsVisited(node.left, false);\n\t\tsetNodeIsVisited(node.right, false);\n\t\tif (node === node.parent.right) {\n\t\t\tdelta -= node.parent.delta;\n\t\t}\n\t\tnode = node.parent;\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n}\n//#endregion\n\n//#region Editing\n\nconst enum MarkerMoveSemantics {\n\tMarkerDefined = 0,\n\tForceMove = 1,\n\tForceStay = 2\n}\n\nfunction adjustMarkerBeforeColumn(markerOffset: number, markerStickToPreviousCharacter: boolean, checkOffset: number, moveSemantics: MarkerMoveSemantics): boolean {\n\tif (markerOffset < checkOffset) {\n\t\treturn true;\n\t}\n\tif (markerOffset > checkOffset) {\n\t\treturn false;\n\t}\n\tif (moveSemantics === MarkerMoveSemantics.ForceMove) {\n\t\treturn false;\n\t}\n\tif (moveSemantics === MarkerMoveSemantics.ForceStay) {\n\t\treturn true;\n\t}\n\treturn markerStickToPreviousCharacter;\n}\n\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node: IntervalNode, start: number, end: number, textLength: number, forceMoveMarkers: boolean): void {\n\tconst nodeStickiness = getNodeStickiness(node);\n\tconst startStickToPreviousCharacter = (\n\t\tnodeStickiness === TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges\n\t\t|| nodeStickiness === TrackedRangeStickiness.GrowsOnlyWhenTypingBefore\n\t);\n\tconst endStickToPreviousCharacter = (\n\t\tnodeStickiness === TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges\n\t\t|| nodeStickiness === TrackedRangeStickiness.GrowsOnlyWhenTypingBefore\n\t);\n\n\tconst deletingCnt = (end - start);\n\tconst insertingCnt = textLength;\n\tconst commonLength = Math.min(deletingCnt, insertingCnt);\n\n\tconst nodeStart = node.start;\n\tlet startDone = false;\n\n\tconst nodeEnd = node.end;\n\tlet endDone = false;\n\n\tif (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n\t\t// This edit encompasses the entire decoration range\n\t\t// and the decoration has asked to become collapsed\n\t\tnode.start = start;\n\t\tstartDone = true;\n\t\tnode.end = start;\n\t\tendDone = true;\n\t}\n\n\t{\n\t\tconst moveSemantics = forceMoveMarkers ? MarkerMoveSemantics.ForceMove : (deletingCnt > 0 ? MarkerMoveSemantics.ForceStay : MarkerMoveSemantics.MarkerDefined);\n\t\tif (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n\t\t\tstartDone = true;\n\t\t}\n\t\tif (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n\t\t\tendDone = true;\n\t\t}\n\t}\n\n\tif (commonLength > 0 && !forceMoveMarkers) {\n\t\tconst moveSemantics = (deletingCnt > insertingCnt ? MarkerMoveSemantics.ForceStay : MarkerMoveSemantics.MarkerDefined);\n\t\tif (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n\t\t\tstartDone = true;\n\t\t}\n\t\tif (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n\t\t\tendDone = true;\n\t\t}\n\t}\n\n\t{\n\t\tconst moveSemantics = forceMoveMarkers ? MarkerMoveSemantics.ForceMove : MarkerMoveSemantics.MarkerDefined;\n\t\tif (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n\t\t\tnode.start = start + insertingCnt;\n\t\t\tstartDone = true;\n\t\t}\n\t\tif (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n\t\t\tnode.end = start + insertingCnt;\n\t\t\tendDone = true;\n\t\t}\n\t}\n\n\t// Finish\n\tconst deltaColumn = (insertingCnt - deletingCnt);\n\tif (!startDone) {\n\t\tnode.start = Math.max(0, nodeStart + deltaColumn);\n\t}\n\tif (!endDone) {\n\t\tnode.end = Math.max(0, nodeEnd + deltaColumn);\n\t}\n\n\tif (node.start > node.end) {\n\t\tnode.end = node.start;\n\t}\n}\n\nfunction searchForEditing(T: IntervalTree, start: number, end: number): IntervalNode[] {\n\t// https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n\t// Now, it is known that two intervals A and B overlap only when both\n\t// A.low <= B.high and A.high >= B.low. When searching the trees for\n\t// nodes overlapping with a given interval, you can immediately skip:\n\t//  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n\t//  b) all nodes that have their maximum 'high' value below the start of the given interval.\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeMaxEnd = 0;\n\tlet nodeStart = 0;\n\tlet nodeEnd = 0;\n\tlet result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!getNodeIsVisited(node.left)) {\n\t\t\t// first time seeing this node\n\t\t\tnodeMaxEnd = delta + node.maxEnd;\n\t\t\tif (nodeMaxEnd < start) {\n\t\t\t\t// cover case b) from above\n\t\t\t\t// there is no need to search this node or its children\n\t\t\t\tsetNodeIsVisited(node, true);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (node.left !== SENTINEL) {\n\t\t\t\t// go left\n\t\t\t\tnode = node.left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tif (nodeStart > end) {\n\t\t\t// cover case a) from above\n\t\t\t// there is no need to search this node or its right subtree\n\t\t\tsetNodeIsVisited(node, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnodeEnd = delta + node.end;\n\t\tif (nodeEnd >= start) {\n\t\t\tnode.setCachedOffsets(nodeStart, nodeEnd, 0);\n\t\t\tresult[resultLen++] = node;\n\t\t}\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction noOverlapReplace(T: IntervalTree, start: number, end: number, textLength: number): void {\n\t// https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n\t// Now, it is known that two intervals A and B overlap only when both\n\t// A.low <= B.high and A.high >= B.low. When searching the trees for\n\t// nodes overlapping with a given interval, you can immediately skip:\n\t//  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n\t//  b) all nodes that have their maximum 'high' value below the start of the given interval.\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeMaxEnd = 0;\n\tlet nodeStart = 0;\n\tconst editDelta = (textLength - (end - start));\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\trecomputeMaxEnd(node);\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!getNodeIsVisited(node.left)) {\n\t\t\t// first time seeing this node\n\t\t\tnodeMaxEnd = delta + node.maxEnd;\n\t\t\tif (nodeMaxEnd < start) {\n\t\t\t\t// cover case b) from above\n\t\t\t\t// there is no need to search this node or its children\n\t\t\t\tsetNodeIsVisited(node, true);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (node.left !== SENTINEL) {\n\t\t\t\t// go left\n\t\t\t\tnode = node.left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tif (nodeStart > end) {\n\t\t\tnode.start += editDelta;\n\t\t\tnode.end += editDelta;\n\t\t\tnode.delta += editDelta;\n\t\t\tif (node.delta < Constants.MIN_SAFE_DELTA || node.delta > Constants.MAX_SAFE_DELTA) {\n\t\t\t\tT.requestNormalizeDelta = true;\n\t\t\t}\n\t\t\t// cover case a) from above\n\t\t\t// there is no need to search this node or its right subtree\n\t\t\tsetNodeIsVisited(node, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n}\n\n//#endregion\n\n//#region Searching\n\nfunction collectNodesFromOwner(T: IntervalTree, ownerId: number): IntervalNode[] {\n\tlet node = T.root;\n\tlet result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tif (node.ownerId === ownerId) {\n\t\t\tresult[resultLen++] = node;\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction collectNodesPostOrder(T: IntervalTree): IntervalNode[] {\n\tlet node = T.root;\n\tlet result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tresult[resultLen++] = node;\n\t\tsetNodeIsVisited(node, true);\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction search(T: IntervalTree, filterOwnerId: number, filterOutValidation: boolean, cachedVersionId: number): IntervalNode[] {\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeStart = 0;\n\tlet nodeEnd = 0;\n\tlet result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tnodeEnd = delta + node.end;\n\n\t\tnode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n\n\t\tlet include = true;\n\t\tif (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n\t\t\tinclude = false;\n\t\t}\n\t\tif (filterOutValidation && getNodeIsForValidation(node)) {\n\t\t\tinclude = false;\n\t\t}\n\t\tif (include) {\n\t\t\tresult[resultLen++] = node;\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction intervalSearch(T: IntervalTree, intervalStart: number, intervalEnd: number, filterOwnerId: number, filterOutValidation: boolean, cachedVersionId: number): IntervalNode[] {\n\t// https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n\t// Now, it is known that two intervals A and B overlap only when both\n\t// A.low <= B.high and A.high >= B.low. When searching the trees for\n\t// nodes overlapping with a given interval, you can immediately skip:\n\t//  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n\t//  b) all nodes that have their maximum 'high' value below the start of the given interval.\n\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeMaxEnd = 0;\n\tlet nodeStart = 0;\n\tlet nodeEnd = 0;\n\tlet result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!getNodeIsVisited(node.left)) {\n\t\t\t// first time seeing this node\n\t\t\tnodeMaxEnd = delta + node.maxEnd;\n\t\t\tif (nodeMaxEnd < intervalStart) {\n\t\t\t\t// cover case b) from above\n\t\t\t\t// there is no need to search this node or its children\n\t\t\t\tsetNodeIsVisited(node, true);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (node.left !== SENTINEL) {\n\t\t\t\t// go left\n\t\t\t\tnode = node.left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tif (nodeStart > intervalEnd) {\n\t\t\t// cover case a) from above\n\t\t\t// there is no need to search this node or its right subtree\n\t\t\tsetNodeIsVisited(node, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnodeEnd = delta + node.end;\n\n\t\tif (nodeEnd >= intervalStart) {\n\t\t\t// There is overlap\n\t\t\tnode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n\n\t\t\tlet include = true;\n\t\t\tif (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n\t\t\t\tinclude = false;\n\t\t\t}\n\t\t\tif (filterOutValidation && getNodeIsForValidation(node)) {\n\t\t\t\tinclude = false;\n\t\t\t}\n\n\t\t\tif (include) {\n\t\t\t\tresult[resultLen++] = node;\n\t\t\t}\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\n//#endregion\n\n//#region Insertion\nfunction rbTreeInsert(T: IntervalTree, newNode: IntervalNode): IntervalNode {\n\tif (T.root === SENTINEL) {\n\t\tnewNode.parent = SENTINEL;\n\t\tnewNode.left = SENTINEL;\n\t\tnewNode.right = SENTINEL;\n\t\tsetNodeColor(newNode, NodeColor.Black);\n\t\tT.root = newNode;\n\t\treturn T.root;\n\t}\n\n\ttreeInsert(T, newNode);\n\n\trecomputeMaxEndWalkToRoot(newNode.parent);\n\n\t// repair tree\n\tlet x = newNode;\n\twhile (x !== T.root && getNodeColor(x.parent) === NodeColor.Red) {\n\t\tif (x.parent === x.parent.parent.left) {\n\t\t\tconst y = x.parent.parent.right;\n\n\t\t\tif (getNodeColor(y) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(y, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\tx = x.parent.parent;\n\t\t\t} else {\n\t\t\t\tif (x === x.parent.right) {\n\t\t\t\t\tx = x.parent;\n\t\t\t\t\tleftRotate(T, x);\n\t\t\t\t}\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\trightRotate(T, x.parent.parent);\n\t\t\t}\n\t\t} else {\n\t\t\tconst y = x.parent.parent.left;\n\n\t\t\tif (getNodeColor(y) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(y, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\tx = x.parent.parent;\n\t\t\t} else {\n\t\t\t\tif (x === x.parent.left) {\n\t\t\t\t\tx = x.parent;\n\t\t\t\t\trightRotate(T, x);\n\t\t\t\t}\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\tleftRotate(T, x.parent.parent);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetNodeColor(T.root, NodeColor.Black);\n\n\treturn newNode;\n}\n\nfunction treeInsert(T: IntervalTree, z: IntervalNode): void {\n\tlet delta: number = 0;\n\tlet x = T.root;\n\tconst zAbsoluteStart = z.start;\n\tconst zAbsoluteEnd = z.end;\n\twhile (true) {\n\t\tconst cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n\t\tif (cmp < 0) {\n\t\t\t// this node should be inserted to the left\n\t\t\t// => it is not affected by the node's delta\n\t\t\tif (x.left === SENTINEL) {\n\t\t\t\tz.start -= delta;\n\t\t\t\tz.end -= delta;\n\t\t\t\tz.maxEnd -= delta;\n\t\t\t\tx.left = z;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tx = x.left;\n\t\t\t}\n\t\t} else {\n\t\t\t// this node should be inserted to the right\n\t\t\t// => it is not affected by the node's delta\n\t\t\tif (x.right === SENTINEL) {\n\t\t\t\tz.start -= (delta + x.delta);\n\t\t\t\tz.end -= (delta + x.delta);\n\t\t\t\tz.maxEnd -= (delta + x.delta);\n\t\t\t\tx.right = z;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdelta += x.delta;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\t}\n\n\tz.parent = x;\n\tz.left = SENTINEL;\n\tz.right = SENTINEL;\n\tsetNodeColor(z, NodeColor.Red);\n}\n//#endregion\n\n//#region Deletion\nfunction rbTreeDelete(T: IntervalTree, z: IntervalNode): void {\n\n\tlet x: IntervalNode;\n\tlet y: IntervalNode;\n\n\t// RB-DELETE except we don't swap z and y in case c)\n\t// i.e. we always delete what's pointed at by z.\n\n\tif (z.left === SENTINEL) {\n\t\tx = z.right;\n\t\ty = z;\n\n\t\t// x's delta is no longer influenced by z's delta\n\t\tx.delta += z.delta;\n\t\tif (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {\n\t\t\tT.requestNormalizeDelta = true;\n\t\t}\n\t\tx.start += z.delta;\n\t\tx.end += z.delta;\n\n\t} else if (z.right === SENTINEL) {\n\t\tx = z.left;\n\t\ty = z;\n\n\t} else {\n\t\ty = leftest(z.right);\n\t\tx = y.right;\n\n\t\t// y's delta is no longer influenced by z's delta,\n\t\t// but we don't want to walk the entire right-hand-side subtree of x.\n\t\t// we therefore maintain z's delta in y, and adjust only x\n\t\tx.start += y.delta;\n\t\tx.end += y.delta;\n\t\tx.delta += y.delta;\n\t\tif (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {\n\t\t\tT.requestNormalizeDelta = true;\n\t\t}\n\n\t\ty.start += z.delta;\n\t\ty.end += z.delta;\n\t\ty.delta = z.delta;\n\t\tif (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {\n\t\t\tT.requestNormalizeDelta = true;\n\t\t}\n\t}\n\n\tif (y === T.root) {\n\t\tT.root = x;\n\t\tsetNodeColor(x, NodeColor.Black);\n\n\t\tz.detach();\n\t\tresetSentinel();\n\t\trecomputeMaxEnd(x);\n\t\tT.root.parent = SENTINEL;\n\t\treturn;\n\t}\n\n\tlet yWasRed = (getNodeColor(y) === NodeColor.Red);\n\n\tif (y === y.parent.left) {\n\t\ty.parent.left = x;\n\t} else {\n\t\ty.parent.right = x;\n\t}\n\n\tif (y === z) {\n\t\tx.parent = y.parent;\n\t} else {\n\n\t\tif (y.parent === z) {\n\t\t\tx.parent = y;\n\t\t} else {\n\t\t\tx.parent = y.parent;\n\t\t}\n\n\t\ty.left = z.left;\n\t\ty.right = z.right;\n\t\ty.parent = z.parent;\n\t\tsetNodeColor(y, getNodeColor(z));\n\n\t\tif (z === T.root) {\n\t\t\tT.root = y;\n\t\t} else {\n\t\t\tif (z === z.parent.left) {\n\t\t\t\tz.parent.left = y;\n\t\t\t} else {\n\t\t\t\tz.parent.right = y;\n\t\t\t}\n\t\t}\n\n\t\tif (y.left !== SENTINEL) {\n\t\t\ty.left.parent = y;\n\t\t}\n\t\tif (y.right !== SENTINEL) {\n\t\t\ty.right.parent = y;\n\t\t}\n\t}\n\n\tz.detach();\n\n\tif (yWasRed) {\n\t\trecomputeMaxEndWalkToRoot(x.parent);\n\t\tif (y !== z) {\n\t\t\trecomputeMaxEndWalkToRoot(y);\n\t\t\trecomputeMaxEndWalkToRoot(y.parent);\n\t\t}\n\t\tresetSentinel();\n\t\treturn;\n\t}\n\n\trecomputeMaxEndWalkToRoot(x);\n\trecomputeMaxEndWalkToRoot(x.parent);\n\tif (y !== z) {\n\t\trecomputeMaxEndWalkToRoot(y);\n\t\trecomputeMaxEndWalkToRoot(y.parent);\n\t}\n\n\t// RB-DELETE-FIXUP\n\tlet w: IntervalNode;\n\twhile (x !== T.root && getNodeColor(x) === NodeColor.Black) {\n\n\t\tif (x === x.parent.left) {\n\t\t\tw = x.parent.right;\n\n\t\t\tif (getNodeColor(w) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(w, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Red);\n\t\t\t\tleftRotate(T, x.parent);\n\t\t\t\tw = x.parent.right;\n\t\t\t}\n\n\t\t\tif (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {\n\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\tx = x.parent;\n\t\t\t} else {\n\t\t\t\tif (getNodeColor(w.right) === NodeColor.Black) {\n\t\t\t\t\tsetNodeColor(w.left, NodeColor.Black);\n\t\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\t\trightRotate(T, w);\n\t\t\t\t\tw = x.parent.right;\n\t\t\t\t}\n\n\t\t\t\tsetNodeColor(w, getNodeColor(x.parent));\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(w.right, NodeColor.Black);\n\t\t\t\tleftRotate(T, x.parent);\n\t\t\t\tx = T.root;\n\t\t\t}\n\n\t\t} else {\n\t\t\tw = x.parent.left;\n\n\t\t\tif (getNodeColor(w) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(w, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Red);\n\t\t\t\trightRotate(T, x.parent);\n\t\t\t\tw = x.parent.left;\n\t\t\t}\n\n\t\t\tif (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {\n\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\tx = x.parent;\n\n\t\t\t} else {\n\t\t\t\tif (getNodeColor(w.left) === NodeColor.Black) {\n\t\t\t\t\tsetNodeColor(w.right, NodeColor.Black);\n\t\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\t\tleftRotate(T, w);\n\t\t\t\t\tw = x.parent.left;\n\t\t\t\t}\n\n\t\t\t\tsetNodeColor(w, getNodeColor(x.parent));\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(w.left, NodeColor.Black);\n\t\t\t\trightRotate(T, x.parent);\n\t\t\t\tx = T.root;\n\t\t\t}\n\t\t}\n\t}\n\n\tsetNodeColor(x, NodeColor.Black);\n\tresetSentinel();\n}\n\nfunction leftest(node: IntervalNode): IntervalNode {\n\twhile (node.left !== SENTINEL) {\n\t\tnode = node.left;\n\t}\n\treturn node;\n}\n\nfunction resetSentinel(): void {\n\tSENTINEL.parent = SENTINEL;\n\tSENTINEL.delta = 0; // optional\n\tSENTINEL.start = 0; // optional\n\tSENTINEL.end = 0; // optional\n}\n//#endregion\n\n//#region Rotations\nfunction leftRotate(T: IntervalTree, x: IntervalNode): void {\n\tconst y = x.right;\t\t\t\t// set y.\n\n\ty.delta += x.delta;\t\t\t\t// y's delta is no longer influenced by x's delta\n\tif (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {\n\t\tT.requestNormalizeDelta = true;\n\t}\n\ty.start += x.delta;\n\ty.end += x.delta;\n\n\tx.right = y.left;\t\t\t\t// turn y's left subtree into x's right subtree.\n\tif (y.left !== SENTINEL) {\n\t\ty.left.parent = x;\n\t}\n\ty.parent = x.parent;\t\t\t// link x's parent to y.\n\tif (x.parent === SENTINEL) {\n\t\tT.root = y;\n\t} else if (x === x.parent.left) {\n\t\tx.parent.left = y;\n\t} else {\n\t\tx.parent.right = y;\n\t}\n\n\ty.left = x;\t\t\t\t\t\t// put x on y's left.\n\tx.parent = y;\n\n\trecomputeMaxEnd(x);\n\trecomputeMaxEnd(y);\n}\n\nfunction rightRotate(T: IntervalTree, y: IntervalNode): void {\n\tconst x = y.left;\n\n\ty.delta -= x.delta;\n\tif (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {\n\t\tT.requestNormalizeDelta = true;\n\t}\n\ty.start -= x.delta;\n\ty.end -= x.delta;\n\n\ty.left = x.right;\n\tif (x.right !== SENTINEL) {\n\t\tx.right.parent = y;\n\t}\n\tx.parent = y.parent;\n\tif (y.parent === SENTINEL) {\n\t\tT.root = x;\n\t} else if (y === y.parent.right) {\n\t\ty.parent.right = x;\n\t} else {\n\t\ty.parent.left = x;\n\t}\n\n\tx.right = y;\n\ty.parent = x;\n\n\trecomputeMaxEnd(y);\n\trecomputeMaxEnd(x);\n}\n//#endregion\n\n//#region max end computation\n\nfunction computeMaxEnd(node: IntervalNode): number {\n\tlet maxEnd = node.end;\n\tif (node.left !== SENTINEL) {\n\t\tconst leftMaxEnd = node.left.maxEnd;\n\t\tif (leftMaxEnd > maxEnd) {\n\t\t\tmaxEnd = leftMaxEnd;\n\t\t}\n\t}\n\tif (node.right !== SENTINEL) {\n\t\tconst rightMaxEnd = node.right.maxEnd + node.delta;\n\t\tif (rightMaxEnd > maxEnd) {\n\t\t\tmaxEnd = rightMaxEnd;\n\t\t}\n\t}\n\treturn maxEnd;\n}\n\nexport function recomputeMaxEnd(node: IntervalNode): void {\n\tnode.maxEnd = computeMaxEnd(node);\n}\n\nfunction recomputeMaxEndWalkToRoot(node: IntervalNode): void {\n\twhile (node !== SENTINEL) {\n\n\t\tconst maxEnd = computeMaxEnd(node);\n\n\t\tif (node.maxEnd === maxEnd) {\n\t\t\t// no need to go further\n\t\t\treturn;\n\t\t}\n\n\t\tnode.maxEnd = maxEnd;\n\t\tnode = node.parent;\n\t}\n}\n\n//#endregion\n\n//#region utils\nexport function intervalCompare(aStart: number, aEnd: number, bStart: number, bEnd: number): number {\n\tif (aStart === bStart) {\n\t\treturn aEnd - bEnd;\n\t}\n\treturn aStart - bStart;\n}\n//#endregion\n"]}]}