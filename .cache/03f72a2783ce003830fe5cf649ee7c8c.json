{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/types.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/types.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const _typeof = {\n        number: 'number',\n        string: 'string',\n        undefined: 'undefined',\n        object: 'object',\n        function: 'function'\n    };\n    /**\n     * @returns whether the provided parameter is a JavaScript Array or not.\n     */\n    function isArray(array) {\n        if (Array.isArray) {\n            return Array.isArray(array);\n        }\n        if (array && typeof (array.length) === _typeof.number && array.constructor === Array) {\n            return true;\n        }\n        return false;\n    }\n    exports.isArray = isArray;\n    /**\n     * @returns whether the provided parameter is a JavaScript String or not.\n     */\n    function isString(str) {\n        if (typeof (str) === _typeof.string || str instanceof String) {\n            return true;\n        }\n        return false;\n    }\n    exports.isString = isString;\n    /**\n     * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.\n     */\n    function isStringArray(value) {\n        return isArray(value) && value.every(elem => isString(elem));\n    }\n    exports.isStringArray = isStringArray;\n    /**\n     *\n     * @returns whether the provided parameter is of type `object` but **not**\n     *\t`null`, an `array`, a `regexp`, nor a `date`.\n     */\n    function isObject(obj) {\n        // The method can't do a type cast since there are type (like strings) which\n        // are subclasses of any put not positvely matched by the function. Hence type\n        // narrowing results in wrong results.\n        return typeof obj === _typeof.object\n            && obj !== null\n            && !Array.isArray(obj)\n            && !(obj instanceof RegExp)\n            && !(obj instanceof Date);\n    }\n    exports.isObject = isObject;\n    /**\n     * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n     * @returns whether the provided parameter is a JavaScript Number or not.\n     */\n    function isNumber(obj) {\n        if ((typeof (obj) === _typeof.number || obj instanceof Number) && !isNaN(obj)) {\n            return true;\n        }\n        return false;\n    }\n    exports.isNumber = isNumber;\n    /**\n     * @returns whether the provided parameter is a JavaScript Boolean or not.\n     */\n    function isBoolean(obj) {\n        return obj === true || obj === false;\n    }\n    exports.isBoolean = isBoolean;\n    /**\n     * @returns whether the provided parameter is undefined.\n     */\n    function isUndefined(obj) {\n        return typeof (obj) === _typeof.undefined;\n    }\n    exports.isUndefined = isUndefined;\n    /**\n     * @returns whether the provided parameter is undefined or null.\n     */\n    function isUndefinedOrNull(obj) {\n        return isUndefined(obj) || obj === null;\n    }\n    exports.isUndefinedOrNull = isUndefinedOrNull;\n    const hasOwnProperty = Object.prototype.hasOwnProperty;\n    /**\n     * @returns whether the provided parameter is an empty JavaScript Object or not.\n     */\n    function isEmptyObject(obj) {\n        if (!isObject(obj)) {\n            return false;\n        }\n        for (let key in obj) {\n            if (hasOwnProperty.call(obj, key)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    exports.isEmptyObject = isEmptyObject;\n    /**\n     * @returns whether the provided parameter is a JavaScript Function or not.\n     */\n    function isFunction(obj) {\n        return typeof obj === _typeof.function;\n    }\n    exports.isFunction = isFunction;\n    /**\n     * @returns whether the provided parameters is are JavaScript Function or not.\n     */\n    function areFunctions(...objects) {\n        return objects.length > 0 && objects.every(isFunction);\n    }\n    exports.areFunctions = areFunctions;\n    function validateConstraints(args, constraints) {\n        const len = Math.min(args.length, constraints.length);\n        for (let i = 0; i < len; i++) {\n            validateConstraint(args[i], constraints[i]);\n        }\n    }\n    exports.validateConstraints = validateConstraints;\n    function validateConstraint(arg, constraint) {\n        if (isString(constraint)) {\n            if (typeof arg !== constraint) {\n                throw new Error(`argument does not match constraint: typeof ${constraint}`);\n            }\n        }\n        else if (isFunction(constraint)) {\n            try {\n                if (arg instanceof constraint) {\n                    return;\n                }\n            }\n            catch (_a) {\n                // ignore\n            }\n            if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {\n                return;\n            }\n            if (constraint.length === 1 && constraint.call(undefined, arg) === true) {\n                return;\n            }\n            throw new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);\n        }\n    }\n    exports.validateConstraint = validateConstraint;\n    /**\n     * Creates a new object of the provided class and will call the constructor with\n     * any additional argument supplied.\n     */\n    function create(ctor, ...args) {\n        if (isNativeClass(ctor)) {\n            return new ctor(...args);\n        }\n        else {\n            const obj = Object.create(ctor.prototype);\n            ctor.apply(obj, args);\n            return obj;\n        }\n    }\n    exports.create = create;\n    // https://stackoverflow.com/a/32235645/1499159\n    function isNativeClass(thing) {\n        return typeof thing === 'function'\n            && thing.hasOwnProperty('prototype')\n            && !thing.hasOwnProperty('arguments');\n    }\n    function getAllPropertyNames(obj) {\n        let res = [];\n        let proto = Object.getPrototypeOf(obj);\n        while (Object.prototype !== proto) {\n            res = res.concat(Object.getOwnPropertyNames(proto));\n            proto = Object.getPrototypeOf(proto);\n        }\n        return res;\n    }\n    exports.getAllPropertyNames = getAllPropertyNames;\n    /**\n     * Converts null to undefined, passes all other values through.\n     */\n    function withNullAsUndefined(x) {\n        return x === null ? undefined : x;\n    }\n    exports.withNullAsUndefined = withNullAsUndefined;\n    /**\n     * Converts undefined to null, passes all other values through.\n     */\n    function withUndefinedAsNull(x) {\n        return typeof x === 'undefined' ? null : x;\n    }\n    exports.withUndefinedAsNull = withUndefinedAsNull;\n});\n",null]}