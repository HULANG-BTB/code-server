{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/node/stream.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/stream.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"fs\"], function (require, exports, fs) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Reads totalBytes from the provided file.\n     */\n    function readExactlyByFile(file, totalBytes) {\n        return new Promise((resolve, reject) => {\n            fs.open(file, 'r', null, (err, fd) => {\n                if (err) {\n                    return reject(err);\n                }\n                function end(err, resultBuffer, bytesRead) {\n                    fs.close(fd, closeError => {\n                        if (closeError) {\n                            return reject(closeError);\n                        }\n                        if (err && err.code === 'EISDIR') {\n                            return reject(err); // we want to bubble this error up (file is actually a folder)\n                        }\n                        return resolve({ buffer: resultBuffer, bytesRead });\n                    });\n                }\n                const buffer = Buffer.allocUnsafe(totalBytes);\n                let offset = 0;\n                function readChunk() {\n                    fs.read(fd, buffer, offset, totalBytes - offset, null, (err, bytesRead) => {\n                        if (err) {\n                            return end(err, null, 0);\n                        }\n                        if (bytesRead === 0) {\n                            return end(null, buffer, offset);\n                        }\n                        offset += bytesRead;\n                        if (offset === totalBytes) {\n                            return end(null, buffer, offset);\n                        }\n                        return readChunk();\n                    });\n                }\n                readChunk();\n            });\n        });\n    }\n    exports.readExactlyByFile = readExactlyByFile;\n    /**\n     * Reads a file until a matching string is found.\n     *\n     * @param file The file to read.\n     * @param matchingString The string to search for.\n     * @param chunkBytes The number of bytes to read each iteration.\n     * @param maximumBytesToRead The maximum number of bytes to read before giving up.\n     * @param callback The finished callback.\n     */\n    function readToMatchingString(file, matchingString, chunkBytes, maximumBytesToRead) {\n        return new Promise((resolve, reject) => fs.open(file, 'r', null, (err, fd) => {\n            if (err) {\n                return reject(err);\n            }\n            function end(err, result) {\n                fs.close(fd, closeError => {\n                    if (closeError) {\n                        return reject(closeError);\n                    }\n                    if (err && err.code === 'EISDIR') {\n                        return reject(err); // we want to bubble this error up (file is actually a folder)\n                    }\n                    return resolve(result);\n                });\n            }\n            const buffer = Buffer.allocUnsafe(maximumBytesToRead);\n            let offset = 0;\n            function readChunk() {\n                fs.read(fd, buffer, offset, chunkBytes, null, (err, bytesRead) => {\n                    if (err) {\n                        return end(err, null);\n                    }\n                    if (bytesRead === 0) {\n                        return end(null, null);\n                    }\n                    offset += bytesRead;\n                    const newLineIndex = buffer.indexOf(matchingString);\n                    if (newLineIndex >= 0) {\n                        return end(null, buffer.toString('utf8').substr(0, newLineIndex));\n                    }\n                    if (offset >= maximumBytesToRead) {\n                        return end(new Error(`Could not find ${matchingString} in first ${maximumBytesToRead} bytes of ${file}`), null);\n                    }\n                    return readChunk();\n                });\n            }\n            readChunk();\n        }));\n    }\n    exports.readToMatchingString = readToMatchingString;\n});\n",null]}