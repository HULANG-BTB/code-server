{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/workspaces/common/workspaces.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/workspaces/common/workspaces.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/platform/instantiation/common/instantiation\", \"vs/nls\", \"vs/base/common/uri\", \"vs/base/common/platform\", \"vs/base/common/path\", \"vs/base/common/resources\", \"vs/base/common/jsonEdit\", \"vs/base/common/json\", \"vs/base/common/network\", \"vs/base/common/labels\", \"vs/base/common/extpath\"], function (require, exports, instantiation_1, nls_1, uri_1, platform_1, path_1, resources_1, jsonEdit, json, network_1, labels_1, extpath_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.IWorkspacesMainService = instantiation_1.createDecorator('workspacesMainService');\n    exports.IWorkspacesService = instantiation_1.createDecorator('workspacesService');\n    exports.WORKSPACE_EXTENSION = 'code-workspace';\n    exports.WORKSPACE_FILTER = [{ name: nls_1.localize('codeWorkspace', \"Code Workspace\"), extensions: [exports.WORKSPACE_EXTENSION] }];\n    exports.UNTITLED_WORKSPACE_NAME = 'workspace.json';\n    function reviveWorkspaceIdentifier(workspace) {\n        return { id: workspace.id, configPath: uri_1.URI.revive(workspace.configPath) };\n    }\n    exports.reviveWorkspaceIdentifier = reviveWorkspaceIdentifier;\n    function isStoredWorkspaceFolder(thing) {\n        return isRawFileWorkspaceFolder(thing) || isRawUriWorkspaceFolder(thing);\n    }\n    exports.isStoredWorkspaceFolder = isStoredWorkspaceFolder;\n    function isRawFileWorkspaceFolder(thing) {\n        return thing\n            && typeof thing === 'object'\n            && typeof thing.path === 'string'\n            && (!thing.name || typeof thing.name === 'string');\n    }\n    exports.isRawFileWorkspaceFolder = isRawFileWorkspaceFolder;\n    function isRawUriWorkspaceFolder(thing) {\n        return thing\n            && typeof thing === 'object'\n            && typeof thing.uri === 'string'\n            && (!thing.name || typeof thing.name === 'string');\n    }\n    exports.isRawUriWorkspaceFolder = isRawUriWorkspaceFolder;\n    function isSingleFolderWorkspaceIdentifier(obj) {\n        return obj instanceof uri_1.URI;\n    }\n    exports.isSingleFolderWorkspaceIdentifier = isSingleFolderWorkspaceIdentifier;\n    function isWorkspaceIdentifier(obj) {\n        const workspaceIdentifier = obj;\n        return workspaceIdentifier && typeof workspaceIdentifier.id === 'string' && workspaceIdentifier.configPath instanceof uri_1.URI;\n    }\n    exports.isWorkspaceIdentifier = isWorkspaceIdentifier;\n    function toWorkspaceIdentifier(workspace) {\n        if (workspace.configuration) {\n            return {\n                configPath: workspace.configuration,\n                id: workspace.id\n            };\n        }\n        if (workspace.folders.length === 1) {\n            return workspace.folders[0].uri;\n        }\n        // Empty workspace\n        return undefined;\n    }\n    exports.toWorkspaceIdentifier = toWorkspaceIdentifier;\n    function isSingleFolderWorkspaceInitializationPayload(obj) {\n        return isSingleFolderWorkspaceIdentifier(obj.folder);\n    }\n    exports.isSingleFolderWorkspaceInitializationPayload = isSingleFolderWorkspaceInitializationPayload;\n    const WORKSPACE_SUFFIX = '.' + exports.WORKSPACE_EXTENSION;\n    function hasWorkspaceFileExtension(path) {\n        return path_1.extname(path) === WORKSPACE_SUFFIX;\n    }\n    exports.hasWorkspaceFileExtension = hasWorkspaceFileExtension;\n    const SLASH = '/';\n    /**\n     * Given a folder URI and the workspace config folder, computes the IStoredWorkspaceFolder using\n    * a relative or absolute path or a uri.\n     * Undefined is returned if the folderURI and the targetConfigFolderURI don't have the same schema or authority\n     *\n     * @param folderURI a workspace folder\n     * @param folderName a workspace name\n     * @param targetConfigFolderURI the folder where the workspace is living in\n     * @param useSlashForPath if set, use forward slashes for file paths on windows\n     */\n    function getStoredWorkspaceFolder(folderURI, folderName, targetConfigFolderURI, useSlashForPath = !platform_1.isWindows) {\n        if (folderURI.scheme !== targetConfigFolderURI.scheme) {\n            return { name: folderName, uri: folderURI.toString(true) };\n        }\n        let folderPath;\n        if (resources_1.isEqualOrParent(folderURI, targetConfigFolderURI)) {\n            // use relative path\n            folderPath = resources_1.relativePath(targetConfigFolderURI, folderURI) || '.'; // always uses forward slashes\n            if (platform_1.isWindows && folderURI.scheme === network_1.Schemas.file && !useSlashForPath) {\n                // Windows gets special treatment:\n                // - use backslahes unless slash is used by other existing folders\n                folderPath = folderPath.replace(/\\//g, '\\\\');\n            }\n        }\n        else {\n            // use absolute path\n            if (folderURI.scheme === network_1.Schemas.file) {\n                folderPath = folderURI.fsPath;\n                if (platform_1.isWindows) {\n                    // Windows gets special treatment:\n                    // - normalize all paths to get nice casing of drive letters\n                    // - use backslahes unless slash is used by other existing folders\n                    folderPath = labels_1.normalizeDriveLetter(folderPath);\n                    if (useSlashForPath) {\n                        folderPath = extpath_1.toSlashes(folderPath);\n                    }\n                }\n            }\n            else {\n                if (!resources_1.isEqualAuthority(folderURI.authority, targetConfigFolderURI.authority)) {\n                    return { name: folderName, uri: folderURI.toString(true) };\n                }\n                folderPath = folderURI.path;\n            }\n        }\n        return { name: folderName, path: folderPath };\n    }\n    exports.getStoredWorkspaceFolder = getStoredWorkspaceFolder;\n    /**\n     * Rewrites the content of a workspace file to be saved at a new location.\n     * Throws an exception if file is not a valid workspace file\n     */\n    function rewriteWorkspaceFileForNewLocation(rawWorkspaceContents, configPathURI, targetConfigPathURI) {\n        let storedWorkspace = doParseStoredWorkspace(configPathURI, rawWorkspaceContents);\n        const sourceConfigFolder = resources_1.dirname(configPathURI);\n        const targetConfigFolder = resources_1.dirname(targetConfigPathURI);\n        const rewrittenFolders = [];\n        const slashForPath = useSlashForPath(storedWorkspace.folders);\n        // Rewrite absolute paths to relative paths if the target workspace folder\n        // is a parent of the location of the workspace file itself. Otherwise keep\n        // using absolute paths.\n        for (const folder of storedWorkspace.folders) {\n            let folderURI = isRawFileWorkspaceFolder(folder) ? resources_1.resolvePath(sourceConfigFolder, folder.path) : uri_1.URI.parse(folder.uri);\n            rewrittenFolders.push(getStoredWorkspaceFolder(folderURI, folder.name, targetConfigFolder, slashForPath));\n        }\n        // Preserve as much of the existing workspace as possible by using jsonEdit\n        // and only changing the folders portion.\n        let newRawWorkspaceContents = rawWorkspaceContents;\n        const edits = jsonEdit.setProperty(rawWorkspaceContents, ['folders'], rewrittenFolders, { insertSpaces: false, tabSize: 4, eol: (platform_1.isLinux || platform_1.isMacintosh) ? '\\n' : '\\r\\n' });\n        edits.forEach(edit => {\n            newRawWorkspaceContents = jsonEdit.applyEdit(rawWorkspaceContents, edit);\n        });\n        return newRawWorkspaceContents;\n    }\n    exports.rewriteWorkspaceFileForNewLocation = rewriteWorkspaceFileForNewLocation;\n    function doParseStoredWorkspace(path, contents) {\n        // Parse workspace file\n        let storedWorkspace = json.parse(contents); // use fault tolerant parser\n        // Filter out folders which do not have a path or uri set\n        if (Array.isArray(storedWorkspace.folders)) {\n            storedWorkspace.folders = storedWorkspace.folders.filter(folder => isStoredWorkspaceFolder(folder));\n        }\n        // Validate\n        if (!Array.isArray(storedWorkspace.folders)) {\n            throw new Error(`${path} looks like an invalid workspace file.`);\n        }\n        return storedWorkspace;\n    }\n    function useSlashForPath(storedFolders) {\n        if (platform_1.isWindows) {\n            for (const folder of storedFolders) {\n                if (isRawFileWorkspaceFolder(folder) && folder.path.indexOf(SLASH) >= 0) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n    exports.useSlashForPath = useSlashForPath;\n});\n",null]}