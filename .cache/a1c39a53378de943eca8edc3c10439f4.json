{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/timer/electron-browser/timerService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/timer/electron-browser/timerService.ts","mtime":1555846338048},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar id_1 = require(\"vs/base/node/id\");\nvar perf = require(\"vs/base/common/performance\");\nvar os = require(\"os\");\nvar windows_1 = require(\"vs/platform/windows/common/windows\");\nvar workspace_1 = require(\"vs/platform/workspace/common/workspace\");\nvar extensions_1 = require(\"vs/workbench/services/extensions/common/extensions\");\nvar extensions_2 = require(\"vs/platform/instantiation/common/extensions\");\nvar arrays_1 = require(\"vs/base/common/arrays\");\nvar update_1 = require(\"vs/platform/update/common/update\");\nvar lifecycle_1 = require(\"vs/platform/lifecycle/common/lifecycle\");\nvar viewlet_1 = require(\"vs/workbench/services/viewlet/browser/viewlet\");\nvar panelService_1 = require(\"vs/workbench/services/panel/common/panelService\");\nvar editorService_1 = require(\"vs/workbench/services/editor/common/editorService\");\nvar accessibility_1 = require(\"vs/platform/accessibility/common/accessibility\");\nvar TimerService = /** @class */ (function () {\n    function TimerService(_windowsService, _windowService, _lifecycleService, _contextService, _extensionService, _updateService, _viewletService, _panelService, _editorService, _accessibilityService) {\n        this._windowsService = _windowsService;\n        this._windowService = _windowService;\n        this._lifecycleService = _lifecycleService;\n        this._contextService = _contextService;\n        this._extensionService = _extensionService;\n        this._updateService = _updateService;\n        this._viewletService = _viewletService;\n        this._panelService = _panelService;\n        this._editorService = _editorService;\n        this._accessibilityService = _accessibilityService;\n    }\n    Object.defineProperty(TimerService.prototype, \"startupMetrics\", {\n        get: function () {\n            var _this = this;\n            if (!this._startupMetrics) {\n                this._startupMetrics = Promise\n                    .resolve(this._extensionService.whenInstalledExtensionsRegistered())\n                    .then(function () { return _this._computeStartupMetrics(); });\n            }\n            return this._startupMetrics;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TimerService.prototype._computeStartupMetrics = function () {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var now, initialStartup, startMark, totalmem, freemem, cpus, platform, release, arch, loadavg, meminfo, isVMLikelyhood, rawCpus, activeViewlet, activePanel, _a, _b;\n            return tslib_1.__generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        now = Date.now();\n                        initialStartup = !!this._windowService.getConfiguration().isInitialStartup;\n                        startMark = initialStartup ? 'main:started' : 'main:loadWindow';\n                        try {\n                            totalmem = os.totalmem();\n                            freemem = os.freemem();\n                            platform = os.platform();\n                            release = os.release();\n                            arch = os.arch();\n                            loadavg = os.loadavg();\n                            meminfo = process.getProcessMemoryInfo();\n                            isVMLikelyhood = Math.round((id_1.virtualMachineHint.value() * 100));\n                            rawCpus = os.cpus();\n                            if (rawCpus && rawCpus.length > 0) {\n                                cpus = { count: rawCpus.length, speed: rawCpus[0].speed, model: rawCpus[0].model };\n                            }\n                        }\n                        catch (error) {\n                            // ignore, be on the safe side with these hardware method calls\n                        }\n                        activeViewlet = this._viewletService.getActiveViewlet();\n                        activePanel = this._panelService.getActivePanel();\n                        _a = {\n                            version: 2,\n                            ellapsed: perf.getDuration(startMark, 'didStartWorkbench')\n                        };\n                        _b = Boolean;\n                        return [4 /*yield*/, this._updateService.isLatestVersion()];\n                    case 1:\n                        // reflections\n                        _a.isLatestVersion = _b.apply(void 0, [_c.sent()]),\n                            _a.didUseCachedData = didUseCachedData(),\n                            _a.windowKind = this._lifecycleService.startupKind;\n                        return [4 /*yield*/, this._windowsService.getWindowCount()];\n                    case 2: return [2 /*return*/, (_a.windowCount = _c.sent(),\n                            _a.viewletId = activeViewlet ? activeViewlet.getId() : undefined,\n                            _a.editorIds = this._editorService.visibleEditors.map(function (input) { return input.getTypeId(); }),\n                            _a.panelId = activePanel ? activePanel.getId() : undefined,\n                            // timers\n                            _a.timers = {\n                                ellapsedAppReady: initialStartup ? perf.getDuration('main:started', 'main:appReady') : undefined,\n                                ellapsedNlsGeneration: initialStartup ? perf.getDuration('nlsGeneration:start', 'nlsGeneration:end') : undefined,\n                                ellapsedWindowLoad: initialStartup ? perf.getDuration('main:appReady', 'main:loadWindow') : undefined,\n                                ellapsedWindowLoadToRequire: perf.getDuration('main:loadWindow', 'willLoadWorkbenchMain'),\n                                ellapsedRequire: perf.getDuration('willLoadWorkbenchMain', 'didLoadWorkbenchMain'),\n                                ellapsedWorkspaceStorageInit: perf.getDuration('willInitWorkspaceStorage', 'didInitWorkspaceStorage'),\n                                ellapsedWorkspaceServiceInit: perf.getDuration('willInitWorkspaceService', 'didInitWorkspaceService'),\n                                ellapsedExtensions: perf.getDuration('willLoadExtensions', 'didLoadExtensions'),\n                                ellapsedEditorRestore: perf.getDuration('willRestoreEditors', 'didRestoreEditors'),\n                                ellapsedViewletRestore: perf.getDuration('willRestoreViewlet', 'didRestoreViewlet'),\n                                ellapsedPanelRestore: perf.getDuration('willRestorePanel', 'didRestorePanel'),\n                                ellapsedWorkbench: perf.getDuration('willStartWorkbench', 'didStartWorkbench'),\n                                ellapsedExtensionsReady: perf.getDuration(startMark, 'didLoadExtensions'),\n                                ellapsedTimersToTimersComputed: Date.now() - now,\n                            },\n                            // system info\n                            _a.platform = platform,\n                            _a.release = release,\n                            _a.arch = arch,\n                            _a.totalmem = totalmem,\n                            _a.freemem = freemem,\n                            _a.meminfo = meminfo,\n                            _a.cpus = cpus,\n                            _a.loadavg = loadavg,\n                            _a.initialStartup = initialStartup,\n                            _a.isVMLikelyhood = isVMLikelyhood,\n                            _a.hasAccessibilitySupport = this._accessibilityService.getAccessibilitySupport() === accessibility_1.AccessibilitySupport.Enabled,\n                            _a.emptyWorkbench = this._contextService.getWorkbenchState() === workspace_1.WorkbenchState.EMPTY,\n                            _a)];\n                }\n            });\n        });\n    };\n    TimerService = tslib_1.__decorate([\n        tslib_1.__param(0, windows_1.IWindowsService),\n        tslib_1.__param(1, windows_1.IWindowService),\n        tslib_1.__param(2, lifecycle_1.ILifecycleService),\n        tslib_1.__param(3, workspace_1.IWorkspaceContextService),\n        tslib_1.__param(4, extensions_1.IExtensionService),\n        tslib_1.__param(5, update_1.IUpdateService),\n        tslib_1.__param(6, viewlet_1.IViewletService),\n        tslib_1.__param(7, panelService_1.IPanelService),\n        tslib_1.__param(8, editorService_1.IEditorService),\n        tslib_1.__param(9, accessibility_1.IAccessibilityService)\n    ], TimerService);\n    return TimerService;\n}());\nexports.ITimerService = instantiation_1.createDecorator('timerService');\nextensions_2.registerSingleton(exports.ITimerService, TimerService, true);\n//#region cached data logic\nfunction didUseCachedData() {\n    return false;\n    // We surely don't use cached data when we don't tell the loader to do so\n    if (!Boolean(global.require.getConfig().nodeCachedData)) {\n        return false;\n    }\n    // whenever cached data is produced or rejected a onNodeCachedData-callback is invoked. That callback\n    // stores data in the `MonacoEnvironment.onNodeCachedData` global. See:\n    // https://github.com/Microsoft/vscode/blob/efe424dfe76a492eab032343e2fa4cfe639939f0/src/vs/workbench/electron-browser/bootstrap/index.js#L299\n    if (arrays_1.isNonEmptyArray(MonacoEnvironment.onNodeCachedData)) {\n        return false;\n    }\n    return true;\n}\nexports.didUseCachedData = didUseCachedData;\n//#endregion\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/timer/electron-browser/timerService.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/timer/electron-browser/timerService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { virtualMachineHint } from 'vs/base/node/id';\nimport * as perf from 'vs/base/common/performance';\nimport * as os from 'os';\nimport { IWindowService, IWindowsService } from 'vs/platform/windows/common/windows';\nimport { IWorkspaceContextService, WorkbenchState } from 'vs/platform/workspace/common/workspace';\nimport { IExtensionService } from 'vs/workbench/services/extensions/common/extensions';\nimport { registerSingleton } from 'vs/platform/instantiation/common/extensions';\nimport { isNonEmptyArray } from 'vs/base/common/arrays';\nimport { IUpdateService } from 'vs/platform/update/common/update';\nimport { ILifecycleService } from 'vs/platform/lifecycle/common/lifecycle';\nimport { IViewletService } from 'vs/workbench/services/viewlet/browser/viewlet';\nimport { IPanelService } from 'vs/workbench/services/panel/common/panelService';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\nimport { IAccessibilityService, AccessibilitySupport } from 'vs/platform/accessibility/common/accessibility';\n\n\n/* __GDPR__FRAGMENT__\n\t\"IMemoryInfo\" : {\n\t\t\"workingSetSize\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"peakWorkingSetSize\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"privateBytes\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"sharedBytes\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true }\n\t}\n*/\nexport interface IMemoryInfo {\n\treadonly workingSetSize: number;\n\treadonly peakWorkingSetSize: number;\n\treadonly privateBytes: number;\n\treadonly sharedBytes: number;\n}\n\n/* __GDPR__FRAGMENT__\n\t\"IStartupMetrics\" : {\n\t\t\"version\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"ellapsed\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"isLatestVersion\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"didUseCachedData\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"windowKind\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"windowCount\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"viewletId\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"panelId\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"editorIds\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"timers.ellapsedAppReady\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"timers.ellapsedWindowLoad\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"timers.ellapsedWindowLoadToRequire\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"timers.ellapsedExtensions\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"timers.ellapsedExtensionsReady\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"timers.ellapsedRequire\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"timers.ellapsedWorkspaceStorageInit\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"timers.ellapsedWorkspaceServiceInit\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"timers.ellapsedViewletRestore\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"timers.ellapsedPanelRestore\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"timers.ellapsedEditorRestore\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"timers.ellapsedWorkbench\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"timers.ellapsedTimersToTimersComputed\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"timers.ellapsedNlsGeneration\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"platform\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"release\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"arch\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"totalmem\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"freemem\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"meminfo\" : { \"${inline}\": [ \"${IMemoryInfo}\" ] },\n\t\t\"cpus.count\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"cpus.speed\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"cpus.model\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"initialStartup\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"hasAccessibilitySupport\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"isVMLikelyhood\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"emptyWorkbench\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"loadavg\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" }\n\t}\n*/\nexport interface IStartupMetrics {\n\n\t/**\n\t * The version of these metrics.\n\t */\n\treadonly version: 2;\n\n\t/**\n\t * If this started the main process and renderer or just a renderer (new or reloaded).\n\t */\n\treadonly initialStartup: boolean;\n\n\t/**\n\t * No folder, no file, no workspace has been opened\n\t */\n\treadonly emptyWorkbench: boolean;\n\n\t/**\n\t * This is the latest (stable/insider) version. Iff not we should ignore this\n\t * measurement.\n\t */\n\treadonly isLatestVersion: boolean;\n\n\t/**\n\t * Whether we asked for and V8 accepted cached data.\n\t */\n\treadonly didUseCachedData: boolean;\n\n\t/**\n\t * How/why the window was created. See https://github.com/Microsoft/vscode/blob/d1f57d871722f4d6ba63e4ef6f06287121ceb045/src/vs/platform/lifecycle/common/lifecycle.ts#L50\n\t */\n\treadonly windowKind: number;\n\n\t/**\n\t * The total number of windows that have been restored/created\n\t */\n\treadonly windowCount: number;\n\n\t/**\n\t * The active viewlet id or `undedined`\n\t */\n\treadonly viewletId?: string;\n\n\t/**\n\t * The active panel id or `undefined`\n\t */\n\treadonly panelId?: string;\n\n\t/**\n\t * The editor input types or `[]`\n\t */\n\treadonly editorIds: string[];\n\n\t/**\n\t * The time it took to create the workbench.\n\t *\n\t * * Happens in the main-process *and* the renderer-process\n\t * * Measured with the *start* and `didStartWorkbench`-performance mark. The *start* is either the start of the\n\t * main process or the start of the renderer.\n\t * * This should be looked at carefully because times vary depending on\n\t *  * This being the first window, the only window, or a reloaded window\n\t *  * Cached data being present and used or not\n\t *  * The numbers and types of editors being restored\n\t *  * The numbers of windows being restored (when starting 'fresh')\n\t *  * The viewlet being restored (esp. when it's a contributed viewlet)\n\t */\n\treadonly ellapsed: number;\n\n\t/**\n\t * Individual timers...\n\t */\n\treadonly timers: {\n\t\t/**\n\t\t * The time it took to receieve the [`ready`](https://electronjs.org/docs/api/app#event-ready)-event. Measured from the first line\n\t\t * of JavaScript code till receiving that event.\n\t\t *\n\t\t * * Happens in the main-process\n\t\t * * Measured with the `main:started` and `main:appReady` performance marks.\n\t\t * * This can be compared between insider and stable builds.\n\t\t * * This should be looked at per OS version and per electron version.\n\t\t * * This is often affected by AV software (and can change with AV software updates outside of our release-cycle).\n\t\t * * It is not our code running here and we can only observe what's happening.\n\t\t */\n\t\treadonly ellapsedAppReady?: number;\n\n\t\t/**\n\t\t * The time it took to generate NLS data.\n\t\t *\n\t\t * * Happens in the main-process\n\t\t * * Measured with the `nlsGeneration:start` and `nlsGeneration:end` performance marks.\n\t\t * * This only happens when a non-english locale is being used.\n\t\t * * It is our code running here and we should monitor this carefully for regressions.\n\t\t */\n\t\treadonly ellapsedNlsGeneration?: number;\n\n\t\t/**\n\t\t * The time it took to tell electron to open/restore a renderer (browser window).\n\t\t *\n\t\t * * Happens in the main-process\n\t\t * * Measured with the `main:appReady` and `main:loadWindow` performance marks.\n\t\t * * This can be compared between insider and stable builds.\n\t\t * * It is our code running here and we should monitor this carefully for regressions.\n\t\t */\n\t\treadonly ellapsedWindowLoad?: number;\n\n\t\t/**\n\t\t * The time it took to create a new renderer (browser window) and to initialize that to the point\n\t\t * of load the main-bundle (`workbench.main.js`).\n\t\t *\n\t\t * * Happens in the main-process *and* the renderer-process\n\t\t * * Measured with the `main:loadWindow` and `willLoadWorkbenchMain` performance marks.\n\t\t * * This can be compared between insider and stable builds.\n\t\t * * It is mostly not our code running here and we can only observe what's happening.\n\t\t *\n\t\t */\n\t\treadonly ellapsedWindowLoadToRequire: number;\n\n\t\t/**\n\t\t * The time it took to require the workspace storage DB, connect to it\n\t\t * and load the initial set of values.\n\t\t *\n\t\t * * Happens in the renderer-process\n\t\t * * Measured with the `willInitWorkspaceStorage` and `didInitWorkspaceStorage` performance marks.\n\t\t */\n\t\treadonly ellapsedWorkspaceStorageInit: number;\n\n\t\t/**\n\t\t * The time it took to initialize the workspace and configuration service.\n\t\t *\n\t\t * * Happens in the renderer-process\n\t\t * * Measured with the `willInitWorkspaceService` and `didInitWorkspaceService` performance marks.\n\t\t */\n\t\treadonly ellapsedWorkspaceServiceInit: number;\n\n\t\t/**\n\t\t * The time it took to load the main-bundle of the workbench, e.g `workbench.main.js`.\n\t\t *\n\t\t * * Happens in the renderer-process\n\t\t * * Measured with the `willLoadWorkbenchMain` and `didLoadWorkbenchMain` performance marks.\n\t\t * * This varies *a lot* when V8 cached data could be used or not\n\t\t * * This should be looked at with and without V8 cached data usage and per electron/v8 version\n\t\t * * This is affected by the size of our code bundle (which  grows about 3-5% per release)\n\t\t */\n\t\treadonly ellapsedRequire: number;\n\n\t\t/**\n\t\t * The time it took to read extensions' package.json-files *and* interpret them (invoking\n\t\t * the contribution points).\n\t\t *\n\t\t * * Happens in the renderer-process\n\t\t * * Measured with the `willLoadExtensions` and `didLoadExtensions` performance marks.\n\t\t * * Reading of package.json-files is avoided by caching them all in a single file (after the read,\n\t\t * until another extension is installed)\n\t\t * * Happens in parallel to other things, depends on async timing\n\t\t *\n\t\t * todo@joh/ramya this measures an artifical dealy we have added, see https://github.com/Microsoft/vscode/blob/2f07ddae8bf56e969e3f4ba1447258ebc999672f/src/vs/workbench/services/extensions/electron-browser/extensionService.ts#L311-L326\n\t\t */\n\t\treadonly ellapsedExtensions: number;\n\n\t\t// the time from start till `didLoadExtensions`\n\t\t// remove?\n\t\treadonly ellapsedExtensionsReady: number;\n\n\t\t/**\n\t\t * The time it took to restore the viewlet.\n\t\t *\n\t\t * * Happens in the renderer-process\n\t\t * * Measured with the `willRestoreViewlet` and `didRestoreViewlet` performance marks.\n\t\t * * This should be looked at per viewlet-type/id.\n\t\t * * Happens in parallel to other things, depends on async timing\n\t\t */\n\t\treadonly ellapsedViewletRestore: number;\n\n\t\t/**\n\t\t * The time it took to restore the panel.\n\t\t *\n\t\t * * Happens in the renderer-process\n\t\t * * Measured with the `willRestorePanel` and `didRestorePanel` performance marks.\n\t\t * * This should be looked at per panel-type/id.\n\t\t * * Happens in parallel to other things, depends on async timing\n\t\t */\n\t\treadonly ellapsedPanelRestore: number;\n\n\t\t/**\n\t\t * The time it took to restore editors - that is text editor and complex editor likes the settings UI\n\t\t * or webviews (markdown preview).\n\t\t *\n\t\t * * Happens in the renderer-process\n\t\t * * Measured with the `willRestoreEditors` and `didRestoreEditors` performance marks.\n\t\t * * This should be looked at per editor and per editor type.\n\t\t * * Happens in parallel to other things, depends on async timing\n\t\t *\n\t\t * todo@joh/ramya We should probably measures each editor individually?\n\t\t */\n\t\treadonly ellapsedEditorRestore: number;\n\n\t\t/**\n\t\t * The time it took to create the workbench.\n\t\t *\n\t\t * * Happens in the renderer-process\n\t\t * * Measured with the `willStartWorkbench` and `didStartWorkbench` performance marks.\n\t\t *\n\t\t * todo@joh/ramya Not sure if this is useful because this includes too much\n\t\t */\n\t\treadonly ellapsedWorkbench: number;\n\n\t\t// the time it took to generate this object.\n\t\t// remove?\n\t\treadonly ellapsedTimersToTimersComputed: number;\n\t};\n\n\treadonly hasAccessibilitySupport: boolean;\n\treadonly isVMLikelyhood?: number;\n\treadonly platform?: string;\n\treadonly release?: string;\n\treadonly arch?: string;\n\treadonly totalmem?: number;\n\treadonly freemem?: number;\n\treadonly meminfo?: IMemoryInfo;\n\treadonly cpus?: { count: number; speed: number; model: string; };\n\treadonly loadavg?: number[];\n}\n\nexport interface ITimerService {\n\t_serviceBrand: any;\n\treadonly startupMetrics: Promise<IStartupMetrics>;\n}\n\nclass TimerService implements ITimerService {\n\n\t_serviceBrand: any;\n\n\tprivate _startupMetrics: Promise<IStartupMetrics>;\n\n\tconstructor(\n\t\t@IWindowsService private readonly _windowsService: IWindowsService,\n\t\t@IWindowService private readonly _windowService: IWindowService,\n\t\t@ILifecycleService private readonly _lifecycleService: ILifecycleService,\n\t\t@IWorkspaceContextService private readonly _contextService: IWorkspaceContextService,\n\t\t@IExtensionService private readonly _extensionService: IExtensionService,\n\t\t@IUpdateService private readonly _updateService: IUpdateService,\n\t\t@IViewletService private readonly _viewletService: IViewletService,\n\t\t@IPanelService private readonly _panelService: IPanelService,\n\t\t@IEditorService private readonly _editorService: IEditorService,\n\t\t@IAccessibilityService private readonly _accessibilityService: IAccessibilityService\n\t) { }\n\n\tget startupMetrics(): Promise<IStartupMetrics> {\n\t\tif (!this._startupMetrics) {\n\t\t\tthis._startupMetrics = Promise\n\t\t\t\t.resolve(this._extensionService.whenInstalledExtensionsRegistered())\n\t\t\t\t.then(() => this._computeStartupMetrics());\n\t\t}\n\t\treturn this._startupMetrics;\n\t}\n\n\tprivate async _computeStartupMetrics(): Promise<IStartupMetrics> {\n\n\t\tconst now = Date.now();\n\t\tconst initialStartup = !!this._windowService.getConfiguration().isInitialStartup;\n\t\tconst startMark = initialStartup ? 'main:started' : 'main:loadWindow';\n\n\t\tlet totalmem: number | undefined;\n\t\tlet freemem: number | undefined;\n\t\tlet cpus: { count: number; speed: number; model: string; } | undefined;\n\t\tlet platform: string | undefined;\n\t\tlet release: string | undefined;\n\t\tlet arch: string | undefined;\n\t\tlet loadavg: number[] | undefined;\n\t\tlet meminfo: IMemoryInfo | undefined;\n\t\tlet isVMLikelyhood: number | undefined;\n\n\t\ttry {\n\t\t\ttotalmem = os.totalmem();\n\t\t\tfreemem = os.freemem();\n\t\t\tplatform = os.platform();\n\t\t\trelease = os.release();\n\t\t\tarch = os.arch();\n\t\t\tloadavg = os.loadavg();\n\t\t\tmeminfo = process.getProcessMemoryInfo();\n\n\t\t\tisVMLikelyhood = Math.round((virtualMachineHint.value() * 100));\n\n\t\t\tconst rawCpus = os.cpus();\n\t\t\tif (rawCpus && rawCpus.length > 0) {\n\t\t\t\tcpus = { count: rawCpus.length, speed: rawCpus[0].speed, model: rawCpus[0].model };\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore, be on the safe side with these hardware method calls\n\t\t}\n\n\t\tconst activeViewlet = this._viewletService.getActiveViewlet();\n\t\tconst activePanel = this._panelService.getActivePanel();\n\t\treturn {\n\t\t\tversion: 2,\n\t\t\tellapsed: perf.getDuration(startMark, 'didStartWorkbench'),\n\n\t\t\t// reflections\n\t\t\tisLatestVersion: Boolean(await this._updateService.isLatestVersion()),\n\t\t\tdidUseCachedData: didUseCachedData(),\n\t\t\twindowKind: this._lifecycleService.startupKind,\n\t\t\twindowCount: await this._windowsService.getWindowCount(),\n\t\t\tviewletId: activeViewlet ? activeViewlet.getId() : undefined,\n\t\t\teditorIds: this._editorService.visibleEditors.map(input => input.getTypeId()),\n\t\t\tpanelId: activePanel ? activePanel.getId() : undefined,\n\n\t\t\t// timers\n\t\t\ttimers: {\n\t\t\t\tellapsedAppReady: initialStartup ? perf.getDuration('main:started', 'main:appReady') : undefined,\n\t\t\t\tellapsedNlsGeneration: initialStartup ? perf.getDuration('nlsGeneration:start', 'nlsGeneration:end') : undefined,\n\t\t\t\tellapsedWindowLoad: initialStartup ? perf.getDuration('main:appReady', 'main:loadWindow') : undefined,\n\t\t\t\tellapsedWindowLoadToRequire: perf.getDuration('main:loadWindow', 'willLoadWorkbenchMain'),\n\t\t\t\tellapsedRequire: perf.getDuration('willLoadWorkbenchMain', 'didLoadWorkbenchMain'),\n\t\t\t\tellapsedWorkspaceStorageInit: perf.getDuration('willInitWorkspaceStorage', 'didInitWorkspaceStorage'),\n\t\t\t\tellapsedWorkspaceServiceInit: perf.getDuration('willInitWorkspaceService', 'didInitWorkspaceService'),\n\t\t\t\tellapsedExtensions: perf.getDuration('willLoadExtensions', 'didLoadExtensions'),\n\t\t\t\tellapsedEditorRestore: perf.getDuration('willRestoreEditors', 'didRestoreEditors'),\n\t\t\t\tellapsedViewletRestore: perf.getDuration('willRestoreViewlet', 'didRestoreViewlet'),\n\t\t\t\tellapsedPanelRestore: perf.getDuration('willRestorePanel', 'didRestorePanel'),\n\t\t\t\tellapsedWorkbench: perf.getDuration('willStartWorkbench', 'didStartWorkbench'),\n\t\t\t\tellapsedExtensionsReady: perf.getDuration(startMark, 'didLoadExtensions'),\n\t\t\t\tellapsedTimersToTimersComputed: Date.now() - now,\n\t\t\t},\n\n\t\t\t// system info\n\t\t\tplatform,\n\t\t\trelease,\n\t\t\tarch,\n\t\t\ttotalmem,\n\t\t\tfreemem,\n\t\t\tmeminfo,\n\t\t\tcpus,\n\t\t\tloadavg,\n\t\t\tinitialStartup,\n\t\t\tisVMLikelyhood,\n\t\t\thasAccessibilitySupport: this._accessibilityService.getAccessibilitySupport() === AccessibilitySupport.Enabled,\n\t\t\temptyWorkbench: this._contextService.getWorkbenchState() === WorkbenchState.EMPTY\n\t\t};\n\t}\n}\n\nexport const ITimerService = createDecorator<ITimerService>('timerService');\n\nregisterSingleton(ITimerService, TimerService, true);\n\n//#region cached data logic\n\nexport function didUseCachedData(): boolean {\n\treturn false;\n\t// We surely don't use cached data when we don't tell the loader to do so\n\tif (!Boolean((<any>global).require.getConfig().nodeCachedData)) {\n\t\treturn false;\n\t}\n\t// whenever cached data is produced or rejected a onNodeCachedData-callback is invoked. That callback\n\t// stores data in the `MonacoEnvironment.onNodeCachedData` global. See:\n\t// https://github.com/Microsoft/vscode/blob/efe424dfe76a492eab032343e2fa4cfe639939f0/src/vs/workbench/electron-browser/bootstrap/index.js#L299\n\tif (isNonEmptyArray(MonacoEnvironment.onNodeCachedData)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\ndeclare type OnNodeCachedDataArgs = [{ errorCode: string, path: string, detail?: string }, { path: string, length: number }];\ndeclare const MonacoEnvironment: { onNodeCachedData: OnNodeCachedDataArgs[] };\n\n//#endregion\n"]}]}