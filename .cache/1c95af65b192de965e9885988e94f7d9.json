{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/objects.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/objects.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/types\"], function (require, exports, types_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function deepClone(obj) {\n        if (!obj || typeof obj !== 'object') {\n            return obj;\n        }\n        if (obj instanceof RegExp) {\n            // See https://github.com/Microsoft/TypeScript/issues/10990\n            return obj;\n        }\n        const result = Array.isArray(obj) ? [] : {};\n        Object.keys(obj).forEach((key) => {\n            if (obj[key] && typeof obj[key] === 'object') {\n                result[key] = deepClone(obj[key]);\n            }\n            else {\n                result[key] = obj[key];\n            }\n        });\n        return result;\n    }\n    exports.deepClone = deepClone;\n    function deepFreeze(obj) {\n        if (!obj || typeof obj !== 'object') {\n            return obj;\n        }\n        const stack = [obj];\n        while (stack.length > 0) {\n            const obj = stack.shift();\n            Object.freeze(obj);\n            for (const key in obj) {\n                if (_hasOwnProperty.call(obj, key)) {\n                    const prop = obj[key];\n                    if (typeof prop === 'object' && !Object.isFrozen(prop)) {\n                        stack.push(prop);\n                    }\n                }\n            }\n        }\n        return obj;\n    }\n    exports.deepFreeze = deepFreeze;\n    const _hasOwnProperty = Object.prototype.hasOwnProperty;\n    function cloneAndChange(obj, changer) {\n        return _cloneAndChange(obj, changer, new Set());\n    }\n    exports.cloneAndChange = cloneAndChange;\n    function _cloneAndChange(obj, changer, seen) {\n        if (types_1.isUndefinedOrNull(obj)) {\n            return obj;\n        }\n        const changed = changer(obj);\n        if (typeof changed !== 'undefined') {\n            return changed;\n        }\n        if (types_1.isArray(obj)) {\n            const r1 = [];\n            for (const e of obj) {\n                r1.push(_cloneAndChange(e, changer, seen));\n            }\n            return r1;\n        }\n        if (types_1.isObject(obj)) {\n            if (seen.has(obj)) {\n                throw new Error('Cannot clone recursive data-structure');\n            }\n            seen.add(obj);\n            const r2 = {};\n            for (let i2 in obj) {\n                if (_hasOwnProperty.call(obj, i2)) {\n                    r2[i2] = _cloneAndChange(obj[i2], changer, seen);\n                }\n            }\n            seen.delete(obj);\n            return r2;\n        }\n        return obj;\n    }\n    /**\n     * Copies all properties of source into destination. The optional parameter \"overwrite\" allows to control\n     * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).\n     */\n    function mixin(destination, source, overwrite = true) {\n        if (!types_1.isObject(destination)) {\n            return source;\n        }\n        if (types_1.isObject(source)) {\n            Object.keys(source).forEach(key => {\n                if (key in destination) {\n                    if (overwrite) {\n                        if (types_1.isObject(destination[key]) && types_1.isObject(source[key])) {\n                            mixin(destination[key], source[key], overwrite);\n                        }\n                        else {\n                            destination[key] = source[key];\n                        }\n                    }\n                }\n                else {\n                    destination[key] = source[key];\n                }\n            });\n        }\n        return destination;\n    }\n    exports.mixin = mixin;\n    function assign(destination, ...sources) {\n        sources.forEach(source => Object.keys(source).forEach(key => destination[key] = source[key]));\n        return destination;\n    }\n    exports.assign = assign;\n    function equals(one, other) {\n        if (one === other) {\n            return true;\n        }\n        if (one === null || one === undefined || other === null || other === undefined) {\n            return false;\n        }\n        if (typeof one !== typeof other) {\n            return false;\n        }\n        if (typeof one !== 'object') {\n            return false;\n        }\n        if ((Array.isArray(one)) !== (Array.isArray(other))) {\n            return false;\n        }\n        let i;\n        let key;\n        if (Array.isArray(one)) {\n            if (one.length !== other.length) {\n                return false;\n            }\n            for (i = 0; i < one.length; i++) {\n                if (!equals(one[i], other[i])) {\n                    return false;\n                }\n            }\n        }\n        else {\n            const oneKeys = [];\n            for (key in one) {\n                oneKeys.push(key);\n            }\n            oneKeys.sort();\n            const otherKeys = [];\n            for (key in other) {\n                otherKeys.push(key);\n            }\n            otherKeys.sort();\n            if (!equals(oneKeys, otherKeys)) {\n                return false;\n            }\n            for (i = 0; i < oneKeys.length; i++) {\n                if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    exports.equals = equals;\n    function arrayToHash(array) {\n        const result = {};\n        for (const e of array) {\n            result[e] = true;\n        }\n        return result;\n    }\n    /**\n     * Given an array of strings, returns a function which, given a string\n     * returns true or false whether the string is in that array.\n     */\n    function createKeywordMatcher(arr, caseInsensitive = false) {\n        if (caseInsensitive) {\n            arr = arr.map(function (x) { return x.toLowerCase(); });\n        }\n        const hash = arrayToHash(arr);\n        if (caseInsensitive) {\n            return function (word) {\n                return hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());\n            };\n        }\n        else {\n            return function (word) {\n                return hash[word] !== undefined && hash.hasOwnProperty(word);\n            };\n        }\n    }\n    exports.createKeywordMatcher = createKeywordMatcher;\n    /**\n     * Calls JSON.Stringify with a replacer to break apart any circular references.\n     * This prevents JSON.stringify from throwing the exception\n     *  \"Uncaught TypeError: Converting circular structure to JSON\"\n     */\n    function safeStringify(obj) {\n        const seen = [];\n        return JSON.stringify(obj, (key, value) => {\n            if (types_1.isObject(value) || Array.isArray(value)) {\n                if (seen.indexOf(value) !== -1) {\n                    return '[Circular]';\n                }\n                else {\n                    seen.push(value);\n                }\n            }\n            return value;\n        });\n    }\n    exports.safeStringify = safeStringify;\n    function getOrDefault(obj, fn, defaultValue) {\n        const result = fn(obj);\n        return typeof result === 'undefined' ? defaultValue : result;\n    }\n    exports.getOrDefault = getOrDefault;\n    /**\n     * Returns an object that has keys for each value that is different in the base object. Keys\n     * that do not exist in the target but in the base object are not considered.\n     *\n     * Note: This is not a deep-diffing method, so the values are strictly taken into the resulting\n     * object if they differ.\n     *\n     * @param base the object to diff against\n     * @param obj the object to use for diffing\n     */\n    function distinct(base, target) {\n        const result = Object.create(null);\n        if (!base || !target) {\n            return result;\n        }\n        const targetKeys = Object.keys(target);\n        targetKeys.forEach(k => {\n            const baseValue = base[k];\n            const targetValue = target[k];\n            if (!equals(baseValue, targetValue)) {\n                result[k] = targetValue;\n            }\n        });\n        return result;\n    }\n    exports.distinct = distinct;\n});\n",null]}