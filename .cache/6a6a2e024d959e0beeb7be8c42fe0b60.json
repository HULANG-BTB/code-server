{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/packages/vscode/src/fill/windowsService.ts","dependencies":[{"path":"/home/coding/workspace/packages/vscode/src/fill/windowsService.ts","mtime":1555841535694},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"electron\", \"@coder/events\", \"@coder/logger\", \"vs/base/common/uri\", \"../client\", \"../dialog\", \"../workbench\"], function (require, exports, electron, events_1, logger_1, uri_1, client_1, dialog_1, workbench_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // tslint:disable completed-docs\n    // VS Code overrides window.open to call openExternal, but we then call\n    // window.open which results in an infinite loop. Store the function but also\n    // make it unable to be set (doesn't work otherwise).\n    const windowOpen = window.open;\n    Object.defineProperty(window, \"open\", {\n        set: () => { },\n        get: () => windowOpen,\n    });\n    /**\n     * Instead of going to the shared process, we'll directly run these methods on\n     * the client. This setup means we can only control the current window.\n     */\n    class WindowsService {\n        constructor() {\n            this.openEmitter = new events_1.Emitter();\n            this.focusEmitter = new events_1.Emitter();\n            this.blurEmitter = new events_1.Emitter();\n            this.maximizeEmitter = new events_1.Emitter();\n            this.unmaximizeEmitter = new events_1.Emitter();\n            this.recentlyOpenedChangeEmitter = new events_1.Emitter();\n            this.onWindowOpen = this.openEmitter.event;\n            this.onWindowFocus = this.focusEmitter.event;\n            this.onWindowBlur = this.blurEmitter.event;\n            this.onWindowMaximize = this.maximizeEmitter.event;\n            this.onWindowUnmaximize = this.unmaximizeEmitter.event;\n            this.onRecentlyOpenedChange = this.recentlyOpenedChangeEmitter.event;\n            this.window = new electron.BrowserWindow();\n        }\n        // Dialogs\n        pickFileFolderAndOpen(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                dialog_1.showOpenDialog(Object.assign({}, (options.dialogOptions || {}), { properties: {\n                        openFile: true,\n                        openDirectory: true,\n                    } })).then((path) => {\n                    // tslint:disable-next-line:no-any\n                    electron.ipcMain.send(\"vscode:openFiles\", {\n                        filesToOpen: [{\n                                fileUri: uri_1.URI.file(path),\n                            }],\n                    });\n                }).catch((ex) => {\n                    logger_1.logger.error(ex.message);\n                });\n            });\n        }\n        pickFileAndOpen(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                dialog_1.showOpenDialog(Object.assign({}, (options.dialogOptions || {}), { properties: {\n                        openFile: true,\n                    } })).then((path) => {\n                    // tslint:disable-next-line:no-any\n                    electron.ipcMain.send(\"vscode:openFiles\", {\n                        filesToOpen: [{\n                                fileUri: uri_1.URI.file(path),\n                            }],\n                    });\n                }).catch((ex) => {\n                    logger_1.logger.error(ex.message);\n                });\n            });\n        }\n        pickFolderAndOpen(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!options.dialogOptions) {\n                    options.dialogOptions = {};\n                }\n                if (!options.dialogOptions.title) {\n                    options.dialogOptions.title = \"Open Folder\";\n                }\n                dialog_1.showOpenDialog(Object.assign({}, (options.dialogOptions || {}), { properties: {\n                        openDirectory: true,\n                    } })).then((path) => {\n                    workbench_1.workbench.workspace = uri_1.URI.file(path);\n                }).catch((ex) => {\n                    logger_1.logger.error(ex.message);\n                });\n            });\n        }\n        pickWorkspaceAndOpen(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                dialog_1.showOpenDialog(Object.assign({}, (options.dialogOptions || {}), { properties: {\n                        openDirectory: true,\n                    } })).then((path) => {\n                    // tslint:disable-next-line:no-any\n                    electron.ipcMain.send(\"vscode:addFolders\", {\n                        foldersToAdd: [uri_1.URI.file(path)],\n                    });\n                }).catch((ex) => {\n                    logger_1.logger.error(ex.message);\n                });\n            });\n        }\n        showMessageBox(windowId, options) {\n            return new Promise((resolve) => {\n                electron.dialog.showMessageBox(this.getWindowById(windowId), options, (response, checkboxChecked) => {\n                    resolve({\n                        button: response,\n                        checkboxChecked,\n                    });\n                });\n            });\n        }\n        showSaveDialog(windowId, options) {\n            return new Promise((resolve) => {\n                electron.dialog.showSaveDialog(this.getWindowById(windowId), options, (filename, _bookmark) => {\n                    resolve(filename);\n                });\n            });\n        }\n        showOpenDialog(_windowId, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return [yield dialog_1.showOpenDialog(Object.assign({}, (options || {}), { properties: {\n                            openDirectory: options && options.properties && options.properties.includes(\"openDirectory\") || false,\n                            openFile: options && options.properties && options.properties.includes(\"openFile\") || false,\n                        } }))];\n            });\n        }\n        reloadWindow(windowId, _args) {\n            return Promise.resolve(this.getWindowById(windowId).reload());\n        }\n        openDevTools(_windowId, _options) {\n            throw new Error(\"not implemented\");\n        }\n        toggleDevTools(_windowId) {\n            throw new Error(\"Toggling developer tools from JavaScript is not supported.\");\n        }\n        closeWorkspace(_windowId) {\n            throw new Error(\"not implemented\");\n        }\n        enterWorkspace(_windowId, uri) {\n            if (uri.path.endsWith(\".json\")) {\n                workbench_1.workbench.workspace = {\n                    id: \"Untitled\",\n                    configPath: uri,\n                };\n            }\n            else {\n                workbench_1.workbench.workspace = uri;\n            }\n            return undefined;\n        }\n        createAndEnterWorkspace(_windowId, _folders, _path) {\n            throw new Error(\"not implemented\");\n        }\n        saveAndEnterWorkspace(_windowId, _path) {\n            throw new Error(\"not implemented\");\n        }\n        toggleFullScreen(windowId) {\n            const win = this.getWindowById(windowId);\n            return Promise.resolve(win.setFullScreen(!win.isFullScreen()));\n        }\n        setRepresentedFilename(windowId, fileName) {\n            return Promise.resolve(this.getWindowById(windowId).setRepresentedFilename(fileName));\n        }\n        addRecentlyOpened(_files) {\n            throw new Error(\"not implemented\");\n        }\n        removeFromRecentlyOpened(_paths) {\n            throw new Error(\"not implemented\");\n        }\n        clearRecentlyOpened() {\n            throw new Error(\"not implemented\");\n        }\n        getRecentlyOpened(_windowId) {\n            // TODO: properly implement.\n            return Promise.resolve({\n                workspaces: [],\n                files: [],\n            });\n        }\n        focusWindow(windowId) {\n            return Promise.resolve(this.getWindowById(windowId).focus());\n        }\n        closeWindow(_windowId) {\n            throw new Error(\"not implemented\");\n        }\n        isFocused(windowId) {\n            return Promise.resolve(this.getWindowById(windowId).isFocused());\n        }\n        isMaximized(_windowId) {\n            throw new Error(\"not implemented\");\n        }\n        maximizeWindow(_windowId) {\n            throw new Error(\"not implemented\");\n        }\n        unmaximizeWindow(_windowId) {\n            throw new Error(\"not implemented\");\n        }\n        minimizeWindow(_windowId) {\n            throw new Error(\"not implemented\");\n        }\n        onWindowTitleDoubleClick(_windowId) {\n            throw new Error(\"not implemented\");\n        }\n        setDocumentEdited(_windowId, _flag) {\n            throw new Error(\"not implemented\");\n        }\n        quit() {\n            throw new Error(\"not implemented\");\n        }\n        relaunch(_options) {\n            throw new Error(\"not implemented\");\n        }\n        // macOS Native Tabs\n        newWindowTab() {\n            throw new Error(\"not implemented\");\n        }\n        showPreviousWindowTab() {\n            throw new Error(\"not implemented\");\n        }\n        showNextWindowTab() {\n            throw new Error(\"not implemented\");\n        }\n        moveWindowTabToNewWindow() {\n            throw new Error(\"not implemented\");\n        }\n        mergeAllWindowTabs() {\n            throw new Error(\"not implemented\");\n        }\n        toggleWindowTabsBar() {\n            throw new Error(\"not implemented\");\n        }\n        // macOS TouchBar\n        updateTouchBar(_windowId, _items) {\n            throw new Error(\"not implemented\");\n        }\n        // Shared process\n        whenSharedProcessReady() {\n            return __awaiter(this, void 0, void 0, function* () {\n                yield client_1.client.sharedProcessData;\n            });\n        }\n        toggleSharedProcess() {\n            throw new Error(\"not implemented\");\n        }\n        // Global methods\n        openWindow(_windowId, _uris, _options) {\n            throw new Error(\"not implemented\");\n        }\n        openNewWindow(_options) {\n            throw new Error(\"not implemented\");\n        }\n        showWindow(windowId) {\n            return Promise.resolve(this.getWindowById(windowId).show());\n        }\n        getWindows() {\n            throw new Error(\"not implemented\");\n        }\n        getWindowCount() {\n            return Promise.resolve(1);\n        }\n        log(_severity, ..._messages) {\n            throw new Error(\"not implemented\");\n        }\n        showItemInFolder(uri) {\n            return __awaiter(this, void 0, void 0, function* () {\n                workbench_1.workbench.workspace = uri;\n            });\n        }\n        getActiveWindowId() {\n            return Promise.resolve(1);\n        }\n        openExternal(_url) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return typeof window.open(_url, \"_blank\") !== \"undefined\";\n            });\n        }\n        startCrashReporter(_config) {\n            throw new Error(\"not implemented\");\n        }\n        openAboutDialog() {\n            throw new Error(\"not implemented\");\n        }\n        resolveProxy(windowId, url) {\n            return new Promise((resolve) => {\n                this.getWindowById(windowId).webContents.session.resolveProxy(url, (proxy) => {\n                    resolve(proxy);\n                });\n            });\n        }\n        /**\n         * Get window by ID. For now this is always the current window.\n         */\n        getWindowById(_windowId) {\n            return this.window;\n        }\n    }\n    exports.WindowsService = WindowsService;\n});\n",null]}