{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/resources.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/resources.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/extpath\", \"vs/base/common/path\", \"vs/base/common/uri\", \"vs/base/common/strings\", \"vs/base/common/network\", \"vs/base/common/platform\", \"vs/base/common/charCode\", \"vs/base/common/glob\", \"vs/base/common/map\"], function (require, exports, extpath, paths, uri_1, strings_1, network_1, platform_1, charCode_1, glob_1, map_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function getComparisonKey(resource) {\n        return hasToIgnoreCase(resource) ? resource.toString().toLowerCase() : resource.toString();\n    }\n    exports.getComparisonKey = getComparisonKey;\n    function hasToIgnoreCase(resource) {\n        // A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n        // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n        return resource && resource.scheme === network_1.Schemas.file ? !platform_1.isLinux : true;\n    }\n    exports.hasToIgnoreCase = hasToIgnoreCase;\n    function basenameOrAuthority(resource) {\n        return basename(resource) || resource.authority;\n    }\n    exports.basenameOrAuthority = basenameOrAuthority;\n    /**\n     * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n     * @param base A uri which is \"longer\"\n     * @param parentCandidate A uri which is \"shorter\" then `base`\n     */\n    function isEqualOrParent(base, parentCandidate, ignoreCase = hasToIgnoreCase(base)) {\n        if (base.scheme === parentCandidate.scheme) {\n            if (base.scheme === network_1.Schemas.file) {\n                return extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), ignoreCase);\n            }\n            if (isEqualAuthority(base.authority, parentCandidate.authority)) {\n                return extpath.isEqualOrParent(base.path, parentCandidate.path, ignoreCase, '/');\n            }\n        }\n        return false;\n    }\n    exports.isEqualOrParent = isEqualOrParent;\n    /**\n     * Tests wheter the two authorities are the same\n     */\n    function isEqualAuthority(a1, a2) {\n        return a1 === a2 || strings_1.equalsIgnoreCase(a1, a2);\n    }\n    exports.isEqualAuthority = isEqualAuthority;\n    function isEqual(first, second, ignoreCase = hasToIgnoreCase(first)) {\n        if (first === second) {\n            return true;\n        }\n        if (!first || !second) {\n            return false;\n        }\n        if (first.scheme !== second.scheme || !isEqualAuthority(first.authority, second.authority)) {\n            return false;\n        }\n        const p1 = first.path || '/', p2 = second.path || '/';\n        return p1 === p2 || ignoreCase && strings_1.equalsIgnoreCase(p1 || '/', p2 || '/');\n    }\n    exports.isEqual = isEqual;\n    function basename(resource) {\n        return paths.posix.basename(resource.path);\n    }\n    exports.basename = basename;\n    function extname(resource) {\n        return paths.posix.extname(resource.path);\n    }\n    exports.extname = extname;\n    /**\n     * Return a URI representing the directory of a URI path.\n     *\n     * @param resource The input URI.\n     * @returns The URI representing the directory of the input URI.\n     */\n    function dirname(resource) {\n        if (resource.path.length === 0) {\n            return resource;\n        }\n        if (resource.scheme === network_1.Schemas.file) {\n            return uri_1.URI.file(paths.dirname(originalFSPath(resource)));\n        }\n        let dirname = paths.posix.dirname(resource.path);\n        if (resource.authority && dirname.length && dirname.charCodeAt(0) !== charCode_1.CharCode.Slash) {\n            console.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n            dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n        }\n        return resource.with({\n            path: dirname\n        });\n    }\n    exports.dirname = dirname;\n    /**\n     * Join a URI path with path fragments and normalizes the resulting path.\n     *\n     * @param resource The input URI.\n     * @param pathFragment The path fragment to add to the URI path.\n     * @returns The resulting URI.\n     */\n    function joinPath(resource, ...pathFragment) {\n        let joinedPath;\n        if (resource.scheme === network_1.Schemas.file) {\n            joinedPath = uri_1.URI.file(paths.join(originalFSPath(resource), ...pathFragment)).path;\n        }\n        else {\n            joinedPath = paths.posix.join(resource.path || '/', ...pathFragment);\n        }\n        return resource.with({\n            path: joinedPath\n        });\n    }\n    exports.joinPath = joinPath;\n    /**\n     * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n     *\n     * @param resource The URI to normalize the path.\n     * @returns The URI with the normalized path.\n     */\n    function normalizePath(resource) {\n        if (!resource.path.length) {\n            return resource;\n        }\n        let normalizedPath;\n        if (resource.scheme === network_1.Schemas.file) {\n            normalizedPath = uri_1.URI.file(paths.normalize(originalFSPath(resource))).path;\n        }\n        else {\n            normalizedPath = paths.posix.normalize(resource.path);\n        }\n        return resource.with({\n            path: normalizedPath\n        });\n    }\n    exports.normalizePath = normalizePath;\n    /**\n     * Returns the fsPath of an URI where the drive letter is not normalized.\n     * See #56403.\n     */\n    function originalFSPath(uri) {\n        let value;\n        const uriPath = uri.path;\n        if (uri.authority && uriPath.length > 1 && uri.scheme === 'file') {\n            // unc path: file://shares/c$/far/boo\n            value = `//${uri.authority}${uriPath}`;\n        }\n        else if (platform_1.isWindows\n            && uriPath.charCodeAt(0) === charCode_1.CharCode.Slash\n            && extpath.isWindowsDriveLetter(uriPath.charCodeAt(1))\n            && uriPath.charCodeAt(2) === charCode_1.CharCode.Colon) {\n            value = uriPath.substr(1);\n        }\n        else {\n            // other path\n            value = uriPath;\n        }\n        if (platform_1.isWindows) {\n            value = value.replace(/\\//g, '\\\\');\n        }\n        return value;\n    }\n    exports.originalFSPath = originalFSPath;\n    /**\n     * Returns true if the URI path is absolute.\n     */\n    function isAbsolutePath(resource) {\n        return !!resource.path && resource.path[0] === '/';\n    }\n    exports.isAbsolutePath = isAbsolutePath;\n    /**\n     * Returns true if the URI path has a trailing path separator\n     */\n    function hasTrailingPathSeparator(resource) {\n        if (resource.scheme === network_1.Schemas.file) {\n            const fsp = originalFSPath(resource);\n            return fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === paths.sep;\n        }\n        else {\n            const p = resource.path;\n            return p.length > 1 && p.charCodeAt(p.length - 1) === charCode_1.CharCode.Slash; // ignore the slash at offset 0\n        }\n    }\n    exports.hasTrailingPathSeparator = hasTrailingPathSeparator;\n    /**\n     * Removes a trailing path seperator, if theres one.\n     * Important: Doesn't remove the first slash, it would make the URI invalid\n     */\n    function removeTrailingPathSeparator(resource) {\n        if (hasTrailingPathSeparator(resource)) {\n            return resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n        }\n        return resource;\n    }\n    exports.removeTrailingPathSeparator = removeTrailingPathSeparator;\n    /**\n     * Returns a relative path between two URIs. If the URIs don't have the same schema or authority, `undefined` is returned.\n     * The returned relative path always uses forward slashes.\n     */\n    function relativePath(from, to) {\n        if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n            return undefined;\n        }\n        if (from.scheme === network_1.Schemas.file) {\n            const relativePath = paths.relative(from.path, to.path);\n            return platform_1.isWindows ? extpath.toSlashes(relativePath) : relativePath;\n        }\n        return paths.posix.relative(from.path || '/', to.path || '/');\n    }\n    exports.relativePath = relativePath;\n    /**\n     * Resolves a absolute or relative path against a base URI.\n     */\n    function resolvePath(base, path) {\n        if (base.scheme === network_1.Schemas.file) {\n            const newURI = uri_1.URI.file(paths.resolve(originalFSPath(base), path));\n            return base.with({\n                authority: newURI.authority,\n                path: newURI.path\n            });\n        }\n        return base.with({\n            path: paths.posix.resolve(base.path, path)\n        });\n    }\n    exports.resolvePath = resolvePath;\n    function distinctParents(items, resourceAccessor) {\n        const distinctParents = [];\n        for (let i = 0; i < items.length; i++) {\n            const candidateResource = resourceAccessor(items[i]);\n            if (items.some((otherItem, index) => {\n                if (index === i) {\n                    return false;\n                }\n                return isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n            })) {\n                continue;\n            }\n            distinctParents.push(items[i]);\n        }\n        return distinctParents;\n    }\n    exports.distinctParents = distinctParents;\n    /**\n     * Data URI related helpers.\n     */\n    var DataUri;\n    (function (DataUri) {\n        DataUri.META_DATA_LABEL = 'label';\n        DataUri.META_DATA_DESCRIPTION = 'description';\n        DataUri.META_DATA_SIZE = 'size';\n        DataUri.META_DATA_MIME = 'mime';\n        function parseMetaData(dataUri) {\n            const metadata = new Map();\n            // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n            // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n            const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n            meta.split(';').forEach(property => {\n                const [key, value] = property.split(':');\n                if (key && value) {\n                    metadata.set(key, value);\n                }\n            });\n            // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n            // the mime is: image/png\n            const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n            if (mime) {\n                metadata.set(DataUri.META_DATA_MIME, mime);\n            }\n            return metadata;\n        }\n        DataUri.parseMetaData = parseMetaData;\n    })(DataUri = exports.DataUri || (exports.DataUri = {}));\n    class ResourceGlobMatcher {\n        constructor(globalExpression, rootExpressions) {\n            this.expressionsByRoot = map_1.TernarySearchTree.forPaths();\n            this.globalExpression = glob_1.parse(globalExpression);\n            for (const expression of rootExpressions) {\n                this.expressionsByRoot.set(expression.root.toString(), { root: expression.root, expression: glob_1.parse(expression.expression) });\n            }\n        }\n        matches(resource) {\n            const rootExpression = this.expressionsByRoot.findSubstr(resource.toString());\n            if (rootExpression) {\n                const path = relativePath(rootExpression.root, resource);\n                if (path && !!rootExpression.expression(path)) {\n                    return true;\n                }\n            }\n            return !!this.globalExpression(resource.path);\n        }\n    }\n    exports.ResourceGlobMatcher = ResourceGlobMatcher;\n});\n",null]}