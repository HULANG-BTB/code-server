{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/node/debugger.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/node/debugger.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/parts/ipc/node/ipc.cp\", \"vs/base/common/strings\", \"vs/base/common/objects\", \"vs/base/common/types\", \"vs/platform/telemetry/node/telemetryIpc\", \"vs/workbench/contrib/debug/common/debug\", \"vs/platform/configuration/common/configuration\", \"vs/platform/commands/common/commands\", \"vs/workbench/contrib/debug/node/debugAdapter\", \"vs/workbench/services/configurationResolver/common/configurationResolver\", \"vs/workbench/services/configurationResolver/common/configurationResolverUtils\", \"vs/platform/telemetry/common/telemetryService\", \"vs/platform/telemetry/common/telemetry\", \"vs/base/common/decorators\", \"vs/workbench/contrib/tasks/common/taskDefinitionRegistry\", \"vs/base/common/amd\", \"vs/editor/common/services/resourceConfiguration\", \"vs/base/common/uri\", \"vs/base/common/network\", \"vs/workbench/contrib/debug/common/debugUtils\"], function (require, exports, nls, ipc_cp_1, strings, objects, types_1, telemetryIpc_1, debug_1, configuration_1, commands_1, debugAdapter_1, configurationResolver_1, ConfigurationResolverUtils, telemetryService_1, telemetry_1, decorators_1, taskDefinitionRegistry_1, amd_1, resourceConfiguration_1, uri_1, network_1, debugUtils_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let Debugger = class Debugger {\n        constructor(configurationManager, dbgContribution, extensionDescription, configurationService, resourcePropertiesService, commandService, configurationResolverService, telemetryService) {\n            this.configurationManager = configurationManager;\n            this.configurationService = configurationService;\n            this.resourcePropertiesService = resourcePropertiesService;\n            this.commandService = commandService;\n            this.configurationResolverService = configurationResolverService;\n            this.telemetryService = telemetryService;\n            this.mergedExtensionDescriptions = [];\n            this.debuggerContribution = { type: dbgContribution.type };\n            this.merge(dbgContribution, extensionDescription);\n        }\n        merge(otherDebuggerContribution, extensionDescription) {\n            /**\n             * Copies all properties of source into destination. The optional parameter \"overwrite\" allows to control\n             * if existing non-structured properties on the destination should be overwritten or not. Defaults to true (overwrite).\n             */\n            function mixin(destination, source, overwrite, level = 0) {\n                if (!types_1.isObject(destination)) {\n                    return source;\n                }\n                if (types_1.isObject(source)) {\n                    Object.keys(source).forEach(key => {\n                        if (types_1.isObject(destination[key]) && types_1.isObject(source[key])) {\n                            mixin(destination[key], source[key], overwrite, level + 1);\n                        }\n                        else {\n                            if (key in destination) {\n                                if (overwrite) {\n                                    if (level === 0 && key === 'type') {\n                                        // don't merge the 'type' property\n                                    }\n                                    else {\n                                        destination[key] = source[key];\n                                    }\n                                }\n                            }\n                            else {\n                                destination[key] = source[key];\n                            }\n                        }\n                    });\n                }\n                return destination;\n            }\n            // only if not already merged\n            if (this.mergedExtensionDescriptions.indexOf(extensionDescription) < 0) {\n                // remember all extensions that have been merged for this debugger\n                this.mergedExtensionDescriptions.push(extensionDescription);\n                // merge new debugger contribution into existing contributions (and don't overwrite values in built-in extensions)\n                mixin(this.debuggerContribution, otherDebuggerContribution, extensionDescription.isBuiltin);\n                // remember the extension that is considered the \"main\" debugger contribution\n                if (debugUtils_1.isDebuggerMainContribution(otherDebuggerContribution)) {\n                    this.mainExtensionDescription = extensionDescription;\n                }\n            }\n        }\n        createDebugAdapter(session, outputService) {\n            return this.configurationManager.activateDebuggers('onDebugAdapterProtocolTracker', this.type).then(_ => {\n                if (this.inExtHost()) {\n                    const da = this.configurationManager.createDebugAdapter(session);\n                    if (da) {\n                        return Promise.resolve(da);\n                    }\n                    throw new Error(nls.localize('cannot.find.da', \"Cannot find debug adapter for type '{0}'.\", this.type));\n                }\n                else {\n                    return this.getAdapterDescriptor(session).then(adapterDescriptor => {\n                        switch (adapterDescriptor.type) {\n                            case 'executable':\n                                return new debugAdapter_1.ExecutableDebugAdapter(adapterDescriptor, this.type, outputService);\n                            case 'server':\n                                return new debugAdapter_1.SocketDebugAdapter(adapterDescriptor);\n                            case 'implementation':\n                                // TODO@AW: this.inExtHost() should now return true\n                                return Promise.resolve(this.configurationManager.createDebugAdapter(session));\n                            default:\n                                throw new Error('unknown descriptor type');\n                        }\n                    }).catch(err => {\n                        if (err && err.message) {\n                            throw new Error(nls.localize('cannot.create.da.with.err', \"Cannot create debug adapter ({0}).\", err.message));\n                        }\n                        else {\n                            throw new Error(nls.localize('cannot.create.da', \"Cannot create debug adapter.\"));\n                        }\n                    });\n                }\n            });\n        }\n        getAdapterDescriptor(session) {\n            // a \"debugServer\" attribute in the launch config takes precedence\n            if (typeof session.configuration.debugServer === 'number') {\n                return Promise.resolve({\n                    type: 'server',\n                    port: session.configuration.debugServer\n                });\n            }\n            // try the new \"createDebugAdapterDescriptor\" and the deprecated \"provideDebugAdapter\" API\n            return this.configurationManager.getDebugAdapterDescriptor(session).then(adapter => {\n                if (adapter) {\n                    return adapter;\n                }\n                // try deprecated command based extension API \"adapterExecutableCommand\" to determine the executable\n                if (this.debuggerContribution.adapterExecutableCommand) {\n                    console.info('debugAdapterExecutable attribute in package.json is deprecated and support for it will be removed soon; please use DebugAdapterDescriptorFactory.createDebugAdapterDescriptor instead.');\n                    const rootFolder = session.root ? session.root.uri.toString() : undefined;\n                    return this.commandService.executeCommand(this.debuggerContribution.adapterExecutableCommand, rootFolder).then(ae => {\n                        if (ae) {\n                            return {\n                                type: 'executable',\n                                command: ae.command,\n                                args: ae.args || []\n                            };\n                        }\n                        throw new Error('command adapterExecutableCommand did not return proper command.');\n                    });\n                }\n                // fallback: use executable information from package.json\n                const ae = debugAdapter_1.ExecutableDebugAdapter.platformAdapterExecutable(this.mergedExtensionDescriptions, this.type);\n                if (ae === undefined) {\n                    throw new Error('no executable specified in package.json');\n                }\n                return ae;\n            });\n        }\n        substituteVariables(folder, config) {\n            if (this.inExtHost()) {\n                return this.configurationManager.substituteVariables(this.type, folder, config).then(config => {\n                    return this.configurationResolverService.resolveWithInteractionReplace(folder, config, 'launch', this.variables);\n                });\n            }\n            else {\n                return this.configurationResolverService.resolveWithInteractionReplace(folder, config, 'launch', this.variables);\n            }\n        }\n        runInTerminal(args) {\n            const config = this.configurationService.getValue('terminal');\n            return this.configurationManager.runInTerminal(this.inExtHost() ? this.type : '*', args, config);\n        }\n        inExtHost() {\n            return true;\n        }\n        get label() {\n            return this.debuggerContribution.label || this.debuggerContribution.type;\n        }\n        get type() {\n            return this.debuggerContribution.type;\n        }\n        get variables() {\n            return this.debuggerContribution.variables;\n        }\n        get configurationSnippets() {\n            return this.debuggerContribution.configurationSnippets;\n        }\n        get languages() {\n            return this.debuggerContribution.languages;\n        }\n        hasInitialConfiguration() {\n            return !!this.debuggerContribution.initialConfigurations;\n        }\n        hasConfigurationProvider() {\n            return this.configurationManager.hasDebugConfigurationProvider(this.type);\n        }\n        getInitialConfigurationContent(initialConfigs) {\n            // at this point we got some configs from the package.json and/or from registered DebugConfigurationProviders\n            let initialConfigurations = this.debuggerContribution.initialConfigurations || [];\n            if (initialConfigs) {\n                initialConfigurations = initialConfigurations.concat(initialConfigs);\n            }\n            const eol = this.resourcePropertiesService.getEOL(uri_1.URI.from({ scheme: network_1.Schemas.untitled, path: '1' })) === '\\r\\n' ? '\\r\\n' : '\\n';\n            const configs = JSON.stringify(initialConfigurations, null, '\\t').split('\\n').map(line => '\\t' + line).join(eol).trim();\n            const comment1 = nls.localize('launch.config.comment1', \"Use IntelliSense to learn about possible attributes.\");\n            const comment2 = nls.localize('launch.config.comment2', \"Hover to view descriptions of existing attributes.\");\n            const comment3 = nls.localize('launch.config.comment3', \"For more information, visit: {0}\", 'https://go.microsoft.com/fwlink/?linkid=830387');\n            let content = [\n                '{',\n                `\\t// ${comment1}`,\n                `\\t// ${comment2}`,\n                `\\t// ${comment3}`,\n                `\\t\"version\": \"0.2.0\",`,\n                `\\t\"configurations\": ${configs}`,\n                '}'\n            ].join(eol);\n            // fix formatting\n            const editorConfig = this.configurationService.getValue();\n            if (editorConfig.editor && editorConfig.editor.insertSpaces) {\n                content = content.replace(new RegExp('\\t', 'g'), strings.repeat(' ', editorConfig.editor.tabSize));\n            }\n            return Promise.resolve(content);\n        }\n        getMainExtensionDescriptor() {\n            return this.mainExtensionDescription || this.mergedExtensionDescriptions[0];\n        }\n        getCustomTelemetryService() {\n            const aiKey = this.debuggerContribution.aiKey;\n            if (!aiKey) {\n                return Promise.resolve(undefined);\n            }\n            return this.telemetryService.getTelemetryInfo().then(info => {\n                const telemetryInfo = Object.create(null);\n                telemetryInfo['common.vscodemachineid'] = info.machineId;\n                telemetryInfo['common.vscodesessionid'] = info.sessionId;\n                return telemetryInfo;\n            }).then(data => {\n                const client = new ipc_cp_1.Client(amd_1.getPathFromAmdModule(require, 'bootstrap-fork'), {\n                    serverName: 'Debug Telemetry',\n                    timeout: 1000 * 60 * 5,\n                    args: [`${this.getMainExtensionDescriptor().publisher}.${this.type}`, JSON.stringify(data), aiKey],\n                    env: {\n                        ELECTRON_RUN_AS_NODE: 1,\n                        PIPE_LOGGING: 'true',\n                        AMD_ENTRYPOINT: 'vs/workbench/contrib/debug/node/telemetryApp'\n                    }\n                });\n                const channel = client.getChannel('telemetryAppender');\n                const appender = new telemetryIpc_1.TelemetryAppenderClient(channel);\n                return new telemetryService_1.TelemetryService({ appender }, this.configurationService);\n            });\n        }\n        getSchemaAttributes() {\n            if (!this.debuggerContribution.configurationAttributes) {\n                return null;\n            }\n            // fill in the default configuration attributes shared by all adapters.\n            const taskSchema = taskDefinitionRegistry_1.TaskDefinitionRegistry.getJsonSchema();\n            return Object.keys(this.debuggerContribution.configurationAttributes).map(request => {\n                const attributes = this.debuggerContribution.configurationAttributes[request];\n                const defaultRequired = ['name', 'type', 'request'];\n                attributes.required = attributes.required && attributes.required.length ? defaultRequired.concat(attributes.required) : defaultRequired;\n                attributes.additionalProperties = false;\n                attributes.type = 'object';\n                if (!attributes.properties) {\n                    attributes.properties = {};\n                }\n                const properties = attributes.properties;\n                properties['type'] = {\n                    enum: [this.type],\n                    description: nls.localize('debugType', \"Type of configuration.\"),\n                    pattern: '^(?!node2)',\n                    errorMessage: nls.localize('debugTypeNotRecognised', \"The debug type is not recognized. Make sure that you have a corresponding debug extension installed and that it is enabled.\"),\n                    patternErrorMessage: nls.localize('node2NotSupported', \"\\\"node2\\\" is no longer supported, use \\\"node\\\" instead and set the \\\"protocol\\\" attribute to \\\"inspector\\\".\")\n                };\n                properties['name'] = {\n                    type: 'string',\n                    description: nls.localize('debugName', \"Name of configuration; appears in the launch configuration drop down menu.\"),\n                    default: 'Launch'\n                };\n                properties['request'] = {\n                    enum: [request],\n                    description: nls.localize('debugRequest', \"Request type of configuration. Can be \\\"launch\\\" or \\\"attach\\\".\"),\n                };\n                properties['debugServer'] = {\n                    type: 'number',\n                    description: nls.localize('debugServer', \"For debug extension development only: if a port is specified VS Code tries to connect to a debug adapter running in server mode\"),\n                    default: 4711\n                };\n                properties['preLaunchTask'] = {\n                    anyOf: [taskSchema, {\n                            type: ['string', 'null'],\n                        }],\n                    default: '',\n                    description: nls.localize('debugPrelaunchTask', \"Task to run before debug session starts.\")\n                };\n                properties['postDebugTask'] = {\n                    anyOf: [taskSchema, {\n                            type: ['string', 'null'],\n                        }],\n                    default: '',\n                    description: nls.localize('debugPostDebugTask', \"Task to run after debug session ends.\")\n                };\n                properties['internalConsoleOptions'] = debug_1.INTERNAL_CONSOLE_OPTIONS_SCHEMA;\n                // Clear out windows, linux and osx fields to not have cycles inside the properties object\n                delete properties['windows'];\n                delete properties['osx'];\n                delete properties['linux'];\n                const osProperties = objects.deepClone(properties);\n                properties['windows'] = {\n                    type: 'object',\n                    description: nls.localize('debugWindowsConfiguration', \"Windows specific launch configuration attributes.\"),\n                    properties: osProperties\n                };\n                properties['osx'] = {\n                    type: 'object',\n                    description: nls.localize('debugOSXConfiguration', \"OS X specific launch configuration attributes.\"),\n                    properties: osProperties\n                };\n                properties['linux'] = {\n                    type: 'object',\n                    description: nls.localize('debugLinuxConfiguration', \"Linux specific launch configuration attributes.\"),\n                    properties: osProperties\n                };\n                Object.keys(properties).forEach(name => {\n                    // Use schema allOf property to get independent error reporting #21113\n                    ConfigurationResolverUtils.applyDeprecatedVariableMessage(properties[name]);\n                });\n                return attributes;\n            });\n        }\n    };\n    __decorate([\n        decorators_1.memoize\n    ], Debugger.prototype, \"getCustomTelemetryService\", null);\n    Debugger = __decorate([\n        __param(3, configuration_1.IConfigurationService),\n        __param(4, resourceConfiguration_1.ITextResourcePropertiesService),\n        __param(5, commands_1.ICommandService),\n        __param(6, configurationResolver_1.IConfigurationResolverService),\n        __param(7, telemetry_1.ITelemetryService)\n    ], Debugger);\n    exports.Debugger = Debugger;\n});\n",null]}