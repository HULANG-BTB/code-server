{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/packages/events/src/events.ts","dependencies":[{"path":"/home/coding/workspace/packages/events/src/events.ts","mtime":1555841535682},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["define([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emitter typecasts for a single event type. You can optionally use IDs, but\n     * using undefined with IDs will not work. If you emit without an ID, *all*\n     * listeners regardless of their ID (or lack thereof) will receive the event.\n     * Similarly, if you listen without an ID you will get *all* events for any or\n     * no ID.\n     */\n    class Emitter {\n        constructor() {\n            this.listeners = [];\n            this.idListeners = new Map();\n        }\n        get event() {\n            return (id, cb) => {\n                if (typeof id !== \"function\") {\n                    if (this.idListeners.has(id)) {\n                        this.idListeners.get(id).push(cb);\n                    }\n                    else {\n                        this.idListeners.set(id, [cb]);\n                    }\n                    return {\n                        dispose: () => {\n                            if (this.idListeners.has(id)) {\n                                const cbs = this.idListeners.get(id);\n                                const i = cbs.indexOf(cb);\n                                if (i !== -1) {\n                                    cbs.splice(i, 1);\n                                }\n                            }\n                        },\n                    };\n                }\n                cb = id;\n                this.listeners.push(cb);\n                return {\n                    dispose: () => {\n                        const i = this.listeners.indexOf(cb);\n                        if (i !== -1) {\n                            this.listeners.splice(i, 1);\n                        }\n                    },\n                };\n            };\n        }\n        emit(id, value) {\n            if ((typeof id === \"number\" || typeof id === \"string\") && typeof value !== \"undefined\") {\n                if (this.idListeners.has(id)) {\n                    this.idListeners.get(id).forEach((cb) => cb(value));\n                }\n                this.listeners.forEach((cb) => cb(value));\n            }\n            else {\n                this.idListeners.forEach((cbs) => cbs.forEach((cb) => cb(id)));\n                this.listeners.forEach((cb) => cb(id));\n            }\n        }\n        dispose(id) {\n            if (typeof id !== \"undefined\") {\n                this.idListeners.delete(id);\n            }\n            else {\n                this.listeners = [];\n                this.idListeners.clear();\n            }\n        }\n        get counts() {\n            const counts = {};\n            if (this.listeners.length > 0) {\n                counts[\"n/a\"] = this.listeners.length;\n            }\n            this.idListeners.forEach((cbs, id) => {\n                if (cbs.length > 0) {\n                    counts[`${id}`] = cbs.length;\n                }\n            });\n            return counts;\n        }\n    }\n    exports.Emitter = Emitter;\n});\n",null]}