{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/node/storage.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/storage.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar event_1 = require(\"vs/base/common/event\");\nvar async_1 = require(\"vs/base/common/async\");\nvar types_1 = require(\"vs/base/common/types\");\nvar map_1 = require(\"vs/base/common/map\");\nvar path_1 = require(\"vs/base/common/path\");\nvar pfs_1 = require(\"vs/base/node/pfs\");\nvar arrays_1 = require(\"vs/base/common/arrays\");\nvar StorageHint;\n(function (StorageHint) {\n    // A hint to the storage that the storage\n    // does not exist on disk yet. This allows\n    // the storage library to improve startup\n    // time by not checking the storage for data.\n    StorageHint[StorageHint[\"STORAGE_DOES_NOT_EXIST\"] = 0] = \"STORAGE_DOES_NOT_EXIST\";\n})(StorageHint = exports.StorageHint || (exports.StorageHint = {}));\nvar StorageState;\n(function (StorageState) {\n    StorageState[StorageState[\"None\"] = 0] = \"None\";\n    StorageState[StorageState[\"Initialized\"] = 1] = \"Initialized\";\n    StorageState[StorageState[\"Closed\"] = 2] = \"Closed\";\n})(StorageState || (StorageState = {}));\nvar Storage = /** @class */ (function (_super) {\n    tslib_1.__extends(Storage, _super);\n    function Storage(database, options) {\n        if (options === void 0) { options = Object.create(null); }\n        var _this = _super.call(this) || this;\n        _this.database = database;\n        _this.options = options;\n        _this._onDidChangeStorage = _this._register(new event_1.Emitter());\n        _this.state = StorageState.None;\n        _this.cache = new Map();\n        _this.pendingDeletes = new Set();\n        _this.pendingInserts = new Map();\n        _this.flushDelayer = _this._register(new async_1.ThrottledDelayer(Storage.DEFAULT_FLUSH_DELAY));\n        _this.registerListeners();\n        return _this;\n    }\n    Object.defineProperty(Storage.prototype, \"onDidChangeStorage\", {\n        get: function () { return this._onDidChangeStorage.event; },\n        enumerable: true,\n        configurable: true\n    });\n    Storage.prototype.registerListeners = function () {\n        var _this = this;\n        this._register(this.database.onDidChangeItemsExternal(function (e) { return _this.onDidChangeItemsExternal(e); }));\n    };\n    Storage.prototype.onDidChangeItemsExternal = function (e) {\n        var _this = this;\n        // items that change external require us to update our\n        // caches with the values. we just accept the value and\n        // emit an event if there is a change.\n        e.items.forEach(function (value, key) { return _this.accept(key, value); });\n    };\n    Storage.prototype.accept = function (key, value) {\n        if (this.state === StorageState.Closed) {\n            return; // Return early if we are already closed\n        }\n        var changed = false;\n        // Item got removed, check for deletion\n        if (types_1.isUndefinedOrNull(value)) {\n            changed = this.cache.delete(key);\n        }\n        // Item got updated, check for change\n        else {\n            var currentValue = this.cache.get(key);\n            if (currentValue !== value) {\n                this.cache.set(key, value);\n                changed = true;\n            }\n        }\n        // Signal to outside listeners\n        if (changed) {\n            this._onDidChangeStorage.fire(key);\n        }\n    };\n    Object.defineProperty(Storage.prototype, \"items\", {\n        get: function () {\n            return this.cache;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Storage.prototype, \"size\", {\n        get: function () {\n            return this.cache.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Storage.prototype.init = function () {\n        var _this = this;\n        if (this.state !== StorageState.None) {\n            return Promise.resolve(); // either closed or already initialized\n        }\n        this.state = StorageState.Initialized;\n        if (this.options.hint === StorageHint.STORAGE_DOES_NOT_EXIST) {\n            // return early if we know the storage file does not exist. this is a performance\n            // optimization to not load all items of the underlying storage if we know that\n            // there can be no items because the storage does not exist.\n            return Promise.resolve();\n        }\n        return this.database.getItems().then(function (items) {\n            _this.cache = items;\n        });\n    };\n    Storage.prototype.get = function (key, fallbackValue) {\n        var value = this.cache.get(key);\n        if (types_1.isUndefinedOrNull(value)) {\n            return fallbackValue;\n        }\n        return value;\n    };\n    Storage.prototype.getBoolean = function (key, fallbackValue) {\n        var value = this.get(key);\n        if (types_1.isUndefinedOrNull(value)) {\n            return fallbackValue;\n        }\n        return value === 'true';\n    };\n    Storage.prototype.getNumber = function (key, fallbackValue) {\n        var value = this.get(key);\n        if (types_1.isUndefinedOrNull(value)) {\n            return fallbackValue;\n        }\n        return parseInt(value, 10);\n    };\n    Storage.prototype.set = function (key, value) {\n        var _this = this;\n        if (this.state === StorageState.Closed) {\n            return Promise.resolve(); // Return early if we are already closed\n        }\n        // We remove the key for undefined/null values\n        if (types_1.isUndefinedOrNull(value)) {\n            return this.delete(key);\n        }\n        // Otherwise, convert to String and store\n        var valueStr = String(value);\n        // Return early if value already set\n        var currentValue = this.cache.get(key);\n        if (currentValue === valueStr) {\n            return Promise.resolve();\n        }\n        // Update in cache and pending\n        this.cache.set(key, valueStr);\n        this.pendingInserts.set(key, valueStr);\n        this.pendingDeletes.delete(key);\n        // Event\n        this._onDidChangeStorage.fire(key);\n        // Accumulate work by scheduling after timeout\n        return this.flushDelayer.trigger(function () { return _this.flushPending(); });\n    };\n    Storage.prototype.delete = function (key) {\n        var _this = this;\n        if (this.state === StorageState.Closed) {\n            return Promise.resolve(); // Return early if we are already closed\n        }\n        // Remove from cache and add to pending\n        var wasDeleted = this.cache.delete(key);\n        if (!wasDeleted) {\n            return Promise.resolve(); // Return early if value already deleted\n        }\n        if (!this.pendingDeletes.has(key)) {\n            this.pendingDeletes.add(key);\n        }\n        this.pendingInserts.delete(key);\n        // Event\n        this._onDidChangeStorage.fire(key);\n        // Accumulate work by scheduling after timeout\n        return this.flushDelayer.trigger(function () { return _this.flushPending(); });\n    };\n    Storage.prototype.close = function () {\n        var _this = this;\n        if (this.state === StorageState.Closed) {\n            return Promise.resolve(); // return if already closed\n        }\n        // Update state\n        this.state = StorageState.Closed;\n        // Trigger new flush to ensure data is persisted and then close\n        // even if there is an error flushing. We must always ensure\n        // the DB is closed to avoid corruption.\n        //\n        // Recovery: we pass our cache over as recovery option in case\n        // the DB is not healthy.\n        var onDone = function () { return _this.database.close(function () { return _this.cache; }); };\n        return this.flushDelayer.trigger(function () { return _this.flushPending(); }, 0 /* as soon as possible */).then(onDone, onDone);\n    };\n    Storage.prototype.flushPending = function () {\n        if (this.pendingInserts.size === 0 && this.pendingDeletes.size === 0) {\n            return Promise.resolve(); // return early if nothing to do\n        }\n        // Get pending data\n        var updateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };\n        // Reset pending data for next run\n        this.pendingDeletes = new Set();\n        this.pendingInserts = new Map();\n        // Update in storage\n        return this.database.updateItems(updateRequest);\n    };\n    Storage.prototype.checkIntegrity = function (full) {\n        return this.database.checkIntegrity(full);\n    };\n    Storage.DEFAULT_FLUSH_DELAY = 100;\n    return Storage;\n}(lifecycle_1.Disposable));\nexports.Storage = Storage;\nvar SQLiteStorageDatabase = /** @class */ (function () {\n    function SQLiteStorageDatabase(path, options) {\n        if (options === void 0) { options = Object.create(null); }\n        this.path = path;\n        this.name = path_1.basename(path);\n        this.logger = new SQLiteStorageDatabaseLogger(options.logging);\n        this.whenConnected = this.connect(path);\n    }\n    Object.defineProperty(SQLiteStorageDatabase.prototype, \"onDidChangeItemsExternal\", {\n        get: function () { return event_1.Event.None; } // since we are the only client, there can be no external changes\n        ,\n        enumerable: true,\n        configurable: true\n    });\n    SQLiteStorageDatabase.prototype.getItems = function () {\n        var _this = this;\n        return this.whenConnected.then(function (connection) {\n            var items = new Map();\n            return _this.all(connection, 'SELECT * FROM ItemTable').then(function (rows) {\n                rows.forEach(function (row) { return items.set(row.key, row.value); });\n                if (_this.logger.isTracing) {\n                    _this.logger.trace(\"[storage \" + _this.name + \"] getItems(): \" + items.size + \" rows\");\n                }\n                return items;\n            });\n        });\n    };\n    SQLiteStorageDatabase.prototype.updateItems = function (request) {\n        var _this = this;\n        return this.whenConnected.then(function (connection) { return _this.doUpdateItems(connection, request); });\n    };\n    SQLiteStorageDatabase.prototype.doUpdateItems = function (connection, request) {\n        var _this = this;\n        var updateCount = 0;\n        if (request.insert) {\n            updateCount += request.insert.size;\n        }\n        if (request.delete) {\n            updateCount += request.delete.size;\n        }\n        if (updateCount === 0) {\n            return Promise.resolve();\n        }\n        if (this.logger.isTracing) {\n            this.logger.trace(\"[storage \" + this.name + \"] updateItems(): insert(\" + (request.insert ? map_1.mapToString(request.insert) : '0') + \"), delete(\" + (request.delete ? map_1.setToString(request.delete) : '0') + \")\");\n        }\n        return this.transaction(connection, function () {\n            // INSERT\n            if (request.insert && request.insert.size > 0) {\n                var keysValuesChunks_1 = [];\n                keysValuesChunks_1.push([]); // seed with initial empty chunk\n                // Split key/values into chunks of SQLiteStorageDatabase.MAX_HOST_PARAMETERS\n                // so that we can efficiently run the INSERT with as many HOST parameters as possible\n                var currentChunkIndex_1 = 0;\n                request.insert.forEach(function (value, key) {\n                    var keyValueChunk = keysValuesChunks_1[currentChunkIndex_1];\n                    if (keyValueChunk.length > SQLiteStorageDatabase.MAX_HOST_PARAMETERS) {\n                        currentChunkIndex_1++;\n                        keyValueChunk = [];\n                        keysValuesChunks_1.push(keyValueChunk);\n                    }\n                    keyValueChunk.push(key, value);\n                });\n                keysValuesChunks_1.forEach(function (keysValuesChunk) {\n                    _this.prepare(connection, \"INSERT INTO ItemTable VALUES \" + arrays_1.fill(keysValuesChunk.length / 2, '(?,?)').join(','), function (stmt) { return stmt.run(keysValuesChunk); }, function () {\n                        var keys = [];\n                        var length = 0;\n                        request.insert.forEach(function (value, key) {\n                            keys.push(key);\n                            length += value.length;\n                        });\n                        return \"Keys: \" + keys.join(', ') + \" Length: \" + length;\n                    });\n                });\n            }\n            // DELETE\n            if (request.delete && request.delete.size) {\n                var keysChunks_1 = [];\n                keysChunks_1.push([]); // seed with initial empty chunk\n                // Split keys into chunks of SQLiteStorageDatabase.MAX_HOST_PARAMETERS\n                // so that we can efficiently run the DELETE with as many HOST parameters\n                // as possible\n                var currentChunkIndex_2 = 0;\n                request.delete.forEach(function (key) {\n                    var keyChunk = keysChunks_1[currentChunkIndex_2];\n                    if (keyChunk.length > SQLiteStorageDatabase.MAX_HOST_PARAMETERS) {\n                        currentChunkIndex_2++;\n                        keyChunk = [];\n                        keysChunks_1.push(keyChunk);\n                    }\n                    keyChunk.push(key);\n                });\n                keysChunks_1.forEach(function (keysChunk) {\n                    _this.prepare(connection, \"DELETE FROM ItemTable WHERE key IN (\" + arrays_1.fill(keysChunk.length, '?').join(',') + \")\", function (stmt) { return stmt.run(keysChunk); }, function () {\n                        var keys = [];\n                        request.delete.forEach(function (key) {\n                            keys.push(key);\n                        });\n                        return \"Keys: \" + keys.join(', ');\n                    });\n                });\n            }\n        });\n    };\n    SQLiteStorageDatabase.prototype.close = function (recovery) {\n        var _this = this;\n        this.logger.trace(\"[storage \" + this.name + \"] close()\");\n        return this.whenConnected.then(function (connection) { return _this.doClose(connection, recovery); });\n    };\n    SQLiteStorageDatabase.prototype.doClose = function (connection, recovery) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            connection.db.close(function (closeError) {\n                if (closeError) {\n                    _this.handleSQLiteError(connection, closeError, \"[storage \" + _this.name + \"] close(): \" + closeError);\n                }\n                // Return early if this storage was created only in-memory\n                // e.g. when running tests we do not need to backup.\n                if (_this.path === SQLiteStorageDatabase.IN_MEMORY_PATH) {\n                    return resolve();\n                }\n                // If the DB closed successfully and we are not running in-memory\n                // and the DB did not get errors during runtime, make a backup\n                // of the DB so that we can use it as fallback in case the actual\n                // DB becomes corrupt in the future.\n                if (!connection.isErroneous && !connection.isInMemory) {\n                    return _this.backup().then(resolve, function (error) {\n                        _this.logger.error(\"[storage \" + _this.name + \"] backup(): \" + error);\n                        return resolve(); // ignore failing backup\n                    });\n                }\n                // Recovery: if we detected errors while using the DB or we are using\n                // an inmemory DB (as a fallback to not being able to open the DB initially)\n                // and we have a recovery function provided, we recreate the DB with this\n                // data to recover all known data without loss if possible.\n                if (typeof recovery === 'function') {\n                    // Delete the existing DB. If the path does not exist or fails to\n                    // be deleted, we do not try to recover anymore because we assume\n                    // that the path is no longer writeable for us.\n                    return pfs_1.unlink(_this.path).then(function () {\n                        // Re-open the DB fresh\n                        return _this.doConnect(_this.path).then(function (recoveryConnection) {\n                            var closeRecoveryConnection = function () {\n                                return _this.doClose(recoveryConnection, undefined /* do not attempt to recover again */);\n                            };\n                            // Store items\n                            return _this.doUpdateItems(recoveryConnection, { insert: recovery() }).then(function () { return closeRecoveryConnection(); }, function (error) {\n                                // In case of an error updating items, still ensure to close the connection\n                                // to prevent SQLITE_BUSY errors when the connection is restablished\n                                closeRecoveryConnection();\n                                return Promise.reject(error);\n                            });\n                        });\n                    }).then(resolve, reject);\n                }\n                // Finally without recovery we just reject\n                return reject(closeError || new Error('Database has errors or is in-memory without recovery option'));\n            });\n        });\n    };\n    SQLiteStorageDatabase.prototype.backup = function () {\n        var backupPath = this.toBackupPath(this.path);\n        return pfs_1.copy(this.path, backupPath);\n    };\n    SQLiteStorageDatabase.prototype.toBackupPath = function (path) {\n        return path + \".backup\";\n    };\n    SQLiteStorageDatabase.prototype.checkIntegrity = function (full) {\n        var _this = this;\n        this.logger.trace(\"[storage \" + this.name + \"] checkIntegrity(full: \" + full + \")\");\n        return this.whenConnected.then(function (connection) {\n            return _this.get(connection, full ? 'PRAGMA integrity_check' : 'PRAGMA quick_check').then(function (row) {\n                var integrity = full ? row['integrity_check'] : row['quick_check'];\n                if (connection.isErroneous) {\n                    return integrity + \" (last error: \" + connection.lastError + \")\";\n                }\n                if (connection.isInMemory) {\n                    return integrity + \" (in-memory!)\";\n                }\n                return integrity;\n            });\n        });\n    };\n    SQLiteStorageDatabase.prototype.connect = function (path, retryOnBusy) {\n        var _this = this;\n        if (retryOnBusy === void 0) { retryOnBusy = true; }\n        this.logger.trace(\"[storage \" + this.name + \"] open(\" + path + \", retryOnBusy: \" + retryOnBusy + \")\");\n        return this.doConnect(path).then(undefined, function (error) {\n            _this.logger.error(\"[storage \" + _this.name + \"] open(): Unable to open DB due to \" + error);\n            // SQLITE_BUSY should only arise if another process is locking the same DB we want\n            // to open at that time. This typically never happens because a DB connection is\n            // limited per window. However, in the event of a window reload, it may be possible\n            // that the previous connection was not properly closed while the new connection is\n            // already established.\n            //\n            // In this case we simply wait for some time and retry once to establish the connection.\n            //\n            if (error.code === 'SQLITE_BUSY' && retryOnBusy) {\n                return async_1.timeout(SQLiteStorageDatabase.BUSY_OPEN_TIMEOUT).then(function () { return _this.connect(path, false /* not another retry */); });\n            }\n            // Otherwise, best we can do is to recover from a backup if that exists, as such we\n            // move the DB to a different filename and try to load from backup. If that fails,\n            // a new empty DB is being created automatically.\n            //\n            // The final fallback is to use an in-memory DB which should only happen if the target\n            // folder is really not writeable for us.\n            //\n            return pfs_1.unlink(path)\n                .then(function () { return pfs_1.renameIgnoreError(_this.toBackupPath(path), path); })\n                .then(function () { return _this.doConnect(path); })\n                .then(undefined, function (error) {\n                _this.logger.error(\"[storage \" + _this.name + \"] open(): Unable to use backup due to \" + error);\n                // In case of any error to open the DB, use an in-memory\n                // DB so that we always have a valid DB to talk to.\n                return _this.doConnect(SQLiteStorageDatabase.IN_MEMORY_PATH);\n            });\n        });\n    };\n    SQLiteStorageDatabase.prototype.handleSQLiteError = function (connection, error, msg) {\n        connection.isErroneous = true;\n        connection.lastError = msg;\n        this.logger.error(msg);\n    };\n    SQLiteStorageDatabase.prototype.doConnect = function (path) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            Promise.resolve().then(function () { return require('vscode-sqlite3'); }).then(function (sqlite3) {\n                var connection = {\n                    db: new (_this.logger.isTracing ? sqlite3.verbose().Database : sqlite3.Database)(path, function (error) {\n                        if (error) {\n                            return connection.db ? connection.db.close(function () { return reject(error); }) : reject(error);\n                        }\n                        // The following exec() statement serves two purposes:\n                        // - create the DB if it does not exist yet\n                        // - validate that the DB is not corrupt (the open() call does not throw otherwise)\n                        return _this.exec(connection, [\n                            'PRAGMA user_version = 1;',\n                            'CREATE TABLE IF NOT EXISTS ItemTable (key TEXT UNIQUE ON CONFLICT REPLACE, value BLOB)'\n                        ].join('')).then(function () {\n                            return resolve(connection);\n                        }, function (error) {\n                            return connection.db.close(function () { return reject(error); });\n                        });\n                    }),\n                    isInMemory: path === SQLiteStorageDatabase.IN_MEMORY_PATH\n                };\n                // Errors\n                connection.db.on('error', function (error) { return _this.handleSQLiteError(connection, error, \"[storage \" + _this.name + \"] Error (event): \" + error); });\n                // Tracing\n                if (_this.logger.isTracing) {\n                    connection.db.on('trace', function (sql) { return _this.logger.trace(\"[storage \" + _this.name + \"] Trace (event): \" + sql); });\n                }\n            }, reject);\n        });\n    };\n    SQLiteStorageDatabase.prototype.exec = function (connection, sql) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            connection.db.exec(sql, function (error) {\n                if (error) {\n                    _this.handleSQLiteError(connection, error, \"[storage \" + _this.name + \"] exec(): \" + error);\n                    return reject(error);\n                }\n                return resolve();\n            });\n        });\n    };\n    SQLiteStorageDatabase.prototype.get = function (connection, sql) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            connection.db.get(sql, function (error, row) {\n                if (error) {\n                    _this.handleSQLiteError(connection, error, \"[storage \" + _this.name + \"] get(): \" + error);\n                    return reject(error);\n                }\n                return resolve(row);\n            });\n        });\n    };\n    SQLiteStorageDatabase.prototype.all = function (connection, sql) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            connection.db.all(sql, function (error, rows) {\n                if (error) {\n                    _this.handleSQLiteError(connection, error, \"[storage \" + _this.name + \"] all(): \" + error);\n                    return reject(error);\n                }\n                return resolve(rows);\n            });\n        });\n    };\n    SQLiteStorageDatabase.prototype.transaction = function (connection, transactions) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            connection.db.serialize(function () {\n                connection.db.run('BEGIN TRANSACTION');\n                transactions();\n                connection.db.run('END TRANSACTION', function (error) {\n                    if (error) {\n                        _this.handleSQLiteError(connection, error, \"[storage \" + _this.name + \"] transaction(): \" + error);\n                        return reject(error);\n                    }\n                    return resolve();\n                });\n            });\n        });\n    };\n    SQLiteStorageDatabase.prototype.prepare = function (connection, sql, runCallback, errorDetails) {\n        var _this = this;\n        var stmt = connection.db.prepare(sql);\n        var statementErrorListener = function (error) {\n            _this.handleSQLiteError(connection, error, \"[storage \" + _this.name + \"] prepare(): \" + error + \" (\" + sql + \"). Details: \" + errorDetails());\n        };\n        stmt.on('error', statementErrorListener);\n        runCallback(stmt);\n        stmt.finalize(function (error) {\n            if (error) {\n                statementErrorListener(error);\n            }\n            stmt.removeListener('error', statementErrorListener);\n        });\n    };\n    SQLiteStorageDatabase.IN_MEMORY_PATH = ':memory:';\n    SQLiteStorageDatabase.BUSY_OPEN_TIMEOUT = 2000; // timeout in ms to retry when opening DB fails with SQLITE_BUSY\n    SQLiteStorageDatabase.MAX_HOST_PARAMETERS = 256; // maximum number of parameters within a statement\n    return SQLiteStorageDatabase;\n}());\nexports.SQLiteStorageDatabase = SQLiteStorageDatabase;\nvar SQLiteStorageDatabaseLogger = /** @class */ (function () {\n    function SQLiteStorageDatabaseLogger(options) {\n        if (options && typeof options.logTrace === 'function') {\n            this.logTrace = options.logTrace;\n        }\n        if (options && typeof options.logError === 'function') {\n            this.logError = options.logError;\n        }\n    }\n    Object.defineProperty(SQLiteStorageDatabaseLogger.prototype, \"isTracing\", {\n        get: function () {\n            return !!this.logTrace;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SQLiteStorageDatabaseLogger.prototype.trace = function (msg) {\n        if (this.logTrace) {\n            this.logTrace(msg);\n        }\n    };\n    SQLiteStorageDatabaseLogger.prototype.error = function (error) {\n        if (this.logError) {\n            this.logError(error);\n        }\n    };\n    return SQLiteStorageDatabaseLogger;\n}());\nvar InMemoryStorageDatabase = /** @class */ (function () {\n    function InMemoryStorageDatabase() {\n        this.onDidChangeItemsExternal = event_1.Event.None;\n        this.items = new Map();\n    }\n    InMemoryStorageDatabase.prototype.getItems = function () {\n        return Promise.resolve(this.items);\n    };\n    InMemoryStorageDatabase.prototype.updateItems = function (request) {\n        var _this = this;\n        if (request.insert) {\n            request.insert.forEach(function (value, key) { return _this.items.set(key, value); });\n        }\n        if (request.delete) {\n            request.delete.forEach(function (key) { return _this.items.delete(key); });\n        }\n        return Promise.resolve();\n    };\n    InMemoryStorageDatabase.prototype.close = function () {\n        return Promise.resolve();\n    };\n    InMemoryStorageDatabase.prototype.checkIntegrity = function (full) {\n        return Promise.resolve('ok');\n    };\n    return InMemoryStorageDatabase;\n}());\nexports.InMemoryStorageDatabase = InMemoryStorageDatabase;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/node/storage.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/node/storage.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Database, Statement } from 'vscode-sqlite3';\nimport { Disposable, IDisposable } from 'vs/base/common/lifecycle';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { ThrottledDelayer, timeout } from 'vs/base/common/async';\nimport { isUndefinedOrNull } from 'vs/base/common/types';\nimport { mapToString, setToString } from 'vs/base/common/map';\nimport { basename } from 'vs/base/common/path';\nimport { copy, renameIgnoreError, unlink } from 'vs/base/node/pfs';\nimport { fill } from 'vs/base/common/arrays';\n\nexport enum StorageHint {\n\n\t// A hint to the storage that the storage\n\t// does not exist on disk yet. This allows\n\t// the storage library to improve startup\n\t// time by not checking the storage for data.\n\tSTORAGE_DOES_NOT_EXIST\n}\n\nexport interface IStorageOptions {\n\thint?: StorageHint;\n}\n\nexport interface IUpdateRequest {\n\tinsert?: Map<string, string>;\n\tdelete?: Set<string>;\n}\n\nexport interface IStorageItemsChangeEvent {\n\titems: Map<string, string>;\n}\n\nexport interface IStorageDatabase {\n\n\treadonly onDidChangeItemsExternal: Event<IStorageItemsChangeEvent>;\n\n\tgetItems(): Promise<Map<string, string>>;\n\tupdateItems(request: IUpdateRequest): Promise<void>;\n\n\tclose(recovery?: () => Map<string, string>): Promise<void>;\n\n\tcheckIntegrity(full: boolean): Promise<string>;\n}\n\nexport interface IStorage extends IDisposable {\n\n\treadonly items: Map<string, string>;\n\treadonly size: number;\n\treadonly onDidChangeStorage: Event<string>;\n\n\tinit(): Promise<void>;\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\n\tgetBoolean(key: string, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined;\n\n\tgetNumber(key: string, fallbackValue: number): number;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined;\n\n\tset(key: string, value: string | boolean | number): Promise<void>;\n\tdelete(key: string): Promise<void>;\n\n\tclose(): Promise<void>;\n\n\tcheckIntegrity(full: boolean): Promise<string>;\n}\n\nenum StorageState {\n\tNone,\n\tInitialized,\n\tClosed\n}\n\nexport class Storage extends Disposable implements IStorage {\n\t_serviceBrand: any;\n\n\tprivate static readonly DEFAULT_FLUSH_DELAY = 100;\n\n\tprivate readonly _onDidChangeStorage: Emitter<string> = this._register(new Emitter<string>());\n\tget onDidChangeStorage(): Event<string> { return this._onDidChangeStorage.event; }\n\n\tprivate state = StorageState.None;\n\n\tprivate cache: Map<string, string> = new Map<string, string>();\n\n\tprivate flushDelayer: ThrottledDelayer<void>;\n\n\tprivate pendingDeletes: Set<string> = new Set<string>();\n\tprivate pendingInserts: Map<string, string> = new Map();\n\n\tconstructor(\n\t\tprotected database: IStorageDatabase,\n\t\tprivate options: IStorageOptions = Object.create(null)\n\t) {\n\t\tsuper();\n\n\t\tthis.flushDelayer = this._register(new ThrottledDelayer(Storage.DEFAULT_FLUSH_DELAY));\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.database.onDidChangeItemsExternal(e => this.onDidChangeItemsExternal(e)));\n\t}\n\n\tprivate onDidChangeItemsExternal(e: IStorageItemsChangeEvent): void {\n\t\t// items that change external require us to update our\n\t\t// caches with the values. we just accept the value and\n\t\t// emit an event if there is a change.\n\t\te.items.forEach((value, key) => this.accept(key, value));\n\t}\n\n\tprivate accept(key: string, value: string): void {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn; // Return early if we are already closed\n\t\t}\n\n\t\tlet changed = false;\n\n\t\t// Item got removed, check for deletion\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\tchanged = this.cache.delete(key);\n\t\t}\n\n\t\t// Item got updated, check for change\n\t\telse {\n\t\t\tconst currentValue = this.cache.get(key);\n\t\t\tif (currentValue !== value) {\n\t\t\t\tthis.cache.set(key, value);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\t// Signal to outside listeners\n\t\tif (changed) {\n\t\t\tthis._onDidChangeStorage.fire(key);\n\t\t}\n\t}\n\n\tget items(): Map<string, string> {\n\t\treturn this.cache;\n\t}\n\n\tget size(): number {\n\t\treturn this.cache.size;\n\t}\n\n\tinit(): Promise<void> {\n\t\tif (this.state !== StorageState.None) {\n\t\t\treturn Promise.resolve(); // either closed or already initialized\n\t\t}\n\n\t\tthis.state = StorageState.Initialized;\n\n\t\tif (this.options.hint === StorageHint.STORAGE_DOES_NOT_EXIST) {\n\t\t\t// return early if we know the storage file does not exist. this is a performance\n\t\t\t// optimization to not load all items of the underlying storage if we know that\n\t\t\t// there can be no items because the storage does not exist.\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn this.database.getItems().then(items => {\n\t\t\tthis.cache = items;\n\t\t});\n\t}\n\n\tget(key: string, fallbackValue: string): string;\n\tget(key: string, fallbackValue?: string): string | undefined;\n\tget(key: string, fallbackValue?: string): string | undefined {\n\t\tconst value = this.cache.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tgetBoolean(key: string, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined;\n\tgetBoolean(key: string, fallbackValue?: boolean): boolean | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value === 'true';\n\t}\n\n\tgetNumber(key: string, fallbackValue: number): number;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined;\n\tgetNumber(key: string, fallbackValue?: number): number | undefined {\n\t\tconst value = this.get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn parseInt(value, 10);\n\t}\n\n\tset(key: string, value: string | boolean | number): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn Promise.resolve(); // Return early if we are already closed\n\t\t}\n\n\t\t// We remove the key for undefined/null values\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn this.delete(key);\n\t\t}\n\n\t\t// Otherwise, convert to String and store\n\t\tconst valueStr = String(value);\n\n\t\t// Return early if value already set\n\t\tconst currentValue = this.cache.get(key);\n\t\tif (currentValue === valueStr) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\t// Update in cache and pending\n\t\tthis.cache.set(key, valueStr);\n\t\tthis.pendingInserts.set(key, valueStr);\n\t\tthis.pendingDeletes.delete(key);\n\n\t\t// Event\n\t\tthis._onDidChangeStorage.fire(key);\n\n\t\t// Accumulate work by scheduling after timeout\n\t\treturn this.flushDelayer.trigger(() => this.flushPending());\n\t}\n\n\tdelete(key: string): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn Promise.resolve(); // Return early if we are already closed\n\t\t}\n\n\t\t// Remove from cache and add to pending\n\t\tconst wasDeleted = this.cache.delete(key);\n\t\tif (!wasDeleted) {\n\t\t\treturn Promise.resolve(); // Return early if value already deleted\n\t\t}\n\n\t\tif (!this.pendingDeletes.has(key)) {\n\t\t\tthis.pendingDeletes.add(key);\n\t\t}\n\n\t\tthis.pendingInserts.delete(key);\n\n\t\t// Event\n\t\tthis._onDidChangeStorage.fire(key);\n\n\t\t// Accumulate work by scheduling after timeout\n\t\treturn this.flushDelayer.trigger(() => this.flushPending());\n\t}\n\n\tclose(): Promise<void> {\n\t\tif (this.state === StorageState.Closed) {\n\t\t\treturn Promise.resolve(); // return if already closed\n\t\t}\n\n\t\t// Update state\n\t\tthis.state = StorageState.Closed;\n\n\t\t// Trigger new flush to ensure data is persisted and then close\n\t\t// even if there is an error flushing. We must always ensure\n\t\t// the DB is closed to avoid corruption.\n\t\t//\n\t\t// Recovery: we pass our cache over as recovery option in case\n\t\t// the DB is not healthy.\n\t\tconst onDone = () => this.database.close(() => this.cache);\n\t\treturn this.flushDelayer.trigger(() => this.flushPending(), 0 /* as soon as possible */).then(onDone, onDone);\n\t}\n\n\tprivate flushPending(): Promise<void> {\n\t\tif (this.pendingInserts.size === 0 && this.pendingDeletes.size === 0) {\n\t\t\treturn Promise.resolve(); // return early if nothing to do\n\t\t}\n\n\t\t// Get pending data\n\t\tconst updateRequest: IUpdateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };\n\n\t\t// Reset pending data for next run\n\t\tthis.pendingDeletes = new Set<string>();\n\t\tthis.pendingInserts = new Map<string, string>();\n\n\t\t// Update in storage\n\t\treturn this.database.updateItems(updateRequest);\n\t}\n\n\tcheckIntegrity(full: boolean): Promise<string> {\n\t\treturn this.database.checkIntegrity(full);\n\t}\n}\n\ninterface IDatabaseConnection {\n\tdb: Database;\n\n\tisInMemory: boolean;\n\n\tisErroneous?: boolean;\n\tlastError?: string;\n}\n\nexport interface ISQLiteStorageDatabaseOptions {\n\tlogging?: ISQLiteStorageDatabaseLoggingOptions;\n}\n\nexport interface ISQLiteStorageDatabaseLoggingOptions {\n\tlogError?: (error: string | Error) => void;\n\tlogTrace?: (msg: string) => void;\n}\n\nexport class SQLiteStorageDatabase implements IStorageDatabase {\n\n\tstatic IN_MEMORY_PATH = ':memory:';\n\n\tget onDidChangeItemsExternal(): Event<IStorageItemsChangeEvent> { return Event.None; } // since we are the only client, there can be no external changes\n\n\tprivate static BUSY_OPEN_TIMEOUT = 2000; // timeout in ms to retry when opening DB fails with SQLITE_BUSY\n\tprivate static MAX_HOST_PARAMETERS = 256; // maximum number of parameters within a statement\n\n\tprivate path: string;\n\tprivate name: string;\n\n\tprivate logger: SQLiteStorageDatabaseLogger;\n\n\tprivate whenConnected: Promise<IDatabaseConnection>;\n\n\tconstructor(path: string, options: ISQLiteStorageDatabaseOptions = Object.create(null)) {\n\t\tthis.path = path;\n\t\tthis.name = basename(path);\n\n\t\tthis.logger = new SQLiteStorageDatabaseLogger(options.logging);\n\n\t\tthis.whenConnected = this.connect(path);\n\t}\n\n\tgetItems(): Promise<Map<string, string>> {\n\t\treturn this.whenConnected.then(connection => {\n\t\t\tconst items = new Map<string, string>();\n\n\t\t\treturn this.all(connection, 'SELECT * FROM ItemTable').then(rows => {\n\t\t\t\trows.forEach(row => items.set(row.key, row.value));\n\n\t\t\t\tif (this.logger.isTracing) {\n\t\t\t\t\tthis.logger.trace(`[storage ${this.name}] getItems(): ${items.size} rows`);\n\t\t\t\t}\n\n\t\t\t\treturn items;\n\t\t\t});\n\t\t});\n\t}\n\n\tupdateItems(request: IUpdateRequest): Promise<void> {\n\t\treturn this.whenConnected.then(connection => this.doUpdateItems(connection, request));\n\t}\n\n\tprivate doUpdateItems(connection: IDatabaseConnection, request: IUpdateRequest): Promise<void> {\n\t\tlet updateCount = 0;\n\t\tif (request.insert) {\n\t\t\tupdateCount += request.insert.size;\n\t\t}\n\t\tif (request.delete) {\n\t\t\tupdateCount += request.delete.size;\n\t\t}\n\n\t\tif (updateCount === 0) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tif (this.logger.isTracing) {\n\t\t\tthis.logger.trace(`[storage ${this.name}] updateItems(): insert(${request.insert ? mapToString(request.insert) : '0'}), delete(${request.delete ? setToString(request.delete) : '0'})`);\n\t\t}\n\n\t\treturn this.transaction(connection, () => {\n\n\t\t\t// INSERT\n\t\t\tif (request.insert && request.insert.size > 0) {\n\t\t\t\tconst keysValuesChunks: (string[])[] = [];\n\t\t\t\tkeysValuesChunks.push([]); // seed with initial empty chunk\n\n\t\t\t\t// Split key/values into chunks of SQLiteStorageDatabase.MAX_HOST_PARAMETERS\n\t\t\t\t// so that we can efficiently run the INSERT with as many HOST parameters as possible\n\t\t\t\tlet currentChunkIndex = 0;\n\t\t\t\trequest.insert.forEach((value, key) => {\n\t\t\t\t\tlet keyValueChunk = keysValuesChunks[currentChunkIndex];\n\n\t\t\t\t\tif (keyValueChunk.length > SQLiteStorageDatabase.MAX_HOST_PARAMETERS) {\n\t\t\t\t\t\tcurrentChunkIndex++;\n\t\t\t\t\t\tkeyValueChunk = [];\n\t\t\t\t\t\tkeysValuesChunks.push(keyValueChunk);\n\t\t\t\t\t}\n\n\t\t\t\t\tkeyValueChunk.push(key, value);\n\t\t\t\t});\n\n\t\t\t\tkeysValuesChunks.forEach(keysValuesChunk => {\n\t\t\t\t\tthis.prepare(connection, `INSERT INTO ItemTable VALUES ${fill(keysValuesChunk.length / 2, '(?,?)').join(',')}`, stmt => stmt.run(keysValuesChunk), () => {\n\t\t\t\t\t\tconst keys: string[] = [];\n\t\t\t\t\t\tlet length = 0;\n\t\t\t\t\t\trequest.insert!.forEach((value, key) => {\n\t\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t\t\tlength += value.length;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn `Keys: ${keys.join(', ')} Length: ${length}`;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// DELETE\n\t\t\tif (request.delete && request.delete.size) {\n\t\t\t\tconst keysChunks: (string[])[] = [];\n\t\t\t\tkeysChunks.push([]); // seed with initial empty chunk\n\n\t\t\t\t// Split keys into chunks of SQLiteStorageDatabase.MAX_HOST_PARAMETERS\n\t\t\t\t// so that we can efficiently run the DELETE with as many HOST parameters\n\t\t\t\t// as possible\n\t\t\t\tlet currentChunkIndex = 0;\n\t\t\t\trequest.delete.forEach(key => {\n\t\t\t\t\tlet keyChunk = keysChunks[currentChunkIndex];\n\n\t\t\t\t\tif (keyChunk.length > SQLiteStorageDatabase.MAX_HOST_PARAMETERS) {\n\t\t\t\t\t\tcurrentChunkIndex++;\n\t\t\t\t\t\tkeyChunk = [];\n\t\t\t\t\t\tkeysChunks.push(keyChunk);\n\t\t\t\t\t}\n\n\t\t\t\t\tkeyChunk.push(key);\n\t\t\t\t});\n\n\t\t\t\tkeysChunks.forEach(keysChunk => {\n\t\t\t\t\tthis.prepare(connection, `DELETE FROM ItemTable WHERE key IN (${fill(keysChunk.length, '?').join(',')})`, stmt => stmt.run(keysChunk), () => {\n\t\t\t\t\t\tconst keys: string[] = [];\n\t\t\t\t\t\trequest.delete!.forEach(key => {\n\t\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn `Keys: ${keys.join(', ')}`;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tclose(recovery?: () => Map<string, string>): Promise<void> {\n\t\tthis.logger.trace(`[storage ${this.name}] close()`);\n\n\t\treturn this.whenConnected.then(connection => this.doClose(connection, recovery));\n\t}\n\n\tprivate doClose(connection: IDatabaseConnection, recovery?: () => Map<string, string>): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.close(closeError => {\n\t\t\t\tif (closeError) {\n\t\t\t\t\tthis.handleSQLiteError(connection, closeError, `[storage ${this.name}] close(): ${closeError}`);\n\t\t\t\t}\n\n\t\t\t\t// Return early if this storage was created only in-memory\n\t\t\t\t// e.g. when running tests we do not need to backup.\n\t\t\t\tif (this.path === SQLiteStorageDatabase.IN_MEMORY_PATH) {\n\t\t\t\t\treturn resolve();\n\t\t\t\t}\n\n\t\t\t\t// If the DB closed successfully and we are not running in-memory\n\t\t\t\t// and the DB did not get errors during runtime, make a backup\n\t\t\t\t// of the DB so that we can use it as fallback in case the actual\n\t\t\t\t// DB becomes corrupt in the future.\n\t\t\t\tif (!connection.isErroneous && !connection.isInMemory) {\n\t\t\t\t\treturn this.backup().then(resolve, error => {\n\t\t\t\t\t\tthis.logger.error(`[storage ${this.name}] backup(): ${error}`);\n\n\t\t\t\t\t\treturn resolve(); // ignore failing backup\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Recovery: if we detected errors while using the DB or we are using\n\t\t\t\t// an inmemory DB (as a fallback to not being able to open the DB initially)\n\t\t\t\t// and we have a recovery function provided, we recreate the DB with this\n\t\t\t\t// data to recover all known data without loss if possible.\n\t\t\t\tif (typeof recovery === 'function') {\n\n\t\t\t\t\t// Delete the existing DB. If the path does not exist or fails to\n\t\t\t\t\t// be deleted, we do not try to recover anymore because we assume\n\t\t\t\t\t// that the path is no longer writeable for us.\n\t\t\t\t\treturn unlink(this.path).then(() => {\n\n\t\t\t\t\t\t// Re-open the DB fresh\n\t\t\t\t\t\treturn this.doConnect(this.path).then(recoveryConnection => {\n\t\t\t\t\t\t\tconst closeRecoveryConnection = () => {\n\t\t\t\t\t\t\t\treturn this.doClose(recoveryConnection, undefined /* do not attempt to recover again */);\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Store items\n\t\t\t\t\t\t\treturn this.doUpdateItems(recoveryConnection, { insert: recovery() }).then(() => closeRecoveryConnection(), error => {\n\n\t\t\t\t\t\t\t\t// In case of an error updating items, still ensure to close the connection\n\t\t\t\t\t\t\t\t// to prevent SQLITE_BUSY errors when the connection is restablished\n\t\t\t\t\t\t\t\tcloseRecoveryConnection();\n\n\t\t\t\t\t\t\t\treturn Promise.reject(error);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}).then(resolve, reject);\n\t\t\t\t}\n\n\t\t\t\t// Finally without recovery we just reject\n\t\t\t\treturn reject(closeError || new Error('Database has errors or is in-memory without recovery option'));\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate backup(): Promise<void> {\n\t\tconst backupPath = this.toBackupPath(this.path);\n\n\t\treturn copy(this.path, backupPath);\n\t}\n\n\tprivate toBackupPath(path: string): string {\n\t\treturn `${path}.backup`;\n\t}\n\n\tcheckIntegrity(full: boolean): Promise<string> {\n\t\tthis.logger.trace(`[storage ${this.name}] checkIntegrity(full: ${full})`);\n\n\t\treturn this.whenConnected.then(connection => {\n\t\t\treturn this.get(connection, full ? 'PRAGMA integrity_check' : 'PRAGMA quick_check').then(row => {\n\t\t\t\tconst integrity = full ? row['integrity_check'] : row['quick_check'];\n\n\t\t\t\tif (connection.isErroneous) {\n\t\t\t\t\treturn `${integrity} (last error: ${connection.lastError})`;\n\t\t\t\t}\n\n\t\t\t\tif (connection.isInMemory) {\n\t\t\t\t\treturn `${integrity} (in-memory!)`;\n\t\t\t\t}\n\n\t\t\t\treturn integrity;\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate connect(path: string, retryOnBusy: boolean = true): Promise<IDatabaseConnection> {\n\t\tthis.logger.trace(`[storage ${this.name}] open(${path}, retryOnBusy: ${retryOnBusy})`);\n\n\t\treturn this.doConnect(path).then(undefined, error => {\n\t\t\tthis.logger.error(`[storage ${this.name}] open(): Unable to open DB due to ${error}`);\n\n\t\t\t// SQLITE_BUSY should only arise if another process is locking the same DB we want\n\t\t\t// to open at that time. This typically never happens because a DB connection is\n\t\t\t// limited per window. However, in the event of a window reload, it may be possible\n\t\t\t// that the previous connection was not properly closed while the new connection is\n\t\t\t// already established.\n\t\t\t//\n\t\t\t// In this case we simply wait for some time and retry once to establish the connection.\n\t\t\t//\n\t\t\tif (error.code === 'SQLITE_BUSY' && retryOnBusy) {\n\t\t\t\treturn timeout(SQLiteStorageDatabase.BUSY_OPEN_TIMEOUT).then(() => this.connect(path, false /* not another retry */));\n\t\t\t}\n\n\t\t\t// Otherwise, best we can do is to recover from a backup if that exists, as such we\n\t\t\t// move the DB to a different filename and try to load from backup. If that fails,\n\t\t\t// a new empty DB is being created automatically.\n\t\t\t//\n\t\t\t// The final fallback is to use an in-memory DB which should only happen if the target\n\t\t\t// folder is really not writeable for us.\n\t\t\t//\n\t\t\treturn unlink(path)\n\t\t\t\t.then(() => renameIgnoreError(this.toBackupPath(path), path))\n\t\t\t\t.then(() => this.doConnect(path))\n\t\t\t\t.then(undefined, error => {\n\t\t\t\t\tthis.logger.error(`[storage ${this.name}] open(): Unable to use backup due to ${error}`);\n\n\t\t\t\t\t// In case of any error to open the DB, use an in-memory\n\t\t\t\t\t// DB so that we always have a valid DB to talk to.\n\t\t\t\t\treturn this.doConnect(SQLiteStorageDatabase.IN_MEMORY_PATH);\n\t\t\t\t});\n\t\t});\n\t}\n\n\tprivate handleSQLiteError(connection: IDatabaseConnection, error: Error & { code?: string }, msg: string): void {\n\t\tconnection.isErroneous = true;\n\t\tconnection.lastError = msg;\n\n\t\tthis.logger.error(msg);\n\t}\n\n\tprivate doConnect(path: string): Promise<IDatabaseConnection> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\timport('vscode-sqlite3').then(sqlite3 => {\n\t\t\t\tconst connection: IDatabaseConnection = {\n\t\t\t\t\tdb: new (this.logger.isTracing ? sqlite3.verbose().Database : sqlite3.Database)(path, error => {\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\treturn connection.db ? connection.db.close(() => reject(error)) : reject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// The following exec() statement serves two purposes:\n\t\t\t\t\t\t// - create the DB if it does not exist yet\n\t\t\t\t\t\t// - validate that the DB is not corrupt (the open() call does not throw otherwise)\n\t\t\t\t\t\treturn this.exec(connection, [\n\t\t\t\t\t\t\t'PRAGMA user_version = 1;',\n\t\t\t\t\t\t\t'CREATE TABLE IF NOT EXISTS ItemTable (key TEXT UNIQUE ON CONFLICT REPLACE, value BLOB)'\n\t\t\t\t\t\t].join('')).then(() => {\n\t\t\t\t\t\t\treturn resolve(connection);\n\t\t\t\t\t\t}, error => {\n\t\t\t\t\t\t\treturn connection.db.close(() => reject(error));\n\t\t\t\t\t\t});\n\t\t\t\t\t}),\n\t\t\t\t\tisInMemory: path === SQLiteStorageDatabase.IN_MEMORY_PATH\n\t\t\t\t};\n\n\t\t\t\t// Errors\n\t\t\t\tconnection.db.on('error', error => this.handleSQLiteError(connection, error, `[storage ${this.name}] Error (event): ${error}`));\n\n\t\t\t\t// Tracing\n\t\t\t\tif (this.logger.isTracing) {\n\t\t\t\t\tconnection.db.on('trace', sql => this.logger.trace(`[storage ${this.name}] Trace (event): ${sql}`));\n\t\t\t\t}\n\t\t\t}, reject);\n\t\t});\n\t}\n\n\tprivate exec(connection: IDatabaseConnection, sql: string): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.exec(sql, error => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.handleSQLiteError(connection, error, `[storage ${this.name}] exec(): ${error}`);\n\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn resolve();\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate get(connection: IDatabaseConnection, sql: string): Promise<object> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.get(sql, (error, row) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.handleSQLiteError(connection, error, `[storage ${this.name}] get(): ${error}`);\n\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn resolve(row);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate all(connection: IDatabaseConnection, sql: string): Promise<{ key: string, value: string }[]> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.all(sql, (error, rows) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.handleSQLiteError(connection, error, `[storage ${this.name}] all(): ${error}`);\n\n\t\t\t\t\treturn reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn resolve(rows);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate transaction(connection: IDatabaseConnection, transactions: () => void): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconnection.db.serialize(() => {\n\t\t\t\tconnection.db.run('BEGIN TRANSACTION');\n\n\t\t\t\ttransactions();\n\n\t\t\t\tconnection.db.run('END TRANSACTION', error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tthis.handleSQLiteError(connection, error, `[storage ${this.name}] transaction(): ${error}`);\n\n\t\t\t\t\t\treturn reject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate prepare(connection: IDatabaseConnection, sql: string, runCallback: (stmt: Statement) => void, errorDetails: () => string): void {\n\t\tconst stmt = connection.db.prepare(sql);\n\n\t\tconst statementErrorListener = (error: Error) => {\n\t\t\tthis.handleSQLiteError(connection, error, `[storage ${this.name}] prepare(): ${error} (${sql}). Details: ${errorDetails()}`);\n\t\t};\n\n\t\tstmt.on('error', statementErrorListener);\n\n\t\trunCallback(stmt);\n\n\t\tstmt.finalize(error => {\n\t\t\tif (error) {\n\t\t\t\tstatementErrorListener(error);\n\t\t\t}\n\n\t\t\tstmt.removeListener('error', statementErrorListener);\n\t\t});\n\t}\n}\n\nclass SQLiteStorageDatabaseLogger {\n\tprivate readonly logTrace: (msg: string) => void;\n\tprivate readonly logError: (error: string | Error) => void;\n\n\tconstructor(options?: ISQLiteStorageDatabaseLoggingOptions) {\n\t\tif (options && typeof options.logTrace === 'function') {\n\t\t\tthis.logTrace = options.logTrace;\n\t\t}\n\n\t\tif (options && typeof options.logError === 'function') {\n\t\t\tthis.logError = options.logError;\n\t\t}\n\t}\n\n\tget isTracing(): boolean {\n\t\treturn !!this.logTrace;\n\t}\n\n\ttrace(msg: string): void {\n\t\tif (this.logTrace) {\n\t\t\tthis.logTrace(msg);\n\t\t}\n\t}\n\n\terror(error: string | Error): void {\n\t\tif (this.logError) {\n\t\t\tthis.logError(error);\n\t\t}\n\t}\n}\n\nexport class InMemoryStorageDatabase implements IStorageDatabase {\n\n\treadonly onDidChangeItemsExternal = Event.None;\n\n\tprivate items = new Map<string, string>();\n\n\tgetItems(): Promise<Map<string, string>> {\n\t\treturn Promise.resolve(this.items);\n\t}\n\n\tupdateItems(request: IUpdateRequest): Promise<void> {\n\t\tif (request.insert) {\n\t\t\trequest.insert.forEach((value, key) => this.items.set(key, value));\n\t\t}\n\n\t\tif (request.delete) {\n\t\t\trequest.delete.forEach(key => this.items.delete(key));\n\t\t}\n\n\t\treturn Promise.resolve();\n\t}\n\n\tclose(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tcheckIntegrity(full: boolean): Promise<string> {\n\t\treturn Promise.resolve('ok');\n\t}\n}"]}]}