{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/multicursor/multicursor.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/multicursor/multicursor.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/async\", \"vs/base/common/keyCodes\", \"vs/base/common/lifecycle\", \"vs/editor/browser/editorExtensions\", \"vs/editor/common/controller/cursorCommon\", \"vs/editor/common/controller/cursorEvents\", \"vs/editor/common/controller/cursorMoveCommands\", \"vs/editor/common/core/range\", \"vs/editor/common/core/selection\", \"vs/editor/common/core/uint\", \"vs/editor/common/editorCommon\", \"vs/editor/common/editorContextKeys\", \"vs/editor/common/model\", \"vs/editor/common/model/textModel\", \"vs/editor/common/modes\", \"vs/editor/contrib/find/findController\", \"vs/editor/contrib/find/findState\", \"vs/platform/actions/common/actions\", \"vs/platform/keybinding/common/keybindingsRegistry\", \"vs/platform/theme/common/colorRegistry\", \"vs/platform/theme/common/themeService\"], function (require, exports, nls, async_1, keyCodes_1, lifecycle_1, editorExtensions_1, cursorCommon_1, cursorEvents_1, cursorMoveCommands_1, range_1, selection_1, uint_1, editorCommon_1, editorContextKeys_1, model_1, textModel_1, modes_1, findController_1, findState_1, actions_1, keybindingsRegistry_1, colorRegistry_1, themeService_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class InsertCursorAbove extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.insertCursorAbove',\n                label: nls.localize('mutlicursor.insertAbove', \"Add Cursor Above\"),\n                alias: 'Add Cursor Above',\n                precondition: null,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.UpArrow,\n                    linux: {\n                        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.UpArrow,\n                        secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.UpArrow]\n                    },\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                menubarOpts: {\n                    menuId: actions_1.MenuId.MenubarSelectionMenu,\n                    group: '3_multi',\n                    title: nls.localize({ key: 'miInsertCursorAbove', comment: ['&& denotes a mnemonic'] }, \"&&Add Cursor Above\"),\n                    order: 2\n                }\n            });\n        }\n        run(accessor, editor, args) {\n            if (!editor.hasModel()) {\n                return;\n            }\n            const useLogicalLine = (args && args.logicalLine === true);\n            const cursors = editor._getCursors();\n            const context = cursors.context;\n            if (context.config.readOnly) {\n                return;\n            }\n            context.model.pushStackElement();\n            cursors.setStates(args.source, cursorEvents_1.CursorChangeReason.Explicit, cursorMoveCommands_1.CursorMoveCommands.addCursorUp(context, cursors.getAll(), useLogicalLine));\n            cursors.reveal(true, cursorCommon_1.RevealTarget.TopMost, editorCommon_1.ScrollType.Smooth);\n        }\n    }\n    exports.InsertCursorAbove = InsertCursorAbove;\n    class InsertCursorBelow extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.insertCursorBelow',\n                label: nls.localize('mutlicursor.insertBelow', \"Add Cursor Below\"),\n                alias: 'Add Cursor Below',\n                precondition: null,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.DownArrow,\n                    linux: {\n                        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.DownArrow,\n                        secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.DownArrow]\n                    },\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                menubarOpts: {\n                    menuId: actions_1.MenuId.MenubarSelectionMenu,\n                    group: '3_multi',\n                    title: nls.localize({ key: 'miInsertCursorBelow', comment: ['&& denotes a mnemonic'] }, \"A&&dd Cursor Below\"),\n                    order: 3\n                }\n            });\n        }\n        run(accessor, editor, args) {\n            if (!editor.hasModel()) {\n                return;\n            }\n            const useLogicalLine = (args && args.logicalLine === true);\n            const cursors = editor._getCursors();\n            const context = cursors.context;\n            if (context.config.readOnly) {\n                return;\n            }\n            context.model.pushStackElement();\n            cursors.setStates(args.source, cursorEvents_1.CursorChangeReason.Explicit, cursorMoveCommands_1.CursorMoveCommands.addCursorDown(context, cursors.getAll(), useLogicalLine));\n            cursors.reveal(true, cursorCommon_1.RevealTarget.BottomMost, editorCommon_1.ScrollType.Smooth);\n        }\n    }\n    exports.InsertCursorBelow = InsertCursorBelow;\n    class InsertCursorAtEndOfEachLineSelected extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.insertCursorAtEndOfEachLineSelected',\n                label: nls.localize('mutlicursor.insertAtEndOfEachLineSelected', \"Add Cursors to Line Ends\"),\n                alias: 'Add Cursors to Line Ends',\n                precondition: null,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_I,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                menubarOpts: {\n                    menuId: actions_1.MenuId.MenubarSelectionMenu,\n                    group: '3_multi',\n                    title: nls.localize({ key: 'miInsertCursorAtEndOfEachLineSelected', comment: ['&& denotes a mnemonic'] }, \"Add C&&ursors to Line Ends\"),\n                    order: 4\n                }\n            });\n        }\n        getCursorsForSelection(selection, model, result) {\n            if (selection.isEmpty()) {\n                return;\n            }\n            for (let i = selection.startLineNumber; i < selection.endLineNumber; i++) {\n                let currentLineMaxColumn = model.getLineMaxColumn(i);\n                result.push(new selection_1.Selection(i, currentLineMaxColumn, i, currentLineMaxColumn));\n            }\n            if (selection.endColumn > 1) {\n                result.push(new selection_1.Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn));\n            }\n        }\n        run(accessor, editor) {\n            if (!editor.hasModel()) {\n                return;\n            }\n            const model = editor.getModel();\n            const selections = editor.getSelections();\n            let newSelections = [];\n            selections.forEach((sel) => this.getCursorsForSelection(sel, model, newSelections));\n            if (newSelections.length > 0) {\n                editor.setSelections(newSelections);\n            }\n        }\n    }\n    class InsertCursorAtEndOfLineSelected extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.addCursorsToBottom',\n                label: nls.localize('mutlicursor.addCursorsToBottom', \"Add Cursors To Bottom\"),\n                alias: 'Add Cursors To Bottom',\n                precondition: null\n            });\n        }\n        run(accessor, editor) {\n            if (!editor.hasModel()) {\n                return;\n            }\n            const selections = editor.getSelections();\n            const lineCount = editor.getModel().getLineCount();\n            let newSelections = [];\n            for (let i = selections[0].startLineNumber; i <= lineCount; i++) {\n                newSelections.push(new selection_1.Selection(i, selections[0].startColumn, i, selections[0].endColumn));\n            }\n            if (newSelections.length > 0) {\n                editor.setSelections(newSelections);\n            }\n        }\n    }\n    class InsertCursorAtTopOfLineSelected extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.addCursorsToTop',\n                label: nls.localize('mutlicursor.addCursorsToTop', \"Add Cursors To Top\"),\n                alias: 'Add Cursors To Top',\n                precondition: null\n            });\n        }\n        run(accessor, editor) {\n            if (!editor.hasModel()) {\n                return;\n            }\n            const selections = editor.getSelections();\n            let newSelections = [];\n            for (let i = selections[0].startLineNumber; i >= 1; i--) {\n                newSelections.push(new selection_1.Selection(i, selections[0].startColumn, i, selections[0].endColumn));\n            }\n            if (newSelections.length > 0) {\n                editor.setSelections(newSelections);\n            }\n        }\n    }\n    class MultiCursorSessionResult {\n        constructor(selections, revealRange, revealScrollType) {\n            this.selections = selections;\n            this.revealRange = revealRange;\n            this.revealScrollType = revealScrollType;\n        }\n    }\n    exports.MultiCursorSessionResult = MultiCursorSessionResult;\n    class MultiCursorSession {\n        constructor(_editor, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch) {\n            this._editor = _editor;\n            this.findController = findController;\n            this.isDisconnectedFromFindController = isDisconnectedFromFindController;\n            this.searchText = searchText;\n            this.wholeWord = wholeWord;\n            this.matchCase = matchCase;\n            this.currentMatch = currentMatch;\n        }\n        static create(editor, findController) {\n            if (!editor.hasModel()) {\n                return null;\n            }\n            const findState = findController.getState();\n            // Find widget owns entirely what we search for if:\n            //  - focus is not in the editor (i.e. it is in the find widget)\n            //  - and the search widget is visible\n            //  - and the search string is non-empty\n            if (!editor.hasTextFocus() && findState.isRevealed && findState.searchString.length > 0) {\n                // Find widget owns what is searched for\n                return new MultiCursorSession(editor, findController, false, findState.searchString, findState.wholeWord, findState.matchCase, null);\n            }\n            // Otherwise, the selection gives the search text, and the find widget gives the search settings\n            // The exception is the find state disassociation case: when beginning with a single, collapsed selection\n            let isDisconnectedFromFindController = false;\n            let wholeWord;\n            let matchCase;\n            const selections = editor.getSelections();\n            if (selections.length === 1 && selections[0].isEmpty()) {\n                isDisconnectedFromFindController = true;\n                wholeWord = true;\n                matchCase = true;\n            }\n            else {\n                wholeWord = findState.wholeWord;\n                matchCase = findState.matchCase;\n            }\n            // Selection owns what is searched for\n            const s = editor.getSelection();\n            let searchText;\n            let currentMatch = null;\n            if (s.isEmpty()) {\n                // selection is empty => expand to current word\n                const word = editor.getModel().getWordAtPosition(s.getStartPosition());\n                if (!word) {\n                    return null;\n                }\n                searchText = word.word;\n                currentMatch = new selection_1.Selection(s.startLineNumber, word.startColumn, s.startLineNumber, word.endColumn);\n            }\n            else {\n                searchText = editor.getModel().getValueInRange(s).replace(/\\r\\n/g, '\\n');\n            }\n            return new MultiCursorSession(editor, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch);\n        }\n        addSelectionToNextFindMatch() {\n            if (!this._editor.hasModel()) {\n                return null;\n            }\n            const nextMatch = this._getNextMatch();\n            if (!nextMatch) {\n                return null;\n            }\n            const allSelections = this._editor.getSelections();\n            return new MultiCursorSessionResult(allSelections.concat(nextMatch), nextMatch, editorCommon_1.ScrollType.Smooth);\n        }\n        moveSelectionToNextFindMatch() {\n            if (!this._editor.hasModel()) {\n                return null;\n            }\n            const nextMatch = this._getNextMatch();\n            if (!nextMatch) {\n                return null;\n            }\n            const allSelections = this._editor.getSelections();\n            return new MultiCursorSessionResult(allSelections.slice(0, allSelections.length - 1).concat(nextMatch), nextMatch, editorCommon_1.ScrollType.Smooth);\n        }\n        _getNextMatch() {\n            if (!this._editor.hasModel()) {\n                return null;\n            }\n            if (this.currentMatch) {\n                const result = this.currentMatch;\n                this.currentMatch = null;\n                return result;\n            }\n            this.findController.highlightFindOptions();\n            const allSelections = this._editor.getSelections();\n            const lastAddedSelection = allSelections[allSelections.length - 1];\n            const nextMatch = this._editor.getModel().findNextMatch(this.searchText, lastAddedSelection.getEndPosition(), false, this.matchCase, this.wholeWord ? this._editor.getConfiguration().wordSeparators : null, false);\n            if (!nextMatch) {\n                return null;\n            }\n            return new selection_1.Selection(nextMatch.range.startLineNumber, nextMatch.range.startColumn, nextMatch.range.endLineNumber, nextMatch.range.endColumn);\n        }\n        addSelectionToPreviousFindMatch() {\n            if (!this._editor.hasModel()) {\n                return null;\n            }\n            const previousMatch = this._getPreviousMatch();\n            if (!previousMatch) {\n                return null;\n            }\n            const allSelections = this._editor.getSelections();\n            return new MultiCursorSessionResult(allSelections.concat(previousMatch), previousMatch, editorCommon_1.ScrollType.Smooth);\n        }\n        moveSelectionToPreviousFindMatch() {\n            if (!this._editor.hasModel()) {\n                return null;\n            }\n            const previousMatch = this._getPreviousMatch();\n            if (!previousMatch) {\n                return null;\n            }\n            const allSelections = this._editor.getSelections();\n            return new MultiCursorSessionResult(allSelections.slice(0, allSelections.length - 1).concat(previousMatch), previousMatch, editorCommon_1.ScrollType.Smooth);\n        }\n        _getPreviousMatch() {\n            if (!this._editor.hasModel()) {\n                return null;\n            }\n            if (this.currentMatch) {\n                const result = this.currentMatch;\n                this.currentMatch = null;\n                return result;\n            }\n            this.findController.highlightFindOptions();\n            const allSelections = this._editor.getSelections();\n            const lastAddedSelection = allSelections[allSelections.length - 1];\n            const previousMatch = this._editor.getModel().findPreviousMatch(this.searchText, lastAddedSelection.getStartPosition(), false, this.matchCase, this.wholeWord ? this._editor.getConfiguration().wordSeparators : null, false);\n            if (!previousMatch) {\n                return null;\n            }\n            return new selection_1.Selection(previousMatch.range.startLineNumber, previousMatch.range.startColumn, previousMatch.range.endLineNumber, previousMatch.range.endColumn);\n        }\n        selectAll() {\n            if (!this._editor.hasModel()) {\n                return [];\n            }\n            this.findController.highlightFindOptions();\n            return this._editor.getModel().findMatches(this.searchText, true, false, this.matchCase, this.wholeWord ? this._editor.getConfiguration().wordSeparators : null, false, uint_1.Constants.MAX_SAFE_SMALL_INTEGER);\n        }\n    }\n    exports.MultiCursorSession = MultiCursorSession;\n    class MultiCursorSelectionController extends lifecycle_1.Disposable {\n        constructor(editor) {\n            super();\n            this._editor = editor;\n            this._ignoreSelectionChange = false;\n            this._session = null;\n            this._sessionDispose = [];\n        }\n        static get(editor) {\n            return editor.getContribution(MultiCursorSelectionController.ID);\n        }\n        dispose() {\n            this._endSession();\n            super.dispose();\n        }\n        getId() {\n            return MultiCursorSelectionController.ID;\n        }\n        _beginSessionIfNeeded(findController) {\n            if (!this._session) {\n                // Create a new session\n                const session = MultiCursorSession.create(this._editor, findController);\n                if (!session) {\n                    return;\n                }\n                this._session = session;\n                const newState = { searchString: this._session.searchText };\n                if (this._session.isDisconnectedFromFindController) {\n                    newState.wholeWordOverride = findState_1.FindOptionOverride.True;\n                    newState.matchCaseOverride = findState_1.FindOptionOverride.True;\n                    newState.isRegexOverride = findState_1.FindOptionOverride.False;\n                }\n                findController.getState().change(newState, false);\n                this._sessionDispose = [\n                    this._editor.onDidChangeCursorSelection((e) => {\n                        if (this._ignoreSelectionChange) {\n                            return;\n                        }\n                        this._endSession();\n                    }),\n                    this._editor.onDidBlurEditorText(() => {\n                        this._endSession();\n                    }),\n                    findController.getState().onFindReplaceStateChange((e) => {\n                        if (e.matchCase || e.wholeWord) {\n                            this._endSession();\n                        }\n                    })\n                ];\n            }\n        }\n        _endSession() {\n            this._sessionDispose = lifecycle_1.dispose(this._sessionDispose);\n            if (this._session && this._session.isDisconnectedFromFindController) {\n                const newState = {\n                    wholeWordOverride: findState_1.FindOptionOverride.NotSet,\n                    matchCaseOverride: findState_1.FindOptionOverride.NotSet,\n                    isRegexOverride: findState_1.FindOptionOverride.NotSet,\n                };\n                this._session.findController.getState().change(newState, false);\n            }\n            this._session = null;\n        }\n        _setSelections(selections) {\n            this._ignoreSelectionChange = true;\n            this._editor.setSelections(selections);\n            this._ignoreSelectionChange = false;\n        }\n        _expandEmptyToWord(model, selection) {\n            if (!selection.isEmpty()) {\n                return selection;\n            }\n            const word = model.getWordAtPosition(selection.getStartPosition());\n            if (!word) {\n                return selection;\n            }\n            return new selection_1.Selection(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);\n        }\n        _applySessionResult(result) {\n            if (!result) {\n                return;\n            }\n            this._setSelections(result.selections);\n            if (result.revealRange) {\n                this._editor.revealRangeInCenterIfOutsideViewport(result.revealRange, result.revealScrollType);\n            }\n        }\n        getSession(findController) {\n            return this._session;\n        }\n        addSelectionToNextFindMatch(findController) {\n            if (!this._editor.hasModel()) {\n                return;\n            }\n            if (!this._session) {\n                // If there are multiple cursors, handle the case where they do not all select the same text.\n                const allSelections = this._editor.getSelections();\n                if (allSelections.length > 1) {\n                    const findState = findController.getState();\n                    const matchCase = findState.matchCase;\n                    const selectionsContainSameText = modelRangesContainSameText(this._editor.getModel(), allSelections, matchCase);\n                    if (!selectionsContainSameText) {\n                        const model = this._editor.getModel();\n                        let resultingSelections = [];\n                        for (let i = 0, len = allSelections.length; i < len; i++) {\n                            resultingSelections[i] = this._expandEmptyToWord(model, allSelections[i]);\n                        }\n                        this._editor.setSelections(resultingSelections);\n                        return;\n                    }\n                }\n            }\n            this._beginSessionIfNeeded(findController);\n            if (this._session) {\n                this._applySessionResult(this._session.addSelectionToNextFindMatch());\n            }\n        }\n        addSelectionToPreviousFindMatch(findController) {\n            this._beginSessionIfNeeded(findController);\n            if (this._session) {\n                this._applySessionResult(this._session.addSelectionToPreviousFindMatch());\n            }\n        }\n        moveSelectionToNextFindMatch(findController) {\n            this._beginSessionIfNeeded(findController);\n            if (this._session) {\n                this._applySessionResult(this._session.moveSelectionToNextFindMatch());\n            }\n        }\n        moveSelectionToPreviousFindMatch(findController) {\n            this._beginSessionIfNeeded(findController);\n            if (this._session) {\n                this._applySessionResult(this._session.moveSelectionToPreviousFindMatch());\n            }\n        }\n        selectAll(findController) {\n            if (!this._editor.hasModel()) {\n                return;\n            }\n            let matches = null;\n            const findState = findController.getState();\n            // Special case: find widget owns entirely what we search for if:\n            // - focus is not in the editor (i.e. it is in the find widget)\n            // - and the search widget is visible\n            // - and the search string is non-empty\n            // - and we're searching for a regex\n            if (findState.isRevealed && findState.searchString.length > 0 && findState.isRegex) {\n                matches = this._editor.getModel().findMatches(findState.searchString, true, findState.isRegex, findState.matchCase, findState.wholeWord ? this._editor.getConfiguration().wordSeparators : null, false, uint_1.Constants.MAX_SAFE_SMALL_INTEGER);\n            }\n            else {\n                this._beginSessionIfNeeded(findController);\n                if (!this._session) {\n                    return;\n                }\n                matches = this._session.selectAll();\n            }\n            if (matches.length > 0) {\n                const editorSelection = this._editor.getSelection();\n                // Have the primary cursor remain the one where the action was invoked\n                for (let i = 0, len = matches.length; i < len; i++) {\n                    const match = matches[i];\n                    const intersection = match.range.intersectRanges(editorSelection);\n                    if (intersection) {\n                        // bingo!\n                        matches[i] = matches[0];\n                        matches[0] = match;\n                        break;\n                    }\n                }\n                this._setSelections(matches.map(m => new selection_1.Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn)));\n            }\n        }\n    }\n    MultiCursorSelectionController.ID = 'editor.contrib.multiCursorController';\n    exports.MultiCursorSelectionController = MultiCursorSelectionController;\n    class MultiCursorSelectionControllerAction extends editorExtensions_1.EditorAction {\n        run(accessor, editor) {\n            const multiCursorController = MultiCursorSelectionController.get(editor);\n            if (!multiCursorController) {\n                return;\n            }\n            const findController = findController_1.CommonFindController.get(editor);\n            if (!findController) {\n                return;\n            }\n            this._run(multiCursorController, findController);\n        }\n    }\n    exports.MultiCursorSelectionControllerAction = MultiCursorSelectionControllerAction;\n    class AddSelectionToNextFindMatchAction extends MultiCursorSelectionControllerAction {\n        constructor() {\n            super({\n                id: 'editor.action.addSelectionToNextFindMatch',\n                label: nls.localize('addSelectionToNextFindMatch', \"Add Selection To Next Find Match\"),\n                alias: 'Add Selection To Next Find Match',\n                precondition: null,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.focus,\n                    primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_D,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                menubarOpts: {\n                    menuId: actions_1.MenuId.MenubarSelectionMenu,\n                    group: '3_multi',\n                    title: nls.localize({ key: 'miAddSelectionToNextFindMatch', comment: ['&& denotes a mnemonic'] }, \"Add &&Next Occurrence\"),\n                    order: 5\n                }\n            });\n        }\n        _run(multiCursorController, findController) {\n            multiCursorController.addSelectionToNextFindMatch(findController);\n        }\n    }\n    exports.AddSelectionToNextFindMatchAction = AddSelectionToNextFindMatchAction;\n    class AddSelectionToPreviousFindMatchAction extends MultiCursorSelectionControllerAction {\n        constructor() {\n            super({\n                id: 'editor.action.addSelectionToPreviousFindMatch',\n                label: nls.localize('addSelectionToPreviousFindMatch', \"Add Selection To Previous Find Match\"),\n                alias: 'Add Selection To Previous Find Match',\n                precondition: null,\n                menubarOpts: {\n                    menuId: actions_1.MenuId.MenubarSelectionMenu,\n                    group: '3_multi',\n                    title: nls.localize({ key: 'miAddSelectionToPreviousFindMatch', comment: ['&& denotes a mnemonic'] }, \"Add P&&revious Occurrence\"),\n                    order: 6\n                }\n            });\n        }\n        _run(multiCursorController, findController) {\n            multiCursorController.addSelectionToPreviousFindMatch(findController);\n        }\n    }\n    exports.AddSelectionToPreviousFindMatchAction = AddSelectionToPreviousFindMatchAction;\n    class MoveSelectionToNextFindMatchAction extends MultiCursorSelectionControllerAction {\n        constructor() {\n            super({\n                id: 'editor.action.moveSelectionToNextFindMatch',\n                label: nls.localize('moveSelectionToNextFindMatch', \"Move Last Selection To Next Find Match\"),\n                alias: 'Move Last Selection To Next Find Match',\n                precondition: null,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.focus,\n                    primary: keyCodes_1.KeyChord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_D),\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        _run(multiCursorController, findController) {\n            multiCursorController.moveSelectionToNextFindMatch(findController);\n        }\n    }\n    exports.MoveSelectionToNextFindMatchAction = MoveSelectionToNextFindMatchAction;\n    class MoveSelectionToPreviousFindMatchAction extends MultiCursorSelectionControllerAction {\n        constructor() {\n            super({\n                id: 'editor.action.moveSelectionToPreviousFindMatch',\n                label: nls.localize('moveSelectionToPreviousFindMatch', \"Move Last Selection To Previous Find Match\"),\n                alias: 'Move Last Selection To Previous Find Match',\n                precondition: null\n            });\n        }\n        _run(multiCursorController, findController) {\n            multiCursorController.moveSelectionToPreviousFindMatch(findController);\n        }\n    }\n    exports.MoveSelectionToPreviousFindMatchAction = MoveSelectionToPreviousFindMatchAction;\n    class SelectHighlightsAction extends MultiCursorSelectionControllerAction {\n        constructor() {\n            super({\n                id: 'editor.action.selectHighlights',\n                label: nls.localize('selectAllOccurrencesOfFindMatch', \"Select All Occurrences of Find Match\"),\n                alias: 'Select All Occurrences of Find Match',\n                precondition: null,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.focus,\n                    primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_L,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                menubarOpts: {\n                    menuId: actions_1.MenuId.MenubarSelectionMenu,\n                    group: '3_multi',\n                    title: nls.localize({ key: 'miSelectHighlights', comment: ['&& denotes a mnemonic'] }, \"Select All &&Occurrences\"),\n                    order: 7\n                }\n            });\n        }\n        _run(multiCursorController, findController) {\n            multiCursorController.selectAll(findController);\n        }\n    }\n    exports.SelectHighlightsAction = SelectHighlightsAction;\n    class CompatChangeAll extends MultiCursorSelectionControllerAction {\n        constructor() {\n            super({\n                id: 'editor.action.changeAll',\n                label: nls.localize('changeAll.label', \"Change All Occurrences\"),\n                alias: 'Change All Occurrences',\n                precondition: editorContextKeys_1.EditorContextKeys.writable,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.F2,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                menuOpts: {\n                    group: '1_modification',\n                    order: 1.2\n                }\n            });\n        }\n        _run(multiCursorController, findController) {\n            multiCursorController.selectAll(findController);\n        }\n    }\n    exports.CompatChangeAll = CompatChangeAll;\n    class SelectionHighlighterState {\n        constructor(searchText, matchCase, wordSeparators) {\n            this.searchText = searchText;\n            this.matchCase = matchCase;\n            this.wordSeparators = wordSeparators;\n        }\n        /**\n         * Everything equals except for `lastWordUnderCursor`\n         */\n        static softEquals(a, b) {\n            if (!a && !b) {\n                return true;\n            }\n            if (!a || !b) {\n                return false;\n            }\n            return (a.searchText === b.searchText\n                && a.matchCase === b.matchCase\n                && a.wordSeparators === b.wordSeparators);\n        }\n    }\n    class SelectionHighlighter extends lifecycle_1.Disposable {\n        constructor(editor) {\n            super();\n            this.editor = editor;\n            this._isEnabled = editor.getConfiguration().contribInfo.selectionHighlight;\n            this.decorations = [];\n            this.updateSoon = this._register(new async_1.RunOnceScheduler(() => this._update(), 300));\n            this.state = null;\n            this._register(editor.onDidChangeConfiguration((e) => {\n                this._isEnabled = editor.getConfiguration().contribInfo.selectionHighlight;\n            }));\n            this._register(editor.onDidChangeCursorSelection((e) => {\n                if (!this._isEnabled) {\n                    // Early exit if nothing needs to be done!\n                    // Leave some form of early exit check here if you wish to continue being a cursor position change listener ;)\n                    return;\n                }\n                if (e.selection.isEmpty()) {\n                    if (e.reason === cursorEvents_1.CursorChangeReason.Explicit) {\n                        if (this.state) {\n                            // no longer valid\n                            this._setState(null);\n                        }\n                        this.updateSoon.schedule();\n                    }\n                    else {\n                        this._setState(null);\n                    }\n                }\n                else {\n                    this._update();\n                }\n            }));\n            this._register(editor.onDidChangeModel((e) => {\n                this._setState(null);\n            }));\n            this._register(findController_1.CommonFindController.get(editor).getState().onFindReplaceStateChange((e) => {\n                this._update();\n            }));\n        }\n        getId() {\n            return SelectionHighlighter.ID;\n        }\n        _update() {\n            this._setState(SelectionHighlighter._createState(this._isEnabled, this.editor));\n        }\n        static _createState(isEnabled, editor) {\n            if (!isEnabled) {\n                return null;\n            }\n            if (!editor.hasModel()) {\n                return null;\n            }\n            const s = editor.getSelection();\n            if (s.startLineNumber !== s.endLineNumber) {\n                // multiline forbidden for perf reasons\n                return null;\n            }\n            const multiCursorController = MultiCursorSelectionController.get(editor);\n            if (!multiCursorController) {\n                return null;\n            }\n            const findController = findController_1.CommonFindController.get(editor);\n            if (!findController) {\n                return null;\n            }\n            let r = multiCursorController.getSession(findController);\n            if (!r) {\n                const allSelections = editor.getSelections();\n                if (allSelections.length > 1) {\n                    const findState = findController.getState();\n                    const matchCase = findState.matchCase;\n                    const selectionsContainSameText = modelRangesContainSameText(editor.getModel(), allSelections, matchCase);\n                    if (!selectionsContainSameText) {\n                        return null;\n                    }\n                }\n                r = MultiCursorSession.create(editor, findController);\n            }\n            if (!r) {\n                return null;\n            }\n            if (r.currentMatch) {\n                // This is an empty selection\n                // Do not interfere with semantic word highlighting in the no selection case\n                return null;\n            }\n            if (/^[ \\t]+$/.test(r.searchText)) {\n                // whitespace only selection\n                return null;\n            }\n            if (r.searchText.length > 200) {\n                // very long selection\n                return null;\n            }\n            // TODO: better handling of this case\n            const findState = findController.getState();\n            const caseSensitive = findState.matchCase;\n            // Return early if the find widget shows the exact same matches\n            if (findState.isRevealed) {\n                let findStateSearchString = findState.searchString;\n                if (!caseSensitive) {\n                    findStateSearchString = findStateSearchString.toLowerCase();\n                }\n                let mySearchString = r.searchText;\n                if (!caseSensitive) {\n                    mySearchString = mySearchString.toLowerCase();\n                }\n                if (findStateSearchString === mySearchString && r.matchCase === findState.matchCase && r.wholeWord === findState.wholeWord && !findState.isRegex) {\n                    return null;\n                }\n            }\n            return new SelectionHighlighterState(r.searchText, r.matchCase, r.wholeWord ? editor.getConfiguration().wordSeparators : null);\n        }\n        _setState(state) {\n            if (SelectionHighlighterState.softEquals(this.state, state)) {\n                this.state = state;\n                return;\n            }\n            this.state = state;\n            if (!this.state) {\n                this.decorations = this.editor.deltaDecorations(this.decorations, []);\n                return;\n            }\n            if (!this.editor.hasModel()) {\n                return;\n            }\n            const model = this.editor.getModel();\n            if (model.isTooLargeForTokenization()) {\n                // the file is too large, so searching word under cursor in the whole document takes is blocking the UI.\n                return;\n            }\n            const hasFindOccurrences = modes_1.DocumentHighlightProviderRegistry.has(model);\n            let allMatches = model.findMatches(this.state.searchText, true, false, this.state.matchCase, this.state.wordSeparators, false).map(m => m.range);\n            allMatches.sort(range_1.Range.compareRangesUsingStarts);\n            let selections = this.editor.getSelections();\n            selections.sort(range_1.Range.compareRangesUsingStarts);\n            // do not overlap with selection (issue #64 and #512)\n            let matches = [];\n            for (let i = 0, j = 0, len = allMatches.length, lenJ = selections.length; i < len;) {\n                const match = allMatches[i];\n                if (j >= lenJ) {\n                    // finished all editor selections\n                    matches.push(match);\n                    i++;\n                }\n                else {\n                    const cmp = range_1.Range.compareRangesUsingStarts(match, selections[j]);\n                    if (cmp < 0) {\n                        // match is before sel\n                        if (selections[j].isEmpty() || !range_1.Range.areIntersecting(match, selections[j])) {\n                            matches.push(match);\n                        }\n                        i++;\n                    }\n                    else if (cmp > 0) {\n                        // sel is before match\n                        j++;\n                    }\n                    else {\n                        // sel is equal to match\n                        i++;\n                        j++;\n                    }\n                }\n            }\n            const decorations = matches.map(r => {\n                return {\n                    range: r,\n                    // Show in overviewRuler only if model has no semantic highlighting\n                    options: (hasFindOccurrences ? SelectionHighlighter._SELECTION_HIGHLIGHT : SelectionHighlighter._SELECTION_HIGHLIGHT_OVERVIEW)\n                };\n            });\n            this.decorations = this.editor.deltaDecorations(this.decorations, decorations);\n        }\n        dispose() {\n            this._setState(null);\n            super.dispose();\n        }\n    }\n    SelectionHighlighter.ID = 'editor.contrib.selectionHighlighter';\n    SelectionHighlighter._SELECTION_HIGHLIGHT_OVERVIEW = textModel_1.ModelDecorationOptions.register({\n        stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n        className: 'selectionHighlight',\n        overviewRuler: {\n            color: themeService_1.themeColorFromId(colorRegistry_1.overviewRulerSelectionHighlightForeground),\n            position: model_1.OverviewRulerLane.Center\n        }\n    });\n    SelectionHighlighter._SELECTION_HIGHLIGHT = textModel_1.ModelDecorationOptions.register({\n        stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n        className: 'selectionHighlight',\n    });\n    exports.SelectionHighlighter = SelectionHighlighter;\n    function modelRangesContainSameText(model, ranges, matchCase) {\n        const selectedText = getValueInRange(model, ranges[0], !matchCase);\n        for (let i = 1, len = ranges.length; i < len; i++) {\n            const range = ranges[i];\n            if (range.isEmpty()) {\n                return false;\n            }\n            const thisSelectedText = getValueInRange(model, range, !matchCase);\n            if (selectedText !== thisSelectedText) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function getValueInRange(model, range, toLowerCase) {\n        const text = model.getValueInRange(range);\n        return (toLowerCase ? text.toLowerCase() : text);\n    }\n    editorExtensions_1.registerEditorContribution(MultiCursorSelectionController);\n    editorExtensions_1.registerEditorContribution(SelectionHighlighter);\n    editorExtensions_1.registerEditorAction(InsertCursorAbove);\n    editorExtensions_1.registerEditorAction(InsertCursorBelow);\n    editorExtensions_1.registerEditorAction(InsertCursorAtEndOfEachLineSelected);\n    editorExtensions_1.registerEditorAction(AddSelectionToNextFindMatchAction);\n    editorExtensions_1.registerEditorAction(AddSelectionToPreviousFindMatchAction);\n    editorExtensions_1.registerEditorAction(MoveSelectionToNextFindMatchAction);\n    editorExtensions_1.registerEditorAction(MoveSelectionToPreviousFindMatchAction);\n    editorExtensions_1.registerEditorAction(SelectHighlightsAction);\n    editorExtensions_1.registerEditorAction(CompatChangeAll);\n    editorExtensions_1.registerEditorAction(InsertCursorAtEndOfLineSelected);\n    editorExtensions_1.registerEditorAction(InsertCursorAtTopOfLineSelected);\n});\n",null]}