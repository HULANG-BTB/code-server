{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/common/ipc.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/common/ipc.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/base/common/async\", \"vs/base/common/cancellation\", \"vs/base/common/errors\", \"vs/base/common/buffer\"], function (require, exports, event_1, lifecycle_1, async_1, cancellation_1, errors, buffer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var RequestType;\n    (function (RequestType) {\n        RequestType[RequestType[\"Promise\"] = 100] = \"Promise\";\n        RequestType[RequestType[\"PromiseCancel\"] = 101] = \"PromiseCancel\";\n        RequestType[RequestType[\"EventListen\"] = 102] = \"EventListen\";\n        RequestType[RequestType[\"EventDispose\"] = 103] = \"EventDispose\";\n    })(RequestType = exports.RequestType || (exports.RequestType = {}));\n    var ResponseType;\n    (function (ResponseType) {\n        ResponseType[ResponseType[\"Initialize\"] = 200] = \"Initialize\";\n        ResponseType[ResponseType[\"PromiseSuccess\"] = 201] = \"PromiseSuccess\";\n        ResponseType[ResponseType[\"PromiseError\"] = 202] = \"PromiseError\";\n        ResponseType[ResponseType[\"PromiseErrorObj\"] = 203] = \"PromiseErrorObj\";\n        ResponseType[ResponseType[\"EventFire\"] = 204] = \"EventFire\";\n    })(ResponseType = exports.ResponseType || (exports.ResponseType = {}));\n    var State;\n    (function (State) {\n        State[State[\"Uninitialized\"] = 0] = \"Uninitialized\";\n        State[State[\"Idle\"] = 1] = \"Idle\";\n    })(State || (State = {}));\n    class BufferReader {\n        constructor(buffer) {\n            this.buffer = buffer;\n            this.pos = 0;\n        }\n        read(bytes) {\n            const result = this.buffer.slice(this.pos, this.pos + bytes);\n            this.pos += result.byteLength;\n            return result;\n        }\n    }\n    class BufferWriter {\n        constructor() {\n            this.buffers = [];\n        }\n        get buffer() {\n            return buffer_1.VSBuffer.concat(this.buffers);\n        }\n        write(buffer) {\n            this.buffers.push(buffer);\n        }\n    }\n    var DataType;\n    (function (DataType) {\n        DataType[DataType[\"Undefined\"] = 0] = \"Undefined\";\n        DataType[DataType[\"String\"] = 1] = \"String\";\n        DataType[DataType[\"Buffer\"] = 2] = \"Buffer\";\n        DataType[DataType[\"VSBuffer\"] = 3] = \"VSBuffer\";\n        DataType[DataType[\"Array\"] = 4] = \"Array\";\n        DataType[DataType[\"Object\"] = 5] = \"Object\";\n    })(DataType || (DataType = {}));\n    function createSizeBuffer(size) {\n        const result = buffer_1.VSBuffer.alloc(4);\n        result.writeUint32BE(size, 0);\n        return result;\n    }\n    function readSizeBuffer(reader) {\n        return reader.read(4).readUint32BE(0);\n    }\n    function createOneByteBuffer(value) {\n        const result = buffer_1.VSBuffer.alloc(1);\n        result.writeUint8(value, 0);\n        return result;\n    }\n    const BufferPresets = {\n        Undefined: createOneByteBuffer(DataType.Undefined),\n        String: createOneByteBuffer(DataType.String),\n        Buffer: createOneByteBuffer(DataType.Buffer),\n        VSBuffer: createOneByteBuffer(DataType.VSBuffer),\n        Array: createOneByteBuffer(DataType.Array),\n        Object: createOneByteBuffer(DataType.Object),\n    };\n    const hasBuffer = (typeof Buffer !== 'undefined');\n    function serialize(writer, data) {\n        if (typeof data === 'undefined') {\n            writer.write(BufferPresets.Undefined);\n        }\n        else if (typeof data === 'string') {\n            const buffer = buffer_1.VSBuffer.fromString(data);\n            writer.write(BufferPresets.String);\n            writer.write(createSizeBuffer(buffer.byteLength));\n            writer.write(buffer);\n        }\n        else if (hasBuffer && Buffer.isBuffer(data)) {\n            const buffer = buffer_1.VSBuffer.wrap(data);\n            writer.write(BufferPresets.Buffer);\n            writer.write(createSizeBuffer(buffer.byteLength));\n            writer.write(buffer);\n        }\n        else if (data instanceof buffer_1.VSBuffer) {\n            writer.write(BufferPresets.VSBuffer);\n            writer.write(createSizeBuffer(data.byteLength));\n            writer.write(data);\n        }\n        else if (Array.isArray(data)) {\n            writer.write(BufferPresets.Array);\n            writer.write(createSizeBuffer(data.length));\n            for (const el of data) {\n                serialize(writer, el);\n            }\n        }\n        else {\n            const buffer = buffer_1.VSBuffer.fromString(JSON.stringify(data));\n            writer.write(BufferPresets.Object);\n            writer.write(createSizeBuffer(buffer.byteLength));\n            writer.write(buffer);\n        }\n    }\n    function deserialize(reader) {\n        const type = reader.read(1).readUint8(0);\n        switch (type) {\n            case DataType.Undefined: return undefined;\n            case DataType.String: return reader.read(readSizeBuffer(reader)).toString();\n            case DataType.Buffer: return reader.read(readSizeBuffer(reader)).buffer;\n            case DataType.VSBuffer: return reader.read(readSizeBuffer(reader));\n            case DataType.Array: {\n                const length = readSizeBuffer(reader);\n                const result = [];\n                for (let i = 0; i < length; i++) {\n                    result.push(deserialize(reader));\n                }\n                return result;\n            }\n            case DataType.Object: return JSON.parse(reader.read(readSizeBuffer(reader)).toString());\n        }\n    }\n    class ChannelServer {\n        constructor(protocol, ctx) {\n            this.protocol = protocol;\n            this.ctx = ctx;\n            this.channels = new Map();\n            this.activeRequests = new Map();\n            this.protocolListener = this.protocol.onMessage(msg => this.onRawMessage(msg));\n            this.sendResponse({ type: ResponseType.Initialize });\n        }\n        registerChannel(channelName, channel) {\n            this.channels.set(channelName, channel);\n        }\n        sendResponse(response) {\n            switch (response.type) {\n                case ResponseType.Initialize:\n                    return this.send([response.type]);\n                case ResponseType.PromiseSuccess:\n                case ResponseType.PromiseError:\n                case ResponseType.EventFire:\n                case ResponseType.PromiseErrorObj:\n                    return this.send([response.type, response.id], response.data);\n            }\n        }\n        send(header, body = undefined) {\n            const writer = new BufferWriter();\n            serialize(writer, header);\n            serialize(writer, body);\n            this.sendBuffer(writer.buffer);\n        }\n        sendBuffer(message) {\n            try {\n                this.protocol.send(message);\n            }\n            catch (err) {\n                // noop\n            }\n        }\n        onRawMessage(message) {\n            const reader = new BufferReader(message);\n            const header = deserialize(reader);\n            const body = deserialize(reader);\n            const type = header[0];\n            switch (type) {\n                case RequestType.Promise:\n                    return this.onPromise({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n                case RequestType.EventListen:\n                    return this.onEventListen({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n                case RequestType.PromiseCancel:\n                    return this.disposeActiveRequest({ type, id: header[1] });\n                case RequestType.EventDispose:\n                    return this.disposeActiveRequest({ type, id: header[1] });\n            }\n        }\n        onPromise(request) {\n            const channel = this.channels.get(request.channelName);\n            if (!channel) {\n                throw new Error('Unknown channel');\n            }\n            const cancellationTokenSource = new cancellation_1.CancellationTokenSource();\n            let promise;\n            try {\n                promise = channel.call(this.ctx, request.name, request.arg, cancellationTokenSource.token);\n            }\n            catch (err) {\n                promise = Promise.reject(err);\n            }\n            const id = request.id;\n            promise.then(data => {\n                this.sendResponse({ id, data, type: ResponseType.PromiseSuccess });\n                this.activeRequests.delete(request.id);\n            }, err => {\n                if (err instanceof Error) {\n                    this.sendResponse({\n                        id, data: {\n                            message: err.message,\n                            name: err.name,\n                            stack: err.stack ? (err.stack.split ? err.stack.split('\\n') : err.stack) : undefined\n                        }, type: ResponseType.PromiseError\n                    });\n                }\n                else {\n                    this.sendResponse({ id, data: err, type: ResponseType.PromiseErrorObj });\n                }\n                this.activeRequests.delete(request.id);\n            });\n            const disposable = lifecycle_1.toDisposable(() => cancellationTokenSource.cancel());\n            this.activeRequests.set(request.id, disposable);\n        }\n        onEventListen(request) {\n            const channel = this.channels.get(request.channelName);\n            if (!channel) {\n                throw new Error('Unknown channel');\n            }\n            const id = request.id;\n            const event = channel.listen(this.ctx, request.name, request.arg);\n            const disposable = event(data => this.sendResponse({ id, data, type: ResponseType.EventFire }));\n            this.activeRequests.set(request.id, disposable);\n        }\n        disposeActiveRequest(request) {\n            const disposable = this.activeRequests.get(request.id);\n            if (disposable) {\n                disposable.dispose();\n                this.activeRequests.delete(request.id);\n            }\n        }\n        dispose() {\n            if (this.protocolListener) {\n                this.protocolListener.dispose();\n                this.protocolListener = null;\n            }\n            this.activeRequests.forEach(d => d.dispose());\n            this.activeRequests.clear();\n        }\n    }\n    exports.ChannelServer = ChannelServer;\n    class ChannelClient {\n        constructor(protocol) {\n            this.protocol = protocol;\n            this.state = State.Uninitialized;\n            this.activeRequests = new Set();\n            this.handlers = new Map();\n            this.lastRequestId = 0;\n            this._onDidInitialize = new event_1.Emitter();\n            this.onDidInitialize = this._onDidInitialize.event;\n            this.protocolListener = this.protocol.onMessage(msg => this.onBuffer(msg));\n        }\n        getChannel(channelName) {\n            const that = this;\n            return {\n                call(command, arg, cancellationToken) {\n                    return that.requestPromise(channelName, command, arg, cancellationToken);\n                },\n                listen(event, arg) {\n                    return that.requestEvent(channelName, event, arg);\n                }\n            };\n        }\n        requestPromise(channelName, name, arg, cancellationToken = cancellation_1.CancellationToken.None) {\n            const id = this.lastRequestId++;\n            const type = RequestType.Promise;\n            const request = { id, type, channelName, name, arg };\n            if (cancellationToken.isCancellationRequested) {\n                return Promise.reject(errors.canceled());\n            }\n            let disposable;\n            const result = new Promise((c, e) => {\n                if (cancellationToken.isCancellationRequested) {\n                    return e(errors.canceled());\n                }\n                let uninitializedPromise = async_1.createCancelablePromise(_ => this.whenInitialized());\n                uninitializedPromise.then(() => {\n                    uninitializedPromise = null;\n                    const handler = response => {\n                        switch (response.type) {\n                            case ResponseType.PromiseSuccess:\n                                this.handlers.delete(id);\n                                c(response.data);\n                                break;\n                            case ResponseType.PromiseError:\n                                this.handlers.delete(id);\n                                const error = new Error(response.data.message);\n                                error.stack = response.data.stack;\n                                error.name = response.data.name;\n                                e(error);\n                                break;\n                            case ResponseType.PromiseErrorObj:\n                                this.handlers.delete(id);\n                                e(response.data);\n                                break;\n                        }\n                    };\n                    this.handlers.set(id, handler);\n                    this.sendRequest(request);\n                });\n                const cancel = () => {\n                    if (uninitializedPromise) {\n                        uninitializedPromise.cancel();\n                        uninitializedPromise = null;\n                    }\n                    else {\n                        this.sendRequest({ id, type: RequestType.PromiseCancel });\n                    }\n                    e(errors.canceled());\n                };\n                const cancellationTokenListener = cancellationToken.onCancellationRequested(cancel);\n                disposable = lifecycle_1.combinedDisposable([lifecycle_1.toDisposable(cancel), cancellationTokenListener]);\n                this.activeRequests.add(disposable);\n            });\n            return result.finally(() => this.activeRequests.delete(disposable));\n        }\n        requestEvent(channelName, name, arg) {\n            const id = this.lastRequestId++;\n            const type = RequestType.EventListen;\n            const request = { id, type, channelName, name, arg };\n            let uninitializedPromise = null;\n            const emitter = new event_1.Emitter({\n                onFirstListenerAdd: () => {\n                    uninitializedPromise = async_1.createCancelablePromise(_ => this.whenInitialized());\n                    uninitializedPromise.then(() => {\n                        uninitializedPromise = null;\n                        this.activeRequests.add(emitter);\n                        this.sendRequest(request);\n                    });\n                },\n                onLastListenerRemove: () => {\n                    if (uninitializedPromise) {\n                        uninitializedPromise.cancel();\n                        uninitializedPromise = null;\n                    }\n                    else {\n                        this.activeRequests.delete(emitter);\n                        this.sendRequest({ id, type: RequestType.EventDispose });\n                    }\n                }\n            });\n            const handler = (res) => emitter.fire(res.data);\n            this.handlers.set(id, handler);\n            return emitter.event;\n        }\n        sendRequest(request) {\n            switch (request.type) {\n                case RequestType.Promise:\n                case RequestType.EventListen:\n                    return this.send([request.type, request.id, request.channelName, request.name], request.arg);\n                case RequestType.PromiseCancel:\n                case RequestType.EventDispose:\n                    return this.send([request.type, request.id]);\n            }\n        }\n        send(header, body = undefined) {\n            const writer = new BufferWriter();\n            serialize(writer, header);\n            serialize(writer, body);\n            this.sendBuffer(writer.buffer);\n        }\n        sendBuffer(message) {\n            try {\n                this.protocol.send(message);\n            }\n            catch (err) {\n                // noop\n            }\n        }\n        onBuffer(message) {\n            const reader = new BufferReader(message);\n            const header = deserialize(reader);\n            const body = deserialize(reader);\n            const type = header[0];\n            switch (type) {\n                case ResponseType.Initialize:\n                    return this.onResponse({ type: header[0] });\n                case ResponseType.PromiseSuccess:\n                case ResponseType.PromiseError:\n                case ResponseType.EventFire:\n                case ResponseType.PromiseErrorObj:\n                    return this.onResponse({ type: header[0], id: header[1], data: body });\n            }\n        }\n        onResponse(response) {\n            if (response.type === ResponseType.Initialize) {\n                this.state = State.Idle;\n                this._onDidInitialize.fire();\n                return;\n            }\n            const handler = this.handlers.get(response.id);\n            if (handler) {\n                handler(response);\n            }\n        }\n        whenInitialized() {\n            if (this.state === State.Idle) {\n                return Promise.resolve();\n            }\n            else {\n                return event_1.Event.toPromise(this.onDidInitialize);\n            }\n        }\n        dispose() {\n            if (this.protocolListener) {\n                this.protocolListener.dispose();\n                this.protocolListener = null;\n            }\n            this.activeRequests.forEach(p => p.dispose());\n            this.activeRequests.clear();\n        }\n    }\n    exports.ChannelClient = ChannelClient;\n    /**\n     * An `IPCServer` is both a channel server and a routing channel\n     * client.\n     *\n     * As the owner of a protocol, you should extend both this\n     * and the `IPCClient` classes to get IPC implementations\n     * for your protocol.\n     */\n    class IPCServer {\n        constructor(onDidClientConnect) {\n            this.channels = new Map();\n            this._connections = new Set();\n            this._onDidChangeConnections = new event_1.Emitter();\n            this.onDidChangeConnections = this._onDidChangeConnections.event;\n            onDidClientConnect(({ protocol, onDidClientDisconnect }) => {\n                const onFirstMessage = event_1.Event.once(protocol.onMessage);\n                onFirstMessage(msg => {\n                    const reader = new BufferReader(msg);\n                    const ctx = deserialize(reader);\n                    const channelServer = new ChannelServer(protocol, ctx);\n                    const channelClient = new ChannelClient(protocol);\n                    this.channels.forEach((channel, name) => channelServer.registerChannel(name, channel));\n                    const connection = { channelClient, ctx };\n                    this._connections.add(connection);\n                    this._onDidChangeConnections.fire(connection);\n                    onDidClientDisconnect(() => {\n                        channelServer.dispose();\n                        channelClient.dispose();\n                        this._connections.delete(connection);\n                    });\n                });\n            });\n        }\n        get connections() {\n            const result = [];\n            this._connections.forEach(ctx => result.push(ctx));\n            return result;\n        }\n        getChannel(channelName, router) {\n            const that = this;\n            return {\n                call(command, arg, cancellationToken) {\n                    const channelPromise = router.routeCall(that, command, arg)\n                        .then(connection => connection.channelClient.getChannel(channelName));\n                    return getDelayedChannel(channelPromise)\n                        .call(command, arg, cancellationToken);\n                },\n                listen(event, arg) {\n                    const channelPromise = router.routeEvent(that, event, arg)\n                        .then(connection => connection.channelClient.getChannel(channelName));\n                    return getDelayedChannel(channelPromise)\n                        .listen(event, arg);\n                }\n            };\n        }\n        registerChannel(channelName, channel) {\n            this.channels.set(channelName, channel);\n        }\n        dispose() {\n            this.channels.clear();\n            this._connections.clear();\n            this._onDidChangeConnections.dispose();\n        }\n    }\n    exports.IPCServer = IPCServer;\n    /**\n     * An `IPCClient` is both a channel client and a channel server.\n     *\n     * As the owner of a protocol, you should extend both this\n     * and the `IPCClient` classes to get IPC implementations\n     * for your protocol.\n     */\n    class IPCClient {\n        constructor(protocol, ctx) {\n            const writer = new BufferWriter();\n            serialize(writer, ctx);\n            protocol.send(writer.buffer);\n            this.channelClient = new ChannelClient(protocol);\n            this.channelServer = new ChannelServer(protocol, ctx);\n        }\n        getChannel(channelName) {\n            return this.channelClient.getChannel(channelName);\n        }\n        registerChannel(channelName, channel) {\n            this.channelServer.registerChannel(channelName, channel);\n        }\n        dispose() {\n            this.channelClient.dispose();\n            this.channelServer.dispose();\n        }\n    }\n    exports.IPCClient = IPCClient;\n    function getDelayedChannel(promise) {\n        return {\n            call(command, arg, cancellationToken) {\n                return promise.then(c => c.call(command, arg, cancellationToken));\n            },\n            listen(event, arg) {\n                const relay = new event_1.Relay();\n                promise.then(c => relay.input = c.listen(event, arg));\n                return relay.event;\n            }\n        };\n    }\n    exports.getDelayedChannel = getDelayedChannel;\n    function getNextTickChannel(channel) {\n        let didTick = false;\n        return {\n            call(command, arg, cancellationToken) {\n                if (didTick) {\n                    return channel.call(command, arg, cancellationToken);\n                }\n                return async_1.timeout(0)\n                    .then(() => didTick = true)\n                    .then(() => channel.call(command, arg, cancellationToken));\n            },\n            listen(event, arg) {\n                if (didTick) {\n                    return channel.listen(event, arg);\n                }\n                const relay = new event_1.Relay();\n                async_1.timeout(0)\n                    .then(() => didTick = true)\n                    .then(() => relay.input = channel.listen(event, arg));\n                return relay.event;\n            }\n        };\n    }\n    exports.getNextTickChannel = getNextTickChannel;\n    class StaticRouter {\n        constructor(fn) {\n            this.fn = fn;\n        }\n        routeCall(hub) {\n            return this.route(hub);\n        }\n        routeEvent(hub) {\n            return this.route(hub);\n        }\n        route(hub) {\n            return __awaiter(this, void 0, void 0, function* () {\n                for (const connection of hub.connections) {\n                    if (yield Promise.resolve(this.fn(connection.ctx))) {\n                        return Promise.resolve(connection);\n                    }\n                }\n                yield event_1.Event.toPromise(hub.onDidChangeConnections);\n                return yield this.route(hub);\n            });\n        }\n    }\n    exports.StaticRouter = StaticRouter;\n});\n",null]}