{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/node/windowsShellHelper.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/node/windowsShellHelper.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar platform = require(\"vs/base/common/platform\");\nvar event_1 = require(\"vs/base/common/event\");\nvar SHELL_EXECUTABLES = [\n    'cmd.exe',\n    'powershell.exe',\n    'bash.exe',\n    'wsl.exe',\n    'ubuntu.exe',\n    'ubuntu1804.exe',\n    'kali.exe',\n    'debian.exe',\n    'opensuse-42.exe',\n    'sles-12.exe'\n];\nvar windowsProcessTree;\nvar WindowsShellHelper = /** @class */ (function () {\n    function WindowsShellHelper(_rootProcessId, _terminalInstance, _xterm) {\n        var _this = this;\n        this._rootProcessId = _rootProcessId;\n        this._terminalInstance = _terminalInstance;\n        this._xterm = _xterm;\n        if (!platform.isWindows) {\n            throw new Error(\"WindowsShellHelper cannot be instantiated on \" + platform.platform);\n        }\n        this._isDisposed = false;\n        (Promise.resolve().then(function () { return require('windows-process-tree'); })).then(function (mod) {\n            if (_this._isDisposed) {\n                return;\n            }\n            windowsProcessTree = mod;\n            _this._onCheckShell = new event_1.Emitter();\n            // The debounce is necessary to prevent multiple processes from spawning when\n            // the enter key or output is spammed\n            event_1.Event.debounce(_this._onCheckShell.event, function (l, e) { return e; }, 150, true)(function () {\n                setTimeout(function () {\n                    _this.checkShell();\n                }, 50);\n            });\n            // We want to fire a new check for the shell on a linefeed, but only\n            // when parsing has finished which is indicated by the cursormove event.\n            // If this is done on every linefeed, parsing ends up taking\n            // significantly longer due to resetting timers. Note that this is\n            // private API.\n            _this._xterm.on('linefeed', function () { return _this._newLineFeed = true; });\n            _this._xterm.on('cursormove', function () {\n                if (_this._newLineFeed) {\n                    _this._onCheckShell.fire(undefined);\n                }\n            });\n            // Fire a new check for the shell when any key is pressed.\n            _this._xterm.on('keypress', function () { return _this._onCheckShell.fire(undefined); });\n        });\n    }\n    WindowsShellHelper.prototype.checkShell = function () {\n        var _this = this;\n        if (platform.isWindows && this._terminalInstance.isTitleSetByProcess) {\n            this.getShellName().then(function (title) {\n                if (!_this._isDisposed) {\n                    _this._terminalInstance.setTitle(title, true);\n                }\n            });\n        }\n    };\n    WindowsShellHelper.prototype.traverseTree = function (tree) {\n        if (!tree) {\n            return '';\n        }\n        if (SHELL_EXECUTABLES.indexOf(tree.name) === -1) {\n            return tree.name;\n        }\n        if (!tree.children || tree.children.length === 0) {\n            return tree.name;\n        }\n        var favouriteChild = 0;\n        for (; favouriteChild < tree.children.length; favouriteChild++) {\n            var child = tree.children[favouriteChild];\n            if (!child.children || child.children.length === 0) {\n                break;\n            }\n            if (child.children[0].name !== 'conhost.exe') {\n                break;\n            }\n        }\n        if (favouriteChild >= tree.children.length) {\n            return tree.name;\n        }\n        return this.traverseTree(tree.children[favouriteChild]);\n    };\n    WindowsShellHelper.prototype.dispose = function () {\n        this._isDisposed = true;\n    };\n    /**\n     * Returns the innermost shell executable running in the terminal\n     */\n    WindowsShellHelper.prototype.getShellName = function () {\n        var _this = this;\n        if (this._isDisposed) {\n            return Promise.resolve('');\n        }\n        // Prevent multiple requests at once, instead return current request\n        if (this._currentRequest) {\n            return this._currentRequest;\n        }\n        this._currentRequest = new Promise(function (resolve) {\n            windowsProcessTree.getProcessTree(_this._rootProcessId, function (tree) {\n                var name = _this.traverseTree(tree);\n                _this._currentRequest = null;\n                resolve(name);\n            });\n        });\n        return this._currentRequest;\n    };\n    return WindowsShellHelper;\n}());\nexports.WindowsShellHelper = WindowsShellHelper;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/node/windowsShellHelper.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/node/windowsShellHelper.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as platform from 'vs/base/common/platform';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { ITerminalInstance, IWindowsShellHelper } from 'vs/workbench/contrib/terminal/common/terminal';\nimport { Terminal as XTermTerminal } from 'vscode-xterm';\nimport WindowsProcessTreeType = require('windows-process-tree');\n\nconst SHELL_EXECUTABLES = [\n\t'cmd.exe',\n\t'powershell.exe',\n\t'bash.exe',\n\t'wsl.exe',\n\t'ubuntu.exe',\n\t'ubuntu1804.exe',\n\t'kali.exe',\n\t'debian.exe',\n\t'opensuse-42.exe',\n\t'sles-12.exe'\n];\n\nlet windowsProcessTree: typeof WindowsProcessTreeType;\n\nexport class WindowsShellHelper implements IWindowsShellHelper {\n\tprivate _onCheckShell: Emitter<Promise<string> | undefined>;\n\tprivate _isDisposed: boolean;\n\tprivate _currentRequest: Promise<string> | null;\n\tprivate _newLineFeed: boolean;\n\n\tpublic constructor(\n\t\tprivate _rootProcessId: number,\n\t\tprivate _terminalInstance: ITerminalInstance,\n\t\tprivate _xterm: XTermTerminal\n\t) {\n\t\tif (!platform.isWindows) {\n\t\t\tthrow new Error(`WindowsShellHelper cannot be instantiated on ${platform.platform}`);\n\t\t}\n\n\t\tthis._isDisposed = false;\n\n\t\t(import('windows-process-tree')).then(mod => {\n\t\t\tif (this._isDisposed) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twindowsProcessTree = mod;\n\t\t\tthis._onCheckShell = new Emitter<Promise<string>>();\n\t\t\t// The debounce is necessary to prevent multiple processes from spawning when\n\t\t\t// the enter key or output is spammed\n\t\t\tEvent.debounce(this._onCheckShell.event, (l, e) => e, 150, true)(() => {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.checkShell();\n\t\t\t\t}, 50);\n\t\t\t});\n\n\t\t\t// We want to fire a new check for the shell on a linefeed, but only\n\t\t\t// when parsing has finished which is indicated by the cursormove event.\n\t\t\t// If this is done on every linefeed, parsing ends up taking\n\t\t\t// significantly longer due to resetting timers. Note that this is\n\t\t\t// private API.\n\t\t\tthis._xterm.on('linefeed', () => this._newLineFeed = true);\n\t\t\tthis._xterm.on('cursormove', () => {\n\t\t\t\tif (this._newLineFeed) {\n\t\t\t\t\tthis._onCheckShell.fire(undefined);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Fire a new check for the shell when any key is pressed.\n\t\t\tthis._xterm.on('keypress', () => this._onCheckShell.fire(undefined));\n\t\t});\n\t}\n\n\tprivate checkShell(): void {\n\t\tif (platform.isWindows && this._terminalInstance.isTitleSetByProcess) {\n\t\t\tthis.getShellName().then(title => {\n\t\t\t\tif (!this._isDisposed) {\n\t\t\t\t\tthis._terminalInstance.setTitle(title, true);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate traverseTree(tree: any): string {\n\t\tif (!tree) {\n\t\t\treturn '';\n\t\t}\n\t\tif (SHELL_EXECUTABLES.indexOf(tree.name) === -1) {\n\t\t\treturn tree.name;\n\t\t}\n\t\tif (!tree.children || tree.children.length === 0) {\n\t\t\treturn tree.name;\n\t\t}\n\t\tlet favouriteChild = 0;\n\t\tfor (; favouriteChild < tree.children.length; favouriteChild++) {\n\t\t\tconst child = tree.children[favouriteChild];\n\t\t\tif (!child.children || child.children.length === 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (child.children[0].name !== 'conhost.exe') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (favouriteChild >= tree.children.length) {\n\t\t\treturn tree.name;\n\t\t}\n\t\treturn this.traverseTree(tree.children[favouriteChild]);\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._isDisposed = true;\n\t}\n\n\t/**\n\t * Returns the innermost shell executable running in the terminal\n\t */\n\tpublic getShellName(): Promise<string> {\n\t\tif (this._isDisposed) {\n\t\t\treturn Promise.resolve('');\n\t\t}\n\t\t// Prevent multiple requests at once, instead return current request\n\t\tif (this._currentRequest) {\n\t\t\treturn this._currentRequest;\n\t\t}\n\t\tthis._currentRequest = new Promise<string>(resolve => {\n\t\t\twindowsProcessTree.getProcessTree(this._rootProcessId, (tree) => {\n\t\t\t\tconst name = this.traverseTree(tree);\n\t\t\t\tthis._currentRequest = null;\n\t\t\t\tresolve(name);\n\t\t\t});\n\t\t});\n\t\treturn this._currentRequest;\n\t}\n}\n"]}]}