{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/viewLineRenderer.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/viewLineRenderer.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/charCode\", \"vs/base/common/strings\", \"vs/editor/common/core/stringBuilder\", \"vs/editor/common/viewLayout/lineDecorations\", \"vs/editor/common/viewModel/viewModel\"], function (require, exports, charCode_1, strings, stringBuilder_1, lineDecorations_1, viewModel_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var RenderWhitespace;\n    (function (RenderWhitespace) {\n        RenderWhitespace[RenderWhitespace[\"None\"] = 0] = \"None\";\n        RenderWhitespace[RenderWhitespace[\"Boundary\"] = 1] = \"Boundary\";\n        RenderWhitespace[RenderWhitespace[\"All\"] = 2] = \"All\";\n    })(RenderWhitespace = exports.RenderWhitespace || (exports.RenderWhitespace = {}));\n    class LinePart {\n        constructor(endIndex, type) {\n            this.endIndex = endIndex;\n            this.type = type;\n        }\n    }\n    class RenderLineInput {\n        constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, spaceWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures) {\n            this.useMonospaceOptimizations = useMonospaceOptimizations;\n            this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n            this.lineContent = lineContent;\n            this.continuesWithWrappedLine = continuesWithWrappedLine;\n            this.isBasicASCII = isBasicASCII;\n            this.containsRTL = containsRTL;\n            this.fauxIndentLength = fauxIndentLength;\n            this.lineTokens = lineTokens;\n            this.lineDecorations = lineDecorations;\n            this.tabSize = tabSize;\n            this.spaceWidth = spaceWidth;\n            this.stopRenderingLineAfter = stopRenderingLineAfter;\n            this.renderWhitespace = (renderWhitespace === 'all'\n                ? RenderWhitespace.All\n                : renderWhitespace === 'boundary'\n                    ? RenderWhitespace.Boundary\n                    : RenderWhitespace.None);\n            this.renderControlCharacters = renderControlCharacters;\n            this.fontLigatures = fontLigatures;\n        }\n        equals(other) {\n            return (this.useMonospaceOptimizations === other.useMonospaceOptimizations\n                && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n                && this.lineContent === other.lineContent\n                && this.continuesWithWrappedLine === other.continuesWithWrappedLine\n                && this.isBasicASCII === other.isBasicASCII\n                && this.containsRTL === other.containsRTL\n                && this.fauxIndentLength === other.fauxIndentLength\n                && this.tabSize === other.tabSize\n                && this.spaceWidth === other.spaceWidth\n                && this.stopRenderingLineAfter === other.stopRenderingLineAfter\n                && this.renderWhitespace === other.renderWhitespace\n                && this.renderControlCharacters === other.renderControlCharacters\n                && this.fontLigatures === other.fontLigatures\n                && lineDecorations_1.LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\n                && this.lineTokens.equals(other.lineTokens));\n        }\n    }\n    exports.RenderLineInput = RenderLineInput;\n    var CharacterMappingConstants;\n    (function (CharacterMappingConstants) {\n        CharacterMappingConstants[CharacterMappingConstants[\"PART_INDEX_MASK\"] = 4294901760] = \"PART_INDEX_MASK\";\n        CharacterMappingConstants[CharacterMappingConstants[\"CHAR_INDEX_MASK\"] = 65535] = \"CHAR_INDEX_MASK\";\n        CharacterMappingConstants[CharacterMappingConstants[\"CHAR_INDEX_OFFSET\"] = 0] = \"CHAR_INDEX_OFFSET\";\n        CharacterMappingConstants[CharacterMappingConstants[\"PART_INDEX_OFFSET\"] = 16] = \"PART_INDEX_OFFSET\";\n    })(CharacterMappingConstants = exports.CharacterMappingConstants || (exports.CharacterMappingConstants = {}));\n    /**\n     * Provides a both direction mapping between a line's character and its rendered position.\n     */\n    class CharacterMapping {\n        static getPartIndex(partData) {\n            return (partData & CharacterMappingConstants.PART_INDEX_MASK) >>> CharacterMappingConstants.PART_INDEX_OFFSET;\n        }\n        static getCharIndex(partData) {\n            return (partData & CharacterMappingConstants.CHAR_INDEX_MASK) >>> CharacterMappingConstants.CHAR_INDEX_OFFSET;\n        }\n        constructor(length, partCount) {\n            this.length = length;\n            this._data = new Uint32Array(this.length);\n            this._absoluteOffsets = new Uint32Array(this.length);\n        }\n        setPartData(charOffset, partIndex, charIndex, partAbsoluteOffset) {\n            let partData = ((partIndex << CharacterMappingConstants.PART_INDEX_OFFSET)\n                | (charIndex << CharacterMappingConstants.CHAR_INDEX_OFFSET)) >>> 0;\n            this._data[charOffset] = partData;\n            this._absoluteOffsets[charOffset] = partAbsoluteOffset + charIndex;\n        }\n        getAbsoluteOffsets() {\n            return this._absoluteOffsets;\n        }\n        charOffsetToPartData(charOffset) {\n            if (this.length === 0) {\n                return 0;\n            }\n            if (charOffset < 0) {\n                return this._data[0];\n            }\n            if (charOffset >= this.length) {\n                return this._data[this.length - 1];\n            }\n            return this._data[charOffset];\n        }\n        partDataToCharOffset(partIndex, partLength, charIndex) {\n            if (this.length === 0) {\n                return 0;\n            }\n            let searchEntry = ((partIndex << CharacterMappingConstants.PART_INDEX_OFFSET)\n                | (charIndex << CharacterMappingConstants.CHAR_INDEX_OFFSET)) >>> 0;\n            let min = 0;\n            let max = this.length - 1;\n            while (min + 1 < max) {\n                let mid = ((min + max) >>> 1);\n                let midEntry = this._data[mid];\n                if (midEntry === searchEntry) {\n                    return mid;\n                }\n                else if (midEntry > searchEntry) {\n                    max = mid;\n                }\n                else {\n                    min = mid;\n                }\n            }\n            if (min === max) {\n                return min;\n            }\n            let minEntry = this._data[min];\n            let maxEntry = this._data[max];\n            if (minEntry === searchEntry) {\n                return min;\n            }\n            if (maxEntry === searchEntry) {\n                return max;\n            }\n            let minPartIndex = CharacterMapping.getPartIndex(minEntry);\n            let minCharIndex = CharacterMapping.getCharIndex(minEntry);\n            let maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n            let maxCharIndex;\n            if (minPartIndex !== maxPartIndex) {\n                // sitting between parts\n                maxCharIndex = partLength;\n            }\n            else {\n                maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n            }\n            let minEntryDistance = charIndex - minCharIndex;\n            let maxEntryDistance = maxCharIndex - charIndex;\n            if (minEntryDistance <= maxEntryDistance) {\n                return min;\n            }\n            return max;\n        }\n    }\n    exports.CharacterMapping = CharacterMapping;\n    var ForeignElementType;\n    (function (ForeignElementType) {\n        ForeignElementType[ForeignElementType[\"None\"] = 0] = \"None\";\n        ForeignElementType[ForeignElementType[\"Before\"] = 1] = \"Before\";\n        ForeignElementType[ForeignElementType[\"After\"] = 2] = \"After\";\n    })(ForeignElementType = exports.ForeignElementType || (exports.ForeignElementType = {}));\n    class RenderLineOutput {\n        constructor(characterMapping, containsRTL, containsForeignElements) {\n            this.characterMapping = characterMapping;\n            this.containsRTL = containsRTL;\n            this.containsForeignElements = containsForeignElements;\n        }\n    }\n    exports.RenderLineOutput = RenderLineOutput;\n    function renderViewLine(input, sb) {\n        if (input.lineContent.length === 0) {\n            let containsForeignElements = ForeignElementType.None;\n            // This is basically for IE's hit test to work\n            let content = '<span><span>\\u00a0</span></span>';\n            if (input.lineDecorations.length > 0) {\n                // This line is empty, but it contains inline decorations\n                let classNames = [];\n                for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n                    const lineDecoration = input.lineDecorations[i];\n                    if (lineDecoration.type === viewModel_1.InlineDecorationType.Before) {\n                        classNames.push(input.lineDecorations[i].className);\n                        containsForeignElements |= ForeignElementType.Before;\n                    }\n                    if (lineDecoration.type === viewModel_1.InlineDecorationType.After) {\n                        classNames.push(input.lineDecorations[i].className);\n                        containsForeignElements |= ForeignElementType.After;\n                    }\n                }\n                if (containsForeignElements !== ForeignElementType.None) {\n                    content = `<span><span class=\"${classNames.join(' ')}\"></span></span>`;\n                }\n            }\n            sb.appendASCIIString(content);\n            return new RenderLineOutput(new CharacterMapping(0, 0), false, containsForeignElements);\n        }\n        return _renderLine(resolveRenderLineInput(input), sb);\n    }\n    exports.renderViewLine = renderViewLine;\n    class RenderLineOutput2 {\n        constructor(characterMapping, html, containsRTL, containsForeignElements) {\n            this.characterMapping = characterMapping;\n            this.html = html;\n            this.containsRTL = containsRTL;\n            this.containsForeignElements = containsForeignElements;\n        }\n    }\n    exports.RenderLineOutput2 = RenderLineOutput2;\n    function renderViewLine2(input) {\n        let sb = stringBuilder_1.createStringBuilder(10000);\n        let out = renderViewLine(input, sb);\n        return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n    }\n    exports.renderViewLine2 = renderViewLine2;\n    class ResolvedRenderLineInput {\n        constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, tabSize, containsRTL, spaceWidth, renderWhitespace, renderControlCharacters) {\n            this.fontIsMonospace = fontIsMonospace;\n            this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n            this.lineContent = lineContent;\n            this.len = len;\n            this.isOverflowing = isOverflowing;\n            this.parts = parts;\n            this.containsForeignElements = containsForeignElements;\n            this.tabSize = tabSize;\n            this.containsRTL = containsRTL;\n            this.spaceWidth = spaceWidth;\n            this.renderWhitespace = renderWhitespace;\n            this.renderControlCharacters = renderControlCharacters;\n            //\n        }\n    }\n    function resolveRenderLineInput(input) {\n        const useMonospaceOptimizations = input.useMonospaceOptimizations;\n        const lineContent = input.lineContent;\n        let isOverflowing;\n        let len;\n        if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n            isOverflowing = true;\n            len = input.stopRenderingLineAfter;\n        }\n        else {\n            isOverflowing = false;\n            len = lineContent.length;\n        }\n        let tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);\n        if (input.renderWhitespace === RenderWhitespace.All || input.renderWhitespace === RenderWhitespace.Boundary) {\n            tokens = _applyRenderWhitespace(lineContent, len, input.continuesWithWrappedLine, tokens, input.fauxIndentLength, input.tabSize, useMonospaceOptimizations, input.renderWhitespace === RenderWhitespace.Boundary);\n        }\n        let containsForeignElements = ForeignElementType.None;\n        if (input.lineDecorations.length > 0) {\n            for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n                const lineDecoration = input.lineDecorations[i];\n                if (lineDecoration.type === viewModel_1.InlineDecorationType.RegularAffectingLetterSpacing) {\n                    // Pretend there are foreign elements... although not 100% accurate.\n                    containsForeignElements |= ForeignElementType.Before;\n                }\n                else if (lineDecoration.type === viewModel_1.InlineDecorationType.Before) {\n                    containsForeignElements |= ForeignElementType.Before;\n                }\n                else if (lineDecoration.type === viewModel_1.InlineDecorationType.After) {\n                    containsForeignElements |= ForeignElementType.After;\n                }\n            }\n            tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n        }\n        if (!input.containsRTL) {\n            // We can never split RTL text, as it ruins the rendering\n            tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n        }\n        return new ResolvedRenderLineInput(useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.tabSize, input.containsRTL, input.spaceWidth, input.renderWhitespace, input.renderControlCharacters);\n    }\n    /**\n     * In the rendering phase, characters are always looped until token.endIndex.\n     * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n     */\n    function transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {\n        let result = [], resultLen = 0;\n        // The faux indent part of the line should have no token type\n        if (fauxIndentLength > 0) {\n            result[resultLen++] = new LinePart(fauxIndentLength, '');\n        }\n        for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n            const endIndex = tokens.getEndOffset(tokenIndex);\n            if (endIndex <= fauxIndentLength) {\n                // The faux indent part of the line should have no token type\n                continue;\n            }\n            const type = tokens.getClassName(tokenIndex);\n            if (endIndex >= len) {\n                result[resultLen++] = new LinePart(len, type);\n                break;\n            }\n            result[resultLen++] = new LinePart(endIndex, type);\n        }\n        return result;\n    }\n    /**\n     * written as a const enum to get value inlining.\n     */\n    var Constants;\n    (function (Constants) {\n        Constants[Constants[\"LongToken\"] = 50] = \"LongToken\";\n    })(Constants || (Constants = {}));\n    /**\n     * See https://github.com/Microsoft/vscode/issues/6885.\n     * It appears that having very large spans causes very slow reading of character positions.\n     * So here we try to avoid that.\n     */\n    function splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n        let lastTokenEndIndex = 0;\n        let result = [], resultLen = 0;\n        if (onlyAtSpaces) {\n            // Split only at spaces => we need to walk each character\n            for (let i = 0, len = tokens.length; i < len; i++) {\n                const token = tokens[i];\n                const tokenEndIndex = token.endIndex;\n                if (lastTokenEndIndex + Constants.LongToken < tokenEndIndex) {\n                    const tokenType = token.type;\n                    let lastSpaceOffset = -1;\n                    let currTokenStart = lastTokenEndIndex;\n                    for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n                        if (lineContent.charCodeAt(j) === charCode_1.CharCode.Space) {\n                            lastSpaceOffset = j;\n                        }\n                        if (lastSpaceOffset !== -1 && j - currTokenStart >= Constants.LongToken) {\n                            // Split at `lastSpaceOffset` + 1\n                            result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType);\n                            currTokenStart = lastSpaceOffset + 1;\n                            lastSpaceOffset = -1;\n                        }\n                    }\n                    if (currTokenStart !== tokenEndIndex) {\n                        result[resultLen++] = new LinePart(tokenEndIndex, tokenType);\n                    }\n                }\n                else {\n                    result[resultLen++] = token;\n                }\n                lastTokenEndIndex = tokenEndIndex;\n            }\n        }\n        else {\n            // Split anywhere => we don't need to walk each character\n            for (let i = 0, len = tokens.length; i < len; i++) {\n                const token = tokens[i];\n                const tokenEndIndex = token.endIndex;\n                let diff = (tokenEndIndex - lastTokenEndIndex);\n                if (diff > Constants.LongToken) {\n                    const tokenType = token.type;\n                    const piecesCount = Math.ceil(diff / Constants.LongToken);\n                    for (let j = 1; j < piecesCount; j++) {\n                        let pieceEndIndex = lastTokenEndIndex + (j * Constants.LongToken);\n                        result[resultLen++] = new LinePart(pieceEndIndex, tokenType);\n                    }\n                    result[resultLen++] = new LinePart(tokenEndIndex, tokenType);\n                }\n                else {\n                    result[resultLen++] = token;\n                }\n                lastTokenEndIndex = tokenEndIndex;\n            }\n        }\n        return result;\n    }\n    /**\n     * Whitespace is rendered by \"replacing\" tokens with a special-purpose `vs-whitespace` type that is later recognized in the rendering phase.\n     * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n     * The rendering phase will generate `style=\"width:...\"` for these tokens.\n     */\n    function _applyRenderWhitespace(lineContent, len, continuesWithWrappedLine, tokens, fauxIndentLength, tabSize, useMonospaceOptimizations, onlyBoundary) {\n        let result = [], resultLen = 0;\n        let tokenIndex = 0;\n        let tokenType = tokens[tokenIndex].type;\n        let tokenEndIndex = tokens[tokenIndex].endIndex;\n        const tokensLength = tokens.length;\n        let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n        let lastNonWhitespaceIndex;\n        if (firstNonWhitespaceIndex === -1) {\n            // The entire line is whitespace\n            firstNonWhitespaceIndex = len;\n            lastNonWhitespaceIndex = len;\n        }\n        else {\n            lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n        }\n        let tmpIndent = 0;\n        for (let charIndex = 0; charIndex < fauxIndentLength; charIndex++) {\n            const chCode = lineContent.charCodeAt(charIndex);\n            if (chCode === charCode_1.CharCode.Tab) {\n                tmpIndent = tabSize;\n            }\n            else if (strings.isFullWidthCharacter(chCode)) {\n                tmpIndent += 2;\n            }\n            else {\n                tmpIndent++;\n            }\n        }\n        tmpIndent = tmpIndent % tabSize;\n        let wasInWhitespace = false;\n        for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n            const chCode = lineContent.charCodeAt(charIndex);\n            let isInWhitespace;\n            if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n                // in leading or trailing whitespace\n                isInWhitespace = true;\n            }\n            else if (chCode === charCode_1.CharCode.Tab) {\n                // a tab character is rendered both in all and boundary cases\n                isInWhitespace = true;\n            }\n            else if (chCode === charCode_1.CharCode.Space) {\n                // hit a space character\n                if (onlyBoundary) {\n                    // rendering only boundary whitespace\n                    if (wasInWhitespace) {\n                        isInWhitespace = true;\n                    }\n                    else {\n                        const nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : charCode_1.CharCode.Null);\n                        isInWhitespace = (nextChCode === charCode_1.CharCode.Space || nextChCode === charCode_1.CharCode.Tab);\n                    }\n                }\n                else {\n                    isInWhitespace = true;\n                }\n            }\n            else {\n                isInWhitespace = false;\n            }\n            if (wasInWhitespace) {\n                // was in whitespace token\n                if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\n                    // leaving whitespace token or entering a new indent\n                    result[resultLen++] = new LinePart(charIndex, 'vs-whitespace');\n                    tmpIndent = tmpIndent % tabSize;\n                }\n            }\n            else {\n                // was in regular token\n                if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\n                    result[resultLen++] = new LinePart(charIndex, tokenType);\n                    tmpIndent = tmpIndent % tabSize;\n                }\n            }\n            if (chCode === charCode_1.CharCode.Tab) {\n                tmpIndent = tabSize;\n            }\n            else if (strings.isFullWidthCharacter(chCode)) {\n                tmpIndent += 2;\n            }\n            else {\n                tmpIndent++;\n            }\n            wasInWhitespace = isInWhitespace;\n            if (charIndex === tokenEndIndex) {\n                tokenIndex++;\n                if (tokenIndex < tokensLength) {\n                    tokenType = tokens[tokenIndex].type;\n                    tokenEndIndex = tokens[tokenIndex].endIndex;\n                }\n            }\n        }\n        let generateWhitespace = false;\n        if (wasInWhitespace) {\n            // was in whitespace token\n            if (continuesWithWrappedLine && onlyBoundary) {\n                let lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : charCode_1.CharCode.Null);\n                let prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : charCode_1.CharCode.Null);\n                let isSingleTrailingSpace = (lastCharCode === charCode_1.CharCode.Space && (prevCharCode !== charCode_1.CharCode.Space && prevCharCode !== charCode_1.CharCode.Tab));\n                if (!isSingleTrailingSpace) {\n                    generateWhitespace = true;\n                }\n            }\n            else {\n                generateWhitespace = true;\n            }\n        }\n        result[resultLen++] = new LinePart(len, generateWhitespace ? 'vs-whitespace' : tokenType);\n        return result;\n    }\n    /**\n     * Inline decorations are \"merged\" on top of tokens.\n     * Special care must be taken when multiple inline decorations are at play and they overlap.\n     */\n    function _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n        _lineDecorations.sort(lineDecorations_1.LineDecoration.compare);\n        const lineDecorations = lineDecorations_1.LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n        const lineDecorationsLen = lineDecorations.length;\n        let lineDecorationIndex = 0;\n        let result = [], resultLen = 0, lastResultEndIndex = 0;\n        for (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n            const token = tokens[tokenIndex];\n            const tokenEndIndex = token.endIndex;\n            const tokenType = token.type;\n            while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n                const lineDecoration = lineDecorations[lineDecorationIndex];\n                if (lineDecoration.startOffset > lastResultEndIndex) {\n                    lastResultEndIndex = lineDecoration.startOffset;\n                    result[resultLen++] = new LinePart(lastResultEndIndex, tokenType);\n                }\n                if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n                    // This line decoration ends before this token ends\n                    lastResultEndIndex = lineDecoration.endOffset + 1;\n                    result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);\n                    lineDecorationIndex++;\n                }\n                else {\n                    // This line decoration continues on to the next token\n                    lastResultEndIndex = tokenEndIndex;\n                    result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);\n                    break;\n                }\n            }\n            if (tokenEndIndex > lastResultEndIndex) {\n                lastResultEndIndex = tokenEndIndex;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType);\n            }\n        }\n        const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n        if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n            let classNames = [];\n            while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n                classNames.push(lineDecorations[lineDecorationIndex].className);\n                lineDecorationIndex++;\n            }\n            result[resultLen++] = new LinePart(lastResultEndIndex, classNames.join(' '));\n        }\n        return result;\n    }\n    /**\n     * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n     * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n     */\n    function _renderLine(input, sb) {\n        const fontIsMonospace = input.fontIsMonospace;\n        const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n        const containsForeignElements = input.containsForeignElements;\n        const lineContent = input.lineContent;\n        const len = input.len;\n        const isOverflowing = input.isOverflowing;\n        const parts = input.parts;\n        const tabSize = input.tabSize;\n        const containsRTL = input.containsRTL;\n        const spaceWidth = input.spaceWidth;\n        const renderWhitespace = input.renderWhitespace;\n        const renderControlCharacters = input.renderControlCharacters;\n        const characterMapping = new CharacterMapping(len + 1, parts.length);\n        let charIndex = 0;\n        let tabsCharDelta = 0;\n        let charOffsetInPart = 0;\n        let prevPartContentCnt = 0;\n        let partAbsoluteOffset = 0;\n        sb.appendASCIIString('<span>');\n        for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n            partAbsoluteOffset += prevPartContentCnt;\n            const part = parts[partIndex];\n            const partEndIndex = part.endIndex;\n            const partType = part.type;\n            const partRendersWhitespace = (renderWhitespace !== RenderWhitespace.None && (partType.indexOf('vs-whitespace') >= 0));\n            charOffsetInPart = 0;\n            sb.appendASCIIString('<span class=\"');\n            sb.appendASCIIString(partType);\n            sb.appendASCII(charCode_1.CharCode.DoubleQuote);\n            if (partRendersWhitespace) {\n                let partContentCnt = 0;\n                {\n                    let _charIndex = charIndex;\n                    let _tabsCharDelta = tabsCharDelta;\n                    for (; _charIndex < partEndIndex; _charIndex++) {\n                        const charCode = lineContent.charCodeAt(_charIndex);\n                        if (charCode === charCode_1.CharCode.Tab) {\n                            let insertSpacesCount = tabSize - (_charIndex + _tabsCharDelta) % tabSize;\n                            _tabsCharDelta += insertSpacesCount - 1;\n                            partContentCnt += insertSpacesCount;\n                        }\n                        else {\n                            // must be CharCode.Space\n                            partContentCnt++;\n                        }\n                    }\n                }\n                if (!fontIsMonospace) {\n                    const partIsOnlyWhitespace = (partType === 'vs-whitespace');\n                    if (partIsOnlyWhitespace || !containsForeignElements) {\n                        sb.appendASCIIString(' style=\"width:');\n                        sb.appendASCIIString(String(spaceWidth * partContentCnt));\n                        sb.appendASCIIString('px\"');\n                    }\n                }\n                sb.appendASCII(charCode_1.CharCode.GreaterThan);\n                for (; charIndex < partEndIndex; charIndex++) {\n                    characterMapping.setPartData(charIndex, partIndex, charOffsetInPart, partAbsoluteOffset);\n                    const charCode = lineContent.charCodeAt(charIndex);\n                    if (charCode === charCode_1.CharCode.Tab) {\n                        let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                        tabsCharDelta += insertSpacesCount - 1;\n                        charOffsetInPart += insertSpacesCount - 1;\n                        if (insertSpacesCount > 0) {\n                            if (!canUseHalfwidthRightwardsArrow || insertSpacesCount > 1) {\n                                sb.write1(0x2192); // RIGHTWARDS ARROW\n                            }\n                            else {\n                                sb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n                            }\n                            insertSpacesCount--;\n                        }\n                        while (insertSpacesCount > 0) {\n                            sb.write1(0xA0); // &nbsp;\n                            insertSpacesCount--;\n                        }\n                    }\n                    else {\n                        // must be CharCode.Space\n                        sb.write1(0xB7); // &middot;\n                    }\n                    charOffsetInPart++;\n                }\n                prevPartContentCnt = partContentCnt;\n            }\n            else {\n                let partContentCnt = 0;\n                if (containsRTL) {\n                    sb.appendASCIIString(' dir=\"ltr\"');\n                }\n                sb.appendASCII(charCode_1.CharCode.GreaterThan);\n                for (; charIndex < partEndIndex; charIndex++) {\n                    characterMapping.setPartData(charIndex, partIndex, charOffsetInPart, partAbsoluteOffset);\n                    const charCode = lineContent.charCodeAt(charIndex);\n                    switch (charCode) {\n                        case charCode_1.CharCode.Tab:\n                            let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                            tabsCharDelta += insertSpacesCount - 1;\n                            charOffsetInPart += insertSpacesCount - 1;\n                            while (insertSpacesCount > 0) {\n                                sb.write1(0xA0); // &nbsp;\n                                partContentCnt++;\n                                insertSpacesCount--;\n                            }\n                            break;\n                        case charCode_1.CharCode.Space:\n                            sb.write1(0xA0); // &nbsp;\n                            partContentCnt++;\n                            break;\n                        case charCode_1.CharCode.LessThan:\n                            sb.appendASCIIString('&lt;');\n                            partContentCnt++;\n                            break;\n                        case charCode_1.CharCode.GreaterThan:\n                            sb.appendASCIIString('&gt;');\n                            partContentCnt++;\n                            break;\n                        case charCode_1.CharCode.Ampersand:\n                            sb.appendASCIIString('&amp;');\n                            partContentCnt++;\n                            break;\n                        case charCode_1.CharCode.Null:\n                            sb.appendASCIIString('&#00;');\n                            partContentCnt++;\n                            break;\n                        case charCode_1.CharCode.UTF8_BOM:\n                        case charCode_1.CharCode.LINE_SEPARATOR_2028:\n                            sb.write1(0xFFFD);\n                            partContentCnt++;\n                            break;\n                        default:\n                            if (strings.isFullWidthCharacter(charCode)) {\n                                tabsCharDelta++;\n                            }\n                            if (renderControlCharacters && charCode < 32) {\n                                sb.write1(9216 + charCode);\n                                partContentCnt++;\n                            }\n                            else {\n                                sb.write1(charCode);\n                                partContentCnt++;\n                            }\n                    }\n                    charOffsetInPart++;\n                }\n                prevPartContentCnt = partContentCnt;\n            }\n            sb.appendASCIIString('</span>');\n        }\n        // When getting client rects for the last character, we will position the\n        // text range at the end of the span, insteaf of at the beginning of next span\n        characterMapping.setPartData(len, parts.length - 1, charOffsetInPart, partAbsoluteOffset);\n        if (isOverflowing) {\n            sb.appendASCIIString('<span>&hellip;</span>');\n        }\n        sb.appendASCIIString('</span>');\n        return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n    }\n});\n",null]}