{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/electron-browser/extensionHostProfiler.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/electron-browser/extensionHostProfiler.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/map\", \"vs/base/node/extfs\", \"vs/workbench/services/extensions/common/extensions\", \"vs/base/common/types\"], function (require, exports, map_1, extfs_1, extensions_1, types_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let ExtensionHostProfiler = class ExtensionHostProfiler {\n        constructor(_port, _extensionService) {\n            this._port = _port;\n            this._extensionService = _extensionService;\n        }\n        start() {\n            return __awaiter(this, void 0, void 0, function* () {\n                const profiler = yield new Promise((resolve_1, reject_1) => { require(['v8-inspect-profiler'], resolve_1, reject_1); });\n                const session = yield profiler.startProfiling({ port: this._port, checkForPaused: true });\n                return {\n                    stop: () => __awaiter(this, void 0, void 0, function* () {\n                        const profile = yield session.stop();\n                        const extensions = yield this._extensionService.getExtensions();\n                        return this.distill(profile.profile, extensions);\n                    })\n                };\n            });\n        }\n        distill(profile, extensions) {\n            let searchTree = map_1.TernarySearchTree.forPaths();\n            for (let extension of extensions) {\n                searchTree.set(extfs_1.realpathSync(extension.extensionLocation.fsPath), extension);\n            }\n            let nodes = profile.nodes;\n            let idsToNodes = new Map();\n            let idsToSegmentId = new Map();\n            for (let node of nodes) {\n                idsToNodes.set(node.id, node);\n            }\n            function visit(node, segmentId) {\n                if (!segmentId) {\n                    switch (node.callFrame.functionName) {\n                        case '(root)':\n                            break;\n                        case '(program)':\n                            segmentId = 'program';\n                            break;\n                        case '(garbage collector)':\n                            segmentId = 'gc';\n                            break;\n                        default:\n                            segmentId = 'self';\n                            break;\n                    }\n                }\n                else if (segmentId === 'self' && node.callFrame.url) {\n                    let extension = searchTree.findSubstr(node.callFrame.url);\n                    if (extension) {\n                        segmentId = extension.identifier.value;\n                    }\n                }\n                idsToSegmentId.set(node.id, segmentId);\n                if (node.children) {\n                    for (const child of node.children) {\n                        const childNode = idsToNodes.get(child);\n                        if (childNode) {\n                            visit(childNode, segmentId);\n                        }\n                    }\n                }\n            }\n            visit(nodes[0], null);\n            const samples = profile.samples || [];\n            let timeDeltas = profile.timeDeltas || [];\n            let distilledDeltas = [];\n            let distilledIds = [];\n            let currSegmentTime = 0;\n            let currSegmentId;\n            for (let i = 0; i < samples.length; i++) {\n                let id = samples[i];\n                let segmentId = idsToSegmentId.get(id);\n                if (segmentId !== currSegmentId) {\n                    if (currSegmentId) {\n                        distilledIds.push(currSegmentId);\n                        distilledDeltas.push(currSegmentTime);\n                    }\n                    currSegmentId = types_1.withNullAsUndefined(segmentId);\n                    currSegmentTime = 0;\n                }\n                currSegmentTime += timeDeltas[i];\n            }\n            if (currSegmentId) {\n                distilledIds.push(currSegmentId);\n                distilledDeltas.push(currSegmentTime);\n            }\n            return {\n                startTime: profile.startTime,\n                endTime: profile.endTime,\n                deltas: distilledDeltas,\n                ids: distilledIds,\n                data: profile,\n                getAggregatedTimes: () => {\n                    let segmentsToTime = new Map();\n                    for (let i = 0; i < distilledIds.length; i++) {\n                        let id = distilledIds[i];\n                        segmentsToTime.set(id, (segmentsToTime.get(id) || 0) + distilledDeltas[i]);\n                    }\n                    return segmentsToTime;\n                }\n            };\n        }\n    };\n    ExtensionHostProfiler = __decorate([\n        __param(1, extensions_1.IExtensionService)\n    ], ExtensionHostProfiler);\n    exports.ExtensionHostProfiler = ExtensionHostProfiler;\n});\n",null]}