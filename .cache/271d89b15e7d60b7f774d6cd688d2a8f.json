{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/event.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/event.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/errors\", \"vs/base/common/functional\", \"vs/base/common/lifecycle\", \"vs/base/common/linkedList\"], function (require, exports, errors_1, functional_1, lifecycle_1, linkedList_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Event;\n    (function (Event) {\n        const _disposable = { dispose() { } };\n        Event.None = function () { return _disposable; };\n        /**\n         * Given an event, returns another event which only fires once.\n         */\n        function once(event) {\n            return (listener, thisArgs = null, disposables) => {\n                // we need this, in case the event fires during the listener call\n                let didFire = false;\n                let result;\n                result = event(e => {\n                    if (didFire) {\n                        return;\n                    }\n                    else if (result) {\n                        result.dispose();\n                    }\n                    else {\n                        didFire = true;\n                    }\n                    return listener.call(thisArgs, e);\n                }, null, disposables);\n                if (didFire) {\n                    result.dispose();\n                }\n                return result;\n            };\n        }\n        Event.once = once;\n        /**\n         * Given an event and a `map` function, returns another event which maps each element\n         * throught the mapping function.\n         */\n        function map(event, map) {\n            return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables));\n        }\n        Event.map = map;\n        /**\n         * Given an event and an `each` function, returns another identical event and calls\n         * the `each` function per each element.\n         */\n        function forEach(event, each) {\n            return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables));\n        }\n        Event.forEach = forEach;\n        function filter(event, filter) {\n            return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables));\n        }\n        Event.filter = filter;\n        /**\n         * Given an event, returns the same event but typed as `Event<void>`.\n         */\n        function signal(event) {\n            return event;\n        }\n        Event.signal = signal;\n        /**\n         * Given a collection of events, returns a single event which emits\n         * whenever any of the provided events emit.\n         */\n        function any(...events) {\n            return (listener, thisArgs = null, disposables) => lifecycle_1.combinedDisposable(events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n        }\n        Event.any = any;\n        /**\n         * Given an event and a `merge` function, returns another event which maps each element\n         * and the cummulative result throught the `merge` function. Similar to `map`, but with memory.\n         */\n        function reduce(event, merge, initial) {\n            let output = initial;\n            return map(event, e => {\n                output = merge(output, e);\n                return output;\n            });\n        }\n        Event.reduce = reduce;\n        /**\n         * Given a chain of event processing functions (filter, map, etc), each\n         * function will be invoked per event & per listener. Snapshotting an event\n         * chain allows each function to be invoked just once per event.\n         */\n        function snapshot(event) {\n            let listener;\n            const emitter = new Emitter({\n                onFirstListenerAdd() {\n                    listener = event(emitter.fire, emitter);\n                },\n                onLastListenerRemove() {\n                    listener.dispose();\n                }\n            });\n            return emitter.event;\n        }\n        Event.snapshot = snapshot;\n        function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold) {\n            let subscription;\n            let output = undefined;\n            let handle = undefined;\n            let numDebouncedCalls = 0;\n            const emitter = new Emitter({\n                leakWarningThreshold,\n                onFirstListenerAdd() {\n                    subscription = event(cur => {\n                        numDebouncedCalls++;\n                        output = merge(output, cur);\n                        if (leading && !handle) {\n                            emitter.fire(output);\n                        }\n                        clearTimeout(handle);\n                        handle = setTimeout(() => {\n                            const _output = output;\n                            output = undefined;\n                            handle = undefined;\n                            if (!leading || numDebouncedCalls > 1) {\n                                emitter.fire(_output);\n                            }\n                            numDebouncedCalls = 0;\n                        }, delay);\n                    });\n                },\n                onLastListenerRemove() {\n                    subscription.dispose();\n                }\n            });\n            return emitter.event;\n        }\n        Event.debounce = debounce;\n        /**\n         * Given an event, it returns another event which fires only once and as soon as\n         * the input event emits. The event data is the number of millis it took for the\n         * event to fire.\n         */\n        function stopwatch(event) {\n            const start = new Date().getTime();\n            return map(once(event), _ => new Date().getTime() - start);\n        }\n        Event.stopwatch = stopwatch;\n        /**\n         * Given an event, it returns another event which fires only when the event\n         * element changes.\n         */\n        function latch(event) {\n            let firstCall = true;\n            let cache;\n            return filter(event, value => {\n                const shouldEmit = firstCall || value !== cache;\n                firstCall = false;\n                cache = value;\n                return shouldEmit;\n            });\n        }\n        Event.latch = latch;\n        /**\n         * Buffers the provided event until a first listener comes\n         * along, at which point fire all the events at once and\n         * pipe the event from then on.\n         *\n         * ```typescript\n         * const emitter = new Emitter<number>();\n         * const event = emitter.event;\n         * const bufferedEvent = buffer(event);\n         *\n         * emitter.fire(1);\n         * emitter.fire(2);\n         * emitter.fire(3);\n         * // nothing...\n         *\n         * const listener = bufferedEvent(num => console.log(num));\n         * // 1, 2, 3\n         *\n         * emitter.fire(4);\n         * // 4\n         * ```\n         */\n        function buffer(event, nextTick = false, _buffer = []) {\n            let buffer = _buffer.slice();\n            let listener = event(e => {\n                if (buffer) {\n                    buffer.push(e);\n                }\n                else {\n                    emitter.fire(e);\n                }\n            });\n            const flush = () => {\n                if (buffer) {\n                    buffer.forEach(e => emitter.fire(e));\n                }\n                buffer = null;\n            };\n            const emitter = new Emitter({\n                onFirstListenerAdd() {\n                    if (!listener) {\n                        listener = event(e => emitter.fire(e));\n                    }\n                },\n                onFirstListenerDidAdd() {\n                    if (buffer) {\n                        if (nextTick) {\n                            setTimeout(flush);\n                        }\n                        else {\n                            flush();\n                        }\n                    }\n                },\n                onLastListenerRemove() {\n                    if (listener) {\n                        listener.dispose();\n                    }\n                    listener = null;\n                }\n            });\n            return emitter.event;\n        }\n        Event.buffer = buffer;\n        /**\n         * Similar to `buffer` but it buffers indefinitely and repeats\n         * the buffered events to every new listener.\n         */\n        function echo(event, nextTick = false, buffer = []) {\n            buffer = buffer.slice();\n            event(e => {\n                buffer.push(e);\n                emitter.fire(e);\n            });\n            const flush = (listener, thisArgs) => buffer.forEach(e => listener.call(thisArgs, e));\n            const emitter = new Emitter({\n                onListenerDidAdd(emitter, listener, thisArgs) {\n                    if (nextTick) {\n                        setTimeout(() => flush(listener, thisArgs));\n                    }\n                    else {\n                        flush(listener, thisArgs);\n                    }\n                }\n            });\n            return emitter.event;\n        }\n        Event.echo = echo;\n        class ChainableEvent {\n            constructor(event) {\n                this.event = event;\n            }\n            map(fn) {\n                return new ChainableEvent(map(this.event, fn));\n            }\n            forEach(fn) {\n                return new ChainableEvent(forEach(this.event, fn));\n            }\n            filter(fn) {\n                return new ChainableEvent(filter(this.event, fn));\n            }\n            reduce(merge, initial) {\n                return new ChainableEvent(reduce(this.event, merge, initial));\n            }\n            latch() {\n                return new ChainableEvent(latch(this.event));\n            }\n            on(listener, thisArgs, disposables) {\n                return this.event(listener, thisArgs, disposables);\n            }\n            once(listener, thisArgs, disposables) {\n                return once(this.event)(listener, thisArgs, disposables);\n            }\n        }\n        function chain(event) {\n            return new ChainableEvent(event);\n        }\n        Event.chain = chain;\n        function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n            const fn = (...args) => result.fire(map(...args));\n            const onFirstListenerAdd = () => emitter.on(eventName, fn);\n            const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n            const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\n            return result.event;\n        }\n        Event.fromNodeEventEmitter = fromNodeEventEmitter;\n        function fromPromise(promise) {\n            const emitter = new Emitter();\n            let shouldEmit = false;\n            promise\n                .then(undefined, () => null)\n                .then(() => {\n                if (!shouldEmit) {\n                    setTimeout(() => emitter.fire(undefined), 0);\n                }\n                else {\n                    emitter.fire(undefined);\n                }\n            });\n            shouldEmit = true;\n            return emitter.event;\n        }\n        Event.fromPromise = fromPromise;\n        function toPromise(event) {\n            return new Promise(c => once(event)(c));\n        }\n        Event.toPromise = toPromise;\n    })(Event = exports.Event || (exports.Event = {}));\n    let _globalLeakWarningThreshold = -1;\n    function setGlobalLeakWarningThreshold(n) {\n        const oldValue = _globalLeakWarningThreshold;\n        _globalLeakWarningThreshold = n;\n        return {\n            dispose() {\n                _globalLeakWarningThreshold = oldValue;\n            }\n        };\n    }\n    exports.setGlobalLeakWarningThreshold = setGlobalLeakWarningThreshold;\n    class LeakageMonitor {\n        constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {\n            this.customThreshold = customThreshold;\n            this.name = name;\n            this._warnCountdown = 0;\n        }\n        dispose() {\n            if (this._stacks) {\n                this._stacks.clear();\n            }\n        }\n        check(listenerCount) {\n            let threshold = _globalLeakWarningThreshold;\n            if (typeof this.customThreshold === 'number') {\n                threshold = this.customThreshold;\n            }\n            if (threshold <= 0 || listenerCount < threshold) {\n                return undefined;\n            }\n            if (!this._stacks) {\n                this._stacks = new Map();\n            }\n            const stack = new Error().stack.split('\\n').slice(3).join('\\n');\n            const count = (this._stacks.get(stack) || 0);\n            this._stacks.set(stack, count + 1);\n            this._warnCountdown -= 1;\n            if (this._warnCountdown <= 0) {\n                // only warn on first exceed and then every time the limit\n                // is exceeded by 50% again\n                this._warnCountdown = threshold * 0.5;\n                // find most frequent listener and print warning\n                let topStack;\n                let topCount = 0;\n                this._stacks.forEach((count, stack) => {\n                    if (!topStack || topCount < count) {\n                        topStack = stack;\n                        topCount = count;\n                    }\n                });\n                console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n                console.warn(topStack);\n            }\n            return () => {\n                const count = (this._stacks.get(stack) || 0);\n                this._stacks.set(stack, count - 1);\n            };\n        }\n    }\n    /**\n     * The Emitter can be used to expose an Event to the public\n     * to fire it from the insides.\n     * Sample:\n        class Document {\n    \n            private _onDidChange = new Emitter<(value:string)=>any>();\n    \n            public onDidChange = this._onDidChange.event;\n    \n            // getter-style\n            // get onDidChange(): Event<(value:string)=>any> {\n            // \treturn this._onDidChange.event;\n            // }\n    \n            private _doIt() {\n                //...\n                this._onDidChange.fire(value);\n            }\n        }\n     */\n    class Emitter {\n        constructor(options) {\n            this._disposed = false;\n            this._options = options;\n            this._leakageMon = _globalLeakWarningThreshold > 0\n                ? new LeakageMonitor(this._options && this._options.leakWarningThreshold)\n                : undefined;\n        }\n        /**\n         * For the public to allow to subscribe\n         * to events from this Emitter\n         */\n        get event() {\n            if (!this._event) {\n                this._event = (listener, thisArgs, disposables) => {\n                    if (!this._listeners) {\n                        this._listeners = new linkedList_1.LinkedList();\n                    }\n                    const firstListener = this._listeners.isEmpty();\n                    if (firstListener && this._options && this._options.onFirstListenerAdd) {\n                        this._options.onFirstListenerAdd(this);\n                    }\n                    const remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n                    if (firstListener && this._options && this._options.onFirstListenerDidAdd) {\n                        this._options.onFirstListenerDidAdd(this);\n                    }\n                    if (this._options && this._options.onListenerDidAdd) {\n                        this._options.onListenerDidAdd(this, listener, thisArgs);\n                    }\n                    // check and record this emitter for potential leakage\n                    let removeMonitor;\n                    if (this._leakageMon) {\n                        removeMonitor = this._leakageMon.check(this._listeners.size);\n                    }\n                    let result;\n                    result = {\n                        dispose: () => {\n                            if (removeMonitor) {\n                                removeMonitor();\n                            }\n                            result.dispose = Emitter._noop;\n                            if (!this._disposed) {\n                                remove();\n                                if (this._options && this._options.onLastListenerRemove) {\n                                    const hasListeners = (this._listeners && !this._listeners.isEmpty());\n                                    if (!hasListeners) {\n                                        this._options.onLastListenerRemove(this);\n                                    }\n                                }\n                            }\n                        }\n                    };\n                    if (Array.isArray(disposables)) {\n                        disposables.push(result);\n                    }\n                    return result;\n                };\n            }\n            return this._event;\n        }\n        /**\n         * To be kept private to fire an event to\n         * subscribers\n         */\n        fire(event) {\n            if (this._listeners) {\n                // put all [listener,event]-pairs into delivery queue\n                // then emit all event. an inner/nested event might be\n                // the driver of this\n                if (!this._deliveryQueue) {\n                    this._deliveryQueue = [];\n                }\n                for (let iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {\n                    this._deliveryQueue.push([e.value, event]);\n                }\n                while (this._deliveryQueue.length > 0) {\n                    const [listener, event] = this._deliveryQueue.shift();\n                    try {\n                        if (typeof listener === 'function') {\n                            listener.call(undefined, event);\n                        }\n                        else {\n                            listener[0].call(listener[1], event);\n                        }\n                    }\n                    catch (e) {\n                        errors_1.onUnexpectedError(e);\n                    }\n                }\n            }\n        }\n        dispose() {\n            if (this._listeners) {\n                this._listeners = undefined;\n            }\n            if (this._deliveryQueue) {\n                this._deliveryQueue.length = 0;\n            }\n            if (this._leakageMon) {\n                this._leakageMon.dispose();\n            }\n            this._disposed = true;\n        }\n    }\n    Emitter._noop = function () { };\n    exports.Emitter = Emitter;\n    class AsyncEmitter extends Emitter {\n        fireAsync(eventFn) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!this._listeners) {\n                    return;\n                }\n                // put all [listener,event]-pairs into delivery queue\n                // then emit all event. an inner/nested event might be\n                // the driver of this\n                if (!this._asyncDeliveryQueue) {\n                    this._asyncDeliveryQueue = [];\n                }\n                for (let iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {\n                    const thenables = [];\n                    this._asyncDeliveryQueue.push([e.value, eventFn(thenables, typeof e.value === 'function' ? e.value : e.value[0]), thenables]);\n                }\n                while (this._asyncDeliveryQueue.length > 0) {\n                    const [listener, event, thenables] = this._asyncDeliveryQueue.shift();\n                    try {\n                        if (typeof listener === 'function') {\n                            listener.call(undefined, event);\n                        }\n                        else {\n                            listener[0].call(listener[1], event);\n                        }\n                    }\n                    catch (e) {\n                        errors_1.onUnexpectedError(e);\n                        continue;\n                    }\n                    // freeze thenables-collection to enforce sync-calls to\n                    // wait until and then wait for all thenables to resolve\n                    Object.freeze(thenables);\n                    yield Promise.all(thenables);\n                }\n            });\n        }\n    }\n    exports.AsyncEmitter = AsyncEmitter;\n    class EventMultiplexer {\n        constructor() {\n            this.hasListeners = false;\n            this.events = [];\n            this.emitter = new Emitter({\n                onFirstListenerAdd: () => this.onFirstListenerAdd(),\n                onLastListenerRemove: () => this.onLastListenerRemove()\n            });\n        }\n        get event() {\n            return this.emitter.event;\n        }\n        add(event) {\n            const e = { event: event, listener: null };\n            this.events.push(e);\n            if (this.hasListeners) {\n                this.hook(e);\n            }\n            const dispose = () => {\n                if (this.hasListeners) {\n                    this.unhook(e);\n                }\n                const idx = this.events.indexOf(e);\n                this.events.splice(idx, 1);\n            };\n            return lifecycle_1.toDisposable(functional_1.once(dispose));\n        }\n        onFirstListenerAdd() {\n            this.hasListeners = true;\n            this.events.forEach(e => this.hook(e));\n        }\n        onLastListenerRemove() {\n            this.hasListeners = false;\n            this.events.forEach(e => this.unhook(e));\n        }\n        hook(e) {\n            e.listener = e.event(r => this.emitter.fire(r));\n        }\n        unhook(e) {\n            if (e.listener) {\n                e.listener.dispose();\n            }\n            e.listener = null;\n        }\n        dispose() {\n            this.emitter.dispose();\n        }\n    }\n    exports.EventMultiplexer = EventMultiplexer;\n    /**\n     * The EventBufferer is useful in situations in which you want\n     * to delay firing your events during some code.\n     * You can wrap that code and be sure that the event will not\n     * be fired during that wrap.\n     *\n     * ```\n     * const emitter: Emitter;\n     * const delayer = new EventDelayer();\n     * const delayedEvent = delayer.wrapEvent(emitter.event);\n     *\n     * delayedEvent(console.log);\n     *\n     * delayer.bufferEvents(() => {\n     *   emitter.fire(); // event will not be fired yet\n     * });\n     *\n     * // event will only be fired at this point\n     * ```\n     */\n    class EventBufferer {\n        constructor() {\n            this.buffers = [];\n        }\n        wrapEvent(event) {\n            return (listener, thisArgs, disposables) => {\n                return event(i => {\n                    const buffer = this.buffers[this.buffers.length - 1];\n                    if (buffer) {\n                        buffer.push(() => listener.call(thisArgs, i));\n                    }\n                    else {\n                        listener.call(thisArgs, i);\n                    }\n                }, undefined, disposables);\n            };\n        }\n        bufferEvents(fn) {\n            const buffer = [];\n            this.buffers.push(buffer);\n            const r = fn();\n            this.buffers.pop();\n            buffer.forEach(flush => flush());\n            return r;\n        }\n    }\n    exports.EventBufferer = EventBufferer;\n    /**\n     * A Relay is an event forwarder which functions as a replugabble event pipe.\n     * Once created, you can connect an input event to it and it will simply forward\n     * events from that input event through its own `event` property. The `input`\n     * can be changed at any point in time.\n     */\n    class Relay {\n        constructor() {\n            this.listening = false;\n            this.inputEvent = Event.None;\n            this.inputEventListener = lifecycle_1.Disposable.None;\n            this.emitter = new Emitter({\n                onFirstListenerDidAdd: () => {\n                    this.listening = true;\n                    this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n                },\n                onLastListenerRemove: () => {\n                    this.listening = false;\n                    this.inputEventListener.dispose();\n                }\n            });\n            this.event = this.emitter.event;\n        }\n        set input(event) {\n            this.inputEvent = event;\n            if (this.listening) {\n                this.inputEventListener.dispose();\n                this.inputEventListener = event(this.emitter.fire, this.emitter);\n            }\n        }\n        dispose() {\n            this.inputEventListener.dispose();\n            this.emitter.dispose();\n        }\n    }\n    exports.Relay = Relay;\n});\n",null]}