{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/timer/electron-browser/timerService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/timer/electron-browser/timerService.ts","mtime":1555846338048},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/platform/instantiation/common/instantiation\", \"vs/base/node/id\", \"vs/base/common/performance\", \"os\", \"vs/platform/windows/common/windows\", \"vs/platform/workspace/common/workspace\", \"vs/workbench/services/extensions/common/extensions\", \"vs/platform/instantiation/common/extensions\", \"vs/base/common/arrays\", \"vs/platform/update/common/update\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/workbench/services/viewlet/browser/viewlet\", \"vs/workbench/services/panel/common/panelService\", \"vs/workbench/services/editor/common/editorService\", \"vs/platform/accessibility/common/accessibility\"], function (require, exports, instantiation_1, id_1, perf, os, windows_1, workspace_1, extensions_1, extensions_2, arrays_1, update_1, lifecycle_1, viewlet_1, panelService_1, editorService_1, accessibility_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let TimerService = class TimerService {\n        constructor(_windowsService, _windowService, _lifecycleService, _contextService, _extensionService, _updateService, _viewletService, _panelService, _editorService, _accessibilityService) {\n            this._windowsService = _windowsService;\n            this._windowService = _windowService;\n            this._lifecycleService = _lifecycleService;\n            this._contextService = _contextService;\n            this._extensionService = _extensionService;\n            this._updateService = _updateService;\n            this._viewletService = _viewletService;\n            this._panelService = _panelService;\n            this._editorService = _editorService;\n            this._accessibilityService = _accessibilityService;\n        }\n        get startupMetrics() {\n            if (!this._startupMetrics) {\n                this._startupMetrics = Promise\n                    .resolve(this._extensionService.whenInstalledExtensionsRegistered())\n                    .then(() => this._computeStartupMetrics());\n            }\n            return this._startupMetrics;\n        }\n        _computeStartupMetrics() {\n            return __awaiter(this, void 0, void 0, function* () {\n                const now = Date.now();\n                const initialStartup = !!this._windowService.getConfiguration().isInitialStartup;\n                const startMark = initialStartup ? 'main:started' : 'main:loadWindow';\n                let totalmem;\n                let freemem;\n                let cpus;\n                let platform;\n                let release;\n                let arch;\n                let loadavg;\n                let meminfo;\n                let isVMLikelyhood;\n                try {\n                    totalmem = os.totalmem();\n                    freemem = os.freemem();\n                    platform = os.platform();\n                    release = os.release();\n                    arch = os.arch();\n                    loadavg = os.loadavg();\n                    meminfo = process.getProcessMemoryInfo();\n                    isVMLikelyhood = Math.round((id_1.virtualMachineHint.value() * 100));\n                    const rawCpus = os.cpus();\n                    if (rawCpus && rawCpus.length > 0) {\n                        cpus = { count: rawCpus.length, speed: rawCpus[0].speed, model: rawCpus[0].model };\n                    }\n                }\n                catch (error) {\n                    // ignore, be on the safe side with these hardware method calls\n                }\n                const activeViewlet = this._viewletService.getActiveViewlet();\n                const activePanel = this._panelService.getActivePanel();\n                return {\n                    version: 2,\n                    ellapsed: perf.getDuration(startMark, 'didStartWorkbench'),\n                    // reflections\n                    isLatestVersion: Boolean(yield this._updateService.isLatestVersion()),\n                    didUseCachedData: didUseCachedData(),\n                    windowKind: this._lifecycleService.startupKind,\n                    windowCount: yield this._windowsService.getWindowCount(),\n                    viewletId: activeViewlet ? activeViewlet.getId() : undefined,\n                    editorIds: this._editorService.visibleEditors.map(input => input.getTypeId()),\n                    panelId: activePanel ? activePanel.getId() : undefined,\n                    // timers\n                    timers: {\n                        ellapsedAppReady: initialStartup ? perf.getDuration('main:started', 'main:appReady') : undefined,\n                        ellapsedNlsGeneration: initialStartup ? perf.getDuration('nlsGeneration:start', 'nlsGeneration:end') : undefined,\n                        ellapsedWindowLoad: initialStartup ? perf.getDuration('main:appReady', 'main:loadWindow') : undefined,\n                        ellapsedWindowLoadToRequire: perf.getDuration('main:loadWindow', 'willLoadWorkbenchMain'),\n                        ellapsedRequire: perf.getDuration('willLoadWorkbenchMain', 'didLoadWorkbenchMain'),\n                        ellapsedWorkspaceStorageInit: perf.getDuration('willInitWorkspaceStorage', 'didInitWorkspaceStorage'),\n                        ellapsedWorkspaceServiceInit: perf.getDuration('willInitWorkspaceService', 'didInitWorkspaceService'),\n                        ellapsedExtensions: perf.getDuration('willLoadExtensions', 'didLoadExtensions'),\n                        ellapsedEditorRestore: perf.getDuration('willRestoreEditors', 'didRestoreEditors'),\n                        ellapsedViewletRestore: perf.getDuration('willRestoreViewlet', 'didRestoreViewlet'),\n                        ellapsedPanelRestore: perf.getDuration('willRestorePanel', 'didRestorePanel'),\n                        ellapsedWorkbench: perf.getDuration('willStartWorkbench', 'didStartWorkbench'),\n                        ellapsedExtensionsReady: perf.getDuration(startMark, 'didLoadExtensions'),\n                        ellapsedTimersToTimersComputed: Date.now() - now,\n                    },\n                    // system info\n                    platform,\n                    release,\n                    arch,\n                    totalmem,\n                    freemem,\n                    meminfo,\n                    cpus,\n                    loadavg,\n                    initialStartup,\n                    isVMLikelyhood,\n                    hasAccessibilitySupport: this._accessibilityService.getAccessibilitySupport() === accessibility_1.AccessibilitySupport.Enabled,\n                    emptyWorkbench: this._contextService.getWorkbenchState() === workspace_1.WorkbenchState.EMPTY\n                };\n            });\n        }\n    };\n    TimerService = __decorate([\n        __param(0, windows_1.IWindowsService),\n        __param(1, windows_1.IWindowService),\n        __param(2, lifecycle_1.ILifecycleService),\n        __param(3, workspace_1.IWorkspaceContextService),\n        __param(4, extensions_1.IExtensionService),\n        __param(5, update_1.IUpdateService),\n        __param(6, viewlet_1.IViewletService),\n        __param(7, panelService_1.IPanelService),\n        __param(8, editorService_1.IEditorService),\n        __param(9, accessibility_1.IAccessibilityService)\n    ], TimerService);\n    exports.ITimerService = instantiation_1.createDecorator('timerService');\n    extensions_2.registerSingleton(exports.ITimerService, TimerService, true);\n    //#region cached data logic\n    function didUseCachedData() {\n        return false;\n        // We surely don't use cached data when we don't tell the loader to do so\n        if (!Boolean(global.require.getConfig().nodeCachedData)) {\n            return false;\n        }\n        // whenever cached data is produced or rejected a onNodeCachedData-callback is invoked. That callback\n        // stores data in the `MonacoEnvironment.onNodeCachedData` global. See:\n        // https://github.com/Microsoft/vscode/blob/efe424dfe76a492eab032343e2fa4cfe639939f0/src/vs/workbench/electron-browser/bootstrap/index.js#L299\n        if (arrays_1.isNonEmptyArray(MonacoEnvironment.onNodeCachedData)) {\n            return false;\n        }\n        return true;\n    }\n    exports.didUseCachedData = didUseCachedData;\n});\n//#endregion\n",null]}