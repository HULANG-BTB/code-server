{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/common/taskConfiguration.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/common/taskConfiguration.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/objects\", \"vs/base/common/platform\", \"vs/base/common/types\", \"vs/base/common/uuid\", \"vs/workbench/contrib/tasks/common/problemMatcher\", \"./tasks\", \"./taskDefinitionRegistry\"], function (require, exports, nls, Objects, platform_1, Types, UUID, problemMatcher_1, Tasks, taskDefinitionRegistry_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var ShellQuoting;\n    (function (ShellQuoting) {\n        /**\n         * Default is character escaping.\n         */\n        ShellQuoting[ShellQuoting[\"escape\"] = 1] = \"escape\";\n        /**\n         * Default is strong quoting\n         */\n        ShellQuoting[ShellQuoting[\"strong\"] = 2] = \"strong\";\n        /**\n         * Default is weak quoting.\n         */\n        ShellQuoting[ShellQuoting[\"weak\"] = 3] = \"weak\";\n    })(ShellQuoting = exports.ShellQuoting || (exports.ShellQuoting = {}));\n    var TaskIdentifier;\n    (function (TaskIdentifier) {\n        function is(value) {\n            let candidate = value;\n            return candidate !== undefined && Types.isString(value.type);\n        }\n        TaskIdentifier.is = is;\n    })(TaskIdentifier = exports.TaskIdentifier || (exports.TaskIdentifier = {}));\n    var CommandString;\n    (function (CommandString) {\n        function value(value) {\n            if (Types.isString(value)) {\n                return value;\n            }\n            else if (Types.isStringArray(value)) {\n                return value.join(' ');\n            }\n            else {\n                if (Types.isString(value.value)) {\n                    return value.value;\n                }\n                else {\n                    return value.value.join(' ');\n                }\n            }\n        }\n        CommandString.value = value;\n    })(CommandString = exports.CommandString || (exports.CommandString = {}));\n    var ProblemMatcherKind;\n    (function (ProblemMatcherKind) {\n        ProblemMatcherKind[ProblemMatcherKind[\"Unknown\"] = 0] = \"Unknown\";\n        ProblemMatcherKind[ProblemMatcherKind[\"String\"] = 1] = \"String\";\n        ProblemMatcherKind[ProblemMatcherKind[\"ProblemMatcher\"] = 2] = \"ProblemMatcher\";\n        ProblemMatcherKind[ProblemMatcherKind[\"Array\"] = 3] = \"Array\";\n    })(ProblemMatcherKind || (ProblemMatcherKind = {}));\n    const EMPTY_ARRAY = [];\n    Object.freeze(EMPTY_ARRAY);\n    function assignProperty(target, source, key) {\n        const sourceAtKey = source[key];\n        if (sourceAtKey !== undefined) {\n            target[key] = sourceAtKey;\n        }\n    }\n    function fillProperty(target, source, key) {\n        const sourceAtKey = source[key];\n        if (target[key] === undefined && sourceAtKey !== undefined) {\n            target[key] = sourceAtKey;\n        }\n    }\n    function _isEmpty(value, properties) {\n        if (value === undefined || value === null || properties === undefined) {\n            return true;\n        }\n        for (let meta of properties) {\n            let property = value[meta.property];\n            if (property !== undefined && property !== null) {\n                if (meta.type !== undefined && !meta.type.isEmpty(property)) {\n                    return false;\n                }\n                else if (!Array.isArray(property) || property.length > 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    function _assignProperties(target, source, properties) {\n        if (_isEmpty(source, properties)) {\n            return target;\n        }\n        if (_isEmpty(target, properties)) {\n            return source;\n        }\n        for (let meta of properties) {\n            let property = meta.property;\n            let value;\n            if (meta.type !== undefined) {\n                value = meta.type.assignProperties(target[property], source[property]);\n            }\n            else {\n                value = source[property];\n            }\n            if (value !== undefined && value !== null) {\n                target[property] = value;\n            }\n        }\n        return target;\n    }\n    function _fillProperties(target, source, properties) {\n        if (_isEmpty(source, properties)) {\n            return target;\n        }\n        if (_isEmpty(target, properties)) {\n            return source;\n        }\n        for (let meta of properties) {\n            let property = meta.property;\n            let value;\n            if (meta.type) {\n                value = meta.type.fillProperties(target[property], source[property]);\n            }\n            else if (target[property] === undefined) {\n                value = source[property];\n            }\n            if (value !== undefined && value !== null) {\n                target[property] = value;\n            }\n        }\n        return target;\n    }\n    function _fillDefaults(target, defaults, properties, context) {\n        if (target && Object.isFrozen(target)) {\n            return target;\n        }\n        if (target === undefined || target === null) {\n            if (defaults !== undefined && defaults !== null) {\n                return Objects.deepClone(defaults);\n            }\n            else {\n                return undefined;\n            }\n        }\n        for (let meta of properties) {\n            let property = meta.property;\n            if (target[property] !== undefined) {\n                continue;\n            }\n            let value;\n            if (meta.type) {\n                value = meta.type.fillDefaults(target[property], context);\n            }\n            else {\n                value = defaults[property];\n            }\n            if (value !== undefined && value !== null) {\n                target[property] = value;\n            }\n        }\n        return target;\n    }\n    function _freeze(target, properties) {\n        if (target === undefined || target === null) {\n            return undefined;\n        }\n        if (Object.isFrozen(target)) {\n            return target;\n        }\n        for (let meta of properties) {\n            if (meta.type) {\n                let value = target[meta.property];\n                if (value) {\n                    meta.type.freeze(value);\n                }\n            }\n        }\n        Object.freeze(target);\n        return target;\n    }\n    var RunOnOptions;\n    (function (RunOnOptions) {\n        function fromString(value) {\n            if (!value) {\n                return Tasks.RunOnOptions.default;\n            }\n            switch (value.toLowerCase()) {\n                case 'folderopen':\n                    return Tasks.RunOnOptions.folderOpen;\n                case 'default':\n                default:\n                    return Tasks.RunOnOptions.default;\n            }\n        }\n        RunOnOptions.fromString = fromString;\n    })(RunOnOptions = exports.RunOnOptions || (exports.RunOnOptions = {}));\n    var RunOptions;\n    (function (RunOptions) {\n        function fromConfiguration(value) {\n            return {\n                reevaluateOnRerun: value ? value.reevaluateOnRerun : true,\n                runOn: value ? RunOnOptions.fromString(value.runOn) : Tasks.RunOnOptions.default\n            };\n        }\n        RunOptions.fromConfiguration = fromConfiguration;\n    })(RunOptions = exports.RunOptions || (exports.RunOptions = {}));\n    class ParseContext {\n    }\n    var ShellConfiguration;\n    (function (ShellConfiguration) {\n        const properties = [{ property: 'executable' }, { property: 'args' }, { property: 'quoting' }];\n        function is(value) {\n            let candidate = value;\n            return candidate && (Types.isString(candidate.executable) || Types.isStringArray(candidate.args));\n        }\n        ShellConfiguration.is = is;\n        function from(config, context) {\n            if (!is(config)) {\n                return undefined;\n            }\n            let result = {};\n            if (config.executable !== undefined) {\n                result.executable = config.executable;\n            }\n            if (config.args !== undefined) {\n                result.args = config.args.slice();\n            }\n            if (config.quoting !== undefined) {\n                result.quoting = Objects.deepClone(config.quoting);\n            }\n            return result;\n        }\n        ShellConfiguration.from = from;\n        function isEmpty(value) {\n            return _isEmpty(value, properties);\n        }\n        ShellConfiguration.isEmpty = isEmpty;\n        function assignProperties(target, source) {\n            return _assignProperties(target, source, properties);\n        }\n        ShellConfiguration.assignProperties = assignProperties;\n        function fillProperties(target, source) {\n            return _fillProperties(target, source, properties);\n        }\n        ShellConfiguration.fillProperties = fillProperties;\n        function fillDefaults(value, context) {\n            return value;\n        }\n        ShellConfiguration.fillDefaults = fillDefaults;\n        function freeze(value) {\n            if (!value) {\n                return undefined;\n            }\n            return Object.freeze(value);\n        }\n        ShellConfiguration.freeze = freeze;\n    })(ShellConfiguration || (ShellConfiguration = {}));\n    var CommandOptions;\n    (function (CommandOptions) {\n        const properties = [{ property: 'cwd' }, { property: 'env' }, { property: 'shell', type: ShellConfiguration }];\n        const defaults = { cwd: '${workspaceFolder}' };\n        function from(options, context) {\n            let result = {};\n            if (options.cwd !== undefined) {\n                if (Types.isString(options.cwd)) {\n                    result.cwd = options.cwd;\n                }\n                else {\n                    context.taskLoadIssues.push(nls.localize('ConfigurationParser.invalidCWD', 'Warning: options.cwd must be of type string. Ignoring value {0}\\n', options.cwd));\n                }\n            }\n            if (options.env !== undefined) {\n                result.env = Objects.deepClone(options.env);\n            }\n            result.shell = ShellConfiguration.from(options.shell, context);\n            return isEmpty(result) ? undefined : result;\n        }\n        CommandOptions.from = from;\n        function isEmpty(value) {\n            return _isEmpty(value, properties);\n        }\n        CommandOptions.isEmpty = isEmpty;\n        function assignProperties(target, source) {\n            if ((source === undefined) || isEmpty(source)) {\n                return target;\n            }\n            if ((target === undefined) || isEmpty(target)) {\n                return source;\n            }\n            assignProperty(target, source, 'cwd');\n            if (target.env === undefined) {\n                target.env = source.env;\n            }\n            else if (source.env !== undefined) {\n                let env = Object.create(null);\n                if (target.env !== undefined) {\n                    Object.keys(target.env).forEach(key => env[key] = target.env[key]);\n                }\n                if (source.env !== undefined) {\n                    Object.keys(source.env).forEach(key => env[key] = source.env[key]);\n                }\n                target.env = env;\n            }\n            target.shell = ShellConfiguration.assignProperties(target.shell, source.shell);\n            return target;\n        }\n        CommandOptions.assignProperties = assignProperties;\n        function fillProperties(target, source) {\n            return _fillProperties(target, source, properties);\n        }\n        CommandOptions.fillProperties = fillProperties;\n        function fillDefaults(value, context) {\n            return _fillDefaults(value, defaults, properties, context);\n        }\n        CommandOptions.fillDefaults = fillDefaults;\n        function freeze(value) {\n            return _freeze(value, properties);\n        }\n        CommandOptions.freeze = freeze;\n    })(CommandOptions || (CommandOptions = {}));\n    var CommandConfiguration;\n    (function (CommandConfiguration) {\n        let PresentationOptions;\n        (function (PresentationOptions) {\n            const properties = [{ property: 'echo' }, { property: 'reveal' }, { property: 'focus' }, { property: 'panel' }, { property: 'showReuseMessage' }, { property: 'clear' }, { property: 'group' }];\n            function from(config, context) {\n                let echo;\n                let reveal;\n                let focus;\n                let panel;\n                let showReuseMessage;\n                let clear;\n                let group;\n                let hasProps = false;\n                if (Types.isBoolean(config.echoCommand)) {\n                    echo = config.echoCommand;\n                    hasProps = true;\n                }\n                if (Types.isString(config.showOutput)) {\n                    reveal = Tasks.RevealKind.fromString(config.showOutput);\n                    hasProps = true;\n                }\n                let presentation = config.presentation || config.terminal;\n                if (presentation) {\n                    if (Types.isBoolean(presentation.echo)) {\n                        echo = presentation.echo;\n                    }\n                    if (Types.isString(presentation.reveal)) {\n                        reveal = Tasks.RevealKind.fromString(presentation.reveal);\n                    }\n                    if (Types.isBoolean(presentation.focus)) {\n                        focus = presentation.focus;\n                    }\n                    if (Types.isString(presentation.panel)) {\n                        panel = Tasks.PanelKind.fromString(presentation.panel);\n                    }\n                    if (Types.isBoolean(presentation.showReuseMessage)) {\n                        showReuseMessage = presentation.showReuseMessage;\n                    }\n                    if (Types.isBoolean(presentation.clear)) {\n                        clear = presentation.clear;\n                    }\n                    if (Types.isString(presentation.group)) {\n                        group = presentation.group;\n                    }\n                    hasProps = true;\n                }\n                if (!hasProps) {\n                    return undefined;\n                }\n                return { echo: echo, reveal: reveal, focus: focus, panel: panel, showReuseMessage: showReuseMessage, clear: clear, group };\n            }\n            PresentationOptions.from = from;\n            function assignProperties(target, source) {\n                return _assignProperties(target, source, properties);\n            }\n            PresentationOptions.assignProperties = assignProperties;\n            function fillProperties(target, source) {\n                return _fillProperties(target, source, properties);\n            }\n            PresentationOptions.fillProperties = fillProperties;\n            function fillDefaults(value, context) {\n                let defaultEcho = context.engine === Tasks.ExecutionEngine.Terminal ? true : false;\n                return _fillDefaults(value, { echo: defaultEcho, reveal: Tasks.RevealKind.Always, focus: false, panel: Tasks.PanelKind.Shared, showReuseMessage: true, clear: false }, properties, context);\n            }\n            PresentationOptions.fillDefaults = fillDefaults;\n            function freeze(value) {\n                return _freeze(value, properties);\n            }\n            PresentationOptions.freeze = freeze;\n            function isEmpty(value) {\n                return _isEmpty(value, properties);\n            }\n            PresentationOptions.isEmpty = isEmpty;\n        })(PresentationOptions = CommandConfiguration.PresentationOptions || (CommandConfiguration.PresentationOptions = {}));\n        let ShellString;\n        (function (ShellString) {\n            function from(value) {\n                if (value === undefined || value === null) {\n                    return undefined;\n                }\n                if (Types.isString(value)) {\n                    return value;\n                }\n                else if (Types.isStringArray(value)) {\n                    return value.join(' ');\n                }\n                else {\n                    let quoting = Tasks.ShellQuoting.from(value.quoting);\n                    let result = Types.isString(value.value) ? value.value : Types.isStringArray(value.value) ? value.value.join(' ') : undefined;\n                    if (result) {\n                        return {\n                            value: result,\n                            quoting: quoting\n                        };\n                    }\n                    else {\n                        return undefined;\n                    }\n                }\n            }\n            ShellString.from = from;\n        })(ShellString || (ShellString = {}));\n        const properties = [\n            { property: 'runtime' }, { property: 'name' }, { property: 'options', type: CommandOptions },\n            { property: 'args' }, { property: 'taskSelector' }, { property: 'suppressTaskName' },\n            { property: 'presentation', type: PresentationOptions }\n        ];\n        function from(config, context) {\n            let result = fromBase(config, context);\n            let osConfig = undefined;\n            if (config.windows && context.platform === platform_1.Platform.Windows) {\n                osConfig = fromBase(config.windows, context);\n            }\n            else if (config.osx && context.platform === platform_1.Platform.Mac) {\n                osConfig = fromBase(config.osx, context);\n            }\n            else if (config.linux && context.platform === platform_1.Platform.Linux) {\n                osConfig = fromBase(config.linux, context);\n            }\n            if (osConfig) {\n                result = assignProperties(result, osConfig, context.schemaVersion === Tasks.JsonSchemaVersion.V2_0_0);\n            }\n            return isEmpty(result) ? undefined : result;\n        }\n        CommandConfiguration.from = from;\n        function fromBase(config, context) {\n            let name = ShellString.from(config.command);\n            let runtime;\n            if (Types.isString(config.type)) {\n                if (config.type === 'shell' || config.type === 'process') {\n                    runtime = Tasks.RuntimeType.fromString(config.type);\n                }\n            }\n            let isShellConfiguration = ShellConfiguration.is(config.isShellCommand);\n            if (Types.isBoolean(config.isShellCommand) || isShellConfiguration) {\n                runtime = Tasks.RuntimeType.Shell;\n            }\n            else if (config.isShellCommand !== undefined) {\n                runtime = !!config.isShellCommand ? Tasks.RuntimeType.Shell : Tasks.RuntimeType.Process;\n            }\n            let result = {\n                name: name,\n                runtime: runtime,\n                presentation: PresentationOptions.from(config, context)\n            };\n            if (config.args !== undefined) {\n                result.args = [];\n                for (let arg of config.args) {\n                    let converted = ShellString.from(arg);\n                    if (converted !== undefined) {\n                        result.args.push(converted);\n                    }\n                    else {\n                        context.taskLoadIssues.push(nls.localize('ConfigurationParser.inValidArg', 'Error: command argument must either be a string or a quoted string. Provided value is:\\n{0}', arg ? JSON.stringify(arg, undefined, 4) : 'undefined'));\n                    }\n                }\n            }\n            if (config.options !== undefined) {\n                result.options = CommandOptions.from(config.options, context);\n                if (result.options && result.options.shell === undefined && isShellConfiguration) {\n                    result.options.shell = ShellConfiguration.from(config.isShellCommand, context);\n                    if (context.engine !== Tasks.ExecutionEngine.Terminal) {\n                        context.taskLoadIssues.push(nls.localize('ConfigurationParser.noShell', 'Warning: shell configuration is only supported when executing tasks in the terminal.'));\n                    }\n                }\n            }\n            if (Types.isString(config.taskSelector)) {\n                result.taskSelector = config.taskSelector;\n            }\n            if (Types.isBoolean(config.suppressTaskName)) {\n                result.suppressTaskName = config.suppressTaskName;\n            }\n            return isEmpty(result) ? undefined : result;\n        }\n        function hasCommand(value) {\n            return value && !!value.name;\n        }\n        CommandConfiguration.hasCommand = hasCommand;\n        function isEmpty(value) {\n            return _isEmpty(value, properties);\n        }\n        CommandConfiguration.isEmpty = isEmpty;\n        function assignProperties(target, source, overwriteArgs) {\n            if (isEmpty(source)) {\n                return target;\n            }\n            if (isEmpty(target)) {\n                return source;\n            }\n            assignProperty(target, source, 'name');\n            assignProperty(target, source, 'runtime');\n            assignProperty(target, source, 'taskSelector');\n            assignProperty(target, source, 'suppressTaskName');\n            if (source.args !== undefined) {\n                if (target.args === undefined || overwriteArgs) {\n                    target.args = source.args;\n                }\n                else {\n                    target.args = target.args.concat(source.args);\n                }\n            }\n            target.presentation = PresentationOptions.assignProperties(target.presentation, source.presentation);\n            target.options = CommandOptions.assignProperties(target.options, source.options);\n            return target;\n        }\n        CommandConfiguration.assignProperties = assignProperties;\n        function fillProperties(target, source) {\n            return _fillProperties(target, source, properties);\n        }\n        CommandConfiguration.fillProperties = fillProperties;\n        function fillGlobals(target, source, taskName) {\n            if ((source === undefined) || isEmpty(source)) {\n                return target;\n            }\n            target = target || {\n                name: undefined,\n                runtime: undefined,\n                presentation: undefined\n            };\n            if (target.name === undefined) {\n                fillProperty(target, source, 'name');\n                fillProperty(target, source, 'taskSelector');\n                fillProperty(target, source, 'suppressTaskName');\n                let args = source.args ? source.args.slice() : [];\n                if (!target.suppressTaskName && taskName) {\n                    if (target.taskSelector !== undefined) {\n                        args.push(target.taskSelector + taskName);\n                    }\n                    else {\n                        args.push(taskName);\n                    }\n                }\n                if (target.args) {\n                    args = args.concat(target.args);\n                }\n                target.args = args;\n            }\n            fillProperty(target, source, 'runtime');\n            target.presentation = PresentationOptions.fillProperties(target.presentation, source.presentation);\n            target.options = CommandOptions.fillProperties(target.options, source.options);\n            return target;\n        }\n        CommandConfiguration.fillGlobals = fillGlobals;\n        function fillDefaults(value, context) {\n            if (!value || Object.isFrozen(value)) {\n                return;\n            }\n            if (value.name !== undefined && value.runtime === undefined) {\n                value.runtime = Tasks.RuntimeType.Process;\n            }\n            value.presentation = PresentationOptions.fillDefaults(value.presentation, context);\n            if (!isEmpty(value)) {\n                value.options = CommandOptions.fillDefaults(value.options, context);\n            }\n            if (value.args === undefined) {\n                value.args = EMPTY_ARRAY;\n            }\n            if (value.suppressTaskName === undefined) {\n                value.suppressTaskName = false;\n            }\n        }\n        CommandConfiguration.fillDefaults = fillDefaults;\n        function freeze(value) {\n            return _freeze(value, properties);\n        }\n        CommandConfiguration.freeze = freeze;\n    })(CommandConfiguration || (CommandConfiguration = {}));\n    var ProblemMatcherConverter;\n    (function (ProblemMatcherConverter) {\n        function namedFrom(declares, context) {\n            let result = Object.create(null);\n            if (!Types.isArray(declares)) {\n                return result;\n            }\n            declares.forEach((value) => {\n                let namedProblemMatcher = (new problemMatcher_1.ProblemMatcherParser(context.problemReporter)).parse(value);\n                if (problemMatcher_1.isNamedProblemMatcher(namedProblemMatcher)) {\n                    result[namedProblemMatcher.name] = namedProblemMatcher;\n                }\n                else {\n                    context.problemReporter.error(nls.localize('ConfigurationParser.noName', 'Error: Problem Matcher in declare scope must have a name:\\n{0}\\n', JSON.stringify(value, undefined, 4)));\n                }\n            });\n            return result;\n        }\n        ProblemMatcherConverter.namedFrom = namedFrom;\n        function from(config, context) {\n            let result = [];\n            if (config === undefined) {\n                return result;\n            }\n            let kind = getProblemMatcherKind(config);\n            if (kind === ProblemMatcherKind.Unknown) {\n                context.problemReporter.warn(nls.localize('ConfigurationParser.unknownMatcherKind', 'Warning: the defined problem matcher is unknown. Supported types are string | ProblemMatcher | Array<string | ProblemMatcher>.\\n{0}\\n', JSON.stringify(config, null, 4)));\n                return result;\n            }\n            else if (kind === ProblemMatcherKind.String || kind === ProblemMatcherKind.ProblemMatcher) {\n                let matcher = resolveProblemMatcher(config, context);\n                if (matcher) {\n                    result.push(matcher);\n                }\n            }\n            else if (kind === ProblemMatcherKind.Array) {\n                let problemMatchers = config;\n                problemMatchers.forEach(problemMatcher => {\n                    let matcher = resolveProblemMatcher(problemMatcher, context);\n                    if (matcher) {\n                        result.push(matcher);\n                    }\n                });\n            }\n            return result;\n        }\n        ProblemMatcherConverter.from = from;\n        function getProblemMatcherKind(value) {\n            if (Types.isString(value)) {\n                return ProblemMatcherKind.String;\n            }\n            else if (Types.isArray(value)) {\n                return ProblemMatcherKind.Array;\n            }\n            else if (!Types.isUndefined(value)) {\n                return ProblemMatcherKind.ProblemMatcher;\n            }\n            else {\n                return ProblemMatcherKind.Unknown;\n            }\n        }\n        function resolveProblemMatcher(value, context) {\n            if (Types.isString(value)) {\n                let variableName = value;\n                if (variableName.length > 1 && variableName[0] === '$') {\n                    variableName = variableName.substring(1);\n                    let global = problemMatcher_1.ProblemMatcherRegistry.get(variableName);\n                    if (global) {\n                        return Objects.deepClone(global);\n                    }\n                    let localProblemMatcher = context.namedProblemMatchers[variableName];\n                    if (localProblemMatcher) {\n                        localProblemMatcher = Objects.deepClone(localProblemMatcher);\n                        // remove the name\n                        delete localProblemMatcher.name;\n                        return localProblemMatcher;\n                    }\n                }\n                context.taskLoadIssues.push(nls.localize('ConfigurationParser.invalidVaraibleReference', 'Error: Invalid problemMatcher reference: {0}\\n', value));\n                return undefined;\n            }\n            else {\n                let json = value;\n                return new problemMatcher_1.ProblemMatcherParser(context.problemReporter).parse(json);\n            }\n        }\n    })(ProblemMatcherConverter || (ProblemMatcherConverter = {}));\n    const source = {\n        kind: Tasks.TaskSourceKind.Workspace,\n        label: 'Workspace',\n        config: undefined\n    };\n    var GroupKind;\n    (function (GroupKind) {\n        function from(external) {\n            if (external === undefined) {\n                return undefined;\n            }\n            if (Types.isString(external)) {\n                if (Tasks.TaskGroup.is(external)) {\n                    return [external, Tasks.GroupType.user];\n                }\n                else {\n                    return undefined;\n                }\n            }\n            if (!Types.isString(external.kind) || !Tasks.TaskGroup.is(external.kind)) {\n                return undefined;\n            }\n            let group = external.kind;\n            let isDefault = !!external.isDefault;\n            return [group, isDefault ? Tasks.GroupType.default : Tasks.GroupType.user];\n        }\n        GroupKind.from = from;\n    })(GroupKind || (GroupKind = {}));\n    var TaskDependency;\n    (function (TaskDependency) {\n        function from(external, context) {\n            if (Types.isString(external)) {\n                return { workspaceFolder: context.workspaceFolder, task: external };\n            }\n            else if (TaskIdentifier.is(external)) {\n                return { workspaceFolder: context.workspaceFolder, task: Tasks.TaskDefinition.createTaskIdentifier(external, context.problemReporter) };\n            }\n            else {\n                return undefined;\n            }\n        }\n        TaskDependency.from = from;\n    })(TaskDependency || (TaskDependency = {}));\n    var ConfigurationProperties;\n    (function (ConfigurationProperties) {\n        const properties = [\n            { property: 'name' }, { property: 'identifier' }, { property: 'group' }, { property: 'isBackground' },\n            { property: 'promptOnClose' }, { property: 'dependsOn' },\n            { property: 'presentation', type: CommandConfiguration.PresentationOptions }, { property: 'problemMatchers' }\n        ];\n        function from(external, context, includeCommandOptions) {\n            if (!external) {\n                return undefined;\n            }\n            let result = {};\n            if (Types.isString(external.taskName)) {\n                result.name = external.taskName;\n            }\n            if (Types.isString(external.label) && context.schemaVersion === Tasks.JsonSchemaVersion.V2_0_0) {\n                result.name = external.label;\n            }\n            if (Types.isString(external.identifier)) {\n                result.identifier = external.identifier;\n            }\n            if (external.isBackground !== undefined) {\n                result.isBackground = !!external.isBackground;\n            }\n            if (external.promptOnClose !== undefined) {\n                result.promptOnClose = !!external.promptOnClose;\n            }\n            if (external.group !== undefined) {\n                if (Types.isString(external.group) && Tasks.TaskGroup.is(external.group)) {\n                    result.group = external.group;\n                    result.groupType = Tasks.GroupType.user;\n                }\n                else {\n                    let values = GroupKind.from(external.group);\n                    if (values) {\n                        result.group = values[0];\n                        result.groupType = values[1];\n                    }\n                }\n            }\n            if (external.dependsOn !== undefined) {\n                if (Types.isArray(external.dependsOn)) {\n                    result.dependsOn = external.dependsOn.reduce((dependencies, item) => {\n                        const dependency = TaskDependency.from(item, context);\n                        if (dependency) {\n                            dependencies.push(dependency);\n                        }\n                        return dependencies;\n                    }, []);\n                }\n                else {\n                    const dependsOnValue = TaskDependency.from(external.dependsOn, context);\n                    result.dependsOn = dependsOnValue ? [dependsOnValue] : undefined;\n                }\n            }\n            if (includeCommandOptions && (external.presentation !== undefined || external.terminal !== undefined)) {\n                result.presentation = CommandConfiguration.PresentationOptions.from(external, context);\n            }\n            if (includeCommandOptions && (external.options !== undefined)) {\n                result.options = CommandOptions.from(external.options, context);\n            }\n            if (external.problemMatcher) {\n                result.problemMatchers = ProblemMatcherConverter.from(external.problemMatcher, context);\n            }\n            return isEmpty(result) ? undefined : result;\n        }\n        ConfigurationProperties.from = from;\n        function isEmpty(value) {\n            return _isEmpty(value, properties);\n        }\n        ConfigurationProperties.isEmpty = isEmpty;\n    })(ConfigurationProperties || (ConfigurationProperties = {}));\n    var ConfiguringTask;\n    (function (ConfiguringTask) {\n        const grunt = 'grunt.';\n        const jake = 'jake.';\n        const gulp = 'gulp.';\n        const npm = 'vscode.npm.';\n        const typescript = 'vscode.typescript.';\n        function from(external, context, index) {\n            if (!external) {\n                return undefined;\n            }\n            let type = external.type;\n            let customize = external.customize;\n            if (!type && !customize) {\n                context.problemReporter.error(nls.localize('ConfigurationParser.noTaskType', 'Error: tasks configuration must have a type property. The configuration will be ignored.\\n{0}\\n', JSON.stringify(external, null, 4)));\n                return undefined;\n            }\n            let typeDeclaration = type ? taskDefinitionRegistry_1.TaskDefinitionRegistry.get(type) : undefined;\n            if (!typeDeclaration) {\n                let message = nls.localize('ConfigurationParser.noTypeDefinition', 'Error: there is no registered task type \\'{0}\\'. Did you miss to install an extension that provides a corresponding task provider?', type);\n                context.problemReporter.error(message);\n                return undefined;\n            }\n            let identifier;\n            if (Types.isString(customize)) {\n                if (customize.indexOf(grunt) === 0) {\n                    identifier = { type: 'grunt', task: customize.substring(grunt.length) };\n                }\n                else if (customize.indexOf(jake) === 0) {\n                    identifier = { type: 'jake', task: customize.substring(jake.length) };\n                }\n                else if (customize.indexOf(gulp) === 0) {\n                    identifier = { type: 'gulp', task: customize.substring(gulp.length) };\n                }\n                else if (customize.indexOf(npm) === 0) {\n                    identifier = { type: 'npm', script: customize.substring(npm.length + 4) };\n                }\n                else if (customize.indexOf(typescript) === 0) {\n                    identifier = { type: 'typescript', tsconfig: customize.substring(typescript.length + 6) };\n                }\n            }\n            else {\n                if (Types.isString(external.type)) {\n                    identifier = external;\n                }\n            }\n            if (identifier === undefined) {\n                context.problemReporter.error(nls.localize('ConfigurationParser.missingType', 'Error: the task configuration \\'{0}\\' is missing the required property \\'type\\'. The task configuration will be ignored.', JSON.stringify(external, undefined, 0)));\n                return undefined;\n            }\n            let taskIdentifier = Tasks.TaskDefinition.createTaskIdentifier(identifier, context.problemReporter);\n            if (taskIdentifier === undefined) {\n                context.problemReporter.error(nls.localize('ConfigurationParser.incorrectType', 'Error: the task configuration \\'{0}\\' is using an unknown type. The task configuration will be ignored.', JSON.stringify(external, undefined, 0)));\n                return undefined;\n            }\n            let configElement = {\n                workspaceFolder: context.workspaceFolder,\n                file: '.vscode/tasks.json',\n                index,\n                element: external\n            };\n            let result = new Tasks.ConfiguringTask(`${typeDeclaration.extensionId}.${taskIdentifier._key}`, Objects.assign({}, source, { config: configElement }), undefined, type, taskIdentifier, RunOptions.fromConfiguration(external.runOptions), {});\n            let configuration = ConfigurationProperties.from(external, context, true);\n            if (configuration) {\n                result.configurationProperties = Objects.assign(result.configurationProperties, configuration);\n                if (result.configurationProperties.name) {\n                    result._label = result.configurationProperties.name;\n                }\n                else {\n                    let label = result.configures.type;\n                    if (typeDeclaration.required && typeDeclaration.required.length > 0) {\n                        for (let required of typeDeclaration.required) {\n                            let value = result.configures[required];\n                            if (value) {\n                                label = label + ' ' + value;\n                                break;\n                            }\n                        }\n                    }\n                    result._label = label;\n                }\n                if (!result.configurationProperties.identifier) {\n                    result.configurationProperties.identifier = taskIdentifier._key;\n                }\n            }\n            return result;\n        }\n        ConfiguringTask.from = from;\n    })(ConfiguringTask || (ConfiguringTask = {}));\n    var CustomTask;\n    (function (CustomTask) {\n        function from(external, context, index) {\n            if (!external) {\n                return undefined;\n            }\n            let type = external.type;\n            if (type === undefined || type === null) {\n                type = Tasks.CUSTOMIZED_TASK_TYPE;\n            }\n            if (type !== Tasks.CUSTOMIZED_TASK_TYPE && type !== 'shell' && type !== 'process') {\n                context.problemReporter.error(nls.localize('ConfigurationParser.notCustom', 'Error: tasks is not declared as a custom task. The configuration will be ignored.\\n{0}\\n', JSON.stringify(external, null, 4)));\n                return undefined;\n            }\n            let taskName = external.taskName;\n            if (Types.isString(external.label) && context.schemaVersion === Tasks.JsonSchemaVersion.V2_0_0) {\n                taskName = external.label;\n            }\n            if (!taskName) {\n                context.problemReporter.error(nls.localize('ConfigurationParser.noTaskName', 'Error: a task must provide a label property. The task will be ignored.\\n{0}\\n', JSON.stringify(external, null, 4)));\n                return undefined;\n            }\n            let result = new Tasks.CustomTask(context.uuidMap.getUUID(taskName), Objects.assign({}, source, { config: { index, element: external, file: '.vscode/tasks.json', workspaceFolder: context.workspaceFolder } }), taskName, Tasks.CUSTOMIZED_TASK_TYPE, undefined, false, RunOptions.fromConfiguration(external.runOptions), {\n                name: taskName,\n                identifier: taskName,\n            });\n            let configuration = ConfigurationProperties.from(external, context, false);\n            if (configuration) {\n                result.configurationProperties = Objects.assign(result.configurationProperties, configuration);\n            }\n            let supportLegacy = true; //context.schemaVersion === Tasks.JsonSchemaVersion.V2_0_0;\n            if (supportLegacy) {\n                let legacy = external;\n                if (result.configurationProperties.isBackground === undefined && legacy.isWatching !== undefined) {\n                    result.configurationProperties.isBackground = !!legacy.isWatching;\n                }\n                if (result.configurationProperties.group === undefined) {\n                    if (legacy.isBuildCommand === true) {\n                        result.configurationProperties.group = Tasks.TaskGroup.Build;\n                    }\n                    else if (legacy.isTestCommand === true) {\n                        result.configurationProperties.group = Tasks.TaskGroup.Test;\n                    }\n                }\n            }\n            let command = CommandConfiguration.from(external, context);\n            if (command) {\n                result.command = command;\n            }\n            if (external.command !== undefined) {\n                // if the task has its own command then we suppress the\n                // task name by default.\n                command.suppressTaskName = true;\n            }\n            return result;\n        }\n        CustomTask.from = from;\n        function fillGlobals(task, globals) {\n            // We only merge a command from a global definition if there is no dependsOn\n            // or there is a dependsOn and a defined command.\n            if (CommandConfiguration.hasCommand(task.command) || task.configurationProperties.dependsOn === undefined) {\n                task.command = CommandConfiguration.fillGlobals(task.command, globals.command, task.configurationProperties.name);\n            }\n            if (task.configurationProperties.problemMatchers === undefined && globals.problemMatcher !== undefined) {\n                task.configurationProperties.problemMatchers = Objects.deepClone(globals.problemMatcher);\n                task.hasDefinedMatchers = true;\n            }\n            // promptOnClose is inferred from isBackground if available\n            if (task.configurationProperties.promptOnClose === undefined && task.configurationProperties.isBackground === undefined && globals.promptOnClose !== undefined) {\n                task.configurationProperties.promptOnClose = globals.promptOnClose;\n            }\n        }\n        CustomTask.fillGlobals = fillGlobals;\n        function fillDefaults(task, context) {\n            CommandConfiguration.fillDefaults(task.command, context);\n            if (task.configurationProperties.promptOnClose === undefined) {\n                task.configurationProperties.promptOnClose = task.configurationProperties.isBackground !== undefined ? !task.configurationProperties.isBackground : true;\n            }\n            if (task.configurationProperties.isBackground === undefined) {\n                task.configurationProperties.isBackground = false;\n            }\n            if (task.configurationProperties.problemMatchers === undefined) {\n                task.configurationProperties.problemMatchers = EMPTY_ARRAY;\n            }\n            if (task.configurationProperties.group !== undefined && task.configurationProperties.groupType === undefined) {\n                task.configurationProperties.groupType = Tasks.GroupType.user;\n            }\n        }\n        CustomTask.fillDefaults = fillDefaults;\n        function createCustomTask(contributedTask, configuredProps) {\n            let result = new Tasks.CustomTask(configuredProps._id, Objects.assign({}, configuredProps._source, { customizes: contributedTask.defines }), configuredProps.configurationProperties.name || contributedTask._label, Tasks.CUSTOMIZED_TASK_TYPE, contributedTask.command, false, contributedTask.runOptions, {\n                name: configuredProps.configurationProperties.name || contributedTask.configurationProperties.name,\n                identifier: configuredProps.configurationProperties.identifier || contributedTask.configurationProperties.identifier,\n            });\n            result.addTaskLoadMessages(configuredProps.taskLoadMessages);\n            let resultConfigProps = result.configurationProperties;\n            assignProperty(resultConfigProps, configuredProps.configurationProperties, 'group');\n            assignProperty(resultConfigProps, configuredProps.configurationProperties, 'groupType');\n            assignProperty(resultConfigProps, configuredProps.configurationProperties, 'isBackground');\n            assignProperty(resultConfigProps, configuredProps.configurationProperties, 'dependsOn');\n            assignProperty(resultConfigProps, configuredProps.configurationProperties, 'problemMatchers');\n            assignProperty(resultConfigProps, configuredProps.configurationProperties, 'promptOnClose');\n            result.command.presentation = CommandConfiguration.PresentationOptions.assignProperties(result.command.presentation, configuredProps.configurationProperties.presentation);\n            result.command.options = CommandOptions.assignProperties(result.command.options, configuredProps.configurationProperties.options);\n            let contributedConfigProps = contributedTask.configurationProperties;\n            fillProperty(resultConfigProps, contributedConfigProps, 'group');\n            fillProperty(resultConfigProps, contributedConfigProps, 'groupType');\n            fillProperty(resultConfigProps, contributedConfigProps, 'isBackground');\n            fillProperty(resultConfigProps, contributedConfigProps, 'dependsOn');\n            fillProperty(resultConfigProps, contributedConfigProps, 'problemMatchers');\n            fillProperty(resultConfigProps, contributedConfigProps, 'promptOnClose');\n            result.command.presentation = CommandConfiguration.PresentationOptions.fillProperties(result.command.presentation, contributedConfigProps.presentation);\n            result.command.options = CommandOptions.fillProperties(result.command.options, contributedConfigProps.options);\n            if (contributedTask.hasDefinedMatchers === true) {\n                result.hasDefinedMatchers = true;\n            }\n            return result;\n        }\n        CustomTask.createCustomTask = createCustomTask;\n    })(CustomTask || (CustomTask = {}));\n    var TaskParser;\n    (function (TaskParser) {\n        function isCustomTask(value) {\n            let type = value.type;\n            let customize = value.customize;\n            return customize === undefined && (type === undefined || type === null || type === Tasks.CUSTOMIZED_TASK_TYPE || type === 'shell' || type === 'process');\n        }\n        function from(externals, globals, context) {\n            let result = { custom: [], configured: [] };\n            if (!externals) {\n                return result;\n            }\n            let defaultBuildTask = { task: undefined, rank: -1 };\n            let defaultTestTask = { task: undefined, rank: -1 };\n            let schema2_0_0 = context.schemaVersion === Tasks.JsonSchemaVersion.V2_0_0;\n            const baseLoadIssues = Objects.deepClone(context.taskLoadIssues);\n            for (let index = 0; index < externals.length; index++) {\n                let external = externals[index];\n                if (isCustomTask(external)) {\n                    let customTask = CustomTask.from(external, context, index);\n                    if (customTask) {\n                        CustomTask.fillGlobals(customTask, globals);\n                        CustomTask.fillDefaults(customTask, context);\n                        if (schema2_0_0) {\n                            if ((customTask.command === undefined || customTask.command.name === undefined) && (customTask.configurationProperties.dependsOn === undefined || customTask.configurationProperties.dependsOn.length === 0)) {\n                                context.problemReporter.error(nls.localize('taskConfiguration.noCommandOrDependsOn', 'Error: the task \\'{0}\\' neither specifies a command nor a dependsOn property. The task will be ignored. Its definition is:\\n{1}', customTask.configurationProperties.name, JSON.stringify(external, undefined, 4)));\n                                continue;\n                            }\n                        }\n                        else {\n                            if (customTask.command === undefined || customTask.command.name === undefined) {\n                                context.problemReporter.warn(nls.localize('taskConfiguration.noCommand', 'Error: the task \\'{0}\\' doesn\\'t define a command. The task will be ignored. Its definition is:\\n{1}', customTask.configurationProperties.name, JSON.stringify(external, undefined, 4)));\n                                continue;\n                            }\n                        }\n                        if (customTask.configurationProperties.group === Tasks.TaskGroup.Build && defaultBuildTask.rank < 2) {\n                            defaultBuildTask.task = customTask;\n                            defaultBuildTask.rank = 2;\n                        }\n                        else if (customTask.configurationProperties.group === Tasks.TaskGroup.Test && defaultTestTask.rank < 2) {\n                            defaultTestTask.task = customTask;\n                            defaultTestTask.rank = 2;\n                        }\n                        else if (customTask.configurationProperties.name === 'build' && defaultBuildTask.rank < 1) {\n                            defaultBuildTask.task = customTask;\n                            defaultBuildTask.rank = 1;\n                        }\n                        else if (customTask.configurationProperties.name === 'test' && defaultTestTask.rank < 1) {\n                            defaultTestTask.task = customTask;\n                            defaultTestTask.rank = 1;\n                        }\n                        customTask.addTaskLoadMessages(context.taskLoadIssues);\n                        result.custom.push(customTask);\n                    }\n                }\n                else {\n                    let configuredTask = ConfiguringTask.from(external, context, index);\n                    if (configuredTask) {\n                        configuredTask.addTaskLoadMessages(context.taskLoadIssues);\n                        result.configured.push(configuredTask);\n                    }\n                }\n                context.taskLoadIssues = Objects.deepClone(baseLoadIssues);\n            }\n            if ((defaultBuildTask.rank > -1) && (defaultBuildTask.rank < 2) && defaultBuildTask.task) {\n                defaultBuildTask.task.configurationProperties.group = Tasks.TaskGroup.Build;\n                defaultBuildTask.task.configurationProperties.groupType = Tasks.GroupType.user;\n            }\n            else if ((defaultTestTask.rank > -1) && (defaultTestTask.rank < 2) && defaultTestTask.task) {\n                defaultTestTask.task.configurationProperties.group = Tasks.TaskGroup.Test;\n                defaultTestTask.task.configurationProperties.groupType = Tasks.GroupType.user;\n            }\n            return result;\n        }\n        TaskParser.from = from;\n        function assignTasks(target, source) {\n            if (source === undefined || source.length === 0) {\n                return target;\n            }\n            if (target === undefined || target.length === 0) {\n                return source;\n            }\n            if (source) {\n                // Tasks are keyed by ID but we need to merge by name\n                let map = Object.create(null);\n                target.forEach((task) => {\n                    map[task.configurationProperties.name] = task;\n                });\n                source.forEach((task) => {\n                    map[task.configurationProperties.name] = task;\n                });\n                let newTarget = [];\n                target.forEach(task => {\n                    newTarget.push(map[task.configurationProperties.name]);\n                    delete map[task.configurationProperties.name];\n                });\n                Object.keys(map).forEach(key => newTarget.push(map[key]));\n                target = newTarget;\n            }\n            return target;\n        }\n        TaskParser.assignTasks = assignTasks;\n    })(TaskParser || (TaskParser = {}));\n    var Globals;\n    (function (Globals) {\n        function from(config, context) {\n            let result = fromBase(config, context);\n            let osGlobals = undefined;\n            if (config.windows && context.platform === platform_1.Platform.Windows) {\n                osGlobals = fromBase(config.windows, context);\n            }\n            else if (config.osx && context.platform === platform_1.Platform.Mac) {\n                osGlobals = fromBase(config.osx, context);\n            }\n            else if (config.linux && context.platform === platform_1.Platform.Linux) {\n                osGlobals = fromBase(config.linux, context);\n            }\n            if (osGlobals) {\n                result = Globals.assignProperties(result, osGlobals);\n            }\n            let command = CommandConfiguration.from(config, context);\n            if (command) {\n                result.command = command;\n            }\n            Globals.fillDefaults(result, context);\n            Globals.freeze(result);\n            return result;\n        }\n        Globals.from = from;\n        function fromBase(config, context) {\n            let result = {};\n            if (config.suppressTaskName !== undefined) {\n                result.suppressTaskName = !!config.suppressTaskName;\n            }\n            if (config.promptOnClose !== undefined) {\n                result.promptOnClose = !!config.promptOnClose;\n            }\n            if (config.problemMatcher) {\n                result.problemMatcher = ProblemMatcherConverter.from(config.problemMatcher, context);\n            }\n            return result;\n        }\n        Globals.fromBase = fromBase;\n        function isEmpty(value) {\n            return !value || value.command === undefined && value.promptOnClose === undefined && value.suppressTaskName === undefined;\n        }\n        Globals.isEmpty = isEmpty;\n        function assignProperties(target, source) {\n            if (isEmpty(source)) {\n                return target;\n            }\n            if (isEmpty(target)) {\n                return source;\n            }\n            assignProperty(target, source, 'promptOnClose');\n            assignProperty(target, source, 'suppressTaskName');\n            return target;\n        }\n        Globals.assignProperties = assignProperties;\n        function fillDefaults(value, context) {\n            if (!value) {\n                return;\n            }\n            CommandConfiguration.fillDefaults(value.command, context);\n            if (value.suppressTaskName === undefined) {\n                value.suppressTaskName = false;\n            }\n            if (value.promptOnClose === undefined) {\n                value.promptOnClose = true;\n            }\n        }\n        Globals.fillDefaults = fillDefaults;\n        function freeze(value) {\n            Object.freeze(value);\n            if (value.command) {\n                CommandConfiguration.freeze(value.command);\n            }\n        }\n        Globals.freeze = freeze;\n    })(Globals || (Globals = {}));\n    var ExecutionEngine;\n    (function (ExecutionEngine) {\n        function from(config) {\n            let runner = config.runner || config._runner;\n            let result;\n            if (runner) {\n                switch (runner) {\n                    case 'terminal':\n                        result = Tasks.ExecutionEngine.Terminal;\n                        break;\n                    case 'process':\n                        result = Tasks.ExecutionEngine.Process;\n                        break;\n                }\n            }\n            let schemaVersion = JsonSchemaVersion.from(config);\n            if (schemaVersion === Tasks.JsonSchemaVersion.V0_1_0) {\n                return result || Tasks.ExecutionEngine.Process;\n            }\n            else if (schemaVersion === Tasks.JsonSchemaVersion.V2_0_0) {\n                return Tasks.ExecutionEngine.Terminal;\n            }\n            else {\n                throw new Error('Shouldn\\'t happen.');\n            }\n        }\n        ExecutionEngine.from = from;\n    })(ExecutionEngine = exports.ExecutionEngine || (exports.ExecutionEngine = {}));\n    var JsonSchemaVersion;\n    (function (JsonSchemaVersion) {\n        const _default = Tasks.JsonSchemaVersion.V2_0_0;\n        function from(config) {\n            let version = config.version;\n            if (!version) {\n                return _default;\n            }\n            switch (version) {\n                case '0.1.0':\n                    return Tasks.JsonSchemaVersion.V0_1_0;\n                case '2.0.0':\n                    return Tasks.JsonSchemaVersion.V2_0_0;\n                default:\n                    return _default;\n            }\n        }\n        JsonSchemaVersion.from = from;\n    })(JsonSchemaVersion = exports.JsonSchemaVersion || (exports.JsonSchemaVersion = {}));\n    class UUIDMap {\n        constructor(other) {\n            this.current = Object.create(null);\n            if (other) {\n                for (let key of Object.keys(other.current)) {\n                    let value = other.current[key];\n                    if (Array.isArray(value)) {\n                        this.current[key] = value.slice();\n                    }\n                    else {\n                        this.current[key] = value;\n                    }\n                }\n            }\n        }\n        start() {\n            this.last = this.current;\n            this.current = Object.create(null);\n        }\n        getUUID(identifier) {\n            let lastValue = this.last ? this.last[identifier] : undefined;\n            let result = undefined;\n            if (lastValue !== undefined) {\n                if (Array.isArray(lastValue)) {\n                    result = lastValue.shift();\n                    if (lastValue.length === 0) {\n                        delete this.last[identifier];\n                    }\n                }\n                else {\n                    result = lastValue;\n                    delete this.last[identifier];\n                }\n            }\n            if (result === undefined) {\n                result = UUID.generateUuid();\n            }\n            let currentValue = this.current[identifier];\n            if (currentValue === undefined) {\n                this.current[identifier] = result;\n            }\n            else {\n                if (Array.isArray(currentValue)) {\n                    currentValue.push(result);\n                }\n                else {\n                    let arrayValue = [currentValue];\n                    arrayValue.push(result);\n                    this.current[identifier] = arrayValue;\n                }\n            }\n            return result;\n        }\n        finish() {\n            this.last = undefined;\n        }\n    }\n    class ConfigurationParser {\n        constructor(workspaceFolder, platform, problemReporter, uuidMap) {\n            this.workspaceFolder = workspaceFolder;\n            this.platform = platform;\n            this.problemReporter = problemReporter;\n            this.uuidMap = uuidMap;\n        }\n        run(fileConfig) {\n            let engine = ExecutionEngine.from(fileConfig);\n            let schemaVersion = JsonSchemaVersion.from(fileConfig);\n            let context = {\n                workspaceFolder: this.workspaceFolder,\n                problemReporter: this.problemReporter,\n                uuidMap: this.uuidMap,\n                namedProblemMatchers: {},\n                engine,\n                schemaVersion,\n                platform: this.platform,\n                taskLoadIssues: []\n            };\n            let taskParseResult = this.createTaskRunnerConfiguration(fileConfig, context);\n            return {\n                validationStatus: this.problemReporter.status,\n                custom: taskParseResult.custom,\n                configured: taskParseResult.configured,\n                engine\n            };\n        }\n        createTaskRunnerConfiguration(fileConfig, context) {\n            let globals = Globals.from(fileConfig, context);\n            if (this.problemReporter.status.isFatal()) {\n                return { custom: [], configured: [] };\n            }\n            context.namedProblemMatchers = ProblemMatcherConverter.namedFrom(fileConfig.declares, context);\n            let globalTasks = undefined;\n            let externalGlobalTasks = undefined;\n            if (fileConfig.windows && context.platform === platform_1.Platform.Windows) {\n                globalTasks = TaskParser.from(fileConfig.windows.tasks, globals, context).custom;\n                externalGlobalTasks = fileConfig.windows.tasks;\n            }\n            else if (fileConfig.osx && context.platform === platform_1.Platform.Mac) {\n                globalTasks = TaskParser.from(fileConfig.osx.tasks, globals, context).custom;\n                externalGlobalTasks = fileConfig.osx.tasks;\n            }\n            else if (fileConfig.linux && context.platform === platform_1.Platform.Linux) {\n                globalTasks = TaskParser.from(fileConfig.linux.tasks, globals, context).custom;\n                externalGlobalTasks = fileConfig.linux.tasks;\n            }\n            if (context.schemaVersion === Tasks.JsonSchemaVersion.V2_0_0 && globalTasks && globalTasks.length > 0 && externalGlobalTasks && externalGlobalTasks.length > 0) {\n                let taskContent = [];\n                for (let task of externalGlobalTasks) {\n                    taskContent.push(JSON.stringify(task, null, 4));\n                }\n                context.problemReporter.error(nls.localize('TaskParse.noOsSpecificGlobalTasks', 'Task version 2.0.0 doesn\\'t support global OS specific tasks. Convert them to a task with a OS specific command. Affected tasks are:\\n{0}', taskContent.join('\\n')));\n            }\n            let result = { custom: [], configured: [] };\n            if (fileConfig.tasks) {\n                result = TaskParser.from(fileConfig.tasks, globals, context);\n            }\n            if (globalTasks) {\n                result.custom = TaskParser.assignTasks(result.custom, globalTasks);\n            }\n            if ((!result.custom || result.custom.length === 0) && (globals.command && globals.command.name)) {\n                let matchers = ProblemMatcherConverter.from(fileConfig.problemMatcher, context);\n                let isBackground = fileConfig.isBackground ? !!fileConfig.isBackground : fileConfig.isWatching ? !!fileConfig.isWatching : undefined;\n                let name = Tasks.CommandString.value(globals.command.name);\n                let task = new Tasks.CustomTask(context.uuidMap.getUUID(name), Objects.assign({}, source, { config: { index: -1, element: fileConfig, workspaceFolder: context.workspaceFolder } }), name, Tasks.CUSTOMIZED_TASK_TYPE, {\n                    name: undefined,\n                    runtime: undefined,\n                    presentation: undefined,\n                    suppressTaskName: true\n                }, false, { reevaluateOnRerun: true }, {\n                    name: name,\n                    identifier: name,\n                    group: Tasks.TaskGroup.Build,\n                    isBackground: isBackground,\n                    problemMatchers: matchers,\n                });\n                let value = GroupKind.from(fileConfig.group);\n                if (value) {\n                    task.configurationProperties.group = value[0];\n                    task.configurationProperties.groupType = value[1];\n                }\n                else if (fileConfig.group === 'none') {\n                    task.configurationProperties.group = undefined;\n                }\n                CustomTask.fillGlobals(task, globals);\n                CustomTask.fillDefaults(task, context);\n                result.custom = [task];\n            }\n            result.custom = result.custom || [];\n            result.configured = result.configured || [];\n            return result;\n        }\n    }\n    let uuidMaps = new Map();\n    function parse(workspaceFolder, platform, configuration, logger) {\n        let uuidMap = uuidMaps.get(workspaceFolder.uri.toString());\n        if (!uuidMap) {\n            uuidMap = new UUIDMap();\n            uuidMaps.set(workspaceFolder.uri.toString(), uuidMap);\n        }\n        try {\n            uuidMap.start();\n            return (new ConfigurationParser(workspaceFolder, platform, logger, uuidMap)).run(configuration);\n        }\n        finally {\n            uuidMap.finish();\n        }\n    }\n    exports.parse = parse;\n    function createCustomTask(contributedTask, configuredProps) {\n        return CustomTask.createCustomTask(contributedTask, configuredProps);\n    }\n    exports.createCustomTask = createCustomTask;\n});\n/*\nclass VersionConverter {\n    constructor(private problemReporter: IProblemReporter) {\n    }\n\n    public convert(fromConfig: ExternalTaskRunnerConfiguration): ExternalTaskRunnerConfiguration {\n        let result: ExternalTaskRunnerConfiguration;\n        result.version = '2.0.0';\n        if (Array.isArray(fromConfig.tasks)) {\n\n        } else {\n            result.tasks = [];\n        }\n\n\n        return result;\n    }\n\n    private convertGlobalTask(fromConfig: ExternalTaskRunnerConfiguration): TaskDescription {\n        let command: string = this.getGlobalCommand(fromConfig);\n        if (!command) {\n            this.problemReporter.error(nls.localize('Converter.noGlobalName', 'No global command specified. Can\\'t convert to 2.0.0 version.'));\n            return undefined;\n        }\n        let result: TaskDescription = {\n            taskName: command\n        };\n        if (fromConfig.isShellCommand) {\n            result.type = 'shell';\n        } else {\n            result.type = 'process';\n            result.args = fromConfig.args;\n        }\n        if (fromConfig.)\n\n        return result;\n    }\n\n    private getGlobalCommand(fromConfig: ExternalTaskRunnerConfiguration): string {\n        if (fromConfig.command) {\n            return fromConfig.command;\n        } else if (fromConfig.windows && fromConfig.windows.command) {\n            return fromConfig.windows.command;\n        } else if (fromConfig.osx && fromConfig.osx.command) {\n            return fromConfig.osx.command;\n        } else if (fromConfig.linux && fromConfig.linux.command) {\n            return fromConfig.linux.command;\n        } else {\n            return undefined;\n        }\n    }\n\n    private createCommandLine(command: string, args: string[], isWindows: boolean): string {\n        let result: string[];\n        let commandHasSpace = false;\n        let argHasSpace = false;\n        if (TaskDescription.hasUnescapedSpaces(command)) {\n            result.push(`\"${command}\"`);\n            commandHasSpace = true;\n        } else {\n            result.push(command);\n        }\n        if (args) {\n            for (let arg of args) {\n                if (TaskDescription.hasUnescapedSpaces(arg)) {\n                    result.push(`\"${arg}\"`);\n                    argHasSpace= true;\n                } else {\n                    result.push(arg);\n                }\n            }\n        }\n        return result.join(' ');\n    }\n\n}\n*/\n",null]}