{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/common/labels.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/labels.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar uri_1 = require(\"vs/base/common/uri\");\nvar path_1 = require(\"vs/base/common/path\");\nvar strings_1 = require(\"vs/base/common/strings\");\nvar network_1 = require(\"vs/base/common/network\");\nvar platform_1 = require(\"vs/base/common/platform\");\nvar resources_1 = require(\"vs/base/common/resources\");\nvar charCode_1 = require(\"vs/base/common/charCode\");\n/**\n * @deprecated use LabelService instead\n */\nfunction getPathLabel(resource, userHomeProvider, rootProvider) {\n    if (typeof resource === 'string') {\n        resource = uri_1.URI.file(resource);\n    }\n    // return early if we can resolve a relative path label from the root\n    if (rootProvider) {\n        var baseResource = rootProvider.getWorkspaceFolder(resource);\n        if (baseResource) {\n            var hasMultipleRoots = rootProvider.getWorkspace().folders.length > 1;\n            var pathLabel = void 0;\n            if (resources_1.isEqual(baseResource.uri, resource)) {\n                pathLabel = ''; // no label if paths are identical\n            }\n            else {\n                // TODO: isidor use resources.relative\n                pathLabel = path_1.normalize(strings_1.ltrim(resource.path.substr(baseResource.uri.path.length), path_1.posix.sep));\n            }\n            if (hasMultipleRoots) {\n                var rootName = (baseResource && baseResource.name) ? baseResource.name : resources_1.basename(baseResource.uri);\n                pathLabel = pathLabel ? (rootName + ' • ' + pathLabel) : rootName; // always show root basename if there are multiple\n            }\n            return pathLabel;\n        }\n    }\n    // return if the resource is neither file:// nor untitled:// and no baseResource was provided\n    if (resource.scheme !== network_1.Schemas.file && resource.scheme !== network_1.Schemas.untitled) {\n        return resource.with({ query: null, fragment: null }).toString(true);\n    }\n    // convert c:\\something => C:\\something\n    if (hasDriveLetter(resource.fsPath)) {\n        return path_1.normalize(normalizeDriveLetter(resource.fsPath));\n    }\n    // normalize and tildify (macOS, Linux only)\n    var res = path_1.normalize(resource.fsPath);\n    if (!platform_1.isWindows && userHomeProvider) {\n        res = tildify(res, userHomeProvider.userHome);\n    }\n    return res;\n}\nexports.getPathLabel = getPathLabel;\nfunction getBaseLabel(resource) {\n    if (!resource) {\n        return undefined;\n    }\n    if (typeof resource === 'string') {\n        resource = uri_1.URI.file(resource);\n    }\n    var base = resources_1.basename(resource) || (resource.scheme === network_1.Schemas.file ? resource.fsPath : resource.path) /* can be empty string if '/' is passed in */;\n    // convert c: => C:\n    if (hasDriveLetter(base)) {\n        return normalizeDriveLetter(base);\n    }\n    return base;\n}\nexports.getBaseLabel = getBaseLabel;\nfunction hasDriveLetter(path) {\n    return !!(platform_1.isWindows && path && path[1] === ':');\n}\nfunction normalizeDriveLetter(path) {\n    if (hasDriveLetter(path)) {\n        return path.charAt(0).toUpperCase() + path.slice(1);\n    }\n    return path;\n}\nexports.normalizeDriveLetter = normalizeDriveLetter;\nvar normalizedUserHomeCached = Object.create(null);\nfunction tildify(path, userHome) {\n    if (platform_1.isWindows || !path || !userHome) {\n        return path; // unsupported\n    }\n    // Keep a normalized user home path as cache to prevent accumulated string creation\n    var normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : undefined;\n    if (!normalizedUserHome) {\n        normalizedUserHome = \"\" + strings_1.rtrim(userHome, path_1.posix.sep) + path_1.posix.sep;\n        normalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };\n    }\n    // Linux: case sensitive, macOS: case insensitive\n    if (platform_1.isLinux ? strings_1.startsWith(path, normalizedUserHome) : strings_1.startsWithIgnoreCase(path, normalizedUserHome)) {\n        path = \"~/\" + path.substr(normalizedUserHome.length);\n    }\n    return path;\n}\nexports.tildify = tildify;\nfunction untildify(path, userHome) {\n    return path.replace(/^~($|\\/|\\\\)/, userHome + \"$1\");\n}\nexports.untildify = untildify;\n/**\n * Shortens the paths but keeps them easy to distinguish.\n * Replaces not important parts with ellipsis.\n * Every shorten path matches only one original path and vice versa.\n *\n * Algorithm for shortening paths is as follows:\n * 1. For every path in list, find unique substring of that path.\n * 2. Unique substring along with ellipsis is shortened path of that path.\n * 3. To find unique substring of path, consider every segment of length from 1 to path.length of path from end of string\n *    and if present segment is not substring to any other paths then present segment is unique path,\n *    else check if it is not present as suffix of any other path and present segment is suffix of path itself,\n *    if it is true take present segment as unique path.\n * 4. Apply ellipsis to unique segment according to whether segment is present at start/in-between/end of path.\n *\n * Example 1\n * 1. consider 2 paths i.e. ['a\\\\b\\\\c\\\\d', 'a\\\\f\\\\b\\\\c\\\\d']\n * 2. find unique path of first path,\n * \ta. 'd' is present in path2 and is suffix of path2, hence not unique of present path.\n * \tb. 'c' is present in path2 and 'c' is not suffix of present path, similarly for 'b' and 'a' also.\n * \tc. 'd\\\\c' is suffix of path2.\n *  d. 'b\\\\c' is not suffix of present path.\n *  e. 'a\\\\b' is not present in path2, hence unique path is 'a\\\\b...'.\n * 3. for path2, 'f' is not present in path1 hence unique is '...\\\\f\\\\...'.\n *\n * Example 2\n * 1. consider 2 paths i.e. ['a\\\\b', 'a\\\\b\\\\c'].\n * \ta. Even if 'b' is present in path2, as 'b' is suffix of path1 and is not suffix of path2, unique path will be '...\\\\b'.\n * 2. for path2, 'c' is not present in path1 hence unique path is '..\\\\c'.\n */\nvar ellipsis = '\\u2026';\nvar unc = '\\\\\\\\';\nvar home = '~';\nfunction shorten(paths) {\n    var shortenedPaths = new Array(paths.length);\n    // for every path\n    var match = false;\n    for (var pathIndex = 0; pathIndex < paths.length; pathIndex++) {\n        var path = paths[pathIndex];\n        if (path === '') {\n            shortenedPaths[pathIndex] = \".\" + path_1.sep;\n            continue;\n        }\n        if (!path) {\n            shortenedPaths[pathIndex] = path;\n            continue;\n        }\n        match = true;\n        // trim for now and concatenate unc path (e.g. \\\\network) or root path (/etc, ~/etc) later\n        var prefix = '';\n        if (path.indexOf(unc) === 0) {\n            prefix = path.substr(0, path.indexOf(unc) + unc.length);\n            path = path.substr(path.indexOf(unc) + unc.length);\n        }\n        else if (path.indexOf(path_1.sep) === 0) {\n            prefix = path.substr(0, path.indexOf(path_1.sep) + path_1.sep.length);\n            path = path.substr(path.indexOf(path_1.sep) + path_1.sep.length);\n        }\n        else if (path.indexOf(home) === 0) {\n            prefix = path.substr(0, path.indexOf(home) + home.length);\n            path = path.substr(path.indexOf(home) + home.length);\n        }\n        // pick the first shortest subpath found\n        var segments = path.split(path_1.sep);\n        for (var subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {\n            for (var start = segments.length - subpathLength; match && start >= 0; start--) {\n                match = false;\n                var subpath = segments.slice(start, start + subpathLength).join(path_1.sep);\n                // that is unique to any other path\n                for (var otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {\n                    // suffix subpath treated specially as we consider no match 'x' and 'x/...'\n                    if (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {\n                        var isSubpathEnding = (start + subpathLength === segments.length);\n                        // Adding separator as prefix for subpath, such that 'endsWith(src, trgt)' considers subpath as directory name instead of plain string.\n                        // prefix is not added when either subpath is root directory or path[otherPathIndex] does not have multiple directories.\n                        var subpathWithSep = (start > 0 && paths[otherPathIndex].indexOf(path_1.sep) > -1) ? path_1.sep + subpath : subpath;\n                        var isOtherPathEnding = strings_1.endsWith(paths[otherPathIndex], subpathWithSep);\n                        match = !isSubpathEnding || isOtherPathEnding;\n                    }\n                }\n                // found unique subpath\n                if (!match) {\n                    var result = '';\n                    // preserve disk drive or root prefix\n                    if (strings_1.endsWith(segments[0], ':') || prefix !== '') {\n                        if (start === 1) {\n                            // extend subpath to include disk drive prefix\n                            start = 0;\n                            subpathLength++;\n                            subpath = segments[0] + path_1.sep + subpath;\n                        }\n                        if (start > 0) {\n                            result = segments[0] + path_1.sep;\n                        }\n                        result = prefix + result;\n                    }\n                    // add ellipsis at the beginning if neeeded\n                    if (start > 0) {\n                        result = result + ellipsis + path_1.sep;\n                    }\n                    result = result + subpath;\n                    // add ellipsis at the end if needed\n                    if (start + subpathLength < segments.length) {\n                        result = result + path_1.sep + ellipsis;\n                    }\n                    shortenedPaths[pathIndex] = result;\n                }\n            }\n        }\n        if (match) {\n            shortenedPaths[pathIndex] = path; // use full path if no unique subpaths found\n        }\n    }\n    return shortenedPaths;\n}\nexports.shorten = shorten;\nvar Type;\n(function (Type) {\n    Type[Type[\"TEXT\"] = 0] = \"TEXT\";\n    Type[Type[\"VARIABLE\"] = 1] = \"VARIABLE\";\n    Type[Type[\"SEPARATOR\"] = 2] = \"SEPARATOR\";\n})(Type || (Type = {}));\n/**\n * Helper to insert values for specific template variables into the string. E.g. \"this $(is) a $(template)\" can be\n * passed to this function together with an object that maps \"is\" and \"template\" to strings to have them replaced.\n * @param value string to which templating is applied\n * @param values the values of the templates to use\n */\nfunction template(template, values) {\n    if (values === void 0) { values = Object.create(null); }\n    var segments = [];\n    var inVariable = false;\n    var curVal = '';\n    for (var _i = 0, template_1 = template; _i < template_1.length; _i++) {\n        var char = template_1[_i];\n        // Beginning of variable\n        if (char === '$' || (inVariable && char === '{')) {\n            if (curVal) {\n                segments.push({ value: curVal, type: Type.TEXT });\n            }\n            curVal = '';\n            inVariable = true;\n        }\n        // End of variable\n        else if (char === '}' && inVariable) {\n            var resolved = values[curVal];\n            // Variable\n            if (typeof resolved === 'string') {\n                if (resolved.length) {\n                    segments.push({ value: resolved, type: Type.VARIABLE });\n                }\n            }\n            // Separator\n            else if (resolved) {\n                var prevSegment = segments[segments.length - 1];\n                if (!prevSegment || prevSegment.type !== Type.SEPARATOR) {\n                    segments.push({ value: resolved.label, type: Type.SEPARATOR }); // prevent duplicate separators\n                }\n            }\n            curVal = '';\n            inVariable = false;\n        }\n        // Text or Variable Name\n        else {\n            curVal += char;\n        }\n    }\n    // Tail\n    if (curVal && !inVariable) {\n        segments.push({ value: curVal, type: Type.TEXT });\n    }\n    return segments.filter(function (segment, index) {\n        // Only keep separator if we have values to the left and right\n        if (segment.type === Type.SEPARATOR) {\n            var left = segments[index - 1];\n            var right = segments[index + 1];\n            return [left, right].every(function (segment) { return segment && (segment.type === Type.VARIABLE || segment.type === Type.TEXT) && segment.value.length > 0; });\n        }\n        // accept any TEXT and VARIABLE\n        return true;\n    }).map(function (segment) { return segment.value; }).join('');\n}\nexports.template = template;\n/**\n * Handles mnemonics for menu items. Depending on OS:\n * - Windows: Supported via & character (replace && with &)\n * -   Linux: Supported via & character (replace && with &)\n * -   macOS: Unsupported (replace && with empty string)\n */\nfunction mnemonicMenuLabel(label, forceDisableMnemonics) {\n    if (platform_1.isMacintosh || forceDisableMnemonics) {\n        return label.replace(/\\(&&\\w\\)|&&/g, '').replace(/&/g, platform_1.isMacintosh ? '&' : '&&');\n    }\n    return label.replace(/&&|&/g, function (m) { return m === '&' ? '&&' : '&'; });\n}\nexports.mnemonicMenuLabel = mnemonicMenuLabel;\n/**\n * Handles mnemonics for buttons. Depending on OS:\n * - Windows: Supported via & character (replace && with & and & with && for escaping)\n * -   Linux: Supported via _ character (replace && with _)\n * -   macOS: Unsupported (replace && with empty string)\n */\nfunction mnemonicButtonLabel(label, forceDisableMnemonics) {\n    if (platform_1.isMacintosh || forceDisableMnemonics) {\n        return label.replace(/\\(&&\\w\\)|&&/g, '');\n    }\n    if (platform_1.isWindows) {\n        return label.replace(/&&|&/g, function (m) { return m === '&' ? '&&' : '&'; });\n    }\n    return label.replace(/&&/g, '_');\n}\nexports.mnemonicButtonLabel = mnemonicButtonLabel;\nfunction unmnemonicLabel(label) {\n    return label.replace(/&/g, '&&');\n}\nexports.unmnemonicLabel = unmnemonicLabel;\n/**\n * Splits a path in name and parent path, supporting both '/' and '\\'\n */\nfunction splitName(fullPath) {\n    for (var i = fullPath.length - 1; i >= 1; i--) {\n        var code = fullPath.charCodeAt(i);\n        if (code === charCode_1.CharCode.Slash || code === charCode_1.CharCode.Backslash) {\n            return { parentPath: fullPath.substr(0, i), name: fullPath.substr(i + 1) };\n        }\n    }\n    return { parentPath: '', name: fullPath };\n}\nexports.splitName = splitName;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/common/labels.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/common/labels.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport { sep, posix, normalize } from 'vs/base/common/path';\nimport { endsWith, ltrim, startsWithIgnoreCase, rtrim, startsWith } from 'vs/base/common/strings';\nimport { Schemas } from 'vs/base/common/network';\nimport { isLinux, isWindows, isMacintosh } from 'vs/base/common/platform';\nimport { isEqual, basename } from 'vs/base/common/resources';\nimport { CharCode } from 'vs/base/common/charCode';\n\nexport interface IWorkspaceFolderProvider {\n\tgetWorkspaceFolder(resource: URI): { uri: URI, name?: string } | null;\n\tgetWorkspace(): {\n\t\tfolders: { uri: URI, name?: string }[];\n\t};\n}\n\nexport interface IUserHomeProvider {\n\tuserHome: string;\n}\n\n/**\n * @deprecated use LabelService instead\n */\nexport function getPathLabel(resource: URI | string, userHomeProvider?: IUserHomeProvider, rootProvider?: IWorkspaceFolderProvider): string {\n\tif (typeof resource === 'string') {\n\t\tresource = URI.file(resource);\n\t}\n\n\t// return early if we can resolve a relative path label from the root\n\tif (rootProvider) {\n\t\tconst baseResource = rootProvider.getWorkspaceFolder(resource);\n\t\tif (baseResource) {\n\t\t\tconst hasMultipleRoots = rootProvider.getWorkspace().folders.length > 1;\n\n\t\t\tlet pathLabel: string;\n\t\t\tif (isEqual(baseResource.uri, resource)) {\n\t\t\t\tpathLabel = ''; // no label if paths are identical\n\t\t\t} else {\n\t\t\t\t// TODO: isidor use resources.relative\n\t\t\t\tpathLabel = normalize(ltrim(resource.path.substr(baseResource.uri.path.length), posix.sep)!);\n\t\t\t}\n\n\t\t\tif (hasMultipleRoots) {\n\t\t\t\tconst rootName = (baseResource && baseResource.name) ? baseResource.name : basename(baseResource.uri);\n\t\t\t\tpathLabel = pathLabel ? (rootName + ' • ' + pathLabel) : rootName; // always show root basename if there are multiple\n\t\t\t}\n\n\t\t\treturn pathLabel;\n\t\t}\n\t}\n\n\t// return if the resource is neither file:// nor untitled:// and no baseResource was provided\n\tif (resource.scheme !== Schemas.file && resource.scheme !== Schemas.untitled) {\n\t\treturn resource.with({ query: null, fragment: null }).toString(true);\n\t}\n\n\t// convert c:\\something => C:\\something\n\tif (hasDriveLetter(resource.fsPath)) {\n\t\treturn normalize(normalizeDriveLetter(resource.fsPath));\n\t}\n\n\t// normalize and tildify (macOS, Linux only)\n\tlet res = normalize(resource.fsPath);\n\tif (!isWindows && userHomeProvider) {\n\t\tres = tildify(res, userHomeProvider.userHome);\n\t}\n\n\treturn res;\n}\n\nexport function getBaseLabel(resource: URI | string): string;\nexport function getBaseLabel(resource: URI | string | undefined): string | undefined;\nexport function getBaseLabel(resource: URI | string | undefined): string | undefined {\n\tif (!resource) {\n\t\treturn undefined;\n\t}\n\n\tif (typeof resource === 'string') {\n\t\tresource = URI.file(resource);\n\t}\n\n\tconst base = basename(resource) || (resource.scheme === Schemas.file ? resource.fsPath : resource.path) /* can be empty string if '/' is passed in */;\n\n\t// convert c: => C:\n\tif (hasDriveLetter(base)) {\n\t\treturn normalizeDriveLetter(base);\n\t}\n\n\treturn base;\n}\n\nfunction hasDriveLetter(path: string): boolean {\n\treturn !!(isWindows && path && path[1] === ':');\n}\n\nexport function normalizeDriveLetter(path: string): string {\n\tif (hasDriveLetter(path)) {\n\t\treturn path.charAt(0).toUpperCase() + path.slice(1);\n\t}\n\n\treturn path;\n}\n\nlet normalizedUserHomeCached: { original: string; normalized: string } = Object.create(null);\nexport function tildify(path: string, userHome: string): string {\n\tif (isWindows || !path || !userHome) {\n\t\treturn path; // unsupported\n\t}\n\n\t// Keep a normalized user home path as cache to prevent accumulated string creation\n\tlet normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : undefined;\n\tif (!normalizedUserHome) {\n\t\tnormalizedUserHome = `${rtrim(userHome, posix.sep)}${posix.sep}`;\n\t\tnormalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };\n\t}\n\n\t// Linux: case sensitive, macOS: case insensitive\n\tif (isLinux ? startsWith(path, normalizedUserHome) : startsWithIgnoreCase(path, normalizedUserHome)) {\n\t\tpath = `~/${path.substr(normalizedUserHome.length)}`;\n\t}\n\n\treturn path;\n}\n\nexport function untildify(path: string, userHome: string): string {\n\treturn path.replace(/^~($|\\/|\\\\)/, `${userHome}$1`);\n}\n\n/**\n * Shortens the paths but keeps them easy to distinguish.\n * Replaces not important parts with ellipsis.\n * Every shorten path matches only one original path and vice versa.\n *\n * Algorithm for shortening paths is as follows:\n * 1. For every path in list, find unique substring of that path.\n * 2. Unique substring along with ellipsis is shortened path of that path.\n * 3. To find unique substring of path, consider every segment of length from 1 to path.length of path from end of string\n *    and if present segment is not substring to any other paths then present segment is unique path,\n *    else check if it is not present as suffix of any other path and present segment is suffix of path itself,\n *    if it is true take present segment as unique path.\n * 4. Apply ellipsis to unique segment according to whether segment is present at start/in-between/end of path.\n *\n * Example 1\n * 1. consider 2 paths i.e. ['a\\\\b\\\\c\\\\d', 'a\\\\f\\\\b\\\\c\\\\d']\n * 2. find unique path of first path,\n * \ta. 'd' is present in path2 and is suffix of path2, hence not unique of present path.\n * \tb. 'c' is present in path2 and 'c' is not suffix of present path, similarly for 'b' and 'a' also.\n * \tc. 'd\\\\c' is suffix of path2.\n *  d. 'b\\\\c' is not suffix of present path.\n *  e. 'a\\\\b' is not present in path2, hence unique path is 'a\\\\b...'.\n * 3. for path2, 'f' is not present in path1 hence unique is '...\\\\f\\\\...'.\n *\n * Example 2\n * 1. consider 2 paths i.e. ['a\\\\b', 'a\\\\b\\\\c'].\n * \ta. Even if 'b' is present in path2, as 'b' is suffix of path1 and is not suffix of path2, unique path will be '...\\\\b'.\n * 2. for path2, 'c' is not present in path1 hence unique path is '..\\\\c'.\n */\nconst ellipsis = '\\u2026';\nconst unc = '\\\\\\\\';\nconst home = '~';\nexport function shorten(paths: string[]): string[] {\n\tconst shortenedPaths: string[] = new Array(paths.length);\n\n\t// for every path\n\tlet match = false;\n\tfor (let pathIndex = 0; pathIndex < paths.length; pathIndex++) {\n\t\tlet path = paths[pathIndex];\n\n\t\tif (path === '') {\n\t\t\tshortenedPaths[pathIndex] = `.${sep}`;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!path) {\n\t\t\tshortenedPaths[pathIndex] = path;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmatch = true;\n\n\t\t// trim for now and concatenate unc path (e.g. \\\\network) or root path (/etc, ~/etc) later\n\t\tlet prefix = '';\n\t\tif (path.indexOf(unc) === 0) {\n\t\t\tprefix = path.substr(0, path.indexOf(unc) + unc.length);\n\t\t\tpath = path.substr(path.indexOf(unc) + unc.length);\n\t\t} else if (path.indexOf(sep) === 0) {\n\t\t\tprefix = path.substr(0, path.indexOf(sep) + sep.length);\n\t\t\tpath = path.substr(path.indexOf(sep) + sep.length);\n\t\t} else if (path.indexOf(home) === 0) {\n\t\t\tprefix = path.substr(0, path.indexOf(home) + home.length);\n\t\t\tpath = path.substr(path.indexOf(home) + home.length);\n\t\t}\n\n\t\t// pick the first shortest subpath found\n\t\tconst segments: string[] = path.split(sep);\n\t\tfor (let subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {\n\t\t\tfor (let start = segments.length - subpathLength; match && start >= 0; start--) {\n\t\t\t\tmatch = false;\n\t\t\t\tlet subpath = segments.slice(start, start + subpathLength).join(sep);\n\n\t\t\t\t// that is unique to any other path\n\t\t\t\tfor (let otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {\n\n\t\t\t\t\t// suffix subpath treated specially as we consider no match 'x' and 'x/...'\n\t\t\t\t\tif (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {\n\t\t\t\t\t\tconst isSubpathEnding: boolean = (start + subpathLength === segments.length);\n\n\t\t\t\t\t\t// Adding separator as prefix for subpath, such that 'endsWith(src, trgt)' considers subpath as directory name instead of plain string.\n\t\t\t\t\t\t// prefix is not added when either subpath is root directory or path[otherPathIndex] does not have multiple directories.\n\t\t\t\t\t\tconst subpathWithSep: string = (start > 0 && paths[otherPathIndex].indexOf(sep) > -1) ? sep + subpath : subpath;\n\t\t\t\t\t\tconst isOtherPathEnding: boolean = endsWith(paths[otherPathIndex], subpathWithSep);\n\n\t\t\t\t\t\tmatch = !isSubpathEnding || isOtherPathEnding;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// found unique subpath\n\t\t\t\tif (!match) {\n\t\t\t\t\tlet result = '';\n\n\t\t\t\t\t// preserve disk drive or root prefix\n\t\t\t\t\tif (endsWith(segments[0], ':') || prefix !== '') {\n\t\t\t\t\t\tif (start === 1) {\n\t\t\t\t\t\t\t// extend subpath to include disk drive prefix\n\t\t\t\t\t\t\tstart = 0;\n\t\t\t\t\t\t\tsubpathLength++;\n\t\t\t\t\t\t\tsubpath = segments[0] + sep + subpath;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (start > 0) {\n\t\t\t\t\t\t\tresult = segments[0] + sep;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresult = prefix + result;\n\t\t\t\t\t}\n\n\t\t\t\t\t// add ellipsis at the beginning if neeeded\n\t\t\t\t\tif (start > 0) {\n\t\t\t\t\t\tresult = result + ellipsis + sep;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = result + subpath;\n\n\t\t\t\t\t// add ellipsis at the end if needed\n\t\t\t\t\tif (start + subpathLength < segments.length) {\n\t\t\t\t\t\tresult = result + sep + ellipsis;\n\t\t\t\t\t}\n\n\t\t\t\t\tshortenedPaths[pathIndex] = result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (match) {\n\t\t\tshortenedPaths[pathIndex] = path; // use full path if no unique subpaths found\n\t\t}\n\t}\n\n\treturn shortenedPaths;\n}\n\nexport interface ISeparator {\n\tlabel: string;\n}\n\nenum Type {\n\tTEXT,\n\tVARIABLE,\n\tSEPARATOR\n}\n\ninterface ISegment {\n\tvalue: string;\n\ttype: Type;\n}\n\n/**\n * Helper to insert values for specific template variables into the string. E.g. \"this $(is) a $(template)\" can be\n * passed to this function together with an object that maps \"is\" and \"template\" to strings to have them replaced.\n * @param value string to which templating is applied\n * @param values the values of the templates to use\n */\nexport function template(template: string, values: { [key: string]: string | ISeparator | null } = Object.create(null)): string {\n\tconst segments: ISegment[] = [];\n\n\tlet inVariable = false;\n\tlet curVal = '';\n\tfor (const char of template) {\n\t\t// Beginning of variable\n\t\tif (char === '$' || (inVariable && char === '{')) {\n\t\t\tif (curVal) {\n\t\t\t\tsegments.push({ value: curVal, type: Type.TEXT });\n\t\t\t}\n\n\t\t\tcurVal = '';\n\t\t\tinVariable = true;\n\t\t}\n\n\t\t// End of variable\n\t\telse if (char === '}' && inVariable) {\n\t\t\tconst resolved = values[curVal];\n\n\t\t\t// Variable\n\t\t\tif (typeof resolved === 'string') {\n\t\t\t\tif (resolved.length) {\n\t\t\t\t\tsegments.push({ value: resolved, type: Type.VARIABLE });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Separator\n\t\t\telse if (resolved) {\n\t\t\t\tconst prevSegment = segments[segments.length - 1];\n\t\t\t\tif (!prevSegment || prevSegment.type !== Type.SEPARATOR) {\n\t\t\t\t\tsegments.push({ value: resolved.label, type: Type.SEPARATOR }); // prevent duplicate separators\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurVal = '';\n\t\t\tinVariable = false;\n\t\t}\n\n\t\t// Text or Variable Name\n\t\telse {\n\t\t\tcurVal += char;\n\t\t}\n\t}\n\n\t// Tail\n\tif (curVal && !inVariable) {\n\t\tsegments.push({ value: curVal, type: Type.TEXT });\n\t}\n\n\treturn segments.filter((segment, index) => {\n\n\t\t// Only keep separator if we have values to the left and right\n\t\tif (segment.type === Type.SEPARATOR) {\n\t\t\tconst left = segments[index - 1];\n\t\t\tconst right = segments[index + 1];\n\n\t\t\treturn [left, right].every(segment => segment && (segment.type === Type.VARIABLE || segment.type === Type.TEXT) && segment.value.length > 0);\n\t\t}\n\n\t\t// accept any TEXT and VARIABLE\n\t\treturn true;\n\t}).map(segment => segment.value).join('');\n}\n\n/**\n * Handles mnemonics for menu items. Depending on OS:\n * - Windows: Supported via & character (replace && with &)\n * -   Linux: Supported via & character (replace && with &)\n * -   macOS: Unsupported (replace && with empty string)\n */\nexport function mnemonicMenuLabel(label: string, forceDisableMnemonics?: boolean): string {\n\tif (isMacintosh || forceDisableMnemonics) {\n\t\treturn label.replace(/\\(&&\\w\\)|&&/g, '').replace(/&/g, isMacintosh ? '&' : '&&');\n\t}\n\n\treturn label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');\n}\n\n/**\n * Handles mnemonics for buttons. Depending on OS:\n * - Windows: Supported via & character (replace && with & and & with && for escaping)\n * -   Linux: Supported via _ character (replace && with _)\n * -   macOS: Unsupported (replace && with empty string)\n */\nexport function mnemonicButtonLabel(label: string, forceDisableMnemonics?: boolean): string {\n\tif (isMacintosh || forceDisableMnemonics) {\n\t\treturn label.replace(/\\(&&\\w\\)|&&/g, '');\n\t}\n\n\tif (isWindows) {\n\t\treturn label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');\n\t}\n\n\treturn label.replace(/&&/g, '_');\n}\n\nexport function unmnemonicLabel(label: string): string {\n\treturn label.replace(/&/g, '&&');\n}\n\n/**\n * Splits a path in name and parent path, supporting both '/' and '\\'\n */\nexport function splitName(fullPath: string): { name: string, parentPath: string } {\n\tfor (let i = fullPath.length - 1; i >= 1; i--) {\n\t\tconst code = fullPath.charCodeAt(i);\n\t\tif (code === CharCode.Slash || code === CharCode.Backslash) {\n\t\t\treturn { parentPath: fullPath.substr(0, i), name: fullPath.substr(i + 1) };\n\t\t}\n\t}\n\treturn { parentPath: '', name: fullPath };\n}\n"]}]}