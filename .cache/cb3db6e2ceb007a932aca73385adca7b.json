{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/find/replacePattern.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/find/replacePattern.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar ReplacePatternKind;\n(function (ReplacePatternKind) {\n    ReplacePatternKind[ReplacePatternKind[\"StaticValue\"] = 0] = \"StaticValue\";\n    ReplacePatternKind[ReplacePatternKind[\"DynamicPieces\"] = 1] = \"DynamicPieces\";\n})(ReplacePatternKind || (ReplacePatternKind = {}));\n/**\n * Assigned when the replace pattern is entirely static.\n */\nvar StaticValueReplacePattern = /** @class */ (function () {\n    function StaticValueReplacePattern(staticValue) {\n        this.staticValue = staticValue;\n        this.kind = ReplacePatternKind.StaticValue;\n    }\n    return StaticValueReplacePattern;\n}());\n/**\n * Assigned when the replace pattern has replacemend patterns.\n */\nvar DynamicPiecesReplacePattern = /** @class */ (function () {\n    function DynamicPiecesReplacePattern(pieces) {\n        this.pieces = pieces;\n        this.kind = ReplacePatternKind.DynamicPieces;\n    }\n    return DynamicPiecesReplacePattern;\n}());\nvar ReplacePattern = /** @class */ (function () {\n    function ReplacePattern(pieces) {\n        if (!pieces || pieces.length === 0) {\n            this._state = new StaticValueReplacePattern('');\n        }\n        else if (pieces.length === 1 && pieces[0].staticValue !== null) {\n            this._state = new StaticValueReplacePattern(pieces[0].staticValue);\n        }\n        else {\n            this._state = new DynamicPiecesReplacePattern(pieces);\n        }\n    }\n    ReplacePattern.fromStaticValue = function (value) {\n        return new ReplacePattern([ReplacePiece.staticValue(value)]);\n    };\n    Object.defineProperty(ReplacePattern.prototype, \"hasReplacementPatterns\", {\n        get: function () {\n            return (this._state.kind === ReplacePatternKind.DynamicPieces);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ReplacePattern.prototype.buildReplaceString = function (matches) {\n        if (this._state.kind === ReplacePatternKind.StaticValue) {\n            return this._state.staticValue;\n        }\n        var result = '';\n        for (var i = 0, len = this._state.pieces.length; i < len; i++) {\n            var piece = this._state.pieces[i];\n            if (piece.staticValue !== null) {\n                // static value ReplacePiece\n                result += piece.staticValue;\n                continue;\n            }\n            // match index ReplacePiece\n            result += ReplacePattern._substitute(piece.matchIndex, matches);\n        }\n        return result;\n    };\n    ReplacePattern._substitute = function (matchIndex, matches) {\n        if (matches === null) {\n            return '';\n        }\n        if (matchIndex === 0) {\n            return matches[0];\n        }\n        var remainder = '';\n        while (matchIndex > 0) {\n            if (matchIndex < matches.length) {\n                // A match can be undefined\n                var match = (matches[matchIndex] || '');\n                return match + remainder;\n            }\n            remainder = String(matchIndex % 10) + remainder;\n            matchIndex = Math.floor(matchIndex / 10);\n        }\n        return '$' + remainder;\n    };\n    return ReplacePattern;\n}());\nexports.ReplacePattern = ReplacePattern;\n/**\n * A replace piece can either be a static string or an index to a specific match.\n */\nvar ReplacePiece = /** @class */ (function () {\n    function ReplacePiece(staticValue, matchIndex) {\n        this.staticValue = staticValue;\n        this.matchIndex = matchIndex;\n    }\n    ReplacePiece.staticValue = function (value) {\n        return new ReplacePiece(value, -1);\n    };\n    ReplacePiece.matchIndex = function (index) {\n        return new ReplacePiece(null, index);\n    };\n    return ReplacePiece;\n}());\nexports.ReplacePiece = ReplacePiece;\nvar ReplacePieceBuilder = /** @class */ (function () {\n    function ReplacePieceBuilder(source) {\n        this._source = source;\n        this._lastCharIndex = 0;\n        this._result = [];\n        this._resultLen = 0;\n        this._currentStaticPiece = '';\n    }\n    ReplacePieceBuilder.prototype.emitUnchanged = function (toCharIndex) {\n        this._emitStatic(this._source.substring(this._lastCharIndex, toCharIndex));\n        this._lastCharIndex = toCharIndex;\n    };\n    ReplacePieceBuilder.prototype.emitStatic = function (value, toCharIndex) {\n        this._emitStatic(value);\n        this._lastCharIndex = toCharIndex;\n    };\n    ReplacePieceBuilder.prototype._emitStatic = function (value) {\n        if (value.length === 0) {\n            return;\n        }\n        this._currentStaticPiece += value;\n    };\n    ReplacePieceBuilder.prototype.emitMatchIndex = function (index, toCharIndex) {\n        if (this._currentStaticPiece.length !== 0) {\n            this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);\n            this._currentStaticPiece = '';\n        }\n        this._result[this._resultLen++] = ReplacePiece.matchIndex(index);\n        this._lastCharIndex = toCharIndex;\n    };\n    ReplacePieceBuilder.prototype.finalize = function () {\n        this.emitUnchanged(this._source.length);\n        if (this._currentStaticPiece.length !== 0) {\n            this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);\n            this._currentStaticPiece = '';\n        }\n        return new ReplacePattern(this._result);\n    };\n    return ReplacePieceBuilder;\n}());\n/**\n * \\n\t\t\t=> inserts a LF\n * \\t\t\t\t=> inserts a TAB\n * \\\\\t\t\t=> inserts a \"\\\".\n * $$\t\t\t=> inserts a \"$\".\n * $& and $0\t=> inserts the matched substring.\n * $n\t\t\t=> Where n is a non-negative integer lesser than 100, inserts the nth parenthesized submatch string\n * everything else stays untouched\n *\n * Also see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter\n */\nfunction parseReplaceString(replaceString) {\n    if (!replaceString || replaceString.length === 0) {\n        return new ReplacePattern(null);\n    }\n    var result = new ReplacePieceBuilder(replaceString);\n    for (var i = 0, len = replaceString.length; i < len; i++) {\n        var chCode = replaceString.charCodeAt(i);\n        if (chCode === charCode_1.CharCode.Backslash) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a \\\n                break;\n            }\n            var nextChCode = replaceString.charCodeAt(i);\n            // let replaceWithCharacter: string | null = null;\n            switch (nextChCode) {\n                case charCode_1.CharCode.Backslash:\n                    // \\\\ => inserts a \"\\\"\n                    result.emitUnchanged(i - 1);\n                    result.emitStatic('\\\\', i + 1);\n                    break;\n                case charCode_1.CharCode.n:\n                    // \\n => inserts a LF\n                    result.emitUnchanged(i - 1);\n                    result.emitStatic('\\n', i + 1);\n                    break;\n                case charCode_1.CharCode.t:\n                    // \\t => inserts a TAB\n                    result.emitUnchanged(i - 1);\n                    result.emitStatic('\\t', i + 1);\n                    break;\n            }\n            continue;\n        }\n        if (chCode === charCode_1.CharCode.DollarSign) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a $\n                break;\n            }\n            var nextChCode = replaceString.charCodeAt(i);\n            if (nextChCode === charCode_1.CharCode.DollarSign) {\n                // $$ => inserts a \"$\"\n                result.emitUnchanged(i - 1);\n                result.emitStatic('$', i + 1);\n                continue;\n            }\n            if (nextChCode === charCode_1.CharCode.Digit0 || nextChCode === charCode_1.CharCode.Ampersand) {\n                // $& and $0 => inserts the matched substring.\n                result.emitUnchanged(i - 1);\n                result.emitMatchIndex(0, i + 1);\n                continue;\n            }\n            if (charCode_1.CharCode.Digit1 <= nextChCode && nextChCode <= charCode_1.CharCode.Digit9) {\n                // $n\n                var matchIndex = nextChCode - charCode_1.CharCode.Digit0;\n                // peek next char to probe for $nn\n                if (i + 1 < len) {\n                    var nextNextChCode = replaceString.charCodeAt(i + 1);\n                    if (charCode_1.CharCode.Digit0 <= nextNextChCode && nextNextChCode <= charCode_1.CharCode.Digit9) {\n                        // $nn\n                        // move to next char\n                        i++;\n                        matchIndex = matchIndex * 10 + (nextNextChCode - charCode_1.CharCode.Digit0);\n                        result.emitUnchanged(i - 2);\n                        result.emitMatchIndex(matchIndex, i + 1);\n                        continue;\n                    }\n                }\n                result.emitUnchanged(i - 1);\n                result.emitMatchIndex(matchIndex, i + 1);\n                continue;\n            }\n        }\n    }\n    return result.finalize();\n}\nexports.parseReplaceString = parseReplaceString;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/find/replacePattern.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/contrib/find/replacePattern.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\n\nconst enum ReplacePatternKind {\n\tStaticValue = 0,\n\tDynamicPieces = 1\n}\n\n/**\n * Assigned when the replace pattern is entirely static.\n */\nclass StaticValueReplacePattern {\n\tpublic readonly kind = ReplacePatternKind.StaticValue;\n\tconstructor(public readonly staticValue: string) { }\n}\n\n/**\n * Assigned when the replace pattern has replacemend patterns.\n */\nclass DynamicPiecesReplacePattern {\n\tpublic readonly kind = ReplacePatternKind.DynamicPieces;\n\tconstructor(public readonly pieces: ReplacePiece[]) { }\n}\n\nexport class ReplacePattern {\n\n\tpublic static fromStaticValue(value: string): ReplacePattern {\n\t\treturn new ReplacePattern([ReplacePiece.staticValue(value)]);\n\t}\n\n\tprivate readonly _state: StaticValueReplacePattern | DynamicPiecesReplacePattern;\n\n\tpublic get hasReplacementPatterns(): boolean {\n\t\treturn (this._state.kind === ReplacePatternKind.DynamicPieces);\n\t}\n\n\tconstructor(pieces: ReplacePiece[] | null) {\n\t\tif (!pieces || pieces.length === 0) {\n\t\t\tthis._state = new StaticValueReplacePattern('');\n\t\t} else if (pieces.length === 1 && pieces[0].staticValue !== null) {\n\t\t\tthis._state = new StaticValueReplacePattern(pieces[0].staticValue);\n\t\t} else {\n\t\t\tthis._state = new DynamicPiecesReplacePattern(pieces);\n\t\t}\n\t}\n\n\tpublic buildReplaceString(matches: string[] | null): string {\n\t\tif (this._state.kind === ReplacePatternKind.StaticValue) {\n\t\t\treturn this._state.staticValue;\n\t\t}\n\n\t\tlet result = '';\n\t\tfor (let i = 0, len = this._state.pieces.length; i < len; i++) {\n\t\t\tlet piece = this._state.pieces[i];\n\t\t\tif (piece.staticValue !== null) {\n\t\t\t\t// static value ReplacePiece\n\t\t\t\tresult += piece.staticValue;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// match index ReplacePiece\n\t\t\tresult += ReplacePattern._substitute(piece.matchIndex, matches);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _substitute(matchIndex: number, matches: string[] | null): string {\n\t\tif (matches === null) {\n\t\t\treturn '';\n\t\t}\n\t\tif (matchIndex === 0) {\n\t\t\treturn matches[0];\n\t\t}\n\n\t\tlet remainder = '';\n\t\twhile (matchIndex > 0) {\n\t\t\tif (matchIndex < matches.length) {\n\t\t\t\t// A match can be undefined\n\t\t\t\tlet match = (matches[matchIndex] || '');\n\t\t\t\treturn match + remainder;\n\t\t\t}\n\t\t\tremainder = String(matchIndex % 10) + remainder;\n\t\t\tmatchIndex = Math.floor(matchIndex / 10);\n\t\t}\n\t\treturn '$' + remainder;\n\t}\n}\n\n/**\n * A replace piece can either be a static string or an index to a specific match.\n */\nexport class ReplacePiece {\n\n\tpublic static staticValue(value: string): ReplacePiece {\n\t\treturn new ReplacePiece(value, -1);\n\t}\n\n\tpublic static matchIndex(index: number): ReplacePiece {\n\t\treturn new ReplacePiece(null, index);\n\t}\n\n\tpublic readonly staticValue: string | null;\n\tpublic readonly matchIndex: number;\n\n\tprivate constructor(staticValue: string | null, matchIndex: number) {\n\t\tthis.staticValue = staticValue;\n\t\tthis.matchIndex = matchIndex;\n\t}\n}\n\nclass ReplacePieceBuilder {\n\n\tprivate readonly _source: string;\n\tprivate _lastCharIndex: number;\n\tprivate readonly _result: ReplacePiece[];\n\tprivate _resultLen: number;\n\tprivate _currentStaticPiece: string;\n\n\tconstructor(source: string) {\n\t\tthis._source = source;\n\t\tthis._lastCharIndex = 0;\n\t\tthis._result = [];\n\t\tthis._resultLen = 0;\n\t\tthis._currentStaticPiece = '';\n\t}\n\n\tpublic emitUnchanged(toCharIndex: number): void {\n\t\tthis._emitStatic(this._source.substring(this._lastCharIndex, toCharIndex));\n\t\tthis._lastCharIndex = toCharIndex;\n\t}\n\n\tpublic emitStatic(value: string, toCharIndex: number): void {\n\t\tthis._emitStatic(value);\n\t\tthis._lastCharIndex = toCharIndex;\n\t}\n\n\tprivate _emitStatic(value: string): void {\n\t\tif (value.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis._currentStaticPiece += value;\n\t}\n\n\tpublic emitMatchIndex(index: number, toCharIndex: number): void {\n\t\tif (this._currentStaticPiece.length !== 0) {\n\t\t\tthis._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);\n\t\t\tthis._currentStaticPiece = '';\n\t\t}\n\t\tthis._result[this._resultLen++] = ReplacePiece.matchIndex(index);\n\t\tthis._lastCharIndex = toCharIndex;\n\t}\n\n\n\tpublic finalize(): ReplacePattern {\n\t\tthis.emitUnchanged(this._source.length);\n\t\tif (this._currentStaticPiece.length !== 0) {\n\t\t\tthis._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);\n\t\t\tthis._currentStaticPiece = '';\n\t\t}\n\t\treturn new ReplacePattern(this._result);\n\t}\n}\n\n/**\n * \\n\t\t\t=> inserts a LF\n * \\t\t\t\t=> inserts a TAB\n * \\\\\t\t\t=> inserts a \"\\\".\n * $$\t\t\t=> inserts a \"$\".\n * $& and $0\t=> inserts the matched substring.\n * $n\t\t\t=> Where n is a non-negative integer lesser than 100, inserts the nth parenthesized submatch string\n * everything else stays untouched\n *\n * Also see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter\n */\nexport function parseReplaceString(replaceString: string): ReplacePattern {\n\tif (!replaceString || replaceString.length === 0) {\n\t\treturn new ReplacePattern(null);\n\t}\n\n\tlet result = new ReplacePieceBuilder(replaceString);\n\n\tfor (let i = 0, len = replaceString.length; i < len; i++) {\n\t\tlet chCode = replaceString.charCodeAt(i);\n\n\t\tif (chCode === CharCode.Backslash) {\n\n\t\t\t// move to next char\n\t\t\ti++;\n\n\t\t\tif (i >= len) {\n\t\t\t\t// string ends with a \\\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet nextChCode = replaceString.charCodeAt(i);\n\t\t\t// let replaceWithCharacter: string | null = null;\n\n\t\t\tswitch (nextChCode) {\n\t\t\t\tcase CharCode.Backslash:\n\t\t\t\t\t// \\\\ => inserts a \"\\\"\n\t\t\t\t\tresult.emitUnchanged(i - 1);\n\t\t\t\t\tresult.emitStatic('\\\\', i + 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CharCode.n:\n\t\t\t\t\t// \\n => inserts a LF\n\t\t\t\t\tresult.emitUnchanged(i - 1);\n\t\t\t\t\tresult.emitStatic('\\n', i + 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CharCode.t:\n\t\t\t\t\t// \\t => inserts a TAB\n\t\t\t\t\tresult.emitUnchanged(i - 1);\n\t\t\t\t\tresult.emitStatic('\\t', i + 1);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (chCode === CharCode.DollarSign) {\n\n\t\t\t// move to next char\n\t\t\ti++;\n\n\t\t\tif (i >= len) {\n\t\t\t\t// string ends with a $\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet nextChCode = replaceString.charCodeAt(i);\n\n\t\t\tif (nextChCode === CharCode.DollarSign) {\n\t\t\t\t// $$ => inserts a \"$\"\n\t\t\t\tresult.emitUnchanged(i - 1);\n\t\t\t\tresult.emitStatic('$', i + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (nextChCode === CharCode.Digit0 || nextChCode === CharCode.Ampersand) {\n\t\t\t\t// $& and $0 => inserts the matched substring.\n\t\t\t\tresult.emitUnchanged(i - 1);\n\t\t\t\tresult.emitMatchIndex(0, i + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (CharCode.Digit1 <= nextChCode && nextChCode <= CharCode.Digit9) {\n\t\t\t\t// $n\n\n\t\t\t\tlet matchIndex = nextChCode - CharCode.Digit0;\n\n\t\t\t\t// peek next char to probe for $nn\n\t\t\t\tif (i + 1 < len) {\n\t\t\t\t\tlet nextNextChCode = replaceString.charCodeAt(i + 1);\n\t\t\t\t\tif (CharCode.Digit0 <= nextNextChCode && nextNextChCode <= CharCode.Digit9) {\n\t\t\t\t\t\t// $nn\n\n\t\t\t\t\t\t// move to next char\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tmatchIndex = matchIndex * 10 + (nextNextChCode - CharCode.Digit0);\n\n\t\t\t\t\t\tresult.emitUnchanged(i - 2);\n\t\t\t\t\t\tresult.emitMatchIndex(matchIndex, i + 1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult.emitUnchanged(i - 1);\n\t\t\t\tresult.emitMatchIndex(matchIndex, i + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result.finalize();\n}\n"]}]}