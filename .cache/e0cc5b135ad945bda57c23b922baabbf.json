{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/textMate/electron-browser/textMateService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/textMate/electron-browser/textMateService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar nls = require(\"vs/nls\");\nvar dom = require(\"vs/base/browser/dom\");\nvar color_1 = require(\"vs/base/common/color\");\nvar errors_1 = require(\"vs/base/common/errors\");\nvar event_1 = require(\"vs/base/common/event\");\nvar resources = require(\"vs/base/common/resources\");\nvar types = require(\"vs/base/common/types\");\nvar token_1 = require(\"vs/editor/common/core/token\");\nvar modes_1 = require(\"vs/editor/common/modes\");\nvar nullMode_1 = require(\"vs/editor/common/modes/nullMode\");\nvar tokenization_1 = require(\"vs/editor/common/modes/supports/tokenization\");\nvar modeService_1 = require(\"vs/editor/common/services/modeService\");\nvar files_1 = require(\"vs/platform/files/common/files\");\nvar log_1 = require(\"vs/platform/log/common/log\");\nvar notification_1 = require(\"vs/platform/notification/common/notification\");\nvar TMGrammars_1 = require(\"vs/workbench/services/textMate/common/TMGrammars\");\nvar textMateService_1 = require(\"vs/workbench/services/textMate/common/textMateService\");\nvar workbenchThemeService_1 = require(\"vs/workbench/services/themes/common/workbenchThemeService\");\nvar vscode_textmate_1 = require(\"vscode-textmate\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar configuration_1 = require(\"vs/platform/configuration/common/configuration\");\nvar extensions_1 = require(\"vs/platform/instantiation/common/extensions\");\nvar TMScopeRegistry = /** @class */ (function () {\n    function TMScopeRegistry() {\n        this._onDidEncounterLanguage = new event_1.Emitter();\n        this.onDidEncounterLanguage = this._onDidEncounterLanguage.event;\n        this.reset();\n    }\n    TMScopeRegistry.prototype.reset = function () {\n        this._scopeNameToLanguageRegistration = Object.create(null);\n        this._encounteredLanguages = [];\n    };\n    TMScopeRegistry.prototype.register = function (scopeName, grammarLocation, embeddedLanguages, tokenTypes) {\n        if (this._scopeNameToLanguageRegistration[scopeName]) {\n            var existingRegistration = this._scopeNameToLanguageRegistration[scopeName];\n            if (!resources.isEqual(existingRegistration.grammarLocation, grammarLocation)) {\n                console.warn(\"Overwriting grammar scope name to file mapping for scope \" + scopeName + \".\\n\" +\n                    (\"Old grammar file: \" + existingRegistration.grammarLocation.toString() + \".\\n\") +\n                    (\"New grammar file: \" + grammarLocation.toString()));\n            }\n        }\n        this._scopeNameToLanguageRegistration[scopeName] = new TMLanguageRegistration(scopeName, grammarLocation, embeddedLanguages, tokenTypes);\n    };\n    TMScopeRegistry.prototype.getLanguageRegistration = function (scopeName) {\n        return this._scopeNameToLanguageRegistration[scopeName] || null;\n    };\n    TMScopeRegistry.prototype.getGrammarLocation = function (scopeName) {\n        var data = this.getLanguageRegistration(scopeName);\n        return data ? data.grammarLocation : null;\n    };\n    /**\n     * To be called when tokenization found/hit an embedded language.\n     */\n    TMScopeRegistry.prototype.onEncounteredLanguage = function (languageId) {\n        if (!this._encounteredLanguages[languageId]) {\n            this._encounteredLanguages[languageId] = true;\n            this._onDidEncounterLanguage.fire(languageId);\n        }\n    };\n    return TMScopeRegistry;\n}());\nexports.TMScopeRegistry = TMScopeRegistry;\nvar TMLanguageRegistration = /** @class */ (function () {\n    function TMLanguageRegistration(scopeName, grammarLocation, embeddedLanguages, tokenTypes) {\n        this.scopeName = scopeName;\n        this.grammarLocation = grammarLocation;\n        // embeddedLanguages handling\n        this.embeddedLanguages = Object.create(null);\n        if (embeddedLanguages) {\n            // If embeddedLanguages are configured, fill in `this._embeddedLanguages`\n            var scopes = Object.keys(embeddedLanguages);\n            for (var i = 0, len = scopes.length; i < len; i++) {\n                var scope = scopes[i];\n                var language = embeddedLanguages[scope];\n                if (typeof language !== 'string') {\n                    // never hurts to be too careful\n                    continue;\n                }\n                this.embeddedLanguages[scope] = language;\n            }\n        }\n        this.tokenTypes = Object.create(null);\n        if (tokenTypes) {\n            // If tokenTypes is configured, fill in `this._tokenTypes`\n            var scopes = Object.keys(tokenTypes);\n            for (var _i = 0, scopes_1 = scopes; _i < scopes_1.length; _i++) {\n                var scope = scopes_1[_i];\n                var tokenType = tokenTypes[scope];\n                switch (tokenType) {\n                    case 'string':\n                        this.tokenTypes[scope] = vscode_textmate_1.StandardTokenType.String;\n                        break;\n                    case 'other':\n                        this.tokenTypes[scope] = vscode_textmate_1.StandardTokenType.Other;\n                        break;\n                    case 'comment':\n                        this.tokenTypes[scope] = vscode_textmate_1.StandardTokenType.Comment;\n                        break;\n                }\n            }\n        }\n    }\n    return TMLanguageRegistration;\n}());\nexports.TMLanguageRegistration = TMLanguageRegistration;\nvar TextMateService = /** @class */ (function (_super) {\n    tslib_1.__extends(TextMateService, _super);\n    function TextMateService(_modeService, _themeService, _fileService, _notificationService, _logService, _configurationService) {\n        var _this = _super.call(this) || this;\n        _this._modeService = _modeService;\n        _this._themeService = _themeService;\n        _this._fileService = _fileService;\n        _this._notificationService = _notificationService;\n        _this._logService = _logService;\n        _this._configurationService = _configurationService;\n        _this._onDidEncounterLanguage = _this._register(new event_1.Emitter());\n        _this.onDidEncounterLanguage = _this._onDidEncounterLanguage.event;\n        _this._styleElement = dom.createStyleSheet();\n        _this._styleElement.className = 'vscode-tokens-styles';\n        _this._createdModes = [];\n        _this._scopeRegistry = new TMScopeRegistry();\n        _this._scopeRegistry.onDidEncounterLanguage(function (language) { return _this._onDidEncounterLanguage.fire(language); });\n        _this._injections = {};\n        _this._injectedEmbeddedLanguages = {};\n        _this._languageToScope = new Map();\n        _this._grammarRegistry = null;\n        _this._tokenizersRegistrations = [];\n        _this._currentTokenColors = null;\n        _this._themeListener = null;\n        TMGrammars_1.grammarsExtPoint.setHandler(function (extensions) {\n            _this._scopeRegistry.reset();\n            _this._injections = {};\n            _this._injectedEmbeddedLanguages = {};\n            _this._languageToScope = new Map();\n            _this._grammarRegistry = null;\n            _this._tokenizersRegistrations = lifecycle_1.dispose(_this._tokenizersRegistrations);\n            _this._currentTokenColors = null;\n            if (_this._themeListener) {\n                _this._themeListener.dispose();\n                _this._themeListener = null;\n            }\n            for (var _i = 0, extensions_2 = extensions; _i < extensions_2.length; _i++) {\n                var extension = extensions_2[_i];\n                var grammars = extension.value;\n                for (var _a = 0, grammars_1 = grammars; _a < grammars_1.length; _a++) {\n                    var grammar = grammars_1[_a];\n                    _this._handleGrammarExtensionPointUser(extension.description.extensionLocation, grammar, extension.collector);\n                }\n            }\n            for (var _b = 0, _c = _this._createdModes; _b < _c.length; _b++) {\n                var createMode = _c[_b];\n                _this._registerDefinitionIfAvailable(createMode);\n            }\n        });\n        // Generate some color map until the grammar registry is loaded\n        var colorTheme = _this._themeService.getColorTheme();\n        var defaultForeground = color_1.Color.transparent;\n        var defaultBackground = color_1.Color.transparent;\n        for (var i = 0, len = colorTheme.tokenColors.length; i < len; i++) {\n            var rule = colorTheme.tokenColors[i];\n            if (!rule.scope && rule.settings) {\n                if (rule.settings.foreground) {\n                    defaultForeground = color_1.Color.fromHex(rule.settings.foreground);\n                }\n                if (rule.settings.background) {\n                    defaultBackground = color_1.Color.fromHex(rule.settings.background);\n                }\n            }\n        }\n        modes_1.TokenizationRegistry.setColorMap([null, defaultForeground, defaultBackground]);\n        _this._modeService.onDidCreateMode(function (mode) {\n            var modeId = mode.getId();\n            _this._createdModes.push(modeId);\n            _this._registerDefinitionIfAvailable(modeId);\n        });\n        return _this;\n    }\n    TextMateService.prototype._registerDefinitionIfAvailable = function (modeId) {\n        var _this = this;\n        if (this._languageToScope.has(modeId)) {\n            var promise = this._createGrammar(modeId).then(function (r) {\n                return new TMTokenization(_this._scopeRegistry, r.languageId, r.grammar, r.initialState, r.containsEmbeddedLanguages, _this._notificationService, _this._configurationService);\n            }, function (e) {\n                errors_1.onUnexpectedError(e);\n                return null;\n            });\n            this._tokenizersRegistrations.push(modes_1.TokenizationRegistry.registerPromise(modeId, promise));\n        }\n    };\n    TextMateService.prototype._createGrammarRegistry = function () {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var _a, Registry, INITIAL, parseRawGrammar, grammarRegistry;\n            var _this = this;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Promise.resolve().then(function () { return require('vscode-textmate'); })];\n                    case 1:\n                        _a = _b.sent(), Registry = _a.Registry, INITIAL = _a.INITIAL, parseRawGrammar = _a.parseRawGrammar;\n                        grammarRegistry = new Registry({\n                            loadGrammar: function (scopeName) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                                var location, content, e_1;\n                                return tslib_1.__generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0:\n                                            location = this._scopeRegistry.getGrammarLocation(scopeName);\n                                            if (!location) {\n                                                this._logService.trace(\"No grammar found for scope \" + scopeName);\n                                                return [2 /*return*/, null];\n                                            }\n                                            _a.label = 1;\n                                        case 1:\n                                            _a.trys.push([1, 3, , 4]);\n                                            return [4 /*yield*/, this._fileService.resolveContent(location, { encoding: 'utf8' })];\n                                        case 2:\n                                            content = _a.sent();\n                                            return [2 /*return*/, parseRawGrammar(content.value, location.path)];\n                                        case 3:\n                                            e_1 = _a.sent();\n                                            this._logService.error(\"Unable to load and parse grammar for scope \" + scopeName + \" from \" + location, e_1);\n                                            return [2 /*return*/, null];\n                                        case 4: return [2 /*return*/];\n                                    }\n                                });\n                            }); },\n                            getInjections: function (scopeName) {\n                                var scopeParts = scopeName.split('.');\n                                var injections = [];\n                                for (var i = 1; i <= scopeParts.length; i++) {\n                                    var subScopeName = scopeParts.slice(0, i).join('.');\n                                    injections = injections.concat((_this._injections[subScopeName] || []));\n                                }\n                                return injections;\n                            }\n                        });\n                        this._updateTheme(grammarRegistry);\n                        this._themeListener = this._themeService.onDidColorThemeChange(function (e) { return _this._updateTheme(grammarRegistry); });\n                        return [2 /*return*/, [grammarRegistry, INITIAL]];\n                }\n            });\n        });\n    };\n    TextMateService.prototype._getOrCreateGrammarRegistry = function () {\n        if (!this._grammarRegistry) {\n            this._grammarRegistry = this._createGrammarRegistry();\n        }\n        return this._grammarRegistry;\n    };\n    TextMateService._toColorMap = function (colorMap) {\n        var result = [null];\n        for (var i = 1, len = colorMap.length; i < len; i++) {\n            result[i] = color_1.Color.fromHex(colorMap[i]);\n        }\n        return result;\n    };\n    TextMateService.prototype._updateTheme = function (grammarRegistry) {\n        var colorTheme = this._themeService.getColorTheme();\n        if (!this.compareTokenRules(colorTheme.tokenColors)) {\n            return;\n        }\n        grammarRegistry.setTheme({ name: colorTheme.label, settings: colorTheme.tokenColors });\n        var colorMap = TextMateService._toColorMap(grammarRegistry.getColorMap());\n        var cssRules = tokenization_1.generateTokensCSSForColorMap(colorMap);\n        this._styleElement.innerHTML = cssRules;\n        modes_1.TokenizationRegistry.setColorMap(colorMap);\n    };\n    TextMateService.prototype.compareTokenRules = function (newRules) {\n        var currRules = this._currentTokenColors;\n        this._currentTokenColors = newRules;\n        if (!newRules || !currRules || newRules.length !== currRules.length) {\n            return true;\n        }\n        for (var i = newRules.length - 1; i >= 0; i--) {\n            var r1 = newRules[i];\n            var r2 = currRules[i];\n            if (r1.scope !== r2.scope) {\n                return true;\n            }\n            var s1 = r1.settings;\n            var s2 = r2.settings;\n            if (s1 && s2) {\n                if (s1.fontStyle !== s2.fontStyle || s1.foreground !== s2.foreground || s1.background !== s2.background) {\n                    return true;\n                }\n            }\n            else if (!s1 || !s2) {\n                return true;\n            }\n        }\n        return false;\n    };\n    TextMateService.prototype._handleGrammarExtensionPointUser = function (extensionLocation, syntax, collector) {\n        if (syntax.language && ((typeof syntax.language !== 'string') || !this._modeService.isRegisteredMode(syntax.language))) {\n            collector.error(nls.localize('invalid.language', \"Unknown language in `contributes.{0}.language`. Provided value: {1}\", TMGrammars_1.grammarsExtPoint.name, String(syntax.language)));\n            return;\n        }\n        if (!syntax.scopeName || (typeof syntax.scopeName !== 'string')) {\n            collector.error(nls.localize('invalid.scopeName', \"Expected string in `contributes.{0}.scopeName`. Provided value: {1}\", TMGrammars_1.grammarsExtPoint.name, String(syntax.scopeName)));\n            return;\n        }\n        if (!syntax.path || (typeof syntax.path !== 'string')) {\n            collector.error(nls.localize('invalid.path.0', \"Expected string in `contributes.{0}.path`. Provided value: {1}\", TMGrammars_1.grammarsExtPoint.name, String(syntax.path)));\n            return;\n        }\n        if (syntax.injectTo && (!Array.isArray(syntax.injectTo) || syntax.injectTo.some(function (scope) { return typeof scope !== 'string'; }))) {\n            collector.error(nls.localize('invalid.injectTo', \"Invalid value in `contributes.{0}.injectTo`. Must be an array of language scope names. Provided value: {1}\", TMGrammars_1.grammarsExtPoint.name, JSON.stringify(syntax.injectTo)));\n            return;\n        }\n        if (syntax.embeddedLanguages && !types.isObject(syntax.embeddedLanguages)) {\n            collector.error(nls.localize('invalid.embeddedLanguages', \"Invalid value in `contributes.{0}.embeddedLanguages`. Must be an object map from scope name to language. Provided value: {1}\", TMGrammars_1.grammarsExtPoint.name, JSON.stringify(syntax.embeddedLanguages)));\n            return;\n        }\n        if (syntax.tokenTypes && !types.isObject(syntax.tokenTypes)) {\n            collector.error(nls.localize('invalid.tokenTypes', \"Invalid value in `contributes.{0}.tokenTypes`. Must be an object map from scope name to token type. Provided value: {1}\", TMGrammars_1.grammarsExtPoint.name, JSON.stringify(syntax.tokenTypes)));\n            return;\n        }\n        var grammarLocation = resources.joinPath(extensionLocation, syntax.path);\n        if (!resources.isEqualOrParent(grammarLocation, extensionLocation)) {\n            collector.warn(nls.localize('invalid.path.1', \"Expected `contributes.{0}.path` ({1}) to be included inside extension's folder ({2}). This might make the extension non-portable.\", TMGrammars_1.grammarsExtPoint.name, grammarLocation.path, extensionLocation.path));\n        }\n        this._scopeRegistry.register(syntax.scopeName, grammarLocation, syntax.embeddedLanguages, syntax.tokenTypes);\n        if (syntax.injectTo) {\n            for (var _i = 0, _a = syntax.injectTo; _i < _a.length; _i++) {\n                var injectScope = _a[_i];\n                var injections = this._injections[injectScope];\n                if (!injections) {\n                    this._injections[injectScope] = injections = [];\n                }\n                injections.push(syntax.scopeName);\n            }\n            if (syntax.embeddedLanguages) {\n                for (var _b = 0, _c = syntax.injectTo; _b < _c.length; _b++) {\n                    var injectScope = _c[_b];\n                    var injectedEmbeddedLanguages = this._injectedEmbeddedLanguages[injectScope];\n                    if (!injectedEmbeddedLanguages) {\n                        this._injectedEmbeddedLanguages[injectScope] = injectedEmbeddedLanguages = [];\n                    }\n                    injectedEmbeddedLanguages.push(syntax.embeddedLanguages);\n                }\n            }\n        }\n        var modeId = syntax.language;\n        if (modeId) {\n            this._languageToScope.set(modeId, syntax.scopeName);\n        }\n    };\n    TextMateService.prototype._resolveEmbeddedLanguages = function (embeddedLanguages) {\n        var scopes = Object.keys(embeddedLanguages);\n        var result = Object.create(null);\n        for (var i = 0, len = scopes.length; i < len; i++) {\n            var scope = scopes[i];\n            var language = embeddedLanguages[scope];\n            var languageIdentifier = this._modeService.getLanguageIdentifier(language);\n            if (languageIdentifier) {\n                result[scope] = languageIdentifier.id;\n            }\n        }\n        return result;\n    };\n    TextMateService.prototype.createGrammar = function (modeId) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var grammar;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._createGrammar(modeId)];\n                    case 1:\n                        grammar = (_a.sent()).grammar;\n                        return [2 /*return*/, grammar];\n                }\n            });\n        });\n    };\n    TextMateService.prototype._createGrammar = function (modeId) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var scopeName, languageRegistration, embeddedLanguages, rawInjectedEmbeddedLanguages, injectedEmbeddedLanguages, _i, injectedEmbeddedLanguages_1, injected, _a, _b, scope, languageId, containsEmbeddedLanguages, _c, grammarRegistry, initialState, grammar;\n            return tslib_1.__generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        scopeName = this._languageToScope.get(modeId);\n                        if (typeof scopeName !== 'string') {\n                            // No TM grammar defined\n                            return [2 /*return*/, Promise.reject(new Error(nls.localize('no-tm-grammar', \"No TM Grammar registered for this language.\")))];\n                        }\n                        languageRegistration = this._scopeRegistry.getLanguageRegistration(scopeName);\n                        if (!languageRegistration) {\n                            // No TM grammar defined\n                            return [2 /*return*/, Promise.reject(new Error(nls.localize('no-tm-grammar', \"No TM Grammar registered for this language.\")))];\n                        }\n                        embeddedLanguages = this._resolveEmbeddedLanguages(languageRegistration.embeddedLanguages);\n                        rawInjectedEmbeddedLanguages = this._injectedEmbeddedLanguages[scopeName];\n                        if (rawInjectedEmbeddedLanguages) {\n                            injectedEmbeddedLanguages = rawInjectedEmbeddedLanguages.map(this._resolveEmbeddedLanguages.bind(this));\n                            for (_i = 0, injectedEmbeddedLanguages_1 = injectedEmbeddedLanguages; _i < injectedEmbeddedLanguages_1.length; _i++) {\n                                injected = injectedEmbeddedLanguages_1[_i];\n                                for (_a = 0, _b = Object.keys(injected); _a < _b.length; _a++) {\n                                    scope = _b[_a];\n                                    embeddedLanguages[scope] = injected[scope];\n                                }\n                            }\n                        }\n                        languageId = this._modeService.getLanguageIdentifier(modeId).id;\n                        containsEmbeddedLanguages = (Object.keys(embeddedLanguages).length > 0);\n                        return [4 /*yield*/, this._getOrCreateGrammarRegistry()];\n                    case 1:\n                        _c = _d.sent(), grammarRegistry = _c[0], initialState = _c[1];\n                        return [4 /*yield*/, grammarRegistry.loadGrammarWithConfiguration(scopeName, languageId, { embeddedLanguages: embeddedLanguages, tokenTypes: languageRegistration.tokenTypes })];\n                    case 2:\n                        grammar = _d.sent();\n                        return [2 /*return*/, {\n                                languageId: languageId,\n                                grammar: grammar,\n                                initialState: initialState,\n                                containsEmbeddedLanguages: containsEmbeddedLanguages\n                            }];\n                }\n            });\n        });\n    };\n    TextMateService = tslib_1.__decorate([\n        tslib_1.__param(0, modeService_1.IModeService),\n        tslib_1.__param(1, workbenchThemeService_1.IWorkbenchThemeService),\n        tslib_1.__param(2, files_1.IFileService),\n        tslib_1.__param(3, notification_1.INotificationService),\n        tslib_1.__param(4, log_1.ILogService),\n        tslib_1.__param(5, configuration_1.IConfigurationService)\n    ], TextMateService);\n    return TextMateService;\n}(lifecycle_1.Disposable));\nexports.TextMateService = TextMateService;\nvar TMTokenization = /** @class */ (function () {\n    function TMTokenization(scopeRegistry, languageId, grammar, initialState, containsEmbeddedLanguages, notificationService, configurationService) {\n        this.notificationService = notificationService;\n        this.configurationService = configurationService;\n        this._scopeRegistry = scopeRegistry;\n        this._languageId = languageId;\n        this._grammar = grammar;\n        this._initialState = initialState;\n        this._containsEmbeddedLanguages = containsEmbeddedLanguages;\n        this._seenLanguages = [];\n        this._maxTokenizationLineLength = configurationService.getValue('editor.maxTokenizationLineLength');\n    }\n    TMTokenization.prototype.getInitialState = function () {\n        return this._initialState;\n    };\n    TMTokenization.prototype.tokenize = function (line, state, offsetDelta) {\n        throw new Error('Not supported!');\n    };\n    TMTokenization.prototype.tokenize2 = function (line, state, offsetDelta) {\n        if (offsetDelta !== 0) {\n            throw new Error('Unexpected: offsetDelta should be 0.');\n        }\n        // Do not attempt to tokenize if a line is too long\n        if (line.length >= this._maxTokenizationLineLength) {\n            if (!this._tokenizationWarningAlreadyShown) {\n                this._tokenizationWarningAlreadyShown = true;\n                this.notificationService.warn(nls.localize('too many characters', \"Tokenization is skipped for long lines for performance reasons. The length of a long line can be configured via `editor.maxTokenizationLineLength`.\"));\n            }\n            console.log(\"Line (\" + line.substr(0, 15) + \"...): longer than \" + this._maxTokenizationLineLength + \" characters, tokenization skipped.\");\n            return nullMode_1.nullTokenize2(this._languageId, line, state, offsetDelta);\n        }\n        var textMateResult = this._grammar.tokenizeLine2(line, state);\n        if (this._containsEmbeddedLanguages) {\n            var seenLanguages = this._seenLanguages;\n            var tokens = textMateResult.tokens;\n            // Must check if any of the embedded languages was hit\n            for (var i = 0, len = (tokens.length >>> 1); i < len; i++) {\n                var metadata = tokens[(i << 1) + 1];\n                var languageId = modes_1.TokenMetadata.getLanguageId(metadata);\n                if (!seenLanguages[languageId]) {\n                    seenLanguages[languageId] = true;\n                    this._scopeRegistry.onEncounteredLanguage(languageId);\n                }\n            }\n        }\n        var endState;\n        // try to save an object if possible\n        if (state.equals(textMateResult.ruleStack)) {\n            endState = state;\n        }\n        else {\n            endState = textMateResult.ruleStack;\n        }\n        return new token_1.TokenizationResult2(textMateResult.tokens, endState);\n    };\n    TMTokenization = tslib_1.__decorate([\n        tslib_1.__param(5, notification_1.INotificationService), tslib_1.__param(6, configuration_1.IConfigurationService)\n    ], TMTokenization);\n    return TMTokenization;\n}());\nextensions_1.registerSingleton(textMateService_1.ITextMateService, TextMateService);\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/textMate/electron-browser/textMateService.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/textMate/electron-browser/textMateService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\nimport * as dom from 'vs/base/browser/dom';\nimport { Color } from 'vs/base/common/color';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport * as resources from 'vs/base/common/resources';\nimport * as types from 'vs/base/common/types';\nimport { URI } from 'vs/base/common/uri';\nimport { TokenizationResult, TokenizationResult2 } from 'vs/editor/common/core/token';\nimport { IState, ITokenizationSupport, LanguageId, TokenMetadata, TokenizationRegistry } from 'vs/editor/common/modes';\nimport { nullTokenize2 } from 'vs/editor/common/modes/nullMode';\nimport { generateTokensCSSForColorMap } from 'vs/editor/common/modes/supports/tokenization';\nimport { IModeService } from 'vs/editor/common/services/modeService';\nimport { IFileService } from 'vs/platform/files/common/files';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { INotificationService } from 'vs/platform/notification/common/notification';\nimport { ExtensionMessageCollector } from 'vs/workbench/services/extensions/common/extensionsRegistry';\nimport { IEmbeddedLanguagesMap, ITMSyntaxExtensionPoint, TokenTypesContribution, grammarsExtPoint } from 'vs/workbench/services/textMate/common/TMGrammars';\nimport { ITextMateService } from 'vs/workbench/services/textMate/common/textMateService';\nimport { ITokenColorizationRule, IWorkbenchThemeService } from 'vs/workbench/services/themes/common/workbenchThemeService';\nimport { IEmbeddedLanguagesMap as IEmbeddedLanguagesMap2, IGrammar, ITokenTypeMap, Registry, StackElement, StandardTokenType } from 'vscode-textmate';\nimport { Disposable, IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { registerSingleton } from 'vs/platform/instantiation/common/extensions';\n\nexport class TMScopeRegistry {\n\n\tprivate _scopeNameToLanguageRegistration: { [scopeName: string]: TMLanguageRegistration; };\n\tprivate _encounteredLanguages: boolean[];\n\n\tprivate readonly _onDidEncounterLanguage = new Emitter<LanguageId>();\n\tpublic readonly onDidEncounterLanguage: Event<LanguageId> = this._onDidEncounterLanguage.event;\n\n\tconstructor() {\n\t\tthis.reset();\n\t}\n\n\tpublic reset(): void {\n\t\tthis._scopeNameToLanguageRegistration = Object.create(null);\n\t\tthis._encounteredLanguages = [];\n\t}\n\n\tpublic register(scopeName: string, grammarLocation: URI, embeddedLanguages?: IEmbeddedLanguagesMap, tokenTypes?: TokenTypesContribution): void {\n\t\tif (this._scopeNameToLanguageRegistration[scopeName]) {\n\t\t\tconst existingRegistration = this._scopeNameToLanguageRegistration[scopeName];\n\t\t\tif (!resources.isEqual(existingRegistration.grammarLocation, grammarLocation)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Overwriting grammar scope name to file mapping for scope ${scopeName}.\\n` +\n\t\t\t\t\t`Old grammar file: ${existingRegistration.grammarLocation.toString()}.\\n` +\n\t\t\t\t\t`New grammar file: ${grammarLocation.toString()}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tthis._scopeNameToLanguageRegistration[scopeName] = new TMLanguageRegistration(scopeName, grammarLocation, embeddedLanguages, tokenTypes);\n\t}\n\n\tpublic getLanguageRegistration(scopeName: string): TMLanguageRegistration {\n\t\treturn this._scopeNameToLanguageRegistration[scopeName] || null;\n\t}\n\n\tpublic getGrammarLocation(scopeName: string): URI | null {\n\t\tlet data = this.getLanguageRegistration(scopeName);\n\t\treturn data ? data.grammarLocation : null;\n\t}\n\n\t/**\n\t * To be called when tokenization found/hit an embedded language.\n\t */\n\tpublic onEncounteredLanguage(languageId: LanguageId): void {\n\t\tif (!this._encounteredLanguages[languageId]) {\n\t\t\tthis._encounteredLanguages[languageId] = true;\n\t\t\tthis._onDidEncounterLanguage.fire(languageId);\n\t\t}\n\t}\n}\n\nexport class TMLanguageRegistration {\n\t_topLevelScopeNameDataBrand: void;\n\n\treadonly scopeName: string;\n\treadonly grammarLocation: URI;\n\treadonly embeddedLanguages: IEmbeddedLanguagesMap;\n\treadonly tokenTypes: ITokenTypeMap;\n\n\tconstructor(scopeName: string, grammarLocation: URI, embeddedLanguages: IEmbeddedLanguagesMap | undefined, tokenTypes: TokenTypesContribution | undefined) {\n\t\tthis.scopeName = scopeName;\n\t\tthis.grammarLocation = grammarLocation;\n\n\t\t// embeddedLanguages handling\n\t\tthis.embeddedLanguages = Object.create(null);\n\n\t\tif (embeddedLanguages) {\n\t\t\t// If embeddedLanguages are configured, fill in `this._embeddedLanguages`\n\t\t\tlet scopes = Object.keys(embeddedLanguages);\n\t\t\tfor (let i = 0, len = scopes.length; i < len; i++) {\n\t\t\t\tlet scope = scopes[i];\n\t\t\t\tlet language = embeddedLanguages[scope];\n\t\t\t\tif (typeof language !== 'string') {\n\t\t\t\t\t// never hurts to be too careful\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis.embeddedLanguages[scope] = language;\n\t\t\t}\n\t\t}\n\n\t\tthis.tokenTypes = Object.create(null);\n\t\tif (tokenTypes) {\n\t\t\t// If tokenTypes is configured, fill in `this._tokenTypes`\n\t\t\tconst scopes = Object.keys(tokenTypes);\n\t\t\tfor (const scope of scopes) {\n\t\t\t\tconst tokenType = tokenTypes[scope];\n\t\t\t\tswitch (tokenType) {\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tthis.tokenTypes[scope] = StandardTokenType.String;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'other':\n\t\t\t\t\t\tthis.tokenTypes[scope] = StandardTokenType.Other;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'comment':\n\t\t\t\t\t\tthis.tokenTypes[scope] = StandardTokenType.Comment;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninterface ICreateGrammarResult {\n\tlanguageId: LanguageId;\n\tgrammar: IGrammar;\n\tinitialState: StackElement;\n\tcontainsEmbeddedLanguages: boolean;\n}\n\nexport class TextMateService extends Disposable implements ITextMateService {\n\tpublic _serviceBrand: any;\n\n\tprivate readonly _onDidEncounterLanguage: Emitter<LanguageId> = this._register(new Emitter<LanguageId>());\n\tpublic readonly onDidEncounterLanguage: Event<LanguageId> = this._onDidEncounterLanguage.event;\n\n\tprivate readonly _styleElement: HTMLStyleElement;\n\tprivate readonly _createdModes: string[];\n\n\tprivate _scopeRegistry: TMScopeRegistry;\n\tprivate _injections: { [scopeName: string]: string[]; };\n\tprivate _injectedEmbeddedLanguages: { [scopeName: string]: IEmbeddedLanguagesMap[]; };\n\tprivate _languageToScope: Map<string, string>;\n\tprivate _grammarRegistry: Promise<[Registry, StackElement]> | null;\n\tprivate _tokenizersRegistrations: IDisposable[];\n\tprivate _currentTokenColors: ITokenColorizationRule[] | null;\n\tprivate _themeListener: IDisposable | null;\n\n\tconstructor(\n\t\t@IModeService private readonly _modeService: IModeService,\n\t\t@IWorkbenchThemeService private readonly _themeService: IWorkbenchThemeService,\n\t\t@IFileService private readonly _fileService: IFileService,\n\t\t@INotificationService private readonly _notificationService: INotificationService,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IConfigurationService private readonly _configurationService: IConfigurationService\n\t) {\n\t\tsuper();\n\t\tthis._styleElement = dom.createStyleSheet();\n\t\tthis._styleElement.className = 'vscode-tokens-styles';\n\t\tthis._createdModes = [];\n\t\tthis._scopeRegistry = new TMScopeRegistry();\n\t\tthis._scopeRegistry.onDidEncounterLanguage((language) => this._onDidEncounterLanguage.fire(language));\n\t\tthis._injections = {};\n\t\tthis._injectedEmbeddedLanguages = {};\n\t\tthis._languageToScope = new Map<string, string>();\n\t\tthis._grammarRegistry = null;\n\t\tthis._tokenizersRegistrations = [];\n\t\tthis._currentTokenColors = null;\n\t\tthis._themeListener = null;\n\n\t\tgrammarsExtPoint.setHandler((extensions) => {\n\t\t\tthis._scopeRegistry.reset();\n\t\t\tthis._injections = {};\n\t\t\tthis._injectedEmbeddedLanguages = {};\n\t\t\tthis._languageToScope = new Map<string, string>();\n\t\t\tthis._grammarRegistry = null;\n\t\t\tthis._tokenizersRegistrations = dispose(this._tokenizersRegistrations);\n\t\t\tthis._currentTokenColors = null;\n\t\t\tif (this._themeListener) {\n\t\t\t\tthis._themeListener.dispose();\n\t\t\t\tthis._themeListener = null;\n\t\t\t}\n\n\t\t\tfor (const extension of extensions) {\n\t\t\t\tlet grammars = extension.value;\n\t\t\t\tfor (const grammar of grammars) {\n\t\t\t\t\tthis._handleGrammarExtensionPointUser(extension.description.extensionLocation, grammar, extension.collector);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const createMode of this._createdModes) {\n\t\t\t\tthis._registerDefinitionIfAvailable(createMode);\n\t\t\t}\n\t\t});\n\n\t\t// Generate some color map until the grammar registry is loaded\n\t\tlet colorTheme = this._themeService.getColorTheme();\n\t\tlet defaultForeground: Color = Color.transparent;\n\t\tlet defaultBackground: Color = Color.transparent;\n\t\tfor (let i = 0, len = colorTheme.tokenColors.length; i < len; i++) {\n\t\t\tlet rule = colorTheme.tokenColors[i];\n\t\t\tif (!rule.scope && rule.settings) {\n\t\t\t\tif (rule.settings.foreground) {\n\t\t\t\t\tdefaultForeground = Color.fromHex(rule.settings.foreground);\n\t\t\t\t}\n\t\t\t\tif (rule.settings.background) {\n\t\t\t\t\tdefaultBackground = Color.fromHex(rule.settings.background);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tTokenizationRegistry.setColorMap([null!, defaultForeground, defaultBackground]);\n\n\t\tthis._modeService.onDidCreateMode((mode) => {\n\t\t\tlet modeId = mode.getId();\n\t\t\tthis._createdModes.push(modeId);\n\t\t\tthis._registerDefinitionIfAvailable(modeId);\n\t\t});\n\t}\n\n\tprivate _registerDefinitionIfAvailable(modeId: string): void {\n\t\tif (this._languageToScope.has(modeId)) {\n\t\t\tconst promise = this._createGrammar(modeId).then((r) => {\n\t\t\t\treturn new TMTokenization(this._scopeRegistry, r.languageId, r.grammar, r.initialState, r.containsEmbeddedLanguages, this._notificationService, this._configurationService);\n\t\t\t}, e => {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\treturn null;\n\t\t\t});\n\t\t\tthis._tokenizersRegistrations.push(TokenizationRegistry.registerPromise(modeId, promise));\n\t\t}\n\t}\n\n\tprivate async _createGrammarRegistry(): Promise<[Registry, StackElement]> {\n\t\tconst { Registry, INITIAL, parseRawGrammar } = await import('vscode-textmate');\n\t\tconst grammarRegistry = new Registry({\n\t\t\tloadGrammar: async (scopeName: string) => {\n\t\t\t\tconst location = this._scopeRegistry.getGrammarLocation(scopeName);\n\t\t\t\tif (!location) {\n\t\t\t\t\tthis._logService.trace(`No grammar found for scope ${scopeName}`);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tconst content = await this._fileService.resolveContent(location, { encoding: 'utf8' });\n\t\t\t\t\treturn parseRawGrammar(content.value, location.path);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis._logService.error(`Unable to load and parse grammar for scope ${scopeName} from ${location}`, e);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetInjections: (scopeName: string) => {\n\t\t\t\tconst scopeParts = scopeName.split('.');\n\t\t\t\tlet injections: string[] = [];\n\t\t\t\tfor (let i = 1; i <= scopeParts.length; i++) {\n\t\t\t\t\tconst subScopeName = scopeParts.slice(0, i).join('.');\n\t\t\t\t\tinjections = [...injections, ...(this._injections[subScopeName] || [])];\n\t\t\t\t}\n\t\t\t\treturn injections;\n\t\t\t}\n\t\t});\n\t\tthis._updateTheme(grammarRegistry);\n\t\tthis._themeListener = this._themeService.onDidColorThemeChange((e) => this._updateTheme(grammarRegistry));\n\t\treturn <[Registry, StackElement]>[grammarRegistry, INITIAL];\n\t}\n\n\tprivate _getOrCreateGrammarRegistry(): Promise<[Registry, StackElement]> {\n\t\tif (!this._grammarRegistry) {\n\t\t\tthis._grammarRegistry = this._createGrammarRegistry();\n\t\t}\n\t\treturn this._grammarRegistry;\n\t}\n\n\tprivate static _toColorMap(colorMap: string[]): Color[] {\n\t\tlet result: Color[] = [null!];\n\t\tfor (let i = 1, len = colorMap.length; i < len; i++) {\n\t\t\tresult[i] = Color.fromHex(colorMap[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _updateTheme(grammarRegistry: Registry): void {\n\t\tlet colorTheme = this._themeService.getColorTheme();\n\t\tif (!this.compareTokenRules(colorTheme.tokenColors)) {\n\t\t\treturn;\n\t\t}\n\t\tgrammarRegistry.setTheme({ name: colorTheme.label, settings: colorTheme.tokenColors });\n\t\tlet colorMap = TextMateService._toColorMap(grammarRegistry.getColorMap());\n\t\tlet cssRules = generateTokensCSSForColorMap(colorMap);\n\t\tthis._styleElement.innerHTML = cssRules;\n\t\tTokenizationRegistry.setColorMap(colorMap);\n\t}\n\n\tprivate compareTokenRules(newRules: ITokenColorizationRule[]): boolean {\n\t\tlet currRules = this._currentTokenColors;\n\t\tthis._currentTokenColors = newRules;\n\t\tif (!newRules || !currRules || newRules.length !== currRules.length) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (let i = newRules.length - 1; i >= 0; i--) {\n\t\t\tlet r1 = newRules[i];\n\t\t\tlet r2 = currRules[i];\n\t\t\tif (r1.scope !== r2.scope) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tlet s1 = r1.settings;\n\t\t\tlet s2 = r2.settings;\n\t\t\tif (s1 && s2) {\n\t\t\t\tif (s1.fontStyle !== s2.fontStyle || s1.foreground !== s2.foreground || s1.background !== s2.background) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if (!s1 || !s2) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate _handleGrammarExtensionPointUser(extensionLocation: URI, syntax: ITMSyntaxExtensionPoint, collector: ExtensionMessageCollector): void {\n\t\tif (syntax.language && ((typeof syntax.language !== 'string') || !this._modeService.isRegisteredMode(syntax.language))) {\n\t\t\tcollector.error(nls.localize('invalid.language', \"Unknown language in `contributes.{0}.language`. Provided value: {1}\", grammarsExtPoint.name, String(syntax.language)));\n\t\t\treturn;\n\t\t}\n\t\tif (!syntax.scopeName || (typeof syntax.scopeName !== 'string')) {\n\t\t\tcollector.error(nls.localize('invalid.scopeName', \"Expected string in `contributes.{0}.scopeName`. Provided value: {1}\", grammarsExtPoint.name, String(syntax.scopeName)));\n\t\t\treturn;\n\t\t}\n\t\tif (!syntax.path || (typeof syntax.path !== 'string')) {\n\t\t\tcollector.error(nls.localize('invalid.path.0', \"Expected string in `contributes.{0}.path`. Provided value: {1}\", grammarsExtPoint.name, String(syntax.path)));\n\t\t\treturn;\n\t\t}\n\t\tif (syntax.injectTo && (!Array.isArray(syntax.injectTo) || syntax.injectTo.some(scope => typeof scope !== 'string'))) {\n\t\t\tcollector.error(nls.localize('invalid.injectTo', \"Invalid value in `contributes.{0}.injectTo`. Must be an array of language scope names. Provided value: {1}\", grammarsExtPoint.name, JSON.stringify(syntax.injectTo)));\n\t\t\treturn;\n\t\t}\n\t\tif (syntax.embeddedLanguages && !types.isObject(syntax.embeddedLanguages)) {\n\t\t\tcollector.error(nls.localize('invalid.embeddedLanguages', \"Invalid value in `contributes.{0}.embeddedLanguages`. Must be an object map from scope name to language. Provided value: {1}\", grammarsExtPoint.name, JSON.stringify(syntax.embeddedLanguages)));\n\t\t\treturn;\n\t\t}\n\n\t\tif (syntax.tokenTypes && !types.isObject(syntax.tokenTypes)) {\n\t\t\tcollector.error(nls.localize('invalid.tokenTypes', \"Invalid value in `contributes.{0}.tokenTypes`. Must be an object map from scope name to token type. Provided value: {1}\", grammarsExtPoint.name, JSON.stringify(syntax.tokenTypes)));\n\t\t\treturn;\n\t\t}\n\n\t\tconst grammarLocation = resources.joinPath(extensionLocation, syntax.path);\n\t\tif (!resources.isEqualOrParent(grammarLocation, extensionLocation)) {\n\t\t\tcollector.warn(nls.localize('invalid.path.1', \"Expected `contributes.{0}.path` ({1}) to be included inside extension's folder ({2}). This might make the extension non-portable.\", grammarsExtPoint.name, grammarLocation.path, extensionLocation.path));\n\t\t}\n\n\t\tthis._scopeRegistry.register(syntax.scopeName, grammarLocation, syntax.embeddedLanguages, syntax.tokenTypes);\n\n\t\tif (syntax.injectTo) {\n\t\t\tfor (let injectScope of syntax.injectTo) {\n\t\t\t\tlet injections = this._injections[injectScope];\n\t\t\t\tif (!injections) {\n\t\t\t\t\tthis._injections[injectScope] = injections = [];\n\t\t\t\t}\n\t\t\t\tinjections.push(syntax.scopeName);\n\t\t\t}\n\n\t\t\tif (syntax.embeddedLanguages) {\n\t\t\t\tfor (let injectScope of syntax.injectTo) {\n\t\t\t\t\tlet injectedEmbeddedLanguages = this._injectedEmbeddedLanguages[injectScope];\n\t\t\t\t\tif (!injectedEmbeddedLanguages) {\n\t\t\t\t\t\tthis._injectedEmbeddedLanguages[injectScope] = injectedEmbeddedLanguages = [];\n\t\t\t\t\t}\n\t\t\t\t\tinjectedEmbeddedLanguages.push(syntax.embeddedLanguages);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet modeId = syntax.language;\n\t\tif (modeId) {\n\t\t\tthis._languageToScope.set(modeId, syntax.scopeName);\n\t\t}\n\t}\n\n\tprivate _resolveEmbeddedLanguages(embeddedLanguages: IEmbeddedLanguagesMap): IEmbeddedLanguagesMap2 {\n\t\tlet scopes = Object.keys(embeddedLanguages);\n\t\tlet result: IEmbeddedLanguagesMap2 = Object.create(null);\n\t\tfor (let i = 0, len = scopes.length; i < len; i++) {\n\t\t\tlet scope = scopes[i];\n\t\t\tlet language = embeddedLanguages[scope];\n\t\t\tlet languageIdentifier = this._modeService.getLanguageIdentifier(language);\n\t\t\tif (languageIdentifier) {\n\t\t\t\tresult[scope] = languageIdentifier.id;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic async createGrammar(modeId: string): Promise<IGrammar> {\n\t\tconst { grammar } = await this._createGrammar(modeId);\n\t\treturn grammar;\n\t}\n\n\tprivate async _createGrammar(modeId: string): Promise<ICreateGrammarResult> {\n\t\tconst scopeName = this._languageToScope.get(modeId);\n\t\tif (typeof scopeName !== 'string') {\n\t\t\t// No TM grammar defined\n\t\t\treturn Promise.reject(new Error(nls.localize('no-tm-grammar', \"No TM Grammar registered for this language.\")));\n\t\t}\n\t\tconst languageRegistration = this._scopeRegistry.getLanguageRegistration(scopeName);\n\t\tif (!languageRegistration) {\n\t\t\t// No TM grammar defined\n\t\t\treturn Promise.reject(new Error(nls.localize('no-tm-grammar', \"No TM Grammar registered for this language.\")));\n\t\t}\n\t\tlet embeddedLanguages = this._resolveEmbeddedLanguages(languageRegistration.embeddedLanguages);\n\t\tlet rawInjectedEmbeddedLanguages = this._injectedEmbeddedLanguages[scopeName];\n\t\tif (rawInjectedEmbeddedLanguages) {\n\t\t\tlet injectedEmbeddedLanguages: IEmbeddedLanguagesMap2[] = rawInjectedEmbeddedLanguages.map(this._resolveEmbeddedLanguages.bind(this));\n\t\t\tfor (const injected of injectedEmbeddedLanguages) {\n\t\t\t\tfor (const scope of Object.keys(injected)) {\n\t\t\t\t\tembeddedLanguages[scope] = injected[scope];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet languageId = this._modeService.getLanguageIdentifier(modeId)!.id;\n\t\tlet containsEmbeddedLanguages = (Object.keys(embeddedLanguages).length > 0);\n\n\t\tconst [grammarRegistry, initialState] = await this._getOrCreateGrammarRegistry();\n\t\tconst grammar = await grammarRegistry.loadGrammarWithConfiguration(scopeName, languageId, { embeddedLanguages, tokenTypes: languageRegistration.tokenTypes });\n\t\treturn {\n\t\t\tlanguageId: languageId,\n\t\t\tgrammar: grammar,\n\t\t\tinitialState: initialState,\n\t\t\tcontainsEmbeddedLanguages: containsEmbeddedLanguages\n\t\t};\n\t}\n}\n\nclass TMTokenization implements ITokenizationSupport {\n\n\tprivate readonly _scopeRegistry: TMScopeRegistry;\n\tprivate readonly _languageId: LanguageId;\n\tprivate readonly _grammar: IGrammar;\n\tprivate readonly _containsEmbeddedLanguages: boolean;\n\tprivate readonly _seenLanguages: boolean[];\n\tprivate readonly _initialState: StackElement;\n\tprivate _maxTokenizationLineLength: number;\n\tprivate _tokenizationWarningAlreadyShown: boolean;\n\n\tconstructor(scopeRegistry: TMScopeRegistry, languageId: LanguageId, grammar: IGrammar, initialState: StackElement, containsEmbeddedLanguages: boolean, @INotificationService private readonly notificationService: INotificationService, @IConfigurationService readonly configurationService: IConfigurationService) {\n\t\tthis._scopeRegistry = scopeRegistry;\n\t\tthis._languageId = languageId;\n\t\tthis._grammar = grammar;\n\t\tthis._initialState = initialState;\n\t\tthis._containsEmbeddedLanguages = containsEmbeddedLanguages;\n\t\tthis._seenLanguages = [];\n\t\tthis._maxTokenizationLineLength = configurationService.getValue<number>('editor.maxTokenizationLineLength');\n\t}\n\n\tpublic getInitialState(): IState {\n\t\treturn this._initialState;\n\t}\n\n\tpublic tokenize(line: string, state: IState, offsetDelta: number): TokenizationResult {\n\t\tthrow new Error('Not supported!');\n\t}\n\n\tpublic tokenize2(line: string, state: StackElement, offsetDelta: number): TokenizationResult2 {\n\t\tif (offsetDelta !== 0) {\n\t\t\tthrow new Error('Unexpected: offsetDelta should be 0.');\n\t\t}\n\n\t\t// Do not attempt to tokenize if a line is too long\n\t\tif (line.length >= this._maxTokenizationLineLength) {\n\t\t\tif (!this._tokenizationWarningAlreadyShown) {\n\t\t\t\tthis._tokenizationWarningAlreadyShown = true;\n\t\t\t\tthis.notificationService.warn(nls.localize('too many characters', \"Tokenization is skipped for long lines for performance reasons. The length of a long line can be configured via `editor.maxTokenizationLineLength`.\"));\n\t\t\t}\n\t\t\tconsole.log(`Line (${line.substr(0, 15)}...): longer than ${this._maxTokenizationLineLength} characters, tokenization skipped.`);\n\t\t\treturn nullTokenize2(this._languageId, line, state, offsetDelta);\n\t\t}\n\n\t\tlet textMateResult = this._grammar.tokenizeLine2(line, state);\n\n\t\tif (this._containsEmbeddedLanguages) {\n\t\t\tlet seenLanguages = this._seenLanguages;\n\t\t\tlet tokens = textMateResult.tokens;\n\n\t\t\t// Must check if any of the embedded languages was hit\n\t\t\tfor (let i = 0, len = (tokens.length >>> 1); i < len; i++) {\n\t\t\t\tlet metadata = tokens[(i << 1) + 1];\n\t\t\t\tlet languageId = TokenMetadata.getLanguageId(metadata);\n\n\t\t\t\tif (!seenLanguages[languageId]) {\n\t\t\t\t\tseenLanguages[languageId] = true;\n\t\t\t\t\tthis._scopeRegistry.onEncounteredLanguage(languageId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet endState: StackElement;\n\t\t// try to save an object if possible\n\t\tif (state.equals(textMateResult.ruleStack)) {\n\t\t\tendState = state;\n\t\t} else {\n\t\t\tendState = textMateResult.ruleStack;\n\n\t\t}\n\n\t\treturn new TokenizationResult2(textMateResult.tokens, endState);\n\t}\n}\n\nregisterSingleton(ITextMateService, TextMateService);"]}]}