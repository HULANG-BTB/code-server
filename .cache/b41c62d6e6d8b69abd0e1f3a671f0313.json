{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/viewLayout.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/viewLayout.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/lifecycle\", \"vs/base/common/scrollable\", \"vs/editor/common/viewLayout/linesLayout\", \"vs/editor/common/viewModel/viewModel\"], function (require, exports, lifecycle_1, scrollable_1, linesLayout_1, viewModel_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const SMOOTH_SCROLLING_TIME = 125;\n    class ViewLayout extends lifecycle_1.Disposable {\n        constructor(configuration, lineCount, scheduleAtNextAnimationFrame) {\n            super();\n            this._configuration = configuration;\n            this._linesLayout = new linesLayout_1.LinesLayout(lineCount, this._configuration.editor.lineHeight);\n            this.scrollable = this._register(new scrollable_1.Scrollable(0, scheduleAtNextAnimationFrame));\n            this._configureSmoothScrollDuration();\n            this.scrollable.setScrollDimensions({\n                width: configuration.editor.layoutInfo.contentWidth,\n                height: configuration.editor.layoutInfo.contentHeight\n            });\n            this.onDidScroll = this.scrollable.onScroll;\n            this._updateHeight();\n        }\n        dispose() {\n            super.dispose();\n        }\n        onHeightMaybeChanged() {\n            this._updateHeight();\n        }\n        _configureSmoothScrollDuration() {\n            this.scrollable.setSmoothScrollDuration(this._configuration.editor.viewInfo.smoothScrolling ? SMOOTH_SCROLLING_TIME : 0);\n        }\n        // ---- begin view event handlers\n        onConfigurationChanged(e) {\n            if (e.lineHeight) {\n                this._linesLayout.setLineHeight(this._configuration.editor.lineHeight);\n            }\n            if (e.layoutInfo) {\n                this.scrollable.setScrollDimensions({\n                    width: this._configuration.editor.layoutInfo.contentWidth,\n                    height: this._configuration.editor.layoutInfo.contentHeight\n                });\n            }\n            if (e.viewInfo) {\n                this._configureSmoothScrollDuration();\n            }\n            this._updateHeight();\n        }\n        onFlushed(lineCount) {\n            this._linesLayout.onFlushed(lineCount);\n        }\n        onLinesDeleted(fromLineNumber, toLineNumber) {\n            this._linesLayout.onLinesDeleted(fromLineNumber, toLineNumber);\n        }\n        onLinesInserted(fromLineNumber, toLineNumber) {\n            this._linesLayout.onLinesInserted(fromLineNumber, toLineNumber);\n        }\n        // ---- end view event handlers\n        _getHorizontalScrollbarHeight(scrollDimensions) {\n            if (this._configuration.editor.viewInfo.scrollbar.horizontal === scrollable_1.ScrollbarVisibility.Hidden) {\n                // horizontal scrollbar not visible\n                return 0;\n            }\n            if (scrollDimensions.width >= scrollDimensions.scrollWidth) {\n                // horizontal scrollbar not visible\n                return 0;\n            }\n            return this._configuration.editor.viewInfo.scrollbar.horizontalScrollbarSize;\n        }\n        _getTotalHeight() {\n            const scrollDimensions = this.scrollable.getScrollDimensions();\n            let result = this._linesLayout.getLinesTotalHeight();\n            if (this._configuration.editor.viewInfo.scrollBeyondLastLine) {\n                result += scrollDimensions.height - this._configuration.editor.lineHeight;\n            }\n            else {\n                result += this._getHorizontalScrollbarHeight(scrollDimensions);\n            }\n            return Math.max(scrollDimensions.height, result);\n        }\n        _updateHeight() {\n            this.scrollable.setScrollDimensions({\n                scrollHeight: this._getTotalHeight()\n            });\n        }\n        // ---- Layouting logic\n        getCurrentViewport() {\n            const scrollDimensions = this.scrollable.getScrollDimensions();\n            const currentScrollPosition = this.scrollable.getCurrentScrollPosition();\n            return new viewModel_1.Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);\n        }\n        getFutureViewport() {\n            const scrollDimensions = this.scrollable.getScrollDimensions();\n            const currentScrollPosition = this.scrollable.getFutureScrollPosition();\n            return new viewModel_1.Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);\n        }\n        _computeScrollWidth(maxLineWidth, viewportWidth) {\n            let isViewportWrapping = this._configuration.editor.wrappingInfo.isViewportWrapping;\n            if (!isViewportWrapping) {\n                const extraHorizontalSpace = this._configuration.editor.viewInfo.scrollBeyondLastColumn * this._configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;\n                const whitespaceMinWidth = this._linesLayout.getWhitespaceMinWidth();\n                return Math.max(maxLineWidth + extraHorizontalSpace, viewportWidth, whitespaceMinWidth);\n            }\n            return Math.max(maxLineWidth, viewportWidth);\n        }\n        onMaxLineWidthChanged(maxLineWidth) {\n            let newScrollWidth = this._computeScrollWidth(maxLineWidth, this.getCurrentViewport().width);\n            this.scrollable.setScrollDimensions({\n                scrollWidth: newScrollWidth\n            });\n            // The height might depend on the fact that there is a horizontal scrollbar or not\n            this._updateHeight();\n        }\n        // ---- view state\n        saveState() {\n            const currentScrollPosition = this.scrollable.getFutureScrollPosition();\n            let scrollTop = currentScrollPosition.scrollTop;\n            let firstLineNumberInViewport = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(scrollTop);\n            let whitespaceAboveFirstLine = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(firstLineNumberInViewport);\n            return {\n                scrollTop: scrollTop,\n                scrollTopWithoutViewZones: scrollTop - whitespaceAboveFirstLine,\n                scrollLeft: currentScrollPosition.scrollLeft\n            };\n        }\n        // ---- IVerticalLayoutProvider\n        addWhitespace(afterLineNumber, ordinal, height, minWidth) {\n            return this._linesLayout.insertWhitespace(afterLineNumber, ordinal, height, minWidth);\n        }\n        changeWhitespace(id, newAfterLineNumber, newHeight) {\n            return this._linesLayout.changeWhitespace(id, newAfterLineNumber, newHeight);\n        }\n        removeWhitespace(id) {\n            return this._linesLayout.removeWhitespace(id);\n        }\n        getVerticalOffsetForLineNumber(lineNumber) {\n            return this._linesLayout.getVerticalOffsetForLineNumber(lineNumber);\n        }\n        isAfterLines(verticalOffset) {\n            return this._linesLayout.isAfterLines(verticalOffset);\n        }\n        getLineNumberAtVerticalOffset(verticalOffset) {\n            return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(verticalOffset);\n        }\n        getWhitespaceAtVerticalOffset(verticalOffset) {\n            return this._linesLayout.getWhitespaceAtVerticalOffset(verticalOffset);\n        }\n        getLinesViewportData() {\n            const visibleBox = this.getCurrentViewport();\n            return this._linesLayout.getLinesViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n        }\n        getLinesViewportDataAtScrollTop(scrollTop) {\n            // do some minimal validations on scrollTop\n            const scrollDimensions = this.scrollable.getScrollDimensions();\n            if (scrollTop + scrollDimensions.height > scrollDimensions.scrollHeight) {\n                scrollTop = scrollDimensions.scrollHeight - scrollDimensions.height;\n            }\n            if (scrollTop < 0) {\n                scrollTop = 0;\n            }\n            return this._linesLayout.getLinesViewportData(scrollTop, scrollTop + scrollDimensions.height);\n        }\n        getWhitespaceViewportData() {\n            const visibleBox = this.getCurrentViewport();\n            return this._linesLayout.getWhitespaceViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n        }\n        getWhitespaces() {\n            return this._linesLayout.getWhitespaces();\n        }\n        // ---- IScrollingProvider\n        getScrollWidth() {\n            const scrollDimensions = this.scrollable.getScrollDimensions();\n            return scrollDimensions.scrollWidth;\n        }\n        getScrollHeight() {\n            const scrollDimensions = this.scrollable.getScrollDimensions();\n            return scrollDimensions.scrollHeight;\n        }\n        getCurrentScrollLeft() {\n            const currentScrollPosition = this.scrollable.getCurrentScrollPosition();\n            return currentScrollPosition.scrollLeft;\n        }\n        getCurrentScrollTop() {\n            const currentScrollPosition = this.scrollable.getCurrentScrollPosition();\n            return currentScrollPosition.scrollTop;\n        }\n        validateScrollPosition(scrollPosition) {\n            return this.scrollable.validateScrollPosition(scrollPosition);\n        }\n        setScrollPositionNow(position) {\n            this.scrollable.setScrollPositionNow(position);\n        }\n        setScrollPositionSmooth(position) {\n            this.scrollable.setScrollPositionSmooth(position);\n        }\n        deltaScrollNow(deltaScrollLeft, deltaScrollTop) {\n            const currentScrollPosition = this.scrollable.getCurrentScrollPosition();\n            this.scrollable.setScrollPositionNow({\n                scrollLeft: currentScrollPosition.scrollLeft + deltaScrollLeft,\n                scrollTop: currentScrollPosition.scrollTop + deltaScrollTop\n            });\n        }\n    }\n    exports.ViewLayout = ViewLayout;\n});\n",null]}