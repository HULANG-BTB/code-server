{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/configuration/node/configurationService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/configuration/node/configurationService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/assert\", \"vs/base/common/event\", \"vs/base/common/map\", \"vs/base/common/objects\", \"vs/base/common/lifecycle\", \"vs/base/common/async\", \"vs/base/node/pfs\", \"vs/platform/jsonschemas/common/jsonContributionRegistry\", \"vs/platform/workspace/common/workspace\", \"vs/base/common/platform\", \"vs/platform/environment/common/environment\", \"vs/platform/configuration/common/configurationModels\", \"vs/platform/configuration/common/configuration\", \"vs/workbench/services/configuration/common/configurationModels\", \"vs/workbench/services/configuration/common/configuration\", \"vs/platform/registry/common/platform\", \"vs/platform/configuration/common/configurationRegistry\", \"vs/platform/workspaces/common/workspaces\", \"vs/workbench/services/extensions/common/extensions\", \"vs/platform/commands/common/commands\", \"vs/platform/product/node/product\", \"vs/workbench/services/configuration/common/configurationEditingService\", \"vs/workbench/services/configuration/node/configuration\", \"vs/workbench/services/configuration/common/jsonEditingService\", \"vs/nls\", \"vs/base/common/resources\", \"vs/base/common/performance\", \"vs/base/common/network\"], function (require, exports, assert, event_1, map_1, objects_1, lifecycle_1, async_1, pfs_1, jsonContributionRegistry_1, workspace_1, platform_1, environment_1, configurationModels_1, configuration_1, configurationModels_2, configuration_2, platform_2, configurationRegistry_1, workspaces_1, extensions_1, commands_1, product_1, configurationEditingService_1, configuration_3, jsonEditingService_1, nls_1, resources_1, performance_1, network_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class WorkspaceService extends lifecycle_1.Disposable {\n        constructor(configuration, environmentService, remoteAgentService, workspaceSettingsRootFolder = configuration_2.FOLDER_CONFIG_FOLDER_NAME) {\n            super();\n            this.environmentService = environmentService;\n            this.remoteAgentService = remoteAgentService;\n            this.workspaceSettingsRootFolder = workspaceSettingsRootFolder;\n            this.remoteUserConfiguration = null;\n            this._onDidChangeConfiguration = this._register(new event_1.Emitter());\n            this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;\n            this._onDidChangeWorkspaceFolders = this._register(new event_1.Emitter());\n            this.onDidChangeWorkspaceFolders = this._onDidChangeWorkspaceFolders.event;\n            this._onDidChangeWorkspaceName = this._register(new event_1.Emitter());\n            this.onDidChangeWorkspaceName = this._onDidChangeWorkspaceName.event;\n            this._onDidChangeWorkbenchState = this._register(new event_1.Emitter());\n            this.onDidChangeWorkbenchState = this._onDidChangeWorkbenchState.event;\n            this.completeWorkspaceBarrier = new async_1.Barrier();\n            this.defaultConfiguration = new configurationModels_1.DefaultConfigurationModel();\n            this.localUserConfiguration = this._register(new configuration_3.LocalUserConfiguration(environmentService));\n            this._register(this.localUserConfiguration.onDidChangeConfiguration(userConfiguration => this.onLocalUserConfigurationChanged(userConfiguration)));\n            if (configuration.remoteAuthority) {\n                this.remoteUserConfiguration = this._register(new configuration_3.RemoteUserConfiguration(configuration.remoteAuthority, environmentService));\n                this._register(this.remoteUserConfiguration.onDidChangeConfiguration(userConfiguration => this.onRemoteUserConfigurationChanged(userConfiguration)));\n            }\n            this.workspaceConfiguration = this._register(new configuration_3.WorkspaceConfiguration(environmentService));\n            this._register(this.workspaceConfiguration.onDidUpdateConfiguration(() => this.onWorkspaceConfigurationChanged()));\n            this._register(platform_2.Registry.as(configurationRegistry_1.Extensions.Configuration).onDidSchemaChange(e => this.registerConfigurationSchemas()));\n            this._register(platform_2.Registry.as(configurationRegistry_1.Extensions.Configuration).onDidUpdateConfiguration(configurationProperties => this.onDefaultConfigurationChanged(configurationProperties)));\n            this.workspaceEditingQueue = new async_1.Queue();\n        }\n        // Workspace Context Service Impl\n        getCompleteWorkspace() {\n            return this.completeWorkspaceBarrier.wait().then(() => this.getWorkspace());\n        }\n        getWorkspace() {\n            return this.workspace;\n        }\n        getWorkbenchState() {\n            // Workspace has configuration file\n            if (this.workspace.configuration) {\n                return workspace_1.WorkbenchState.WORKSPACE;\n            }\n            // Folder has single root\n            if (this.workspace.folders.length === 1) {\n                return workspace_1.WorkbenchState.FOLDER;\n            }\n            // Empty\n            return workspace_1.WorkbenchState.EMPTY;\n        }\n        getWorkspaceFolder(resource) {\n            return this.workspace.getFolder(resource);\n        }\n        addFolders(foldersToAdd, index) {\n            return this.updateFolders(foldersToAdd, [], index);\n        }\n        removeFolders(foldersToRemove) {\n            return this.updateFolders([], foldersToRemove);\n        }\n        updateFolders(foldersToAdd, foldersToRemove, index) {\n            assert.ok(this.jsonEditingService, 'Workbench is not initialized yet');\n            return Promise.resolve(this.workspaceEditingQueue.queue(() => this.doUpdateFolders(foldersToAdd, foldersToRemove, index)));\n        }\n        isInsideWorkspace(resource) {\n            return !!this.getWorkspaceFolder(resource);\n        }\n        isCurrentWorkspace(workspaceIdentifier) {\n            switch (this.getWorkbenchState()) {\n                case workspace_1.WorkbenchState.FOLDER:\n                    return workspaces_1.isSingleFolderWorkspaceIdentifier(workspaceIdentifier) && resources_1.isEqual(workspaceIdentifier, this.workspace.folders[0].uri);\n                case workspace_1.WorkbenchState.WORKSPACE:\n                    return workspaces_1.isWorkspaceIdentifier(workspaceIdentifier) && this.workspace.id === workspaceIdentifier.id;\n            }\n            return false;\n        }\n        doUpdateFolders(foldersToAdd, foldersToRemove, index) {\n            if (this.getWorkbenchState() !== workspace_1.WorkbenchState.WORKSPACE) {\n                return Promise.resolve(undefined); // we need a workspace to begin with\n            }\n            if (foldersToAdd.length + foldersToRemove.length === 0) {\n                return Promise.resolve(undefined); // nothing to do\n            }\n            let foldersHaveChanged = false;\n            // Remove first (if any)\n            let currentWorkspaceFolders = this.getWorkspace().folders;\n            let newStoredFolders = currentWorkspaceFolders.map(f => f.raw).filter((folder, index) => {\n                if (!workspaces_1.isStoredWorkspaceFolder(folder)) {\n                    return true; // keep entries which are unrelated\n                }\n                return !this.contains(foldersToRemove, currentWorkspaceFolders[index].uri); // keep entries which are unrelated\n            });\n            const slashForPath = workspaces_1.useSlashForPath(newStoredFolders);\n            foldersHaveChanged = currentWorkspaceFolders.length !== newStoredFolders.length;\n            // Add afterwards (if any)\n            if (foldersToAdd.length) {\n                // Recompute current workspace folders if we have folders to add\n                const workspaceConfigFolder = resources_1.dirname(this.getWorkspace().configuration);\n                currentWorkspaceFolders = workspace_1.toWorkspaceFolders(newStoredFolders, workspaceConfigFolder);\n                const currentWorkspaceFolderUris = currentWorkspaceFolders.map(folder => folder.uri);\n                const storedFoldersToAdd = [];\n                foldersToAdd.forEach(folderToAdd => {\n                    const folderURI = folderToAdd.uri;\n                    if (this.contains(currentWorkspaceFolderUris, folderURI)) {\n                        return; // already existing\n                    }\n                    storedFoldersToAdd.push(workspaces_1.getStoredWorkspaceFolder(folderURI, folderToAdd.name, workspaceConfigFolder, slashForPath));\n                });\n                // Apply to array of newStoredFolders\n                if (storedFoldersToAdd.length > 0) {\n                    foldersHaveChanged = true;\n                    if (typeof index === 'number' && index >= 0 && index < newStoredFolders.length) {\n                        newStoredFolders = newStoredFolders.slice(0);\n                        newStoredFolders.splice(index, 0, ...storedFoldersToAdd);\n                    }\n                    else {\n                        newStoredFolders = [...newStoredFolders, ...storedFoldersToAdd];\n                    }\n                }\n            }\n            // Set folders if we recorded a change\n            if (foldersHaveChanged) {\n                return this.setFolders(newStoredFolders);\n            }\n            return Promise.resolve(undefined);\n        }\n        setFolders(folders) {\n            return this.workspaceConfiguration.setFolders(folders, this.jsonEditingService)\n                .then(() => this.onWorkspaceConfigurationChanged());\n        }\n        contains(resources, toCheck) {\n            return resources.some(resource => {\n                if (platform_1.isLinux) {\n                    return resource.toString() === toCheck.toString();\n                }\n                return resource.toString().toLowerCase() === toCheck.toString().toLowerCase();\n            });\n        }\n        // Workspace Configuration Service Impl\n        getConfigurationData() {\n            const configurationData = this._configuration.toData();\n            configurationData.isComplete = this.cachedFolderConfigs.values().every(c => c.loaded);\n            return configurationData;\n        }\n        getValue(arg1, arg2) {\n            const section = typeof arg1 === 'string' ? arg1 : undefined;\n            const overrides = configuration_1.isConfigurationOverrides(arg1) ? arg1 : configuration_1.isConfigurationOverrides(arg2) ? arg2 : undefined;\n            return this._configuration.getValue(section, overrides);\n        }\n        updateValue(key, value, arg3, arg4, donotNotifyError) {\n            assert.ok(this.configurationEditingService, 'Workbench is not initialized yet');\n            const overrides = configuration_1.isConfigurationOverrides(arg3) ? arg3 : undefined;\n            const target = this.deriveConfigurationTarget(key, value, overrides, overrides ? arg4 : arg3);\n            return target ? this.writeConfigurationValue(key, value, target, overrides, donotNotifyError)\n                : Promise.resolve();\n        }\n        reloadConfiguration(folder, key) {\n            if (folder) {\n                return this.reloadWorkspaceFolderConfiguration(folder, key);\n            }\n            return this.reloadUserConfiguration()\n                .then(({ local, remote }) => this.reloadWorkspaceConfiguration()\n                .then(() => this.loadConfiguration(local, remote)));\n        }\n        inspect(key, overrides) {\n            return this._configuration.inspect(key, overrides);\n        }\n        keys() {\n            return this._configuration.keys();\n        }\n        initialize(arg, postInitialisationTask = () => null) {\n            performance_1.mark('willInitWorkspaceService');\n            return this.createWorkspace(arg)\n                .then(workspace => this.updateWorkspaceAndInitializeConfiguration(workspace, postInitialisationTask)).then(() => {\n                performance_1.mark('didInitWorkspaceService');\n            });\n        }\n        acquireFileService(fileService) {\n            this.fileService = fileService;\n            const changedWorkspaceFolders = [];\n            this.localUserConfiguration.adopt(fileService);\n            Promise.all([this.workspaceConfiguration.adopt(fileService), ...this.cachedFolderConfigs.values()\n                    .map(folderConfiguration => folderConfiguration.adopt(fileService)\n                    .then(result => {\n                    if (result) {\n                        changedWorkspaceFolders.push(folderConfiguration.workspaceFolder);\n                    }\n                    return result;\n                }))])\n                .then(([workspaceChanged]) => {\n                if (workspaceChanged) {\n                    this.onWorkspaceConfigurationChanged();\n                }\n                for (const workspaceFolder of changedWorkspaceFolders) {\n                    this.onWorkspaceFolderConfigurationChanged(workspaceFolder);\n                }\n                this.releaseWorkspaceBarrier();\n            });\n            if (this.remoteUserConfiguration) {\n                this.remoteAgentService.getEnvironment()\n                    .then(environment => this.remoteUserConfiguration.adopt(environment ? environment.appSettingsPath : null, fileService)\n                    .then(changedModel => {\n                    if (changedModel) {\n                        this.onRemoteUserConfigurationChanged(changedModel);\n                    }\n                }));\n            }\n        }\n        acquireInstantiationService(instantiationService) {\n            this.configurationEditingService = instantiationService.createInstance(configurationEditingService_1.ConfigurationEditingService);\n            this.jsonEditingService = instantiationService.createInstance(jsonEditingService_1.JSONEditingService);\n        }\n        createWorkspace(arg) {\n            if (workspaces_1.isWorkspaceIdentifier(arg)) {\n                return this.createMultiFolderWorkspace(arg);\n            }\n            if (workspaces_1.isSingleFolderWorkspaceInitializationPayload(arg)) {\n                return this.createSingleFolderWorkspace(arg);\n            }\n            return this.createEmptyWorkspace(arg);\n        }\n        createMultiFolderWorkspace(workspaceIdentifier) {\n            return this.workspaceConfiguration.load({ id: workspaceIdentifier.id, configPath: workspaceIdentifier.configPath })\n                .then(() => {\n                const workspaceConfigPath = workspaceIdentifier.configPath;\n                const workspaceFolders = workspace_1.toWorkspaceFolders(this.workspaceConfiguration.getFolders(), resources_1.dirname(workspaceConfigPath));\n                const workspaceId = workspaceIdentifier.id;\n                const workspace = new workspace_1.Workspace(workspaceId, workspaceFolders, workspaceConfigPath);\n                if (workspace.configuration.scheme === network_1.Schemas.file) {\n                    this.releaseWorkspaceBarrier(); // Release barrier as workspace is complete because it is from disk.\n                }\n                return workspace;\n            });\n        }\n        createSingleFolderWorkspace(singleFolder) {\n            const folder = singleFolder.folder;\n            let configuredFolders;\n            if (folder.scheme === 'file') {\n                configuredFolders = [{ path: folder.fsPath }];\n            }\n            else {\n                configuredFolders = [{ uri: folder.toString() }];\n            }\n            const workspace = new workspace_1.Workspace(singleFolder.id, workspace_1.toWorkspaceFolders(configuredFolders));\n            this.releaseWorkspaceBarrier(); // Release barrier as workspace is complete because it is single folder.\n            return Promise.resolve(workspace);\n        }\n        createEmptyWorkspace(emptyWorkspace) {\n            const workspace = new workspace_1.Workspace(emptyWorkspace.id);\n            this.releaseWorkspaceBarrier(); // Release barrier as workspace is complete because it is an empty workspace.\n            return Promise.resolve(workspace);\n        }\n        releaseWorkspaceBarrier() {\n            if (!this.completeWorkspaceBarrier.isOpen()) {\n                this.completeWorkspaceBarrier.open();\n            }\n        }\n        updateWorkspaceAndInitializeConfiguration(workspace, postInitialisationTask) {\n            const hasWorkspaceBefore = !!this.workspace;\n            let previousState;\n            let previousWorkspacePath;\n            let previousFolders;\n            if (hasWorkspaceBefore) {\n                previousState = this.getWorkbenchState();\n                previousWorkspacePath = this.workspace.configuration ? this.workspace.configuration.fsPath : undefined;\n                previousFolders = this.workspace.folders;\n                this.workspace.update(workspace);\n            }\n            else {\n                this.workspace = workspace;\n            }\n            return this.initializeConfiguration().then(() => {\n                postInitialisationTask(); // Post initialisation task should be run before triggering events.\n                // Trigger changes after configuration initialization so that configuration is up to date.\n                if (hasWorkspaceBefore) {\n                    const newState = this.getWorkbenchState();\n                    if (previousState && newState !== previousState) {\n                        this._onDidChangeWorkbenchState.fire(newState);\n                    }\n                    const newWorkspacePath = this.workspace.configuration ? this.workspace.configuration.fsPath : undefined;\n                    if (previousWorkspacePath && newWorkspacePath !== previousWorkspacePath || newState !== previousState) {\n                        this._onDidChangeWorkspaceName.fire();\n                    }\n                    const folderChanges = this.compareFolders(previousFolders, this.workspace.folders);\n                    if (folderChanges && (folderChanges.added.length || folderChanges.removed.length || folderChanges.changed.length)) {\n                        this._onDidChangeWorkspaceFolders.fire(folderChanges);\n                    }\n                }\n            });\n        }\n        compareFolders(currentFolders, newFolders) {\n            const result = { added: [], removed: [], changed: [] };\n            result.added = newFolders.filter(newFolder => !currentFolders.some(currentFolder => newFolder.uri.toString() === currentFolder.uri.toString()));\n            for (let currentIndex = 0; currentIndex < currentFolders.length; currentIndex++) {\n                let currentFolder = currentFolders[currentIndex];\n                let newIndex = 0;\n                for (newIndex = 0; newIndex < newFolders.length && currentFolder.uri.toString() !== newFolders[newIndex].uri.toString(); newIndex++) { }\n                if (newIndex < newFolders.length) {\n                    if (currentIndex !== newIndex || currentFolder.name !== newFolders[newIndex].name) {\n                        result.changed.push(currentFolder);\n                    }\n                }\n                else {\n                    result.removed.push(currentFolder);\n                }\n            }\n            return result;\n        }\n        initializeConfiguration() {\n            this.registerConfigurationSchemas();\n            return this.initializeUserConfiguration()\n                .then(({ local, remote }) => this.loadConfiguration(local, remote));\n        }\n        initializeUserConfiguration() {\n            return Promise.all([this.localUserConfiguration.initialize(), this.remoteUserConfiguration ? this.remoteUserConfiguration.initialize() : Promise.resolve(new configurationModels_1.ConfigurationModel())])\n                .then(([local, remote]) => ({ local, remote }));\n        }\n        reloadUserConfiguration(key) {\n            return Promise.all([this.localUserConfiguration.reload(), this.remoteUserConfiguration ? this.remoteUserConfiguration.reload() : Promise.resolve(new configurationModels_1.ConfigurationModel())])\n                .then(([local, remote]) => ({ local, remote }));\n        }\n        reloadWorkspaceConfiguration(key) {\n            const workbenchState = this.getWorkbenchState();\n            if (workbenchState === workspace_1.WorkbenchState.FOLDER) {\n                return this.onWorkspaceFolderConfigurationChanged(this.workspace.folders[0], key);\n            }\n            if (workbenchState === workspace_1.WorkbenchState.WORKSPACE) {\n                return this.workspaceConfiguration.reload().then(() => this.onWorkspaceConfigurationChanged());\n            }\n            return Promise.resolve(undefined);\n        }\n        reloadWorkspaceFolderConfiguration(folder, key) {\n            return this.onWorkspaceFolderConfigurationChanged(folder, key);\n        }\n        loadConfiguration(userConfigurationModel, remoteUserConfigurationModel) {\n            // reset caches\n            this.cachedFolderConfigs = new map_1.ResourceMap();\n            const folders = this.workspace.folders;\n            return this.loadFolderConfigurations(folders)\n                .then((folderConfigurations) => {\n                let workspaceConfiguration = this.getWorkspaceConfigurationModel(folderConfigurations);\n                const folderConfigurationModels = new map_1.ResourceMap();\n                folderConfigurations.forEach((folderConfiguration, index) => folderConfigurationModels.set(folders[index].uri, folderConfiguration));\n                const currentConfiguration = this._configuration;\n                this._configuration = new configurationModels_2.Configuration(this.defaultConfiguration, userConfigurationModel, remoteUserConfigurationModel, workspaceConfiguration, folderConfigurationModels, new configurationModels_1.ConfigurationModel(), new map_1.ResourceMap(), this.workspace);\n                if (currentConfiguration) {\n                    const changedKeys = this._configuration.compare(currentConfiguration);\n                    this.triggerConfigurationChange(new configurationModels_1.ConfigurationChangeEvent().change(changedKeys), configuration_1.ConfigurationTarget.WORKSPACE);\n                }\n                else {\n                    this._onDidChangeConfiguration.fire(new configurationModels_2.AllKeysConfigurationChangeEvent(this._configuration, configuration_1.ConfigurationTarget.WORKSPACE, this.getTargetConfiguration(configuration_1.ConfigurationTarget.WORKSPACE)));\n                }\n            });\n        }\n        getWorkspaceConfigurationModel(folderConfigurations) {\n            switch (this.getWorkbenchState()) {\n                case workspace_1.WorkbenchState.FOLDER:\n                    return folderConfigurations[0];\n                case workspace_1.WorkbenchState.WORKSPACE:\n                    return this.workspaceConfiguration.getConfiguration();\n                default:\n                    return new configurationModels_1.ConfigurationModel();\n            }\n        }\n        onDefaultConfigurationChanged(keys) {\n            this.defaultConfiguration = new configurationModels_1.DefaultConfigurationModel();\n            this.registerConfigurationSchemas();\n            if (this.workspace && this._configuration) {\n                this._configuration.updateDefaultConfiguration(this.defaultConfiguration);\n                if (this.getWorkbenchState() === workspace_1.WorkbenchState.FOLDER) {\n                    this._configuration.updateWorkspaceConfiguration(this.cachedFolderConfigs.get(this.workspace.folders[0].uri).reprocess());\n                }\n                else {\n                    this._configuration.updateWorkspaceConfiguration(this.workspaceConfiguration.reprocessWorkspaceSettings());\n                    this.workspace.folders.forEach(folder => this._configuration.updateFolderConfiguration(folder.uri, this.cachedFolderConfigs.get(folder.uri).reprocess()));\n                }\n                this.triggerConfigurationChange(new configurationModels_1.ConfigurationChangeEvent().change(keys), configuration_1.ConfigurationTarget.DEFAULT);\n            }\n        }\n        registerConfigurationSchemas() {\n            if (this.workspace) {\n                const jsonRegistry = platform_2.Registry.as(jsonContributionRegistry_1.Extensions.JSONContribution);\n                const convertToNotSuggestedProperties = (properties, errorMessage) => {\n                    return Object.keys(properties).reduce((result, property) => {\n                        result[property] = objects_1.deepClone(properties[property]);\n                        result[property].deprecationMessage = errorMessage;\n                        return result;\n                    }, {});\n                };\n                const allSettingsSchema = { properties: configurationRegistry_1.allSettings.properties, patternProperties: configurationRegistry_1.allSettings.patternProperties, additionalProperties: false, errorMessage: 'Unknown configuration setting' };\n                const unsupportedApplicationSettings = convertToNotSuggestedProperties(configurationRegistry_1.applicationSettings.properties, nls_1.localize('unsupportedApplicationSetting', \"This setting can be applied only in User Settings\"));\n                const workspaceSettingsSchema = { properties: Object.assign({}, unsupportedApplicationSettings, configurationRegistry_1.windowSettings.properties, configurationRegistry_1.resourceSettings.properties), patternProperties: configurationRegistry_1.allSettings.patternProperties, additionalProperties: false, errorMessage: 'Unknown configuration setting' };\n                jsonRegistry.registerSchema(configuration_2.defaultSettingsSchemaId, allSettingsSchema);\n                jsonRegistry.registerSchema(configuration_2.userSettingsSchemaId, allSettingsSchema);\n                if (workspace_1.WorkbenchState.WORKSPACE === this.getWorkbenchState()) {\n                    const unsupportedWindowSettings = convertToNotSuggestedProperties(configurationRegistry_1.windowSettings.properties, nls_1.localize('unsupportedWindowSetting', \"This setting cannot be applied now. It will be applied when you open this folder directly.\"));\n                    const folderSettingsSchema = { properties: Object.assign({}, unsupportedApplicationSettings, unsupportedWindowSettings, configurationRegistry_1.resourceSettings.properties), patternProperties: configurationRegistry_1.allSettings.patternProperties, additionalProperties: false, errorMessage: 'Unknown configuration setting' };\n                    jsonRegistry.registerSchema(configuration_2.workspaceSettingsSchemaId, workspaceSettingsSchema);\n                    jsonRegistry.registerSchema(configuration_2.folderSettingsSchemaId, folderSettingsSchema);\n                }\n                else {\n                    jsonRegistry.registerSchema(configuration_2.workspaceSettingsSchemaId, workspaceSettingsSchema);\n                    jsonRegistry.registerSchema(configuration_2.folderSettingsSchemaId, workspaceSettingsSchema);\n                }\n            }\n        }\n        onLocalUserConfigurationChanged(userConfiguration) {\n            const keys = this._configuration.compareAndUpdateLocalUserConfiguration(userConfiguration);\n            this.triggerConfigurationChange(keys, configuration_1.ConfigurationTarget.USER);\n        }\n        onRemoteUserConfigurationChanged(userConfiguration) {\n            const keys = this._configuration.compareAndUpdateRemoteUserConfiguration(userConfiguration);\n            this.triggerConfigurationChange(keys, configuration_1.ConfigurationTarget.USER);\n        }\n        onWorkspaceConfigurationChanged() {\n            if (this.workspace && this.workspace.configuration && this._configuration) {\n                const workspaceConfigurationChangeEvent = this._configuration.compareAndUpdateWorkspaceConfiguration(this.workspaceConfiguration.getConfiguration());\n                let configuredFolders = workspace_1.toWorkspaceFolders(this.workspaceConfiguration.getFolders(), resources_1.dirname(this.workspace.configuration));\n                const changes = this.compareFolders(this.workspace.folders, configuredFolders);\n                if (changes.added.length || changes.removed.length || changes.changed.length) {\n                    this.workspace.folders = configuredFolders;\n                    return this.onFoldersChanged()\n                        .then(foldersConfigurationChangeEvent => {\n                        this.triggerConfigurationChange(foldersConfigurationChangeEvent.change(workspaceConfigurationChangeEvent), configuration_1.ConfigurationTarget.WORKSPACE_FOLDER);\n                        this._onDidChangeWorkspaceFolders.fire(changes);\n                    });\n                }\n                else {\n                    this.triggerConfigurationChange(workspaceConfigurationChangeEvent, configuration_1.ConfigurationTarget.WORKSPACE);\n                }\n            }\n            return Promise.resolve(undefined);\n        }\n        onWorkspaceFolderConfigurationChanged(folder, key) {\n            return this.loadFolderConfigurations([folder])\n                .then(([folderConfiguration]) => {\n                const folderChangedKeys = this._configuration.compareAndUpdateFolderConfiguration(folder.uri, folderConfiguration);\n                if (this.getWorkbenchState() === workspace_1.WorkbenchState.FOLDER) {\n                    const workspaceChangedKeys = this._configuration.compareAndUpdateWorkspaceConfiguration(folderConfiguration);\n                    this.triggerConfigurationChange(workspaceChangedKeys, configuration_1.ConfigurationTarget.WORKSPACE);\n                }\n                else {\n                    this.triggerConfigurationChange(folderChangedKeys, configuration_1.ConfigurationTarget.WORKSPACE_FOLDER);\n                }\n            });\n        }\n        onFoldersChanged() {\n            let changeEvent = new configurationModels_1.ConfigurationChangeEvent();\n            // Remove the configurations of deleted folders\n            for (const key of this.cachedFolderConfigs.keys()) {\n                if (!this.workspace.folders.filter(folder => folder.uri.toString() === key.toString())[0]) {\n                    const folderConfiguration = this.cachedFolderConfigs.get(key);\n                    folderConfiguration.dispose();\n                    this.cachedFolderConfigs.delete(key);\n                    changeEvent = changeEvent.change(this._configuration.compareAndDeleteFolderConfiguration(key));\n                }\n            }\n            const toInitialize = this.workspace.folders.filter(folder => !this.cachedFolderConfigs.has(folder.uri));\n            if (toInitialize.length) {\n                return this.loadFolderConfigurations(toInitialize)\n                    .then(folderConfigurations => {\n                    folderConfigurations.forEach((folderConfiguration, index) => {\n                        changeEvent = changeEvent.change(this._configuration.compareAndUpdateFolderConfiguration(toInitialize[index].uri, folderConfiguration));\n                    });\n                    return changeEvent;\n                });\n            }\n            return Promise.resolve(changeEvent);\n        }\n        loadFolderConfigurations(folders) {\n            return Promise.all([...folders.map(folder => {\n                    let folderConfiguration = this.cachedFolderConfigs.get(folder.uri);\n                    if (!folderConfiguration) {\n                        folderConfiguration = new configuration_3.FolderConfiguration(folder, this.workspaceSettingsRootFolder, this.getWorkbenchState(), this.environmentService, this.fileService);\n                        this._register(folderConfiguration.onDidChange(() => this.onWorkspaceFolderConfigurationChanged(folder)));\n                        this.cachedFolderConfigs.set(folder.uri, this._register(folderConfiguration));\n                    }\n                    return folderConfiguration.loadConfiguration();\n                })]);\n        }\n        writeConfigurationValue(key, value, target, overrides, donotNotifyError) {\n            if (target === configuration_1.ConfigurationTarget.DEFAULT) {\n                return Promise.reject(new Error('Invalid configuration target'));\n            }\n            if (target === configuration_1.ConfigurationTarget.MEMORY) {\n                this._configuration.updateValue(key, value, overrides);\n                this.triggerConfigurationChange(new configurationModels_1.ConfigurationChangeEvent().change(overrides && overrides.overrideIdentifier ? [configuration_1.keyFromOverrideIdentifier(overrides.overrideIdentifier)] : [key], overrides && overrides.resource || undefined), target);\n                return Promise.resolve(undefined);\n            }\n            return this.configurationEditingService.writeConfiguration(target, { key, value }, { scopes: overrides, donotNotifyError })\n                .then(() => {\n                switch (target) {\n                    case configuration_1.ConfigurationTarget.USER:\n                        return this.reloadUserConfiguration()\n                            .then(({ local, remote }) => {\n                            this.onLocalUserConfigurationChanged(local);\n                            if (this.remoteUserConfiguration) {\n                                this.onRemoteUserConfigurationChanged(remote);\n                            }\n                        });\n                    case configuration_1.ConfigurationTarget.WORKSPACE:\n                        return this.reloadWorkspaceConfiguration();\n                    case configuration_1.ConfigurationTarget.WORKSPACE_FOLDER:\n                        const workspaceFolder = overrides && overrides.resource ? this.workspace.getFolder(overrides.resource) : null;\n                        if (workspaceFolder) {\n                            return this.reloadWorkspaceFolderConfiguration(workspaceFolder, key);\n                        }\n                }\n                return Promise.resolve();\n            });\n        }\n        deriveConfigurationTarget(key, value, overrides, target) {\n            if (target) {\n                return target;\n            }\n            if (value === undefined) {\n                // Ignore. But expected is to remove the value from all targets\n                return undefined;\n            }\n            const inspect = this.inspect(key, overrides);\n            if (objects_1.equals(value, inspect.value)) {\n                // No change. So ignore.\n                return undefined;\n            }\n            if (inspect.workspaceFolder !== undefined) {\n                return configuration_1.ConfigurationTarget.WORKSPACE_FOLDER;\n            }\n            if (inspect.workspace !== undefined) {\n                return configuration_1.ConfigurationTarget.WORKSPACE;\n            }\n            return configuration_1.ConfigurationTarget.USER;\n        }\n        triggerConfigurationChange(configurationEvent, target) {\n            if (configurationEvent.affectedKeys.length) {\n                configurationEvent.telemetryData(target, this.getTargetConfiguration(target));\n                this._onDidChangeConfiguration.fire(new configurationModels_2.WorkspaceConfigurationChangeEvent(configurationEvent, this.workspace));\n            }\n        }\n        getTargetConfiguration(target) {\n            switch (target) {\n                case configuration_1.ConfigurationTarget.DEFAULT:\n                    return this._configuration.defaults.contents;\n                case configuration_1.ConfigurationTarget.USER:\n                    return this._configuration.userConfiguration.contents;\n                case configuration_1.ConfigurationTarget.WORKSPACE:\n                    return this._configuration.workspaceConfiguration.contents;\n            }\n            return {};\n        }\n    }\n    exports.WorkspaceService = WorkspaceService;\n    let DefaultConfigurationExportHelper = class DefaultConfigurationExportHelper {\n        constructor(environmentService, extensionService, commandService) {\n            this.extensionService = extensionService;\n            this.commandService = commandService;\n            if (environmentService.args['export-default-configuration']) {\n                this.writeConfigModelAndQuit(environmentService.args['export-default-configuration']);\n            }\n        }\n        writeConfigModelAndQuit(targetPath) {\n            return Promise.resolve(this.extensionService.whenInstalledExtensionsRegistered())\n                .then(() => this.writeConfigModel(targetPath))\n                .then(() => this.commandService.executeCommand('workbench.action.quit'))\n                .then(() => { });\n        }\n        writeConfigModel(targetPath) {\n            const config = this.getConfigModel();\n            const resultString = JSON.stringify(config, undefined, '  ');\n            return pfs_1.writeFile(targetPath, resultString);\n        }\n        getConfigModel() {\n            const configRegistry = platform_2.Registry.as(configurationRegistry_1.Extensions.Configuration);\n            const configurations = configRegistry.getConfigurations().slice();\n            const settings = [];\n            const processProperty = (name, prop) => {\n                const propDetails = {\n                    name,\n                    description: prop.description || prop.markdownDescription || '',\n                    default: prop.default,\n                    type: prop.type\n                };\n                if (prop.enum) {\n                    propDetails.enum = prop.enum;\n                }\n                if (prop.enumDescriptions || prop.markdownEnumDescriptions) {\n                    propDetails.enumDescriptions = prop.enumDescriptions || prop.markdownEnumDescriptions;\n                }\n                settings.push(propDetails);\n            };\n            const processConfig = (config) => {\n                if (config.properties) {\n                    for (let name in config.properties) {\n                        processProperty(name, config.properties[name]);\n                    }\n                }\n                if (config.allOf) {\n                    config.allOf.forEach(processConfig);\n                }\n            };\n            configurations.forEach(processConfig);\n            const excludedProps = configRegistry.getExcludedConfigurationProperties();\n            for (let name in excludedProps) {\n                processProperty(name, excludedProps[name]);\n            }\n            const result = {\n                settings: settings.sort((a, b) => a.name.localeCompare(b.name)),\n                buildTime: Date.now(),\n                commit: product_1.default.commit,\n                buildNumber: product_1.default.settingsSearchBuildId\n            };\n            return result;\n        }\n    };\n    DefaultConfigurationExportHelper = __decorate([\n        __param(0, environment_1.IEnvironmentService),\n        __param(1, extensions_1.IExtensionService),\n        __param(2, commands_1.ICommandService)\n    ], DefaultConfigurationExportHelper);\n    exports.DefaultConfigurationExportHelper = DefaultConfigurationExportHelper;\n});\n",null]}