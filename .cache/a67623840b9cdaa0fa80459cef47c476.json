{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/packages/vscode/src/fill/stdioElectron.ts","dependencies":[{"path":"/home/coding/workspace/packages/vscode/src/fill/stdioElectron.ts","mtime":1555841535694},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["define([\"require\", \"exports\", \"@coder/server/src/ipc\"], function (require, exports, ipc_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // TODO: Commenting out for now since the electron fill includes the client code\n    // and tries to connect to the web socket. The fill also likely wouldn't work\n    // since it assumes it is running on the client. Could we proxy all methods to\n    // the client? It might not matter since we intercept everything before sending\n    // to the shared process.\n    // export * from \"@coder/ide/src/fill/electron\";\n    class StdioIpcRenderer extends ipc_1.StdioIpcHandler {\n        // tslint:disable-next-line no-any\n        sendTo(_windowId, _channel, ..._args) {\n            throw new Error(\"Method not implemented.\");\n        }\n        // tslint:disable-next-line no-any\n        sendToHost(_channel, ..._args) {\n            throw new Error(\"Method not implemented.\");\n        }\n        eventNames() {\n            return super.eventNames();\n        }\n    }\n    exports.ipcRenderer = new StdioIpcRenderer();\n});\n",null]}