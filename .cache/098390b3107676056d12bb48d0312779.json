{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/electron-browser/terminalTaskSystem.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/electron-browser/terminalTaskSystem.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/path\", \"vs/nls\", \"vs/base/common/objects\", \"vs/base/common/types\", \"vs/base/common/platform\", \"vs/base/common/async\", \"vs/base/common/collections\", \"vs/base/common/map\", \"vs/base/common/severity\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/base/common/extpath\", \"vs/base/node/processes\", \"vs/platform/markers/common/markers\", \"vs/platform/workspace/common/workspace\", \"vs/workbench/contrib/tasks/common/problemMatcher\", \"vs/workbench/contrib/tasks/common/problemCollectors\", \"vs/workbench/contrib/tasks/common/tasks\", \"vs/workbench/contrib/tasks/common/taskSystem\", \"vs/platform/remote/common/remoteHosts\", \"vs/base/common/uri\", \"vs/base/common/network\", \"vs/workbench/contrib/terminal/node/terminal\"], function (require, exports, path, nls, Objects, Types, Platform, Async, collections_1, map_1, severity_1, event_1, lifecycle_1, extpath_1, processes_1, markers_1, workspace_1, problemMatcher_1, problemCollectors_1, tasks_1, taskSystem_1, remoteHosts_1, uri_1, network_1, terminal_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class VariableResolver {\n        constructor(workspaceFolder, taskSystemInfo, _values, _service) {\n            this.workspaceFolder = workspaceFolder;\n            this.taskSystemInfo = taskSystemInfo;\n            this._values = _values;\n            this._service = _service;\n        }\n        resolve(value) {\n            return value.replace(/\\$\\{(.*?)\\}/g, (match, variable) => {\n                // Strip out the ${} because the map contains them variables without those characters.\n                let result = this._values.get(match.substring(2, match.length - 1));\n                if ((result !== undefined) && (result !== null)) {\n                    return result;\n                }\n                if (this._service) {\n                    return this._service.resolve(this.workspaceFolder, match);\n                }\n                return match;\n            });\n        }\n    }\n    class VerifiedTask {\n        constructor(task, resolver, trigger) {\n            this.task = task;\n            this.resolver = resolver;\n            this.trigger = trigger;\n        }\n        verify() {\n            let verified = false;\n            if (this.trigger && this.resolvedVariables && this.workspaceFolder && (this.shellLaunchConfig !== undefined)) {\n                verified = true;\n            }\n            return verified;\n        }\n        getVerifiedTask() {\n            if (this.verify()) {\n                return { task: this.task, resolver: this.resolver, trigger: this.trigger, resolvedVariables: this.resolvedVariables, systemInfo: this.systemInfo, workspaceFolder: this.workspaceFolder, shellLaunchConfig: this.shellLaunchConfig };\n            }\n            else {\n                throw new Error('VerifiedTask was not checked. verify must be checked before getVerifiedTask.');\n            }\n        }\n    }\n    exports.VerifiedTask = VerifiedTask;\n    class TerminalTaskSystem {\n        constructor(terminalService, outputService, markerService, modelService, configurationResolverService, telemetryService, contextService, windowService, outputChannelId, taskSystemInfoResolver) {\n            this.terminalService = terminalService;\n            this.outputService = outputService;\n            this.markerService = markerService;\n            this.modelService = modelService;\n            this.configurationResolverService = configurationResolverService;\n            this.telemetryService = telemetryService;\n            this.contextService = contextService;\n            this.windowService = windowService;\n            this.outputChannelId = outputChannelId;\n            this.activeTasks = Object.create(null);\n            this.terminals = Object.create(null);\n            this.idleTaskTerminals = new map_1.LinkedMap();\n            this.sameTaskTerminals = Object.create(null);\n            this._onDidStateChange = new event_1.Emitter();\n            this.taskSystemInfoResolver = taskSystemInfoResolver;\n        }\n        get onDidStateChange() {\n            return this._onDidStateChange.event;\n        }\n        log(value) {\n            this.appendOutput(value + '\\n');\n        }\n        showOutput() {\n            this.outputService.showChannel(this.outputChannelId, true);\n        }\n        run(task, resolver, trigger = taskSystem_1.Triggers.command) {\n            this.currentTask = new VerifiedTask(task, resolver, trigger);\n            let terminalData = this.activeTasks[task.getMapKey()];\n            if (terminalData && terminalData.promise) {\n                let reveal = tasks_1.RevealKind.Always;\n                let focus = false;\n                if (tasks_1.CustomTask.is(task) || tasks_1.ContributedTask.is(task)) {\n                    reveal = task.command.presentation.reveal;\n                    focus = task.command.presentation.focus;\n                }\n                if (reveal === tasks_1.RevealKind.Always || focus) {\n                    this.terminalService.setActiveInstance(terminalData.terminal);\n                    this.terminalService.showPanel(focus);\n                }\n                this.lastTask = this.currentTask;\n                return { kind: taskSystem_1.TaskExecuteKind.Active, task, active: { same: true, background: task.configurationProperties.isBackground }, promise: terminalData.promise };\n            }\n            try {\n                const executeResult = { kind: taskSystem_1.TaskExecuteKind.Started, task, started: {}, promise: this.executeTask(task, resolver, trigger) };\n                executeResult.promise.then(summary => {\n                    this.lastTask = this.currentTask;\n                });\n                return executeResult;\n            }\n            catch (error) {\n                if (error instanceof taskSystem_1.TaskError) {\n                    throw error;\n                }\n                else if (error instanceof Error) {\n                    this.log(error.message);\n                    throw new taskSystem_1.TaskError(severity_1.default.Error, error.message, taskSystem_1.TaskErrors.UnknownError);\n                }\n                else {\n                    this.log(error.toString());\n                    throw new taskSystem_1.TaskError(severity_1.default.Error, nls.localize('TerminalTaskSystem.unknownError', 'A unknown error has occurred while executing a task. See task output log for details.'), taskSystem_1.TaskErrors.UnknownError);\n                }\n            }\n        }\n        rerun() {\n            if (this.lastTask && this.lastTask.verify()) {\n                if ((this.lastTask.task.runOptions.reevaluateOnRerun !== undefined) && !this.lastTask.task.runOptions.reevaluateOnRerun) {\n                    this.isRerun = true;\n                }\n                const result = this.run(this.lastTask.task, this.lastTask.resolver);\n                result.promise.then(summary => {\n                    this.isRerun = false;\n                });\n                return result;\n            }\n            else {\n                return undefined;\n            }\n        }\n        revealTask(task) {\n            let terminalData = this.activeTasks[task.getMapKey()];\n            if (!terminalData) {\n                return false;\n            }\n            this.terminalService.setActiveInstance(terminalData.terminal);\n            if (tasks_1.CustomTask.is(task) || tasks_1.ContributedTask.is(task)) {\n                this.terminalService.showPanel(task.command.presentation.focus);\n            }\n            return true;\n        }\n        isActive() {\n            return Promise.resolve(this.isActiveSync());\n        }\n        isActiveSync() {\n            return Object.keys(this.activeTasks).length > 0;\n        }\n        canAutoTerminate() {\n            return Object.keys(this.activeTasks).every(key => !this.activeTasks[key].task.configurationProperties.promptOnClose);\n        }\n        getActiveTasks() {\n            return Object.keys(this.activeTasks).map(key => this.activeTasks[key].task);\n        }\n        customExecutionComplete(task, result) {\n            let activeTerminal = this.activeTasks[task.getMapKey()];\n            if (!activeTerminal) {\n                return Promise.reject(new Error('Expected to have a terminal for an custom execution task'));\n            }\n            return new Promise((resolve) => {\n                activeTerminal.terminal.rendererExit(result);\n                resolve();\n            });\n        }\n        terminate(task) {\n            let activeTerminal = this.activeTasks[task.getMapKey()];\n            if (!activeTerminal) {\n                return Promise.resolve({ success: false, task: undefined });\n            }\n            return new Promise((resolve, reject) => {\n                let terminal = activeTerminal.terminal;\n                const onExit = terminal.onExit(() => {\n                    let task = activeTerminal.task;\n                    try {\n                        onExit.dispose();\n                        this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Terminated, task));\n                    }\n                    catch (error) {\n                        // Do nothing.\n                    }\n                    resolve({ success: true, task: task });\n                });\n                terminal.dispose();\n            });\n        }\n        terminateAll() {\n            let promises = [];\n            Object.keys(this.activeTasks).forEach((key) => {\n                let terminalData = this.activeTasks[key];\n                let terminal = terminalData.terminal;\n                promises.push(new Promise((resolve, reject) => {\n                    const onExit = terminal.onExit(() => {\n                        let task = terminalData.task;\n                        try {\n                            onExit.dispose();\n                            this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Terminated, task));\n                        }\n                        catch (error) {\n                            // Do nothing.\n                        }\n                        resolve({ success: true, task: terminalData.task });\n                    });\n                }));\n                terminal.dispose();\n            });\n            this.activeTasks = Object.create(null);\n            return Promise.all(promises);\n        }\n        executeTask(task, resolver, trigger) {\n            let promises = [];\n            if (task.configurationProperties.dependsOn) {\n                task.configurationProperties.dependsOn.forEach((dependency) => {\n                    let dependencyTask = resolver.resolve(dependency.workspaceFolder, dependency.task);\n                    if (dependencyTask) {\n                        let key = dependencyTask.getMapKey();\n                        let promise = this.activeTasks[key] ? this.activeTasks[key].promise : undefined;\n                        if (!promise) {\n                            this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.DependsOnStarted, task));\n                            promise = this.executeTask(dependencyTask, resolver, trigger);\n                        }\n                        promises.push(promise);\n                    }\n                    else {\n                        this.log(nls.localize('dependencyFailed', 'Couldn\\'t resolve dependent task \\'{0}\\' in workspace folder \\'{1}\\'', Types.isString(dependency.task) ? dependency.task : JSON.stringify(dependency.task, undefined, 0), dependency.workspaceFolder.name));\n                        this.showOutput();\n                    }\n                });\n            }\n            if ((tasks_1.ContributedTask.is(task) || tasks_1.CustomTask.is(task)) && (task.command)) {\n                return Promise.all(promises).then((summaries) => {\n                    for (let summary of summaries) {\n                        if (summary.exitCode !== 0) {\n                            return { exitCode: summary.exitCode };\n                        }\n                    }\n                    if (this.isRerun) {\n                        return this.reexecuteCommand(task, trigger);\n                    }\n                    else {\n                        return this.executeCommand(task, trigger);\n                    }\n                });\n            }\n            else {\n                return Promise.all(promises).then((summaries) => {\n                    for (let summary of summaries) {\n                        if (summary.exitCode !== 0) {\n                            return { exitCode: summary.exitCode };\n                        }\n                    }\n                    return { exitCode: 0 };\n                });\n            }\n        }\n        resolveVariablesFromSet(taskSystemInfo, workspaceFolder, task, variables) {\n            let isProcess = task.command && task.command.runtime === tasks_1.RuntimeType.Process;\n            let options = task.command && task.command.options ? task.command.options : undefined;\n            let cwd = options ? options.cwd : undefined;\n            let envPath = undefined;\n            if (options && options.env) {\n                for (let key of Object.keys(options.env)) {\n                    if (key.toLowerCase() === 'path') {\n                        if (Types.isString(options.env[key])) {\n                            envPath = options.env[key];\n                        }\n                        break;\n                    }\n                }\n            }\n            let resolvedVariables;\n            if (taskSystemInfo) {\n                let resolveSet = {\n                    variables\n                };\n                if (taskSystemInfo.platform === Platform.Platform.Windows && isProcess) {\n                    resolveSet.process = { name: tasks_1.CommandString.value(task.command.name) };\n                    if (cwd) {\n                        resolveSet.process.cwd = cwd;\n                    }\n                    if (envPath) {\n                        resolveSet.process.path = envPath;\n                    }\n                }\n                resolvedVariables = taskSystemInfo.resolveVariables(workspaceFolder, resolveSet).then(resolved => {\n                    if ((taskSystemInfo.platform !== Platform.Platform.Windows) && isProcess) {\n                        resolved.variables.set(TerminalTaskSystem.ProcessVarName, tasks_1.CommandString.value(task.command.name));\n                    }\n                    return Promise.resolve(resolved);\n                });\n                return resolvedVariables;\n            }\n            else {\n                let variablesArray = new Array();\n                variables.forEach(variable => variablesArray.push(variable));\n                return new Promise((resolve, reject) => {\n                    this.configurationResolverService.resolveWithInteraction(workspaceFolder, variablesArray, 'tasks').then(resolvedVariablesMap => {\n                        if (resolvedVariablesMap) {\n                            if (isProcess) {\n                                let processVarValue;\n                                if (Platform.isWindows) {\n                                    processVarValue = processes_1.win32.findExecutable(this.configurationResolverService.resolve(workspaceFolder, tasks_1.CommandString.value(task.command.name)), cwd ? this.configurationResolverService.resolve(workspaceFolder, cwd) : undefined, envPath ? envPath.split(path.delimiter).map(p => this.configurationResolverService.resolve(workspaceFolder, p)) : undefined);\n                                }\n                                else {\n                                    processVarValue = this.configurationResolverService.resolve(workspaceFolder, tasks_1.CommandString.value(task.command.name));\n                                }\n                                resolvedVariablesMap.set(TerminalTaskSystem.ProcessVarName, processVarValue);\n                            }\n                            let resolvedVariablesResult = {\n                                variables: resolvedVariablesMap,\n                            };\n                            resolve(resolvedVariablesResult);\n                        }\n                        else {\n                            resolve(undefined);\n                        }\n                    }, reason => {\n                        reject(reason);\n                    });\n                });\n            }\n        }\n        executeCommand(task, trigger) {\n            this.currentTask.workspaceFolder = task.getWorkspaceFolder();\n            if (this.currentTask.workspaceFolder) {\n                this.currentTask.systemInfo = this.taskSystemInfoResolver(this.currentTask.workspaceFolder);\n            }\n            let variables = new Set();\n            this.collectTaskVariables(variables, task);\n            const resolvedVariables = this.resolveVariablesFromSet(this.currentTask.systemInfo, this.currentTask.workspaceFolder, task, variables);\n            return resolvedVariables.then((resolvedVariables) => {\n                if (resolvedVariables && task.command && task.command.runtime) {\n                    this.currentTask.resolvedVariables = resolvedVariables;\n                    return this.executeInTerminal(task, trigger, new VariableResolver(this.currentTask.workspaceFolder, this.currentTask.systemInfo, resolvedVariables.variables, this.configurationResolverService));\n                }\n                else {\n                    return Promise.resolve({ exitCode: 0 });\n                }\n            }, reason => {\n                return Promise.reject(reason);\n            });\n        }\n        reexecuteCommand(task, trigger) {\n            this.currentTask.workspaceFolder = this.lastTask.workspaceFolder;\n            let variables = new Set();\n            this.collectTaskVariables(variables, task);\n            // Check that the task hasn't changed to include new variables\n            let hasAllVariables = true;\n            variables.forEach(value => {\n                if (value.substring(2, value.length - 1) in this.lastTask.getVerifiedTask().resolvedVariables) {\n                    hasAllVariables = false;\n                }\n            });\n            if (!hasAllVariables) {\n                return this.resolveVariablesFromSet(this.lastTask.getVerifiedTask().systemInfo, this.lastTask.getVerifiedTask().workspaceFolder, task, variables).then((resolvedVariables) => {\n                    this.currentTask.resolvedVariables = resolvedVariables;\n                    return this.executeInTerminal(task, trigger, new VariableResolver(this.lastTask.getVerifiedTask().workspaceFolder, this.lastTask.getVerifiedTask().systemInfo, resolvedVariables.variables, this.configurationResolverService));\n                }, reason => {\n                    return Promise.reject(reason);\n                });\n            }\n            else {\n                this.currentTask.resolvedVariables = this.lastTask.getVerifiedTask().resolvedVariables;\n                return this.executeInTerminal(task, trigger, new VariableResolver(this.lastTask.getVerifiedTask().workspaceFolder, this.lastTask.getVerifiedTask().systemInfo, this.lastTask.getVerifiedTask().resolvedVariables.variables, this.configurationResolverService));\n            }\n        }\n        executeInTerminal(task, trigger, resolver) {\n            let terminal = undefined;\n            let executedCommand = undefined;\n            let error = undefined;\n            let promise = undefined;\n            if (task.configurationProperties.isBackground) {\n                promise = new Promise((resolve, reject) => {\n                    const problemMatchers = this.resolveMatchers(resolver, task.configurationProperties.problemMatchers);\n                    let watchingProblemMatcher = new problemCollectors_1.WatchingProblemCollector(problemMatchers, this.markerService, this.modelService);\n                    let toDispose = [];\n                    let eventCounter = 0;\n                    toDispose.push(watchingProblemMatcher.onDidStateChange((event) => {\n                        if (event.kind === problemCollectors_1.ProblemCollectorEventKind.BackgroundProcessingBegins) {\n                            eventCounter++;\n                            this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Active, task));\n                        }\n                        else if (event.kind === problemCollectors_1.ProblemCollectorEventKind.BackgroundProcessingEnds) {\n                            eventCounter--;\n                            this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Inactive, task));\n                            if (eventCounter === 0) {\n                                let reveal = task.command.presentation.reveal;\n                                if ((reveal === tasks_1.RevealKind.Silent) && (watchingProblemMatcher.numberOfMatches > 0) && watchingProblemMatcher.maxMarkerSeverity &&\n                                    (watchingProblemMatcher.maxMarkerSeverity >= markers_1.MarkerSeverity.Error)) {\n                                    this.terminalService.setActiveInstance(terminal);\n                                    this.terminalService.showPanel(false);\n                                }\n                            }\n                        }\n                    }));\n                    watchingProblemMatcher.aboutToStart();\n                    let delayer = undefined;\n                    [terminal, executedCommand, error] = this.createTerminal(task, resolver);\n                    if (error || !terminal) {\n                        return;\n                    }\n                    let processStartedSignaled = false;\n                    terminal.processReady.then(() => {\n                        if (!processStartedSignaled) {\n                            if (task.command.runtime !== tasks_1.RuntimeType.CustomExecution) {\n                                this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.ProcessStarted, task, terminal.processId));\n                            }\n                            processStartedSignaled = true;\n                        }\n                    }, (_error) => {\n                        // The process never got ready. Need to think how to handle this.\n                    });\n                    this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Start, task, terminal.id));\n                    const registeredLinkMatchers = this.registerLinkMatchers(terminal, problemMatchers);\n                    const onData = terminal.onLineData((line) => {\n                        watchingProblemMatcher.processLine(line);\n                        if (!delayer) {\n                            delayer = new Async.Delayer(3000);\n                        }\n                        delayer.trigger(() => {\n                            watchingProblemMatcher.forceDelivery();\n                            delayer = undefined;\n                        });\n                    });\n                    const onExit = terminal.onExit((exitCode) => {\n                        onData.dispose();\n                        onExit.dispose();\n                        let key = task.getMapKey();\n                        delete this.activeTasks[key];\n                        this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Changed));\n                        if (exitCode !== undefined) {\n                            // Only keep a reference to the terminal if it is not being disposed.\n                            switch (task.command.presentation.panel) {\n                                case tasks_1.PanelKind.Dedicated:\n                                    this.sameTaskTerminals[key] = terminal.id.toString();\n                                    break;\n                                case tasks_1.PanelKind.Shared:\n                                    this.idleTaskTerminals.set(key, terminal.id.toString(), map_1.Touch.AsOld);\n                                    break;\n                            }\n                        }\n                        let reveal = task.command.presentation.reveal;\n                        if ((reveal === tasks_1.RevealKind.Silent) && ((exitCode !== 0) || (watchingProblemMatcher.numberOfMatches > 0) && watchingProblemMatcher.maxMarkerSeverity &&\n                            (watchingProblemMatcher.maxMarkerSeverity >= markers_1.MarkerSeverity.Error))) {\n                            this.terminalService.setActiveInstance(terminal);\n                            this.terminalService.showPanel(false);\n                        }\n                        watchingProblemMatcher.done();\n                        watchingProblemMatcher.dispose();\n                        registeredLinkMatchers.forEach(handle => terminal.deregisterLinkMatcher(handle));\n                        if (!processStartedSignaled) {\n                            this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.ProcessStarted, task, terminal.processId));\n                            processStartedSignaled = true;\n                        }\n                        if (task.command.runtime !== tasks_1.RuntimeType.CustomExecution) {\n                            this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.ProcessEnded, task, exitCode));\n                        }\n                        for (let i = 0; i < eventCounter; i++) {\n                            let event = tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Inactive, task);\n                            this._onDidStateChange.fire(event);\n                        }\n                        eventCounter = 0;\n                        this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.End, task));\n                        toDispose = lifecycle_1.dispose(toDispose);\n                        toDispose = undefined;\n                        resolve({ exitCode });\n                    });\n                });\n            }\n            else {\n                promise = new Promise((resolve, reject) => {\n                    [terminal, executedCommand, error] = this.createTerminal(task, resolver);\n                    if (!terminal || error) {\n                        return;\n                    }\n                    let processStartedSignaled = false;\n                    terminal.processReady.then(() => {\n                        if (!processStartedSignaled) {\n                            if (task.command.runtime !== tasks_1.RuntimeType.CustomExecution) {\n                                this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.ProcessStarted, task, terminal.processId));\n                            }\n                            processStartedSignaled = true;\n                        }\n                    }, (_error) => {\n                        // The process never got ready. Need to think how to handle this.\n                    });\n                    this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Start, task, terminal.id));\n                    this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Active, task));\n                    let problemMatchers = this.resolveMatchers(resolver, task.configurationProperties.problemMatchers);\n                    let startStopProblemMatcher = new problemCollectors_1.StartStopProblemCollector(problemMatchers, this.markerService, this.modelService);\n                    const registeredLinkMatchers = this.registerLinkMatchers(terminal, problemMatchers);\n                    const onData = terminal.onLineData((line) => {\n                        startStopProblemMatcher.processLine(line);\n                    });\n                    const onExit = terminal.onExit((exitCode) => {\n                        onData.dispose();\n                        onExit.dispose();\n                        let key = task.getMapKey();\n                        delete this.activeTasks[key];\n                        this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Changed));\n                        if (exitCode !== undefined) {\n                            // Only keep a reference to the terminal if it is not being disposed.\n                            switch (task.command.presentation.panel) {\n                                case tasks_1.PanelKind.Dedicated:\n                                    this.sameTaskTerminals[key] = terminal.id.toString();\n                                    break;\n                                case tasks_1.PanelKind.Shared:\n                                    this.idleTaskTerminals.set(key, terminal.id.toString(), map_1.Touch.AsOld);\n                                    break;\n                            }\n                        }\n                        let reveal = task.command.presentation.reveal;\n                        if (terminal && (reveal === tasks_1.RevealKind.Silent) && ((exitCode !== 0) || (startStopProblemMatcher.numberOfMatches > 0) && startStopProblemMatcher.maxMarkerSeverity &&\n                            (startStopProblemMatcher.maxMarkerSeverity >= markers_1.MarkerSeverity.Error))) {\n                            this.terminalService.setActiveInstance(terminal);\n                            this.terminalService.showPanel(false);\n                        }\n                        startStopProblemMatcher.done();\n                        startStopProblemMatcher.dispose();\n                        registeredLinkMatchers.forEach(handle => {\n                            if (terminal) {\n                                terminal.deregisterLinkMatcher(handle);\n                            }\n                        });\n                        if (!processStartedSignaled && terminal) {\n                            this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.ProcessStarted, task, terminal.processId));\n                            processStartedSignaled = true;\n                        }\n                        if (task.command.runtime !== tasks_1.RuntimeType.CustomExecution) {\n                            this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.ProcessEnded, task, exitCode));\n                        }\n                        this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Inactive, task));\n                        this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.End, task));\n                        resolve({ exitCode });\n                    });\n                });\n            }\n            if (error) {\n                return Promise.reject(new Error(error.message));\n            }\n            if (!terminal) {\n                return Promise.reject(new Error(`Failed to create terminal for task ${task._label}`));\n            }\n            if (task.command.presentation && (task.command.presentation.reveal === tasks_1.RevealKind.Always)) {\n                this.terminalService.setActiveInstance(terminal);\n                this.terminalService.showPanel(task.command.presentation.focus);\n            }\n            this.activeTasks[task.getMapKey()] = { terminal, task, promise };\n            this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Changed));\n            return promise.then((summary) => {\n                try {\n                    let telemetryEvent = {\n                        trigger: trigger,\n                        runner: 'terminal',\n                        taskKind: task.getTelemetryKind(),\n                        command: this.getSanitizedCommand(executedCommand),\n                        success: true,\n                        exitCode: summary.exitCode\n                    };\n                    /* __GDPR__\n                        \"taskService\" : {\n                            \"${include}\": [\n                                \"${TelemetryEvent}\"\n                            ]\n                        }\n                    */\n                    this.telemetryService.publicLog(TerminalTaskSystem.TelemetryEventName, telemetryEvent);\n                }\n                catch (error) {\n                }\n                return summary;\n            }, (error) => {\n                try {\n                    let telemetryEvent = {\n                        trigger: trigger,\n                        runner: 'terminal',\n                        taskKind: task.getTelemetryKind(),\n                        command: this.getSanitizedCommand(executedCommand),\n                        success: false\n                    };\n                    /* __GDPR__\n                        \"taskService\" : {\n                            \"${include}\": [\n                                \"${TelemetryEvent}\"\n                            ]\n                        }\n                    */\n                    this.telemetryService.publicLog(TerminalTaskSystem.TelemetryEventName, telemetryEvent);\n                }\n                catch (error) {\n                }\n                return Promise.reject(error);\n            });\n        }\n        createTerminalName(task) {\n            const needsFolderQualification = this.currentTask.workspaceFolder && this.contextService.getWorkbenchState() === workspace_1.WorkbenchState.WORKSPACE;\n            return nls.localize('TerminalTaskSystem.terminalName', 'Task - {0}', needsFolderQualification ? task.getQualifiedLabel() : task.configurationProperties.name);\n        }\n        createShellLaunchConfig(task, variableResolver, platform, options, command, args, waitOnExit) {\n            let shellLaunchConfig;\n            let isShellCommand = task.command.runtime === tasks_1.RuntimeType.Shell;\n            let needsFolderQualification = this.currentTask.workspaceFolder && this.contextService.getWorkbenchState() === workspace_1.WorkbenchState.WORKSPACE;\n            let terminalName = this.createTerminalName(task);\n            let originalCommand = task.command.name;\n            if (isShellCommand) {\n                shellLaunchConfig = { name: terminalName, executable: undefined, args: undefined, waitOnExit };\n                this.terminalService.configHelper.mergeDefaultShellPathAndArgs(shellLaunchConfig, platform);\n                let shellSpecified = false;\n                let shellOptions = task.command.options && task.command.options.shell;\n                if (shellOptions) {\n                    if (shellOptions.executable) {\n                        shellLaunchConfig.executable = this.resolveVariable(variableResolver, shellOptions.executable);\n                        shellSpecified = true;\n                    }\n                    if (shellOptions.args) {\n                        shellLaunchConfig.args = this.resolveVariables(variableResolver, shellOptions.args.slice());\n                    }\n                    else {\n                        shellLaunchConfig.args = [];\n                    }\n                }\n                let shellArgs = shellLaunchConfig.args.slice(0);\n                let toAdd = [];\n                let commandLine = this.buildShellCommandLine(platform, shellLaunchConfig.executable, shellOptions, command, originalCommand, args);\n                let windowsShellArgs = false;\n                if (platform === Platform.Platform.Windows) {\n                    // Change Sysnative to System32 if the OS is Windows but NOT WoW64. It's\n                    // safe to assume that this was used by accident as Sysnative does not\n                    // exist and will break the terminal in non-WoW64 environments.\n                    if (!process.env.hasOwnProperty('PROCESSOR_ARCHITEW6432')) {\n                        const sysnativePath = path.join(process.env.windir, 'Sysnative').toLowerCase();\n                        if (shellLaunchConfig.executable.toLowerCase().indexOf(sysnativePath) === 0) {\n                            shellLaunchConfig.executable = path.join(process.env.windir, 'System32', shellLaunchConfig.executable.substr(sysnativePath.length));\n                        }\n                    }\n                    windowsShellArgs = true;\n                    let basename = path.basename(shellLaunchConfig.executable).toLowerCase();\n                    if (basename === 'cmd.exe' && ((options.cwd && extpath_1.isUNC(options.cwd)) || (!options.cwd && extpath_1.isUNC(process.cwd())))) {\n                        return undefined;\n                    }\n                    if ((basename === 'powershell.exe') || (basename === 'pwsh.exe')) {\n                        if (!shellSpecified) {\n                            toAdd.push('-Command');\n                        }\n                    }\n                    else if ((basename === 'bash.exe') || (basename === 'zsh.exe')) {\n                        windowsShellArgs = false;\n                        if (!shellSpecified) {\n                            toAdd.push('-c');\n                        }\n                    }\n                    else if (basename === 'wsl.exe') {\n                        if (!shellSpecified && (terminal_1.getWindowsBuildNumber() >= 17763)) { // See https://github.com/Microsoft/vscode/issues/67855\n                            toAdd.push('-e');\n                        }\n                    }\n                    else {\n                        if (!shellSpecified) {\n                            toAdd.push('/d', '/c');\n                        }\n                    }\n                }\n                else {\n                    if (!shellSpecified) {\n                        // Under Mac remove -l to not start it as a login shell.\n                        if (platform === Platform.Platform.Mac) {\n                            let index = shellArgs.indexOf('-l');\n                            if (index !== -1) {\n                                shellArgs.splice(index, 1);\n                            }\n                        }\n                        toAdd.push('-c');\n                    }\n                }\n                toAdd.forEach(element => {\n                    if (!shellArgs.some(arg => arg.toLowerCase() === element)) {\n                        shellArgs.push(element);\n                    }\n                });\n                shellArgs.push(commandLine);\n                shellLaunchConfig.args = windowsShellArgs ? shellArgs.join(' ') : shellArgs;\n                if (task.command.presentation && task.command.presentation.echo) {\n                    if (needsFolderQualification) {\n                        shellLaunchConfig.initialText = `\\x1b[1m> Executing task in folder ${this.currentTask.workspaceFolder.name}: ${commandLine} <\\x1b[0m\\n`;\n                    }\n                    else {\n                        shellLaunchConfig.initialText = `\\x1b[1m> Executing task: ${commandLine} <\\x1b[0m\\n`;\n                    }\n                }\n            }\n            else {\n                let commandExecutable = task.command.runtime !== tasks_1.RuntimeType.CustomExecution ? tasks_1.CommandString.value(command) : undefined;\n                let executable = !isShellCommand\n                    ? this.resolveVariable(variableResolver, '${' + TerminalTaskSystem.ProcessVarName + '}')\n                    : commandExecutable;\n                // When we have a process task there is no need to quote arguments. So we go ahead and take the string value.\n                shellLaunchConfig = {\n                    name: terminalName,\n                    executable: executable,\n                    args: args.map(a => Types.isString(a) ? a : a.value),\n                    waitOnExit\n                };\n                if (task.command.presentation && task.command.presentation.echo) {\n                    let getArgsToEcho = (args) => {\n                        if (!args || args.length === 0) {\n                            return '';\n                        }\n                        if (Types.isString(args)) {\n                            return args;\n                        }\n                        return args.join(' ');\n                    };\n                    if (needsFolderQualification) {\n                        shellLaunchConfig.initialText = `\\x1b[1m> Executing task in folder ${this.currentTask.workspaceFolder.name}: ${shellLaunchConfig.executable} ${getArgsToEcho(shellLaunchConfig.args)} <\\x1b[0m\\n`;\n                    }\n                    else {\n                        shellLaunchConfig.initialText = `\\x1b[1m> Executing task: ${shellLaunchConfig.executable} ${getArgsToEcho(shellLaunchConfig.args)} <\\x1b[0m\\n`;\n                    }\n                }\n            }\n            if (options.cwd) {\n                let cwd = options.cwd;\n                if (!path.isAbsolute(cwd)) {\n                    let workspaceFolder = task.getWorkspaceFolder();\n                    if (workspaceFolder && (workspaceFolder.uri.scheme === 'file')) {\n                        cwd = path.join(workspaceFolder.uri.fsPath, cwd);\n                    }\n                }\n                // This must be normalized to the OS\n                const authority = this.windowService.getConfiguration().remoteAuthority;\n                shellLaunchConfig.cwd = uri_1.URI.from({ scheme: authority ? remoteHosts_1.REMOTE_HOST_SCHEME : network_1.Schemas.file, authority: authority, path: cwd });\n            }\n            if (options.env) {\n                shellLaunchConfig.env = options.env;\n            }\n            return shellLaunchConfig;\n        }\n        createTerminal(task, resolver) {\n            let platform = resolver.taskSystemInfo ? resolver.taskSystemInfo.platform : Platform.platform;\n            let options = this.resolveOptions(resolver, task.command.options);\n            let waitOnExit = false;\n            const presentationOptions = task.command.presentation;\n            if (!presentationOptions) {\n                throw new Error('Task presentation options should not be undefined here.');\n            }\n            if (presentationOptions.reveal !== tasks_1.RevealKind.Never || !task.configurationProperties.isBackground) {\n                if (presentationOptions.panel === tasks_1.PanelKind.New) {\n                    waitOnExit = nls.localize('closeTerminal', 'Press any key to close the terminal.');\n                }\n                else if (presentationOptions.showReuseMessage) {\n                    waitOnExit = nls.localize('reuseTerminal', 'Terminal will be reused by tasks, press any key to close it.');\n                }\n                else {\n                    waitOnExit = true;\n                }\n            }\n            let commandExecutable;\n            let command;\n            let args;\n            if (task.command.runtime === tasks_1.RuntimeType.CustomExecution) {\n                this.currentTask.shellLaunchConfig = {\n                    isRendererOnly: true,\n                    waitOnExit,\n                    name: this.createTerminalName(task),\n                    initialText: task.command.presentation && task.command.presentation.echo ? `\\x1b[1m> Executing task: ${task._label} <\\x1b[0m\\n` : undefined\n                };\n            }\n            else {\n                let resolvedResult = this.resolveCommandAndArgs(resolver, task.command);\n                command = resolvedResult.command;\n                args = resolvedResult.args;\n                commandExecutable = tasks_1.CommandString.value(command);\n                this.currentTask.shellLaunchConfig = this.isRerun ? this.lastTask.getVerifiedTask().shellLaunchConfig : this.createShellLaunchConfig(task, resolver, platform, options, command, args, waitOnExit);\n                if (this.currentTask.shellLaunchConfig === undefined) {\n                    return [undefined, undefined, new taskSystem_1.TaskError(severity_1.default.Error, nls.localize('TerminalTaskSystem', 'Can\\'t execute a shell command on an UNC drive using cmd.exe.'), taskSystem_1.TaskErrors.UnknownError)];\n                }\n            }\n            let prefersSameTerminal = presentationOptions.panel === tasks_1.PanelKind.Dedicated;\n            let allowsSharedTerminal = presentationOptions.panel === tasks_1.PanelKind.Shared;\n            let group = presentationOptions.group;\n            let taskKey = task.getMapKey();\n            let terminalToReuse;\n            if (prefersSameTerminal) {\n                let terminalId = this.sameTaskTerminals[taskKey];\n                if (terminalId) {\n                    terminalToReuse = this.terminals[terminalId];\n                    delete this.sameTaskTerminals[taskKey];\n                }\n            }\n            else if (allowsSharedTerminal) {\n                // Always allow to reuse the terminal previously used by the same task.\n                let terminalId = this.idleTaskTerminals.remove(taskKey);\n                if (!terminalId) {\n                    // There is no idle terminal which was used by the same task.\n                    // Search for any idle terminal used previously by a task of the same group\n                    // (or, if the task has no group, a terminal used by a task without group).\n                    for (const taskId of this.idleTaskTerminals.keys()) {\n                        const idleTerminalId = this.idleTaskTerminals.get(taskId);\n                        if (idleTerminalId && this.terminals[idleTerminalId] && this.terminals[idleTerminalId].group === group) {\n                            terminalId = this.idleTaskTerminals.remove(taskId);\n                            break;\n                        }\n                    }\n                }\n                if (terminalId) {\n                    terminalToReuse = this.terminals[terminalId];\n                }\n            }\n            if (terminalToReuse) {\n                if (!this.currentTask.shellLaunchConfig) {\n                    throw new Error('Task shell launch configuration should not be undefined here.');\n                }\n                terminalToReuse.terminal.reuseTerminal(this.currentTask.shellLaunchConfig);\n                if (task.command.presentation && task.command.presentation.clear) {\n                    terminalToReuse.terminal.clear();\n                }\n                this.terminals[terminalToReuse.terminal.id.toString()].lastTask = taskKey;\n                return [terminalToReuse.terminal, commandExecutable, undefined];\n            }\n            let result = null;\n            if (group) {\n                // Try to find an existing terminal to split.\n                // Even if an existing terminal is found, the split can fail if the terminal width is too small.\n                for (const terminal of collections_1.values(this.terminals)) {\n                    if (terminal.group === group) {\n                        const originalInstance = terminal.terminal;\n                        const config = this.currentTask.shellLaunchConfig;\n                        result = this.terminalService.splitInstance(originalInstance, config);\n                        if (result) {\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!result) {\n                // Either no group is used, no terminal with the group exists or splitting an existing terminal failed.\n                result = this.terminalService.createTerminal(this.currentTask.shellLaunchConfig);\n            }\n            const terminalKey = result.id.toString();\n            result.onDisposed((terminal) => {\n                let terminalData = this.terminals[terminalKey];\n                if (terminalData) {\n                    delete this.terminals[terminalKey];\n                    delete this.sameTaskTerminals[terminalData.lastTask];\n                    this.idleTaskTerminals.delete(terminalData.lastTask);\n                    // Delete the task now as a work around for cases when the onExit isn't fired.\n                    // This can happen if the terminal wasn't shutdown with an \"immediate\" flag and is expected.\n                    // For correct terminal re-use, the task needs to be deleted immediately.\n                    // Note that this shouldn't be a problem anymore since user initiated terminal kills are now immediate.\n                    delete this.activeTasks[task.getMapKey()];\n                }\n            });\n            this.terminals[terminalKey] = { terminal: result, lastTask: taskKey, group };\n            return [result, commandExecutable, undefined];\n        }\n        buildShellCommandLine(platform, shellExecutable, shellOptions, command, originalCommand, args) {\n            let basename = path.parse(shellExecutable).name.toLowerCase();\n            let shellQuoteOptions = this.getQuotingOptions(basename, shellOptions);\n            function needsQuotes(value) {\n                if (value.length >= 2) {\n                    let first = value[0] === shellQuoteOptions.strong ? shellQuoteOptions.strong : value[0] === shellQuoteOptions.weak ? shellQuoteOptions.weak : undefined;\n                    if (first === value[value.length - 1]) {\n                        return false;\n                    }\n                }\n                let quote;\n                for (let i = 0; i < value.length; i++) {\n                    // We found the end quote.\n                    let ch = value[i];\n                    if (ch === quote) {\n                        quote = undefined;\n                    }\n                    else if (quote !== undefined) {\n                        // skip the character. We are quoted.\n                        continue;\n                    }\n                    else if (ch === shellQuoteOptions.escape) {\n                        // Skip the next character\n                        i++;\n                    }\n                    else if (ch === shellQuoteOptions.strong || ch === shellQuoteOptions.weak) {\n                        quote = ch;\n                    }\n                    else if (ch === ' ') {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            function quote(value, kind) {\n                if (kind === tasks_1.ShellQuoting.Strong && shellQuoteOptions.strong) {\n                    return [shellQuoteOptions.strong + value + shellQuoteOptions.strong, true];\n                }\n                else if (kind === tasks_1.ShellQuoting.Weak && shellQuoteOptions.weak) {\n                    return [shellQuoteOptions.weak + value + shellQuoteOptions.weak, true];\n                }\n                else if (kind === tasks_1.ShellQuoting.Escape && shellQuoteOptions.escape) {\n                    if (Types.isString(shellQuoteOptions.escape)) {\n                        return [value.replace(/ /g, shellQuoteOptions.escape + ' '), true];\n                    }\n                    else {\n                        let buffer = [];\n                        for (let ch of shellQuoteOptions.escape.charsToEscape) {\n                            buffer.push(`\\\\${ch}`);\n                        }\n                        let regexp = new RegExp('[' + buffer.join(',') + ']', 'g');\n                        let escapeChar = shellQuoteOptions.escape.escapeChar;\n                        return [value.replace(regexp, (match) => escapeChar + match), true];\n                    }\n                }\n                return [value, false];\n            }\n            function quoteIfNecessary(value) {\n                if (Types.isString(value)) {\n                    if (needsQuotes(value)) {\n                        return quote(value, tasks_1.ShellQuoting.Strong);\n                    }\n                    else {\n                        return [value, false];\n                    }\n                }\n                else {\n                    return quote(value.value, value.quoting);\n                }\n            }\n            // If we have no args and the command is a string then use the command to stay backwards compatible with the old command line\n            // model. To allow variable resolving with spaces we do continue if the resolved value is different than the original one\n            // and the resolved one needs quoting.\n            if ((!args || args.length === 0) && Types.isString(command) && (command === originalCommand || needsQuotes(originalCommand))) {\n                return command;\n            }\n            let result = [];\n            let commandQuoted = false;\n            let argQuoted = false;\n            let value;\n            let quoted;\n            [value, quoted] = quoteIfNecessary(command);\n            result.push(value);\n            commandQuoted = quoted;\n            for (let arg of args) {\n                [value, quoted] = quoteIfNecessary(arg);\n                result.push(value);\n                argQuoted = argQuoted || quoted;\n            }\n            let commandLine = result.join(' ');\n            // There are special rules quoted command line in cmd.exe\n            if (platform === Platform.Platform.Windows) {\n                if (basename === 'cmd' && commandQuoted && argQuoted) {\n                    commandLine = '\"' + commandLine + '\"';\n                }\n                else if (basename === 'powershell' && commandQuoted) {\n                    commandLine = '& ' + commandLine;\n                }\n            }\n            if (basename === 'cmd' && platform === Platform.Platform.Windows && commandQuoted && argQuoted) {\n                commandLine = '\"' + commandLine + '\"';\n            }\n            return commandLine;\n        }\n        getQuotingOptions(shellBasename, shellOptions) {\n            if (shellOptions && shellOptions.quoting) {\n                return shellOptions.quoting;\n            }\n            return TerminalTaskSystem.shellQuotes[shellBasename] || TerminalTaskSystem.osShellQuotes[process.platform];\n        }\n        collectTaskVariables(variables, task) {\n            if (task.command && task.command.name) {\n                this.collectCommandVariables(variables, task.command, task);\n            }\n            this.collectMatcherVariables(variables, task.configurationProperties.problemMatchers);\n        }\n        collectCommandVariables(variables, command, task) {\n            // The custom execution should have everything it needs already as it provided\n            // the callback.\n            if (command.runtime === tasks_1.RuntimeType.CustomExecution) {\n                return;\n            }\n            if (command.name === undefined) {\n                throw new Error('Command name should never be undefined here.');\n            }\n            this.collectVariables(variables, command.name);\n            if (command.args) {\n                command.args.forEach(arg => this.collectVariables(variables, arg));\n            }\n            // Try to get a scope.\n            const scope = task._source.scope;\n            if (scope !== tasks_1.TaskScope.Global) {\n                variables.add('${workspaceFolder}');\n            }\n            if (command.options) {\n                let options = command.options;\n                if (options.cwd) {\n                    this.collectVariables(variables, options.cwd);\n                }\n                const optionsEnv = options.env;\n                if (optionsEnv) {\n                    Object.keys(optionsEnv).forEach((key) => {\n                        let value = optionsEnv[key];\n                        if (Types.isString(value)) {\n                            this.collectVariables(variables, value);\n                        }\n                    });\n                }\n                if (options.shell) {\n                    if (options.shell.executable) {\n                        this.collectVariables(variables, options.shell.executable);\n                    }\n                    if (options.shell.args) {\n                        options.shell.args.forEach(arg => this.collectVariables(variables, arg));\n                    }\n                }\n            }\n        }\n        collectMatcherVariables(variables, values) {\n            if (values === undefined || values === null || values.length === 0) {\n                return;\n            }\n            values.forEach((value) => {\n                let matcher;\n                if (Types.isString(value)) {\n                    if (value[0] === '$') {\n                        matcher = problemMatcher_1.ProblemMatcherRegistry.get(value.substring(1));\n                    }\n                    else {\n                        matcher = problemMatcher_1.ProblemMatcherRegistry.get(value);\n                    }\n                }\n                else {\n                    matcher = value;\n                }\n                if (matcher && matcher.filePrefix) {\n                    this.collectVariables(variables, matcher.filePrefix);\n                }\n            });\n        }\n        collectVariables(variables, value) {\n            let string = Types.isString(value) ? value : value.value;\n            let r = /\\$\\{(.*?)\\}/g;\n            let matches;\n            do {\n                matches = r.exec(string);\n                if (matches) {\n                    variables.add(matches[0]);\n                }\n            } while (matches);\n        }\n        resolveCommandAndArgs(resolver, commandConfig) {\n            // First we need to use the command args:\n            let args = commandConfig.args ? commandConfig.args.slice() : [];\n            args = this.resolveVariables(resolver, args);\n            let command = this.resolveVariable(resolver, commandConfig.name);\n            return { command, args };\n        }\n        resolveVariables(resolver, value) {\n            return value.map(s => this.resolveVariable(resolver, s));\n        }\n        resolveMatchers(resolver, values) {\n            if (values === undefined || values === null || values.length === 0) {\n                return [];\n            }\n            let result = [];\n            values.forEach((value) => {\n                let matcher;\n                if (Types.isString(value)) {\n                    if (value[0] === '$') {\n                        matcher = problemMatcher_1.ProblemMatcherRegistry.get(value.substring(1));\n                    }\n                    else {\n                        matcher = problemMatcher_1.ProblemMatcherRegistry.get(value);\n                    }\n                }\n                else {\n                    matcher = value;\n                }\n                if (!matcher) {\n                    this.appendOutput(nls.localize('unkownProblemMatcher', 'Problem matcher {0} can\\'t be resolved. The matcher will be ignored'));\n                    return;\n                }\n                let taskSystemInfo = resolver.taskSystemInfo;\n                let hasFilePrefix = matcher.filePrefix !== undefined;\n                let hasUriProvider = taskSystemInfo !== undefined && taskSystemInfo.uriProvider !== undefined;\n                if (!hasFilePrefix && !hasUriProvider) {\n                    result.push(matcher);\n                }\n                else {\n                    let copy = Objects.deepClone(matcher);\n                    if (hasUriProvider && (taskSystemInfo !== undefined)) {\n                        copy.uriProvider = taskSystemInfo.uriProvider;\n                    }\n                    if (hasFilePrefix) {\n                        copy.filePrefix = this.resolveVariable(resolver, copy.filePrefix);\n                    }\n                    result.push(copy);\n                }\n            });\n            return result;\n        }\n        resolveVariable(resolver, value) {\n            // TODO@Dirk Task.getWorkspaceFolder should return a WorkspaceFolder that is defined in workspace.ts\n            if (Types.isString(value)) {\n                return resolver.resolve(value);\n            }\n            else if (value !== undefined) {\n                return {\n                    value: resolver.resolve(value.value),\n                    quoting: value.quoting\n                };\n            }\n            else { // This should never happen\n                throw new Error('Should never try to resolve undefined.');\n            }\n        }\n        resolveOptions(resolver, options) {\n            if (options === undefined || options === null) {\n                return { cwd: this.resolveVariable(resolver, '${workspaceFolder}') };\n            }\n            let result = Types.isString(options.cwd)\n                ? { cwd: this.resolveVariable(resolver, options.cwd) }\n                : { cwd: this.resolveVariable(resolver, '${workspaceFolder}') };\n            if (options.env) {\n                result.env = Object.create(null);\n                Object.keys(options.env).forEach((key) => {\n                    let value = options.env[key];\n                    if (Types.isString(value)) {\n                        result.env[key] = this.resolveVariable(resolver, value);\n                    }\n                    else {\n                        result.env[key] = value.toString();\n                    }\n                });\n            }\n            return result;\n        }\n        registerLinkMatchers(terminal, problemMatchers) {\n            let result = [];\n            /*\n            let handlePattern = (matcher: ProblemMatcher, pattern: ProblemPattern): void => {\n                if (pattern.regexp instanceof RegExp && Types.isNumber(pattern.file)) {\n                    result.push(terminal.registerLinkMatcher(pattern.regexp, (match: string) => {\n                        let resource: URI = getResource(match, matcher);\n                        if (resource) {\n                            this.workbenchEditorService.openEditor({\n                                resource: resource\n                            });\n                        }\n                    }, 0));\n                }\n            };\n    \n            for (let problemMatcher of problemMatchers) {\n                if (Array.isArray(problemMatcher.pattern)) {\n                    for (let pattern of problemMatcher.pattern) {\n                        handlePattern(problemMatcher, pattern);\n                    }\n                } else if (problemMatcher.pattern) {\n                    handlePattern(problemMatcher, problemMatcher.pattern);\n                }\n            }\n            */\n            return result;\n        }\n        getSanitizedCommand(cmd) {\n            let result = cmd.toLowerCase();\n            let index = result.lastIndexOf(path.sep);\n            if (index !== -1) {\n                result = result.substring(index + 1);\n            }\n            if (TerminalTaskSystem.WellKnowCommands[result]) {\n                return result;\n            }\n            return 'other';\n        }\n        appendOutput(output) {\n            const outputChannel = this.outputService.getChannel(this.outputChannelId);\n            if (outputChannel) {\n                outputChannel.append(output);\n            }\n        }\n    }\n    TerminalTaskSystem.TelemetryEventName = 'taskService';\n    TerminalTaskSystem.ProcessVarName = '__process__';\n    TerminalTaskSystem.shellQuotes = {\n        'cmd': {\n            strong: '\"'\n        },\n        'powershell': {\n            escape: {\n                escapeChar: '`',\n                charsToEscape: ' \"\\'()'\n            },\n            strong: '\\'',\n            weak: '\"'\n        },\n        'bash': {\n            escape: {\n                escapeChar: '\\\\',\n                charsToEscape: ' \"\\''\n            },\n            strong: '\\'',\n            weak: '\"'\n        },\n        'zsh': {\n            escape: {\n                escapeChar: '\\\\',\n                charsToEscape: ' \"\\''\n            },\n            strong: '\\'',\n            weak: '\"'\n        }\n    };\n    TerminalTaskSystem.osShellQuotes = {\n        'linux': TerminalTaskSystem.shellQuotes['bash'],\n        'darwin': TerminalTaskSystem.shellQuotes['bash'],\n        'win32': TerminalTaskSystem.shellQuotes['powershell']\n    };\n    TerminalTaskSystem.WellKnowCommands = {\n        'ant': true,\n        'cmake': true,\n        'eslint': true,\n        'gradle': true,\n        'grunt': true,\n        'gulp': true,\n        'jake': true,\n        'jenkins': true,\n        'jshint': true,\n        'make': true,\n        'maven': true,\n        'msbuild': true,\n        'msc': true,\n        'nmake': true,\n        'npm': true,\n        'rake': true,\n        'tsc': true,\n        'xbuild': true\n    };\n    exports.TerminalTaskSystem = TerminalTaskSystem;\n});\n",null]}