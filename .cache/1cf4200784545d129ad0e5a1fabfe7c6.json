{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/packages/ide/src/upload.ts","dependencies":[{"path":"/home/coding/workspace/packages/ide/src/upload.ts","mtime":1555841535682},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar child_process_1 = require(\"child_process\");\nvar fs_1 = require(\"fs\");\nvar util_1 = require(\"util\");\nvar logger_1 = require(\"@coder/logger\");\nvar protocol_1 = require(\"@coder/protocol\");\nvar notification_1 = require(\"./fill/notification\");\n/**\n * Handles file uploads.\n */\nvar Upload = /** @class */ (function () {\n    function Upload(_notificationService, _progressService) {\n        this._notificationService = _notificationService;\n        this._progressService = _progressService;\n        this.maxParallelUploads = 100;\n        this.readSize = 32000; // ~32kb max while reading in the file.\n        this.packetSize = 32000; // ~32kb max when writing.\n        this.logger = logger_1.logger.named(\"Upload\");\n        this.currentlyUploadingFiles = new Map();\n        this.queueByDirectory = new Map();\n        this.finished = 0;\n        this.uploadedFilePaths = [];\n        this.total = 0;\n    }\n    Object.defineProperty(Upload.prototype, \"notificationService\", {\n        get: function () {\n            return this._notificationService;\n        },\n        set: function (service) {\n            this._notificationService = service;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Upload.prototype, \"progressService\", {\n        get: function () {\n            return this._progressService;\n        },\n        set: function (service) {\n            this._progressService = service;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Upload dropped files. This will try to upload everything it can. Errors\n     * will show via notifications. If an upload operation is ongoing, the files\n     * will be added to that operation.\n     */\n    Upload.prototype.uploadDropped = function (event, uploadDir) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.addDirectory(uploadDir.path);\n                        return [4 /*yield*/, this.queueFiles(event, uploadDir)];\n                    case 1:\n                        _a.sent();\n                        this.logger.debug(// -1 so we don't include the uploadDir itself.\n                        \"Uploading \" + (this.queueByDirectory.size - 1) + \" directories and \" + this.total + \" files\");\n                        return [4 /*yield*/, this.prepareDirectories()];\n                    case 2:\n                        _a.sent();\n                        if (!this.uploadPromise) {\n                            this.uploadPromise = this.progressService.start(\"Uploading files...\", function (progress) {\n                                return new Promise(function (resolve) {\n                                    _this.progress = progress;\n                                    _this.resolveUploadPromise = function () {\n                                        var uploaded = _this.uploadedFilePaths;\n                                        _this.uploadPromise = undefined;\n                                        _this.resolveUploadPromise = undefined;\n                                        _this.uploadedFilePaths = [];\n                                        _this.finished = 0;\n                                        _this.total = 0;\n                                        resolve(uploaded);\n                                    };\n                                });\n                            }, function () {\n                                _this.cancel();\n                            });\n                        }\n                        this.uploadFiles();\n                        return [2 /*return*/, this.uploadPromise];\n                }\n            });\n        });\n    };\n    /**\n     * Cancel all file uploads.\n     */\n    Upload.prototype.cancel = function () {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            return tslib_1.__generator(this, function (_a) {\n                this.currentlyUploadingFiles.clear();\n                this.queueByDirectory.clear();\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Create directories and get existing files.\n     * On failure, show the error and remove the failed directory from the queue.\n     */\n    Upload.prototype.prepareDirectories = function () {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, Promise.all(Array.from(this.queueByDirectory).map(function (_a) {\n                            var path = _a[0], dir = _a[1];\n                            if (!dir.preparePromise) {\n                                dir.preparePromise = _this.prepareDirectory(path, dir);\n                            }\n                            return dir.preparePromise;\n                        }))];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Create a directory and get existing files.\n     * On failure, show the error and remove the directory from the queue.\n     */\n    Upload.prototype.prepareDirectory = function (path, dir) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            util_1.promisify(child_process_1.exec)(\"mkdir -p \" + protocol_1.escapePath(path)).catch(function (error) {\n                                var message = error.message.toLowerCase();\n                                if (message.includes(\"file exists\")) {\n                                    throw new Error(\"Unable to create directory at \" + path + \" because a file exists there\");\n                                }\n                                throw new Error(error.message || \"Unable to upload \" + path);\n                            }),\n                            // Only get files, so we don't show an override option that will just\n                            // fail anyway.\n                            util_1.promisify(child_process_1.exec)(\"find \" + protocol_1.escapePath(path) + \" -maxdepth 1 -not -type d\").then(function (stdio) {\n                                dir.existingFiles = stdio.stdout.split(\"\\n\");\n                            }),\n                        ]).catch(function (error) {\n                            _this.queueByDirectory.delete(path);\n                            _this.notificationService.error(error);\n                        })];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Upload as many files as possible. When finished, resolve the upload promise.\n     */\n    Upload.prototype.uploadFiles = function () {\n        var _this = this;\n        var finishFileUpload = function (path) {\n            ++_this.finished;\n            _this.currentlyUploadingFiles.delete(path);\n            _this.progress.report(Math.floor((_this.finished / _this.total) * 100));\n            _this.uploadFiles();\n        };\n        var _loop_1 = function () {\n            var _a = this_1.queueByDirectory.entries().next().value, dirPath = _a[0], dir = _a[1];\n            if (dir.filesToUpload.size === 0) {\n                this_1.queueByDirectory.delete(dirPath);\n                return \"continue\";\n            }\n            var _b = dir.filesToUpload.entries().next().value, filePath = _b[0], item = _b[1];\n            this_1.currentlyUploadingFiles.set(filePath, item);\n            dir.filesToUpload.delete(filePath);\n            this_1.uploadFile(filePath, item, dir.existingFiles).then(function () {\n                finishFileUpload(filePath);\n            }).catch(function (error) {\n                _this.notificationService.error(error);\n                finishFileUpload(filePath);\n            });\n        };\n        var this_1 = this;\n        while (this.queueByDirectory.size > 0 && this.currentlyUploadingFiles.size < this.maxParallelUploads) {\n            _loop_1();\n        }\n        if (this.queueByDirectory.size === 0 && this.currentlyUploadingFiles.size === 0) {\n            this.resolveUploadPromise();\n        }\n    };\n    /**\n     * Upload a file.\n     */\n    Upload.prototype.uploadFile = function (path, file, existingFiles) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var shouldOverwrite;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!existingFiles.includes(path)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, new Promise(function (resolve) {\n                                _this.notificationService.prompt(notification_1.Severity.Error, path + \" already exists. Overwrite?\", [{\n                                        label: \"Yes\",\n                                        run: function () { return resolve(true); },\n                                    }, {\n                                        label: \"No\",\n                                        run: function () { return resolve(false); },\n                                    }], function () { return resolve(false); });\n                            })];\n                    case 1:\n                        shouldOverwrite = _a.sent();\n                        if (!shouldOverwrite) {\n                            return [2 /*return*/];\n                        }\n                        _a.label = 2;\n                    case 2: return [4 /*yield*/, new Promise(function (resolve, reject) { return tslib_1.__awaiter(_this, void 0, Promise, function () {\n                            var readOffset, reader, seek, rm, load;\n                            var _this = this;\n                            return tslib_1.__generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0:\n                                        readOffset = 0;\n                                        reader = new FileReader();\n                                        seek = function () {\n                                            var slice = file.slice(readOffset, readOffset + _this.readSize);\n                                            readOffset += _this.readSize;\n                                            reader.readAsArrayBuffer(slice);\n                                        };\n                                        rm = function () { return tslib_1.__awaiter(_this, void 0, Promise, function () {\n                                            return tslib_1.__generator(this, function (_a) {\n                                                switch (_a.label) {\n                                                    case 0: return [4 /*yield*/, util_1.promisify(child_process_1.exec)(\"rm -f \" + protocol_1.escapePath(path))];\n                                                    case 1:\n                                                        _a.sent();\n                                                        return [2 /*return*/];\n                                                }\n                                            });\n                                        }); };\n                                        return [4 /*yield*/, rm()];\n                                    case 1:\n                                        _a.sent();\n                                        load = function () { return tslib_1.__awaiter(_this, void 0, Promise, function () {\n                                            var buffer, bufferOffset, data, error_1, message;\n                                            return tslib_1.__generator(this, function (_a) {\n                                                switch (_a.label) {\n                                                    case 0:\n                                                        buffer = new Uint8Array(reader.result);\n                                                        bufferOffset = 0;\n                                                        _a.label = 1;\n                                                    case 1:\n                                                        if (!(bufferOffset <= buffer.length)) return [3 /*break*/, 9];\n                                                        if (!!this.currentlyUploadingFiles.has(path)) return [3 /*break*/, 3];\n                                                        return [4 /*yield*/, rm()];\n                                                    case 2:\n                                                        _a.sent();\n                                                        return [2 /*return*/, resolve()];\n                                                    case 3:\n                                                        data = buffer.slice(bufferOffset, bufferOffset + this.packetSize);\n                                                        _a.label = 4;\n                                                    case 4:\n                                                        _a.trys.push([4, 6, , 8]);\n                                                        return [4 /*yield*/, util_1.promisify(fs_1.appendFile)(path, data)];\n                                                    case 5:\n                                                        _a.sent();\n                                                        return [3 /*break*/, 8];\n                                                    case 6:\n                                                        error_1 = _a.sent();\n                                                        return [4 /*yield*/, rm()];\n                                                    case 7:\n                                                        _a.sent();\n                                                        message = error_1.message.toLowerCase();\n                                                        if (message.includes(\"no space\")) {\n                                                            return [2 /*return*/, reject(new Error(\"You are out of disk space\"))];\n                                                        }\n                                                        else if (message.includes(\"is a directory\")) {\n                                                            return [2 /*return*/, reject(new Error(\"Unable to upload \" + path + \" because there is a directory there\"))];\n                                                        }\n                                                        return [2 /*return*/, reject(new Error(error_1.message || \"Unable to upload \" + path))];\n                                                    case 8:\n                                                        bufferOffset += this.packetSize;\n                                                        return [3 /*break*/, 1];\n                                                    case 9:\n                                                        if (readOffset >= file.size) {\n                                                            this.uploadedFilePaths.push(path);\n                                                            return [2 /*return*/, resolve()];\n                                                        }\n                                                        seek();\n                                                        return [2 /*return*/];\n                                                }\n                                            });\n                                        }); };\n                                        reader.addEventListener(\"load\", load);\n                                        seek();\n                                        return [2 /*return*/];\n                                }\n                            });\n                        }); })];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Queue files from a drop event. We have to get the files first; we can't do\n     * it in tandem with uploading or the entries will disappear.\n     */\n    Upload.prototype.queueFiles = function (event, uploadDir) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var promises, i, item, file;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!event.dataTransfer || !event.dataTransfer.items) {\n                            return [2 /*return*/];\n                        }\n                        promises = [];\n                        for (i = 0; i < event.dataTransfer.items.length; i++) {\n                            item = event.dataTransfer.items[i];\n                            if (typeof item.webkitGetAsEntry === \"function\") {\n                                promises.push(this.traverseItem(item.webkitGetAsEntry(), uploadDir.fsPath).catch(this.notificationService.error));\n                            }\n                            else {\n                                file = item.getAsFile();\n                                if (file) {\n                                    this.addFile(uploadDir.fsPath, uploadDir.fsPath + \"/\" + file.name, file);\n                                }\n                            }\n                        }\n                        return [4 /*yield*/, Promise.all(promises)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Traverses an entry and add files to the queue.\n     */\n    Upload.prototype.traverseItem = function (entry, parentPath) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (entry.isFile) {\n                            return [2 /*return*/, new Promise(function (resolve) {\n                                    entry.file(function (file) {\n                                        _this.addFile(parentPath, parentPath + \"/\" + file.name, file);\n                                        resolve();\n                                    });\n                                })];\n                        }\n                        parentPath += \"/\" + entry.name;\n                        this.addDirectory(parentPath);\n                        return [4 /*yield*/, new Promise(function (resolve) {\n                                var promises = [];\n                                var dirReader = entry.createReader();\n                                // According to the spec, readEntries() must be called until it calls\n                                // the callback with an empty array.\n                                var readEntries = function () {\n                                    dirReader.readEntries(function (entries) {\n                                        if (entries.length === 0) {\n                                            Promise.all(promises).then(resolve).catch(function (error) {\n                                                _this.notificationService.error(error);\n                                                resolve();\n                                            });\n                                        }\n                                        else {\n                                            promises.push.apply(promises, entries.map(function (child) { return _this.traverseItem(child, parentPath); }));\n                                            readEntries();\n                                        }\n                                    });\n                                };\n                                readEntries();\n                            })];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Add a file to the queue.\n     */\n    Upload.prototype.addFile = function (parentPath, path, file) {\n        ++this.total;\n        this.addDirectory(parentPath);\n        this.queueByDirectory.get(parentPath).filesToUpload.set(path, file);\n    };\n    /**\n     * Add a directory to the queue.\n     */\n    Upload.prototype.addDirectory = function (path) {\n        if (!this.queueByDirectory.has(path)) {\n            this.queueByDirectory.set(path, {\n                existingFiles: [],\n                filesToUpload: new Map(),\n            });\n        }\n    };\n    return Upload;\n}());\nexports.Upload = Upload;\n// Global instance.\nexports.upload = new Upload(new notification_1.NotificationService(), new notification_1.ProgressService());\n",{"version":3,"file":"/home/coding/workspace/packages/ide/src/upload.ts","sourceRoot":"","sources":["/home/coding/workspace/packages/ide/src/upload.ts"],"names":[],"mappings":"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","sourcesContent":["import { exec } from \"child_process\";\nimport { appendFile } from \"fs\";\nimport { promisify } from \"util\";\nimport { logger } from \"@coder/logger\";\nimport { escapePath } from \"@coder/protocol\";\nimport { NotificationService, INotificationService, ProgressService, IProgressService, IProgress, Severity } from \"./fill/notification\";\n\nexport interface IURI {\n\treadonly path: string;\n\treadonly fsPath: string;\n\treadonly scheme: string;\n}\n\n/**\n * Represents an uploadable directory, so we can query for existing files once.\n */\ninterface IUploadableDirectory {\n\texistingFiles: string[];\n\tfilesToUpload: Map<string, File>;\n\tpreparePromise?: Promise<void>;\n}\n\n/**\n * There doesn't seem to be a provided type for entries, so here is an\n * incomplete version.\n */\ninterface IEntry {\n\tname: string;\n\tisFile: boolean;\n\tfile: (cb: (file: File) => void) => void;\n\tcreateReader: () => ({\n\t\treadEntries: (cb: (entries: Array<IEntry>) => void) => void;\n\t});\n}\n\n/**\n * Handles file uploads.\n */\nexport class Upload {\n\tprivate readonly maxParallelUploads = 100;\n\tprivate readonly readSize = 32000; // ~32kb max while reading in the file.\n\tprivate readonly packetSize = 32000; // ~32kb max when writing.\n\tprivate readonly logger = logger.named(\"Upload\");\n\tprivate readonly currentlyUploadingFiles = new Map<string, File>();\n\tprivate readonly queueByDirectory = new Map<string, IUploadableDirectory>();\n\tprivate progress: IProgress | undefined;\n\tprivate uploadPromise: Promise<string[]> | undefined;\n\tprivate resolveUploadPromise: (() => void) | undefined;\n\tprivate finished = 0;\n\tprivate uploadedFilePaths = <string[]>[];\n\tprivate total = 0;\n\n\tpublic constructor(\n\t\tprivate _notificationService: INotificationService,\n\t\tprivate _progressService: IProgressService,\n\t) {}\n\n\tpublic set notificationService(service: INotificationService) {\n\t\tthis._notificationService = service;\n\t}\n\n\tpublic get notificationService(): INotificationService {\n\t\treturn this._notificationService;\n\t}\n\n\tpublic set progressService(service: IProgressService) {\n\t\tthis._progressService = service;\n\t}\n\n\tpublic get progressService(): IProgressService {\n\t\treturn this._progressService;\n\t}\n\n\t/**\n\t * Upload dropped files. This will try to upload everything it can. Errors\n\t * will show via notifications. If an upload operation is ongoing, the files\n\t * will be added to that operation.\n\t */\n\tpublic async uploadDropped(event: DragEvent, uploadDir: IURI): Promise<string[]> {\n\t\tthis.addDirectory(uploadDir.path);\n\t\tawait this.queueFiles(event, uploadDir);\n\t\tthis.logger.debug( // -1 so we don't include the uploadDir itself.\n\t\t\t`Uploading ${this.queueByDirectory.size - 1} directories and ${this.total} files`,\n\t\t);\n\t\tawait this.prepareDirectories();\n\t\tif (!this.uploadPromise) {\n\t\t\tthis.uploadPromise = this.progressService.start(\"Uploading files...\", (progress) => {\n\t\t\t\treturn new Promise((resolve): void => {\n\t\t\t\t\tthis.progress = progress;\n\t\t\t\t\tthis.resolveUploadPromise = (): void => {\n\t\t\t\t\t\tconst uploaded = this.uploadedFilePaths;\n\t\t\t\t\t\tthis.uploadPromise = undefined;\n\t\t\t\t\t\tthis.resolveUploadPromise = undefined;\n\t\t\t\t\t\tthis.uploadedFilePaths = [];\n\t\t\t\t\t\tthis.finished = 0;\n\t\t\t\t\t\tthis.total = 0;\n\t\t\t\t\t\tresolve(uploaded);\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t}, () => {\n\t\t\t\tthis.cancel();\n\t\t\t});\n\t\t}\n\t\tthis.uploadFiles();\n\n\t\treturn this.uploadPromise;\n\t}\n\n\t/**\n\t * Cancel all file uploads.\n\t */\n\tpublic async cancel(): Promise<void> {\n\t\tthis.currentlyUploadingFiles.clear();\n\t\tthis.queueByDirectory.clear();\n\t}\n\n\t/**\n\t * Create directories and get existing files.\n\t * On failure, show the error and remove the failed directory from the queue.\n\t */\n\tprivate async prepareDirectories(): Promise<void> {\n\t\tawait Promise.all(Array.from(this.queueByDirectory).map(([path, dir]) => {\n\t\t\tif (!dir.preparePromise) {\n\t\t\t\tdir.preparePromise = this.prepareDirectory(path, dir);\n\t\t\t}\n\n\t\t\treturn dir.preparePromise;\n\t\t}));\n\t}\n\n\t/**\n\t * Create a directory and get existing files.\n\t * On failure, show the error and remove the directory from the queue.\n\t */\n\tprivate async prepareDirectory(path: string, dir: IUploadableDirectory): Promise<void> {\n\t\tawait Promise.all([\n\t\t\tpromisify(exec)(`mkdir -p ${escapePath(path)}`).catch((error) => {\n\t\t\t\tconst message = error.message.toLowerCase();\n\t\t\t\tif (message.includes(\"file exists\")) {\n\t\t\t\t\tthrow new Error(`Unable to create directory at ${path} because a file exists there`);\n\t\t\t\t}\n\t\t\t\tthrow new Error(error.message || `Unable to upload ${path}`);\n\t\t\t}),\n\t\t\t// Only get files, so we don't show an override option that will just\n\t\t\t// fail anyway.\n\t\t\tpromisify(exec)(`find ${escapePath(path)} -maxdepth 1 -not -type d`).then((stdio) => {\n\t\t\t\tdir.existingFiles = stdio.stdout.split(\"\\n\");\n\t\t\t}),\n\t\t]).catch((error) => {\n\t\t\tthis.queueByDirectory.delete(path);\n\t\t\tthis.notificationService.error(error);\n\t\t});\n\t}\n\n\t/**\n\t * Upload as many files as possible. When finished, resolve the upload promise.\n\t */\n\tprivate uploadFiles(): void {\n\t\tconst finishFileUpload = (path: string): void => {\n\t\t\t++this.finished;\n\t\t\tthis.currentlyUploadingFiles.delete(path);\n\t\t\tthis.progress!.report(Math.floor((this.finished / this.total) * 100));\n\t\t\tthis.uploadFiles();\n\t\t};\n\t\twhile (this.queueByDirectory.size > 0 && this.currentlyUploadingFiles.size < this.maxParallelUploads) {\n\t\t\tconst [dirPath, dir] = this.queueByDirectory.entries().next().value;\n\t\t\tif (dir.filesToUpload.size === 0) {\n\t\t\t\tthis.queueByDirectory.delete(dirPath);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst [filePath, item] = dir.filesToUpload.entries().next().value;\n\t\t\tthis.currentlyUploadingFiles.set(filePath, item);\n\t\t\tdir.filesToUpload.delete(filePath);\n\t\t\tthis.uploadFile(filePath, item, dir.existingFiles).then(() => {\n\t\t\t\tfinishFileUpload(filePath);\n\t\t\t}).catch((error) => {\n\t\t\t\tthis.notificationService.error(error);\n\t\t\t\tfinishFileUpload(filePath);\n\t\t\t});\n\t\t}\n\t\tif (this.queueByDirectory.size === 0 && this.currentlyUploadingFiles.size === 0) {\n\t\t\tthis.resolveUploadPromise!();\n\t\t}\n\t}\n\n\t/**\n\t * Upload a file.\n\t */\n\tprivate async uploadFile(path: string, file: File, existingFiles: string[]): Promise<void> {\n\t\tif (existingFiles.includes(path)) {\n\t\t\tconst shouldOverwrite = await new Promise((resolve): void => {\n\t\t\t\tthis.notificationService.prompt(\n\t\t\t\t\tSeverity.Error,\n\t\t\t\t\t`${path} already exists. Overwrite?`,\n\t\t\t\t\t[{\n\t\t\t\t\t\tlabel: \"Yes\",\n\t\t\t\t\t\trun: (): void => resolve(true),\n\t\t\t\t\t}, {\n\t\t\t\t\t\tlabel: \"No\",\n\t\t\t\t\t\trun: (): void => resolve(false),\n\t\t\t\t\t}],\n\t\t\t\t\t() => resolve(false),\n\t\t\t\t);\n\t\t\t});\n\t\t\tif (!shouldOverwrite) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tawait new Promise(async (resolve, reject): Promise<void> => {\n\t\t\tlet readOffset = 0;\n\t\t\tconst reader = new FileReader();\n\t\t\tconst seek = (): void => {\n\t\t\t\tconst slice = file.slice(readOffset, readOffset + this.readSize);\n\t\t\t\treadOffset += this.readSize;\n\t\t\t\treader.readAsArrayBuffer(slice);\n\t\t\t};\n\n\t\t\tconst rm = async (): Promise<void> => {\n\t\t\t\tawait promisify(exec)(`rm -f ${escapePath(path)}`);\n\t\t\t};\n\n\t\t\tawait rm();\n\n\t\t\tconst load = async (): Promise<void> => {\n\t\t\t\tconst buffer = new Uint8Array(reader.result as ArrayBuffer);\n\t\t\t\tlet bufferOffset = 0;\n\n\t\t\t\twhile (bufferOffset <= buffer.length) {\n\t\t\t\t\t// Got canceled while sending data.\n\t\t\t\t\tif (!this.currentlyUploadingFiles.has(path)) {\n\t\t\t\t\t\tawait rm();\n\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\t\t\t\t\tconst data = buffer.slice(bufferOffset, bufferOffset + this.packetSize);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait promisify(appendFile)(path, data);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tawait rm();\n\n\t\t\t\t\t\tconst message = error.message.toLowerCase();\n\t\t\t\t\t\tif (message.includes(\"no space\")) {\n\t\t\t\t\t\t\treturn reject(new Error(\"You are out of disk space\"));\n\t\t\t\t\t\t} else if (message.includes(\"is a directory\")) {\n\t\t\t\t\t\t\treturn reject(new Error(`Unable to upload ${path} because there is a directory there`));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn reject(new Error(error.message || `Unable to upload ${path}`));\n\t\t\t\t\t}\n\n\t\t\t\t\tbufferOffset += this.packetSize;\n\t\t\t\t}\n\n\t\t\t\tif (readOffset >= file.size) {\n\t\t\t\t\tthis.uploadedFilePaths.push(path);\n\n\t\t\t\t\treturn resolve();\n\t\t\t\t}\n\n\t\t\t\tseek();\n\t\t\t};\n\n\t\t\treader.addEventListener(\"load\", load);\n\n\t\t\tseek();\n\t\t});\n\t}\n\n\t/**\n\t * Queue files from a drop event. We have to get the files first; we can't do\n\t * it in tandem with uploading or the entries will disappear.\n\t */\n\tprivate async queueFiles(event: DragEvent, uploadDir: IURI): Promise<void> {\n\t\tif (!event.dataTransfer || !event.dataTransfer.items) {\n\t\t\treturn;\n\t\t}\n\t\tconst promises: Array<Promise<void>> = [];\n\t\tfor (let i = 0; i < event.dataTransfer.items.length; i++) {\n\t\t\tconst item = event.dataTransfer.items[i];\n\t\t\tif (typeof item.webkitGetAsEntry === \"function\") {\n\t\t\t\tpromises.push(this.traverseItem(item.webkitGetAsEntry(), uploadDir.fsPath).catch(this.notificationService.error));\n\t\t\t} else {\n\t\t\t\tconst file = item.getAsFile();\n\t\t\t\tif (file) {\n\t\t\t\t\tthis.addFile(uploadDir.fsPath, uploadDir.fsPath + \"/\" + file.name, file);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * Traverses an entry and add files to the queue.\n\t */\n\tprivate async traverseItem(entry: IEntry, parentPath: string): Promise<void> {\n\t\tif (entry.isFile) {\n\t\t\treturn new Promise<void>((resolve): void => {\n\t\t\t\tentry.file((file) => {\n\t\t\t\t\tthis.addFile(\n\t\t\t\t\t\tparentPath,\n\t\t\t\t\t\tparentPath + \"/\" + file.name,\n\t\t\t\t\t\tfile,\n\t\t\t\t\t);\n\t\t\t\t\tresolve();\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\tparentPath += \"/\" + entry.name;\n\t\tthis.addDirectory(parentPath);\n\n\t\tawait new Promise((resolve): void => {\n\t\t\tconst promises: Array<Promise<void>> = [];\n\t\t\tconst dirReader = entry.createReader();\n\t\t\t// According to the spec, readEntries() must be called until it calls\n\t\t\t// the callback with an empty array.\n\t\t\tconst readEntries = (): void => {\n\t\t\t\tdirReader.readEntries((entries) => {\n\t\t\t\t\tif (entries.length === 0) {\n\t\t\t\t\t\tPromise.all(promises).then(resolve).catch((error) => {\n\t\t\t\t\t\t\tthis.notificationService.error(error);\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpromises.push(...entries.map((child) => this.traverseItem(child, parentPath)));\n\t\t\t\t\t\treadEntries();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t\treadEntries();\n\t\t});\n\t}\n\n\t/**\n\t * Add a file to the queue.\n\t */\n\tprivate addFile(parentPath: string, path: string, file: File): void {\n\t\t++this.total;\n\t\tthis.addDirectory(parentPath);\n\t\tthis.queueByDirectory.get(parentPath)!.filesToUpload.set(path, file);\n\t}\n\n\t/**\n\t * Add a directory to the queue.\n\t */\n\tprivate addDirectory(path: string): void {\n\t\tif (!this.queueByDirectory.has(path)) {\n\t\t\tthis.queueByDirectory.set(path, {\n\t\t\t\texistingFiles: [],\n\t\t\t\tfilesToUpload: new Map(),\n\t\t\t});\n\t\t}\n\t}\n}\n\n// Global instance.\nexport const upload = new Upload(new NotificationService(), new ProgressService());\n"]}]}