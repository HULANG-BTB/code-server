{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/hiddenRangeModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/hiddenRangeModel.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/event\", \"vs/editor/common/core/range\", \"vs/base/common/arrays\"], function (require, exports, event_1, range_1, arrays_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class HiddenRangeModel {\n        constructor(model) {\n            this._updateEventEmitter = new event_1.Emitter();\n            this._foldingModel = model;\n            this._foldingModelListener = model.onDidChange(_ => this.updateHiddenRanges());\n            this._hiddenRanges = [];\n            if (model.regions.length) {\n                this.updateHiddenRanges();\n            }\n        }\n        get onDidChange() { return this._updateEventEmitter.event; }\n        get hiddenRanges() { return this._hiddenRanges; }\n        updateHiddenRanges() {\n            let updateHiddenAreas = false;\n            let newHiddenAreas = [];\n            let i = 0; // index into hidden\n            let k = 0;\n            let lastCollapsedStart = Number.MAX_VALUE;\n            let lastCollapsedEnd = -1;\n            let ranges = this._foldingModel.regions;\n            for (; i < ranges.length; i++) {\n                if (!ranges.isCollapsed(i)) {\n                    continue;\n                }\n                let startLineNumber = ranges.getStartLineNumber(i) + 1; // the first line is not hidden\n                let endLineNumber = ranges.getEndLineNumber(i);\n                if (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) {\n                    // ignore ranges contained in collapsed regions\n                    continue;\n                }\n                if (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {\n                    // reuse the old ranges\n                    newHiddenAreas.push(this._hiddenRanges[k]);\n                    k++;\n                }\n                else {\n                    updateHiddenAreas = true;\n                    newHiddenAreas.push(new range_1.Range(startLineNumber, 1, endLineNumber, 1));\n                }\n                lastCollapsedStart = startLineNumber;\n                lastCollapsedEnd = endLineNumber;\n            }\n            if (updateHiddenAreas || k < this._hiddenRanges.length) {\n                this.applyHiddenRanges(newHiddenAreas);\n            }\n        }\n        applyMemento(state) {\n            if (!Array.isArray(state) || state.length === 0) {\n                return false;\n            }\n            let hiddenRanges = [];\n            for (let r of state) {\n                if (!r.startLineNumber || !r.endLineNumber) {\n                    return false;\n                }\n                hiddenRanges.push(new range_1.Range(r.startLineNumber + 1, 1, r.endLineNumber, 1));\n            }\n            this.applyHiddenRanges(hiddenRanges);\n            return true;\n        }\n        /**\n         * Collapse state memento, for persistence only, only used if folding model is not yet initialized\n         */\n        getMemento() {\n            return this._hiddenRanges.map(r => ({ startLineNumber: r.startLineNumber - 1, endLineNumber: r.endLineNumber }));\n        }\n        applyHiddenRanges(newHiddenAreas) {\n            this._hiddenRanges = newHiddenAreas;\n            this._updateEventEmitter.fire(newHiddenAreas);\n        }\n        hasRanges() {\n            return this._hiddenRanges.length > 0;\n        }\n        isHidden(line) {\n            return findRange(this._hiddenRanges, line) !== null;\n        }\n        adjustSelections(selections) {\n            let hasChanges = false;\n            let editorModel = this._foldingModel.textModel;\n            let lastRange = null;\n            let adjustLine = (line) => {\n                if (!lastRange || !isInside(line, lastRange)) {\n                    lastRange = findRange(this._hiddenRanges, line);\n                }\n                if (lastRange) {\n                    return lastRange.startLineNumber - 1;\n                }\n                return null;\n            };\n            for (let i = 0, len = selections.length; i < len; i++) {\n                let selection = selections[i];\n                let adjustedStartLine = adjustLine(selection.startLineNumber);\n                if (adjustedStartLine) {\n                    selection = selection.setStartPosition(adjustedStartLine, editorModel.getLineMaxColumn(adjustedStartLine));\n                    hasChanges = true;\n                }\n                let adjustedEndLine = adjustLine(selection.endLineNumber);\n                if (adjustedEndLine) {\n                    selection = selection.setEndPosition(adjustedEndLine, editorModel.getLineMaxColumn(adjustedEndLine));\n                    hasChanges = true;\n                }\n                selections[i] = selection;\n            }\n            return hasChanges;\n        }\n        dispose() {\n            if (this.hiddenRanges.length > 0) {\n                this._hiddenRanges = [];\n                this._updateEventEmitter.fire(this._hiddenRanges);\n            }\n            if (this._foldingModelListener) {\n                this._foldingModelListener.dispose();\n                this._foldingModelListener = null;\n            }\n        }\n    }\n    exports.HiddenRangeModel = HiddenRangeModel;\n    function isInside(line, range) {\n        return line >= range.startLineNumber && line <= range.endLineNumber;\n    }\n    function findRange(ranges, line) {\n        let i = arrays_1.findFirstInSorted(ranges, r => line < r.startLineNumber) - 1;\n        if (i >= 0 && ranges[i].endLineNumber >= line) {\n            return ranges[i];\n        }\n        return null;\n    }\n});\n",null]}