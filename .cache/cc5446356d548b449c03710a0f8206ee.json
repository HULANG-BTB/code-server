{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/lineDecorations.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/lineDecorations.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar strings = require(\"vs/base/common/strings\");\nvar uint_1 = require(\"vs/editor/common/core/uint\");\nvar viewModel_1 = require(\"vs/editor/common/viewModel/viewModel\");\nvar LineDecoration = /** @class */ (function () {\n    function LineDecoration(startColumn, endColumn, className, type) {\n        this.startColumn = startColumn;\n        this.endColumn = endColumn;\n        this.className = className;\n        this.type = type;\n    }\n    LineDecoration._equals = function (a, b) {\n        return (a.startColumn === b.startColumn\n            && a.endColumn === b.endColumn\n            && a.className === b.className\n            && a.type === b.type);\n    };\n    LineDecoration.equalsArr = function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        if (aLen !== bLen) {\n            return false;\n        }\n        for (var i = 0; i < aLen; i++) {\n            if (!LineDecoration._equals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    };\n    LineDecoration.filter = function (lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        var result = [], resultLen = 0;\n        for (var i = 0, len = lineDecorations.length; i < len; i++) {\n            var d = lineDecorations[i];\n            var range = d.range;\n            if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n                // Ignore decorations that sit outside this line\n                continue;\n            }\n            if (range.isEmpty() && (d.type === viewModel_1.InlineDecorationType.Regular || d.type === viewModel_1.InlineDecorationType.RegularAffectingLetterSpacing)) {\n                // Ignore empty range decorations\n                continue;\n            }\n            var startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\n            var endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\n            result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n        }\n        return result;\n    };\n    LineDecoration.compare = function (a, b) {\n        if (a.startColumn === b.startColumn) {\n            if (a.endColumn === b.endColumn) {\n                if (a.className < b.className) {\n                    return -1;\n                }\n                if (a.className > b.className) {\n                    return 1;\n                }\n                return 0;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.startColumn - b.startColumn;\n    };\n    return LineDecoration;\n}());\nexports.LineDecoration = LineDecoration;\nvar DecorationSegment = /** @class */ (function () {\n    function DecorationSegment(startOffset, endOffset, className) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.className = className;\n    }\n    return DecorationSegment;\n}());\nexports.DecorationSegment = DecorationSegment;\nvar Stack = /** @class */ (function () {\n    function Stack() {\n        this.stopOffsets = [];\n        this.classNames = [];\n        this.count = 0;\n    }\n    Stack.prototype.consumeLowerThan = function (maxStopOffset, nextStartOffset, result) {\n        while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n            var i = 0;\n            // Take all equal stopping offsets\n            while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n                i++;\n            }\n            // Basically we are consuming the first i + 1 elements of the stack\n            result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' ')));\n            nextStartOffset = this.stopOffsets[i] + 1;\n            // Consume them\n            this.stopOffsets.splice(0, i + 1);\n            this.classNames.splice(0, i + 1);\n            this.count -= (i + 1);\n        }\n        if (this.count > 0 && nextStartOffset < maxStopOffset) {\n            result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' ')));\n            nextStartOffset = maxStopOffset;\n        }\n        return nextStartOffset;\n    };\n    Stack.prototype.insert = function (stopOffset, className) {\n        if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n            // Insert at the end\n            this.stopOffsets.push(stopOffset);\n            this.classNames.push(className);\n        }\n        else {\n            // Find the insertion position for `stopOffset`\n            for (var i = 0; i < this.count; i++) {\n                if (this.stopOffsets[i] >= stopOffset) {\n                    this.stopOffsets.splice(i, 0, stopOffset);\n                    this.classNames.splice(i, 0, className);\n                    break;\n                }\n            }\n        }\n        this.count++;\n        return;\n    };\n    return Stack;\n}());\nvar LineDecorationsNormalizer = /** @class */ (function () {\n    function LineDecorationsNormalizer() {\n    }\n    /**\n     * Normalize line decorations. Overlapping decorations will generate multiple segments\n     */\n    LineDecorationsNormalizer.normalize = function (lineContent, lineDecorations) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        var result = [];\n        var stack = new Stack();\n        var nextStartOffset = 0;\n        for (var i = 0, len = lineDecorations.length; i < len; i++) {\n            var d = lineDecorations[i];\n            var startColumn = d.startColumn;\n            var endColumn = d.endColumn;\n            var className = d.className;\n            // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n            if (startColumn > 1) {\n                var charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    startColumn--;\n                }\n            }\n            if (endColumn > 1) {\n                var charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    endColumn--;\n                }\n            }\n            var currentStartOffset = startColumn - 1;\n            var currentEndOffset = endColumn - 2;\n            nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n            if (stack.count === 0) {\n                nextStartOffset = currentStartOffset;\n            }\n            stack.insert(currentEndOffset, className);\n        }\n        stack.consumeLowerThan(uint_1.Constants.MAX_SAFE_SMALL_INTEGER, nextStartOffset, result);\n        return result;\n    };\n    return LineDecorationsNormalizer;\n}());\nexports.LineDecorationsNormalizer = LineDecorationsNormalizer;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/lineDecorations.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/lineDecorations.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from 'vs/base/common/strings';\nimport { Constants } from 'vs/editor/common/core/uint';\nimport { InlineDecoration, InlineDecorationType } from 'vs/editor/common/viewModel/viewModel';\n\nexport class LineDecoration {\n\t_lineDecorationBrand: void;\n\n\tconstructor(\n\t\tpublic readonly startColumn: number,\n\t\tpublic readonly endColumn: number,\n\t\tpublic readonly className: string,\n\t\tpublic readonly type: InlineDecorationType\n\t) {\n\t}\n\n\tprivate static _equals(a: LineDecoration, b: LineDecoration): boolean {\n\t\treturn (\n\t\t\ta.startColumn === b.startColumn\n\t\t\t&& a.endColumn === b.endColumn\n\t\t\t&& a.className === b.className\n\t\t\t&& a.type === b.type\n\t\t);\n\t}\n\n\tpublic static equalsArr(a: LineDecoration[], b: LineDecoration[]): boolean {\n\t\tlet aLen = a.length;\n\t\tlet bLen = b.length;\n\t\tif (aLen !== bLen) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < aLen; i++) {\n\t\t\tif (!LineDecoration._equals(a[i], b[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static filter(lineDecorations: InlineDecoration[], lineNumber: number, minLineColumn: number, maxLineColumn: number): LineDecoration[] {\n\t\tif (lineDecorations.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet result: LineDecoration[] = [], resultLen = 0;\n\n\t\tfor (let i = 0, len = lineDecorations.length; i < len; i++) {\n\t\t\tlet d = lineDecorations[i];\n\t\t\tlet range = d.range;\n\n\t\t\tif (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n\t\t\t\t// Ignore decorations that sit outside this line\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (range.isEmpty() && (d.type === InlineDecorationType.Regular || d.type === InlineDecorationType.RegularAffectingLetterSpacing)) {\n\t\t\t\t// Ignore empty range decorations\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\n\t\t\tlet endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\n\n\t\t\tresult[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic static compare(a: LineDecoration, b: LineDecoration): number {\n\t\tif (a.startColumn === b.startColumn) {\n\t\t\tif (a.endColumn === b.endColumn) {\n\t\t\t\tif (a.className < b.className) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (a.className > b.className) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn a.endColumn - b.endColumn;\n\t\t}\n\t\treturn a.startColumn - b.startColumn;\n\t}\n}\n\nexport class DecorationSegment {\n\tstartOffset: number;\n\tendOffset: number;\n\tclassName: string;\n\n\tconstructor(startOffset: number, endOffset: number, className: string) {\n\t\tthis.startOffset = startOffset;\n\t\tthis.endOffset = endOffset;\n\t\tthis.className = className;\n\t}\n}\n\nclass Stack {\n\tpublic count: number;\n\tprivate readonly stopOffsets: number[];\n\tprivate readonly classNames: string[];\n\n\tconstructor() {\n\t\tthis.stopOffsets = [];\n\t\tthis.classNames = [];\n\t\tthis.count = 0;\n\t}\n\n\tpublic consumeLowerThan(maxStopOffset: number, nextStartOffset: number, result: DecorationSegment[]): number {\n\n\t\twhile (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n\t\t\tlet i = 0;\n\n\t\t\t// Take all equal stopping offsets\n\t\t\twhile (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t// Basically we are consuming the first i + 1 elements of the stack\n\t\t\tresult.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' ')));\n\t\t\tnextStartOffset = this.stopOffsets[i] + 1;\n\n\t\t\t// Consume them\n\t\t\tthis.stopOffsets.splice(0, i + 1);\n\t\t\tthis.classNames.splice(0, i + 1);\n\t\t\tthis.count -= (i + 1);\n\t\t}\n\n\t\tif (this.count > 0 && nextStartOffset < maxStopOffset) {\n\t\t\tresult.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' ')));\n\t\t\tnextStartOffset = maxStopOffset;\n\t\t}\n\n\t\treturn nextStartOffset;\n\t}\n\n\tpublic insert(stopOffset: number, className: string): void {\n\t\tif (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n\t\t\t// Insert at the end\n\t\t\tthis.stopOffsets.push(stopOffset);\n\t\t\tthis.classNames.push(className);\n\t\t} else {\n\t\t\t// Find the insertion position for `stopOffset`\n\t\t\tfor (let i = 0; i < this.count; i++) {\n\t\t\t\tif (this.stopOffsets[i] >= stopOffset) {\n\t\t\t\t\tthis.stopOffsets.splice(i, 0, stopOffset);\n\t\t\t\t\tthis.classNames.splice(i, 0, className);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.count++;\n\t\treturn;\n\t}\n}\n\nexport class LineDecorationsNormalizer {\n\t/**\n\t * Normalize line decorations. Overlapping decorations will generate multiple segments\n\t */\n\tpublic static normalize(lineContent: string, lineDecorations: LineDecoration[]): DecorationSegment[] {\n\t\tif (lineDecorations.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet result: DecorationSegment[] = [];\n\n\t\tlet stack = new Stack();\n\t\tlet nextStartOffset = 0;\n\n\t\tfor (let i = 0, len = lineDecorations.length; i < len; i++) {\n\t\t\tlet d = lineDecorations[i];\n\t\t\tlet startColumn = d.startColumn;\n\t\t\tlet endColumn = d.endColumn;\n\t\t\tlet className = d.className;\n\n\t\t\t// If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n\t\t\tif (startColumn > 1) {\n\t\t\t\tconst charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n\t\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\t\tstartColumn--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (endColumn > 1) {\n\t\t\t\tconst charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n\t\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\t\tendColumn--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet currentStartOffset = startColumn - 1;\n\t\t\tlet currentEndOffset = endColumn - 2;\n\n\t\t\tnextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n\n\t\t\tif (stack.count === 0) {\n\t\t\t\tnextStartOffset = currentStartOffset;\n\t\t\t}\n\t\t\tstack.insert(currentEndOffset, className);\n\t\t}\n\n\t\tstack.consumeLowerThan(Constants.MAX_SAFE_SMALL_INTEGER, nextStartOffset, result);\n\n\t\treturn result;\n\t}\n\n}\n"]}]}