{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/common/inactiveExtensionUrlHandler.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/common/inactiveExtensionUrlHandler.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/actions\", \"vs/base/common/lifecycle\", \"vs/base/common/uri\", \"vs/platform/dialogs/common/dialogs\", \"vs/platform/extensionManagement/common/extensionManagement\", \"vs/platform/extensionManagement/common/extensionManagementUtil\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/notification/common/notification\", \"vs/platform/storage/common/storage\", \"vs/platform/url/common/url\", \"vs/platform/windows/common/windows\", \"vs/workbench/services/extensions/common/extensions\", \"vs/platform/extensions/common/extensions\", \"vs/platform/instantiation/common/extensions\"], function (require, exports, nls_1, actions_1, lifecycle_1, uri_1, dialogs_1, extensionManagement_1, extensionManagementUtil_1, instantiation_1, notification_1, storage_1, url_1, windows_1, extensions_1, extensions_2, extensions_3) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const FIVE_MINUTES = 5 * 60 * 1000;\n    const THIRTY_SECONDS = 30 * 1000;\n    const URL_TO_HANDLE = 'extensionUrlHandler.urlToHandle';\n    function isExtensionId(value) {\n        return /^[a-z0-9][a-z0-9\\-]*\\.[a-z0-9][a-z0-9\\-]*$/i.test(value);\n    }\n    exports.IExtensionUrlHandler = instantiation_1.createDecorator('inactiveExtensionUrlHandler');\n    /**\n     * This class handles URLs which are directed towards inactive extensions.\n     * If a URL is directed towards an inactive extension, it buffers it,\n     * activates the extension and re-opens the URL once the extension registers\n     * a URL handler. If the extension never registers a URL handler, the urls\n     * will eventually be garbage collected.\n     *\n     * It also makes sure the user confirms opening URLs directed towards extensions.\n     */\n    let ExtensionUrlHandler = class ExtensionUrlHandler {\n        constructor(urlService, extensionService, dialogService, notificationService, extensionManagementService, extensionEnablementService, windowService, galleryService, storageService) {\n            this.extensionService = extensionService;\n            this.dialogService = dialogService;\n            this.notificationService = notificationService;\n            this.extensionManagementService = extensionManagementService;\n            this.extensionEnablementService = extensionEnablementService;\n            this.windowService = windowService;\n            this.galleryService = galleryService;\n            this.storageService = storageService;\n            this.extensionHandlers = new Map();\n            this.uriBuffer = new Map();\n            const interval = setInterval(() => this.garbageCollect(), THIRTY_SECONDS);\n            const urlToHandleValue = this.storageService.get(URL_TO_HANDLE, storage_1.StorageScope.WORKSPACE);\n            if (urlToHandleValue) {\n                this.storageService.remove(URL_TO_HANDLE, storage_1.StorageScope.WORKSPACE);\n                this.handleURL(uri_1.URI.revive(JSON.parse(urlToHandleValue)), true);\n            }\n            this.disposable = lifecycle_1.combinedDisposable([\n                urlService.registerHandler(this),\n                lifecycle_1.toDisposable(() => clearInterval(interval))\n            ]);\n        }\n        handleURL(uri, confirmed) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!isExtensionId(uri.authority)) {\n                    return false;\n                }\n                const extensionId = uri.authority;\n                const wasHandlerAvailable = this.extensionHandlers.has(extensions_2.ExtensionIdentifier.toKey(extensionId));\n                const extension = yield this.extensionService.getExtension(extensionId);\n                if (!extension) {\n                    yield this.handleUnhandledURL(uri, { id: extensionId });\n                    return true;\n                }\n                if (!confirmed) {\n                    let uriString = uri.toString();\n                    if (uriString.length > 40) {\n                        uriString = `${uriString.substring(0, 30)}...${uriString.substring(uriString.length - 5)}`;\n                    }\n                    const result = yield this.dialogService.confirm({\n                        message: nls_1.localize('confirmUrl', \"Allow an extension to open this URL?\", extensionId),\n                        detail: `${extension.displayName || extension.name} (${extensionId}) wants to open a URL:\\n\\n${uriString}`,\n                        primaryButton: nls_1.localize('open', \"&&Open\"),\n                        type: 'question'\n                    });\n                    if (!result.confirmed) {\n                        return true;\n                    }\n                }\n                const handler = this.extensionHandlers.get(extensions_2.ExtensionIdentifier.toKey(extensionId));\n                if (handler) {\n                    if (!wasHandlerAvailable) {\n                        // forward it directly\n                        return yield handler.handleURL(uri);\n                    }\n                    // let the ExtensionUrlHandler instance handle this\n                    return false;\n                }\n                // collect URI for eventual extension activation\n                const timestamp = new Date().getTime();\n                let uris = this.uriBuffer.get(extensions_2.ExtensionIdentifier.toKey(extensionId));\n                if (!uris) {\n                    uris = [];\n                    this.uriBuffer.set(extensions_2.ExtensionIdentifier.toKey(extensionId), uris);\n                }\n                uris.push({ timestamp, uri });\n                // activate the extension\n                yield this.extensionService.activateByEvent(`onUri:${extensions_2.ExtensionIdentifier.toKey(extensionId)}`);\n                return true;\n            });\n        }\n        registerExtensionHandler(extensionId, handler) {\n            this.extensionHandlers.set(extensions_2.ExtensionIdentifier.toKey(extensionId), handler);\n            const uris = this.uriBuffer.get(extensions_2.ExtensionIdentifier.toKey(extensionId)) || [];\n            for (const { uri } of uris) {\n                handler.handleURL(uri);\n            }\n            this.uriBuffer.delete(extensions_2.ExtensionIdentifier.toKey(extensionId));\n        }\n        unregisterExtensionHandler(extensionId) {\n            this.extensionHandlers.delete(extensions_2.ExtensionIdentifier.toKey(extensionId));\n        }\n        handleUnhandledURL(uri, extensionIdentifier) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const installedExtensions = yield this.extensionManagementService.getInstalled();\n                const extension = installedExtensions.filter(e => extensionManagementUtil_1.areSameExtensions(e.identifier, extensionIdentifier))[0];\n                // Extension is installed\n                if (extension) {\n                    const enabled = this.extensionEnablementService.isEnabled(extension);\n                    // Extension is not running. Reload the window to handle.\n                    if (enabled) {\n                        const result = yield this.dialogService.confirm({\n                            message: nls_1.localize('reloadAndHandle', \"Extension '{0}' is not loaded. Would you like to reload the window to load the extension and open the URL?\", extension.manifest.displayName || extension.manifest.name),\n                            detail: `${extension.manifest.displayName || extension.manifest.name} (${extensionIdentifier.id}) wants to open a URL:\\n\\n${uri.toString()}`,\n                            primaryButton: nls_1.localize('reloadAndOpen', \"&&Reload Window and Open\"),\n                            type: 'question'\n                        });\n                        if (!result.confirmed) {\n                            return;\n                        }\n                        yield this.reloadAndHandle(uri);\n                    }\n                    // Extension is disabled. Enable the extension and reload the window to handle.\n                    else {\n                        const result = yield this.dialogService.confirm({\n                            message: nls_1.localize('enableAndHandle', \"Extension '{0}' is disabled. Would you like to enable the extension and reload the window to open the URL?\", extension.manifest.displayName || extension.manifest.name),\n                            detail: `${extension.manifest.displayName || extension.manifest.name} (${extensionIdentifier.id}) wants to open a URL:\\n\\n${uri.toString()}`,\n                            primaryButton: nls_1.localize('enableAndReload', \"&&Enable and Open\"),\n                            type: 'question'\n                        });\n                        if (!result.confirmed) {\n                            return;\n                        }\n                        yield this.extensionEnablementService.setEnablement([extension], extensionManagement_1.EnablementState.Enabled);\n                        yield this.reloadAndHandle(uri);\n                    }\n                }\n                // Extension is not installed\n                else {\n                    const galleryExtension = yield this.galleryService.getCompatibleExtension(extensionIdentifier);\n                    if (!galleryExtension) {\n                        return;\n                    }\n                    // Install the Extension and reload the window to handle.\n                    const result = yield this.dialogService.confirm({\n                        message: nls_1.localize('installAndHandle', \"Extension '{0}' is not installed. Would you like to install the extension and reload the window to open this URL?\", galleryExtension.displayName || galleryExtension.name),\n                        detail: `${galleryExtension.displayName || galleryExtension.name} (${extensionIdentifier.id}) wants to open a URL:\\n\\n${uri.toString()}`,\n                        primaryButton: nls_1.localize('install', \"&&Install\"),\n                        type: 'question'\n                    });\n                    if (!result.confirmed) {\n                        return;\n                    }\n                    let notificationHandle = this.notificationService.notify({ severity: notification_1.Severity.Info, message: nls_1.localize('Installing', \"Installing Extension '{0}'...\", galleryExtension.displayName || galleryExtension.name) });\n                    notificationHandle.progress.infinite();\n                    notificationHandle.onDidClose(() => notificationHandle = null);\n                    try {\n                        yield this.extensionManagementService.installFromGallery(galleryExtension);\n                        const reloadMessage = nls_1.localize('reload', \"Would you like to reload the window and open the URL '{0}'?\", uri.toString());\n                        const reloadActionLabel = nls_1.localize('Reload', \"Reload Window and Open\");\n                        if (notificationHandle) {\n                            notificationHandle.progress.done();\n                            notificationHandle.updateMessage(reloadMessage);\n                            notificationHandle.updateActions({\n                                primary: [new actions_1.Action('reloadWindow', reloadActionLabel, undefined, true, () => this.reloadAndHandle(uri))]\n                            });\n                        }\n                        else {\n                            this.notificationService.prompt(notification_1.Severity.Info, reloadMessage, [{ label: reloadActionLabel, run: () => this.reloadAndHandle(uri) }], { sticky: true });\n                        }\n                    }\n                    catch (e) {\n                        if (notificationHandle) {\n                            notificationHandle.progress.done();\n                            notificationHandle.updateSeverity(notification_1.Severity.Error);\n                            notificationHandle.updateMessage(e);\n                        }\n                        else {\n                            this.notificationService.error(e);\n                        }\n                    }\n                }\n            });\n        }\n        reloadAndHandle(url) {\n            return __awaiter(this, void 0, void 0, function* () {\n                this.storageService.store(URL_TO_HANDLE, JSON.stringify(url.toJSON()), storage_1.StorageScope.WORKSPACE);\n                yield this.windowService.reloadWindow();\n            });\n        }\n        // forget about all uris buffered more than 5 minutes ago\n        garbageCollect() {\n            const now = new Date().getTime();\n            const uriBuffer = new Map();\n            this.uriBuffer.forEach((uris, extensionId) => {\n                uris = uris.filter(({ timestamp }) => now - timestamp < FIVE_MINUTES);\n                if (uris.length > 0) {\n                    uriBuffer.set(extensionId, uris);\n                }\n            });\n            this.uriBuffer = uriBuffer;\n        }\n        dispose() {\n            this.disposable.dispose();\n            this.extensionHandlers.clear();\n            this.uriBuffer.clear();\n        }\n    };\n    ExtensionUrlHandler = __decorate([\n        __param(0, url_1.IURLService),\n        __param(1, extensions_1.IExtensionService),\n        __param(2, dialogs_1.IDialogService),\n        __param(3, notification_1.INotificationService),\n        __param(4, extensionManagement_1.IExtensionManagementService),\n        __param(5, extensionManagement_1.IExtensionEnablementService),\n        __param(6, windows_1.IWindowService),\n        __param(7, extensionManagement_1.IExtensionGalleryService),\n        __param(8, storage_1.IStorageService)\n    ], ExtensionUrlHandler);\n    exports.ExtensionUrlHandler = ExtensionUrlHandler;\n    extensions_3.registerSingleton(exports.IExtensionUrlHandler, ExtensionUrlHandler);\n});\n",null]}