{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostOutputService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostOutputService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"../common/extHost.protocol\", \"vs/base/common/uri\", \"vs/base/common/path\", \"vs/workbench/services/output/node/outputAppender\", \"vs/base/common/date\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/base/node/pfs\"], function (require, exports, extHost_protocol_1, uri_1, path_1, outputAppender_1, date_1, event_1, lifecycle_1, pfs_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class AbstractExtHostOutputChannel extends lifecycle_1.Disposable {\n        constructor(name, log, file, proxy) {\n            super();\n            this._onDidAppend = this._register(new event_1.Emitter());\n            this.onDidAppend = this._onDidAppend.event;\n            this._name = name;\n            this._proxy = proxy;\n            this._id = proxy.$register(this.name, log, file);\n            this._offset = 0;\n        }\n        get name() {\n            return this._name;\n        }\n        append(value) {\n            this.validate();\n            this._offset += value ? Buffer.from(value).byteLength : 0;\n        }\n        update() {\n            this._id.then(id => this._proxy.$update(id));\n        }\n        appendLine(value) {\n            this.validate();\n            this.append(value + '\\n');\n        }\n        clear() {\n            this.validate();\n            const till = this._offset;\n            this._id.then(id => this._proxy.$clear(id, till));\n        }\n        show(columnOrPreserveFocus, preserveFocus) {\n            this.validate();\n            this._id.then(id => this._proxy.$reveal(id, !!(typeof columnOrPreserveFocus === 'boolean' ? columnOrPreserveFocus : preserveFocus)));\n        }\n        hide() {\n            this.validate();\n            this._id.then(id => this._proxy.$close(id));\n        }\n        validate() {\n            if (this._disposed) {\n                throw new Error('Channel has been closed');\n            }\n        }\n        dispose() {\n            super.dispose();\n            if (!this._disposed) {\n                this._id\n                    .then(id => this._proxy.$dispose(id))\n                    .then(() => this._disposed = true);\n            }\n        }\n    }\n    class ExtHostPushOutputChannel extends AbstractExtHostOutputChannel {\n        constructor(name, proxy) {\n            super(name, false, undefined, proxy);\n        }\n        append(value) {\n            super.append(value);\n            this._id.then(id => this._proxy.$append(id, value));\n            this._onDidAppend.fire();\n        }\n    }\n    class ExtHostOutputChannelBackedByFile extends AbstractExtHostOutputChannel {\n        constructor(name, appender, proxy) {\n            super(name, false, uri_1.URI.file(appender.file), proxy);\n            this._appender = appender;\n        }\n        append(value) {\n            super.append(value);\n            this._appender.append(value);\n            this._onDidAppend.fire();\n        }\n        update() {\n            this._appender.flush();\n            super.update();\n        }\n        show(columnOrPreserveFocus, preserveFocus) {\n            this._appender.flush();\n            super.show(columnOrPreserveFocus, preserveFocus);\n        }\n        clear() {\n            this._appender.flush();\n            super.clear();\n        }\n    }\n    class ExtHostLogFileOutputChannel extends AbstractExtHostOutputChannel {\n        constructor(name, file, proxy) {\n            super(name, true, file, proxy);\n        }\n        append(value) {\n            throw new Error('Not supported');\n        }\n    }\n    let namePool = 1;\n    function createExtHostOutputChannel(name, outputDirPromise, proxy) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const outputDir = yield outputDirPromise;\n                const fileName = `${namePool++}-${name}`;\n                const file = uri_1.URI.file(path_1.join(outputDir, `${fileName}.log`));\n                const appender = new outputAppender_1.OutputAppender(fileName, file.fsPath);\n                return new ExtHostOutputChannelBackedByFile(name, appender, proxy);\n            }\n            catch (error) {\n                // Do not crash if logger cannot be created\n                console.log(error);\n                return new ExtHostPushOutputChannel(name, proxy);\n            }\n        });\n    }\n    class ExtHostOutputService {\n        constructor(logsLocation, mainContext) {\n            this._channels = new Map();\n            const outputDirPath = path_1.join(logsLocation.fsPath, `output_logging_${date_1.toLocalISOString(new Date()).replace(/-|:|\\.\\d+Z$/g, '')}`);\n            this._outputDir = pfs_1.dirExists(outputDirPath).then(exists => exists ? exists : pfs_1.mkdirp(outputDirPath)).then(() => outputDirPath);\n            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadOutputService);\n        }\n        $setVisibleChannel(channelId) {\n            if (this._visibleChannelDisposable) {\n                this._visibleChannelDisposable = lifecycle_1.dispose(this._visibleChannelDisposable);\n            }\n            if (channelId) {\n                const channel = this._channels.get(channelId);\n                if (channel) {\n                    this._visibleChannelDisposable = channel.onDidAppend(() => channel.update());\n                }\n            }\n        }\n        createOutputChannel(name) {\n            name = name.trim();\n            if (!name) {\n                throw new Error('illegal argument `name`. must not be falsy');\n            }\n            else {\n                const extHostOutputChannel = createExtHostOutputChannel(name, this._outputDir, this._proxy);\n                extHostOutputChannel.then(channel => channel._id.then(id => this._channels.set(id, channel)));\n                return {\n                    get name() {\n                        return name;\n                    },\n                    append(value) {\n                        extHostOutputChannel.then(channel => channel.append(value));\n                    },\n                    appendLine(value) {\n                        extHostOutputChannel.then(channel => channel.appendLine(value));\n                    },\n                    clear() {\n                        extHostOutputChannel.then(channel => channel.clear());\n                    },\n                    show(columnOrPreserveFocus, preserveFocus) {\n                        extHostOutputChannel.then(channel => channel.show(columnOrPreserveFocus, preserveFocus));\n                    },\n                    hide() {\n                        extHostOutputChannel.then(channel => channel.hide());\n                    },\n                    dispose() {\n                        extHostOutputChannel.then(channel => channel.dispose());\n                    }\n                };\n            }\n        }\n        createOutputChannelFromLogFile(name, file) {\n            name = name.trim();\n            if (!name) {\n                throw new Error('illegal argument `name`. must not be falsy');\n            }\n            if (!file) {\n                throw new Error('illegal argument `file`. must not be falsy');\n            }\n            return new ExtHostLogFileOutputChannel(name, file, this._proxy);\n        }\n    }\n    exports.ExtHostOutputService = ExtHostOutputService;\n});\n",null]}