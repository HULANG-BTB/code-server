{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/worker/simpleWorker.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/worker/simpleWorker.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/errors\", \"vs/base/common/lifecycle\", \"vs/base/common/platform\", \"vs/base/common/types\"], function (require, exports, errors_1, lifecycle_1, platform_1, types_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const INITIALIZE = '$initialize';\n    let webWorkerWarningLogged = false;\n    function logOnceWebWorkerWarning(err) {\n        if (!platform_1.isWeb) {\n            // running tests\n            return;\n        }\n        if (!webWorkerWarningLogged) {\n            webWorkerWarningLogged = true;\n            console.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/Microsoft/monaco-editor#faq');\n        }\n        console.warn(err.message);\n    }\n    exports.logOnceWebWorkerWarning = logOnceWebWorkerWarning;\n    class SimpleWorkerProtocol {\n        constructor(handler) {\n            this._workerId = -1;\n            this._handler = handler;\n            this._lastSentReq = 0;\n            this._pendingReplies = Object.create(null);\n        }\n        setWorkerId(workerId) {\n            this._workerId = workerId;\n        }\n        sendMessage(method, args) {\n            let req = String(++this._lastSentReq);\n            return new Promise((resolve, reject) => {\n                this._pendingReplies[req] = {\n                    resolve: resolve,\n                    reject: reject\n                };\n                this._send({\n                    vsWorker: this._workerId,\n                    req: req,\n                    method: method,\n                    args: args\n                });\n            });\n        }\n        handleMessage(serializedMessage) {\n            let message;\n            try {\n                message = JSON.parse(serializedMessage);\n            }\n            catch (e) {\n                // nothing\n                return;\n            }\n            if (!message || !message.vsWorker) {\n                return;\n            }\n            if (this._workerId !== -1 && message.vsWorker !== this._workerId) {\n                return;\n            }\n            this._handleMessage(message);\n        }\n        _handleMessage(msg) {\n            if (msg.seq) {\n                let replyMessage = msg;\n                if (!this._pendingReplies[replyMessage.seq]) {\n                    console.warn('Got reply to unknown seq');\n                    return;\n                }\n                let reply = this._pendingReplies[replyMessage.seq];\n                delete this._pendingReplies[replyMessage.seq];\n                if (replyMessage.err) {\n                    let err = replyMessage.err;\n                    if (replyMessage.err.$isError) {\n                        err = new Error();\n                        err.name = replyMessage.err.name;\n                        err.message = replyMessage.err.message;\n                        err.stack = replyMessage.err.stack;\n                    }\n                    reply.reject(err);\n                    return;\n                }\n                reply.resolve(replyMessage.res);\n                return;\n            }\n            let requestMessage = msg;\n            let req = requestMessage.req;\n            let result = this._handler.handleMessage(requestMessage.method, requestMessage.args);\n            result.then((r) => {\n                this._send({\n                    vsWorker: this._workerId,\n                    seq: req,\n                    res: r,\n                    err: undefined\n                });\n            }, (e) => {\n                if (e.detail instanceof Error) {\n                    // Loading errors have a detail property that points to the actual error\n                    e.detail = errors_1.transformErrorForSerialization(e.detail);\n                }\n                this._send({\n                    vsWorker: this._workerId,\n                    seq: req,\n                    res: undefined,\n                    err: errors_1.transformErrorForSerialization(e)\n                });\n            });\n        }\n        _send(msg) {\n            let strMsg = JSON.stringify(msg);\n            // console.log('SENDING: ' + strMsg);\n            this._handler.sendMessage(strMsg);\n        }\n    }\n    /**\n     * Main thread side\n     */\n    class SimpleWorkerClient extends lifecycle_1.Disposable {\n        constructor(workerFactory, moduleId) {\n            super();\n            let lazyProxyReject = null;\n            this._worker = this._register(workerFactory.create('vs/base/common/worker/simpleWorker', (msg) => {\n                this._protocol.handleMessage(msg);\n            }, (err) => {\n                // in Firefox, web workers fail lazily :(\n                // we will reject the proxy\n                if (lazyProxyReject) {\n                    lazyProxyReject(err);\n                }\n            }));\n            this._protocol = new SimpleWorkerProtocol({\n                sendMessage: (msg) => {\n                    this._worker.postMessage(msg);\n                },\n                handleMessage: (method, args) => {\n                    // Intentionally not supporting worker -> main requests\n                    return Promise.resolve(null);\n                }\n            });\n            this._protocol.setWorkerId(this._worker.getId());\n            // Gather loader configuration\n            let loaderConfiguration = null;\n            if (typeof self.require !== 'undefined' && typeof self.require.getConfig === 'function') {\n                // Get the configuration from the Monaco AMD Loader\n                loaderConfiguration = self.require.getConfig();\n            }\n            else if (typeof self.requirejs !== 'undefined') {\n                // Get the configuration from requirejs\n                loaderConfiguration = self.requirejs.s.contexts._.config;\n            }\n            // Send initialize message\n            this._onModuleLoaded = this._protocol.sendMessage(INITIALIZE, [\n                this._worker.getId(),\n                moduleId,\n                loaderConfiguration\n            ]);\n            this._lazyProxy = new Promise((resolve, reject) => {\n                lazyProxyReject = reject;\n                this._onModuleLoaded.then((availableMethods) => {\n                    let proxy = {};\n                    for (const methodName of availableMethods) {\n                        proxy[methodName] = createProxyMethod(methodName, proxyMethodRequest);\n                    }\n                    resolve(proxy);\n                }, (e) => {\n                    reject(e);\n                    this._onError('Worker failed to load ' + moduleId, e);\n                });\n            });\n            // Create proxy to loaded code\n            const proxyMethodRequest = (method, args) => {\n                return this._request(method, args);\n            };\n            const createProxyMethod = (method, proxyMethodRequest) => {\n                return function () {\n                    let args = Array.prototype.slice.call(arguments, 0);\n                    return proxyMethodRequest(method, args);\n                };\n            };\n        }\n        getProxyObject() {\n            return this._lazyProxy;\n        }\n        _request(method, args) {\n            return new Promise((resolve, reject) => {\n                this._onModuleLoaded.then(() => {\n                    this._protocol.sendMessage(method, args).then(resolve, reject);\n                }, reject);\n            });\n        }\n        _onError(message, error) {\n            console.error(message);\n            console.info(error);\n        }\n    }\n    exports.SimpleWorkerClient = SimpleWorkerClient;\n    /**\n     * Worker side\n     */\n    class SimpleWorkerServer {\n        constructor(postSerializedMessage, requestHandler) {\n            this._requestHandler = requestHandler;\n            this._protocol = new SimpleWorkerProtocol({\n                sendMessage: (msg) => {\n                    postSerializedMessage(msg);\n                },\n                handleMessage: (method, args) => this._handleMessage(method, args)\n            });\n        }\n        onmessage(msg) {\n            this._protocol.handleMessage(msg);\n        }\n        _handleMessage(method, args) {\n            if (method === INITIALIZE) {\n                return this.initialize(args[0], args[1], args[2]);\n            }\n            if (!this._requestHandler || typeof this._requestHandler[method] !== 'function') {\n                return Promise.reject(new Error('Missing requestHandler or method: ' + method));\n            }\n            try {\n                return Promise.resolve(this._requestHandler[method].apply(this._requestHandler, args));\n            }\n            catch (e) {\n                return Promise.reject(e);\n            }\n        }\n        initialize(workerId, moduleId, loaderConfig) {\n            this._protocol.setWorkerId(workerId);\n            if (this._requestHandler) {\n                // static request handler\n                let methods = [];\n                for (const prop of types_1.getAllPropertyNames(this._requestHandler)) {\n                    if (typeof this._requestHandler[prop] === 'function') {\n                        methods.push(prop);\n                    }\n                }\n                return Promise.resolve(methods);\n            }\n            if (loaderConfig) {\n                // Remove 'baseUrl', handling it is beyond scope for now\n                if (typeof loaderConfig.baseUrl !== 'undefined') {\n                    delete loaderConfig['baseUrl'];\n                }\n                if (typeof loaderConfig.paths !== 'undefined') {\n                    if (typeof loaderConfig.paths.vs !== 'undefined') {\n                        delete loaderConfig.paths['vs'];\n                    }\n                }\n                // Since this is in a web worker, enable catching errors\n                loaderConfig.catchError = true;\n                self.require.config(loaderConfig);\n            }\n            return new Promise((resolve, reject) => {\n                // Use the global require to be sure to get the global config\n                self.require([moduleId], (...result) => {\n                    let handlerModule = result[0];\n                    this._requestHandler = handlerModule.create();\n                    if (!this._requestHandler) {\n                        reject(new Error(`No RequestHandler!`));\n                        return;\n                    }\n                    let methods = [];\n                    for (const prop of types_1.getAllPropertyNames(this._requestHandler)) {\n                        if (typeof this._requestHandler[prop] === 'function') {\n                            methods.push(prop);\n                        }\n                    }\n                    resolve(methods);\n                }, reject);\n            });\n        }\n    }\n    exports.SimpleWorkerServer = SimpleWorkerServer;\n    /**\n     * Called on the worker side\n     */\n    function create(postMessage) {\n        return new SimpleWorkerServer(postMessage, null);\n    }\n    exports.create = create;\n});\n",null]}