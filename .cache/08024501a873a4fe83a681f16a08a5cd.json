{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/code/node/cliProcessMain.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/code/node/cliProcessMain.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/platform/product/node/product\", \"vs/platform/product/node/package\", \"vs/base/common/path\", \"semver\", \"vs/platform/instantiation/common/serviceCollection\", \"vs/platform/instantiation/common/descriptors\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/instantiation/common/instantiationService\", \"vs/platform/environment/common/environment\", \"vs/platform/environment/node/environmentService\", \"vs/platform/extensionManagement/common/extensionManagement\", \"vs/platform/extensionManagement/node/extensionManagementService\", \"vs/platform/extensionManagement/node/extensionGalleryService\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/telemetry/common/telemetryUtils\", \"vs/platform/telemetry/common/telemetryService\", \"vs/platform/telemetry/node/commonProperties\", \"vs/platform/request/node/request\", \"vs/platform/request/node/requestService\", \"vs/platform/configuration/common/configuration\", \"vs/platform/configuration/node/configurationService\", \"vs/platform/telemetry/node/appInsightsAppender\", \"vs/base/node/pfs\", \"vs/base/common/labels\", \"vs/platform/state/common/state\", \"vs/platform/state/node/stateService\", \"vs/platform/log/node/spdlogService\", \"vs/platform/log/common/log\", \"vs/base/common/errors\", \"vs/platform/extensionManagement/common/extensionManagementUtil\", \"vs/base/common/uri\", \"vs/platform/extensionManagement/node/extensionManagementUtil\", \"vs/platform/extensions/common/extensions\", \"vs/platform/extensions/node/extensionsUtil\", \"vs/base/common/cancellation\", \"vs/platform/localizations/node/localizations\"], function (require, exports, nls_1, product_1, package_1, path, semver, serviceCollection_1, descriptors_1, instantiation_1, instantiationService_1, environment_1, environmentService_1, extensionManagement_1, extensionManagementService_1, extensionGalleryService_1, telemetry_1, telemetryUtils_1, telemetryService_1, commonProperties_1, request_1, requestService_1, configuration_1, configurationService_1, appInsightsAppender_1, pfs_1, labels_1, state_1, stateService_1, spdlogService_1, log_1, errors_1, extensionManagementUtil_1, uri_1, extensionManagementUtil_2, extensions_1, extensionsUtil_1, cancellation_1, localizations_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const notFound = (id) => nls_1.localize('notFound', \"Extension '{0}' not found.\", id);\n    const notInstalled = (id) => nls_1.localize('notInstalled', \"Extension '{0}' is not installed.\", id);\n    const useId = nls_1.localize('useId', \"Make sure you use the full extension ID, including the publisher, eg: {0}\", 'ms-vscode.csharp');\n    function getId(manifest, withVersion) {\n        if (withVersion) {\n            return `${manifest.publisher}.${manifest.name}@${manifest.version}`;\n        }\n        else {\n            return `${manifest.publisher}.${manifest.name}`;\n        }\n    }\n    const EXTENSION_ID_REGEX = /^([^.]+\\..+)@(\\d+\\.\\d+\\.\\d+(-.*)?)$/;\n    function getIdAndVersion(id) {\n        const matches = EXTENSION_ID_REGEX.exec(id);\n        if (matches && matches[1]) {\n            return [extensionManagementUtil_1.adoptToGalleryExtensionId(matches[1]), matches[2]];\n        }\n        return [extensionManagementUtil_1.adoptToGalleryExtensionId(id), undefined];\n    }\n    exports.getIdAndVersion = getIdAndVersion;\n    let Main = class Main {\n        constructor(remote, instantiationService, environmentService, configurationService, extensionManagementService, extensionGalleryService) {\n            this.remote = remote;\n            this.instantiationService = instantiationService;\n            this.environmentService = environmentService;\n            this.configurationService = configurationService;\n            this.extensionManagementService = extensionManagementService;\n            this.extensionGalleryService = extensionGalleryService;\n        }\n        run(argv) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (argv['install-source']) {\n                    yield this.setInstallSource(argv['install-source']);\n                }\n                else if (argv['list-extensions']) {\n                    yield this.listExtensions(!!argv['show-versions']);\n                }\n                else if (argv['install-extension']) {\n                    const arg = argv['install-extension'];\n                    const args = typeof arg === 'string' ? [arg] : arg;\n                    yield this.installExtensions(args, argv['force']);\n                }\n                else if (argv['uninstall-extension']) {\n                    const arg = argv['uninstall-extension'];\n                    const ids = typeof arg === 'string' ? [arg] : arg;\n                    yield this.uninstallExtension(ids);\n                }\n            });\n        }\n        setInstallSource(installSource) {\n            return pfs_1.writeFile(this.environmentService.installSourcePath, installSource.slice(0, 30));\n        }\n        listExtensions(showVersions) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const extensions = yield this.extensionManagementService.getInstalled(extensions_1.ExtensionType.User);\n                extensions.forEach(e => console.log(getId(e.manifest, showVersions)));\n            });\n        }\n        installExtensions(extensions, force) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const failed = [];\n                const installedExtensionsManifests = [];\n                for (const extension of extensions) {\n                    try {\n                        const manifest = yield this.installExtension(extension, force);\n                        if (manifest) {\n                            installedExtensionsManifests.push(manifest);\n                        }\n                    }\n                    catch (err) {\n                        console.error(err.message || err.stack || err);\n                        failed.push(extension);\n                    }\n                }\n                if (installedExtensionsManifests.some(manifest => extensions_1.isLanguagePackExtension(manifest))) {\n                    yield this.updateLocalizationsCache();\n                }\n                return failed.length ? Promise.reject(nls_1.localize('installation failed', \"Failed Installing Extensions: {0}\", failed.join(', '))) : Promise.resolve();\n            });\n        }\n        installExtension(extension, force) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (/\\.vsix$/i.test(extension)) {\n                    extension = path.isAbsolute(extension) ? extension : path.join(process.cwd(), extension);\n                    const manifest = yield extensionManagementUtil_2.getManifest(extension);\n                    if (this.remote && (!extensions_1.isLanguagePackExtension(manifest) && extensionsUtil_1.isUIExtension(manifest, [], this.configurationService))) {\n                        console.log(nls_1.localize('notSupportedUIExtension', \"Can't install extension {0} since UI Extensions are not supported\", labels_1.getBaseLabel(extension)));\n                        return null;\n                    }\n                    const valid = yield this.validate(manifest, force);\n                    if (valid) {\n                        return this.extensionManagementService.install(uri_1.URI.file(extension)).then(id => {\n                            console.log(nls_1.localize('successVsixInstall', \"Extension '{0}' was successfully installed!\", labels_1.getBaseLabel(extension)));\n                            return manifest;\n                        }, error => {\n                            if (errors_1.isPromiseCanceledError(error)) {\n                                console.log(nls_1.localize('cancelVsixInstall', \"Cancelled installing Extension '{0}'.\", labels_1.getBaseLabel(extension)));\n                                return null;\n                            }\n                            else {\n                                return Promise.reject(error);\n                            }\n                        });\n                    }\n                    return null;\n                }\n                const [id, version] = getIdAndVersion(extension);\n                return this.extensionManagementService.getInstalled(extensions_1.ExtensionType.User)\n                    .then(installed => this.extensionGalleryService.getCompatibleExtension({ id }, version)\n                    .then(null, err => {\n                    if (err.responseText) {\n                        try {\n                            const response = JSON.parse(err.responseText);\n                            return Promise.reject(response.message);\n                        }\n                        catch (e) {\n                            // noop\n                        }\n                    }\n                    return Promise.reject(err);\n                })\n                    .then((extension) => __awaiter(this, void 0, void 0, function* () {\n                    if (!extension) {\n                        return Promise.reject(new Error(`${notFound(version ? `${id}@${version}` : id)}\\n${useId}`));\n                    }\n                    const manifest = yield this.extensionGalleryService.getManifest(extension, cancellation_1.CancellationToken.None);\n                    if (this.remote && manifest && (!extensions_1.isLanguagePackExtension(manifest) && extensionsUtil_1.isUIExtension(manifest, [], this.configurationService))) {\n                        console.log(nls_1.localize('notSupportedUIExtension', \"Can't install extension {0} since UI Extensions are not supported\", extension.identifier.id));\n                        return null;\n                    }\n                    const [installedExtension] = installed.filter(e => extensionManagementUtil_1.areSameExtensions(e.identifier, { id }));\n                    if (installedExtension) {\n                        if (extension.version === installedExtension.manifest.version) {\n                            console.log(nls_1.localize('alreadyInstalled', \"Extension '{0}' is already installed.\", version ? `${id}@${version}` : id));\n                            return Promise.resolve(null);\n                        }\n                        if (!version && !force) {\n                            console.log(nls_1.localize('forceUpdate', \"Extension '{0}' v{1} is already installed, but a newer version {2} is available in the marketplace. Use '--force' option to update to newer version.\", id, installedExtension.manifest.version, extension.version));\n                            return Promise.resolve(null);\n                        }\n                        console.log(nls_1.localize('updateMessage', \"Updating the Extension '{0}' to the version {1}\", id, extension.version));\n                    }\n                    else {\n                        console.log(nls_1.localize('foundExtension', \"Found '{0}' in the marketplace.\", id));\n                    }\n                    yield this.installFromGallery(id, extension);\n                    return manifest;\n                })));\n            });\n        }\n        validate(manifest, force) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!manifest) {\n                    throw new Error('Invalid vsix');\n                }\n                const extensionIdentifier = { id: extensionManagementUtil_1.getGalleryExtensionId(manifest.publisher, manifest.name) };\n                const installedExtensions = yield this.extensionManagementService.getInstalled(extensions_1.ExtensionType.User);\n                const newer = installedExtensions.filter(local => extensionManagementUtil_1.areSameExtensions(extensionIdentifier, local.identifier) && semver.gt(local.manifest.version, manifest.version))[0];\n                if (newer && !force) {\n                    console.log(nls_1.localize('forceDowngrade', \"A newer version of this extension '{0}' v{1} is already installed. Use '--force' option to downgrade to older version.\", newer.identifier.id, newer.manifest.version, manifest.version));\n                    return false;\n                }\n                return true;\n            });\n        }\n        installFromGallery(id, extension) {\n            return __awaiter(this, void 0, void 0, function* () {\n                console.log(nls_1.localize('installing', \"Installing...\"));\n                try {\n                    yield this.extensionManagementService.installFromGallery(extension);\n                    console.log(nls_1.localize('successInstall', \"Extension '{0}' v{1} was successfully installed!\", id, extension.version));\n                }\n                catch (error) {\n                    if (errors_1.isPromiseCanceledError(error)) {\n                        console.log(nls_1.localize('cancelVsixInstall', \"Cancelled installing Extension '{0}'.\", id));\n                    }\n                    else {\n                        throw error;\n                    }\n                }\n            });\n        }\n        uninstallExtension(extensions) {\n            return __awaiter(this, void 0, void 0, function* () {\n                function getExtensionId(extensionDescription) {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        if (!/\\.vsix$/i.test(extensionDescription)) {\n                            return extensionDescription;\n                        }\n                        const zipPath = path.isAbsolute(extensionDescription) ? extensionDescription : path.join(process.cwd(), extensionDescription);\n                        const manifest = yield extensionManagementUtil_2.getManifest(zipPath);\n                        return getId(manifest);\n                    });\n                }\n                const uninstalledExtensions = [];\n                for (const extension of extensions) {\n                    const id = yield getExtensionId(extension);\n                    const installed = yield this.extensionManagementService.getInstalled(extensions_1.ExtensionType.User);\n                    const [extensionToUninstall] = installed.filter(e => extensionManagementUtil_1.areSameExtensions(e.identifier, { id }));\n                    if (!extensionToUninstall) {\n                        return Promise.reject(new Error(`${notInstalled(id)}\\n${useId}`));\n                    }\n                    console.log(nls_1.localize('uninstalling', \"Uninstalling {0}...\", id));\n                    yield this.extensionManagementService.uninstall(extensionToUninstall, true);\n                    uninstalledExtensions.push(extensionToUninstall);\n                    console.log(nls_1.localize('successUninstall', \"Extension '{0}' was successfully uninstalled!\", id));\n                }\n                if (uninstalledExtensions.some(e => extensions_1.isLanguagePackExtension(e.manifest))) {\n                    yield this.updateLocalizationsCache();\n                }\n            });\n        }\n        updateLocalizationsCache() {\n            return __awaiter(this, void 0, void 0, function* () {\n                const localizationService = this.instantiationService.createInstance(localizations_1.LocalizationsService);\n                yield localizationService.update();\n                localizationService.dispose();\n            });\n        }\n    };\n    Main = __decorate([\n        __param(1, instantiation_1.IInstantiationService),\n        __param(2, environment_1.IEnvironmentService),\n        __param(3, configuration_1.IConfigurationService),\n        __param(4, extensionManagement_1.IExtensionManagementService),\n        __param(5, extensionManagement_1.IExtensionGalleryService)\n    ], Main);\n    exports.Main = Main;\n    const eventPrefix = 'monacoworkbench';\n    function main(argv) {\n        const services = new serviceCollection_1.ServiceCollection();\n        const environmentService = new environmentService_1.EnvironmentService(argv, process.execPath);\n        const logService = spdlogService_1.createSpdLogService('cli', log_1.getLogLevel(environmentService), environmentService.logsPath);\n        process.once('exit', () => logService.dispose());\n        logService.info('main', argv);\n        services.set(environment_1.IEnvironmentService, environmentService);\n        services.set(log_1.ILogService, logService);\n        services.set(state_1.IStateService, new descriptors_1.SyncDescriptor(stateService_1.StateService));\n        const instantiationService = new instantiationService_1.InstantiationService(services);\n        return instantiationService.invokeFunction(accessor => {\n            const envService = accessor.get(environment_1.IEnvironmentService);\n            const stateService = accessor.get(state_1.IStateService);\n            return Promise.all([envService.appSettingsHome, envService.extensionsPath].map(p => pfs_1.mkdirp(p))).then(() => {\n                const { appRoot, extensionsPath, extensionDevelopmentLocationURI, isBuilt, installSourcePath } = envService;\n                const services = new serviceCollection_1.ServiceCollection();\n                services.set(configuration_1.IConfigurationService, new descriptors_1.SyncDescriptor(configurationService_1.ConfigurationService));\n                services.set(request_1.IRequestService, new descriptors_1.SyncDescriptor(requestService_1.RequestService));\n                services.set(extensionManagement_1.IExtensionManagementService, new descriptors_1.SyncDescriptor(extensionManagementService_1.ExtensionManagementService, [false]));\n                services.set(extensionManagement_1.IExtensionGalleryService, new descriptors_1.SyncDescriptor(extensionGalleryService_1.ExtensionGalleryService));\n                const appenders = [];\n                if (isBuilt && !extensionDevelopmentLocationURI && !envService.args['disable-telemetry'] && product_1.default.enableTelemetry) {\n                    if (product_1.default.aiConfig && product_1.default.aiConfig.asimovKey) {\n                        appenders.push(new appInsightsAppender_1.AppInsightsAppender(eventPrefix, null, product_1.default.aiConfig.asimovKey, logService));\n                    }\n                    const config = {\n                        appender: telemetryUtils_1.combinedAppender(...appenders),\n                        commonProperties: commonProperties_1.resolveCommonProperties(product_1.default.commit, package_1.default.version, stateService.getItem('telemetry.machineId'), installSourcePath),\n                        piiPaths: [appRoot, extensionsPath]\n                    };\n                    services.set(telemetry_1.ITelemetryService, new descriptors_1.SyncDescriptor(telemetryService_1.TelemetryService, [config]));\n                }\n                else {\n                    services.set(telemetry_1.ITelemetryService, telemetryUtils_1.NullTelemetryService);\n                }\n                const instantiationService2 = instantiationService.createChild(services);\n                const main = instantiationService2.createInstance(Main, false);\n                return main.run(argv).then(() => {\n                    // Dispose the AI adapter so that remaining data gets flushed.\n                    return telemetryUtils_1.combinedAppender(...appenders).dispose();\n                });\n            });\n        });\n    }\n    exports.main = main;\n});\n",null]}