{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/node/processes.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/processes.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar path = require(\"vs/base/common/path\");\nvar fs = require(\"fs\");\nvar cp = require(\"child_process\");\nvar nls = require(\"vs/nls\");\nvar Types = require(\"vs/base/common/types\");\nvar Objects = require(\"vs/base/common/objects\");\nvar extpath = require(\"vs/base/common/extpath\");\nvar Platform = require(\"vs/base/common/platform\");\nvar decoder_1 = require(\"vs/base/node/decoder\");\nvar processes_1 = require(\"vs/base/common/processes\");\nexports.CommandOptions = processes_1.CommandOptions;\nexports.ForkOptions = processes_1.ForkOptions;\nexports.SuccessData = processes_1.SuccessData;\nexports.Source = processes_1.Source;\nexports.TerminateResponse = processes_1.TerminateResponse;\nexports.TerminateResponseCode = processes_1.TerminateResponseCode;\nvar amd_1 = require(\"vs/base/common/amd\");\nfunction getWindowsCode(status) {\n    switch (status) {\n        case 0:\n            return processes_1.TerminateResponseCode.Success;\n        case 1:\n            return processes_1.TerminateResponseCode.AccessDenied;\n        case 128:\n            return processes_1.TerminateResponseCode.ProcessNotFound;\n        default:\n            return processes_1.TerminateResponseCode.Unknown;\n    }\n}\nfunction terminateProcess(process, cwd) {\n    if (Platform.isWindows) {\n        try {\n            var options = {\n                stdio: ['pipe', 'pipe', 'ignore']\n            };\n            if (cwd) {\n                options.cwd = cwd;\n            }\n            cp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);\n        }\n        catch (err) {\n            return { success: false, error: err, code: err.status ? getWindowsCode(err.status) : processes_1.TerminateResponseCode.Unknown };\n        }\n    }\n    else if (Platform.isLinux || Platform.isMacintosh) {\n        try {\n            var cmd = amd_1.getPathFromAmdModule(require, 'vs/base/node/terminateProcess.sh');\n            var result = cp.spawnSync(cmd, [process.pid.toString()]);\n            if (result.error) {\n                return { success: false, error: result.error };\n            }\n        }\n        catch (err) {\n            return { success: false, error: err };\n        }\n    }\n    else {\n        process.kill('SIGKILL');\n    }\n    return { success: true };\n}\nexports.terminateProcess = terminateProcess;\nfunction getWindowsShell() {\n    return process.env['comspec'] || 'cmd.exe';\n}\nexports.getWindowsShell = getWindowsShell;\nvar AbstractProcess = /** @class */ (function () {\n    function AbstractProcess(arg1, arg2, arg3, arg4) {\n        var _this = this;\n        if (arg2 !== undefined && arg3 !== undefined && arg4 !== undefined) {\n            this.cmd = arg1;\n            this.args = arg2;\n            this.shell = arg3;\n            this.options = arg4;\n        }\n        else {\n            var executable = arg1;\n            this.cmd = executable.command;\n            this.shell = executable.isShellCommand;\n            this.args = executable.args.slice(0);\n            this.options = executable.options || {};\n        }\n        this.childProcess = null;\n        this.terminateRequested = false;\n        if (this.options.env) {\n            var newEnv_1 = Object.create(null);\n            Object.keys(process.env).forEach(function (key) {\n                newEnv_1[key] = process.env[key];\n            });\n            Object.keys(this.options.env).forEach(function (key) {\n                newEnv_1[key] = _this.options.env[key];\n            });\n            this.options.env = newEnv_1;\n        }\n    }\n    AbstractProcess.prototype.getSanitizedCommand = function () {\n        var result = this.cmd.toLowerCase();\n        var index = result.lastIndexOf(path.sep);\n        if (index !== -1) {\n            result = result.substring(index + 1);\n        }\n        if (AbstractProcess.WellKnowCommands[result]) {\n            return result;\n        }\n        return 'other';\n    };\n    AbstractProcess.prototype.start = function (pp) {\n        var _this = this;\n        if (Platform.isWindows && ((this.options && this.options.cwd && extpath.isUNC(this.options.cwd)) || !this.options && extpath.isUNC(process.cwd()))) {\n            return Promise.reject(new Error(nls.localize('TaskRunner.UNC', 'Can\\'t execute a shell command on a UNC drive.')));\n        }\n        return this.useExec().then(function (useExec) {\n            var cc;\n            var ee;\n            var result = new Promise(function (c, e) {\n                cc = c;\n                ee = e;\n            });\n            if (useExec) {\n                var cmd = _this.cmd;\n                if (_this.args) {\n                    cmd = cmd + ' ' + _this.args.join(' ');\n                }\n                _this.childProcess = cp.exec(cmd, _this.options, function (error, stdout, stderr) {\n                    _this.childProcess = null;\n                    var err = error;\n                    // This is tricky since executing a command shell reports error back in case the executed command return an\n                    // error or the command didn't exist at all. So we can't blindly treat an error as a failed command. So we\n                    // always parse the output and report success unless the job got killed.\n                    if (err && err.killed) {\n                        ee({ killed: _this.terminateRequested, stdout: stdout.toString(), stderr: stderr.toString() });\n                    }\n                    else {\n                        _this.handleExec(cc, pp, error, stdout, stderr);\n                    }\n                });\n            }\n            else {\n                var childProcess = null;\n                var closeHandler = function (data) {\n                    _this.childProcess = null;\n                    _this.childProcessPromise = null;\n                    _this.handleClose(data, cc, pp, ee);\n                    var result = {\n                        terminated: _this.terminateRequested\n                    };\n                    if (Types.isNumber(data)) {\n                        result.cmdCode = data;\n                    }\n                    cc(result);\n                };\n                if (_this.shell && Platform.isWindows) {\n                    var options = Objects.deepClone(_this.options);\n                    options.windowsVerbatimArguments = true;\n                    options.detached = false;\n                    var quotedCommand = false;\n                    var quotedArg_1 = false;\n                    var commandLine_1 = [];\n                    var quoted_1 = _this.ensureQuotes(_this.cmd);\n                    commandLine_1.push(quoted_1.value);\n                    quotedCommand = quoted_1.quoted;\n                    if (_this.args) {\n                        _this.args.forEach(function (elem) {\n                            quoted_1 = _this.ensureQuotes(elem);\n                            commandLine_1.push(quoted_1.value);\n                            quotedArg_1 = quotedArg_1 && quoted_1.quoted;\n                        });\n                    }\n                    var args = [\n                        '/s',\n                        '/c',\n                    ];\n                    if (quotedCommand) {\n                        if (quotedArg_1) {\n                            args.push('\"' + commandLine_1.join(' ') + '\"');\n                        }\n                        else if (commandLine_1.length > 1) {\n                            args.push('\"' + commandLine_1[0] + '\"' + ' ' + commandLine_1.slice(1).join(' '));\n                        }\n                        else {\n                            args.push('\"' + commandLine_1[0] + '\"');\n                        }\n                    }\n                    else {\n                        args.push(commandLine_1.join(' '));\n                    }\n                    childProcess = cp.spawn(getWindowsShell(), args, options);\n                }\n                else {\n                    if (_this.cmd) {\n                        childProcess = cp.spawn(_this.cmd, _this.args, _this.options);\n                    }\n                }\n                if (childProcess) {\n                    _this.childProcess = childProcess;\n                    _this.childProcessPromise = Promise.resolve(childProcess);\n                    if (_this.pidResolve) {\n                        _this.pidResolve(Types.isNumber(childProcess.pid) ? childProcess.pid : -1);\n                        _this.pidResolve = undefined;\n                    }\n                    childProcess.on('error', function (error) {\n                        _this.childProcess = null;\n                        ee({ terminated: _this.terminateRequested, error: error });\n                    });\n                    if (childProcess.pid) {\n                        _this.childProcess.on('close', closeHandler);\n                        _this.handleSpawn(childProcess, cc, pp, ee, true);\n                    }\n                }\n            }\n            return result;\n        });\n    };\n    AbstractProcess.prototype.handleClose = function (data, cc, pp, ee) {\n        // Default is to do nothing.\n    };\n    AbstractProcess.prototype.ensureQuotes = function (value) {\n        if (AbstractProcess.regexp.test(value)) {\n            return {\n                value: '\"' + value + '\"',\n                quoted: true\n            };\n        }\n        else {\n            return {\n                value: value,\n                quoted: value.length > 0 && value[0] === '\"' && value[value.length - 1] === '\"'\n            };\n        }\n    };\n    Object.defineProperty(AbstractProcess.prototype, \"pid\", {\n        get: function () {\n            var _this = this;\n            if (this.childProcessPromise) {\n                return this.childProcessPromise.then(function (childProcess) { return childProcess.pid; }, function (err) { return -1; });\n            }\n            else {\n                return new Promise(function (resolve) {\n                    _this.pidResolve = resolve;\n                });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AbstractProcess.prototype.terminate = function () {\n        var _this = this;\n        if (!this.childProcessPromise) {\n            return Promise.resolve({ success: true });\n        }\n        return this.childProcessPromise.then(function (childProcess) {\n            _this.terminateRequested = true;\n            var result = terminateProcess(childProcess, _this.options.cwd);\n            if (result.success) {\n                _this.childProcess = null;\n            }\n            return result;\n        }, function (err) {\n            return { success: true };\n        });\n    };\n    AbstractProcess.prototype.useExec = function () {\n        var _this = this;\n        return new Promise(function (c, e) {\n            if (!_this.shell || !Platform.isWindows) {\n                return c(false);\n            }\n            var cmdShell = cp.spawn(getWindowsShell(), ['/s', '/c']);\n            cmdShell.on('error', function (error) {\n                return c(true);\n            });\n            cmdShell.on('exit', function (data) {\n                return c(false);\n            });\n        });\n    };\n    AbstractProcess.WellKnowCommands = {\n        'ant': true,\n        'cmake': true,\n        'eslint': true,\n        'gradle': true,\n        'grunt': true,\n        'gulp': true,\n        'jake': true,\n        'jenkins': true,\n        'jshint': true,\n        'make': true,\n        'maven': true,\n        'msbuild': true,\n        'msc': true,\n        'nmake': true,\n        'npm': true,\n        'rake': true,\n        'tsc': true,\n        'xbuild': true\n    };\n    AbstractProcess.regexp = /^[^\"].* .*[^\"]/;\n    return AbstractProcess;\n}());\nexports.AbstractProcess = AbstractProcess;\nvar LineProcess = /** @class */ (function (_super) {\n    tslib_1.__extends(LineProcess, _super);\n    function LineProcess(arg1, arg2, arg3, arg4) {\n        return _super.call(this, arg1, arg2, arg3, arg4) || this;\n    }\n    LineProcess.prototype.handleExec = function (cc, pp, error, stdout, stderr) {\n        [stdout, stderr].forEach(function (buffer, index) {\n            var lineDecoder = new decoder_1.LineDecoder();\n            var lines = lineDecoder.write(buffer);\n            lines.forEach(function (line) {\n                pp({ line: line, source: index === 0 ? processes_1.Source.stdout : processes_1.Source.stderr });\n            });\n            var line = lineDecoder.end();\n            if (line) {\n                pp({ line: line, source: index === 0 ? processes_1.Source.stdout : processes_1.Source.stderr });\n            }\n        });\n        cc({ terminated: this.terminateRequested, error: error });\n    };\n    LineProcess.prototype.handleSpawn = function (childProcess, cc, pp, ee, sync) {\n        var _this = this;\n        this.stdoutLineDecoder = new decoder_1.LineDecoder();\n        this.stderrLineDecoder = new decoder_1.LineDecoder();\n        childProcess.stdout.on('data', function (data) {\n            var lines = _this.stdoutLineDecoder.write(data);\n            lines.forEach(function (line) { return pp({ line: line, source: processes_1.Source.stdout }); });\n        });\n        childProcess.stderr.on('data', function (data) {\n            var lines = _this.stderrLineDecoder.write(data);\n            lines.forEach(function (line) { return pp({ line: line, source: processes_1.Source.stderr }); });\n        });\n    };\n    LineProcess.prototype.handleClose = function (data, cc, pp, ee) {\n        [this.stdoutLineDecoder.end(), this.stderrLineDecoder.end()].forEach(function (line, index) {\n            if (line) {\n                pp({ line: line, source: index === 0 ? processes_1.Source.stdout : processes_1.Source.stderr });\n            }\n        });\n    };\n    return LineProcess;\n}(AbstractProcess));\nexports.LineProcess = LineProcess;\n// Wrapper around process.send() that will queue any messages if the internal node.js\n// queue is filled with messages and only continue sending messages when the internal\n// queue is free again to consume messages.\n// On Windows we always wait for the send() method to return before sending the next message\n// to workaround https://github.com/nodejs/node/issues/7657 (IPC can freeze process)\nfunction createQueuedSender(childProcess) {\n    var msgQueue = [];\n    var useQueue = false;\n    var send = function (msg) {\n        if (useQueue) {\n            msgQueue.push(msg); // add to the queue if the process cannot handle more messages\n            return;\n        }\n        var result = childProcess.send(msg, function (error) {\n            if (error) {\n                console.error(error); // unlikely to happen, best we can do is log this error\n            }\n            useQueue = false; // we are good again to send directly without queue\n            // now send all the messages that we have in our queue and did not send yet\n            if (msgQueue.length > 0) {\n                var msgQueueCopy = msgQueue.slice(0);\n                msgQueue = [];\n                msgQueueCopy.forEach(function (entry) { return send(entry); });\n            }\n        });\n        if (!result || Platform.isWindows /* workaround https://github.com/nodejs/node/issues/7657 */) {\n            useQueue = true;\n        }\n    };\n    return { send: send };\n}\nexports.createQueuedSender = createQueuedSender;\nvar win32;\n(function (win32) {\n    function findExecutable(command, cwd, paths) {\n        // If we have an absolute path then we take it.\n        if (path.isAbsolute(command)) {\n            return command;\n        }\n        if (cwd === undefined) {\n            cwd = process.cwd();\n        }\n        var dir = path.dirname(command);\n        if (dir !== '.') {\n            // We have a directory and the directory is relative (see above). Make the path absolute\n            // to the current working directory.\n            return path.join(cwd, command);\n        }\n        if (paths === undefined && Types.isString(process.env.PATH)) {\n            paths = process.env.PATH.split(path.delimiter);\n        }\n        // No PATH environment. Make path absolute to the cwd.\n        if (paths === undefined || paths.length === 0) {\n            return path.join(cwd, command);\n        }\n        // We have a simple file name. We get the path variable from the env\n        // and try to find the executable on the path.\n        for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {\n            var pathEntry = paths_1[_i];\n            // The path entry is absolute.\n            var fullPath = void 0;\n            if (path.isAbsolute(pathEntry)) {\n                fullPath = path.join(pathEntry, command);\n            }\n            else {\n                fullPath = path.join(cwd, pathEntry, command);\n            }\n            if (fs.existsSync(fullPath)) {\n                return fullPath;\n            }\n            var withExtension = fullPath + '.com';\n            if (fs.existsSync(withExtension)) {\n                return withExtension;\n            }\n            withExtension = fullPath + '.exe';\n            if (fs.existsSync(withExtension)) {\n                return withExtension;\n            }\n        }\n        return path.join(cwd, command);\n    }\n    win32.findExecutable = findExecutable;\n})(win32 = exports.win32 || (exports.win32 = {}));\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/node/processes.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/node/processes.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from 'vs/base/common/path';\nimport * as fs from 'fs';\nimport * as cp from 'child_process';\nimport * as nls from 'vs/nls';\nimport * as Types from 'vs/base/common/types';\nimport { IStringDictionary } from 'vs/base/common/collections';\nimport * as Objects from 'vs/base/common/objects';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as Platform from 'vs/base/common/platform';\nimport { LineDecoder } from 'vs/base/node/decoder';\nimport { CommandOptions, ForkOptions, SuccessData, Source, TerminateResponse, TerminateResponseCode, Executable } from 'vs/base/common/processes';\nimport { getPathFromAmdModule } from 'vs/base/common/amd';\nexport { CommandOptions, ForkOptions, SuccessData, Source, TerminateResponse, TerminateResponseCode };\n\nexport type ValueCallback<T> = (value?: T | Promise<T>) => void;\nexport type ErrorCallback = (error?: any) => void;\nexport type ProgressCallback<T> = (progress: T) => void;\n\nexport interface LineData {\n\tline: string;\n\tsource: Source;\n}\n\nfunction getWindowsCode(status: number): TerminateResponseCode {\n\tswitch (status) {\n\t\tcase 0:\n\t\t\treturn TerminateResponseCode.Success;\n\t\tcase 1:\n\t\t\treturn TerminateResponseCode.AccessDenied;\n\t\tcase 128:\n\t\t\treturn TerminateResponseCode.ProcessNotFound;\n\t\tdefault:\n\t\t\treturn TerminateResponseCode.Unknown;\n\t}\n}\n\nexport function terminateProcess(process: cp.ChildProcess, cwd?: string): TerminateResponse {\n\tif (Platform.isWindows) {\n\t\ttry {\n\t\t\tconst options: any = {\n\t\t\t\tstdio: ['pipe', 'pipe', 'ignore']\n\t\t\t};\n\t\t\tif (cwd) {\n\t\t\t\toptions.cwd = cwd;\n\t\t\t}\n\t\t\tcp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);\n\t\t} catch (err) {\n\t\t\treturn { success: false, error: err, code: err.status ? getWindowsCode(err.status) : TerminateResponseCode.Unknown };\n\t\t}\n\t} else if (Platform.isLinux || Platform.isMacintosh) {\n\t\ttry {\n\t\t\tconst cmd = getPathFromAmdModule(require, 'vs/base/node/terminateProcess.sh');\n\t\t\tconst result = cp.spawnSync(cmd, [process.pid.toString()]);\n\t\t\tif (result.error) {\n\t\t\t\treturn { success: false, error: result.error };\n\t\t\t}\n\t\t} catch (err) {\n\t\t\treturn { success: false, error: err };\n\t\t}\n\t} else {\n\t\tprocess.kill('SIGKILL');\n\t}\n\treturn { success: true };\n}\n\nexport function getWindowsShell(): string {\n\treturn process.env['comspec'] || 'cmd.exe';\n}\n\nexport abstract class AbstractProcess<TProgressData> {\n\tprivate cmd: string;\n\tprivate args: string[];\n\tprivate options: CommandOptions | ForkOptions;\n\tprotected shell: boolean;\n\n\tprivate childProcess: cp.ChildProcess | null;\n\tprotected childProcessPromise: Promise<cp.ChildProcess> | null;\n\tprivate pidResolve?: ValueCallback<number>;\n\tprotected terminateRequested: boolean;\n\n\tprivate static WellKnowCommands: IStringDictionary<boolean> = {\n\t\t'ant': true,\n\t\t'cmake': true,\n\t\t'eslint': true,\n\t\t'gradle': true,\n\t\t'grunt': true,\n\t\t'gulp': true,\n\t\t'jake': true,\n\t\t'jenkins': true,\n\t\t'jshint': true,\n\t\t'make': true,\n\t\t'maven': true,\n\t\t'msbuild': true,\n\t\t'msc': true,\n\t\t'nmake': true,\n\t\t'npm': true,\n\t\t'rake': true,\n\t\t'tsc': true,\n\t\t'xbuild': true\n\t};\n\n\tpublic constructor(executable: Executable);\n\tpublic constructor(cmd: string, args: string[] | undefined, shell: boolean, options: CommandOptions | undefined);\n\tpublic constructor(arg1: string | Executable, arg2?: string[], arg3?: boolean, arg4?: CommandOptions) {\n\t\tif (arg2 !== undefined && arg3 !== undefined && arg4 !== undefined) {\n\t\t\tthis.cmd = <string>arg1;\n\t\t\tthis.args = arg2;\n\t\t\tthis.shell = arg3;\n\t\t\tthis.options = arg4;\n\t\t} else {\n\t\t\tconst executable = <Executable>arg1;\n\t\t\tthis.cmd = executable.command;\n\t\t\tthis.shell = executable.isShellCommand;\n\t\t\tthis.args = executable.args.slice(0);\n\t\t\tthis.options = executable.options || {};\n\t\t}\n\n\t\tthis.childProcess = null;\n\t\tthis.terminateRequested = false;\n\n\t\tif (this.options.env) {\n\t\t\tconst newEnv: IStringDictionary<string> = Object.create(null);\n\t\t\tObject.keys(process.env).forEach((key) => {\n\t\t\t\tnewEnv[key] = process.env[key]!;\n\t\t\t});\n\t\t\tObject.keys(this.options.env).forEach((key) => {\n\t\t\t\tnewEnv[key] = this.options.env![key]!;\n\t\t\t});\n\t\t\tthis.options.env = newEnv;\n\t\t}\n\t}\n\n\tpublic getSanitizedCommand(): string {\n\t\tlet result = this.cmd.toLowerCase();\n\t\tconst index = result.lastIndexOf(path.sep);\n\t\tif (index !== -1) {\n\t\t\tresult = result.substring(index + 1);\n\t\t}\n\t\tif (AbstractProcess.WellKnowCommands[result]) {\n\t\t\treturn result;\n\t\t}\n\t\treturn 'other';\n\t}\n\n\tpublic start(pp: ProgressCallback<TProgressData>): Promise<SuccessData> {\n\t\tif (Platform.isWindows && ((this.options && this.options.cwd && extpath.isUNC(this.options.cwd)) || !this.options && extpath.isUNC(process.cwd()))) {\n\t\t\treturn Promise.reject(new Error(nls.localize('TaskRunner.UNC', 'Can\\'t execute a shell command on a UNC drive.')));\n\t\t}\n\t\treturn this.useExec().then((useExec) => {\n\t\t\tlet cc: ValueCallback<SuccessData>;\n\t\t\tlet ee: ErrorCallback;\n\t\t\tconst result = new Promise<any>((c, e) => {\n\t\t\t\tcc = c;\n\t\t\t\tee = e;\n\t\t\t});\n\n\t\t\tif (useExec) {\n\t\t\t\tlet cmd: string = this.cmd;\n\t\t\t\tif (this.args) {\n\t\t\t\t\tcmd = cmd + ' ' + this.args.join(' ');\n\t\t\t\t}\n\t\t\t\tthis.childProcess = cp.exec(cmd, this.options, (error, stdout, stderr) => {\n\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\tconst err: any = error;\n\t\t\t\t\t// This is tricky since executing a command shell reports error back in case the executed command return an\n\t\t\t\t\t// error or the command didn't exist at all. So we can't blindly treat an error as a failed command. So we\n\t\t\t\t\t// always parse the output and report success unless the job got killed.\n\t\t\t\t\tif (err && err.killed) {\n\t\t\t\t\t\tee({ killed: this.terminateRequested, stdout: stdout.toString(), stderr: stderr.toString() });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.handleExec(cc, pp, error, stdout as any, stderr as any);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlet childProcess: cp.ChildProcess | null = null;\n\t\t\t\tconst closeHandler = (data: any) => {\n\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\tthis.childProcessPromise = null;\n\t\t\t\t\tthis.handleClose(data, cc, pp, ee);\n\t\t\t\t\tconst result: SuccessData = {\n\t\t\t\t\t\tterminated: this.terminateRequested\n\t\t\t\t\t};\n\t\t\t\t\tif (Types.isNumber(data)) {\n\t\t\t\t\t\tresult.cmdCode = <number>data;\n\t\t\t\t\t}\n\t\t\t\t\tcc(result);\n\t\t\t\t};\n\t\t\t\tif (this.shell && Platform.isWindows) {\n\t\t\t\t\tconst options: any = Objects.deepClone(this.options);\n\t\t\t\t\toptions.windowsVerbatimArguments = true;\n\t\t\t\t\toptions.detached = false;\n\t\t\t\t\tlet quotedCommand: boolean = false;\n\t\t\t\t\tlet quotedArg: boolean = false;\n\t\t\t\t\tconst commandLine: string[] = [];\n\t\t\t\t\tlet quoted = this.ensureQuotes(this.cmd);\n\t\t\t\t\tcommandLine.push(quoted.value);\n\t\t\t\t\tquotedCommand = quoted.quoted;\n\t\t\t\t\tif (this.args) {\n\t\t\t\t\t\tthis.args.forEach((elem) => {\n\t\t\t\t\t\t\tquoted = this.ensureQuotes(elem);\n\t\t\t\t\t\t\tcommandLine.push(quoted.value);\n\t\t\t\t\t\t\tquotedArg = quotedArg && quoted.quoted;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tconst args: string[] = [\n\t\t\t\t\t\t'/s',\n\t\t\t\t\t\t'/c',\n\t\t\t\t\t];\n\t\t\t\t\tif (quotedCommand) {\n\t\t\t\t\t\tif (quotedArg) {\n\t\t\t\t\t\t\targs.push('\"' + commandLine.join(' ') + '\"');\n\t\t\t\t\t\t} else if (commandLine.length > 1) {\n\t\t\t\t\t\t\targs.push('\"' + commandLine[0] + '\"' + ' ' + commandLine.slice(1).join(' '));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\targs.push('\"' + commandLine[0] + '\"');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\targs.push(commandLine.join(' '));\n\t\t\t\t\t}\n\t\t\t\t\tchildProcess = cp.spawn(getWindowsShell(), args, options);\n\t\t\t\t} else {\n\t\t\t\t\tif (this.cmd) {\n\t\t\t\t\t\tchildProcess = cp.spawn(this.cmd, this.args, this.options);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (childProcess) {\n\t\t\t\t\tthis.childProcess = childProcess;\n\t\t\t\t\tthis.childProcessPromise = Promise.resolve(childProcess);\n\t\t\t\t\tif (this.pidResolve) {\n\t\t\t\t\t\tthis.pidResolve(Types.isNumber(childProcess.pid) ? childProcess.pid : -1);\n\t\t\t\t\t\tthis.pidResolve = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tchildProcess.on('error', (error: Error) => {\n\t\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\t\tee({ terminated: this.terminateRequested, error: error });\n\t\t\t\t\t});\n\t\t\t\t\tif (childProcess.pid) {\n\t\t\t\t\t\tthis.childProcess.on('close', closeHandler);\n\t\t\t\t\t\tthis.handleSpawn(childProcess, cc!, pp, ee!, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tprotected abstract handleExec(cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, error: Error | null, stdout: Buffer, stderr: Buffer): void;\n\tprotected abstract handleSpawn(childProcess: cp.ChildProcess, cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, ee: ErrorCallback, sync: boolean): void;\n\n\tprotected handleClose(data: any, cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, ee: ErrorCallback): void {\n\t\t// Default is to do nothing.\n\t}\n\n\tprivate static readonly regexp = /^[^\"].* .*[^\"]/;\n\tprivate ensureQuotes(value: string) {\n\t\tif (AbstractProcess.regexp.test(value)) {\n\t\t\treturn {\n\t\t\t\tvalue: '\"' + value + '\"', //`\"${value}\"`,\n\t\t\t\tquoted: true\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tvalue: value,\n\t\t\t\tquoted: value.length > 0 && value[0] === '\"' && value[value.length - 1] === '\"'\n\t\t\t};\n\t\t}\n\t}\n\n\tpublic get pid(): Promise<number> {\n\t\tif (this.childProcessPromise) {\n\t\t\treturn this.childProcessPromise.then(childProcess => childProcess.pid, err => -1);\n\t\t} else {\n\t\t\treturn new Promise<number>((resolve) => {\n\t\t\t\tthis.pidResolve = resolve;\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic terminate(): Promise<TerminateResponse> {\n\t\tif (!this.childProcessPromise) {\n\t\t\treturn Promise.resolve<TerminateResponse>({ success: true });\n\t\t}\n\t\treturn this.childProcessPromise.then((childProcess) => {\n\t\t\tthis.terminateRequested = true;\n\t\t\tconst result = terminateProcess(childProcess, this.options.cwd);\n\t\t\tif (result.success) {\n\t\t\t\tthis.childProcess = null;\n\t\t\t}\n\t\t\treturn result;\n\t\t}, (err) => {\n\t\t\treturn { success: true };\n\t\t});\n\t}\n\n\tprivate useExec(): Promise<boolean> {\n\t\treturn new Promise<boolean>((c, e) => {\n\t\t\tif (!this.shell || !Platform.isWindows) {\n\t\t\t\treturn c(false);\n\t\t\t}\n\t\t\tconst cmdShell = cp.spawn(getWindowsShell(), ['/s', '/c']);\n\t\t\tcmdShell.on('error', (error: Error) => {\n\t\t\t\treturn c(true);\n\t\t\t});\n\t\t\tcmdShell.on('exit', (data: any) => {\n\t\t\t\treturn c(false);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class LineProcess extends AbstractProcess<LineData> {\n\n\tprivate stdoutLineDecoder: LineDecoder;\n\tprivate stderrLineDecoder: LineDecoder;\n\n\tpublic constructor(executable: Executable);\n\tpublic constructor(cmd: string, args: string[], shell: boolean, options: CommandOptions);\n\tpublic constructor(arg1: string | Executable, arg2?: string[], arg3?: boolean | ForkOptions, arg4?: CommandOptions) {\n\t\tsuper(<any>arg1, arg2, <any>arg3, arg4);\n\t}\n\n\tprotected handleExec(cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, error: Error, stdout: Buffer, stderr: Buffer) {\n\t\t[stdout, stderr].forEach((buffer: Buffer, index: number) => {\n\t\t\tconst lineDecoder = new LineDecoder();\n\t\t\tconst lines = lineDecoder.write(buffer);\n\t\t\tlines.forEach((line) => {\n\t\t\t\tpp({ line: line, source: index === 0 ? Source.stdout : Source.stderr });\n\t\t\t});\n\t\t\tconst line = lineDecoder.end();\n\t\t\tif (line) {\n\t\t\t\tpp({ line: line, source: index === 0 ? Source.stdout : Source.stderr });\n\t\t\t}\n\t\t});\n\t\tcc({ terminated: this.terminateRequested, error: error });\n\t}\n\n\tprotected handleSpawn(childProcess: cp.ChildProcess, cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, ee: ErrorCallback, sync: boolean): void {\n\t\tthis.stdoutLineDecoder = new LineDecoder();\n\t\tthis.stderrLineDecoder = new LineDecoder();\n\t\tchildProcess.stdout.on('data', (data: Buffer) => {\n\t\t\tconst lines = this.stdoutLineDecoder.write(data);\n\t\t\tlines.forEach(line => pp({ line: line, source: Source.stdout }));\n\t\t});\n\t\tchildProcess.stderr.on('data', (data: Buffer) => {\n\t\t\tconst lines = this.stderrLineDecoder.write(data);\n\t\t\tlines.forEach(line => pp({ line: line, source: Source.stderr }));\n\t\t});\n\t}\n\n\tprotected handleClose(data: any, cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, ee: ErrorCallback): void {\n\t\t[this.stdoutLineDecoder.end(), this.stderrLineDecoder.end()].forEach((line, index) => {\n\t\t\tif (line) {\n\t\t\t\tpp({ line: line, source: index === 0 ? Source.stdout : Source.stderr });\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport interface IQueuedSender {\n\tsend: (msg: any) => void;\n}\n\n// Wrapper around process.send() that will queue any messages if the internal node.js\n// queue is filled with messages and only continue sending messages when the internal\n// queue is free again to consume messages.\n// On Windows we always wait for the send() method to return before sending the next message\n// to workaround https://github.com/nodejs/node/issues/7657 (IPC can freeze process)\nexport function createQueuedSender(childProcess: cp.ChildProcess): IQueuedSender {\n\tlet msgQueue: string[] = [];\n\tlet useQueue = false;\n\n\tconst send = function (msg: any): void {\n\t\tif (useQueue) {\n\t\t\tmsgQueue.push(msg); // add to the queue if the process cannot handle more messages\n\t\t\treturn;\n\t\t}\n\n\t\tconst result = childProcess.send(msg, (error: Error) => {\n\t\t\tif (error) {\n\t\t\t\tconsole.error(error); // unlikely to happen, best we can do is log this error\n\t\t\t}\n\n\t\t\tuseQueue = false; // we are good again to send directly without queue\n\n\t\t\t// now send all the messages that we have in our queue and did not send yet\n\t\t\tif (msgQueue.length > 0) {\n\t\t\t\tconst msgQueueCopy = msgQueue.slice(0);\n\t\t\t\tmsgQueue = [];\n\t\t\t\tmsgQueueCopy.forEach(entry => send(entry));\n\t\t\t}\n\t\t});\n\n\t\tif (!result || Platform.isWindows /* workaround https://github.com/nodejs/node/issues/7657 */) {\n\t\t\tuseQueue = true;\n\t\t}\n\t};\n\n\treturn { send };\n}\n\nexport namespace win32 {\n\texport function findExecutable(command: string, cwd?: string, paths?: string[]): string {\n\t\t// If we have an absolute path then we take it.\n\t\tif (path.isAbsolute(command)) {\n\t\t\treturn command;\n\t\t}\n\t\tif (cwd === undefined) {\n\t\t\tcwd = process.cwd();\n\t\t}\n\t\tconst dir = path.dirname(command);\n\t\tif (dir !== '.') {\n\t\t\t// We have a directory and the directory is relative (see above). Make the path absolute\n\t\t\t// to the current working directory.\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\t\tif (paths === undefined && Types.isString(process.env.PATH)) {\n\t\t\tpaths = process.env.PATH.split(path.delimiter);\n\t\t}\n\t\t// No PATH environment. Make path absolute to the cwd.\n\t\tif (paths === undefined || paths.length === 0) {\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\t\t// We have a simple file name. We get the path variable from the env\n\t\t// and try to find the executable on the path.\n\t\tfor (let pathEntry of paths) {\n\t\t\t// The path entry is absolute.\n\t\t\tlet fullPath: string;\n\t\t\tif (path.isAbsolute(pathEntry)) {\n\t\t\t\tfullPath = path.join(pathEntry, command);\n\t\t\t} else {\n\t\t\t\tfullPath = path.join(cwd, pathEntry, command);\n\t\t\t}\n\t\t\tif (fs.existsSync(fullPath)) {\n\t\t\t\treturn fullPath;\n\t\t\t}\n\t\t\tlet withExtension = fullPath + '.com';\n\t\t\tif (fs.existsSync(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t\twithExtension = fullPath + '.exe';\n\t\t\tif (fs.existsSync(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t}\n\t\treturn path.join(cwd, command);\n\t}\n}\n"]}]}