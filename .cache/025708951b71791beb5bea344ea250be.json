{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/instantiation/common/instantiationService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/instantiation/common/instantiationService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/errors\", \"vs/base/common/types\", \"vs/platform/instantiation/common/graph\", \"vs/platform/instantiation/common/descriptors\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/instantiation/common/serviceCollection\", \"vs/base/common/async\"], function (require, exports, errors_1, types_1, graph_1, descriptors_1, instantiation_1, serviceCollection_1, async_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // TRACING\n    const _enableTracing = false;\n    const _canUseProxy = typeof Proxy === 'function';\n    class InstantiationService {\n        constructor(services = new serviceCollection_1.ServiceCollection(), strict = false, parent) {\n            this._services = services;\n            this._strict = strict;\n            this._parent = parent;\n            this._services.set(instantiation_1.IInstantiationService, this);\n        }\n        createChild(services) {\n            return new InstantiationService(services, this._strict, this);\n        }\n        invokeFunction(fn, ...args) {\n            let _trace = Trace.traceInvocation(fn);\n            let _done = false;\n            try {\n                const accessor = {\n                    get: (id, isOptional) => {\n                        if (_done) {\n                            throw errors_1.illegalState('service accessor is only valid during the invocation of its target method');\n                        }\n                        const result = this._getOrCreateServiceInstance(id, _trace);\n                        if (!result && isOptional !== instantiation_1.optional) {\n                            throw new Error(`[invokeFunction] unknown service '${id}'`);\n                        }\n                        return result;\n                    }\n                };\n                return fn.apply(undefined, [accessor, ...args]);\n            }\n            finally {\n                _done = true;\n                _trace.stop();\n            }\n        }\n        createInstance(ctorOrDescriptor, ...rest) {\n            let _trace;\n            let result;\n            if (ctorOrDescriptor instanceof descriptors_1.SyncDescriptor) {\n                _trace = Trace.traceCreation(ctorOrDescriptor.ctor);\n                result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n            }\n            else {\n                _trace = Trace.traceCreation(ctorOrDescriptor);\n                result = this._createInstance(ctorOrDescriptor, rest, _trace);\n            }\n            _trace.stop();\n            return result;\n        }\n        _createInstance(ctor, args = [], _trace) {\n            // arguments defined by service decorators\n            let serviceDependencies = instantiation_1._util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n            let serviceArgs = [];\n            for (const dependency of serviceDependencies) {\n                let service = this._getOrCreateServiceInstance(dependency.id, _trace);\n                if (!service && this._strict && !dependency.optional) {\n                    throw new Error(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`);\n                }\n                serviceArgs.push(service);\n            }\n            let firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n            // check for argument mismatches, adjust static args if needed\n            if (args.length !== firstServiceArgPos) {\n                console.warn(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n                let delta = firstServiceArgPos - args.length;\n                if (delta > 0) {\n                    args = args.concat(new Array(delta));\n                }\n                else {\n                    args = args.slice(0, firstServiceArgPos);\n                }\n            }\n            // now create the instance\n            return types_1.create.apply(null, [ctor].concat(args, serviceArgs));\n        }\n        _setServiceInstance(id, instance) {\n            if (this._services.get(id) instanceof descriptors_1.SyncDescriptor) {\n                this._services.set(id, instance);\n            }\n            else if (this._parent) {\n                this._parent._setServiceInstance(id, instance);\n            }\n            else {\n                throw new Error('illegalState - setting UNKNOWN service instance');\n            }\n        }\n        _getServiceInstanceOrDescriptor(id) {\n            let instanceOrDesc = this._services.get(id);\n            if (!instanceOrDesc && this._parent) {\n                return this._parent._getServiceInstanceOrDescriptor(id);\n            }\n            else {\n                return instanceOrDesc;\n            }\n        }\n        _getOrCreateServiceInstance(id, _trace) {\n            let thing = this._getServiceInstanceOrDescriptor(id);\n            if (thing instanceof descriptors_1.SyncDescriptor) {\n                return this._createAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n            }\n            else {\n                _trace.branch(id, false);\n                return thing;\n            }\n        }\n        _createAndCacheServiceInstance(id, desc, _trace) {\n            const graph = new graph_1.Graph(data => data.id.toString());\n            function throwCycleError() {\n                const err = new Error('[createInstance] cyclic dependency between services');\n                err.message = graph.toString();\n                throw err;\n            }\n            let count = 0;\n            const stack = [{ id, desc, _trace }];\n            while (stack.length) {\n                const item = stack.pop();\n                graph.lookupOrInsertNode(item);\n                // TODO@joh use the graph to find a cycle\n                // a weak heuristic for cycle checks\n                if (count++ > 100) {\n                    throwCycleError();\n                }\n                // check all dependencies for existence and if they need to be created first\n                let dependencies = instantiation_1._util.getServiceDependencies(item.desc.ctor);\n                for (let dependency of dependencies) {\n                    let instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n                    if (!instanceOrDesc && !dependency.optional) {\n                        console.warn(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`);\n                    }\n                    if (instanceOrDesc instanceof descriptors_1.SyncDescriptor) {\n                        const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\n                        graph.insertEdge(item, d);\n                        stack.push(d);\n                    }\n                }\n            }\n            while (true) {\n                let roots = graph.roots();\n                // if there is no more roots but still\n                // nodes in the graph we have a cycle\n                if (roots.length === 0) {\n                    if (!graph.isEmpty()) {\n                        throwCycleError();\n                    }\n                    break;\n                }\n                for (let { data } of roots) {\n                    // create instance and overwrite the service collections\n                    const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n                    this._setServiceInstance(data.id, instance);\n                    graph.removeNode(data);\n                }\n            }\n            return this._getServiceInstanceOrDescriptor(id);\n        }\n        _createServiceInstanceWithOwner(id, ctor, args = [], supportsDelayedInstantiation, _trace) {\n            if (this._services.get(id) instanceof descriptors_1.SyncDescriptor) {\n                return this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);\n            }\n            else if (this._parent) {\n                return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n            }\n            else {\n                throw new Error('illegalState - creating UNKNOWN service instance');\n            }\n        }\n        _createServiceInstance(ctor, args = [], _supportsDelayedInstantiation, _trace) {\n            if (!_supportsDelayedInstantiation || !_canUseProxy) {\n                // eager instantiation or no support JS proxies (e.g. IE11)\n                return this._createInstance(ctor, args, _trace);\n            }\n            else {\n                // Return a proxy object that's backed by an idle value. That\n                // strategy is to instantiate services in our idle time or when actually\n                // needed but not when injected into a consumer\n                const idle = new async_1.IdleValue(() => this._createInstance(ctor, args, _trace));\n                return new Proxy(Object.create(null), {\n                    get(_target, prop) {\n                        return idle.getValue()[prop];\n                    },\n                    set(_target, p, value) {\n                        idle.getValue()[p] = value;\n                        return true;\n                    }\n                });\n            }\n        }\n    }\n    exports.InstantiationService = InstantiationService;\n    //#region -- tracing ---\n    var TraceType;\n    (function (TraceType) {\n        TraceType[TraceType[\"Creation\"] = 0] = \"Creation\";\n        TraceType[TraceType[\"Invocation\"] = 1] = \"Invocation\";\n        TraceType[TraceType[\"Branch\"] = 2] = \"Branch\";\n    })(TraceType || (TraceType = {}));\n    class Trace {\n        constructor(type, name) {\n            this.type = type;\n            this.name = name;\n            this._start = Date.now();\n            this._dep = [];\n        }\n        static traceInvocation(ctor) {\n            return !_enableTracing ? Trace._None : new Trace(TraceType.Invocation, ctor.name || ctor.toString().substring(0, 42).replace(/\\n/g, ''));\n        }\n        static traceCreation(ctor) {\n            return !_enableTracing ? Trace._None : new Trace(TraceType.Creation, ctor.name);\n        }\n        branch(id, first) {\n            let child = new Trace(TraceType.Branch, id.toString());\n            this._dep.push([id, first, child]);\n            return child;\n        }\n        stop() {\n            let dur = Date.now() - this._start;\n            Trace._totals += dur;\n            let causedCreation = false;\n            function printChild(n, trace) {\n                let res = [];\n                let prefix = new Array(n + 1).join('\\t');\n                for (const [id, first, child] of trace._dep) {\n                    if (first && child) {\n                        causedCreation = true;\n                        res.push(`${prefix}CREATES -> ${id}`);\n                        let nested = printChild(n + 1, child);\n                        if (nested) {\n                            res.push(nested);\n                        }\n                    }\n                    else {\n                        res.push(`${prefix}uses -> ${id}`);\n                    }\n                }\n                return res.join('\\n');\n            }\n            let lines = [\n                `${this.type === TraceType.Creation ? 'CREATE' : 'CALL'} ${this.name}`,\n                `${printChild(1, this)}`,\n                `DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\n            ];\n            if (dur > 2 || causedCreation) {\n                console.log(lines.join('\\n'));\n            }\n        }\n    }\n    Trace._None = new class extends Trace {\n        constructor() { super(-1, null); }\n        stop() { }\n        branch() { return this; }\n    };\n    Trace._totals = 0;\n});\n//#endregion\n",null]}