{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/packages/vscode/src/fill/zip.ts","dependencies":[{"path":"/home/coding/workspace/packages/vscode/src/fill/zip.ts","mtime":1555841535694},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _this = this;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar nls = require(\"vs/nls\");\nvar vszip = require(\"vszip\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar tarStream = require(\"tar-stream\");\nvar util_1 = require(\"util\");\nvar pfs_1 = require(\"vs/base/node/pfs\");\n/**\n * Override the standard VS Code behavior for zipping\n * extensions to use the TAR format instead of ZIP.\n */\nexports.zip = function (tarPath, files) {\n    return new Promise(function (c, e) {\n        var pack = tarStream.pack();\n        var chunks = [];\n        var ended = new Promise(function (res) {\n            pack.on(\"end\", function () {\n                res(Buffer.concat(chunks));\n            });\n        });\n        pack.on(\"data\", function (chunk) {\n            chunks.push(chunk);\n        });\n        for (var i = 0; i < files.length; i++) {\n            var file = files[i];\n            pack.entry({\n                name: file.path,\n            }, file.contents);\n        }\n        pack.finalize();\n        ended.then(function (buffer) {\n            return util_1.promisify(fs.writeFile)(tarPath, buffer);\n        }).then(function () {\n            c(tarPath);\n        }).catch(function (ex) {\n            e(ex);\n        });\n    });\n};\n/**\n * Override the standard VS Code behavior for extracting\n * archives, to first attempt to process the archive as a TAR\n * and then fallback on the original implementation, for processing\n * ZIPs.\n */\nexports.extract = function (archivePath, extractPath, options, token) {\n    if (options === void 0) { options = {}; }\n    return new Promise(function (c, e) {\n        extractTar(archivePath, extractPath, options, token).then(c).catch(function (ex) {\n            if (!ex.toString().includes(\"Invalid tar header\")) {\n                e(ex);\n                return;\n            }\n            vszip.extract(archivePath, extractPath, options, token).then(c).catch(e);\n        });\n    });\n};\n/**\n * Override the standard VS Code behavior for buffering\n * archives, to first process the Buffer as a TAR and then\n * fallback on the original implementation, for processing ZIPs.\n */\nexports.buffer = function (targetPath, filePath) {\n    return new Promise(function (c, e) {\n        var done = false;\n        exports.extractAssets(targetPath, new RegExp(filePath), function (assetPath, data) {\n            if (path.normalize(assetPath) === path.normalize(filePath)) {\n                done = true;\n                c(data);\n            }\n        }).then(function () {\n            if (!done) {\n                e(\"couldn't find asset \" + filePath);\n            }\n        }).catch(function (ex) {\n            if (!ex.toString().includes(\"Invalid tar header\")) {\n                e(ex);\n                return;\n            }\n            vszip.buffer(targetPath, filePath).then(c).catch(e);\n        });\n    });\n};\n/**\n * Override the standard VS Code behavior for extracting assets\n * from archive Buffers to use the TAR format instead of ZIP.\n */\nexports.extractAssets = function (tarPath, match, callback) {\n    return new Promise(function (c, e) { return tslib_1.__awaiter(_this, void 0, Promise, function () {\n        var buffer_1, extractor, ex_1;\n        return tslib_1.__generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, util_1.promisify(fs.readFile)(tarPath)];\n                case 1:\n                    buffer_1 = _a.sent();\n                    extractor = tarStream.extract();\n                    extractor.once(\"error\", e);\n                    extractor.on(\"entry\", function (header, stream, next) {\n                        var name = header.name;\n                        if (match.test(name)) {\n                            extractData(stream).then(function (data) {\n                                callback(name, data);\n                                next();\n                            }).catch(e);\n                            stream.resume();\n                        }\n                        else {\n                            stream.on(\"end\", function () {\n                                next();\n                            });\n                            stream.resume();\n                        }\n                    });\n                    extractor.on(\"finish\", function () {\n                        c();\n                    });\n                    extractor.write(buffer_1);\n                    extractor.end();\n                    return [3 /*break*/, 3];\n                case 2:\n                    ex_1 = _a.sent();\n                    e(ex_1);\n                    return [3 /*break*/, 3];\n                case 3: return [2 /*return*/];\n            }\n        });\n    }); });\n};\nvar extractData = function (stream) {\n    return new Promise(function (c, e) {\n        var fileData = [];\n        stream.on(\"data\", function (data) { return fileData.push(data); });\n        stream.on(\"end\", function () {\n            var fd = Buffer.concat(fileData);\n            c(fd);\n        });\n        stream.on(\"error\", e);\n    });\n};\nvar extractTar = function (tarPath, targetPath, options, token) {\n    if (options === void 0) { options = {}; }\n    return new Promise(function (c, e) { return tslib_1.__awaiter(_this, void 0, Promise, function () {\n        var sourcePathRegex_1, buffer_2, extractor, ex_2;\n        return tslib_1.__generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    sourcePathRegex_1 = new RegExp(options.sourcePath ? \"^\" + options.sourcePath : \"\");\n                    return [4 /*yield*/, util_1.promisify(fs.readFile)(tarPath)];\n                case 1:\n                    buffer_2 = _a.sent();\n                    extractor = tarStream.extract();\n                    extractor.once(\"error\", e);\n                    extractor.on(\"entry\", function (header, stream, next) {\n                        var rawName = path.normalize(header.name);\n                        var nextEntry = function () {\n                            stream.resume();\n                            next();\n                        };\n                        if (token.isCancellationRequested) {\n                            return nextEntry();\n                        }\n                        if (!sourcePathRegex_1.test(rawName)) {\n                            return nextEntry();\n                        }\n                        var fileName = rawName.replace(sourcePathRegex_1, \"\");\n                        var targetFileName = path.join(targetPath, fileName);\n                        if (/\\/$/.test(fileName)) {\n                            stream.resume();\n                            pfs_1.mkdirp(targetFileName).then(function () {\n                                next();\n                            }, e);\n                            return;\n                        }\n                        var dirName = path.dirname(fileName);\n                        var targetDirName = path.join(targetPath, dirName);\n                        if (targetDirName.indexOf(targetPath) !== 0) {\n                            e(nls.localize(\"invalid file\", \"Error extracting {0}. Invalid file.\", fileName));\n                            return nextEntry();\n                        }\n                        return pfs_1.mkdirp(targetDirName, undefined, token).then(function () {\n                            var fstream = fs.createWriteStream(targetFileName, { mode: header.mode });\n                            fstream.once(\"close\", function () {\n                                next();\n                            });\n                            fstream.once(\"error\", e);\n                            stream.pipe(fstream);\n                            stream.resume();\n                        });\n                    });\n                    extractor.once(\"finish\", c);\n                    extractor.write(buffer_2);\n                    extractor.end();\n                    return [3 /*break*/, 3];\n                case 2:\n                    ex_2 = _a.sent();\n                    e(ex_2);\n                    return [3 /*break*/, 3];\n                case 3: return [2 /*return*/];\n            }\n        });\n    }); });\n};\n",{"version":3,"file":"/home/coding/workspace/packages/vscode/src/fill/zip.ts","sourceRoot":"","sources":["/home/coding/workspace/packages/vscode/src/fill/zip.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from \"vs/nls\";\nimport * as vszip from \"vszip\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as tarStream from \"tar-stream\";\nimport { promisify } from \"util\";\nimport { CancellationToken } from \"vs/base/common/cancellation\";\nimport { mkdirp } from \"vs/base/node/pfs\";\n\nexport interface IExtractOptions {\n\toverwrite?: boolean;\n\n\t/**\n\t * Source path within the TAR/ZIP archive. Only the files\n\t * contained in this path will be extracted.\n\t */\n\tsourcePath?: string;\n}\n\nexport interface IFile {\n\tpath: string;\n\tcontents?: Buffer | string;\n\tlocalPath?: string;\n}\n\n/**\n * Override the standard VS Code behavior for zipping\n * extensions to use the TAR format instead of ZIP.\n */\nexport const zip = (tarPath: string, files: IFile[]): Promise<string> => {\n\treturn new Promise<string>((c, e): void => {\n\t\tconst pack = tarStream.pack();\n\t\tconst chunks: Buffer[] = [];\n\t\tconst ended = new Promise<Buffer>((res): void => {\n\t\t\tpack.on(\"end\", () => {\n\t\t\t\tres(Buffer.concat(chunks));\n\t\t\t});\n\t\t});\n\t\tpack.on(\"data\", (chunk) => {\n\t\t\tchunks.push(chunk as Buffer);\n\t\t});\n\t\tfor (let i = 0; i < files.length; i++) {\n\t\t\tconst file = files[i];\n\t\t\tpack.entry({\n\t\t\t\tname: file.path,\n\t\t\t}, file.contents);\n\t\t}\n\t\tpack.finalize();\n\n\t\tended.then((buffer) => {\n\t\t\treturn promisify(fs.writeFile)(tarPath, buffer);\n\t\t}).then(() => {\n\t\t\tc(tarPath);\n\t\t}).catch((ex) => {\n\t\t\te(ex);\n\t\t});\n\t});\n};\n\n/**\n * Override the standard VS Code behavior for extracting\n * archives, to first attempt to process the archive as a TAR\n * and then fallback on the original implementation, for processing\n * ZIPs.\n */\nexport const extract = (archivePath: string, extractPath: string, options: IExtractOptions = {}, token: CancellationToken): Promise<void> => {\n\treturn new Promise<void>((c, e): void => {\n\t\textractTar(archivePath, extractPath, options, token).then(c).catch((ex) => {\n\t\t\tif (!ex.toString().includes(\"Invalid tar header\")) {\n\t\t\t\te(ex);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvszip.extract(archivePath, extractPath, options, token).then(c).catch(e);\n\t\t});\n\t});\n};\n\n/**\n * Override the standard VS Code behavior for buffering\n * archives, to first process the Buffer as a TAR and then\n * fallback on the original implementation, for processing ZIPs.\n */\nexport const buffer = (targetPath: string, filePath: string): Promise<Buffer> => {\n\treturn new Promise<Buffer>((c, e): void => {\n\t\tlet done: boolean = false;\n\t\textractAssets(targetPath, new RegExp(filePath), (assetPath: string, data: Buffer) => {\n\t\t\tif (path.normalize(assetPath) === path.normalize(filePath)) {\n\t\t\t\tdone = true;\n\t\t\t\tc(data);\n\t\t\t}\n\t\t}).then(() => {\n\t\t\tif (!done) {\n\t\t\t\te(\"couldn't find asset \" + filePath);\n\t\t\t}\n\t\t}).catch((ex) => {\n\t\t\tif (!ex.toString().includes(\"Invalid tar header\")) {\n\t\t\t\te(ex);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvszip.buffer(targetPath, filePath).then(c).catch(e);\n\t\t});\n\t});\n};\n\n/**\n * Override the standard VS Code behavior for extracting assets\n * from archive Buffers to use the TAR format instead of ZIP.\n */\nexport const extractAssets = (tarPath: string, match: RegExp, callback: (path: string, data: Buffer) => void): Promise<void> => {\n\treturn new Promise<void>(async (c, e): Promise<void> => {\n\t\ttry {\n\t\t\tconst buffer = await promisify(fs.readFile)(tarPath);\n\t\t\tconst extractor = tarStream.extract();\n\t\t\textractor.once(\"error\", e);\n\t\t\textractor.on(\"entry\", (header, stream, next) => {\n\t\t\t\tconst name = header.name;\n\t\t\t\tif (match.test(name)) {\n\t\t\t\t\textractData(stream).then((data) => {\n\t\t\t\t\t\tcallback(name, data);\n\t\t\t\t\t\tnext();\n\t\t\t\t\t}).catch(e);\n\t\t\t\t\tstream.resume();\n\t\t\t\t} else {\n\t\t\t\t\tstream.on(\"end\", () => {\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t\tstream.resume();\n\t\t\t\t}\n\t\t\t});\n\t\t\textractor.on(\"finish\", () => {\n\t\t\t\tc();\n\t\t\t});\n\t\t\textractor.write(buffer);\n\t\t\textractor.end();\n\t\t} catch (ex) {\n\t\t\te(ex);\n\t\t}\n\t});\n};\n\nconst extractData = (stream: NodeJS.ReadableStream): Promise<Buffer> => {\n\treturn new Promise<Buffer>((c, e): void => {\n\t\tconst fileData: Buffer[] = [];\n\t\tstream.on(\"data\", (data) => fileData.push(data));\n\t\tstream.on(\"end\", () => {\n\t\t\tconst fd = Buffer.concat(fileData);\n\t\t\tc(fd);\n\t\t});\n\t\tstream.on(\"error\", e);\n\t});\n};\n\nconst extractTar = (tarPath: string, targetPath: string, options: IExtractOptions = {}, token: CancellationToken): Promise<void> => {\n\treturn new Promise<void>(async (c, e): Promise<void> => {\n\t\ttry {\n\t\t\tconst sourcePathRegex = new RegExp(options.sourcePath ? `^${options.sourcePath}` : \"\");\n\t\t\tconst buffer = await promisify(fs.readFile)(tarPath);\n\t\t\tconst extractor = tarStream.extract();\n\t\t\textractor.once(\"error\", e);\n\t\t\textractor.on(\"entry\", (header, stream, next) => {\n\t\t\t\tconst rawName = path.normalize(header.name);\n\n\t\t\t\tconst nextEntry = (): void => {\n\t\t\t\t\tstream.resume();\n\t\t\t\t\tnext();\n\t\t\t\t};\n\n\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\treturn nextEntry();\n\t\t\t\t}\n\n\t\t\t\tif (!sourcePathRegex.test(rawName)) {\n\t\t\t\t\treturn nextEntry();\n\t\t\t\t}\n\n\t\t\t\tconst fileName = rawName.replace(sourcePathRegex, \"\");\n\t\t\t\tconst targetFileName = path.join(targetPath, fileName);\n\t\t\t\tif (/\\/$/.test(fileName)) {\n\t\t\t\t\tstream.resume();\n\t\t\t\t\tmkdirp(targetFileName).then(() => {\n\t\t\t\t\t\tnext();\n\t\t\t\t\t}, e);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst dirName = path.dirname(fileName);\n\t\t\t\tconst targetDirName = path.join(targetPath, dirName);\n\t\t\t\tif (targetDirName.indexOf(targetPath) !== 0) {\n\t\t\t\t\te(nls.localize(\"invalid file\", \"Error extracting {0}. Invalid file.\", fileName));\n\n\t\t\t\t\treturn nextEntry();\n\t\t\t\t}\n\n\t\t\t\treturn mkdirp(targetDirName, undefined, token).then(() => {\n\t\t\t\t\tconst fstream = fs.createWriteStream(targetFileName, { mode: header.mode });\n\t\t\t\t\tfstream.once(\"close\", () => {\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t\tfstream.once(\"error\", e);\n\t\t\t\t\tstream.pipe(fstream);\n\t\t\t\t\tstream.resume();\n\t\t\t\t});\n\t\t\t});\n\t\t\textractor.once(\"finish\", c);\n\t\t\textractor.write(buffer);\n\t\t\textractor.end();\n\t\t} catch (ex) {\n\t\t\te(ex);\n\t\t}\n\t});\n};\n"]}]}