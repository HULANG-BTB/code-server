{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/suggest/suggestWidget.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/suggest/suggestWidget.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/filters\", \"vs/base/common/strings\", \"vs/base/common/event\", \"vs/base/common/errors\", \"vs/base/common/lifecycle\", \"vs/base/browser/dom\", \"vs/base/browser/ui/list/listWidget\", \"vs/base/browser/ui/scrollbar/scrollableElement\", \"vs/platform/keybinding/common/keybinding\", \"vs/platform/contextkey/common/contextkey\", \"vs/editor/browser/editorBrowser\", \"./suggest\", \"vs/base/browser/ui/aria/aria\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/theme/common/styler\", \"vs/platform/theme/common/themeService\", \"vs/platform/theme/common/colorRegistry\", \"vs/platform/storage/common/storage\", \"vs/editor/contrib/markdown/markdownRenderer\", \"vs/editor/common/services/modeService\", \"vs/platform/opener/common/opener\", \"vs/base/common/async\", \"vs/base/common/cancellation\", \"vs/editor/common/modes\", \"vs/base/browser/ui/iconLabel/iconLabel\", \"vs/editor/common/services/getIconClasses\", \"vs/editor/common/services/modelService\", \"vs/base/common/uri\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/files/common/files\", \"vs/css!./media/suggest\"], function (require, exports, nls, filters_1, strings, event_1, errors_1, lifecycle_1, dom_1, listWidget_1, scrollableElement_1, keybinding_1, contextkey_1, editorBrowser_1, suggest_1, aria_1, telemetry_1, styler_1, themeService_1, colorRegistry_1, storage_1, markdownRenderer_1, modeService_1, opener_1, async_1, cancellation_1, modes_1, iconLabel_1, getIconClasses_1, modelService_1, uri_1, instantiation_1, files_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const expandSuggestionDocsByDefault = false;\n    /**\n     * Suggest widget colors\n     */\n    exports.editorSuggestWidgetBackground = colorRegistry_1.registerColor('editorSuggestWidget.background', { dark: colorRegistry_1.editorWidgetBackground, light: colorRegistry_1.editorWidgetBackground, hc: colorRegistry_1.editorWidgetBackground }, nls.localize('editorSuggestWidgetBackground', 'Background color of the suggest widget.'));\n    exports.editorSuggestWidgetBorder = colorRegistry_1.registerColor('editorSuggestWidget.border', { dark: colorRegistry_1.editorWidgetBorder, light: colorRegistry_1.editorWidgetBorder, hc: colorRegistry_1.editorWidgetBorder }, nls.localize('editorSuggestWidgetBorder', 'Border color of the suggest widget.'));\n    exports.editorSuggestWidgetForeground = colorRegistry_1.registerColor('editorSuggestWidget.foreground', { dark: colorRegistry_1.editorForeground, light: colorRegistry_1.editorForeground, hc: colorRegistry_1.editorForeground }, nls.localize('editorSuggestWidgetForeground', 'Foreground color of the suggest widget.'));\n    exports.editorSuggestWidgetSelectedBackground = colorRegistry_1.registerColor('editorSuggestWidget.selectedBackground', { dark: colorRegistry_1.listFocusBackground, light: colorRegistry_1.listFocusBackground, hc: colorRegistry_1.listFocusBackground }, nls.localize('editorSuggestWidgetSelectedBackground', 'Background color of the selected entry in the suggest widget.'));\n    exports.editorSuggestWidgetHighlightForeground = colorRegistry_1.registerColor('editorSuggestWidget.highlightForeground', { dark: colorRegistry_1.listHighlightForeground, light: colorRegistry_1.listHighlightForeground, hc: colorRegistry_1.listHighlightForeground }, nls.localize('editorSuggestWidgetHighlightForeground', 'Color of the match highlights in the suggest widget.'));\n    const colorRegExp = /^(#([\\da-f]{3}){1,2}|(rgb|hsl)a\\(\\s*(\\d{1,3}%?\\s*,\\s*){3}(1|0?\\.\\d+)\\)|(rgb|hsl)\\(\\s*\\d{1,3}%?(\\s*,\\s*\\d{1,3}%?){2}\\s*\\))$/i;\n    function extractColor(item, out) {\n        if (item.completion.label.match(colorRegExp)) {\n            out[0] = item.completion.label;\n            return true;\n        }\n        if (typeof item.completion.documentation === 'string' && item.completion.documentation.match(colorRegExp)) {\n            out[0] = item.completion.documentation;\n            return true;\n        }\n        return false;\n    }\n    function canExpandCompletionItem(item) {\n        if (!item) {\n            return false;\n        }\n        const suggestion = item.completion;\n        if (suggestion.documentation) {\n            return true;\n        }\n        return (suggestion.detail && suggestion.detail !== suggestion.label);\n    }\n    let Renderer = class Renderer {\n        constructor(widget, editor, triggerKeybindingLabel, _modelService, _modeService, _themeService) {\n            this.widget = widget;\n            this.editor = editor;\n            this.triggerKeybindingLabel = triggerKeybindingLabel;\n            this._modelService = _modelService;\n            this._modeService = _modeService;\n            this._themeService = _themeService;\n        }\n        get templateId() {\n            return 'suggestion';\n        }\n        renderTemplate(container) {\n            const data = Object.create(null);\n            data.disposables = [];\n            data.root = container;\n            dom_1.addClass(data.root, 'show-file-icons');\n            data.icon = dom_1.append(container, dom_1.$('.icon'));\n            data.colorspan = dom_1.append(data.icon, dom_1.$('span.colorspan'));\n            const text = dom_1.append(container, dom_1.$('.contents'));\n            const main = dom_1.append(text, dom_1.$('.main'));\n            data.iconLabel = new iconLabel_1.IconLabel(main, { supportHighlights: true });\n            data.disposables.push(data.iconLabel);\n            data.typeLabel = dom_1.append(main, dom_1.$('span.type-label'));\n            data.readMore = dom_1.append(main, dom_1.$('span.readMore'));\n            data.readMore.title = nls.localize('readMore', \"Read More...{0}\", this.triggerKeybindingLabel);\n            const configureFont = () => {\n                const configuration = this.editor.getConfiguration();\n                const fontFamily = configuration.fontInfo.fontFamily;\n                const fontSize = configuration.contribInfo.suggestFontSize || configuration.fontInfo.fontSize;\n                const lineHeight = configuration.contribInfo.suggestLineHeight || configuration.fontInfo.lineHeight;\n                const fontWeight = configuration.fontInfo.fontWeight;\n                const fontSizePx = `${fontSize}px`;\n                const lineHeightPx = `${lineHeight}px`;\n                data.root.style.fontSize = fontSizePx;\n                data.root.style.fontWeight = fontWeight;\n                main.style.fontFamily = fontFamily;\n                main.style.lineHeight = lineHeightPx;\n                data.icon.style.height = lineHeightPx;\n                data.icon.style.width = lineHeightPx;\n                data.readMore.style.height = lineHeightPx;\n                data.readMore.style.width = lineHeightPx;\n            };\n            configureFont();\n            event_1.Event.chain(this.editor.onDidChangeConfiguration.bind(this.editor))\n                .filter(e => e.fontInfo || e.contribInfo)\n                .on(configureFont, null, data.disposables);\n            return data;\n        }\n        renderElement(element, _index, templateData) {\n            const data = templateData;\n            const suggestion = element.completion;\n            data.icon.className = 'icon ' + modes_1.completionKindToCssClass(suggestion.kind);\n            data.colorspan.style.backgroundColor = '';\n            const labelOptions = {\n                labelEscapeNewLines: true,\n                matches: filters_1.createMatches(element.score)\n            };\n            let color = [];\n            if (suggestion.kind === modes_1.CompletionItemKind.Color && extractColor(element, color)) {\n                // special logic for 'color' completion items\n                data.icon.className = 'icon customcolor';\n                data.colorspan.style.backgroundColor = color[0];\n            }\n            else if (suggestion.kind === modes_1.CompletionItemKind.File && this._themeService.getIconTheme().hasFileIcons) {\n                // special logic for 'file' completion items\n                data.icon.className = 'icon hide';\n                labelOptions.extraClasses = [].concat(getIconClasses_1.getIconClasses(this._modelService, this._modeService, uri_1.URI.from({ scheme: 'fake', path: suggestion.label }), files_1.FileKind.FILE), getIconClasses_1.getIconClasses(this._modelService, this._modeService, uri_1.URI.from({ scheme: 'fake', path: suggestion.detail }), files_1.FileKind.FILE));\n            }\n            else if (suggestion.kind === modes_1.CompletionItemKind.Folder && this._themeService.getIconTheme().hasFolderIcons) {\n                // special logic for 'folder' completion items\n                data.icon.className = 'icon hide';\n                labelOptions.extraClasses = [].concat(getIconClasses_1.getIconClasses(this._modelService, this._modeService, uri_1.URI.from({ scheme: 'fake', path: suggestion.label }), files_1.FileKind.FOLDER), getIconClasses_1.getIconClasses(this._modelService, this._modeService, uri_1.URI.from({ scheme: 'fake', path: suggestion.detail }), files_1.FileKind.FOLDER));\n            }\n            else {\n                // normal icon\n                data.icon.className = 'icon hide';\n                labelOptions.extraClasses = [\n                    `suggest-icon ${modes_1.completionKindToCssClass(suggestion.kind)}`\n                ];\n            }\n            data.iconLabel.setLabel(suggestion.label, undefined, labelOptions);\n            data.typeLabel.textContent = (suggestion.detail || '').replace(/\\n.*$/m, '');\n            if (canExpandCompletionItem(element)) {\n                dom_1.show(data.readMore);\n                data.readMore.onmousedown = e => {\n                    e.stopPropagation();\n                    e.preventDefault();\n                };\n                data.readMore.onclick = e => {\n                    e.stopPropagation();\n                    e.preventDefault();\n                    this.widget.toggleDetails();\n                };\n            }\n            else {\n                dom_1.hide(data.readMore);\n                data.readMore.onmousedown = null;\n                data.readMore.onclick = null;\n            }\n        }\n        disposeTemplate(templateData) {\n            templateData.disposables = lifecycle_1.dispose(templateData.disposables);\n        }\n    };\n    Renderer = __decorate([\n        __param(3, modelService_1.IModelService),\n        __param(4, modeService_1.IModeService),\n        __param(5, themeService_1.IThemeService)\n    ], Renderer);\n    var State;\n    (function (State) {\n        State[State[\"Hidden\"] = 0] = \"Hidden\";\n        State[State[\"Loading\"] = 1] = \"Loading\";\n        State[State[\"Empty\"] = 2] = \"Empty\";\n        State[State[\"Open\"] = 3] = \"Open\";\n        State[State[\"Frozen\"] = 4] = \"Frozen\";\n        State[State[\"Details\"] = 5] = \"Details\";\n    })(State || (State = {}));\n    class SuggestionDetails {\n        constructor(container, widget, editor, markdownRenderer, triggerKeybindingLabel) {\n            this.widget = widget;\n            this.editor = editor;\n            this.markdownRenderer = markdownRenderer;\n            this.triggerKeybindingLabel = triggerKeybindingLabel;\n            this.borderWidth = 1;\n            this.disposables = [];\n            this.el = dom_1.append(container, dom_1.$('.details'));\n            this.disposables.push(lifecycle_1.toDisposable(() => container.removeChild(this.el)));\n            this.body = dom_1.$('.body');\n            this.scrollbar = new scrollableElement_1.DomScrollableElement(this.body, {});\n            dom_1.append(this.el, this.scrollbar.getDomNode());\n            this.disposables.push(this.scrollbar);\n            this.header = dom_1.append(this.body, dom_1.$('.header'));\n            this.close = dom_1.append(this.header, dom_1.$('span.close'));\n            this.close.title = nls.localize('readLess', \"Read less...{0}\", this.triggerKeybindingLabel);\n            this.type = dom_1.append(this.header, dom_1.$('p.type'));\n            this.docs = dom_1.append(this.body, dom_1.$('p.docs'));\n            this.ariaLabel = null;\n            this.configureFont();\n            event_1.Event.chain(this.editor.onDidChangeConfiguration.bind(this.editor))\n                .filter(e => e.fontInfo)\n                .on(this.configureFont, this, this.disposables);\n            markdownRenderer.onDidRenderCodeBlock(() => this.scrollbar.scanDomNode(), this, this.disposables);\n        }\n        get element() {\n            return this.el;\n        }\n        render(item) {\n            this.renderDisposeable = lifecycle_1.dispose(this.renderDisposeable);\n            if (!item || !canExpandCompletionItem(item)) {\n                this.type.textContent = '';\n                this.docs.textContent = '';\n                dom_1.addClass(this.el, 'no-docs');\n                this.ariaLabel = null;\n                return;\n            }\n            dom_1.removeClass(this.el, 'no-docs');\n            if (typeof item.completion.documentation === 'string') {\n                dom_1.removeClass(this.docs, 'markdown-docs');\n                this.docs.textContent = item.completion.documentation;\n            }\n            else {\n                dom_1.addClass(this.docs, 'markdown-docs');\n                this.docs.innerHTML = '';\n                const renderedContents = this.markdownRenderer.render(item.completion.documentation);\n                this.renderDisposeable = renderedContents;\n                this.docs.appendChild(renderedContents.element);\n            }\n            if (item.completion.detail) {\n                this.type.innerText = item.completion.detail;\n                dom_1.show(this.type);\n            }\n            else {\n                this.type.innerText = '';\n                dom_1.hide(this.type);\n            }\n            this.el.style.height = this.header.offsetHeight + this.docs.offsetHeight + (this.borderWidth * 2) + 'px';\n            this.close.onmousedown = e => {\n                e.preventDefault();\n                e.stopPropagation();\n            };\n            this.close.onclick = e => {\n                e.preventDefault();\n                e.stopPropagation();\n                this.widget.toggleDetails();\n            };\n            this.body.scrollTop = 0;\n            this.scrollbar.scanDomNode();\n            this.ariaLabel = strings.format('{0}{1}', item.completion.detail || '', item.completion.documentation ? (typeof item.completion.documentation === 'string' ? item.completion.documentation : item.completion.documentation.value) : '');\n        }\n        getAriaLabel() {\n            return this.ariaLabel;\n        }\n        scrollDown(much = 8) {\n            this.body.scrollTop += much;\n        }\n        scrollUp(much = 8) {\n            this.body.scrollTop -= much;\n        }\n        scrollTop() {\n            this.body.scrollTop = 0;\n        }\n        scrollBottom() {\n            this.body.scrollTop = this.body.scrollHeight;\n        }\n        pageDown() {\n            this.scrollDown(80);\n        }\n        pageUp() {\n            this.scrollUp(80);\n        }\n        setBorderWidth(width) {\n            this.borderWidth = width;\n        }\n        configureFont() {\n            const configuration = this.editor.getConfiguration();\n            const fontFamily = configuration.fontInfo.fontFamily;\n            const fontSize = configuration.contribInfo.suggestFontSize || configuration.fontInfo.fontSize;\n            const lineHeight = configuration.contribInfo.suggestLineHeight || configuration.fontInfo.lineHeight;\n            const fontWeight = configuration.fontInfo.fontWeight;\n            const fontSizePx = `${fontSize}px`;\n            const lineHeightPx = `${lineHeight}px`;\n            this.el.style.fontSize = fontSizePx;\n            this.el.style.fontWeight = fontWeight;\n            this.type.style.fontFamily = fontFamily;\n            this.close.style.height = lineHeightPx;\n            this.close.style.width = lineHeightPx;\n        }\n        dispose() {\n            this.disposables = lifecycle_1.dispose(this.disposables);\n            this.renderDisposeable = lifecycle_1.dispose(this.renderDisposeable);\n        }\n    }\n    let SuggestWidget = class SuggestWidget {\n        constructor(editor, telemetryService, contextKeyService, themeService, storageService, keybindingService, modeService, openerService, instantiationService) {\n            this.editor = editor;\n            this.telemetryService = telemetryService;\n            // Editor.IContentWidget.allowEditorOverflow\n            this.allowEditorOverflow = true;\n            this.ignoreFocusEvents = false;\n            this.editorBlurTimeout = new async_1.TimeoutTimer();\n            this.showTimeout = new async_1.TimeoutTimer();\n            this.onDidSelectEmitter = new event_1.Emitter();\n            this.onDidFocusEmitter = new event_1.Emitter();\n            this.onDidHideEmitter = new event_1.Emitter();\n            this.onDidShowEmitter = new event_1.Emitter();\n            this.onDidSelect = this.onDidSelectEmitter.event;\n            this.onDidFocus = this.onDidFocusEmitter.event;\n            this.onDidHide = this.onDidHideEmitter.event;\n            this.onDidShow = this.onDidShowEmitter.event;\n            this.maxWidgetWidth = 660;\n            this.listWidth = 330;\n            this.firstFocusInCurrentList = false;\n            this.preferDocPositionTop = false;\n            const kb = keybindingService.lookupKeybinding('editor.action.triggerSuggest');\n            const triggerKeybindingLabel = !kb ? '' : ` (${kb.getLabel()})`;\n            const markdownRenderer = new markdownRenderer_1.MarkdownRenderer(editor, modeService, openerService);\n            this.isAuto = false;\n            this.focusedItem = null;\n            this.storageService = storageService;\n            this.element = dom_1.$('.editor-widget.suggest-widget');\n            this.messageElement = dom_1.append(this.element, dom_1.$('.message'));\n            this.listElement = dom_1.append(this.element, dom_1.$('.tree'));\n            this.details = new SuggestionDetails(this.element, this, this.editor, markdownRenderer, triggerKeybindingLabel);\n            const applyIconStyle = () => dom_1.toggleClass(this.element, 'no-icons', !this.editor.getConfiguration().contribInfo.suggest.showIcons);\n            applyIconStyle();\n            let renderer = instantiationService.createInstance(Renderer, this, this.editor, triggerKeybindingLabel);\n            this.list = new listWidget_1.List(this.listElement, this, [renderer], {\n                useShadows: false,\n                openController: { shouldOpen: () => false },\n                mouseSupport: false\n            });\n            this.toDispose = [\n                styler_1.attachListStyler(this.list, themeService, {\n                    listInactiveFocusBackground: exports.editorSuggestWidgetSelectedBackground,\n                    listInactiveFocusOutline: colorRegistry_1.activeContrastBorder\n                }),\n                themeService.onThemeChange(t => this.onThemeChange(t)),\n                editor.onDidLayoutChange(() => this.onEditorLayoutChange()),\n                this.list.onMouseDown(e => this.onListMouseDown(e)),\n                this.list.onSelectionChange(e => this.onListSelection(e)),\n                this.list.onFocusChange(e => this.onListFocus(e)),\n                this.editor.onDidChangeCursorSelection(() => this.onCursorSelectionChanged()),\n                this.editor.onDidChangeConfiguration(e => e.contribInfo && applyIconStyle())\n            ];\n            this.suggestWidgetVisible = suggest_1.Context.Visible.bindTo(contextKeyService);\n            this.suggestWidgetMultipleSuggestions = suggest_1.Context.MultipleSuggestions.bindTo(contextKeyService);\n            this.editor.addContentWidget(this);\n            this.setState(State.Hidden);\n            this.onThemeChange(themeService.getTheme());\n        }\n        onCursorSelectionChanged() {\n            if (this.state === State.Hidden) {\n                return;\n            }\n            this.editor.layoutContentWidget(this);\n        }\n        onEditorLayoutChange() {\n            if ((this.state === State.Open || this.state === State.Details) && this.expandDocsSettingFromStorage()) {\n                this.expandSideOrBelow();\n            }\n        }\n        onListMouseDown(e) {\n            if (typeof e.element === 'undefined' || typeof e.index === 'undefined') {\n                return;\n            }\n            // prevent stealing browser focus from the editor\n            e.browserEvent.preventDefault();\n            e.browserEvent.stopPropagation();\n            this.select(e.element, e.index);\n        }\n        onListSelection(e) {\n            if (!e.elements.length) {\n                return;\n            }\n            this.select(e.elements[0], e.indexes[0]);\n        }\n        select(item, index) {\n            const completionModel = this.completionModel;\n            if (!completionModel) {\n                return;\n            }\n            item.resolve(cancellation_1.CancellationToken.None).then(() => {\n                this.onDidSelectEmitter.fire({ item, index, model: completionModel });\n                this.editor.focus();\n            });\n        }\n        _getSuggestionAriaAlertLabel(item) {\n            if (this.expandDocsSettingFromStorage()) {\n                return nls.localize('ariaCurrenttSuggestionReadDetails', \"Item {0}, docs: {1}\", item.completion.label, this.details.getAriaLabel());\n            }\n            else {\n                return item.completion.label;\n            }\n        }\n        _ariaAlert(newAriaAlertLabel) {\n            if (this._lastAriaAlertLabel === newAriaAlertLabel) {\n                return;\n            }\n            this._lastAriaAlertLabel = newAriaAlertLabel;\n            if (this._lastAriaAlertLabel) {\n                aria_1.alert(this._lastAriaAlertLabel, true);\n            }\n        }\n        onThemeChange(theme) {\n            const backgroundColor = theme.getColor(exports.editorSuggestWidgetBackground);\n            if (backgroundColor) {\n                this.listElement.style.backgroundColor = backgroundColor.toString();\n                this.details.element.style.backgroundColor = backgroundColor.toString();\n                this.messageElement.style.backgroundColor = backgroundColor.toString();\n            }\n            const borderColor = theme.getColor(exports.editorSuggestWidgetBorder);\n            if (borderColor) {\n                this.listElement.style.borderColor = borderColor.toString();\n                this.details.element.style.borderColor = borderColor.toString();\n                this.messageElement.style.borderColor = borderColor.toString();\n                this.detailsBorderColor = borderColor.toString();\n            }\n            const focusBorderColor = theme.getColor(colorRegistry_1.focusBorder);\n            if (focusBorderColor) {\n                this.detailsFocusBorderColor = focusBorderColor.toString();\n            }\n            this.details.setBorderWidth(theme.type === 'hc' ? 2 : 1);\n        }\n        onListFocus(e) {\n            if (this.ignoreFocusEvents) {\n                return;\n            }\n            if (!e.elements.length) {\n                if (this.currentSuggestionDetails) {\n                    this.currentSuggestionDetails.cancel();\n                    this.currentSuggestionDetails = null;\n                    this.focusedItem = null;\n                }\n                this._ariaAlert(null);\n                return;\n            }\n            if (!this.completionModel) {\n                return;\n            }\n            const item = e.elements[0];\n            const index = e.indexes[0];\n            this.firstFocusInCurrentList = !this.focusedItem;\n            if (item !== this.focusedItem) {\n                if (this.currentSuggestionDetails) {\n                    this.currentSuggestionDetails.cancel();\n                    this.currentSuggestionDetails = null;\n                }\n                this.focusedItem = item;\n                this.list.reveal(index);\n                this.currentSuggestionDetails = async_1.createCancelablePromise(token => item.resolve(token));\n                this.currentSuggestionDetails.then(() => {\n                    if (this.list.length < index) {\n                        return;\n                    }\n                    // item can have extra information, so re-render\n                    this.ignoreFocusEvents = true;\n                    this.list.splice(index, 1, [item]);\n                    this.list.setFocus([index]);\n                    this.ignoreFocusEvents = false;\n                    if (this.expandDocsSettingFromStorage()) {\n                        this.showDetails();\n                    }\n                    else {\n                        dom_1.removeClass(this.element, 'docs-side');\n                    }\n                    this._ariaAlert(this._getSuggestionAriaAlertLabel(item));\n                }).catch(errors_1.onUnexpectedError).then(() => {\n                    if (this.focusedItem === item) {\n                        this.currentSuggestionDetails = null;\n                    }\n                });\n            }\n            // emit an event\n            this.onDidFocusEmitter.fire({ item, index, model: this.completionModel });\n        }\n        setState(state) {\n            if (!this.element) {\n                return;\n            }\n            const stateChanged = this.state !== state;\n            this.state = state;\n            dom_1.toggleClass(this.element, 'frozen', state === State.Frozen);\n            switch (state) {\n                case State.Hidden:\n                    dom_1.hide(this.messageElement, this.details.element, this.listElement);\n                    this.hide();\n                    this.listHeight = 0;\n                    if (stateChanged) {\n                        this.list.splice(0, this.list.length);\n                    }\n                    this.focusedItem = null;\n                    break;\n                case State.Loading:\n                    this.messageElement.textContent = SuggestWidget.LOADING_MESSAGE;\n                    dom_1.hide(this.listElement, this.details.element);\n                    dom_1.show(this.messageElement);\n                    dom_1.removeClass(this.element, 'docs-side');\n                    this.show();\n                    this.focusedItem = null;\n                    break;\n                case State.Empty:\n                    this.messageElement.textContent = SuggestWidget.NO_SUGGESTIONS_MESSAGE;\n                    dom_1.hide(this.listElement, this.details.element);\n                    dom_1.show(this.messageElement);\n                    dom_1.removeClass(this.element, 'docs-side');\n                    this.show();\n                    this.focusedItem = null;\n                    break;\n                case State.Open:\n                    dom_1.hide(this.messageElement);\n                    dom_1.show(this.listElement);\n                    this.show();\n                    break;\n                case State.Frozen:\n                    dom_1.hide(this.messageElement);\n                    dom_1.show(this.listElement);\n                    this.show();\n                    break;\n                case State.Details:\n                    dom_1.hide(this.messageElement);\n                    dom_1.show(this.details.element, this.listElement);\n                    this.show();\n                    this._ariaAlert(this.details.getAriaLabel());\n                    break;\n            }\n        }\n        showTriggered(auto, delay) {\n            if (this.state !== State.Hidden) {\n                return;\n            }\n            this.isAuto = !!auto;\n            if (!this.isAuto) {\n                this.loadingTimeout = setTimeout(() => {\n                    this.loadingTimeout = null;\n                    this.setState(State.Loading);\n                }, delay);\n            }\n        }\n        showSuggestions(completionModel, selectionIndex, isFrozen, isAuto) {\n            this.preferDocPositionTop = false;\n            this.docsPositionPreviousWidgetY = null;\n            if (this.loadingTimeout) {\n                clearTimeout(this.loadingTimeout);\n                this.loadingTimeout = null;\n            }\n            if (this.currentSuggestionDetails) {\n                this.currentSuggestionDetails.cancel();\n                this.currentSuggestionDetails = null;\n            }\n            if (this.completionModel !== completionModel) {\n                this.completionModel = completionModel;\n            }\n            if (isFrozen && this.state !== State.Empty && this.state !== State.Hidden) {\n                this.setState(State.Frozen);\n                return;\n            }\n            let visibleCount = this.completionModel.items.length;\n            const isEmpty = visibleCount === 0;\n            this.suggestWidgetMultipleSuggestions.set(visibleCount > 1);\n            if (isEmpty) {\n                if (isAuto) {\n                    this.setState(State.Hidden);\n                }\n                else {\n                    this.setState(State.Empty);\n                }\n                this.completionModel = null;\n            }\n            else {\n                if (this.state !== State.Open) {\n                    const { stats } = this.completionModel;\n                    stats['wasAutomaticallyTriggered'] = !!isAuto;\n                    /* __GDPR__\n                        \"suggestWidget\" : {\n                            \"wasAutomaticallyTriggered\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                            \"${include}\": [\n                                \"${ICompletionStats}\",\n                                \"${EditorTelemetryData}\"\n                            ]\n                        }\n                    */\n                    this.telemetryService.publicLog('suggestWidget', Object.assign({}, stats, this.editor.getTelemetryData()));\n                }\n                this.focusedItem = null;\n                this.list.splice(0, this.list.length, this.completionModel.items);\n                if (isFrozen) {\n                    this.setState(State.Frozen);\n                }\n                else {\n                    this.setState(State.Open);\n                }\n                this.list.reveal(selectionIndex, 0);\n                this.list.setFocus([selectionIndex]);\n                // Reset focus border\n                if (this.detailsBorderColor) {\n                    this.details.element.style.borderColor = this.detailsBorderColor;\n                }\n            }\n        }\n        selectNextPage() {\n            switch (this.state) {\n                case State.Hidden:\n                    return false;\n                case State.Details:\n                    this.details.pageDown();\n                    return true;\n                case State.Loading:\n                    return !this.isAuto;\n                default:\n                    this.list.focusNextPage();\n                    return true;\n            }\n        }\n        selectNext() {\n            switch (this.state) {\n                case State.Hidden:\n                    return false;\n                case State.Loading:\n                    return !this.isAuto;\n                default:\n                    this.list.focusNext(1, true);\n                    return true;\n            }\n        }\n        selectLast() {\n            switch (this.state) {\n                case State.Hidden:\n                    return false;\n                case State.Details:\n                    this.details.scrollBottom();\n                    return true;\n                case State.Loading:\n                    return !this.isAuto;\n                default:\n                    this.list.focusLast();\n                    return true;\n            }\n        }\n        selectPreviousPage() {\n            switch (this.state) {\n                case State.Hidden:\n                    return false;\n                case State.Details:\n                    this.details.pageUp();\n                    return true;\n                case State.Loading:\n                    return !this.isAuto;\n                default:\n                    this.list.focusPreviousPage();\n                    return true;\n            }\n        }\n        selectPrevious() {\n            switch (this.state) {\n                case State.Hidden:\n                    return false;\n                case State.Loading:\n                    return !this.isAuto;\n                default:\n                    this.list.focusPrevious(1, true);\n                    return false;\n            }\n        }\n        selectFirst() {\n            switch (this.state) {\n                case State.Hidden:\n                    return false;\n                case State.Details:\n                    this.details.scrollTop();\n                    return true;\n                case State.Loading:\n                    return !this.isAuto;\n                default:\n                    this.list.focusFirst();\n                    return true;\n            }\n        }\n        getFocusedItem() {\n            if (this.state !== State.Hidden\n                && this.state !== State.Empty\n                && this.state !== State.Loading\n                && this.completionModel) {\n                return {\n                    item: this.list.getFocusedElements()[0],\n                    index: this.list.getFocus()[0],\n                    model: this.completionModel\n                };\n            }\n            return undefined;\n        }\n        toggleDetailsFocus() {\n            if (this.state === State.Details) {\n                this.setState(State.Open);\n                if (this.detailsBorderColor) {\n                    this.details.element.style.borderColor = this.detailsBorderColor;\n                }\n            }\n            else if (this.state === State.Open && this.expandDocsSettingFromStorage()) {\n                this.setState(State.Details);\n                if (this.detailsFocusBorderColor) {\n                    this.details.element.style.borderColor = this.detailsFocusBorderColor;\n                }\n            }\n            /* __GDPR__\n                \"suggestWidget:toggleDetailsFocus\" : {\n                    \"${include}\": [\n                        \"${EditorTelemetryData}\"\n                    ]\n                }\n            */\n            this.telemetryService.publicLog('suggestWidget:toggleDetailsFocus', this.editor.getTelemetryData());\n        }\n        toggleDetails() {\n            if (!canExpandCompletionItem(this.list.getFocusedElements()[0])) {\n                return;\n            }\n            if (this.expandDocsSettingFromStorage()) {\n                this.updateExpandDocsSetting(false);\n                dom_1.hide(this.details.element);\n                dom_1.removeClass(this.element, 'docs-side');\n                dom_1.removeClass(this.element, 'docs-below');\n                this.editor.layoutContentWidget(this);\n                /* __GDPR__\n                    \"suggestWidget:collapseDetails\" : {\n                        \"${include}\": [\n                            \"${EditorTelemetryData}\"\n                        ]\n                    }\n                */\n                this.telemetryService.publicLog('suggestWidget:collapseDetails', this.editor.getTelemetryData());\n            }\n            else {\n                if (this.state !== State.Open && this.state !== State.Details && this.state !== State.Frozen) {\n                    return;\n                }\n                this.updateExpandDocsSetting(true);\n                this.showDetails();\n                this._ariaAlert(this.details.getAriaLabel());\n                /* __GDPR__\n                    \"suggestWidget:expandDetails\" : {\n                        \"${include}\": [\n                            \"${EditorTelemetryData}\"\n                        ]\n                    }\n                */\n                this.telemetryService.publicLog('suggestWidget:expandDetails', this.editor.getTelemetryData());\n            }\n        }\n        showDetails() {\n            this.expandSideOrBelow();\n            dom_1.show(this.details.element);\n            this.details.render(this.list.getFocusedElements()[0]);\n            this.details.element.style.maxHeight = this.maxWidgetHeight + 'px';\n            // Reset margin-top that was set as Fix for #26416\n            this.listElement.style.marginTop = '0px';\n            // with docs showing up widget width/height may change, so reposition the widget\n            this.editor.layoutContentWidget(this);\n            this.adjustDocsPosition();\n            this.editor.focus();\n        }\n        show() {\n            const newHeight = this.updateListHeight();\n            if (newHeight !== this.listHeight) {\n                this.editor.layoutContentWidget(this);\n                this.listHeight = newHeight;\n            }\n            this.suggestWidgetVisible.set(true);\n            this.showTimeout.cancelAndSet(() => {\n                dom_1.addClass(this.element, 'visible');\n                this.onDidShowEmitter.fire(this);\n            }, 100);\n        }\n        hide() {\n            this.suggestWidgetVisible.reset();\n            this.suggestWidgetMultipleSuggestions.reset();\n            dom_1.removeClass(this.element, 'visible');\n        }\n        hideWidget() {\n            clearTimeout(this.loadingTimeout);\n            this.setState(State.Hidden);\n            this.onDidHideEmitter.fire(this);\n        }\n        getPosition() {\n            if (this.state === State.Hidden) {\n                return null;\n            }\n            let preference = [editorBrowser_1.ContentWidgetPositionPreference.BELOW, editorBrowser_1.ContentWidgetPositionPreference.ABOVE];\n            if (this.preferDocPositionTop) {\n                preference = [editorBrowser_1.ContentWidgetPositionPreference.ABOVE];\n            }\n            return {\n                position: this.editor.getPosition(),\n                preference: preference\n            };\n        }\n        getDomNode() {\n            return this.element;\n        }\n        getId() {\n            return SuggestWidget.ID;\n        }\n        updateListHeight() {\n            let height = 0;\n            if (this.state === State.Empty || this.state === State.Loading) {\n                height = this.unfocusedHeight;\n            }\n            else {\n                const suggestionCount = this.list.contentHeight / this.unfocusedHeight;\n                const { maxVisibleSuggestions } = this.editor.getConfiguration().contribInfo.suggest;\n                height = Math.min(suggestionCount, maxVisibleSuggestions) * this.unfocusedHeight;\n            }\n            this.element.style.lineHeight = `${this.unfocusedHeight}px`;\n            this.listElement.style.height = `${height}px`;\n            this.list.layout(height);\n            return height;\n        }\n        /**\n         * Adds the propert classes, margins when positioning the docs to the side\n         */\n        adjustDocsPosition() {\n            if (!this.editor.hasModel()) {\n                return;\n            }\n            const lineHeight = this.editor.getConfiguration().fontInfo.lineHeight;\n            const cursorCoords = this.editor.getScrolledVisiblePosition(this.editor.getPosition());\n            const editorCoords = dom_1.getDomNodePagePosition(this.editor.getDomNode());\n            const cursorX = editorCoords.left + cursorCoords.left;\n            const cursorY = editorCoords.top + cursorCoords.top + cursorCoords.height;\n            const widgetCoords = dom_1.getDomNodePagePosition(this.element);\n            const widgetX = widgetCoords.left;\n            const widgetY = widgetCoords.top;\n            // Fixes #27649\n            // Check if the Y changed to the top of the cursor and keep the widget flagged to prefer top\n            if (this.docsPositionPreviousWidgetY &&\n                this.docsPositionPreviousWidgetY < widgetY &&\n                !this.preferDocPositionTop) {\n                this.preferDocPositionTop = true;\n                this.adjustDocsPosition();\n                return;\n            }\n            this.docsPositionPreviousWidgetY = widgetY;\n            if (widgetX < cursorX - this.listWidth) {\n                // Widget is too far to the left of cursor, swap list and docs\n                dom_1.addClass(this.element, 'list-right');\n            }\n            else {\n                dom_1.removeClass(this.element, 'list-right');\n            }\n            // Compare top of the cursor (cursorY - lineheight) with widgetTop to determine if\n            // margin-top needs to be applied on list to make it appear right above the cursor\n            // Cannot compare cursorY directly as it may be a few decimals off due to zoooming\n            if (dom_1.hasClass(this.element, 'docs-side')\n                && cursorY - lineHeight > widgetY\n                && this.details.element.offsetHeight > this.listElement.offsetHeight) {\n                // Fix for #26416\n                // Docs is bigger than list and widget is above cursor, apply margin-top so that list appears right above cursor\n                this.listElement.style.marginTop = `${this.details.element.offsetHeight - this.listElement.offsetHeight}px`;\n            }\n        }\n        /**\n         * Adds the proper classes for positioning the docs to the side or below\n         */\n        expandSideOrBelow() {\n            if (!canExpandCompletionItem(this.focusedItem) && this.firstFocusInCurrentList) {\n                dom_1.removeClass(this.element, 'docs-side');\n                dom_1.removeClass(this.element, 'docs-below');\n                return;\n            }\n            let matches = this.element.style.maxWidth.match(/(\\d+)px/);\n            if (!matches || Number(matches[1]) < this.maxWidgetWidth) {\n                dom_1.addClass(this.element, 'docs-below');\n                dom_1.removeClass(this.element, 'docs-side');\n            }\n            else if (canExpandCompletionItem(this.focusedItem)) {\n                dom_1.addClass(this.element, 'docs-side');\n                dom_1.removeClass(this.element, 'docs-below');\n            }\n        }\n        // Heights\n        get maxWidgetHeight() {\n            return this.unfocusedHeight * this.editor.getConfiguration().contribInfo.suggest.maxVisibleSuggestions;\n        }\n        get unfocusedHeight() {\n            const configuration = this.editor.getConfiguration();\n            return configuration.contribInfo.suggestLineHeight || configuration.fontInfo.lineHeight;\n        }\n        // IDelegate\n        getHeight(element) {\n            return this.unfocusedHeight;\n        }\n        getTemplateId(element) {\n            return 'suggestion';\n        }\n        expandDocsSettingFromStorage() {\n            return this.storageService.getBoolean('expandSuggestionDocs', storage_1.StorageScope.GLOBAL, expandSuggestionDocsByDefault);\n        }\n        updateExpandDocsSetting(value) {\n            this.storageService.store('expandSuggestionDocs', value, storage_1.StorageScope.GLOBAL);\n        }\n        dispose() {\n            this.state = null;\n            this.currentSuggestionDetails = null;\n            this.focusedItem = null;\n            this.element = null; // StrictNullOverride: nulling out ok in dispose\n            this.messageElement = null; // StrictNullOverride: nulling out ok in dispose\n            this.listElement = null; // StrictNullOverride: nulling out ok in dispose\n            this.details.dispose();\n            this.details = null; // StrictNullOverride: nulling out ok in dispose\n            this.list.dispose();\n            this.list = null; // StrictNullOverride: nulling out ok in dispose\n            this.toDispose = lifecycle_1.dispose(this.toDispose);\n            if (this.loadingTimeout) {\n                clearTimeout(this.loadingTimeout);\n                this.loadingTimeout = null;\n            }\n            this.editorBlurTimeout.dispose();\n            this.showTimeout.dispose();\n        }\n    };\n    SuggestWidget.ID = 'editor.widget.suggestWidget';\n    SuggestWidget.LOADING_MESSAGE = nls.localize('suggestWidget.loading', \"Loading...\");\n    SuggestWidget.NO_SUGGESTIONS_MESSAGE = nls.localize('suggestWidget.noSuggestions', \"No suggestions.\");\n    SuggestWidget = __decorate([\n        __param(1, telemetry_1.ITelemetryService),\n        __param(2, contextkey_1.IContextKeyService),\n        __param(3, themeService_1.IThemeService),\n        __param(4, storage_1.IStorageService),\n        __param(5, keybinding_1.IKeybindingService),\n        __param(6, modeService_1.IModeService),\n        __param(7, opener_1.IOpenerService),\n        __param(8, instantiation_1.IInstantiationService)\n    ], SuggestWidget);\n    exports.SuggestWidget = SuggestWidget;\n    themeService_1.registerThemingParticipant((theme, collector) => {\n        const matchHighlight = theme.getColor(exports.editorSuggestWidgetHighlightForeground);\n        if (matchHighlight) {\n            collector.addRule(`.monaco-editor .suggest-widget .monaco-list .monaco-list-row .monaco-highlighted-label .highlight { color: ${matchHighlight}; }`);\n        }\n        const foreground = theme.getColor(exports.editorSuggestWidgetForeground);\n        if (foreground) {\n            collector.addRule(`.monaco-editor .suggest-widget { color: ${foreground}; }`);\n        }\n        const link = theme.getColor(colorRegistry_1.textLinkForeground);\n        if (link) {\n            collector.addRule(`.monaco-editor .suggest-widget a { color: ${link}; }`);\n        }\n        const codeBackground = theme.getColor(colorRegistry_1.textCodeBlockBackground);\n        if (codeBackground) {\n            collector.addRule(`.monaco-editor .suggest-widget code { background-color: ${codeBackground}; }`);\n        }\n    });\n});\n",null]}