{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/node/processTaskSystem.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/node/processTaskSystem.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/objects\", \"vs/base/common/types\", \"vs/base/common/platform\", \"vs/base/common/async\", \"vs/base/common/severity\", \"vs/base/common/strings\", \"vs/base/common/event\", \"vs/base/node/processes\", \"vs/workbench/contrib/tasks/common/problemMatcher\", \"vs/workbench/contrib/tasks/common/problemCollectors\", \"vs/workbench/contrib/tasks/common/taskSystem\", \"vs/workbench/contrib/tasks/common/tasks\", \"vs/base/common/lifecycle\"], function (require, exports, nls, Objects, Types, Platform, Async, severity_1, Strings, event_1, processes_1, problemMatcher_1, problemCollectors_1, taskSystem_1, tasks_1, lifecycle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Since ProcessTaskSystem is not receiving new feature updates all strict null check fixing has been done with !.\n     */\n    class ProcessTaskSystem {\n        constructor(markerService, modelService, telemetryService, outputService, configurationResolverService, outputChannelId) {\n            this.outputChannelId = outputChannelId;\n            this.markerService = markerService;\n            this.modelService = modelService;\n            this.outputService = outputService;\n            this.telemetryService = telemetryService;\n            this.configurationResolverService = configurationResolverService;\n            this.childProcess = null;\n            this.activeTask = null;\n            this.activeTaskPromise = null;\n            this.errorsShown = true;\n            this._onDidStateChange = new event_1.Emitter();\n        }\n        get onDidStateChange() {\n            return this._onDidStateChange.event;\n        }\n        isActive() {\n            return Promise.resolve(!!this.childProcess);\n        }\n        isActiveSync() {\n            return !!this.childProcess;\n        }\n        getActiveTasks() {\n            let result = [];\n            if (this.activeTask) {\n                result.push(this.activeTask);\n            }\n            return result;\n        }\n        run(task) {\n            if (this.activeTask) {\n                return { kind: taskSystem_1.TaskExecuteKind.Active, task, active: { same: this.activeTask._id === task._id, background: this.activeTask.configurationProperties.isBackground }, promise: this.activeTaskPromise };\n            }\n            return this.executeTask(task);\n        }\n        revealTask(task) {\n            this.showOutput();\n            return true;\n        }\n        customExecutionComplete(task, result) {\n            throw new taskSystem_1.TaskError(severity_1.default.Error, 'Custom execution task completion is never expected in the process task system.', taskSystem_1.TaskErrors.UnknownError);\n        }\n        hasErrors(value) {\n            this.errorsShown = !value;\n        }\n        canAutoTerminate() {\n            if (this.childProcess) {\n                if (this.activeTask) {\n                    return !this.activeTask.configurationProperties.promptOnClose;\n                }\n                return false;\n            }\n            return true;\n        }\n        terminate(task) {\n            if (!this.activeTask || this.activeTask.getMapKey() !== task.getMapKey()) {\n                return Promise.resolve({ success: false, task: undefined });\n            }\n            return this.terminateAll().then(values => values[0]);\n        }\n        terminateAll() {\n            if (this.childProcess) {\n                let task = this.activeTask;\n                return this.childProcess.terminate().then((response) => {\n                    let result = Objects.assign({ task: task }, response);\n                    this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Terminated, task));\n                    return [result];\n                });\n            }\n            return Promise.resolve([{ success: true, task: undefined }]);\n        }\n        executeTask(task, trigger = taskSystem_1.Triggers.command) {\n            if (!tasks_1.CustomTask.is(task)) {\n                throw new Error(nls.localize('version1_0', 'The task system is configured for version 0.1.0 (see tasks.json file), which can only execute custom tasks. Upgrade to version 2.0.0 to run the task: {0}', task._label));\n            }\n            let telemetryEvent = {\n                trigger: trigger,\n                runner: 'output',\n                taskKind: task.getTelemetryKind(),\n                command: 'other',\n                success: true\n            };\n            try {\n                let result = this.doExecuteTask(task, telemetryEvent);\n                result.promise = result.promise.then((success) => {\n                    /* __GDPR__\n                        \"taskService\" : {\n                            \"${include}\": [\n                                \"${TelemetryEvent}\"\n                            ]\n                        }\n                    */\n                    this.telemetryService.publicLog(ProcessTaskSystem.TelemetryEventName, telemetryEvent);\n                    return success;\n                }, (err) => {\n                    telemetryEvent.success = false;\n                    /* __GDPR__\n                        \"taskService\" : {\n                            \"${include}\": [\n                                \"${TelemetryEvent}\"\n                            ]\n                        }\n                    */\n                    this.telemetryService.publicLog(ProcessTaskSystem.TelemetryEventName, telemetryEvent);\n                    return Promise.reject(err);\n                });\n                return result;\n            }\n            catch (err) {\n                telemetryEvent.success = false;\n                /* __GDPR__\n                    \"taskService\" : {\n                        \"${include}\": [\n                            \"${TelemetryEvent}\"\n                        ]\n                    }\n                */\n                this.telemetryService.publicLog(ProcessTaskSystem.TelemetryEventName, telemetryEvent);\n                if (err instanceof taskSystem_1.TaskError) {\n                    throw err;\n                }\n                else if (err instanceof Error) {\n                    let error = err;\n                    this.appendOutput(error.message);\n                    throw new taskSystem_1.TaskError(severity_1.default.Error, error.message, taskSystem_1.TaskErrors.UnknownError);\n                }\n                else {\n                    this.appendOutput(err.toString());\n                    throw new taskSystem_1.TaskError(severity_1.default.Error, nls.localize('TaskRunnerSystem.unknownError', 'A unknown error has occurred while executing a task. See task output log for details.'), taskSystem_1.TaskErrors.UnknownError);\n                }\n            }\n        }\n        rerun() {\n            return undefined;\n        }\n        doExecuteTask(task, telemetryEvent) {\n            let taskSummary = {};\n            let commandConfig = task.command;\n            if (!this.errorsShown) {\n                this.showOutput();\n                this.errorsShown = true;\n            }\n            else {\n                this.clearOutput();\n            }\n            let args = [];\n            if (commandConfig.args) {\n                for (let arg of commandConfig.args) {\n                    if (Types.isString(arg)) {\n                        args.push(arg);\n                    }\n                    else {\n                        this.log(`Quoting individual arguments is not supported in the process runner. Using plain value: ${arg.value}`);\n                        args.push(arg.value);\n                    }\n                }\n            }\n            args = this.resolveVariables(task, args);\n            let command = this.resolveVariable(task, Types.isString(commandConfig.name) ? commandConfig.name : commandConfig.name.value);\n            this.childProcess = new processes_1.LineProcess(command, args, commandConfig.runtime === tasks_1.RuntimeType.Shell, this.resolveOptions(task, commandConfig.options));\n            telemetryEvent.command = this.childProcess.getSanitizedCommand();\n            // we have no problem matchers defined. So show the output log\n            let reveal = task.command.presentation.reveal;\n            if (reveal === tasks_1.RevealKind.Always || (reveal === tasks_1.RevealKind.Silent && task.configurationProperties.problemMatchers.length === 0)) {\n                this.showOutput();\n            }\n            if (commandConfig.presentation.echo) {\n                let prompt = Platform.isWindows ? '>' : '$';\n                this.log(`running command${prompt} ${command} ${args.join(' ')}`);\n            }\n            if (task.configurationProperties.isBackground) {\n                let watchingProblemMatcher = new problemCollectors_1.WatchingProblemCollector(this.resolveMatchers(task, task.configurationProperties.problemMatchers), this.markerService, this.modelService);\n                let toDispose = [];\n                let eventCounter = 0;\n                toDispose.push(watchingProblemMatcher.onDidStateChange((event) => {\n                    if (event.kind === problemCollectors_1.ProblemCollectorEventKind.BackgroundProcessingBegins) {\n                        eventCounter++;\n                        this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Active, task));\n                    }\n                    else if (event.kind === problemCollectors_1.ProblemCollectorEventKind.BackgroundProcessingEnds) {\n                        eventCounter--;\n                        this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Inactive, task));\n                    }\n                }));\n                watchingProblemMatcher.aboutToStart();\n                let delayer = null;\n                this.activeTask = task;\n                const inactiveEvent = tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Inactive, task);\n                let processStartedSignaled = false;\n                const onProgress = (progress) => {\n                    let line = Strings.removeAnsiEscapeCodes(progress.line);\n                    this.appendOutput(line + '\\n');\n                    watchingProblemMatcher.processLine(line);\n                    if (delayer === null) {\n                        delayer = new Async.Delayer(3000);\n                    }\n                    delayer.trigger(() => {\n                        watchingProblemMatcher.forceDelivery();\n                        return null;\n                    }).then(() => {\n                        delayer = null;\n                    });\n                };\n                const startPromise = this.childProcess.start(onProgress);\n                this.childProcess.pid.then(pid => {\n                    if (pid !== -1) {\n                        processStartedSignaled = true;\n                        this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.ProcessStarted, task, pid));\n                    }\n                });\n                this.activeTaskPromise = startPromise.then((success) => {\n                    this.childProcessEnded();\n                    watchingProblemMatcher.done();\n                    watchingProblemMatcher.dispose();\n                    if (processStartedSignaled && task.command.runtime !== tasks_1.RuntimeType.CustomExecution) {\n                        this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.ProcessEnded, task, success.cmdCode));\n                    }\n                    toDispose = lifecycle_1.dispose(toDispose);\n                    toDispose = null;\n                    for (let i = 0; i < eventCounter; i++) {\n                        this._onDidStateChange.fire(inactiveEvent);\n                    }\n                    eventCounter = 0;\n                    if (!this.checkTerminated(task, success)) {\n                        this.log(nls.localize('TaskRunnerSystem.watchingBuildTaskFinished', '\\nWatching build tasks has finished.'));\n                    }\n                    if (success.cmdCode && success.cmdCode === 1 && watchingProblemMatcher.numberOfMatches === 0 && reveal !== tasks_1.RevealKind.Never) {\n                        this.showOutput();\n                    }\n                    taskSummary.exitCode = success.cmdCode;\n                    return taskSummary;\n                }, (error) => {\n                    this.childProcessEnded();\n                    watchingProblemMatcher.dispose();\n                    toDispose = lifecycle_1.dispose(toDispose);\n                    toDispose = null;\n                    for (let i = 0; i < eventCounter; i++) {\n                        this._onDidStateChange.fire(inactiveEvent);\n                    }\n                    eventCounter = 0;\n                    return this.handleError(task, error);\n                });\n                let result = task.tscWatch\n                    ? { kind: taskSystem_1.TaskExecuteKind.Started, task, started: { restartOnFileChanges: '**/*.ts' }, promise: this.activeTaskPromise }\n                    : { kind: taskSystem_1.TaskExecuteKind.Started, task, started: {}, promise: this.activeTaskPromise };\n                return result;\n            }\n            else {\n                this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Start, task));\n                this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Active, task));\n                let startStopProblemMatcher = new problemCollectors_1.StartStopProblemCollector(this.resolveMatchers(task, task.configurationProperties.problemMatchers), this.markerService, this.modelService);\n                this.activeTask = task;\n                const inactiveEvent = tasks_1.TaskEvent.create(tasks_1.TaskEventKind.Inactive, task);\n                let processStartedSignaled = false;\n                const onProgress = (progress) => {\n                    let line = Strings.removeAnsiEscapeCodes(progress.line);\n                    this.appendOutput(line + '\\n');\n                    startStopProblemMatcher.processLine(line);\n                };\n                const startPromise = this.childProcess.start(onProgress);\n                this.childProcess.pid.then(pid => {\n                    if (pid !== -1) {\n                        processStartedSignaled = true;\n                        this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.ProcessStarted, task, pid));\n                    }\n                });\n                this.activeTaskPromise = startPromise.then((success) => {\n                    this.childProcessEnded();\n                    startStopProblemMatcher.done();\n                    startStopProblemMatcher.dispose();\n                    this.checkTerminated(task, success);\n                    if (processStartedSignaled && task.command.runtime !== tasks_1.RuntimeType.CustomExecution) {\n                        this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.ProcessEnded, task, success.cmdCode));\n                    }\n                    this._onDidStateChange.fire(inactiveEvent);\n                    this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.End, task));\n                    if (success.cmdCode && success.cmdCode === 1 && startStopProblemMatcher.numberOfMatches === 0 && reveal !== tasks_1.RevealKind.Never) {\n                        this.showOutput();\n                    }\n                    taskSummary.exitCode = success.cmdCode;\n                    return taskSummary;\n                }, (error) => {\n                    this.childProcessEnded();\n                    startStopProblemMatcher.dispose();\n                    this._onDidStateChange.fire(inactiveEvent);\n                    this._onDidStateChange.fire(tasks_1.TaskEvent.create(tasks_1.TaskEventKind.End, task));\n                    return this.handleError(task, error);\n                });\n                return { kind: taskSystem_1.TaskExecuteKind.Started, task, started: {}, promise: this.activeTaskPromise };\n            }\n        }\n        childProcessEnded() {\n            this.childProcess = null;\n            this.activeTask = null;\n            this.activeTaskPromise = null;\n        }\n        handleError(task, errorData) {\n            let makeVisible = false;\n            if (errorData.error && !errorData.terminated) {\n                let args = task.command.args ? task.command.args.join(' ') : '';\n                this.log(nls.localize('TaskRunnerSystem.childProcessError', 'Failed to launch external program {0} {1}.', JSON.stringify(task.command.name), args));\n                this.appendOutput(errorData.error.message);\n                makeVisible = true;\n            }\n            if (errorData.stdout) {\n                this.appendOutput(errorData.stdout);\n                makeVisible = true;\n            }\n            if (errorData.stderr) {\n                this.appendOutput(errorData.stderr);\n                makeVisible = true;\n            }\n            makeVisible = this.checkTerminated(task, errorData) || makeVisible;\n            if (makeVisible) {\n                this.showOutput();\n            }\n            const error = errorData.error || new Error();\n            error.stderr = errorData.stderr;\n            error.stdout = errorData.stdout;\n            error.terminated = errorData.terminated;\n            return Promise.reject(error);\n        }\n        checkTerminated(task, data) {\n            if (data.terminated) {\n                this.log(nls.localize('TaskRunnerSystem.cancelRequested', '\\nThe task \\'{0}\\' was terminated per user request.', task.configurationProperties.name));\n                return true;\n            }\n            return false;\n        }\n        resolveOptions(task, options) {\n            let result = { cwd: this.resolveVariable(task, options.cwd) };\n            if (options.env) {\n                result.env = Object.create(null);\n                Object.keys(options.env).forEach((key) => {\n                    let value = options.env[key];\n                    if (Types.isString(value)) {\n                        result.env[key] = this.resolveVariable(task, value);\n                    }\n                    else {\n                        result.env[key] = value.toString();\n                    }\n                });\n            }\n            return result;\n        }\n        resolveVariables(task, value) {\n            return value.map(s => this.resolveVariable(task, s));\n        }\n        resolveMatchers(task, values) {\n            if (values === undefined || values === null || values.length === 0) {\n                return [];\n            }\n            let result = [];\n            values.forEach((value) => {\n                let matcher;\n                if (Types.isString(value)) {\n                    if (value[0] === '$') {\n                        matcher = problemMatcher_1.ProblemMatcherRegistry.get(value.substring(1));\n                    }\n                    else {\n                        matcher = problemMatcher_1.ProblemMatcherRegistry.get(value);\n                    }\n                }\n                else {\n                    matcher = value;\n                }\n                if (!matcher) {\n                    this.appendOutput(nls.localize('unkownProblemMatcher', 'Problem matcher {0} can\\'t be resolved. The matcher will be ignored'));\n                    return;\n                }\n                if (!matcher.filePrefix) {\n                    result.push(matcher);\n                }\n                else {\n                    let copy = Objects.deepClone(matcher);\n                    copy.filePrefix = this.resolveVariable(task, copy.filePrefix);\n                    result.push(copy);\n                }\n            });\n            return result;\n        }\n        resolveVariable(task, value) {\n            return this.configurationResolverService.resolve(task.getWorkspaceFolder(), value);\n        }\n        log(value) {\n            this.appendOutput(value + '\\n');\n        }\n        showOutput() {\n            this.outputService.showChannel(this.outputChannelId, true);\n        }\n        appendOutput(output) {\n            const outputChannel = this.outputService.getChannel(this.outputChannelId);\n            if (outputChannel) {\n                outputChannel.append(output);\n            }\n        }\n        clearOutput() {\n            const outputChannel = this.outputService.getChannel(this.outputChannelId);\n            if (outputChannel) {\n                outputChannel.clear();\n            }\n        }\n    }\n    ProcessTaskSystem.TelemetryEventName = 'taskService';\n    exports.ProcessTaskSystem = ProcessTaskSystem;\n});\n",null]}