{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostCommands.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostCommands.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/types\", \"vs/workbench/api/node/extHostTypes\", \"vs/workbench/api/node/extHostTypeConverters\", \"vs/base/common/objects\", \"../common/extHost.protocol\", \"vs/base/common/arrays\", \"vs/base/common/marshalling\", \"vs/editor/common/core/range\", \"vs/editor/common/core/position\", \"vs/base/common/uri\"], function (require, exports, types_1, extHostTypes, extHostTypeConverter, objects_1, extHost_protocol_1, arrays_1, marshalling_1, range_1, position_1, uri_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class ExtHostCommands {\n        constructor(mainContext, heapService, logService) {\n            this._commands = new Map();\n            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadCommands);\n            this._logService = logService;\n            this._converter = new CommandsConverter(this, heapService);\n            this._argumentProcessors = [\n                {\n                    processArgument(a) {\n                        // URI, Regex\n                        return marshalling_1.revive(a, 0);\n                    }\n                },\n                {\n                    processArgument(arg) {\n                        return objects_1.cloneAndChange(arg, function (obj) {\n                            // Reverse of https://github.com/Microsoft/vscode/blob/1f28c5fc681f4c01226460b6d1c7e91b8acb4a5b/src/vs/workbench/api/node/extHostCommands.ts#L112-L127\n                            if (range_1.Range.isIRange(obj)) {\n                                return extHostTypeConverter.Range.to(obj);\n                            }\n                            if (position_1.Position.isIPosition(obj)) {\n                                return extHostTypeConverter.Position.to(obj);\n                            }\n                            if (range_1.Range.isIRange(obj.range) && uri_1.URI.isUri(obj.uri)) {\n                                return extHostTypeConverter.location.to(obj);\n                            }\n                            if (!Array.isArray(obj)) {\n                                return obj;\n                            }\n                        });\n                    }\n                }\n            ];\n        }\n        get converter() {\n            return this._converter;\n        }\n        registerArgumentProcessor(processor) {\n            this._argumentProcessors.push(processor);\n        }\n        registerCommand(global, id, callback, thisArg, description) {\n            this._logService.trace('ExtHostCommands#registerCommand', id);\n            if (!id.trim().length) {\n                throw new Error('invalid id');\n            }\n            if (this._commands.has(id)) {\n                throw new Error(`command '${id}' already exists`);\n            }\n            this._commands.set(id, { callback, thisArg, description });\n            if (global) {\n                this._proxy.$registerCommand(id);\n            }\n            return new extHostTypes.Disposable(() => {\n                if (this._commands.delete(id)) {\n                    if (global) {\n                        this._proxy.$unregisterCommand(id);\n                    }\n                }\n            });\n        }\n        executeCommand(id, ...args) {\n            this._logService.trace('ExtHostCommands#executeCommand', id);\n            if (this._commands.has(id)) {\n                // we stay inside the extension host and support\n                // to pass any kind of parameters around\n                return this._executeContributedCommand(id, args);\n            }\n            else {\n                // automagically convert some argument types\n                args = objects_1.cloneAndChange(args, function (value) {\n                    if (value instanceof extHostTypes.Position) {\n                        return extHostTypeConverter.Position.from(value);\n                    }\n                    if (value instanceof extHostTypes.Range) {\n                        return extHostTypeConverter.Range.from(value);\n                    }\n                    if (value instanceof extHostTypes.Location) {\n                        return extHostTypeConverter.location.from(value);\n                    }\n                    if (!Array.isArray(value)) {\n                        return value;\n                    }\n                });\n                return this._proxy.$executeCommand(id, args).then(result => marshalling_1.revive(result, 0));\n            }\n        }\n        _executeContributedCommand(id, args) {\n            const command = this._commands.get(id);\n            if (!command) {\n                throw new Error('Unknown command');\n            }\n            let { callback, thisArg, description } = command;\n            if (description) {\n                for (let i = 0; i < description.args.length; i++) {\n                    try {\n                        types_1.validateConstraint(args[i], description.args[i].constraint);\n                    }\n                    catch (err) {\n                        return Promise.reject(new Error(`Running the contributed command: '${id}' failed. Illegal argument '${description.args[i].name}' - ${description.args[i].description}`));\n                    }\n                }\n            }\n            try {\n                const result = callback.apply(thisArg, args);\n                return Promise.resolve(result);\n            }\n            catch (err) {\n                this._logService.error(err, id);\n                return Promise.reject(new Error(`Running the contributed command: '${id}' failed.`));\n            }\n        }\n        $executeContributedCommand(id, ...args) {\n            this._logService.trace('ExtHostCommands#$executeContributedCommand', id);\n            if (!this._commands.has(id)) {\n                return Promise.reject(new Error(`Contributed command '${id}' does not exist.`));\n            }\n            else {\n                args = args.map(arg => this._argumentProcessors.reduce((r, p) => p.processArgument(r), arg));\n                return this._executeContributedCommand(id, args);\n            }\n        }\n        getCommands(filterUnderscoreCommands = false) {\n            this._logService.trace('ExtHostCommands#getCommands', filterUnderscoreCommands);\n            return this._proxy.$getCommands().then(result => {\n                if (filterUnderscoreCommands) {\n                    result = result.filter(command => command[0] !== '_');\n                }\n                return result;\n            });\n        }\n        $getContributedCommandHandlerDescriptions() {\n            const result = Object.create(null);\n            this._commands.forEach((command, id) => {\n                let { description } = command;\n                if (description) {\n                    result[id] = description;\n                }\n            });\n            return Promise.resolve(result);\n        }\n    }\n    exports.ExtHostCommands = ExtHostCommands;\n    class CommandsConverter {\n        // --- conversion between internal and api commands\n        constructor(commands, heap) {\n            this._delegatingCommandId = `_internal_command_delegation_${Date.now()}`;\n            this._commands = commands;\n            this._heap = heap;\n            this._commands.registerCommand(true, this._delegatingCommandId, this._executeConvertedCommand, this);\n        }\n        toInternal(command) {\n            if (!command) {\n                return undefined;\n            }\n            const result = {\n                $ident: undefined,\n                id: command.command,\n                title: command.title,\n            };\n            if (command.command && arrays_1.isNonEmptyArray(command.arguments)) {\n                // we have a contributed command with arguments. that\n                // means we don't want to send the arguments around\n                const id = this._heap.keep(command);\n                result.$ident = id;\n                result.id = this._delegatingCommandId;\n                result.arguments = [id];\n            }\n            if (command.tooltip) {\n                result.tooltip = command.tooltip;\n            }\n            return result;\n        }\n        fromInternal(command) {\n            const id = extHost_protocol_1.ObjectIdentifier.of(command);\n            if (typeof id === 'number') {\n                return this._heap.get(id);\n            }\n            else {\n                return {\n                    command: command.id,\n                    title: command.title,\n                    arguments: command.arguments\n                };\n            }\n        }\n        _executeConvertedCommand(...args) {\n            const actualCmd = this._heap.get(args[0]);\n            return this._commands.executeCommand(actualCmd.command, ...(actualCmd.arguments || []));\n        }\n    }\n    exports.CommandsConverter = CommandsConverter;\n});\n",null]}