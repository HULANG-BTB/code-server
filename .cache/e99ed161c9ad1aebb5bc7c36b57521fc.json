{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/files/common/dirtyFilesTracker.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/files/common/dirtyFilesTracker.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/workbench/contrib/files/common/files\", \"vs/workbench/services/textfile/common/textfiles\", \"vs/base/common/platform\", \"vs/platform/windows/common/windows\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/base/common/lifecycle\", \"vs/workbench/services/activity/common/activity\", \"vs/workbench/services/untitled/common/untitledEditorService\", \"vs/base/common/arrays\", \"vs/workbench/services/editor/common/editorService\"], function (require, exports, nls, files_1, textfiles_1, platform_1, windows_1, lifecycle_1, lifecycle_2, activity_1, untitledEditorService_1, arrays, editorService_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let DirtyFilesTracker = class DirtyFilesTracker extends lifecycle_2.Disposable {\n        constructor(textFileService, lifecycleService, editorService, activityService, windowService, untitledEditorService) {\n            super();\n            this.textFileService = textFileService;\n            this.lifecycleService = lifecycleService;\n            this.editorService = editorService;\n            this.activityService = activityService;\n            this.windowService = windowService;\n            this.untitledEditorService = untitledEditorService;\n            this.isDocumentedEdited = false;\n            this.registerListeners();\n        }\n        registerListeners() {\n            // Local text file changes\n            this._register(this.untitledEditorService.onDidChangeDirty(e => this.onUntitledDidChangeDirty(e)));\n            this._register(this.textFileService.models.onModelsDirty(e => this.onTextFilesDirty(e)));\n            this._register(this.textFileService.models.onModelsSaved(e => this.onTextFilesSaved(e)));\n            this._register(this.textFileService.models.onModelsSaveError(e => this.onTextFilesSaveError(e)));\n            this._register(this.textFileService.models.onModelsReverted(e => this.onTextFilesReverted(e)));\n            // Lifecycle\n            this.lifecycleService.onShutdown(this.dispose, this);\n        }\n        onUntitledDidChangeDirty(resource) {\n            const gotDirty = this.untitledEditorService.isDirty(resource);\n            if ((!this.isDocumentedEdited && gotDirty) || (this.isDocumentedEdited && !gotDirty)) {\n                this.updateDocumentEdited();\n            }\n            if (gotDirty || this.lastDirtyCount > 0) {\n                this.updateActivityBadge();\n            }\n        }\n        onTextFilesDirty(e) {\n            if ((this.textFileService.getAutoSaveMode() !== textfiles_1.AutoSaveMode.AFTER_SHORT_DELAY) && !this.isDocumentedEdited) {\n                this.updateDocumentEdited(); // no indication needed when auto save is enabled for short delay\n            }\n            if (this.textFileService.getAutoSaveMode() !== textfiles_1.AutoSaveMode.AFTER_SHORT_DELAY) {\n                this.updateActivityBadge(); // no indication needed when auto save is enabled for short delay\n            }\n            // If files become dirty but are not opened, we open it in the background unless there are pending to be saved\n            this.doOpenDirtyResources(arrays.distinct(e.filter(e => {\n                // Only dirty models that are not PENDING_SAVE\n                const model = this.textFileService.models.get(e.resource);\n                const shouldOpen = model && model.isDirty() && !model.hasState(textfiles_1.ModelState.PENDING_SAVE);\n                // Only if not open already\n                return shouldOpen && !this.editorService.isOpen({ resource: e.resource });\n            }).map(e => e.resource), r => r.toString()));\n        }\n        doOpenDirtyResources(resources) {\n            const activeEditor = this.editorService.activeControl;\n            // Open\n            this.editorService.openEditors(resources.map(resource => {\n                return {\n                    resource,\n                    options: { inactive: true, pinned: true, preserveFocus: true }\n                };\n            }), activeEditor ? activeEditor.group : editorService_1.ACTIVE_GROUP);\n        }\n        onTextFilesSaved(e) {\n            if (this.isDocumentedEdited) {\n                this.updateDocumentEdited();\n            }\n            if (this.lastDirtyCount > 0) {\n                this.updateActivityBadge();\n            }\n        }\n        onTextFilesSaveError(e) {\n            if (!this.isDocumentedEdited) {\n                this.updateDocumentEdited();\n            }\n            this.updateActivityBadge();\n        }\n        onTextFilesReverted(e) {\n            if (this.isDocumentedEdited) {\n                this.updateDocumentEdited();\n            }\n            if (this.lastDirtyCount > 0) {\n                this.updateActivityBadge();\n            }\n        }\n        updateActivityBadge() {\n            const dirtyCount = this.textFileService.getDirty().length;\n            this.lastDirtyCount = dirtyCount;\n            lifecycle_2.dispose(this.badgeHandle);\n            if (dirtyCount > 0) {\n                this.badgeHandle = this.activityService.showActivity(files_1.VIEWLET_ID, new activity_1.NumberBadge(dirtyCount, num => num === 1 ? nls.localize('dirtyFile', \"1 unsaved file\") : nls.localize('dirtyFiles', \"{0} unsaved files\", dirtyCount)), 'explorer-viewlet-label');\n            }\n        }\n        updateDocumentEdited() {\n            if (platform_1.platform === platform_1.Platform.Mac) {\n                const hasDirtyFiles = this.textFileService.isDirty();\n                this.isDocumentedEdited = hasDirtyFiles;\n                this.windowService.setDocumentEdited(hasDirtyFiles);\n            }\n        }\n    };\n    DirtyFilesTracker = __decorate([\n        __param(0, textfiles_1.ITextFileService),\n        __param(1, lifecycle_1.ILifecycleService),\n        __param(2, editorService_1.IEditorService),\n        __param(3, activity_1.IActivityService),\n        __param(4, windows_1.IWindowService),\n        __param(5, untitledEditorService_1.IUntitledEditorService)\n    ], DirtyFilesTracker);\n    exports.DirtyFilesTracker = DirtyFilesTracker;\n});\n",null]}