{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar strings = require(\"vs/base/common/strings\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar model_1 = require(\"vs/editor/common/model\");\nvar pieceTreeBase_1 = require(\"vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase\");\nvar PieceTreeTextBuffer = /** @class */ (function () {\n    function PieceTreeTextBuffer(chunks, BOM, eol, containsRTL, isBasicASCII, eolNormalized) {\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._pieceTree = new pieceTreeBase_1.PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    // #region TextBuffer\n    PieceTreeTextBuffer.prototype.equals = function (other) {\n        if (!(other instanceof PieceTreeTextBuffer)) {\n            return false;\n        }\n        if (this._BOM !== other._BOM) {\n            return false;\n        }\n        if (this.getEOL() !== other.getEOL()) {\n            return false;\n        }\n        return this._pieceTree.equal(other._pieceTree);\n    };\n    PieceTreeTextBuffer.prototype.mightContainRTL = function () {\n        return this._mightContainRTL;\n    };\n    PieceTreeTextBuffer.prototype.mightContainNonBasicASCII = function () {\n        return this._mightContainNonBasicASCII;\n    };\n    PieceTreeTextBuffer.prototype.getBOM = function () {\n        return this._BOM;\n    };\n    PieceTreeTextBuffer.prototype.getEOL = function () {\n        return this._pieceTree.getEOL();\n    };\n    PieceTreeTextBuffer.prototype.createSnapshot = function (preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    };\n    PieceTreeTextBuffer.prototype.getOffsetAt = function (lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    };\n    PieceTreeTextBuffer.prototype.getPositionAt = function (offset) {\n        return this._pieceTree.getPositionAt(offset);\n    };\n    PieceTreeTextBuffer.prototype.getRangeAt = function (start, length) {\n        var end = start + length;\n        var startPosition = this.getPositionAt(start);\n        var endPosition = this.getPositionAt(end);\n        return new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    };\n    PieceTreeTextBuffer.prototype.getValueInRange = function (range, eol) {\n        if (eol === void 0) { eol = model_1.EndOfLinePreference.TextDefined; }\n        if (range.isEmpty()) {\n            return '';\n        }\n        var lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    };\n    PieceTreeTextBuffer.prototype.getValueLengthInRange = function (range, eol) {\n        if (eol === void 0) { eol = model_1.EndOfLinePreference.TextDefined; }\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        var startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        var endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        return endOffset - startOffset;\n    };\n    PieceTreeTextBuffer.prototype.getLength = function () {\n        return this._pieceTree.getLength();\n    };\n    PieceTreeTextBuffer.prototype.getLineCount = function () {\n        return this._pieceTree.getLineCount();\n    };\n    PieceTreeTextBuffer.prototype.getLinesContent = function () {\n        return this._pieceTree.getLinesContent();\n    };\n    PieceTreeTextBuffer.prototype.getLineContent = function (lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    };\n    PieceTreeTextBuffer.prototype.getLineCharCode = function (lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    };\n    PieceTreeTextBuffer.prototype.getLineLength = function (lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    };\n    PieceTreeTextBuffer.prototype.getLineMinColumn = function (lineNumber) {\n        return 1;\n    };\n    PieceTreeTextBuffer.prototype.getLineMaxColumn = function (lineNumber) {\n        return this.getLineLength(lineNumber) + 1;\n    };\n    PieceTreeTextBuffer.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {\n        var result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    };\n    PieceTreeTextBuffer.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {\n        var result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    };\n    PieceTreeTextBuffer.prototype._getEndOfLine = function (eol) {\n        switch (eol) {\n            case model_1.EndOfLinePreference.LF:\n                return '\\n';\n            case model_1.EndOfLinePreference.CRLF:\n                return '\\r\\n';\n            case model_1.EndOfLinePreference.TextDefined:\n                return this.getEOL();\n        }\n        throw new Error('Unknown EOL preference');\n    };\n    PieceTreeTextBuffer.prototype.setEOL = function (newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    };\n    PieceTreeTextBuffer.prototype.applyEdits = function (rawOperations, recordTrimAutoWhitespace) {\n        var mightContainRTL = this._mightContainRTL;\n        var mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        var canReduceOperations = true;\n        var operations = [];\n        for (var i = 0; i < rawOperations.length; i++) {\n            var op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            var validatedRange = op.range;\n            if (!mightContainRTL && op.text) {\n                // check if the new inserted text contains RTL\n                mightContainRTL = strings.containsRTL(op.text);\n            }\n            if (!mightContainNonBasicASCII && op.text) {\n                mightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                lines: op.text ? op.text.split(/\\r\\n|\\r|\\n/) : null,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        var hasTouchingRanges = false;\n        for (var i = 0, count = operations.length - 1; i < count; i++) {\n            var rangeEnd = operations[i].range.getEndPosition();\n            var nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        var reverseRanges = PieceTreeTextBuffer._getInverseEditRanges(operations);\n        var newTrimAutoWhitespaceCandidates = [];\n        for (var i = 0; i < operations.length; i++) {\n            var op = operations[i];\n            var reverseRange = reverseRanges[i];\n            if (recordTrimAutoWhitespace && op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                for (var lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                    var currentLineContent = '';\n                    if (lineNumber === reverseRange.startLineNumber) {\n                        currentLineContent = this.getLineContent(op.range.startLineNumber);\n                        if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                            continue;\n                        }\n                    }\n                    newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                }\n            }\n        }\n        var reverseOperations = [];\n        for (var i = 0; i < operations.length; i++) {\n            var op = operations[i];\n            var reverseRange = reverseRanges[i];\n            reverseOperations[i] = {\n                sortIndex: op.sortIndex,\n                identifier: op.identifier,\n                range: reverseRange,\n                text: this.getValueInRange(op.range),\n                forceMoveMarkers: op.forceMoveMarkers\n            };\n        }\n        // Can only sort reverse operations when the order is not significant\n        if (!hasTouchingRanges) {\n            reverseOperations.sort(function (a, b) { return a.sortIndex - b.sortIndex; });\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        var contentChanges = this._doApplyEdits(operations);\n        var trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort(function (a, b) { return b.lineNumber - a.lineNumber; });\n            trimAutoWhitespaceLineNumbers = [];\n            for (var i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                var lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                var prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                var lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        return new model_1.ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    };\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    PieceTreeTextBuffer.prototype._reduceOperations = function (operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    };\n    PieceTreeTextBuffer.prototype._toSingleEditOperation = function (operations) {\n        var forceMoveMarkers = false, firstEditRange = operations[0].range, lastEditRange = operations[operations.length - 1].range, entireEditRange = new range_1.Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn), lastEndLineNumber = firstEditRange.startLineNumber, lastEndColumn = firstEditRange.startColumn, result = [];\n        for (var i = 0, len = operations.length; i < len; i++) {\n            var operation = operations[i], range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            for (var lineNumber = lastEndLineNumber; lineNumber < range.startLineNumber; lineNumber++) {\n                if (lineNumber === lastEndLineNumber) {\n                    result.push(this.getLineContent(lineNumber).substring(lastEndColumn - 1));\n                }\n                else {\n                    result.push('\\n');\n                    result.push(this.getLineContent(lineNumber));\n                }\n            }\n            if (range.startLineNumber === lastEndLineNumber) {\n                result.push(this.getLineContent(range.startLineNumber).substring(lastEndColumn - 1, range.startColumn - 1));\n            }\n            else {\n                result.push('\\n');\n                result.push(this.getLineContent(range.startLineNumber).substring(0, range.startColumn - 1));\n            }\n            // (2) -- Push new text\n            if (operation.lines) {\n                for (var j = 0, lenJ = operation.lines.length; j < lenJ; j++) {\n                    if (j !== 0) {\n                        result.push('\\n');\n                    }\n                    result.push(operation.lines[j]);\n                }\n            }\n            lastEndLineNumber = operation.range.endLineNumber;\n            lastEndColumn = operation.range.endColumn;\n        }\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, model_1.EndOfLinePreference.TextDefined),\n            lines: result.join('').split('\\n'),\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    };\n    PieceTreeTextBuffer.prototype._doApplyEdits = function (operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        var contentChanges = [];\n        // operations are from bottom to top\n        for (var i = 0; i < operations.length; i++) {\n            var op = operations[i];\n            var startLineNumber = op.range.startLineNumber;\n            var startColumn = op.range.startColumn;\n            var endLineNumber = op.range.endLineNumber;\n            var endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && (!op.lines || op.lines.length === 0)) {\n                // no-op\n                continue;\n            }\n            var deletingLinesCnt = endLineNumber - startLineNumber;\n            var insertingLinesCnt = (op.lines ? op.lines.length - 1 : 0);\n            var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n            var text = (op.lines ? op.lines.join(this.getEOL()) : '');\n            if (text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            if (editingLinesCnt < insertingLinesCnt) {\n                var newLinesContent = [];\n                for (var j = editingLinesCnt + 1; j <= insertingLinesCnt; j++) {\n                    newLinesContent.push(op.lines[j]);\n                }\n                newLinesContent[newLinesContent.length - 1] = this.getLineContent(startLineNumber + insertingLinesCnt - 1);\n            }\n            var contentChangeRange = new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    };\n    PieceTreeTextBuffer.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    };\n    // #endregion\n    // #region helper\n    // testing purpose.\n    PieceTreeTextBuffer.prototype.getPieceTree = function () {\n        return this._pieceTree;\n    };\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    PieceTreeTextBuffer._getInverseEditRanges = function (operations) {\n        var result = [];\n        var prevOpEndLineNumber = 0;\n        var prevOpEndColumn = 0;\n        var prevOp = null;\n        for (var i = 0, len = operations.length; i < len; i++) {\n            var op = operations[i];\n            var startLineNumber = void 0;\n            var startColumn = void 0;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            var resultRange = void 0;\n            if (op.lines && op.lines.length > 0) {\n                // the operation inserts something\n                var lineCount = op.lines.length;\n                var firstLine = op.lines[0];\n                var lastLine = op.lines[lineCount - 1];\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new range_1.Range(startLineNumber, startColumn, startLineNumber, startColumn + firstLine.length);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new range_1.Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLine.length + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new range_1.Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    };\n    PieceTreeTextBuffer._sortOpsAscending = function (a, b) {\n        var r = range_1.Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    };\n    PieceTreeTextBuffer._sortOpsDescending = function (a, b) {\n        var r = range_1.Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    };\n    return PieceTreeTextBuffer;\n}());\nexports.PieceTreeTextBuffer = PieceTreeTextBuffer;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from 'vs/base/common/strings';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { ApplyEditsResult, EndOfLinePreference, FindMatch, IIdentifiedSingleEditOperation, IInternalModelContentChange, ISingleEditOperationIdentifier, ITextBuffer } from 'vs/editor/common/model';\nimport { PieceTreeBase, StringBuffer } from 'vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase';\nimport { SearchData } from 'vs/editor/common/model/textModelSearch';\nimport { ITextSnapshot } from 'vs/platform/files/common/files';\n\nexport interface IValidatedEditOperation {\n\tsortIndex: number;\n\tidentifier: ISingleEditOperationIdentifier | null;\n\trange: Range;\n\trangeOffset: number;\n\trangeLength: number;\n\tlines: string[] | null;\n\tforceMoveMarkers: boolean;\n\tisAutoWhitespaceEdit: boolean;\n}\n\nexport interface IReverseSingleEditOperation extends IIdentifiedSingleEditOperation {\n\tsortIndex: number;\n}\n\nexport class PieceTreeTextBuffer implements ITextBuffer {\n\tprivate readonly _pieceTree: PieceTreeBase;\n\tprivate readonly _BOM: string;\n\tprivate _mightContainRTL: boolean;\n\tprivate _mightContainNonBasicASCII: boolean;\n\n\tconstructor(chunks: StringBuffer[], BOM: string, eol: '\\r\\n' | '\\n', containsRTL: boolean, isBasicASCII: boolean, eolNormalized: boolean) {\n\t\tthis._BOM = BOM;\n\t\tthis._mightContainNonBasicASCII = !isBasicASCII;\n\t\tthis._mightContainRTL = containsRTL;\n\t\tthis._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n\t}\n\n\t// #region TextBuffer\n\tpublic equals(other: ITextBuffer): boolean {\n\t\tif (!(other instanceof PieceTreeTextBuffer)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._BOM !== other._BOM) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.getEOL() !== other.getEOL()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this._pieceTree.equal(other._pieceTree);\n\t}\n\tpublic mightContainRTL(): boolean {\n\t\treturn this._mightContainRTL;\n\t}\n\tpublic mightContainNonBasicASCII(): boolean {\n\t\treturn this._mightContainNonBasicASCII;\n\t}\n\tpublic getBOM(): string {\n\t\treturn this._BOM;\n\t}\n\tpublic getEOL(): string {\n\t\treturn this._pieceTree.getEOL();\n\t}\n\n\tpublic createSnapshot(preserveBOM: boolean): ITextSnapshot {\n\t\treturn this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n\t}\n\n\tpublic getOffsetAt(lineNumber: number, column: number): number {\n\t\treturn this._pieceTree.getOffsetAt(lineNumber, column);\n\t}\n\n\tpublic getPositionAt(offset: number): Position {\n\t\treturn this._pieceTree.getPositionAt(offset);\n\t}\n\n\tpublic getRangeAt(start: number, length: number): Range {\n\t\tlet end = start + length;\n\t\tconst startPosition = this.getPositionAt(start);\n\t\tconst endPosition = this.getPositionAt(end);\n\t\treturn new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n\t}\n\n\tpublic getValueInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): string {\n\t\tif (range.isEmpty()) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst lineEnding = this._getEndOfLine(eol);\n\t\treturn this._pieceTree.getValueInRange(range, lineEnding);\n\t}\n\n\tpublic getValueLengthInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): number {\n\t\tif (range.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn (range.endColumn - range.startColumn);\n\t\t}\n\n\t\tlet startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\tlet endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n\t\treturn endOffset - startOffset;\n\t}\n\n\tpublic getLength(): number {\n\t\treturn this._pieceTree.getLength();\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._pieceTree.getLineCount();\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\treturn this._pieceTree.getLinesContent();\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\treturn this._pieceTree.getLineContent(lineNumber);\n\t}\n\n\tpublic getLineCharCode(lineNumber: number, index: number): number {\n\t\treturn this._pieceTree.getLineCharCode(lineNumber, index);\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\treturn this._pieceTree.getLineLength(lineNumber);\n\t}\n\n\tpublic getLineMinColumn(lineNumber: number): number {\n\t\treturn 1;\n\t}\n\n\tpublic getLineMaxColumn(lineNumber: number): number {\n\t\treturn this.getLineLength(lineNumber) + 1;\n\t}\n\n\tpublic getLineFirstNonWhitespaceColumn(lineNumber: number): number {\n\t\tconst result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n\t\tif (result === -1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn result + 1;\n\t}\n\n\tpublic getLineLastNonWhitespaceColumn(lineNumber: number): number {\n\t\tconst result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n\t\tif (result === -1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn result + 2;\n\t}\n\n\tprivate _getEndOfLine(eol: EndOfLinePreference): string {\n\t\tswitch (eol) {\n\t\t\tcase EndOfLinePreference.LF:\n\t\t\t\treturn '\\n';\n\t\t\tcase EndOfLinePreference.CRLF:\n\t\t\t\treturn '\\r\\n';\n\t\t\tcase EndOfLinePreference.TextDefined:\n\t\t\t\treturn this.getEOL();\n\t\t}\n\t\tthrow new Error('Unknown EOL preference');\n\t}\n\n\tpublic setEOL(newEOL: '\\r\\n' | '\\n'): void {\n\t\tthis._pieceTree.setEOL(newEOL);\n\t}\n\n\tpublic applyEdits(rawOperations: IIdentifiedSingleEditOperation[], recordTrimAutoWhitespace: boolean): ApplyEditsResult {\n\t\tlet mightContainRTL = this._mightContainRTL;\n\t\tlet mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n\t\tlet canReduceOperations = true;\n\n\t\tlet operations: IValidatedEditOperation[] = [];\n\t\tfor (let i = 0; i < rawOperations.length; i++) {\n\t\t\tlet op = rawOperations[i];\n\t\t\tif (canReduceOperations && op._isTracked) {\n\t\t\t\tcanReduceOperations = false;\n\t\t\t}\n\t\t\tlet validatedRange = op.range;\n\t\t\tif (!mightContainRTL && op.text) {\n\t\t\t\t// check if the new inserted text contains RTL\n\t\t\t\tmightContainRTL = strings.containsRTL(op.text);\n\t\t\t}\n\t\t\tif (!mightContainNonBasicASCII && op.text) {\n\t\t\t\tmightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n\t\t\t}\n\t\t\toperations[i] = {\n\t\t\t\tsortIndex: i,\n\t\t\t\tidentifier: op.identifier || null,\n\t\t\t\trange: validatedRange,\n\t\t\t\trangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n\t\t\t\trangeLength: this.getValueLengthInRange(validatedRange),\n\t\t\t\tlines: op.text ? op.text.split(/\\r\\n|\\r|\\n/) : null,\n\t\t\t\tforceMoveMarkers: Boolean(op.forceMoveMarkers),\n\t\t\t\tisAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n\t\t\t};\n\t\t}\n\n\t\t// Sort operations ascending\n\t\toperations.sort(PieceTreeTextBuffer._sortOpsAscending);\n\n\t\tlet hasTouchingRanges = false;\n\t\tfor (let i = 0, count = operations.length - 1; i < count; i++) {\n\t\t\tlet rangeEnd = operations[i].range.getEndPosition();\n\t\t\tlet nextRangeStart = operations[i + 1].range.getStartPosition();\n\n\t\t\tif (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n\t\t\t\tif (nextRangeStart.isBefore(rangeEnd)) {\n\t\t\t\t\t// overlapping ranges\n\t\t\t\t\tthrow new Error('Overlapping ranges are not allowed!');\n\t\t\t\t}\n\t\t\t\thasTouchingRanges = true;\n\t\t\t}\n\t\t}\n\n\t\tif (canReduceOperations) {\n\t\t\toperations = this._reduceOperations(operations);\n\t\t}\n\n\t\t// Delta encode operations\n\t\tlet reverseRanges = PieceTreeTextBuffer._getInverseEditRanges(operations);\n\t\tlet newTrimAutoWhitespaceCandidates: { lineNumber: number, oldContent: string }[] = [];\n\n\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\tlet op = operations[i];\n\t\t\tlet reverseRange = reverseRanges[i];\n\n\t\t\tif (recordTrimAutoWhitespace && op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n\t\t\t\t// Record already the future line numbers that might be auto whitespace removal candidates on next edit\n\t\t\t\tfor (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n\t\t\t\t\tlet currentLineContent = '';\n\t\t\t\t\tif (lineNumber === reverseRange.startLineNumber) {\n\t\t\t\t\t\tcurrentLineContent = this.getLineContent(op.range.startLineNumber);\n\t\t\t\t\t\tif (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnewTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet reverseOperations: IReverseSingleEditOperation[] = [];\n\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\tlet op = operations[i];\n\t\t\tlet reverseRange = reverseRanges[i];\n\n\t\t\treverseOperations[i] = {\n\t\t\t\tsortIndex: op.sortIndex,\n\t\t\t\tidentifier: op.identifier,\n\t\t\t\trange: reverseRange,\n\t\t\t\ttext: this.getValueInRange(op.range),\n\t\t\t\tforceMoveMarkers: op.forceMoveMarkers\n\t\t\t};\n\t\t}\n\n\t\t// Can only sort reverse operations when the order is not significant\n\t\tif (!hasTouchingRanges) {\n\t\t\treverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n\t\t}\n\n\t\tthis._mightContainRTL = mightContainRTL;\n\t\tthis._mightContainNonBasicASCII = mightContainNonBasicASCII;\n\n\t\tconst contentChanges = this._doApplyEdits(operations);\n\n\t\tlet trimAutoWhitespaceLineNumbers: number[] | null = null;\n\t\tif (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n\t\t\t// sort line numbers auto whitespace removal candidates for next edit descending\n\t\t\tnewTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n\n\t\t\ttrimAutoWhitespaceLineNumbers = [];\n\t\t\tfor (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n\t\t\t\tlet lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n\t\t\t\tif (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n\t\t\t\t\t// Do not have the same line number twice\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n\t\t\t\tlet lineContent = this.getLineContent(lineNumber);\n\n\t\t\t\tif (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttrimAutoWhitespaceLineNumbers.push(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\treturn new ApplyEditsResult(\n\t\t\treverseOperations,\n\t\t\tcontentChanges,\n\t\t\ttrimAutoWhitespaceLineNumbers\n\t\t);\n\t}\n\n\t/**\n\t * Transform operations such that they represent the same logic edit,\n\t * but that they also do not cause OOM crashes.\n\t */\n\tprivate _reduceOperations(operations: IValidatedEditOperation[]): IValidatedEditOperation[] {\n\t\tif (operations.length < 1000) {\n\t\t\t// We know from empirical testing that a thousand edits work fine regardless of their shape.\n\t\t\treturn operations;\n\t\t}\n\n\t\t// At one point, due to how events are emitted and how each operation is handled,\n\t\t// some operations can trigger a high amount of temporary string allocations,\n\t\t// that will immediately get edited again.\n\t\t// e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n\t\t// Therefore, the strategy is to collapse all the operations into a huge single edit operation\n\t\treturn [this._toSingleEditOperation(operations)];\n\t}\n\n\t_toSingleEditOperation(operations: IValidatedEditOperation[]): IValidatedEditOperation {\n\t\tlet forceMoveMarkers = false,\n\t\t\tfirstEditRange = operations[0].range,\n\t\t\tlastEditRange = operations[operations.length - 1].range,\n\t\t\tentireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn),\n\t\t\tlastEndLineNumber = firstEditRange.startLineNumber,\n\t\t\tlastEndColumn = firstEditRange.startColumn,\n\t\t\tresult: string[] = [];\n\n\t\tfor (let i = 0, len = operations.length; i < len; i++) {\n\t\t\tlet operation = operations[i],\n\t\t\t\trange = operation.range;\n\n\t\t\tforceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n\n\t\t\t// (1) -- Push old text\n\t\t\tfor (let lineNumber = lastEndLineNumber; lineNumber < range.startLineNumber; lineNumber++) {\n\t\t\t\tif (lineNumber === lastEndLineNumber) {\n\t\t\t\t\tresult.push(this.getLineContent(lineNumber).substring(lastEndColumn - 1));\n\t\t\t\t} else {\n\t\t\t\t\tresult.push('\\n');\n\t\t\t\t\tresult.push(this.getLineContent(lineNumber));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (range.startLineNumber === lastEndLineNumber) {\n\t\t\t\tresult.push(this.getLineContent(range.startLineNumber).substring(lastEndColumn - 1, range.startColumn - 1));\n\t\t\t} else {\n\t\t\t\tresult.push('\\n');\n\t\t\t\tresult.push(this.getLineContent(range.startLineNumber).substring(0, range.startColumn - 1));\n\t\t\t}\n\n\t\t\t// (2) -- Push new text\n\t\t\tif (operation.lines) {\n\t\t\t\tfor (let j = 0, lenJ = operation.lines.length; j < lenJ; j++) {\n\t\t\t\t\tif (j !== 0) {\n\t\t\t\t\t\tresult.push('\\n');\n\t\t\t\t\t}\n\t\t\t\t\tresult.push(operation.lines[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlastEndLineNumber = operation.range.endLineNumber;\n\t\t\tlastEndColumn = operation.range.endColumn;\n\t\t}\n\n\t\treturn {\n\t\t\tsortIndex: 0,\n\t\t\tidentifier: operations[0].identifier,\n\t\t\trange: entireEditRange,\n\t\t\trangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n\t\t\trangeLength: this.getValueLengthInRange(entireEditRange, EndOfLinePreference.TextDefined),\n\t\t\tlines: result.join('').split('\\n'),\n\t\t\tforceMoveMarkers: forceMoveMarkers,\n\t\t\tisAutoWhitespaceEdit: false\n\t\t};\n\t}\n\n\tprivate _doApplyEdits(operations: IValidatedEditOperation[]): IInternalModelContentChange[] {\n\t\toperations.sort(PieceTreeTextBuffer._sortOpsDescending);\n\n\t\tlet contentChanges: IInternalModelContentChange[] = [];\n\n\t\t// operations are from bottom to top\n\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\tlet op = operations[i];\n\n\t\t\tconst startLineNumber = op.range.startLineNumber;\n\t\t\tconst startColumn = op.range.startColumn;\n\t\t\tconst endLineNumber = op.range.endLineNumber;\n\t\t\tconst endColumn = op.range.endColumn;\n\n\t\t\tif (startLineNumber === endLineNumber && startColumn === endColumn && (!op.lines || op.lines.length === 0)) {\n\t\t\t\t// no-op\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst deletingLinesCnt = endLineNumber - startLineNumber;\n\t\t\tconst insertingLinesCnt = (op.lines ? op.lines.length - 1 : 0);\n\t\t\tconst editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n\n\t\t\tconst text = (op.lines ? op.lines.join(this.getEOL()) : '');\n\n\t\t\tif (text) {\n\t\t\t\t// replacement\n\t\t\t\tthis._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\t\t\t\tthis._pieceTree.insert(op.rangeOffset, text, true);\n\n\t\t\t} else {\n\t\t\t\t// deletion\n\t\t\t\tthis._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\t\t\t}\n\n\t\t\tif (editingLinesCnt < insertingLinesCnt) {\n\t\t\t\tlet newLinesContent: string[] = [];\n\t\t\t\tfor (let j = editingLinesCnt + 1; j <= insertingLinesCnt; j++) {\n\t\t\t\t\tnewLinesContent.push(op.lines![j]);\n\t\t\t\t}\n\n\t\t\t\tnewLinesContent[newLinesContent.length - 1] = this.getLineContent(startLineNumber + insertingLinesCnt - 1);\n\t\t\t}\n\n\t\t\tconst contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t\t\tcontentChanges.push({\n\t\t\t\trange: contentChangeRange,\n\t\t\t\trangeLength: op.rangeLength,\n\t\t\t\ttext: text,\n\t\t\t\trangeOffset: op.rangeOffset,\n\t\t\t\tforceMoveMarkers: op.forceMoveMarkers\n\t\t\t});\n\t\t}\n\t\treturn contentChanges;\n\t}\n\n\tfindMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\treturn this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n\t}\n\n\t// #endregion\n\n\t// #region helper\n\t// testing purpose.\n\tpublic getPieceTree(): PieceTreeBase {\n\t\treturn this._pieceTree;\n\t}\n\t/**\n\t * Assumes `operations` are validated and sorted ascending\n\t */\n\tpublic static _getInverseEditRanges(operations: IValidatedEditOperation[]): Range[] {\n\t\tlet result: Range[] = [];\n\n\t\tlet prevOpEndLineNumber: number = 0;\n\t\tlet prevOpEndColumn: number = 0;\n\t\tlet prevOp: IValidatedEditOperation | null = null;\n\t\tfor (let i = 0, len = operations.length; i < len; i++) {\n\t\t\tlet op = operations[i];\n\n\t\t\tlet startLineNumber: number;\n\t\t\tlet startColumn: number;\n\n\t\t\tif (prevOp) {\n\t\t\t\tif (prevOp.range.endLineNumber === op.range.startLineNumber) {\n\t\t\t\t\tstartLineNumber = prevOpEndLineNumber;\n\t\t\t\t\tstartColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n\t\t\t\t} else {\n\t\t\t\t\tstartLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n\t\t\t\t\tstartColumn = op.range.startColumn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstartLineNumber = op.range.startLineNumber;\n\t\t\t\tstartColumn = op.range.startColumn;\n\t\t\t}\n\n\t\t\tlet resultRange: Range;\n\n\t\t\tif (op.lines && op.lines.length > 0) {\n\t\t\t\t// the operation inserts something\n\t\t\t\tlet lineCount = op.lines.length;\n\t\t\t\tlet firstLine = op.lines[0];\n\t\t\t\tlet lastLine = op.lines[lineCount - 1];\n\n\t\t\t\tif (lineCount === 1) {\n\t\t\t\t\t// single line insert\n\t\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + firstLine.length);\n\t\t\t\t} else {\n\t\t\t\t\t// multi line insert\n\t\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLine.length + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// There is nothing to insert\n\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n\t\t\t}\n\n\t\t\tprevOpEndLineNumber = resultRange.endLineNumber;\n\t\t\tprevOpEndColumn = resultRange.endColumn;\n\n\t\t\tresult.push(resultRange);\n\t\t\tprevOp = op;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _sortOpsAscending(a: IValidatedEditOperation, b: IValidatedEditOperation): number {\n\t\tlet r = Range.compareRangesUsingEnds(a.range, b.range);\n\t\tif (r === 0) {\n\t\t\treturn a.sortIndex - b.sortIndex;\n\t\t}\n\t\treturn r;\n\t}\n\n\tprivate static _sortOpsDescending(a: IValidatedEditOperation, b: IValidatedEditOperation): number {\n\t\tlet r = Range.compareRangesUsingEnds(a.range, b.range);\n\t\tif (r === 0) {\n\t\t\treturn b.sortIndex - a.sortIndex;\n\t\t}\n\t\treturn -r;\n\t}\n\t// #endregion\n}\n"]}]}