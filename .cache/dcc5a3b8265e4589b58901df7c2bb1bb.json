{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/common/problemCollectors.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/common/problemCollectors.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/uri\", \"vs/base/common/event\", \"vs/workbench/contrib/tasks/common/problemMatcher\", \"vs/platform/markers/common/markers\", \"vs/base/common/uuid\"], function (require, exports, uri_1, event_1, problemMatcher_1, markers_1, uuid_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var ProblemCollectorEventKind;\n    (function (ProblemCollectorEventKind) {\n        ProblemCollectorEventKind[\"BackgroundProcessingBegins\"] = \"backgroundProcessingBegins\";\n        ProblemCollectorEventKind[\"BackgroundProcessingEnds\"] = \"backgroundProcessingEnds\";\n    })(ProblemCollectorEventKind = exports.ProblemCollectorEventKind || (exports.ProblemCollectorEventKind = {}));\n    var ProblemCollectorEvent;\n    (function (ProblemCollectorEvent) {\n        function create(kind) {\n            return Object.freeze({ kind });\n        }\n        ProblemCollectorEvent.create = create;\n    })(ProblemCollectorEvent || (ProblemCollectorEvent = {}));\n    class AbstractProblemCollector {\n        constructor(problemMatchers, markerService, modelService) {\n            this.markerService = markerService;\n            this.modelService = modelService;\n            this.matchers = Object.create(null);\n            this.bufferLength = 1;\n            problemMatchers.map(elem => problemMatcher_1.createLineMatcher(elem)).forEach((matcher) => {\n                let length = matcher.matchLength;\n                if (length > this.bufferLength) {\n                    this.bufferLength = length;\n                }\n                let value = this.matchers[length];\n                if (!value) {\n                    value = [];\n                    this.matchers[length] = value;\n                }\n                value.push(matcher);\n            });\n            this.buffer = [];\n            this.activeMatcher = null;\n            this._numberOfMatches = 0;\n            this._maxMarkerSeverity = undefined;\n            this.openModels = Object.create(null);\n            this.modelListeners = [];\n            this.applyToByOwner = new Map();\n            for (let problemMatcher of problemMatchers) {\n                let current = this.applyToByOwner.get(problemMatcher.owner);\n                if (current === undefined) {\n                    this.applyToByOwner.set(problemMatcher.owner, problemMatcher.applyTo);\n                }\n                else {\n                    this.applyToByOwner.set(problemMatcher.owner, this.mergeApplyTo(current, problemMatcher.applyTo));\n                }\n            }\n            this.resourcesToClean = new Map();\n            this.markers = new Map();\n            this.deliveredMarkers = new Map();\n            this.modelService.onModelAdded((model) => {\n                this.openModels[model.uri.toString()] = true;\n            }, this, this.modelListeners);\n            this.modelService.onModelRemoved((model) => {\n                delete this.openModels[model.uri.toString()];\n            }, this, this.modelListeners);\n            this.modelService.getModels().forEach(model => this.openModels[model.uri.toString()] = true);\n            this._onDidStateChange = new event_1.Emitter();\n        }\n        get onDidStateChange() {\n            return this._onDidStateChange.event;\n        }\n        dispose() {\n            this.modelListeners.forEach(disposable => disposable.dispose());\n        }\n        get numberOfMatches() {\n            return this._numberOfMatches;\n        }\n        get maxMarkerSeverity() {\n            return this._maxMarkerSeverity;\n        }\n        tryFindMarker(line) {\n            let result = null;\n            if (this.activeMatcher) {\n                result = this.activeMatcher.next(line);\n                if (result) {\n                    this.captureMatch(result);\n                    return result;\n                }\n                this.clearBuffer();\n                this.activeMatcher = null;\n            }\n            if (this.buffer.length < this.bufferLength) {\n                this.buffer.push(line);\n            }\n            else {\n                let end = this.buffer.length - 1;\n                for (let i = 0; i < end; i++) {\n                    this.buffer[i] = this.buffer[i + 1];\n                }\n                this.buffer[end] = line;\n            }\n            result = this.tryMatchers();\n            if (result) {\n                this.clearBuffer();\n            }\n            return result;\n        }\n        shouldApplyMatch(result) {\n            switch (result.description.applyTo) {\n                case problemMatcher_1.ApplyToKind.allDocuments:\n                    return true;\n                case problemMatcher_1.ApplyToKind.openDocuments:\n                    return !!this.openModels[result.resource.toString()];\n                case problemMatcher_1.ApplyToKind.closedDocuments:\n                    return !this.openModels[result.resource.toString()];\n                default:\n                    return true;\n            }\n        }\n        mergeApplyTo(current, value) {\n            if (current === value || current === problemMatcher_1.ApplyToKind.allDocuments) {\n                return current;\n            }\n            return problemMatcher_1.ApplyToKind.allDocuments;\n        }\n        tryMatchers() {\n            this.activeMatcher = null;\n            let length = this.buffer.length;\n            for (let startIndex = 0; startIndex < length; startIndex++) {\n                let candidates = this.matchers[length - startIndex];\n                if (!candidates) {\n                    continue;\n                }\n                for (const matcher of candidates) {\n                    let result = matcher.handle(this.buffer, startIndex);\n                    if (result.match) {\n                        this.captureMatch(result.match);\n                        if (result.continue) {\n                            this.activeMatcher = matcher;\n                        }\n                        return result.match;\n                    }\n                }\n            }\n            return null;\n        }\n        captureMatch(match) {\n            this._numberOfMatches++;\n            if (this._maxMarkerSeverity === undefined || match.marker.severity > this._maxMarkerSeverity) {\n                this._maxMarkerSeverity = match.marker.severity;\n            }\n        }\n        clearBuffer() {\n            if (this.buffer.length > 0) {\n                this.buffer = [];\n            }\n        }\n        recordResourcesToClean(owner) {\n            let resourceSetToClean = this.getResourceSetToClean(owner);\n            this.markerService.read({ owner: owner }).forEach(marker => resourceSetToClean.set(marker.resource.toString(), marker.resource));\n        }\n        recordResourceToClean(owner, resource) {\n            this.getResourceSetToClean(owner).set(resource.toString(), resource);\n        }\n        removeResourceToClean(owner, resource) {\n            let resourceSet = this.resourcesToClean.get(owner);\n            if (resourceSet) {\n                resourceSet.delete(resource);\n            }\n        }\n        getResourceSetToClean(owner) {\n            let result = this.resourcesToClean.get(owner);\n            if (!result) {\n                result = new Map();\n                this.resourcesToClean.set(owner, result);\n            }\n            return result;\n        }\n        cleanAllMarkers() {\n            this.resourcesToClean.forEach((value, owner) => {\n                this._cleanMarkers(owner, value);\n            });\n            this.resourcesToClean = new Map();\n        }\n        cleanMarkers(owner) {\n            let toClean = this.resourcesToClean.get(owner);\n            if (toClean) {\n                this._cleanMarkers(owner, toClean);\n                this.resourcesToClean.delete(owner);\n            }\n        }\n        _cleanMarkers(owner, toClean) {\n            let uris = [];\n            let applyTo = this.applyToByOwner.get(owner);\n            toClean.forEach((uri, uriAsString) => {\n                if (applyTo === problemMatcher_1.ApplyToKind.allDocuments ||\n                    (applyTo === problemMatcher_1.ApplyToKind.openDocuments && this.openModels[uriAsString]) ||\n                    (applyTo === problemMatcher_1.ApplyToKind.closedDocuments && !this.openModels[uriAsString])) {\n                    uris.push(uri);\n                }\n            });\n            this.markerService.remove(owner, uris);\n        }\n        recordMarker(marker, owner, resourceAsString) {\n            let markersPerOwner = this.markers.get(owner);\n            if (!markersPerOwner) {\n                markersPerOwner = new Map();\n                this.markers.set(owner, markersPerOwner);\n            }\n            let markersPerResource = markersPerOwner.get(resourceAsString);\n            if (!markersPerResource) {\n                markersPerResource = new Map();\n                markersPerOwner.set(resourceAsString, markersPerResource);\n            }\n            let key = markers_1.IMarkerData.makeKey(marker);\n            if (!markersPerResource.has(key)) {\n                markersPerResource.set(key, marker);\n            }\n        }\n        reportMarkers() {\n            this.markers.forEach((markersPerOwner, owner) => {\n                let develieredMarkersPerOwner = this.getDeliveredMarkersPerOwner(owner);\n                markersPerOwner.forEach((markers, resource) => {\n                    this.deliverMarkersPerOwnerAndResourceResolved(owner, resource, markers, develieredMarkersPerOwner);\n                });\n            });\n        }\n        deliverMarkersPerOwnerAndResource(owner, resource) {\n            let markersPerOwner = this.markers.get(owner);\n            if (!markersPerOwner) {\n                return;\n            }\n            let deliveredMarkersPerOwner = this.getDeliveredMarkersPerOwner(owner);\n            let markersPerResource = markersPerOwner.get(resource);\n            if (!markersPerResource) {\n                return;\n            }\n            this.deliverMarkersPerOwnerAndResourceResolved(owner, resource, markersPerResource, deliveredMarkersPerOwner);\n        }\n        deliverMarkersPerOwnerAndResourceResolved(owner, resource, markers, reported) {\n            if (markers.size !== reported.get(resource)) {\n                let toSet = [];\n                markers.forEach(value => toSet.push(value));\n                this.markerService.changeOne(owner, uri_1.URI.parse(resource), toSet);\n                reported.set(resource, markers.size);\n            }\n        }\n        getDeliveredMarkersPerOwner(owner) {\n            let result = this.deliveredMarkers.get(owner);\n            if (!result) {\n                result = new Map();\n                this.deliveredMarkers.set(owner, result);\n            }\n            return result;\n        }\n        cleanMarkerCaches() {\n            this._numberOfMatches = 0;\n            this._maxMarkerSeverity = undefined;\n            this.markers.clear();\n            this.deliveredMarkers.clear();\n        }\n        done() {\n            this.reportMarkers();\n            this.cleanAllMarkers();\n        }\n    }\n    exports.AbstractProblemCollector = AbstractProblemCollector;\n    var ProblemHandlingStrategy;\n    (function (ProblemHandlingStrategy) {\n        ProblemHandlingStrategy[ProblemHandlingStrategy[\"Clean\"] = 0] = \"Clean\";\n    })(ProblemHandlingStrategy = exports.ProblemHandlingStrategy || (exports.ProblemHandlingStrategy = {}));\n    class StartStopProblemCollector extends AbstractProblemCollector {\n        constructor(problemMatchers, markerService, modelService, _strategy = ProblemHandlingStrategy.Clean) {\n            super(problemMatchers, markerService, modelService);\n            let ownerSet = Object.create(null);\n            problemMatchers.forEach(description => ownerSet[description.owner] = true);\n            this.owners = Object.keys(ownerSet);\n            this.owners.forEach((owner) => {\n                this.recordResourcesToClean(owner);\n            });\n        }\n        processLine(line) {\n            let markerMatch = this.tryFindMarker(line);\n            if (!markerMatch) {\n                return;\n            }\n            let owner = markerMatch.description.owner;\n            let resource = markerMatch.resource;\n            let resourceAsString = resource.toString();\n            this.removeResourceToClean(owner, resourceAsString);\n            let shouldApplyMatch = this.shouldApplyMatch(markerMatch);\n            if (shouldApplyMatch) {\n                this.recordMarker(markerMatch.marker, owner, resourceAsString);\n                if (this.currentOwner !== owner || this.currentResource !== resourceAsString) {\n                    if (this.currentOwner && this.currentResource) {\n                        this.deliverMarkersPerOwnerAndResource(this.currentOwner, this.currentResource);\n                    }\n                    this.currentOwner = owner;\n                    this.currentResource = resourceAsString;\n                }\n            }\n        }\n    }\n    exports.StartStopProblemCollector = StartStopProblemCollector;\n    class WatchingProblemCollector extends AbstractProblemCollector {\n        constructor(problemMatchers, markerService, modelService) {\n            super(problemMatchers, markerService, modelService);\n            this.problemMatchers = problemMatchers;\n            this.resetCurrentResource();\n            this.backgroundPatterns = [];\n            this._activeBackgroundMatchers = new Set();\n            this.problemMatchers.forEach(matcher => {\n                if (matcher.watching) {\n                    const key = uuid_1.generateUuid();\n                    this.backgroundPatterns.push({\n                        key,\n                        matcher: matcher,\n                        begin: matcher.watching.beginsPattern,\n                        end: matcher.watching.endsPattern\n                    });\n                }\n            });\n        }\n        aboutToStart() {\n            for (let background of this.backgroundPatterns) {\n                if (background.matcher.watching && background.matcher.watching.activeOnStart) {\n                    this._activeBackgroundMatchers.add(background.key);\n                    this._onDidStateChange.fire(ProblemCollectorEvent.create(ProblemCollectorEventKind.BackgroundProcessingBegins));\n                    this.recordResourcesToClean(background.matcher.owner);\n                }\n            }\n        }\n        processLine(line) {\n            if (this.tryBegin(line) || this.tryFinish(line)) {\n                return;\n            }\n            let markerMatch = this.tryFindMarker(line);\n            if (!markerMatch) {\n                return;\n            }\n            let resource = markerMatch.resource;\n            let owner = markerMatch.description.owner;\n            let resourceAsString = resource.toString();\n            this.removeResourceToClean(owner, resourceAsString);\n            let shouldApplyMatch = this.shouldApplyMatch(markerMatch);\n            if (shouldApplyMatch) {\n                this.recordMarker(markerMatch.marker, owner, resourceAsString);\n                if (this.currentOwner !== owner || this.currentResource !== resourceAsString) {\n                    this.reportMarkersForCurrentResource();\n                    this.currentOwner = owner;\n                    this.currentResource = resourceAsString;\n                }\n            }\n        }\n        forceDelivery() {\n            this.reportMarkersForCurrentResource();\n        }\n        tryBegin(line) {\n            let result = false;\n            for (const background of this.backgroundPatterns) {\n                let matches = background.begin.regexp.exec(line);\n                if (matches) {\n                    if (this._activeBackgroundMatchers.has(background.key)) {\n                        continue;\n                    }\n                    this._activeBackgroundMatchers.add(background.key);\n                    result = true;\n                    this._onDidStateChange.fire(ProblemCollectorEvent.create(ProblemCollectorEventKind.BackgroundProcessingBegins));\n                    this.cleanMarkerCaches();\n                    this.resetCurrentResource();\n                    let owner = background.matcher.owner;\n                    let file = matches[background.begin.file];\n                    if (file) {\n                        let resource = problemMatcher_1.getResource(file, background.matcher);\n                        this.recordResourceToClean(owner, resource);\n                    }\n                    else {\n                        this.recordResourcesToClean(owner);\n                    }\n                }\n            }\n            return result;\n        }\n        tryFinish(line) {\n            let result = false;\n            for (const background of this.backgroundPatterns) {\n                let matches = background.end.regexp.exec(line);\n                if (matches) {\n                    if (this._activeBackgroundMatchers.has(background.key)) {\n                        this._activeBackgroundMatchers.delete(background.key);\n                        this.resetCurrentResource();\n                        this._onDidStateChange.fire(ProblemCollectorEvent.create(ProblemCollectorEventKind.BackgroundProcessingEnds));\n                        result = true;\n                        let owner = background.matcher.owner;\n                        this.cleanMarkers(owner);\n                        this.cleanMarkerCaches();\n                    }\n                }\n            }\n            return result;\n        }\n        resetCurrentResource() {\n            this.reportMarkersForCurrentResource();\n            this.currentOwner = null;\n            this.currentResource = null;\n        }\n        reportMarkersForCurrentResource() {\n            if (this.currentOwner && this.currentResource) {\n                this.deliverMarkersPerOwnerAndResource(this.currentOwner, this.currentResource);\n            }\n        }\n    }\n    exports.WatchingProblemCollector = WatchingProblemCollector;\n});\n",null]}