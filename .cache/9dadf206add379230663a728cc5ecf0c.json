{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/windows/node/windowsIpc.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/windows/node/windowsIpc.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/event\", \"vs/platform/workspaces/common/workspaces\", \"vs/base/common/uri\", \"vs/platform/history/common/history\"], function (require, exports, event_1, workspaces_1, uri_1, history_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class WindowsChannel {\n        constructor(service) {\n            this.service = service;\n            this.onWindowOpen = event_1.Event.buffer(service.onWindowOpen, true);\n            this.onWindowFocus = event_1.Event.buffer(service.onWindowFocus, true);\n            this.onWindowBlur = event_1.Event.buffer(service.onWindowBlur, true);\n            this.onWindowMaximize = event_1.Event.buffer(service.onWindowMaximize, true);\n            this.onWindowUnmaximize = event_1.Event.buffer(service.onWindowUnmaximize, true);\n            this.onRecentlyOpenedChange = event_1.Event.buffer(service.onRecentlyOpenedChange, true);\n        }\n        listen(_, event) {\n            switch (event) {\n                case 'onWindowOpen': return this.onWindowOpen;\n                case 'onWindowFocus': return this.onWindowFocus;\n                case 'onWindowBlur': return this.onWindowBlur;\n                case 'onWindowMaximize': return this.onWindowMaximize;\n                case 'onWindowUnmaximize': return this.onWindowUnmaximize;\n                case 'onRecentlyOpenedChange': return this.onRecentlyOpenedChange;\n            }\n            throw new Error(`Event not found: ${event}`);\n        }\n        call(_, command, arg) {\n            switch (command) {\n                case 'pickFileFolderAndOpen': return this.service.pickFileFolderAndOpen(arg);\n                case 'pickFileAndOpen': return this.service.pickFileAndOpen(arg);\n                case 'pickFolderAndOpen': return this.service.pickFolderAndOpen(arg);\n                case 'pickWorkspaceAndOpen': return this.service.pickWorkspaceAndOpen(arg);\n                case 'showMessageBox': return this.service.showMessageBox(arg[0], arg[1]);\n                case 'showSaveDialog': return this.service.showSaveDialog(arg[0], arg[1]);\n                case 'showOpenDialog': return this.service.showOpenDialog(arg[0], arg[1]);\n                case 'reloadWindow': return this.service.reloadWindow(arg[0], arg[1]);\n                case 'openDevTools': return this.service.openDevTools(arg[0], arg[1]);\n                case 'toggleDevTools': return this.service.toggleDevTools(arg);\n                case 'closeWorkspace': return this.service.closeWorkspace(arg);\n                case 'enterWorkspace': return this.service.enterWorkspace(arg[0], uri_1.URI.revive(arg[1]));\n                case 'toggleFullScreen': return this.service.toggleFullScreen(arg);\n                case 'setRepresentedFilename': return this.service.setRepresentedFilename(arg[0], arg[1]);\n                case 'addRecentlyOpened': return this.service.addRecentlyOpened(arg.map((recent) => {\n                    if (history_1.isRecentFile(recent)) {\n                        recent.fileUri = uri_1.URI.revive(recent.fileUri);\n                    }\n                    else if (history_1.isRecentFolder(recent)) {\n                        recent.folderUri = uri_1.URI.revive(recent.folderUri);\n                    }\n                    else {\n                        recent.workspace = workspaces_1.reviveWorkspaceIdentifier(recent.workspace);\n                    }\n                    return recent;\n                }));\n                case 'removeFromRecentlyOpened': return this.service.removeFromRecentlyOpened(arg.map(uri_1.URI.revive));\n                case 'clearRecentlyOpened': return this.service.clearRecentlyOpened();\n                case 'newWindowTab': return this.service.newWindowTab();\n                case 'showPreviousWindowTab': return this.service.showPreviousWindowTab();\n                case 'showNextWindowTab': return this.service.showNextWindowTab();\n                case 'moveWindowTabToNewWindow': return this.service.moveWindowTabToNewWindow();\n                case 'mergeAllWindowTabs': return this.service.mergeAllWindowTabs();\n                case 'toggleWindowTabsBar': return this.service.toggleWindowTabsBar();\n                case 'updateTouchBar': return this.service.updateTouchBar(arg[0], arg[1]);\n                case 'getRecentlyOpened': return this.service.getRecentlyOpened(arg);\n                case 'focusWindow': return this.service.focusWindow(arg);\n                case 'closeWindow': return this.service.closeWindow(arg);\n                case 'isFocused': return this.service.isFocused(arg);\n                case 'isMaximized': return this.service.isMaximized(arg);\n                case 'maximizeWindow': return this.service.maximizeWindow(arg);\n                case 'unmaximizeWindow': return this.service.unmaximizeWindow(arg);\n                case 'minimizeWindow': return this.service.minimizeWindow(arg);\n                case 'onWindowTitleDoubleClick': return this.service.onWindowTitleDoubleClick(arg);\n                case 'setDocumentEdited': return this.service.setDocumentEdited(arg[0], arg[1]);\n                case 'openWindow': {\n                    const urisToOpen = arg[1];\n                    const options = arg[2];\n                    urisToOpen.forEach(r => { r.uri = uri_1.URI.revive(r.uri); return r; });\n                    options.waitMarkerFileURI = options.waitMarkerFileURI && uri_1.URI.revive(options.waitMarkerFileURI);\n                    return this.service.openWindow(arg[0], urisToOpen, options);\n                }\n                case 'openNewWindow': return this.service.openNewWindow(arg);\n                case 'getWindows': return this.service.getWindows();\n                case 'getWindowCount': return this.service.getWindowCount();\n                case 'relaunch': return this.service.relaunch(arg[0]);\n                case 'whenSharedProcessReady': return this.service.whenSharedProcessReady();\n                case 'toggleSharedProcess': return this.service.toggleSharedProcess();\n                case 'quit': return this.service.quit();\n                case 'log': return this.service.log(arg[0], arg[1]);\n                case 'showItemInFolder': return this.service.showItemInFolder(uri_1.URI.revive(arg));\n                case 'getActiveWindowId': return this.service.getActiveWindowId();\n                case 'openExternal': return this.service.openExternal(arg);\n                case 'startCrashReporter': return this.service.startCrashReporter(arg);\n                case 'openAboutDialog': return this.service.openAboutDialog();\n                case 'resolveProxy': return this.service.resolveProxy(arg[0], arg[1]);\n            }\n            throw new Error(`Call not found: ${command}`);\n        }\n    }\n    exports.WindowsChannel = WindowsChannel;\n});\n",null]}