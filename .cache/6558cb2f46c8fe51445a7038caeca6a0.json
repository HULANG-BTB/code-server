{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/preferences/common/preferencesModels.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/preferences/common/preferencesModels.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/arrays\", \"vs/base/common/event\", \"vs/base/common/json\", \"vs/base/common/lifecycle\", \"vs/base/common/map\", \"vs/base/common/objects\", \"vs/editor/common/core/range\", \"vs/editor/common/core/selection\", \"vs/nls\", \"vs/platform/configuration/common/configuration\", \"vs/platform/configuration/common/configurationRegistry\", \"vs/platform/keybinding/common/keybinding\", \"vs/platform/registry/common/platform\", \"vs/workbench/common/editor\", \"vs/base/common/types\"], function (require, exports, arrays_1, event_1, json_1, lifecycle_1, map, objects_1, range_1, selection_1, nls, configuration_1, configurationRegistry_1, keybinding_1, platform_1, editor_1, types_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.nullRange = { startLineNumber: -1, startColumn: -1, endLineNumber: -1, endColumn: -1 };\n    function isNullRange(range) { return range.startLineNumber === -1 && range.startColumn === -1 && range.endLineNumber === -1 && range.endColumn === -1; }\n    exports.isNullRange = isNullRange;\n    class AbstractSettingsModel extends editor_1.EditorModel {\n        constructor() {\n            super(...arguments);\n            this._currentResultGroups = new Map();\n        }\n        updateResultGroup(id, resultGroup) {\n            if (resultGroup) {\n                this._currentResultGroups.set(id, resultGroup);\n            }\n            else {\n                this._currentResultGroups.delete(id);\n            }\n            this.removeDuplicateResults();\n            return this.update();\n        }\n        /**\n         * Remove duplicates between result groups, preferring results in earlier groups\n         */\n        removeDuplicateResults() {\n            const settingKeys = new Set();\n            map.keys(this._currentResultGroups)\n                .sort((a, b) => this._currentResultGroups.get(a).order - this._currentResultGroups.get(b).order)\n                .forEach(groupId => {\n                const group = this._currentResultGroups.get(groupId);\n                group.result.filterMatches = group.result.filterMatches.filter(s => !settingKeys.has(s.setting.key));\n                group.result.filterMatches.forEach(s => settingKeys.add(s.setting.key));\n            });\n        }\n        filterSettings(filter, groupFilter, settingMatcher) {\n            const allGroups = this.filterGroups;\n            const filterMatches = [];\n            for (const group of allGroups) {\n                const groupMatched = groupFilter(group);\n                for (const section of group.sections) {\n                    for (const setting of section.settings) {\n                        const settingMatchResult = settingMatcher(setting, group);\n                        if (groupMatched || settingMatchResult) {\n                            filterMatches.push({\n                                setting,\n                                matches: settingMatchResult && settingMatchResult.matches,\n                                score: settingMatchResult ? settingMatchResult.score : 0\n                            });\n                        }\n                    }\n                }\n            }\n            return filterMatches.sort((a, b) => b.score - a.score);\n        }\n        getPreference(key) {\n            for (const group of this.settingsGroups) {\n                for (const section of group.sections) {\n                    for (const setting of section.settings) {\n                        if (key === setting.key) {\n                            return setting;\n                        }\n                    }\n                }\n            }\n            return undefined;\n        }\n        collectMetadata(groups) {\n            const metadata = Object.create(null);\n            let hasMetadata = false;\n            groups.forEach(g => {\n                if (g.result.metadata) {\n                    metadata[g.id] = g.result.metadata;\n                    hasMetadata = true;\n                }\n            });\n            return hasMetadata ? metadata : null;\n        }\n        get filterGroups() {\n            return this.settingsGroups;\n        }\n    }\n    exports.AbstractSettingsModel = AbstractSettingsModel;\n    class SettingsEditorModel extends AbstractSettingsModel {\n        constructor(reference, _configurationTarget) {\n            super();\n            this._configurationTarget = _configurationTarget;\n            this._onDidChangeGroups = this._register(new event_1.Emitter());\n            this.onDidChangeGroups = this._onDidChangeGroups.event;\n            this.settingsModel = reference.object.textEditorModel;\n            this._register(this.onDispose(() => reference.dispose()));\n            this._register(this.settingsModel.onDidChangeContent(() => {\n                this._settingsGroups = undefined;\n                this._onDidChangeGroups.fire();\n            }));\n        }\n        get uri() {\n            return this.settingsModel.uri;\n        }\n        get configurationTarget() {\n            return this._configurationTarget;\n        }\n        get settingsGroups() {\n            if (!this._settingsGroups) {\n                this.parse();\n            }\n            return this._settingsGroups;\n        }\n        get content() {\n            return this.settingsModel.getValue();\n        }\n        findValueMatches(filter, setting) {\n            return this.settingsModel.findMatches(filter, setting.valueRange, false, false, null, false).map(match => match.range);\n        }\n        isSettingsProperty(property, previousParents) {\n            return previousParents.length === 0; // Settings is root\n        }\n        parse() {\n            this._settingsGroups = parse(this.settingsModel, (property, previousParents) => this.isSettingsProperty(property, previousParents));\n        }\n        update() {\n            const resultGroups = map.values(this._currentResultGroups);\n            if (!resultGroups.length) {\n                return undefined;\n            }\n            // Transform resultGroups into IFilterResult - ISetting ranges are already correct here\n            const filteredSettings = [];\n            const matches = [];\n            resultGroups.forEach(group => {\n                group.result.filterMatches.forEach(filterMatch => {\n                    filteredSettings.push(filterMatch.setting);\n                    if (filterMatch.matches) {\n                        matches.push(...filterMatch.matches);\n                    }\n                });\n            });\n            let filteredGroup;\n            const modelGroup = this.settingsGroups[0]; // Editable model has one or zero groups\n            if (modelGroup) {\n                filteredGroup = {\n                    id: modelGroup.id,\n                    range: modelGroup.range,\n                    sections: [{\n                            settings: filteredSettings\n                        }],\n                    title: modelGroup.title,\n                    titleRange: modelGroup.titleRange,\n                    contributedByExtension: !!modelGroup.contributedByExtension\n                };\n            }\n            const metadata = this.collectMetadata(resultGroups);\n            return {\n                allGroups: this.settingsGroups,\n                filteredGroups: filteredGroup ? [filteredGroup] : [],\n                matches,\n                metadata\n            };\n        }\n    }\n    exports.SettingsEditorModel = SettingsEditorModel;\n    let Settings2EditorModel = class Settings2EditorModel extends AbstractSettingsModel {\n        constructor(_defaultSettings, configurationService) {\n            super();\n            this._defaultSettings = _defaultSettings;\n            this._onDidChangeGroups = this._register(new event_1.Emitter());\n            this.onDidChangeGroups = this._onDidChangeGroups.event;\n            this.dirty = false;\n            this._register(configurationService.onDidChangeConfiguration(e => {\n                if (e.source === configuration_1.ConfigurationTarget.DEFAULT) {\n                    this.dirty = true;\n                    this._onDidChangeGroups.fire();\n                }\n            }));\n            this._register(platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).onDidSchemaChange(e => {\n                this.dirty = true;\n                this._onDidChangeGroups.fire();\n            }));\n        }\n        get filterGroups() {\n            // Don't filter \"commonly used\"\n            return this.settingsGroups.slice(1);\n        }\n        get settingsGroups() {\n            const groups = this._defaultSettings.getSettingsGroups(this.dirty);\n            this.dirty = false;\n            return groups;\n        }\n        findValueMatches(filter, setting) {\n            // TODO @roblou\n            return [];\n        }\n        update() {\n            throw new Error('Not supported');\n        }\n    };\n    Settings2EditorModel = __decorate([\n        __param(1, configuration_1.IConfigurationService)\n    ], Settings2EditorModel);\n    exports.Settings2EditorModel = Settings2EditorModel;\n    function parse(model, isSettingsProperty) {\n        const settings = [];\n        let overrideSetting = null;\n        let currentProperty = null;\n        let currentParent = [];\n        const previousParents = [];\n        let settingsPropertyIndex = -1;\n        const range = {\n            startLineNumber: 0,\n            startColumn: 0,\n            endLineNumber: 0,\n            endColumn: 0\n        };\n        function onValue(value, offset, length) {\n            if (Array.isArray(currentParent)) {\n                currentParent.push(value);\n            }\n            else if (currentProperty) {\n                currentParent[currentProperty] = value;\n            }\n            if (previousParents.length === settingsPropertyIndex + 1 || (previousParents.length === settingsPropertyIndex + 2 && overrideSetting !== null)) {\n                // settings value started\n                const setting = previousParents.length === settingsPropertyIndex + 1 ? settings[settings.length - 1] : overrideSetting.overrides[overrideSetting.overrides.length - 1];\n                if (setting) {\n                    const valueStartPosition = model.getPositionAt(offset);\n                    const valueEndPosition = model.getPositionAt(offset + length);\n                    setting.value = value;\n                    setting.valueRange = {\n                        startLineNumber: valueStartPosition.lineNumber,\n                        startColumn: valueStartPosition.column,\n                        endLineNumber: valueEndPosition.lineNumber,\n                        endColumn: valueEndPosition.column\n                    };\n                    setting.range = objects_1.assign(setting.range, {\n                        endLineNumber: valueEndPosition.lineNumber,\n                        endColumn: valueEndPosition.column\n                    });\n                }\n            }\n        }\n        const visitor = {\n            onObjectBegin: (offset, length) => {\n                if (isSettingsProperty(currentProperty, previousParents)) {\n                    // Settings started\n                    settingsPropertyIndex = previousParents.length;\n                    const position = model.getPositionAt(offset);\n                    range.startLineNumber = position.lineNumber;\n                    range.startColumn = position.column;\n                }\n                const object = {};\n                onValue(object, offset, length);\n                currentParent = object;\n                currentProperty = null;\n                previousParents.push(currentParent);\n            },\n            onObjectProperty: (name, offset, length) => {\n                currentProperty = name;\n                if (previousParents.length === settingsPropertyIndex + 1 || (previousParents.length === settingsPropertyIndex + 2 && overrideSetting !== null)) {\n                    // setting started\n                    const settingStartPosition = model.getPositionAt(offset);\n                    const setting = {\n                        description: [],\n                        descriptionIsMarkdown: false,\n                        key: name,\n                        keyRange: {\n                            startLineNumber: settingStartPosition.lineNumber,\n                            startColumn: settingStartPosition.column + 1,\n                            endLineNumber: settingStartPosition.lineNumber,\n                            endColumn: settingStartPosition.column + length\n                        },\n                        range: {\n                            startLineNumber: settingStartPosition.lineNumber,\n                            startColumn: settingStartPosition.column,\n                            endLineNumber: 0,\n                            endColumn: 0\n                        },\n                        value: null,\n                        valueRange: exports.nullRange,\n                        descriptionRanges: [],\n                        overrides: [],\n                        overrideOf: types_1.withNullAsUndefined(overrideSetting)\n                    };\n                    if (previousParents.length === settingsPropertyIndex + 1) {\n                        settings.push(setting);\n                        if (configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(name)) {\n                            overrideSetting = setting;\n                        }\n                    }\n                    else {\n                        overrideSetting.overrides.push(setting);\n                    }\n                }\n            },\n            onObjectEnd: (offset, length) => {\n                currentParent = previousParents.pop();\n                if (previousParents.length === settingsPropertyIndex + 1 || (previousParents.length === settingsPropertyIndex + 2 && overrideSetting !== null)) {\n                    // setting ended\n                    const setting = previousParents.length === settingsPropertyIndex + 1 ? settings[settings.length - 1] : overrideSetting.overrides[overrideSetting.overrides.length - 1];\n                    if (setting) {\n                        const valueEndPosition = model.getPositionAt(offset + length);\n                        setting.valueRange = objects_1.assign(setting.valueRange, {\n                            endLineNumber: valueEndPosition.lineNumber,\n                            endColumn: valueEndPosition.column\n                        });\n                        setting.range = objects_1.assign(setting.range, {\n                            endLineNumber: valueEndPosition.lineNumber,\n                            endColumn: valueEndPosition.column\n                        });\n                    }\n                    if (previousParents.length === settingsPropertyIndex + 1) {\n                        overrideSetting = null;\n                    }\n                }\n                if (previousParents.length === settingsPropertyIndex) {\n                    // settings ended\n                    const position = model.getPositionAt(offset);\n                    range.endLineNumber = position.lineNumber;\n                    range.endColumn = position.column;\n                }\n            },\n            onArrayBegin: (offset, length) => {\n                const array = [];\n                onValue(array, offset, length);\n                previousParents.push(currentParent);\n                currentParent = array;\n                currentProperty = null;\n            },\n            onArrayEnd: (offset, length) => {\n                currentParent = previousParents.pop();\n                if (previousParents.length === settingsPropertyIndex + 1 || (previousParents.length === settingsPropertyIndex + 2 && overrideSetting !== null)) {\n                    // setting value ended\n                    const setting = previousParents.length === settingsPropertyIndex + 1 ? settings[settings.length - 1] : overrideSetting.overrides[overrideSetting.overrides.length - 1];\n                    if (setting) {\n                        const valueEndPosition = model.getPositionAt(offset + length);\n                        setting.valueRange = objects_1.assign(setting.valueRange, {\n                            endLineNumber: valueEndPosition.lineNumber,\n                            endColumn: valueEndPosition.column\n                        });\n                        setting.range = objects_1.assign(setting.range, {\n                            endLineNumber: valueEndPosition.lineNumber,\n                            endColumn: valueEndPosition.column\n                        });\n                    }\n                }\n            },\n            onLiteralValue: onValue,\n            onError: (error) => {\n                const setting = settings[settings.length - 1];\n                if (setting && (isNullRange(setting.range) || isNullRange(setting.keyRange) || isNullRange(setting.valueRange))) {\n                    settings.pop();\n                }\n            }\n        };\n        if (!model.isDisposed()) {\n            json_1.visit(model.getValue(), visitor);\n        }\n        return settings.length > 0 ? [{\n                sections: [\n                    {\n                        settings\n                    }\n                ],\n                title: '',\n                titleRange: exports.nullRange,\n                range\n            }] : [];\n    }\n    class WorkspaceConfigurationEditorModel extends SettingsEditorModel {\n        get configurationGroups() {\n            return this._configurationGroups;\n        }\n        parse() {\n            super.parse();\n            this._configurationGroups = parse(this.settingsModel, (property, previousParents) => previousParents.length === 0);\n        }\n        isSettingsProperty(property, previousParents) {\n            return property === 'settings' && previousParents.length === 1;\n        }\n    }\n    exports.WorkspaceConfigurationEditorModel = WorkspaceConfigurationEditorModel;\n    class DefaultSettings extends lifecycle_1.Disposable {\n        constructor(_mostCommonlyUsedSettingsKeys, target) {\n            super();\n            this._mostCommonlyUsedSettingsKeys = _mostCommonlyUsedSettingsKeys;\n            this.target = target;\n            this._onDidChange = this._register(new event_1.Emitter());\n            this.onDidChange = this._onDidChange.event;\n        }\n        getContent(forceUpdate = false) {\n            if (!this._content || forceUpdate) {\n                this.initialize();\n            }\n            return this._content;\n        }\n        getSettingsGroups(forceUpdate = false) {\n            if (!this._allSettingsGroups || forceUpdate) {\n                this.initialize();\n            }\n            return this._allSettingsGroups;\n        }\n        initialize() {\n            this._allSettingsGroups = this.parse();\n            this._content = this.toContent(this._allSettingsGroups);\n        }\n        parse() {\n            const settingsGroups = this.getRegisteredGroups();\n            this.initAllSettingsMap(settingsGroups);\n            const mostCommonlyUsed = this.getMostCommonlyUsedSettings(settingsGroups);\n            return [mostCommonlyUsed, ...settingsGroups];\n        }\n        getRegisteredGroups() {\n            const configurations = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurations().slice();\n            const groups = this.removeEmptySettingsGroups(configurations.sort(this.compareConfigurationNodes)\n                .reduce((result, config, index, array) => this.parseConfig(config, result, array), []));\n            return this.sortGroups(groups);\n        }\n        sortGroups(groups) {\n            groups.forEach(group => {\n                group.sections.forEach(section => {\n                    section.settings.sort((a, b) => a.key.localeCompare(b.key));\n                });\n            });\n            return groups;\n        }\n        initAllSettingsMap(allSettingsGroups) {\n            this._settingsByName = new Map();\n            for (const group of allSettingsGroups) {\n                for (const section of group.sections) {\n                    for (const setting of section.settings) {\n                        this._settingsByName.set(setting.key, setting);\n                    }\n                }\n            }\n        }\n        getMostCommonlyUsedSettings(allSettingsGroups) {\n            const settings = arrays_1.coalesce(this._mostCommonlyUsedSettingsKeys.map(key => {\n                const setting = this._settingsByName.get(key);\n                if (setting) {\n                    return {\n                        description: setting.description,\n                        key: setting.key,\n                        value: setting.value,\n                        keyRange: exports.nullRange,\n                        range: exports.nullRange,\n                        valueRange: exports.nullRange,\n                        overrides: [],\n                        scope: configurationRegistry_1.ConfigurationScope.RESOURCE,\n                        type: setting.type,\n                        enum: setting.enum,\n                        enumDescriptions: setting.enumDescriptions,\n                        descriptionRanges: []\n                    };\n                }\n                return null;\n            }));\n            return {\n                id: 'mostCommonlyUsed',\n                range: exports.nullRange,\n                title: nls.localize('commonlyUsed', \"Commonly Used\"),\n                titleRange: exports.nullRange,\n                sections: [\n                    {\n                        settings\n                    }\n                ]\n            };\n        }\n        parseConfig(config, result, configurations, settingsGroup, seenSettings) {\n            seenSettings = seenSettings ? seenSettings : {};\n            let title = config.title;\n            if (!title) {\n                const configWithTitleAndSameId = arrays_1.find(configurations, c => (c.id === config.id) && c.title);\n                if (configWithTitleAndSameId) {\n                    title = configWithTitleAndSameId.title;\n                }\n            }\n            if (title) {\n                if (!settingsGroup) {\n                    settingsGroup = arrays_1.find(result, g => g.title === title);\n                    if (!settingsGroup) {\n                        settingsGroup = { sections: [{ settings: [] }], id: config.id || '', title: title || '', titleRange: exports.nullRange, range: exports.nullRange, contributedByExtension: !!config.contributedByExtension };\n                        result.push(settingsGroup);\n                    }\n                }\n                else {\n                    settingsGroup.sections[settingsGroup.sections.length - 1].title = title;\n                }\n            }\n            if (config.properties) {\n                if (!settingsGroup) {\n                    settingsGroup = { sections: [{ settings: [] }], id: config.id || '', title: config.id || '', titleRange: exports.nullRange, range: exports.nullRange, contributedByExtension: !!config.contributedByExtension };\n                    result.push(settingsGroup);\n                }\n                const configurationSettings = [];\n                for (const setting of [...settingsGroup.sections[settingsGroup.sections.length - 1].settings, ...this.parseSettings(config.properties)]) {\n                    if (!seenSettings[setting.key]) {\n                        configurationSettings.push(setting);\n                        seenSettings[setting.key] = true;\n                    }\n                }\n                if (configurationSettings.length) {\n                    settingsGroup.sections[settingsGroup.sections.length - 1].settings = configurationSettings;\n                }\n            }\n            if (config.allOf) {\n                config.allOf.forEach(c => this.parseConfig(c, result, configurations, settingsGroup, seenSettings));\n            }\n            return result;\n        }\n        removeEmptySettingsGroups(settingsGroups) {\n            const result = [];\n            for (const settingsGroup of settingsGroups) {\n                settingsGroup.sections = settingsGroup.sections.filter(section => section.settings.length > 0);\n                if (settingsGroup.sections.length) {\n                    result.push(settingsGroup);\n                }\n            }\n            return result;\n        }\n        parseSettings(settingsObject) {\n            const result = [];\n            for (const key in settingsObject) {\n                const prop = settingsObject[key];\n                if (this.matchesScope(prop)) {\n                    const value = prop.default;\n                    const description = (prop.description || prop.markdownDescription || '').split('\\n');\n                    const overrides = configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(key) ? this.parseOverrideSettings(prop.default) : [];\n                    result.push({\n                        key,\n                        value,\n                        description,\n                        descriptionIsMarkdown: !prop.description,\n                        range: exports.nullRange,\n                        keyRange: exports.nullRange,\n                        valueRange: exports.nullRange,\n                        descriptionRanges: [],\n                        overrides,\n                        scope: prop.scope,\n                        type: prop.type,\n                        enum: prop.enum,\n                        enumDescriptions: prop.enumDescriptions || prop.markdownEnumDescriptions,\n                        enumDescriptionsAreMarkdown: !prop.enumDescriptions,\n                        tags: prop.tags,\n                        deprecationMessage: prop.deprecationMessage,\n                        validator: createValidator(prop)\n                    });\n                }\n            }\n            return result;\n        }\n        parseOverrideSettings(overrideSettings) {\n            return Object.keys(overrideSettings).map((key) => ({\n                key,\n                value: overrideSettings[key],\n                description: [],\n                descriptionIsMarkdown: false,\n                range: exports.nullRange,\n                keyRange: exports.nullRange,\n                valueRange: exports.nullRange,\n                descriptionRanges: [],\n                overrides: []\n            }));\n        }\n        matchesScope(property) {\n            if (this.target === configuration_1.ConfigurationTarget.WORKSPACE_FOLDER) {\n                return property.scope === configurationRegistry_1.ConfigurationScope.RESOURCE;\n            }\n            if (this.target === configuration_1.ConfigurationTarget.WORKSPACE) {\n                return property.scope === configurationRegistry_1.ConfigurationScope.WINDOW || property.scope === configurationRegistry_1.ConfigurationScope.RESOURCE;\n            }\n            return true;\n        }\n        compareConfigurationNodes(c1, c2) {\n            if (typeof c1.order !== 'number') {\n                return 1;\n            }\n            if (typeof c2.order !== 'number') {\n                return -1;\n            }\n            if (c1.order === c2.order) {\n                const title1 = c1.title || '';\n                const title2 = c2.title || '';\n                return title1.localeCompare(title2);\n            }\n            return c1.order - c2.order;\n        }\n        toContent(settingsGroups) {\n            const builder = new SettingsContentBuilder();\n            builder.pushLine('[');\n            settingsGroups.forEach((settingsGroup, i) => {\n                builder.pushGroup(settingsGroup);\n                builder.pushLine(',');\n            });\n            builder.pushLine(']');\n            return builder.getContent();\n        }\n    }\n    exports.DefaultSettings = DefaultSettings;\n    class DefaultSettingsEditorModel extends AbstractSettingsModel {\n        constructor(_uri, reference, defaultSettings) {\n            super();\n            this._uri = _uri;\n            this.defaultSettings = defaultSettings;\n            this._onDidChangeGroups = this._register(new event_1.Emitter());\n            this.onDidChangeGroups = this._onDidChangeGroups.event;\n            this._register(defaultSettings.onDidChange(() => this._onDidChangeGroups.fire()));\n            this._model = reference.object.textEditorModel;\n            this._register(this.onDispose(() => reference.dispose()));\n        }\n        get uri() {\n            return this._uri;\n        }\n        get target() {\n            return this.defaultSettings.target;\n        }\n        get settingsGroups() {\n            return this.defaultSettings.getSettingsGroups();\n        }\n        get filterGroups() {\n            // Don't look at \"commonly used\" for filter\n            return this.settingsGroups.slice(1);\n        }\n        update() {\n            if (this._model.isDisposed()) {\n                return undefined;\n            }\n            // Grab current result groups, only render non-empty groups\n            const resultGroups = map\n                .values(this._currentResultGroups)\n                .sort((a, b) => a.order - b.order);\n            const nonEmptyResultGroups = resultGroups.filter(group => group.result.filterMatches.length);\n            const startLine = arrays_1.tail(this.settingsGroups).range.endLineNumber + 2;\n            const { settingsGroups: filteredGroups, matches } = this.writeResultGroups(nonEmptyResultGroups, startLine);\n            const metadata = this.collectMetadata(resultGroups);\n            return resultGroups.length ?\n                {\n                    allGroups: this.settingsGroups,\n                    filteredGroups,\n                    matches,\n                    metadata\n                } :\n                undefined;\n        }\n        /**\n         * Translate the ISearchResultGroups to text, and write it to the editor model\n         */\n        writeResultGroups(groups, startLine) {\n            const contentBuilderOffset = startLine - 1;\n            const builder = new SettingsContentBuilder(contentBuilderOffset);\n            const settingsGroups = [];\n            const matches = [];\n            builder.pushLine(',');\n            groups.forEach(resultGroup => {\n                const settingsGroup = this.getGroup(resultGroup);\n                settingsGroups.push(settingsGroup);\n                matches.push(...this.writeSettingsGroupToBuilder(builder, settingsGroup, resultGroup.result.filterMatches));\n            });\n            // note: 1-indexed line numbers here\n            const groupContent = builder.getContent() + '\\n';\n            const groupEndLine = this._model.getLineCount();\n            const cursorPosition = new selection_1.Selection(startLine, 1, startLine, 1);\n            const edit = {\n                text: groupContent,\n                forceMoveMarkers: true,\n                range: new range_1.Range(startLine, 1, groupEndLine, 1),\n                identifier: { major: 1, minor: 0 }\n            };\n            this._model.pushEditOperations([cursorPosition], [edit], () => [cursorPosition]);\n            // Force tokenization now - otherwise it may be slightly delayed, causing a flash of white text\n            const tokenizeTo = Math.min(startLine + 60, this._model.getLineCount());\n            this._model.forceTokenization(tokenizeTo);\n            return { matches, settingsGroups };\n        }\n        writeSettingsGroupToBuilder(builder, settingsGroup, filterMatches) {\n            filterMatches = filterMatches\n                .map(filteredMatch => {\n                // Fix match ranges to offset from setting start line\n                return {\n                    setting: filteredMatch.setting,\n                    score: filteredMatch.score,\n                    matches: filteredMatch.matches && filteredMatch.matches.map(match => {\n                        return new range_1.Range(match.startLineNumber - filteredMatch.setting.range.startLineNumber, match.startColumn, match.endLineNumber - filteredMatch.setting.range.startLineNumber, match.endColumn);\n                    })\n                };\n            });\n            builder.pushGroup(settingsGroup);\n            builder.pushLine(',');\n            // builder has rewritten settings ranges, fix match ranges\n            const fixedMatches = arrays_1.flatten(filterMatches\n                .map(m => m.matches || [])\n                .map((settingMatches, i) => {\n                const setting = settingsGroup.sections[0].settings[i];\n                return settingMatches.map(range => {\n                    return new range_1.Range(range.startLineNumber + setting.range.startLineNumber, range.startColumn, range.endLineNumber + setting.range.startLineNumber, range.endColumn);\n                });\n            }));\n            return fixedMatches;\n        }\n        copySetting(setting) {\n            return {\n                description: setting.description,\n                scope: setting.scope,\n                type: setting.type,\n                enum: setting.enum,\n                enumDescriptions: setting.enumDescriptions,\n                key: setting.key,\n                value: setting.value,\n                range: setting.range,\n                overrides: [],\n                overrideOf: setting.overrideOf,\n                tags: setting.tags,\n                deprecationMessage: setting.deprecationMessage,\n                keyRange: exports.nullRange,\n                valueRange: exports.nullRange,\n                descriptionIsMarkdown: undefined,\n                descriptionRanges: []\n            };\n        }\n        findValueMatches(filter, setting) {\n            return [];\n        }\n        getPreference(key) {\n            for (const group of this.settingsGroups) {\n                for (const section of group.sections) {\n                    for (const setting of section.settings) {\n                        if (setting.key === key) {\n                            return setting;\n                        }\n                    }\n                }\n            }\n            return undefined;\n        }\n        getGroup(resultGroup) {\n            return {\n                id: resultGroup.id,\n                range: exports.nullRange,\n                title: resultGroup.label,\n                titleRange: exports.nullRange,\n                sections: [\n                    {\n                        settings: resultGroup.result.filterMatches.map(m => this.copySetting(m.setting))\n                    }\n                ]\n            };\n        }\n    }\n    exports.DefaultSettingsEditorModel = DefaultSettingsEditorModel;\n    class SettingsContentBuilder {\n        constructor(_rangeOffset = 0) {\n            this._rangeOffset = _rangeOffset;\n            this._contentByLines = [];\n        }\n        get lineCountWithOffset() {\n            return this._contentByLines.length + this._rangeOffset;\n        }\n        get lastLine() {\n            return this._contentByLines[this._contentByLines.length - 1] || '';\n        }\n        pushLine(...lineText) {\n            this._contentByLines.push(...lineText);\n        }\n        pushGroup(settingsGroups) {\n            this._contentByLines.push('{');\n            this._contentByLines.push('');\n            this._contentByLines.push('');\n            const lastSetting = this._pushGroup(settingsGroups, '  ');\n            if (lastSetting) {\n                // Strip the comma from the last setting\n                const lineIdx = lastSetting.range.endLineNumber - this._rangeOffset;\n                const content = this._contentByLines[lineIdx - 2];\n                this._contentByLines[lineIdx - 2] = content.substring(0, content.length - 1);\n            }\n            this._contentByLines.push('}');\n        }\n        _pushGroup(group, indent) {\n            let lastSetting = null;\n            const groupStart = this.lineCountWithOffset + 1;\n            for (const section of group.sections) {\n                if (section.title) {\n                    const sectionTitleStart = this.lineCountWithOffset + 1;\n                    this.addDescription([section.title], indent, this._contentByLines);\n                    section.titleRange = { startLineNumber: sectionTitleStart, startColumn: 1, endLineNumber: this.lineCountWithOffset, endColumn: this.lastLine.length };\n                }\n                if (section.settings.length) {\n                    for (const setting of section.settings) {\n                        this.pushSetting(setting, indent);\n                        lastSetting = setting;\n                    }\n                }\n            }\n            group.range = { startLineNumber: groupStart, startColumn: 1, endLineNumber: this.lineCountWithOffset, endColumn: this.lastLine.length };\n            return lastSetting;\n        }\n        getContent() {\n            return this._contentByLines.join('\\n');\n        }\n        pushSetting(setting, indent) {\n            const settingStart = this.lineCountWithOffset + 1;\n            this.pushSettingDescription(setting, indent);\n            let preValueContent = indent;\n            const keyString = JSON.stringify(setting.key);\n            preValueContent += keyString;\n            setting.keyRange = { startLineNumber: this.lineCountWithOffset + 1, startColumn: preValueContent.indexOf(setting.key) + 1, endLineNumber: this.lineCountWithOffset + 1, endColumn: setting.key.length };\n            preValueContent += ': ';\n            const valueStart = this.lineCountWithOffset + 1;\n            this.pushValue(setting, preValueContent, indent);\n            setting.valueRange = { startLineNumber: valueStart, startColumn: preValueContent.length + 1, endLineNumber: this.lineCountWithOffset, endColumn: this.lastLine.length + 1 };\n            this._contentByLines[this._contentByLines.length - 1] += ',';\n            this._contentByLines.push('');\n            setting.range = { startLineNumber: settingStart, startColumn: 1, endLineNumber: this.lineCountWithOffset, endColumn: this.lastLine.length };\n        }\n        pushSettingDescription(setting, indent) {\n            const fixSettingLink = (line) => line.replace(/`#(.*)#`/g, (match, settingName) => `\\`${settingName}\\``);\n            setting.descriptionRanges = [];\n            const descriptionPreValue = indent + '// ';\n            for (let line of (setting.deprecationMessage ? [setting.deprecationMessage, ...setting.description] : setting.description)) {\n                line = fixSettingLink(line);\n                this._contentByLines.push(descriptionPreValue + line);\n                setting.descriptionRanges.push({ startLineNumber: this.lineCountWithOffset, startColumn: this.lastLine.indexOf(line) + 1, endLineNumber: this.lineCountWithOffset, endColumn: this.lastLine.length });\n            }\n            if (setting.enumDescriptions && setting.enumDescriptions.some(desc => !!desc)) {\n                setting.enumDescriptions.forEach((desc, i) => {\n                    const displayEnum = escapeInvisibleChars(String(setting.enum[i]));\n                    const line = desc ?\n                        `${displayEnum}: ${fixSettingLink(desc)}` :\n                        displayEnum;\n                    this._contentByLines.push(`${indent}//  - ${line}`);\n                    setting.descriptionRanges.push({ startLineNumber: this.lineCountWithOffset, startColumn: this.lastLine.indexOf(line) + 1, endLineNumber: this.lineCountWithOffset, endColumn: this.lastLine.length });\n                });\n            }\n        }\n        pushValue(setting, preValueConent, indent) {\n            const valueString = JSON.stringify(setting.value, null, indent);\n            if (valueString && (typeof setting.value === 'object')) {\n                if (setting.overrides && setting.overrides.length) {\n                    this._contentByLines.push(preValueConent + ' {');\n                    for (const subSetting of setting.overrides) {\n                        this.pushSetting(subSetting, indent + indent);\n                        this._contentByLines.pop();\n                    }\n                    const lastSetting = setting.overrides[setting.overrides.length - 1];\n                    const content = this._contentByLines[lastSetting.range.endLineNumber - 2];\n                    this._contentByLines[lastSetting.range.endLineNumber - 2] = content.substring(0, content.length - 1);\n                    this._contentByLines.push(indent + '}');\n                }\n                else {\n                    const mulitLineValue = valueString.split('\\n');\n                    this._contentByLines.push(preValueConent + mulitLineValue[0]);\n                    for (let i = 1; i < mulitLineValue.length; i++) {\n                        this._contentByLines.push(indent + mulitLineValue[i]);\n                    }\n                }\n            }\n            else {\n                this._contentByLines.push(preValueConent + valueString);\n            }\n        }\n        addDescription(description, indent, result) {\n            for (const line of description) {\n                result.push(indent + '// ' + line);\n            }\n        }\n    }\n    function createValidator(prop) {\n        return value => {\n            let exclusiveMax;\n            let exclusiveMin;\n            if (typeof prop.exclusiveMaximum === 'boolean') {\n                exclusiveMax = prop.exclusiveMaximum ? prop.maximum : undefined;\n            }\n            else {\n                exclusiveMax = prop.exclusiveMaximum;\n            }\n            if (typeof prop.exclusiveMinimum === 'boolean') {\n                exclusiveMin = prop.exclusiveMinimum ? prop.minimum : undefined;\n            }\n            else {\n                exclusiveMin = prop.exclusiveMinimum;\n            }\n            let patternRegex;\n            if (typeof prop.pattern === 'string') {\n                patternRegex = new RegExp(prop.pattern);\n            }\n            const type = Array.isArray(prop.type) ? prop.type : [prop.type];\n            const canBeType = (t) => type.indexOf(t) > -1;\n            const isNullable = canBeType('null');\n            const isNumeric = (canBeType('number') || canBeType('integer')) && (type.length === 1 || type.length === 2 && isNullable);\n            const isIntegral = (canBeType('integer')) && (type.length === 1 || type.length === 2 && isNullable);\n            const numericValidations = isNumeric ? [\n                {\n                    enabled: exclusiveMax !== undefined && (prop.maximum === undefined || exclusiveMax <= prop.maximum),\n                    isValid: ((value) => value < exclusiveMax),\n                    message: nls.localize('validations.exclusiveMax', \"Value must be strictly less than {0}.\", exclusiveMax)\n                },\n                {\n                    enabled: exclusiveMin !== undefined && (prop.minimum === undefined || exclusiveMin >= prop.minimum),\n                    isValid: ((value) => value > exclusiveMin),\n                    message: nls.localize('validations.exclusiveMin', \"Value must be strictly greater than {0}.\", exclusiveMin)\n                },\n                {\n                    enabled: prop.maximum !== undefined && (exclusiveMax === undefined || exclusiveMax > prop.maximum),\n                    isValid: ((value) => value <= prop.maximum),\n                    message: nls.localize('validations.max', \"Value must be less than or equal to {0}.\", prop.maximum)\n                },\n                {\n                    enabled: prop.minimum !== undefined && (exclusiveMin === undefined || exclusiveMin < prop.minimum),\n                    isValid: ((value) => value >= prop.minimum),\n                    message: nls.localize('validations.min', \"Value must be greater than or equal to {0}.\", prop.minimum)\n                },\n                {\n                    enabled: prop.multipleOf !== undefined,\n                    isValid: ((value) => value % prop.multipleOf === 0),\n                    message: nls.localize('validations.multipleOf', \"Value must be a multiple of {0}.\", prop.multipleOf)\n                },\n                {\n                    enabled: isIntegral,\n                    isValid: ((value) => value % 1 === 0),\n                    message: nls.localize('validations.expectedInteger', \"Value must be an integer.\")\n                },\n            ].filter(validation => validation.enabled) : [];\n            const stringValidations = [\n                {\n                    enabled: prop.maxLength !== undefined,\n                    isValid: ((value) => value.length <= prop.maxLength),\n                    message: nls.localize('validations.maxLength', \"Value must be {0} or fewer characters long.\", prop.maxLength)\n                },\n                {\n                    enabled: prop.minLength !== undefined,\n                    isValid: ((value) => value.length >= prop.minLength),\n                    message: nls.localize('validations.minLength', \"Value must be {0} or more characters long.\", prop.minLength)\n                },\n                {\n                    enabled: patternRegex !== undefined,\n                    isValid: ((value) => patternRegex.test(value)),\n                    message: prop.patternErrorMessage || nls.localize('validations.regex', \"Value must match regex `{0}`.\", prop.pattern)\n                },\n            ].filter(validation => validation.enabled);\n            if (prop.type === 'string' && stringValidations.length === 0) {\n                return null;\n            }\n            if (isNullable && value === '') {\n                return '';\n            }\n            const errors = [];\n            if (isNumeric) {\n                if (value === '' || isNaN(+value)) {\n                    errors.push(nls.localize('validations.expectedNumeric', \"Value must be a number.\"));\n                }\n                else {\n                    errors.push(...numericValidations.filter(validator => !validator.isValid(+value)).map(validator => validator.message));\n                }\n            }\n            if (prop.type === 'string') {\n                errors.push(...stringValidations.filter(validator => !validator.isValid('' + value)).map(validator => validator.message));\n            }\n            if (errors.length) {\n                return prop.errorMessage ? [prop.errorMessage, ...errors].join(' ') : errors.join(' ');\n            }\n            return '';\n        };\n    }\n    exports.createValidator = createValidator;\n    class RawSettingsContentBuilder extends SettingsContentBuilder {\n        constructor(indent = '\\t') {\n            super(0);\n            this.indent = indent;\n        }\n        pushGroup(settingsGroups) {\n            this._pushGroup(settingsGroups, this.indent);\n        }\n    }\n    class DefaultRawSettingsEditorModel extends lifecycle_1.Disposable {\n        constructor(defaultSettings) {\n            super();\n            this.defaultSettings = defaultSettings;\n            this._content = null;\n            this._register(defaultSettings.onDidChange(() => this._content = null));\n        }\n        get content() {\n            if (this._content === null) {\n                const builder = new RawSettingsContentBuilder();\n                builder.pushLine('{');\n                for (const settingsGroup of this.defaultSettings.getRegisteredGroups()) {\n                    builder.pushGroup(settingsGroup);\n                }\n                builder.pushLine('}');\n                this._content = builder.getContent();\n            }\n            return this._content;\n        }\n    }\n    exports.DefaultRawSettingsEditorModel = DefaultRawSettingsEditorModel;\n    function escapeInvisibleChars(enumValue) {\n        return enumValue && enumValue\n            .replace(/\\n/g, '\\\\n')\n            .replace(/\\r/g, '\\\\r');\n    }\n    function defaultKeybindingsContents(keybindingService) {\n        const defaultsHeader = '// ' + nls.localize('defaultKeybindingsHeader', \"Override key bindings by placing them into your key bindings file.\");\n        return defaultsHeader + '\\n' + keybindingService.getDefaultKeybindingsContent();\n    }\n    exports.defaultKeybindingsContents = defaultKeybindingsContents;\n    let DefaultKeybindingsEditorModel = class DefaultKeybindingsEditorModel {\n        constructor(_uri, keybindingService) {\n            this._uri = _uri;\n            this.keybindingService = keybindingService;\n        }\n        get uri() {\n            return this._uri;\n        }\n        get content() {\n            if (!this._content) {\n                this._content = defaultKeybindingsContents(this.keybindingService);\n            }\n            return this._content;\n        }\n        getPreference() {\n            return null;\n        }\n        dispose() {\n            // Not disposable\n        }\n    };\n    DefaultKeybindingsEditorModel = __decorate([\n        __param(1, keybinding_1.IKeybindingService)\n    ], DefaultKeybindingsEditorModel);\n    exports.DefaultKeybindingsEditorModel = DefaultKeybindingsEditorModel;\n});\n",null]}