{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/codelens/codelensController.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/codelens/codelensController.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/async\", \"vs/base/common/errors\", \"vs/base/common/lifecycle\", \"vs/editor/browser/core/editorState\", \"vs/editor/browser/editorBrowser\", \"vs/editor/browser/editorExtensions\", \"vs/editor/common/modes\", \"vs/editor/contrib/codelens/codelens\", \"vs/editor/contrib/codelens/codelensWidget\", \"vs/platform/commands/common/commands\", \"vs/platform/notification/common/notification\"], function (require, exports, async_1, errors_1, lifecycle_1, editorState_1, editorBrowser, editorExtensions_1, modes_1, codelens_1, codelensWidget_1, commands_1, notification_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let CodeLensContribution = class CodeLensContribution {\n        constructor(_editor, _commandService, _notificationService) {\n            this._editor = _editor;\n            this._commandService = _commandService;\n            this._notificationService = _notificationService;\n            this._isEnabled = this._editor.getConfiguration().contribInfo.codeLens;\n            this._globalToDispose = [];\n            this._localToDispose = [];\n            this._lenses = [];\n            this._currentFindCodeLensSymbolsPromise = null;\n            this._modelChangeCounter = 0;\n            this._globalToDispose.push(this._editor.onDidChangeModel(() => this._onModelChange()));\n            this._globalToDispose.push(this._editor.onDidChangeModelLanguage(() => this._onModelChange()));\n            this._globalToDispose.push(this._editor.onDidChangeConfiguration((e) => {\n                let prevIsEnabled = this._isEnabled;\n                this._isEnabled = this._editor.getConfiguration().contribInfo.codeLens;\n                if (prevIsEnabled !== this._isEnabled) {\n                    this._onModelChange();\n                }\n            }));\n            this._globalToDispose.push(modes_1.CodeLensProviderRegistry.onDidChange(this._onModelChange, this));\n            this._onModelChange();\n        }\n        dispose() {\n            this._localDispose();\n            this._globalToDispose = lifecycle_1.dispose(this._globalToDispose);\n        }\n        _localDispose() {\n            if (this._currentFindCodeLensSymbolsPromise) {\n                this._currentFindCodeLensSymbolsPromise.cancel();\n                this._currentFindCodeLensSymbolsPromise = null;\n                this._modelChangeCounter++;\n            }\n            if (this._currentResolveCodeLensSymbolsPromise) {\n                this._currentResolveCodeLensSymbolsPromise.cancel();\n                this._currentResolveCodeLensSymbolsPromise = null;\n            }\n            this._localToDispose = lifecycle_1.dispose(this._localToDispose);\n        }\n        getId() {\n            return CodeLensContribution.ID;\n        }\n        _onModelChange() {\n            this._localDispose();\n            const model = this._editor.getModel();\n            if (!model) {\n                return;\n            }\n            if (!this._isEnabled) {\n                return;\n            }\n            if (!modes_1.CodeLensProviderRegistry.has(model)) {\n                return;\n            }\n            for (const provider of modes_1.CodeLensProviderRegistry.all(model)) {\n                if (typeof provider.onDidChange === 'function') {\n                    let registration = provider.onDidChange(() => scheduler.schedule());\n                    this._localToDispose.push(registration);\n                }\n            }\n            this._detectVisibleLenses = new async_1.RunOnceScheduler(() => {\n                this._onViewportChanged();\n            }, 500);\n            const scheduler = new async_1.RunOnceScheduler(() => {\n                const counterValue = ++this._modelChangeCounter;\n                if (this._currentFindCodeLensSymbolsPromise) {\n                    this._currentFindCodeLensSymbolsPromise.cancel();\n                }\n                this._currentFindCodeLensSymbolsPromise = async_1.createCancelablePromise(token => codelens_1.getCodeLensData(model, token));\n                this._currentFindCodeLensSymbolsPromise.then((result) => {\n                    if (counterValue === this._modelChangeCounter) { // only the last one wins\n                        this._renderCodeLensSymbols(result);\n                        this._detectVisibleLenses.schedule();\n                    }\n                }, errors_1.onUnexpectedError);\n            }, 250);\n            this._localToDispose.push(scheduler);\n            this._localToDispose.push(this._detectVisibleLenses);\n            this._localToDispose.push(this._editor.onDidChangeModelContent((e) => {\n                this._editor.changeDecorations((changeAccessor) => {\n                    this._editor.changeViewZones((viewAccessor) => {\n                        let toDispose = [];\n                        let lastLensLineNumber = -1;\n                        this._lenses.forEach((lens) => {\n                            if (!lens.isValid() || lastLensLineNumber === lens.getLineNumber()) {\n                                // invalid -> lens collapsed, attach range doesn't exist anymore\n                                // line_number -> lenses should never be on the same line\n                                toDispose.push(lens);\n                            }\n                            else {\n                                lens.update(viewAccessor);\n                                lastLensLineNumber = lens.getLineNumber();\n                            }\n                        });\n                        let helper = new codelensWidget_1.CodeLensHelper();\n                        toDispose.forEach((l) => {\n                            l.dispose(helper, viewAccessor);\n                            this._lenses.splice(this._lenses.indexOf(l), 1);\n                        });\n                        helper.commit(changeAccessor);\n                    });\n                });\n                // Compute new `visible` code lenses\n                this._detectVisibleLenses.schedule();\n                // Ask for all references again\n                scheduler.schedule();\n            }));\n            this._localToDispose.push(this._editor.onDidScrollChange(e => {\n                if (e.scrollTopChanged && this._lenses.length > 0) {\n                    this._detectVisibleLenses.schedule();\n                }\n            }));\n            this._localToDispose.push(this._editor.onDidLayoutChange(e => {\n                this._detectVisibleLenses.schedule();\n            }));\n            this._localToDispose.push(lifecycle_1.toDisposable(() => {\n                if (this._editor.getModel()) {\n                    const scrollState = editorState_1.StableEditorScrollState.capture(this._editor);\n                    this._editor.changeDecorations((changeAccessor) => {\n                        this._editor.changeViewZones((accessor) => {\n                            this._disposeAllLenses(changeAccessor, accessor);\n                        });\n                    });\n                    scrollState.restore(this._editor);\n                }\n                else {\n                    // No accessors available\n                    this._disposeAllLenses(undefined, undefined);\n                }\n            }));\n            this._localToDispose.push(this._editor.onDidChangeConfiguration(e => {\n                if (e.fontInfo) {\n                    for (const lens of this._lenses) {\n                        lens.updateHeight();\n                    }\n                }\n            }));\n            this._localToDispose.push(this._editor.onMouseUp(e => {\n                if (e.target.type === editorBrowser.MouseTargetType.CONTENT_WIDGET && e.target.element && e.target.element.tagName === 'A') {\n                    for (const lens of this._lenses) {\n                        let command = lens.getCommand(e.target.element);\n                        if (command) {\n                            this._commandService.executeCommand(command.id, ...(command.arguments || [])).catch(err => this._notificationService.error(err));\n                            break;\n                        }\n                    }\n                }\n            }));\n            scheduler.schedule();\n        }\n        _disposeAllLenses(decChangeAccessor, viewZoneChangeAccessor) {\n            let helper = new codelensWidget_1.CodeLensHelper();\n            this._lenses.forEach((lens) => lens.dispose(helper, viewZoneChangeAccessor));\n            if (decChangeAccessor) {\n                helper.commit(decChangeAccessor);\n            }\n            this._lenses = [];\n        }\n        _renderCodeLensSymbols(symbols) {\n            if (!this._editor.hasModel()) {\n                return;\n            }\n            let maxLineNumber = this._editor.getModel().getLineCount();\n            let groups = [];\n            let lastGroup;\n            for (let symbol of symbols) {\n                let line = symbol.symbol.range.startLineNumber;\n                if (line < 1 || line > maxLineNumber) {\n                    // invalid code lens\n                    continue;\n                }\n                else if (lastGroup && lastGroup[lastGroup.length - 1].symbol.range.startLineNumber === line) {\n                    // on same line as previous\n                    lastGroup.push(symbol);\n                }\n                else {\n                    // on later line as previous\n                    lastGroup = [symbol];\n                    groups.push(lastGroup);\n                }\n            }\n            const scrollState = editorState_1.StableEditorScrollState.capture(this._editor);\n            this._editor.changeDecorations((changeAccessor) => {\n                this._editor.changeViewZones((accessor) => {\n                    let codeLensIndex = 0, groupsIndex = 0, helper = new codelensWidget_1.CodeLensHelper();\n                    while (groupsIndex < groups.length && codeLensIndex < this._lenses.length) {\n                        let symbolsLineNumber = groups[groupsIndex][0].symbol.range.startLineNumber;\n                        let codeLensLineNumber = this._lenses[codeLensIndex].getLineNumber();\n                        if (codeLensLineNumber < symbolsLineNumber) {\n                            this._lenses[codeLensIndex].dispose(helper, accessor);\n                            this._lenses.splice(codeLensIndex, 1);\n                        }\n                        else if (codeLensLineNumber === symbolsLineNumber) {\n                            this._lenses[codeLensIndex].updateCodeLensSymbols(groups[groupsIndex], helper);\n                            groupsIndex++;\n                            codeLensIndex++;\n                        }\n                        else {\n                            this._lenses.splice(codeLensIndex, 0, new codelensWidget_1.CodeLens(groups[groupsIndex], this._editor, helper, accessor, () => this._detectVisibleLenses.schedule()));\n                            codeLensIndex++;\n                            groupsIndex++;\n                        }\n                    }\n                    // Delete extra code lenses\n                    while (codeLensIndex < this._lenses.length) {\n                        this._lenses[codeLensIndex].dispose(helper, accessor);\n                        this._lenses.splice(codeLensIndex, 1);\n                    }\n                    // Create extra symbols\n                    while (groupsIndex < groups.length) {\n                        this._lenses.push(new codelensWidget_1.CodeLens(groups[groupsIndex], this._editor, helper, accessor, () => this._detectVisibleLenses.schedule()));\n                        groupsIndex++;\n                    }\n                    helper.commit(changeAccessor);\n                });\n            });\n            scrollState.restore(this._editor);\n        }\n        _onViewportChanged() {\n            if (this._currentResolveCodeLensSymbolsPromise) {\n                this._currentResolveCodeLensSymbolsPromise.cancel();\n                this._currentResolveCodeLensSymbolsPromise = null;\n            }\n            const model = this._editor.getModel();\n            if (!model) {\n                return;\n            }\n            const toResolve = [];\n            const lenses = [];\n            this._lenses.forEach((lens) => {\n                const request = lens.computeIfNecessary(model);\n                if (request) {\n                    toResolve.push(request);\n                    lenses.push(lens);\n                }\n            });\n            if (toResolve.length === 0) {\n                return;\n            }\n            this._currentResolveCodeLensSymbolsPromise = async_1.createCancelablePromise(token => {\n                const promises = toResolve.map((request, i) => {\n                    const resolvedSymbols = new Array(request.length);\n                    const promises = request.map((request, i) => {\n                        if (!request.symbol.command && typeof request.provider.resolveCodeLens === 'function') {\n                            return Promise.resolve(request.provider.resolveCodeLens(model, request.symbol, token)).then(symbol => {\n                                resolvedSymbols[i] = symbol;\n                            });\n                        }\n                        else {\n                            resolvedSymbols[i] = request.symbol;\n                            return Promise.resolve(undefined);\n                        }\n                    });\n                    return Promise.all(promises).then(() => {\n                        lenses[i].updateCommands(resolvedSymbols);\n                    });\n                });\n                return Promise.all(promises);\n            });\n            this._currentResolveCodeLensSymbolsPromise.then(() => {\n                this._currentResolveCodeLensSymbolsPromise = null;\n            }).catch(err => {\n                this._currentResolveCodeLensSymbolsPromise = null;\n                errors_1.onUnexpectedError(err);\n            });\n        }\n    };\n    CodeLensContribution.ID = 'css.editor.codeLens';\n    CodeLensContribution = __decorate([\n        __param(1, commands_1.ICommandService),\n        __param(2, notification_1.INotificationService)\n    ], CodeLensContribution);\n    exports.CodeLensContribution = CodeLensContribution;\n    editorExtensions_1.registerEditorContribution(CodeLensContribution);\n});\n",null]}