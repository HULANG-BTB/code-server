{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/experiments/node/experimentService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/experiments/node/experimentService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/platform/product/node/product\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/storage/common/storage\", \"vs/platform/environment/common/environment\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/platform/configuration/common/configuration\", \"vs/platform/extensionManagement/common/extensionManagement\", \"vs/platform/request/node/request\", \"vs/base/common/platform\", \"vs/base/common/lifecycle\", \"vs/base/common/glob\", \"vs/base/node/request\", \"vs/base/common/event\", \"vs/workbench/services/textfile/common/textfiles\", \"vs/workbench/contrib/stats/node/workspaceStats\", \"vs/base/common/cancellation\", \"vs/base/common/arrays\", \"vs/platform/telemetry/node/workbenchCommonProperties\", \"vs/platform/extensions/common/extensions\"], function (require, exports, product_1, instantiation_1, storage_1, environment_1, telemetry_1, lifecycle_1, configuration_1, extensionManagement_1, request_1, platform_1, lifecycle_2, glob_1, request_2, event_1, textfiles_1, workspaceStats_1, cancellation_1, arrays_1, workbenchCommonProperties_1, extensions_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var ExperimentState;\n    (function (ExperimentState) {\n        ExperimentState[ExperimentState[\"Evaluating\"] = 0] = \"Evaluating\";\n        ExperimentState[ExperimentState[\"NoRun\"] = 1] = \"NoRun\";\n        ExperimentState[ExperimentState[\"Run\"] = 2] = \"Run\";\n        ExperimentState[ExperimentState[\"Complete\"] = 3] = \"Complete\";\n    })(ExperimentState = exports.ExperimentState || (exports.ExperimentState = {}));\n    var ExperimentActionType;\n    (function (ExperimentActionType) {\n        ExperimentActionType[\"Custom\"] = \"Custom\";\n        ExperimentActionType[\"Prompt\"] = \"Prompt\";\n        ExperimentActionType[\"AddToRecommendations\"] = \"AddToRecommendations\";\n        ExperimentActionType[\"ExtensionSearchResults\"] = \"ExtensionSearchResults\";\n    })(ExperimentActionType = exports.ExperimentActionType || (exports.ExperimentActionType = {}));\n    exports.IExperimentService = instantiation_1.createDecorator('experimentService');\n    let ExperimentService = class ExperimentService extends lifecycle_2.Disposable {\n        constructor(storageService, extensionManagementService, textFileService, environmentService, telemetryService, lifecycleService, requestService, configurationService) {\n            super();\n            this.storageService = storageService;\n            this.extensionManagementService = extensionManagementService;\n            this.textFileService = textFileService;\n            this.environmentService = environmentService;\n            this.telemetryService = telemetryService;\n            this.lifecycleService = lifecycleService;\n            this.requestService = requestService;\n            this.configurationService = configurationService;\n            this._experiments = [];\n            this._curatedMapping = Object.create(null);\n            this._disposables = [];\n            this._onExperimentEnabled = new event_1.Emitter();\n            this.onExperimentEnabled = this._onExperimentEnabled.event;\n            this._loadExperimentsPromise = Promise.resolve(this.lifecycleService.when(lifecycle_1.LifecyclePhase.Eventually)).then(() => this.loadExperiments());\n        }\n        getExperimentById(id) {\n            return this._loadExperimentsPromise.then(() => {\n                return this._experiments.filter(x => x.id === id)[0];\n            });\n        }\n        getExperimentsByType(type) {\n            return this._loadExperimentsPromise.then(() => {\n                if (type === ExperimentActionType.Custom) {\n                    return this._experiments.filter(x => x.enabled && (!x.action || x.action.type === type));\n                }\n                return this._experiments.filter(x => x.enabled && x.action && x.action.type === type);\n            });\n        }\n        getCuratedExtensionsList(curatedExtensionsKey) {\n            return this._loadExperimentsPromise.then(() => {\n                for (const experiment of this._experiments) {\n                    if (experiment.enabled\n                        && experiment.state === ExperimentState.Run\n                        && this._curatedMapping[experiment.id]\n                        && this._curatedMapping[experiment.id].curatedExtensionsKey === curatedExtensionsKey) {\n                        return this._curatedMapping[experiment.id].curatedExtensionsList;\n                    }\n                }\n                return [];\n            });\n        }\n        markAsCompleted(experimentId) {\n            const storageKey = 'experiments.' + experimentId;\n            const experimentState = safeParse(this.storageService.get(storageKey, storage_1.StorageScope.GLOBAL), {});\n            experimentState.state = ExperimentState.Complete;\n            this.storageService.store(storageKey, JSON.stringify(experimentState), storage_1.StorageScope.GLOBAL);\n        }\n        getExperiments() {\n            if (!product_1.default.experimentsUrl || this.configurationService.getValue('workbench.enableExperiments') === false) {\n                return Promise.resolve([]);\n            }\n            return this.requestService.request({ type: 'GET', url: product_1.default.experimentsUrl }, cancellation_1.CancellationToken.None).then(context => {\n                if (context.res.statusCode !== 200) {\n                    return Promise.resolve(null);\n                }\n                return request_2.asJson(context).then(result => {\n                    return result && Array.isArray(result['experiments']) ? result['experiments'] : [];\n                });\n            }, () => Promise.resolve(null));\n        }\n        loadExperiments() {\n            return this.getExperiments().then(rawExperiments => {\n                // Offline mode\n                if (!rawExperiments) {\n                    const allExperimentIdsFromStorage = safeParse(this.storageService.get('allExperiments', storage_1.StorageScope.GLOBAL), []);\n                    if (Array.isArray(allExperimentIdsFromStorage)) {\n                        allExperimentIdsFromStorage.forEach(experimentId => {\n                            const storageKey = 'experiments.' + experimentId;\n                            const experimentState = safeParse(this.storageService.get(storageKey, storage_1.StorageScope.GLOBAL), null);\n                            if (experimentState) {\n                                this._experiments.push({\n                                    id: experimentId,\n                                    enabled: experimentState.enabled,\n                                    state: experimentState.state\n                                });\n                            }\n                        });\n                    }\n                    return Promise.resolve(null);\n                }\n                // Clear disbaled/deleted experiments from storage\n                const allExperimentIdsFromStorage = safeParse(this.storageService.get('allExperiments', storage_1.StorageScope.GLOBAL), []);\n                const enabledExperiments = rawExperiments.filter(experiment => !!experiment.enabled).map(experiment => experiment.id.toLowerCase());\n                if (Array.isArray(allExperimentIdsFromStorage)) {\n                    allExperimentIdsFromStorage.forEach(experiment => {\n                        if (enabledExperiments.indexOf(experiment) === -1) {\n                            this.storageService.remove(`experiments.${experiment}`, storage_1.StorageScope.GLOBAL);\n                        }\n                    });\n                }\n                if (enabledExperiments.length) {\n                    this.storageService.store('allExperiments', JSON.stringify(enabledExperiments), storage_1.StorageScope.GLOBAL);\n                }\n                else {\n                    this.storageService.remove('allExperiments', storage_1.StorageScope.GLOBAL);\n                }\n                const promises = rawExperiments.map(experiment => {\n                    const processedExperiment = {\n                        id: experiment.id,\n                        enabled: !!experiment.enabled,\n                        state: !!experiment.enabled ? ExperimentState.Evaluating : ExperimentState.NoRun\n                    };\n                    if (experiment.action) {\n                        processedExperiment.action = {\n                            type: ExperimentActionType[experiment.action.type] || ExperimentActionType.Custom,\n                            properties: experiment.action.properties\n                        };\n                        if (processedExperiment.action.type === ExperimentActionType.Prompt) {\n                            (processedExperiment.action.properties.commands || []).forEach(x => {\n                                if (x.curatedExtensionsKey && Array.isArray(x.curatedExtensionsList)) {\n                                    this._curatedMapping[experiment.id] = x;\n                                }\n                            });\n                        }\n                        if (!processedExperiment.action.properties) {\n                            processedExperiment.action.properties = {};\n                        }\n                    }\n                    this._experiments.push(processedExperiment);\n                    if (!processedExperiment.enabled) {\n                        return Promise.resolve(null);\n                    }\n                    const storageKey = 'experiments.' + experiment.id;\n                    const experimentState = safeParse(this.storageService.get(storageKey, storage_1.StorageScope.GLOBAL), {});\n                    if (!experimentState.hasOwnProperty('enabled')) {\n                        experimentState.enabled = processedExperiment.enabled;\n                    }\n                    if (!experimentState.hasOwnProperty('state')) {\n                        experimentState.state = processedExperiment.enabled ? ExperimentState.Evaluating : ExperimentState.NoRun;\n                    }\n                    else {\n                        processedExperiment.state = experimentState.state;\n                    }\n                    return this.shouldRunExperiment(experiment, processedExperiment).then((state) => {\n                        experimentState.state = processedExperiment.state = state;\n                        this.storageService.store(storageKey, JSON.stringify(experimentState), storage_1.StorageScope.GLOBAL);\n                        if (state === ExperimentState.Run) {\n                            this.fireRunExperiment(processedExperiment);\n                        }\n                        return Promise.resolve(null);\n                    });\n                });\n                return Promise.all(promises).then(() => {\n                    /* __GDPR__\n                        \"experiments\" : {\n                            \"experiments\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                        }\n                    */\n                    this.telemetryService.publicLog('experiments', { experiments: this._experiments });\n                });\n            });\n        }\n        fireRunExperiment(experiment) {\n            this._onExperimentEnabled.fire(experiment);\n            const runExperimentIdsFromStorage = safeParse(this.storageService.get('currentOrPreviouslyRunExperiments', storage_1.StorageScope.GLOBAL), []);\n            if (runExperimentIdsFromStorage.indexOf(experiment.id) === -1) {\n                runExperimentIdsFromStorage.push(experiment.id);\n            }\n            // Ensure we dont store duplicates\n            const distinctExperiments = arrays_1.distinct(runExperimentIdsFromStorage);\n            if (runExperimentIdsFromStorage.length !== distinctExperiments.length) {\n                this.storageService.store('currentOrPreviouslyRunExperiments', JSON.stringify(distinctExperiments), storage_1.StorageScope.GLOBAL);\n            }\n        }\n        checkExperimentDependencies(experiment) {\n            const experimentsPreviouslyRun = experiment.condition ? experiment.condition.experimentsPreviouslyRun : undefined;\n            if (experimentsPreviouslyRun) {\n                const runExperimentIdsFromStorage = safeParse(this.storageService.get('currentOrPreviouslyRunExperiments', storage_1.StorageScope.GLOBAL), []);\n                let includeCheck = true;\n                let excludeCheck = true;\n                const includes = experimentsPreviouslyRun.includes;\n                if (Array.isArray(includes)) {\n                    includeCheck = runExperimentIdsFromStorage.some(x => includes.indexOf(x) > -1);\n                }\n                const excludes = experimentsPreviouslyRun.excludes;\n                if (includeCheck && Array.isArray(excludes)) {\n                    excludeCheck = !runExperimentIdsFromStorage.some(x => excludes.indexOf(x) > -1);\n                }\n                if (!includeCheck || !excludeCheck) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        shouldRunExperiment(experiment, processedExperiment) {\n            if (processedExperiment.state !== ExperimentState.Evaluating) {\n                return Promise.resolve(processedExperiment.state);\n            }\n            if (!experiment.enabled) {\n                return Promise.resolve(ExperimentState.NoRun);\n            }\n            const condition = experiment.condition;\n            if (!condition) {\n                return Promise.resolve(ExperimentState.Run);\n            }\n            if (!this.checkExperimentDependencies(experiment)) {\n                return Promise.resolve(ExperimentState.NoRun);\n            }\n            if (this.environmentService.appQuality === 'stable' && condition.insidersOnly === true) {\n                return Promise.resolve(ExperimentState.NoRun);\n            }\n            const isNewUser = !this.storageService.get(workbenchCommonProperties_1.lastSessionDateStorageKey, storage_1.StorageScope.GLOBAL);\n            if ((condition.newUser === true && !isNewUser)\n                || (condition.newUser === false && isNewUser)) {\n                return Promise.resolve(ExperimentState.NoRun);\n            }\n            if (typeof condition.displayLanguage === 'string') {\n                let localeToCheck = condition.displayLanguage.toLowerCase();\n                let displayLanguage = platform_1.language.toLowerCase();\n                if (localeToCheck !== displayLanguage) {\n                    const a = displayLanguage.indexOf('-');\n                    const b = localeToCheck.indexOf('-');\n                    if (a > -1) {\n                        displayLanguage = displayLanguage.substr(0, a);\n                    }\n                    if (b > -1) {\n                        localeToCheck = localeToCheck.substr(0, b);\n                    }\n                    if (displayLanguage !== localeToCheck) {\n                        return Promise.resolve(ExperimentState.NoRun);\n                    }\n                }\n            }\n            if (!condition.userProbability) {\n                condition.userProbability = 1;\n            }\n            let extensionsCheckPromise = Promise.resolve(true);\n            const installedExtensions = condition.installedExtensions;\n            if (installedExtensions) {\n                extensionsCheckPromise = this.extensionManagementService.getInstalled(extensions_1.ExtensionType.User).then(locals => {\n                    let includesCheck = true;\n                    let excludesCheck = true;\n                    const localExtensions = locals.map(local => `${local.manifest.publisher.toLowerCase()}.${local.manifest.name.toLowerCase()}`);\n                    if (Array.isArray(installedExtensions.includes) && installedExtensions.includes.length) {\n                        const extensionIncludes = installedExtensions.includes.map(e => e.toLowerCase());\n                        includesCheck = localExtensions.some(e => extensionIncludes.indexOf(e) > -1);\n                    }\n                    if (Array.isArray(installedExtensions.excludes) && installedExtensions.excludes.length) {\n                        const extensionExcludes = installedExtensions.excludes.map(e => e.toLowerCase());\n                        excludesCheck = !localExtensions.some(e => extensionExcludes.indexOf(e) > -1);\n                    }\n                    return includesCheck && excludesCheck;\n                });\n            }\n            const storageKey = 'experiments.' + experiment.id;\n            const experimentState = safeParse(this.storageService.get(storageKey, storage_1.StorageScope.GLOBAL), {});\n            return extensionsCheckPromise.then(success => {\n                const fileEdits = condition.fileEdits;\n                if (!success || !fileEdits || typeof fileEdits.minEditCount !== 'number') {\n                    const runExperiment = success && typeof condition.userProbability === 'number' && Math.random() < condition.userProbability;\n                    return runExperiment ? ExperimentState.Run : ExperimentState.NoRun;\n                }\n                experimentState.editCount = experimentState.editCount || 0;\n                if (experimentState.editCount >= fileEdits.minEditCount) {\n                    return ExperimentState.Run;\n                }\n                const onSaveHandler = this.textFileService.models.onModelsSaved(e => {\n                    const date = new Date().toDateString();\n                    const latestExperimentState = safeParse(this.storageService.get(storageKey, storage_1.StorageScope.GLOBAL), {});\n                    if (latestExperimentState.state !== ExperimentState.Evaluating) {\n                        onSaveHandler.dispose();\n                        return;\n                    }\n                    e.forEach(event => {\n                        if (event.kind !== textfiles_1.StateChange.SAVED\n                            || latestExperimentState.state !== ExperimentState.Evaluating\n                            || date === latestExperimentState.lastEditedDate\n                            || (typeof latestExperimentState.editCount === 'number' && latestExperimentState.editCount >= fileEdits.minEditCount)) {\n                            return;\n                        }\n                        let filePathCheck = true;\n                        let workspaceCheck = true;\n                        if (typeof fileEdits.filePathPattern === 'string') {\n                            filePathCheck = glob_1.match(fileEdits.filePathPattern, event.resource.fsPath);\n                        }\n                        if (Array.isArray(fileEdits.workspaceIncludes) && fileEdits.workspaceIncludes.length) {\n                            workspaceCheck = !!workspaceStats_1.WorkspaceStats.TAGS && fileEdits.workspaceIncludes.some(x => !!workspaceStats_1.WorkspaceStats.TAGS[x]);\n                        }\n                        if (workspaceCheck && Array.isArray(fileEdits.workspaceExcludes) && fileEdits.workspaceExcludes.length) {\n                            workspaceCheck = !!workspaceStats_1.WorkspaceStats.TAGS && !fileEdits.workspaceExcludes.some(x => !!workspaceStats_1.WorkspaceStats.TAGS[x]);\n                        }\n                        if (filePathCheck && workspaceCheck) {\n                            latestExperimentState.editCount = (latestExperimentState.editCount || 0) + 1;\n                            latestExperimentState.lastEditedDate = date;\n                            this.storageService.store(storageKey, JSON.stringify(latestExperimentState), storage_1.StorageScope.GLOBAL);\n                        }\n                    });\n                    if (typeof latestExperimentState.editCount === 'number' && latestExperimentState.editCount >= fileEdits.minEditCount) {\n                        processedExperiment.state = latestExperimentState.state = (typeof condition.userProbability === 'number' && Math.random() < condition.userProbability && this.checkExperimentDependencies(experiment)) ? ExperimentState.Run : ExperimentState.NoRun;\n                        this.storageService.store(storageKey, JSON.stringify(latestExperimentState), storage_1.StorageScope.GLOBAL);\n                        if (latestExperimentState.state === ExperimentState.Run && experiment.action && ExperimentActionType[experiment.action.type] === ExperimentActionType.Prompt) {\n                            this.fireRunExperiment(processedExperiment);\n                        }\n                    }\n                });\n                this._disposables.push(onSaveHandler);\n                return ExperimentState.Evaluating;\n            });\n        }\n        dispose() {\n            this._disposables = lifecycle_2.dispose(this._disposables);\n        }\n    };\n    ExperimentService = __decorate([\n        __param(0, storage_1.IStorageService),\n        __param(1, extensionManagement_1.IExtensionManagementService),\n        __param(2, textfiles_1.ITextFileService),\n        __param(3, environment_1.IEnvironmentService),\n        __param(4, telemetry_1.ITelemetryService),\n        __param(5, lifecycle_1.ILifecycleService),\n        __param(6, request_1.IRequestService),\n        __param(7, configuration_1.IConfigurationService)\n    ], ExperimentService);\n    exports.ExperimentService = ExperimentService;\n    function safeParse(text, defaultObject) {\n        try {\n            return text ? JSON.parse(text) || defaultObject : defaultObject;\n        }\n        catch (e) {\n            return defaultObject;\n        }\n    }\n});\n",null]}