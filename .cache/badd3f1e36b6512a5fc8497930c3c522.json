{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/model/textModelTokens.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/textModelTokens.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/arrays\", \"vs/base/common/errors\", \"vs/editor/common/core/lineTokens\", \"vs/editor/common/core/position\", \"vs/editor/common/modes\", \"vs/editor/common/modes/nullMode\"], function (require, exports, arrays, errors_1, lineTokens_1, position_1, modes_1, nullMode_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function getDefaultMetadata(topLevelLanguageId) {\n        return ((topLevelLanguageId << modes_1.MetadataConsts.LANGUAGEID_OFFSET)\n            | (modes_1.StandardTokenType.Other << modes_1.MetadataConsts.TOKEN_TYPE_OFFSET)\n            | (modes_1.FontStyle.None << modes_1.MetadataConsts.FONT_STYLE_OFFSET)\n            | (modes_1.ColorId.DefaultForeground << modes_1.MetadataConsts.FOREGROUND_OFFSET)\n            | (modes_1.ColorId.DefaultBackground << modes_1.MetadataConsts.BACKGROUND_OFFSET)) >>> 0;\n    }\n    const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\n    class ModelLineTokens {\n        constructor(state) {\n            this._state = state;\n            this._lineTokens = null;\n            this._invalid = true;\n        }\n        deleteBeginning(toChIndex) {\n            if (this._lineTokens === null || this._lineTokens === EMPTY_LINE_TOKENS) {\n                return;\n            }\n            this.delete(0, toChIndex);\n        }\n        deleteEnding(fromChIndex) {\n            if (this._lineTokens === null || this._lineTokens === EMPTY_LINE_TOKENS) {\n                return;\n            }\n            const tokens = new Uint32Array(this._lineTokens);\n            const lineTextLength = tokens[tokens.length - 2];\n            this.delete(fromChIndex, lineTextLength);\n        }\n        delete(fromChIndex, toChIndex) {\n            if (this._lineTokens === null || this._lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n                return;\n            }\n            const tokens = new Uint32Array(this._lineTokens);\n            const tokensCount = (tokens.length >>> 1);\n            // special case: deleting everything\n            if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n                this._lineTokens = EMPTY_LINE_TOKENS;\n                return;\n            }\n            const fromTokenIndex = lineTokens_1.LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n            const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n            const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n            if (toChIndex < fromTokenEndOffset) {\n                // the delete range is inside a single token\n                const delta = (toChIndex - fromChIndex);\n                for (let i = fromTokenIndex; i < tokensCount; i++) {\n                    tokens[i << 1] -= delta;\n                }\n                return;\n            }\n            let dest;\n            let lastEnd;\n            if (fromTokenStartOffset !== fromChIndex) {\n                tokens[fromTokenIndex << 1] = fromChIndex;\n                dest = ((fromTokenIndex + 1) << 1);\n                lastEnd = fromChIndex;\n            }\n            else {\n                dest = (fromTokenIndex << 1);\n                lastEnd = fromTokenStartOffset;\n            }\n            const delta = (toChIndex - fromChIndex);\n            for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n                const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n                if (tokenEndOffset > lastEnd) {\n                    tokens[dest++] = tokenEndOffset;\n                    tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n                    lastEnd = tokenEndOffset;\n                }\n            }\n            if (dest === tokens.length) {\n                // nothing to trim\n                return;\n            }\n            let tmp = new Uint32Array(dest);\n            tmp.set(tokens.subarray(0, dest), 0);\n            this._lineTokens = tmp.buffer;\n        }\n        append(_otherTokens) {\n            if (_otherTokens === EMPTY_LINE_TOKENS) {\n                return;\n            }\n            if (this._lineTokens === EMPTY_LINE_TOKENS) {\n                this._lineTokens = _otherTokens;\n                return;\n            }\n            if (this._lineTokens === null) {\n                return;\n            }\n            if (_otherTokens === null) {\n                // cannot determine combined line length...\n                this._lineTokens = null;\n                return;\n            }\n            const myTokens = new Uint32Array(this._lineTokens);\n            const otherTokens = new Uint32Array(_otherTokens);\n            const otherTokensCount = (otherTokens.length >>> 1);\n            let result = new Uint32Array(myTokens.length + otherTokens.length);\n            result.set(myTokens, 0);\n            let dest = myTokens.length;\n            const delta = myTokens[myTokens.length - 2];\n            for (let i = 0; i < otherTokensCount; i++) {\n                result[dest++] = otherTokens[(i << 1)] + delta;\n                result[dest++] = otherTokens[(i << 1) + 1];\n            }\n            this._lineTokens = result.buffer;\n        }\n        insert(chIndex, textLength) {\n            if (!this._lineTokens) {\n                // nothing to do\n                return;\n            }\n            const tokens = new Uint32Array(this._lineTokens);\n            const tokensCount = (tokens.length >>> 1);\n            let fromTokenIndex = lineTokens_1.LineTokens.findIndexInTokensArray(tokens, chIndex);\n            if (fromTokenIndex > 0) {\n                const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n                if (fromTokenStartOffset === chIndex) {\n                    fromTokenIndex--;\n                }\n            }\n            for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n                tokens[tokenIndex << 1] += textLength;\n            }\n        }\n    }\n    class ModelLinesTokens {\n        constructor(languageIdentifier, tokenizationSupport) {\n            this.languageIdentifier = languageIdentifier;\n            this.tokenizationSupport = tokenizationSupport;\n            this._tokens = [];\n            if (this.tokenizationSupport) {\n                let initialState = null;\n                try {\n                    initialState = this.tokenizationSupport.getInitialState();\n                }\n                catch (e) {\n                    errors_1.onUnexpectedError(e);\n                    this.tokenizationSupport = null;\n                }\n                if (initialState) {\n                    this._tokens[0] = new ModelLineTokens(initialState);\n                }\n            }\n            this._invalidLineStartIndex = 0;\n            this._lastState = null;\n        }\n        get inValidLineStartIndex() {\n            return this._invalidLineStartIndex;\n        }\n        getTokens(topLevelLanguageId, lineIndex, lineText) {\n            let rawLineTokens = null;\n            if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {\n                rawLineTokens = this._tokens[lineIndex]._lineTokens;\n            }\n            if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n                return new lineTokens_1.LineTokens(new Uint32Array(rawLineTokens), lineText);\n            }\n            let lineTokens = new Uint32Array(2);\n            lineTokens[0] = lineText.length;\n            lineTokens[1] = getDefaultMetadata(topLevelLanguageId);\n            return new lineTokens_1.LineTokens(lineTokens, lineText);\n        }\n        isCheapToTokenize(lineNumber) {\n            const firstInvalidLineNumber = this._invalidLineStartIndex + 1;\n            return (firstInvalidLineNumber >= lineNumber);\n        }\n        hasLinesToTokenize(buffer) {\n            return (this._invalidLineStartIndex < buffer.getLineCount());\n        }\n        invalidateLine(lineIndex) {\n            this._setIsInvalid(lineIndex, true);\n            if (lineIndex < this._invalidLineStartIndex) {\n                this._setIsInvalid(this._invalidLineStartIndex, true);\n                this._invalidLineStartIndex = lineIndex;\n            }\n        }\n        _setIsInvalid(lineIndex, invalid) {\n            if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {\n                this._tokens[lineIndex]._invalid = invalid;\n            }\n        }\n        _isInvalid(lineIndex) {\n            if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {\n                return this._tokens[lineIndex]._invalid;\n            }\n            return true;\n        }\n        _getState(lineIndex) {\n            if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {\n                return this._tokens[lineIndex]._state;\n            }\n            return null;\n        }\n        _setTokens(topLevelLanguageId, lineIndex, lineTextLength, tokens) {\n            let target;\n            if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {\n                target = this._tokens[lineIndex];\n            }\n            else {\n                target = new ModelLineTokens(null);\n                this._tokens[lineIndex] = target;\n            }\n            if (lineTextLength === 0) {\n                let hasDifferentLanguageId = false;\n                if (tokens && tokens.length > 1) {\n                    hasDifferentLanguageId = (modes_1.TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n                }\n                if (!hasDifferentLanguageId) {\n                    target._lineTokens = EMPTY_LINE_TOKENS;\n                    return;\n                }\n            }\n            if (!tokens || tokens.length === 0) {\n                tokens = new Uint32Array(2);\n                tokens[0] = 0;\n                tokens[1] = getDefaultMetadata(topLevelLanguageId);\n            }\n            lineTokens_1.LineTokens.convertToEndOffset(tokens, lineTextLength);\n            target._lineTokens = tokens.buffer;\n        }\n        _setState(lineIndex, state) {\n            if (lineIndex < this._tokens.length && this._tokens[lineIndex]) {\n                this._tokens[lineIndex]._state = state;\n            }\n            else {\n                const tmp = new ModelLineTokens(state);\n                this._tokens[lineIndex] = tmp;\n            }\n        }\n        //#region Editing\n        applyEdits(range, eolCount, firstLineLength) {\n            const deletingLinesCnt = range.endLineNumber - range.startLineNumber;\n            const insertingLinesCnt = eolCount;\n            const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n            for (let j = editingLinesCnt; j >= 0; j--) {\n                this.invalidateLine(range.startLineNumber + j - 1);\n            }\n            this._acceptDeleteRange(range);\n            this._acceptInsertText(new position_1.Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n        }\n        _acceptDeleteRange(range) {\n            const firstLineIndex = range.startLineNumber - 1;\n            if (firstLineIndex >= this._tokens.length) {\n                return;\n            }\n            if (range.startLineNumber === range.endLineNumber) {\n                if (range.startColumn === range.endColumn) {\n                    // Nothing to delete\n                    return;\n                }\n                this._tokens[firstLineIndex].delete(range.startColumn - 1, range.endColumn - 1);\n                return;\n            }\n            const firstLine = this._tokens[firstLineIndex];\n            firstLine.deleteEnding(range.startColumn - 1);\n            const lastLineIndex = range.endLineNumber - 1;\n            let lastLineTokens = null;\n            if (lastLineIndex < this._tokens.length) {\n                const lastLine = this._tokens[lastLineIndex];\n                lastLine.deleteBeginning(range.endColumn - 1);\n                lastLineTokens = lastLine._lineTokens;\n            }\n            // Take remaining text on last line and append it to remaining text on first line\n            firstLine.append(lastLineTokens);\n            // Delete middle lines\n            this._tokens.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        }\n        _acceptInsertText(position, eolCount, firstLineLength) {\n            if (eolCount === 0 && firstLineLength === 0) {\n                // Nothing to insert\n                return;\n            }\n            const lineIndex = position.lineNumber - 1;\n            if (lineIndex >= this._tokens.length) {\n                return;\n            }\n            if (eolCount === 0) {\n                // Inserting text on one line\n                this._tokens[lineIndex].insert(position.column - 1, firstLineLength);\n                return;\n            }\n            const line = this._tokens[lineIndex];\n            line.deleteEnding(position.column - 1);\n            line.insert(position.column - 1, firstLineLength);\n            let insert = new Array(eolCount);\n            for (let i = eolCount - 1; i >= 0; i--) {\n                insert[i] = new ModelLineTokens(null);\n            }\n            this._tokens = arrays.arrayInsert(this._tokens, position.lineNumber, insert);\n        }\n        //#endregion\n        //#region Tokenization\n        _tokenizeOneLine(buffer, eventBuilder) {\n            if (!this.hasLinesToTokenize(buffer)) {\n                return buffer.getLineCount() + 1;\n            }\n            const lineNumber = this._invalidLineStartIndex + 1;\n            this._updateTokensUntilLine(buffer, eventBuilder, lineNumber);\n            return lineNumber;\n        }\n        _tokenizeText(buffer, text, state) {\n            let r = null;\n            if (this.tokenizationSupport) {\n                try {\n                    r = this.tokenizationSupport.tokenize2(text, state, 0);\n                }\n                catch (e) {\n                    errors_1.onUnexpectedError(e);\n                }\n            }\n            if (!r) {\n                r = nullMode_1.nullTokenize2(this.languageIdentifier.id, text, state, 0);\n            }\n            return r;\n        }\n        _updateTokensUntilLine(buffer, eventBuilder, lineNumber) {\n            if (!this.tokenizationSupport) {\n                this._invalidLineStartIndex = buffer.getLineCount();\n                return;\n            }\n            const linesLength = buffer.getLineCount();\n            const endLineIndex = lineNumber - 1;\n            // Validate all states up to and including endLineIndex\n            for (let lineIndex = this._invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {\n                const endStateIndex = lineIndex + 1;\n                const text = buffer.getLineContent(lineIndex + 1);\n                const lineStartState = this._getState(lineIndex);\n                let r = null;\n                try {\n                    // Tokenize only the first X characters\n                    let freshState = lineStartState.clone();\n                    r = this.tokenizationSupport.tokenize2(text, freshState, 0);\n                }\n                catch (e) {\n                    errors_1.onUnexpectedError(e);\n                }\n                if (!r) {\n                    r = nullMode_1.nullTokenize2(this.languageIdentifier.id, text, lineStartState, 0);\n                }\n                this._setTokens(this.languageIdentifier.id, lineIndex, text.length, r.tokens);\n                eventBuilder.registerChangedTokens(lineIndex + 1);\n                this._setIsInvalid(lineIndex, false);\n                if (endStateIndex < linesLength) {\n                    const previousEndState = this._getState(endStateIndex);\n                    if (previousEndState !== null && r.endState.equals(previousEndState)) {\n                        // The end state of this line remains the same\n                        let nextInvalidLineIndex = lineIndex + 1;\n                        while (nextInvalidLineIndex < linesLength) {\n                            if (this._isInvalid(nextInvalidLineIndex)) {\n                                break;\n                            }\n                            if (nextInvalidLineIndex + 1 < linesLength) {\n                                if (this._getState(nextInvalidLineIndex + 1) === null) {\n                                    break;\n                                }\n                            }\n                            else {\n                                if (this._lastState === null) {\n                                    break;\n                                }\n                            }\n                            nextInvalidLineIndex++;\n                        }\n                        this._invalidLineStartIndex = Math.max(this._invalidLineStartIndex, nextInvalidLineIndex);\n                        lineIndex = nextInvalidLineIndex - 1; // -1 because the outer loop increments it\n                    }\n                    else {\n                        this._setState(endStateIndex, r.endState);\n                    }\n                }\n                else {\n                    this._lastState = r.endState;\n                }\n            }\n            this._invalidLineStartIndex = Math.max(this._invalidLineStartIndex, endLineIndex + 1);\n        }\n    }\n    exports.ModelLinesTokens = ModelLinesTokens;\n    class ModelTokensChangedEventBuilder {\n        constructor() {\n            this._ranges = [];\n        }\n        registerChangedTokens(lineNumber) {\n            const ranges = this._ranges;\n            const rangesLength = ranges.length;\n            const previousRange = rangesLength > 0 ? ranges[rangesLength - 1] : null;\n            if (previousRange && previousRange.toLineNumber === lineNumber - 1) {\n                // extend previous range\n                previousRange.toLineNumber++;\n            }\n            else {\n                // insert new range\n                ranges[rangesLength] = {\n                    fromLineNumber: lineNumber,\n                    toLineNumber: lineNumber\n                };\n            }\n        }\n        build() {\n            if (this._ranges.length === 0) {\n                return null;\n            }\n            return {\n                tokenizationSupportChanged: false,\n                ranges: this._ranges\n            };\n        }\n    }\n    exports.ModelTokensChangedEventBuilder = ModelTokensChangedEventBuilder;\n});\n",null]}