{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/model/wordHelper.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/wordHelper.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n    /**\n     * Create a word definition regular expression based on default word separators.\n     * Optionally provide allowed separators that should be included in words.\n     *\n     * The default would look like this:\n     * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n     */\n    function createWordRegExp(allowInWords = '') {\n        let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n        for (const sep of exports.USUAL_WORD_SEPARATORS) {\n            if (allowInWords.indexOf(sep) >= 0) {\n                continue;\n            }\n            source += '\\\\' + sep;\n        }\n        source += '\\\\s]+)';\n        return new RegExp(source, 'g');\n    }\n    // catches numbers (including floating numbers) in the first group, and alphanum in the second\n    exports.DEFAULT_WORD_REGEXP = createWordRegExp();\n    function ensureValidWordDefinition(wordDefinition) {\n        let result = exports.DEFAULT_WORD_REGEXP;\n        if (wordDefinition && (wordDefinition instanceof RegExp)) {\n            if (!wordDefinition.global) {\n                let flags = 'g';\n                if (wordDefinition.ignoreCase) {\n                    flags += 'i';\n                }\n                if (wordDefinition.multiline) {\n                    flags += 'm';\n                }\n                if (wordDefinition.unicode) {\n                    flags += 'u';\n                }\n                result = new RegExp(wordDefinition.source, flags);\n            }\n            else {\n                result = wordDefinition;\n            }\n        }\n        result.lastIndex = 0;\n        return result;\n    }\n    exports.ensureValidWordDefinition = ensureValidWordDefinition;\n    function getWordAtPosFast(column, wordDefinition, text, textOffset) {\n        // find whitespace enclosed text around column and match from there\n        let pos = column - 1 - textOffset;\n        let start = text.lastIndexOf(' ', pos - 1) + 1;\n        wordDefinition.lastIndex = start;\n        let match;\n        while (match = wordDefinition.exec(text)) {\n            const matchIndex = match.index || 0;\n            if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n                return {\n                    word: match[0],\n                    startColumn: textOffset + 1 + matchIndex,\n                    endColumn: textOffset + 1 + wordDefinition.lastIndex\n                };\n            }\n        }\n        return null;\n    }\n    function getWordAtPosSlow(column, wordDefinition, text, textOffset) {\n        // matches all words starting at the beginning\n        // of the input until it finds a match that encloses\n        // the desired column. slow but correct\n        let pos = column - 1 - textOffset;\n        wordDefinition.lastIndex = 0;\n        let match;\n        while (match = wordDefinition.exec(text)) {\n            const matchIndex = match.index || 0;\n            if (matchIndex > pos) {\n                // |nW -> matched only after the pos\n                return null;\n            }\n            else if (wordDefinition.lastIndex >= pos) {\n                // W|W -> match encloses pos\n                return {\n                    word: match[0],\n                    startColumn: textOffset + 1 + matchIndex,\n                    endColumn: textOffset + 1 + wordDefinition.lastIndex\n                };\n            }\n        }\n        return null;\n    }\n    function getWordAtText(column, wordDefinition, text, textOffset) {\n        // if `words` can contain whitespace character we have to use the slow variant\n        // otherwise we use the fast variant of finding a word\n        wordDefinition.lastIndex = 0;\n        let match = wordDefinition.exec(text);\n        if (!match) {\n            return null;\n        }\n        // todo@joh the `match` could already be the (first) word\n        const ret = match[0].indexOf(' ') >= 0\n            // did match a word which contains a space character -> use slow word find\n            ? getWordAtPosSlow(column, wordDefinition, text, textOffset)\n            // sane word definition -> use fast word find\n            : getWordAtPosFast(column, wordDefinition, text, textOffset);\n        // both (getWordAtPosFast and getWordAtPosSlow) leave the wordDefinition-RegExp\n        // in an undefined state and to not confuse other users of the wordDefinition\n        // we reset the lastIndex\n        wordDefinition.lastIndex = 0;\n        return ret;\n    }\n    exports.getWordAtText = getWordAtText;\n});\n",null]}