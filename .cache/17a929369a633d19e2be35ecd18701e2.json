{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/contextkey/common/contextkey.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/contextkey/common/contextkey.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/strings\", \"vs/platform/instantiation/common/instantiation\"], function (require, exports, strings_1, instantiation_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var ContextKeyExprType;\n    (function (ContextKeyExprType) {\n        ContextKeyExprType[ContextKeyExprType[\"Defined\"] = 1] = \"Defined\";\n        ContextKeyExprType[ContextKeyExprType[\"Not\"] = 2] = \"Not\";\n        ContextKeyExprType[ContextKeyExprType[\"Equals\"] = 3] = \"Equals\";\n        ContextKeyExprType[ContextKeyExprType[\"NotEquals\"] = 4] = \"NotEquals\";\n        ContextKeyExprType[ContextKeyExprType[\"And\"] = 5] = \"And\";\n        ContextKeyExprType[ContextKeyExprType[\"Regex\"] = 6] = \"Regex\";\n    })(ContextKeyExprType = exports.ContextKeyExprType || (exports.ContextKeyExprType = {}));\n    class ContextKeyExpr {\n        static has(key) {\n            return new ContextKeyDefinedExpr(key);\n        }\n        static equals(key, value) {\n            return new ContextKeyEqualsExpr(key, value);\n        }\n        static notEquals(key, value) {\n            return new ContextKeyNotEqualsExpr(key, value);\n        }\n        static regex(key, value) {\n            return new ContextKeyRegexExpr(key, value);\n        }\n        static not(key) {\n            return new ContextKeyNotExpr(key);\n        }\n        static and(...expr) {\n            return new ContextKeyAndExpr(expr);\n        }\n        static deserialize(serialized, strict = false) {\n            if (!serialized) {\n                return undefined;\n            }\n            let pieces = serialized.split('&&');\n            let result = new ContextKeyAndExpr(pieces.map(p => this._deserializeOne(p, strict)));\n            return result.normalize();\n        }\n        static _deserializeOne(serializedOne, strict) {\n            serializedOne = serializedOne.trim();\n            if (serializedOne.indexOf('!=') >= 0) {\n                let pieces = serializedOne.split('!=');\n                return new ContextKeyNotEqualsExpr(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n            }\n            if (serializedOne.indexOf('==') >= 0) {\n                let pieces = serializedOne.split('==');\n                return new ContextKeyEqualsExpr(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n            }\n            if (serializedOne.indexOf('=~') >= 0) {\n                let pieces = serializedOne.split('=~');\n                return new ContextKeyRegexExpr(pieces[0].trim(), this._deserializeRegexValue(pieces[1], strict));\n            }\n            if (/^\\!\\s*/.test(serializedOne)) {\n                return new ContextKeyNotExpr(serializedOne.substr(1).trim());\n            }\n            return new ContextKeyDefinedExpr(serializedOne);\n        }\n        static _deserializeValue(serializedValue, strict) {\n            serializedValue = serializedValue.trim();\n            if (serializedValue === 'true') {\n                return true;\n            }\n            if (serializedValue === 'false') {\n                return false;\n            }\n            let m = /^'([^']*)'$/.exec(serializedValue);\n            if (m) {\n                return m[1].trim();\n            }\n            return serializedValue;\n        }\n        static _deserializeRegexValue(serializedValue, strict) {\n            if (strings_1.isFalsyOrWhitespace(serializedValue)) {\n                if (strict) {\n                    throw new Error('missing regexp-value for =~-expression');\n                }\n                else {\n                    console.warn('missing regexp-value for =~-expression');\n                }\n                return null;\n            }\n            let start = serializedValue.indexOf('/');\n            let end = serializedValue.lastIndexOf('/');\n            if (start === end || start < 0 /* || to < 0 */) {\n                if (strict) {\n                    throw new Error(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n                }\n                else {\n                    console.warn(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n                }\n                return null;\n            }\n            let value = serializedValue.slice(start + 1, end);\n            let caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n            try {\n                return new RegExp(value, caseIgnoreFlag);\n            }\n            catch (e) {\n                if (strict) {\n                    throw new Error(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n                }\n                else {\n                    console.warn(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n                }\n                return null;\n            }\n        }\n    }\n    exports.ContextKeyExpr = ContextKeyExpr;\n    function cmp(a, b) {\n        let aType = a.getType();\n        let bType = b.getType();\n        if (aType !== bType) {\n            return aType - bType;\n        }\n        switch (aType) {\n            case ContextKeyExprType.Defined:\n                return a.cmp(b);\n            case ContextKeyExprType.Not:\n                return a.cmp(b);\n            case ContextKeyExprType.Equals:\n                return a.cmp(b);\n            case ContextKeyExprType.NotEquals:\n                return a.cmp(b);\n            case ContextKeyExprType.Regex:\n                return a.cmp(b);\n            default:\n                throw new Error('Unknown ContextKeyExpr!');\n        }\n    }\n    class ContextKeyDefinedExpr {\n        constructor(key) {\n            this.key = key;\n        }\n        getType() {\n            return ContextKeyExprType.Defined;\n        }\n        cmp(other) {\n            if (this.key < other.key) {\n                return -1;\n            }\n            if (this.key > other.key) {\n                return 1;\n            }\n            return 0;\n        }\n        equals(other) {\n            if (other instanceof ContextKeyDefinedExpr) {\n                return (this.key === other.key);\n            }\n            return false;\n        }\n        evaluate(context) {\n            return (!!context.getValue(this.key));\n        }\n        normalize() {\n            return this;\n        }\n        serialize() {\n            return this.key;\n        }\n        keys() {\n            return [this.key];\n        }\n        map(mapFnc) {\n            return mapFnc.mapDefined(this.key);\n        }\n    }\n    exports.ContextKeyDefinedExpr = ContextKeyDefinedExpr;\n    class ContextKeyEqualsExpr {\n        constructor(key, value) {\n            this.key = key;\n            this.value = value;\n        }\n        getType() {\n            return ContextKeyExprType.Equals;\n        }\n        cmp(other) {\n            if (this.key < other.key) {\n                return -1;\n            }\n            if (this.key > other.key) {\n                return 1;\n            }\n            if (this.value < other.value) {\n                return -1;\n            }\n            if (this.value > other.value) {\n                return 1;\n            }\n            return 0;\n        }\n        equals(other) {\n            if (other instanceof ContextKeyEqualsExpr) {\n                return (this.key === other.key && this.value === other.value);\n            }\n            return false;\n        }\n        evaluate(context) {\n            /* tslint:disable:triple-equals */\n            // Intentional ==\n            return (context.getValue(this.key) == this.value);\n            /* tslint:enable:triple-equals */\n        }\n        normalize() {\n            if (typeof this.value === 'boolean') {\n                if (this.value) {\n                    return new ContextKeyDefinedExpr(this.key);\n                }\n                return new ContextKeyNotExpr(this.key);\n            }\n            return this;\n        }\n        serialize() {\n            if (typeof this.value === 'boolean') {\n                return this.normalize().serialize();\n            }\n            return this.key + ' == \\'' + this.value + '\\'';\n        }\n        keys() {\n            return [this.key];\n        }\n        map(mapFnc) {\n            return mapFnc.mapEquals(this.key, this.value);\n        }\n    }\n    exports.ContextKeyEqualsExpr = ContextKeyEqualsExpr;\n    class ContextKeyNotEqualsExpr {\n        constructor(key, value) {\n            this.key = key;\n            this.value = value;\n        }\n        getType() {\n            return ContextKeyExprType.NotEquals;\n        }\n        cmp(other) {\n            if (this.key < other.key) {\n                return -1;\n            }\n            if (this.key > other.key) {\n                return 1;\n            }\n            if (this.value < other.value) {\n                return -1;\n            }\n            if (this.value > other.value) {\n                return 1;\n            }\n            return 0;\n        }\n        equals(other) {\n            if (other instanceof ContextKeyNotEqualsExpr) {\n                return (this.key === other.key && this.value === other.value);\n            }\n            return false;\n        }\n        evaluate(context) {\n            /* tslint:disable:triple-equals */\n            // Intentional !=\n            return (context.getValue(this.key) != this.value);\n            /* tslint:enable:triple-equals */\n        }\n        normalize() {\n            if (typeof this.value === 'boolean') {\n                if (this.value) {\n                    return new ContextKeyNotExpr(this.key);\n                }\n                return new ContextKeyDefinedExpr(this.key);\n            }\n            return this;\n        }\n        serialize() {\n            if (typeof this.value === 'boolean') {\n                return this.normalize().serialize();\n            }\n            return this.key + ' != \\'' + this.value + '\\'';\n        }\n        keys() {\n            return [this.key];\n        }\n        map(mapFnc) {\n            return mapFnc.mapNotEquals(this.key, this.value);\n        }\n    }\n    exports.ContextKeyNotEqualsExpr = ContextKeyNotEqualsExpr;\n    class ContextKeyNotExpr {\n        constructor(key) {\n            this.key = key;\n        }\n        getType() {\n            return ContextKeyExprType.Not;\n        }\n        cmp(other) {\n            if (this.key < other.key) {\n                return -1;\n            }\n            if (this.key > other.key) {\n                return 1;\n            }\n            return 0;\n        }\n        equals(other) {\n            if (other instanceof ContextKeyNotExpr) {\n                return (this.key === other.key);\n            }\n            return false;\n        }\n        evaluate(context) {\n            return (!context.getValue(this.key));\n        }\n        normalize() {\n            return this;\n        }\n        serialize() {\n            return '!' + this.key;\n        }\n        keys() {\n            return [this.key];\n        }\n        map(mapFnc) {\n            return mapFnc.mapNot(this.key);\n        }\n    }\n    exports.ContextKeyNotExpr = ContextKeyNotExpr;\n    class ContextKeyRegexExpr {\n        constructor(key, regexp) {\n            this.key = key;\n            this.regexp = regexp;\n            //\n        }\n        getType() {\n            return ContextKeyExprType.Regex;\n        }\n        cmp(other) {\n            if (this.key < other.key) {\n                return -1;\n            }\n            if (this.key > other.key) {\n                return 1;\n            }\n            const thisSource = this.regexp ? this.regexp.source : '';\n            const otherSource = other.regexp ? other.regexp.source : '';\n            if (thisSource < otherSource) {\n                return -1;\n            }\n            if (thisSource > otherSource) {\n                return 1;\n            }\n            return 0;\n        }\n        equals(other) {\n            if (other instanceof ContextKeyRegexExpr) {\n                const thisSource = this.regexp ? this.regexp.source : '';\n                const otherSource = other.regexp ? other.regexp.source : '';\n                return (this.key === other.key && thisSource === otherSource);\n            }\n            return false;\n        }\n        evaluate(context) {\n            let value = context.getValue(this.key);\n            return this.regexp ? this.regexp.test(value) : false;\n        }\n        normalize() {\n            return this;\n        }\n        serialize() {\n            const value = this.regexp\n                ? `/${this.regexp.source}/${this.regexp.ignoreCase ? 'i' : ''}`\n                : '/invalid/';\n            return `${this.key} =~ ${value}`;\n        }\n        keys() {\n            return [this.key];\n        }\n        map(mapFnc) {\n            return mapFnc.mapRegex(this.key, this.regexp);\n        }\n    }\n    exports.ContextKeyRegexExpr = ContextKeyRegexExpr;\n    class ContextKeyAndExpr {\n        constructor(expr) {\n            this.expr = ContextKeyAndExpr._normalizeArr(expr);\n        }\n        getType() {\n            return ContextKeyExprType.And;\n        }\n        equals(other) {\n            if (other instanceof ContextKeyAndExpr) {\n                if (this.expr.length !== other.expr.length) {\n                    return false;\n                }\n                for (let i = 0, len = this.expr.length; i < len; i++) {\n                    if (!this.expr[i].equals(other.expr[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n        evaluate(context) {\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].evaluate(context)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        static _normalizeArr(arr) {\n            let expr = [];\n            if (arr) {\n                for (let i = 0, len = arr.length; i < len; i++) {\n                    let e = arr[i];\n                    if (!e) {\n                        continue;\n                    }\n                    e = e.normalize();\n                    if (!e) {\n                        continue;\n                    }\n                    if (e instanceof ContextKeyAndExpr) {\n                        expr = expr.concat(e.expr);\n                        continue;\n                    }\n                    expr.push(e);\n                }\n                expr.sort(cmp);\n            }\n            return expr;\n        }\n        normalize() {\n            if (this.expr.length === 0) {\n                return undefined;\n            }\n            if (this.expr.length === 1) {\n                return this.expr[0];\n            }\n            return this;\n        }\n        serialize() {\n            if (this.expr.length === 0) {\n                return '';\n            }\n            if (this.expr.length === 1) {\n                const normalized = this.normalize();\n                if (!normalized) {\n                    return '';\n                }\n                return normalized.serialize();\n            }\n            return this.expr.map(e => e.serialize()).join(' && ');\n        }\n        keys() {\n            const result = [];\n            for (let expr of this.expr) {\n                result.push(...expr.keys());\n            }\n            return result;\n        }\n        map(mapFnc) {\n            return new ContextKeyAndExpr(this.expr.map(expr => expr.map(mapFnc)));\n        }\n    }\n    exports.ContextKeyAndExpr = ContextKeyAndExpr;\n    class RawContextKey extends ContextKeyDefinedExpr {\n        constructor(key, defaultValue) {\n            super(key);\n            this._defaultValue = defaultValue;\n        }\n        bindTo(target) {\n            return target.createKey(this.key, this._defaultValue);\n        }\n        getValue(target) {\n            return target.getContextKeyValue(this.key);\n        }\n        toNegated() {\n            return ContextKeyExpr.not(this.key);\n        }\n        isEqualTo(value) {\n            return ContextKeyExpr.equals(this.key, value);\n        }\n        notEqualsTo(value) {\n            return ContextKeyExpr.notEquals(this.key, value);\n        }\n    }\n    exports.RawContextKey = RawContextKey;\n    exports.IContextKeyService = instantiation_1.createDecorator('contextKeyService');\n    exports.SET_CONTEXT_COMMAND_ID = 'setContext';\n});\n",null]}