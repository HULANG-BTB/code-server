{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/syntaxRangeProvider.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/syntaxRangeProvider.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/errors\", \"./foldingRanges\"], function (require, exports, errors_1, foldingRanges_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const MAX_FOLDING_REGIONS = 5000;\n    const foldingContext = {};\n    exports.ID_SYNTAX_PROVIDER = 'syntax';\n    class SyntaxRangeProvider {\n        constructor(editorModel, providers, limit = MAX_FOLDING_REGIONS) {\n            this.editorModel = editorModel;\n            this.providers = providers;\n            this.limit = limit;\n            this.id = exports.ID_SYNTAX_PROVIDER;\n        }\n        compute(cancellationToken) {\n            return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then(ranges => {\n                if (ranges) {\n                    let res = sanitizeRanges(ranges, this.limit);\n                    return res;\n                }\n                return null;\n            });\n        }\n        dispose() {\n        }\n    }\n    exports.SyntaxRangeProvider = SyntaxRangeProvider;\n    function collectSyntaxRanges(providers, model, cancellationToken) {\n        let rangeData = null;\n        let promises = providers.map((provider, i) => {\n            return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then(ranges => {\n                if (cancellationToken.isCancellationRequested) {\n                    return;\n                }\n                if (Array.isArray(ranges)) {\n                    if (!Array.isArray(rangeData)) {\n                        rangeData = [];\n                    }\n                    let nLines = model.getLineCount();\n                    for (let r of ranges) {\n                        if (r.start > 0 && r.end > r.start && r.end <= nLines) {\n                            rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });\n                        }\n                    }\n                }\n            }, errors_1.onUnexpectedExternalError);\n        });\n        return Promise.all(promises).then(_ => {\n            return rangeData;\n        });\n    }\n    class RangesCollector {\n        constructor(foldingRangesLimit) {\n            this._startIndexes = [];\n            this._endIndexes = [];\n            this._nestingLevels = [];\n            this._nestingLevelCounts = [];\n            this._types = [];\n            this._length = 0;\n            this._foldingRangesLimit = foldingRangesLimit;\n        }\n        add(startLineNumber, endLineNumber, type, nestingLevel) {\n            if (startLineNumber > foldingRanges_1.MAX_LINE_NUMBER || endLineNumber > foldingRanges_1.MAX_LINE_NUMBER) {\n                return;\n            }\n            let index = this._length;\n            this._startIndexes[index] = startLineNumber;\n            this._endIndexes[index] = endLineNumber;\n            this._nestingLevels[index] = nestingLevel;\n            this._types[index] = type;\n            this._length++;\n            if (nestingLevel < 30) {\n                this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;\n            }\n        }\n        toIndentRanges() {\n            if (this._length <= this._foldingRangesLimit) {\n                let startIndexes = new Uint32Array(this._length);\n                let endIndexes = new Uint32Array(this._length);\n                for (let i = 0; i < this._length; i++) {\n                    startIndexes[i] = this._startIndexes[i];\n                    endIndexes[i] = this._endIndexes[i];\n                }\n                return new foldingRanges_1.FoldingRegions(startIndexes, endIndexes, this._types);\n            }\n            else {\n                let entries = 0;\n                let maxLevel = this._nestingLevelCounts.length;\n                for (let i = 0; i < this._nestingLevelCounts.length; i++) {\n                    let n = this._nestingLevelCounts[i];\n                    if (n) {\n                        if (n + entries > this._foldingRangesLimit) {\n                            maxLevel = i;\n                            break;\n                        }\n                        entries += n;\n                    }\n                }\n                let startIndexes = new Uint32Array(this._foldingRangesLimit);\n                let endIndexes = new Uint32Array(this._foldingRangesLimit);\n                let types = [];\n                for (let i = 0, k = 0; i < this._length; i++) {\n                    let level = this._nestingLevels[i];\n                    if (level < maxLevel || (level === maxLevel && entries++ < this._foldingRangesLimit)) {\n                        startIndexes[k] = this._startIndexes[i];\n                        endIndexes[k] = this._endIndexes[i];\n                        types[k] = this._types[i];\n                        k++;\n                    }\n                }\n                return new foldingRanges_1.FoldingRegions(startIndexes, endIndexes, types);\n            }\n        }\n    }\n    exports.RangesCollector = RangesCollector;\n    function sanitizeRanges(rangeData, limit) {\n        let sorted = rangeData.sort((d1, d2) => {\n            let diff = d1.start - d2.start;\n            if (diff === 0) {\n                diff = d1.rank - d2.rank;\n            }\n            return diff;\n        });\n        let collector = new RangesCollector(limit);\n        let top = undefined;\n        let previous = [];\n        for (let entry of sorted) {\n            if (!top) {\n                top = entry;\n                collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n            }\n            else {\n                if (entry.start > top.start) {\n                    if (entry.end <= top.end) {\n                        previous.push(top);\n                        top = entry;\n                        collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n                    }\n                    else {\n                        if (entry.start > top.end) {\n                            do {\n                                top = previous.pop();\n                            } while (top && entry.start > top.end);\n                            if (top) {\n                                previous.push(top);\n                            }\n                            top = entry;\n                        }\n                        collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n                    }\n                }\n            }\n        }\n        return collector.toIndentRanges();\n    }\n    exports.sanitizeRanges = sanitizeRanges;\n});\n",null]}