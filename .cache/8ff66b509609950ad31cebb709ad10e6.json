{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/search/common/queryBuilder.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/search/common/queryBuilder.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/arrays\", \"vs/base/common/collections\", \"vs/base/common/glob\", \"vs/base/common/labels\", \"vs/base/common/map\", \"vs/base/common/path\", \"vs/base/common/resources\", \"vs/base/common/strings\", \"vs/base/common/uri\", \"vs/editor/common/model/textModelSearch\", \"vs/nls\", \"vs/platform/configuration/common/configuration\", \"vs/platform/environment/common/environment\", \"vs/platform/workspace/common/workspace\", \"vs/workbench/services/search/common/search\", \"vs/base/common/network\"], function (require, exports, arrays, collections, glob, labels_1, map_1, path, resources_1, strings, uri_1, textModelSearch_1, nls, configuration_1, environment_1, workspace_1, search_1, network_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let QueryBuilder = class QueryBuilder {\n        constructor(configurationService, workspaceContextService, environmentService) {\n            this.configurationService = configurationService;\n            this.workspaceContextService = workspaceContextService;\n            this.environmentService = environmentService;\n        }\n        text(contentPattern, folderResources, options = {}) {\n            contentPattern = this.getContentPattern(contentPattern, options);\n            const searchConfig = this.configurationService.getValue();\n            const fallbackToPCRE = folderResources && folderResources.some(folder => {\n                const folderConfig = this.configurationService.getValue({ resource: folder });\n                return !folderConfig.search.useRipgrep;\n            });\n            const commonQuery = this.commonQuery(folderResources, options);\n            return Object.assign({}, commonQuery, { type: search_1.QueryType.Text, contentPattern, previewOptions: options.previewOptions, maxFileSize: options.maxFileSize, usePCRE2: searchConfig.search.usePCRE2 || fallbackToPCRE || false, beforeContext: options.beforeContext, afterContext: options.afterContext, userDisabledExcludesAndIgnoreFiles: options.disregardExcludeSettings && options.disregardIgnoreFiles });\n        }\n        /**\n         * Adjusts input pattern for config\n         */\n        getContentPattern(inputPattern, options) {\n            const searchConfig = this.configurationService.getValue();\n            if (inputPattern.isRegExp) {\n                inputPattern.pattern = inputPattern.pattern.replace(/\\r?\\n/g, '\\\\n');\n            }\n            const newPattern = Object.assign({}, inputPattern, { wordSeparators: searchConfig.editor.wordSeparators });\n            if (this.isCaseSensitive(inputPattern, options)) {\n                newPattern.isCaseSensitive = true;\n            }\n            if (this.isMultiline(inputPattern)) {\n                newPattern.isMultiline = true;\n            }\n            return newPattern;\n        }\n        file(folderResources, options = {}) {\n            const commonQuery = this.commonQuery(folderResources, options);\n            return Object.assign({}, commonQuery, { type: search_1.QueryType.File, filePattern: options.filePattern\n                    ? options.filePattern.trim()\n                    : options.filePattern, exists: options.exists, sortByScore: options.sortByScore, cacheKey: options.cacheKey });\n        }\n        commonQuery(folderResources = [], options = {}) {\n            let includeSearchPathsInfo = {};\n            if (options.includePattern) {\n                includeSearchPathsInfo = options.expandPatterns ?\n                    this.parseSearchPaths(options.includePattern) :\n                    { pattern: patternListToIExpression(options.includePattern) };\n            }\n            let excludeSearchPathsInfo = {};\n            if (options.excludePattern) {\n                excludeSearchPathsInfo = options.expandPatterns ?\n                    this.parseSearchPaths(options.excludePattern) :\n                    { pattern: patternListToIExpression(options.excludePattern) };\n            }\n            // Build folderQueries from searchPaths, if given, otherwise folderResources\n            const folderQueries = (includeSearchPathsInfo.searchPaths && includeSearchPathsInfo.searchPaths.length ?\n                includeSearchPathsInfo.searchPaths.map(searchPath => this.getFolderQueryForSearchPath(searchPath, options, excludeSearchPathsInfo)) :\n                folderResources.map(uri => this.getFolderQueryForRoot(uri, options, excludeSearchPathsInfo)))\n                .filter(query => !!query);\n            const queryProps = {\n                _reason: options._reason,\n                folderQueries,\n                usingSearchPaths: !!(includeSearchPathsInfo.searchPaths && includeSearchPathsInfo.searchPaths.length),\n                extraFileResources: options.extraFileResources,\n                excludePattern: excludeSearchPathsInfo.pattern,\n                includePattern: includeSearchPathsInfo.pattern,\n                maxResults: options.maxResults\n            };\n            // Filter extraFileResources against global include/exclude patterns - they are already expected to not belong to a workspace\n            const extraFileResources = options.extraFileResources && options.extraFileResources.filter(extraFile => search_1.pathIncludedInQuery(queryProps, extraFile.fsPath));\n            queryProps.extraFileResources = extraFileResources && extraFileResources.length ? extraFileResources : undefined;\n            return queryProps;\n        }\n        /**\n         * Resolve isCaseSensitive flag based on the query and the isSmartCase flag, for search providers that don't support smart case natively.\n         */\n        isCaseSensitive(contentPattern, options) {\n            if (options.isSmartCase) {\n                if (contentPattern.isRegExp) {\n                    // Consider it case sensitive if it contains an unescaped capital letter\n                    if (strings.containsUppercaseCharacter(contentPattern.pattern, true)) {\n                        return true;\n                    }\n                }\n                else if (strings.containsUppercaseCharacter(contentPattern.pattern)) {\n                    return true;\n                }\n            }\n            return !!contentPattern.isCaseSensitive;\n        }\n        isMultiline(contentPattern) {\n            if (contentPattern.isMultiline) {\n                return true;\n            }\n            if (contentPattern.isRegExp && textModelSearch_1.isMultilineRegexSource(contentPattern.pattern)) {\n                return true;\n            }\n            if (contentPattern.pattern.indexOf('\\n') >= 0) {\n                return true;\n            }\n            return !!contentPattern.isMultiline;\n        }\n        /**\n         * Take the includePattern as seen in the search viewlet, and split into components that look like searchPaths, and\n         * glob patterns. Glob patterns are expanded from 'foo/bar' to '{foo/bar/**, **\\/foo/bar}.\n         *\n         * Public for test.\n         */\n        parseSearchPaths(pattern) {\n            const isSearchPath = (segment) => {\n                // A segment is a search path if it is an absolute path or starts with ./, ../, .\\, or ..\\\n                return path.isAbsolute(segment) || /^\\.\\.?([\\/\\\\]|$)/.test(segment);\n            };\n            const segments = splitGlobPattern(pattern)\n                .map(segment => labels_1.untildify(segment, this.environmentService.userHome));\n            const groups = collections.groupBy(segments, segment => isSearchPath(segment) ? 'searchPaths' : 'exprSegments');\n            const expandedExprSegments = (groups.exprSegments || [])\n                .map(s => strings.rtrim(s, '/'))\n                .map(s => strings.rtrim(s, '\\\\'))\n                .map(p => {\n                if (p[0] === '.') {\n                    p = '*' + p; // convert \".js\" to \"*.js\"\n                }\n                return expandGlobalGlob(p);\n            });\n            const result = {};\n            const searchPaths = this.expandSearchPathPatterns(groups.searchPaths || []);\n            if (searchPaths && searchPaths.length) {\n                result.searchPaths = searchPaths;\n            }\n            const exprSegments = arrays.flatten(expandedExprSegments);\n            const includePattern = patternListToIExpression(...exprSegments);\n            if (includePattern) {\n                result.pattern = includePattern;\n            }\n            return result;\n        }\n        getExcludesForFolder(folderConfig, options) {\n            return options.disregardExcludeSettings ?\n                undefined :\n                search_1.getExcludes(folderConfig, !options.disregardSearchExcludeSettings);\n        }\n        /**\n         * Split search paths (./ or ../ or absolute paths in the includePatterns) into absolute paths and globs applied to those paths\n         */\n        expandSearchPathPatterns(searchPaths) {\n            if (this.workspaceContextService.getWorkbenchState() === workspace_1.WorkbenchState.EMPTY || !searchPaths || !searchPaths.length) {\n                // No workspace => ignore search paths\n                return [];\n            }\n            const expandedSearchPaths = arrays.flatten(searchPaths.map(searchPath => {\n                // 1 open folder => just resolve the search paths to absolute paths\n                let { pathPortion, globPortion } = splitGlobFromPath(searchPath);\n                if (globPortion) {\n                    globPortion = normalizeGlobPattern(globPortion);\n                }\n                // One pathPortion to multiple expanded search paths (eg duplicate matching workspace folders)\n                const oneExpanded = this.expandOneSearchPath(pathPortion);\n                // Expanded search paths to multiple resolved patterns (with ** and without)\n                return arrays.flatten(oneExpanded.map(oneExpandedResult => this.resolveOneSearchPathPattern(oneExpandedResult, globPortion)));\n            }));\n            const searchPathPatternMap = new Map();\n            expandedSearchPaths.forEach(oneSearchPathPattern => {\n                const key = oneSearchPathPattern.searchPath.toString();\n                const existing = searchPathPatternMap.get(key);\n                if (existing) {\n                    if (oneSearchPathPattern.pattern) {\n                        existing.pattern = existing.pattern || {};\n                        existing.pattern[oneSearchPathPattern.pattern] = true;\n                    }\n                }\n                else {\n                    searchPathPatternMap.set(key, {\n                        searchPath: oneSearchPathPattern.searchPath,\n                        pattern: oneSearchPathPattern.pattern ? patternListToIExpression(oneSearchPathPattern.pattern) : undefined\n                    });\n                }\n            });\n            return map_1.values(searchPathPatternMap);\n        }\n        /**\n         * Takes a searchPath like `./a/foo` or `../a/foo` and expands it to absolute paths for all the workspaces it matches.\n         */\n        expandOneSearchPath(searchPath) {\n            if (path.isAbsolute(searchPath)) {\n                const workspaceFolders = this.workspaceContextService.getWorkspace().folders;\n                if (workspaceFolders[0] && workspaceFolders[0].uri.scheme !== network_1.Schemas.file) {\n                    return [{\n                            searchPath: workspaceFolders[0].uri.with({ path: searchPath })\n                        }];\n                }\n                // Currently only local resources can be searched for with absolute search paths.\n                // TODO convert this to a workspace folder + pattern, so excludes will be resolved properly for an absolute path inside a workspace folder\n                return [{\n                        searchPath: uri_1.URI.file(path.normalize(searchPath))\n                    }];\n            }\n            if (this.workspaceContextService.getWorkbenchState() === workspace_1.WorkbenchState.FOLDER) {\n                const workspaceUri = this.workspaceContextService.getWorkspace().folders[0].uri;\n                searchPath = normalizeSlashes(searchPath);\n                if (strings.startsWith(searchPath, '../') || searchPath === '..') {\n                    const resolvedPath = path.posix.resolve(workspaceUri.path, searchPath);\n                    return [{\n                            searchPath: workspaceUri.with({ path: resolvedPath })\n                        }];\n                }\n                const cleanedPattern = normalizeGlobPattern(searchPath);\n                return [{\n                        searchPath: workspaceUri,\n                        pattern: cleanedPattern\n                    }];\n            }\n            else if (searchPath === './' || searchPath === '.\\\\') {\n                return []; // ./ or ./**/foo makes sense for single-folder but not multi-folder workspaces\n            }\n            else {\n                const relativeSearchPathMatch = searchPath.match(/\\.[\\/\\\\]([^\\/\\\\]+)(?:[\\/\\\\](.+))?/);\n                if (relativeSearchPathMatch) {\n                    const searchPathRoot = relativeSearchPathMatch[1];\n                    const matchingRoots = this.workspaceContextService.getWorkspace().folders.filter(folder => folder.name === searchPathRoot);\n                    if (matchingRoots.length) {\n                        return matchingRoots.map(root => {\n                            const patternMatch = relativeSearchPathMatch[2];\n                            return {\n                                searchPath: root.uri,\n                                pattern: patternMatch && normalizeGlobPattern(patternMatch)\n                            };\n                        });\n                    }\n                    else {\n                        // No root folder with name\n                        const searchPathNotFoundError = nls.localize('search.noWorkspaceWithName', \"No folder in workspace with name: {0}\", searchPathRoot);\n                        throw new Error(searchPathNotFoundError);\n                    }\n                }\n                else {\n                    // Malformed ./ search path, ignore\n                }\n            }\n            return [];\n        }\n        resolveOneSearchPathPattern(oneExpandedResult, globPortion) {\n            const pattern = oneExpandedResult.pattern && globPortion ?\n                `${oneExpandedResult.pattern}/${globPortion}` :\n                oneExpandedResult.pattern || globPortion;\n            const results = [\n                {\n                    searchPath: oneExpandedResult.searchPath,\n                    pattern\n                }\n            ];\n            if (pattern && !strings.endsWith(pattern, '**')) {\n                results.push({\n                    searchPath: oneExpandedResult.searchPath,\n                    pattern: pattern + '/**'\n                });\n            }\n            return results;\n        }\n        getFolderQueryForSearchPath(searchPath, options, searchPathExcludes) {\n            const rootConfig = this.getFolderQueryForRoot(searchPath.searchPath, options, searchPathExcludes);\n            if (!rootConfig) {\n                return null;\n            }\n            return Object.assign({}, rootConfig, {\n                includePattern: searchPath.pattern\n            });\n        }\n        getFolderQueryForRoot(folder, options, searchPathExcludes) {\n            let thisFolderExcludeSearchPathPattern;\n            if (searchPathExcludes.searchPaths) {\n                const thisFolderExcludeSearchPath = searchPathExcludes.searchPaths.filter(sp => resources_1.isEqual(sp.searchPath, folder))[0];\n                if (thisFolderExcludeSearchPath && !thisFolderExcludeSearchPath.pattern) {\n                    // entire folder is excluded\n                    return null;\n                }\n                else if (thisFolderExcludeSearchPath) {\n                    thisFolderExcludeSearchPathPattern = thisFolderExcludeSearchPath.pattern;\n                }\n            }\n            const folderConfig = this.configurationService.getValue({ resource: folder });\n            const settingExcludes = this.getExcludesForFolder(folderConfig, options);\n            const excludePattern = Object.assign({}, (settingExcludes || {}), (thisFolderExcludeSearchPathPattern || {}));\n            return {\n                folder,\n                excludePattern: Object.keys(excludePattern).length > 0 ? excludePattern : undefined,\n                fileEncoding: folderConfig.files && folderConfig.files.encoding,\n                disregardIgnoreFiles: typeof options.disregardIgnoreFiles === 'boolean' ? options.disregardIgnoreFiles : !folderConfig.search.useIgnoreFiles,\n                disregardGlobalIgnoreFiles: typeof options.disregardGlobalIgnoreFiles === 'boolean' ? options.disregardGlobalIgnoreFiles : !folderConfig.search.useGlobalIgnoreFiles,\n                ignoreSymlinks: typeof options.ignoreSymlinks === 'boolean' ? options.ignoreSymlinks : !folderConfig.search.followSymlinks,\n            };\n        }\n    };\n    QueryBuilder = __decorate([\n        __param(0, configuration_1.IConfigurationService),\n        __param(1, workspace_1.IWorkspaceContextService),\n        __param(2, environment_1.IEnvironmentService)\n    ], QueryBuilder);\n    exports.QueryBuilder = QueryBuilder;\n    function splitGlobFromPath(searchPath) {\n        const globCharMatch = searchPath.match(/[\\*\\{\\}\\(\\)\\[\\]\\?]/);\n        if (globCharMatch) {\n            const globCharIdx = globCharMatch.index;\n            const lastSlashMatch = searchPath.substr(0, globCharIdx).match(/[/|\\\\][^/\\\\]*$/);\n            if (lastSlashMatch) {\n                let pathPortion = searchPath.substr(0, lastSlashMatch.index);\n                if (!pathPortion.match(/[/\\\\]/)) {\n                    // If the last slash was the only slash, then we now have '' or 'C:' or '.'. Append a slash.\n                    pathPortion += '/';\n                }\n                return {\n                    pathPortion,\n                    globPortion: searchPath.substr((lastSlashMatch.index || 0) + 1)\n                };\n            }\n        }\n        // No glob char, or malformed\n        return {\n            pathPortion: searchPath\n        };\n    }\n    function patternListToIExpression(...patterns) {\n        return patterns.length ?\n            patterns.reduce((glob, cur) => { glob[cur] = true; return glob; }, Object.create(null)) :\n            undefined;\n    }\n    function splitGlobPattern(pattern) {\n        return glob.splitGlobAware(pattern, ',')\n            .map(s => s.trim())\n            .filter(s => !!s.length);\n    }\n    /**\n     * Note - we used {} here previously but ripgrep can't handle nested {} patterns. See https://github.com/Microsoft/vscode/issues/32761\n     */\n    function expandGlobalGlob(pattern) {\n        const patterns = [\n            `**/${pattern}/**`,\n            `**/${pattern}`\n        ];\n        return patterns.map(p => p.replace(/\\*\\*\\/\\*\\*/g, '**'));\n    }\n    function normalizeSlashes(pattern) {\n        return pattern.replace(/\\\\/g, '/');\n    }\n    /**\n     * Normalize slashes, remove `./` and trailing slashes\n     */\n    function normalizeGlobPattern(pattern) {\n        return normalizeSlashes(pattern)\n            .replace(/^\\.\\//, '')\n            .replace(/\\/+$/g, '');\n    }\n});\n",null]}