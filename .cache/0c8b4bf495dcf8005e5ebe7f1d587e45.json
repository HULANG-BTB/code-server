{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/common/search.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/common/search.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar arrays_1 = require(\"vs/base/common/arrays\");\nvar glob = require(\"vs/base/common/glob\");\nvar objects = require(\"vs/base/common/objects\");\nvar extpath = require(\"vs/base/common/extpath\");\nvar strings_1 = require(\"vs/base/common/strings\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar views_1 = require(\"vs/workbench/common/views\");\nvar platform_1 = require(\"vs/platform/registry/common/platform\");\nexports.VIEWLET_ID = 'workbench.view.search';\nexports.PANEL_ID = 'workbench.view.search';\nexports.VIEW_ID = 'workbench.view.search';\n/**\n * Search viewlet container.\n */\nexports.VIEW_CONTAINER = platform_1.Registry.as(views_1.Extensions.ViewContainersRegistry).registerViewContainer(exports.VIEWLET_ID, true);\nexports.ISearchService = instantiation_1.createDecorator('searchService');\n/**\n * TODO@roblou - split text from file search entirely, or share code in a more natural way.\n */\nvar SearchProviderType;\n(function (SearchProviderType) {\n    SearchProviderType[SearchProviderType[\"file\"] = 0] = \"file\";\n    SearchProviderType[SearchProviderType[\"text\"] = 1] = \"text\";\n})(SearchProviderType = exports.SearchProviderType || (exports.SearchProviderType = {}));\nvar QueryType;\n(function (QueryType) {\n    QueryType[QueryType[\"File\"] = 1] = \"File\";\n    QueryType[QueryType[\"Text\"] = 2] = \"Text\";\n})(QueryType = exports.QueryType || (exports.QueryType = {}));\nfunction resultIsMatch(result) {\n    return !!result.preview;\n}\nexports.resultIsMatch = resultIsMatch;\nfunction isFileMatch(p) {\n    return !!p.resource;\n}\nexports.isFileMatch = isFileMatch;\nfunction isProgressMessage(p) {\n    return !isFileMatch(p);\n}\nexports.isProgressMessage = isProgressMessage;\nvar FileMatch = /** @class */ (function () {\n    function FileMatch(resource) {\n        this.resource = resource;\n        this.results = [];\n        // empty\n    }\n    return FileMatch;\n}());\nexports.FileMatch = FileMatch;\nvar TextSearchMatch = /** @class */ (function () {\n    function TextSearchMatch(text, range, previewOptions) {\n        this.ranges = range;\n        if (previewOptions && previewOptions.matchLines === 1 && !Array.isArray(range)) {\n            // 1 line preview requested\n            text = strings_1.getNLines(text, previewOptions.matchLines);\n            var leadingChars = Math.floor(previewOptions.charsPerLine / 5);\n            var previewStart = Math.max(range.startColumn - leadingChars, 0);\n            var previewText = text.substring(previewStart, previewOptions.charsPerLine + previewStart);\n            var endColInPreview = (range.endLineNumber - range.startLineNumber + 1) <= previewOptions.matchLines ?\n                Math.min(previewText.length, range.endColumn - previewStart) : // if number of match lines will not be trimmed by previewOptions\n                previewText.length; // if number of lines is trimmed\n            this.preview = {\n                text: previewText,\n                matches: new OneLineRange(0, range.startColumn - previewStart, endColInPreview)\n            };\n        }\n        else {\n            var firstMatchLine_1 = Array.isArray(range) ? range[0].startLineNumber : range.startLineNumber;\n            // n line, no preview requested, or multiple matches in the preview\n            this.preview = {\n                text: text,\n                matches: arrays_1.mapArrayOrNot(range, function (r) { return new SearchRange(r.startLineNumber - firstMatchLine_1, r.startColumn, r.endLineNumber - firstMatchLine_1, r.endColumn); })\n            };\n        }\n    }\n    return TextSearchMatch;\n}());\nexports.TextSearchMatch = TextSearchMatch;\nvar SearchRange = /** @class */ (function () {\n    function SearchRange(startLineNumber, startColumn, endLineNumber, endColumn) {\n        this.startLineNumber = startLineNumber;\n        this.startColumn = startColumn;\n        this.endLineNumber = endLineNumber;\n        this.endColumn = endColumn;\n    }\n    return SearchRange;\n}());\nexports.SearchRange = SearchRange;\nvar OneLineRange = /** @class */ (function (_super) {\n    tslib_1.__extends(OneLineRange, _super);\n    function OneLineRange(lineNumber, startColumn, endColumn) {\n        return _super.call(this, lineNumber, startColumn, lineNumber, endColumn) || this;\n    }\n    return OneLineRange;\n}(SearchRange));\nexports.OneLineRange = OneLineRange;\nfunction getExcludes(configuration, includeSearchExcludes) {\n    if (includeSearchExcludes === void 0) { includeSearchExcludes = true; }\n    var fileExcludes = configuration && configuration.files && configuration.files.exclude;\n    var searchExcludes = includeSearchExcludes && configuration && configuration.search && configuration.search.exclude;\n    if (!fileExcludes && !searchExcludes) {\n        return undefined;\n    }\n    if (!fileExcludes || !searchExcludes) {\n        return fileExcludes || searchExcludes;\n    }\n    var allExcludes = Object.create(null);\n    // clone the config as it could be frozen\n    allExcludes = objects.mixin(allExcludes, objects.deepClone(fileExcludes));\n    allExcludes = objects.mixin(allExcludes, objects.deepClone(searchExcludes), true);\n    return allExcludes;\n}\nexports.getExcludes = getExcludes;\nfunction pathIncludedInQuery(queryProps, fsPath) {\n    if (queryProps.excludePattern && glob.match(queryProps.excludePattern, fsPath)) {\n        return false;\n    }\n    if (queryProps.includePattern && !glob.match(queryProps.includePattern, fsPath)) {\n        return false;\n    }\n    // If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present\n    if (queryProps.usingSearchPaths) {\n        return !!queryProps.folderQueries && queryProps.folderQueries.every(function (fq) {\n            var searchPath = fq.folder.fsPath;\n            if (extpath.isEqualOrParent(fsPath, searchPath)) {\n                return !fq.includePattern || !!glob.match(fq.includePattern, fsPath);\n            }\n            else {\n                return false;\n            }\n        });\n    }\n    return true;\n}\nexports.pathIncludedInQuery = pathIncludedInQuery;\nvar SearchErrorCode;\n(function (SearchErrorCode) {\n    SearchErrorCode[SearchErrorCode[\"unknownEncoding\"] = 1] = \"unknownEncoding\";\n    SearchErrorCode[SearchErrorCode[\"regexParseError\"] = 2] = \"regexParseError\";\n    SearchErrorCode[SearchErrorCode[\"globParseError\"] = 3] = \"globParseError\";\n    SearchErrorCode[SearchErrorCode[\"invalidLiteral\"] = 4] = \"invalidLiteral\";\n    SearchErrorCode[SearchErrorCode[\"rgProcessError\"] = 5] = \"rgProcessError\";\n    SearchErrorCode[SearchErrorCode[\"other\"] = 6] = \"other\";\n})(SearchErrorCode = exports.SearchErrorCode || (exports.SearchErrorCode = {}));\nvar SearchError = /** @class */ (function (_super) {\n    tslib_1.__extends(SearchError, _super);\n    function SearchError(message, code) {\n        var _this = _super.call(this, message) || this;\n        _this.code = code;\n        return _this;\n    }\n    return SearchError;\n}(Error));\nexports.SearchError = SearchError;\nfunction deserializeSearchError(errorMsg) {\n    try {\n        var details = JSON.parse(errorMsg);\n        return new SearchError(details.message, details.code);\n    }\n    catch (e) {\n        return new SearchError(errorMsg, SearchErrorCode.other);\n    }\n}\nexports.deserializeSearchError = deserializeSearchError;\nfunction serializeSearchError(searchError) {\n    var details = { message: searchError.message, code: searchError.code };\n    return new Error(JSON.stringify(details));\n}\nexports.serializeSearchError = serializeSearchError;\nfunction isSerializedSearchComplete(arg) {\n    if (arg.type === 'error') {\n        return true;\n    }\n    else if (arg.type === 'success') {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexports.isSerializedSearchComplete = isSerializedSearchComplete;\nfunction isSerializedSearchSuccess(arg) {\n    return arg.type === 'success';\n}\nexports.isSerializedSearchSuccess = isSerializedSearchSuccess;\nfunction isSerializedFileMatch(arg) {\n    return !!arg.path;\n}\nexports.isSerializedFileMatch = isSerializedFileMatch;\nvar SerializableFileMatch = /** @class */ (function () {\n    function SerializableFileMatch(path) {\n        this.path = path;\n        this.results = [];\n    }\n    SerializableFileMatch.prototype.addMatch = function (match) {\n        this.results.push(match);\n    };\n    SerializableFileMatch.prototype.serialize = function () {\n        return {\n            path: this.path,\n            results: this.results,\n            numMatches: this.results.length\n        };\n    };\n    return SerializableFileMatch;\n}());\nexports.SerializableFileMatch = SerializableFileMatch;\n/**\n *  Computes the patterns that the provider handles. Discards sibling clauses and 'false' patterns\n */\nfunction resolvePatternsForProvider(globalPattern, folderPattern) {\n    var merged = tslib_1.__assign({}, (globalPattern || {}), (folderPattern || {}));\n    return Object.keys(merged)\n        .filter(function (key) {\n        var value = merged[key];\n        return typeof value === 'boolean' && value;\n    });\n}\nexports.resolvePatternsForProvider = resolvePatternsForProvider;\nvar QueryGlobTester = /** @class */ (function () {\n    function QueryGlobTester(config, folderQuery) {\n        this._excludeExpression = tslib_1.__assign({}, (config.excludePattern || {}), (folderQuery.excludePattern || {}));\n        this._parsedExcludeExpression = glob.parse(this._excludeExpression);\n        // Empty includeExpression means include nothing, so no {} shortcuts\n        var includeExpression = config.includePattern;\n        if (folderQuery.includePattern) {\n            if (includeExpression) {\n                includeExpression = tslib_1.__assign({}, includeExpression, folderQuery.includePattern);\n            }\n            else {\n                includeExpression = folderQuery.includePattern;\n            }\n        }\n        if (includeExpression) {\n            this._parsedIncludeExpression = glob.parse(includeExpression);\n        }\n    }\n    /**\n     * Guaranteed sync - siblingsFn should not return a promise.\n     */\n    QueryGlobTester.prototype.includedInQuerySync = function (testPath, basename, hasSibling) {\n        if (this._parsedExcludeExpression && this._parsedExcludeExpression(testPath, basename, hasSibling)) {\n            return false;\n        }\n        if (this._parsedIncludeExpression && !this._parsedIncludeExpression(testPath, basename, hasSibling)) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Guaranteed async.\n     */\n    QueryGlobTester.prototype.includedInQuery = function (testPath, basename, hasSibling) {\n        var _this = this;\n        var excludeP = this._parsedExcludeExpression ?\n            Promise.resolve(this._parsedExcludeExpression(testPath, basename, hasSibling)).then(function (result) { return !!result; }) :\n            Promise.resolve(false);\n        return excludeP.then(function (excluded) {\n            if (excluded) {\n                return false;\n            }\n            return _this._parsedIncludeExpression ?\n                Promise.resolve(_this._parsedIncludeExpression(testPath, basename, hasSibling)).then(function (result) { return !!result; }) :\n                Promise.resolve(true);\n        }).then(function (included) {\n            return included;\n        });\n    };\n    QueryGlobTester.prototype.hasSiblingExcludeClauses = function () {\n        return hasSiblingClauses(this._excludeExpression);\n    };\n    return QueryGlobTester;\n}());\nexports.QueryGlobTester = QueryGlobTester;\nfunction hasSiblingClauses(pattern) {\n    for (var key in pattern) {\n        if (typeof pattern[key] !== 'boolean') {\n            return true;\n        }\n    }\n    return false;\n}\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/common/search.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/common/search.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { mapArrayOrNot } from 'vs/base/common/arrays';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport * as glob from 'vs/base/common/glob';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport * as objects from 'vs/base/common/objects';\nimport * as extpath from 'vs/base/common/extpath';\nimport { getNLines } from 'vs/base/common/strings';\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { IFilesConfiguration } from 'vs/platform/files/common/files';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { ITelemetryData } from 'vs/platform/telemetry/common/telemetry';\nimport { Event } from 'vs/base/common/event';\nimport { ViewContainer, IViewContainersRegistry, Extensions as ViewContainerExtensions } from 'vs/workbench/common/views';\nimport { Registry } from 'vs/platform/registry/common/platform';\n\nexport const VIEWLET_ID = 'workbench.view.search';\nexport const PANEL_ID = 'workbench.view.search';\nexport const VIEW_ID = 'workbench.view.search';\n/**\n * Search viewlet container.\n */\nexport const VIEW_CONTAINER: ViewContainer = Registry.as<IViewContainersRegistry>(ViewContainerExtensions.ViewContainersRegistry).registerViewContainer(VIEWLET_ID, true);\n\nexport const ISearchService = createDecorator<ISearchService>('searchService');\n\n/**\n * A service that enables to search for files or with in files.\n */\nexport interface ISearchService {\n\t_serviceBrand: any;\n\ttextSearch(query: ITextQuery, token?: CancellationToken, onProgress?: (result: ISearchProgressItem) => void): Promise<ISearchComplete>;\n\tfileSearch(query: IFileQuery, token?: CancellationToken): Promise<ISearchComplete>;\n\tclearCache(cacheKey: string): Promise<void>;\n\tregisterSearchResultProvider(scheme: string, type: SearchProviderType, provider: ISearchResultProvider): IDisposable;\n}\n\n/**\n * TODO@roblou - split text from file search entirely, or share code in a more natural way.\n */\nexport const enum SearchProviderType {\n\tfile,\n\ttext\n}\n\nexport interface ISearchResultProvider {\n\ttextSearch(query: ITextQuery, onProgress?: (p: ISearchProgressItem) => void, token?: CancellationToken): Promise<ISearchComplete>;\n\tfileSearch(query: IFileQuery, token?: CancellationToken): Promise<ISearchComplete>;\n\tclearCache(cacheKey: string): Promise<void>;\n}\n\nexport interface IFolderQuery<U extends UriComponents=URI> {\n\tfolder: U;\n\texcludePattern?: glob.IExpression;\n\tincludePattern?: glob.IExpression;\n\tfileEncoding?: string;\n\tdisregardIgnoreFiles?: boolean;\n\tdisregardGlobalIgnoreFiles?: boolean;\n\tignoreSymlinks?: boolean;\n}\n\nexport interface ICommonQueryProps<U extends UriComponents> {\n\t/** For telemetry - indicates what is triggering the source */\n\t_reason?: string;\n\n\tfolderQueries: IFolderQuery<U>[];\n\tincludePattern?: glob.IExpression;\n\texcludePattern?: glob.IExpression;\n\textraFileResources?: U[];\n\n\tmaxResults?: number;\n\tusingSearchPaths?: boolean;\n}\n\nexport interface IFileQueryProps<U extends UriComponents> extends ICommonQueryProps<U> {\n\ttype: QueryType.File;\n\tfilePattern?: string;\n\n\t/**\n\t * If true no results will be returned. Instead `limitHit` will indicate if at least one result exists or not.\n\t * Currently does not work with queries including a 'siblings clause'.\n\t */\n\texists?: boolean;\n\tsortByScore?: boolean;\n\tcacheKey?: string;\n}\n\nexport interface ITextQueryProps<U extends UriComponents> extends ICommonQueryProps<U> {\n\ttype: QueryType.Text;\n\tcontentPattern: IPatternInfo;\n\n\tpreviewOptions?: ITextSearchPreviewOptions;\n\tmaxFileSize?: number;\n\tusePCRE2?: boolean;\n\tafterContext?: number;\n\tbeforeContext?: number;\n\n\tuserDisabledExcludesAndIgnoreFiles?: boolean;\n}\n\nexport type IFileQuery = IFileQueryProps<URI>;\nexport type IRawFileQuery = IFileQueryProps<UriComponents>;\nexport type ITextQuery = ITextQueryProps<URI>;\nexport type IRawTextQuery = ITextQueryProps<UriComponents>;\n\nexport type IRawQuery = IRawTextQuery | IRawFileQuery;\nexport type ISearchQuery = ITextQuery | IFileQuery;\n\nexport const enum QueryType {\n\tFile = 1,\n\tText = 2\n}\n\n/* __GDPR__FRAGMENT__\n\t\"IPatternInfo\" : {\n\t\t\"pattern\" : { \"classification\": \"CustomerContent\", \"purpose\": \"FeatureInsight\" },\n\t\t\"isRegExp\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isWordMatch\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"wordSeparators\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"isMultiline\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isCaseSensitive\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isSmartCase\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n\t}\n*/\nexport interface IPatternInfo {\n\tpattern: string;\n\tisRegExp?: boolean;\n\tisWordMatch?: boolean;\n\twordSeparators?: string;\n\tisMultiline?: boolean;\n\tisCaseSensitive?: boolean;\n}\n\nexport interface IExtendedExtensionSearchOptions {\n\tusePCRE2?: boolean;\n}\n\nexport interface IFileMatch<U extends UriComponents = URI> {\n\tresource: U;\n\tresults?: ITextSearchResult[];\n}\n\nexport type IRawFileMatch2 = IFileMatch<UriComponents>;\n\nexport interface ITextSearchPreviewOptions {\n\tmatchLines: number;\n\tcharsPerLine: number;\n}\n\nexport interface ISearchRange {\n\treadonly startLineNumber: number;\n\treadonly startColumn: number;\n\treadonly endLineNumber: number;\n\treadonly endColumn: number;\n}\n\nexport interface ITextSearchResultPreview {\n\ttext: string;\n\tmatches: ISearchRange | ISearchRange[];\n}\n\nexport interface ITextSearchMatch {\n\turi?: URI;\n\tranges: ISearchRange | ISearchRange[];\n\tpreview: ITextSearchResultPreview;\n}\n\nexport interface ITextSearchContext {\n\turi?: URI;\n\ttext: string;\n\tlineNumber: number;\n}\n\nexport type ITextSearchResult = ITextSearchMatch | ITextSearchContext;\n\nexport function resultIsMatch(result: ITextSearchResult): result is ITextSearchMatch {\n\treturn !!(<ITextSearchMatch>result).preview;\n}\n\nexport interface IProgressMessage {\n\tmessage?: string;\n}\n\nexport type ISearchProgressItem = IFileMatch | IProgressMessage;\n\nexport function isFileMatch(p: ISearchProgressItem): p is IFileMatch {\n\treturn !!(<IFileMatch>p).resource;\n}\n\nexport function isProgressMessage(p: ISearchProgressItem): p is IProgressMessage {\n\treturn !isFileMatch(p);\n}\n\nexport interface ISearchCompleteStats {\n\tlimitHit?: boolean;\n\tstats?: IFileSearchStats | ITextSearchStats;\n}\n\nexport interface ISearchComplete extends ISearchCompleteStats {\n\tresults: IFileMatch[];\n}\n\nexport interface ITextSearchStats {\n\ttype: 'textSearchProvider' | 'searchProcess';\n}\n\nexport interface IFileSearchStats {\n\tfromCache: boolean;\n\tdetailStats: ISearchEngineStats | ICachedSearchStats | IFileSearchProviderStats;\n\n\tresultCount: number;\n\ttype: 'fileSearchProvider' | 'searchProcess';\n\tsortingTime?: number;\n}\n\nexport interface ICachedSearchStats {\n\tcacheWasResolved: boolean;\n\tcacheLookupTime: number;\n\tcacheFilterTime: number;\n\tcacheEntryCount: number;\n}\n\nexport interface ISearchEngineStats {\n\tfileWalkTime: number;\n\tdirectoriesWalked: number;\n\tfilesWalked: number;\n\tcmdTime: number;\n\tcmdResultCount?: number;\n}\n\nexport interface IFileSearchProviderStats {\n\tproviderTime: number;\n\tpostProcessTime: number;\n}\n\nexport class FileMatch implements IFileMatch {\n\tresults: ITextSearchResult[] = [];\n\tconstructor(public resource: URI) {\n\t\t// empty\n\t}\n}\n\nexport class TextSearchMatch implements ITextSearchMatch {\n\tranges: ISearchRange | ISearchRange[];\n\tpreview: ITextSearchResultPreview;\n\n\tconstructor(text: string, range: ISearchRange | ISearchRange[], previewOptions?: ITextSearchPreviewOptions) {\n\t\tthis.ranges = range;\n\n\t\tif (previewOptions && previewOptions.matchLines === 1 && !Array.isArray(range)) {\n\t\t\t// 1 line preview requested\n\t\t\ttext = getNLines(text, previewOptions.matchLines);\n\t\t\tconst leadingChars = Math.floor(previewOptions.charsPerLine / 5);\n\t\t\tconst previewStart = Math.max(range.startColumn - leadingChars, 0);\n\t\t\tconst previewText = text.substring(previewStart, previewOptions.charsPerLine + previewStart);\n\n\t\t\tconst endColInPreview = (range.endLineNumber - range.startLineNumber + 1) <= previewOptions.matchLines ?\n\t\t\t\tMath.min(previewText.length, range.endColumn - previewStart) :  // if number of match lines will not be trimmed by previewOptions\n\t\t\t\tpreviewText.length; // if number of lines is trimmed\n\n\t\t\tthis.preview = {\n\t\t\t\ttext: previewText,\n\t\t\t\tmatches: new OneLineRange(0, range.startColumn - previewStart, endColInPreview)\n\t\t\t};\n\t\t} else {\n\t\t\tconst firstMatchLine = Array.isArray(range) ? range[0].startLineNumber : range.startLineNumber;\n\n\t\t\t// n line, no preview requested, or multiple matches in the preview\n\t\t\tthis.preview = {\n\t\t\t\ttext,\n\t\t\t\tmatches: mapArrayOrNot(range, r => new SearchRange(r.startLineNumber - firstMatchLine, r.startColumn, r.endLineNumber - firstMatchLine, r.endColumn))\n\t\t\t};\n\t\t}\n\t}\n}\n\nexport class SearchRange implements ISearchRange {\n\tstartLineNumber: number;\n\tstartColumn: number;\n\tendLineNumber: number;\n\tendColumn: number;\n\n\tconstructor(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number) {\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.startColumn = startColumn;\n\t\tthis.endLineNumber = endLineNumber;\n\t\tthis.endColumn = endColumn;\n\t}\n}\n\nexport class OneLineRange extends SearchRange {\n\tconstructor(lineNumber: number, startColumn: number, endColumn: number) {\n\t\tsuper(lineNumber, startColumn, lineNumber, endColumn);\n\t}\n}\n\nexport interface ISearchConfigurationProperties {\n\texclude: glob.IExpression;\n\tuseRipgrep: boolean;\n\t/**\n\t * Use ignore file for file search.\n\t */\n\tuseIgnoreFiles: boolean;\n\tuseGlobalIgnoreFiles: boolean;\n\tfollowSymlinks: boolean;\n\tsmartCase: boolean;\n\tglobalFindClipboard: boolean;\n\tlocation: 'sidebar' | 'panel';\n\tuseReplacePreview: boolean;\n\tshowLineNumbers: boolean;\n\tusePCRE2: boolean;\n\tactionsPosition: 'auto' | 'right';\n\tmaintainFileSearchCache: boolean;\n\tcollapseResults: 'auto' | 'alwaysCollapse' | 'alwaysExpand';\n}\n\nexport interface ISearchConfiguration extends IFilesConfiguration {\n\tsearch: ISearchConfigurationProperties;\n\teditor: {\n\t\twordSeparators: string;\n\t};\n}\n\nexport function getExcludes(configuration: ISearchConfiguration, includeSearchExcludes = true): glob.IExpression | undefined {\n\tconst fileExcludes = configuration && configuration.files && configuration.files.exclude;\n\tconst searchExcludes = includeSearchExcludes && configuration && configuration.search && configuration.search.exclude;\n\n\tif (!fileExcludes && !searchExcludes) {\n\t\treturn undefined;\n\t}\n\n\tif (!fileExcludes || !searchExcludes) {\n\t\treturn fileExcludes || searchExcludes;\n\t}\n\n\tlet allExcludes: glob.IExpression = Object.create(null);\n\t// clone the config as it could be frozen\n\tallExcludes = objects.mixin(allExcludes, objects.deepClone(fileExcludes));\n\tallExcludes = objects.mixin(allExcludes, objects.deepClone(searchExcludes), true);\n\n\treturn allExcludes;\n}\n\nexport function pathIncludedInQuery(queryProps: ICommonQueryProps<URI>, fsPath: string): boolean {\n\tif (queryProps.excludePattern && glob.match(queryProps.excludePattern, fsPath)) {\n\t\treturn false;\n\t}\n\n\tif (queryProps.includePattern && !glob.match(queryProps.includePattern, fsPath)) {\n\t\treturn false;\n\t}\n\n\t// If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present\n\tif (queryProps.usingSearchPaths) {\n\t\treturn !!queryProps.folderQueries && queryProps.folderQueries.every(fq => {\n\t\t\tconst searchPath = fq.folder.fsPath;\n\t\t\tif (extpath.isEqualOrParent(fsPath, searchPath)) {\n\t\t\t\treturn !fq.includePattern || !!glob.match(fq.includePattern, fsPath);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t}\n\n\treturn true;\n}\n\nexport enum SearchErrorCode {\n\tunknownEncoding = 1,\n\tregexParseError,\n\tglobParseError,\n\tinvalidLiteral,\n\trgProcessError,\n\tother\n}\n\nexport class SearchError extends Error {\n\tconstructor(message: string, readonly code?: SearchErrorCode) {\n\t\tsuper(message);\n\t}\n}\n\nexport function deserializeSearchError(errorMsg: string): SearchError {\n\ttry {\n\t\tconst details = JSON.parse(errorMsg);\n\t\treturn new SearchError(details.message, details.code);\n\t} catch (e) {\n\t\treturn new SearchError(errorMsg, SearchErrorCode.other);\n\t}\n}\n\nexport function serializeSearchError(searchError: SearchError): Error {\n\tconst details = { message: searchError.message, code: searchError.code };\n\treturn new Error(JSON.stringify(details));\n}\nexport interface ITelemetryEvent {\n\teventName: string;\n\tdata: ITelemetryData;\n}\n\nexport interface IRawSearchService {\n\tfileSearch(search: IRawFileQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete>;\n\ttextSearch(search: IRawTextQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete>;\n\tclearCache(cacheKey: string): Promise<void>;\n}\n\nexport interface IRawFileMatch {\n\tbase?: string;\n\trelativePath: string;\n\tbasename: string;\n\tsize?: number;\n}\n\nexport interface ISearchEngine<T> {\n\tsearch: (onResult: (matches: T) => void, onProgress: (progress: IProgressMessage) => void, done: (error: Error | null, complete: ISearchEngineSuccess) => void) => void;\n\tcancel: () => void;\n}\n\nexport interface ISerializedSearchSuccess {\n\ttype: 'success';\n\tlimitHit: boolean;\n\tstats?: IFileSearchStats | ITextSearchStats;\n}\n\nexport interface ISearchEngineSuccess {\n\tlimitHit: boolean;\n\tstats: ISearchEngineStats;\n}\n\nexport interface ISerializedSearchError {\n\ttype: 'error';\n\terror: {\n\t\tmessage: string,\n\t\tstack: string\n\t};\n}\n\nexport type ISerializedSearchComplete = ISerializedSearchSuccess | ISerializedSearchError;\n\nexport function isSerializedSearchComplete(arg: ISerializedSearchProgressItem | ISerializedSearchComplete): arg is ISerializedSearchComplete {\n\tif ((arg as any).type === 'error') {\n\t\treturn true;\n\t} else if ((arg as any).type === 'success') {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nexport function isSerializedSearchSuccess(arg: ISerializedSearchComplete): arg is ISerializedSearchSuccess {\n\treturn arg.type === 'success';\n}\n\nexport function isSerializedFileMatch(arg: ISerializedSearchProgressItem): arg is ISerializedFileMatch {\n\treturn !!(<ISerializedFileMatch>arg).path;\n}\n\nexport interface ISerializedFileMatch {\n\tpath: string;\n\tresults?: ITextSearchResult[];\n\tnumMatches?: number;\n}\n\n// Type of the possible values for progress calls from the engine\nexport type ISerializedSearchProgressItem = ISerializedFileMatch | ISerializedFileMatch[] | IProgressMessage;\nexport type IFileSearchProgressItem = IRawFileMatch | IRawFileMatch[] | IProgressMessage;\n\n\nexport class SerializableFileMatch implements ISerializedFileMatch {\n\tpath: string;\n\tresults: ITextSearchMatch[];\n\n\tconstructor(path: string) {\n\t\tthis.path = path;\n\t\tthis.results = [];\n\t}\n\n\taddMatch(match: ITextSearchMatch): void {\n\t\tthis.results.push(match);\n\t}\n\n\tserialize(): ISerializedFileMatch {\n\t\treturn {\n\t\t\tpath: this.path,\n\t\t\tresults: this.results,\n\t\t\tnumMatches: this.results.length\n\t\t};\n\t}\n}\n\n/**\n *  Computes the patterns that the provider handles. Discards sibling clauses and 'false' patterns\n */\nexport function resolvePatternsForProvider(globalPattern: glob.IExpression | undefined, folderPattern: glob.IExpression | undefined): string[] {\n\tconst merged = {\n\t\t...(globalPattern || {}),\n\t\t...(folderPattern || {})\n\t};\n\n\treturn Object.keys(merged)\n\t\t.filter(key => {\n\t\t\tconst value = merged[key];\n\t\t\treturn typeof value === 'boolean' && value;\n\t\t});\n}\n\nexport class QueryGlobTester {\n\n\tprivate _excludeExpression: glob.IExpression;\n\tprivate _parsedExcludeExpression: glob.ParsedExpression;\n\n\tprivate _parsedIncludeExpression: glob.ParsedExpression;\n\n\tconstructor(config: ISearchQuery, folderQuery: IFolderQuery) {\n\t\tthis._excludeExpression = {\n\t\t\t...(config.excludePattern || {}),\n\t\t\t...(folderQuery.excludePattern || {})\n\t\t};\n\t\tthis._parsedExcludeExpression = glob.parse(this._excludeExpression);\n\n\t\t// Empty includeExpression means include nothing, so no {} shortcuts\n\t\tlet includeExpression: glob.IExpression | undefined = config.includePattern;\n\t\tif (folderQuery.includePattern) {\n\t\t\tif (includeExpression) {\n\t\t\t\tincludeExpression = {\n\t\t\t\t\t...includeExpression,\n\t\t\t\t\t...folderQuery.includePattern\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tincludeExpression = folderQuery.includePattern;\n\t\t\t}\n\t\t}\n\n\t\tif (includeExpression) {\n\t\t\tthis._parsedIncludeExpression = glob.parse(includeExpression);\n\t\t}\n\t}\n\n\t/**\n\t * Guaranteed sync - siblingsFn should not return a promise.\n\t */\n\tincludedInQuerySync(testPath: string, basename?: string, hasSibling?: (name: string) => boolean): boolean {\n\t\tif (this._parsedExcludeExpression && this._parsedExcludeExpression(testPath, basename, hasSibling)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this._parsedIncludeExpression && !this._parsedIncludeExpression(testPath, basename, hasSibling)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Guaranteed async.\n\t */\n\tincludedInQuery(testPath: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): Promise<boolean> {\n\t\tconst excludeP = this._parsedExcludeExpression ?\n\t\t\tPromise.resolve(this._parsedExcludeExpression(testPath, basename, hasSibling)).then(result => !!result) :\n\t\t\tPromise.resolve(false);\n\n\t\treturn excludeP.then(excluded => {\n\t\t\tif (excluded) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn this._parsedIncludeExpression ?\n\t\t\t\tPromise.resolve(this._parsedIncludeExpression(testPath, basename, hasSibling)).then(result => !!result) :\n\t\t\t\tPromise.resolve(true);\n\t\t}).then(included => {\n\t\t\treturn included;\n\t\t});\n\t}\n\n\thasSiblingExcludeClauses(): boolean {\n\t\treturn hasSiblingClauses(this._excludeExpression);\n\t}\n}\n\nfunction hasSiblingClauses(pattern: glob.IExpression): boolean {\n\tfor (const key in pattern) {\n\t\tif (typeof pattern[key] !== 'boolean') {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n"]}]}