{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/node/extfs.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/extfs.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar fs = require(\"fs\");\nvar paths = require(\"vs/base/common/path\");\nvar async_1 = require(\"vs/base/common/async\");\nvar normalization_1 = require(\"vs/base/common/normalization\");\nvar platform = require(\"vs/base/common/platform\");\nvar strings = require(\"vs/base/common/strings\");\nvar uuid = require(\"vs/base/common/uuid\");\nvar encoding_1 = require(\"vs/base/node/encoding\");\nvar flow = require(\"vs/base/node/flow\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar loop = flow.loop;\nfunction readdirSync(path) {\n    // Mac: uses NFD unicode form on disk, but we want NFC\n    // See also https://github.com/nodejs/node/issues/2165\n    if (platform.isMacintosh) {\n        return fs.readdirSync(path).map(function (c) { return normalization_1.normalizeNFC(c); });\n    }\n    return fs.readdirSync(path);\n}\nexports.readdirSync = readdirSync;\nfunction readdir(path, callback) {\n    // Mac: uses NFD unicode form on disk, but we want NFC\n    // See also https://github.com/nodejs/node/issues/2165\n    if (platform.isMacintosh) {\n        return fs.readdir(path, function (error, children) {\n            if (error) {\n                return callback(error, []);\n            }\n            return callback(null, children.map(function (c) { return normalization_1.normalizeNFC(c); }));\n        });\n    }\n    return fs.readdir(path, callback);\n}\nexports.readdir = readdir;\nfunction statLink(path, callback) {\n    fs.lstat(path, function (error, lstat) {\n        if (error || lstat.isSymbolicLink()) {\n            fs.stat(path, function (error, stat) {\n                if (error) {\n                    return callback(error, null);\n                }\n                callback(null, { stat: stat, isSymbolicLink: lstat && lstat.isSymbolicLink() });\n            });\n        }\n        else {\n            callback(null, { stat: lstat, isSymbolicLink: false });\n        }\n    });\n}\nexports.statLink = statLink;\nfunction copy(source, target, callback, copiedSourcesIn) {\n    var copiedSources = copiedSourcesIn ? copiedSourcesIn : Object.create(null);\n    fs.stat(source, function (error, stat) {\n        if (error) {\n            return callback(error);\n        }\n        if (!stat.isDirectory()) {\n            return doCopyFile(source, target, stat.mode & 511, callback);\n        }\n        if (copiedSources[source]) {\n            return callback(null); // escape when there are cycles (can happen with symlinks)\n        }\n        copiedSources[source] = true; // remember as copied\n        var proceed = function () {\n            readdir(source, function (err, files) {\n                loop(files, function (file, clb) {\n                    copy(paths.join(source, file), paths.join(target, file), function (error) { return clb(error, []); }, copiedSources);\n                }, callback);\n            });\n        };\n        mkdirp(target, stat.mode & 511).then(proceed, proceed);\n    });\n}\nexports.copy = copy;\nfunction doCopyFile(source, target, mode, callback) {\n    var reader = fs.createReadStream(source);\n    var writer = fs.createWriteStream(target, { mode: mode });\n    var finished = false;\n    var finish = function (error) {\n        if (!finished) {\n            finished = true;\n            // in error cases, pass to callback\n            if (error) {\n                callback(error);\n            }\n            // we need to explicitly chmod because of https://github.com/nodejs/node/issues/1104\n            else {\n                fs.chmod(target, mode, callback);\n            }\n        }\n    };\n    // handle errors properly\n    reader.once('error', function (error) { return finish(error); });\n    writer.once('error', function (error) { return finish(error); });\n    // we are done (underlying fd has been closed)\n    writer.once('close', function () { return finish(); });\n    // start piping\n    reader.pipe(writer);\n}\nfunction mkdirp(path, mode, token) {\n    var mkdir = function () {\n        return async_1.nfcall(fs.mkdir, path, mode).then(undefined, function (mkdirErr) {\n            // ENOENT: a parent folder does not exist yet\n            if (mkdirErr.code === 'ENOENT') {\n                return Promise.reject(mkdirErr);\n            }\n            // Any other error: check if folder exists and\n            // return normally in that case if its a folder\n            return async_1.nfcall(fs.stat, path).then(function (stat) {\n                if (!stat.isDirectory()) {\n                    return Promise.reject(new Error(\"'\" + path + \"' exists and is not a directory.\"));\n                }\n                return null;\n            }, function (statErr) {\n                return Promise.reject(mkdirErr); // bubble up original mkdir error\n            });\n        });\n    };\n    // stop at root\n    if (path === paths.dirname(path)) {\n        return Promise.resolve(true);\n    }\n    // recursively mkdir\n    return mkdir().then(undefined, function (err) {\n        // Respect cancellation\n        if (token && token.isCancellationRequested) {\n            return Promise.resolve(false);\n        }\n        // ENOENT: a parent folder does not exist yet, continue\n        // to create the parent folder and then try again.\n        if (err.code === 'ENOENT') {\n            return mkdirp(paths.dirname(path), mode).then(mkdir);\n        }\n        // Any other error\n        return Promise.reject(err);\n    });\n}\nexports.mkdirp = mkdirp;\n// Deletes the given path by first moving it out of the workspace. This has two benefits. For one, the operation can return fast because\n// after the rename, the contents are out of the workspace although not yet deleted. The greater benefit however is that this operation\n// will fail in case any file is used by another process. fs.unlink() in node will not bail if a file unlinked is used by another process.\n// However, the consequences are bad as outlined in all the related bugs from https://github.com/joyent/node/issues/7164\nfunction del(path, tmpFolder, callback, done) {\n    fs.exists(path, function (exists) {\n        if (!exists) {\n            return callback(null);\n        }\n        fs.stat(path, function (err, stat) {\n            if (err || !stat) {\n                return callback(err);\n            }\n            // Special windows workaround: A file or folder that ends with a \".\" cannot be moved to another place\n            // because it is not a valid file name. In this case, we really have to do the deletion without prior move.\n            if (path[path.length - 1] === '.' || strings.endsWith(path, './') || strings.endsWith(path, '.\\\\')) {\n                return rmRecursive(path, callback);\n            }\n            var pathInTemp = paths.join(tmpFolder, uuid.generateUuid());\n            fs.rename(path, pathInTemp, function (error) {\n                if (error) {\n                    return rmRecursive(path, callback); // if rename fails, delete without tmp dir\n                }\n                // Return early since the move succeeded\n                callback(null);\n                // do the heavy deletion outside the callers callback\n                rmRecursive(pathInTemp, function (error) {\n                    if (done) {\n                        done(error);\n                    }\n                });\n            });\n        });\n    });\n}\nexports.del = del;\nfunction rmRecursive(path, callback) {\n    if (path === paths.win32.sep || path === paths.posix.sep) {\n        return callback(new Error('Will not delete root!'));\n    }\n    fs.exists(path, function (exists) {\n        if (!exists) {\n            callback(null);\n        }\n        else {\n            fs.lstat(path, function (err, stat) {\n                if (err || !stat) {\n                    callback(err);\n                }\n                else if (!stat.isDirectory() || stat.isSymbolicLink() /* !!! never recurse into links when deleting !!! */) {\n                    var mode = stat.mode;\n                    if (!(mode & 128)) { // 128 === 0200\n                        fs.chmod(path, mode | 128, function (err) {\n                            if (err) {\n                                callback(err);\n                            }\n                            else {\n                                fs.unlink(path, callback);\n                            }\n                        });\n                    }\n                    else {\n                        fs.unlink(path, callback);\n                    }\n                }\n                else {\n                    readdir(path, function (err, children) {\n                        if (err || !children) {\n                            callback(err);\n                        }\n                        else if (children.length === 0) {\n                            fs.rmdir(path, callback);\n                        }\n                        else {\n                            var firstError_1 = null;\n                            var childrenLeft_1 = children.length;\n                            children.forEach(function (child) {\n                                rmRecursive(paths.join(path, child), function (err) {\n                                    childrenLeft_1--;\n                                    if (err) {\n                                        firstError_1 = firstError_1 || err;\n                                    }\n                                    if (childrenLeft_1 === 0) {\n                                        if (firstError_1) {\n                                            callback(firstError_1);\n                                        }\n                                        else {\n                                            fs.rmdir(path, callback);\n                                        }\n                                    }\n                                });\n                            });\n                        }\n                    });\n                }\n            });\n        }\n    });\n}\nfunction delSync(path) {\n    if (path === paths.win32.sep || path === paths.posix.sep) {\n        throw new Error('Will not delete root!');\n    }\n    try {\n        var stat = fs.lstatSync(path);\n        if (stat.isDirectory() && !stat.isSymbolicLink()) {\n            readdirSync(path).forEach(function (child) { return delSync(paths.join(path, child)); });\n            fs.rmdirSync(path);\n        }\n        else {\n            fs.unlinkSync(path);\n        }\n    }\n    catch (err) {\n        if (err.code === 'ENOENT') {\n            return; // not found\n        }\n        throw err;\n    }\n}\nexports.delSync = delSync;\nfunction mv(source, target, callback) {\n    if (source === target) {\n        return callback(null);\n    }\n    function updateMtime(err) {\n        if (err) {\n            return callback(err);\n        }\n        fs.lstat(target, function (error, stat) {\n            if (error) {\n                return callback(error);\n            }\n            if (stat.isDirectory() || stat.isSymbolicLink()) {\n                return callback(null);\n            }\n            fs.open(target, 'a', null, function (err, fd) {\n                if (err) {\n                    return callback(err);\n                }\n                fs.futimes(fd, stat.atime, new Date(), function (err) {\n                    if (err) {\n                        return callback(err);\n                    }\n                    fs.close(fd, callback);\n                });\n            });\n        });\n    }\n    // Try native rename()\n    fs.rename(source, target, function (err) {\n        if (!err) {\n            return updateMtime(null);\n        }\n        // In two cases we fallback to classic copy and delete:\n        //\n        // 1.) The EXDEV error indicates that source and target are on different devices\n        // In this case, fallback to using a copy() operation as there is no way to\n        // rename() between different devices.\n        //\n        // 2.) The user tries to rename a file/folder that ends with a dot. This is not\n        // really possible to move then, at least on UNC devices.\n        if (err && source.toLowerCase() !== target.toLowerCase() && (err.code === 'EXDEV') || strings.endsWith(source, '.')) {\n            return copy(source, target, function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                rmRecursive(source, updateMtime);\n            });\n        }\n        return callback(err);\n    });\n}\nexports.mv = mv;\nvar canFlush = true;\nfunction writeFileAndFlush(path, data, options, callback) {\n    options = ensureOptions(options);\n    if (typeof data === 'string' || Buffer.isBuffer(data) || data instanceof Uint8Array) {\n        doWriteFileAndFlush(path, data, options, callback);\n    }\n    else {\n        doWriteFileStreamAndFlush(path, data, options, callback);\n    }\n}\nexports.writeFileAndFlush = writeFileAndFlush;\nfunction doWriteFileStreamAndFlush(path, reader, options, callback) {\n    // finish only once\n    var finished = false;\n    var finish = function (error) {\n        if (!finished) {\n            finished = true;\n            // in error cases we need to manually close streams\n            // if the write stream was successfully opened\n            if (error) {\n                if (isOpen) {\n                    writer.once('close', function () { return callback(error); });\n                    writer.destroy();\n                }\n                else {\n                    callback(error);\n                }\n            }\n            // otherwise just return without error\n            else {\n                callback();\n            }\n        }\n    };\n    // create writer to target. we set autoClose: false because we want to use the streams\n    // file descriptor to call fs.fdatasync to ensure the data is flushed to disk\n    var writer = fs.createWriteStream(path, { mode: options.mode, flags: options.flag, autoClose: false });\n    // Event: 'open'\n    // Purpose: save the fd for later use and start piping\n    // Notes: will not be called when there is an error opening the file descriptor!\n    var fd;\n    var isOpen;\n    writer.once('open', function (descriptor) {\n        fd = descriptor;\n        isOpen = true;\n        // if an encoding is provided, we need to pipe the stream through\n        // an encoder stream and forward the encoding related options\n        if (options.encoding) {\n            reader = reader.pipe(encoding_1.encodeStream(options.encoding.charset, { addBOM: options.encoding.addBOM }));\n        }\n        // start data piping only when we got a successful open. this ensures that we do\n        // not consume the stream when an error happens and helps to fix this issue:\n        // https://github.com/Microsoft/vscode/issues/42542\n        reader.pipe(writer);\n    });\n    // Event: 'error'\n    // Purpose: to return the error to the outside and to close the write stream (does not happen automatically)\n    reader.once('error', function (error) { return finish(error); });\n    writer.once('error', function (error) { return finish(error); });\n    // Event: 'finish'\n    // Purpose: use fs.fdatasync to flush the contents to disk\n    // Notes: event is called when the writer has finished writing to the underlying resource. we must call writer.close()\n    // because we have created the WriteStream with autoClose: false\n    writer.once('finish', function () {\n        // flush to disk\n        if (canFlush && isOpen) {\n            fs.fdatasync(fd, function (syncError) {\n                // In some exotic setups it is well possible that node fails to sync\n                // In that case we disable flushing and warn to the console\n                if (syncError) {\n                    console.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n                    canFlush = false;\n                }\n                writer.destroy();\n            });\n        }\n        else {\n            writer.destroy();\n        }\n    });\n    // Event: 'close'\n    // Purpose: signal we are done to the outside\n    // Notes: event is called when the writer's filedescriptor is closed\n    writer.once('close', function () { return finish(); });\n}\n// Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk\n// We do this in cases where we want to make sure the data is really on disk and\n// not in some cache.\n//\n// See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194\nfunction doWriteFileAndFlush(path, data, options, callback) {\n    if (options.encoding) {\n        data = encoding_1.encode(data instanceof Uint8Array ? Buffer.from(data) : data, options.encoding.charset, { addBOM: options.encoding.addBOM });\n    }\n    if (!canFlush) {\n        return fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);\n    }\n    // Open the file with same flags and mode as fs.writeFile()\n    fs.open(path, typeof options.flag === 'string' ? options.flag : 'r', options.mode, function (openError, fd) {\n        if (openError) {\n            return callback(openError);\n        }\n        // It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n        fs.writeFile(fd, data, function (writeError) {\n            if (writeError) {\n                return fs.close(fd, function () { return callback(writeError); }); // still need to close the handle on error!\n            }\n            // Flush contents (not metadata) of the file to disk\n            fs.fdatasync(fd, function (syncError) {\n                // In some exotic setups it is well possible that node fails to sync\n                // In that case we disable flushing and warn to the console\n                if (syncError) {\n                    console.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n                    canFlush = false;\n                }\n                return fs.close(fd, function (closeError) { return callback(closeError); });\n            });\n        });\n    });\n}\nfunction writeFileAndFlushSync(path, data, options) {\n    options = ensureOptions(options);\n    if (options.encoding) {\n        data = encoding_1.encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });\n    }\n    if (!canFlush) {\n        return fs.writeFileSync(path, data, { mode: options.mode, flag: options.flag });\n    }\n    // Open the file with same flags and mode as fs.writeFile()\n    var fd = fs.openSync(path, typeof options.flag === 'string' ? options.flag : 'r', options.mode);\n    try {\n        // It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n        fs.writeFileSync(fd, data);\n        // Flush contents (not metadata) of the file to disk\n        try {\n            fs.fdatasyncSync(fd);\n        }\n        catch (syncError) {\n            console.warn('[node.js fs] fdatasyncSync is now disabled for this session because it failed: ', syncError);\n            canFlush = false;\n        }\n    }\n    finally {\n        fs.closeSync(fd);\n    }\n}\nexports.writeFileAndFlushSync = writeFileAndFlushSync;\nfunction ensureOptions(options) {\n    if (!options) {\n        return { mode: 438, flag: 'w' };\n    }\n    var ensuredOptions = { mode: options.mode, flag: options.flag, encoding: options.encoding };\n    if (typeof ensuredOptions.mode !== 'number') {\n        ensuredOptions.mode = 438;\n    }\n    if (typeof ensuredOptions.flag !== 'string') {\n        ensuredOptions.flag = 'w';\n    }\n    return ensuredOptions;\n}\n/**\n * Copied from: https://github.com/Microsoft/vscode-node-debug/blob/master/src/node/pathUtilities.ts#L83\n *\n * Given an absolute, normalized, and existing file path 'realcase' returns the exact path that the file has on disk.\n * On a case insensitive file system, the returned path might differ from the original path by character casing.\n * On a case sensitive file system, the returned path will always be identical to the original path.\n * In case of errors, null is returned. But you cannot use this function to verify that a path exists.\n * realcaseSync does not handle '..' or '.' path segments and it does not take the locale into account.\n */\nfunction realcaseSync(path) {\n    var dir = paths.dirname(path);\n    if (path === dir) { // end recursion\n        return path;\n    }\n    var name = (paths.basename(path) /* can be '' for windows drive letters */ || path).toLowerCase();\n    try {\n        var entries = readdirSync(dir);\n        var found = entries.filter(function (e) { return e.toLowerCase() === name; }); // use a case insensitive search\n        if (found.length === 1) {\n            // on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition\n            var prefix = realcaseSync(dir); // recurse\n            if (prefix) {\n                return paths.join(prefix, found[0]);\n            }\n        }\n        else if (found.length > 1) {\n            // must be a case sensitive $filesystem\n            var ix = found.indexOf(name);\n            if (ix >= 0) { // case sensitive\n                var prefix = realcaseSync(dir); // recurse\n                if (prefix) {\n                    return paths.join(prefix, found[ix]);\n                }\n            }\n        }\n    }\n    catch (error) {\n        // silently ignore error\n    }\n    return null;\n}\nexports.realcaseSync = realcaseSync;\nfunction realpathSync(path) {\n    try {\n        return fs.realpathSync(path);\n    }\n    catch (error) {\n        // We hit an error calling fs.realpathSync(). Since fs.realpathSync() is doing some path normalization\n        // we now do a similar normalization and then try again if we can access the path with read\n        // permissions at least. If that succeeds, we return that path.\n        // fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n        // to not resolve links but to simply see if the path is read accessible or not.\n        var normalizedPath = normalizePath(path);\n        fs.accessSync(normalizedPath, fs.constants.R_OK); // throws in case of an error\n        return normalizedPath;\n    }\n}\nexports.realpathSync = realpathSync;\nfunction realpath(path, callback) {\n    return fs.realpath(path, function (error, realpath) {\n        if (!error) {\n            return callback(null, realpath);\n        }\n        // We hit an error calling fs.realpath(). Since fs.realpath() is doing some path normalization\n        // we now do a similar normalization and then try again if we can access the path with read\n        // permissions at least. If that succeeds, we return that path.\n        // fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n        // to not resolve links but to simply see if the path is read accessible or not.\n        var normalizedPath = normalizePath(path);\n        return fs.access(normalizedPath, fs.constants.R_OK, function (error) {\n            return callback(error, normalizedPath);\n        });\n    });\n}\nexports.realpath = realpath;\nfunction normalizePath(path) {\n    return strings.rtrim(paths.normalize(path), paths.sep);\n}\nfunction watch(path, onChange, onError) {\n    try {\n        var watcher_1 = fs.watch(path);\n        watcher_1.on('change', function (type, raw) {\n            var file;\n            if (raw) { // https://github.com/Microsoft/vscode/issues/38191\n                file = raw.toString();\n                if (platform.isMacintosh) {\n                    // Mac: uses NFD unicode form on disk, but we want NFC\n                    // See also https://github.com/nodejs/node/issues/2165\n                    file = normalization_1.normalizeNFC(file);\n                }\n            }\n            onChange(type, file);\n        });\n        watcher_1.on('error', function (code, signal) { return onError(\"Failed to watch \" + path + \" for changes (\" + code + \", \" + signal + \")\"); });\n        return lifecycle_1.toDisposable(function () {\n            watcher_1.removeAllListeners();\n            watcher_1.close();\n        });\n    }\n    catch (error) {\n        fs.exists(path, function (exists) {\n            if (exists) {\n                onError(\"Failed to watch \" + path + \" for changes (\" + error.toString() + \")\");\n            }\n        });\n    }\n    return lifecycle_1.Disposable.None;\n}\nexports.watch = watch;\nfunction sanitizeFilePath(candidate, cwd) {\n    // Special case: allow to open a drive letter without trailing backslash\n    if (platform.isWindows && strings.endsWith(candidate, ':')) {\n        candidate += paths.sep;\n    }\n    // Ensure absolute\n    if (!paths.isAbsolute(candidate)) {\n        candidate = paths.join(cwd, candidate);\n    }\n    // Ensure normalized\n    candidate = paths.normalize(candidate);\n    // Ensure no trailing slash/backslash\n    if (platform.isWindows) {\n        candidate = strings.rtrim(candidate, paths.sep);\n        // Special case: allow to open drive root ('C:\\')\n        if (strings.endsWith(candidate, ':')) {\n            candidate += paths.sep;\n        }\n    }\n    else {\n        candidate = strings.rtrim(candidate, paths.sep);\n        // Special case: allow to open root ('/')\n        if (!candidate) {\n            candidate = paths.sep;\n        }\n    }\n    return candidate;\n}\nexports.sanitizeFilePath = sanitizeFilePath;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/node/extfs.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/node/extfs.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport * as paths from 'vs/base/common/path';\nimport { nfcall } from 'vs/base/common/async';\nimport { normalizeNFC } from 'vs/base/common/normalization';\nimport * as platform from 'vs/base/common/platform';\nimport * as strings from 'vs/base/common/strings';\nimport * as uuid from 'vs/base/common/uuid';\nimport { encode, encodeStream } from 'vs/base/node/encoding';\nimport * as flow from 'vs/base/node/flow';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { IDisposable, toDisposable, Disposable } from 'vs/base/common/lifecycle';\n\nconst loop = flow.loop;\n\nexport function readdirSync(path: string): string[] {\n\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t// See also https://github.com/nodejs/node/issues/2165\n\tif (platform.isMacintosh) {\n\t\treturn fs.readdirSync(path).map(c => normalizeNFC(c));\n\t}\n\n\treturn fs.readdirSync(path);\n}\n\nexport function readdir(path: string, callback: (error: Error | null, files: string[]) => void): void {\n\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t// See also https://github.com/nodejs/node/issues/2165\n\tif (platform.isMacintosh) {\n\t\treturn fs.readdir(path, (error, children) => {\n\t\t\tif (error) {\n\t\t\t\treturn callback(error, []);\n\t\t\t}\n\n\t\t\treturn callback(null, children.map(c => normalizeNFC(c)));\n\t\t});\n\t}\n\n\treturn fs.readdir(path, callback);\n}\n\nexport interface IStatAndLink {\n\tstat: fs.Stats;\n\tisSymbolicLink: boolean;\n}\n\nexport function statLink(path: string, callback: (error: Error | null, statAndIsLink: IStatAndLink | null) => void): void {\n\tfs.lstat(path, (error, lstat) => {\n\t\tif (error || lstat.isSymbolicLink()) {\n\t\t\tfs.stat(path, (error, stat) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treturn callback(error, null);\n\t\t\t\t}\n\n\t\t\t\tcallback(null, { stat, isSymbolicLink: lstat && lstat.isSymbolicLink() });\n\t\t\t});\n\t\t} else {\n\t\t\tcallback(null, { stat: lstat, isSymbolicLink: false });\n\t\t}\n\t});\n}\n\nexport function copy(source: string, target: string, callback: (error: Error | null) => void, copiedSourcesIn?: { [path: string]: boolean }): void {\n\tconst copiedSources = copiedSourcesIn ? copiedSourcesIn : Object.create(null);\n\n\tfs.stat(source, (error, stat) => {\n\t\tif (error) {\n\t\t\treturn callback(error);\n\t\t}\n\n\t\tif (!stat.isDirectory()) {\n\t\t\treturn doCopyFile(source, target, stat.mode & 511, callback);\n\t\t}\n\n\t\tif (copiedSources[source]) {\n\t\t\treturn callback(null); // escape when there are cycles (can happen with symlinks)\n\t\t}\n\n\t\tcopiedSources[source] = true; // remember as copied\n\n\t\tconst proceed = function () {\n\t\t\treaddir(source, (err, files) => {\n\t\t\t\tloop(files, (file: string, clb: (error: Error | null, result: string[]) => void) => {\n\t\t\t\t\tcopy(paths.join(source, file), paths.join(target, file), (error: Error) => clb(error, []), copiedSources);\n\t\t\t\t}, callback);\n\t\t\t});\n\t\t};\n\n\t\tmkdirp(target, stat.mode & 511).then(proceed, proceed);\n\t});\n}\n\nfunction doCopyFile(source: string, target: string, mode: number, callback: (error: Error) => void): void {\n\tconst reader = fs.createReadStream(source);\n\tconst writer = fs.createWriteStream(target, { mode });\n\n\tlet finished = false;\n\tconst finish = (error?: Error) => {\n\t\tif (!finished) {\n\t\t\tfinished = true;\n\n\t\t\t// in error cases, pass to callback\n\t\t\tif (error) {\n\t\t\t\tcallback(error);\n\t\t\t}\n\n\t\t\t// we need to explicitly chmod because of https://github.com/nodejs/node/issues/1104\n\t\t\telse {\n\t\t\t\tfs.chmod(target, mode, callback);\n\t\t\t}\n\t\t}\n\t};\n\n\t// handle errors properly\n\treader.once('error', error => finish(error));\n\twriter.once('error', error => finish(error));\n\n\t// we are done (underlying fd has been closed)\n\twriter.once('close', () => finish());\n\n\t// start piping\n\treader.pipe(writer);\n}\n\nexport function mkdirp(path: string, mode?: number, token?: CancellationToken): Promise<boolean> {\n\tconst mkdir = (): Promise<null> => {\n\t\treturn nfcall(fs.mkdir, path, mode).then(undefined, (mkdirErr: NodeJS.ErrnoException) => {\n\n\t\t\t// ENOENT: a parent folder does not exist yet\n\t\t\tif (mkdirErr.code === 'ENOENT') {\n\t\t\t\treturn Promise.reject(mkdirErr);\n\t\t\t}\n\n\t\t\t// Any other error: check if folder exists and\n\t\t\t// return normally in that case if its a folder\n\t\t\treturn nfcall(fs.stat, path).then((stat: fs.Stats) => {\n\t\t\t\tif (!stat.isDirectory()) {\n\t\t\t\t\treturn Promise.reject(new Error(`'${path}' exists and is not a directory.`));\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}, statErr => {\n\t\t\t\treturn Promise.reject(mkdirErr); // bubble up original mkdir error\n\t\t\t});\n\t\t});\n\t};\n\n\t// stop at root\n\tif (path === paths.dirname(path)) {\n\t\treturn Promise.resolve(true);\n\t}\n\n\t// recursively mkdir\n\treturn mkdir().then(undefined, (err: NodeJS.ErrnoException) => {\n\n\t\t// Respect cancellation\n\t\tif (token && token.isCancellationRequested) {\n\t\t\treturn Promise.resolve(false);\n\t\t}\n\n\t\t// ENOENT: a parent folder does not exist yet, continue\n\t\t// to create the parent folder and then try again.\n\t\tif (err.code === 'ENOENT') {\n\t\t\treturn mkdirp(paths.dirname(path), mode).then(mkdir);\n\t\t}\n\n\t\t// Any other error\n\t\treturn Promise.reject(err);\n\t});\n}\n\n// Deletes the given path by first moving it out of the workspace. This has two benefits. For one, the operation can return fast because\n// after the rename, the contents are out of the workspace although not yet deleted. The greater benefit however is that this operation\n// will fail in case any file is used by another process. fs.unlink() in node will not bail if a file unlinked is used by another process.\n// However, the consequences are bad as outlined in all the related bugs from https://github.com/joyent/node/issues/7164\nexport function del(path: string, tmpFolder: string, callback: (error: Error | null) => void, done?: (error: Error | null) => void): void {\n\tfs.exists(path, exists => {\n\t\tif (!exists) {\n\t\t\treturn callback(null);\n\t\t}\n\n\t\tfs.stat(path, (err, stat) => {\n\t\t\tif (err || !stat) {\n\t\t\t\treturn callback(err);\n\t\t\t}\n\n\t\t\t// Special windows workaround: A file or folder that ends with a \".\" cannot be moved to another place\n\t\t\t// because it is not a valid file name. In this case, we really have to do the deletion without prior move.\n\t\t\tif (path[path.length - 1] === '.' || strings.endsWith(path, './') || strings.endsWith(path, '.\\\\')) {\n\t\t\t\treturn rmRecursive(path, callback);\n\t\t\t}\n\n\t\t\tconst pathInTemp = paths.join(tmpFolder, uuid.generateUuid());\n\t\t\tfs.rename(path, pathInTemp, (error: Error | null) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treturn rmRecursive(path, callback); // if rename fails, delete without tmp dir\n\t\t\t\t}\n\n\t\t\t\t// Return early since the move succeeded\n\t\t\t\tcallback(null);\n\n\t\t\t\t// do the heavy deletion outside the callers callback\n\t\t\t\trmRecursive(pathInTemp, error => {\n\t\t\t\t\tif (done) {\n\t\t\t\t\t\tdone(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n}\n\nfunction rmRecursive(path: string, callback: (error: Error | null) => void): void {\n\tif (path === paths.win32.sep || path === paths.posix.sep) {\n\t\treturn callback(new Error('Will not delete root!'));\n\t}\n\n\tfs.exists(path, exists => {\n\t\tif (!exists) {\n\t\t\tcallback(null);\n\t\t} else {\n\t\t\tfs.lstat(path, (err, stat) => {\n\t\t\t\tif (err || !stat) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t} else if (!stat.isDirectory() || stat.isSymbolicLink() /* !!! never recurse into links when deleting !!! */) {\n\t\t\t\t\tconst mode = stat.mode;\n\t\t\t\t\tif (!(mode & 128)) { // 128 === 0200\n\t\t\t\t\t\tfs.chmod(path, mode | 128, (err: Error) => { // 128 === 0200\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfs.unlink(path, callback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfs.unlink(path, callback);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treaddir(path, (err, children) => {\n\t\t\t\t\t\tif (err || !children) {\n\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t} else if (children.length === 0) {\n\t\t\t\t\t\t\tfs.rmdir(path, callback);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet firstError: Error | null = null;\n\t\t\t\t\t\t\tlet childrenLeft = children.length;\n\t\t\t\t\t\t\tchildren.forEach(child => {\n\t\t\t\t\t\t\t\trmRecursive(paths.join(path, child), (err: Error) => {\n\t\t\t\t\t\t\t\t\tchildrenLeft--;\n\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\tfirstError = firstError || err;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (childrenLeft === 0) {\n\t\t\t\t\t\t\t\t\t\tif (firstError) {\n\t\t\t\t\t\t\t\t\t\t\tcallback(firstError);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tfs.rmdir(path, callback);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n}\n\nexport function delSync(path: string): void {\n\tif (path === paths.win32.sep || path === paths.posix.sep) {\n\t\tthrow new Error('Will not delete root!');\n\t}\n\n\ttry {\n\t\tconst stat = fs.lstatSync(path);\n\t\tif (stat.isDirectory() && !stat.isSymbolicLink()) {\n\t\t\treaddirSync(path).forEach(child => delSync(paths.join(path, child)));\n\t\t\tfs.rmdirSync(path);\n\t\t} else {\n\t\t\tfs.unlinkSync(path);\n\t\t}\n\t} catch (err) {\n\t\tif (err.code === 'ENOENT') {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tthrow err;\n\t}\n}\n\nexport function mv(source: string, target: string, callback: (error: Error | null) => void): void {\n\tif (source === target) {\n\t\treturn callback(null);\n\t}\n\n\tfunction updateMtime(err: Error | null): void {\n\t\tif (err) {\n\t\t\treturn callback(err);\n\t\t}\n\n\t\tfs.lstat(target, (error, stat) => {\n\t\t\tif (error) {\n\t\t\t\treturn callback(error);\n\t\t\t}\n\n\t\t\tif (stat.isDirectory() || stat.isSymbolicLink()) {\n\t\t\t\treturn callback(null);\n\t\t\t}\n\n\t\t\tfs.open(target, 'a', null, (err: Error, fd: number) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\n\t\t\t\tfs.futimes(fd, stat.atime, new Date(), (err: Error) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t}\n\n\t\t\t\t\tfs.close(fd, callback);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t// Try native rename()\n\tfs.rename(source, target, (err: Error) => {\n\t\tif (!err) {\n\t\t\treturn updateMtime(null);\n\t\t}\n\n\t\t// In two cases we fallback to classic copy and delete:\n\t\t//\n\t\t// 1.) The EXDEV error indicates that source and target are on different devices\n\t\t// In this case, fallback to using a copy() operation as there is no way to\n\t\t// rename() between different devices.\n\t\t//\n\t\t// 2.) The user tries to rename a file/folder that ends with a dot. This is not\n\t\t// really possible to move then, at least on UNC devices.\n\t\tif (err && source.toLowerCase() !== target.toLowerCase() && ((<any>err).code === 'EXDEV') || strings.endsWith(source, '.')) {\n\t\t\treturn copy(source, target, (err: Error) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\n\t\t\t\trmRecursive(source, updateMtime);\n\t\t\t});\n\t\t}\n\n\t\treturn callback(err);\n\t});\n}\n\nexport interface IWriteFileOptions {\n\tmode?: number;\n\tflag?: string;\n\tencoding?: {\n\t\tcharset: string;\n\t\taddBOM: boolean;\n\t};\n}\n\nlet canFlush = true;\nexport function writeFileAndFlush(path: string, data: string | Buffer | NodeJS.ReadableStream | Uint8Array, options: IWriteFileOptions, callback: (error?: Error) => void): void {\n\toptions = ensureOptions(options);\n\n\tif (typeof data === 'string' || Buffer.isBuffer(data) || data instanceof Uint8Array) {\n\t\tdoWriteFileAndFlush(path, data, options, callback);\n\t} else {\n\t\tdoWriteFileStreamAndFlush(path, data, options, callback);\n\t}\n}\n\nfunction doWriteFileStreamAndFlush(path: string, reader: NodeJS.ReadableStream, options: IWriteFileOptions, callback: (error?: Error) => void): void {\n\n\t// finish only once\n\tlet finished = false;\n\tconst finish = (error?: Error) => {\n\t\tif (!finished) {\n\t\t\tfinished = true;\n\n\t\t\t// in error cases we need to manually close streams\n\t\t\t// if the write stream was successfully opened\n\t\t\tif (error) {\n\t\t\t\tif (isOpen) {\n\t\t\t\t\twriter.once('close', () => callback(error));\n\t\t\t\t\twriter.destroy();\n\t\t\t\t} else {\n\t\t\t\t\tcallback(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// otherwise just return without error\n\t\t\telse {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t};\n\n\t// create writer to target. we set autoClose: false because we want to use the streams\n\t// file descriptor to call fs.fdatasync to ensure the data is flushed to disk\n\tconst writer = fs.createWriteStream(path, { mode: options.mode, flags: options.flag, autoClose: false });\n\n\t// Event: 'open'\n\t// Purpose: save the fd for later use and start piping\n\t// Notes: will not be called when there is an error opening the file descriptor!\n\tlet fd: number;\n\tlet isOpen: boolean;\n\twriter.once('open', descriptor => {\n\t\tfd = descriptor;\n\t\tisOpen = true;\n\n\t\t// if an encoding is provided, we need to pipe the stream through\n\t\t// an encoder stream and forward the encoding related options\n\t\tif (options.encoding) {\n\t\t\treader = reader.pipe(encodeStream(options.encoding.charset, { addBOM: options.encoding.addBOM }));\n\t\t}\n\n\t\t// start data piping only when we got a successful open. this ensures that we do\n\t\t// not consume the stream when an error happens and helps to fix this issue:\n\t\t// https://github.com/Microsoft/vscode/issues/42542\n\t\treader.pipe(writer);\n\t});\n\n\t// Event: 'error'\n\t// Purpose: to return the error to the outside and to close the write stream (does not happen automatically)\n\treader.once('error', error => finish(error));\n\twriter.once('error', error => finish(error));\n\n\t// Event: 'finish'\n\t// Purpose: use fs.fdatasync to flush the contents to disk\n\t// Notes: event is called when the writer has finished writing to the underlying resource. we must call writer.close()\n\t// because we have created the WriteStream with autoClose: false\n\twriter.once('finish', () => {\n\n\t\t// flush to disk\n\t\tif (canFlush && isOpen) {\n\t\t\tfs.fdatasync(fd, (syncError: Error) => {\n\n\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t// In that case we disable flushing and warn to the console\n\t\t\t\tif (syncError) {\n\t\t\t\t\tconsole.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n\t\t\t\t\tcanFlush = false;\n\t\t\t\t}\n\n\t\t\t\twriter.destroy();\n\t\t\t});\n\t\t} else {\n\t\t\twriter.destroy();\n\t\t}\n\t});\n\n\t// Event: 'close'\n\t// Purpose: signal we are done to the outside\n\t// Notes: event is called when the writer's filedescriptor is closed\n\twriter.once('close', () => finish());\n}\n\n// Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk\n// We do this in cases where we want to make sure the data is really on disk and\n// not in some cache.\n//\n// See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194\nfunction doWriteFileAndFlush(path: string, data: string | Buffer | Uint8Array, options: IWriteFileOptions, callback: (error?: Error) => void): void {\n\tif (options.encoding) {\n\t\tdata = encode(data instanceof Uint8Array ? Buffer.from(data) : data, options.encoding.charset, { addBOM: options.encoding.addBOM });\n\t}\n\n\tif (!canFlush) {\n\t\treturn fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tfs.open(path, typeof options.flag === 'string' ? options.flag : 'r', options.mode, (openError, fd) => {\n\t\tif (openError) {\n\t\t\treturn callback(openError);\n\t\t}\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFile(fd, data, writeError => {\n\t\t\tif (writeError) {\n\t\t\t\treturn fs.close(fd, () => callback(writeError)); // still need to close the handle on error!\n\t\t\t}\n\n\t\t\t// Flush contents (not metadata) of the file to disk\n\t\t\tfs.fdatasync(fd, (syncError: Error) => {\n\n\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t// In that case we disable flushing and warn to the console\n\t\t\t\tif (syncError) {\n\t\t\t\t\tconsole.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n\t\t\t\t\tcanFlush = false;\n\t\t\t\t}\n\n\t\t\t\treturn fs.close(fd, closeError => callback(closeError));\n\t\t\t});\n\t\t});\n\t});\n}\n\nexport function writeFileAndFlushSync(path: string, data: string | Buffer, options?: IWriteFileOptions): void {\n\toptions = ensureOptions(options);\n\n\tif (options.encoding) {\n\t\tdata = encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });\n\t}\n\n\tif (!canFlush) {\n\t\treturn fs.writeFileSync(path, data, { mode: options.mode, flag: options.flag });\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tconst fd = fs.openSync(path, typeof options.flag === 'string' ? options.flag : 'r', options.mode);\n\n\ttry {\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFileSync(fd, data);\n\n\t\t// Flush contents (not metadata) of the file to disk\n\t\ttry {\n\t\t\tfs.fdatasyncSync(fd);\n\t\t} catch (syncError) {\n\t\t\tconsole.warn('[node.js fs] fdatasyncSync is now disabled for this session because it failed: ', syncError);\n\t\t\tcanFlush = false;\n\t\t}\n\t} finally {\n\t\tfs.closeSync(fd);\n\t}\n}\n\nfunction ensureOptions(options?: IWriteFileOptions): IWriteFileOptions {\n\tif (!options) {\n\t\treturn { mode: 0o666, flag: 'w' };\n\t}\n\n\tconst ensuredOptions: IWriteFileOptions = { mode: options.mode, flag: options.flag, encoding: options.encoding };\n\n\tif (typeof ensuredOptions.mode !== 'number') {\n\t\tensuredOptions.mode = 0o666;\n\t}\n\n\tif (typeof ensuredOptions.flag !== 'string') {\n\t\tensuredOptions.flag = 'w';\n\t}\n\n\treturn ensuredOptions;\n}\n\n/**\n * Copied from: https://github.com/Microsoft/vscode-node-debug/blob/master/src/node/pathUtilities.ts#L83\n *\n * Given an absolute, normalized, and existing file path 'realcase' returns the exact path that the file has on disk.\n * On a case insensitive file system, the returned path might differ from the original path by character casing.\n * On a case sensitive file system, the returned path will always be identical to the original path.\n * In case of errors, null is returned. But you cannot use this function to verify that a path exists.\n * realcaseSync does not handle '..' or '.' path segments and it does not take the locale into account.\n */\nexport function realcaseSync(path: string): string | null {\n\tconst dir = paths.dirname(path);\n\tif (path === dir) {\t// end recursion\n\t\treturn path;\n\t}\n\n\tconst name = (paths.basename(path) /* can be '' for windows drive letters */ || path).toLowerCase();\n\ttry {\n\t\tconst entries = readdirSync(dir);\n\t\tconst found = entries.filter(e => e.toLowerCase() === name);\t// use a case insensitive search\n\t\tif (found.length === 1) {\n\t\t\t// on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition\n\t\t\tconst prefix = realcaseSync(dir);   // recurse\n\t\t\tif (prefix) {\n\t\t\t\treturn paths.join(prefix, found[0]);\n\t\t\t}\n\t\t} else if (found.length > 1) {\n\t\t\t// must be a case sensitive $filesystem\n\t\t\tconst ix = found.indexOf(name);\n\t\t\tif (ix >= 0) {\t// case sensitive\n\t\t\t\tconst prefix = realcaseSync(dir);   // recurse\n\t\t\t\tif (prefix) {\n\t\t\t\t\treturn paths.join(prefix, found[ix]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\t// silently ignore error\n\t}\n\n\treturn null;\n}\n\nexport function realpathSync(path: string): string {\n\ttry {\n\t\treturn fs.realpathSync(path);\n\t} catch (error) {\n\n\t\t// We hit an error calling fs.realpathSync(). Since fs.realpathSync() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\t\tfs.accessSync(normalizedPath, fs.constants.R_OK); // throws in case of an error\n\n\t\treturn normalizedPath;\n\t}\n}\n\nexport function realpath(path: string, callback: (error: Error | null, realpath: string) => void): void {\n\treturn fs.realpath(path, (error, realpath) => {\n\t\tif (!error) {\n\t\t\treturn callback(null, realpath);\n\t\t}\n\n\t\t// We hit an error calling fs.realpath(). Since fs.realpath() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\n\t\treturn fs.access(normalizedPath, fs.constants.R_OK, error => {\n\t\t\treturn callback(error, normalizedPath);\n\t\t});\n\t});\n}\n\nfunction normalizePath(path: string): string {\n\treturn strings.rtrim(paths.normalize(path), paths.sep);\n}\n\nexport function watch(path: string, onChange: (type: string, path?: string) => void, onError: (error: string) => void): IDisposable {\n\ttry {\n\t\tconst watcher = fs.watch(path);\n\n\t\twatcher.on('change', (type, raw) => {\n\t\t\tlet file: string | undefined;\n\t\t\tif (raw) { // https://github.com/Microsoft/vscode/issues/38191\n\t\t\t\tfile = raw.toString();\n\t\t\t\tif (platform.isMacintosh) {\n\t\t\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\t\t\t// See also https://github.com/nodejs/node/issues/2165\n\t\t\t\t\tfile = normalizeNFC(file);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tonChange(type, file);\n\t\t});\n\n\t\twatcher.on('error', (code: number, signal: string) => onError(`Failed to watch ${path} for changes (${code}, ${signal})`));\n\n\t\treturn toDisposable(() => {\n\t\t\twatcher.removeAllListeners();\n\t\t\twatcher.close();\n\t\t});\n\t} catch (error) {\n\t\tfs.exists(path, exists => {\n\t\t\tif (exists) {\n\t\t\t\tonError(`Failed to watch ${path} for changes (${error.toString()})`);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn Disposable.None;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (platform.isWindows && strings.endsWith(candidate, ':')) {\n\t\tcandidate += paths.sep;\n\t}\n\n\t// Ensure absolute\n\tif (!paths.isAbsolute(candidate)) {\n\t\tcandidate = paths.join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = paths.normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (platform.isWindows) {\n\t\tcandidate = strings.rtrim(candidate, paths.sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (strings.endsWith(candidate, ':')) {\n\t\t\tcandidate += paths.sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = strings.rtrim(candidate, paths.sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = paths.sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}"]}]}