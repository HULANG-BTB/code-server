{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/keybinding/electron-browser/keybindingService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/keybinding/electron-browser/keybindingService.ts","mtime":1555846338048},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"native-keymap\", \"os\", \"vs/base/browser/dom\", \"vs/base/browser/keyboardEvent\", \"vs/base/common/errors\", \"vs/base/common/event\", \"vs/base/common/keybindingParser\", \"vs/base/common/platform\", \"vs/base/node/config\", \"vs/platform/commands/common/commands\", \"vs/platform/configuration/common/configuration\", \"vs/platform/configuration/common/configurationRegistry\", \"vs/platform/contextkey/common/contextkey\", \"vs/platform/environment/common/environment\", \"vs/platform/jsonschemas/common/jsonContributionRegistry\", \"vs/platform/keybinding/common/abstractKeybindingService\", \"vs/platform/keybinding/common/keybinding\", \"vs/platform/keybinding/common/keybindingResolver\", \"vs/platform/keybinding/common/keybindingsRegistry\", \"vs/platform/keybinding/common/resolvedKeybindingItem\", \"vs/platform/notification/common/notification\", \"vs/platform/registry/common/platform\", \"vs/platform/statusbar/common/statusbar\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/telemetry/common/telemetryUtils\", \"vs/workbench/services/extensions/common/extensionsRegistry\", \"vs/workbench/services/keybinding/common/keybindingIO\", \"vs/workbench/services/keybinding/common/keyboardMapper\", \"vs/workbench/services/keybinding/common/macLinuxFallbackKeyboardMapper\", \"vs/workbench/services/keybinding/common/macLinuxKeyboardMapper\", \"vs/workbench/services/keybinding/common/windowsKeyboardMapper\", \"vs/platform/windows/common/windows\", \"vs/workbench/services/extensions/common/extensions\", \"vs/platform/actions/common/actions\", \"vs/platform/instantiation/common/extensions\"], function (require, exports, nls, nativeKeymap, os_1, dom, keyboardEvent_1, errors_1, event_1, keybindingParser_1, platform_1, config_1, commands_1, configuration_1, configurationRegistry_1, contextkey_1, environment_1, jsonContributionRegistry_1, abstractKeybindingService_1, keybinding_1, keybindingResolver_1, keybindingsRegistry_1, resolvedKeybindingItem_1, notification_1, platform_2, statusbar_1, telemetry_1, telemetryUtils_1, extensionsRegistry_1, keybindingIO_1, keyboardMapper_1, macLinuxFallbackKeyboardMapper_1, macLinuxKeyboardMapper_1, windowsKeyboardMapper_1, windows_1, extensions_1, actions_1, extensions_2) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class KeyboardMapperFactory {\n        constructor() {\n            this._onDidChangeKeyboardMapper = new event_1.Emitter();\n            this.onDidChangeKeyboardMapper = this._onDidChangeKeyboardMapper.event;\n            this._layoutInfo = null;\n            this._rawMapping = null;\n            this._keyboardMapper = null;\n            this._initialized = false;\n        }\n        _onKeyboardLayoutChanged() {\n            if (this._initialized) {\n                this._setKeyboardData(nativeKeymap.getCurrentKeyboardLayout(), nativeKeymap.getKeyMap());\n            }\n        }\n        getKeyboardMapper(dispatchConfig) {\n            if (!this._initialized) {\n                this._setKeyboardData(nativeKeymap.getCurrentKeyboardLayout(), nativeKeymap.getKeyMap());\n            }\n            if (dispatchConfig === DispatchConfig.KeyCode) {\n                // Forcefully set to use keyCode\n                return new macLinuxFallbackKeyboardMapper_1.MacLinuxFallbackKeyboardMapper(platform_1.OS);\n            }\n            return this._keyboardMapper;\n        }\n        getCurrentKeyboardLayout() {\n            if (!this._initialized) {\n                this._setKeyboardData(nativeKeymap.getCurrentKeyboardLayout(), nativeKeymap.getKeyMap());\n            }\n            return this._layoutInfo;\n        }\n        static _isUSStandard(_kbInfo) {\n            if (platform_1.OS === platform_1.OperatingSystem.Linux) {\n                const kbInfo = _kbInfo;\n                return (kbInfo && kbInfo.layout === 'us');\n            }\n            if (platform_1.OS === platform_1.OperatingSystem.Macintosh) {\n                const kbInfo = _kbInfo;\n                return (kbInfo && kbInfo.id === 'com.apple.keylayout.US');\n            }\n            if (platform_1.OS === platform_1.OperatingSystem.Windows) {\n                const kbInfo = _kbInfo;\n                return (kbInfo && kbInfo.name === '00000409');\n            }\n            return false;\n        }\n        getRawKeyboardMapping() {\n            if (!this._initialized) {\n                this._setKeyboardData(nativeKeymap.getCurrentKeyboardLayout(), nativeKeymap.getKeyMap());\n            }\n            return this._rawMapping;\n        }\n        _setKeyboardData(layoutInfo, rawMapping) {\n            this._layoutInfo = layoutInfo;\n            if (this._initialized && KeyboardMapperFactory._equals(this._rawMapping, rawMapping)) {\n                // nothing to do...\n                return;\n            }\n            this._initialized = true;\n            this._rawMapping = rawMapping;\n            this._keyboardMapper = new keyboardMapper_1.CachedKeyboardMapper(KeyboardMapperFactory._createKeyboardMapper(this._layoutInfo, this._rawMapping));\n            this._onDidChangeKeyboardMapper.fire();\n        }\n        static _createKeyboardMapper(layoutInfo, rawMapping) {\n            const isUSStandard = KeyboardMapperFactory._isUSStandard(layoutInfo);\n            if (platform_1.isNative && platform_1.OS === platform_1.OperatingSystem.Windows) {\n                return new windowsKeyboardMapper_1.WindowsKeyboardMapper(isUSStandard, rawMapping);\n            }\n            if (Object.keys(rawMapping).length === 0) {\n                // Looks like reading the mappings failed (most likely Mac + Japanese/Chinese keyboard layouts)\n                return new macLinuxFallbackKeyboardMapper_1.MacLinuxFallbackKeyboardMapper(platform_1.OS);\n            }\n            if (platform_1.OS === platform_1.OperatingSystem.Macintosh) {\n                const kbInfo = layoutInfo;\n                if (kbInfo.id === 'com.apple.keylayout.DVORAK-QWERTYCMD') {\n                    // Use keyCode based dispatching for DVORAK - QWERTY âŒ˜\n                    return new macLinuxFallbackKeyboardMapper_1.MacLinuxFallbackKeyboardMapper(platform_1.OS);\n                }\n            }\n            return new macLinuxKeyboardMapper_1.MacLinuxKeyboardMapper(isUSStandard, rawMapping, platform_1.OS);\n        }\n        static _equals(a, b) {\n            if (platform_1.OS === platform_1.OperatingSystem.Windows) {\n                return windowsKeyboardMapper_1.windowsKeyboardMappingEquals(a, b);\n            }\n            return macLinuxKeyboardMapper_1.macLinuxKeyboardMappingEquals(a, b);\n        }\n    }\n    KeyboardMapperFactory.INSTANCE = new KeyboardMapperFactory();\n    exports.KeyboardMapperFactory = KeyboardMapperFactory;\n    function isContributedKeyBindingsArray(thing) {\n        return Array.isArray(thing);\n    }\n    function isValidContributedKeyBinding(keyBinding, rejects) {\n        if (!keyBinding) {\n            rejects.push(nls.localize('nonempty', \"expected non-empty value.\"));\n            return false;\n        }\n        if (typeof keyBinding.command !== 'string') {\n            rejects.push(nls.localize('requirestring', \"property `{0}` is mandatory and must be of type `string`\", 'command'));\n            return false;\n        }\n        if (keyBinding.key && typeof keyBinding.key !== 'string') {\n            rejects.push(nls.localize('optstring', \"property `{0}` can be omitted or must be of type `string`\", 'key'));\n            return false;\n        }\n        if (keyBinding.when && typeof keyBinding.when !== 'string') {\n            rejects.push(nls.localize('optstring', \"property `{0}` can be omitted or must be of type `string`\", 'when'));\n            return false;\n        }\n        if (keyBinding.mac && typeof keyBinding.mac !== 'string') {\n            rejects.push(nls.localize('optstring', \"property `{0}` can be omitted or must be of type `string`\", 'mac'));\n            return false;\n        }\n        if (keyBinding.linux && typeof keyBinding.linux !== 'string') {\n            rejects.push(nls.localize('optstring', \"property `{0}` can be omitted or must be of type `string`\", 'linux'));\n            return false;\n        }\n        if (keyBinding.win && typeof keyBinding.win !== 'string') {\n            rejects.push(nls.localize('optstring', \"property `{0}` can be omitted or must be of type `string`\", 'win'));\n            return false;\n        }\n        return true;\n    }\n    let keybindingType = {\n        type: 'object',\n        default: { command: '', key: '' },\n        properties: {\n            command: {\n                description: nls.localize('vscode.extension.contributes.keybindings.command', 'Identifier of the command to run when keybinding is triggered.'),\n                type: 'string'\n            },\n            args: {\n                description: nls.localize('vscode.extension.contributes.keybindings.args', \"Arguments to pass to the command to execute.\")\n            },\n            key: {\n                description: nls.localize('vscode.extension.contributes.keybindings.key', 'Key or key sequence (separate keys with plus-sign and sequences with space, e.g Ctrl+O and Ctrl+L L for a chord).'),\n                type: 'string'\n            },\n            mac: {\n                description: nls.localize('vscode.extension.contributes.keybindings.mac', 'Mac specific key or key sequence.'),\n                type: 'string'\n            },\n            linux: {\n                description: nls.localize('vscode.extension.contributes.keybindings.linux', 'Linux specific key or key sequence.'),\n                type: 'string'\n            },\n            win: {\n                description: nls.localize('vscode.extension.contributes.keybindings.win', 'Windows specific key or key sequence.'),\n                type: 'string'\n            },\n            when: {\n                description: nls.localize('vscode.extension.contributes.keybindings.when', 'Condition when the key is active.'),\n                type: 'string'\n            },\n        }\n    };\n    const keybindingsExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint({\n        extensionPoint: 'keybindings',\n        jsonSchema: {\n            description: nls.localize('vscode.extension.contributes.keybindings', \"Contributes keybindings.\"),\n            oneOf: [\n                keybindingType,\n                {\n                    type: 'array',\n                    items: keybindingType\n                }\n            ]\n        }\n    });\n    var DispatchConfig;\n    (function (DispatchConfig) {\n        DispatchConfig[DispatchConfig[\"Code\"] = 0] = \"Code\";\n        DispatchConfig[DispatchConfig[\"KeyCode\"] = 1] = \"KeyCode\";\n    })(DispatchConfig = exports.DispatchConfig || (exports.DispatchConfig = {}));\n    function getDispatchConfig(configurationService) {\n        const keyboard = configurationService.getValue('keyboard');\n        const r = (keyboard ? keyboard.dispatch : null);\n        return (r === 'keyCode' ? DispatchConfig.KeyCode : DispatchConfig.Code);\n    }\n    let WorkbenchKeybindingService = class WorkbenchKeybindingService extends abstractKeybindingService_1.AbstractKeybindingService {\n        constructor(contextKeyService, commandService, telemetryService, notificationService, environmentService, statusBarService, configurationService, windowService, extensionService) {\n            super(contextKeyService, commandService, telemetryService, notificationService, statusBarService);\n            this.windowService = windowService;\n            updateSchema();\n            let dispatchConfig = getDispatchConfig(configurationService);\n            configurationService.onDidChangeConfiguration((e) => {\n                let newDispatchConfig = getDispatchConfig(configurationService);\n                if (dispatchConfig === newDispatchConfig) {\n                    return;\n                }\n                dispatchConfig = newDispatchConfig;\n                this._keyboardMapper = KeyboardMapperFactory.INSTANCE.getKeyboardMapper(dispatchConfig);\n                this.updateResolver({ source: keybinding_1.KeybindingSource.Default });\n            });\n            this._keyboardMapper = KeyboardMapperFactory.INSTANCE.getKeyboardMapper(dispatchConfig);\n            KeyboardMapperFactory.INSTANCE.onDidChangeKeyboardMapper(() => {\n                this._keyboardMapper = KeyboardMapperFactory.INSTANCE.getKeyboardMapper(dispatchConfig);\n                this.updateResolver({ source: keybinding_1.KeybindingSource.Default });\n            });\n            this._cachedResolver = null;\n            this._firstTimeComputingResolver = true;\n            this.userKeybindings = this._register(new config_1.ConfigWatcher(environmentService.appKeybindingsPath, { defaultConfig: [], onError: error => errors_1.onUnexpectedError(error) }));\n            keybindingsExtPoint.setHandler((extensions) => {\n                let keybindings = [];\n                for (let extension of extensions) {\n                    this._handleKeybindingsExtensionPointUser(extension.description.isBuiltin, extension.value, extension.collector, keybindings);\n                }\n                keybindingsRegistry_1.KeybindingsRegistry.setExtensionKeybindings(keybindings);\n                this.updateResolver({ source: keybinding_1.KeybindingSource.Default });\n            });\n            updateSchema();\n            this._register(extensionService.onDidRegisterExtensions(() => updateSchema()));\n            this._register(this.userKeybindings.onDidUpdateConfiguration(event => this.updateResolver({\n                source: keybinding_1.KeybindingSource.User,\n                keybindings: event.config\n            })));\n            this._register(dom.addDisposableListener(window, dom.EventType.KEY_DOWN, (e) => {\n                let keyEvent = new keyboardEvent_1.StandardKeyboardEvent(e);\n                let shouldPreventDefault = this._dispatch(keyEvent, keyEvent.target);\n                if (shouldPreventDefault) {\n                    keyEvent.preventDefault();\n                }\n            }));\n            telemetryUtils_1.keybindingsTelemetry(telemetryService, this);\n            let data = KeyboardMapperFactory.INSTANCE.getCurrentKeyboardLayout();\n            /* __GDPR__\n                \"keyboardLayout\" : {\n                    \"currentKeyboardLayout\": { \"${inline}\": [ \"${IKeyboardLayoutInfo}\" ] }\n                }\n            */\n            telemetryService.publicLog('keyboardLayout', {\n                currentKeyboardLayout: data\n            });\n        }\n        _dumpDebugInfo() {\n            const layoutInfo = JSON.stringify(KeyboardMapperFactory.INSTANCE.getCurrentKeyboardLayout(), null, '\\t');\n            const mapperInfo = this._keyboardMapper.dumpDebugInfo();\n            const rawMapping = JSON.stringify(KeyboardMapperFactory.INSTANCE.getRawKeyboardMapping(), null, '\\t');\n            return `Layout info:\\n${layoutInfo}\\n${mapperInfo}\\n\\nRaw mapping:\\n${rawMapping}`;\n        }\n        _safeGetConfig() {\n            let rawConfig = this.userKeybindings.getConfig();\n            if (Array.isArray(rawConfig)) {\n                return rawConfig;\n            }\n            return [];\n        }\n        customKeybindingsCount() {\n            let userKeybindings = this._safeGetConfig();\n            return userKeybindings.length;\n        }\n        updateResolver(event) {\n            this._cachedResolver = null;\n            this._onDidUpdateKeybindings.fire(event);\n        }\n        _getResolver() {\n            if (!this._cachedResolver) {\n                const defaults = this._resolveKeybindingItems(keybindingsRegistry_1.KeybindingsRegistry.getDefaultKeybindings(), true);\n                const overrides = this._resolveUserKeybindingItems(this._getExtraKeybindings(this._firstTimeComputingResolver), false);\n                this._cachedResolver = new keybindingResolver_1.KeybindingResolver(defaults, overrides);\n                this._firstTimeComputingResolver = false;\n            }\n            return this._cachedResolver;\n        }\n        _documentHasFocus() {\n            // it is possible that the document has lost focus, but the\n            // window is still focused, e.g. when a <webview> element\n            // has focus\n            return this.windowService.hasFocus;\n        }\n        _resolveKeybindingItems(items, isDefault) {\n            let result = [], resultLen = 0;\n            for (const item of items) {\n                const when = (item.when ? item.when.normalize() : undefined);\n                const keybinding = item.keybinding;\n                if (!keybinding) {\n                    // This might be a removal keybinding item in user settings => accept it\n                    result[resultLen++] = new resolvedKeybindingItem_1.ResolvedKeybindingItem(null, item.command, item.commandArgs, when, isDefault);\n                }\n                else {\n                    const resolvedKeybindings = this.resolveKeybinding(keybinding);\n                    for (const resolvedKeybinding of resolvedKeybindings) {\n                        result[resultLen++] = new resolvedKeybindingItem_1.ResolvedKeybindingItem(resolvedKeybinding, item.command, item.commandArgs, when, isDefault);\n                    }\n                }\n            }\n            return result;\n        }\n        _resolveUserKeybindingItems(items, isDefault) {\n            let result = [], resultLen = 0;\n            for (const item of items) {\n                const when = (item.when ? item.when.normalize() : undefined);\n                const parts = item.parts;\n                if (parts.length === 0) {\n                    // This might be a removal keybinding item in user settings => accept it\n                    result[resultLen++] = new resolvedKeybindingItem_1.ResolvedKeybindingItem(null, item.command, item.commandArgs, when, isDefault);\n                }\n                else {\n                    const resolvedKeybindings = this._keyboardMapper.resolveUserBinding(parts);\n                    for (const resolvedKeybinding of resolvedKeybindings) {\n                        result[resultLen++] = new resolvedKeybindingItem_1.ResolvedKeybindingItem(resolvedKeybinding, item.command, item.commandArgs, when, isDefault);\n                    }\n                }\n            }\n            return result;\n        }\n        _getExtraKeybindings(isFirstTime) {\n            let extraUserKeybindings = this._safeGetConfig();\n            if (!isFirstTime) {\n                let cnt = extraUserKeybindings.length;\n                /* __GDPR__\n                    \"customKeybindingsChanged\" : {\n                        \"keyCount\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n                    }\n                */\n                this._telemetryService.publicLog('customKeybindingsChanged', {\n                    keyCount: cnt\n                });\n            }\n            return extraUserKeybindings.map((k) => keybindingIO_1.KeybindingIO.readUserKeybindingItem(k));\n        }\n        resolveKeybinding(kb) {\n            return this._keyboardMapper.resolveKeybinding(kb);\n        }\n        resolveKeyboardEvent(keyboardEvent) {\n            return this._keyboardMapper.resolveKeyboardEvent(keyboardEvent);\n        }\n        resolveUserBinding(userBinding) {\n            const parts = keybindingParser_1.KeybindingParser.parseUserBinding(userBinding);\n            return this._keyboardMapper.resolveUserBinding(parts);\n        }\n        _handleKeybindingsExtensionPointUser(isBuiltin, keybindings, collector, result) {\n            if (isContributedKeyBindingsArray(keybindings)) {\n                for (let i = 0, len = keybindings.length; i < len; i++) {\n                    this._handleKeybinding(isBuiltin, i + 1, keybindings[i], collector, result);\n                }\n            }\n            else {\n                this._handleKeybinding(isBuiltin, 1, keybindings, collector, result);\n            }\n        }\n        _handleKeybinding(isBuiltin, idx, keybindings, collector, result) {\n            let rejects = [];\n            if (isValidContributedKeyBinding(keybindings, rejects)) {\n                let rule = this._asCommandRule(isBuiltin, idx++, keybindings);\n                if (rule) {\n                    result.push(rule);\n                }\n            }\n            if (rejects.length > 0) {\n                collector.error(nls.localize('invalid.keybindings', \"Invalid `contributes.{0}`: {1}\", keybindingsExtPoint.name, rejects.join('\\n')));\n            }\n        }\n        _asCommandRule(isBuiltin, idx, binding) {\n            let { command, args, when, key, mac, linux, win } = binding;\n            let weight;\n            if (isBuiltin) {\n                weight = keybindingsRegistry_1.KeybindingWeight.BuiltinExtension + idx;\n            }\n            else {\n                weight = keybindingsRegistry_1.KeybindingWeight.ExternalExtension + idx;\n            }\n            let desc = {\n                id: command,\n                args,\n                when: contextkey_1.ContextKeyExpr.deserialize(when),\n                weight: weight,\n                primary: keybindingParser_1.KeybindingParser.parseKeybinding(key, platform_1.OS),\n                mac: mac ? { primary: keybindingParser_1.KeybindingParser.parseKeybinding(mac, platform_1.OS) } : null,\n                linux: linux ? { primary: keybindingParser_1.KeybindingParser.parseKeybinding(linux, platform_1.OS) } : null,\n                win: win ? { primary: keybindingParser_1.KeybindingParser.parseKeybinding(win, platform_1.OS) } : null\n            };\n            if (!desc.primary && !desc.mac && !desc.linux && !desc.win) {\n                return undefined;\n            }\n            return desc;\n        }\n        getDefaultKeybindingsContent() {\n            const resolver = this._getResolver();\n            const defaultKeybindings = resolver.getDefaultKeybindings();\n            const boundCommands = resolver.getDefaultBoundCommands();\n            return (WorkbenchKeybindingService._getDefaultKeybindings(defaultKeybindings)\n                + '\\n\\n'\n                + WorkbenchKeybindingService._getAllCommandsAsComment(boundCommands));\n        }\n        static _getDefaultKeybindings(defaultKeybindings) {\n            let out = new keybindingIO_1.OutputBuilder();\n            out.writeLine('[');\n            let lastIndex = defaultKeybindings.length - 1;\n            defaultKeybindings.forEach((k, index) => {\n                keybindingIO_1.KeybindingIO.writeKeybindingItem(out, k);\n                if (index !== lastIndex) {\n                    out.writeLine(',');\n                }\n                else {\n                    out.writeLine();\n                }\n            });\n            out.writeLine(']');\n            return out.toString();\n        }\n        static _getAllCommandsAsComment(boundCommands) {\n            const unboundCommands = keybindingResolver_1.KeybindingResolver.getAllUnboundCommands(boundCommands);\n            let pretty = unboundCommands.sort().join('\\n// - ');\n            return '// ' + nls.localize('unboundCommands', \"Here are other available commands: \") + '\\n// - ' + pretty;\n        }\n        mightProducePrintableCharacter(event) {\n            if (event.ctrlKey || event.metaKey) {\n                // ignore ctrl/cmd-combination but not shift/alt-combinatios\n                return false;\n            }\n            // consult the KeyboardMapperFactory to check the given event for\n            // a printable value.\n            const mapping = KeyboardMapperFactory.INSTANCE.getRawKeyboardMapping();\n            if (!mapping) {\n                return false;\n            }\n            const keyInfo = mapping[event.code];\n            if (!keyInfo) {\n                return false;\n            }\n            if (!keyInfo.value || /\\s/.test(keyInfo.value)) {\n                return false;\n            }\n            return true;\n        }\n    };\n    WorkbenchKeybindingService = __decorate([\n        __param(0, contextkey_1.IContextKeyService),\n        __param(1, commands_1.ICommandService),\n        __param(2, telemetry_1.ITelemetryService),\n        __param(3, notification_1.INotificationService),\n        __param(4, environment_1.IEnvironmentService),\n        __param(5, statusbar_1.IStatusbarService),\n        __param(6, configuration_1.IConfigurationService),\n        __param(7, windows_1.IWindowService),\n        __param(8, extensions_1.IExtensionService)\n    ], WorkbenchKeybindingService);\n    exports.WorkbenchKeybindingService = WorkbenchKeybindingService;\n    let schemaId = 'vscode://schemas/keybindings';\n    let commandsSchemas = [];\n    let commandsEnum = [];\n    let commandsEnumDescriptions = [];\n    let schema = {\n        'id': schemaId,\n        'type': 'array',\n        'title': nls.localize('keybindings.json.title', \"Keybindings configuration\"),\n        'definitions': {\n            'editorGroupsSchema': {\n                'type': 'array',\n                'items': {\n                    'type': 'object',\n                    'properties': {\n                        'groups': {\n                            '$ref': '#/definitions/editorGroupsSchema',\n                            'default': [{}, {}]\n                        },\n                        'size': {\n                            'type': 'number',\n                            'default': 0.5\n                        }\n                    }\n                }\n            }\n        },\n        'items': {\n            'required': ['key'],\n            'type': 'object',\n            'defaultSnippets': [{ 'body': { 'key': '$1', 'command': '$2', 'when': '$3' } }],\n            'properties': {\n                'key': {\n                    'type': 'string',\n                    'description': nls.localize('keybindings.json.key', \"Key or key sequence (separated by space)\"),\n                },\n                'command': {\n                    'type': 'string',\n                    'enum': commandsEnum,\n                    'enumDescriptions': commandsEnumDescriptions,\n                    'description': nls.localize('keybindings.json.command', \"Name of the command to execute\"),\n                },\n                'when': {\n                    'type': 'string',\n                    'description': nls.localize('keybindings.json.when', \"Condition when the key is active.\")\n                },\n                'args': {\n                    'description': nls.localize('keybindings.json.args', \"Arguments to pass to the command to execute.\")\n                }\n            },\n            'allOf': commandsSchemas\n        }\n    };\n    let schemaRegistry = platform_2.Registry.as(jsonContributionRegistry_1.Extensions.JSONContribution);\n    schemaRegistry.registerSchema(schemaId, schema);\n    function updateSchema() {\n        commandsSchemas.length = 0;\n        commandsEnum.length = 0;\n        commandsEnumDescriptions.length = 0;\n        const knownCommands = new Set();\n        const addKnownCommand = (commandId, description) => {\n            if (!/^_/.test(commandId)) {\n                if (!knownCommands.has(commandId)) {\n                    knownCommands.add(commandId);\n                    commandsEnum.push(commandId);\n                    commandsEnumDescriptions.push(description);\n                    // Also add the negative form for keybinding removal\n                    commandsEnum.push(`-${commandId}`);\n                    commandsEnumDescriptions.push(description);\n                }\n            }\n        };\n        const allCommands = commands_1.CommandsRegistry.getCommands();\n        for (let commandId in allCommands) {\n            const commandDescription = allCommands[commandId].description;\n            addKnownCommand(commandId, commandDescription ? commandDescription.description : undefined);\n            if (!commandDescription || !commandDescription.args || commandDescription.args.length !== 1 || !commandDescription.args[0].schema) {\n                continue;\n            }\n            const argsSchema = commandDescription.args[0].schema;\n            const argsRequired = Array.isArray(argsSchema.required) && argsSchema.required.length > 0;\n            const addition = {\n                'if': {\n                    'properties': {\n                        'command': { 'const': commandId }\n                    }\n                },\n                'then': {\n                    'required': [].concat(argsRequired ? ['args'] : []),\n                    'properties': {\n                        'args': argsSchema\n                    }\n                }\n            };\n            commandsSchemas.push(addition);\n        }\n        const menuCommands = actions_1.MenuRegistry.getCommands();\n        for (let commandId in menuCommands) {\n            addKnownCommand(commandId);\n        }\n    }\n    const configurationRegistry = platform_2.Registry.as(configurationRegistry_1.Extensions.Configuration);\n    const keyboardConfiguration = {\n        'id': 'keyboard',\n        'order': 15,\n        'type': 'object',\n        'title': nls.localize('keyboardConfigurationTitle', \"Keyboard\"),\n        'overridable': true,\n        'properties': {\n            'keyboard.dispatch': {\n                'type': 'string',\n                'enum': ['code', 'keyCode'],\n                'default': 'code',\n                'markdownDescription': nls.localize('dispatch', \"Controls the dispatching logic for key presses to use either `code` (recommended) or `keyCode`.\"),\n                'included': platform_1.OS === platform_1.OperatingSystem.Macintosh || platform_1.OS === platform_1.OperatingSystem.Linux\n            },\n            'keyboard.touchbar.enabled': {\n                'type': 'boolean',\n                'default': true,\n                'description': nls.localize('touchbar.enabled', \"Enables the macOS touchbar buttons on the keyboard if available.\"),\n                'included': platform_1.OS === platform_1.OperatingSystem.Macintosh && parseFloat(os_1.release()) >= 16 // Minimum: macOS Sierra (10.12.x = darwin 16.x)\n            }\n        }\n    };\n    configurationRegistry.registerConfiguration(keyboardConfiguration);\n    extensions_2.registerSingleton(keybinding_1.IKeybindingService, WorkbenchKeybindingService);\n});\n",null]}