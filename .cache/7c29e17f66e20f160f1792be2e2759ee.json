{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/comment/lineCommentCommand.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/comment/lineCommentCommand.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/charCode\", \"vs/base/common/strings\", \"vs/editor/common/core/editOperation\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\", \"vs/editor/common/core/selection\", \"vs/editor/common/modes/languageConfigurationRegistry\", \"vs/editor/contrib/comment/blockCommentCommand\"], function (require, exports, charCode_1, strings, editOperation_1, position_1, range_1, selection_1, languageConfigurationRegistry_1, blockCommentCommand_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Type;\n    (function (Type) {\n        Type[Type[\"Toggle\"] = 0] = \"Toggle\";\n        Type[Type[\"ForceAdd\"] = 1] = \"ForceAdd\";\n        Type[Type[\"ForceRemove\"] = 2] = \"ForceRemove\";\n    })(Type = exports.Type || (exports.Type = {}));\n    class LineCommentCommand {\n        constructor(selection, tabSize, type) {\n            this._selection = selection;\n            this._tabSize = tabSize;\n            this._type = type;\n            this._deltaColumn = 0;\n        }\n        /**\n         * Do an initial pass over the lines and gather info about the line comment string.\n         * Returns null if any of the lines doesn't support a line comment string.\n         */\n        static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber) {\n            model.tokenizeIfCheap(startLineNumber);\n            const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n            const config = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getComments(languageId);\n            const commentStr = (config ? config.lineCommentToken : null);\n            if (!commentStr) {\n                // Mode does not support line comments\n                return null;\n            }\n            let lines = [];\n            for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n                lines[i] = {\n                    ignore: false,\n                    commentStr: commentStr,\n                    commentStrOffset: 0,\n                    commentStrLength: commentStr.length\n                };\n            }\n            return lines;\n        }\n        /**\n         * Analyze lines and decide which lines are relevant and what the toggle should do.\n         * Also, build up several offsets and lengths useful in the generation of editor operations.\n         */\n        static _analyzeLines(type, model, lines, startLineNumber) {\n            let onlyWhitespaceLines = true;\n            let shouldRemoveComments;\n            if (type === Type.Toggle) {\n                shouldRemoveComments = true;\n            }\n            else if (type === Type.ForceAdd) {\n                shouldRemoveComments = false;\n            }\n            else {\n                shouldRemoveComments = true;\n            }\n            for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n                const lineData = lines[i];\n                const lineNumber = startLineNumber + i;\n                const lineContent = model.getLineContent(lineNumber);\n                const lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n                if (lineContentStartOffset === -1) {\n                    // Empty or whitespace only line\n                    if (type === Type.Toggle) {\n                        lineData.ignore = true;\n                    }\n                    else if (type === Type.ForceAdd) {\n                        lineData.ignore = true;\n                    }\n                    else {\n                        lineData.ignore = true;\n                    }\n                    lineData.commentStrOffset = lineContent.length;\n                    continue;\n                }\n                onlyWhitespaceLines = false;\n                lineData.ignore = false;\n                lineData.commentStrOffset = lineContentStartOffset;\n                if (shouldRemoveComments && !blockCommentCommand_1.BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\n                    if (type === Type.Toggle) {\n                        // Every line so far has been a line comment, but this one is not\n                        shouldRemoveComments = false;\n                    }\n                    else if (type === Type.ForceAdd) {\n                        // Will not happen\n                    }\n                    else {\n                        lineData.ignore = true;\n                    }\n                }\n                if (shouldRemoveComments) {\n                    const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n                    if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === charCode_1.CharCode.Space) {\n                        lineData.commentStrLength += 1;\n                    }\n                }\n            }\n            if (type === Type.Toggle && onlyWhitespaceLines) {\n                // For only whitespace lines, we insert comments\n                shouldRemoveComments = false;\n                // Also, no longer ignore them\n                for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n                    lines[i].ignore = false;\n                }\n            }\n            return {\n                supported: true,\n                shouldRemoveComments: shouldRemoveComments,\n                lines: lines\n            };\n        }\n        /**\n         * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\n         */\n        static _gatherPreflightData(type, model, startLineNumber, endLineNumber) {\n            const lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber);\n            if (lines === null) {\n                return {\n                    supported: false\n                };\n            }\n            return LineCommentCommand._analyzeLines(type, model, lines, startLineNumber);\n        }\n        /**\n         * Given a successful analysis, execute either insert line comments, either remove line comments\n         */\n        _executeLineComments(model, builder, data, s) {\n            let ops;\n            if (data.shouldRemoveComments) {\n                ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n            }\n            else {\n                LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);\n                ops = LineCommentCommand._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n            }\n            const cursorPosition = new position_1.Position(s.positionLineNumber, s.positionColumn);\n            for (let i = 0, len = ops.length; i < len; i++) {\n                builder.addEditOperation(ops[i].range, ops[i].text);\n                if (ops[i].range.isEmpty() && ops[i].range.getStartPosition().equals(cursorPosition)) {\n                    const lineContent = model.getLineContent(cursorPosition.lineNumber);\n                    if (lineContent.length + 1 === cursorPosition.column) {\n                        this._deltaColumn = (ops[i].text || '').length;\n                    }\n                }\n            }\n            this._selectionId = builder.trackSelection(s);\n        }\n        _attemptRemoveBlockComment(model, s, startToken, endToken) {\n            let startLineNumber = s.startLineNumber;\n            let endLineNumber = s.endLineNumber;\n            let startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\n            let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n            let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n            if (startTokenIndex !== -1 && endTokenIndex === -1) {\n                endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n                endLineNumber = startLineNumber;\n            }\n            if (startTokenIndex === -1 && endTokenIndex !== -1) {\n                startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n                startLineNumber = endLineNumber;\n            }\n            if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n                startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n                if (startTokenIndex !== -1) {\n                    endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n                }\n            }\n            // We have to adjust to possible inner white space.\n            // For Space after startToken, add Space to startToken - range math will work out.\n            if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === charCode_1.CharCode.Space) {\n                startToken += ' ';\n            }\n            // For Space before endToken, add Space before endToken and shift index one left.\n            if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === charCode_1.CharCode.Space) {\n                endToken = ' ' + endToken;\n                endTokenIndex -= 1;\n            }\n            if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n                return blockCommentCommand_1.BlockCommentCommand._createRemoveBlockCommentOperations(new range_1.Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n            }\n            return null;\n        }\n        /**\n         * Given an unsuccessful analysis, delegate to the block comment command\n         */\n        _executeBlockComment(model, builder, s) {\n            model.tokenizeIfCheap(s.startLineNumber);\n            let languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n            let config = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getComments(languageId);\n            if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n                // Mode does not support block comments\n                return;\n            }\n            const startToken = config.blockCommentStartToken;\n            const endToken = config.blockCommentEndToken;\n            let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n            if (!ops) {\n                if (s.isEmpty()) {\n                    const lineContent = model.getLineContent(s.startLineNumber);\n                    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n                    if (firstNonWhitespaceIndex === -1) {\n                        // Line is empty or contains only whitespace\n                        firstNonWhitespaceIndex = lineContent.length;\n                    }\n                    ops = blockCommentCommand_1.BlockCommentCommand._createAddBlockCommentOperations(new range_1.Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken);\n                }\n                else {\n                    ops = blockCommentCommand_1.BlockCommentCommand._createAddBlockCommentOperations(new range_1.Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken);\n                }\n                if (ops.length === 1) {\n                    // Leave cursor after token and Space\n                    this._deltaColumn = startToken.length + 1;\n                }\n            }\n            this._selectionId = builder.trackSelection(s);\n            for (const op of ops) {\n                builder.addEditOperation(op.range, op.text);\n            }\n        }\n        getEditOperations(model, builder) {\n            let s = this._selection;\n            this._moveEndPositionDown = false;\n            if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n                this._moveEndPositionDown = true;\n                s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n            }\n            const data = LineCommentCommand._gatherPreflightData(this._type, model, s.startLineNumber, s.endLineNumber);\n            if (data.supported) {\n                return this._executeLineComments(model, builder, data, s);\n            }\n            return this._executeBlockComment(model, builder, s);\n        }\n        computeCursorState(model, helper) {\n            let result = helper.getTrackedSelection(this._selectionId);\n            if (this._moveEndPositionDown) {\n                result = result.setEndPosition(result.endLineNumber + 1, 1);\n            }\n            return new selection_1.Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\n        }\n        /**\n         * Generate edit operations in the remove line comment case\n         */\n        static _createRemoveLineCommentsOperations(lines, startLineNumber) {\n            let res = [];\n            for (let i = 0, len = lines.length; i < len; i++) {\n                const lineData = lines[i];\n                if (lineData.ignore) {\n                    continue;\n                }\n                res.push(editOperation_1.EditOperation.delete(new range_1.Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\n            }\n            return res;\n        }\n        /**\n         * Generate edit operations in the add line comment case\n         */\n        static _createAddLineCommentsOperations(lines, startLineNumber) {\n            let res = [];\n            for (let i = 0, len = lines.length; i < len; i++) {\n                const lineData = lines[i];\n                if (lineData.ignore) {\n                    continue;\n                }\n                res.push(editOperation_1.EditOperation.insert(new position_1.Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + ' '));\n            }\n            return res;\n        }\n        // TODO@Alex -> duplicated in characterHardWrappingLineMapper\n        static nextVisibleColumn(currentVisibleColumn, tabSize, isTab, columnSize) {\n            if (isTab) {\n                return currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));\n            }\n            return currentVisibleColumn + columnSize;\n        }\n        /**\n         * Adjust insertion points to have them vertically aligned in the add line comment case\n         */\n        static _normalizeInsertionPoint(model, lines, startLineNumber, tabSize) {\n            let minVisibleColumn = Number.MAX_VALUE;\n            let j;\n            let lenJ;\n            for (let i = 0, len = lines.length; i < len; i++) {\n                if (lines[i].ignore) {\n                    continue;\n                }\n                const lineContent = model.getLineContent(startLineNumber + i);\n                let currentVisibleColumn = 0;\n                for (let j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n                    currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === charCode_1.CharCode.Tab, 1);\n                }\n                if (currentVisibleColumn < minVisibleColumn) {\n                    minVisibleColumn = currentVisibleColumn;\n                }\n            }\n            minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;\n            for (let i = 0, len = lines.length; i < len; i++) {\n                if (lines[i].ignore) {\n                    continue;\n                }\n                const lineContent = model.getLineContent(startLineNumber + i);\n                let currentVisibleColumn = 0;\n                for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n                    currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === charCode_1.CharCode.Tab, 1);\n                }\n                if (currentVisibleColumn > minVisibleColumn) {\n                    lines[i].commentStrOffset = j - 1;\n                }\n                else {\n                    lines[i].commentStrOffset = j;\n                }\n            }\n        }\n    }\n    exports.LineCommentCommand = LineCommentCommand;\n});\n",null]}