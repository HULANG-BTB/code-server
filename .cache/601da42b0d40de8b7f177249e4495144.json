{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/notification/common/notificationService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/notification/common/notificationService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/platform/notification/common/notification\", \"vs/workbench/common/notifications\", \"vs/base/common/lifecycle\", \"vs/base/common/event\", \"vs/platform/instantiation/common/extensions\"], function (require, exports, notification_1, notifications_1, lifecycle_1, event_1, extensions_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class NotificationService extends lifecycle_1.Disposable {\n        constructor() {\n            super(...arguments);\n            this._model = this._register(new notifications_1.NotificationsModel());\n        }\n        get model() {\n            return this._model;\n        }\n        info(message) {\n            if (Array.isArray(message)) {\n                message.forEach(m => this.info(m));\n                return;\n            }\n            this.model.notify({ severity: notification_1.Severity.Info, message });\n        }\n        warn(message) {\n            if (Array.isArray(message)) {\n                message.forEach(m => this.warn(m));\n                return;\n            }\n            this.model.notify({ severity: notification_1.Severity.Warning, message });\n        }\n        error(message) {\n            if (Array.isArray(message)) {\n                message.forEach(m => this.error(m));\n                return;\n            }\n            this.model.notify({ severity: notification_1.Severity.Error, message });\n        }\n        notify(notification) {\n            return this.model.notify(notification);\n        }\n        prompt(severity, message, choices, options) {\n            const toDispose = [];\n            let choiceClicked = false;\n            let handle;\n            // Convert choices into primary/secondary actions\n            const actions = { primary: [], secondary: [] };\n            choices.forEach((choice, index) => {\n                const action = new notifications_1.ChoiceAction(`workbench.dialog.choice.${index}`, choice);\n                if (!choice.isSecondary) {\n                    if (!actions.primary) {\n                        actions.primary = [];\n                    }\n                    actions.primary.push(action);\n                }\n                else {\n                    if (!actions.secondary) {\n                        actions.secondary = [];\n                    }\n                    actions.secondary.push(action);\n                }\n                // React to action being clicked\n                toDispose.push(action.onDidRun(() => {\n                    choiceClicked = true;\n                    // Close notification unless we are told to keep open\n                    if (!choice.keepOpen) {\n                        handle.close();\n                    }\n                }));\n                toDispose.push(action);\n            });\n            // Show notification with actions\n            handle = this.notify({ severity, message, actions, sticky: options && options.sticky, silent: options && options.silent });\n            event_1.Event.once(handle.onDidClose)(() => {\n                // Cleanup when notification gets disposed\n                lifecycle_1.dispose(toDispose);\n                // Indicate cancellation to the outside if no action was executed\n                if (options && typeof options.onCancel === 'function' && !choiceClicked) {\n                    options.onCancel();\n                }\n            });\n            return handle;\n        }\n    }\n    exports.NotificationService = NotificationService;\n    extensions_1.registerSingleton(notification_1.INotificationService, NotificationService, true);\n});\n",null]}