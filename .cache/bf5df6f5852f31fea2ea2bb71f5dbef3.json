{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/node/searchService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/node/searchService.ts","mtime":1555846338048},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/amd\", \"vs/base/common/arrays\", \"vs/base/common/errors\", \"vs/base/common/lifecycle\", \"vs/base/common/map\", \"vs/base/common/network\", \"vs/base/common/stopwatch\", \"vs/base/common/uri\", \"vs/base/node/pfs\", \"vs/base/parts/ipc/common/ipc\", \"vs/base/parts/ipc/node/ipc.cp\", \"vs/editor/common/services/modelService\", \"vs/platform/configuration/common/configuration\", \"vs/platform/environment/common/environment\", \"vs/platform/files/common/files\", \"vs/platform/instantiation/common/extensions\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/log/common/log\", \"vs/platform/telemetry/common/telemetry\", \"vs/workbench/services/editor/common/editorService\", \"vs/workbench/services/extensions/common/extensions\", \"vs/workbench/services/search/common/search\", \"vs/workbench/services/search/common/searchHelpers\", \"vs/workbench/services/untitled/common/untitledEditorService\", \"./searchIpc\"], function (require, exports, amd_1, arrays, errors_1, lifecycle_1, map_1, network_1, stopwatch_1, uri_1, pfs, ipc_1, ipc_cp_1, modelService_1, configuration_1, environment_1, files_1, extensions_1, instantiation_1, log_1, telemetry_1, editorService_1, extensions_2, search_1, searchHelpers_1, untitledEditorService_1, searchIpc_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let SearchService = class SearchService extends lifecycle_1.Disposable {\n        constructor(instantiationService, modelService, untitledEditorService, editorService, environmentService, telemetryService, logService, extensionService, fileService) {\n            super();\n            this.instantiationService = instantiationService;\n            this.modelService = modelService;\n            this.untitledEditorService = untitledEditorService;\n            this.editorService = editorService;\n            this.telemetryService = telemetryService;\n            this.logService = logService;\n            this.extensionService = extensionService;\n            this.fileService = fileService;\n            this.fileSearchProviders = new Map();\n            this.textSearchProviders = new Map();\n            this.diskSearch = this.instantiationService.createInstance(DiskSearch, !environmentService.isBuilt || environmentService.verbose, environmentService.debugSearch);\n        }\n        registerSearchResultProvider(scheme, type, provider) {\n            let list;\n            if (type === search_1.SearchProviderType.file) {\n                list = this.fileSearchProviders;\n            }\n            else if (type === search_1.SearchProviderType.text) {\n                list = this.textSearchProviders;\n            }\n            else {\n                throw new Error('Unknown SearchProviderType');\n            }\n            list.set(scheme, provider);\n            return lifecycle_1.toDisposable(() => {\n                list.delete(scheme);\n            });\n        }\n        textSearch(query, token, onProgress) {\n            // Get local results from dirty/untitled\n            const localResults = this.getLocalResults(query);\n            if (onProgress) {\n                arrays.coalesce(localResults.values()).forEach(onProgress);\n            }\n            const onProviderProgress = (progress) => {\n                if (search_1.isFileMatch(progress)) {\n                    // Match\n                    if (!localResults.has(progress.resource) && onProgress) { // don't override local results\n                        onProgress(progress);\n                    }\n                }\n                else if (onProgress) {\n                    // Progress\n                    onProgress(progress);\n                }\n                if (search_1.isProgressMessage(progress)) {\n                    this.logService.debug('SearchService#search', progress.message);\n                }\n            };\n            return this.doSearch(query, token, onProviderProgress);\n        }\n        fileSearch(query, token) {\n            return this.doSearch(query, token);\n        }\n        doSearch(query, token, onProgress) {\n            this.logService.trace('SearchService#search', JSON.stringify(query));\n            const schemesInQuery = this.getSchemesInQuery(query);\n            const providerActivations = [Promise.resolve(null)];\n            schemesInQuery.forEach(scheme => providerActivations.push(this.extensionService.activateByEvent(`onSearch:${scheme}`)));\n            providerActivations.push(this.extensionService.activateByEvent('onSearch:file'));\n            const providerPromise = Promise.all(providerActivations)\n                .then(() => this.extensionService.whenInstalledExtensionsRegistered())\n                .then(() => {\n                // Cancel faster if search was canceled while waiting for extensions\n                if (token && token.isCancellationRequested) {\n                    return Promise.reject(errors_1.canceled());\n                }\n                const progressCallback = (item) => {\n                    if (token && token.isCancellationRequested) {\n                        return;\n                    }\n                    if (onProgress) {\n                        onProgress(item);\n                    }\n                };\n                return this.searchWithProviders(query, progressCallback, token);\n            })\n                .then(completes => {\n                completes = arrays.coalesce(completes);\n                if (!completes.length) {\n                    return {\n                        limitHit: false,\n                        results: []\n                    };\n                }\n                return {\n                    limitHit: completes[0] && completes[0].limitHit,\n                    stats: completes[0].stats,\n                    results: arrays.flatten(completes.map((c) => c.results))\n                };\n            });\n            return new Promise((resolve, reject) => {\n                if (token) {\n                    token.onCancellationRequested(() => {\n                        reject(errors_1.canceled());\n                    });\n                }\n                providerPromise.then(resolve, reject);\n            });\n        }\n        getSchemesInQuery(query) {\n            const schemes = new Set();\n            if (query.folderQueries) {\n                query.folderQueries.forEach(fq => schemes.add(fq.folder.scheme));\n            }\n            if (query.extraFileResources) {\n                query.extraFileResources.forEach(extraFile => schemes.add(extraFile.scheme));\n            }\n            return schemes;\n        }\n        searchWithProviders(query, onProviderProgress, token) {\n            const e2eSW = stopwatch_1.StopWatch.create(false);\n            const diskSearchQueries = [];\n            const searchPs = [];\n            const fqs = this.groupFolderQueriesByScheme(query);\n            map_1.keys(fqs).forEach(scheme => {\n                const schemeFQs = fqs.get(scheme);\n                const provider = query.type === search_1.QueryType.File ?\n                    this.fileSearchProviders.get(scheme) :\n                    this.textSearchProviders.get(scheme);\n                if (!provider && scheme === 'file') {\n                    diskSearchQueries.push(...schemeFQs);\n                }\n                else if (!provider) {\n                    console.warn('No search provider registered for scheme: ' + scheme);\n                }\n                else {\n                    const oneSchemeQuery = Object.assign({}, query, {\n                        folderQueries: schemeFQs\n                    });\n                    searchPs.push(query.type === search_1.QueryType.File ?\n                        provider.fileSearch(oneSchemeQuery, token) :\n                        provider.textSearch(oneSchemeQuery, onProviderProgress, token));\n                }\n            });\n            const diskSearchExtraFileResources = query.extraFileResources && query.extraFileResources.filter(res => res.scheme === network_1.Schemas.file);\n            if (diskSearchQueries.length || diskSearchExtraFileResources) {\n                const diskSearchQuery = Object.assign({}, query, {\n                    folderQueries: diskSearchQueries\n                }, { extraFileResources: diskSearchExtraFileResources });\n                searchPs.push(diskSearchQuery.type === search_1.QueryType.File ?\n                    this.diskSearch.fileSearch(diskSearchQuery, token) :\n                    this.diskSearch.textSearch(diskSearchQuery, onProviderProgress, token));\n            }\n            return Promise.all(searchPs).then(completes => {\n                const endToEndTime = e2eSW.elapsed();\n                this.logService.trace(`SearchService#search: ${endToEndTime}ms`);\n                completes.forEach(complete => {\n                    this.sendTelemetry(query, endToEndTime, complete);\n                });\n                return completes;\n            }, err => {\n                const endToEndTime = e2eSW.elapsed();\n                this.logService.trace(`SearchService#search: ${endToEndTime}ms`);\n                const searchError = search_1.deserializeSearchError(err.message);\n                this.sendTelemetry(query, endToEndTime, undefined, searchError);\n                throw searchError;\n            });\n        }\n        groupFolderQueriesByScheme(query) {\n            const queries = new Map();\n            query.folderQueries.forEach(fq => {\n                const schemeFQs = queries.get(fq.folder.scheme) || [];\n                schemeFQs.push(fq);\n                queries.set(fq.folder.scheme, schemeFQs);\n            });\n            return queries;\n        }\n        sendTelemetry(query, endToEndTime, complete, err) {\n            const fileSchemeOnly = query.folderQueries.every(fq => fq.folder.scheme === 'file');\n            const otherSchemeOnly = query.folderQueries.every(fq => fq.folder.scheme !== 'file');\n            const scheme = fileSchemeOnly ? 'file' :\n                otherSchemeOnly ? 'other' :\n                    'mixed';\n            if (query.type === search_1.QueryType.File && complete && complete.stats) {\n                const fileSearchStats = complete.stats;\n                if (fileSearchStats.fromCache) {\n                    const cacheStats = fileSearchStats.detailStats;\n                    /* __GDPR__\n                        \"cachedSearchComplete\" : {\n                            \"reason\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\"  },\n                            \"resultCount\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true  },\n                            \"workspaceFolderCount\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true  },\n                            \"type\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n                            \"endToEndTime\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                            \"sortingTime\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                            \"cacheWasResolved\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n                            \"cacheLookupTime\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                            \"cacheFilterTime\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                            \"cacheEntryCount\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                            \"scheme\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" }\n                        }\n                     */\n                    this.telemetryService.publicLog('cachedSearchComplete', {\n                        reason: query._reason,\n                        resultCount: fileSearchStats.resultCount,\n                        workspaceFolderCount: query.folderQueries.length,\n                        type: fileSearchStats.type,\n                        endToEndTime: endToEndTime,\n                        sortingTime: fileSearchStats.sortingTime,\n                        cacheWasResolved: cacheStats.cacheWasResolved,\n                        cacheLookupTime: cacheStats.cacheLookupTime,\n                        cacheFilterTime: cacheStats.cacheFilterTime,\n                        cacheEntryCount: cacheStats.cacheEntryCount,\n                        scheme\n                    });\n                }\n                else {\n                    const searchEngineStats = fileSearchStats.detailStats;\n                    /* __GDPR__\n                        \"searchComplete\" : {\n                            \"reason\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n                            \"resultCount\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                            \"workspaceFolderCount\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                            \"type\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n                            \"endToEndTime\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                            \"sortingTime\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                            \"fileWalkTime\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                            \"directoriesWalked\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                            \"filesWalked\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                            \"cmdTime\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                            \"cmdResultCount\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                            \"scheme\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" }\n                        }\n                     */\n                    this.telemetryService.publicLog('searchComplete', {\n                        reason: query._reason,\n                        resultCount: fileSearchStats.resultCount,\n                        workspaceFolderCount: query.folderQueries.length,\n                        type: fileSearchStats.type,\n                        endToEndTime: endToEndTime,\n                        sortingTime: fileSearchStats.sortingTime,\n                        fileWalkTime: searchEngineStats.fileWalkTime,\n                        directoriesWalked: searchEngineStats.directoriesWalked,\n                        filesWalked: searchEngineStats.filesWalked,\n                        cmdTime: searchEngineStats.cmdTime,\n                        cmdResultCount: searchEngineStats.cmdResultCount,\n                        scheme\n                    });\n                }\n            }\n            else if (query.type === search_1.QueryType.Text) {\n                let errorType;\n                if (err) {\n                    errorType = err.code === search_1.SearchErrorCode.regexParseError ? 'regex' :\n                        err.code === search_1.SearchErrorCode.unknownEncoding ? 'encoding' :\n                            err.code === search_1.SearchErrorCode.globParseError ? 'glob' :\n                                err.code === search_1.SearchErrorCode.invalidLiteral ? 'literal' :\n                                    err.code === search_1.SearchErrorCode.other ? 'other' :\n                                        'unknown';\n                }\n                /* __GDPR__\n                    \"textSearchComplete\" : {\n                        \"reason\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n                        \"workspaceFolderCount\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                        \"endToEndTime\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                        \"scheme\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n                        \"error\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n                        \"useRipgrep\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n                        \"usePCRE2\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" }\n                    }\n                 */\n                this.telemetryService.publicLog('textSearchComplete', {\n                    reason: query._reason,\n                    workspaceFolderCount: query.folderQueries.length,\n                    endToEndTime: endToEndTime,\n                    scheme,\n                    error: errorType,\n                    usePCRE2: !!query.usePCRE2\n                });\n            }\n        }\n        getLocalResults(query) {\n            const localResults = new map_1.ResourceMap();\n            if (query.type === search_1.QueryType.Text) {\n                const models = this.modelService.getModels();\n                models.forEach((model) => {\n                    const resource = model.uri;\n                    if (!resource) {\n                        return;\n                    }\n                    if (!this.editorService.isOpen({ resource })) {\n                        return;\n                    }\n                    // Support untitled files\n                    if (resource.scheme === network_1.Schemas.untitled) {\n                        if (!this.untitledEditorService.exists(resource)) {\n                            return;\n                        }\n                    }\n                    // Block walkthrough, webview, etc.\n                    else if (!this.fileService.canHandleResource(resource)) {\n                        return;\n                    }\n                    if (!this.matches(resource, query)) {\n                        return; // respect user filters\n                    }\n                    // Use editor API to find matches\n                    const matches = model.findMatches(query.contentPattern.pattern, false, !!query.contentPattern.isRegExp, !!query.contentPattern.isCaseSensitive, query.contentPattern.isWordMatch ? query.contentPattern.wordSeparators : null, false, query.maxResults);\n                    if (matches.length) {\n                        const fileMatch = new search_1.FileMatch(resource);\n                        localResults.set(resource, fileMatch);\n                        const textSearchResults = searchHelpers_1.editorMatchesToTextSearchResults(matches, model, query.previewOptions);\n                        fileMatch.results = searchHelpers_1.addContextToEditorMatches(textSearchResults, model, query);\n                    }\n                    else {\n                        localResults.set(resource, null);\n                    }\n                });\n            }\n            return localResults;\n        }\n        matches(resource, query) {\n            return search_1.pathIncludedInQuery(query, resource.fsPath);\n        }\n        clearCache(cacheKey) {\n            const clearPs = [\n                this.diskSearch,\n                ...map_1.values(this.fileSearchProviders)\n            ].map(provider => provider && provider.clearCache(cacheKey));\n            return Promise.all(clearPs)\n                .then(() => { });\n        }\n    };\n    SearchService = __decorate([\n        __param(0, instantiation_1.IInstantiationService),\n        __param(1, modelService_1.IModelService),\n        __param(2, untitledEditorService_1.IUntitledEditorService),\n        __param(3, editorService_1.IEditorService),\n        __param(4, environment_1.IEnvironmentService),\n        __param(5, telemetry_1.ITelemetryService),\n        __param(6, log_1.ILogService),\n        __param(7, extensions_2.IExtensionService),\n        __param(8, files_1.IFileService)\n    ], SearchService);\n    exports.SearchService = SearchService;\n    let DiskSearch = class DiskSearch {\n        constructor(verboseLogging, searchDebug, logService, configService) {\n            this.logService = logService;\n            this.configService = configService;\n            this.toDispose = [];\n            const timeout = this.configService.getValue().search.maintainFileSearchCache ?\n                Number.MAX_VALUE :\n                60 * 60 * 1000;\n            const opts = {\n                serverName: 'Search',\n                timeout,\n                args: ['--type=searchService'],\n                // See https://github.com/Microsoft/vscode/issues/27665\n                // Pass in fresh execArgv to the forked process such that it doesn't inherit them from `process.execArgv`.\n                // e.g. Launching the extension host process with `--inspect-brk=xxx` and then forking a process from the extension host\n                // results in the forked process inheriting `--inspect-brk=xxx`.\n                freshExecArgv: true,\n                env: {\n                    AMD_ENTRYPOINT: 'vs/workbench/services/search/node/searchApp',\n                    PIPE_LOGGING: 'true',\n                    VERBOSE_LOGGING: verboseLogging\n                },\n                useQueue: true\n            };\n            if (searchDebug) {\n                if (searchDebug.break && searchDebug.port) {\n                    opts.debugBrk = searchDebug.port;\n                }\n                else if (!searchDebug.break && searchDebug.port) {\n                    opts.debug = searchDebug.port;\n                }\n            }\n            const connect = () => {\n                const client = new ipc_cp_1.Client(amd_1.getPathFromAmdModule(require, 'bootstrap-fork'), opts);\n                client.onDidProcessExit(() => {\n                    this.toDispose = lifecycle_1.dispose(this.toDispose);\n                    retry.run();\n                }, null, this.toDispose);\n                this.toDispose.push(client);\n                const channel = ipc_1.getNextTickChannel(client.getChannel('search'));\n                this.raw = new searchIpc_1.SearchChannelClient(channel);\n                return this.raw.clearCache('test-connectivity');\n            };\n            const retry = require('vs/../../../../packages/vscode/src/workbench').workbench.retry.register('Searcher', connect);\n            retry.run();\n        }\n        textSearch(query, onProgress, token) {\n            const folderQueries = query.folderQueries || [];\n            return Promise.all(folderQueries.map(q => q.folder.scheme === network_1.Schemas.file && pfs.exists(q.folder.fsPath)))\n                .then(exists => {\n                if (token && token.isCancellationRequested) {\n                    throw errors_1.canceled();\n                }\n                query.folderQueries = folderQueries.filter((q, index) => exists[index]);\n                const event = this.raw.textSearch(query);\n                return DiskSearch.collectResultsFromEvent(event, onProgress, token);\n            });\n        }\n        fileSearch(query, token) {\n            const folderQueries = query.folderQueries || [];\n            return Promise.all(folderQueries.map(q => q.folder.scheme === network_1.Schemas.file && pfs.exists(q.folder.fsPath)))\n                .then(exists => {\n                if (token && token.isCancellationRequested) {\n                    throw errors_1.canceled();\n                }\n                query.folderQueries = folderQueries.filter((q, index) => exists[index]);\n                let event;\n                event = this.raw.fileSearch(query);\n                const onProgress = (p) => {\n                    if (p.message) {\n                        // Should only be for logs\n                        this.logService.debug('SearchService#search', p.message);\n                    }\n                };\n                return DiskSearch.collectResultsFromEvent(event, onProgress, token);\n            });\n        }\n        /**\n         * Public for test\n         */\n        static collectResultsFromEvent(event, onProgress, token) {\n            let result = [];\n            let listener;\n            return new Promise((c, e) => {\n                if (token) {\n                    token.onCancellationRequested(() => {\n                        if (listener) {\n                            listener.dispose();\n                        }\n                        e(errors_1.canceled());\n                    });\n                }\n                listener = event(ev => {\n                    if (search_1.isSerializedSearchComplete(ev)) {\n                        if (search_1.isSerializedSearchSuccess(ev)) {\n                            c({\n                                limitHit: ev.limitHit,\n                                results: result,\n                                stats: ev.stats\n                            });\n                        }\n                        else {\n                            e(ev.error);\n                        }\n                        listener.dispose();\n                    }\n                    else {\n                        // Matches\n                        if (Array.isArray(ev)) {\n                            const fileMatches = ev.map(d => this.createFileMatch(d));\n                            result = result.concat(fileMatches);\n                            if (onProgress) {\n                                fileMatches.forEach(onProgress);\n                            }\n                        }\n                        // Match\n                        else if (ev.path) {\n                            const fileMatch = this.createFileMatch(ev);\n                            result.push(fileMatch);\n                            if (onProgress) {\n                                onProgress(fileMatch);\n                            }\n                        }\n                        // Progress\n                        else if (onProgress) {\n                            onProgress(ev);\n                        }\n                    }\n                });\n            });\n        }\n        static createFileMatch(data) {\n            const fileMatch = new search_1.FileMatch(uri_1.URI.file(data.path));\n            if (data.results) {\n                // const matches = data.results.filter(resultIsMatch);\n                fileMatch.results.push(...data.results);\n            }\n            return fileMatch;\n        }\n        clearCache(cacheKey) {\n            return this.raw.clearCache(cacheKey);\n        }\n    };\n    DiskSearch = __decorate([\n        __param(2, log_1.ILogService),\n        __param(3, configuration_1.IConfigurationService)\n    ], DiskSearch);\n    exports.DiskSearch = DiskSearch;\n    extensions_1.registerSingleton(search_1.ISearchService, SearchService, true);\n});\n",null]}