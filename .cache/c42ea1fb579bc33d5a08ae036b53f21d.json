{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/storage/node/storageIpc.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/storage/node/storageIpc.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/event\", \"vs/base/common/map\", \"vs/base/common/lifecycle\", \"vs/base/common/errors\", \"vs/base/common/uuid\", \"vs/platform/telemetry/node/workbenchCommonProperties\"], function (require, exports, event_1, map_1, lifecycle_1, errors_1, uuid_1, workbenchCommonProperties_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class GlobalStorageDatabaseChannel extends lifecycle_1.Disposable {\n        constructor(logService, storageMainService) {\n            super();\n            this.logService = logService;\n            this.storageMainService = storageMainService;\n            this._onDidChangeItems = this._register(new event_1.Emitter());\n            this.whenReady = this.init();\n        }\n        get onDidChangeItems() { return this._onDidChangeItems.event; }\n        init() {\n            return this.storageMainService.initialize().then(undefined, error => {\n                errors_1.onUnexpectedError(error);\n                this.logService.error(error);\n            }).then(() => {\n                // Apply global telemetry values as part of the initialization\n                // These are global across all windows and thereby should be\n                // written from the main process once.\n                this.initTelemetry();\n                // Setup storage change listeners\n                this.registerListeners();\n            });\n        }\n        initTelemetry() {\n            const instanceId = this.storageMainService.get(workbenchCommonProperties_1.instanceStorageKey, undefined);\n            if (instanceId === undefined) {\n                this.storageMainService.store(workbenchCommonProperties_1.instanceStorageKey, uuid_1.generateUuid());\n            }\n            const firstSessionDate = this.storageMainService.get(workbenchCommonProperties_1.firstSessionDateStorageKey, undefined);\n            if (firstSessionDate === undefined) {\n                this.storageMainService.store(workbenchCommonProperties_1.firstSessionDateStorageKey, new Date().toUTCString());\n            }\n            const lastSessionDate = this.storageMainService.get(workbenchCommonProperties_1.currentSessionDateStorageKey, undefined); // previous session date was the \"current\" one at that time\n            const currentSessionDate = new Date().toUTCString(); // current session date is \"now\"\n            this.storageMainService.store(workbenchCommonProperties_1.lastSessionDateStorageKey, typeof lastSessionDate === 'undefined' ? null : lastSessionDate);\n            this.storageMainService.store(workbenchCommonProperties_1.currentSessionDateStorageKey, currentSessionDate);\n        }\n        registerListeners() {\n            // Listen for changes in global storage to send to listeners\n            // that are listening. Use a debouncer to reduce IPC traffic.\n            this._register(event_1.Event.debounce(this.storageMainService.onDidChangeStorage, (prev, cur) => {\n                if (!prev) {\n                    prev = [cur];\n                }\n                else {\n                    prev.push(cur);\n                }\n                return prev;\n            }, GlobalStorageDatabaseChannel.STORAGE_CHANGE_DEBOUNCE_TIME)(events => {\n                if (events.length) {\n                    this._onDidChangeItems.fire(this.serializeEvents(events));\n                }\n            }));\n        }\n        serializeEvents(events) {\n            const items = new Map();\n            events.forEach(event => items.set(event.key, this.storageMainService.get(event.key)));\n            return { items: map_1.mapToSerializable(items) };\n        }\n        listen(_, event) {\n            switch (event) {\n                case 'onDidChangeItems': return this.onDidChangeItems;\n            }\n            throw new Error(`Event not found: ${event}`);\n        }\n        call(_, command, arg) {\n            switch (command) {\n                case 'getItems': {\n                    return this.whenReady.then(() => map_1.mapToSerializable(this.storageMainService.items));\n                }\n                case 'updateItems': {\n                    return this.whenReady.then(() => {\n                        const items = arg;\n                        if (items.insert) {\n                            for (const [key, value] of items.insert) {\n                                this.storageMainService.store(key, value);\n                            }\n                        }\n                        if (items.delete) {\n                            items.delete.forEach(key => this.storageMainService.remove(key));\n                        }\n                    });\n                }\n                case 'checkIntegrity': {\n                    return this.whenReady.then(() => this.storageMainService.checkIntegrity(arg));\n                }\n            }\n            throw new Error(`Call not found: ${command}`);\n        }\n    }\n    GlobalStorageDatabaseChannel.STORAGE_CHANGE_DEBOUNCE_TIME = 100;\n    exports.GlobalStorageDatabaseChannel = GlobalStorageDatabaseChannel;\n    class GlobalStorageDatabaseChannelClient extends lifecycle_1.Disposable {\n        constructor(channel) {\n            super();\n            this.channel = channel;\n            this._onDidChangeItemsExternal = this._register(new event_1.Emitter());\n            this.registerListeners();\n        }\n        get onDidChangeItemsExternal() { return this._onDidChangeItemsExternal.event; }\n        registerListeners() {\n            this.onDidChangeItemsOnMainListener = this.channel.listen('onDidChangeItems')((e) => this.onDidChangeItemsOnMain(e));\n        }\n        onDidChangeItemsOnMain(e) {\n            if (Array.isArray(e.items)) {\n                this._onDidChangeItemsExternal.fire({ items: map_1.serializableToMap(e.items) });\n            }\n        }\n        getItems() {\n            return this.channel.call('getItems').then((data) => map_1.serializableToMap(data));\n        }\n        updateItems(request) {\n            let updateCount = 0;\n            const serializableRequest = Object.create(null);\n            if (request.insert) {\n                serializableRequest.insert = map_1.mapToSerializable(request.insert);\n                updateCount += request.insert.size;\n            }\n            if (request.delete) {\n                serializableRequest.delete = map_1.values(request.delete);\n                updateCount += request.delete.size;\n            }\n            if (updateCount === 0) {\n                return Promise.resolve(); // prevent work if not needed\n            }\n            return this.channel.call('updateItems', serializableRequest);\n        }\n        checkIntegrity(full) {\n            return this.channel.call('checkIntegrity', full);\n        }\n        close() {\n            // when we are about to close, we start to ignore main-side changes since we close anyway\n            this.onDidChangeItemsOnMainListener = lifecycle_1.dispose(this.onDidChangeItemsOnMainListener);\n            return Promise.resolve(); // global storage is closed on the main side\n        }\n        dispose() {\n            super.dispose();\n            this.onDidChangeItemsOnMainListener = lifecycle_1.dispose(this.onDidChangeItemsOnMainListener);\n        }\n    }\n    exports.GlobalStorageDatabaseChannelClient = GlobalStorageDatabaseChannelClient;\n});\n",null]}