{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/viewModel/characterHardWrappingLineMapper.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewModel/characterHardWrappingLineMapper.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar strings = require(\"vs/base/common/strings\");\nvar editorOptions_1 = require(\"vs/editor/common/config/editorOptions\");\nvar characterClassifier_1 = require(\"vs/editor/common/core/characterClassifier\");\nvar uint_1 = require(\"vs/editor/common/core/uint\");\nvar prefixSumComputer_1 = require(\"vs/editor/common/viewModel/prefixSumComputer\");\nvar splitLinesCollection_1 = require(\"vs/editor/common/viewModel/splitLinesCollection\");\nvar CharacterClass;\n(function (CharacterClass) {\n    CharacterClass[CharacterClass[\"NONE\"] = 0] = \"NONE\";\n    CharacterClass[CharacterClass[\"BREAK_BEFORE\"] = 1] = \"BREAK_BEFORE\";\n    CharacterClass[CharacterClass[\"BREAK_AFTER\"] = 2] = \"BREAK_AFTER\";\n    CharacterClass[CharacterClass[\"BREAK_OBTRUSIVE\"] = 3] = \"BREAK_OBTRUSIVE\";\n    CharacterClass[CharacterClass[\"BREAK_IDEOGRAPHIC\"] = 4] = \"BREAK_IDEOGRAPHIC\"; // for Han and Kana.\n})(CharacterClass || (CharacterClass = {}));\nvar WrappingCharacterClassifier = /** @class */ (function (_super) {\n    tslib_1.__extends(WrappingCharacterClassifier, _super);\n    function WrappingCharacterClassifier(BREAK_BEFORE, BREAK_AFTER, BREAK_OBTRUSIVE) {\n        var _this = _super.call(this, CharacterClass.NONE) || this;\n        for (var i = 0; i < BREAK_BEFORE.length; i++) {\n            _this.set(BREAK_BEFORE.charCodeAt(i), CharacterClass.BREAK_BEFORE);\n        }\n        for (var i = 0; i < BREAK_AFTER.length; i++) {\n            _this.set(BREAK_AFTER.charCodeAt(i), CharacterClass.BREAK_AFTER);\n        }\n        for (var i = 0; i < BREAK_OBTRUSIVE.length; i++) {\n            _this.set(BREAK_OBTRUSIVE.charCodeAt(i), CharacterClass.BREAK_OBTRUSIVE);\n        }\n        return _this;\n    }\n    WrappingCharacterClassifier.prototype.get = function (charCode) {\n        // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n        // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n        // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n        // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n        if ((charCode >= 0x3040 && charCode <= 0x30FF)\n            || (charCode >= 0x3400 && charCode <= 0x4DBF)\n            || (charCode >= 0x4E00 && charCode <= 0x9FFF)) {\n            return CharacterClass.BREAK_IDEOGRAPHIC;\n        }\n        return _super.prototype.get.call(this, charCode);\n    };\n    return WrappingCharacterClassifier;\n}(characterClassifier_1.CharacterClassifier));\nvar CharacterHardWrappingLineMapperFactory = /** @class */ (function () {\n    function CharacterHardWrappingLineMapperFactory(breakBeforeChars, breakAfterChars, breakObtrusiveChars) {\n        this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars, breakObtrusiveChars);\n    }\n    // TODO@Alex -> duplicated in lineCommentCommand\n    CharacterHardWrappingLineMapperFactory.nextVisibleColumn = function (currentVisibleColumn, tabSize, isTab, columnSize) {\n        currentVisibleColumn = +currentVisibleColumn; //@perf\n        tabSize = +tabSize; //@perf\n        columnSize = +columnSize; //@perf\n        if (isTab) {\n            return currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));\n        }\n        return currentVisibleColumn + columnSize;\n    };\n    CharacterHardWrappingLineMapperFactory.prototype.createLineMapping = function (lineText, tabSize, breakingColumn, columnsForFullWidthChar, hardWrappingIndent) {\n        if (breakingColumn === -1) {\n            return null;\n        }\n        tabSize = +tabSize; //@perf\n        breakingColumn = +breakingColumn; //@perf\n        columnsForFullWidthChar = +columnsForFullWidthChar; //@perf\n        hardWrappingIndent = +hardWrappingIndent; //@perf\n        var wrappedTextIndentVisibleColumn = 0;\n        var wrappedTextIndent = '';\n        var firstNonWhitespaceIndex = -1;\n        if (hardWrappingIndent !== editorOptions_1.WrappingIndent.None) {\n            firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n            if (firstNonWhitespaceIndex !== -1) {\n                // Track existing indent\n                wrappedTextIndent = lineText.substring(0, firstNonWhitespaceIndex);\n                for (var i = 0; i < firstNonWhitespaceIndex; i++) {\n                    wrappedTextIndentVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(wrappedTextIndentVisibleColumn, tabSize, lineText.charCodeAt(i) === charCode_1.CharCode.Tab, 1);\n                }\n                // Increase indent of continuation lines, if desired\n                var numberOfAdditionalTabs = 0;\n                if (hardWrappingIndent === editorOptions_1.WrappingIndent.Indent) {\n                    numberOfAdditionalTabs = 1;\n                }\n                else if (hardWrappingIndent === editorOptions_1.WrappingIndent.DeepIndent) {\n                    numberOfAdditionalTabs = 2;\n                }\n                for (var i = 0; i < numberOfAdditionalTabs; i++) {\n                    wrappedTextIndent += '\\t';\n                    wrappedTextIndentVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(wrappedTextIndentVisibleColumn, tabSize, true, 1);\n                }\n                // Force sticking to beginning of line if no character would fit except for the indentation\n                if (wrappedTextIndentVisibleColumn + columnsForFullWidthChar > breakingColumn) {\n                    wrappedTextIndent = '';\n                    wrappedTextIndentVisibleColumn = 0;\n                }\n            }\n        }\n        var classifier = this.classifier;\n        var lastBreakingOffset = 0; // Last 0-based offset in the lineText at which a break happened\n        var breakingLengths = []; // The length of each broken-up line text\n        var breakingLengthsIndex = 0; // The count of breaks already done\n        var visibleColumn = 0; // Visible column since the beginning of the current line\n        var niceBreakOffset = -1; // Last index of a character that indicates a break should happen before it (more desirable)\n        var niceBreakVisibleColumn = 0; // visible column if a break were to be later introduced before `niceBreakOffset`\n        var obtrusiveBreakOffset = -1; // Last index of a character that indicates a break should happen before it (less desirable)\n        var obtrusiveBreakVisibleColumn = 0; // visible column if a break were to be later introduced before `obtrusiveBreakOffset`\n        var len = lineText.length;\n        for (var i = 0; i < len; i++) {\n            // At this point, there is a certainty that the character before `i` fits on the current line,\n            // but the character at `i` might not fit\n            var charCode = lineText.charCodeAt(i);\n            var charCodeIsTab = (charCode === charCode_1.CharCode.Tab);\n            var charCodeClass = classifier.get(charCode);\n            if (charCodeClass === CharacterClass.BREAK_BEFORE) {\n                // This is a character that indicates that a break should happen before it\n                // Since we are certain the character before `i` fits, there's no extra checking needed,\n                // just mark it as a nice breaking opportunity\n                niceBreakOffset = i;\n                niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n            }\n            // CJK breaking : before break\n            if (charCodeClass === CharacterClass.BREAK_IDEOGRAPHIC && i > 0) {\n                var prevCode = lineText.charCodeAt(i - 1);\n                var prevClass = classifier.get(prevCode);\n                if (prevClass !== CharacterClass.BREAK_BEFORE) { // Kinsoku Shori: Don't break after a leading character, like an open bracket\n                    niceBreakOffset = i;\n                    niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n                }\n            }\n            var charColumnSize = 1;\n            if (strings.isFullWidthCharacter(charCode)) {\n                charColumnSize = columnsForFullWidthChar;\n            }\n            // Advance visibleColumn with character at `i`\n            visibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(visibleColumn, tabSize, charCodeIsTab, charColumnSize);\n            if (visibleColumn > breakingColumn && i !== 0) {\n                // We need to break at least before character at `i`:\n                //  - break before niceBreakLastOffset if it exists (and re-establish a correct visibleColumn by using niceBreakVisibleColumn + charAt(i))\n                //  - otherwise, break before obtrusiveBreakLastOffset if it exists (and re-establish a correct visibleColumn by using obtrusiveBreakVisibleColumn + charAt(i))\n                //  - otherwise, break before i (and re-establish a correct visibleColumn by charAt(i))\n                var breakBeforeOffset = void 0;\n                var restoreVisibleColumnFrom = void 0;\n                if (niceBreakOffset !== -1 && niceBreakVisibleColumn <= breakingColumn) {\n                    // We will break before `niceBreakLastOffset`\n                    breakBeforeOffset = niceBreakOffset;\n                    restoreVisibleColumnFrom = niceBreakVisibleColumn;\n                }\n                else if (obtrusiveBreakOffset !== -1 && obtrusiveBreakVisibleColumn <= breakingColumn) {\n                    // We will break before `obtrusiveBreakLastOffset`\n                    breakBeforeOffset = obtrusiveBreakOffset;\n                    restoreVisibleColumnFrom = obtrusiveBreakVisibleColumn;\n                }\n                else {\n                    // We will break before `i`\n                    breakBeforeOffset = i;\n                    restoreVisibleColumnFrom = wrappedTextIndentVisibleColumn;\n                }\n                // Break before character at `breakBeforeOffset`\n                breakingLengths[breakingLengthsIndex++] = breakBeforeOffset - lastBreakingOffset;\n                lastBreakingOffset = breakBeforeOffset;\n                // Re-establish visibleColumn by taking character at `i` into account\n                visibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(restoreVisibleColumnFrom, tabSize, charCodeIsTab, charColumnSize);\n                // Reset markers\n                niceBreakOffset = -1;\n                niceBreakVisibleColumn = 0;\n                obtrusiveBreakOffset = -1;\n                obtrusiveBreakVisibleColumn = 0;\n            }\n            // At this point, there is a certainty that the character at `i` fits on the current line\n            if (niceBreakOffset !== -1) {\n                // Advance niceBreakVisibleColumn\n                niceBreakVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(niceBreakVisibleColumn, tabSize, charCodeIsTab, charColumnSize);\n            }\n            if (obtrusiveBreakOffset !== -1) {\n                // Advance obtrusiveBreakVisibleColumn\n                obtrusiveBreakVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(obtrusiveBreakVisibleColumn, tabSize, charCodeIsTab, charColumnSize);\n            }\n            if (charCodeClass === CharacterClass.BREAK_AFTER && (hardWrappingIndent === editorOptions_1.WrappingIndent.None || i >= firstNonWhitespaceIndex)) {\n                // This is a character that indicates that a break should happen after it\n                niceBreakOffset = i + 1;\n                niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n            }\n            // CJK breaking : after break\n            if (charCodeClass === CharacterClass.BREAK_IDEOGRAPHIC && i < len - 1) {\n                var nextCode = lineText.charCodeAt(i + 1);\n                var nextClass = classifier.get(nextCode);\n                if (nextClass !== CharacterClass.BREAK_AFTER) { // Kinsoku Shori: Don't break before a trailing character, like a period\n                    niceBreakOffset = i + 1;\n                    niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n                }\n            }\n            if (charCodeClass === CharacterClass.BREAK_OBTRUSIVE) {\n                // This is an obtrusive character that indicates that a break should happen after it\n                obtrusiveBreakOffset = i + 1;\n                obtrusiveBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n            }\n        }\n        if (breakingLengthsIndex === 0) {\n            return null;\n        }\n        // Add last segment\n        breakingLengths[breakingLengthsIndex++] = len - lastBreakingOffset;\n        return new CharacterHardWrappingLineMapping(new prefixSumComputer_1.PrefixSumComputer(uint_1.toUint32Array(breakingLengths)), wrappedTextIndent);\n    };\n    return CharacterHardWrappingLineMapperFactory;\n}());\nexports.CharacterHardWrappingLineMapperFactory = CharacterHardWrappingLineMapperFactory;\nvar CharacterHardWrappingLineMapping = /** @class */ (function () {\n    function CharacterHardWrappingLineMapping(prefixSums, wrappedLinesIndent) {\n        this._prefixSums = prefixSums;\n        this._wrappedLinesIndent = wrappedLinesIndent;\n    }\n    CharacterHardWrappingLineMapping.prototype.getOutputLineCount = function () {\n        return this._prefixSums.getCount();\n    };\n    CharacterHardWrappingLineMapping.prototype.getWrappedLinesIndent = function () {\n        return this._wrappedLinesIndent;\n    };\n    CharacterHardWrappingLineMapping.prototype.getInputOffsetOfOutputPosition = function (outputLineIndex, outputOffset) {\n        if (outputLineIndex === 0) {\n            return outputOffset;\n        }\n        else {\n            return this._prefixSums.getAccumulatedValue(outputLineIndex - 1) + outputOffset;\n        }\n    };\n    CharacterHardWrappingLineMapping.prototype.getOutputPositionOfInputOffset = function (inputOffset) {\n        var r = this._prefixSums.getIndexOf(inputOffset);\n        return new splitLinesCollection_1.OutputPosition(r.index, r.remainder);\n    };\n    return CharacterHardWrappingLineMapping;\n}());\nexports.CharacterHardWrappingLineMapping = CharacterHardWrappingLineMapping;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewModel/characterHardWrappingLineMapper.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/viewModel/characterHardWrappingLineMapper.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as strings from 'vs/base/common/strings';\nimport { WrappingIndent } from 'vs/editor/common/config/editorOptions';\nimport { CharacterClassifier } from 'vs/editor/common/core/characterClassifier';\nimport { toUint32Array } from 'vs/editor/common/core/uint';\nimport { PrefixSumComputer } from 'vs/editor/common/viewModel/prefixSumComputer';\nimport { ILineMapperFactory, ILineMapping, OutputPosition } from 'vs/editor/common/viewModel/splitLinesCollection';\n\nconst enum CharacterClass {\n\tNONE = 0,\n\tBREAK_BEFORE = 1,\n\tBREAK_AFTER = 2,\n\tBREAK_OBTRUSIVE = 3,\n\tBREAK_IDEOGRAPHIC = 4 // for Han and Kana.\n}\n\nclass WrappingCharacterClassifier extends CharacterClassifier<CharacterClass> {\n\n\tconstructor(BREAK_BEFORE: string, BREAK_AFTER: string, BREAK_OBTRUSIVE: string) {\n\t\tsuper(CharacterClass.NONE);\n\n\t\tfor (let i = 0; i < BREAK_BEFORE.length; i++) {\n\t\t\tthis.set(BREAK_BEFORE.charCodeAt(i), CharacterClass.BREAK_BEFORE);\n\t\t}\n\n\t\tfor (let i = 0; i < BREAK_AFTER.length; i++) {\n\t\t\tthis.set(BREAK_AFTER.charCodeAt(i), CharacterClass.BREAK_AFTER);\n\t\t}\n\n\t\tfor (let i = 0; i < BREAK_OBTRUSIVE.length; i++) {\n\t\t\tthis.set(BREAK_OBTRUSIVE.charCodeAt(i), CharacterClass.BREAK_OBTRUSIVE);\n\t\t}\n\t}\n\n\tpublic get(charCode: number): CharacterClass {\n\t\t// Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n\t\t// 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n\t\t// 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n\t\t// 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n\t\tif (\n\t\t\t(charCode >= 0x3040 && charCode <= 0x30FF)\n\t\t\t|| (charCode >= 0x3400 && charCode <= 0x4DBF)\n\t\t\t|| (charCode >= 0x4E00 && charCode <= 0x9FFF)\n\t\t) {\n\t\t\treturn CharacterClass.BREAK_IDEOGRAPHIC;\n\t\t}\n\n\t\treturn super.get(charCode);\n\t}\n}\n\nexport class CharacterHardWrappingLineMapperFactory implements ILineMapperFactory {\n\n\tprivate readonly classifier: WrappingCharacterClassifier;\n\n\tconstructor(breakBeforeChars: string, breakAfterChars: string, breakObtrusiveChars: string) {\n\t\tthis.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars, breakObtrusiveChars);\n\t}\n\n\t// TODO@Alex -> duplicated in lineCommentCommand\n\tprivate static nextVisibleColumn(currentVisibleColumn: number, tabSize: number, isTab: boolean, columnSize: number): number {\n\t\tcurrentVisibleColumn = +currentVisibleColumn; //@perf\n\t\ttabSize = +tabSize; //@perf\n\t\tcolumnSize = +columnSize; //@perf\n\n\t\tif (isTab) {\n\t\t\treturn currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));\n\t\t}\n\t\treturn currentVisibleColumn + columnSize;\n\t}\n\n\tpublic createLineMapping(lineText: string, tabSize: number, breakingColumn: number, columnsForFullWidthChar: number, hardWrappingIndent: WrappingIndent): ILineMapping | null {\n\t\tif (breakingColumn === -1) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttabSize = +tabSize; //@perf\n\t\tbreakingColumn = +breakingColumn; //@perf\n\t\tcolumnsForFullWidthChar = +columnsForFullWidthChar; //@perf\n\t\thardWrappingIndent = +hardWrappingIndent; //@perf\n\n\t\tlet wrappedTextIndentVisibleColumn = 0;\n\t\tlet wrappedTextIndent = '';\n\n\t\tlet firstNonWhitespaceIndex = -1;\n\t\tif (hardWrappingIndent !== WrappingIndent.None) {\n\t\t\tfirstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n\t\t\tif (firstNonWhitespaceIndex !== -1) {\n\t\t\t\t// Track existing indent\n\t\t\t\twrappedTextIndent = lineText.substring(0, firstNonWhitespaceIndex);\n\t\t\t\tfor (let i = 0; i < firstNonWhitespaceIndex; i++) {\n\t\t\t\t\twrappedTextIndentVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(wrappedTextIndentVisibleColumn, tabSize, lineText.charCodeAt(i) === CharCode.Tab, 1);\n\t\t\t\t}\n\n\t\t\t\t// Increase indent of continuation lines, if desired\n\t\t\t\tlet numberOfAdditionalTabs = 0;\n\t\t\t\tif (hardWrappingIndent === WrappingIndent.Indent) {\n\t\t\t\t\tnumberOfAdditionalTabs = 1;\n\t\t\t\t} else if (hardWrappingIndent === WrappingIndent.DeepIndent) {\n\t\t\t\t\tnumberOfAdditionalTabs = 2;\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < numberOfAdditionalTabs; i++) {\n\t\t\t\t\twrappedTextIndent += '\\t';\n\t\t\t\t\twrappedTextIndentVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(wrappedTextIndentVisibleColumn, tabSize, true, 1);\n\t\t\t\t}\n\n\t\t\t\t// Force sticking to beginning of line if no character would fit except for the indentation\n\t\t\t\tif (wrappedTextIndentVisibleColumn + columnsForFullWidthChar > breakingColumn) {\n\t\t\t\t\twrappedTextIndent = '';\n\t\t\t\t\twrappedTextIndentVisibleColumn = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet classifier = this.classifier;\n\t\tlet lastBreakingOffset = 0; // Last 0-based offset in the lineText at which a break happened\n\t\tlet breakingLengths: number[] = []; // The length of each broken-up line text\n\t\tlet breakingLengthsIndex: number = 0; // The count of breaks already done\n\t\tlet visibleColumn = 0; // Visible column since the beginning of the current line\n\t\tlet niceBreakOffset = -1; // Last index of a character that indicates a break should happen before it (more desirable)\n\t\tlet niceBreakVisibleColumn = 0; // visible column if a break were to be later introduced before `niceBreakOffset`\n\t\tlet obtrusiveBreakOffset = -1; // Last index of a character that indicates a break should happen before it (less desirable)\n\t\tlet obtrusiveBreakVisibleColumn = 0; // visible column if a break were to be later introduced before `obtrusiveBreakOffset`\n\t\tlet len = lineText.length;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\t// At this point, there is a certainty that the character before `i` fits on the current line,\n\t\t\t// but the character at `i` might not fit\n\n\t\t\tlet charCode = lineText.charCodeAt(i);\n\t\t\tlet charCodeIsTab = (charCode === CharCode.Tab);\n\t\t\tlet charCodeClass = classifier.get(charCode);\n\n\t\t\tif (charCodeClass === CharacterClass.BREAK_BEFORE) {\n\t\t\t\t// This is a character that indicates that a break should happen before it\n\t\t\t\t// Since we are certain the character before `i` fits, there's no extra checking needed,\n\t\t\t\t// just mark it as a nice breaking opportunity\n\t\t\t\tniceBreakOffset = i;\n\t\t\t\tniceBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n\t\t\t}\n\n\t\t\t// CJK breaking : before break\n\t\t\tif (charCodeClass === CharacterClass.BREAK_IDEOGRAPHIC && i > 0) {\n\t\t\t\tlet prevCode = lineText.charCodeAt(i - 1);\n\t\t\t\tlet prevClass = classifier.get(prevCode);\n\t\t\t\tif (prevClass !== CharacterClass.BREAK_BEFORE) { // Kinsoku Shori: Don't break after a leading character, like an open bracket\n\t\t\t\t\tniceBreakOffset = i;\n\t\t\t\t\tniceBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet charColumnSize = 1;\n\t\t\tif (strings.isFullWidthCharacter(charCode)) {\n\t\t\t\tcharColumnSize = columnsForFullWidthChar;\n\t\t\t}\n\n\t\t\t// Advance visibleColumn with character at `i`\n\t\t\tvisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(visibleColumn, tabSize, charCodeIsTab, charColumnSize);\n\n\t\t\tif (visibleColumn > breakingColumn && i !== 0) {\n\t\t\t\t// We need to break at least before character at `i`:\n\t\t\t\t//  - break before niceBreakLastOffset if it exists (and re-establish a correct visibleColumn by using niceBreakVisibleColumn + charAt(i))\n\t\t\t\t//  - otherwise, break before obtrusiveBreakLastOffset if it exists (and re-establish a correct visibleColumn by using obtrusiveBreakVisibleColumn + charAt(i))\n\t\t\t\t//  - otherwise, break before i (and re-establish a correct visibleColumn by charAt(i))\n\n\t\t\t\tlet breakBeforeOffset: number;\n\t\t\t\tlet restoreVisibleColumnFrom: number;\n\n\t\t\t\tif (niceBreakOffset !== -1 && niceBreakVisibleColumn <= breakingColumn) {\n\n\t\t\t\t\t// We will break before `niceBreakLastOffset`\n\t\t\t\t\tbreakBeforeOffset = niceBreakOffset;\n\t\t\t\t\trestoreVisibleColumnFrom = niceBreakVisibleColumn;\n\n\t\t\t\t} else if (obtrusiveBreakOffset !== -1 && obtrusiveBreakVisibleColumn <= breakingColumn) {\n\n\t\t\t\t\t// We will break before `obtrusiveBreakLastOffset`\n\t\t\t\t\tbreakBeforeOffset = obtrusiveBreakOffset;\n\t\t\t\t\trestoreVisibleColumnFrom = obtrusiveBreakVisibleColumn;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// We will break before `i`\n\t\t\t\t\tbreakBeforeOffset = i;\n\t\t\t\t\trestoreVisibleColumnFrom = wrappedTextIndentVisibleColumn;\n\n\t\t\t\t}\n\n\t\t\t\t// Break before character at `breakBeforeOffset`\n\t\t\t\tbreakingLengths[breakingLengthsIndex++] = breakBeforeOffset - lastBreakingOffset;\n\t\t\t\tlastBreakingOffset = breakBeforeOffset;\n\n\t\t\t\t// Re-establish visibleColumn by taking character at `i` into account\n\t\t\t\tvisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(restoreVisibleColumnFrom, tabSize, charCodeIsTab, charColumnSize);\n\n\t\t\t\t// Reset markers\n\t\t\t\tniceBreakOffset = -1;\n\t\t\t\tniceBreakVisibleColumn = 0;\n\t\t\t\tobtrusiveBreakOffset = -1;\n\t\t\t\tobtrusiveBreakVisibleColumn = 0;\n\t\t\t}\n\n\t\t\t// At this point, there is a certainty that the character at `i` fits on the current line\n\n\t\t\tif (niceBreakOffset !== -1) {\n\t\t\t\t// Advance niceBreakVisibleColumn\n\t\t\t\tniceBreakVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(niceBreakVisibleColumn, tabSize, charCodeIsTab, charColumnSize);\n\t\t\t}\n\t\t\tif (obtrusiveBreakOffset !== -1) {\n\t\t\t\t// Advance obtrusiveBreakVisibleColumn\n\t\t\t\tobtrusiveBreakVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(obtrusiveBreakVisibleColumn, tabSize, charCodeIsTab, charColumnSize);\n\t\t\t}\n\n\t\t\tif (charCodeClass === CharacterClass.BREAK_AFTER && (hardWrappingIndent === WrappingIndent.None || i >= firstNonWhitespaceIndex)) {\n\t\t\t\t// This is a character that indicates that a break should happen after it\n\t\t\t\tniceBreakOffset = i + 1;\n\t\t\t\tniceBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n\t\t\t}\n\n\t\t\t// CJK breaking : after break\n\t\t\tif (charCodeClass === CharacterClass.BREAK_IDEOGRAPHIC && i < len - 1) {\n\t\t\t\tlet nextCode = lineText.charCodeAt(i + 1);\n\t\t\t\tlet nextClass = classifier.get(nextCode);\n\t\t\t\tif (nextClass !== CharacterClass.BREAK_AFTER) { // Kinsoku Shori: Don't break before a trailing character, like a period\n\t\t\t\t\tniceBreakOffset = i + 1;\n\t\t\t\t\tniceBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (charCodeClass === CharacterClass.BREAK_OBTRUSIVE) {\n\t\t\t\t// This is an obtrusive character that indicates that a break should happen after it\n\t\t\t\tobtrusiveBreakOffset = i + 1;\n\t\t\t\tobtrusiveBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n\t\t\t}\n\t\t}\n\n\t\tif (breakingLengthsIndex === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Add last segment\n\t\tbreakingLengths[breakingLengthsIndex++] = len - lastBreakingOffset;\n\n\t\treturn new CharacterHardWrappingLineMapping(\n\t\t\tnew PrefixSumComputer(toUint32Array(breakingLengths)),\n\t\t\twrappedTextIndent\n\t\t);\n\t}\n}\n\nexport class CharacterHardWrappingLineMapping implements ILineMapping {\n\n\tprivate readonly _prefixSums: PrefixSumComputer;\n\tprivate readonly _wrappedLinesIndent: string;\n\n\tconstructor(prefixSums: PrefixSumComputer, wrappedLinesIndent: string) {\n\t\tthis._prefixSums = prefixSums;\n\t\tthis._wrappedLinesIndent = wrappedLinesIndent;\n\t}\n\n\tpublic getOutputLineCount(): number {\n\t\treturn this._prefixSums.getCount();\n\t}\n\n\tpublic getWrappedLinesIndent(): string {\n\t\treturn this._wrappedLinesIndent;\n\t}\n\n\tpublic getInputOffsetOfOutputPosition(outputLineIndex: number, outputOffset: number): number {\n\t\tif (outputLineIndex === 0) {\n\t\t\treturn outputOffset;\n\t\t} else {\n\t\t\treturn this._prefixSums.getAccumulatedValue(outputLineIndex - 1) + outputOffset;\n\t\t}\n\t}\n\n\tpublic getOutputPositionOfInputOffset(inputOffset: number): OutputPosition {\n\t\tlet r = this._prefixSums.getIndexOf(inputOffset);\n\t\treturn new OutputPosition(r.index, r.remainder);\n\t}\n}\n"]}]}