{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/referenceSearch/referencesModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/referenceSearch/referencesModel.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/event\", \"vs/base/common/resources\", \"vs/base/common/lifecycle\", \"vs/base/common/strings\", \"vs/base/common/idGenerator\", \"vs/editor/common/core/range\"], function (require, exports, nls_1, event_1, resources_1, lifecycle_1, strings, idGenerator_1, range_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class OneReference {\n        constructor(parent, _range, isProviderFirst) {\n            this.parent = parent;\n            this._range = _range;\n            this.isProviderFirst = isProviderFirst;\n            this._onRefChanged = new event_1.Emitter();\n            this.onRefChanged = this._onRefChanged.event;\n            this.id = idGenerator_1.defaultGenerator.nextId();\n        }\n        get uri() {\n            return this.parent.uri;\n        }\n        get range() {\n            return this._range;\n        }\n        set range(value) {\n            this._range = value;\n            this._onRefChanged.fire(this);\n        }\n        getAriaMessage() {\n            return nls_1.localize('aria.oneReference', \"symbol in {0} on line {1} at column {2}\", resources_1.basename(this.uri), this.range.startLineNumber, this.range.startColumn);\n        }\n    }\n    exports.OneReference = OneReference;\n    class FilePreview {\n        constructor(_modelReference) {\n            this._modelReference = _modelReference;\n        }\n        dispose() {\n            lifecycle_1.dispose(this._modelReference);\n        }\n        preview(range, n = 8) {\n            const model = this._modelReference.object.textEditorModel;\n            if (!model) {\n                return undefined;\n            }\n            const { startLineNumber, startColumn, endLineNumber, endColumn } = range;\n            const word = model.getWordUntilPosition({ lineNumber: startLineNumber, column: startColumn - n });\n            const beforeRange = new range_1.Range(startLineNumber, word.startColumn, startLineNumber, startColumn);\n            const afterRange = new range_1.Range(endLineNumber, endColumn, endLineNumber, Number.MAX_VALUE);\n            const ret = {\n                before: model.getValueInRange(beforeRange).replace(/^\\s+/, strings.empty),\n                inside: model.getValueInRange(range),\n                after: model.getValueInRange(afterRange).replace(/\\s+$/, strings.empty)\n            };\n            return ret;\n        }\n    }\n    exports.FilePreview = FilePreview;\n    class FileReferences {\n        constructor(_parent, _uri) {\n            this._parent = _parent;\n            this._uri = _uri;\n            this._children = [];\n        }\n        get id() {\n            return this._uri.toString();\n        }\n        get parent() {\n            return this._parent;\n        }\n        get children() {\n            return this._children;\n        }\n        get uri() {\n            return this._uri;\n        }\n        get preview() {\n            return this._preview;\n        }\n        get failure() {\n            return this._loadFailure;\n        }\n        getAriaMessage() {\n            const len = this.children.length;\n            if (len === 1) {\n                return nls_1.localize('aria.fileReferences.1', \"1 symbol in {0}, full path {1}\", resources_1.basename(this.uri), this.uri.fsPath);\n            }\n            else {\n                return nls_1.localize('aria.fileReferences.N', \"{0} symbols in {1}, full path {2}\", len, resources_1.basename(this.uri), this.uri.fsPath);\n            }\n        }\n        resolve(textModelResolverService) {\n            if (this._resolved) {\n                return Promise.resolve(this);\n            }\n            return Promise.resolve(textModelResolverService.createModelReference(this._uri).then(modelReference => {\n                const model = modelReference.object;\n                if (!model) {\n                    modelReference.dispose();\n                    throw new Error();\n                }\n                this._preview = new FilePreview(modelReference);\n                this._resolved = true;\n                return this;\n            }, err => {\n                // something wrong here\n                this._children = [];\n                this._resolved = true;\n                this._loadFailure = err;\n                return this;\n            }));\n        }\n        dispose() {\n            if (this._preview) {\n                this._preview.dispose();\n                this._preview = undefined;\n            }\n        }\n    }\n    exports.FileReferences = FileReferences;\n    class ReferencesModel {\n        constructor(references) {\n            this.groups = [];\n            this.references = [];\n            this._onDidChangeReferenceRange = new event_1.Emitter();\n            this.onDidChangeReferenceRange = this._onDidChangeReferenceRange.event;\n            this._disposables = [];\n            // grouping and sorting\n            const [providersFirst] = references;\n            references.sort(ReferencesModel._compareReferences);\n            let current;\n            for (let ref of references) {\n                if (!current || current.uri.toString() !== ref.uri.toString()) {\n                    // new group\n                    current = new FileReferences(this, ref.uri);\n                    this.groups.push(current);\n                }\n                // append, check for equality first!\n                if (current.children.length === 0\n                    || !range_1.Range.equalsRange(ref.range, current.children[current.children.length - 1].range)) {\n                    let oneRef = new OneReference(current, ref.targetSelectionRange || ref.range, providersFirst === ref);\n                    this._disposables.push(oneRef.onRefChanged((e) => this._onDidChangeReferenceRange.fire(e)));\n                    this.references.push(oneRef);\n                    current.children.push(oneRef);\n                }\n            }\n        }\n        get empty() {\n            return this.groups.length === 0;\n        }\n        getAriaMessage() {\n            if (this.empty) {\n                return nls_1.localize('aria.result.0', \"No results found\");\n            }\n            else if (this.references.length === 1) {\n                return nls_1.localize('aria.result.1', \"Found 1 symbol in {0}\", this.references[0].uri.fsPath);\n            }\n            else if (this.groups.length === 1) {\n                return nls_1.localize('aria.result.n1', \"Found {0} symbols in {1}\", this.references.length, this.groups[0].uri.fsPath);\n            }\n            else {\n                return nls_1.localize('aria.result.nm', \"Found {0} symbols in {1} files\", this.references.length, this.groups.length);\n            }\n        }\n        nextOrPreviousReference(reference, next) {\n            let { parent } = reference;\n            let idx = parent.children.indexOf(reference);\n            let childCount = parent.children.length;\n            let groupCount = parent.parent.groups.length;\n            if (groupCount === 1 || next && idx + 1 < childCount || !next && idx > 0) {\n                // cycling within one file\n                if (next) {\n                    idx = (idx + 1) % childCount;\n                }\n                else {\n                    idx = (idx + childCount - 1) % childCount;\n                }\n                return parent.children[idx];\n            }\n            idx = parent.parent.groups.indexOf(parent);\n            if (next) {\n                idx = (idx + 1) % groupCount;\n                return parent.parent.groups[idx].children[0];\n            }\n            else {\n                idx = (idx + groupCount - 1) % groupCount;\n                return parent.parent.groups[idx].children[parent.parent.groups[idx].children.length - 1];\n            }\n        }\n        nearestReference(resource, position) {\n            const nearest = this.references.map((ref, idx) => {\n                return {\n                    idx,\n                    prefixLen: strings.commonPrefixLength(ref.uri.toString(), resource.toString()),\n                    offsetDist: Math.abs(ref.range.startLineNumber - position.lineNumber) * 100 + Math.abs(ref.range.startColumn - position.column)\n                };\n            }).sort((a, b) => {\n                if (a.prefixLen > b.prefixLen) {\n                    return -1;\n                }\n                else if (a.prefixLen < b.prefixLen) {\n                    return 1;\n                }\n                else if (a.offsetDist < b.offsetDist) {\n                    return -1;\n                }\n                else if (a.offsetDist > b.offsetDist) {\n                    return 1;\n                }\n                else {\n                    return 0;\n                }\n            })[0];\n            if (nearest) {\n                return this.references[nearest.idx];\n            }\n            return undefined;\n        }\n        firstReference() {\n            for (const ref of this.references) {\n                if (ref.isProviderFirst) {\n                    return ref;\n                }\n            }\n            return this.references[0];\n        }\n        dispose() {\n            lifecycle_1.dispose(this.groups);\n            lifecycle_1.dispose(this._disposables);\n            this.groups.length = 0;\n            this._disposables.length = 0;\n        }\n        static _compareReferences(a, b) {\n            const auri = a.uri.toString();\n            const buri = b.uri.toString();\n            if (auri < buri) {\n                return -1;\n            }\n            else if (auri > buri) {\n                return 1;\n            }\n            else {\n                return range_1.Range.compareRangesUsingStarts(a.range, b.range);\n            }\n        }\n    }\n    exports.ReferencesModel = ReferencesModel;\n});\n",null]}