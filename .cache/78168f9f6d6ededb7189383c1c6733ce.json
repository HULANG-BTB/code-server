{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/common/jsonSchema_v1.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/common/jsonSchema_v1.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/objects\", \"vs/workbench/contrib/tasks/common/problemMatcher\", \"./jsonSchemaCommon\"], function (require, exports, nls, Objects, problemMatcher_1, jsonSchemaCommon_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const schema = {\n        oneOf: [\n            {\n                allOf: [\n                    {\n                        type: 'object',\n                        required: ['version'],\n                        properties: {\n                            version: {\n                                type: 'string',\n                                enum: ['0.1.0'],\n                                deprecationMessage: nls.localize('JsonSchema.version.deprecated', 'Task version 0.1.0 is deprecated. Please use 2.0.0'),\n                                description: nls.localize('JsonSchema.version', 'The config\\'s version number')\n                            },\n                            _runner: {\n                                deprecationMessage: nls.localize('JsonSchema._runner', 'The runner has graduated. Use the offical runner property')\n                            },\n                            runner: {\n                                type: 'string',\n                                enum: ['process', 'terminal'],\n                                default: 'process',\n                                description: nls.localize('JsonSchema.runner', 'Defines whether the task is executed as a process and the output is shown in the output window or inside the terminal.')\n                            },\n                            windows: {\n                                $ref: '#/definitions/taskRunnerConfiguration',\n                                description: nls.localize('JsonSchema.windows', 'Windows specific command configuration')\n                            },\n                            osx: {\n                                $ref: '#/definitions/taskRunnerConfiguration',\n                                description: nls.localize('JsonSchema.mac', 'Mac specific command configuration')\n                            },\n                            linux: {\n                                $ref: '#/definitions/taskRunnerConfiguration',\n                                description: nls.localize('JsonSchema.linux', 'Linux specific command configuration')\n                            }\n                        }\n                    },\n                    {\n                        $ref: '#/definitions/taskRunnerConfiguration'\n                    }\n                ]\n            }\n        ]\n    };\n    const shellCommand = {\n        type: 'boolean',\n        default: true,\n        description: nls.localize('JsonSchema.shell', 'Specifies whether the command is a shell command or an external program. Defaults to false if omitted.')\n    };\n    schema.definitions = Objects.deepClone(jsonSchemaCommon_1.default.definitions);\n    let definitions = schema.definitions;\n    definitions['commandConfiguration']['properties']['isShellCommand'] = Objects.deepClone(shellCommand);\n    definitions['taskDescription']['properties']['isShellCommand'] = Objects.deepClone(shellCommand);\n    definitions['taskRunnerConfiguration']['properties']['isShellCommand'] = Objects.deepClone(shellCommand);\n    Object.getOwnPropertyNames(definitions).forEach(key => {\n        let newKey = key + '1';\n        definitions[newKey] = definitions[key];\n        delete definitions[key];\n    });\n    function fixReferences(literal) {\n        if (Array.isArray(literal)) {\n            literal.forEach(fixReferences);\n        }\n        else if (typeof literal === 'object') {\n            if (literal['$ref']) {\n                literal['$ref'] = literal['$ref'] + '1';\n            }\n            Object.getOwnPropertyNames(literal).forEach(property => {\n                let value = literal[property];\n                if (Array.isArray(value) || typeof value === 'object') {\n                    fixReferences(value);\n                }\n            });\n        }\n    }\n    fixReferences(schema);\n    problemMatcher_1.ProblemMatcherRegistry.onReady().then(() => {\n        try {\n            let matcherIds = problemMatcher_1.ProblemMatcherRegistry.keys().map(key => '$' + key);\n            definitions.problemMatcherType1.oneOf[0].enum = matcherIds;\n            definitions.problemMatcherType1.oneOf[2].items.anyOf[1].enum = matcherIds;\n        }\n        catch (err) {\n            console.log('Installing problem matcher ids failed');\n        }\n    });\n    exports.default = schema;\n});\n",null]}