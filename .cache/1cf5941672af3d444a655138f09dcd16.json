{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostTypes.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostTypes.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\ndefine([\"require\", \"exports\", \"crypto\", \"vs/base/common/arrays\", \"vs/base/common/errors\", \"vs/base/common/htmlContent\", \"vs/base/common/map\", \"vs/base/common/strings\", \"vs/base/common/uri\", \"vs/base/common/uuid\", \"vs/platform/files/common/files\"], function (require, exports, crypto, arrays_1, errors_1, htmlContent_1, map_1, strings_1, uri_1, uuid_1, files_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Disposable_1, Position_1, Range_1, Selection_1, TextEdit_1, SnippetString_1, Location_1, SymbolInformation_1, DocumentSymbol_1, CodeActionKind_1, TaskGroup_1, Task_1, FileSystemError_1;\n    \"use strict\";\n    function es5ClassCompat(target) {\n        ///@ts-ignore\n        function _() { return Reflect.construct(target, arguments, this.constructor); }\n        Object.defineProperty(_, 'name', Object.getOwnPropertyDescriptor(target, 'name'));\n        ///@ts-ignore\n        Object.setPrototypeOf(_, target);\n        ///@ts-ignore\n        Object.setPrototypeOf(_.prototype, target.prototype);\n        return _;\n    }\n    let Disposable = Disposable_1 = class Disposable {\n        constructor(callOnDispose) {\n            this._callOnDispose = callOnDispose;\n        }\n        static from(...inDisposables) {\n            let disposables = inDisposables;\n            return new Disposable_1(function () {\n                if (disposables) {\n                    for (const disposable of disposables) {\n                        if (disposable && typeof disposable.dispose === 'function') {\n                            disposable.dispose();\n                        }\n                    }\n                    disposables = undefined;\n                }\n            });\n        }\n        dispose() {\n            if (typeof this._callOnDispose === 'function') {\n                this._callOnDispose();\n                this._callOnDispose = undefined;\n            }\n        }\n    };\n    Disposable = Disposable_1 = __decorate([\n        es5ClassCompat\n    ], Disposable);\n    exports.Disposable = Disposable;\n    let Position = Position_1 = class Position {\n        constructor(line, character) {\n            if (line < 0) {\n                throw errors_1.illegalArgument('line must be non-negative');\n            }\n            if (character < 0) {\n                throw errors_1.illegalArgument('character must be non-negative');\n            }\n            this._line = line;\n            this._character = character;\n        }\n        static Min(...positions) {\n            if (positions.length === 0) {\n                throw new TypeError();\n            }\n            let result = positions[0];\n            for (let i = 1; i < positions.length; i++) {\n                const p = positions[i];\n                if (p.isBefore(result)) {\n                    result = p;\n                }\n            }\n            return result;\n        }\n        static Max(...positions) {\n            if (positions.length === 0) {\n                throw new TypeError();\n            }\n            let result = positions[0];\n            for (let i = 1; i < positions.length; i++) {\n                const p = positions[i];\n                if (p.isAfter(result)) {\n                    result = p;\n                }\n            }\n            return result;\n        }\n        static isPosition(other) {\n            if (!other) {\n                return false;\n            }\n            if (other instanceof Position_1) {\n                return true;\n            }\n            let { line, character } = other;\n            if (typeof line === 'number' && typeof character === 'number') {\n                return true;\n            }\n            return false;\n        }\n        get line() {\n            return this._line;\n        }\n        get character() {\n            return this._character;\n        }\n        isBefore(other) {\n            if (this._line < other._line) {\n                return true;\n            }\n            if (other._line < this._line) {\n                return false;\n            }\n            return this._character < other._character;\n        }\n        isBeforeOrEqual(other) {\n            if (this._line < other._line) {\n                return true;\n            }\n            if (other._line < this._line) {\n                return false;\n            }\n            return this._character <= other._character;\n        }\n        isAfter(other) {\n            return !this.isBeforeOrEqual(other);\n        }\n        isAfterOrEqual(other) {\n            return !this.isBefore(other);\n        }\n        isEqual(other) {\n            return this._line === other._line && this._character === other._character;\n        }\n        compareTo(other) {\n            if (this._line < other._line) {\n                return -1;\n            }\n            else if (this._line > other.line) {\n                return 1;\n            }\n            else {\n                // equal line\n                if (this._character < other._character) {\n                    return -1;\n                }\n                else if (this._character > other._character) {\n                    return 1;\n                }\n                else {\n                    // equal line and character\n                    return 0;\n                }\n            }\n        }\n        translate(lineDeltaOrChange, characterDelta = 0) {\n            if (lineDeltaOrChange === null || characterDelta === null) {\n                throw errors_1.illegalArgument();\n            }\n            let lineDelta;\n            if (typeof lineDeltaOrChange === 'undefined') {\n                lineDelta = 0;\n            }\n            else if (typeof lineDeltaOrChange === 'number') {\n                lineDelta = lineDeltaOrChange;\n            }\n            else {\n                lineDelta = typeof lineDeltaOrChange.lineDelta === 'number' ? lineDeltaOrChange.lineDelta : 0;\n                characterDelta = typeof lineDeltaOrChange.characterDelta === 'number' ? lineDeltaOrChange.characterDelta : 0;\n            }\n            if (lineDelta === 0 && characterDelta === 0) {\n                return this;\n            }\n            return new Position_1(this.line + lineDelta, this.character + characterDelta);\n        }\n        with(lineOrChange, character = this.character) {\n            if (lineOrChange === null || character === null) {\n                throw errors_1.illegalArgument();\n            }\n            let line;\n            if (typeof lineOrChange === 'undefined') {\n                line = this.line;\n            }\n            else if (typeof lineOrChange === 'number') {\n                line = lineOrChange;\n            }\n            else {\n                line = typeof lineOrChange.line === 'number' ? lineOrChange.line : this.line;\n                character = typeof lineOrChange.character === 'number' ? lineOrChange.character : this.character;\n            }\n            if (line === this.line && character === this.character) {\n                return this;\n            }\n            return new Position_1(line, character);\n        }\n        toJSON() {\n            return { line: this.line, character: this.character };\n        }\n    };\n    Position = Position_1 = __decorate([\n        es5ClassCompat\n    ], Position);\n    exports.Position = Position;\n    let Range = Range_1 = class Range {\n        constructor(startLineOrStart, startColumnOrEnd, endLine, endColumn) {\n            let start;\n            let end;\n            if (typeof startLineOrStart === 'number' && typeof startColumnOrEnd === 'number' && typeof endLine === 'number' && typeof endColumn === 'number') {\n                start = new Position(startLineOrStart, startColumnOrEnd);\n                end = new Position(endLine, endColumn);\n            }\n            else if (startLineOrStart instanceof Position && startColumnOrEnd instanceof Position) {\n                start = startLineOrStart;\n                end = startColumnOrEnd;\n            }\n            if (!start || !end) {\n                throw new Error('Invalid arguments');\n            }\n            if (start.isBefore(end)) {\n                this._start = start;\n                this._end = end;\n            }\n            else {\n                this._start = end;\n                this._end = start;\n            }\n        }\n        static isRange(thing) {\n            if (thing instanceof Range_1) {\n                return true;\n            }\n            if (!thing) {\n                return false;\n            }\n            return Position.isPosition(thing.start)\n                && Position.isPosition(thing.end);\n        }\n        get start() {\n            return this._start;\n        }\n        get end() {\n            return this._end;\n        }\n        contains(positionOrRange) {\n            if (positionOrRange instanceof Range_1) {\n                return this.contains(positionOrRange._start)\n                    && this.contains(positionOrRange._end);\n            }\n            else if (positionOrRange instanceof Position) {\n                if (positionOrRange.isBefore(this._start)) {\n                    return false;\n                }\n                if (this._end.isBefore(positionOrRange)) {\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        }\n        isEqual(other) {\n            return this._start.isEqual(other._start) && this._end.isEqual(other._end);\n        }\n        intersection(other) {\n            const start = Position.Max(other.start, this._start);\n            const end = Position.Min(other.end, this._end);\n            if (start.isAfter(end)) {\n                // this happens when there is no overlap:\n                // |-----|\n                //          |----|\n                return undefined;\n            }\n            return new Range_1(start, end);\n        }\n        union(other) {\n            if (this.contains(other)) {\n                return this;\n            }\n            else if (other.contains(this)) {\n                return other;\n            }\n            const start = Position.Min(other.start, this._start);\n            const end = Position.Max(other.end, this.end);\n            return new Range_1(start, end);\n        }\n        get isEmpty() {\n            return this._start.isEqual(this._end);\n        }\n        get isSingleLine() {\n            return this._start.line === this._end.line;\n        }\n        with(startOrChange, end = this.end) {\n            if (startOrChange === null || end === null) {\n                throw errors_1.illegalArgument();\n            }\n            let start;\n            if (!startOrChange) {\n                start = this.start;\n            }\n            else if (Position.isPosition(startOrChange)) {\n                start = startOrChange;\n            }\n            else {\n                start = startOrChange.start || this.start;\n                end = startOrChange.end || this.end;\n            }\n            if (start.isEqual(this._start) && end.isEqual(this.end)) {\n                return this;\n            }\n            return new Range_1(start, end);\n        }\n        toJSON() {\n            return [this.start, this.end];\n        }\n    };\n    Range = Range_1 = __decorate([\n        es5ClassCompat\n    ], Range);\n    exports.Range = Range;\n    let Selection = Selection_1 = class Selection extends Range {\n        constructor(anchorLineOrAnchor, anchorColumnOrActive, activeLine, activeColumn) {\n            let anchor;\n            let active;\n            if (typeof anchorLineOrAnchor === 'number' && typeof anchorColumnOrActive === 'number' && typeof activeLine === 'number' && typeof activeColumn === 'number') {\n                anchor = new Position(anchorLineOrAnchor, anchorColumnOrActive);\n                active = new Position(activeLine, activeColumn);\n            }\n            else if (anchorLineOrAnchor instanceof Position && anchorColumnOrActive instanceof Position) {\n                anchor = anchorLineOrAnchor;\n                active = anchorColumnOrActive;\n            }\n            if (!anchor || !active) {\n                throw new Error('Invalid arguments');\n            }\n            super(anchor, active);\n            this._anchor = anchor;\n            this._active = active;\n        }\n        static isSelection(thing) {\n            if (thing instanceof Selection_1) {\n                return true;\n            }\n            if (!thing) {\n                return false;\n            }\n            return Range.isRange(thing)\n                && Position.isPosition(thing.anchor)\n                && Position.isPosition(thing.active)\n                && typeof thing.isReversed === 'boolean';\n        }\n        get anchor() {\n            return this._anchor;\n        }\n        get active() {\n            return this._active;\n        }\n        get isReversed() {\n            return this._anchor === this._end;\n        }\n        toJSON() {\n            return {\n                start: this.start,\n                end: this.end,\n                active: this.active,\n                anchor: this.anchor\n            };\n        }\n    };\n    Selection = Selection_1 = __decorate([\n        es5ClassCompat\n    ], Selection);\n    exports.Selection = Selection;\n    class ResolvedAuthority {\n        constructor(host, port) {\n            if (typeof host !== 'string' || host.length === 0) {\n                throw errors_1.illegalArgument('host');\n            }\n            if (typeof port !== 'number' || port === 0 || Math.round(port) !== port) {\n                throw errors_1.illegalArgument('port');\n            }\n            this.host = host;\n            this.port = Math.round(port);\n        }\n    }\n    exports.ResolvedAuthority = ResolvedAuthority;\n    var EndOfLine;\n    (function (EndOfLine) {\n        EndOfLine[EndOfLine[\"LF\"] = 1] = \"LF\";\n        EndOfLine[EndOfLine[\"CRLF\"] = 2] = \"CRLF\";\n    })(EndOfLine = exports.EndOfLine || (exports.EndOfLine = {}));\n    let TextEdit = TextEdit_1 = class TextEdit {\n        constructor(range, newText) {\n            this.range = range;\n            this._newText = newText;\n        }\n        static isTextEdit(thing) {\n            if (thing instanceof TextEdit_1) {\n                return true;\n            }\n            if (!thing) {\n                return false;\n            }\n            return Range.isRange(thing)\n                && typeof thing.newText === 'string';\n        }\n        static replace(range, newText) {\n            return new TextEdit_1(range, newText);\n        }\n        static insert(position, newText) {\n            return TextEdit_1.replace(new Range(position, position), newText);\n        }\n        static delete(range) {\n            return TextEdit_1.replace(range, '');\n        }\n        static setEndOfLine(eol) {\n            const ret = new TextEdit_1(new Range(new Position(0, 0), new Position(0, 0)), '');\n            ret.newEol = eol;\n            return ret;\n        }\n        get range() {\n            return this._range;\n        }\n        set range(value) {\n            if (value && !Range.isRange(value)) {\n                throw errors_1.illegalArgument('range');\n            }\n            this._range = value;\n        }\n        get newText() {\n            return this._newText || '';\n        }\n        set newText(value) {\n            if (value && typeof value !== 'string') {\n                throw errors_1.illegalArgument('newText');\n            }\n            this._newText = value;\n        }\n        get newEol() {\n            return this._newEol;\n        }\n        set newEol(value) {\n            if (value && typeof value !== 'number') {\n                throw errors_1.illegalArgument('newEol');\n            }\n            this._newEol = value;\n        }\n        toJSON() {\n            return {\n                range: this.range,\n                newText: this.newText,\n                newEol: this._newEol\n            };\n        }\n    };\n    TextEdit = TextEdit_1 = __decorate([\n        es5ClassCompat\n    ], TextEdit);\n    exports.TextEdit = TextEdit;\n    let WorkspaceEdit = class WorkspaceEdit {\n        constructor() {\n            this._edits = new Array();\n        }\n        renameFile(from, to, options) {\n            this._edits.push({ _type: 1, from, to, options });\n        }\n        createFile(uri, options) {\n            this._edits.push({ _type: 1, from: undefined, to: uri, options });\n        }\n        deleteFile(uri, options) {\n            this._edits.push({ _type: 1, from: uri, to: undefined, options });\n        }\n        replace(uri, range, newText) {\n            this._edits.push({ _type: 2, uri, edit: new TextEdit(range, newText) });\n        }\n        insert(resource, position, newText) {\n            this.replace(resource, new Range(position, position), newText);\n        }\n        delete(resource, range) {\n            this.replace(resource, range, '');\n        }\n        has(uri) {\n            for (const edit of this._edits) {\n                if (edit._type === 2 && edit.uri.toString() === uri.toString()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        set(uri, edits) {\n            if (!edits) {\n                // remove all text edits for `uri`\n                for (let i = 0; i < this._edits.length; i++) {\n                    const element = this._edits[i];\n                    if (element._type === 2 && element.uri.toString() === uri.toString()) {\n                        this._edits[i] = undefined; // will be coalesced down below\n                    }\n                }\n                this._edits = arrays_1.coalesce(this._edits);\n            }\n            else {\n                // append edit to the end\n                for (const edit of edits) {\n                    if (edit) {\n                        this._edits.push({ _type: 2, uri, edit });\n                    }\n                }\n            }\n        }\n        get(uri) {\n            const res = [];\n            for (let candidate of this._edits) {\n                if (candidate._type === 2 && candidate.uri.toString() === uri.toString()) {\n                    res.push(candidate.edit);\n                }\n            }\n            return res;\n        }\n        entries() {\n            const textEdits = new Map();\n            for (let candidate of this._edits) {\n                if (candidate._type === 2) {\n                    let textEdit = textEdits.get(candidate.uri.toString());\n                    if (!textEdit) {\n                        textEdit = [candidate.uri, []];\n                        textEdits.set(candidate.uri.toString(), textEdit);\n                    }\n                    textEdit[1].push(candidate.edit);\n                }\n            }\n            return map_1.values(textEdits);\n        }\n        _allEntries() {\n            const res = [];\n            for (let edit of this._edits) {\n                if (edit._type === 1) {\n                    res.push([edit.from, edit.to, edit.options]);\n                }\n                else {\n                    res.push([edit.uri, [edit.edit]]);\n                }\n            }\n            return res;\n        }\n        get size() {\n            return this.entries().length;\n        }\n        toJSON() {\n            return this.entries();\n        }\n    };\n    WorkspaceEdit = __decorate([\n        es5ClassCompat\n    ], WorkspaceEdit);\n    exports.WorkspaceEdit = WorkspaceEdit;\n    let SnippetString = SnippetString_1 = class SnippetString {\n        constructor(value) {\n            this._tabstop = 1;\n            this.value = value || '';\n        }\n        static isSnippetString(thing) {\n            if (thing instanceof SnippetString_1) {\n                return true;\n            }\n            if (!thing) {\n                return false;\n            }\n            return typeof thing.value === 'string';\n        }\n        static _escape(value) {\n            return value.replace(/\\$|}|\\\\/g, '\\\\$&');\n        }\n        appendText(string) {\n            this.value += SnippetString_1._escape(string);\n            return this;\n        }\n        appendTabstop(number = this._tabstop++) {\n            this.value += '$';\n            this.value += number;\n            return this;\n        }\n        appendPlaceholder(value, number = this._tabstop++) {\n            if (typeof value === 'function') {\n                const nested = new SnippetString_1();\n                nested._tabstop = this._tabstop;\n                value(nested);\n                this._tabstop = nested._tabstop;\n                value = nested.value;\n            }\n            else {\n                value = SnippetString_1._escape(value);\n            }\n            this.value += '${';\n            this.value += number;\n            this.value += ':';\n            this.value += value;\n            this.value += '}';\n            return this;\n        }\n        appendVariable(name, defaultValue) {\n            if (typeof defaultValue === 'function') {\n                const nested = new SnippetString_1();\n                nested._tabstop = this._tabstop;\n                defaultValue(nested);\n                this._tabstop = nested._tabstop;\n                defaultValue = nested.value;\n            }\n            else if (typeof defaultValue === 'string') {\n                defaultValue = defaultValue.replace(/\\$|}/g, '\\\\$&');\n            }\n            this.value += '${';\n            this.value += name;\n            if (defaultValue) {\n                this.value += ':';\n                this.value += defaultValue;\n            }\n            this.value += '}';\n            return this;\n        }\n    };\n    SnippetString = SnippetString_1 = __decorate([\n        es5ClassCompat\n    ], SnippetString);\n    exports.SnippetString = SnippetString;\n    var DiagnosticTag;\n    (function (DiagnosticTag) {\n        DiagnosticTag[DiagnosticTag[\"Unnecessary\"] = 1] = \"Unnecessary\";\n    })(DiagnosticTag = exports.DiagnosticTag || (exports.DiagnosticTag = {}));\n    var DiagnosticSeverity;\n    (function (DiagnosticSeverity) {\n        DiagnosticSeverity[DiagnosticSeverity[\"Hint\"] = 3] = \"Hint\";\n        DiagnosticSeverity[DiagnosticSeverity[\"Information\"] = 2] = \"Information\";\n        DiagnosticSeverity[DiagnosticSeverity[\"Warning\"] = 1] = \"Warning\";\n        DiagnosticSeverity[DiagnosticSeverity[\"Error\"] = 0] = \"Error\";\n    })(DiagnosticSeverity = exports.DiagnosticSeverity || (exports.DiagnosticSeverity = {}));\n    let Location = Location_1 = class Location {\n        constructor(uri, rangeOrPosition) {\n            this.uri = uri;\n            if (!rangeOrPosition) {\n                //that's OK\n            }\n            else if (rangeOrPosition instanceof Range) {\n                this.range = rangeOrPosition;\n            }\n            else if (rangeOrPosition instanceof Position) {\n                this.range = new Range(rangeOrPosition, rangeOrPosition);\n            }\n            else {\n                throw new Error('Illegal argument');\n            }\n        }\n        static isLocation(thing) {\n            if (thing instanceof Location_1) {\n                return true;\n            }\n            if (!thing) {\n                return false;\n            }\n            return Range.isRange(thing.range)\n                && uri_1.URI.isUri(thing.uri);\n        }\n        toJSON() {\n            return {\n                uri: this.uri,\n                range: this.range\n            };\n        }\n    };\n    Location = Location_1 = __decorate([\n        es5ClassCompat\n    ], Location);\n    exports.Location = Location;\n    let DiagnosticRelatedInformation = class DiagnosticRelatedInformation {\n        constructor(location, message) {\n            this.location = location;\n            this.message = message;\n        }\n        static is(thing) {\n            if (!thing) {\n                return false;\n            }\n            return typeof thing.message === 'string'\n                && thing.location\n                && Range.isRange(thing.location.range)\n                && uri_1.URI.isUri(thing.location.uri);\n        }\n        static isEqual(a, b) {\n            if (a === b) {\n                return true;\n            }\n            if (!a || !b) {\n                return false;\n            }\n            return a.message === b.message\n                && a.location.range.isEqual(b.location.range)\n                && a.location.uri.toString() === b.location.uri.toString();\n        }\n    };\n    DiagnosticRelatedInformation = __decorate([\n        es5ClassCompat\n    ], DiagnosticRelatedInformation);\n    exports.DiagnosticRelatedInformation = DiagnosticRelatedInformation;\n    let Diagnostic = class Diagnostic {\n        constructor(range, message, severity = DiagnosticSeverity.Error) {\n            this.range = range;\n            this.message = message;\n            this.severity = severity;\n        }\n        toJSON() {\n            return {\n                severity: DiagnosticSeverity[this.severity],\n                message: this.message,\n                range: this.range,\n                source: this.source,\n                code: this.code,\n            };\n        }\n        static isEqual(a, b) {\n            if (a === b) {\n                return true;\n            }\n            if (!a || !b) {\n                return false;\n            }\n            return a.message === b.message\n                && a.severity === b.severity\n                && a.code === b.code\n                && a.severity === b.severity\n                && a.source === b.source\n                && a.range.isEqual(b.range)\n                && arrays_1.equals(a.tags, b.tags)\n                && arrays_1.equals(a.relatedInformation, b.relatedInformation, DiagnosticRelatedInformation.isEqual);\n        }\n    };\n    Diagnostic = __decorate([\n        es5ClassCompat\n    ], Diagnostic);\n    exports.Diagnostic = Diagnostic;\n    let Hover = class Hover {\n        constructor(contents, range) {\n            if (!contents) {\n                throw new Error('Illegal argument, contents must be defined');\n            }\n            if (Array.isArray(contents)) {\n                this.contents = contents;\n            }\n            else if (htmlContent_1.isMarkdownString(contents)) {\n                this.contents = [contents];\n            }\n            else {\n                this.contents = [contents];\n            }\n            this.range = range;\n        }\n    };\n    Hover = __decorate([\n        es5ClassCompat\n    ], Hover);\n    exports.Hover = Hover;\n    var DocumentHighlightKind;\n    (function (DocumentHighlightKind) {\n        DocumentHighlightKind[DocumentHighlightKind[\"Text\"] = 0] = \"Text\";\n        DocumentHighlightKind[DocumentHighlightKind[\"Read\"] = 1] = \"Read\";\n        DocumentHighlightKind[DocumentHighlightKind[\"Write\"] = 2] = \"Write\";\n    })(DocumentHighlightKind = exports.DocumentHighlightKind || (exports.DocumentHighlightKind = {}));\n    let DocumentHighlight = class DocumentHighlight {\n        constructor(range, kind = DocumentHighlightKind.Text) {\n            this.range = range;\n            this.kind = kind;\n        }\n        toJSON() {\n            return {\n                range: this.range,\n                kind: DocumentHighlightKind[this.kind]\n            };\n        }\n    };\n    DocumentHighlight = __decorate([\n        es5ClassCompat\n    ], DocumentHighlight);\n    exports.DocumentHighlight = DocumentHighlight;\n    var SymbolKind;\n    (function (SymbolKind) {\n        SymbolKind[SymbolKind[\"File\"] = 0] = \"File\";\n        SymbolKind[SymbolKind[\"Module\"] = 1] = \"Module\";\n        SymbolKind[SymbolKind[\"Namespace\"] = 2] = \"Namespace\";\n        SymbolKind[SymbolKind[\"Package\"] = 3] = \"Package\";\n        SymbolKind[SymbolKind[\"Class\"] = 4] = \"Class\";\n        SymbolKind[SymbolKind[\"Method\"] = 5] = \"Method\";\n        SymbolKind[SymbolKind[\"Property\"] = 6] = \"Property\";\n        SymbolKind[SymbolKind[\"Field\"] = 7] = \"Field\";\n        SymbolKind[SymbolKind[\"Constructor\"] = 8] = \"Constructor\";\n        SymbolKind[SymbolKind[\"Enum\"] = 9] = \"Enum\";\n        SymbolKind[SymbolKind[\"Interface\"] = 10] = \"Interface\";\n        SymbolKind[SymbolKind[\"Function\"] = 11] = \"Function\";\n        SymbolKind[SymbolKind[\"Variable\"] = 12] = \"Variable\";\n        SymbolKind[SymbolKind[\"Constant\"] = 13] = \"Constant\";\n        SymbolKind[SymbolKind[\"String\"] = 14] = \"String\";\n        SymbolKind[SymbolKind[\"Number\"] = 15] = \"Number\";\n        SymbolKind[SymbolKind[\"Boolean\"] = 16] = \"Boolean\";\n        SymbolKind[SymbolKind[\"Array\"] = 17] = \"Array\";\n        SymbolKind[SymbolKind[\"Object\"] = 18] = \"Object\";\n        SymbolKind[SymbolKind[\"Key\"] = 19] = \"Key\";\n        SymbolKind[SymbolKind[\"Null\"] = 20] = \"Null\";\n        SymbolKind[SymbolKind[\"EnumMember\"] = 21] = \"EnumMember\";\n        SymbolKind[SymbolKind[\"Struct\"] = 22] = \"Struct\";\n        SymbolKind[SymbolKind[\"Event\"] = 23] = \"Event\";\n        SymbolKind[SymbolKind[\"Operator\"] = 24] = \"Operator\";\n        SymbolKind[SymbolKind[\"TypeParameter\"] = 25] = \"TypeParameter\";\n    })(SymbolKind = exports.SymbolKind || (exports.SymbolKind = {}));\n    let SymbolInformation = SymbolInformation_1 = class SymbolInformation {\n        constructor(name, kind, rangeOrContainer, locationOrUri, containerName) {\n            this.name = name;\n            this.kind = kind;\n            this.containerName = containerName;\n            if (typeof rangeOrContainer === 'string') {\n                this.containerName = rangeOrContainer;\n            }\n            if (locationOrUri instanceof Location) {\n                this.location = locationOrUri;\n            }\n            else if (rangeOrContainer instanceof Range) {\n                this.location = new Location(locationOrUri, rangeOrContainer);\n            }\n            SymbolInformation_1.validate(this);\n        }\n        static validate(candidate) {\n            if (!candidate.name) {\n                throw new Error('name must not be falsy');\n            }\n        }\n        toJSON() {\n            return {\n                name: this.name,\n                kind: SymbolKind[this.kind],\n                location: this.location,\n                containerName: this.containerName\n            };\n        }\n    };\n    SymbolInformation = SymbolInformation_1 = __decorate([\n        es5ClassCompat\n    ], SymbolInformation);\n    exports.SymbolInformation = SymbolInformation;\n    let DocumentSymbol = DocumentSymbol_1 = class DocumentSymbol {\n        constructor(name, detail, kind, range, selectionRange) {\n            this.name = name;\n            this.detail = detail;\n            this.kind = kind;\n            this.range = range;\n            this.selectionRange = selectionRange;\n            this.children = [];\n            DocumentSymbol_1.validate(this);\n        }\n        static validate(candidate) {\n            if (!candidate.name) {\n                throw new Error('name must not be falsy');\n            }\n            if (!candidate.range.contains(candidate.selectionRange)) {\n                throw new Error('selectionRange must be contained in fullRange');\n            }\n            if (candidate.children) {\n                candidate.children.forEach(DocumentSymbol_1.validate);\n            }\n        }\n    };\n    DocumentSymbol = DocumentSymbol_1 = __decorate([\n        es5ClassCompat\n    ], DocumentSymbol);\n    exports.DocumentSymbol = DocumentSymbol;\n    var CodeActionTrigger;\n    (function (CodeActionTrigger) {\n        CodeActionTrigger[CodeActionTrigger[\"Automatic\"] = 1] = \"Automatic\";\n        CodeActionTrigger[CodeActionTrigger[\"Manual\"] = 2] = \"Manual\";\n    })(CodeActionTrigger = exports.CodeActionTrigger || (exports.CodeActionTrigger = {}));\n    let CodeAction = class CodeAction {\n        constructor(title, kind) {\n            this.title = title;\n            this.kind = kind;\n        }\n    };\n    CodeAction = __decorate([\n        es5ClassCompat\n    ], CodeAction);\n    exports.CodeAction = CodeAction;\n    let CodeActionKind = CodeActionKind_1 = class CodeActionKind {\n        constructor(value) {\n            this.value = value;\n        }\n        append(parts) {\n            return new CodeActionKind_1(this.value ? this.value + CodeActionKind_1.sep + parts : parts);\n        }\n        intersects(other) {\n            return this.contains(other) || other.contains(this);\n        }\n        contains(other) {\n            return this.value === other.value || strings_1.startsWith(other.value, this.value + CodeActionKind_1.sep);\n        }\n    };\n    CodeActionKind.sep = '.';\n    CodeActionKind = CodeActionKind_1 = __decorate([\n        es5ClassCompat\n    ], CodeActionKind);\n    exports.CodeActionKind = CodeActionKind;\n    CodeActionKind.Empty = new CodeActionKind('');\n    CodeActionKind.QuickFix = CodeActionKind.Empty.append('quickfix');\n    CodeActionKind.Refactor = CodeActionKind.Empty.append('refactor');\n    CodeActionKind.RefactorExtract = CodeActionKind.Refactor.append('extract');\n    CodeActionKind.RefactorInline = CodeActionKind.Refactor.append('inline');\n    CodeActionKind.RefactorRewrite = CodeActionKind.Refactor.append('rewrite');\n    CodeActionKind.Source = CodeActionKind.Empty.append('source');\n    CodeActionKind.SourceOrganizeImports = CodeActionKind.Source.append('organizeImports');\n    CodeActionKind.SourceFixAll = CodeActionKind.Source.append('fixAll');\n    let SelectionRange = class SelectionRange {\n        constructor(range, parent) {\n            this.range = range;\n            this.parent = parent;\n            if (parent && !parent.range.contains(this.range)) {\n                throw new Error('Invalid argument: parent must contain this range');\n            }\n        }\n    };\n    SelectionRange = __decorate([\n        es5ClassCompat\n    ], SelectionRange);\n    exports.SelectionRange = SelectionRange;\n    var CallHierarchyDirection;\n    (function (CallHierarchyDirection) {\n        CallHierarchyDirection[CallHierarchyDirection[\"CallsFrom\"] = 1] = \"CallsFrom\";\n        CallHierarchyDirection[CallHierarchyDirection[\"CallsTo\"] = 2] = \"CallsTo\";\n    })(CallHierarchyDirection = exports.CallHierarchyDirection || (exports.CallHierarchyDirection = {}));\n    class CallHierarchyItem {\n        constructor(kind, name, detail, uri, range, selectionRange) {\n            this.kind = kind;\n            this.name = name;\n            this.detail = detail;\n            this.uri = uri;\n            this.range = range;\n            this.selectionRange = selectionRange;\n        }\n    }\n    exports.CallHierarchyItem = CallHierarchyItem;\n    let CodeLens = class CodeLens {\n        constructor(range, command) {\n            this.range = range;\n            this.command = command;\n        }\n        get isResolved() {\n            return !!this.command;\n        }\n    };\n    CodeLens = __decorate([\n        es5ClassCompat\n    ], CodeLens);\n    exports.CodeLens = CodeLens;\n    class CodeInset {\n        constructor(range, height) {\n            this.range = range;\n            this.height = height;\n        }\n    }\n    exports.CodeInset = CodeInset;\n    let MarkdownString = class MarkdownString {\n        constructor(value) {\n            this.value = value || '';\n        }\n        appendText(value) {\n            // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n            this.value += value.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&');\n            return this;\n        }\n        appendMarkdown(value) {\n            this.value += value;\n            return this;\n        }\n        appendCodeblock(code, language = '') {\n            this.value += '\\n```';\n            this.value += language;\n            this.value += '\\n';\n            this.value += code;\n            this.value += '\\n```\\n';\n            return this;\n        }\n    };\n    MarkdownString = __decorate([\n        es5ClassCompat\n    ], MarkdownString);\n    exports.MarkdownString = MarkdownString;\n    let ParameterInformation = class ParameterInformation {\n        constructor(label, documentation) {\n            this.label = label;\n            this.documentation = documentation;\n        }\n    };\n    ParameterInformation = __decorate([\n        es5ClassCompat\n    ], ParameterInformation);\n    exports.ParameterInformation = ParameterInformation;\n    let SignatureInformation = class SignatureInformation {\n        constructor(label, documentation) {\n            this.label = label;\n            this.documentation = documentation;\n            this.parameters = [];\n        }\n    };\n    SignatureInformation = __decorate([\n        es5ClassCompat\n    ], SignatureInformation);\n    exports.SignatureInformation = SignatureInformation;\n    let SignatureHelp = class SignatureHelp {\n        constructor() {\n            this.signatures = [];\n        }\n    };\n    SignatureHelp = __decorate([\n        es5ClassCompat\n    ], SignatureHelp);\n    exports.SignatureHelp = SignatureHelp;\n    var SignatureHelpTriggerKind;\n    (function (SignatureHelpTriggerKind) {\n        SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"Invoke\"] = 1] = \"Invoke\";\n        SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n        SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"ContentChange\"] = 3] = \"ContentChange\";\n    })(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));\n    var CompletionTriggerKind;\n    (function (CompletionTriggerKind) {\n        CompletionTriggerKind[CompletionTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n        CompletionTriggerKind[CompletionTriggerKind[\"TriggerCharacter\"] = 1] = \"TriggerCharacter\";\n        CompletionTriggerKind[CompletionTriggerKind[\"TriggerForIncompleteCompletions\"] = 2] = \"TriggerForIncompleteCompletions\";\n    })(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));\n    var CompletionItemKind;\n    (function (CompletionItemKind) {\n        CompletionItemKind[CompletionItemKind[\"Text\"] = 0] = \"Text\";\n        CompletionItemKind[CompletionItemKind[\"Method\"] = 1] = \"Method\";\n        CompletionItemKind[CompletionItemKind[\"Function\"] = 2] = \"Function\";\n        CompletionItemKind[CompletionItemKind[\"Constructor\"] = 3] = \"Constructor\";\n        CompletionItemKind[CompletionItemKind[\"Field\"] = 4] = \"Field\";\n        CompletionItemKind[CompletionItemKind[\"Variable\"] = 5] = \"Variable\";\n        CompletionItemKind[CompletionItemKind[\"Class\"] = 6] = \"Class\";\n        CompletionItemKind[CompletionItemKind[\"Interface\"] = 7] = \"Interface\";\n        CompletionItemKind[CompletionItemKind[\"Module\"] = 8] = \"Module\";\n        CompletionItemKind[CompletionItemKind[\"Property\"] = 9] = \"Property\";\n        CompletionItemKind[CompletionItemKind[\"Unit\"] = 10] = \"Unit\";\n        CompletionItemKind[CompletionItemKind[\"Value\"] = 11] = \"Value\";\n        CompletionItemKind[CompletionItemKind[\"Enum\"] = 12] = \"Enum\";\n        CompletionItemKind[CompletionItemKind[\"Keyword\"] = 13] = \"Keyword\";\n        CompletionItemKind[CompletionItemKind[\"Snippet\"] = 14] = \"Snippet\";\n        CompletionItemKind[CompletionItemKind[\"Color\"] = 15] = \"Color\";\n        CompletionItemKind[CompletionItemKind[\"File\"] = 16] = \"File\";\n        CompletionItemKind[CompletionItemKind[\"Reference\"] = 17] = \"Reference\";\n        CompletionItemKind[CompletionItemKind[\"Folder\"] = 18] = \"Folder\";\n        CompletionItemKind[CompletionItemKind[\"EnumMember\"] = 19] = \"EnumMember\";\n        CompletionItemKind[CompletionItemKind[\"Constant\"] = 20] = \"Constant\";\n        CompletionItemKind[CompletionItemKind[\"Struct\"] = 21] = \"Struct\";\n        CompletionItemKind[CompletionItemKind[\"Event\"] = 22] = \"Event\";\n        CompletionItemKind[CompletionItemKind[\"Operator\"] = 23] = \"Operator\";\n        CompletionItemKind[CompletionItemKind[\"TypeParameter\"] = 24] = \"TypeParameter\";\n    })(CompletionItemKind = exports.CompletionItemKind || (exports.CompletionItemKind = {}));\n    let CompletionItem = class CompletionItem {\n        constructor(label, kind) {\n            this.label = label;\n            this.kind = kind;\n        }\n        toJSON() {\n            return {\n                label: this.label,\n                kind: this.kind && CompletionItemKind[this.kind],\n                detail: this.detail,\n                documentation: this.documentation,\n                sortText: this.sortText,\n                filterText: this.filterText,\n                preselect: this.preselect,\n                insertText: this.insertText,\n                textEdit: this.textEdit\n            };\n        }\n    };\n    CompletionItem = __decorate([\n        es5ClassCompat\n    ], CompletionItem);\n    exports.CompletionItem = CompletionItem;\n    let CompletionList = class CompletionList {\n        constructor(items = [], isIncomplete = false) {\n            this.items = items;\n            this.isIncomplete = isIncomplete;\n        }\n    };\n    CompletionList = __decorate([\n        es5ClassCompat\n    ], CompletionList);\n    exports.CompletionList = CompletionList;\n    var ViewColumn;\n    (function (ViewColumn) {\n        ViewColumn[ViewColumn[\"Active\"] = -1] = \"Active\";\n        ViewColumn[ViewColumn[\"Beside\"] = -2] = \"Beside\";\n        ViewColumn[ViewColumn[\"One\"] = 1] = \"One\";\n        ViewColumn[ViewColumn[\"Two\"] = 2] = \"Two\";\n        ViewColumn[ViewColumn[\"Three\"] = 3] = \"Three\";\n        ViewColumn[ViewColumn[\"Four\"] = 4] = \"Four\";\n        ViewColumn[ViewColumn[\"Five\"] = 5] = \"Five\";\n        ViewColumn[ViewColumn[\"Six\"] = 6] = \"Six\";\n        ViewColumn[ViewColumn[\"Seven\"] = 7] = \"Seven\";\n        ViewColumn[ViewColumn[\"Eight\"] = 8] = \"Eight\";\n        ViewColumn[ViewColumn[\"Nine\"] = 9] = \"Nine\";\n    })(ViewColumn = exports.ViewColumn || (exports.ViewColumn = {}));\n    var StatusBarAlignment;\n    (function (StatusBarAlignment) {\n        StatusBarAlignment[StatusBarAlignment[\"Left\"] = 1] = \"Left\";\n        StatusBarAlignment[StatusBarAlignment[\"Right\"] = 2] = \"Right\";\n    })(StatusBarAlignment = exports.StatusBarAlignment || (exports.StatusBarAlignment = {}));\n    var TextEditorLineNumbersStyle;\n    (function (TextEditorLineNumbersStyle) {\n        TextEditorLineNumbersStyle[TextEditorLineNumbersStyle[\"Off\"] = 0] = \"Off\";\n        TextEditorLineNumbersStyle[TextEditorLineNumbersStyle[\"On\"] = 1] = \"On\";\n        TextEditorLineNumbersStyle[TextEditorLineNumbersStyle[\"Relative\"] = 2] = \"Relative\";\n    })(TextEditorLineNumbersStyle = exports.TextEditorLineNumbersStyle || (exports.TextEditorLineNumbersStyle = {}));\n    var TextDocumentSaveReason;\n    (function (TextDocumentSaveReason) {\n        TextDocumentSaveReason[TextDocumentSaveReason[\"Manual\"] = 1] = \"Manual\";\n        TextDocumentSaveReason[TextDocumentSaveReason[\"AfterDelay\"] = 2] = \"AfterDelay\";\n        TextDocumentSaveReason[TextDocumentSaveReason[\"FocusOut\"] = 3] = \"FocusOut\";\n    })(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));\n    var TextEditorRevealType;\n    (function (TextEditorRevealType) {\n        TextEditorRevealType[TextEditorRevealType[\"Default\"] = 0] = \"Default\";\n        TextEditorRevealType[TextEditorRevealType[\"InCenter\"] = 1] = \"InCenter\";\n        TextEditorRevealType[TextEditorRevealType[\"InCenterIfOutsideViewport\"] = 2] = \"InCenterIfOutsideViewport\";\n        TextEditorRevealType[TextEditorRevealType[\"AtTop\"] = 3] = \"AtTop\";\n    })(TextEditorRevealType = exports.TextEditorRevealType || (exports.TextEditorRevealType = {}));\n    var TextEditorSelectionChangeKind;\n    (function (TextEditorSelectionChangeKind) {\n        TextEditorSelectionChangeKind[TextEditorSelectionChangeKind[\"Keyboard\"] = 1] = \"Keyboard\";\n        TextEditorSelectionChangeKind[TextEditorSelectionChangeKind[\"Mouse\"] = 2] = \"Mouse\";\n        TextEditorSelectionChangeKind[TextEditorSelectionChangeKind[\"Command\"] = 3] = \"Command\";\n    })(TextEditorSelectionChangeKind = exports.TextEditorSelectionChangeKind || (exports.TextEditorSelectionChangeKind = {}));\n    /**\n     * These values match very carefully the values of `TrackedRangeStickiness`\n     */\n    var DecorationRangeBehavior;\n    (function (DecorationRangeBehavior) {\n        /**\n         * TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges\n         */\n        DecorationRangeBehavior[DecorationRangeBehavior[\"OpenOpen\"] = 0] = \"OpenOpen\";\n        /**\n         * TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges\n         */\n        DecorationRangeBehavior[DecorationRangeBehavior[\"ClosedClosed\"] = 1] = \"ClosedClosed\";\n        /**\n         * TrackedRangeStickiness.GrowsOnlyWhenTypingBefore\n         */\n        DecorationRangeBehavior[DecorationRangeBehavior[\"OpenClosed\"] = 2] = \"OpenClosed\";\n        /**\n         * TrackedRangeStickiness.GrowsOnlyWhenTypingAfter\n         */\n        DecorationRangeBehavior[DecorationRangeBehavior[\"ClosedOpen\"] = 3] = \"ClosedOpen\";\n    })(DecorationRangeBehavior = exports.DecorationRangeBehavior || (exports.DecorationRangeBehavior = {}));\n    (function (TextEditorSelectionChangeKind) {\n        function fromValue(s) {\n            switch (s) {\n                case 'keyboard': return TextEditorSelectionChangeKind.Keyboard;\n                case 'mouse': return TextEditorSelectionChangeKind.Mouse;\n                case 'api': return TextEditorSelectionChangeKind.Command;\n            }\n            return undefined;\n        }\n        TextEditorSelectionChangeKind.fromValue = fromValue;\n    })(TextEditorSelectionChangeKind = exports.TextEditorSelectionChangeKind || (exports.TextEditorSelectionChangeKind = {}));\n    let DocumentLink = class DocumentLink {\n        constructor(range, target) {\n            if (target && !(target instanceof uri_1.URI)) {\n                throw errors_1.illegalArgument('target');\n            }\n            if (!Range.isRange(range) || range.isEmpty) {\n                throw errors_1.illegalArgument('range');\n            }\n            this.range = range;\n            this.target = target;\n        }\n    };\n    DocumentLink = __decorate([\n        es5ClassCompat\n    ], DocumentLink);\n    exports.DocumentLink = DocumentLink;\n    let Color = class Color {\n        constructor(red, green, blue, alpha) {\n            this.red = red;\n            this.green = green;\n            this.blue = blue;\n            this.alpha = alpha;\n        }\n    };\n    Color = __decorate([\n        es5ClassCompat\n    ], Color);\n    exports.Color = Color;\n    let ColorInformation = class ColorInformation {\n        constructor(range, color) {\n            if (color && !(color instanceof Color)) {\n                throw errors_1.illegalArgument('color');\n            }\n            if (!Range.isRange(range) || range.isEmpty) {\n                throw errors_1.illegalArgument('range');\n            }\n            this.range = range;\n            this.color = color;\n        }\n    };\n    ColorInformation = __decorate([\n        es5ClassCompat\n    ], ColorInformation);\n    exports.ColorInformation = ColorInformation;\n    let ColorPresentation = class ColorPresentation {\n        constructor(label) {\n            if (!label || typeof label !== 'string') {\n                throw errors_1.illegalArgument('label');\n            }\n            this.label = label;\n        }\n    };\n    ColorPresentation = __decorate([\n        es5ClassCompat\n    ], ColorPresentation);\n    exports.ColorPresentation = ColorPresentation;\n    var ColorFormat;\n    (function (ColorFormat) {\n        ColorFormat[ColorFormat[\"RGB\"] = 0] = \"RGB\";\n        ColorFormat[ColorFormat[\"HEX\"] = 1] = \"HEX\";\n        ColorFormat[ColorFormat[\"HSL\"] = 2] = \"HSL\";\n    })(ColorFormat = exports.ColorFormat || (exports.ColorFormat = {}));\n    var SourceControlInputBoxValidationType;\n    (function (SourceControlInputBoxValidationType) {\n        SourceControlInputBoxValidationType[SourceControlInputBoxValidationType[\"Error\"] = 0] = \"Error\";\n        SourceControlInputBoxValidationType[SourceControlInputBoxValidationType[\"Warning\"] = 1] = \"Warning\";\n        SourceControlInputBoxValidationType[SourceControlInputBoxValidationType[\"Information\"] = 2] = \"Information\";\n    })(SourceControlInputBoxValidationType = exports.SourceControlInputBoxValidationType || (exports.SourceControlInputBoxValidationType = {}));\n    var TaskRevealKind;\n    (function (TaskRevealKind) {\n        TaskRevealKind[TaskRevealKind[\"Always\"] = 1] = \"Always\";\n        TaskRevealKind[TaskRevealKind[\"Silent\"] = 2] = \"Silent\";\n        TaskRevealKind[TaskRevealKind[\"Never\"] = 3] = \"Never\";\n    })(TaskRevealKind = exports.TaskRevealKind || (exports.TaskRevealKind = {}));\n    var TaskPanelKind;\n    (function (TaskPanelKind) {\n        TaskPanelKind[TaskPanelKind[\"Shared\"] = 1] = \"Shared\";\n        TaskPanelKind[TaskPanelKind[\"Dedicated\"] = 2] = \"Dedicated\";\n        TaskPanelKind[TaskPanelKind[\"New\"] = 3] = \"New\";\n    })(TaskPanelKind = exports.TaskPanelKind || (exports.TaskPanelKind = {}));\n    let TaskGroup = TaskGroup_1 = class TaskGroup {\n        constructor(id, _label) {\n            if (typeof id !== 'string') {\n                throw errors_1.illegalArgument('name');\n            }\n            if (typeof _label !== 'string') {\n                throw errors_1.illegalArgument('name');\n            }\n            this._id = id;\n        }\n        static from(value) {\n            switch (value) {\n                case 'clean':\n                    return TaskGroup_1.Clean;\n                case 'build':\n                    return TaskGroup_1.Build;\n                case 'rebuild':\n                    return TaskGroup_1.Rebuild;\n                case 'test':\n                    return TaskGroup_1.Test;\n                default:\n                    return undefined;\n            }\n        }\n        get id() {\n            return this._id;\n        }\n    };\n    TaskGroup.Clean = new TaskGroup_1('clean', 'Clean');\n    TaskGroup.Build = new TaskGroup_1('build', 'Build');\n    TaskGroup.Rebuild = new TaskGroup_1('rebuild', 'Rebuild');\n    TaskGroup.Test = new TaskGroup_1('test', 'Test');\n    TaskGroup = TaskGroup_1 = __decorate([\n        es5ClassCompat\n    ], TaskGroup);\n    exports.TaskGroup = TaskGroup;\n    let ProcessExecution = class ProcessExecution {\n        constructor(process, varg1, varg2) {\n            if (typeof process !== 'string') {\n                throw errors_1.illegalArgument('process');\n            }\n            this._process = process;\n            if (varg1 !== undefined) {\n                if (Array.isArray(varg1)) {\n                    this._args = varg1;\n                    this._options = varg2;\n                }\n                else {\n                    this._options = varg1;\n                }\n            }\n            if (this._args === undefined) {\n                this._args = [];\n            }\n        }\n        get process() {\n            return this._process;\n        }\n        set process(value) {\n            if (typeof value !== 'string') {\n                throw errors_1.illegalArgument('process');\n            }\n            this._process = value;\n        }\n        get args() {\n            return this._args;\n        }\n        set args(value) {\n            if (!Array.isArray(value)) {\n                value = [];\n            }\n            this._args = value;\n        }\n        get options() {\n            return this._options;\n        }\n        set options(value) {\n            this._options = value;\n        }\n        computeId() {\n            const hash = crypto.createHash('md5');\n            hash.update('process');\n            if (this._process !== undefined) {\n                hash.update(this._process);\n            }\n            if (this._args && this._args.length > 0) {\n                for (let arg of this._args) {\n                    hash.update(arg);\n                }\n            }\n            return hash.digest('hex');\n        }\n    };\n    ProcessExecution = __decorate([\n        es5ClassCompat\n    ], ProcessExecution);\n    exports.ProcessExecution = ProcessExecution;\n    let ShellExecution = class ShellExecution {\n        constructor(arg0, arg1, arg2) {\n            if (Array.isArray(arg1)) {\n                if (!arg0) {\n                    throw errors_1.illegalArgument('command can\\'t be undefined or null');\n                }\n                if (typeof arg0 !== 'string' && typeof arg0.value !== 'string') {\n                    throw errors_1.illegalArgument('command');\n                }\n                this._command = arg0;\n                this._args = arg1;\n                this._options = arg2;\n            }\n            else {\n                if (typeof arg0 !== 'string') {\n                    throw errors_1.illegalArgument('commandLine');\n                }\n                this._commandLine = arg0;\n                this._options = arg1;\n            }\n        }\n        get commandLine() {\n            return this._commandLine;\n        }\n        set commandLine(value) {\n            if (typeof value !== 'string') {\n                throw errors_1.illegalArgument('commandLine');\n            }\n            this._commandLine = value;\n        }\n        get command() {\n            return this._command;\n        }\n        set command(value) {\n            if (typeof value !== 'string' && typeof value.value !== 'string') {\n                throw errors_1.illegalArgument('command');\n            }\n            this._command = value;\n        }\n        get args() {\n            return this._args;\n        }\n        set args(value) {\n            this._args = value || [];\n        }\n        get options() {\n            return this._options;\n        }\n        set options(value) {\n            this._options = value;\n        }\n        computeId() {\n            const hash = crypto.createHash('md5');\n            hash.update('shell');\n            if (this._commandLine !== undefined) {\n                hash.update(this._commandLine);\n            }\n            if (this._command !== undefined) {\n                hash.update(typeof this._command === 'string' ? this._command : this._command.value);\n            }\n            if (this._args && this._args.length > 0) {\n                for (let arg of this._args) {\n                    hash.update(typeof arg === 'string' ? arg : arg.value);\n                }\n            }\n            return hash.digest('hex');\n        }\n    };\n    ShellExecution = __decorate([\n        es5ClassCompat\n    ], ShellExecution);\n    exports.ShellExecution = ShellExecution;\n    var ShellQuoting;\n    (function (ShellQuoting) {\n        ShellQuoting[ShellQuoting[\"Escape\"] = 1] = \"Escape\";\n        ShellQuoting[ShellQuoting[\"Strong\"] = 2] = \"Strong\";\n        ShellQuoting[ShellQuoting[\"Weak\"] = 3] = \"Weak\";\n    })(ShellQuoting = exports.ShellQuoting || (exports.ShellQuoting = {}));\n    var TaskScope;\n    (function (TaskScope) {\n        TaskScope[TaskScope[\"Global\"] = 1] = \"Global\";\n        TaskScope[TaskScope[\"Workspace\"] = 2] = \"Workspace\";\n    })(TaskScope = exports.TaskScope || (exports.TaskScope = {}));\n    class CustomExecution {\n        constructor(callback) {\n            this._callback = callback;\n        }\n        computeId() {\n            const hash = crypto.createHash('md5');\n            hash.update('customExecution');\n            hash.update(uuid_1.generateUuid());\n            return hash.digest('hex');\n        }\n        set callback(value) {\n            this._callback = value;\n        }\n        get callback() {\n            return this._callback;\n        }\n    }\n    exports.CustomExecution = CustomExecution;\n    let Task = Task_1 = class Task {\n        constructor(definition, arg2, arg3, arg4, arg5, arg6) {\n            this.definition = definition;\n            let problemMatchers;\n            if (typeof arg2 === 'string') {\n                this.name = arg2;\n                this.source = arg3;\n                this.execution = arg4;\n                problemMatchers = arg5;\n            }\n            else if (arg2 === TaskScope.Global || arg2 === TaskScope.Workspace) {\n                this.target = arg2;\n                this.name = arg3;\n                this.source = arg4;\n                this.execution = arg5;\n                problemMatchers = arg6;\n            }\n            else {\n                this.target = arg2;\n                this.name = arg3;\n                this.source = arg4;\n                this.execution = arg5;\n                problemMatchers = arg6;\n            }\n            if (typeof problemMatchers === 'string') {\n                this._problemMatchers = [problemMatchers];\n                this._hasDefinedMatchers = true;\n            }\n            else if (Array.isArray(problemMatchers)) {\n                this._problemMatchers = problemMatchers;\n                this._hasDefinedMatchers = true;\n            }\n            else {\n                this._problemMatchers = [];\n                this._hasDefinedMatchers = false;\n            }\n            this._isBackground = false;\n            this._presentationOptions = Object.create(null);\n            this._runOptions = Object.create(null);\n        }\n        get _id() {\n            return this.__id;\n        }\n        set _id(value) {\n            this.__id = value;\n        }\n        clear() {\n            if (this.__id === undefined) {\n                return;\n            }\n            this.__id = undefined;\n            this._scope = undefined;\n            this.computeDefinitionBasedOnExecution();\n        }\n        computeDefinitionBasedOnExecution() {\n            if (this._execution instanceof ProcessExecution) {\n                this._definition = {\n                    type: Task_1.ProcessType,\n                    id: this._execution.computeId()\n                };\n            }\n            else if (this._execution instanceof ShellExecution) {\n                this._definition = {\n                    type: Task_1.ShellType,\n                    id: this._execution.computeId()\n                };\n            }\n            else if (this._execution instanceof CustomExecution) {\n                this._definition = {\n                    type: Task_1.ExtensionCallbackType,\n                    id: this._execution.computeId()\n                };\n            }\n            else {\n                this._definition = {\n                    type: Task_1.EmptyType,\n                    id: uuid_1.generateUuid()\n                };\n            }\n        }\n        get definition() {\n            return this._definition;\n        }\n        set definition(value) {\n            if (value === undefined || value === null) {\n                throw errors_1.illegalArgument('Kind can\\'t be undefined or null');\n            }\n            this.clear();\n            this._definition = value;\n        }\n        get scope() {\n            return this._scope;\n        }\n        set target(value) {\n            this.clear();\n            this._scope = value;\n        }\n        get name() {\n            return this._name;\n        }\n        set name(value) {\n            if (typeof value !== 'string') {\n                throw errors_1.illegalArgument('name');\n            }\n            this.clear();\n            this._name = value;\n        }\n        get execution() {\n            return (this._execution instanceof CustomExecution) ? undefined : this._execution;\n        }\n        set execution(value) {\n            this.execution2 = value;\n        }\n        get execution2() {\n            return this._execution;\n        }\n        set execution2(value) {\n            if (value === null) {\n                value = undefined;\n            }\n            this.clear();\n            this._execution = value;\n            const type = this._definition.type;\n            if (Task_1.EmptyType === type || Task_1.ProcessType === type || Task_1.ShellType === type || Task_1.ExtensionCallbackType === type) {\n                this.computeDefinitionBasedOnExecution();\n            }\n        }\n        get problemMatchers() {\n            return this._problemMatchers;\n        }\n        set problemMatchers(value) {\n            if (!Array.isArray(value)) {\n                this.clear();\n                this._problemMatchers = [];\n                this._hasDefinedMatchers = false;\n                return;\n            }\n            else {\n                this.clear();\n                this._problemMatchers = value;\n                this._hasDefinedMatchers = true;\n            }\n        }\n        get hasDefinedMatchers() {\n            return this._hasDefinedMatchers;\n        }\n        get isBackground() {\n            return this._isBackground;\n        }\n        set isBackground(value) {\n            if (value !== true && value !== false) {\n                value = false;\n            }\n            this.clear();\n            this._isBackground = value;\n        }\n        get source() {\n            return this._source;\n        }\n        set source(value) {\n            if (typeof value !== 'string' || value.length === 0) {\n                throw errors_1.illegalArgument('source must be a string of length > 0');\n            }\n            this.clear();\n            this._source = value;\n        }\n        get group() {\n            return this._group;\n        }\n        set group(value) {\n            if (value === null) {\n                value = undefined;\n            }\n            this.clear();\n            this._group = value;\n        }\n        get presentationOptions() {\n            return this._presentationOptions;\n        }\n        set presentationOptions(value) {\n            if (value === null || value === undefined) {\n                value = Object.create(null);\n            }\n            this.clear();\n            this._presentationOptions = value;\n        }\n        get runOptions() {\n            return this._runOptions;\n        }\n        set runOptions(value) {\n            if (value === null || value === undefined) {\n                value = Object.create(null);\n            }\n            this.clear();\n            this._runOptions = value;\n        }\n    };\n    Task.ExtensionCallbackType = 'customExecution';\n    Task.ProcessType = 'process';\n    Task.ShellType = 'shell';\n    Task.EmptyType = '$empty';\n    Task = Task_1 = __decorate([\n        es5ClassCompat\n    ], Task);\n    exports.Task = Task;\n    var ProgressLocation;\n    (function (ProgressLocation) {\n        ProgressLocation[ProgressLocation[\"SourceControl\"] = 1] = \"SourceControl\";\n        ProgressLocation[ProgressLocation[\"Window\"] = 10] = \"Window\";\n        ProgressLocation[ProgressLocation[\"Notification\"] = 15] = \"Notification\";\n    })(ProgressLocation = exports.ProgressLocation || (exports.ProgressLocation = {}));\n    let TreeItem = class TreeItem {\n        constructor(arg1, collapsibleState = TreeItemCollapsibleState.None) {\n            this.collapsibleState = collapsibleState;\n            if (arg1 instanceof uri_1.URI) {\n                this.resourceUri = arg1;\n            }\n            else {\n                this.label = arg1;\n            }\n        }\n    };\n    TreeItem = __decorate([\n        es5ClassCompat\n    ], TreeItem);\n    exports.TreeItem = TreeItem;\n    var TreeItemCollapsibleState;\n    (function (TreeItemCollapsibleState) {\n        TreeItemCollapsibleState[TreeItemCollapsibleState[\"None\"] = 0] = \"None\";\n        TreeItemCollapsibleState[TreeItemCollapsibleState[\"Collapsed\"] = 1] = \"Collapsed\";\n        TreeItemCollapsibleState[TreeItemCollapsibleState[\"Expanded\"] = 2] = \"Expanded\";\n    })(TreeItemCollapsibleState = exports.TreeItemCollapsibleState || (exports.TreeItemCollapsibleState = {}));\n    let ThemeIcon = class ThemeIcon {\n        constructor(id) {\n            this.id = id;\n        }\n    };\n    ThemeIcon = __decorate([\n        es5ClassCompat\n    ], ThemeIcon);\n    exports.ThemeIcon = ThemeIcon;\n    ThemeIcon.File = new ThemeIcon('file');\n    ThemeIcon.Folder = new ThemeIcon('folder');\n    let ThemeColor = class ThemeColor {\n        constructor(id) {\n            this.id = id;\n        }\n    };\n    ThemeColor = __decorate([\n        es5ClassCompat\n    ], ThemeColor);\n    exports.ThemeColor = ThemeColor;\n    var ConfigurationTarget;\n    (function (ConfigurationTarget) {\n        ConfigurationTarget[ConfigurationTarget[\"Global\"] = 1] = \"Global\";\n        ConfigurationTarget[ConfigurationTarget[\"Workspace\"] = 2] = \"Workspace\";\n        ConfigurationTarget[ConfigurationTarget[\"WorkspaceFolder\"] = 3] = \"WorkspaceFolder\";\n    })(ConfigurationTarget = exports.ConfigurationTarget || (exports.ConfigurationTarget = {}));\n    let RelativePattern = class RelativePattern {\n        constructor(base, pattern) {\n            if (typeof base !== 'string') {\n                if (!base || !uri_1.URI.isUri(base.uri)) {\n                    throw errors_1.illegalArgument('base');\n                }\n            }\n            if (typeof pattern !== 'string') {\n                throw errors_1.illegalArgument('pattern');\n            }\n            if (typeof base === 'string') {\n                this.base = base;\n            }\n            else {\n                this.baseFolder = base.uri;\n                this.base = base.uri.fsPath;\n            }\n            this.pattern = pattern;\n        }\n    };\n    RelativePattern = __decorate([\n        es5ClassCompat\n    ], RelativePattern);\n    exports.RelativePattern = RelativePattern;\n    let Breakpoint = class Breakpoint {\n        constructor(enabled, condition, hitCondition, logMessage) {\n            this.enabled = typeof enabled === 'boolean' ? enabled : true;\n            if (typeof condition === 'string') {\n                this.condition = condition;\n            }\n            if (typeof hitCondition === 'string') {\n                this.hitCondition = hitCondition;\n            }\n            if (typeof logMessage === 'string') {\n                this.logMessage = logMessage;\n            }\n        }\n        get id() {\n            if (!this._id) {\n                this._id = uuid_1.generateUuid();\n            }\n            return this._id;\n        }\n    };\n    Breakpoint = __decorate([\n        es5ClassCompat\n    ], Breakpoint);\n    exports.Breakpoint = Breakpoint;\n    let SourceBreakpoint = class SourceBreakpoint extends Breakpoint {\n        constructor(location, enabled, condition, hitCondition, logMessage) {\n            super(enabled, condition, hitCondition, logMessage);\n            if (location === null) {\n                throw errors_1.illegalArgument('location');\n            }\n            this.location = location;\n        }\n    };\n    SourceBreakpoint = __decorate([\n        es5ClassCompat\n    ], SourceBreakpoint);\n    exports.SourceBreakpoint = SourceBreakpoint;\n    let FunctionBreakpoint = class FunctionBreakpoint extends Breakpoint {\n        constructor(functionName, enabled, condition, hitCondition, logMessage) {\n            super(enabled, condition, hitCondition, logMessage);\n            if (!functionName) {\n                throw errors_1.illegalArgument('functionName');\n            }\n            this.functionName = functionName;\n        }\n    };\n    FunctionBreakpoint = __decorate([\n        es5ClassCompat\n    ], FunctionBreakpoint);\n    exports.FunctionBreakpoint = FunctionBreakpoint;\n    let DebugAdapterExecutable = class DebugAdapterExecutable {\n        constructor(command, args, options) {\n            this.command = command;\n            this.args = args || [];\n            this.options = options;\n        }\n    };\n    DebugAdapterExecutable = __decorate([\n        es5ClassCompat\n    ], DebugAdapterExecutable);\n    exports.DebugAdapterExecutable = DebugAdapterExecutable;\n    let DebugAdapterServer = class DebugAdapterServer {\n        constructor(port, host) {\n            this.port = port;\n            this.host = host;\n        }\n    };\n    DebugAdapterServer = __decorate([\n        es5ClassCompat\n    ], DebugAdapterServer);\n    exports.DebugAdapterServer = DebugAdapterServer;\n    /*\n    @es5ClassCompat\n    export class DebugAdapterImplementation implements vscode.DebugAdapterImplementation {\n        readonly implementation: any;\n    \n        constructor(transport: any) {\n            this.implementation = transport;\n        }\n    }\n    */\n    var LogLevel;\n    (function (LogLevel) {\n        LogLevel[LogLevel[\"Trace\"] = 1] = \"Trace\";\n        LogLevel[LogLevel[\"Debug\"] = 2] = \"Debug\";\n        LogLevel[LogLevel[\"Info\"] = 3] = \"Info\";\n        LogLevel[LogLevel[\"Warning\"] = 4] = \"Warning\";\n        LogLevel[LogLevel[\"Error\"] = 5] = \"Error\";\n        LogLevel[LogLevel[\"Critical\"] = 6] = \"Critical\";\n        LogLevel[LogLevel[\"Off\"] = 7] = \"Off\";\n    })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\n    //#region file api\n    var FileChangeType;\n    (function (FileChangeType) {\n        FileChangeType[FileChangeType[\"Changed\"] = 1] = \"Changed\";\n        FileChangeType[FileChangeType[\"Created\"] = 2] = \"Created\";\n        FileChangeType[FileChangeType[\"Deleted\"] = 3] = \"Deleted\";\n    })(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));\n    let FileSystemError = FileSystemError_1 = class FileSystemError extends Error {\n        constructor(uriOrMessage, code = files_1.FileSystemProviderErrorCode.Unknown, terminator) {\n            super(uri_1.URI.isUri(uriOrMessage) ? uriOrMessage.toString(true) : uriOrMessage);\n            // mark the error as file system provider error so that\n            // we can extract the error code on the receiving side\n            files_1.markAsFileSystemProviderError(this, code);\n            // workaround when extending builtin objects and when compiling to ES5, see:\n            // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n            if (typeof Object.setPrototypeOf === 'function') {\n                Object.setPrototypeOf(this, FileSystemError_1.prototype);\n            }\n            if (typeof Error.captureStackTrace === 'function' && typeof terminator === 'function') {\n                // nice stack traces\n                Error.captureStackTrace(this, terminator);\n            }\n        }\n        static FileExists(messageOrUri) {\n            return new FileSystemError_1(messageOrUri, files_1.FileSystemProviderErrorCode.FileExists, FileSystemError_1.FileExists);\n        }\n        static FileNotFound(messageOrUri) {\n            return new FileSystemError_1(messageOrUri, files_1.FileSystemProviderErrorCode.FileNotFound, FileSystemError_1.FileNotFound);\n        }\n        static FileNotADirectory(messageOrUri) {\n            return new FileSystemError_1(messageOrUri, files_1.FileSystemProviderErrorCode.FileNotADirectory, FileSystemError_1.FileNotADirectory);\n        }\n        static FileIsADirectory(messageOrUri) {\n            return new FileSystemError_1(messageOrUri, files_1.FileSystemProviderErrorCode.FileIsADirectory, FileSystemError_1.FileIsADirectory);\n        }\n        static NoPermissions(messageOrUri) {\n            return new FileSystemError_1(messageOrUri, files_1.FileSystemProviderErrorCode.NoPermissions, FileSystemError_1.NoPermissions);\n        }\n        static Unavailable(messageOrUri) {\n            return new FileSystemError_1(messageOrUri, files_1.FileSystemProviderErrorCode.Unavailable, FileSystemError_1.Unavailable);\n        }\n    };\n    FileSystemError = FileSystemError_1 = __decorate([\n        es5ClassCompat\n    ], FileSystemError);\n    exports.FileSystemError = FileSystemError;\n    //#endregion\n    //#region folding api\n    let FoldingRange = class FoldingRange {\n        constructor(start, end, kind) {\n            this.start = start;\n            this.end = end;\n            this.kind = kind;\n        }\n    };\n    FoldingRange = __decorate([\n        es5ClassCompat\n    ], FoldingRange);\n    exports.FoldingRange = FoldingRange;\n    var FoldingRangeKind;\n    (function (FoldingRangeKind) {\n        FoldingRangeKind[FoldingRangeKind[\"Comment\"] = 1] = \"Comment\";\n        FoldingRangeKind[FoldingRangeKind[\"Imports\"] = 2] = \"Imports\";\n        FoldingRangeKind[FoldingRangeKind[\"Region\"] = 3] = \"Region\";\n    })(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));\n    //#endregion\n    var CommentThreadCollapsibleState;\n    (function (CommentThreadCollapsibleState) {\n        /**\n         * Determines an item is collapsed\n         */\n        CommentThreadCollapsibleState[CommentThreadCollapsibleState[\"Collapsed\"] = 0] = \"Collapsed\";\n        /**\n         * Determines an item is expanded\n         */\n        CommentThreadCollapsibleState[CommentThreadCollapsibleState[\"Expanded\"] = 1] = \"Expanded\";\n    })(CommentThreadCollapsibleState = exports.CommentThreadCollapsibleState || (exports.CommentThreadCollapsibleState = {}));\n    let QuickInputButtons = class QuickInputButtons {\n        constructor() { }\n    };\n    QuickInputButtons.Back = { iconPath: 'back.svg' };\n    QuickInputButtons = __decorate([\n        es5ClassCompat\n    ], QuickInputButtons);\n    exports.QuickInputButtons = QuickInputButtons;\n});\n",null]}