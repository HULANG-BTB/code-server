{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/textfile/common/textfiles.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/textfile/common/textfiles.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar contextkey_1 = require(\"vs/platform/contextkey/common/contextkey\");\n/**\n * States the text file editor model can be in.\n */\nvar ModelState;\n(function (ModelState) {\n    ModelState[ModelState[\"SAVED\"] = 0] = \"SAVED\";\n    ModelState[ModelState[\"DIRTY\"] = 1] = \"DIRTY\";\n    ModelState[ModelState[\"PENDING_SAVE\"] = 2] = \"PENDING_SAVE\";\n    /**\n     * A model is in conflict mode when changes cannot be saved because the\n     * underlying file has changed. Models in conflict mode are always dirty.\n     */\n    ModelState[ModelState[\"CONFLICT\"] = 3] = \"CONFLICT\";\n    /**\n     * A model is in orphan state when the underlying file has been deleted.\n     */\n    ModelState[ModelState[\"ORPHAN\"] = 4] = \"ORPHAN\";\n    /**\n     * Any error that happens during a save that is not causing the CONFLICT state.\n     * Models in error mode are always diry.\n     */\n    ModelState[ModelState[\"ERROR\"] = 5] = \"ERROR\";\n})(ModelState = exports.ModelState || (exports.ModelState = {}));\nvar StateChange;\n(function (StateChange) {\n    StateChange[StateChange[\"DIRTY\"] = 0] = \"DIRTY\";\n    StateChange[StateChange[\"SAVING\"] = 1] = \"SAVING\";\n    StateChange[StateChange[\"SAVE_ERROR\"] = 2] = \"SAVE_ERROR\";\n    StateChange[StateChange[\"SAVED\"] = 3] = \"SAVED\";\n    StateChange[StateChange[\"REVERTED\"] = 4] = \"REVERTED\";\n    StateChange[StateChange[\"ENCODING\"] = 5] = \"ENCODING\";\n    StateChange[StateChange[\"CONTENT_CHANGE\"] = 6] = \"CONTENT_CHANGE\";\n    StateChange[StateChange[\"ORPHANED_CHANGE\"] = 7] = \"ORPHANED_CHANGE\";\n})(StateChange = exports.StateChange || (exports.StateChange = {}));\nvar TextFileModelChangeEvent = /** @class */ (function () {\n    function TextFileModelChangeEvent(model, kind) {\n        this._resource = model.getResource();\n        this._kind = kind;\n    }\n    Object.defineProperty(TextFileModelChangeEvent.prototype, \"resource\", {\n        get: function () {\n            return this._resource;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TextFileModelChangeEvent.prototype, \"kind\", {\n        get: function () {\n            return this._kind;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return TextFileModelChangeEvent;\n}());\nexports.TextFileModelChangeEvent = TextFileModelChangeEvent;\nexports.TEXT_FILE_SERVICE_ID = 'textFileService';\nexports.AutoSaveContext = new contextkey_1.RawContextKey('config.files.autoSave', undefined);\nvar AutoSaveMode;\n(function (AutoSaveMode) {\n    AutoSaveMode[AutoSaveMode[\"OFF\"] = 0] = \"OFF\";\n    AutoSaveMode[AutoSaveMode[\"AFTER_SHORT_DELAY\"] = 1] = \"AFTER_SHORT_DELAY\";\n    AutoSaveMode[AutoSaveMode[\"AFTER_LONG_DELAY\"] = 2] = \"AFTER_LONG_DELAY\";\n    AutoSaveMode[AutoSaveMode[\"ON_FOCUS_CHANGE\"] = 3] = \"ON_FOCUS_CHANGE\";\n    AutoSaveMode[AutoSaveMode[\"ON_WINDOW_CHANGE\"] = 4] = \"ON_WINDOW_CHANGE\";\n})(AutoSaveMode = exports.AutoSaveMode || (exports.AutoSaveMode = {}));\nvar SaveReason;\n(function (SaveReason) {\n    SaveReason[SaveReason[\"EXPLICIT\"] = 1] = \"EXPLICIT\";\n    SaveReason[SaveReason[\"AUTO\"] = 2] = \"AUTO\";\n    SaveReason[SaveReason[\"FOCUS_CHANGE\"] = 3] = \"FOCUS_CHANGE\";\n    SaveReason[SaveReason[\"WINDOW_CHANGE\"] = 4] = \"WINDOW_CHANGE\";\n})(SaveReason = exports.SaveReason || (exports.SaveReason = {}));\nvar LoadReason;\n(function (LoadReason) {\n    LoadReason[LoadReason[\"EDITOR\"] = 1] = \"EDITOR\";\n    LoadReason[LoadReason[\"REFERENCE\"] = 2] = \"REFERENCE\";\n    LoadReason[LoadReason[\"OTHER\"] = 3] = \"OTHER\";\n})(LoadReason = exports.LoadReason || (exports.LoadReason = {}));\nexports.ITextFileService = instantiation_1.createDecorator(exports.TEXT_FILE_SERVICE_ID);\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/textfile/common/textfiles.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/textfile/common/textfiles.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;AAOhG,gFAAiF;AAGjF,uEAAyE;AAqBzE;;GAEG;AACH,IAAkB,UAqBjB;AArBD,WAAkB,UAAU;IAC3B,6CAAK,CAAA;IACL,6CAAK,CAAA;IACL,2DAAY,CAAA;IAEZ;;;OAGG;IACH,mDAAQ,CAAA;IAER;;OAEG;IACH,+CAAM,CAAA;IAEN;;;OAGG;IACH,6CAAK,CAAA;AACN,CAAC,EArBiB,UAAU,GAAV,kBAAU,KAAV,kBAAU,QAqB3B;AAED,IAAkB,WASjB;AATD,WAAkB,WAAW;IAC5B,+CAAK,CAAA;IACL,iDAAM,CAAA;IACN,yDAAU,CAAA;IACV,+CAAK,CAAA;IACL,qDAAQ,CAAA;IACR,qDAAQ,CAAA;IACR,iEAAc,CAAA;IACd,mEAAe,CAAA;AAChB,CAAC,EATiB,WAAW,GAAX,mBAAW,KAAX,mBAAW,QAS5B;AAED;IAIC,kCAAY,KAA2B,EAAE,IAAiB;QACzD,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,WAAW,EAAE,CAAC;QACrC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;IACnB,CAAC;IAED,sBAAI,8CAAQ;aAAZ;YACC,OAAO,IAAI,CAAC,SAAS,CAAC;QACvB,CAAC;;;OAAA;IAED,sBAAI,0CAAI;aAAR;YACC,OAAO,IAAI,CAAC,KAAK,CAAC;QACnB,CAAC;;;OAAA;IACF,+BAAC;AAAD,CAAC,AAhBD,IAgBC;AAhBY,4DAAwB;AAkBxB,QAAA,oBAAoB,GAAG,iBAAiB,CAAC;AACzC,QAAA,eAAe,GAAG,IAAI,0BAAa,CAAS,uBAAuB,EAAE,SAAS,CAAC,CAAC;AAkB7F,IAAkB,YAMjB;AAND,WAAkB,YAAY;IAC7B,6CAAG,CAAA;IACH,yEAAiB,CAAA;IACjB,uEAAgB,CAAA;IAChB,qEAAe,CAAA;IACf,uEAAgB,CAAA;AACjB,CAAC,EANiB,YAAY,GAAZ,oBAAY,KAAZ,oBAAY,QAM7B;AAED,IAAkB,UAKjB;AALD,WAAkB,UAAU;IAC3B,mDAAY,CAAA;IACZ,2CAAQ,CAAA;IACR,2DAAgB,CAAA;IAChB,6DAAiB,CAAA;AAClB,CAAC,EALiB,UAAU,GAAV,kBAAU,KAAV,kBAAU,QAK3B;AAED,IAAkB,UAIjB;AAJD,WAAkB,UAAU;IAC3B,+CAAU,CAAA;IACV,qDAAa,CAAA;IACb,6CAAS,CAAA;AACV,CAAC,EAJiB,UAAU,GAAV,kBAAU,KAAV,kBAAU,QAI3B;AAEY,QAAA,gBAAgB,GAAG,+BAAe,CAAmB,4BAAoB,CAAC,CAAC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport { Event } from 'vs/base/common/event';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { IEncodingSupport, ConfirmResult, IRevertOptions } from 'vs/workbench/common/editor';\nimport { IResolveContentOptions, ITextSnapshot, IBaseStatWithMetadata } from 'vs/platform/files/common/files';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { ITextEditorModel } from 'vs/editor/common/services/resolverService';\nimport { ITextBufferFactory, ITextModel } from 'vs/editor/common/model';\nimport { RawContextKey } from 'vs/platform/contextkey/common/contextkey';\n\n/**\n * The save error handler can be installed on the text file editor model to install code that executes when save errors occur.\n */\nexport interface ISaveErrorHandler {\n\n\t/**\n\t * Called whenever a save fails.\n\t */\n\tonSaveError(error: Error, model: ITextFileEditorModel): void;\n}\n\nexport interface ISaveParticipant {\n\n\t/**\n\t * Participate in a save of a model. Allows to change the model before it is being saved to disk.\n\t */\n\tparticipate(model: IResolvedTextFileEditorModel, env: { reason: SaveReason }): Promise<void>;\n}\n\n/**\n * States the text file editor model can be in.\n */\nexport const enum ModelState {\n\tSAVED,\n\tDIRTY,\n\tPENDING_SAVE,\n\n\t/**\n\t * A model is in conflict mode when changes cannot be saved because the\n\t * underlying file has changed. Models in conflict mode are always dirty.\n\t */\n\tCONFLICT,\n\n\t/**\n\t * A model is in orphan state when the underlying file has been deleted.\n\t */\n\tORPHAN,\n\n\t/**\n\t * Any error that happens during a save that is not causing the CONFLICT state.\n\t * Models in error mode are always diry.\n\t */\n\tERROR\n}\n\nexport const enum StateChange {\n\tDIRTY,\n\tSAVING,\n\tSAVE_ERROR,\n\tSAVED,\n\tREVERTED,\n\tENCODING,\n\tCONTENT_CHANGE,\n\tORPHANED_CHANGE\n}\n\nexport class TextFileModelChangeEvent {\n\tprivate _resource: URI;\n\tprivate _kind: StateChange;\n\n\tconstructor(model: ITextFileEditorModel, kind: StateChange) {\n\t\tthis._resource = model.getResource();\n\t\tthis._kind = kind;\n\t}\n\n\tget resource(): URI {\n\t\treturn this._resource;\n\t}\n\n\tget kind(): StateChange {\n\t\treturn this._kind;\n\t}\n}\n\nexport const TEXT_FILE_SERVICE_ID = 'textFileService';\nexport const AutoSaveContext = new RawContextKey<string>('config.files.autoSave', undefined);\n\nexport interface ITextFileOperationResult {\n\tresults: IResult[];\n}\n\nexport interface IResult {\n\tsource: URI;\n\ttarget?: URI;\n\tsuccess?: boolean;\n}\n\nexport interface IAutoSaveConfiguration {\n\tautoSaveDelay?: number;\n\tautoSaveFocusChange: boolean;\n\tautoSaveApplicationChange: boolean;\n}\n\nexport const enum AutoSaveMode {\n\tOFF,\n\tAFTER_SHORT_DELAY,\n\tAFTER_LONG_DELAY,\n\tON_FOCUS_CHANGE,\n\tON_WINDOW_CHANGE\n}\n\nexport const enum SaveReason {\n\tEXPLICIT = 1,\n\tAUTO = 2,\n\tFOCUS_CHANGE = 3,\n\tWINDOW_CHANGE = 4\n}\n\nexport const enum LoadReason {\n\tEDITOR = 1,\n\tREFERENCE = 2,\n\tOTHER = 3\n}\n\nexport const ITextFileService = createDecorator<ITextFileService>(TEXT_FILE_SERVICE_ID);\n\nexport interface IRawTextContent extends IBaseStatWithMetadata {\n\n\t/**\n\t * The line grouped content of a text file.\n\t */\n\tvalue: ITextBufferFactory;\n\n\t/**\n\t * The encoding of the content if known.\n\t */\n\tencoding: string;\n}\n\nexport interface IModelLoadOrCreateOptions {\n\n\t/**\n\t * Context why the model is being loaded or created.\n\t */\n\treason?: LoadReason;\n\n\t/**\n\t * The encoding to use when resolving the model text content.\n\t */\n\tencoding?: string;\n\n\t/**\n\t * If the model was already loaded before, allows to trigger\n\t * a reload of it to fetch the latest contents:\n\t * - async: loadOrCreate() will return immediately and trigger\n\t * a reload that will run in the background.\n\t * - sync: loadOrCreate() will only return resolved when the\n\t * model has finished reloading.\n\t */\n\treload?: {\n\t\tasync: boolean\n\t};\n\n\t/**\n\t * Allow to load a model even if we think it is a binary file.\n\t */\n\tallowBinary?: boolean;\n}\n\nexport interface ITextFileEditorModelManager {\n\n\tonModelDisposed: Event<URI>;\n\tonModelContentChanged: Event<TextFileModelChangeEvent>;\n\tonModelEncodingChanged: Event<TextFileModelChangeEvent>;\n\n\tonModelDirty: Event<TextFileModelChangeEvent>;\n\tonModelSaveError: Event<TextFileModelChangeEvent>;\n\tonModelSaved: Event<TextFileModelChangeEvent>;\n\tonModelReverted: Event<TextFileModelChangeEvent>;\n\tonModelOrphanedChanged: Event<TextFileModelChangeEvent>;\n\n\tonModelsDirty: Event<TextFileModelChangeEvent[]>;\n\tonModelsSaveError: Event<TextFileModelChangeEvent[]>;\n\tonModelsSaved: Event<TextFileModelChangeEvent[]>;\n\tonModelsReverted: Event<TextFileModelChangeEvent[]>;\n\n\tget(resource: URI): ITextFileEditorModel | undefined;\n\n\tgetAll(resource?: URI): ITextFileEditorModel[];\n\n\tloadOrCreate(resource: URI, options?: IModelLoadOrCreateOptions): Promise<ITextFileEditorModel>;\n\n\tdisposeModel(model: ITextFileEditorModel): void;\n}\n\nexport interface ISaveOptions {\n\tforce?: boolean;\n\treason?: SaveReason;\n\toverwriteReadonly?: boolean;\n\toverwriteEncoding?: boolean;\n\tskipSaveParticipants?: boolean;\n\twriteElevated?: boolean;\n}\n\nexport interface ILoadOptions {\n\n\t/**\n\t * Go to disk bypassing any cache of the model if any.\n\t */\n\tforceReadFromDisk?: boolean;\n\n\t/**\n\t * Allow to load a model even if we think it is a binary file.\n\t */\n\tallowBinary?: boolean;\n\n\t/**\n\t * Context why the model is being loaded.\n\t */\n\treason?: LoadReason;\n}\n\nexport interface ITextFileEditorModel extends ITextEditorModel, IEncodingSupport {\n\n\tonDidContentChange: Event<StateChange>;\n\tonDidStateChange: Event<StateChange>;\n\n\tgetVersionId(): number;\n\n\tgetResource(): URI;\n\n\thasState(state: ModelState): boolean;\n\n\tgetETag(): string | null;\n\n\tupdatePreferredEncoding(encoding: string): void;\n\n\tsave(options?: ISaveOptions): Promise<void>;\n\n\tload(options?: ILoadOptions): Promise<ITextFileEditorModel>;\n\n\trevert(soft?: boolean): Promise<void>;\n\n\tcreateSnapshot(): ITextSnapshot | null;\n\n\tisDirty(): boolean;\n\n\tisResolved(): boolean;\n\n\tisDisposed(): boolean;\n}\n\nexport interface IResolvedTextFileEditorModel extends ITextFileEditorModel {\n\treadonly textEditorModel: ITextModel;\n\n\tcreateSnapshot(): ITextSnapshot;\n}\n\n\nexport interface IWillMoveEvent {\n\toldResource: URI;\n\tnewResource: URI;\n\twaitUntil(p: Promise<any>): void;\n}\n\nexport interface ITextFileService extends IDisposable {\n\t_serviceBrand: any;\n\n\treadonly onAutoSaveConfigurationChange: Event<IAutoSaveConfiguration>;\n\treadonly onFilesAssociationChange: Event<void>;\n\n\tonWillMove: Event<IWillMoveEvent>;\n\n\treadonly isHotExitEnabled: boolean;\n\n\t/**\n\t * Access to the manager of text file editor models providing further methods to work with them.\n\t */\n\treadonly models: ITextFileEditorModelManager;\n\n\t/**\n\t * Resolve the contents of a file identified by the resource.\n\t */\n\tresolveTextContent(resource: URI, options?: IResolveContentOptions): Promise<IRawTextContent>;\n\n\t/**\n\t * A resource is dirty if it has unsaved changes or is an untitled file not yet saved.\n\t *\n\t * @param resource the resource to check for being dirty. If it is not specified, will check for\n\t * all dirty resources.\n\t */\n\tisDirty(resource?: URI): boolean;\n\n\t/**\n\t * Returns all resources that are currently dirty matching the provided resources or all dirty resources.\n\t *\n\t * @param resources the resources to check for being dirty. If it is not specified, will check for\n\t * all dirty resources.\n\t */\n\tgetDirty(resources?: URI[]): URI[];\n\n\t/**\n\t * Saves the resource.\n\t *\n\t * @param resource the resource to save\n\t * @param options optional save options\n\t * @return true if the resource was saved.\n\t */\n\tsave(resource: URI, options?: ISaveOptions): Promise<boolean>;\n\n\t/**\n\t * Saves the provided resource asking the user for a file name or using the provided one.\n\t *\n\t * @param resource the resource to save as.\n\t * @param targetResource the optional target to save to.\n\t * @param options optional save options\n\t * @return Path of the saved resource.\n\t */\n\tsaveAs(resource: URI, targetResource?: URI, options?: ISaveOptions): Promise<URI | undefined>;\n\n\t/**\n\t * Saves the set of resources and returns a promise with the operation result.\n\t *\n\t * @param resources can be null to save all.\n\t * @param includeUntitled to save all resources and optionally exclude untitled ones.\n\t */\n\tsaveAll(includeUntitled?: boolean, options?: ISaveOptions): Promise<ITextFileOperationResult>;\n\tsaveAll(resources: URI[], options?: ISaveOptions): Promise<ITextFileOperationResult>;\n\n\t/**\n\t * Reverts the provided resource.\n\t *\n\t * @param resource the resource of the file to revert.\n\t * @param force to force revert even when the file is not dirty\n\t */\n\trevert(resource: URI, options?: IRevertOptions): Promise<boolean>;\n\n\t/**\n\t * Reverts all the provided resources and returns a promise with the operation result.\n\t */\n\trevertAll(resources?: URI[], options?: IRevertOptions): Promise<ITextFileOperationResult>;\n\n\t/**\n\t * Create a file. If the file exists it will be overwritten with the contents if\n\t * the options enable to overwrite.\n\t */\n\tcreate(resource: URI, contents?: string, options?: { overwrite?: boolean }): Promise<void>;\n\n\t/**\n\t * Delete a file. If the file is dirty, it will get reverted and then deleted from disk.\n\t */\n\tdelete(resource: URI, options?: { useTrash?: boolean, recursive?: boolean }): Promise<void>;\n\n\t/**\n\t * Move a file. If the file is dirty, its contents will be preserved and restored.\n\t */\n\tmove(source: URI, target: URI, overwrite?: boolean): Promise<void>;\n\n\t/**\n\t * Brings up the confirm dialog to either save, don't save or cancel.\n\t *\n\t * @param resources the resources of the files to ask for confirmation or null if\n\t * confirming for all dirty resources.\n\t */\n\tconfirmSave(resources?: URI[]): Promise<ConfirmResult>;\n\n\t/**\n\t * Convinient fast access to the current auto save mode.\n\t */\n\tgetAutoSaveMode(): AutoSaveMode;\n\n\t/**\n\t * Convinient fast access to the raw configured auto save settings.\n\t */\n\tgetAutoSaveConfiguration(): IAutoSaveConfiguration;\n}\n"]}]}