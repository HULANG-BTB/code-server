{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/common.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/common.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/uri\", \"vs/platform/files/common/files\", \"vs/base/common/platform\"], function (require, exports, uri_1, files_1, platform_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function toFileChangesEvent(changes) {\n        // map to file changes event that talks about URIs\n        return new files_1.FileChangesEvent(changes.map((c) => {\n            return {\n                type: c.type,\n                resource: uri_1.URI.file(c.path)\n            };\n        }));\n    }\n    exports.toFileChangesEvent = toFileChangesEvent;\n    /**\n     * Given events that occurred, applies some rules to normalize the events\n     */\n    function normalize(changes) {\n        // Build deltas\n        let normalizer = new EventNormalizer();\n        for (const event of changes) {\n            normalizer.processEvent(event);\n        }\n        return normalizer.normalize();\n    }\n    exports.normalize = normalize;\n    class EventNormalizer {\n        constructor() {\n            this.normalized = [];\n            this.mapPathToChange = Object.create(null);\n        }\n        processEvent(event) {\n            // Event path already exists\n            let existingEvent = this.mapPathToChange[event.path];\n            if (existingEvent) {\n                let currentChangeType = existingEvent.type;\n                let newChangeType = event.type;\n                // ignore CREATE followed by DELETE in one go\n                if (currentChangeType === files_1.FileChangeType.ADDED && newChangeType === files_1.FileChangeType.DELETED) {\n                    delete this.mapPathToChange[event.path];\n                    this.normalized.splice(this.normalized.indexOf(existingEvent), 1);\n                }\n                // flatten DELETE followed by CREATE into CHANGE\n                else if (currentChangeType === files_1.FileChangeType.DELETED && newChangeType === files_1.FileChangeType.ADDED) {\n                    existingEvent.type = files_1.FileChangeType.UPDATED;\n                }\n                // Do nothing. Keep the created event\n                else if (currentChangeType === files_1.FileChangeType.ADDED && newChangeType === files_1.FileChangeType.UPDATED) {\n                }\n                // Otherwise apply change type\n                else {\n                    existingEvent.type = newChangeType;\n                }\n            }\n            // Otherwise Store\n            else {\n                this.normalized.push(event);\n                this.mapPathToChange[event.path] = event;\n            }\n        }\n        normalize() {\n            let addedChangeEvents = [];\n            let deletedPaths = [];\n            // This algorithm will remove all DELETE events up to the root folder\n            // that got deleted if any. This ensures that we are not producing\n            // DELETE events for each file inside a folder that gets deleted.\n            //\n            // 1.) split ADD/CHANGE and DELETED events\n            // 2.) sort short deleted paths to the top\n            // 3.) for each DELETE, check if there is a deleted parent and ignore the event in that case\n            return this.normalized.filter(e => {\n                if (e.type !== files_1.FileChangeType.DELETED) {\n                    addedChangeEvents.push(e);\n                    return false; // remove ADD / CHANGE\n                }\n                return true; // keep DELETE\n            }).sort((e1, e2) => {\n                return e1.path.length - e2.path.length; // shortest path first\n            }).filter(e => {\n                if (deletedPaths.some(d => files_1.isParent(e.path, d, !platform_1.isLinux /* ignorecase */))) {\n                    return false; // DELETE is ignored if parent is deleted already\n                }\n                // otherwise mark as deleted\n                deletedPaths.push(e.path);\n                return true;\n            }).concat(addedChangeEvents);\n        }\n    }\n});\n",null]}