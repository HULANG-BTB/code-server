{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/extensionManagement/node/extensionManagementService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/extensionManagement/node/extensionManagementService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/path\", \"vs/base/node/pfs\", \"vs/base/common/objects\", \"vs/base/common/lifecycle\", \"vs/base/common/arrays\", \"vs/base/node/zip\", \"vs/platform/extensionManagement/common/extensionManagement\", \"vs/platform/extensionManagement/common/extensionManagementUtil\", \"../common/extensionNls\", \"vs/platform/environment/common/environment\", \"vs/base/common/async\", \"vs/base/common/event\", \"semver\", \"vs/base/common/uri\", \"vs/platform/product/node/package\", \"vs/base/common/platform\", \"vs/platform/log/common/log\", \"vs/platform/extensionManagement/node/extensionsManifestCache\", \"vs/platform/extensionManagement/node/extensionLifecycle\", \"vs/base/common/errorMessage\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/extensions/node/extensionValidator\", \"os\", \"vs/base/common/uuid\", \"vs/platform/download/common/download\", \"vs/platform/instantiation/common/instantiation\", \"vs/base/common/network\", \"vs/base/common/cancellation\", \"vs/base/common/amd\", \"vs/platform/extensionManagement/node/extensionManagementUtil\", \"vs/platform/extensions/common/extensions\", \"vs/platform/configuration/common/configuration\", \"vs/platform/extensions/node/extensionsUtil\"], function (require, exports, nls, path, pfs, objects_1, lifecycle_1, arrays_1, zip_1, extensionManagement_1, extensionManagementUtil_1, extensionNls_1, environment_1, async_1, event_1, semver, uri_1, package_1, platform_1, log_1, extensionsManifestCache_1, extensionLifecycle_1, errorMessage_1, telemetry_1, extensionValidator_1, os_1, uuid_1, download_1, instantiation_1, network_1, cancellation_1, amd_1, extensionManagementUtil_2, extensions_1, configuration_1, extensionsUtil_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const ERROR_SCANNING_SYS_EXTENSIONS = 'scanningSystem';\n    const ERROR_SCANNING_USER_EXTENSIONS = 'scanningUser';\n    const INSTALL_ERROR_UNSET_UNINSTALLED = 'unsetUninstalled';\n    const INSTALL_ERROR_DOWNLOADING = 'downloading';\n    const INSTALL_ERROR_VALIDATING = 'validating';\n    const INSTALL_ERROR_LOCAL = 'local';\n    const INSTALL_ERROR_EXTRACTING = 'extracting';\n    const INSTALL_ERROR_RENAMING = 'renaming';\n    const INSTALL_ERROR_DELETING = 'deleting';\n    const ERROR_UNKNOWN = 'unknown';\n    class ExtensionManagementError extends Error {\n        constructor(message, code) {\n            super(message);\n            this.code = code;\n        }\n    }\n    exports.ExtensionManagementError = ExtensionManagementError;\n    function parseManifest(raw) {\n        return new Promise((c, e) => {\n            try {\n                const manifest = JSON.parse(raw);\n                const metadata = manifest.__metadata || null;\n                delete manifest.__metadata;\n                c({ manifest, metadata });\n            }\n            catch (err) {\n                e(new Error(nls.localize('invalidManifest', \"Extension invalid: package.json is not a JSON file.\")));\n            }\n        });\n    }\n    function readManifest(extensionPath) {\n        const promises = [\n            pfs.readFile(path.join(extensionPath, 'package.json'), 'utf8')\n                .then(raw => parseManifest(raw)),\n            pfs.readFile(path.join(extensionPath, 'package.nls.json'), 'utf8')\n                .then(undefined, err => err.code !== 'ENOENT' ? Promise.reject(err) : '{}')\n                .then(raw => JSON.parse(raw))\n        ];\n        return Promise.all(promises).then(([{ manifest, metadata }, translations]) => {\n            return {\n                manifest: extensionNls_1.localizeManifest(manifest, translations),\n                metadata\n            };\n        });\n    }\n    let ExtensionManagementService = class ExtensionManagementService extends lifecycle_1.Disposable {\n        constructor(remote, environmentService, configurationService, galleryService, logService, downloadService, telemetryService) {\n            super();\n            this.remote = remote;\n            this.environmentService = environmentService;\n            this.configurationService = configurationService;\n            this.galleryService = galleryService;\n            this.logService = logService;\n            this.downloadService = downloadService;\n            this.telemetryService = telemetryService;\n            this.lastReportTimestamp = 0;\n            this.installingExtensions = new Map();\n            this.uninstallingExtensions = new Map();\n            this._onInstallExtension = new event_1.Emitter();\n            this.onInstallExtension = this._onInstallExtension.event;\n            this._onDidInstallExtension = new event_1.Emitter();\n            this.onDidInstallExtension = this._onDidInstallExtension.event;\n            this._onUninstallExtension = new event_1.Emitter();\n            this.onUninstallExtension = this._onUninstallExtension.event;\n            this._onDidUninstallExtension = new event_1.Emitter();\n            this.onDidUninstallExtension = this._onDidUninstallExtension.event;\n            this._devSystemExtensionsPath = null;\n            this._devSystemExtensionsFilePath = null;\n            this.systemExtensionsPath = environmentService.builtinExtensionsPath;\n            this.extensionsPath = environmentService.extensionsPath;\n            this.uninstalledPath = path.join(this.extensionsPath, '.obsolete');\n            this.uninstalledFileLimiter = new async_1.Queue();\n            this.manifestCache = this._register(new extensionsManifestCache_1.ExtensionsManifestCache(environmentService, this));\n            this.extensionLifecycle = this._register(new extensionLifecycle_1.ExtensionsLifecycle(environmentService, this.logService));\n            this._register(lifecycle_1.toDisposable(() => {\n                this.installingExtensions.forEach(promise => promise.cancel());\n                this.uninstallingExtensions.forEach(promise => promise.cancel());\n                this.installingExtensions.clear();\n                this.uninstallingExtensions.clear();\n            }));\n        }\n        zip(extension) {\n            this.logService.trace('ExtensionManagementService#zip', extension.identifier.id);\n            return this.collectFiles(extension)\n                .then(files => zip_1.zip(path.join(os_1.tmpdir(), uuid_1.generateUuid()), files))\n                .then(path => uri_1.URI.file(path));\n        }\n        unzip(zipLocation, type) {\n            this.logService.trace('ExtensionManagementService#unzip', zipLocation.toString());\n            return this.install(zipLocation, type);\n        }\n        collectFiles(extension) {\n            const collectFilesFromDirectory = (dir) => __awaiter(this, void 0, void 0, function* () {\n                let entries = yield pfs.readdir(dir);\n                entries = entries.map(e => path.join(dir, e));\n                const stats = yield Promise.all(entries.map(e => pfs.stat(e)));\n                let promise = Promise.resolve([]);\n                stats.forEach((stat, index) => {\n                    const entry = entries[index];\n                    if (stat.isFile()) {\n                        promise = promise.then(result => ([...result, entry]));\n                    }\n                    if (stat.isDirectory()) {\n                        promise = promise\n                            .then(result => collectFilesFromDirectory(entry)\n                            .then(files => ([...result, ...files])));\n                    }\n                });\n                return promise;\n            });\n            return collectFilesFromDirectory(extension.location.fsPath)\n                .then(files => files.map(f => ({ path: `extension/${path.relative(extension.location.fsPath, f)}`, localPath: f })));\n        }\n        install(vsix, type = extensions_1.ExtensionType.User) {\n            this.logService.trace('ExtensionManagementService#install', vsix.toString());\n            return async_1.createCancelablePromise(token => {\n                return this.downloadVsix(vsix).then(downloadLocation => {\n                    const zipPath = path.resolve(downloadLocation.fsPath);\n                    return extensionManagementUtil_2.getManifest(zipPath)\n                        .then(manifest => {\n                        const identifier = { id: extensionManagementUtil_1.getGalleryExtensionId(manifest.publisher, manifest.name) };\n                        let operation = extensionManagement_1.InstallOperation.Install;\n                        if (manifest.engines && manifest.engines.vscode && !extensionValidator_1.isEngineValid(manifest.engines.vscode)) {\n                            return Promise.reject(new Error(nls.localize('incompatible', \"Unable to install extension '{0}' as it is not compatible with VS Code '{1}'.\", identifier.id, package_1.default.version)));\n                        }\n                        const identifierWithVersion = new extensions_1.ExtensionIdentifierWithVersion(identifier, manifest.version);\n                        return this.getInstalled(extensions_1.ExtensionType.User)\n                            .then(installedExtensions => {\n                            const existing = installedExtensions.filter(i => extensionManagementUtil_1.areSameExtensions(identifier, i.identifier))[0];\n                            if (existing) {\n                                operation = extensionManagement_1.InstallOperation.Update;\n                                if (identifierWithVersion.equals(new extensions_1.ExtensionIdentifierWithVersion(existing.identifier, existing.manifest.version))) {\n                                    return this.removeExtension(existing, 'existing').then(null, e => Promise.reject(new Error(nls.localize('restartCode', \"Please restart VS Code before reinstalling {0}.\", manifest.displayName || manifest.name))));\n                                }\n                                else if (semver.gt(existing.manifest.version, manifest.version)) {\n                                    return this.uninstall(existing, true);\n                                }\n                            }\n                            return undefined;\n                        })\n                            .then(() => {\n                            this.logService.info('Installing the extension:', identifier.id);\n                            this._onInstallExtension.fire({ identifier, zipPath });\n                            return this.getMetadata(extensionManagementUtil_1.getGalleryExtensionId(manifest.publisher, manifest.name))\n                                .then(metadata => this.installFromZipPath(identifierWithVersion, zipPath, metadata, type, operation, token), () => this.installFromZipPath(identifierWithVersion, zipPath, null, type, operation, token))\n                                .then(() => { this.logService.info('Successfully installed the extension:', identifier.id); return identifier; }, e => {\n                                this.logService.error('Failed to install the extension:', identifier.id, e.message);\n                                return Promise.reject(e);\n                            });\n                        });\n                    });\n                });\n            });\n        }\n        downloadVsix(vsix) {\n            if (vsix.scheme === network_1.Schemas.file) {\n                return Promise.resolve(vsix);\n            }\n            if (!this.downloadService) {\n                throw new Error('Download service is not available');\n            }\n            const downloadedLocation = path.join(os_1.tmpdir(), uuid_1.generateUuid());\n            return this.downloadService.download(vsix, downloadedLocation).then(() => uri_1.URI.file(downloadedLocation));\n        }\n        installFromZipPath(identifierWithVersion, zipPath, metadata, type, operation, token) {\n            return this.toNonCancellablePromise(this.installExtension({ zipPath, identifierWithVersion, metadata }, type, token)\n                .then(local => this.installDependenciesAndPackExtensions(local, null).then(() => local, error => this.uninstall(local, true).then(() => Promise.reject(error), () => Promise.reject(error))))\n                .then(local => { this._onDidInstallExtension.fire({ identifier: identifierWithVersion.identifier, zipPath, local, operation }); return local; }, error => { this._onDidInstallExtension.fire({ identifier: identifierWithVersion.identifier, zipPath, operation, error }); return Promise.reject(error); }));\n        }\n        installFromGallery(extension) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const startTime = new Date().getTime();\n                this.logService.info('Installing extension:', extension.identifier.id);\n                this._onInstallExtension.fire({ identifier: extension.identifier, gallery: extension });\n                const onDidInstallExtensionSuccess = (extension, operation, local) => {\n                    this.logService.info(`Extensions installed successfully:`, extension.identifier.id);\n                    this._onDidInstallExtension.fire({ identifier: extension.identifier, gallery: extension, local, operation });\n                    this.reportTelemetry(this.getTelemetryEvent(operation), extensionManagementUtil_1.getGalleryExtensionTelemetryData(extension), new Date().getTime() - startTime, undefined);\n                };\n                const onDidInstallExtensionFailure = (extension, operation, error) => {\n                    const errorCode = error && error.code ? error.code : ERROR_UNKNOWN;\n                    this.logService.error(`Failed to install extension:`, extension.identifier.id, error ? error.message : errorCode);\n                    this._onDidInstallExtension.fire({ identifier: extension.identifier, gallery: extension, operation, error: errorCode });\n                    this.reportTelemetry(this.getTelemetryEvent(operation), extensionManagementUtil_1.getGalleryExtensionTelemetryData(extension), new Date().getTime() - startTime, error);\n                    if (error instanceof Error) {\n                        error.name = errorCode;\n                    }\n                };\n                try {\n                    extension = yield this.checkAndGetCompatibleVersion(extension);\n                }\n                catch (error) {\n                    onDidInstallExtensionFailure(extension, extensionManagement_1.InstallOperation.Install, error);\n                    return Promise.reject(error);\n                }\n                const key = new extensions_1.ExtensionIdentifierWithVersion(extension.identifier, extension.version).key();\n                let cancellablePromise = this.installingExtensions.get(key);\n                if (!cancellablePromise) {\n                    let operation = extensionManagement_1.InstallOperation.Install;\n                    let cancellationToken, successCallback, errorCallback;\n                    cancellablePromise = async_1.createCancelablePromise(token => { cancellationToken = token; return new Promise((c, e) => { successCallback = c; errorCallback = e; }); });\n                    this.installingExtensions.set(key, cancellablePromise);\n                    try {\n                        const installed = yield this.getInstalled(extensions_1.ExtensionType.User);\n                        const existingExtension = installed.filter(i => extensionManagementUtil_1.areSameExtensions(i.identifier, extension.identifier))[0];\n                        if (existingExtension) {\n                            operation = extensionManagement_1.InstallOperation.Update;\n                        }\n                        this.downloadInstallableExtension(extension, operation)\n                            .then(installableExtension => this.installExtension(installableExtension, extensions_1.ExtensionType.User, cancellationToken)\n                            .then(local => pfs.rimraf(installableExtension.zipPath).finally(() => null).then(() => local)))\n                            .then(local => this.installDependenciesAndPackExtensions(local, existingExtension)\n                            .then(() => local, error => this.uninstall(local, true).then(() => Promise.reject(error), () => Promise.reject(error))))\n                            .then((local) => __awaiter(this, void 0, void 0, function* () {\n                            if (existingExtension && semver.neq(existingExtension.manifest.version, extension.version)) {\n                                yield this.setUninstalled(existingExtension);\n                            }\n                            this.installingExtensions.delete(key);\n                            onDidInstallExtensionSuccess(extension, operation, local);\n                            successCallback(null);\n                        }), error => {\n                            this.installingExtensions.delete(key);\n                            onDidInstallExtensionFailure(extension, operation, error);\n                            errorCallback(error);\n                        });\n                    }\n                    catch (error) {\n                        this.installingExtensions.delete(key);\n                        onDidInstallExtensionFailure(extension, operation, error);\n                        return Promise.reject(error);\n                    }\n                }\n                return cancellablePromise;\n            });\n        }\n        checkAndGetCompatibleVersion(extension) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (yield this.isMalicious(extension)) {\n                    return Promise.reject(new ExtensionManagementError(nls.localize('malicious extension', \"Can't install extension since it was reported to be problematic.\"), extensionManagement_1.INSTALL_ERROR_MALICIOUS));\n                }\n                const compatibleExtension = yield this.galleryService.getCompatibleExtension(extension);\n                if (!compatibleExtension) {\n                    return Promise.reject(new ExtensionManagementError(nls.localize('notFoundCompatibleDependency', \"Unable to install because, the extension '{0}' compatible with current version '{1}' of VS Code is not found.\", extension.identifier.id, package_1.default.version), extensionManagement_1.INSTALL_ERROR_INCOMPATIBLE));\n                }\n                if (this.remote) {\n                    const manifest = yield this.galleryService.getManifest(extension, cancellation_1.CancellationToken.None);\n                    if (manifest && extensionsUtil_1.isUIExtension(manifest, [], this.configurationService) && !extensions_1.isLanguagePackExtension(manifest)) {\n                        return Promise.reject(new Error(nls.localize('notSupportedUIExtension', \"Can't install extension {0} since UI Extensions are not supported\", extension.identifier.id)));\n                    }\n                }\n                return compatibleExtension;\n            });\n        }\n        reinstallFromGallery(extension) {\n            this.logService.trace('ExtensionManagementService#reinstallFromGallery', extension.identifier.id);\n            if (!this.galleryService.isEnabled()) {\n                return Promise.reject(new Error(nls.localize('MarketPlaceDisabled', \"Marketplace is not enabled\")));\n            }\n            return this.findGalleryExtension(extension)\n                .then(galleryExtension => {\n                if (galleryExtension) {\n                    return this.setUninstalled(extension)\n                        .then(() => this.removeUninstalledExtension(extension)\n                        .then(() => this.installFromGallery(galleryExtension), e => Promise.reject(new Error(nls.localize('removeError', \"Error while removing the extension: {0}. Please Quit and Start VS Code before trying again.\", errorMessage_1.toErrorMessage(e))))));\n                }\n                return Promise.reject(new Error(nls.localize('Not a Marketplace extension', \"Only Marketplace Extensions can be reinstalled\")));\n            });\n        }\n        getTelemetryEvent(operation) {\n            return operation === extensionManagement_1.InstallOperation.Update ? 'extensionGallery:update' : 'extensionGallery:install';\n        }\n        isMalicious(extension) {\n            return this.getExtensionsReport()\n                .then(report => extensionManagementUtil_1.getMaliciousExtensionsSet(report).has(extension.identifier.id));\n        }\n        downloadInstallableExtension(extension, operation) {\n            const metadata = {\n                id: extension.identifier.uuid,\n                publisherId: extension.publisherId,\n                publisherDisplayName: extension.publisherDisplayName,\n            };\n            this.logService.trace('Started downloading extension:', extension.identifier.id);\n            return this.galleryService.download(extension, operation)\n                .then(zipPath => {\n                this.logService.info('Downloaded extension:', extension.identifier.id, zipPath);\n                return extensionManagementUtil_2.getManifest(zipPath)\n                    .then(manifest => ({ zipPath, identifierWithVersion: new extensions_1.ExtensionIdentifierWithVersion(extension.identifier, manifest.version), metadata }), error => Promise.reject(new ExtensionManagementError(this.joinErrors(error).message, INSTALL_ERROR_VALIDATING)));\n            }, error => Promise.reject(new ExtensionManagementError(this.joinErrors(error).message, INSTALL_ERROR_DOWNLOADING)));\n        }\n        installExtension(installableExtension, type, token) {\n            return this.unsetUninstalledAndGetLocal(installableExtension.identifierWithVersion)\n                .then(local => {\n                if (local) {\n                    return local;\n                }\n                return this.extractAndInstall(installableExtension, type, token);\n            }, e => {\n                if (platform_1.isMacintosh) {\n                    return Promise.reject(new ExtensionManagementError(nls.localize('quitCode', \"Unable to install the extension. Please Quit and Start VS Code before reinstalling.\"), INSTALL_ERROR_UNSET_UNINSTALLED));\n                }\n                return Promise.reject(new ExtensionManagementError(nls.localize('exitCode', \"Unable to install the extension. Please Exit and Start VS Code before reinstalling.\"), INSTALL_ERROR_UNSET_UNINSTALLED));\n            });\n        }\n        unsetUninstalledAndGetLocal(identifierWithVersion) {\n            return this.isUninstalled(identifierWithVersion)\n                .then(isUninstalled => {\n                if (isUninstalled) {\n                    this.logService.trace('Removing the extension from uninstalled list:', identifierWithVersion.identifier.id);\n                    // If the same version of extension is marked as uninstalled, remove it from there and return the local.\n                    return this.unsetUninstalled(identifierWithVersion)\n                        .then(() => {\n                        this.logService.info('Removed the extension from uninstalled list:', identifierWithVersion.identifier.id);\n                        return this.getInstalled(extensions_1.ExtensionType.User);\n                    })\n                        .then(installed => installed.filter(i => new extensions_1.ExtensionIdentifierWithVersion(i.identifier, i.manifest.version).equals(identifierWithVersion))[0]);\n                }\n                return null;\n            });\n        }\n        extractAndInstall({ zipPath, identifierWithVersion, metadata }, type, token) {\n            const { identifier } = identifierWithVersion;\n            const location = type === extensions_1.ExtensionType.User ? this.extensionsPath : this.systemExtensionsPath;\n            const folderName = identifierWithVersion.key();\n            const tempPath = path.join(location, `.${folderName}`);\n            const extensionPath = path.join(location, folderName);\n            return pfs.rimraf(extensionPath)\n                .then(() => this.extractAndRename(identifier, zipPath, tempPath, extensionPath, token), e => Promise.reject(new ExtensionManagementError(nls.localize('errorDeleting', \"Unable to delete the existing folder '{0}' while installing the extension '{1}'. Please delete the folder manually and try again\", extensionPath, identifier.id), INSTALL_ERROR_DELETING)))\n                .then(() => this.scanExtension(folderName, location, type))\n                .then(local => {\n                if (!local) {\n                    return Promise.reject(nls.localize('cannot read', \"Cannot read the extension from {0}\", location));\n                }\n                this.logService.info('Installation completed.', identifier.id);\n                if (metadata) {\n                    local.metadata = metadata;\n                    return this.saveMetadataForLocalExtension(local);\n                }\n                return local;\n            }, error => pfs.rimraf(extensionPath).then(() => Promise.reject(error), () => Promise.reject(error)));\n        }\n        extractAndRename(identifier, zipPath, extractPath, renamePath, token) {\n            return this.extract(identifier, zipPath, extractPath, token)\n                .then(() => this.rename(identifier, extractPath, renamePath, Date.now() + (2 * 60 * 1000) /* Retry for 2 minutes */)\n                .then(() => this.logService.info('Renamed to', renamePath), e => {\n                this.logService.info('Rename failed. Deleting from extracted location', extractPath);\n                return pfs.rimraf(extractPath).finally(() => null).then(() => Promise.reject(e));\n            }));\n        }\n        extract(identifier, zipPath, extractPath, token) {\n            this.logService.trace(`Started extracting the extension from ${zipPath} to ${extractPath}`);\n            return pfs.rimraf(extractPath)\n                .then(() => zip_1.extract(zipPath, extractPath, { sourcePath: 'extension', overwrite: true }, token)\n                .then(() => this.logService.info(`Extracted extension to ${extractPath}:`, identifier.id), e => pfs.rimraf(extractPath).finally(() => null)\n                .then(() => Promise.reject(new ExtensionManagementError(e.message, e instanceof zip_1.ExtractError && e.type ? e.type : INSTALL_ERROR_EXTRACTING)))), e => Promise.reject(new ExtensionManagementError(this.joinErrors(e).message, INSTALL_ERROR_DELETING)));\n        }\n        rename(identfier, extractPath, renamePath, retryUntil) {\n            return pfs.rename(extractPath, renamePath)\n                .then(undefined, error => {\n                if (platform_1.isWindows && error && error.code === 'EPERM' && Date.now() < retryUntil) {\n                    this.logService.info(`Failed renaming ${extractPath} to ${renamePath} with 'EPERM' error. Trying again...`, identfier.id);\n                    return this.rename(identfier, extractPath, renamePath, retryUntil);\n                }\n                return Promise.reject(new ExtensionManagementError(error.message || nls.localize('renameError', \"Unknown error while renaming {0} to {1}\", extractPath, renamePath), error.code || INSTALL_ERROR_RENAMING));\n            });\n        }\n        installDependenciesAndPackExtensions(installed, existing) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (this.galleryService.isEnabled()) {\n                    const dependenciesAndPackExtensions = installed.manifest.extensionDependencies || [];\n                    if (installed.manifest.extensionPack) {\n                        for (const extension of installed.manifest.extensionPack) {\n                            // add only those extensions which are new in currently installed extension\n                            if (!(existing && existing.manifest.extensionPack && existing.manifest.extensionPack.some(old => extensionManagementUtil_1.areSameExtensions({ id: old }, { id: extension })))) {\n                                if (dependenciesAndPackExtensions.every(e => !extensionManagementUtil_1.areSameExtensions({ id: e }, { id: extension }))) {\n                                    dependenciesAndPackExtensions.push(extension);\n                                }\n                            }\n                        }\n                    }\n                    if (dependenciesAndPackExtensions.length) {\n                        return this.getInstalled()\n                            .then(installed => {\n                            // filter out installed extensions\n                            const names = dependenciesAndPackExtensions.filter(id => installed.every(({ identifier: galleryIdentifier }) => !extensionManagementUtil_1.areSameExtensions(galleryIdentifier, { id })));\n                            if (names.length) {\n                                return this.galleryService.query({ names, pageSize: dependenciesAndPackExtensions.length }, cancellation_1.CancellationToken.None)\n                                    .then(galleryResult => {\n                                    const extensionsToInstall = galleryResult.firstPage;\n                                    return Promise.all(extensionsToInstall.map((e) => __awaiter(this, void 0, void 0, function* () {\n                                        if (this.remote) {\n                                            const manifest = yield this.galleryService.getManifest(e, cancellation_1.CancellationToken.None);\n                                            if (manifest && extensionsUtil_1.isUIExtension(manifest, [], this.configurationService) && !extensions_1.isLanguagePackExtension(manifest)) {\n                                                this.logService.info('Ignored installing the UI dependency', e.identifier.id);\n                                                return;\n                                            }\n                                        }\n                                        return this.installFromGallery(e);\n                                    })))\n                                        .then(() => null, errors => this.rollback(extensionsToInstall).then(() => Promise.reject(errors), () => Promise.reject(errors)));\n                                });\n                            }\n                            return null;\n                        });\n                    }\n                }\n                return Promise.resolve(undefined);\n            });\n        }\n        rollback(extensions) {\n            return this.getInstalled(extensions_1.ExtensionType.User)\n                .then(installed => Promise.all(installed.filter(local => extensions.some(galleryExtension => new extensions_1.ExtensionIdentifierWithVersion(local.identifier, local.manifest.version).equals(new extensions_1.ExtensionIdentifierWithVersion(galleryExtension.identifier, galleryExtension.version)))) // Check with version because we want to rollback the exact version\n                .map(local => this.uninstall(local, true))))\n                .then(() => undefined, () => undefined);\n        }\n        uninstall(extension, force = false) {\n            this.logService.trace('ExtensionManagementService#uninstall', extension.identifier.id);\n            return this.toNonCancellablePromise(this.getInstalled(extensions_1.ExtensionType.User)\n                .then(installed => {\n                const extensionToUninstall = installed.filter(e => extensionManagementUtil_1.areSameExtensions(e.identifier, extension.identifier))[0];\n                if (extensionToUninstall) {\n                    return this.checkForDependenciesAndUninstall(extensionToUninstall, installed).then(() => null, error => Promise.reject(this.joinErrors(error)));\n                }\n                else {\n                    return Promise.reject(new Error(nls.localize('notInstalled', \"Extension '{0}' is not installed.\", extension.manifest.displayName || extension.manifest.name)));\n                }\n            }));\n        }\n        updateMetadata(local, metadata) {\n            this.logService.trace('ExtensionManagementService#updateMetadata', local.identifier.id);\n            local.metadata = metadata;\n            return this.saveMetadataForLocalExtension(local)\n                .then(localExtension => {\n                this.manifestCache.invalidate();\n                return localExtension;\n            });\n        }\n        saveMetadataForLocalExtension(local) {\n            if (!local.metadata) {\n                return Promise.resolve(local);\n            }\n            const manifestPath = path.join(local.location.fsPath, 'package.json');\n            return pfs.readFile(manifestPath, 'utf8')\n                .then(raw => parseManifest(raw))\n                .then(({ manifest }) => objects_1.assign(manifest, { __metadata: local.metadata }))\n                .then(manifest => pfs.writeFile(manifestPath, JSON.stringify(manifest, null, '\\t')))\n                .then(() => local);\n        }\n        getMetadata(extensionName) {\n            return this.findGalleryExtensionByName(extensionName)\n                .then(galleryExtension => galleryExtension ? { id: galleryExtension.identifier.uuid, publisherDisplayName: galleryExtension.publisherDisplayName, publisherId: galleryExtension.publisherId } : null);\n        }\n        findGalleryExtension(local) {\n            if (local.identifier.uuid) {\n                return this.findGalleryExtensionById(local.identifier.uuid)\n                    .then(galleryExtension => galleryExtension ? galleryExtension : this.findGalleryExtensionByName(local.identifier.id));\n            }\n            return this.findGalleryExtensionByName(local.identifier.id);\n        }\n        findGalleryExtensionById(uuid) {\n            return this.galleryService.query({ ids: [uuid], pageSize: 1 }, cancellation_1.CancellationToken.None).then(galleryResult => galleryResult.firstPage[0]);\n        }\n        findGalleryExtensionByName(name) {\n            return this.galleryService.query({ names: [name], pageSize: 1 }, cancellation_1.CancellationToken.None).then(galleryResult => galleryResult.firstPage[0]);\n        }\n        joinErrors(errorOrErrors) {\n            const errors = Array.isArray(errorOrErrors) ? errorOrErrors : [errorOrErrors];\n            if (errors.length === 1) {\n                return errors[0] instanceof Error ? errors[0] : new Error(errors[0]);\n            }\n            return errors.reduce((previousValue, currentValue) => {\n                return new Error(`${previousValue.message}${previousValue.message ? ',' : ''}${currentValue instanceof Error ? currentValue.message : currentValue}`);\n            }, new Error(''));\n        }\n        checkForDependenciesAndUninstall(extension, installed) {\n            return this.preUninstallExtension(extension)\n                .then(() => {\n                const packedExtensions = this.getAllPackExtensionsToUninstall(extension, installed);\n                if (packedExtensions.length) {\n                    return this.uninstallExtensions(extension, packedExtensions, installed);\n                }\n                return this.uninstallExtensions(extension, [], installed);\n            })\n                .then(() => this.postUninstallExtension(extension), error => {\n                this.postUninstallExtension(extension, new ExtensionManagementError(error instanceof Error ? error.message : error, INSTALL_ERROR_LOCAL));\n                return Promise.reject(error);\n            });\n        }\n        uninstallExtensions(extension, otherExtensionsToUninstall, installed) {\n            const dependents = this.getDependents(extension, installed);\n            if (dependents.length) {\n                const remainingDependents = dependents.filter(dependent => extension !== dependent && otherExtensionsToUninstall.indexOf(dependent) === -1);\n                if (remainingDependents.length) {\n                    return Promise.reject(new Error(this.getDependentsErrorMessage(extension, remainingDependents)));\n                }\n            }\n            return Promise.all([this.uninstallExtension(extension), ...otherExtensionsToUninstall.map(d => this.doUninstall(d))]).then(() => undefined);\n        }\n        getDependentsErrorMessage(extension, dependents) {\n            if (dependents.length === 1) {\n                return nls.localize('singleDependentError', \"Cannot uninstall extension '{0}'. Extension '{1}' depends on this.\", extension.manifest.displayName || extension.manifest.name, dependents[0].manifest.displayName || dependents[0].manifest.name);\n            }\n            if (dependents.length === 2) {\n                return nls.localize('twoDependentsError', \"Cannot uninstall extension '{0}'. Extensions '{1}' and '{2}' depend on this.\", extension.manifest.displayName || extension.manifest.name, dependents[0].manifest.displayName || dependents[0].manifest.name, dependents[1].manifest.displayName || dependents[1].manifest.name);\n            }\n            return nls.localize('multipleDependentsError', \"Cannot uninstall extension '{0}'. Extensions '{1}', '{2}' and others depend on this.\", extension.manifest.displayName || extension.manifest.name, dependents[0].manifest.displayName || dependents[0].manifest.name, dependents[1].manifest.displayName || dependents[1].manifest.name);\n        }\n        getAllPackExtensionsToUninstall(extension, installed, checked = []) {\n            if (checked.indexOf(extension) !== -1) {\n                return [];\n            }\n            checked.push(extension);\n            const extensionsPack = extension.manifest.extensionPack ? extension.manifest.extensionPack : [];\n            if (extensionsPack.length) {\n                const packedExtensions = installed.filter(i => extensionsPack.some(id => extensionManagementUtil_1.areSameExtensions({ id }, i.identifier)));\n                const packOfPackedExtensions = [];\n                for (const packedExtension of packedExtensions) {\n                    packOfPackedExtensions.push(...this.getAllPackExtensionsToUninstall(packedExtension, installed, checked));\n                }\n                return [...packedExtensions, ...packOfPackedExtensions];\n            }\n            return [];\n        }\n        getDependents(extension, installed) {\n            return installed.filter(e => e.manifest.extensionDependencies && e.manifest.extensionDependencies.some(id => extensionManagementUtil_1.areSameExtensions({ id }, extension.identifier)));\n        }\n        doUninstall(extension) {\n            return this.preUninstallExtension(extension)\n                .then(() => this.uninstallExtension(extension))\n                .then(() => this.postUninstallExtension(extension), error => {\n                this.postUninstallExtension(extension, new ExtensionManagementError(error instanceof Error ? error.message : error, INSTALL_ERROR_LOCAL));\n                return Promise.reject(error);\n            });\n        }\n        preUninstallExtension(extension) {\n            return Promise.resolve(pfs.exists(extension.location.fsPath))\n                .then(exists => exists ? null : Promise.reject(new Error(nls.localize('notExists', \"Could not find extension\"))))\n                .then(() => {\n                this.logService.info('Uninstalling extension:', extension.identifier.id);\n                this._onUninstallExtension.fire(extension.identifier);\n            });\n        }\n        uninstallExtension(local) {\n            let promise = this.uninstallingExtensions.get(local.identifier.id);\n            if (!promise) {\n                // Set all versions of the extension as uninstalled\n                promise = async_1.createCancelablePromise(token => this.scanUserExtensions(false)\n                    .then(userExtensions => this.setUninstalled(...userExtensions.filter(u => extensionManagementUtil_1.areSameExtensions(u.identifier, local.identifier))))\n                    .then(() => { this.uninstallingExtensions.delete(local.identifier.id); }));\n                this.uninstallingExtensions.set(local.identifier.id, promise);\n            }\n            return promise;\n        }\n        postUninstallExtension(extension, error) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (error) {\n                    this.logService.error('Failed to uninstall extension:', extension.identifier.id, error.message);\n                }\n                else {\n                    this.logService.info('Successfully uninstalled extension:', extension.identifier.id);\n                    // only report if extension has a mapped gallery extension. UUID identifies the gallery extension.\n                    if (extension.identifier.uuid) {\n                        yield this.galleryService.reportStatistic(extension.manifest.publisher, extension.manifest.name, extension.manifest.version, extensionManagement_1.StatisticType.Uninstall);\n                    }\n                }\n                this.reportTelemetry('extensionGallery:uninstall', extensionManagementUtil_1.getLocalExtensionTelemetryData(extension), undefined, error);\n                const errorcode = error ? error instanceof ExtensionManagementError ? error.code : ERROR_UNKNOWN : undefined;\n                this._onDidUninstallExtension.fire({ identifier: extension.identifier, error: errorcode });\n            });\n        }\n        getInstalled(type = null) {\n            const promises = [];\n            if (type === null || type === extensions_1.ExtensionType.System) {\n                promises.push(this.scanSystemExtensions().then(null, e => Promise.reject(new ExtensionManagementError(this.joinErrors(e).message, ERROR_SCANNING_SYS_EXTENSIONS))));\n            }\n            if (type === null || type === extensions_1.ExtensionType.User) {\n                promises.push(this.scanUserExtensions(true).then(null, e => Promise.reject(new ExtensionManagementError(this.joinErrors(e).message, ERROR_SCANNING_USER_EXTENSIONS))));\n            }\n            return Promise.all(promises).then(arrays_1.flatten, errors => Promise.reject(this.joinErrors(errors)));\n        }\n        scanSystemExtensions() {\n            this.logService.trace('Started scanning system extensions');\n            const systemExtensionsPromise = this.scanExtensions(this.systemExtensionsPath, extensions_1.ExtensionType.System)\n                .then(result => {\n                this.logService.info('Scanned system extensions:', result.length);\n                return result;\n            });\n            if (this.environmentService.isBuilt) {\n                return systemExtensionsPromise;\n            }\n            // Scan other system extensions during development\n            const devSystemExtensionsPromise = this.getDevSystemExtensionsList()\n                .then(devSystemExtensionsList => {\n                if (devSystemExtensionsList.length) {\n                    return this.scanExtensions(this.devSystemExtensionsPath, extensions_1.ExtensionType.System)\n                        .then(result => {\n                        this.logService.info('Scanned dev system extensions:', result.length);\n                        return result.filter(r => devSystemExtensionsList.some(id => extensionManagementUtil_1.areSameExtensions(r.identifier, { id })));\n                    });\n                }\n                else {\n                    return [];\n                }\n            });\n            return Promise.all([systemExtensionsPromise, devSystemExtensionsPromise])\n                .then(([systemExtensions, devSystemExtensions]) => [...systemExtensions, ...devSystemExtensions]);\n        }\n        scanUserExtensions(excludeOutdated) {\n            this.logService.trace('Started scanning user extensions');\n            return Promise.all([this.getUninstalledExtensions(), this.scanExtensions(this.extensionsPath, extensions_1.ExtensionType.User)])\n                .then(([uninstalled, extensions]) => {\n                extensions = extensions.filter(e => !uninstalled[new extensions_1.ExtensionIdentifierWithVersion(e.identifier, e.manifest.version).key()]);\n                if (excludeOutdated) {\n                    const byExtension = extensionManagementUtil_1.groupByExtension(extensions, e => e.identifier);\n                    extensions = byExtension.map(p => p.sort((a, b) => semver.rcompare(a.manifest.version, b.manifest.version))[0]);\n                }\n                this.logService.info('Scanned user extensions:', extensions.length);\n                return extensions;\n            });\n        }\n        scanExtensions(root, type) {\n            const limiter = new async_1.Limiter(10);\n            return pfs.readdir(root)\n                .then(extensionsFolders => Promise.all(extensionsFolders.map(extensionFolder => limiter.queue(() => this.scanExtension(extensionFolder, root, type)))))\n                .then(extensions => extensions.filter(e => e && e.identifier));\n        }\n        scanExtension(folderName, root, type) {\n            if (type === extensions_1.ExtensionType.User && folderName.indexOf('.') === 0) { // Do not consider user extension folder starting with `.`\n                return Promise.resolve(null);\n            }\n            const extensionPath = path.join(root, folderName);\n            return pfs.readdir(extensionPath)\n                .then(children => readManifest(extensionPath)\n                .then(({ manifest, metadata }) => {\n                const readme = children.filter(child => /^readme(\\.txt|\\.md|)$/i.test(child))[0];\n                const readmeUrl = readme ? uri_1.URI.file(path.join(extensionPath, readme)) : null;\n                const changelog = children.filter(child => /^changelog(\\.txt|\\.md|)$/i.test(child))[0];\n                const changelogUrl = changelog ? uri_1.URI.file(path.join(extensionPath, changelog)) : null;\n                const identifier = { id: extensionManagementUtil_1.getGalleryExtensionId(manifest.publisher, manifest.name), uuid: metadata ? metadata.id : null };\n                return { type, identifier, manifest, metadata, location: uri_1.URI.file(extensionPath), readmeUrl, changelogUrl };\n            }))\n                .then(undefined, () => null);\n        }\n        removeDeprecatedExtensions() {\n            return this.removeUninstalledExtensions()\n                .then(() => this.removeOutdatedExtensions());\n        }\n        removeUninstalledExtensions() {\n            return this.getUninstalledExtensions()\n                .then(uninstalled => this.scanExtensions(this.extensionsPath, extensions_1.ExtensionType.User) // All user extensions\n                .then(extensions => {\n                const toRemove = extensions.filter(e => uninstalled[new extensions_1.ExtensionIdentifierWithVersion(e.identifier, e.manifest.version).key()]);\n                return Promise.all(toRemove.map(e => this.extensionLifecycle.postUninstall(e).then(() => this.removeUninstalledExtension(e))));\n            })).then(() => undefined);\n        }\n        removeOutdatedExtensions() {\n            return this.scanExtensions(this.extensionsPath, extensions_1.ExtensionType.User) // All user extensions\n                .then(extensions => {\n                const toRemove = [];\n                // Outdated extensions\n                const byExtension = extensionManagementUtil_1.groupByExtension(extensions, e => e.identifier);\n                toRemove.push(...arrays_1.flatten(byExtension.map(p => p.sort((a, b) => semver.rcompare(a.manifest.version, b.manifest.version)).slice(1))));\n                return Promise.all(toRemove.map(extension => this.removeExtension(extension, 'outdated')));\n            }).then(() => undefined);\n        }\n        removeUninstalledExtension(extension) {\n            return this.removeExtension(extension, 'uninstalled')\n                .then(() => this.withUninstalledExtensions(uninstalled => delete uninstalled[new extensions_1.ExtensionIdentifierWithVersion(extension.identifier, extension.manifest.version).key()]))\n                .then(() => undefined);\n        }\n        removeExtension(extension, type) {\n            this.logService.trace(`Deleting ${type} extension from disk`, extension.identifier.id, extension.location.fsPath);\n            return pfs.rimraf(extension.location.fsPath).then(() => this.logService.info('Deleted from disk', extension.identifier.id, extension.location.fsPath));\n        }\n        isUninstalled(identfier) {\n            return this.filterUninstalled(identfier).then(uninstalled => uninstalled.length === 1);\n        }\n        filterUninstalled(...identifiers) {\n            return this.withUninstalledExtensions(allUninstalled => {\n                const uninstalled = [];\n                for (const identifier of identifiers) {\n                    if (!!allUninstalled[identifier.key()]) {\n                        uninstalled.push(identifier.key());\n                    }\n                }\n                return uninstalled;\n            });\n        }\n        setUninstalled(...extensions) {\n            const ids = extensions.map(e => new extensions_1.ExtensionIdentifierWithVersion(e.identifier, e.manifest.version));\n            return this.withUninstalledExtensions(uninstalled => objects_1.assign(uninstalled, ids.reduce((result, id) => { result[id.key()] = true; return result; }, {})));\n        }\n        unsetUninstalled(extensionIdentifier) {\n            return this.withUninstalledExtensions(uninstalled => delete uninstalled[extensionIdentifier.key()]);\n        }\n        getUninstalledExtensions() {\n            return this.withUninstalledExtensions(uninstalled => uninstalled);\n        }\n        withUninstalledExtensions(fn) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return yield this.uninstalledFileLimiter.queue(() => {\n                    let result = null;\n                    return pfs.readFile(this.uninstalledPath, 'utf8')\n                        .then(undefined, err => err.code === 'ENOENT' ? Promise.resolve('{}') : Promise.reject(err))\n                        .then(raw => { try {\n                        return JSON.parse(raw);\n                    }\n                    catch (e) {\n                        return {};\n                    } })\n                        .then(uninstalled => { result = fn(uninstalled); return uninstalled; })\n                        .then(uninstalled => {\n                        if (Object.keys(uninstalled).length === 0) {\n                            return pfs.rimraf(this.uninstalledPath);\n                        }\n                        else {\n                            const raw = JSON.stringify(uninstalled);\n                            return pfs.writeFile(this.uninstalledPath, raw);\n                        }\n                    })\n                        .then(() => result);\n                });\n            });\n        }\n        getExtensionsReport() {\n            const now = new Date().getTime();\n            if (!this.reportedExtensions || now - this.lastReportTimestamp > 1000 * 60 * 5) { // 5 minute cache freshness\n                this.reportedExtensions = this.updateReportCache();\n                this.lastReportTimestamp = now;\n            }\n            return this.reportedExtensions;\n        }\n        updateReportCache() {\n            this.logService.trace('ExtensionManagementService.refreshReportedCache');\n            return this.galleryService.getExtensionsReport()\n                .then(result => {\n                this.logService.trace(`ExtensionManagementService.refreshReportedCache - got ${result.length} reported extensions from service`);\n                return result;\n            }, err => {\n                this.logService.trace('ExtensionManagementService.refreshReportedCache - failed to get extension report');\n                return [];\n            });\n        }\n        get devSystemExtensionsPath() {\n            if (!this._devSystemExtensionsPath) {\n                this._devSystemExtensionsPath = path.normalize(path.join(amd_1.getPathFromAmdModule(require, ''), '..', '.build', 'builtInExtensions'));\n            }\n            return this._devSystemExtensionsPath;\n        }\n        get devSystemExtensionsFilePath() {\n            if (!this._devSystemExtensionsFilePath) {\n                this._devSystemExtensionsFilePath = path.normalize(path.join(amd_1.getPathFromAmdModule(require, ''), '..', 'build', 'builtInExtensions.json'));\n            }\n            return this._devSystemExtensionsFilePath;\n        }\n        getDevSystemExtensionsList() {\n            return pfs.readFile(this.devSystemExtensionsFilePath, 'utf8')\n                .then(raw => {\n                const parsed = JSON.parse(raw);\n                return parsed.map(({ name }) => name);\n            });\n        }\n        toNonCancellablePromise(promise) {\n            return new Promise((c, e) => promise.then(result => c(result), error => e(error)));\n        }\n        reportTelemetry(eventName, extensionData, duration, error) {\n            const errorcode = error ? error instanceof ExtensionManagementError ? error.code : ERROR_UNKNOWN : undefined;\n            /* __GDPR__\n                \"extensionGallery:install\" : {\n                    \"success\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                    \"duration\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                    \"errorcode\": { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\" },\n                    \"recommendationReason\": { \"retiredFromVersion\": \"1.23.0\", \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                    \"${include}\": [\n                        \"${GalleryExtensionTelemetryData}\"\n                    ]\n                }\n            */\n            /* __GDPR__\n                \"extensionGallery:uninstall\" : {\n                    \"success\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                    \"duration\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                    \"errorcode\": { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\" },\n                    \"${include}\": [\n                        \"${GalleryExtensionTelemetryData}\"\n                    ]\n                }\n            */\n            /* __GDPR__\n                \"extensionGallery:update\" : {\n                    \"success\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                    \"duration\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                    \"errorcode\": { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\" },\n                    \"${include}\": [\n                        \"${GalleryExtensionTelemetryData}\"\n                    ]\n                }\n            */\n            this.telemetryService.publicLog(eventName, objects_1.assign(extensionData, { success: !error, duration, errorcode }));\n        }\n    };\n    ExtensionManagementService = __decorate([\n        __param(1, environment_1.IEnvironmentService),\n        __param(2, configuration_1.IConfigurationService),\n        __param(3, extensionManagement_1.IExtensionGalleryService),\n        __param(4, log_1.ILogService),\n        __param(5, instantiation_1.optional(download_1.IDownloadService)),\n        __param(6, telemetry_1.ITelemetryService)\n    ], ExtensionManagementService);\n    exports.ExtensionManagementService = ExtensionManagementService;\n});\n",null]}