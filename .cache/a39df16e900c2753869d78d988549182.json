{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/code/electron-browser/sharedProcess/sharedProcessMain.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/code/electron-browser/sharedProcess/sharedProcessMain.ts","mtime":1555846338028},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"fs\", \"vs/base/common/platform\", \"vs/platform/product/node/product\", \"vs/platform/product/node/package\", \"vs/base/parts/ipc/node/ipc.net\", \"vs/platform/instantiation/common/serviceCollection\", \"vs/platform/instantiation/common/descriptors\", \"vs/platform/instantiation/common/instantiationService\", \"vs/platform/environment/common/environment\", \"vs/platform/environment/node/environmentService\", \"vs/platform/extensionManagement/node/extensionManagementIpc\", \"vs/platform/extensionManagement/common/extensionManagement\", \"vs/platform/extensionManagement/node/extensionManagementService\", \"vs/platform/extensionManagement/node/extensionGalleryService\", \"vs/platform/configuration/common/configuration\", \"vs/platform/configuration/node/configurationService\", \"vs/platform/request/node/request\", \"vs/platform/request/electron-browser/requestService\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/telemetry/common/telemetryUtils\", \"vs/platform/telemetry/node/commonProperties\", \"vs/platform/telemetry/node/telemetryIpc\", \"vs/platform/telemetry/common/telemetryService\", \"vs/platform/telemetry/node/appInsightsAppender\", \"vs/platform/windows/common/windows\", \"vs/platform/windows/electron-browser/windowsService\", \"electron\", \"vs/platform/log/node/spdlogService\", \"vs/platform/log/common/log\", \"vs/platform/log/node/logIpc\", \"vs/platform/localizations/node/localizations\", \"vs/platform/localizations/common/localizations\", \"vs/platform/localizations/node/localizationsIpc\", \"vs/platform/dialogs/node/dialogIpc\", \"vs/platform/dialogs/common/dialogs\", \"vs/base/common/lifecycle\", \"vs/platform/download/node/downloadService\", \"vs/platform/download/common/download\", \"vs/base/parts/ipc/common/ipc\", \"vs/code/electron-browser/sharedProcess/contrib/nodeCachedDataCleaner\", \"vs/code/electron-browser/sharedProcess/contrib/languagePackCachedDataCleaner\", \"vs/code/electron-browser/sharedProcess/contrib/storageDataCleaner\", \"vs/code/electron-browser/sharedProcess/contrib/logsDataCleaner\", \"vs/platform/ipc/electron-browser/mainProcessService\", \"vs/platform/backup/electron-main/backupMainService\", \"vs/base/node/pfs\"], function (require, exports, fs, platform, product_1, package_1, ipc_net_1, serviceCollection_1, descriptors_1, instantiationService_1, environment_1, environmentService_1, extensionManagementIpc_1, extensionManagement_1, extensionManagementService_1, extensionGalleryService_1, configuration_1, configurationService_1, request_1, requestService_1, telemetry_1, telemetryUtils_1, commonProperties_1, telemetryIpc_1, telemetryService_1, appInsightsAppender_1, windows_1, windowsService_1, electron_1, spdlogService_1, log_1, logIpc_1, localizations_1, localizations_2, localizationsIpc_1, dialogIpc_1, dialogs_1, lifecycle_1, downloadService_1, download_1, ipc_1, nodeCachedDataCleaner_1, languagePackCachedDataCleaner_1, storageDataCleaner_1, logsDataCleaner_1, mainProcessService_1, backupMainService_1, pfs_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function startup(configuration) {\n        handshake(configuration);\n    }\n    exports.startup = startup;\n    const eventPrefix = 'monacoworkbench';\n    class MainProcessService {\n        constructor(server, mainRouter) {\n            this.server = server;\n            this.mainRouter = mainRouter;\n        }\n        getChannel(channelName) {\n            return this.server.getChannel(channelName, this.mainRouter);\n        }\n        registerChannel(channelName, channel) {\n            this.server.registerChannel(channelName, channel);\n        }\n    }\n    function main(server, initData, configuration) {\n        const services = new serviceCollection_1.ServiceCollection();\n        const disposables = [];\n        const onExit = () => lifecycle_1.dispose(disposables);\n        process.once('exit', onExit);\n        electron_1.ipcRenderer.once('handshake:goodbye', onExit);\n        disposables.push(server);\n        const environmentService = new environmentService_1.EnvironmentService(initData.args, process.execPath);\n        Promise.all([\n            environmentService.extensionsPath,\n            environmentService.nodeCachedDataDir,\n            environmentService.logsPath,\n            environmentService.globalStorageHome,\n            environmentService.workspaceStorageHome,\n            environmentService.backupHome\n        ].map((path) => path ? pfs_1.mkdirp(path) : undefined));\n        const mainRouter = new ipc_1.StaticRouter(ctx => ctx === 'main');\n        const logLevelClient = new logIpc_1.LogLevelSetterChannelClient(server.getChannel('loglevel', mainRouter));\n        const logService = new logIpc_1.FollowerLogService(logLevelClient, spdlogService_1.createSpdLogService('sharedprocess', initData.logLevel, environmentService.logsPath));\n        disposables.push(logService);\n        logService.info('main', JSON.stringify(configuration));\n        services.set(environment_1.IEnvironmentService, environmentService);\n        services.set(log_1.ILogService, logService);\n        services.set(configuration_1.IConfigurationService, new descriptors_1.SyncDescriptor(configurationService_1.ConfigurationService));\n        services.set(request_1.IRequestService, new descriptors_1.SyncDescriptor(requestService_1.RequestService));\n        services.set(download_1.IDownloadService, new descriptors_1.SyncDescriptor(downloadService_1.DownloadService));\n        const mainProcessService = new MainProcessService(server, mainRouter);\n        services.set(mainProcessService_1.IMainProcessService, mainProcessService);\n        const windowsService = new windowsService_1.WindowsService(mainProcessService);\n        services.set(windows_1.IWindowsService, windowsService);\n        const activeWindowManager = new windows_1.ActiveWindowManager(windowsService);\n        const activeWindowRouter = new ipc_1.StaticRouter(ctx => activeWindowManager.getActiveClientId().then(id => ctx === id));\n        const dialogChannel = server.getChannel('dialog', activeWindowRouter);\n        services.set(dialogs_1.IDialogService, new dialogIpc_1.DialogChannelClient(dialogChannel));\n        const instantiationService = new instantiationService_1.InstantiationService(services);\n        const backupMainService = instantiationService.createInstance(backupMainService_1.BackupMainService);\n        backupMainService.initialize().catch(console.error);\n        instantiationService.invokeFunction(accessor => {\n            const services = new serviceCollection_1.ServiceCollection();\n            const environmentService = accessor.get(environment_1.IEnvironmentService);\n            const { appRoot, extensionsPath, extensionDevelopmentLocationURI, isBuilt, installSourcePath } = environmentService;\n            const telemetryLogService = new logIpc_1.FollowerLogService(logLevelClient, spdlogService_1.createSpdLogService('telemetry', initData.logLevel, environmentService.logsPath));\n            telemetryLogService.info('The below are logs for every telemetry event sent from VS Code once the log level is set to trace.');\n            telemetryLogService.info('===========================================================');\n            let appInsightsAppender = telemetryUtils_1.NullAppender;\n            if (!extensionDevelopmentLocationURI && !environmentService.args['disable-telemetry'] && product_1.default.enableTelemetry) {\n                if (product_1.default.aiConfig && product_1.default.aiConfig.asimovKey && isBuilt) {\n                    appInsightsAppender = new appInsightsAppender_1.AppInsightsAppender(eventPrefix, null, product_1.default.aiConfig.asimovKey, telemetryLogService);\n                    disposables.push(appInsightsAppender); // Ensure the AI appender is disposed so that it flushes remaining data\n                }\n                const config = {\n                    appender: telemetryUtils_1.combinedAppender(appInsightsAppender, new telemetryUtils_1.LogAppender(logService)),\n                    commonProperties: commonProperties_1.resolveCommonProperties(product_1.default.commit, package_1.default.version, configuration.machineId, installSourcePath),\n                    piiPaths: [appRoot, extensionsPath]\n                };\n                services.set(telemetry_1.ITelemetryService, new descriptors_1.SyncDescriptor(telemetryService_1.TelemetryService, [config]));\n            }\n            else {\n                services.set(telemetry_1.ITelemetryService, telemetryUtils_1.NullTelemetryService);\n            }\n            server.registerChannel('telemetryAppender', new telemetryIpc_1.TelemetryAppenderChannel(appInsightsAppender));\n            services.set(extensionManagement_1.IExtensionManagementService, new descriptors_1.SyncDescriptor(extensionManagementService_1.ExtensionManagementService, [false]));\n            services.set(extensionManagement_1.IExtensionGalleryService, new descriptors_1.SyncDescriptor(extensionGalleryService_1.ExtensionGalleryService));\n            services.set(localizations_2.ILocalizationsService, new descriptors_1.SyncDescriptor(localizations_1.LocalizationsService));\n            const instantiationService2 = instantiationService.createChild(services);\n            instantiationService2.invokeFunction(accessor => {\n                const extensionManagementService = accessor.get(extensionManagement_1.IExtensionManagementService);\n                const channel = new extensionManagementIpc_1.ExtensionManagementChannel(extensionManagementService, () => null);\n                server.registerChannel('extensions', channel);\n                const localizationsService = accessor.get(localizations_2.ILocalizationsService);\n                const localizationsChannel = new localizationsIpc_1.LocalizationsChannel(localizationsService);\n                server.registerChannel('localizations', localizationsChannel);\n                // clean up deprecated extensions\n                extensionManagementService.removeDeprecatedExtensions();\n                // update localizations cache\n                localizationsService.update();\n                // cache clean ups\n                disposables.push(lifecycle_1.combinedDisposable([\n                    instantiationService2.createInstance(nodeCachedDataCleaner_1.NodeCachedDataCleaner),\n                    instantiationService2.createInstance(languagePackCachedDataCleaner_1.LanguagePackCachedDataCleaner),\n                    instantiationService2.createInstance(storageDataCleaner_1.StorageDataCleaner),\n                    instantiationService2.createInstance(logsDataCleaner_1.LogsDataCleaner)\n                ]));\n                disposables.push(extensionManagementService);\n            });\n        });\n    }\n    function setupIPC(hook) {\n        function setup(retry) {\n            return ipc_net_1.serve(hook).then(null, err => {\n                if (!retry || platform.isWindows || err.code !== 'EADDRINUSE') {\n                    return Promise.reject(err);\n                }\n                // should retry, not windows and eaddrinuse\n                return ipc_net_1.connect(hook, '').then(client => {\n                    // we could connect to a running instance. this is not good, abort\n                    client.dispose();\n                    return Promise.reject(new Error('There is an instance already running.'));\n                }, err => {\n                    // it happens on Linux and OS X that the pipe is left behind\n                    // let's delete it, since we can't connect to it\n                    // and the retry the whole thing\n                    try {\n                        fs.unlinkSync(hook);\n                    }\n                    catch (e) {\n                        return Promise.reject(new Error('Error deleting the shared ipc hook.'));\n                    }\n                    return setup(false);\n                });\n            });\n        }\n        return setup(true);\n    }\n    function handshake(configuration) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = yield new Promise(c => {\n                electron_1.ipcRenderer.once('handshake:hey there', (_, r) => c(r));\n                electron_1.ipcRenderer.send('handshake:hello');\n            });\n            const server = yield setupIPC(data.sharedIPCHandle);\n            main(server, data, configuration);\n            electron_1.ipcRenderer.send('handshake:im ready');\n        });\n    }\n    startup({ machineId: \"1\" });\n});\n",null]}