{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostQuickOpen.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostQuickOpen.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/async\", \"vs/base/common/cancellation\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"../common/extHost.protocol\", \"vs/base/common/uri\", \"vs/workbench/api/node/extHostTypes\", \"vs/base/common/errors\", \"vs/base/common/arrays\"], function (require, exports, async_1, cancellation_1, event_1, lifecycle_1, extHost_protocol_1, uri_1, extHostTypes_1, errors_1, arrays_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class ExtHostQuickOpen {\n        constructor(mainContext, workspace, commands) {\n            this._sessions = new Map();\n            this._instances = 0;\n            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadQuickOpen);\n            this._workspace = workspace;\n            this._commands = commands;\n        }\n        showQuickPick(itemsOrItemsPromise, enableProposedApi, options, token = cancellation_1.CancellationToken.None) {\n            // clear state from last invocation\n            this._onDidSelectItem = undefined;\n            const itemsPromise = Promise.resolve(itemsOrItemsPromise);\n            const instance = ++this._instances;\n            const quickPickWidget = this._proxy.$show(instance, {\n                placeHolder: options && options.placeHolder,\n                matchOnDescription: options && options.matchOnDescription,\n                matchOnDetail: options && options.matchOnDetail,\n                ignoreFocusLost: options && options.ignoreFocusOut,\n                canPickMany: options && options.canPickMany\n            }, token);\n            const widgetClosedMarker = {};\n            const widgetClosedPromise = quickPickWidget.then(() => widgetClosedMarker);\n            return Promise.race([widgetClosedPromise, itemsPromise]).then(result => {\n                if (result === widgetClosedMarker) {\n                    return undefined;\n                }\n                return itemsPromise.then(items => {\n                    const pickItems = [];\n                    for (let handle = 0; handle < items.length; handle++) {\n                        const item = items[handle];\n                        let label;\n                        let description;\n                        let detail;\n                        let picked;\n                        let alwaysShow;\n                        if (typeof item === 'string') {\n                            label = item;\n                        }\n                        else {\n                            label = item.label;\n                            description = item.description;\n                            detail = item.detail;\n                            picked = item.picked;\n                            alwaysShow = item.alwaysShow;\n                        }\n                        pickItems.push({\n                            label,\n                            description,\n                            handle,\n                            detail,\n                            picked,\n                            alwaysShow\n                        });\n                    }\n                    // handle selection changes\n                    if (options && typeof options.onDidSelectItem === 'function') {\n                        this._onDidSelectItem = (handle) => {\n                            options.onDidSelectItem(items[handle]);\n                        };\n                    }\n                    // show items\n                    this._proxy.$setItems(instance, pickItems);\n                    return quickPickWidget.then(handle => {\n                        if (typeof handle === 'number') {\n                            return items[handle];\n                        }\n                        else if (Array.isArray(handle)) {\n                            return handle.map(h => items[h]);\n                        }\n                        return undefined;\n                    });\n                });\n            }).then(undefined, err => {\n                if (errors_1.isPromiseCanceledError(err)) {\n                    return undefined;\n                }\n                this._proxy.$setError(instance, err);\n                return Promise.reject(err);\n            });\n        }\n        $onItemSelected(handle) {\n            if (this._onDidSelectItem) {\n                this._onDidSelectItem(handle);\n            }\n        }\n        // ---- input\n        showInput(options, token = cancellation_1.CancellationToken.None) {\n            // global validate fn used in callback below\n            this._validateInput = options ? options.validateInput : undefined;\n            return this._proxy.$input(options, typeof this._validateInput === 'function', token)\n                .then(undefined, err => {\n                if (errors_1.isPromiseCanceledError(err)) {\n                    return undefined;\n                }\n                return Promise.reject(err);\n            });\n        }\n        $validateInput(input) {\n            if (this._validateInput) {\n                return async_1.asPromise(() => this._validateInput(input));\n            }\n            return Promise.resolve(undefined);\n        }\n        // ---- workspace folder picker\n        showWorkspaceFolderPick(options, token = cancellation_1.CancellationToken.None) {\n            return this._commands.executeCommand('_workbench.pickWorkspaceFolder', [options]).then((selectedFolder) => __awaiter(this, void 0, void 0, function* () {\n                if (!selectedFolder) {\n                    return undefined;\n                }\n                const workspaceFolders = yield this._workspace.getWorkspaceFolders2();\n                if (!workspaceFolders) {\n                    return undefined;\n                }\n                return workspaceFolders.filter(folder => folder.uri.toString() === selectedFolder.uri.toString())[0];\n            }));\n        }\n        // ---- QuickInput\n        createQuickPick(extensionId, enableProposedApi) {\n            const session = new ExtHostQuickPick(this._proxy, extensionId, enableProposedApi, () => this._sessions.delete(session._id));\n            this._sessions.set(session._id, session);\n            return session;\n        }\n        createInputBox(extensionId) {\n            const session = new ExtHostInputBox(this._proxy, extensionId, () => this._sessions.delete(session._id));\n            this._sessions.set(session._id, session);\n            return session;\n        }\n        $onDidChangeValue(sessionId, value) {\n            const session = this._sessions.get(sessionId);\n            if (session) {\n                session._fireDidChangeValue(value);\n            }\n        }\n        $onDidAccept(sessionId) {\n            const session = this._sessions.get(sessionId);\n            if (session) {\n                session._fireDidAccept();\n            }\n        }\n        $onDidChangeActive(sessionId, handles) {\n            const session = this._sessions.get(sessionId);\n            if (session instanceof ExtHostQuickPick) {\n                session._fireDidChangeActive(handles);\n            }\n        }\n        $onDidChangeSelection(sessionId, handles) {\n            const session = this._sessions.get(sessionId);\n            if (session instanceof ExtHostQuickPick) {\n                session._fireDidChangeSelection(handles);\n            }\n        }\n        $onDidTriggerButton(sessionId, handle) {\n            const session = this._sessions.get(sessionId);\n            if (session) {\n                session._fireDidTriggerButton(handle);\n            }\n        }\n        $onDidHide(sessionId) {\n            const session = this._sessions.get(sessionId);\n            if (session) {\n                session._fireDidHide();\n            }\n        }\n    }\n    exports.ExtHostQuickOpen = ExtHostQuickOpen;\n    class ExtHostQuickInput {\n        constructor(_proxy, _extensionId, _onDidDispose) {\n            this._proxy = _proxy;\n            this._extensionId = _extensionId;\n            this._onDidDispose = _onDidDispose;\n            this._id = ExtHostQuickPick._nextId++;\n            this._visible = false;\n            this._expectingHide = false;\n            this._enabled = true;\n            this._busy = false;\n            this._ignoreFocusOut = true;\n            this._value = '';\n            this._buttons = [];\n            this._handlesToButtons = new Map();\n            this._onDidAcceptEmitter = new event_1.Emitter();\n            this._onDidChangeValueEmitter = new event_1.Emitter();\n            this._onDidTriggerButtonEmitter = new event_1.Emitter();\n            this._onDidHideEmitter = new event_1.Emitter();\n            this._pendingUpdate = { id: this._id };\n            this._disposed = false;\n            this._disposables = [\n                this._onDidTriggerButtonEmitter,\n                this._onDidHideEmitter,\n                this._onDidAcceptEmitter,\n                this._onDidChangeValueEmitter\n            ];\n            this.onDidChangeValue = this._onDidChangeValueEmitter.event;\n            this.onDidAccept = this._onDidAcceptEmitter.event;\n            this.onDidTriggerButton = this._onDidTriggerButtonEmitter.event;\n            this.onDidHide = this._onDidHideEmitter.event;\n        }\n        get title() {\n            return this._title;\n        }\n        set title(title) {\n            this._title = title;\n            this.update({ title });\n        }\n        get step() {\n            return this._steps;\n        }\n        set step(step) {\n            this._steps = step;\n            this.update({ step });\n        }\n        get totalSteps() {\n            return this._totalSteps;\n        }\n        set totalSteps(totalSteps) {\n            this._totalSteps = totalSteps;\n            this.update({ totalSteps });\n        }\n        get enabled() {\n            return this._enabled;\n        }\n        set enabled(enabled) {\n            this._enabled = enabled;\n            this.update({ enabled });\n        }\n        get busy() {\n            return this._busy;\n        }\n        set busy(busy) {\n            this._busy = busy;\n            this.update({ busy });\n        }\n        get ignoreFocusOut() {\n            return this._ignoreFocusOut;\n        }\n        set ignoreFocusOut(ignoreFocusOut) {\n            this._ignoreFocusOut = ignoreFocusOut;\n            this.update({ ignoreFocusOut });\n        }\n        get value() {\n            return this._value;\n        }\n        set value(value) {\n            this._value = value;\n            this.update({ value });\n        }\n        get placeholder() {\n            return this._placeholder;\n        }\n        set placeholder(placeholder) {\n            this._placeholder = placeholder;\n            this.update({ placeholder });\n        }\n        get buttons() {\n            return this._buttons;\n        }\n        set buttons(buttons) {\n            this._buttons = buttons.slice();\n            this._handlesToButtons.clear();\n            buttons.forEach((button, i) => {\n                const handle = button === extHostTypes_1.QuickInputButtons.Back ? -1 : i;\n                this._handlesToButtons.set(handle, button);\n            });\n            this.update({\n                buttons: buttons.map((button, i) => ({\n                    iconPath: getIconUris(button.iconPath),\n                    tooltip: button.tooltip,\n                    handle: button === extHostTypes_1.QuickInputButtons.Back ? -1 : i,\n                }))\n            });\n        }\n        show() {\n            this._visible = true;\n            this._expectingHide = true;\n            this.update({ visible: true });\n        }\n        hide() {\n            this._visible = false;\n            this.update({ visible: false });\n        }\n        _fireDidAccept() {\n            this._onDidAcceptEmitter.fire();\n        }\n        _fireDidChangeValue(value) {\n            this._value = value;\n            this._onDidChangeValueEmitter.fire(value);\n        }\n        _fireDidTriggerButton(handle) {\n            const button = this._handlesToButtons.get(handle);\n            if (button) {\n                this._onDidTriggerButtonEmitter.fire(button);\n            }\n        }\n        _fireDidHide() {\n            if (this._expectingHide) {\n                this._expectingHide = false;\n                this._onDidHideEmitter.fire();\n            }\n        }\n        dispose() {\n            if (this._disposed) {\n                return;\n            }\n            this._disposed = true;\n            this._fireDidHide();\n            this._disposables = lifecycle_1.dispose(this._disposables);\n            if (this._updateTimeout) {\n                clearTimeout(this._updateTimeout);\n                this._updateTimeout = undefined;\n            }\n            this._onDidDispose();\n            this._proxy.$dispose(this._id);\n        }\n        update(properties) {\n            if (this._disposed) {\n                return;\n            }\n            for (const key of Object.keys(properties)) {\n                const value = properties[key];\n                this._pendingUpdate[key] = value === undefined ? null : value;\n            }\n            if ('visible' in this._pendingUpdate) {\n                if (this._updateTimeout) {\n                    clearTimeout(this._updateTimeout);\n                    this._updateTimeout = undefined;\n                }\n                this.dispatchUpdate();\n            }\n            else if (this._visible && !this._updateTimeout) {\n                // Defer the update so that multiple changes to setters dont cause a redraw each\n                this._updateTimeout = setTimeout(() => {\n                    this._updateTimeout = undefined;\n                    this.dispatchUpdate();\n                }, 0);\n            }\n        }\n        dispatchUpdate() {\n            this._proxy.$createOrUpdate(this._pendingUpdate);\n            this._pendingUpdate = { id: this._id };\n        }\n    }\n    ExtHostQuickInput._nextId = 1;\n    function getIconUris(iconPath) {\n        const dark = getDarkIconUri(iconPath);\n        const light = getLightIconUri(iconPath);\n        if (!light && !dark) {\n            return undefined;\n        }\n        return { dark: (dark || light), light };\n    }\n    function getLightIconUri(iconPath) {\n        if (iconPath && !(iconPath instanceof extHostTypes_1.ThemeIcon)) {\n            if (typeof iconPath === 'string'\n                || iconPath instanceof uri_1.URI) {\n                return getIconUri(iconPath);\n            }\n            return getIconUri(iconPath['light']);\n        }\n        return undefined;\n    }\n    function getDarkIconUri(iconPath) {\n        if (iconPath && !(iconPath instanceof extHostTypes_1.ThemeIcon) && iconPath['dark']) {\n            return getIconUri(iconPath['dark']);\n        }\n        return undefined;\n    }\n    function getIconUri(iconPath) {\n        if (iconPath instanceof uri_1.URI) {\n            return iconPath;\n        }\n        return uri_1.URI.file(iconPath);\n    }\n    class ExtHostQuickPick extends ExtHostQuickInput {\n        constructor(proxy, extensionId, enableProposedApi, onDispose) {\n            super(proxy, extensionId, onDispose);\n            this._items = [];\n            this._handlesToItems = new Map();\n            this._itemsToHandles = new Map();\n            this._canSelectMany = false;\n            this._matchOnDescription = true;\n            this._matchOnDetail = true;\n            this._activeItems = [];\n            this._onDidChangeActiveEmitter = new event_1.Emitter();\n            this._selectedItems = [];\n            this._onDidChangeSelectionEmitter = new event_1.Emitter();\n            this.onDidChangeActive = this._onDidChangeActiveEmitter.event;\n            this.onDidChangeSelection = this._onDidChangeSelectionEmitter.event;\n            this._disposables.push(this._onDidChangeActiveEmitter, this._onDidChangeSelectionEmitter);\n            this.update({ type: 'quickPick' });\n        }\n        get items() {\n            return this._items;\n        }\n        set items(items) {\n            this._items = items.slice();\n            this._handlesToItems.clear();\n            this._itemsToHandles.clear();\n            items.forEach((item, i) => {\n                this._handlesToItems.set(i, item);\n                this._itemsToHandles.set(item, i);\n            });\n            this.update({\n                items: items.map((item, i) => ({\n                    label: item.label,\n                    description: item.description,\n                    handle: i,\n                    detail: item.detail,\n                    picked: item.picked,\n                    alwaysShow: item.alwaysShow\n                }))\n            });\n        }\n        get canSelectMany() {\n            return this._canSelectMany;\n        }\n        set canSelectMany(canSelectMany) {\n            this._canSelectMany = canSelectMany;\n            this.update({ canSelectMany });\n        }\n        get matchOnDescription() {\n            return this._matchOnDescription;\n        }\n        set matchOnDescription(matchOnDescription) {\n            this._matchOnDescription = matchOnDescription;\n            this.update({ matchOnDescription });\n        }\n        get matchOnDetail() {\n            return this._matchOnDetail;\n        }\n        set matchOnDetail(matchOnDetail) {\n            this._matchOnDetail = matchOnDetail;\n            this.update({ matchOnDetail });\n        }\n        get activeItems() {\n            return this._activeItems;\n        }\n        set activeItems(activeItems) {\n            this._activeItems = activeItems.filter(item => this._itemsToHandles.has(item));\n            this.update({ activeItems: this._activeItems.map(item => this._itemsToHandles.get(item)) });\n        }\n        get selectedItems() {\n            return this._selectedItems;\n        }\n        set selectedItems(selectedItems) {\n            this._selectedItems = selectedItems.filter(item => this._itemsToHandles.has(item));\n            this.update({ selectedItems: this._selectedItems.map(item => this._itemsToHandles.get(item)) });\n        }\n        _fireDidChangeActive(handles) {\n            const items = arrays_1.coalesce(handles.map(handle => this._handlesToItems.get(handle)));\n            this._activeItems = items;\n            this._onDidChangeActiveEmitter.fire(items);\n        }\n        _fireDidChangeSelection(handles) {\n            const items = arrays_1.coalesce(handles.map(handle => this._handlesToItems.get(handle)));\n            this._selectedItems = items;\n            this._onDidChangeSelectionEmitter.fire(items);\n        }\n    }\n    class ExtHostInputBox extends ExtHostQuickInput {\n        constructor(proxy, extensionId, onDispose) {\n            super(proxy, extensionId, onDispose);\n            this.update({ type: 'inputBox' });\n        }\n        get password() {\n            return this._password;\n        }\n        set password(password) {\n            this._password = password;\n            this.update({ password });\n        }\n        get prompt() {\n            return this._prompt;\n        }\n        set prompt(prompt) {\n            this._prompt = prompt;\n            this.update({ prompt });\n        }\n        get validationMessage() {\n            return this._validationMessage;\n        }\n        set validationMessage(validationMessage) {\n            this._validationMessage = validationMessage;\n            this.update({ validationMessage });\n        }\n    }\n});\n",null]}