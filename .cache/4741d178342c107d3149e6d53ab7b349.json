{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/links/getLinks.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/links/getLinks.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/cancellation\", \"vs/base/common/errors\", \"vs/base/common/uri\", \"vs/editor/common/core/range\", \"vs/editor/common/modes\", \"vs/editor/common/services/modelService\", \"vs/platform/commands/common/commands\"], function (require, exports, cancellation_1, errors_1, uri_1, range_1, modes_1, modelService_1, commands_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class Link {\n        constructor(link, provider) {\n            this._link = link;\n            this._provider = provider;\n        }\n        toJSON() {\n            return {\n                range: this.range,\n                url: this.url\n            };\n        }\n        get range() {\n            return this._link.range;\n        }\n        get url() {\n            return this._link.url;\n        }\n        resolve(token) {\n            if (this._link.url) {\n                try {\n                    if (typeof this._link.url === 'string') {\n                        return Promise.resolve(uri_1.URI.parse(this._link.url));\n                    }\n                    else {\n                        return Promise.resolve(this._link.url);\n                    }\n                }\n                catch (e) {\n                    return Promise.reject(new Error('invalid'));\n                }\n            }\n            if (typeof this._provider.resolveLink === 'function') {\n                return Promise.resolve(this._provider.resolveLink(this._link, token)).then(value => {\n                    this._link = value || this._link;\n                    if (this._link.url) {\n                        // recurse\n                        return this.resolve(token);\n                    }\n                    return Promise.reject(new Error('missing'));\n                });\n            }\n            return Promise.reject(new Error('missing'));\n        }\n    }\n    exports.Link = Link;\n    function getLinks(model, token) {\n        let links = [];\n        // ask all providers for links in parallel\n        const promises = modes_1.LinkProviderRegistry.ordered(model).reverse().map(provider => {\n            return Promise.resolve(provider.provideLinks(model, token)).then(result => {\n                if (Array.isArray(result)) {\n                    const newLinks = result.map(link => new Link(link, provider));\n                    links = union(links, newLinks);\n                }\n            }, errors_1.onUnexpectedExternalError);\n        });\n        return Promise.all(promises).then(() => {\n            return links;\n        });\n    }\n    exports.getLinks = getLinks;\n    function union(oldLinks, newLinks) {\n        // reunite oldLinks with newLinks and remove duplicates\n        let result = [];\n        let oldIndex;\n        let oldLen;\n        let newIndex;\n        let newLen;\n        for (oldIndex = 0, newIndex = 0, oldLen = oldLinks.length, newLen = newLinks.length; oldIndex < oldLen && newIndex < newLen;) {\n            const oldLink = oldLinks[oldIndex];\n            const newLink = newLinks[newIndex];\n            if (range_1.Range.areIntersectingOrTouching(oldLink.range, newLink.range)) {\n                // Remove the oldLink\n                oldIndex++;\n                continue;\n            }\n            const comparisonResult = range_1.Range.compareRangesUsingStarts(oldLink.range, newLink.range);\n            if (comparisonResult < 0) {\n                // oldLink is before\n                result.push(oldLink);\n                oldIndex++;\n            }\n            else {\n                // newLink is before\n                result.push(newLink);\n                newIndex++;\n            }\n        }\n        for (; oldIndex < oldLen; oldIndex++) {\n            result.push(oldLinks[oldIndex]);\n        }\n        for (; newIndex < newLen; newIndex++) {\n            result.push(newLinks[newIndex]);\n        }\n        return result;\n    }\n    commands_1.CommandsRegistry.registerCommand('_executeLinkProvider', (accessor, ...args) => {\n        const [uri] = args;\n        if (!(uri instanceof uri_1.URI)) {\n            return undefined;\n        }\n        const model = accessor.get(modelService_1.IModelService).getModel(uri);\n        if (!model) {\n            return undefined;\n        }\n        return getLinks(model, cancellation_1.CancellationToken.None);\n    });\n});\n",null]}