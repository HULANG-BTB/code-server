{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/files2/common/fileService2.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files2/common/fileService2.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/lifecycle\", \"vs/platform/files/common/files\", \"vs/base/common/event\", \"vs/base/common/resources\", \"vs/nls\", \"vs/base/common/map\", \"vs/base/common/arrays\", \"vs/base/common/labels\", \"vs/platform/log/common/log\"], function (require, exports, lifecycle_1, files_1, event_1, resources_1, nls_1, map_1, arrays_1, labels_1, log_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let FileService2 = class FileService2 extends lifecycle_1.Disposable {\n        constructor(logService) {\n            super();\n            this.logService = logService;\n            //#region File System Provider\n            this._onDidChangeFileSystemProviderRegistrations = this._register(new event_1.Emitter());\n            this._onWillActivateFileSystemProvider = this._register(new event_1.Emitter());\n            this.provider = new Map();\n            //#endregion\n            this._onAfterOperation = this._register(new event_1.Emitter());\n            //#endregion\n            //#region File Watching\n            this._onFileChanges = this._register(new event_1.Emitter());\n            this.joinOnLegacy = new Promise(resolve => {\n                this.joinOnImplResolve = resolve;\n            });\n        }\n        setLegacyService(legacy) {\n            this._legacy = this._register(legacy);\n            this._register(legacy.onFileChanges(e => this._onFileChanges.fire(e)));\n            this._register(legacy.onAfterOperation(e => this._onAfterOperation.fire(e)));\n            this.provider.forEach((provider, scheme) => {\n                legacy.registerProvider(scheme, provider);\n            });\n            this.joinOnImplResolve(legacy);\n        }\n        get onDidChangeFileSystemProviderRegistrations() { return this._onDidChangeFileSystemProviderRegistrations.event; }\n        get onWillActivateFileSystemProvider() { return this._onWillActivateFileSystemProvider.event; }\n        registerProvider(scheme, provider) {\n            if (this.provider.has(scheme)) {\n                throw new Error(`A provider for the scheme ${scheme} is already registered.`);\n            }\n            let legacyDisposal;\n            if (this._legacy) {\n                legacyDisposal = this._legacy.registerProvider(scheme, provider);\n            }\n            else {\n                legacyDisposal = lifecycle_1.Disposable.None;\n            }\n            // Add provider with event\n            this.provider.set(scheme, provider);\n            this._onDidChangeFileSystemProviderRegistrations.fire({ added: true, scheme, provider });\n            // Forward change events from provider\n            const providerFileListener = provider.onDidChangeFile(changes => this._onFileChanges.fire(new files_1.FileChangesEvent(changes)));\n            return lifecycle_1.combinedDisposable([\n                lifecycle_1.toDisposable(() => {\n                    this._onDidChangeFileSystemProviderRegistrations.fire({ added: false, scheme, provider });\n                    this.provider.delete(scheme);\n                    providerFileListener.dispose();\n                }),\n                legacyDisposal\n            ]);\n        }\n        activateProvider(scheme) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // Emit an event that we are about to activate a provider with the given scheme.\n                // Listeners can participate in the activation by registering a provider for it.\n                const joiners = [];\n                this._onWillActivateFileSystemProvider.fire({\n                    scheme,\n                    join(promise) {\n                        if (promise) {\n                            joiners.push(promise);\n                        }\n                    },\n                });\n                if (this.provider.has(scheme)) {\n                    return Promise.resolve(); // provider is already here so we can return directly\n                }\n                // If the provider is not yet there, make sure to join on the listeners assuming\n                // that it takes a bit longer to register the file system provider.\n                yield Promise.all(joiners);\n            });\n        }\n        canHandleResource(resource) {\n            return this.provider.has(resource.scheme);\n        }\n        hasCapability(resource, capability) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const provider = yield this.withProvider(resource);\n                return !!(provider.capabilities & capability);\n            });\n        }\n        withProvider(resource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // Assert path is absolute\n                if (!resources_1.isAbsolutePath(resource)) {\n                    throw new files_1.FileOperationError(nls_1.localize('invalidPath', \"The path of resource '{0}' must be absolute\", resource.toString(true)), files_1.FileOperationResult.FILE_INVALID_PATH);\n                }\n                // Activate provider\n                yield this.activateProvider(resource.scheme);\n                // Assert provider\n                const provider = this.provider.get(resource.scheme);\n                if (!provider) {\n                    const err = new Error();\n                    err.name = 'ENOPRO';\n                    err.message = `No provider found for ${resource.toString()}`;\n                    throw err;\n                }\n                return provider;\n            });\n        }\n        get onAfterOperation() { return this._onAfterOperation.event; }\n        resolveFile(resource, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    return yield this.doResolveFile(resource, options);\n                }\n                catch (error) {\n                    // Specially handle file not found case as file operation result\n                    if (files_1.toFileSystemProviderErrorCode(error) === files_1.FileSystemProviderErrorCode.FileNotFound) {\n                        throw new files_1.FileOperationError(nls_1.localize('fileNotFoundError', \"File not found ({0})\", resource.toString(true)), files_1.FileOperationResult.FILE_NOT_FOUND);\n                    }\n                    // Bubble up any other error as is\n                    throw error;\n                }\n            });\n        }\n        doResolveFile(resource, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const provider = yield this.withProvider(resource);\n                // leverage a trie to check for recursive resolving\n                const resolveTo = options && options.resolveTo;\n                const trie = map_1.TernarySearchTree.forPaths();\n                trie.set(resource.toString(), true);\n                if (arrays_1.isNonEmptyArray(resolveTo)) {\n                    resolveTo.forEach(uri => trie.set(uri.toString(), true));\n                }\n                const resolveSingleChildDescendants = !!(options && options.resolveSingleChildDescendants);\n                const resolveMetadata = !!(options && options.resolveMetadata);\n                const stat = yield provider.stat(resource);\n                return yield this.toFileStat(provider, resource, stat, undefined, resolveMetadata, (stat, siblings) => {\n                    // check for recursive resolving\n                    if (Boolean(trie.findSuperstr(stat.resource.toString()) || trie.get(stat.resource.toString()))) {\n                        return true;\n                    }\n                    // check for resolving single child folders\n                    if (stat.isDirectory && resolveSingleChildDescendants) {\n                        return siblings === 1;\n                    }\n                    return false;\n                });\n            });\n        }\n        toFileStat(provider, resource, stat, siblings, resolveMetadata, recurse) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // convert to file stat\n                const fileStat = {\n                    resource,\n                    name: labels_1.getBaseLabel(resource),\n                    isDirectory: (stat.type & files_1.FileType.Directory) !== 0,\n                    isSymbolicLink: (stat.type & files_1.FileType.SymbolicLink) !== 0,\n                    isReadonly: !!(provider.capabilities & files_1.FileSystemProviderCapabilities.Readonly),\n                    mtime: stat.mtime,\n                    size: stat.size,\n                    etag: files_1.etag(stat.mtime, stat.size)\n                };\n                // check to recurse for directories\n                if (fileStat.isDirectory && recurse(fileStat, siblings)) {\n                    try {\n                        const entries = yield provider.readdir(resource);\n                        const resolvedEntries = yield Promise.all(entries.map(([name, type]) => __awaiter(this, void 0, void 0, function* () {\n                            try {\n                                const childResource = resources_1.joinPath(resource, name);\n                                const childStat = resolveMetadata ? yield provider.stat(childResource) : { type };\n                                return yield this.toFileStat(provider, childResource, childStat, entries.length, resolveMetadata, recurse);\n                            }\n                            catch (error) {\n                                this.logService.trace(error);\n                                return null; // can happen e.g. due to permission errors\n                            }\n                        })));\n                        // make sure to get rid of null values that signal a failure to resolve a particular entry\n                        fileStat.children = arrays_1.coalesce(resolvedEntries);\n                    }\n                    catch (error) {\n                        this.logService.trace(error);\n                        fileStat.children = []; // gracefully handle errors, we may not have permissions to read\n                    }\n                    return fileStat;\n                }\n                return Promise.resolve(fileStat);\n            });\n        }\n        resolveFiles(toResolve) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return Promise.all(toResolve.map((entry) => __awaiter(this, void 0, void 0, function* () {\n                    try {\n                        return { stat: yield this.doResolveFile(entry.resource, entry.options), success: true };\n                    }\n                    catch (error) {\n                        this.logService.trace(error);\n                        return { stat: undefined, success: false };\n                    }\n                })));\n            });\n        }\n        existsFile(resource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    return !!(yield this.resolveFile(resource));\n                }\n                catch (error) {\n                    return false;\n                }\n            });\n        }\n        //#endregion\n        //#region File Reading/Writing\n        get encoding() {\n            if (!this._legacy) {\n                throw new Error('Legacy file service not ready yet');\n            }\n            return this._legacy.encoding;\n        }\n        createFile(resource, content, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const useLegacy = true; // can only disable this when encoding is sorted out\n                if (useLegacy) {\n                    return this.joinOnLegacy.then(legacy => legacy.createFile(resource, content, options));\n                }\n                const provider = this.throwIfFileSystemIsReadonly(yield this.withProvider(resource));\n                // validate overwrite\n                const overwrite = !!(options && options.overwrite);\n                if (yield this.existsFile(resource)) {\n                    if (!overwrite) {\n                        throw new files_1.FileOperationError(nls_1.localize('fileExists', \"File to create already exists ({0})\", resource.toString(true)), files_1.FileOperationResult.FILE_MODIFIED_SINCE, options);\n                    }\n                    // delete otherwise\n                    yield this.del(resource, { recursive: true });\n                }\n                try {\n                    // mkdir recursively\n                    yield this.mkdirp(provider, resources_1.dirname(resource));\n                    // create file: buffered\n                    if (files_1.hasOpenReadWriteCloseCapability(provider)) {\n                        yield this.doWriteBuffered(provider, resource, new TextEncoder().encode(content));\n                    }\n                    // create file: unbuffered\n                    else if (files_1.hasReadWriteCapability(provider)) {\n                        yield this.doWriteUnbuffered(provider, resource, new TextEncoder().encode(content), overwrite);\n                    }\n                    // give up if provider has insufficient capabilities\n                    else {\n                        return Promise.reject('Provider neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed to support creating a file.');\n                    }\n                }\n                catch (error) {\n                    throw new files_1.FileOperationError(nls_1.localize('err.create', \"Failed to create file {0}\", resource.toString(false)), files_1.toFileOperationResult(error), options);\n                }\n                // events\n                const fileStat = yield this.resolveFile(resource, { resolveMetadata: true });\n                this._onAfterOperation.fire(new files_1.FileOperationEvent(resource, files_1.FileOperation.CREATE, fileStat));\n                return fileStat;\n            });\n        }\n        resolveContent(resource, options) {\n            return this.joinOnLegacy.then(legacy => legacy.resolveContent(resource, options));\n        }\n        resolveStreamContent(resource, options) {\n            return this.joinOnLegacy.then(legacy => legacy.resolveStreamContent(resource, options));\n        }\n        updateContent(resource, value, options) {\n            return this.joinOnLegacy.then(legacy => legacy.updateContent(resource, value, options));\n        }\n        //#endregion\n        //#region Move/Copy/Delete/Create Folder\n        moveFile(source, target, overwrite) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const sourceProvider = this.throwIfFileSystemIsReadonly(yield this.withProvider(source));\n                const targetProvider = this.throwIfFileSystemIsReadonly(yield this.withProvider(target));\n                // move\n                const mode = yield this.doMoveCopy(sourceProvider, source, targetProvider, target, 'move', overwrite);\n                // resolve and send events\n                const fileStat = yield this.resolveFile(target, { resolveMetadata: true });\n                this._onAfterOperation.fire(new files_1.FileOperationEvent(source, mode === 'move' ? files_1.FileOperation.MOVE : files_1.FileOperation.COPY, fileStat));\n                return fileStat;\n            });\n        }\n        copyFile(source, target, overwrite) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const sourceProvider = yield this.withProvider(source);\n                const targetProvider = this.throwIfFileSystemIsReadonly(yield this.withProvider(target));\n                // copy\n                const mode = yield this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', overwrite);\n                // resolve and send events\n                const fileStat = yield this.resolveFile(target, { resolveMetadata: true });\n                this._onAfterOperation.fire(new files_1.FileOperationEvent(source, mode === 'copy' ? files_1.FileOperation.COPY : files_1.FileOperation.MOVE, fileStat));\n                return fileStat;\n            });\n        }\n        doMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // validation\n                const { exists, isCaseChange } = yield this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, overwrite);\n                // delete as needed\n                if (exists && !isCaseChange && overwrite) {\n                    yield this.del(target, { recursive: true });\n                }\n                // create parent folders\n                yield this.mkdirp(targetProvider, resources_1.dirname(target));\n                // copy source => target\n                if (mode === 'copy') {\n                    // same provider with fast copy: leverage copy() functionality\n                    if (sourceProvider === targetProvider && files_1.hasFileFolderCopyCapability(sourceProvider)) {\n                        return sourceProvider.copy(source, target, { overwrite: !!overwrite }).then(() => mode);\n                    }\n                    // otherwise, ensure we got the capabilities to do this\n                    if (!(files_1.hasOpenReadWriteCloseCapability(sourceProvider) || files_1.hasReadWriteCapability(sourceProvider)) ||\n                        !(files_1.hasOpenReadWriteCloseCapability(targetProvider) || files_1.hasReadWriteCapability(targetProvider))) {\n                        return Promise.reject('Provider neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed to support copy.');\n                    }\n                    // when copying via buffer/unbuffered, we have to manually\n                    // traverse the source if it is a folder and not a file\n                    const sourceFile = yield this.resolveFile(source);\n                    if (sourceFile.isDirectory) {\n                        return this.doCopyFolder(sourceProvider, sourceFile, targetProvider, target, overwrite).then(() => mode);\n                    }\n                    else {\n                        return this.doCopyFile(sourceProvider, source, targetProvider, target, overwrite).then(() => mode);\n                    }\n                }\n                // move source => target\n                else {\n                    // same provider: leverage rename() functionality\n                    if (sourceProvider === targetProvider) {\n                        return sourceProvider.rename(source, target, { overwrite: !!overwrite }).then(() => mode);\n                    }\n                    // across providers: copy to target & delete at source\n                    else {\n                        yield this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', overwrite);\n                        return this.del(source, { recursive: true }).then(() => 'copy');\n                    }\n                }\n            });\n        }\n        doCopyFile(sourceProvider, source, targetProvider, target, overwrite) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // copy: source (buffered) => target (buffered)\n                if (files_1.hasOpenReadWriteCloseCapability(sourceProvider) && files_1.hasOpenReadWriteCloseCapability(targetProvider)) {\n                    return this.doPipeBuffered(sourceProvider, source, targetProvider, target);\n                }\n                // copy: source (buffered) => target (unbuffered)\n                if (files_1.hasOpenReadWriteCloseCapability(sourceProvider) && files_1.hasReadWriteCapability(targetProvider)) {\n                    return this.doPipeBufferedToUnbuffered(sourceProvider, source, targetProvider, target, !!overwrite);\n                }\n                // copy: source (unbuffered) => target (buffered)\n                if (files_1.hasReadWriteCapability(sourceProvider) && files_1.hasOpenReadWriteCloseCapability(targetProvider)) {\n                    return this.doPipeUnbufferedToBuffered(sourceProvider, source, targetProvider, target);\n                }\n                // copy: source (unbuffered) => target (unbuffered)\n                if (files_1.hasReadWriteCapability(sourceProvider) && files_1.hasReadWriteCapability(targetProvider)) {\n                    return this.doPipeUnbuffered(sourceProvider, source, targetProvider, target, !!overwrite);\n                }\n            });\n        }\n        doCopyFolder(sourceProvider, sourceFolder, targetProvider, targetFolder, overwrite) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // create folder in target\n                yield targetProvider.mkdir(targetFolder);\n                // create children in target\n                if (Array.isArray(sourceFolder.children)) {\n                    yield Promise.all(sourceFolder.children.map((sourceChild) => __awaiter(this, void 0, void 0, function* () {\n                        const targetChild = resources_1.joinPath(targetFolder, sourceChild.name);\n                        if (sourceChild.isDirectory) {\n                            return this.doCopyFolder(sourceProvider, yield this.resolveFile(sourceChild.resource), targetProvider, targetChild, overwrite);\n                        }\n                        else {\n                            return this.doCopyFile(sourceProvider, sourceChild.resource, targetProvider, targetChild, overwrite);\n                        }\n                    })));\n                }\n            });\n        }\n        doValidateMoveCopy(sourceProvider, source, targetProvider, target, overwrite) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let isCaseChange = false;\n                let isPathCaseSensitive = false;\n                // Check if source is equal or parent to target (requires providers to be the same)\n                if (sourceProvider === targetProvider) {\n                    const isPathCaseSensitive = !!(sourceProvider.capabilities & files_1.FileSystemProviderCapabilities.PathCaseSensitive);\n                    isCaseChange = isPathCaseSensitive ? false : resources_1.isEqual(source, target, true /* ignore case */);\n                    if (!isCaseChange && resources_1.isEqualOrParent(target, source, !isPathCaseSensitive)) {\n                        return Promise.reject(new Error(nls_1.localize('unableToMoveCopyError1', \"Unable to move/copy when source path is equal or parent of target path\")));\n                    }\n                }\n                // Extra checks if target exists and this is not a rename\n                const exists = yield this.existsFile(target);\n                if (exists && !isCaseChange) {\n                    // Bail out if target exists and we are not about to overwrite\n                    if (!overwrite) {\n                        throw new files_1.FileOperationError(nls_1.localize('unableToMoveCopyError2', \"Unable to move/copy. File already exists at destination.\"), files_1.FileOperationResult.FILE_MOVE_CONFLICT);\n                    }\n                    // Special case: if the target is a parent of the source, we cannot delete\n                    // it as it would delete the source as well. In this case we have to throw\n                    if (sourceProvider === targetProvider && resources_1.isEqualOrParent(source, target, !isPathCaseSensitive)) {\n                        return Promise.reject(new Error(nls_1.localize('unableToMoveCopyError3', \"Unable to move/copy. File would replace folder it is contained in.\")));\n                    }\n                }\n                return { exists, isCaseChange };\n            });\n        }\n        createFolder(resource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const provider = this.throwIfFileSystemIsReadonly(yield this.withProvider(resource));\n                // mkdir recursively\n                yield this.mkdirp(provider, resource);\n                // events\n                const fileStat = yield this.resolveFile(resource, { resolveMetadata: true });\n                this._onAfterOperation.fire(new files_1.FileOperationEvent(resource, files_1.FileOperation.CREATE, fileStat));\n                return fileStat;\n            });\n        }\n        mkdirp(provider, directory) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const directoriesToCreate = [];\n                // mkdir until we reach root\n                while (!resources_1.isEqual(directory, resources_1.dirname(directory))) {\n                    try {\n                        const stat = yield provider.stat(directory);\n                        if ((stat.type & files_1.FileType.Directory) === 0) {\n                            throw new Error(nls_1.localize('mkdirExistsError', \"{0} exists, but is not a directory\", directory.toString()));\n                        }\n                        break; // we have hit a directory that exists -> good\n                    }\n                    catch (error) {\n                        // Bubble up any other error that is not file not found\n                        if (files_1.toFileSystemProviderErrorCode(error) !== files_1.FileSystemProviderErrorCode.FileNotFound) {\n                            throw error;\n                        }\n                        // Upon error, remember directories that need to be created\n                        directoriesToCreate.push(resources_1.basename(directory));\n                        // Continue up\n                        directory = resources_1.dirname(directory);\n                    }\n                }\n                // Create directories as needed\n                for (let i = directoriesToCreate.length - 1; i >= 0; i--) {\n                    directory = resources_1.joinPath(directory, directoriesToCreate[i]);\n                    yield provider.mkdir(directory);\n                }\n            });\n        }\n        del(resource, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const provider = this.throwIfFileSystemIsReadonly(yield this.withProvider(resource));\n                // Validate trash support\n                const useTrash = !!(options && options.useTrash);\n                if (useTrash && !(provider.capabilities & files_1.FileSystemProviderCapabilities.Trash)) {\n                    throw new Error(nls_1.localize('err.trash', \"Provider does not support trash.\"));\n                }\n                // Validate recursive\n                const recursive = !!(options && options.recursive);\n                if (!recursive && (yield this.existsFile(resource))) {\n                    const stat = yield this.resolveFile(resource);\n                    if (stat.isDirectory && Array.isArray(stat.children) && stat.children.length > 0) {\n                        throw new Error(nls_1.localize('deleteFailed', \"Failed to delete non-empty folder '{0}'.\", resource.toString()));\n                    }\n                }\n                // Delete through provider\n                yield provider.delete(resource, { recursive, useTrash });\n                // Events\n                this._onAfterOperation.fire(new files_1.FileOperationEvent(resource, files_1.FileOperation.DELETE));\n            });\n        }\n        get onFileChanges() { return this._onFileChanges.event; }\n        watchFileChanges(resource) {\n            this.joinOnLegacy.then(legacy => legacy.watchFileChanges(resource));\n        }\n        unwatchFileChanges(resource) {\n            this.joinOnLegacy.then(legacy => legacy.unwatchFileChanges(resource));\n        }\n        //#endregion\n        //#region Helpers\n        doWriteBuffered(provider, resource, buffer) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // open handle\n                const handle = yield provider.open(resource, { create: true });\n                // write into handle until all bytes from buffer have been written\n                try {\n                    yield this.doWriteBuffer(provider, handle, buffer, buffer.byteLength, 0, 0);\n                }\n                catch (error) {\n                    throw error;\n                }\n                finally {\n                    yield provider.close(handle);\n                }\n            });\n        }\n        doWriteBuffer(provider, handle, buffer, length, posInFile, posInBuffer) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let totalBytesWritten = 0;\n                while (totalBytesWritten < length) {\n                    const bytesWritten = yield provider.write(handle, posInFile + totalBytesWritten, buffer, posInBuffer + totalBytesWritten, length - totalBytesWritten);\n                    totalBytesWritten += bytesWritten;\n                }\n            });\n        }\n        doWriteUnbuffered(provider, resource, buffer, overwrite) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return provider.writeFile(resource, buffer, { create: true, overwrite });\n            });\n        }\n        doPipeBuffered(sourceProvider, source, targetProvider, target) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let sourceHandle = undefined;\n                let targetHandle = undefined;\n                try {\n                    // Open handles\n                    sourceHandle = yield sourceProvider.open(source, { create: false });\n                    targetHandle = yield targetProvider.open(target, { create: true });\n                    const buffer = new Uint8Array(16 * 1024);\n                    let posInFile = 0;\n                    let posInBuffer = 0;\n                    let bytesRead = 0;\n                    do {\n                        // read from source (sourceHandle) at current position (posInFile) into buffer (buffer) at\n                        // buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n                        bytesRead = yield sourceProvider.read(sourceHandle, posInFile, buffer, posInBuffer, buffer.byteLength - posInBuffer);\n                        // write into target (targetHandle) at current position (posInFile) from buffer (buffer) at\n                        // buffer position (posInBuffer) all bytes we read (bytesRead).\n                        yield this.doWriteBuffer(targetProvider, targetHandle, buffer, bytesRead, posInFile, posInBuffer);\n                        posInFile += bytesRead;\n                        posInBuffer += bytesRead;\n                        // when buffer full, fill it again from the beginning\n                        if (posInBuffer === buffer.length) {\n                            posInBuffer = 0;\n                        }\n                    } while (bytesRead > 0);\n                }\n                catch (error) {\n                    throw error;\n                }\n                finally {\n                    yield Promise.all([\n                        typeof sourceHandle === 'number' ? sourceProvider.close(sourceHandle) : Promise.resolve(),\n                        typeof targetHandle === 'number' ? targetProvider.close(targetHandle) : Promise.resolve(),\n                    ]);\n                }\n            });\n        }\n        doPipeUnbuffered(sourceProvider, source, targetProvider, target, overwrite) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return targetProvider.writeFile(target, yield sourceProvider.readFile(source), { create: true, overwrite });\n            });\n        }\n        doPipeUnbufferedToBuffered(sourceProvider, source, targetProvider, target) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // Open handle\n                const targetHandle = yield targetProvider.open(target, { create: true });\n                // Read entire buffer from source and write buffered\n                try {\n                    const buffer = yield sourceProvider.readFile(source);\n                    yield this.doWriteBuffer(targetProvider, targetHandle, buffer, buffer.byteLength, 0, 0);\n                }\n                catch (error) {\n                    throw error;\n                }\n                finally {\n                    yield targetProvider.close(targetHandle);\n                }\n            });\n        }\n        doPipeBufferedToUnbuffered(sourceProvider, source, targetProvider, target, overwrite) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // Determine file size\n                const size = (yield this.resolveFile(source, { resolveMetadata: true })).size;\n                // Open handle\n                const sourceHandle = yield sourceProvider.open(source, { create: false });\n                try {\n                    const buffer = new Uint8Array(size);\n                    let pos = 0;\n                    let bytesRead = 0;\n                    do {\n                        // read from source (sourceHandle) at current position (posInFile) into buffer (buffer) at\n                        // buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n                        bytesRead = yield sourceProvider.read(sourceHandle, pos, buffer, pos, buffer.byteLength - pos);\n                        pos += bytesRead;\n                    } while (bytesRead > 0 && pos < size);\n                    // Write buffer into target at once\n                    yield this.doWriteUnbuffered(targetProvider, target, buffer, overwrite);\n                }\n                catch (error) {\n                    throw error;\n                }\n                finally {\n                    yield sourceProvider.close(sourceHandle);\n                }\n            });\n        }\n        throwIfFileSystemIsReadonly(provider) {\n            if (provider.capabilities & files_1.FileSystemProviderCapabilities.Readonly) {\n                throw new files_1.FileOperationError(nls_1.localize('err.readonly', \"Resource can not be modified.\"), files_1.FileOperationResult.FILE_PERMISSION_DENIED);\n            }\n            return provider;\n        }\n    };\n    FileService2 = __decorate([\n        __param(0, log_1.ILogService)\n    ], FileService2);\n    exports.FileService2 = FileService2;\n});\n",null]}