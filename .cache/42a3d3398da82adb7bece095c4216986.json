{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursorCommon.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursorCommon.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/charCode\", \"vs/base/common/errors\", \"vs/base/common/strings\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\", \"vs/editor/common/core/selection\", \"vs/editor/common/model/textModel\", \"vs/editor/common/modes/languageConfigurationRegistry\"], function (require, exports, charCode_1, errors_1, strings, position_1, range_1, selection_1, textModel_1, languageConfigurationRegistry_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var RevealTarget;\n    (function (RevealTarget) {\n        RevealTarget[RevealTarget[\"Primary\"] = 0] = \"Primary\";\n        RevealTarget[RevealTarget[\"TopMost\"] = 1] = \"TopMost\";\n        RevealTarget[RevealTarget[\"BottomMost\"] = 2] = \"BottomMost\";\n    })(RevealTarget = exports.RevealTarget || (exports.RevealTarget = {}));\n    /**\n     * This is an operation type that will be recorded for undo/redo purposes.\n     * The goal is to introduce an undo stop when the controller switches between different operation types.\n     */\n    var EditOperationType;\n    (function (EditOperationType) {\n        EditOperationType[EditOperationType[\"Other\"] = 0] = \"Other\";\n        EditOperationType[EditOperationType[\"Typing\"] = 1] = \"Typing\";\n        EditOperationType[EditOperationType[\"DeletingLeft\"] = 2] = \"DeletingLeft\";\n        EditOperationType[EditOperationType[\"DeletingRight\"] = 3] = \"DeletingRight\";\n    })(EditOperationType = exports.EditOperationType || (exports.EditOperationType = {}));\n    const autoCloseAlways = () => true;\n    const autoCloseNever = () => false;\n    const autoCloseBeforeWhitespace = (chr) => (chr === ' ' || chr === '\\t');\n    class CursorConfiguration {\n        static shouldRecreate(e) {\n            return (e.layoutInfo\n                || e.wordSeparators\n                || e.emptySelectionClipboard\n                || e.multiCursorMergeOverlapping\n                || e.autoClosingBrackets\n                || e.autoClosingQuotes\n                || e.autoSurround\n                || e.useTabStops\n                || e.lineHeight\n                || e.readOnly);\n        }\n        constructor(languageIdentifier, modelOptions, configuration) {\n            this._languageIdentifier = languageIdentifier;\n            let c = configuration.editor;\n            this.readOnly = c.readOnly;\n            this.tabSize = modelOptions.tabSize;\n            this.indentSize = modelOptions.indentSize;\n            this.insertSpaces = modelOptions.insertSpaces;\n            this.pageSize = Math.max(1, Math.floor(c.layoutInfo.height / c.fontInfo.lineHeight) - 2);\n            this.lineHeight = c.lineHeight;\n            this.useTabStops = c.useTabStops;\n            this.wordSeparators = c.wordSeparators;\n            this.emptySelectionClipboard = c.emptySelectionClipboard;\n            this.copyWithSyntaxHighlighting = c.copyWithSyntaxHighlighting;\n            this.multiCursorMergeOverlapping = c.multiCursorMergeOverlapping;\n            this.autoClosingBrackets = c.autoClosingBrackets;\n            this.autoClosingQuotes = c.autoClosingQuotes;\n            this.autoSurround = c.autoSurround;\n            this.autoIndent = c.autoIndent;\n            this.autoClosingPairsOpen = {};\n            this.autoClosingPairsClose = {};\n            this.surroundingPairs = {};\n            this._electricChars = null;\n            this.shouldAutoCloseBefore = {\n                quote: CursorConfiguration._getShouldAutoClose(languageIdentifier, this.autoClosingQuotes),\n                bracket: CursorConfiguration._getShouldAutoClose(languageIdentifier, this.autoClosingBrackets)\n            };\n            let autoClosingPairs = CursorConfiguration._getAutoClosingPairs(languageIdentifier);\n            if (autoClosingPairs) {\n                for (const pair of autoClosingPairs) {\n                    this.autoClosingPairsOpen[pair.open] = pair.close;\n                    this.autoClosingPairsClose[pair.close] = pair.open;\n                }\n            }\n            let surroundingPairs = CursorConfiguration._getSurroundingPairs(languageIdentifier);\n            if (surroundingPairs) {\n                for (const pair of surroundingPairs) {\n                    this.surroundingPairs[pair.open] = pair.close;\n                }\n            }\n        }\n        get electricChars() {\n            if (!this._electricChars) {\n                this._electricChars = {};\n                let electricChars = CursorConfiguration._getElectricCharacters(this._languageIdentifier);\n                if (electricChars) {\n                    for (const char of electricChars) {\n                        this._electricChars[char] = true;\n                    }\n                }\n            }\n            return this._electricChars;\n        }\n        normalizeIndentation(str) {\n            return textModel_1.TextModel.normalizeIndentation(str, this.indentSize, this.insertSpaces);\n        }\n        static _getElectricCharacters(languageIdentifier) {\n            try {\n                return languageConfigurationRegistry_1.LanguageConfigurationRegistry.getElectricCharacters(languageIdentifier.id);\n            }\n            catch (e) {\n                errors_1.onUnexpectedError(e);\n                return null;\n            }\n        }\n        static _getAutoClosingPairs(languageIdentifier) {\n            try {\n                return languageConfigurationRegistry_1.LanguageConfigurationRegistry.getAutoClosingPairs(languageIdentifier.id);\n            }\n            catch (e) {\n                errors_1.onUnexpectedError(e);\n                return null;\n            }\n        }\n        static _getShouldAutoClose(languageIdentifier, autoCloseConfig) {\n            switch (autoCloseConfig) {\n                case 'beforeWhitespace':\n                    return autoCloseBeforeWhitespace;\n                case 'languageDefined':\n                    return CursorConfiguration._getLanguageDefinedShouldAutoClose(languageIdentifier);\n                case 'always':\n                    return autoCloseAlways;\n                case 'never':\n                    return autoCloseNever;\n            }\n        }\n        static _getLanguageDefinedShouldAutoClose(languageIdentifier) {\n            try {\n                const autoCloseBeforeSet = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getAutoCloseBeforeSet(languageIdentifier.id);\n                return c => autoCloseBeforeSet.indexOf(c) !== -1;\n            }\n            catch (e) {\n                errors_1.onUnexpectedError(e);\n                return autoCloseNever;\n            }\n        }\n        static _getSurroundingPairs(languageIdentifier) {\n            try {\n                return languageConfigurationRegistry_1.LanguageConfigurationRegistry.getSurroundingPairs(languageIdentifier.id);\n            }\n            catch (e) {\n                errors_1.onUnexpectedError(e);\n                return null;\n            }\n        }\n    }\n    exports.CursorConfiguration = CursorConfiguration;\n    /**\n     * Represents the cursor state on either the model or on the view model.\n     */\n    class SingleCursorState {\n        constructor(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns) {\n            this.selectionStart = selectionStart;\n            this.selectionStartLeftoverVisibleColumns = selectionStartLeftoverVisibleColumns;\n            this.position = position;\n            this.leftoverVisibleColumns = leftoverVisibleColumns;\n            this.selection = SingleCursorState._computeSelection(this.selectionStart, this.position);\n        }\n        equals(other) {\n            return (this.selectionStartLeftoverVisibleColumns === other.selectionStartLeftoverVisibleColumns\n                && this.leftoverVisibleColumns === other.leftoverVisibleColumns\n                && this.position.equals(other.position)\n                && this.selectionStart.equalsRange(other.selectionStart));\n        }\n        hasSelection() {\n            return (!this.selection.isEmpty() || !this.selectionStart.isEmpty());\n        }\n        move(inSelectionMode, lineNumber, column, leftoverVisibleColumns) {\n            if (inSelectionMode) {\n                // move just position\n                return new SingleCursorState(this.selectionStart, this.selectionStartLeftoverVisibleColumns, new position_1.Position(lineNumber, column), leftoverVisibleColumns);\n            }\n            else {\n                // move everything\n                return new SingleCursorState(new range_1.Range(lineNumber, column, lineNumber, column), leftoverVisibleColumns, new position_1.Position(lineNumber, column), leftoverVisibleColumns);\n            }\n        }\n        static _computeSelection(selectionStart, position) {\n            let startLineNumber, startColumn, endLineNumber, endColumn;\n            if (selectionStart.isEmpty()) {\n                startLineNumber = selectionStart.startLineNumber;\n                startColumn = selectionStart.startColumn;\n                endLineNumber = position.lineNumber;\n                endColumn = position.column;\n            }\n            else {\n                if (position.isBeforeOrEqual(selectionStart.getStartPosition())) {\n                    startLineNumber = selectionStart.endLineNumber;\n                    startColumn = selectionStart.endColumn;\n                    endLineNumber = position.lineNumber;\n                    endColumn = position.column;\n                }\n                else {\n                    startLineNumber = selectionStart.startLineNumber;\n                    startColumn = selectionStart.startColumn;\n                    endLineNumber = position.lineNumber;\n                    endColumn = position.column;\n                }\n            }\n            return new selection_1.Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n    }\n    exports.SingleCursorState = SingleCursorState;\n    class CursorContext {\n        constructor(configuration, model, viewModel) {\n            this.model = model;\n            this.viewModel = viewModel;\n            this.config = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), configuration);\n        }\n        validateViewPosition(viewPosition, modelPosition) {\n            return this.viewModel.coordinatesConverter.validateViewPosition(viewPosition, modelPosition);\n        }\n        validateViewRange(viewRange, expectedModelRange) {\n            return this.viewModel.coordinatesConverter.validateViewRange(viewRange, expectedModelRange);\n        }\n        convertViewRangeToModelRange(viewRange) {\n            return this.viewModel.coordinatesConverter.convertViewRangeToModelRange(viewRange);\n        }\n        convertViewPositionToModelPosition(lineNumber, column) {\n            return this.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new position_1.Position(lineNumber, column));\n        }\n        convertModelPositionToViewPosition(modelPosition) {\n            return this.viewModel.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        }\n        convertModelRangeToViewRange(modelRange) {\n            return this.viewModel.coordinatesConverter.convertModelRangeToViewRange(modelRange);\n        }\n        getCurrentScrollTop() {\n            return this.viewModel.viewLayout.getCurrentScrollTop();\n        }\n        getCompletelyVisibleViewRange() {\n            return this.viewModel.getCompletelyVisibleViewRange();\n        }\n        getCompletelyVisibleModelRange() {\n            const viewRange = this.viewModel.getCompletelyVisibleViewRange();\n            return this.viewModel.coordinatesConverter.convertViewRangeToModelRange(viewRange);\n        }\n        getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n            return this.viewModel.getCompletelyVisibleViewRangeAtScrollTop(scrollTop);\n        }\n        getVerticalOffsetForViewLine(viewLineNumber) {\n            return this.viewModel.viewLayout.getVerticalOffsetForLineNumber(viewLineNumber);\n        }\n    }\n    exports.CursorContext = CursorContext;\n    class PartialModelCursorState {\n        constructor(modelState) {\n            this.modelState = modelState;\n            this.viewState = null;\n        }\n    }\n    exports.PartialModelCursorState = PartialModelCursorState;\n    class PartialViewCursorState {\n        constructor(viewState) {\n            this.modelState = null;\n            this.viewState = viewState;\n        }\n    }\n    exports.PartialViewCursorState = PartialViewCursorState;\n    class CursorState {\n        static fromModelState(modelState) {\n            return new PartialModelCursorState(modelState);\n        }\n        static fromViewState(viewState) {\n            return new PartialViewCursorState(viewState);\n        }\n        static fromModelSelection(modelSelection) {\n            const selectionStartLineNumber = modelSelection.selectionStartLineNumber;\n            const selectionStartColumn = modelSelection.selectionStartColumn;\n            const positionLineNumber = modelSelection.positionLineNumber;\n            const positionColumn = modelSelection.positionColumn;\n            const modelState = new SingleCursorState(new range_1.Range(selectionStartLineNumber, selectionStartColumn, selectionStartLineNumber, selectionStartColumn), 0, new position_1.Position(positionLineNumber, positionColumn), 0);\n            return CursorState.fromModelState(modelState);\n        }\n        static fromModelSelections(modelSelections) {\n            let states = [];\n            for (let i = 0, len = modelSelections.length; i < len; i++) {\n                states[i] = this.fromModelSelection(modelSelections[i]);\n            }\n            return states;\n        }\n        constructor(modelState, viewState) {\n            this.modelState = modelState;\n            this.viewState = viewState;\n        }\n        equals(other) {\n            return (this.viewState.equals(other.viewState) && this.modelState.equals(other.modelState));\n        }\n    }\n    exports.CursorState = CursorState;\n    class EditOperationResult {\n        constructor(type, commands, opts) {\n            this.type = type;\n            this.commands = commands;\n            this.shouldPushStackElementBefore = opts.shouldPushStackElementBefore;\n            this.shouldPushStackElementAfter = opts.shouldPushStackElementAfter;\n        }\n    }\n    exports.EditOperationResult = EditOperationResult;\n    /**\n     * Common operations that work and make sense both on the model and on the view model.\n     */\n    class CursorColumns {\n        static isLowSurrogate(model, lineNumber, charOffset) {\n            let lineContent = model.getLineContent(lineNumber);\n            if (charOffset < 0 || charOffset >= lineContent.length) {\n                return false;\n            }\n            return strings.isLowSurrogate(lineContent.charCodeAt(charOffset));\n        }\n        static isHighSurrogate(model, lineNumber, charOffset) {\n            let lineContent = model.getLineContent(lineNumber);\n            if (charOffset < 0 || charOffset >= lineContent.length) {\n                return false;\n            }\n            return strings.isHighSurrogate(lineContent.charCodeAt(charOffset));\n        }\n        static isInsideSurrogatePair(model, lineNumber, column) {\n            return this.isHighSurrogate(model, lineNumber, column - 2);\n        }\n        static visibleColumnFromColumn(lineContent, column, tabSize) {\n            let endOffset = lineContent.length;\n            if (endOffset > column - 1) {\n                endOffset = column - 1;\n            }\n            let result = 0;\n            for (let i = 0; i < endOffset; i++) {\n                let charCode = lineContent.charCodeAt(i);\n                if (charCode === charCode_1.CharCode.Tab) {\n                    result = this.nextRenderTabStop(result, tabSize);\n                }\n                else if (strings.isFullWidthCharacter(charCode)) {\n                    result = result + 2;\n                }\n                else {\n                    result = result + 1;\n                }\n            }\n            return result;\n        }\n        static visibleColumnFromColumn2(config, model, position) {\n            return this.visibleColumnFromColumn(model.getLineContent(position.lineNumber), position.column, config.tabSize);\n        }\n        static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n            if (visibleColumn <= 0) {\n                return 1;\n            }\n            const lineLength = lineContent.length;\n            let beforeVisibleColumn = 0;\n            for (let i = 0; i < lineLength; i++) {\n                let charCode = lineContent.charCodeAt(i);\n                let afterVisibleColumn;\n                if (charCode === charCode_1.CharCode.Tab) {\n                    afterVisibleColumn = this.nextRenderTabStop(beforeVisibleColumn, tabSize);\n                }\n                else if (strings.isFullWidthCharacter(charCode)) {\n                    afterVisibleColumn = beforeVisibleColumn + 2;\n                }\n                else {\n                    afterVisibleColumn = beforeVisibleColumn + 1;\n                }\n                if (afterVisibleColumn >= visibleColumn) {\n                    let prevDelta = visibleColumn - beforeVisibleColumn;\n                    let afterDelta = afterVisibleColumn - visibleColumn;\n                    if (afterDelta < prevDelta) {\n                        return i + 2;\n                    }\n                    else {\n                        return i + 1;\n                    }\n                }\n                beforeVisibleColumn = afterVisibleColumn;\n            }\n            // walked the entire string\n            return lineLength + 1;\n        }\n        static columnFromVisibleColumn2(config, model, lineNumber, visibleColumn) {\n            let result = this.columnFromVisibleColumn(model.getLineContent(lineNumber), visibleColumn, config.tabSize);\n            let minColumn = model.getLineMinColumn(lineNumber);\n            if (result < minColumn) {\n                return minColumn;\n            }\n            let maxColumn = model.getLineMaxColumn(lineNumber);\n            if (result > maxColumn) {\n                return maxColumn;\n            }\n            return result;\n        }\n        /**\n         * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n         */\n        static nextRenderTabStop(visibleColumn, tabSize) {\n            return visibleColumn + tabSize - visibleColumn % tabSize;\n        }\n        /**\n         * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n         */\n        static nextIndentTabStop(visibleColumn, indentSize) {\n            return visibleColumn + indentSize - visibleColumn % indentSize;\n        }\n        /**\n         * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n         */\n        static prevRenderTabStop(column, tabSize) {\n            return column - 1 - (column - 1) % tabSize;\n        }\n        /**\n         * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n         */\n        static prevIndentTabStop(column, indentSize) {\n            return column - 1 - (column - 1) % indentSize;\n        }\n    }\n    exports.CursorColumns = CursorColumns;\n    function isQuote(ch) {\n        return (ch === '\\'' || ch === '\"' || ch === '`');\n    }\n    exports.isQuote = isQuote;\n});\n",null]}