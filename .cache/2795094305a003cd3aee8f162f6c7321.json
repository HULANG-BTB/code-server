{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursor.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursor.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/errors\", \"vs/base/common/event\", \"vs/base/common/strings\", \"vs/editor/common/controller/cursorCollection\", \"vs/editor/common/controller/cursorCommon\", \"vs/editor/common/controller/cursorDeleteOperations\", \"vs/editor/common/controller/cursorEvents\", \"vs/editor/common/controller/cursorTypeOperations\", \"vs/editor/common/core/range\", \"vs/editor/common/core/selection\", \"vs/editor/common/editorCommon\", \"vs/editor/common/model\", \"vs/editor/common/model/textModelEvents\", \"vs/editor/common/view/viewEvents\"], function (require, exports, errors_1, event_1, strings, cursorCollection_1, cursorCommon_1, cursorDeleteOperations_1, cursorEvents_1, cursorTypeOperations_1, range_1, selection_1, editorCommon, model_1, textModelEvents_1, viewEvents) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function containsLineMappingChanged(events) {\n        for (let i = 0, len = events.length; i < len; i++) {\n            if (events[i].type === viewEvents.ViewEventType.ViewLineMappingChanged) {\n                return true;\n            }\n        }\n        return false;\n    }\n    class CursorStateChangedEvent {\n        constructor(selections, source, reason) {\n            this.selections = selections;\n            this.source = source;\n            this.reason = reason;\n        }\n    }\n    exports.CursorStateChangedEvent = CursorStateChangedEvent;\n    /**\n     * A snapshot of the cursor and the model state\n     */\n    class CursorModelState {\n        constructor(model, cursor) {\n            this.modelVersionId = model.getVersionId();\n            this.cursorState = cursor.getAll();\n        }\n        equals(other) {\n            if (!other) {\n                return false;\n            }\n            if (this.modelVersionId !== other.modelVersionId) {\n                return false;\n            }\n            if (this.cursorState.length !== other.cursorState.length) {\n                return false;\n            }\n            for (let i = 0, len = this.cursorState.length; i < len; i++) {\n                if (!this.cursorState[i].equals(other.cursorState[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    exports.CursorModelState = CursorModelState;\n    class Cursor extends viewEvents.ViewEventEmitter {\n        constructor(configuration, model, viewModel) {\n            super();\n            this._onDidReachMaxCursorCount = this._register(new event_1.Emitter());\n            this.onDidReachMaxCursorCount = this._onDidReachMaxCursorCount.event;\n            this._onDidAttemptReadOnlyEdit = this._register(new event_1.Emitter());\n            this.onDidAttemptReadOnlyEdit = this._onDidAttemptReadOnlyEdit.event;\n            this._onDidChange = this._register(new event_1.Emitter());\n            this.onDidChange = this._onDidChange.event;\n            this._configuration = configuration;\n            this._model = model;\n            this._knownModelVersionId = this._model.getVersionId();\n            this._viewModel = viewModel;\n            this.context = new cursorCommon_1.CursorContext(this._configuration, this._model, this._viewModel);\n            this._cursors = new cursorCollection_1.CursorCollection(this.context);\n            this._isHandling = false;\n            this._isDoingComposition = false;\n            this._columnSelectData = null;\n            this._prevEditOperationType = cursorCommon_1.EditOperationType.Other;\n            this._register(this._model.onDidChangeRawContent((e) => {\n                this._knownModelVersionId = e.versionId;\n                if (this._isHandling) {\n                    return;\n                }\n                let hadFlushEvent = e.containsEvent(textModelEvents_1.RawContentChangedType.Flush);\n                this._onModelContentChanged(hadFlushEvent);\n            }));\n            this._register(viewModel.addEventListener((events) => {\n                if (!containsLineMappingChanged(events)) {\n                    return;\n                }\n                if (this._knownModelVersionId !== this._model.getVersionId()) {\n                    // There are model change events that I didn't yet receive.\n                    //\n                    // This can happen when editing the model, and the view model receives the change events first,\n                    // and the view model emits line mapping changed events, all before the cursor gets a chance to\n                    // recover from markers.\n                    //\n                    // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n                    return;\n                }\n                // Ensure valid state\n                this.setStates('viewModel', cursorEvents_1.CursorChangeReason.NotSet, this.getAll());\n            }));\n            const updateCursorContext = () => {\n                this.context = new cursorCommon_1.CursorContext(this._configuration, this._model, this._viewModel);\n                this._cursors.updateContext(this.context);\n            };\n            this._register(this._model.onDidChangeLanguage((e) => {\n                updateCursorContext();\n            }));\n            this._register(this._model.onDidChangeLanguageConfiguration(() => {\n                updateCursorContext();\n            }));\n            this._register(this._model.onDidChangeOptions(() => {\n                updateCursorContext();\n            }));\n            this._register(this._configuration.onDidChange((e) => {\n                if (cursorCommon_1.CursorConfiguration.shouldRecreate(e)) {\n                    updateCursorContext();\n                }\n            }));\n        }\n        dispose() {\n            this._cursors.dispose();\n            super.dispose();\n        }\n        // ------ some getters/setters\n        getPrimaryCursor() {\n            return this._cursors.getPrimaryCursor();\n        }\n        getLastAddedCursorIndex() {\n            return this._cursors.getLastAddedCursorIndex();\n        }\n        getAll() {\n            return this._cursors.getAll();\n        }\n        setStates(source, reason, states) {\n            if (states !== null && states.length > Cursor.MAX_CURSOR_COUNT) {\n                states = states.slice(0, Cursor.MAX_CURSOR_COUNT);\n                this._onDidReachMaxCursorCount.fire(undefined);\n            }\n            const oldState = new CursorModelState(this._model, this);\n            this._cursors.setStates(states);\n            this._cursors.normalize();\n            this._columnSelectData = null;\n            this._emitStateChangedIfNecessary(source, reason, oldState);\n        }\n        setColumnSelectData(columnSelectData) {\n            this._columnSelectData = columnSelectData;\n        }\n        reveal(horizontal, target, scrollType) {\n            this._revealRange(target, viewEvents.VerticalRevealType.Simple, horizontal, scrollType);\n        }\n        revealRange(revealHorizontal, viewRange, verticalType, scrollType) {\n            this.emitCursorRevealRange(viewRange, verticalType, revealHorizontal, scrollType);\n        }\n        scrollTo(desiredScrollTop) {\n            this._viewModel.viewLayout.setScrollPositionSmooth({\n                scrollTop: desiredScrollTop\n            });\n        }\n        saveState() {\n            let result = [];\n            const selections = this._cursors.getSelections();\n            for (let i = 0, len = selections.length; i < len; i++) {\n                const selection = selections[i];\n                result.push({\n                    inSelectionMode: !selection.isEmpty(),\n                    selectionStart: {\n                        lineNumber: selection.selectionStartLineNumber,\n                        column: selection.selectionStartColumn,\n                    },\n                    position: {\n                        lineNumber: selection.positionLineNumber,\n                        column: selection.positionColumn,\n                    }\n                });\n            }\n            return result;\n        }\n        restoreState(states) {\n            let desiredSelections = [];\n            for (let i = 0, len = states.length; i < len; i++) {\n                const state = states[i];\n                let positionLineNumber = 1;\n                let positionColumn = 1;\n                // Avoid missing properties on the literal\n                if (state.position && state.position.lineNumber) {\n                    positionLineNumber = state.position.lineNumber;\n                }\n                if (state.position && state.position.column) {\n                    positionColumn = state.position.column;\n                }\n                let selectionStartLineNumber = positionLineNumber;\n                let selectionStartColumn = positionColumn;\n                // Avoid missing properties on the literal\n                if (state.selectionStart && state.selectionStart.lineNumber) {\n                    selectionStartLineNumber = state.selectionStart.lineNumber;\n                }\n                if (state.selectionStart && state.selectionStart.column) {\n                    selectionStartColumn = state.selectionStart.column;\n                }\n                desiredSelections.push({\n                    selectionStartLineNumber: selectionStartLineNumber,\n                    selectionStartColumn: selectionStartColumn,\n                    positionLineNumber: positionLineNumber,\n                    positionColumn: positionColumn\n                });\n            }\n            this.setStates('restoreState', cursorEvents_1.CursorChangeReason.NotSet, cursorCommon_1.CursorState.fromModelSelections(desiredSelections));\n            this.reveal(true, cursorCommon_1.RevealTarget.Primary, editorCommon.ScrollType.Immediate);\n        }\n        _onModelContentChanged(hadFlushEvent) {\n            this._prevEditOperationType = cursorCommon_1.EditOperationType.Other;\n            if (hadFlushEvent) {\n                // a model.setValue() was called\n                this._cursors.dispose();\n                this._cursors = new cursorCollection_1.CursorCollection(this.context);\n                this._emitStateChangedIfNecessary('model', cursorEvents_1.CursorChangeReason.ContentFlush, null);\n            }\n            else {\n                const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                this.setStates('modelChange', cursorEvents_1.CursorChangeReason.RecoverFromMarkers, cursorCommon_1.CursorState.fromModelSelections(selectionsFromMarkers));\n            }\n        }\n        getSelection() {\n            return this._cursors.getPrimaryCursor().modelState.selection;\n        }\n        getColumnSelectData() {\n            if (this._columnSelectData) {\n                return this._columnSelectData;\n            }\n            const primaryCursor = this._cursors.getPrimaryCursor();\n            const primaryPos = primaryCursor.viewState.position;\n            return {\n                toViewLineNumber: primaryPos.lineNumber,\n                toViewVisualColumn: cursorCommon_1.CursorColumns.visibleColumnFromColumn2(this.context.config, this.context.viewModel, primaryPos)\n            };\n        }\n        getSelections() {\n            return this._cursors.getSelections();\n        }\n        getViewSelections() {\n            return this._cursors.getViewSelections();\n        }\n        getPosition() {\n            return this._cursors.getPrimaryCursor().modelState.position;\n        }\n        setSelections(source, selections) {\n            this.setStates(source, cursorEvents_1.CursorChangeReason.NotSet, cursorCommon_1.CursorState.fromModelSelections(selections));\n        }\n        getPrevEditOperationType() {\n            return this._prevEditOperationType;\n        }\n        setPrevEditOperationType(type) {\n            this._prevEditOperationType = type;\n        }\n        // ------ auxiliary handling logic\n        _executeEditOperation(opResult) {\n            if (!opResult) {\n                // Nothing to execute\n                return;\n            }\n            if (opResult.shouldPushStackElementBefore) {\n                this._model.pushStackElement();\n            }\n            const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n            if (result) {\n                // The commands were applied correctly\n                this._interpretCommandResult(result);\n                this._prevEditOperationType = opResult.type;\n            }\n            if (opResult.shouldPushStackElementAfter) {\n                this._model.pushStackElement();\n            }\n        }\n        _interpretCommandResult(cursorState) {\n            if (!cursorState || cursorState.length === 0) {\n                cursorState = this._cursors.readSelectionFromMarkers();\n            }\n            this._columnSelectData = null;\n            this._cursors.setSelections(cursorState);\n            this._cursors.normalize();\n        }\n        // -----------------------------------------------------------------------------------------------------------\n        // ----- emitting events\n        _emitStateChangedIfNecessary(source, reason, oldState) {\n            const newState = new CursorModelState(this._model, this);\n            if (newState.equals(oldState)) {\n                return false;\n            }\n            const selections = this._cursors.getSelections();\n            const viewSelections = this._cursors.getViewSelections();\n            // Let the view get the event first.\n            try {\n                const eventsCollector = this._beginEmit();\n                eventsCollector.emit(new viewEvents.ViewCursorStateChangedEvent(viewSelections));\n            }\n            finally {\n                this._endEmit();\n            }\n            // Only after the view has been notified, let the rest of the world know...\n            if (!oldState\n                || oldState.cursorState.length !== newState.cursorState.length\n                || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n                this._onDidChange.fire(new CursorStateChangedEvent(selections, source || 'keyboard', reason));\n            }\n            return true;\n        }\n        _revealRange(revealTarget, verticalType, revealHorizontal, scrollType) {\n            const viewPositions = this._cursors.getViewPositions();\n            let viewPosition = viewPositions[0];\n            if (revealTarget === cursorCommon_1.RevealTarget.TopMost) {\n                for (let i = 1; i < viewPositions.length; i++) {\n                    if (viewPositions[i].isBefore(viewPosition)) {\n                        viewPosition = viewPositions[i];\n                    }\n                }\n            }\n            else if (revealTarget === cursorCommon_1.RevealTarget.BottomMost) {\n                for (let i = 1; i < viewPositions.length; i++) {\n                    if (viewPosition.isBeforeOrEqual(viewPositions[i])) {\n                        viewPosition = viewPositions[i];\n                    }\n                }\n            }\n            else {\n                if (viewPositions.length > 1) {\n                    // no revealing!\n                    return;\n                }\n            }\n            const viewRange = new range_1.Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n            this.emitCursorRevealRange(viewRange, verticalType, revealHorizontal, scrollType);\n        }\n        emitCursorRevealRange(viewRange, verticalType, revealHorizontal, scrollType) {\n            try {\n                const eventsCollector = this._beginEmit();\n                eventsCollector.emit(new viewEvents.ViewRevealRangeRequestEvent(viewRange, verticalType, revealHorizontal, scrollType));\n            }\n            finally {\n                this._endEmit();\n            }\n        }\n        // -----------------------------------------------------------------------------------------------------------\n        // ----- handlers beyond this point\n        trigger(source, handlerId, payload) {\n            const H = editorCommon.Handler;\n            if (handlerId === H.CompositionStart) {\n                this._isDoingComposition = true;\n                return;\n            }\n            if (handlerId === H.CompositionEnd) {\n                this._isDoingComposition = false;\n            }\n            if (this._configuration.editor.readOnly) {\n                // All the remaining handlers will try to edit the model,\n                // but we cannot edit when read only...\n                this._onDidAttemptReadOnlyEdit.fire(undefined);\n                return;\n            }\n            const oldState = new CursorModelState(this._model, this);\n            let cursorChangeReason = cursorEvents_1.CursorChangeReason.NotSet;\n            if (handlerId !== H.Undo && handlerId !== H.Redo) {\n                // TODO@Alex: if the undo/redo stack contains non-null selections\n                // it would also be OK to stop tracking selections here\n                this._cursors.stopTrackingSelections();\n            }\n            // ensure valid state on all cursors\n            this._cursors.ensureValidState();\n            this._isHandling = true;\n            try {\n                switch (handlerId) {\n                    case H.Type:\n                        this._type(source, payload.text);\n                        break;\n                    case H.ReplacePreviousChar:\n                        this._replacePreviousChar(payload.text, payload.replaceCharCnt);\n                        break;\n                    case H.Paste:\n                        cursorChangeReason = cursorEvents_1.CursorChangeReason.Paste;\n                        this._paste(payload.text, payload.pasteOnNewLine, payload.multicursorText);\n                        break;\n                    case H.Cut:\n                        this._cut();\n                        break;\n                    case H.Undo:\n                        cursorChangeReason = cursorEvents_1.CursorChangeReason.Undo;\n                        this._interpretCommandResult(this._model.undo());\n                        break;\n                    case H.Redo:\n                        cursorChangeReason = cursorEvents_1.CursorChangeReason.Redo;\n                        this._interpretCommandResult(this._model.redo());\n                        break;\n                    case H.ExecuteCommand:\n                        this._externalExecuteCommand(payload);\n                        break;\n                    case H.ExecuteCommands:\n                        this._externalExecuteCommands(payload);\n                        break;\n                    case H.CompositionEnd:\n                        this._interpretCompositionEnd(source);\n                        break;\n                }\n            }\n            catch (err) {\n                errors_1.onUnexpectedError(err);\n            }\n            this._isHandling = false;\n            if (handlerId !== H.Undo && handlerId !== H.Redo) {\n                this._cursors.startTrackingSelections();\n            }\n            if (this._emitStateChangedIfNecessary(source, cursorChangeReason, oldState)) {\n                this._revealRange(cursorCommon_1.RevealTarget.Primary, viewEvents.VerticalRevealType.Simple, true, editorCommon.ScrollType.Smooth);\n            }\n        }\n        _interpretCompositionEnd(source) {\n            if (!this._isDoingComposition && source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(cursorTypeOperations_1.TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections()));\n            }\n        }\n        _type(source, text) {\n            if (!this._isDoingComposition && source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                for (let i = 0, len = text.length; i < len; i++) {\n                    let charCode = text.charCodeAt(i);\n                    let chr;\n                    if (strings.isHighSurrogate(charCode) && i + 1 < len) {\n                        chr = text.charAt(i) + text.charAt(i + 1);\n                        i++;\n                    }\n                    else {\n                        chr = text.charAt(i);\n                    }\n                    // Here we must interpret each typed character individually, that's why we create a new context\n                    this._executeEditOperation(cursorTypeOperations_1.TypeOperations.typeWithInterceptors(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), chr));\n                }\n            }\n            else {\n                this._executeEditOperation(cursorTypeOperations_1.TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), text));\n            }\n        }\n        _replacePreviousChar(text, replaceCharCnt) {\n            this._executeEditOperation(cursorTypeOperations_1.TypeOperations.replacePreviousChar(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), text, replaceCharCnt));\n        }\n        _paste(text, pasteOnNewLine, multicursorText) {\n            this._executeEditOperation(cursorTypeOperations_1.TypeOperations.paste(this.context.config, this.context.model, this.getSelections(), text, pasteOnNewLine, multicursorText));\n        }\n        _cut() {\n            this._executeEditOperation(cursorDeleteOperations_1.DeleteOperations.cut(this.context.config, this.context.model, this.getSelections()));\n        }\n        _externalExecuteCommand(command) {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Other, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }\n        _externalExecuteCommands(commands) {\n            this._executeEditOperation(new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Other, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }\n    }\n    Cursor.MAX_CURSOR_COUNT = 10000;\n    exports.Cursor = Cursor;\n    class CommandExecutor {\n        static executeCommands(model, selectionsBefore, commands) {\n            const ctx = {\n                model: model,\n                selectionsBefore: selectionsBefore,\n                trackedRanges: [],\n                trackedRangesDirection: []\n            };\n            const result = this._innerExecuteCommands(ctx, commands);\n            for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n                ctx.model._setTrackedRange(ctx.trackedRanges[i], null, model_1.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);\n            }\n            return result;\n        }\n        static _innerExecuteCommands(ctx, commands) {\n            if (this._arrayIsEmpty(commands)) {\n                return null;\n            }\n            const commandsData = this._getEditOperations(ctx, commands);\n            if (commandsData.operations.length === 0) {\n                return null;\n            }\n            const rawOperations = commandsData.operations;\n            const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n            if (loserCursorsMap.hasOwnProperty('0')) {\n                // These commands are very messed up\n                console.warn('Ignoring commands');\n                return null;\n            }\n            // Remove operations belonging to losing cursors\n            let filteredOperations = [];\n            for (let i = 0, len = rawOperations.length; i < len; i++) {\n                if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                    filteredOperations.push(rawOperations[i]);\n                }\n            }\n            // TODO@Alex: find a better way to do this.\n            // give the hint that edit operations are tracked to the model\n            if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n                filteredOperations[0]._isTracked = true;\n            }\n            let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n                let groupedInverseEditOperations = [];\n                for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                    groupedInverseEditOperations[i] = [];\n                }\n                for (const op of inverseEditOperations) {\n                    if (!op.identifier) {\n                        // perhaps auto whitespace trim edits\n                        continue;\n                    }\n                    groupedInverseEditOperations[op.identifier.major].push(op);\n                }\n                const minorBasedSorter = (a, b) => {\n                    return a.identifier.minor - b.identifier.minor;\n                };\n                let cursorSelections = [];\n                for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                    if (groupedInverseEditOperations[i].length > 0) {\n                        groupedInverseEditOperations[i].sort(minorBasedSorter);\n                        cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                            getInverseEditOperations: () => {\n                                return groupedInverseEditOperations[i];\n                            },\n                            getTrackedSelection: (id) => {\n                                const idx = parseInt(id, 10);\n                                const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                                if (ctx.trackedRangesDirection[idx] === selection_1.SelectionDirection.LTR) {\n                                    return new selection_1.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                                }\n                                return new selection_1.Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                            }\n                        });\n                    }\n                    else {\n                        cursorSelections[i] = ctx.selectionsBefore[i];\n                    }\n                }\n                return cursorSelections;\n            });\n            if (!selectionsAfter) {\n                selectionsAfter = ctx.selectionsBefore;\n            }\n            // Extract losing cursors\n            let losingCursors = [];\n            for (let losingCursorIndex in loserCursorsMap) {\n                if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                    losingCursors.push(parseInt(losingCursorIndex, 10));\n                }\n            }\n            // Sort losing cursors descending\n            losingCursors.sort((a, b) => {\n                return b - a;\n            });\n            // Remove losing cursors\n            for (const losingCursor of losingCursors) {\n                selectionsAfter.splice(losingCursor, 1);\n            }\n            return selectionsAfter;\n        }\n        static _arrayIsEmpty(commands) {\n            for (let i = 0, len = commands.length; i < len; i++) {\n                if (commands[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        static _getEditOperations(ctx, commands) {\n            let operations = [];\n            let hadTrackedEditOperation = false;\n            for (let i = 0, len = commands.length; i < len; i++) {\n                const command = commands[i];\n                if (command) {\n                    const r = this._getEditOperationsFromCommand(ctx, i, command);\n                    operations = operations.concat(r.operations);\n                    hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n                }\n            }\n            return {\n                operations: operations,\n                hadTrackedEditOperation: hadTrackedEditOperation\n            };\n        }\n        static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n            // This method acts as a transaction, if the command fails\n            // everything it has done is ignored\n            let operations = [];\n            let operationMinor = 0;\n            const addEditOperation = (selection, text) => {\n                if (selection.isEmpty() && text === '') {\n                    // This command wants to add a no-op => no thank you\n                    return;\n                }\n                operations.push({\n                    identifier: {\n                        major: majorIdentifier,\n                        minor: operationMinor++\n                    },\n                    range: selection,\n                    text: text,\n                    forceMoveMarkers: false,\n                    isAutoWhitespaceEdit: command.insertsAutoWhitespace\n                });\n            };\n            let hadTrackedEditOperation = false;\n            const addTrackedEditOperation = (selection, text) => {\n                hadTrackedEditOperation = true;\n                addEditOperation(selection, text);\n            };\n            const trackSelection = (selection, trackPreviousOnEmpty) => {\n                let stickiness;\n                if (selection.isEmpty()) {\n                    if (typeof trackPreviousOnEmpty === 'boolean') {\n                        if (trackPreviousOnEmpty) {\n                            stickiness = model_1.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore;\n                        }\n                        else {\n                            stickiness = model_1.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter;\n                        }\n                    }\n                    else {\n                        // Try to lock it with surrounding text\n                        const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                        if (selection.startColumn === maxLineColumn) {\n                            stickiness = model_1.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore;\n                        }\n                        else {\n                            stickiness = model_1.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter;\n                        }\n                    }\n                }\n                else {\n                    stickiness = model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges;\n                }\n                const l = ctx.trackedRanges.length;\n                const id = ctx.model._setTrackedRange(null, selection, stickiness);\n                ctx.trackedRanges[l] = id;\n                ctx.trackedRangesDirection[l] = selection.getDirection();\n                return l.toString();\n            };\n            const editOperationBuilder = {\n                addEditOperation: addEditOperation,\n                addTrackedEditOperation: addTrackedEditOperation,\n                trackSelection: trackSelection\n            };\n            try {\n                command.getEditOperations(ctx.model, editOperationBuilder);\n            }\n            catch (e) {\n                // TODO@Alex use notification service if this should be user facing\n                // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n                errors_1.onUnexpectedError(e);\n                return {\n                    operations: [],\n                    hadTrackedEditOperation: false\n                };\n            }\n            return {\n                operations: operations,\n                hadTrackedEditOperation: hadTrackedEditOperation\n            };\n        }\n        static _getLoserCursorMap(operations) {\n            // This is destructive on the array\n            operations = operations.slice(0);\n            // Sort operations with last one first\n            operations.sort((a, b) => {\n                // Note the minus!\n                return -(range_1.Range.compareRangesUsingEnds(a.range, b.range));\n            });\n            // Operations can not overlap!\n            let loserCursorsMap = {};\n            for (let i = 1; i < operations.length; i++) {\n                const previousOp = operations[i - 1];\n                const currentOp = operations[i];\n                if (previousOp.range.getStartPosition().isBefore(currentOp.range.getEndPosition())) {\n                    let loserMajor;\n                    if (previousOp.identifier.major > currentOp.identifier.major) {\n                        // previousOp loses the battle\n                        loserMajor = previousOp.identifier.major;\n                    }\n                    else {\n                        loserMajor = currentOp.identifier.major;\n                    }\n                    loserCursorsMap[loserMajor.toString()] = true;\n                    for (let j = 0; j < operations.length; j++) {\n                        if (operations[j].identifier.major === loserMajor) {\n                            operations.splice(j, 1);\n                            if (j < i) {\n                                i--;\n                            }\n                            j--;\n                        }\n                    }\n                    if (i > 0) {\n                        i--;\n                    }\n                }\n            }\n            return loserCursorsMap;\n        }\n    }\n});\n",null]}