{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/platform/workspaces/electron-main/workspacesMainService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/workspaces/electron-main/workspacesMainService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar workspaces_1 = require(\"vs/platform/workspaces/common/workspaces\");\nvar environment_1 = require(\"vs/platform/environment/common/environment\");\nvar path_1 = require(\"vs/base/common/path\");\nvar pfs_1 = require(\"vs/base/node/pfs\");\nvar fs_1 = require(\"fs\");\nvar platform_1 = require(\"vs/base/common/platform\");\nvar extfs_1 = require(\"vs/base/node/extfs\");\nvar event_1 = require(\"vs/base/common/event\");\nvar log_1 = require(\"vs/platform/log/common/log\");\nvar crypto_1 = require(\"crypto\");\nvar json = require(\"vs/base/common/json\");\nvar workspace_1 = require(\"vs/platform/workspace/common/workspace\");\nvar network_1 = require(\"vs/base/common/network\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar resources_1 = require(\"vs/base/common/resources\");\nvar WorkspacesMainService = /** @class */ (function (_super) {\n    tslib_1.__extends(WorkspacesMainService, _super);\n    function WorkspacesMainService(environmentService, logService) {\n        var _this = _super.call(this) || this;\n        _this.environmentService = environmentService;\n        _this.logService = logService;\n        _this._onUntitledWorkspaceDeleted = _this._register(new event_1.Emitter());\n        _this.untitledWorkspacesHome = environmentService.untitledWorkspacesHome;\n        return _this;\n    }\n    Object.defineProperty(WorkspacesMainService.prototype, \"onUntitledWorkspaceDeleted\", {\n        get: function () { return this._onUntitledWorkspaceDeleted.event; },\n        enumerable: true,\n        configurable: true\n    });\n    WorkspacesMainService.prototype.resolveLocalWorkspaceSync = function (uri) {\n        if (!this.isWorkspacePath(uri)) {\n            return null; // does not look like a valid workspace config file\n        }\n        if (uri.scheme !== network_1.Schemas.file) {\n            return null;\n        }\n        var contents;\n        try {\n            contents = fs_1.readFileSync(uri.fsPath, 'utf8');\n        }\n        catch (error) {\n            return null; // invalid workspace\n        }\n        return this.doResolveWorkspace(uri, contents);\n    };\n    WorkspacesMainService.prototype.isWorkspacePath = function (uri) {\n        return this.isInsideWorkspacesHome(uri) || workspaces_1.hasWorkspaceFileExtension(uri.path);\n    };\n    WorkspacesMainService.prototype.doResolveWorkspace = function (path, contents) {\n        try {\n            var workspace = this.doParseStoredWorkspace(path, contents);\n            var workspaceIdentifier = getWorkspaceIdentifier(path);\n            return {\n                id: workspaceIdentifier.id,\n                configPath: workspaceIdentifier.configPath,\n                folders: workspace_1.toWorkspaceFolders(workspace.folders, resources_1.dirname(path)),\n                remoteAuthority: workspace.remoteAuthority\n            };\n        }\n        catch (error) {\n            this.logService.warn(error.toString());\n        }\n        return null;\n    };\n    WorkspacesMainService.prototype.doParseStoredWorkspace = function (path, contents) {\n        // Parse workspace file\n        var storedWorkspace = json.parse(contents); // use fault tolerant parser\n        // Filter out folders which do not have a path or uri set\n        if (Array.isArray(storedWorkspace.folders)) {\n            storedWorkspace.folders = storedWorkspace.folders.filter(function (folder) { return workspaces_1.isStoredWorkspaceFolder(folder); });\n        }\n        // Validate\n        if (!Array.isArray(storedWorkspace.folders)) {\n            throw new Error(path.toString() + \" looks like an invalid workspace file.\");\n        }\n        return storedWorkspace;\n    };\n    WorkspacesMainService.prototype.isInsideWorkspacesHome = function (path) {\n        return resources_1.isEqualOrParent(path, this.environmentService.untitledWorkspacesHome);\n    };\n    WorkspacesMainService.prototype.createUntitledWorkspace = function (folders, remoteAuthority) {\n        var _a = this.newUntitledWorkspace(folders, remoteAuthority), workspace = _a.workspace, storedWorkspace = _a.storedWorkspace;\n        var configPath = workspace.configPath.fsPath;\n        return pfs_1.mkdirp(path_1.dirname(configPath)).then(function () {\n            return pfs_1.writeFile(configPath, JSON.stringify(storedWorkspace, null, '\\t')).then(function () { return workspace; });\n        });\n    };\n    WorkspacesMainService.prototype.createUntitledWorkspaceSync = function (folders, remoteAuthority) {\n        var _a = this.newUntitledWorkspace(folders, remoteAuthority), workspace = _a.workspace, storedWorkspace = _a.storedWorkspace;\n        var configPath = workspace.configPath.fsPath;\n        var configPathDir = path_1.dirname(configPath);\n        if (!fs_1.existsSync(configPathDir)) {\n            var configPathDirDir = path_1.dirname(configPathDir);\n            if (!fs_1.existsSync(configPathDirDir)) {\n                fs_1.mkdirSync(configPathDirDir);\n            }\n            fs_1.mkdirSync(configPathDir);\n        }\n        extfs_1.writeFileAndFlushSync(configPath, JSON.stringify(storedWorkspace, null, '\\t'));\n        return workspace;\n    };\n    WorkspacesMainService.prototype.newUntitledWorkspace = function (folders, remoteAuthority) {\n        if (folders === void 0) { folders = []; }\n        var randomId = (Date.now() + Math.round(Math.random() * 1000)).toString();\n        var untitledWorkspaceConfigFolder = resources_1.joinPath(this.untitledWorkspacesHome, randomId);\n        var untitledWorkspaceConfigPath = resources_1.joinPath(untitledWorkspaceConfigFolder, workspaces_1.UNTITLED_WORKSPACE_NAME);\n        var storedWorkspaceFolder = [];\n        for (var _i = 0, folders_1 = folders; _i < folders_1.length; _i++) {\n            var folder = folders_1[_i];\n            storedWorkspaceFolder.push(workspaces_1.getStoredWorkspaceFolder(folder.uri, folder.name, untitledWorkspaceConfigFolder));\n        }\n        return {\n            workspace: getWorkspaceIdentifier(untitledWorkspaceConfigPath),\n            storedWorkspace: { folders: storedWorkspaceFolder, remoteAuthority: remoteAuthority }\n        };\n    };\n    WorkspacesMainService.prototype.getWorkspaceIdentifier = function (configPath) {\n        return Promise.resolve(getWorkspaceIdentifier(configPath));\n    };\n    WorkspacesMainService.prototype.isUntitledWorkspace = function (workspace) {\n        return this.isInsideWorkspacesHome(workspace.configPath);\n    };\n    WorkspacesMainService.prototype.deleteUntitledWorkspaceSync = function (workspace) {\n        if (!this.isUntitledWorkspace(workspace)) {\n            return; // only supported for untitled workspaces\n        }\n        // Delete from disk\n        this.doDeleteUntitledWorkspaceSync(workspace);\n        // Event\n        this._onUntitledWorkspaceDeleted.fire(workspace);\n    };\n    WorkspacesMainService.prototype.deleteUntitledWorkspace = function (workspace) {\n        this.deleteUntitledWorkspaceSync(workspace);\n        return Promise.resolve();\n    };\n    WorkspacesMainService.prototype.doDeleteUntitledWorkspaceSync = function (workspace) {\n        var configPath = resources_1.originalFSPath(workspace.configPath);\n        try {\n            // Delete Workspace\n            extfs_1.delSync(path_1.dirname(configPath));\n            // Mark Workspace Storage to be deleted\n            var workspaceStoragePath = path_1.join(this.environmentService.workspaceStorageHome, workspace.id);\n            if (fs_1.existsSync(workspaceStoragePath)) {\n                fs_1.writeFileSync(path_1.join(workspaceStoragePath, 'obsolete'), '');\n            }\n        }\n        catch (error) {\n            this.logService.warn(\"Unable to delete untitled workspace \" + configPath + \" (\" + error + \").\");\n        }\n    };\n    WorkspacesMainService.prototype.getUntitledWorkspacesSync = function () {\n        var _this = this;\n        var untitledWorkspaces = [];\n        try {\n            var untitledWorkspacePaths = extfs_1.readdirSync(this.untitledWorkspacesHome.fsPath).map(function (folder) { return resources_1.joinPath(_this.untitledWorkspacesHome, folder, workspaces_1.UNTITLED_WORKSPACE_NAME); });\n            for (var _i = 0, untitledWorkspacePaths_1 = untitledWorkspacePaths; _i < untitledWorkspacePaths_1.length; _i++) {\n                var untitledWorkspacePath = untitledWorkspacePaths_1[_i];\n                var workspace = getWorkspaceIdentifier(untitledWorkspacePath);\n                var resolvedWorkspace = this.resolveLocalWorkspaceSync(untitledWorkspacePath);\n                if (!resolvedWorkspace) {\n                    this.doDeleteUntitledWorkspaceSync(workspace);\n                }\n                else {\n                    untitledWorkspaces.push({ workspace: workspace, remoteAuthority: resolvedWorkspace.remoteAuthority });\n                }\n            }\n        }\n        catch (error) {\n            if (error && error.code !== 'ENOENT') {\n                this.logService.warn(\"Unable to read folders in \" + this.untitledWorkspacesHome + \" (\" + error + \").\");\n            }\n        }\n        return untitledWorkspaces;\n    };\n    WorkspacesMainService = tslib_1.__decorate([\n        tslib_1.__param(0, environment_1.IEnvironmentService),\n        tslib_1.__param(1, log_1.ILogService)\n    ], WorkspacesMainService);\n    return WorkspacesMainService;\n}(lifecycle_1.Disposable));\nexports.WorkspacesMainService = WorkspacesMainService;\nfunction getWorkspaceId(configPath) {\n    var workspaceConfigPath = configPath.scheme === network_1.Schemas.file ? resources_1.originalFSPath(configPath) : configPath.toString();\n    if (!platform_1.isLinux) {\n        workspaceConfigPath = workspaceConfigPath.toLowerCase(); // sanitize for platform file system\n    }\n    return crypto_1.createHash('md5').update(workspaceConfigPath).digest('hex');\n}\nfunction getWorkspaceIdentifier(configPath) {\n    return {\n        configPath: configPath,\n        id: getWorkspaceId(configPath)\n    };\n}\nexports.getWorkspaceIdentifier = getWorkspaceIdentifier;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/platform/workspaces/electron-main/workspacesMainService.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/platform/workspaces/electron-main/workspacesMainService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IWorkspacesMainService, IWorkspaceIdentifier, hasWorkspaceFileExtension, UNTITLED_WORKSPACE_NAME, IResolvedWorkspace, IStoredWorkspaceFolder, isStoredWorkspaceFolder, IWorkspaceFolderCreationData, IUntitledWorkspaceInfo, getStoredWorkspaceFolder } from 'vs/platform/workspaces/common/workspaces';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { join, dirname } from 'vs/base/common/path';\nimport { mkdirp, writeFile } from 'vs/base/node/pfs';\nimport { readFileSync, existsSync, mkdirSync, writeFileSync } from 'fs';\nimport { isLinux } from 'vs/base/common/platform';\nimport { delSync, readdirSync, writeFileAndFlushSync } from 'vs/base/node/extfs';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { createHash } from 'crypto';\nimport * as json from 'vs/base/common/json';\nimport { toWorkspaceFolders } from 'vs/platform/workspace/common/workspace';\nimport { URI } from 'vs/base/common/uri';\nimport { Schemas } from 'vs/base/common/network';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { originalFSPath, dirname as resourcesDirname, isEqualOrParent, joinPath } from 'vs/base/common/resources';\n\nexport interface IStoredWorkspace {\n\tfolders: IStoredWorkspaceFolder[];\n\tremoteAuthority?: string;\n}\n\nexport class WorkspacesMainService extends Disposable implements IWorkspacesMainService {\n\n\t_serviceBrand: any;\n\n\tprivate readonly untitledWorkspacesHome: URI; // local URI that contains all untitled workspaces\n\n\tprivate readonly _onUntitledWorkspaceDeleted = this._register(new Emitter<IWorkspaceIdentifier>());\n\tget onUntitledWorkspaceDeleted(): Event<IWorkspaceIdentifier> { return this._onUntitledWorkspaceDeleted.event; }\n\n\tconstructor(\n\t\t@IEnvironmentService private readonly environmentService: IEnvironmentService,\n\t\t@ILogService private readonly logService: ILogService\n\t) {\n\t\tsuper();\n\n\t\tthis.untitledWorkspacesHome = environmentService.untitledWorkspacesHome;\n\t}\n\n\tresolveLocalWorkspaceSync(uri: URI): IResolvedWorkspace | null {\n\t\tif (!this.isWorkspacePath(uri)) {\n\t\t\treturn null; // does not look like a valid workspace config file\n\t\t}\n\t\tif (uri.scheme !== Schemas.file) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet contents: string;\n\t\ttry {\n\t\t\tcontents = readFileSync(uri.fsPath, 'utf8');\n\t\t} catch (error) {\n\t\t\treturn null; // invalid workspace\n\t\t}\n\n\t\treturn this.doResolveWorkspace(uri, contents);\n\t}\n\n\tprivate isWorkspacePath(uri: URI): boolean {\n\t\treturn this.isInsideWorkspacesHome(uri) || hasWorkspaceFileExtension(uri.path);\n\t}\n\n\tprivate doResolveWorkspace(path: URI, contents: string): IResolvedWorkspace | null {\n\t\ttry {\n\t\t\tconst workspace = this.doParseStoredWorkspace(path, contents);\n\t\t\tconst workspaceIdentifier = getWorkspaceIdentifier(path);\n\t\t\treturn {\n\t\t\t\tid: workspaceIdentifier.id,\n\t\t\t\tconfigPath: workspaceIdentifier.configPath,\n\t\t\t\tfolders: toWorkspaceFolders(workspace.folders, resourcesDirname(path)),\n\t\t\t\tremoteAuthority: workspace.remoteAuthority\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthis.logService.warn(error.toString());\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate doParseStoredWorkspace(path: URI, contents: string): IStoredWorkspace {\n\n\t\t// Parse workspace file\n\t\tlet storedWorkspace: IStoredWorkspace = json.parse(contents); // use fault tolerant parser\n\n\t\t// Filter out folders which do not have a path or uri set\n\t\tif (Array.isArray(storedWorkspace.folders)) {\n\t\t\tstoredWorkspace.folders = storedWorkspace.folders.filter(folder => isStoredWorkspaceFolder(folder));\n\t\t}\n\n\t\t// Validate\n\t\tif (!Array.isArray(storedWorkspace.folders)) {\n\t\t\tthrow new Error(`${path.toString()} looks like an invalid workspace file.`);\n\t\t}\n\n\t\treturn storedWorkspace;\n\t}\n\n\tprivate isInsideWorkspacesHome(path: URI): boolean {\n\t\treturn isEqualOrParent(path, this.environmentService.untitledWorkspacesHome);\n\t}\n\n\tcreateUntitledWorkspace(folders?: IWorkspaceFolderCreationData[], remoteAuthority?: string): Promise<IWorkspaceIdentifier> {\n\t\tconst { workspace, storedWorkspace } = this.newUntitledWorkspace(folders, remoteAuthority);\n\t\tconst configPath = workspace.configPath.fsPath;\n\n\t\treturn mkdirp(dirname(configPath)).then(() => {\n\t\t\treturn writeFile(configPath, JSON.stringify(storedWorkspace, null, '\\t')).then(() => workspace);\n\t\t});\n\t}\n\n\tcreateUntitledWorkspaceSync(folders?: IWorkspaceFolderCreationData[], remoteAuthority?: string): IWorkspaceIdentifier {\n\t\tconst { workspace, storedWorkspace } = this.newUntitledWorkspace(folders, remoteAuthority);\n\t\tconst configPath = workspace.configPath.fsPath;\n\n\t\tconst configPathDir = dirname(configPath);\n\t\tif (!existsSync(configPathDir)) {\n\t\t\tconst configPathDirDir = dirname(configPathDir);\n\t\t\tif (!existsSync(configPathDirDir)) {\n\t\t\t\tmkdirSync(configPathDirDir);\n\t\t\t}\n\t\t\tmkdirSync(configPathDir);\n\t\t}\n\n\t\twriteFileAndFlushSync(configPath, JSON.stringify(storedWorkspace, null, '\\t'));\n\n\t\treturn workspace;\n\t}\n\n\tprivate newUntitledWorkspace(folders: IWorkspaceFolderCreationData[] = [], remoteAuthority?: string): { workspace: IWorkspaceIdentifier, storedWorkspace: IStoredWorkspace } {\n\t\tconst randomId = (Date.now() + Math.round(Math.random() * 1000)).toString();\n\t\tconst untitledWorkspaceConfigFolder = joinPath(this.untitledWorkspacesHome, randomId);\n\t\tconst untitledWorkspaceConfigPath = joinPath(untitledWorkspaceConfigFolder, UNTITLED_WORKSPACE_NAME);\n\n\t\tconst storedWorkspaceFolder: IStoredWorkspaceFolder[] = [];\n\n\t\tfor (const folder of folders) {\n\t\t\tstoredWorkspaceFolder.push(getStoredWorkspaceFolder(folder.uri, folder.name, untitledWorkspaceConfigFolder));\n\t\t}\n\n\t\treturn {\n\t\t\tworkspace: getWorkspaceIdentifier(untitledWorkspaceConfigPath),\n\t\t\tstoredWorkspace: { folders: storedWorkspaceFolder, remoteAuthority }\n\t\t};\n\t}\n\n\tgetWorkspaceIdentifier(configPath: URI): Promise<IWorkspaceIdentifier> {\n\t\treturn Promise.resolve(getWorkspaceIdentifier(configPath));\n\t}\n\n\tisUntitledWorkspace(workspace: IWorkspaceIdentifier): boolean {\n\t\treturn this.isInsideWorkspacesHome(workspace.configPath);\n\t}\n\n\tdeleteUntitledWorkspaceSync(workspace: IWorkspaceIdentifier): void {\n\t\tif (!this.isUntitledWorkspace(workspace)) {\n\t\t\treturn; // only supported for untitled workspaces\n\t\t}\n\n\t\t// Delete from disk\n\t\tthis.doDeleteUntitledWorkspaceSync(workspace);\n\n\t\t// Event\n\t\tthis._onUntitledWorkspaceDeleted.fire(workspace);\n\t}\n\n\tdeleteUntitledWorkspace(workspace: IWorkspaceIdentifier): Promise<void> {\n\t\tthis.deleteUntitledWorkspaceSync(workspace);\n\t\treturn Promise.resolve();\n\t}\n\n\tprivate doDeleteUntitledWorkspaceSync(workspace: IWorkspaceIdentifier): void {\n\t\tconst configPath = originalFSPath(workspace.configPath);\n\t\ttry {\n\t\t\t// Delete Workspace\n\t\t\tdelSync(dirname(configPath));\n\n\t\t\t// Mark Workspace Storage to be deleted\n\t\t\tconst workspaceStoragePath = join(this.environmentService.workspaceStorageHome, workspace.id);\n\t\t\tif (existsSync(workspaceStoragePath)) {\n\t\t\t\twriteFileSync(join(workspaceStoragePath, 'obsolete'), '');\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.logService.warn(`Unable to delete untitled workspace ${configPath} (${error}).`);\n\t\t}\n\t}\n\n\tgetUntitledWorkspacesSync(): IUntitledWorkspaceInfo[] {\n\t\tlet untitledWorkspaces: IUntitledWorkspaceInfo[] = [];\n\t\ttry {\n\t\t\tconst untitledWorkspacePaths = readdirSync(this.untitledWorkspacesHome.fsPath).map(folder => joinPath(this.untitledWorkspacesHome, folder, UNTITLED_WORKSPACE_NAME));\n\t\t\tfor (const untitledWorkspacePath of untitledWorkspacePaths) {\n\t\t\t\tconst workspace = getWorkspaceIdentifier(untitledWorkspacePath);\n\t\t\t\tconst resolvedWorkspace = this.resolveLocalWorkspaceSync(untitledWorkspacePath);\n\t\t\t\tif (!resolvedWorkspace) {\n\t\t\t\t\tthis.doDeleteUntitledWorkspaceSync(workspace);\n\t\t\t\t} else {\n\t\t\t\t\tuntitledWorkspaces.push({ workspace, remoteAuthority: resolvedWorkspace.remoteAuthority });\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tif (error && error.code !== 'ENOENT') {\n\t\t\t\tthis.logService.warn(`Unable to read folders in ${this.untitledWorkspacesHome} (${error}).`);\n\t\t\t}\n\t\t}\n\t\treturn untitledWorkspaces;\n\t}\n}\n\nfunction getWorkspaceId(configPath: URI): string {\n\tlet workspaceConfigPath = configPath.scheme === Schemas.file ? originalFSPath(configPath) : configPath.toString();\n\tif (!isLinux) {\n\t\tworkspaceConfigPath = workspaceConfigPath.toLowerCase(); // sanitize for platform file system\n\t}\n\n\treturn createHash('md5').update(workspaceConfigPath).digest('hex');\n}\n\nexport function getWorkspaceIdentifier(configPath: URI): IWorkspaceIdentifier {\n\treturn {\n\t\tconfigPath,\n\t\tid: getWorkspaceId(configPath)\n\t};\n}\n"]}]}