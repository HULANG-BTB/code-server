{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/tree.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/tree.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar list_1 = require(\"vs/base/browser/ui/list/list\");\nvar TreeVisibility;\n(function (TreeVisibility) {\n    /**\n     * The tree node should be hidden.\n     */\n    TreeVisibility[TreeVisibility[\"Hidden\"] = 0] = \"Hidden\";\n    /**\n     * The tree node should be visible.\n     */\n    TreeVisibility[TreeVisibility[\"Visible\"] = 1] = \"Visible\";\n    /**\n     * The tree node should be visible if any of its descendants is visible.\n     */\n    TreeVisibility[TreeVisibility[\"Recurse\"] = 2] = \"Recurse\";\n})(TreeVisibility = exports.TreeVisibility || (exports.TreeVisibility = {}));\nvar TreeDragOverBubble;\n(function (TreeDragOverBubble) {\n    TreeDragOverBubble[TreeDragOverBubble[\"Down\"] = 0] = \"Down\";\n    TreeDragOverBubble[TreeDragOverBubble[\"Up\"] = 1] = \"Up\";\n})(TreeDragOverBubble = exports.TreeDragOverBubble || (exports.TreeDragOverBubble = {}));\nexports.TreeDragOverReactions = {\n    acceptBubbleUp: function () { return { accept: true, bubble: TreeDragOverBubble.Up }; },\n    acceptBubbleDown: function (autoExpand) {\n        if (autoExpand === void 0) { autoExpand = false; }\n        return { accept: true, bubble: TreeDragOverBubble.Down, autoExpand: autoExpand };\n    },\n    acceptCopyBubbleUp: function () { return { accept: true, bubble: TreeDragOverBubble.Up, effect: list_1.ListDragOverEffect.Copy }; },\n    acceptCopyBubbleDown: function (autoExpand) {\n        if (autoExpand === void 0) { autoExpand = false; }\n        return { accept: true, bubble: TreeDragOverBubble.Down, effect: list_1.ListDragOverEffect.Copy, autoExpand: autoExpand };\n    }\n};\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/tree.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/tree.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;AAIhG,qDAA0H;AAG1H,IAAkB,cAgBjB;AAhBD,WAAkB,cAAc;IAE/B;;OAEG;IACH,uDAAM,CAAA;IAEN;;OAEG;IACH,yDAAO,CAAA;IAEP;;OAEG;IACH,yDAAO,CAAA;AACR,CAAC,EAhBiB,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAgB/B;AA8ID,IAAkB,kBAGjB;AAHD,WAAkB,kBAAkB;IACnC,2DAAI,CAAA;IACJ,uDAAE,CAAA;AACH,CAAC,EAHiB,kBAAkB,GAAlB,0BAAkB,KAAlB,0BAAkB,QAGnC;AAOY,QAAA,qBAAqB,GAAG;IACpC,cAAc,EAAd,cAA0C,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,kBAAkB,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;IACnG,gBAAgB,EAAhB,UAAiB,UAAkB;QAAlB,2BAAA,EAAA,kBAAkB;QAA2B,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,kBAAkB,CAAC,IAAI,EAAE,UAAU,YAAA,EAAE,CAAC;IAAC,CAAC;IACrI,kBAAkB,EAAlB,cAA8C,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,kBAAkB,CAAC,EAAE,EAAE,MAAM,EAAE,yBAAkB,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;IACxI,oBAAoB,EAApB,UAAqB,UAAkB;QAAlB,2BAAA,EAAA,kBAAkB;QAA2B,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,kBAAkB,CAAC,IAAI,EAAE,MAAM,EAAE,yBAAkB,CAAC,IAAI,EAAE,UAAU,YAAA,EAAE,CAAC;IAAC,CAAC;CAC1K,CAAC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { Iterator } from 'vs/base/common/iterator';\nimport { IListRenderer, IListDragOverReaction, IListDragAndDrop, ListDragOverEffect } from 'vs/base/browser/ui/list/list';\nimport { IDragAndDropData } from 'vs/base/browser/dnd';\n\nexport const enum TreeVisibility {\n\n\t/**\n\t * The tree node should be hidden.\n\t */\n\tHidden,\n\n\t/**\n\t * The tree node should be visible.\n\t */\n\tVisible,\n\n\t/**\n\t * The tree node should be visible if any of its descendants is visible.\n\t */\n\tRecurse\n}\n\n/**\n * A composed filter result containing the visibility result as well as\n * metadata.\n */\nexport interface ITreeFilterDataResult<TFilterData> {\n\n\t/**\n\t * Whether the node should be visibile.\n\t */\n\tvisibility: boolean | TreeVisibility;\n\n\t/**\n\t * Metadata about the element's visibility which gets forwarded to the\n\t * renderer once the element gets rendered.\n\t */\n\tdata: TFilterData;\n}\n\n/**\n * The result of a filter call can be a boolean value indicating whether\n * the element should be visible or not, a value of type `TreeVisibility` or\n * an object composed of the visibility result as well as additional metadata\n * which gets forwarded to the renderer once the element gets rendered.\n */\nexport type TreeFilterResult<TFilterData> = boolean | TreeVisibility | ITreeFilterDataResult<TFilterData>;\n\n/**\n * A tree filter is responsible for controlling the visibility of\n * elements in a tree.\n */\nexport interface ITreeFilter<T, TFilterData = void> {\n\n\t/**\n\t * Returns whether this elements should be visible and, if affirmative,\n\t * additional metadata which gets forwarded to the renderer once the element\n\t * gets rendered.\n\t *\n\t * @param element The tree element.\n\t */\n\tfilter(element: T, parentVisibility: TreeVisibility): TreeFilterResult<TFilterData>;\n}\n\nexport interface ITreeSorter<T> {\n\tcompare(element: T, otherElement: T): number;\n}\n\nexport interface ITreeElement<T> {\n\treadonly element: T;\n\treadonly children?: Iterator<ITreeElement<T>> | ITreeElement<T>[];\n\treadonly collapsible?: boolean;\n\treadonly collapsed?: boolean;\n}\n\nexport interface ITreeNode<T, TFilterData = void> {\n\treadonly element: T;\n\treadonly parent: ITreeNode<T, TFilterData> | undefined;\n\treadonly children: ITreeNode<T, TFilterData>[];\n\treadonly depth: number;\n\treadonly visibleChildrenCount: number;\n\treadonly visibleChildIndex: number;\n\treadonly collapsible: boolean;\n\treadonly collapsed: boolean;\n\treadonly visible: boolean;\n\treadonly filterData: TFilterData | undefined;\n}\n\nexport interface ICollapseStateChangeEvent<T, TFilterData> {\n\tnode: ITreeNode<T, TFilterData>;\n\tdeep: boolean;\n}\n\nexport interface ITreeModelSpliceEvent<T, TFilterData> {\n\tinsertedNodes: ITreeNode<T, TFilterData>[];\n\tdeletedNodes: ITreeNode<T, TFilterData>[];\n}\n\nexport interface ITreeModel<T, TFilterData, TRef> {\n\treadonly rootRef: TRef;\n\n\treadonly onDidSplice: Event<ITreeModelSpliceEvent<T, TFilterData>>;\n\treadonly onDidChangeCollapseState: Event<ICollapseStateChangeEvent<T, TFilterData>>;\n\treadonly onDidChangeRenderNodeCount: Event<ITreeNode<T, TFilterData>>;\n\n\tgetListIndex(location: TRef): number;\n\tgetListRenderCount(location: TRef): number;\n\tgetNode(location?: TRef): ITreeNode<T, any>;\n\tgetNodeLocation(node: ITreeNode<T, any>): TRef;\n\tgetParentNodeLocation(location: TRef): TRef;\n\n\tgetParentElement(location: TRef): T;\n\tgetFirstElementChild(location: TRef): T | undefined;\n\tgetLastElementAncestor(location?: TRef): T | undefined;\n\n\tisCollapsible(location: TRef): boolean;\n\tisCollapsed(location: TRef): boolean;\n\tsetCollapsed(location: TRef, collapsed?: boolean, recursive?: boolean): boolean;\n\texpandTo(location: TRef): void;\n\n\trefilter(): void;\n}\n\nexport interface ITreeRenderer<T, TFilterData = void, TTemplateData = void> extends IListRenderer<ITreeNode<T, TFilterData>, TTemplateData> {\n\trenderTwistie?(element: T, twistieElement: HTMLElement): void;\n\tonDidChangeTwistieState?: Event<T>;\n}\n\nexport interface ITreeEvent<T> {\n\telements: T[];\n\tbrowserEvent?: UIEvent;\n}\n\nexport interface ITreeMouseEvent<T> {\n\tbrowserEvent: MouseEvent;\n\telement: T | null;\n}\n\nexport interface ITreeContextMenuEvent<T> {\n\tbrowserEvent: UIEvent;\n\telement: T | null;\n\tanchor: HTMLElement | { x: number; y: number; };\n}\n\nexport interface ITreeNavigator<T> {\n\tcurrent(): T | null;\n\tprevious(): T | null;\n\tparent(): T | null;\n\tfirst(): T | null;\n\tlast(): T | null;\n\tnext(): T | null;\n}\n\nexport interface IDataSource<TInput, T> {\n\tgetChildren(element: TInput | T): T[];\n}\n\nexport interface IAsyncDataSource<TInput, T> {\n\thasChildren(element: TInput | T): boolean;\n\tgetChildren(element: TInput | T): T[] | Promise<T[]>;\n}\n\nexport const enum TreeDragOverBubble {\n\tDown,\n\tUp\n}\n\nexport interface ITreeDragOverReaction extends IListDragOverReaction {\n\tbubble?: TreeDragOverBubble;\n\tautoExpand?: boolean;\n}\n\nexport const TreeDragOverReactions = {\n\tacceptBubbleUp(): ITreeDragOverReaction { return { accept: true, bubble: TreeDragOverBubble.Up }; },\n\tacceptBubbleDown(autoExpand = false): ITreeDragOverReaction { return { accept: true, bubble: TreeDragOverBubble.Down, autoExpand }; },\n\tacceptCopyBubbleUp(): ITreeDragOverReaction { return { accept: true, bubble: TreeDragOverBubble.Up, effect: ListDragOverEffect.Copy }; },\n\tacceptCopyBubbleDown(autoExpand = false): ITreeDragOverReaction { return { accept: true, bubble: TreeDragOverBubble.Down, effect: ListDragOverEffect.Copy, autoExpand }; }\n};\n\nexport interface ITreeDragAndDrop<T> extends IListDragAndDrop<T> {\n\tonDragOver(data: IDragAndDropData, targetElement: T | undefined, targetIndex: number | undefined, originalEvent: DragEvent): boolean | ITreeDragOverReaction;\n}\n"]}]}