{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/packages/protocol/src/common/util.ts","dependencies":[{"path":"/home/coding/workspace/packages/protocol/src/common/util.ts","mtime":1555841535686},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["define([\"require\", \"exports\", \"../proto\", \"../common/connection\", \"./proxy\"], function (require, exports, proto_1, connection_1, proxy_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // tslint:disable no-any\n    /**\n     * Return true if we're in a browser environment (including web workers).\n     */\n    exports.isBrowserEnvironment = () => {\n        return typeof process === \"undefined\" || typeof process.stdout === \"undefined\";\n    };\n    /**\n     * Escape a path. This prevents any issues with file names that have quotes,\n     * spaces, braces, etc.\n     */\n    exports.escapePath = (path) => {\n        return `'${path.replace(/'/g, \"'\\\\''\")}'`;\n    };\n    /**\n     * Convert an argument to proto.\n     * If sending a function is possible, provide `storeFunction`.\n     * If sending a proxy is possible, provide `storeProxy`.\n     */\n    exports.argumentToProto = (value, storeFunction, storeProxy) => {\n        const convert = (currentValue) => {\n            const message = new proto_1.Argument();\n            if (currentValue instanceof Error\n                || (currentValue && typeof currentValue.message !== \"undefined\"\n                    && typeof currentValue.stack !== \"undefined\")) {\n                const arg = new proto_1.Argument.ErrorValue();\n                arg.setMessage(currentValue.message);\n                arg.setStack(currentValue.stack);\n                arg.setCode(currentValue.code);\n                message.setError(arg);\n            }\n            else if (currentValue instanceof Uint8Array || currentValue instanceof Buffer) {\n                const arg = new proto_1.Argument.BufferValue();\n                arg.setData(currentValue);\n                message.setBuffer(arg);\n            }\n            else if (Array.isArray(currentValue)) {\n                const arg = new proto_1.Argument.ArrayValue();\n                arg.setDataList(currentValue.map(convert));\n                message.setArray(arg);\n            }\n            else if (exports.isProxy(currentValue)) {\n                if (!storeProxy) {\n                    throw new Error(\"no way to serialize proxy\");\n                }\n                const arg = new proto_1.Argument.ProxyValue();\n                arg.setId(storeProxy(currentValue));\n                message.setProxy(arg);\n            }\n            else if (currentValue instanceof Date\n                || (currentValue && typeof currentValue.getTime === \"function\")) {\n                const arg = new proto_1.Argument.DateValue();\n                arg.setDate(currentValue.toString());\n                message.setDate(arg);\n            }\n            else if (currentValue !== null && typeof currentValue === \"object\") {\n                const arg = new proto_1.Argument.ObjectValue();\n                const map = arg.getDataMap();\n                Object.keys(currentValue).forEach((key) => {\n                    map.set(key, convert(currentValue[key]));\n                });\n                message.setObject(arg);\n            }\n            else if (currentValue === null) {\n                message.setNull(new proto_1.Argument.NullValue());\n            }\n            else {\n                switch (typeof currentValue) {\n                    case \"undefined\":\n                        message.setUndefined(new proto_1.Argument.UndefinedValue());\n                        break;\n                    case \"function\":\n                        if (!storeFunction) {\n                            throw new Error(\"no way to serialize function\");\n                        }\n                        const arg = new proto_1.Argument.FunctionValue();\n                        arg.setId(storeFunction(currentValue));\n                        message.setFunction(arg);\n                        break;\n                    case \"number\":\n                        message.setNumber(currentValue);\n                        break;\n                    case \"string\":\n                        message.setString(currentValue);\n                        break;\n                    case \"boolean\":\n                        message.setBoolean(currentValue);\n                        break;\n                    default:\n                        throw new Error(`cannot convert ${typeof currentValue} to proto`);\n                }\n            }\n            return message;\n        };\n        return convert(value);\n    };\n    /**\n     * Convert proto to an argument.\n     * If running a remote callback is supported, provide `runCallback`.\n     * If using a remote proxy is supported, provide `createProxy`.\n     */\n    exports.protoToArgument = (message, runCallback, createProxy) => {\n        const convert = (currentMessage) => {\n            switch (currentMessage.getMsgCase()) {\n                case proto_1.Argument.MsgCase.ERROR:\n                    const errorMessage = currentMessage.getError();\n                    const error = new Error(errorMessage.getMessage());\n                    error.code = errorMessage.getCode();\n                    error.originalStack = errorMessage.getStack();\n                    return error;\n                case proto_1.Argument.MsgCase.BUFFER:\n                    return Buffer.from(currentMessage.getBuffer().getData());\n                case proto_1.Argument.MsgCase.ARRAY:\n                    return currentMessage.getArray().getDataList().map((a) => convert(a));\n                case proto_1.Argument.MsgCase.PROXY:\n                    if (!createProxy) {\n                        throw new Error(\"no way to create proxy\");\n                    }\n                    return createProxy(currentMessage.getProxy().getId());\n                case proto_1.Argument.MsgCase.DATE:\n                    return new Date(currentMessage.getDate().getDate());\n                case proto_1.Argument.MsgCase.OBJECT:\n                    const obj = {};\n                    currentMessage.getObject().getDataMap().forEach((argument, key) => {\n                        obj[key] = convert(argument);\n                    });\n                    return obj;\n                case proto_1.Argument.MsgCase.UNDEFINED:\n                    return undefined;\n                case proto_1.Argument.MsgCase.NULL:\n                    return null;\n                case proto_1.Argument.MsgCase.FUNCTION:\n                    if (!runCallback) {\n                        throw new Error(\"no way to run remote callback\");\n                    }\n                    return (...args) => {\n                        return runCallback(currentMessage.getFunction().getId(), args);\n                    };\n                case proto_1.Argument.MsgCase.NUMBER:\n                    return currentMessage.getNumber();\n                case proto_1.Argument.MsgCase.STRING:\n                    return currentMessage.getString();\n                case proto_1.Argument.MsgCase.BOOLEAN:\n                    return currentMessage.getBoolean();\n                default:\n                    throw new Error(\"cannot convert unexpected proto to argument\");\n            }\n        };\n        return message && convert(message);\n    };\n    exports.protoToModule = (protoModule) => {\n        switch (protoModule) {\n            case proto_1.Module.CHILDPROCESS: return proxy_1.Module.ChildProcess;\n            case proto_1.Module.FS: return proxy_1.Module.Fs;\n            case proto_1.Module.NET: return proxy_1.Module.Net;\n            case proto_1.Module.NODEPTY: return proxy_1.Module.NodePty;\n            case proto_1.Module.SPDLOG: return proxy_1.Module.Spdlog;\n            case proto_1.Module.TRASH: return proxy_1.Module.Trash;\n            default: throw new Error(`invalid module ${protoModule}`);\n        }\n    };\n    exports.moduleToProto = (moduleName) => {\n        switch (moduleName) {\n            case proxy_1.Module.ChildProcess: return proto_1.Module.CHILDPROCESS;\n            case proxy_1.Module.Fs: return proto_1.Module.FS;\n            case proxy_1.Module.Net: return proto_1.Module.NET;\n            case proxy_1.Module.NodePty: return proto_1.Module.NODEPTY;\n            case proxy_1.Module.Spdlog: return proto_1.Module.SPDLOG;\n            case proxy_1.Module.Trash: return proto_1.Module.TRASH;\n            default: throw new Error(`invalid module \"${moduleName}\"`);\n        }\n    };\n    exports.protoToOperatingSystem = (protoOp) => {\n        switch (protoOp) {\n            case proto_1.WorkingInit.OperatingSystem.WINDOWS: return connection_1.OperatingSystem.Windows;\n            case proto_1.WorkingInit.OperatingSystem.LINUX: return connection_1.OperatingSystem.Linux;\n            case proto_1.WorkingInit.OperatingSystem.MAC: return connection_1.OperatingSystem.Mac;\n            default: throw new Error(`unsupported operating system ${protoOp}`);\n        }\n    };\n    exports.platformToProto = (platform) => {\n        switch (platform) {\n            case \"win32\": return proto_1.WorkingInit.OperatingSystem.WINDOWS;\n            case \"linux\": return proto_1.WorkingInit.OperatingSystem.LINUX;\n            case \"darwin\": return proto_1.WorkingInit.OperatingSystem.MAC;\n            default: throw new Error(`unrecognized platform \"${platform}\"`);\n        }\n    };\n    exports.isProxy = (value) => {\n        return value && typeof value === \"object\" && typeof value.onEvent === \"function\";\n    };\n    exports.isPromise = (value) => {\n        return typeof value.then === \"function\" && typeof value.catch === \"function\";\n    };\n    /**\n     * When spawning VS Code tries to preserve the environment but since it's in\n     * the browser, it doesn't work.\n     */\n    exports.preserveEnv = (options) => {\n        if (options && options.env) {\n            options.env = Object.assign({}, process.env, options.env);\n        }\n    };\n});\n",null]}