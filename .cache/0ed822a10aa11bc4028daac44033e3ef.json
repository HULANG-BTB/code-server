{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/node/terminals.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/node/terminals.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"child_process\", \"vs/nls\", \"vs/base/common/platform\", \"vs/base/node/pfs\", \"vs/base/common/objects\", \"vs/base/common/amd\"], function (require, exports, cp, nls, env, pfs, objects_1, amd_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const TERMINAL_TITLE = nls.localize('console.title', \"VS Code Console\");\n    let terminalLauncher = undefined;\n    function getTerminalLauncher() {\n        if (!terminalLauncher) {\n            if (env.isWindows) {\n                terminalLauncher = new WinTerminalService();\n            }\n            else if (env.isMacintosh) {\n                terminalLauncher = new MacTerminalService();\n            }\n            else if (env.isLinux) {\n                terminalLauncher = new LinuxTerminalService();\n            }\n        }\n        return terminalLauncher;\n    }\n    exports.getTerminalLauncher = getTerminalLauncher;\n    let _DEFAULT_TERMINAL_LINUX_READY = null;\n    function getDefaultTerminalLinuxReady() {\n        if (!_DEFAULT_TERMINAL_LINUX_READY) {\n            _DEFAULT_TERMINAL_LINUX_READY = new Promise(c => {\n                if (env.isLinux) {\n                    Promise.all([pfs.exists('/etc/debian_version'), process.lazyEnv]).then(([isDebian]) => {\n                        if (isDebian) {\n                            c('x-terminal-emulator');\n                        }\n                        else if (process.env.DESKTOP_SESSION === 'gnome' || process.env.DESKTOP_SESSION === 'gnome-classic') {\n                            c('gnome-terminal');\n                        }\n                        else if (process.env.DESKTOP_SESSION === 'kde-plasma') {\n                            c('konsole');\n                        }\n                        else if (process.env.COLORTERM) {\n                            c(process.env.COLORTERM);\n                        }\n                        else if (process.env.TERM) {\n                            c(process.env.TERM);\n                        }\n                        else {\n                            c('xterm');\n                        }\n                    });\n                    return;\n                }\n                c('xterm');\n            });\n        }\n        return _DEFAULT_TERMINAL_LINUX_READY;\n    }\n    exports.getDefaultTerminalLinuxReady = getDefaultTerminalLinuxReady;\n    let _DEFAULT_TERMINAL_WINDOWS = null;\n    function getDefaultTerminalWindows() {\n        if (!_DEFAULT_TERMINAL_WINDOWS) {\n            const isWoW64 = !!process.env.hasOwnProperty('PROCESSOR_ARCHITEW6432');\n            _DEFAULT_TERMINAL_WINDOWS = `${process.env.windir ? process.env.windir : 'C:\\\\Windows'}\\\\${isWoW64 ? 'Sysnative' : 'System32'}\\\\cmd.exe`;\n        }\n        return _DEFAULT_TERMINAL_WINDOWS;\n    }\n    exports.getDefaultTerminalWindows = getDefaultTerminalWindows;\n    class TerminalLauncher {\n        runInTerminal(args, config) {\n            return this.runInTerminal0(args.title, args.cwd, args.args, args.env || {}, config);\n        }\n    }\n    class WinTerminalService extends TerminalLauncher {\n        runInTerminal0(title, dir, args, envVars, configuration) {\n            const exec = configuration.external.windowsExec || getDefaultTerminalWindows();\n            return new Promise((c, e) => {\n                const title = `\"${dir} - ${TERMINAL_TITLE}\"`;\n                const command = `\"\"${args.join('\" \"')}\" & pause\"`; // use '|' to only pause on non-zero exit code\n                const cmdArgs = [\n                    '/c', 'start', title, '/wait', exec, '/c', command\n                ];\n                // merge environment variables into a copy of the process.env\n                const env = objects_1.assign({}, process.env, envVars);\n                // delete environment variables that have a null value\n                Object.keys(env).filter(v => env[v] === null).forEach(key => delete env[key]);\n                const options = {\n                    cwd: dir,\n                    env: env,\n                    windowsVerbatimArguments: true\n                };\n                const cmd = cp.spawn(WinTerminalService.CMD, cmdArgs, options);\n                cmd.on('error', e);\n                c(undefined);\n            });\n        }\n    }\n    WinTerminalService.CMD = 'cmd.exe';\n    class MacTerminalService extends TerminalLauncher {\n        runInTerminal0(title, dir, args, envVars, configuration) {\n            const terminalApp = configuration.external.osxExec || MacTerminalService.DEFAULT_TERMINAL_OSX;\n            return new Promise((c, e) => {\n                if (terminalApp === MacTerminalService.DEFAULT_TERMINAL_OSX || terminalApp === 'iTerm.app') {\n                    // On OS X we launch an AppleScript that creates (or reuses) a Terminal window\n                    // and then launches the program inside that window.\n                    const script = terminalApp === MacTerminalService.DEFAULT_TERMINAL_OSX ? 'TerminalHelper' : 'iTermHelper';\n                    const scriptpath = amd_1.getPathFromAmdModule(require, `vs/workbench/contrib/externalTerminal/electron-browser/${script}.scpt`);\n                    const osaArgs = [\n                        scriptpath,\n                        '-t', title || TERMINAL_TITLE,\n                        '-w', dir,\n                    ];\n                    for (let a of args) {\n                        osaArgs.push('-a');\n                        osaArgs.push(a);\n                    }\n                    if (envVars) {\n                        for (let key in envVars) {\n                            const value = envVars[key];\n                            if (value === null) {\n                                osaArgs.push('-u');\n                                osaArgs.push(key);\n                            }\n                            else {\n                                osaArgs.push('-e');\n                                osaArgs.push(`${key}=${value}`);\n                            }\n                        }\n                    }\n                    let stderr = '';\n                    const osa = cp.spawn(MacTerminalService.OSASCRIPT, osaArgs);\n                    osa.on('error', e);\n                    osa.stderr.on('data', (data) => {\n                        stderr += data.toString();\n                    });\n                    osa.on('exit', (code) => {\n                        if (code === 0) { // OK\n                            c(undefined);\n                        }\n                        else {\n                            if (stderr) {\n                                const lines = stderr.split('\\n', 1);\n                                e(new Error(lines[0]));\n                            }\n                            else {\n                                e(new Error(nls.localize('mac.terminal.script.failed', \"Script '{0}' failed with exit code {1}\", script, code)));\n                            }\n                        }\n                    });\n                }\n                else {\n                    e(new Error(nls.localize('mac.terminal.type.not.supported', \"'{0}' not supported\", terminalApp)));\n                }\n            });\n        }\n    }\n    MacTerminalService.DEFAULT_TERMINAL_OSX = 'Terminal.app';\n    MacTerminalService.OSASCRIPT = '/usr/bin/osascript'; // osascript is the AppleScript interpreter on OS X\n    class LinuxTerminalService extends TerminalLauncher {\n        runInTerminal0(title, dir, args, envVars, configuration) {\n            const terminalConfig = configuration.external;\n            const execThenable = terminalConfig.linuxExec ? Promise.resolve(terminalConfig.linuxExec) : getDefaultTerminalLinuxReady();\n            return new Promise((c, e) => {\n                let termArgs = [];\n                //termArgs.push('--title');\n                //termArgs.push(`\"${TERMINAL_TITLE}\"`);\n                execThenable.then(exec => {\n                    if (exec.indexOf('gnome-terminal') >= 0) {\n                        termArgs.push('-x');\n                    }\n                    else {\n                        termArgs.push('-e');\n                    }\n                    termArgs.push('bash');\n                    termArgs.push('-c');\n                    const bashCommand = `${quote(args)}; echo; read -p \"${LinuxTerminalService.WAIT_MESSAGE}\" -n1;`;\n                    termArgs.push(`''${bashCommand}''`); // wrapping argument in two sets of ' because node is so \"friendly\" that it removes one set...\n                    // merge environment variables into a copy of the process.env\n                    const env = objects_1.assign({}, process.env, envVars);\n                    // delete environment variables that have a null value\n                    Object.keys(env).filter(v => env[v] === null).forEach(key => delete env[key]);\n                    const options = {\n                        cwd: dir,\n                        env: env\n                    };\n                    let stderr = '';\n                    const cmd = cp.spawn(exec, termArgs, options);\n                    cmd.on('error', e);\n                    cmd.stderr.on('data', (data) => {\n                        stderr += data.toString();\n                    });\n                    cmd.on('exit', (code) => {\n                        if (code === 0) { // OK\n                            c(undefined);\n                        }\n                        else {\n                            if (stderr) {\n                                const lines = stderr.split('\\n', 1);\n                                e(new Error(lines[0]));\n                            }\n                            else {\n                                e(new Error(nls.localize('linux.term.failed', \"'{0}' failed with exit code {1}\", exec, code)));\n                            }\n                        }\n                    });\n                });\n            });\n        }\n    }\n    LinuxTerminalService.WAIT_MESSAGE = nls.localize('press.any.key', \"Press any key to continue...\");\n    /**\n     * Quote args if necessary and combine into a space separated string.\n     */\n    function quote(args) {\n        let r = '';\n        for (let a of args) {\n            if (a.indexOf(' ') >= 0) {\n                r += '\"' + a + '\"';\n            }\n            else {\n                r += a;\n            }\n            r += ' ';\n        }\n        return r;\n    }\n    function hasChildProcesses(processId) {\n        if (processId) {\n            try {\n                // if shell has at least one child process, assume that shell is busy\n                if (env.isWindows) {\n                    const result = cp.spawnSync('wmic', ['process', 'get', 'ParentProcessId']);\n                    if (result.stdout) {\n                        const pids = result.stdout.toString().split('\\r\\n');\n                        if (!pids.some(p => parseInt(p) === processId)) {\n                            return false;\n                        }\n                    }\n                }\n                else {\n                    const result = cp.spawnSync('/usr/bin/pgrep', ['-lP', String(processId)]);\n                    if (result.stdout) {\n                        const r = result.stdout.toString().trim();\n                        if (r.length === 0 || r.indexOf(' tmux') >= 0) { // ignore 'tmux'; see #43683\n                            return false;\n                        }\n                    }\n                }\n            }\n            catch (e) {\n                // silently ignore\n            }\n        }\n        // fall back to safe side\n        return true;\n    }\n    exports.hasChildProcesses = hasChildProcesses;\n    var ShellType;\n    (function (ShellType) {\n        ShellType[ShellType[\"cmd\"] = 0] = \"cmd\";\n        ShellType[ShellType[\"powershell\"] = 1] = \"powershell\";\n        ShellType[ShellType[\"bash\"] = 2] = \"bash\";\n    })(ShellType || (ShellType = {}));\n    function prepareCommand(args, config) {\n        let shellType;\n        // get the shell configuration for the current platform\n        let shell;\n        const shell_config = config.integrated.shell;\n        if (env.isWindows) {\n            shell = shell_config.windows;\n            shellType = ShellType.cmd;\n        }\n        else if (env.isLinux) {\n            shell = shell_config.linux;\n            shellType = ShellType.bash;\n        }\n        else if (env.isMacintosh) {\n            shell = shell_config.osx;\n            shellType = ShellType.bash;\n        }\n        else {\n            throw new Error('Unknown platform');\n        }\n        // try to determine the shell type\n        shell = shell.trim().toLowerCase();\n        if (shell.indexOf('powershell') >= 0 || shell.indexOf('pwsh') >= 0) {\n            shellType = ShellType.powershell;\n        }\n        else if (shell.indexOf('cmd.exe') >= 0) {\n            shellType = ShellType.cmd;\n        }\n        else if (shell.indexOf('bash') >= 0) {\n            shellType = ShellType.bash;\n        }\n        else if (shell.indexOf('git\\\\bin\\\\bash.exe') >= 0) {\n            shellType = ShellType.bash;\n        }\n        let quote;\n        let command = '';\n        switch (shellType) {\n            case ShellType.powershell:\n                quote = (s) => {\n                    s = s.replace(/\\'/g, '\\'\\'');\n                    return `'${s}'`;\n                    //return s.indexOf(' ') >= 0 || s.indexOf('\\'') >= 0 || s.indexOf('\"') >= 0 ? `'${s}'` : s;\n                };\n                if (args.cwd) {\n                    command += `cd '${args.cwd}'; `;\n                }\n                if (args.env) {\n                    for (let key in args.env) {\n                        const value = args.env[key];\n                        if (value === null) {\n                            command += `Remove-Item env:${key}; `;\n                        }\n                        else {\n                            command += `\\${env:${key}}='${value}'; `;\n                        }\n                    }\n                }\n                if (args.args && args.args.length > 0) {\n                    const cmd = quote(args.args.shift());\n                    command += (cmd[0] === '\\'') ? `& ${cmd} ` : `${cmd} `;\n                    for (let a of args.args) {\n                        command += `${quote(a)} `;\n                    }\n                }\n                break;\n            case ShellType.cmd:\n                quote = (s) => {\n                    s = s.replace(/\\\"/g, '\"\"');\n                    return (s.indexOf(' ') >= 0 || s.indexOf('\"') >= 0) ? `\"${s}\"` : s;\n                };\n                if (args.cwd) {\n                    command += `cd ${quote(args.cwd)} && `;\n                }\n                if (args.env) {\n                    command += 'cmd /C \"';\n                    for (let key in args.env) {\n                        let value = args.env[key];\n                        if (value === null) {\n                            command += `set \"${key}=\" && `;\n                        }\n                        else {\n                            value = value.replace(/[\\^\\&]/g, s => `^${s}`);\n                            command += `set \"${key}=${value}\" && `;\n                        }\n                    }\n                }\n                for (let a of args.args) {\n                    command += `${quote(a)} `;\n                }\n                if (args.env) {\n                    command += '\"';\n                }\n                break;\n            case ShellType.bash:\n                quote = (s) => {\n                    s = s.replace(/\\\"/g, '\\\\\"');\n                    return (s.indexOf(' ') >= 0 || s.indexOf('\\\\') >= 0) ? `\"${s}\"` : s;\n                };\n                const hardQuote = (s) => {\n                    return /[^\\w@%\\/+=,.:^-]/.test(s) ? `'${s.replace(/'/g, '\\'\\\\\\'\\'')}'` : s;\n                };\n                if (args.cwd) {\n                    command += `cd ${quote(args.cwd)} ; `;\n                }\n                if (args.env) {\n                    command += 'env';\n                    for (let key in args.env) {\n                        const value = args.env[key];\n                        if (value === null) {\n                            command += ` -u ${hardQuote(key)}`;\n                        }\n                        else {\n                            command += ` ${hardQuote(`${key}=${value}`)}`;\n                        }\n                    }\n                    command += ' ';\n                }\n                for (let a of args.args) {\n                    command += `${quote(a)} `;\n                }\n                break;\n        }\n        return command;\n    }\n    exports.prepareCommand = prepareCommand;\n});\n",null]}