{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/extensionManagement/node/extensionGalleryService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/extensionManagement/node/extensionGalleryService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"os\", \"vs/base/common/path\", \"vs/base/common/arrays\", \"vs/base/common/errors\", \"vs/platform/extensionManagement/common/extensionManagement\", \"vs/platform/extensionManagement/common/extensionManagementUtil\", \"vs/base/common/objects\", \"vs/platform/request/node/request\", \"vs/platform/telemetry/common/telemetry\", \"vs/base/node/request\", \"vs/platform/product/node/package\", \"vs/platform/product/node/product\", \"vs/platform/extensions/node/extensionValidator\", \"vs/platform/environment/common/environment\", \"vs/base/node/pfs\", \"vs/base/node/extfs\", \"vs/base/common/uuid\", \"vs/base/common/map\", \"vs/base/common/cancellation\", \"vs/platform/log/common/log\"], function (require, exports, os_1, path, arrays_1, errors_1, extensionManagement_1, extensionManagementUtil_1, objects_1, request_1, telemetry_1, request_2, package_1, product_1, extensionValidator_1, environment_1, pfs_1, extfs_1, uuid_1, map_1, cancellation_1, log_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Flags;\n    (function (Flags) {\n        Flags[Flags[\"None\"] = 0] = \"None\";\n        Flags[Flags[\"IncludeVersions\"] = 1] = \"IncludeVersions\";\n        Flags[Flags[\"IncludeFiles\"] = 2] = \"IncludeFiles\";\n        Flags[Flags[\"IncludeCategoryAndTags\"] = 4] = \"IncludeCategoryAndTags\";\n        Flags[Flags[\"IncludeSharedAccounts\"] = 8] = \"IncludeSharedAccounts\";\n        Flags[Flags[\"IncludeVersionProperties\"] = 16] = \"IncludeVersionProperties\";\n        Flags[Flags[\"ExcludeNonValidated\"] = 32] = \"ExcludeNonValidated\";\n        Flags[Flags[\"IncludeInstallationTargets\"] = 64] = \"IncludeInstallationTargets\";\n        Flags[Flags[\"IncludeAssetUri\"] = 128] = \"IncludeAssetUri\";\n        Flags[Flags[\"IncludeStatistics\"] = 256] = \"IncludeStatistics\";\n        Flags[Flags[\"IncludeLatestVersionOnly\"] = 512] = \"IncludeLatestVersionOnly\";\n        Flags[Flags[\"Unpublished\"] = 4096] = \"Unpublished\";\n    })(Flags || (Flags = {}));\n    function flagsToString(...flags) {\n        return String(flags.reduce((r, f) => r | f, 0));\n    }\n    var FilterType;\n    (function (FilterType) {\n        FilterType[FilterType[\"Tag\"] = 1] = \"Tag\";\n        FilterType[FilterType[\"ExtensionId\"] = 4] = \"ExtensionId\";\n        FilterType[FilterType[\"Category\"] = 5] = \"Category\";\n        FilterType[FilterType[\"ExtensionName\"] = 7] = \"ExtensionName\";\n        FilterType[FilterType[\"Target\"] = 8] = \"Target\";\n        FilterType[FilterType[\"Featured\"] = 9] = \"Featured\";\n        FilterType[FilterType[\"SearchText\"] = 10] = \"SearchText\";\n        FilterType[FilterType[\"ExcludeWithFlags\"] = 12] = \"ExcludeWithFlags\";\n    })(FilterType || (FilterType = {}));\n    const AssetType = {\n        Icon: 'Microsoft.VisualStudio.Services.Icons.Default',\n        Details: 'Microsoft.VisualStudio.Services.Content.Details',\n        Changelog: 'Microsoft.VisualStudio.Services.Content.Changelog',\n        Manifest: 'Microsoft.VisualStudio.Code.Manifest',\n        VSIX: 'Microsoft.VisualStudio.Services.VSIXPackage',\n        License: 'Microsoft.VisualStudio.Services.Content.License',\n        Repository: 'Microsoft.VisualStudio.Services.Links.Source'\n    };\n    const PropertyType = {\n        Dependency: 'Microsoft.VisualStudio.Code.ExtensionDependencies',\n        ExtensionPack: 'Microsoft.VisualStudio.Code.ExtensionPack',\n        Engine: 'Microsoft.VisualStudio.Code.Engine',\n        LocalizedLanguages: 'Microsoft.VisualStudio.Code.LocalizedLanguages'\n    };\n    const DefaultPageSize = 10;\n    const DefaultQueryState = {\n        pageNumber: 1,\n        pageSize: DefaultPageSize,\n        sortBy: extensionManagement_1.SortBy.NoneOrRelevance,\n        sortOrder: extensionManagement_1.SortOrder.Default,\n        flags: Flags.None,\n        criteria: [],\n        assetTypes: []\n    };\n    class Query {\n        constructor(state = DefaultQueryState) {\n            this.state = state;\n        }\n        get pageNumber() { return this.state.pageNumber; }\n        get pageSize() { return this.state.pageSize; }\n        get sortBy() { return this.state.sortBy; }\n        get sortOrder() { return this.state.sortOrder; }\n        get flags() { return this.state.flags; }\n        withPage(pageNumber, pageSize = this.state.pageSize) {\n            return new Query(objects_1.assign({}, this.state, { pageNumber, pageSize }));\n        }\n        withFilter(filterType, ...values) {\n            const criteria = [\n                ...this.state.criteria,\n                ...values.map(value => ({ filterType, value }))\n            ];\n            return new Query(objects_1.assign({}, this.state, { criteria }));\n        }\n        withSortBy(sortBy) {\n            return new Query(objects_1.assign({}, this.state, { sortBy }));\n        }\n        withSortOrder(sortOrder) {\n            return new Query(objects_1.assign({}, this.state, { sortOrder }));\n        }\n        withFlags(...flags) {\n            return new Query(objects_1.assign({}, this.state, { flags: flags.reduce((r, f) => r | f, 0) }));\n        }\n        withAssetTypes(...assetTypes) {\n            return new Query(objects_1.assign({}, this.state, { assetTypes }));\n        }\n        get raw() {\n            const { criteria, pageNumber, pageSize, sortBy, sortOrder, flags, assetTypes } = this.state;\n            const filters = [{ criteria, pageNumber, pageSize, sortBy, sortOrder }];\n            return { filters, assetTypes, flags };\n        }\n        get searchText() {\n            const criterium = this.state.criteria.filter(criterium => criterium.filterType === FilterType.SearchText)[0];\n            return criterium && criterium.value ? criterium.value : '';\n        }\n    }\n    function getStatistic(statistics, name) {\n        const result = (statistics || []).filter(s => s.statisticName === name)[0];\n        return result ? result.value : 0;\n    }\n    function getCoreTranslationAssets(version) {\n        const coreTranslationAssetPrefix = 'Microsoft.VisualStudio.Code.Translation.';\n        const result = version.files.filter(f => f.assetType.indexOf(coreTranslationAssetPrefix) === 0);\n        return result.reduce((result, file) => {\n            result[file.assetType.substring(coreTranslationAssetPrefix.length)] = getVersionAsset(version, file.assetType);\n            return result;\n        }, {});\n    }\n    function getRepositoryAsset(version) {\n        if (version.properties) {\n            const results = version.properties.filter(p => p.key === AssetType.Repository);\n            const gitRegExp = new RegExp('((git|ssh|http(s)?)|(git@[\\w\\.]+))(:(//)?)([\\w\\.@\\:/\\-~]+)(\\.git)(/)?');\n            const uri = results.filter(r => gitRegExp.test(r.value))[0];\n            return uri ? { uri: uri.value, fallbackUri: uri.value } : null;\n        }\n        return getVersionAsset(version, AssetType.Repository);\n    }\n    function getDownloadAsset(version) {\n        return {\n            uri: `${version.fallbackAssetUri}/${AssetType.VSIX}?redirect=true`,\n            fallbackUri: `${version.fallbackAssetUri}/${AssetType.VSIX}`\n        };\n    }\n    function getIconAsset(version) {\n        const asset = getVersionAsset(version, AssetType.Icon);\n        if (asset) {\n            return asset;\n        }\n        const uri = require.toUrl('./media/defaultIcon.png');\n        return { uri, fallbackUri: uri };\n    }\n    function getVersionAsset(version, type) {\n        const result = version.files.filter(f => f.assetType === type)[0];\n        return result ? { uri: `${version.assetUri}/${type}`, fallbackUri: `${version.fallbackAssetUri}/${type}` } : null;\n    }\n    function getExtensions(version, property) {\n        const values = version.properties ? version.properties.filter(p => p.key === property) : [];\n        const value = values.length > 0 && values[0].value;\n        return value ? value.split(',').map(v => extensionManagementUtil_1.adoptToGalleryExtensionId(v)) : [];\n    }\n    function getEngine(version) {\n        const values = version.properties ? version.properties.filter(p => p.key === PropertyType.Engine) : [];\n        return (values.length > 0 && values[0].value) || '';\n    }\n    function getLocalizedLanguages(version) {\n        const values = version.properties ? version.properties.filter(p => p.key === PropertyType.LocalizedLanguages) : [];\n        const value = (values.length > 0 && values[0].value) || '';\n        return value ? value.split(',') : [];\n    }\n    function getIsPreview(flags) {\n        return flags.indexOf('preview') !== -1;\n    }\n    function toExtension(galleryExtension, version, index, query, querySource) {\n        const assets = {\n            manifest: getVersionAsset(version, AssetType.Manifest),\n            readme: getVersionAsset(version, AssetType.Details),\n            changelog: getVersionAsset(version, AssetType.Changelog),\n            license: getVersionAsset(version, AssetType.License),\n            repository: getRepositoryAsset(version),\n            download: getDownloadAsset(version),\n            icon: getIconAsset(version),\n            coreTranslations: getCoreTranslationAssets(version)\n        };\n        return {\n            identifier: {\n                id: extensionManagementUtil_1.getGalleryExtensionId(galleryExtension.publisher.publisherName, galleryExtension.extensionName),\n                uuid: galleryExtension.extensionId\n            },\n            name: galleryExtension.extensionName,\n            version: version.version,\n            date: version.lastUpdated,\n            displayName: galleryExtension.displayName,\n            publisherId: galleryExtension.publisher.publisherId,\n            publisher: galleryExtension.publisher.publisherName,\n            publisherDisplayName: galleryExtension.publisher.displayName,\n            description: galleryExtension.shortDescription || '',\n            installCount: getStatistic(galleryExtension.statistics, 'install') + getStatistic(galleryExtension.statistics, 'updateCount'),\n            rating: getStatistic(galleryExtension.statistics, 'averagerating'),\n            ratingCount: getStatistic(galleryExtension.statistics, 'ratingcount'),\n            assets,\n            properties: {\n                dependencies: getExtensions(version, PropertyType.Dependency),\n                extensionPack: getExtensions(version, PropertyType.ExtensionPack),\n                engine: getEngine(version),\n                localizedLanguages: getLocalizedLanguages(version)\n            },\n            /* __GDPR__FRAGMENT__\n                \"GalleryExtensionTelemetryData2\" : {\n                    \"index\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                    \"searchText\": { \"classification\": \"CustomerContent\", \"purpose\": \"FeatureInsight\" },\n                    \"querySource\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                }\n            */\n            telemetryData: {\n                index: ((query.pageNumber - 1) * query.pageSize) + index,\n                searchText: query.searchText,\n                querySource\n            },\n            preview: getIsPreview(galleryExtension.flags)\n        };\n    }\n    let ExtensionGalleryService = class ExtensionGalleryService {\n        constructor(requestService, logService, environmentService, telemetryService) {\n            this.requestService = requestService;\n            this.logService = logService;\n            this.environmentService = environmentService;\n            this.telemetryService = telemetryService;\n            const config = product_1.default.extensionsGallery;\n            this.extensionsGalleryUrl = config && config.serviceUrl;\n            this.extensionsControlUrl = config && config.controlUrl;\n            this.commonHeadersPromise = resolveMarketplaceHeaders(this.environmentService);\n        }\n        api(path = '') {\n            return `${this.extensionsGalleryUrl}${path}`;\n        }\n        isEnabled() {\n            return !!this.extensionsGalleryUrl;\n        }\n        getCompatibleExtension(arg1, version) {\n            const extension = extensionManagement_1.isIExtensionIdentifier(arg1) ? null : arg1;\n            if (extension && extension.properties.engine && extensionValidator_1.isEngineValid(extension.properties.engine)) {\n                return Promise.resolve(extension);\n            }\n            const { id, uuid } = extension ? extension.identifier : arg1;\n            let query = new Query()\n                .withFlags(Flags.IncludeAssetUri, Flags.IncludeStatistics, Flags.IncludeFiles, Flags.IncludeVersionProperties, Flags.ExcludeNonValidated)\n                .withPage(1, 1)\n                .withFilter(FilterType.Target, 'Microsoft.VisualStudio.Code')\n                .withFilter(FilterType.ExcludeWithFlags, flagsToString(Flags.Unpublished));\n            if (uuid) {\n                query = query.withFilter(FilterType.ExtensionId, uuid);\n            }\n            else {\n                query = query.withFilter(FilterType.ExtensionName, id);\n            }\n            return this.queryGallery(query, cancellation_1.CancellationToken.None)\n                .then(({ galleryExtensions }) => {\n                const [rawExtension] = galleryExtensions;\n                if (!rawExtension || !rawExtension.versions.length) {\n                    return null;\n                }\n                if (version) {\n                    const versionAsset = rawExtension.versions.filter(v => v.version === version)[0];\n                    if (versionAsset) {\n                        const extension = toExtension(rawExtension, versionAsset, 0, query);\n                        if (extension.properties.engine && extensionValidator_1.isEngineValid(extension.properties.engine)) {\n                            return extension;\n                        }\n                    }\n                    return null;\n                }\n                return this.getLastValidExtensionVersion(rawExtension, rawExtension.versions)\n                    .then(rawVersion => {\n                    if (rawVersion) {\n                        return toExtension(rawExtension, rawVersion, 0, query);\n                    }\n                    return null;\n                });\n            });\n        }\n        query(arg1, arg2) {\n            const options = cancellation_1.CancellationToken.isCancellationToken(arg1) ? {} : arg1;\n            const token = cancellation_1.CancellationToken.isCancellationToken(arg1) ? arg1 : arg2;\n            if (!this.isEnabled()) {\n                return Promise.reject(new Error('No extension gallery service configured.'));\n            }\n            const type = options.names ? 'ids' : (options.text ? 'text' : 'all');\n            let text = options.text || '';\n            const pageSize = objects_1.getOrDefault(options, o => o.pageSize, 50);\n            /* __GDPR__\n                \"galleryService:query\" : {\n                    \"type\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                    \"text\": { \"classification\": \"CustomerContent\", \"purpose\": \"FeatureInsight\" }\n                }\n            */\n            this.telemetryService.publicLog('galleryService:query', { type, text });\n            let query = new Query()\n                .withFlags(Flags.IncludeLatestVersionOnly, Flags.IncludeAssetUri, Flags.IncludeStatistics, Flags.IncludeFiles, Flags.IncludeVersionProperties)\n                .withPage(1, pageSize)\n                .withFilter(FilterType.Target, 'Microsoft.VisualStudio.Code')\n                .withFilter(FilterType.ExcludeWithFlags, flagsToString(Flags.Unpublished));\n            if (text) {\n                // Use category filter instead of \"category:themes\"\n                text = text.replace(/\\bcategory:(\"([^\"]*)\"|([^\"]\\S*))(\\s+|\\b|$)/g, (_, quotedCategory, category) => {\n                    query = query.withFilter(FilterType.Category, category || quotedCategory);\n                    return '';\n                });\n                // Use tag filter instead of \"tag:debuggers\"\n                text = text.replace(/\\btag:(\"([^\"]*)\"|([^\"]\\S*))(\\s+|\\b|$)/g, (_, quotedTag, tag) => {\n                    query = query.withFilter(FilterType.Tag, tag || quotedTag);\n                    return '';\n                });\n                text = text.trim();\n                if (text) {\n                    text = text.length < 200 ? text : text.substring(0, 200);\n                    query = query.withFilter(FilterType.SearchText, text);\n                }\n                query = query.withSortBy(extensionManagement_1.SortBy.NoneOrRelevance);\n            }\n            else if (options.ids) {\n                query = query.withFilter(FilterType.ExtensionId, ...options.ids);\n            }\n            else if (options.names) {\n                query = query.withFilter(FilterType.ExtensionName, ...options.names);\n            }\n            else {\n                query = query.withSortBy(extensionManagement_1.SortBy.InstallCount);\n            }\n            if (typeof options.sortBy === 'number') {\n                query = query.withSortBy(options.sortBy);\n            }\n            if (typeof options.sortOrder === 'number') {\n                query = query.withSortOrder(options.sortOrder);\n            }\n            return this.queryGallery(query, token).then(({ galleryExtensions, total }) => {\n                const extensions = galleryExtensions.map((e, index) => toExtension(e, e.versions[0], index, query, options.source));\n                const pageSize = query.pageSize;\n                const getPage = (pageIndex, ct) => {\n                    if (ct.isCancellationRequested) {\n                        return Promise.reject(errors_1.canceled());\n                    }\n                    const nextPageQuery = query.withPage(pageIndex + 1);\n                    return this.queryGallery(nextPageQuery, ct)\n                        .then(({ galleryExtensions }) => galleryExtensions.map((e, index) => toExtension(e, e.versions[0], index, nextPageQuery, options.source)));\n                };\n                return { firstPage: extensions, total, pageSize, getPage };\n            });\n        }\n        queryGallery(query, token) {\n            if (!this.isEnabled()) {\n                return Promise.reject(new Error('No extension gallery service configured.'));\n            }\n            return this.commonHeadersPromise.then(commonHeaders => {\n                const data = JSON.stringify(query.raw);\n                const headers = objects_1.assign({}, commonHeaders, {\n                    'Content-Type': 'application/json',\n                    'Accept': 'application/json;api-version=3.0-preview.1',\n                    'Accept-Encoding': 'gzip',\n                    'Content-Length': data.length\n                });\n                return this.requestService.request({\n                    type: 'POST',\n                    url: this.api('/extensionquery'),\n                    data,\n                    headers\n                }, token).then(context => {\n                    if (context.res.statusCode && context.res.statusCode >= 400 && context.res.statusCode < 500) {\n                        return { galleryExtensions: [], total: 0 };\n                    }\n                    return request_2.asJson(context).then(result => {\n                        if (result) {\n                            const r = result.results[0];\n                            const galleryExtensions = r.extensions;\n                            const resultCount = r.resultMetadata && r.resultMetadata.filter(m => m.metadataType === 'ResultCount')[0];\n                            const total = resultCount && resultCount.metadataItems.filter(i => i.name === 'TotalCount')[0].count || 0;\n                            return { galleryExtensions, total };\n                        }\n                        return { galleryExtensions: [], total: 0 };\n                    });\n                });\n            });\n        }\n        reportStatistic(publisher, name, version, type) {\n            if (!this.isEnabled()) {\n                return Promise.resolve(undefined);\n            }\n            return this.commonHeadersPromise.then(commonHeaders => {\n                const headers = Object.assign({}, commonHeaders, { Accept: '*/*;api-version=4.0-preview.1' });\n                return this.requestService.request({\n                    type: 'POST',\n                    url: this.api(`/publishers/${publisher}/extensions/${name}/${version}/stats?statType=${type}`),\n                    headers\n                }, cancellation_1.CancellationToken.None).then(undefined, () => undefined);\n            });\n        }\n        download(extension, operation) {\n            this.logService.trace('ExtensionGalleryService#download', extension.identifier.id);\n            const zipPath = path.join(os_1.tmpdir(), uuid_1.generateUuid());\n            const data = extensionManagementUtil_1.getGalleryExtensionTelemetryData(extension);\n            const startTime = new Date().getTime();\n            /* __GDPR__\n                \"galleryService:downloadVSIX\" : {\n                    \"duration\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                    \"${include}\": [\n                        \"${GalleryExtensionTelemetryData}\"\n                    ]\n                }\n            */\n            const log = (duration) => this.telemetryService.publicLog('galleryService:downloadVSIX', objects_1.assign(data, { duration }));\n            const operationParam = operation === extensionManagement_1.InstallOperation.Install ? 'install' : operation === extensionManagement_1.InstallOperation.Update ? 'update' : '';\n            const downloadAsset = operationParam ? {\n                uri: `${extension.assets.download.uri}&${operationParam}=true`,\n                fallbackUri: `${extension.assets.download.fallbackUri}?${operationParam}=true`\n            } : extension.assets.download;\n            return this.getAsset(downloadAsset)\n                .then(context => request_2.download(zipPath, context))\n                .then(() => log(new Date().getTime() - startTime))\n                .then(() => zipPath);\n        }\n        getReadme(extension, token) {\n            if (extension.assets.readme) {\n                return this.getAsset(extension.assets.readme, {}, token)\n                    .then(context => request_2.asText(context))\n                    .then(content => content || '');\n            }\n            return Promise.resolve('');\n        }\n        getManifest(extension, token) {\n            if (extension.assets.manifest) {\n                return this.getAsset(extension.assets.manifest, {}, token)\n                    .then(request_2.asText)\n                    .then(JSON.parse);\n            }\n            return Promise.resolve(null);\n        }\n        getCoreTranslation(extension, languageId) {\n            const asset = extension.assets.coreTranslations[languageId.toUpperCase()];\n            if (asset) {\n                return this.getAsset(asset)\n                    .then(request_2.asText)\n                    .then(JSON.parse);\n            }\n            return Promise.resolve(null);\n        }\n        getChangelog(extension, token) {\n            if (extension.assets.changelog) {\n                return this.getAsset(extension.assets.changelog, {}, token)\n                    .then(context => request_2.asText(context))\n                    .then(content => content || '');\n            }\n            return Promise.resolve('');\n        }\n        loadAllDependencies(extensions, token) {\n            return this.getDependenciesReccursively(extensions.map(e => e.id), [], token);\n        }\n        getAllVersions(extension, compatible) {\n            let query = new Query()\n                .withFlags(Flags.IncludeVersions, Flags.IncludeFiles, Flags.IncludeVersionProperties, Flags.ExcludeNonValidated)\n                .withPage(1, 1)\n                .withFilter(FilterType.Target, 'Microsoft.VisualStudio.Code')\n                .withFilter(FilterType.ExcludeWithFlags, flagsToString(Flags.Unpublished));\n            if (extension.identifier.uuid) {\n                query = query.withFilter(FilterType.ExtensionId, extension.identifier.uuid);\n            }\n            else {\n                query = query.withFilter(FilterType.ExtensionName, extension.identifier.id);\n            }\n            return this.queryGallery(query, cancellation_1.CancellationToken.None).then(({ galleryExtensions }) => {\n                if (galleryExtensions.length) {\n                    if (compatible) {\n                        return Promise.all(galleryExtensions[0].versions.map(v => this.getEngine(v).then(engine => extensionValidator_1.isEngineValid(engine) ? v : null)))\n                            .then(versions => versions\n                            .filter(v => !!v)\n                            .map(v => ({ version: v.version, date: v.lastUpdated })));\n                    }\n                    else {\n                        return galleryExtensions[0].versions.map(v => ({ version: v.version, date: v.lastUpdated }));\n                    }\n                }\n                return [];\n            });\n        }\n        loadDependencies(extensionNames, token) {\n            if (!extensionNames || extensionNames.length === 0) {\n                return Promise.resolve([]);\n            }\n            let query = new Query()\n                .withFlags(Flags.IncludeLatestVersionOnly, Flags.IncludeAssetUri, Flags.IncludeStatistics, Flags.IncludeFiles, Flags.IncludeVersionProperties)\n                .withPage(1, extensionNames.length)\n                .withFilter(FilterType.Target, 'Microsoft.VisualStudio.Code')\n                .withFilter(FilterType.ExcludeWithFlags, flagsToString(Flags.Unpublished))\n                .withAssetTypes(AssetType.Icon, AssetType.License, AssetType.Details, AssetType.Manifest, AssetType.VSIX)\n                .withFilter(FilterType.ExtensionName, ...extensionNames);\n            return this.queryGallery(query, token).then(result => {\n                const dependencies = [];\n                const ids = [];\n                for (let index = 0; index < result.galleryExtensions.length; index++) {\n                    const rawExtension = result.galleryExtensions[index];\n                    if (ids.indexOf(rawExtension.extensionId) === -1) {\n                        dependencies.push(toExtension(rawExtension, rawExtension.versions[0], index, query, 'dependencies'));\n                        ids.push(rawExtension.extensionId);\n                    }\n                }\n                return dependencies;\n            });\n        }\n        getDependenciesReccursively(toGet, result, token) {\n            if (!toGet || !toGet.length) {\n                return Promise.resolve(result);\n            }\n            toGet = result.length ? toGet.filter(e => !ExtensionGalleryService.hasExtensionByName(result, e)) : toGet;\n            if (!toGet.length) {\n                return Promise.resolve(result);\n            }\n            return this.loadDependencies(toGet, token)\n                .then(loadedDependencies => {\n                const dependenciesSet = new Set();\n                for (const dep of loadedDependencies) {\n                    if (dep.properties.dependencies) {\n                        dep.properties.dependencies.forEach(d => dependenciesSet.add(d));\n                    }\n                }\n                result = arrays_1.distinct(result.concat(loadedDependencies), d => d.identifier.uuid);\n                const dependencies = [];\n                dependenciesSet.forEach(d => !ExtensionGalleryService.hasExtensionByName(result, d) && dependencies.push(d));\n                return this.getDependenciesReccursively(dependencies, result, token);\n            });\n        }\n        getAsset(asset, options = {}, token = cancellation_1.CancellationToken.None) {\n            return this.commonHeadersPromise.then(commonHeaders => {\n                const baseOptions = { type: 'GET' };\n                const headers = objects_1.assign({}, commonHeaders, options.headers || {});\n                options = objects_1.assign({}, options, baseOptions, { headers });\n                const url = asset.uri;\n                const fallbackUrl = asset.fallbackUri;\n                const firstOptions = objects_1.assign({}, options, { url });\n                return this.requestService.request(firstOptions, token)\n                    .then(context => {\n                    if (context.res.statusCode === 200) {\n                        return Promise.resolve(context);\n                    }\n                    return request_2.asText(context)\n                        .then(message => Promise.reject(new Error(`Expected 200, got back ${context.res.statusCode} instead.\\n\\n${message}`)));\n                })\n                    .then(undefined, err => {\n                    if (errors_1.isPromiseCanceledError(err)) {\n                        return Promise.reject(err);\n                    }\n                    const message = errors_1.getErrorMessage(err);\n                    /* __GDPR__\n                        \"galleryService:requestError\" : {\n                            \"url\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                            \"cdn\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                            \"message\": { \"classification\": \"CallstackOrException\", \"purpose\": \"FeatureInsight\" }\n                        }\n                    */\n                    this.telemetryService.publicLog('galleryService:requestError', { url, cdn: true, message });\n                    /* __GDPR__\n                        \"galleryService:cdnFallback\" : {\n                            \"url\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                            \"message\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                        }\n                    */\n                    this.telemetryService.publicLog('galleryService:cdnFallback', { url, message });\n                    const fallbackOptions = objects_1.assign({}, options, { url: fallbackUrl });\n                    return this.requestService.request(fallbackOptions, token).then(undefined, err => {\n                        if (errors_1.isPromiseCanceledError(err)) {\n                            return Promise.reject(err);\n                        }\n                        const message = errors_1.getErrorMessage(err);\n                        /* __GDPR__\n                            \"galleryService:requestError\" : {\n                                \"url\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                                \"cdn\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                                \"message\": { \"classification\": \"CallstackOrException\", \"purpose\": \"FeatureInsight\" }\n                            }\n                        */\n                        this.telemetryService.publicLog('galleryService:requestError', { url: fallbackUrl, cdn: false, message });\n                        return Promise.reject(err);\n                    });\n                });\n            });\n        }\n        getLastValidExtensionVersion(extension, versions) {\n            const version = this.getLastValidExtensionVersionFromProperties(extension, versions);\n            if (version) {\n                return version;\n            }\n            return this.getLastValidExtensionVersionReccursively(extension, versions);\n        }\n        getLastValidExtensionVersionFromProperties(extension, versions) {\n            for (const version of versions) {\n                const engine = getEngine(version);\n                if (!engine) {\n                    return null;\n                }\n                if (extensionValidator_1.isEngineValid(engine)) {\n                    return Promise.resolve(version);\n                }\n            }\n            return null;\n        }\n        getEngine(version) {\n            const engine = getEngine(version);\n            if (engine) {\n                return Promise.resolve(engine);\n            }\n            const manifest = getVersionAsset(version, AssetType.Manifest);\n            if (!manifest) {\n                return Promise.reject('Manifest was not found');\n            }\n            const headers = { 'Accept-Encoding': 'gzip' };\n            return this.getAsset(manifest, { headers })\n                .then(context => request_2.asJson(context))\n                .then(manifest => manifest ? manifest.engines.vscode : Promise.reject('Error while reading manifest'));\n        }\n        getLastValidExtensionVersionReccursively(extension, versions) {\n            if (!versions.length) {\n                return Promise.resolve(null);\n            }\n            const version = versions[0];\n            return this.getEngine(version)\n                .then(engine => {\n                if (!extensionValidator_1.isEngineValid(engine)) {\n                    return this.getLastValidExtensionVersionReccursively(extension, versions.slice(1));\n                }\n                version.properties = version.properties || [];\n                version.properties.push({ key: PropertyType.Engine, value: engine });\n                return version;\n            });\n        }\n        static hasExtensionByName(extensions, name) {\n            for (const extension of extensions) {\n                if (`${extension.publisher}.${extension.name}` === name) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        getExtensionsReport() {\n            if (!this.isEnabled()) {\n                return Promise.reject(new Error('No extension gallery service configured.'));\n            }\n            if (!this.extensionsControlUrl) {\n                return Promise.resolve([]);\n            }\n            return this.requestService.request({ type: 'GET', url: this.extensionsControlUrl }, cancellation_1.CancellationToken.None).then(context => {\n                if (context.res.statusCode !== 200) {\n                    return Promise.reject(new Error('Could not get extensions report.'));\n                }\n                return request_2.asJson(context).then(result => {\n                    const map = new Map();\n                    if (result) {\n                        for (const id of result.malicious) {\n                            const ext = map.get(id) || { id: { id }, malicious: true, slow: false };\n                            ext.malicious = true;\n                            map.set(id, ext);\n                        }\n                    }\n                    return Promise.resolve(map_1.values(map));\n                });\n            });\n        }\n    };\n    ExtensionGalleryService = __decorate([\n        __param(0, request_1.IRequestService),\n        __param(1, log_1.ILogService),\n        __param(2, environment_1.IEnvironmentService),\n        __param(3, telemetry_1.ITelemetryService)\n    ], ExtensionGalleryService);\n    exports.ExtensionGalleryService = ExtensionGalleryService;\n    function resolveMarketplaceHeaders(environmentService) {\n        const marketplaceMachineIdFile = path.join(environmentService.userDataPath, 'machineid');\n        return pfs_1.readFile(marketplaceMachineIdFile, 'utf8')\n            .then(contents => uuid_1.isUUID(contents) ? contents : null, () => null /* error reading ID file */)\n            .then(uuid => {\n            if (!uuid) {\n                uuid = uuid_1.generateUuid();\n                try {\n                    extfs_1.writeFileAndFlushSync(marketplaceMachineIdFile, uuid);\n                }\n                catch (error) {\n                    //noop\n                }\n            }\n            return {\n                'X-Market-Client-Id': `VSCode ${package_1.default.version}`,\n                'User-Agent': `VSCode ${package_1.default.version}`,\n                'X-Market-User-Id': uuid\n            };\n        });\n    }\n    exports.resolveMarketplaceHeaders = resolveMarketplaceHeaders;\n});\n",null]}