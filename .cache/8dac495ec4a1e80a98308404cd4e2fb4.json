{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/driver/node/driver.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/driver/node/driver.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/parts/ipc/node/ipc.net\", \"vs/platform/instantiation/common/instantiation\"], function (require, exports, ipc_net_1, instantiation_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.ID = 'driverService';\n    exports.IDriver = instantiation_1.createDecorator(exports.ID);\n    //*END\n    class DriverChannel {\n        constructor(driver) {\n            this.driver = driver;\n        }\n        listen(_, event) {\n            throw new Error('No event found');\n        }\n        call(_, command, arg) {\n            switch (command) {\n                case 'getWindowIds': return this.driver.getWindowIds();\n                case 'capturePage': return this.driver.capturePage(arg);\n                case 'reloadWindow': return this.driver.reloadWindow(arg);\n                case 'exitApplication': return this.driver.exitApplication();\n                case 'dispatchKeybinding': return this.driver.dispatchKeybinding(arg[0], arg[1]);\n                case 'click': return this.driver.click(arg[0], arg[1], arg[2], arg[3]);\n                case 'doubleClick': return this.driver.doubleClick(arg[0], arg[1]);\n                case 'setValue': return this.driver.setValue(arg[0], arg[1], arg[2]);\n                case 'getTitle': return this.driver.getTitle(arg[0]);\n                case 'isActiveElement': return this.driver.isActiveElement(arg[0], arg[1]);\n                case 'getElements': return this.driver.getElements(arg[0], arg[1], arg[2]);\n                case 'typeInEditor': return this.driver.typeInEditor(arg[0], arg[1], arg[2]);\n                case 'getTerminalBuffer': return this.driver.getTerminalBuffer(arg[0], arg[1]);\n                case 'writeInTerminal': return this.driver.writeInTerminal(arg[0], arg[1], arg[2]);\n            }\n            throw new Error(`Call not found: ${command}`);\n        }\n    }\n    exports.DriverChannel = DriverChannel;\n    class DriverChannelClient {\n        constructor(channel) {\n            this.channel = channel;\n        }\n        getWindowIds() {\n            return this.channel.call('getWindowIds');\n        }\n        capturePage(windowId) {\n            return this.channel.call('capturePage', windowId);\n        }\n        reloadWindow(windowId) {\n            return this.channel.call('reloadWindow', windowId);\n        }\n        exitApplication() {\n            return this.channel.call('exitApplication');\n        }\n        dispatchKeybinding(windowId, keybinding) {\n            return this.channel.call('dispatchKeybinding', [windowId, keybinding]);\n        }\n        click(windowId, selector, xoffset, yoffset) {\n            return this.channel.call('click', [windowId, selector, xoffset, yoffset]);\n        }\n        doubleClick(windowId, selector) {\n            return this.channel.call('doubleClick', [windowId, selector]);\n        }\n        setValue(windowId, selector, text) {\n            return this.channel.call('setValue', [windowId, selector, text]);\n        }\n        getTitle(windowId) {\n            return this.channel.call('getTitle', [windowId]);\n        }\n        isActiveElement(windowId, selector) {\n            return this.channel.call('isActiveElement', [windowId, selector]);\n        }\n        getElements(windowId, selector, recursive) {\n            return this.channel.call('getElements', [windowId, selector, recursive]);\n        }\n        typeInEditor(windowId, selector, text) {\n            return this.channel.call('typeInEditor', [windowId, selector, text]);\n        }\n        getTerminalBuffer(windowId, selector) {\n            return this.channel.call('getTerminalBuffer', [windowId, selector]);\n        }\n        writeInTerminal(windowId, selector, text) {\n            return this.channel.call('writeInTerminal', [windowId, selector, text]);\n        }\n    }\n    exports.DriverChannelClient = DriverChannelClient;\n    class WindowDriverRegistryChannel {\n        constructor(registry) {\n            this.registry = registry;\n        }\n        listen(_, event) {\n            throw new Error(`Event not found: ${event}`);\n        }\n        call(_, command, arg) {\n            switch (command) {\n                case 'registerWindowDriver': return this.registry.registerWindowDriver(arg);\n                case 'reloadWindowDriver': return this.registry.reloadWindowDriver(arg);\n            }\n            throw new Error(`Call not found: ${command}`);\n        }\n    }\n    exports.WindowDriverRegistryChannel = WindowDriverRegistryChannel;\n    class WindowDriverRegistryChannelClient {\n        constructor(channel) {\n            this.channel = channel;\n        }\n        registerWindowDriver(windowId) {\n            return this.channel.call('registerWindowDriver', windowId);\n        }\n        reloadWindowDriver(windowId) {\n            return this.channel.call('reloadWindowDriver', windowId);\n        }\n    }\n    exports.WindowDriverRegistryChannelClient = WindowDriverRegistryChannelClient;\n    class WindowDriverChannel {\n        constructor(driver) {\n            this.driver = driver;\n        }\n        listen(_, event) {\n            throw new Error(`No event found: ${event}`);\n        }\n        call(_, command, arg) {\n            switch (command) {\n                case 'click': return this.driver.click(arg[0], arg[1], arg[2]);\n                case 'doubleClick': return this.driver.doubleClick(arg);\n                case 'setValue': return this.driver.setValue(arg[0], arg[1]);\n                case 'getTitle': return this.driver.getTitle();\n                case 'isActiveElement': return this.driver.isActiveElement(arg);\n                case 'getElements': return this.driver.getElements(arg[0], arg[1]);\n                case 'typeInEditor': return this.driver.typeInEditor(arg[0], arg[1]);\n                case 'getTerminalBuffer': return this.driver.getTerminalBuffer(arg);\n                case 'writeInTerminal': return this.driver.writeInTerminal(arg[0], arg[1]);\n            }\n            throw new Error(`Call not found: ${command}`);\n        }\n    }\n    exports.WindowDriverChannel = WindowDriverChannel;\n    class WindowDriverChannelClient {\n        constructor(channel) {\n            this.channel = channel;\n        }\n        click(selector, xoffset, yoffset) {\n            return this.channel.call('click', [selector, xoffset, yoffset]);\n        }\n        doubleClick(selector) {\n            return this.channel.call('doubleClick', selector);\n        }\n        setValue(selector, text) {\n            return this.channel.call('setValue', [selector, text]);\n        }\n        getTitle() {\n            return this.channel.call('getTitle');\n        }\n        isActiveElement(selector) {\n            return this.channel.call('isActiveElement', selector);\n        }\n        getElements(selector, recursive) {\n            return this.channel.call('getElements', [selector, recursive]);\n        }\n        typeInEditor(selector, text) {\n            return this.channel.call('typeInEditor', [selector, text]);\n        }\n        getTerminalBuffer(selector) {\n            return this.channel.call('getTerminalBuffer', selector);\n        }\n        writeInTerminal(selector, text) {\n            return this.channel.call('writeInTerminal', [selector, text]);\n        }\n    }\n    exports.WindowDriverChannelClient = WindowDriverChannelClient;\n    function connect(handle) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const client = yield ipc_net_1.connect(handle, 'driverClient');\n            const channel = client.getChannel('driver');\n            const driver = new DriverChannelClient(channel);\n            return { client, driver };\n        });\n    }\n    exports.connect = connect;\n});\n",null]}