{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/externalTerminal/electron-browser/externalTerminalService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/externalTerminal/electron-browser/externalTerminalService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"child_process\", \"vs/base/common/path\", \"vs/base/node/processes\", \"vs/nls\", \"vs/base/common/objects\", \"vs/platform/configuration/common/configuration\", \"vs/workbench/contrib/externalTerminal/electron-browser/externalTerminal\", \"vs/base/common/amd\"], function (require, exports, cp, path, processes, nls, objects_1, configuration_1, externalTerminal_1, amd_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const TERMINAL_TITLE = nls.localize('console.title', \"VS Code Console\");\n    var WinSpawnType;\n    (function (WinSpawnType) {\n        WinSpawnType[WinSpawnType[\"CMD\"] = 0] = \"CMD\";\n        WinSpawnType[WinSpawnType[\"CMDER\"] = 1] = \"CMDER\";\n    })(WinSpawnType || (WinSpawnType = {}));\n    let WindowsExternalTerminalService = class WindowsExternalTerminalService {\n        constructor(_configurationService) {\n            this._configurationService = _configurationService;\n        }\n        openTerminal(cwd) {\n            const configuration = this._configurationService.getValue();\n            this.spawnTerminal(cp, configuration, processes.getWindowsShell(), cwd);\n        }\n        runInTerminal(title, dir, args, envVars) {\n            const configuration = this._configurationService.getValue();\n            const terminalConfig = configuration.terminal.external;\n            const exec = terminalConfig.windowsExec || externalTerminal_1.getDefaultTerminalWindows();\n            return new Promise((c, e) => {\n                const title = `\"${dir} - ${TERMINAL_TITLE}\"`;\n                const command = `\"\"${args.join('\" \"')}\" & pause\"`; // use '|' to only pause on non-zero exit code\n                const cmdArgs = [\n                    '/c', 'start', title, '/wait', exec, '/c', command\n                ];\n                // merge environment variables into a copy of the process.env\n                const env = objects_1.assign({}, process.env, envVars);\n                // delete environment variables that have a null value\n                Object.keys(env).filter(v => env[v] === null).forEach(key => delete env[key]);\n                const options = {\n                    cwd: dir,\n                    env: env,\n                    windowsVerbatimArguments: true\n                };\n                const cmd = cp.spawn(WindowsExternalTerminalService.CMD, cmdArgs, options);\n                cmd.on('error', e);\n                c(undefined);\n            });\n        }\n        spawnTerminal(spawner, configuration, command, cwd) {\n            const terminalConfig = configuration.terminal.external;\n            const exec = terminalConfig.windowsExec || externalTerminal_1.getDefaultTerminalWindows();\n            const spawnType = this.getSpawnType(exec);\n            // Make the drive letter uppercase on Windows (see #9448)\n            if (cwd && cwd[1] === ':') {\n                cwd = cwd[0].toUpperCase() + cwd.substr(1);\n            }\n            // cmder ignores the environment cwd and instead opts to always open in %USERPROFILE%\n            // unless otherwise specified\n            if (spawnType === WinSpawnType.CMDER) {\n                spawner.spawn(exec, cwd ? [cwd] : undefined);\n                return Promise.resolve(undefined);\n            }\n            const cmdArgs = ['/c', 'start', '/wait'];\n            if (exec.indexOf(' ') >= 0) {\n                // The \"\" argument is the window title. Without this, exec doesn't work when the path\n                // contains spaces\n                cmdArgs.push('\"\"');\n            }\n            cmdArgs.push(exec);\n            return new Promise((c, e) => {\n                const env = cwd ? { cwd: cwd } : undefined;\n                const child = spawner.spawn(command, cmdArgs, env);\n                child.on('error', e);\n                child.on('exit', () => c());\n            });\n        }\n        getSpawnType(exec) {\n            const basename = path.basename(exec).toLowerCase();\n            if (basename === 'cmder' || basename === 'cmder.exe') {\n                return WinSpawnType.CMDER;\n            }\n            return WinSpawnType.CMD;\n        }\n    };\n    WindowsExternalTerminalService.CMD = 'cmd.exe';\n    WindowsExternalTerminalService = __decorate([\n        __param(0, configuration_1.IConfigurationService)\n    ], WindowsExternalTerminalService);\n    exports.WindowsExternalTerminalService = WindowsExternalTerminalService;\n    let MacExternalTerminalService = class MacExternalTerminalService {\n        constructor(_configurationService) {\n            this._configurationService = _configurationService;\n        }\n        openTerminal(cwd) {\n            const configuration = this._configurationService.getValue();\n            this.spawnTerminal(cp, configuration, cwd);\n        }\n        runInTerminal(title, dir, args, envVars) {\n            const configuration = this._configurationService.getValue();\n            const terminalConfig = configuration.terminal.external;\n            const terminalApp = terminalConfig.osxExec || externalTerminal_1.DEFAULT_TERMINAL_OSX;\n            return new Promise((c, e) => {\n                if (terminalApp === externalTerminal_1.DEFAULT_TERMINAL_OSX || terminalApp === 'iTerm.app') {\n                    // On OS X we launch an AppleScript that creates (or reuses) a Terminal window\n                    // and then launches the program inside that window.\n                    const script = terminalApp === externalTerminal_1.DEFAULT_TERMINAL_OSX ? 'TerminalHelper' : 'iTermHelper';\n                    const scriptpath = amd_1.getPathFromAmdModule(require, `vs/workbench/contrib/externalTerminal/electron-browser/${script}.scpt`);\n                    const osaArgs = [\n                        scriptpath,\n                        '-t', title || TERMINAL_TITLE,\n                        '-w', dir,\n                    ];\n                    for (let a of args) {\n                        osaArgs.push('-a');\n                        osaArgs.push(a);\n                    }\n                    if (envVars) {\n                        for (let key in envVars) {\n                            const value = envVars[key];\n                            if (value === null) {\n                                osaArgs.push('-u');\n                                osaArgs.push(key);\n                            }\n                            else {\n                                osaArgs.push('-e');\n                                osaArgs.push(`${key}=${value}`);\n                            }\n                        }\n                    }\n                    let stderr = '';\n                    const osa = cp.spawn(MacExternalTerminalService.OSASCRIPT, osaArgs);\n                    osa.on('error', e);\n                    osa.stderr.on('data', (data) => {\n                        stderr += data.toString();\n                    });\n                    osa.on('exit', (code) => {\n                        if (code === 0) { // OK\n                            c(undefined);\n                        }\n                        else {\n                            if (stderr) {\n                                const lines = stderr.split('\\n', 1);\n                                e(new Error(lines[0]));\n                            }\n                            else {\n                                e(new Error(nls.localize('mac.terminal.script.failed', \"Script '{0}' failed with exit code {1}\", script, code)));\n                            }\n                        }\n                    });\n                }\n                else {\n                    e(new Error(nls.localize('mac.terminal.type.not.supported', \"'{0}' not supported\", terminalApp)));\n                }\n            });\n        }\n        spawnTerminal(spawner, configuration, cwd) {\n            const terminalConfig = configuration.terminal.external;\n            const terminalApp = terminalConfig.osxExec || externalTerminal_1.DEFAULT_TERMINAL_OSX;\n            return new Promise((c, e) => {\n                const args = ['-a', terminalApp];\n                if (cwd) {\n                    args.push(cwd);\n                }\n                const child = spawner.spawn('/usr/bin/open', args);\n                child.on('error', e);\n                child.on('exit', () => c());\n            });\n        }\n    };\n    MacExternalTerminalService.OSASCRIPT = '/usr/bin/osascript'; // osascript is the AppleScript interpreter on OS X\n    MacExternalTerminalService = __decorate([\n        __param(0, configuration_1.IConfigurationService)\n    ], MacExternalTerminalService);\n    exports.MacExternalTerminalService = MacExternalTerminalService;\n    let LinuxExternalTerminalService = class LinuxExternalTerminalService {\n        constructor(_configurationService) {\n            this._configurationService = _configurationService;\n        }\n        openTerminal(cwd) {\n            const configuration = this._configurationService.getValue();\n            this.spawnTerminal(cp, configuration, cwd);\n        }\n        runInTerminal(title, dir, args, envVars) {\n            const configuration = this._configurationService.getValue();\n            const terminalConfig = configuration.terminal.external;\n            const execPromise = terminalConfig.linuxExec ? Promise.resolve(terminalConfig.linuxExec) : externalTerminal_1.getDefaultTerminalLinuxReady();\n            return new Promise((c, e) => {\n                let termArgs = [];\n                //termArgs.push('--title');\n                //termArgs.push(`\"${TERMINAL_TITLE}\"`);\n                execPromise.then(exec => {\n                    if (exec.indexOf('gnome-terminal') >= 0) {\n                        termArgs.push('-x');\n                    }\n                    else {\n                        termArgs.push('-e');\n                    }\n                    termArgs.push('bash');\n                    termArgs.push('-c');\n                    const bashCommand = `${quote(args)}; echo; read -p \"${LinuxExternalTerminalService.WAIT_MESSAGE}\" -n1;`;\n                    termArgs.push(`''${bashCommand}''`); // wrapping argument in two sets of ' because node is so \"friendly\" that it removes one set...\n                    // merge environment variables into a copy of the process.env\n                    const env = objects_1.assign({}, process.env, envVars);\n                    // delete environment variables that have a null value\n                    Object.keys(env).filter(v => env[v] === null).forEach(key => delete env[key]);\n                    const options = {\n                        cwd: dir,\n                        env: env\n                    };\n                    let stderr = '';\n                    const cmd = cp.spawn(exec, termArgs, options);\n                    cmd.on('error', e);\n                    cmd.stderr.on('data', (data) => {\n                        stderr += data.toString();\n                    });\n                    cmd.on('exit', (code) => {\n                        if (code === 0) { // OK\n                            c(undefined);\n                        }\n                        else {\n                            if (stderr) {\n                                const lines = stderr.split('\\n', 1);\n                                e(new Error(lines[0]));\n                            }\n                            else {\n                                e(new Error(nls.localize('linux.term.failed', \"'{0}' failed with exit code {1}\", exec, code)));\n                            }\n                        }\n                    });\n                });\n            });\n        }\n        spawnTerminal(spawner, configuration, cwd) {\n            const terminalConfig = configuration.terminal.external;\n            const execPromise = terminalConfig.linuxExec ? Promise.resolve(terminalConfig.linuxExec) : externalTerminal_1.getDefaultTerminalLinuxReady();\n            return new Promise((c, e) => {\n                execPromise.then(exec => {\n                    const env = cwd ? { cwd } : undefined;\n                    const child = spawner.spawn(exec, [], env);\n                    child.on('error', e);\n                    child.on('exit', () => c());\n                });\n            });\n        }\n    };\n    LinuxExternalTerminalService.WAIT_MESSAGE = nls.localize('press.any.key', \"Press any key to continue...\");\n    LinuxExternalTerminalService = __decorate([\n        __param(0, configuration_1.IConfigurationService)\n    ], LinuxExternalTerminalService);\n    exports.LinuxExternalTerminalService = LinuxExternalTerminalService;\n    /**\n     * Quote args if necessary and combine into a space separated string.\n     */\n    function quote(args) {\n        let r = '';\n        for (let a of args) {\n            if (a.indexOf(' ') >= 0) {\n                r += '\"' + a + '\"';\n            }\n            else {\n                r += a;\n            }\n            r += ' ';\n        }\n        return r;\n    }\n});\n",null]}