{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/scrollbar/scrollbarState.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/scrollbar/scrollbarState.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The minimal size of the slider (such that it can still be clickable) -- it is artificially enlarged.\n */\nvar MINIMUM_SLIDER_SIZE = 20;\nvar ScrollbarState = /** @class */ (function () {\n    function ScrollbarState(arrowSize, scrollbarSize, oppositeScrollbarSize) {\n        this._scrollbarSize = Math.round(scrollbarSize);\n        this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\n        this._arrowSize = Math.round(arrowSize);\n        this._visibleSize = 0;\n        this._scrollSize = 0;\n        this._scrollPosition = 0;\n        this._computedAvailableSize = 0;\n        this._computedIsNeeded = false;\n        this._computedSliderSize = 0;\n        this._computedSliderRatio = 0;\n        this._computedSliderPosition = 0;\n        this._refreshComputedValues();\n    }\n    ScrollbarState.prototype.clone = function () {\n        var r = new ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize);\n        r.setVisibleSize(this._visibleSize);\n        r.setScrollSize(this._scrollSize);\n        r.setScrollPosition(this._scrollPosition);\n        return r;\n    };\n    ScrollbarState.prototype.setVisibleSize = function (visibleSize) {\n        var iVisibleSize = Math.round(visibleSize);\n        if (this._visibleSize !== iVisibleSize) {\n            this._visibleSize = iVisibleSize;\n            this._refreshComputedValues();\n            return true;\n        }\n        return false;\n    };\n    ScrollbarState.prototype.setScrollSize = function (scrollSize) {\n        var iScrollSize = Math.round(scrollSize);\n        if (this._scrollSize !== iScrollSize) {\n            this._scrollSize = iScrollSize;\n            this._refreshComputedValues();\n            return true;\n        }\n        return false;\n    };\n    ScrollbarState.prototype.setScrollPosition = function (scrollPosition) {\n        var iScrollPosition = Math.round(scrollPosition);\n        if (this._scrollPosition !== iScrollPosition) {\n            this._scrollPosition = iScrollPosition;\n            this._refreshComputedValues();\n            return true;\n        }\n        return false;\n    };\n    ScrollbarState._computeValues = function (oppositeScrollbarSize, arrowSize, visibleSize, scrollSize, scrollPosition) {\n        var computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);\n        var computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);\n        var computedIsNeeded = (scrollSize > 0 && scrollSize > visibleSize);\n        if (!computedIsNeeded) {\n            // There is no need for a slider\n            return {\n                computedAvailableSize: Math.round(computedAvailableSize),\n                computedIsNeeded: computedIsNeeded,\n                computedSliderSize: Math.round(computedRepresentableSize),\n                computedSliderRatio: 0,\n                computedSliderPosition: 0,\n            };\n        }\n        // We must artificially increase the size of the slider if needed, since the slider would be too small to grab with the mouse otherwise\n        var computedSliderSize = Math.round(Math.max(MINIMUM_SLIDER_SIZE, Math.floor(visibleSize * computedRepresentableSize / scrollSize)));\n        // The slider can move from 0 to `computedRepresentableSize` - `computedSliderSize`\n        // in the same way `scrollPosition` can move from 0 to `scrollSize` - `visibleSize`.\n        var computedSliderRatio = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);\n        var computedSliderPosition = (scrollPosition * computedSliderRatio);\n        return {\n            computedAvailableSize: Math.round(computedAvailableSize),\n            computedIsNeeded: computedIsNeeded,\n            computedSliderSize: Math.round(computedSliderSize),\n            computedSliderRatio: computedSliderRatio,\n            computedSliderPosition: Math.round(computedSliderPosition),\n        };\n    };\n    ScrollbarState.prototype._refreshComputedValues = function () {\n        var r = ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n        this._computedAvailableSize = r.computedAvailableSize;\n        this._computedIsNeeded = r.computedIsNeeded;\n        this._computedSliderSize = r.computedSliderSize;\n        this._computedSliderRatio = r.computedSliderRatio;\n        this._computedSliderPosition = r.computedSliderPosition;\n    };\n    ScrollbarState.prototype.getArrowSize = function () {\n        return this._arrowSize;\n    };\n    ScrollbarState.prototype.getScrollPosition = function () {\n        return this._scrollPosition;\n    };\n    ScrollbarState.prototype.getRectangleLargeSize = function () {\n        return this._computedAvailableSize;\n    };\n    ScrollbarState.prototype.getRectangleSmallSize = function () {\n        return this._scrollbarSize;\n    };\n    ScrollbarState.prototype.isNeeded = function () {\n        return this._computedIsNeeded;\n    };\n    ScrollbarState.prototype.getSliderSize = function () {\n        return this._computedSliderSize;\n    };\n    ScrollbarState.prototype.getSliderPosition = function () {\n        return this._computedSliderPosition;\n    };\n    /**\n     * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.\n     * `offset` is based on the same coordinate system as the `sliderPosition`.\n     */\n    ScrollbarState.prototype.getDesiredScrollPositionFromOffset = function (offset) {\n        if (!this._computedIsNeeded) {\n            // no need for a slider\n            return 0;\n        }\n        var desiredSliderPosition = offset - this._arrowSize - this._computedSliderSize / 2;\n        return Math.round(desiredSliderPosition / this._computedSliderRatio);\n    };\n    /**\n     * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n     */\n    ScrollbarState.prototype.getDesiredScrollPositionFromDelta = function (delta) {\n        if (!this._computedIsNeeded) {\n            // no need for a slider\n            return 0;\n        }\n        var desiredSliderPosition = this._computedSliderPosition + delta;\n        return Math.round(desiredSliderPosition / this._computedSliderRatio);\n    };\n    return ScrollbarState;\n}());\nexports.ScrollbarState = ScrollbarState;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/scrollbar/scrollbarState.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/scrollbar/scrollbarState.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;AAEhG;;GAEG;AACH,IAAM,mBAAmB,GAAG,EAAE,CAAC;AAE/B;IAsDC,wBAAY,SAAiB,EAAE,aAAqB,EAAE,qBAA6B;QAClF,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;QAChD,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC,KAAK,CAAC,qBAAqB,CAAC,CAAC;QAChE,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QAExC,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;QACtB,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;QACrB,IAAI,CAAC,eAAe,GAAG,CAAC,CAAC;QAEzB,IAAI,CAAC,sBAAsB,GAAG,CAAC,CAAC;QAChC,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC;QAC/B,IAAI,CAAC,mBAAmB,GAAG,CAAC,CAAC;QAC7B,IAAI,CAAC,oBAAoB,GAAG,CAAC,CAAC;QAC9B,IAAI,CAAC,uBAAuB,GAAG,CAAC,CAAC;QAEjC,IAAI,CAAC,sBAAsB,EAAE,CAAC;IAC/B,CAAC;IAEM,8BAAK,GAAZ;QACC,IAAI,CAAC,GAAG,IAAI,cAAc,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,sBAAsB,CAAC,CAAC;QAC9F,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QACpC,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAClC,CAAC,CAAC,iBAAiB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QAC1C,OAAO,CAAC,CAAC;IACV,CAAC;IAEM,uCAAc,GAArB,UAAsB,WAAmB;QACxC,IAAI,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;QAC3C,IAAI,IAAI,CAAC,YAAY,KAAK,YAAY,EAAE;YACvC,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;YACjC,IAAI,CAAC,sBAAsB,EAAE,CAAC;YAC9B,OAAO,IAAI,CAAC;SACZ;QACD,OAAO,KAAK,CAAC;IACd,CAAC;IAEM,sCAAa,GAApB,UAAqB,UAAkB;QACtC,IAAI,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;QACzC,IAAI,IAAI,CAAC,WAAW,KAAK,WAAW,EAAE;YACrC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;YAC/B,IAAI,CAAC,sBAAsB,EAAE,CAAC;YAC9B,OAAO,IAAI,CAAC;SACZ;QACD,OAAO,KAAK,CAAC;IACd,CAAC;IAEM,0CAAiB,GAAxB,UAAyB,cAAsB;QAC9C,IAAI,eAAe,GAAG,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC;QACjD,IAAI,IAAI,CAAC,eAAe,KAAK,eAAe,EAAE;YAC7C,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;YACvC,IAAI,CAAC,sBAAsB,EAAE,CAAC;YAC9B,OAAO,IAAI,CAAC;SACZ;QACD,OAAO,KAAK,CAAC;IACd,CAAC;IAEc,6BAAc,GAA7B,UAA8B,qBAA6B,EAAE,SAAiB,EAAE,WAAmB,EAAE,UAAkB,EAAE,cAAsB;QAC9I,IAAM,qBAAqB,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,WAAW,GAAG,qBAAqB,CAAC,CAAC;QAC/E,IAAM,yBAAyB,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,qBAAqB,GAAG,CAAC,GAAG,SAAS,CAAC,CAAC;QACrF,IAAM,gBAAgB,GAAG,CAAC,UAAU,GAAG,CAAC,IAAI,UAAU,GAAG,WAAW,CAAC,CAAC;QAEtE,IAAI,CAAC,gBAAgB,EAAE;YACtB,gCAAgC;YAChC,OAAO;gBACN,qBAAqB,EAAE,IAAI,CAAC,KAAK,CAAC,qBAAqB,CAAC;gBACxD,gBAAgB,EAAE,gBAAgB;gBAClC,kBAAkB,EAAE,IAAI,CAAC,KAAK,CAAC,yBAAyB,CAAC;gBACzD,mBAAmB,EAAE,CAAC;gBACtB,sBAAsB,EAAE,CAAC;aACzB,CAAC;SACF;QAED,uIAAuI;QACvI,IAAM,kBAAkB,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,mBAAmB,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,yBAAyB,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;QAEvI,mFAAmF;QACnF,oFAAoF;QACpF,IAAM,mBAAmB,GAAG,CAAC,yBAAyB,GAAG,kBAAkB,CAAC,GAAG,CAAC,UAAU,GAAG,WAAW,CAAC,CAAC;QAC1G,IAAM,sBAAsB,GAAG,CAAC,cAAc,GAAG,mBAAmB,CAAC,CAAC;QAEtE,OAAO;YACN,qBAAqB,EAAE,IAAI,CAAC,KAAK,CAAC,qBAAqB,CAAC;YACxD,gBAAgB,EAAE,gBAAgB;YAClC,kBAAkB,EAAE,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC;YAClD,mBAAmB,EAAE,mBAAmB;YACxC,sBAAsB,EAAE,IAAI,CAAC,KAAK,CAAC,sBAAsB,CAAC;SAC1D,CAAC;IACH,CAAC;IAEO,+CAAsB,GAA9B;QACC,IAAM,CAAC,GAAG,cAAc,CAAC,cAAc,CAAC,IAAI,CAAC,sBAAsB,EAAE,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;QACjJ,IAAI,CAAC,sBAAsB,GAAG,CAAC,CAAC,qBAAqB,CAAC;QACtD,IAAI,CAAC,iBAAiB,GAAG,CAAC,CAAC,gBAAgB,CAAC;QAC5C,IAAI,CAAC,mBAAmB,GAAG,CAAC,CAAC,kBAAkB,CAAC;QAChD,IAAI,CAAC,oBAAoB,GAAG,CAAC,CAAC,mBAAmB,CAAC;QAClD,IAAI,CAAC,uBAAuB,GAAG,CAAC,CAAC,sBAAsB,CAAC;IACzD,CAAC;IAEM,qCAAY,GAAnB;QACC,OAAO,IAAI,CAAC,UAAU,CAAC;IACxB,CAAC;IAEM,0CAAiB,GAAxB;QACC,OAAO,IAAI,CAAC,eAAe,CAAC;IAC7B,CAAC;IAEM,8CAAqB,GAA5B;QACC,OAAO,IAAI,CAAC,sBAAsB,CAAC;IACpC,CAAC;IAEM,8CAAqB,GAA5B;QACC,OAAO,IAAI,CAAC,cAAc,CAAC;IAC5B,CAAC;IAEM,iCAAQ,GAAf;QACC,OAAO,IAAI,CAAC,iBAAiB,CAAC;IAC/B,CAAC;IAEM,sCAAa,GAApB;QACC,OAAO,IAAI,CAAC,mBAAmB,CAAC;IACjC,CAAC;IAEM,0CAAiB,GAAxB;QACC,OAAO,IAAI,CAAC,uBAAuB,CAAC;IACrC,CAAC;IAED;;;OAGG;IACI,2DAAkC,GAAzC,UAA0C,MAAc;QACvD,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE;YAC5B,uBAAuB;YACvB,OAAO,CAAC,CAAC;SACT;QAED,IAAI,qBAAqB,GAAG,MAAM,GAAG,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,mBAAmB,GAAG,CAAC,CAAC;QACpF,OAAO,IAAI,CAAC,KAAK,CAAC,qBAAqB,GAAG,IAAI,CAAC,oBAAoB,CAAC,CAAC;IACtE,CAAC;IAED;;OAEG;IACI,0DAAiC,GAAxC,UAAyC,KAAa;QACrD,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE;YAC5B,uBAAuB;YACvB,OAAO,CAAC,CAAC;SACT;QAED,IAAI,qBAAqB,GAAG,IAAI,CAAC,uBAAuB,GAAG,KAAK,CAAC;QACjE,OAAO,IAAI,CAAC,KAAK,CAAC,qBAAqB,GAAG,IAAI,CAAC,oBAAoB,CAAC,CAAC;IACtE,CAAC;IACF,qBAAC;AAAD,CAAC,AA9MD,IA8MC;AA9MY,wCAAc","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * The minimal size of the slider (such that it can still be clickable) -- it is artificially enlarged.\n */\nconst MINIMUM_SLIDER_SIZE = 20;\n\nexport class ScrollbarState {\n\n\t/**\n\t * For the vertical scrollbar: the width.\n\t * For the horizontal scrollbar: the height.\n\t */\n\tprivate readonly _scrollbarSize: number;\n\n\t/**\n\t * For the vertical scrollbar: the height of the pair horizontal scrollbar.\n\t * For the horizontal scrollbar: the width of the pair vertical scrollbar.\n\t */\n\tprivate readonly _oppositeScrollbarSize: number;\n\n\t/**\n\t * For the vertical scrollbar: the height of the scrollbar's arrows.\n\t * For the horizontal scrollbar: the width of the scrollbar's arrows.\n\t */\n\tprivate readonly _arrowSize: number;\n\n\t// --- variables\n\t/**\n\t * For the vertical scrollbar: the viewport height.\n\t * For the horizontal scrollbar: the viewport width.\n\t */\n\tprivate _visibleSize: number;\n\n\t/**\n\t * For the vertical scrollbar: the scroll height.\n\t * For the horizontal scrollbar: the scroll width.\n\t */\n\tprivate _scrollSize: number;\n\n\t/**\n\t * For the vertical scrollbar: the scroll top.\n\t * For the horizontal scrollbar: the scroll left.\n\t */\n\tprivate _scrollPosition: number;\n\n\t// --- computed variables\n\n\t/**\n\t * `visibleSize` - `oppositeScrollbarSize`\n\t */\n\tprivate _computedAvailableSize: number;\n\t/**\n\t * (`scrollSize` > 0 && `scrollSize` > `visibleSize`)\n\t */\n\tprivate _computedIsNeeded: boolean;\n\n\tprivate _computedSliderSize: number;\n\tprivate _computedSliderRatio: number;\n\tprivate _computedSliderPosition: number;\n\n\tconstructor(arrowSize: number, scrollbarSize: number, oppositeScrollbarSize: number) {\n\t\tthis._scrollbarSize = Math.round(scrollbarSize);\n\t\tthis._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\n\t\tthis._arrowSize = Math.round(arrowSize);\n\n\t\tthis._visibleSize = 0;\n\t\tthis._scrollSize = 0;\n\t\tthis._scrollPosition = 0;\n\n\t\tthis._computedAvailableSize = 0;\n\t\tthis._computedIsNeeded = false;\n\t\tthis._computedSliderSize = 0;\n\t\tthis._computedSliderRatio = 0;\n\t\tthis._computedSliderPosition = 0;\n\n\t\tthis._refreshComputedValues();\n\t}\n\n\tpublic clone(): ScrollbarState {\n\t\tlet r = new ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize);\n\t\tr.setVisibleSize(this._visibleSize);\n\t\tr.setScrollSize(this._scrollSize);\n\t\tr.setScrollPosition(this._scrollPosition);\n\t\treturn r;\n\t}\n\n\tpublic setVisibleSize(visibleSize: number): boolean {\n\t\tlet iVisibleSize = Math.round(visibleSize);\n\t\tif (this._visibleSize !== iVisibleSize) {\n\t\t\tthis._visibleSize = iVisibleSize;\n\t\t\tthis._refreshComputedValues();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic setScrollSize(scrollSize: number): boolean {\n\t\tlet iScrollSize = Math.round(scrollSize);\n\t\tif (this._scrollSize !== iScrollSize) {\n\t\t\tthis._scrollSize = iScrollSize;\n\t\t\tthis._refreshComputedValues();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic setScrollPosition(scrollPosition: number): boolean {\n\t\tlet iScrollPosition = Math.round(scrollPosition);\n\t\tif (this._scrollPosition !== iScrollPosition) {\n\t\t\tthis._scrollPosition = iScrollPosition;\n\t\t\tthis._refreshComputedValues();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static _computeValues(oppositeScrollbarSize: number, arrowSize: number, visibleSize: number, scrollSize: number, scrollPosition: number) {\n\t\tconst computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);\n\t\tconst computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);\n\t\tconst computedIsNeeded = (scrollSize > 0 && scrollSize > visibleSize);\n\n\t\tif (!computedIsNeeded) {\n\t\t\t// There is no need for a slider\n\t\t\treturn {\n\t\t\t\tcomputedAvailableSize: Math.round(computedAvailableSize),\n\t\t\t\tcomputedIsNeeded: computedIsNeeded,\n\t\t\t\tcomputedSliderSize: Math.round(computedRepresentableSize),\n\t\t\t\tcomputedSliderRatio: 0,\n\t\t\t\tcomputedSliderPosition: 0,\n\t\t\t};\n\t\t}\n\n\t\t// We must artificially increase the size of the slider if needed, since the slider would be too small to grab with the mouse otherwise\n\t\tconst computedSliderSize = Math.round(Math.max(MINIMUM_SLIDER_SIZE, Math.floor(visibleSize * computedRepresentableSize / scrollSize)));\n\n\t\t// The slider can move from 0 to `computedRepresentableSize` - `computedSliderSize`\n\t\t// in the same way `scrollPosition` can move from 0 to `scrollSize` - `visibleSize`.\n\t\tconst computedSliderRatio = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);\n\t\tconst computedSliderPosition = (scrollPosition * computedSliderRatio);\n\n\t\treturn {\n\t\t\tcomputedAvailableSize: Math.round(computedAvailableSize),\n\t\t\tcomputedIsNeeded: computedIsNeeded,\n\t\t\tcomputedSliderSize: Math.round(computedSliderSize),\n\t\t\tcomputedSliderRatio: computedSliderRatio,\n\t\t\tcomputedSliderPosition: Math.round(computedSliderPosition),\n\t\t};\n\t}\n\n\tprivate _refreshComputedValues(): void {\n\t\tconst r = ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n\t\tthis._computedAvailableSize = r.computedAvailableSize;\n\t\tthis._computedIsNeeded = r.computedIsNeeded;\n\t\tthis._computedSliderSize = r.computedSliderSize;\n\t\tthis._computedSliderRatio = r.computedSliderRatio;\n\t\tthis._computedSliderPosition = r.computedSliderPosition;\n\t}\n\n\tpublic getArrowSize(): number {\n\t\treturn this._arrowSize;\n\t}\n\n\tpublic getScrollPosition(): number {\n\t\treturn this._scrollPosition;\n\t}\n\n\tpublic getRectangleLargeSize(): number {\n\t\treturn this._computedAvailableSize;\n\t}\n\n\tpublic getRectangleSmallSize(): number {\n\t\treturn this._scrollbarSize;\n\t}\n\n\tpublic isNeeded(): boolean {\n\t\treturn this._computedIsNeeded;\n\t}\n\n\tpublic getSliderSize(): number {\n\t\treturn this._computedSliderSize;\n\t}\n\n\tpublic getSliderPosition(): number {\n\t\treturn this._computedSliderPosition;\n\t}\n\n\t/**\n\t * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.\n\t * `offset` is based on the same coordinate system as the `sliderPosition`.\n\t */\n\tpublic getDesiredScrollPositionFromOffset(offset: number): number {\n\t\tif (!this._computedIsNeeded) {\n\t\t\t// no need for a slider\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet desiredSliderPosition = offset - this._arrowSize - this._computedSliderSize / 2;\n\t\treturn Math.round(desiredSliderPosition / this._computedSliderRatio);\n\t}\n\n\t/**\n\t * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n\t */\n\tpublic getDesiredScrollPositionFromDelta(delta: number): number {\n\t\tif (!this._computedIsNeeded) {\n\t\t\t// no need for a slider\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet desiredSliderPosition = this._computedSliderPosition + delta;\n\t\treturn Math.round(desiredSliderPosition / this._computedSliderRatio);\n\t}\n}\n"]}]}