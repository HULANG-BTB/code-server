{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/links/links.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/links/links.ts","mtime":1555846338032},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/async\", \"vs/base/common/cancellation\", \"vs/base/common/errors\", \"vs/base/common/htmlContent\", \"vs/base/common/lifecycle\", \"vs/base/browser/browser\", \"vs/editor/browser/editorBrowser\", \"vs/editor/browser/editorExtensions\", \"vs/editor/common/model\", \"vs/editor/common/model/textModel\", \"vs/editor/common/modes\", \"vs/editor/contrib/goToDefinition/clickLinkGesture\", \"vs/editor/contrib/links/getLinks\", \"vs/platform/notification/common/notification\", \"vs/platform/opener/common/opener\", \"vs/platform/theme/common/colorRegistry\", \"vs/platform/theme/common/themeService\", \"vs/css!./links\"], function (require, exports, nls, async, cancellation_1, errors_1, htmlContent_1, lifecycle_1, browser, editorBrowser_1, editorExtensions_1, model_1, textModel_1, modes_1, clickLinkGesture_1, getLinks_1, notification_1, opener_1, colorRegistry_1, themeService_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const HOVER_MESSAGE_GENERAL_META = new htmlContent_1.MarkdownString().appendText(browser.isMacintosh\n        ? nls.localize('links.navigate.mac', \"Cmd + click to follow link\")\n        : nls.localize('links.navigate', \"Ctrl + click to follow link\"));\n    const HOVER_MESSAGE_COMMAND_META = new htmlContent_1.MarkdownString().appendText(browser.isMacintosh\n        ? nls.localize('links.command.mac', \"Cmd + click to execute command\")\n        : nls.localize('links.command', \"Ctrl + click to execute command\"));\n    const HOVER_MESSAGE_GENERAL_ALT = new htmlContent_1.MarkdownString().appendText(browser.isMacintosh\n        ? nls.localize('links.navigate.al.mac', \"Option + click to follow link\")\n        : nls.localize('links.navigate.al', \"Alt + click to follow link\"));\n    const HOVER_MESSAGE_COMMAND_ALT = new htmlContent_1.MarkdownString().appendText(browser.isMacintosh\n        ? nls.localize('links.command.al.mac', \"Option + click to execute command\")\n        : nls.localize('links.command.al', \"Alt + click to execute command\"));\n    const decoration = {\n        meta: textModel_1.ModelDecorationOptions.register({\n            stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n            collapseOnReplaceEdit: true,\n            inlineClassName: 'detected-link',\n            hoverMessage: HOVER_MESSAGE_GENERAL_META\n        }),\n        metaActive: textModel_1.ModelDecorationOptions.register({\n            stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n            collapseOnReplaceEdit: true,\n            inlineClassName: 'detected-link-active',\n            hoverMessage: HOVER_MESSAGE_GENERAL_META\n        }),\n        alt: textModel_1.ModelDecorationOptions.register({\n            stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n            collapseOnReplaceEdit: true,\n            inlineClassName: 'detected-link',\n            hoverMessage: HOVER_MESSAGE_GENERAL_ALT\n        }),\n        altActive: textModel_1.ModelDecorationOptions.register({\n            stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n            collapseOnReplaceEdit: true,\n            inlineClassName: 'detected-link-active',\n            hoverMessage: HOVER_MESSAGE_GENERAL_ALT\n        }),\n        altCommand: textModel_1.ModelDecorationOptions.register({\n            stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n            collapseOnReplaceEdit: true,\n            inlineClassName: 'detected-link',\n            hoverMessage: HOVER_MESSAGE_COMMAND_ALT\n        }),\n        altCommandActive: textModel_1.ModelDecorationOptions.register({\n            stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n            collapseOnReplaceEdit: true,\n            inlineClassName: 'detected-link-active',\n            hoverMessage: HOVER_MESSAGE_COMMAND_ALT\n        }),\n        metaCommand: textModel_1.ModelDecorationOptions.register({\n            stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n            collapseOnReplaceEdit: true,\n            inlineClassName: 'detected-link',\n            hoverMessage: HOVER_MESSAGE_COMMAND_META\n        }),\n        metaCommandActive: textModel_1.ModelDecorationOptions.register({\n            stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n            collapseOnReplaceEdit: true,\n            inlineClassName: 'detected-link-active',\n            hoverMessage: HOVER_MESSAGE_COMMAND_META\n        }),\n    };\n    class LinkOccurrence {\n        static decoration(link, useMetaKey) {\n            return {\n                range: link.range,\n                options: LinkOccurrence._getOptions(link, useMetaKey, false)\n            };\n        }\n        static _getOptions(link, useMetaKey, isActive) {\n            if (link.url && /^command:/i.test(link.url.toString())) {\n                if (useMetaKey) {\n                    return (isActive ? decoration.metaCommandActive : decoration.metaCommand);\n                }\n                else {\n                    return (isActive ? decoration.altCommandActive : decoration.altCommand);\n                }\n            }\n            else {\n                if (useMetaKey) {\n                    return (isActive ? decoration.metaActive : decoration.meta);\n                }\n                else {\n                    return (isActive ? decoration.altActive : decoration.alt);\n                }\n            }\n        }\n        constructor(link, decorationId) {\n            this.link = link;\n            this.decorationId = decorationId;\n        }\n        activate(changeAccessor, useMetaKey) {\n            changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurrence._getOptions(this.link, useMetaKey, true));\n        }\n        deactivate(changeAccessor, useMetaKey) {\n            changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurrence._getOptions(this.link, useMetaKey, false));\n        }\n    }\n    let LinkDetector = class LinkDetector {\n        constructor(editor, openerService, notificationService) {\n            this.editor = editor;\n            this.openerService = openerService;\n            this.notificationService = notificationService;\n            this.listenersToRemove = [];\n            let clickLinkGesture = new clickLinkGesture_1.ClickLinkGesture(editor);\n            this.listenersToRemove.push(clickLinkGesture);\n            this.listenersToRemove.push(clickLinkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {\n                this._onEditorMouseMove(mouseEvent, keyboardEvent);\n            }));\n            this.listenersToRemove.push(clickLinkGesture.onExecute((e) => {\n                this.onEditorMouseUp(e);\n            }));\n            this.listenersToRemove.push(clickLinkGesture.onCancel((e) => {\n                this.cleanUpActiveLinkDecoration();\n            }));\n            this.enabled = editor.getConfiguration().contribInfo.links;\n            this.listenersToRemove.push(editor.onDidChangeConfiguration((e) => {\n                let enabled = editor.getConfiguration().contribInfo.links;\n                if (this.enabled === enabled) {\n                    // No change in our configuration option\n                    return;\n                }\n                this.enabled = enabled;\n                // Remove any links (for the getting disabled case)\n                this.updateDecorations([]);\n                // Stop any computation (for the getting disabled case)\n                this.stop();\n                // Start computing (for the getting enabled case)\n                this.beginCompute();\n            }));\n            this.listenersToRemove.push(editor.onDidChangeModelContent((e) => this.onChange()));\n            this.listenersToRemove.push(editor.onDidChangeModel((e) => this.onModelChanged()));\n            this.listenersToRemove.push(editor.onDidChangeModelLanguage((e) => this.onModelModeChanged()));\n            this.listenersToRemove.push(modes_1.LinkProviderRegistry.onDidChange((e) => this.onModelModeChanged()));\n            this.timeout = new async.TimeoutTimer();\n            this.computePromise = null;\n            this.currentOccurrences = {};\n            this.activeLinkDecorationId = null;\n            this.beginCompute();\n        }\n        static get(editor) {\n            return editor.getContribution(LinkDetector.ID);\n        }\n        getId() {\n            return LinkDetector.ID;\n        }\n        onModelChanged() {\n            this.currentOccurrences = {};\n            this.activeLinkDecorationId = null;\n            this.stop();\n            this.beginCompute();\n        }\n        onModelModeChanged() {\n            this.stop();\n            this.beginCompute();\n        }\n        onChange() {\n            this.timeout.setIfNotSet(() => this.beginCompute(), LinkDetector.RECOMPUTE_TIME);\n        }\n        beginCompute() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!this.editor.hasModel() || !this.enabled) {\n                    return;\n                }\n                const model = this.editor.getModel();\n                if (!modes_1.LinkProviderRegistry.has(model)) {\n                    return;\n                }\n                this.computePromise = async.createCancelablePromise(token => getLinks_1.getLinks(model, token));\n                try {\n                    const links = yield this.computePromise;\n                    this.updateDecorations(links);\n                }\n                catch (err) {\n                    errors_1.onUnexpectedError(err);\n                }\n                finally {\n                    this.computePromise = null;\n                }\n            });\n        }\n        updateDecorations(links) {\n            const useMetaKey = (this.editor.getConfiguration().multiCursorModifier === 'altKey');\n            let oldDecorations = [];\n            let keys = Object.keys(this.currentOccurrences);\n            for (let i = 0, len = keys.length; i < len; i++) {\n                let decorationId = keys[i];\n                let occurance = this.currentOccurrences[decorationId];\n                oldDecorations.push(occurance.decorationId);\n            }\n            let newDecorations = [];\n            if (links) {\n                // Not sure why this is sometimes null\n                for (const link of links) {\n                    newDecorations.push(LinkOccurrence.decoration(link, useMetaKey));\n                }\n            }\n            let decorations = this.editor.deltaDecorations(oldDecorations, newDecorations);\n            this.currentOccurrences = {};\n            this.activeLinkDecorationId = null;\n            for (let i = 0, len = decorations.length; i < len; i++) {\n                let occurance = new LinkOccurrence(links[i], decorations[i]);\n                this.currentOccurrences[occurance.decorationId] = occurance;\n            }\n        }\n        _onEditorMouseMove(mouseEvent, withKey) {\n            const useMetaKey = (this.editor.getConfiguration().multiCursorModifier === 'altKey');\n            if (this.isEnabled(mouseEvent, withKey)) {\n                this.cleanUpActiveLinkDecoration(); // always remove previous link decoration as their can only be one\n                const occurrence = this.getLinkOccurrence(mouseEvent.target.position);\n                if (occurrence) {\n                    this.editor.changeDecorations((changeAccessor) => {\n                        occurrence.activate(changeAccessor, useMetaKey);\n                        this.activeLinkDecorationId = occurrence.decorationId;\n                    });\n                }\n            }\n            else {\n                this.cleanUpActiveLinkDecoration();\n            }\n        }\n        cleanUpActiveLinkDecoration() {\n            const useMetaKey = (this.editor.getConfiguration().multiCursorModifier === 'altKey');\n            if (this.activeLinkDecorationId) {\n                const occurrence = this.currentOccurrences[this.activeLinkDecorationId];\n                if (occurrence) {\n                    this.editor.changeDecorations((changeAccessor) => {\n                        occurrence.deactivate(changeAccessor, useMetaKey);\n                    });\n                }\n                this.activeLinkDecorationId = null;\n            }\n        }\n        onEditorMouseUp(mouseEvent) {\n            if (!this.isEnabled(mouseEvent)) {\n                return;\n            }\n            const occurrence = this.getLinkOccurrence(mouseEvent.target.position);\n            if (!occurrence) {\n                return;\n            }\n            this.openLinkOccurrence(occurrence, mouseEvent.hasSideBySideModifier);\n        }\n        openLinkOccurrence(occurrence, openToSide) {\n            if (!this.openerService) {\n                return;\n            }\n            const { link } = occurrence;\n            link.resolve(cancellation_1.CancellationToken.None).then(uri => {\n                // open the uri\n                return this.openerService.open(uri, { openToSide });\n            }, err => {\n                // different error cases\n                if (err === 'invalid') {\n                    this.notificationService.warn(nls.localize('invalid.url', 'Failed to open this link because it is not well-formed: {0}', link.url.toString()));\n                }\n                else if (err === 'missing') {\n                    this.notificationService.warn(nls.localize('missing.url', 'Failed to open this link because its target is missing.'));\n                }\n                else {\n                    errors_1.onUnexpectedError(err);\n                }\n            });\n        }\n        getLinkOccurrence(position) {\n            if (!this.editor.hasModel() || !position) {\n                return null;\n            }\n            const decorations = this.editor.getModel().getDecorationsInRange({\n                startLineNumber: position.lineNumber,\n                startColumn: position.column,\n                endLineNumber: position.lineNumber,\n                endColumn: position.column\n            }, 0, true);\n            for (const decoration of decorations) {\n                const currentOccurrence = this.currentOccurrences[decoration.id];\n                if (currentOccurrence) {\n                    return currentOccurrence;\n                }\n            }\n            return null;\n        }\n        isEnabled(mouseEvent, withKey) {\n            return Boolean((mouseEvent.target.type === editorBrowser_1.MouseTargetType.CONTENT_TEXT)\n                && (mouseEvent.hasTriggerModifier || (withKey && withKey.keyCodeIsTriggerKey)));\n        }\n        stop() {\n            this.timeout.cancel();\n            if (this.computePromise) {\n                this.computePromise.cancel();\n                this.computePromise = null;\n            }\n        }\n        dispose() {\n            this.listenersToRemove = lifecycle_1.dispose(this.listenersToRemove);\n            this.stop();\n            this.timeout.dispose();\n        }\n    };\n    LinkDetector.ID = 'editor.linkDetector';\n    LinkDetector.RECOMPUTE_TIME = 1000; // ms\n    LinkDetector = __decorate([\n        __param(1, opener_1.IOpenerService),\n        __param(2, notification_1.INotificationService)\n    ], LinkDetector);\n    class OpenLinkAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.openLink',\n                label: nls.localize('label', \"Open Link\"),\n                alias: 'Open Link',\n                precondition: null\n            });\n        }\n        run(accessor, editor) {\n            let linkDetector = LinkDetector.get(editor);\n            if (!linkDetector) {\n                return;\n            }\n            if (!editor.hasModel()) {\n                return;\n            }\n            let selections = editor.getSelections();\n            for (let sel of selections) {\n                let link = linkDetector.getLinkOccurrence(sel.getEndPosition());\n                if (link) {\n                    linkDetector.openLinkOccurrence(link, false);\n                }\n            }\n        }\n    }\n    editorExtensions_1.registerEditorContribution(LinkDetector);\n    editorExtensions_1.registerEditorAction(OpenLinkAction);\n    themeService_1.registerThemingParticipant((theme, collector) => {\n        const activeLinkForeground = theme.getColor(colorRegistry_1.editorActiveLinkForeground);\n        if (activeLinkForeground) {\n            collector.addRule(`.monaco-editor .detected-link-active { color: ${activeLinkForeground} !important; }`);\n        }\n    });\n});\n",null]}