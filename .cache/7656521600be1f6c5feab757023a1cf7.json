{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/platform/instantiation/common/instantiationService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/instantiation/common/instantiationService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar errors_1 = require(\"vs/base/common/errors\");\nvar types_1 = require(\"vs/base/common/types\");\nvar graph_1 = require(\"vs/platform/instantiation/common/graph\");\nvar descriptors_1 = require(\"vs/platform/instantiation/common/descriptors\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar serviceCollection_1 = require(\"vs/platform/instantiation/common/serviceCollection\");\nvar async_1 = require(\"vs/base/common/async\");\n// TRACING\nvar _enableTracing = false;\nvar _canUseProxy = typeof Proxy === 'function';\nvar InstantiationService = /** @class */ (function () {\n    function InstantiationService(services, strict, parent) {\n        if (services === void 0) { services = new serviceCollection_1.ServiceCollection(); }\n        if (strict === void 0) { strict = false; }\n        this._services = services;\n        this._strict = strict;\n        this._parent = parent;\n        this._services.set(instantiation_1.IInstantiationService, this);\n    }\n    InstantiationService.prototype.createChild = function (services) {\n        return new InstantiationService(services, this._strict, this);\n    };\n    InstantiationService.prototype.invokeFunction = function (fn) {\n        var _this = this;\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var _trace = Trace.traceInvocation(fn);\n        var _done = false;\n        try {\n            var accessor = {\n                get: function (id, isOptional) {\n                    if (_done) {\n                        throw errors_1.illegalState('service accessor is only valid during the invocation of its target method');\n                    }\n                    var result = _this._getOrCreateServiceInstance(id, _trace);\n                    if (!result && isOptional !== instantiation_1.optional) {\n                        throw new Error(\"[invokeFunction] unknown service '\" + id + \"'\");\n                    }\n                    return result;\n                }\n            };\n            return fn.apply(undefined, [accessor].concat(args));\n        }\n        finally {\n            _done = true;\n            _trace.stop();\n        }\n    };\n    InstantiationService.prototype.createInstance = function (ctorOrDescriptor) {\n        var rest = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            rest[_i - 1] = arguments[_i];\n        }\n        var _trace;\n        var result;\n        if (ctorOrDescriptor instanceof descriptors_1.SyncDescriptor) {\n            _trace = Trace.traceCreation(ctorOrDescriptor.ctor);\n            result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n        }\n        else {\n            _trace = Trace.traceCreation(ctorOrDescriptor);\n            result = this._createInstance(ctorOrDescriptor, rest, _trace);\n        }\n        _trace.stop();\n        return result;\n    };\n    InstantiationService.prototype._createInstance = function (ctor, args, _trace) {\n        if (args === void 0) { args = []; }\n        // arguments defined by service decorators\n        var serviceDependencies = instantiation_1._util.getServiceDependencies(ctor).sort(function (a, b) { return a.index - b.index; });\n        var serviceArgs = [];\n        for (var _i = 0, serviceDependencies_1 = serviceDependencies; _i < serviceDependencies_1.length; _i++) {\n            var dependency = serviceDependencies_1[_i];\n            var service = this._getOrCreateServiceInstance(dependency.id, _trace);\n            if (!service && this._strict && !dependency.optional) {\n                throw new Error(\"[createInstance] \" + ctor.name + \" depends on UNKNOWN service \" + dependency.id + \".\");\n            }\n            serviceArgs.push(service);\n        }\n        var firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n        // check for argument mismatches, adjust static args if needed\n        if (args.length !== firstServiceArgPos) {\n            console.warn(\"[createInstance] First service dependency of \" + ctor.name + \" at position \" + (firstServiceArgPos + 1) + \" conflicts with \" + args.length + \" static arguments\");\n            var delta = firstServiceArgPos - args.length;\n            if (delta > 0) {\n                args = args.concat(new Array(delta));\n            }\n            else {\n                args = args.slice(0, firstServiceArgPos);\n            }\n        }\n        // now create the instance\n        return types_1.create.apply(null, [ctor].concat(args, serviceArgs));\n    };\n    InstantiationService.prototype._setServiceInstance = function (id, instance) {\n        if (this._services.get(id) instanceof descriptors_1.SyncDescriptor) {\n            this._services.set(id, instance);\n        }\n        else if (this._parent) {\n            this._parent._setServiceInstance(id, instance);\n        }\n        else {\n            throw new Error('illegalState - setting UNKNOWN service instance');\n        }\n    };\n    InstantiationService.prototype._getServiceInstanceOrDescriptor = function (id) {\n        var instanceOrDesc = this._services.get(id);\n        if (!instanceOrDesc && this._parent) {\n            return this._parent._getServiceInstanceOrDescriptor(id);\n        }\n        else {\n            return instanceOrDesc;\n        }\n    };\n    InstantiationService.prototype._getOrCreateServiceInstance = function (id, _trace) {\n        var thing = this._getServiceInstanceOrDescriptor(id);\n        if (thing instanceof descriptors_1.SyncDescriptor) {\n            return this._createAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n        }\n        else {\n            _trace.branch(id, false);\n            return thing;\n        }\n    };\n    InstantiationService.prototype._createAndCacheServiceInstance = function (id, desc, _trace) {\n        var graph = new graph_1.Graph(function (data) { return data.id.toString(); });\n        function throwCycleError() {\n            var err = new Error('[createInstance] cyclic dependency between services');\n            err.message = graph.toString();\n            throw err;\n        }\n        var count = 0;\n        var stack = [{ id: id, desc: desc, _trace: _trace }];\n        while (stack.length) {\n            var item = stack.pop();\n            graph.lookupOrInsertNode(item);\n            // TODO@joh use the graph to find a cycle\n            // a weak heuristic for cycle checks\n            if (count++ > 100) {\n                throwCycleError();\n            }\n            // check all dependencies for existence and if they need to be created first\n            var dependencies = instantiation_1._util.getServiceDependencies(item.desc.ctor);\n            for (var _i = 0, dependencies_1 = dependencies; _i < dependencies_1.length; _i++) {\n                var dependency = dependencies_1[_i];\n                var instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n                if (!instanceOrDesc && !dependency.optional) {\n                    console.warn(\"[createInstance] \" + id + \" depends on \" + dependency.id + \" which is NOT registered.\");\n                }\n                if (instanceOrDesc instanceof descriptors_1.SyncDescriptor) {\n                    var d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\n                    graph.insertEdge(item, d);\n                    stack.push(d);\n                }\n            }\n        }\n        while (true) {\n            var roots = graph.roots();\n            // if there is no more roots but still\n            // nodes in the graph we have a cycle\n            if (roots.length === 0) {\n                if (!graph.isEmpty()) {\n                    throwCycleError();\n                }\n                break;\n            }\n            for (var _a = 0, roots_1 = roots; _a < roots_1.length; _a++) {\n                var data = roots_1[_a].data;\n                // create instance and overwrite the service collections\n                var instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n                this._setServiceInstance(data.id, instance);\n                graph.removeNode(data);\n            }\n        }\n        return this._getServiceInstanceOrDescriptor(id);\n    };\n    InstantiationService.prototype._createServiceInstanceWithOwner = function (id, ctor, args, supportsDelayedInstantiation, _trace) {\n        if (args === void 0) { args = []; }\n        if (this._services.get(id) instanceof descriptors_1.SyncDescriptor) {\n            return this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);\n        }\n        else if (this._parent) {\n            return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n        }\n        else {\n            throw new Error('illegalState - creating UNKNOWN service instance');\n        }\n    };\n    InstantiationService.prototype._createServiceInstance = function (ctor, args, _supportsDelayedInstantiation, _trace) {\n        var _this = this;\n        if (args === void 0) { args = []; }\n        if (!_supportsDelayedInstantiation || !_canUseProxy) {\n            // eager instantiation or no support JS proxies (e.g. IE11)\n            return this._createInstance(ctor, args, _trace);\n        }\n        else {\n            // Return a proxy object that's backed by an idle value. That\n            // strategy is to instantiate services in our idle time or when actually\n            // needed but not when injected into a consumer\n            var idle_1 = new async_1.IdleValue(function () { return _this._createInstance(ctor, args, _trace); });\n            return new Proxy(Object.create(null), {\n                get: function (_target, prop) {\n                    return idle_1.getValue()[prop];\n                },\n                set: function (_target, p, value) {\n                    idle_1.getValue()[p] = value;\n                    return true;\n                }\n            });\n        }\n    };\n    return InstantiationService;\n}());\nexports.InstantiationService = InstantiationService;\n//#region -- tracing ---\nvar TraceType;\n(function (TraceType) {\n    TraceType[TraceType[\"Creation\"] = 0] = \"Creation\";\n    TraceType[TraceType[\"Invocation\"] = 1] = \"Invocation\";\n    TraceType[TraceType[\"Branch\"] = 2] = \"Branch\";\n})(TraceType || (TraceType = {}));\nvar Trace = /** @class */ (function () {\n    function Trace(type, name) {\n        this.type = type;\n        this.name = name;\n        this._start = Date.now();\n        this._dep = [];\n    }\n    Trace.traceInvocation = function (ctor) {\n        return !_enableTracing ? Trace._None : new Trace(TraceType.Invocation, ctor.name || ctor.toString().substring(0, 42).replace(/\\n/g, ''));\n    };\n    Trace.traceCreation = function (ctor) {\n        return !_enableTracing ? Trace._None : new Trace(TraceType.Creation, ctor.name);\n    };\n    Trace.prototype.branch = function (id, first) {\n        var child = new Trace(TraceType.Branch, id.toString());\n        this._dep.push([id, first, child]);\n        return child;\n    };\n    Trace.prototype.stop = function () {\n        var dur = Date.now() - this._start;\n        Trace._totals += dur;\n        var causedCreation = false;\n        function printChild(n, trace) {\n            var res = [];\n            var prefix = new Array(n + 1).join('\\t');\n            for (var _i = 0, _a = trace._dep; _i < _a.length; _i++) {\n                var _b = _a[_i], id = _b[0], first = _b[1], child = _b[2];\n                if (first && child) {\n                    causedCreation = true;\n                    res.push(prefix + \"CREATES -> \" + id);\n                    var nested = printChild(n + 1, child);\n                    if (nested) {\n                        res.push(nested);\n                    }\n                }\n                else {\n                    res.push(prefix + \"uses -> \" + id);\n                }\n            }\n            return res.join('\\n');\n        }\n        var lines = [\n            (this.type === TraceType.Creation ? 'CREATE' : 'CALL') + \" \" + this.name,\n            \"\" + printChild(1, this),\n            \"DONE, took \" + dur.toFixed(2) + \"ms (grand total \" + Trace._totals.toFixed(2) + \"ms)\"\n        ];\n        if (dur > 2 || causedCreation) {\n            console.log(lines.join('\\n'));\n        }\n    };\n    Trace._None = new /** @class */ (function (_super) {\n        tslib_1.__extends(class_1, _super);\n        function class_1() {\n            return _super.call(this, -1, null) || this;\n        }\n        class_1.prototype.stop = function () { };\n        class_1.prototype.branch = function () { return this; };\n        return class_1;\n    }(Trace));\n    Trace._totals = 0;\n    return Trace;\n}());\n//#endregion\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/platform/instantiation/common/instantiationService.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/platform/instantiation/common/instantiationService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { illegalState } from 'vs/base/common/errors';\nimport { create } from 'vs/base/common/types';\nimport { Graph } from 'vs/platform/instantiation/common/graph';\nimport { SyncDescriptor } from 'vs/platform/instantiation/common/descriptors';\nimport { ServiceIdentifier, IInstantiationService, ServicesAccessor, _util, optional } from 'vs/platform/instantiation/common/instantiation';\nimport { ServiceCollection } from 'vs/platform/instantiation/common/serviceCollection';\nimport { IdleValue } from 'vs/base/common/async';\n\n// TRACING\nconst _enableTracing = false;\n\n// PROXY\n// Ghetto-declare of the global Proxy object. This isn't the proper way\n// but allows us to run this code in the browser without IE11.\ndeclare var Proxy: any;\nconst _canUseProxy = typeof Proxy === 'function';\n\nexport class InstantiationService implements IInstantiationService {\n\n\t_serviceBrand: any;\n\n\tprotected readonly _services: ServiceCollection;\n\tprotected readonly _strict: boolean;\n\tprotected readonly _parent?: InstantiationService;\n\n\tconstructor(services: ServiceCollection = new ServiceCollection(), strict: boolean = false, parent?: InstantiationService) {\n\t\tthis._services = services;\n\t\tthis._strict = strict;\n\t\tthis._parent = parent;\n\n\t\tthis._services.set(IInstantiationService, this);\n\t}\n\n\tcreateChild(services: ServiceCollection): IInstantiationService {\n\t\treturn new InstantiationService(services, this._strict, this);\n\t}\n\n\tinvokeFunction<R, TS extends any[]=[]>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R {\n\t\tlet _trace = Trace.traceInvocation(fn);\n\t\tlet _done = false;\n\t\ttry {\n\t\t\tconst accessor: ServicesAccessor = {\n\t\t\t\tget: <T>(id: ServiceIdentifier<T>, isOptional?: typeof optional) => {\n\n\t\t\t\t\tif (_done) {\n\t\t\t\t\t\tthrow illegalState('service accessor is only valid during the invocation of its target method');\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this._getOrCreateServiceInstance(id, _trace);\n\t\t\t\t\tif (!result && isOptional !== optional) {\n\t\t\t\t\t\tthrow new Error(`[invokeFunction] unknown service '${id}'`);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn fn.apply(undefined, [accessor, ...args]);\n\t\t} finally {\n\t\t\t_done = true;\n\t\t\t_trace.stop();\n\t\t}\n\t}\n\n\tcreateInstance(ctorOrDescriptor: any | SyncDescriptor<any>, ...rest: any[]): any {\n\t\tlet _trace: Trace;\n\t\tlet result: any;\n\t\tif (ctorOrDescriptor instanceof SyncDescriptor) {\n\t\t\t_trace = Trace.traceCreation(ctorOrDescriptor.ctor);\n\t\t\tresult = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n\t\t} else {\n\t\t\t_trace = Trace.traceCreation(ctorOrDescriptor);\n\t\t\tresult = this._createInstance(ctorOrDescriptor, rest, _trace);\n\t\t}\n\t\t_trace.stop();\n\t\treturn result;\n\t}\n\n\tprivate _createInstance<T>(ctor: any, args: any[] = [], _trace: Trace): T {\n\n\t\t// arguments defined by service decorators\n\t\tlet serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n\t\tlet serviceArgs: any[] = [];\n\t\tfor (const dependency of serviceDependencies) {\n\t\t\tlet service = this._getOrCreateServiceInstance(dependency.id, _trace);\n\t\t\tif (!service && this._strict && !dependency.optional) {\n\t\t\t\tthrow new Error(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`);\n\t\t\t}\n\t\t\tserviceArgs.push(service);\n\t\t}\n\n\t\tlet firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n\n\t\t// check for argument mismatches, adjust static args if needed\n\t\tif (args.length !== firstServiceArgPos) {\n\t\t\tconsole.warn(`[createInstance] First service dependency of ${ctor.name} at position ${\n\t\t\t\tfirstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n\n\t\t\tlet delta = firstServiceArgPos - args.length;\n\t\t\tif (delta > 0) {\n\t\t\t\targs = args.concat(new Array(delta));\n\t\t\t} else {\n\t\t\t\targs = args.slice(0, firstServiceArgPos);\n\t\t\t}\n\t\t}\n\n\t\t// now create the instance\n\t\treturn <T>create.apply(null, [ctor].concat(args, serviceArgs));\n\t}\n\n\tprivate _setServiceInstance<T>(id: ServiceIdentifier<T>, instance: T): void {\n\t\tif (this._services.get(id) instanceof SyncDescriptor) {\n\t\t\tthis._services.set(id, instance);\n\t\t} else if (this._parent) {\n\t\t\tthis._parent._setServiceInstance(id, instance);\n\t\t} else {\n\t\t\tthrow new Error('illegalState - setting UNKNOWN service instance');\n\t\t}\n\t}\n\n\tprivate _getServiceInstanceOrDescriptor<T>(id: ServiceIdentifier<T>): T | SyncDescriptor<T> {\n\t\tlet instanceOrDesc = this._services.get(id);\n\t\tif (!instanceOrDesc && this._parent) {\n\t\t\treturn this._parent._getServiceInstanceOrDescriptor(id);\n\t\t} else {\n\t\t\treturn instanceOrDesc;\n\t\t}\n\t}\n\n\tprivate _getOrCreateServiceInstance<T>(id: ServiceIdentifier<T>, _trace: Trace): T {\n\t\tlet thing = this._getServiceInstanceOrDescriptor(id);\n\t\tif (thing instanceof SyncDescriptor) {\n\t\t\treturn this._createAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n\t\t} else {\n\t\t\t_trace.branch(id, false);\n\t\t\treturn thing;\n\t\t}\n\t}\n\n\tprivate _createAndCacheServiceInstance<T>(id: ServiceIdentifier<T>, desc: SyncDescriptor<T>, _trace: Trace): T {\n\t\ttype Triple = { id: ServiceIdentifier<any>, desc: SyncDescriptor<any>, _trace: Trace };\n\t\tconst graph = new Graph<Triple>(data => data.id.toString());\n\n\t\tfunction throwCycleError() {\n\t\t\tconst err = new Error('[createInstance] cyclic dependency between services');\n\t\t\terr.message = graph.toString();\n\t\t\tthrow err;\n\t\t}\n\n\t\tlet count = 0;\n\t\tconst stack = [{ id, desc, _trace }];\n\t\twhile (stack.length) {\n\t\t\tconst item = stack.pop()!;\n\t\t\tgraph.lookupOrInsertNode(item);\n\n\t\t\t// TODO@joh use the graph to find a cycle\n\t\t\t// a weak heuristic for cycle checks\n\t\t\tif (count++ > 100) {\n\t\t\t\tthrowCycleError();\n\t\t\t}\n\n\t\t\t// check all dependencies for existence and if they need to be created first\n\t\t\tlet dependencies = _util.getServiceDependencies(item.desc.ctor);\n\t\t\tfor (let dependency of dependencies) {\n\n\t\t\t\tlet instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n\t\t\t\tif (!instanceOrDesc && !dependency.optional) {\n\t\t\t\t\tconsole.warn(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`);\n\t\t\t\t}\n\n\t\t\t\tif (instanceOrDesc instanceof SyncDescriptor) {\n\t\t\t\t\tconst d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\n\t\t\t\t\tgraph.insertEdge(item, d);\n\t\t\t\t\tstack.push(d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (true) {\n\t\t\tlet roots = graph.roots();\n\n\t\t\t// if there is no more roots but still\n\t\t\t// nodes in the graph we have a cycle\n\t\t\tif (roots.length === 0) {\n\t\t\t\tif (!graph.isEmpty()) {\n\t\t\t\t\tthrowCycleError();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (let { data } of roots) {\n\t\t\t\t// create instance and overwrite the service collections\n\t\t\t\tconst instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n\t\t\t\tthis._setServiceInstance(data.id, instance);\n\t\t\t\tgraph.removeNode(data);\n\t\t\t}\n\t\t}\n\n\t\treturn <T>this._getServiceInstanceOrDescriptor(id);\n\t}\n\n\tprivate _createServiceInstanceWithOwner<T>(id: ServiceIdentifier<T>, ctor: any, args: any[] = [], supportsDelayedInstantiation: boolean, _trace: Trace): T {\n\t\tif (this._services.get(id) instanceof SyncDescriptor) {\n\t\t\treturn this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);\n\t\t} else if (this._parent) {\n\t\t\treturn this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n\t\t} else {\n\t\t\tthrow new Error('illegalState - creating UNKNOWN service instance');\n\t\t}\n\t}\n\n\tprivate _createServiceInstance<T>(ctor: any, args: any[] = [], _supportsDelayedInstantiation: boolean, _trace: Trace): T {\n\t\tif (!_supportsDelayedInstantiation || !_canUseProxy) {\n\t\t\t// eager instantiation or no support JS proxies (e.g. IE11)\n\t\t\treturn this._createInstance(ctor, args, _trace);\n\n\t\t} else {\n\t\t\t// Return a proxy object that's backed by an idle value. That\n\t\t\t// strategy is to instantiate services in our idle time or when actually\n\t\t\t// needed but not when injected into a consumer\n\t\t\tconst idle = new IdleValue(() => this._createInstance(ctor, args, _trace));\n\t\t\treturn <T>new Proxy(Object.create(null), {\n\t\t\t\tget(_target: T, prop: PropertyKey): any {\n\t\t\t\t\treturn idle.getValue()[prop];\n\t\t\t\t},\n\t\t\t\tset(_target: T, p: PropertyKey, value: any): boolean {\n\t\t\t\t\tidle.getValue()[p] = value;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n\n//#region -- tracing ---\n\nconst enum TraceType {\n\tCreation, Invocation, Branch\n}\n\nclass Trace {\n\n\tprivate static _None = new class extends Trace {\n\t\tconstructor() { super(-1, null); }\n\t\tstop() { }\n\t\tbranch() { return this; }\n\t};\n\n\tstatic traceInvocation(ctor: any): Trace {\n\t\treturn !_enableTracing ? Trace._None : new Trace(TraceType.Invocation, ctor.name || (ctor.toString() as string).substring(0, 42).replace(/\\n/g, ''));\n\t}\n\n\tstatic traceCreation(ctor: any): Trace {\n\t\treturn !_enableTracing ? Trace._None : new Trace(TraceType.Creation, ctor.name);\n\t}\n\n\tprivate static _totals: number = 0;\n\tprivate readonly _start: number = Date.now();\n\tprivate readonly _dep: [ServiceIdentifier<any>, boolean, Trace?][] = [];\n\n\tprivate constructor(\n\t\treadonly type: TraceType,\n\t\treadonly name: string | null\n\t) { }\n\n\tbranch(id: ServiceIdentifier<any>, first: boolean): Trace {\n\t\tlet child = new Trace(TraceType.Branch, id.toString());\n\t\tthis._dep.push([id, first, child]);\n\t\treturn child;\n\t}\n\n\tstop() {\n\t\tlet dur = Date.now() - this._start;\n\t\tTrace._totals += dur;\n\n\t\tlet causedCreation = false;\n\n\t\tfunction printChild(n: number, trace: Trace) {\n\t\t\tlet res: string[] = [];\n\t\t\tlet prefix = new Array(n + 1).join('\\t');\n\t\t\tfor (const [id, first, child] of trace._dep) {\n\t\t\t\tif (first && child) {\n\t\t\t\t\tcausedCreation = true;\n\t\t\t\t\tres.push(`${prefix}CREATES -> ${id}`);\n\t\t\t\t\tlet nested = printChild(n + 1, child);\n\t\t\t\t\tif (nested) {\n\t\t\t\t\t\tres.push(nested);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tres.push(`${prefix}uses -> ${id}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res.join('\\n');\n\t\t}\n\n\t\tlet lines = [\n\t\t\t`${this.type === TraceType.Creation ? 'CREATE' : 'CALL'} ${this.name}`,\n\t\t\t`${printChild(1, this)}`,\n\t\t\t`DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\n\t\t];\n\n\t\tif (dur > 2 || causedCreation) {\n\t\t\tconsole.log(lines.join('\\n'));\n\t\t}\n\t}\n}\n\n//#endregion\n"]}]}