{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/keybinding/common/macLinuxKeyboardMapper.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/keybinding/common/macLinuxKeyboardMapper.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar keyCodes_1 = require(\"vs/base/common/keyCodes\");\nvar platform_1 = require(\"vs/base/common/platform\");\nvar scanCode_1 = require(\"vs/base/common/scanCode\");\nvar baseResolvedKeybinding_1 = require(\"vs/platform/keybinding/common/baseResolvedKeybinding\");\nfunction macLinuxKeyMappingEquals(a, b) {\n    if (!a && !b) {\n        return true;\n    }\n    if (!a || !b) {\n        return false;\n    }\n    return (a.value === b.value\n        && a.withShift === b.withShift\n        && a.withAltGr === b.withAltGr\n        && a.withShiftAltGr === b.withShiftAltGr);\n}\nfunction macLinuxKeyboardMappingEquals(a, b) {\n    if (!a && !b) {\n        return true;\n    }\n    if (!a || !b) {\n        return false;\n    }\n    for (var scanCode = 0; scanCode < scanCode_1.ScanCode.MAX_VALUE; scanCode++) {\n        var strScanCode = scanCode_1.ScanCodeUtils.toString(scanCode);\n        var aEntry = a[strScanCode];\n        var bEntry = b[strScanCode];\n        if (!macLinuxKeyMappingEquals(aEntry, bEntry)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.macLinuxKeyboardMappingEquals = macLinuxKeyboardMappingEquals;\n/**\n * A map from character to key codes.\n * e.g. Contains entries such as:\n *  - '/' => { keyCode: KeyCode.US_SLASH, shiftKey: false }\n *  - '?' => { keyCode: KeyCode.US_SLASH, shiftKey: true }\n */\nvar CHAR_CODE_TO_KEY_CODE = [];\nvar NativeResolvedKeybinding = /** @class */ (function (_super) {\n    tslib_1.__extends(NativeResolvedKeybinding, _super);\n    function NativeResolvedKeybinding(mapper, os, parts) {\n        var _this = _super.call(this, os, parts) || this;\n        _this._mapper = mapper;\n        return _this;\n    }\n    NativeResolvedKeybinding.prototype._getLabel = function (keybinding) {\n        return this._mapper.getUILabelForScanCodeBinding(keybinding);\n    };\n    NativeResolvedKeybinding.prototype._getAriaLabel = function (keybinding) {\n        return this._mapper.getAriaLabelForScanCodeBinding(keybinding);\n    };\n    NativeResolvedKeybinding.prototype._getElectronAccelerator = function (keybinding) {\n        return this._mapper.getElectronAcceleratorLabelForScanCodeBinding(keybinding);\n    };\n    NativeResolvedKeybinding.prototype._getUserSettingsLabel = function (keybinding) {\n        return this._mapper.getUserSettingsLabelForScanCodeBinding(keybinding);\n    };\n    NativeResolvedKeybinding.prototype._isWYSIWYG = function (binding) {\n        if (!binding) {\n            return true;\n        }\n        if (scanCode_1.IMMUTABLE_CODE_TO_KEY_CODE[binding.scanCode] !== -1) {\n            return true;\n        }\n        var a = this._mapper.getAriaLabelForScanCodeBinding(binding);\n        var b = this._mapper.getUserSettingsLabelForScanCodeBinding(binding);\n        if (!a && !b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        return (a.toLowerCase() === b.toLowerCase());\n    };\n    NativeResolvedKeybinding.prototype._getDispatchPart = function (keybinding) {\n        return this._mapper.getDispatchStrForScanCodeBinding(keybinding);\n    };\n    return NativeResolvedKeybinding;\n}(baseResolvedKeybinding_1.BaseResolvedKeybinding));\nexports.NativeResolvedKeybinding = NativeResolvedKeybinding;\nvar ScanCodeCombo = /** @class */ (function () {\n    function ScanCodeCombo(ctrlKey, shiftKey, altKey, scanCode) {\n        this.ctrlKey = ctrlKey;\n        this.shiftKey = shiftKey;\n        this.altKey = altKey;\n        this.scanCode = scanCode;\n    }\n    ScanCodeCombo.prototype.toString = function () {\n        return \"\" + (this.ctrlKey ? 'Ctrl+' : '') + (this.shiftKey ? 'Shift+' : '') + (this.altKey ? 'Alt+' : '') + scanCode_1.ScanCodeUtils.toString(this.scanCode);\n    };\n    ScanCodeCombo.prototype.equals = function (other) {\n        return (this.ctrlKey === other.ctrlKey\n            && this.shiftKey === other.shiftKey\n            && this.altKey === other.altKey\n            && this.scanCode === other.scanCode);\n    };\n    ScanCodeCombo.prototype.getProducedCharCode = function (mapping) {\n        if (!mapping) {\n            return '';\n        }\n        if (this.ctrlKey && this.shiftKey && this.altKey) {\n            return mapping.withShiftAltGr;\n        }\n        if (this.ctrlKey && this.altKey) {\n            return mapping.withAltGr;\n        }\n        if (this.shiftKey) {\n            return mapping.withShift;\n        }\n        return mapping.value;\n    };\n    ScanCodeCombo.prototype.getProducedChar = function (mapping) {\n        var charCode = MacLinuxKeyboardMapper.getCharCode(this.getProducedCharCode(mapping));\n        if (charCode === 0) {\n            return ' --- ';\n        }\n        if (charCode >= charCode_1.CharCode.U_Combining_Grave_Accent && charCode <= charCode_1.CharCode.U_Combining_Latin_Small_Letter_X) {\n            // combining\n            return 'U+' + charCode.toString(16);\n        }\n        return '  ' + String.fromCharCode(charCode) + '  ';\n    };\n    return ScanCodeCombo;\n}());\nvar KeyCodeCombo = /** @class */ (function () {\n    function KeyCodeCombo(ctrlKey, shiftKey, altKey, keyCode) {\n        this.ctrlKey = ctrlKey;\n        this.shiftKey = shiftKey;\n        this.altKey = altKey;\n        this.keyCode = keyCode;\n    }\n    KeyCodeCombo.prototype.toString = function () {\n        return \"\" + (this.ctrlKey ? 'Ctrl+' : '') + (this.shiftKey ? 'Shift+' : '') + (this.altKey ? 'Alt+' : '') + keyCodes_1.KeyCodeUtils.toString(this.keyCode);\n    };\n    return KeyCodeCombo;\n}());\nvar ScanCodeKeyCodeMapper = /** @class */ (function () {\n    function ScanCodeKeyCodeMapper() {\n        /**\n         * ScanCode combination => KeyCode combination.\n         * Only covers relevant modifiers ctrl, shift, alt (since meta does not influence the mappings).\n         */\n        this._scanCodeToKeyCode = [];\n        /**\n         * inverse of `_scanCodeToKeyCode`.\n         * KeyCode combination => ScanCode combination.\n         * Only covers relevant modifiers ctrl, shift, alt (since meta does not influence the mappings).\n         */\n        this._keyCodeToScanCode = [];\n        this._scanCodeToKeyCode = [];\n        this._keyCodeToScanCode = [];\n    }\n    ScanCodeKeyCodeMapper.prototype.registrationComplete = function () {\n        // IntlHash and IntlBackslash are rare keys, so ensure they don't end up being the preferred...\n        this._moveToEnd(scanCode_1.ScanCode.IntlHash);\n        this._moveToEnd(scanCode_1.ScanCode.IntlBackslash);\n    };\n    ScanCodeKeyCodeMapper.prototype._moveToEnd = function (scanCode) {\n        for (var mod = 0; mod < 8; mod++) {\n            var encodedKeyCodeCombos = this._scanCodeToKeyCode[(scanCode << 3) + mod];\n            if (!encodedKeyCodeCombos) {\n                continue;\n            }\n            for (var i = 0, len = encodedKeyCodeCombos.length; i < len; i++) {\n                var encodedScanCodeCombos = this._keyCodeToScanCode[encodedKeyCodeCombos[i]];\n                if (encodedScanCodeCombos.length === 1) {\n                    continue;\n                }\n                for (var j = 0, len_1 = encodedScanCodeCombos.length; j < len_1; j++) {\n                    var entry = encodedScanCodeCombos[j];\n                    var entryScanCode = (entry >>> 3);\n                    if (entryScanCode === scanCode) {\n                        // Move this entry to the end\n                        for (var k = j + 1; k < len_1; k++) {\n                            encodedScanCodeCombos[k - 1] = encodedScanCodeCombos[k];\n                        }\n                        encodedScanCodeCombos[len_1 - 1] = entry;\n                    }\n                }\n            }\n        }\n    };\n    ScanCodeKeyCodeMapper.prototype.registerIfUnknown = function (scanCodeCombo, keyCodeCombo) {\n        if (keyCodeCombo.keyCode === keyCodes_1.KeyCode.Unknown) {\n            return;\n        }\n        var scanCodeComboEncoded = this._encodeScanCodeCombo(scanCodeCombo);\n        var keyCodeComboEncoded = this._encodeKeyCodeCombo(keyCodeCombo);\n        var keyCodeIsDigit = (keyCodeCombo.keyCode >= keyCodes_1.KeyCode.KEY_0 && keyCodeCombo.keyCode <= keyCodes_1.KeyCode.KEY_9);\n        var keyCodeIsLetter = (keyCodeCombo.keyCode >= keyCodes_1.KeyCode.KEY_A && keyCodeCombo.keyCode <= keyCodes_1.KeyCode.KEY_Z);\n        var existingKeyCodeCombos = this._scanCodeToKeyCode[scanCodeComboEncoded];\n        // Allow a scan code to map to multiple key codes if it is a digit or a letter key code\n        if (keyCodeIsDigit || keyCodeIsLetter) {\n            // Only check that we don't insert the same entry twice\n            if (existingKeyCodeCombos) {\n                for (var i = 0, len = existingKeyCodeCombos.length; i < len; i++) {\n                    if (existingKeyCodeCombos[i] === keyCodeComboEncoded) {\n                        // avoid duplicates\n                        return;\n                    }\n                }\n            }\n        }\n        else {\n            // Don't allow multiples\n            if (existingKeyCodeCombos && existingKeyCodeCombos.length !== 0) {\n                return;\n            }\n        }\n        this._scanCodeToKeyCode[scanCodeComboEncoded] = this._scanCodeToKeyCode[scanCodeComboEncoded] || [];\n        this._scanCodeToKeyCode[scanCodeComboEncoded].unshift(keyCodeComboEncoded);\n        this._keyCodeToScanCode[keyCodeComboEncoded] = this._keyCodeToScanCode[keyCodeComboEncoded] || [];\n        this._keyCodeToScanCode[keyCodeComboEncoded].unshift(scanCodeComboEncoded);\n    };\n    ScanCodeKeyCodeMapper.prototype.lookupKeyCodeCombo = function (keyCodeCombo) {\n        var keyCodeComboEncoded = this._encodeKeyCodeCombo(keyCodeCombo);\n        var scanCodeCombosEncoded = this._keyCodeToScanCode[keyCodeComboEncoded];\n        if (!scanCodeCombosEncoded || scanCodeCombosEncoded.length === 0) {\n            return [];\n        }\n        var result = [];\n        for (var i = 0, len = scanCodeCombosEncoded.length; i < len; i++) {\n            var scanCodeComboEncoded = scanCodeCombosEncoded[i];\n            var ctrlKey = (scanCodeComboEncoded & 1) ? true : false;\n            var shiftKey = (scanCodeComboEncoded & 2) ? true : false;\n            var altKey = (scanCodeComboEncoded & 4) ? true : false;\n            var scanCode = (scanCodeComboEncoded >>> 3);\n            result[i] = new ScanCodeCombo(ctrlKey, shiftKey, altKey, scanCode);\n        }\n        return result;\n    };\n    ScanCodeKeyCodeMapper.prototype.lookupScanCodeCombo = function (scanCodeCombo) {\n        var scanCodeComboEncoded = this._encodeScanCodeCombo(scanCodeCombo);\n        var keyCodeCombosEncoded = this._scanCodeToKeyCode[scanCodeComboEncoded];\n        if (!keyCodeCombosEncoded || keyCodeCombosEncoded.length === 0) {\n            return [];\n        }\n        var result = [];\n        for (var i = 0, len = keyCodeCombosEncoded.length; i < len; i++) {\n            var keyCodeComboEncoded = keyCodeCombosEncoded[i];\n            var ctrlKey = (keyCodeComboEncoded & 1) ? true : false;\n            var shiftKey = (keyCodeComboEncoded & 2) ? true : false;\n            var altKey = (keyCodeComboEncoded & 4) ? true : false;\n            var keyCode = (keyCodeComboEncoded >>> 3);\n            result[i] = new KeyCodeCombo(ctrlKey, shiftKey, altKey, keyCode);\n        }\n        return result;\n    };\n    ScanCodeKeyCodeMapper.prototype.guessStableKeyCode = function (scanCode) {\n        if (scanCode >= scanCode_1.ScanCode.Digit1 && scanCode <= scanCode_1.ScanCode.Digit0) {\n            // digits are ok\n            switch (scanCode) {\n                case scanCode_1.ScanCode.Digit1: return keyCodes_1.KeyCode.KEY_1;\n                case scanCode_1.ScanCode.Digit2: return keyCodes_1.KeyCode.KEY_2;\n                case scanCode_1.ScanCode.Digit3: return keyCodes_1.KeyCode.KEY_3;\n                case scanCode_1.ScanCode.Digit4: return keyCodes_1.KeyCode.KEY_4;\n                case scanCode_1.ScanCode.Digit5: return keyCodes_1.KeyCode.KEY_5;\n                case scanCode_1.ScanCode.Digit6: return keyCodes_1.KeyCode.KEY_6;\n                case scanCode_1.ScanCode.Digit7: return keyCodes_1.KeyCode.KEY_7;\n                case scanCode_1.ScanCode.Digit8: return keyCodes_1.KeyCode.KEY_8;\n                case scanCode_1.ScanCode.Digit9: return keyCodes_1.KeyCode.KEY_9;\n                case scanCode_1.ScanCode.Digit0: return keyCodes_1.KeyCode.KEY_0;\n            }\n        }\n        // Lookup the scanCode with and without shift and see if the keyCode is stable\n        var keyCodeCombos1 = this.lookupScanCodeCombo(new ScanCodeCombo(false, false, false, scanCode));\n        var keyCodeCombos2 = this.lookupScanCodeCombo(new ScanCodeCombo(false, true, false, scanCode));\n        if (keyCodeCombos1.length === 1 && keyCodeCombos2.length === 1) {\n            var shiftKey1 = keyCodeCombos1[0].shiftKey;\n            var keyCode1 = keyCodeCombos1[0].keyCode;\n            var shiftKey2 = keyCodeCombos2[0].shiftKey;\n            var keyCode2 = keyCodeCombos2[0].keyCode;\n            if (keyCode1 === keyCode2 && shiftKey1 !== shiftKey2) {\n                // This looks like a stable mapping\n                return keyCode1;\n            }\n        }\n        return -1;\n    };\n    ScanCodeKeyCodeMapper.prototype._encodeScanCodeCombo = function (scanCodeCombo) {\n        return this._encode(scanCodeCombo.ctrlKey, scanCodeCombo.shiftKey, scanCodeCombo.altKey, scanCodeCombo.scanCode);\n    };\n    ScanCodeKeyCodeMapper.prototype._encodeKeyCodeCombo = function (keyCodeCombo) {\n        return this._encode(keyCodeCombo.ctrlKey, keyCodeCombo.shiftKey, keyCodeCombo.altKey, keyCodeCombo.keyCode);\n    };\n    ScanCodeKeyCodeMapper.prototype._encode = function (ctrlKey, shiftKey, altKey, principal) {\n        return (((ctrlKey ? 1 : 0) << 0)\n            | ((shiftKey ? 1 : 0) << 1)\n            | ((altKey ? 1 : 0) << 2)\n            | principal << 3) >>> 0;\n    };\n    return ScanCodeKeyCodeMapper;\n}());\nvar MacLinuxKeyboardMapper = /** @class */ (function () {\n    function MacLinuxKeyboardMapper(isUSStandard, rawMappings, OS) {\n        var _this = this;\n        /**\n         * UI label for a ScanCode.\n         */\n        this._scanCodeToLabel = [];\n        /**\n         * Dispatching string for a ScanCode.\n         */\n        this._scanCodeToDispatch = [];\n        this._isUSStandard = isUSStandard;\n        this._OS = OS;\n        this._codeInfo = [];\n        this._scanCodeKeyCodeMapper = new ScanCodeKeyCodeMapper();\n        this._scanCodeToLabel = [];\n        this._scanCodeToDispatch = [];\n        var _registerIfUnknown = function (hwCtrlKey, hwShiftKey, hwAltKey, scanCode, kbCtrlKey, kbShiftKey, kbAltKey, keyCode) {\n            _this._scanCodeKeyCodeMapper.registerIfUnknown(new ScanCodeCombo(hwCtrlKey ? true : false, hwShiftKey ? true : false, hwAltKey ? true : false, scanCode), new KeyCodeCombo(kbCtrlKey ? true : false, kbShiftKey ? true : false, kbAltKey ? true : false, keyCode));\n        };\n        var _registerAllCombos = function (_ctrlKey, _shiftKey, _altKey, scanCode, keyCode) {\n            for (var ctrlKey = _ctrlKey; ctrlKey <= 1; ctrlKey++) {\n                for (var shiftKey = _shiftKey; shiftKey <= 1; shiftKey++) {\n                    for (var altKey = _altKey; altKey <= 1; altKey++) {\n                        _registerIfUnknown(ctrlKey, shiftKey, altKey, scanCode, ctrlKey, shiftKey, altKey, keyCode);\n                    }\n                }\n            }\n        };\n        // Initialize `_scanCodeToLabel`\n        for (var scanCode = scanCode_1.ScanCode.None; scanCode < scanCode_1.ScanCode.MAX_VALUE; scanCode++) {\n            this._scanCodeToLabel[scanCode] = null;\n        }\n        // Initialize `_scanCodeToDispatch`\n        for (var scanCode = scanCode_1.ScanCode.None; scanCode < scanCode_1.ScanCode.MAX_VALUE; scanCode++) {\n            this._scanCodeToDispatch[scanCode] = null;\n        }\n        // Handle immutable mappings\n        for (var scanCode = scanCode_1.ScanCode.None; scanCode < scanCode_1.ScanCode.MAX_VALUE; scanCode++) {\n            var keyCode = scanCode_1.IMMUTABLE_CODE_TO_KEY_CODE[scanCode];\n            if (keyCode !== -1) {\n                _registerAllCombos(0, 0, 0, scanCode, keyCode);\n                this._scanCodeToLabel[scanCode] = keyCodes_1.KeyCodeUtils.toString(keyCode);\n                if (keyCode === keyCodes_1.KeyCode.Unknown || keyCode === keyCodes_1.KeyCode.Ctrl || keyCode === keyCodes_1.KeyCode.Meta || keyCode === keyCodes_1.KeyCode.Alt || keyCode === keyCodes_1.KeyCode.Shift) {\n                    this._scanCodeToDispatch[scanCode] = null; // cannot dispatch on this ScanCode\n                }\n                else {\n                    this._scanCodeToDispatch[scanCode] = \"[\" + scanCode_1.ScanCodeUtils.toString(scanCode) + \"]\";\n                }\n            }\n        }\n        // Try to identify keyboard layouts where characters A-Z are missing\n        // and forcefully map them to their corresponding scan codes if that is the case\n        var missingLatinLettersOverride = {};\n        {\n            var producesLatinLetter_1 = [];\n            for (var strScanCode in rawMappings) {\n                if (rawMappings.hasOwnProperty(strScanCode)) {\n                    var scanCode = scanCode_1.ScanCodeUtils.toEnum(strScanCode);\n                    if (scanCode === scanCode_1.ScanCode.None) {\n                        continue;\n                    }\n                    if (scanCode_1.IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== -1) {\n                        continue;\n                    }\n                    var rawMapping = rawMappings[strScanCode];\n                    var value = MacLinuxKeyboardMapper.getCharCode(rawMapping.value);\n                    if (value >= charCode_1.CharCode.a && value <= charCode_1.CharCode.z) {\n                        var upperCaseValue = charCode_1.CharCode.A + (value - charCode_1.CharCode.a);\n                        producesLatinLetter_1[upperCaseValue] = true;\n                    }\n                }\n            }\n            var _registerLetterIfMissing = function (charCode, scanCode, value, withShift) {\n                if (!producesLatinLetter_1[charCode]) {\n                    missingLatinLettersOverride[scanCode_1.ScanCodeUtils.toString(scanCode)] = {\n                        value: value,\n                        withShift: withShift,\n                        withAltGr: '',\n                        withShiftAltGr: ''\n                    };\n                }\n            };\n            // Ensure letters are mapped\n            _registerLetterIfMissing(charCode_1.CharCode.A, scanCode_1.ScanCode.KeyA, 'a', 'A');\n            _registerLetterIfMissing(charCode_1.CharCode.B, scanCode_1.ScanCode.KeyB, 'b', 'B');\n            _registerLetterIfMissing(charCode_1.CharCode.C, scanCode_1.ScanCode.KeyC, 'c', 'C');\n            _registerLetterIfMissing(charCode_1.CharCode.D, scanCode_1.ScanCode.KeyD, 'd', 'D');\n            _registerLetterIfMissing(charCode_1.CharCode.E, scanCode_1.ScanCode.KeyE, 'e', 'E');\n            _registerLetterIfMissing(charCode_1.CharCode.F, scanCode_1.ScanCode.KeyF, 'f', 'F');\n            _registerLetterIfMissing(charCode_1.CharCode.G, scanCode_1.ScanCode.KeyG, 'g', 'G');\n            _registerLetterIfMissing(charCode_1.CharCode.H, scanCode_1.ScanCode.KeyH, 'h', 'H');\n            _registerLetterIfMissing(charCode_1.CharCode.I, scanCode_1.ScanCode.KeyI, 'i', 'I');\n            _registerLetterIfMissing(charCode_1.CharCode.J, scanCode_1.ScanCode.KeyJ, 'j', 'J');\n            _registerLetterIfMissing(charCode_1.CharCode.K, scanCode_1.ScanCode.KeyK, 'k', 'K');\n            _registerLetterIfMissing(charCode_1.CharCode.L, scanCode_1.ScanCode.KeyL, 'l', 'L');\n            _registerLetterIfMissing(charCode_1.CharCode.M, scanCode_1.ScanCode.KeyM, 'm', 'M');\n            _registerLetterIfMissing(charCode_1.CharCode.N, scanCode_1.ScanCode.KeyN, 'n', 'N');\n            _registerLetterIfMissing(charCode_1.CharCode.O, scanCode_1.ScanCode.KeyO, 'o', 'O');\n            _registerLetterIfMissing(charCode_1.CharCode.P, scanCode_1.ScanCode.KeyP, 'p', 'P');\n            _registerLetterIfMissing(charCode_1.CharCode.Q, scanCode_1.ScanCode.KeyQ, 'q', 'Q');\n            _registerLetterIfMissing(charCode_1.CharCode.R, scanCode_1.ScanCode.KeyR, 'r', 'R');\n            _registerLetterIfMissing(charCode_1.CharCode.S, scanCode_1.ScanCode.KeyS, 's', 'S');\n            _registerLetterIfMissing(charCode_1.CharCode.T, scanCode_1.ScanCode.KeyT, 't', 'T');\n            _registerLetterIfMissing(charCode_1.CharCode.U, scanCode_1.ScanCode.KeyU, 'u', 'U');\n            _registerLetterIfMissing(charCode_1.CharCode.V, scanCode_1.ScanCode.KeyV, 'v', 'V');\n            _registerLetterIfMissing(charCode_1.CharCode.W, scanCode_1.ScanCode.KeyW, 'w', 'W');\n            _registerLetterIfMissing(charCode_1.CharCode.X, scanCode_1.ScanCode.KeyX, 'x', 'X');\n            _registerLetterIfMissing(charCode_1.CharCode.Y, scanCode_1.ScanCode.KeyY, 'y', 'Y');\n            _registerLetterIfMissing(charCode_1.CharCode.Z, scanCode_1.ScanCode.KeyZ, 'z', 'Z');\n        }\n        var mappings = [], mappingsLen = 0;\n        for (var strScanCode in rawMappings) {\n            if (rawMappings.hasOwnProperty(strScanCode)) {\n                var scanCode = scanCode_1.ScanCodeUtils.toEnum(strScanCode);\n                if (scanCode === scanCode_1.ScanCode.None) {\n                    continue;\n                }\n                if (scanCode_1.IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== -1) {\n                    continue;\n                }\n                this._codeInfo[scanCode] = rawMappings[strScanCode];\n                var rawMapping = missingLatinLettersOverride[strScanCode] || rawMappings[strScanCode];\n                var value = MacLinuxKeyboardMapper.getCharCode(rawMapping.value);\n                var withShift = MacLinuxKeyboardMapper.getCharCode(rawMapping.withShift);\n                var withAltGr = MacLinuxKeyboardMapper.getCharCode(rawMapping.withAltGr);\n                var withShiftAltGr = MacLinuxKeyboardMapper.getCharCode(rawMapping.withShiftAltGr);\n                var mapping = {\n                    scanCode: scanCode,\n                    value: value,\n                    withShift: withShift,\n                    withAltGr: withAltGr,\n                    withShiftAltGr: withShiftAltGr,\n                };\n                mappings[mappingsLen++] = mapping;\n                this._scanCodeToDispatch[scanCode] = \"[\" + scanCode_1.ScanCodeUtils.toString(scanCode) + \"]\";\n                if (value >= charCode_1.CharCode.a && value <= charCode_1.CharCode.z) {\n                    var upperCaseValue = charCode_1.CharCode.A + (value - charCode_1.CharCode.a);\n                    this._scanCodeToLabel[scanCode] = String.fromCharCode(upperCaseValue);\n                }\n                else if (value >= charCode_1.CharCode.A && value <= charCode_1.CharCode.Z) {\n                    this._scanCodeToLabel[scanCode] = String.fromCharCode(value);\n                }\n                else if (value) {\n                    this._scanCodeToLabel[scanCode] = String.fromCharCode(value);\n                }\n                else {\n                    this._scanCodeToLabel[scanCode] = null;\n                }\n            }\n        }\n        // Handle all `withShiftAltGr` entries\n        for (var i = mappings.length - 1; i >= 0; i--) {\n            var mapping = mappings[i];\n            var scanCode = mapping.scanCode;\n            var withShiftAltGr = mapping.withShiftAltGr;\n            if (withShiftAltGr === mapping.withAltGr || withShiftAltGr === mapping.withShift || withShiftAltGr === mapping.value) {\n                // handled below\n                continue;\n            }\n            var kb = MacLinuxKeyboardMapper._charCodeToKb(withShiftAltGr);\n            if (!kb) {\n                continue;\n            }\n            var kbShiftKey = kb.shiftKey;\n            var keyCode = kb.keyCode;\n            if (kbShiftKey) {\n                // Ctrl+Shift+Alt+ScanCode => Shift+KeyCode\n                _registerIfUnknown(1, 1, 1, scanCode, 0, 1, 0, keyCode); //       Ctrl+Alt+ScanCode =>          Shift+KeyCode\n            }\n            else {\n                // Ctrl+Shift+Alt+ScanCode => KeyCode\n                _registerIfUnknown(1, 1, 1, scanCode, 0, 0, 0, keyCode); //       Ctrl+Alt+ScanCode =>                KeyCode\n            }\n        }\n        // Handle all `withAltGr` entries\n        for (var i = mappings.length - 1; i >= 0; i--) {\n            var mapping = mappings[i];\n            var scanCode = mapping.scanCode;\n            var withAltGr = mapping.withAltGr;\n            if (withAltGr === mapping.withShift || withAltGr === mapping.value) {\n                // handled below\n                continue;\n            }\n            var kb = MacLinuxKeyboardMapper._charCodeToKb(withAltGr);\n            if (!kb) {\n                continue;\n            }\n            var kbShiftKey = kb.shiftKey;\n            var keyCode = kb.keyCode;\n            if (kbShiftKey) {\n                // Ctrl+Alt+ScanCode => Shift+KeyCode\n                _registerIfUnknown(1, 0, 1, scanCode, 0, 1, 0, keyCode); //       Ctrl+Alt+ScanCode =>          Shift+KeyCode\n            }\n            else {\n                // Ctrl+Alt+ScanCode => KeyCode\n                _registerIfUnknown(1, 0, 1, scanCode, 0, 0, 0, keyCode); //       Ctrl+Alt+ScanCode =>                KeyCode\n            }\n        }\n        // Handle all `withShift` entries\n        for (var i = mappings.length - 1; i >= 0; i--) {\n            var mapping = mappings[i];\n            var scanCode = mapping.scanCode;\n            var withShift = mapping.withShift;\n            if (withShift === mapping.value) {\n                // handled below\n                continue;\n            }\n            var kb = MacLinuxKeyboardMapper._charCodeToKb(withShift);\n            if (!kb) {\n                continue;\n            }\n            var kbShiftKey = kb.shiftKey;\n            var keyCode = kb.keyCode;\n            if (kbShiftKey) {\n                // Shift+ScanCode => Shift+KeyCode\n                _registerIfUnknown(0, 1, 0, scanCode, 0, 1, 0, keyCode); //          Shift+ScanCode =>          Shift+KeyCode\n                _registerIfUnknown(0, 1, 1, scanCode, 0, 1, 1, keyCode); //      Shift+Alt+ScanCode =>      Shift+Alt+KeyCode\n                _registerIfUnknown(1, 1, 0, scanCode, 1, 1, 0, keyCode); //     Ctrl+Shift+ScanCode =>     Ctrl+Shift+KeyCode\n                _registerIfUnknown(1, 1, 1, scanCode, 1, 1, 1, keyCode); // Ctrl+Shift+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n            }\n            else {\n                // Shift+ScanCode => KeyCode\n                _registerIfUnknown(0, 1, 0, scanCode, 0, 0, 0, keyCode); //          Shift+ScanCode =>                KeyCode\n                _registerIfUnknown(0, 1, 0, scanCode, 0, 1, 0, keyCode); //          Shift+ScanCode =>          Shift+KeyCode\n                _registerIfUnknown(0, 1, 1, scanCode, 0, 0, 1, keyCode); //      Shift+Alt+ScanCode =>            Alt+KeyCode\n                _registerIfUnknown(0, 1, 1, scanCode, 0, 1, 1, keyCode); //      Shift+Alt+ScanCode =>      Shift+Alt+KeyCode\n                _registerIfUnknown(1, 1, 0, scanCode, 1, 0, 0, keyCode); //     Ctrl+Shift+ScanCode =>           Ctrl+KeyCode\n                _registerIfUnknown(1, 1, 0, scanCode, 1, 1, 0, keyCode); //     Ctrl+Shift+ScanCode =>     Ctrl+Shift+KeyCode\n                _registerIfUnknown(1, 1, 1, scanCode, 1, 0, 1, keyCode); // Ctrl+Shift+Alt+ScanCode =>       Ctrl+Alt+KeyCode\n                _registerIfUnknown(1, 1, 1, scanCode, 1, 1, 1, keyCode); // Ctrl+Shift+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n            }\n        }\n        // Handle all `value` entries\n        for (var i = mappings.length - 1; i >= 0; i--) {\n            var mapping = mappings[i];\n            var scanCode = mapping.scanCode;\n            var kb = MacLinuxKeyboardMapper._charCodeToKb(mapping.value);\n            if (!kb) {\n                continue;\n            }\n            var kbShiftKey = kb.shiftKey;\n            var keyCode = kb.keyCode;\n            if (kbShiftKey) {\n                // ScanCode => Shift+KeyCode\n                _registerIfUnknown(0, 0, 0, scanCode, 0, 1, 0, keyCode); //                ScanCode =>          Shift+KeyCode\n                _registerIfUnknown(0, 0, 1, scanCode, 0, 1, 1, keyCode); //            Alt+ScanCode =>      Shift+Alt+KeyCode\n                _registerIfUnknown(1, 0, 0, scanCode, 1, 1, 0, keyCode); //           Ctrl+ScanCode =>     Ctrl+Shift+KeyCode\n                _registerIfUnknown(1, 0, 1, scanCode, 1, 1, 1, keyCode); //       Ctrl+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n            }\n            else {\n                // ScanCode => KeyCode\n                _registerIfUnknown(0, 0, 0, scanCode, 0, 0, 0, keyCode); //                ScanCode =>                KeyCode\n                _registerIfUnknown(0, 0, 1, scanCode, 0, 0, 1, keyCode); //            Alt+ScanCode =>            Alt+KeyCode\n                _registerIfUnknown(0, 1, 0, scanCode, 0, 1, 0, keyCode); //          Shift+ScanCode =>          Shift+KeyCode\n                _registerIfUnknown(0, 1, 1, scanCode, 0, 1, 1, keyCode); //      Shift+Alt+ScanCode =>      Shift+Alt+KeyCode\n                _registerIfUnknown(1, 0, 0, scanCode, 1, 0, 0, keyCode); //           Ctrl+ScanCode =>           Ctrl+KeyCode\n                _registerIfUnknown(1, 0, 1, scanCode, 1, 0, 1, keyCode); //       Ctrl+Alt+ScanCode =>       Ctrl+Alt+KeyCode\n                _registerIfUnknown(1, 1, 0, scanCode, 1, 1, 0, keyCode); //     Ctrl+Shift+ScanCode =>     Ctrl+Shift+KeyCode\n                _registerIfUnknown(1, 1, 1, scanCode, 1, 1, 1, keyCode); // Ctrl+Shift+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n            }\n        }\n        // Handle all left-over available digits\n        _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit1, keyCodes_1.KeyCode.KEY_1);\n        _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit2, keyCodes_1.KeyCode.KEY_2);\n        _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit3, keyCodes_1.KeyCode.KEY_3);\n        _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit4, keyCodes_1.KeyCode.KEY_4);\n        _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit5, keyCodes_1.KeyCode.KEY_5);\n        _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit6, keyCodes_1.KeyCode.KEY_6);\n        _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit7, keyCodes_1.KeyCode.KEY_7);\n        _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit8, keyCodes_1.KeyCode.KEY_8);\n        _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit9, keyCodes_1.KeyCode.KEY_9);\n        _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit0, keyCodes_1.KeyCode.KEY_0);\n        this._scanCodeKeyCodeMapper.registrationComplete();\n    }\n    MacLinuxKeyboardMapper.prototype.dumpDebugInfo = function () {\n        var result = [];\n        var immutableSamples = [\n            scanCode_1.ScanCode.ArrowUp,\n            scanCode_1.ScanCode.Numpad0\n        ];\n        var cnt = 0;\n        result.push(\"isUSStandard: \" + this._isUSStandard);\n        result.push(\"----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\");\n        for (var scanCode = scanCode_1.ScanCode.None; scanCode < scanCode_1.ScanCode.MAX_VALUE; scanCode++) {\n            if (scanCode_1.IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== -1) {\n                if (immutableSamples.indexOf(scanCode) === -1) {\n                    continue;\n                }\n            }\n            if (cnt % 4 === 0) {\n                result.push(\"|       HW Code combination      |  Key  |    KeyCode combination    | Pri |          UI label         |         User settings          |    Electron accelerator   |       Dispatching string       | WYSIWYG |\");\n                result.push(\"----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\");\n            }\n            cnt++;\n            var mapping = this._codeInfo[scanCode];\n            for (var mod = 0; mod < 8; mod++) {\n                var hwCtrlKey = (mod & 1) ? true : false;\n                var hwShiftKey = (mod & 2) ? true : false;\n                var hwAltKey = (mod & 4) ? true : false;\n                var scanCodeCombo = new ScanCodeCombo(hwCtrlKey, hwShiftKey, hwAltKey, scanCode);\n                var resolvedKb = this.resolveKeyboardEvent({\n                    _standardKeyboardEventBrand: true,\n                    ctrlKey: scanCodeCombo.ctrlKey,\n                    shiftKey: scanCodeCombo.shiftKey,\n                    altKey: scanCodeCombo.altKey,\n                    metaKey: false,\n                    keyCode: -1,\n                    code: scanCode_1.ScanCodeUtils.toString(scanCode)\n                });\n                var outScanCodeCombo = scanCodeCombo.toString();\n                var outKey = scanCodeCombo.getProducedChar(mapping);\n                var ariaLabel = resolvedKb.getAriaLabel();\n                var outUILabel = (ariaLabel ? ariaLabel.replace(/Control\\+/, 'Ctrl+') : null);\n                var outUserSettings = resolvedKb.getUserSettingsLabel();\n                var outElectronAccelerator = resolvedKb.getElectronAccelerator();\n                var outDispatchStr = resolvedKb.getDispatchParts()[0];\n                var isWYSIWYG = (resolvedKb ? resolvedKb.isWYSIWYG() : false);\n                var outWYSIWYG = (isWYSIWYG ? '       ' : '   NO  ');\n                var kbCombos = this._scanCodeKeyCodeMapper.lookupScanCodeCombo(scanCodeCombo);\n                if (kbCombos.length === 0) {\n                    result.push(\"| \" + this._leftPad(outScanCodeCombo, 30) + \" | \" + outKey + \" | \" + this._leftPad('', 25) + \" | \" + this._leftPad('', 3) + \" | \" + this._leftPad(outUILabel, 25) + \" | \" + this._leftPad(outUserSettings, 30) + \" | \" + this._leftPad(outElectronAccelerator, 25) + \" | \" + this._leftPad(outDispatchStr, 30) + \" | \" + outWYSIWYG + \" |\");\n                }\n                else {\n                    for (var i = 0, len = kbCombos.length; i < len; i++) {\n                        var kbCombo = kbCombos[i];\n                        // find out the priority of this scan code for this key code\n                        var colPriority = void 0;\n                        var scanCodeCombos = this._scanCodeKeyCodeMapper.lookupKeyCodeCombo(kbCombo);\n                        if (scanCodeCombos.length === 1) {\n                            // no need for priority, this key code combo maps to precisely this scan code combo\n                            colPriority = '';\n                        }\n                        else {\n                            var priority = -1;\n                            for (var j = 0; j < scanCodeCombos.length; j++) {\n                                if (scanCodeCombos[j].equals(scanCodeCombo)) {\n                                    priority = j + 1;\n                                    break;\n                                }\n                            }\n                            colPriority = String(priority);\n                        }\n                        var outKeybinding = kbCombo.toString();\n                        if (i === 0) {\n                            result.push(\"| \" + this._leftPad(outScanCodeCombo, 30) + \" | \" + outKey + \" | \" + this._leftPad(outKeybinding, 25) + \" | \" + this._leftPad(colPriority, 3) + \" | \" + this._leftPad(outUILabel, 25) + \" | \" + this._leftPad(outUserSettings, 30) + \" | \" + this._leftPad(outElectronAccelerator, 25) + \" | \" + this._leftPad(outDispatchStr, 30) + \" | \" + outWYSIWYG + \" |\");\n                        }\n                        else {\n                            // secondary keybindings\n                            result.push(\"| \" + this._leftPad('', 30) + \" |       | \" + this._leftPad(outKeybinding, 25) + \" | \" + this._leftPad(colPriority, 3) + \" | \" + this._leftPad('', 25) + \" | \" + this._leftPad('', 30) + \" | \" + this._leftPad('', 25) + \" | \" + this._leftPad('', 30) + \" |         |\");\n                        }\n                    }\n                }\n            }\n            result.push(\"----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\");\n        }\n        return result.join('\\n');\n    };\n    MacLinuxKeyboardMapper.prototype._leftPad = function (str, cnt) {\n        if (str === null) {\n            str = 'null';\n        }\n        while (str.length < cnt) {\n            str = ' ' + str;\n        }\n        return str;\n    };\n    MacLinuxKeyboardMapper.prototype.simpleKeybindingToScanCodeBinding = function (keybinding) {\n        // Avoid double Enter bindings (both ScanCode.NumpadEnter and ScanCode.Enter point to KeyCode.Enter)\n        if (keybinding.keyCode === keyCodes_1.KeyCode.Enter) {\n            return [new scanCode_1.ScanCodeBinding(keybinding.ctrlKey, keybinding.shiftKey, keybinding.altKey, keybinding.metaKey, scanCode_1.ScanCode.Enter)];\n        }\n        var scanCodeCombos = this._scanCodeKeyCodeMapper.lookupKeyCodeCombo(new KeyCodeCombo(keybinding.ctrlKey, keybinding.shiftKey, keybinding.altKey, keybinding.keyCode));\n        var result = [];\n        for (var i = 0, len = scanCodeCombos.length; i < len; i++) {\n            var scanCodeCombo = scanCodeCombos[i];\n            result[i] = new scanCode_1.ScanCodeBinding(scanCodeCombo.ctrlKey, scanCodeCombo.shiftKey, scanCodeCombo.altKey, keybinding.metaKey, scanCodeCombo.scanCode);\n        }\n        return result;\n    };\n    MacLinuxKeyboardMapper.prototype.getUILabelForScanCodeBinding = function (binding) {\n        if (!binding) {\n            return null;\n        }\n        if (binding.isDuplicateModifierCase()) {\n            return '';\n        }\n        if (this._OS === platform_1.OperatingSystem.Macintosh) {\n            switch (binding.scanCode) {\n                case scanCode_1.ScanCode.ArrowLeft:\n                    return '←';\n                case scanCode_1.ScanCode.ArrowUp:\n                    return '↑';\n                case scanCode_1.ScanCode.ArrowRight:\n                    return '→';\n                case scanCode_1.ScanCode.ArrowDown:\n                    return '↓';\n            }\n        }\n        return this._scanCodeToLabel[binding.scanCode];\n    };\n    MacLinuxKeyboardMapper.prototype.getAriaLabelForScanCodeBinding = function (binding) {\n        if (!binding) {\n            return null;\n        }\n        if (binding.isDuplicateModifierCase()) {\n            return '';\n        }\n        return this._scanCodeToLabel[binding.scanCode];\n    };\n    MacLinuxKeyboardMapper.prototype.getDispatchStrForScanCodeBinding = function (keypress) {\n        var codeDispatch = this._scanCodeToDispatch[keypress.scanCode];\n        if (!codeDispatch) {\n            return null;\n        }\n        var result = '';\n        if (keypress.ctrlKey) {\n            result += 'ctrl+';\n        }\n        if (keypress.shiftKey) {\n            result += 'shift+';\n        }\n        if (keypress.altKey) {\n            result += 'alt+';\n        }\n        if (keypress.metaKey) {\n            result += 'meta+';\n        }\n        result += codeDispatch;\n        return result;\n    };\n    MacLinuxKeyboardMapper.prototype.getUserSettingsLabelForScanCodeBinding = function (binding) {\n        if (!binding) {\n            return null;\n        }\n        if (binding.isDuplicateModifierCase()) {\n            return '';\n        }\n        var immutableKeyCode = scanCode_1.IMMUTABLE_CODE_TO_KEY_CODE[binding.scanCode];\n        if (immutableKeyCode !== -1) {\n            return keyCodes_1.KeyCodeUtils.toUserSettingsUS(immutableKeyCode).toLowerCase();\n        }\n        // Check if this scanCode always maps to the same keyCode and back\n        var constantKeyCode = this._scanCodeKeyCodeMapper.guessStableKeyCode(binding.scanCode);\n        if (constantKeyCode !== -1) {\n            // Verify that this is a good key code that can be mapped back to the same scan code\n            var reverseBindings = this.simpleKeybindingToScanCodeBinding(new keyCodes_1.SimpleKeybinding(binding.ctrlKey, binding.shiftKey, binding.altKey, binding.metaKey, constantKeyCode));\n            for (var i = 0, len = reverseBindings.length; i < len; i++) {\n                var reverseBinding = reverseBindings[i];\n                if (reverseBinding.scanCode === binding.scanCode) {\n                    return keyCodes_1.KeyCodeUtils.toUserSettingsUS(constantKeyCode).toLowerCase();\n                }\n            }\n        }\n        return this._scanCodeToDispatch[binding.scanCode];\n    };\n    MacLinuxKeyboardMapper.prototype._getElectronLabelForKeyCode = function (keyCode) {\n        if (keyCode >= keyCodes_1.KeyCode.NUMPAD_0 && keyCode <= keyCodes_1.KeyCode.NUMPAD_DIVIDE) {\n            // Electron cannot handle numpad keys\n            return null;\n        }\n        switch (keyCode) {\n            case keyCodes_1.KeyCode.UpArrow:\n                return 'Up';\n            case keyCodes_1.KeyCode.DownArrow:\n                return 'Down';\n            case keyCodes_1.KeyCode.LeftArrow:\n                return 'Left';\n            case keyCodes_1.KeyCode.RightArrow:\n                return 'Right';\n        }\n        // electron menus always do the correct rendering on Windows\n        return keyCodes_1.KeyCodeUtils.toString(keyCode);\n    };\n    MacLinuxKeyboardMapper.prototype.getElectronAcceleratorLabelForScanCodeBinding = function (binding) {\n        if (!binding) {\n            return null;\n        }\n        if (binding.isDuplicateModifierCase()) {\n            return null;\n        }\n        var immutableKeyCode = scanCode_1.IMMUTABLE_CODE_TO_KEY_CODE[binding.scanCode];\n        if (immutableKeyCode !== -1) {\n            return this._getElectronLabelForKeyCode(immutableKeyCode);\n        }\n        // Check if this scanCode always maps to the same keyCode and back\n        var constantKeyCode = this._scanCodeKeyCodeMapper.guessStableKeyCode(binding.scanCode);\n        if (!this._isUSStandard) {\n            // Electron cannot handle these key codes on anything else than standard US\n            var isOEMKey = (constantKeyCode === keyCodes_1.KeyCode.US_SEMICOLON\n                || constantKeyCode === keyCodes_1.KeyCode.US_EQUAL\n                || constantKeyCode === keyCodes_1.KeyCode.US_COMMA\n                || constantKeyCode === keyCodes_1.KeyCode.US_MINUS\n                || constantKeyCode === keyCodes_1.KeyCode.US_DOT\n                || constantKeyCode === keyCodes_1.KeyCode.US_SLASH\n                || constantKeyCode === keyCodes_1.KeyCode.US_BACKTICK\n                || constantKeyCode === keyCodes_1.KeyCode.US_OPEN_SQUARE_BRACKET\n                || constantKeyCode === keyCodes_1.KeyCode.US_BACKSLASH\n                || constantKeyCode === keyCodes_1.KeyCode.US_CLOSE_SQUARE_BRACKET);\n            if (isOEMKey) {\n                return null;\n            }\n        }\n        if (constantKeyCode !== -1) {\n            return this._getElectronLabelForKeyCode(constantKeyCode);\n        }\n        return null;\n    };\n    MacLinuxKeyboardMapper.prototype.resolveKeybinding = function (keybinding) {\n        var chordParts = [];\n        for (var _i = 0, _a = keybinding.parts; _i < _a.length; _i++) {\n            var part = _a[_i];\n            chordParts.push(this.simpleKeybindingToScanCodeBinding(part));\n        }\n        return this._toResolvedKeybinding(chordParts);\n    };\n    MacLinuxKeyboardMapper.prototype._toResolvedKeybinding = function (chordParts) {\n        if (chordParts.length === 0) {\n            return [];\n        }\n        var result = [];\n        this._generateResolvedKeybindings(chordParts, 0, [], result);\n        return result;\n    };\n    MacLinuxKeyboardMapper.prototype._generateResolvedKeybindings = function (chordParts, currentIndex, previousParts, result) {\n        var chordPart = chordParts[currentIndex];\n        var isFinalIndex = currentIndex === chordParts.length - 1;\n        for (var i = 0, len = chordPart.length; i < len; i++) {\n            var chords = previousParts.concat([chordPart[i]]);\n            if (isFinalIndex) {\n                result.push(new NativeResolvedKeybinding(this, this._OS, chords));\n            }\n            else {\n                this._generateResolvedKeybindings(chordParts, currentIndex + 1, chords, result);\n            }\n        }\n    };\n    MacLinuxKeyboardMapper.prototype.resolveKeyboardEvent = function (keyboardEvent) {\n        var code = scanCode_1.ScanCodeUtils.toEnum(keyboardEvent.code);\n        // Treat NumpadEnter as Enter\n        if (code === scanCode_1.ScanCode.NumpadEnter) {\n            code = scanCode_1.ScanCode.Enter;\n        }\n        var keyCode = keyboardEvent.keyCode;\n        if ((keyCode === keyCodes_1.KeyCode.LeftArrow)\n            || (keyCode === keyCodes_1.KeyCode.UpArrow)\n            || (keyCode === keyCodes_1.KeyCode.RightArrow)\n            || (keyCode === keyCodes_1.KeyCode.DownArrow)\n            || (keyCode === keyCodes_1.KeyCode.Delete)\n            || (keyCode === keyCodes_1.KeyCode.Insert)\n            || (keyCode === keyCodes_1.KeyCode.Home)\n            || (keyCode === keyCodes_1.KeyCode.End)\n            || (keyCode === keyCodes_1.KeyCode.PageDown)\n            || (keyCode === keyCodes_1.KeyCode.PageUp)) {\n            // \"Dispatch\" on keyCode for these key codes to workaround issues with remote desktoping software\n            // where the scan codes appear to be incorrect (see https://github.com/Microsoft/vscode/issues/24107)\n            var immutableScanCode = scanCode_1.IMMUTABLE_KEY_CODE_TO_CODE[keyCode];\n            if (immutableScanCode !== -1) {\n                code = immutableScanCode;\n            }\n        }\n        else {\n            if ((code === scanCode_1.ScanCode.Numpad1)\n                || (code === scanCode_1.ScanCode.Numpad2)\n                || (code === scanCode_1.ScanCode.Numpad3)\n                || (code === scanCode_1.ScanCode.Numpad4)\n                || (code === scanCode_1.ScanCode.Numpad5)\n                || (code === scanCode_1.ScanCode.Numpad6)\n                || (code === scanCode_1.ScanCode.Numpad7)\n                || (code === scanCode_1.ScanCode.Numpad8)\n                || (code === scanCode_1.ScanCode.Numpad9)\n                || (code === scanCode_1.ScanCode.Numpad0)\n                || (code === scanCode_1.ScanCode.NumpadDecimal)) {\n                // \"Dispatch\" on keyCode for all numpad keys in order for NumLock to work correctly\n                if (keyCode >= 0) {\n                    var immutableScanCode = scanCode_1.IMMUTABLE_KEY_CODE_TO_CODE[keyCode];\n                    if (immutableScanCode !== -1) {\n                        code = immutableScanCode;\n                    }\n                }\n            }\n        }\n        var keypress = new scanCode_1.ScanCodeBinding(keyboardEvent.ctrlKey, keyboardEvent.shiftKey, keyboardEvent.altKey, keyboardEvent.metaKey, code);\n        return new NativeResolvedKeybinding(this, this._OS, [keypress]);\n    };\n    MacLinuxKeyboardMapper.prototype._resolveSimpleUserBinding = function (binding) {\n        if (!binding) {\n            return [];\n        }\n        if (binding instanceof scanCode_1.ScanCodeBinding) {\n            return [binding];\n        }\n        return this.simpleKeybindingToScanCodeBinding(binding);\n    };\n    MacLinuxKeyboardMapper.prototype.resolveUserBinding = function (input) {\n        var _this = this;\n        var parts = input.map(function (keybinding) { return _this._resolveSimpleUserBinding(keybinding); });\n        return this._toResolvedKeybinding(parts);\n    };\n    MacLinuxKeyboardMapper._charCodeToKb = function (charCode) {\n        if (charCode < CHAR_CODE_TO_KEY_CODE.length) {\n            return CHAR_CODE_TO_KEY_CODE[charCode];\n        }\n        return null;\n    };\n    /**\n     * Attempt to map a combining character to a regular one that renders the same way.\n     *\n     * To the brave person following me: Good Luck!\n     * https://www.compart.com/en/unicode/bidiclass/NSM\n     */\n    MacLinuxKeyboardMapper.getCharCode = function (char) {\n        if (char.length === 0) {\n            return 0;\n        }\n        var charCode = char.charCodeAt(0);\n        switch (charCode) {\n            case charCode_1.CharCode.U_Combining_Grave_Accent: return charCode_1.CharCode.U_GRAVE_ACCENT;\n            case charCode_1.CharCode.U_Combining_Acute_Accent: return charCode_1.CharCode.U_ACUTE_ACCENT;\n            case charCode_1.CharCode.U_Combining_Circumflex_Accent: return charCode_1.CharCode.U_CIRCUMFLEX;\n            case charCode_1.CharCode.U_Combining_Tilde: return charCode_1.CharCode.U_SMALL_TILDE;\n            case charCode_1.CharCode.U_Combining_Macron: return charCode_1.CharCode.U_MACRON;\n            case charCode_1.CharCode.U_Combining_Overline: return charCode_1.CharCode.U_OVERLINE;\n            case charCode_1.CharCode.U_Combining_Breve: return charCode_1.CharCode.U_BREVE;\n            case charCode_1.CharCode.U_Combining_Dot_Above: return charCode_1.CharCode.U_DOT_ABOVE;\n            case charCode_1.CharCode.U_Combining_Diaeresis: return charCode_1.CharCode.U_DIAERESIS;\n            case charCode_1.CharCode.U_Combining_Ring_Above: return charCode_1.CharCode.U_RING_ABOVE;\n            case charCode_1.CharCode.U_Combining_Double_Acute_Accent: return charCode_1.CharCode.U_DOUBLE_ACUTE_ACCENT;\n        }\n        return charCode;\n    };\n    return MacLinuxKeyboardMapper;\n}());\nexports.MacLinuxKeyboardMapper = MacLinuxKeyboardMapper;\n(function () {\n    function define(charCode, keyCode, shiftKey) {\n        for (var i = CHAR_CODE_TO_KEY_CODE.length; i < charCode; i++) {\n            CHAR_CODE_TO_KEY_CODE[i] = null;\n        }\n        CHAR_CODE_TO_KEY_CODE[charCode] = { keyCode: keyCode, shiftKey: shiftKey };\n    }\n    for (var chCode = charCode_1.CharCode.A; chCode <= charCode_1.CharCode.Z; chCode++) {\n        define(chCode, keyCodes_1.KeyCode.KEY_A + (chCode - charCode_1.CharCode.A), true);\n    }\n    for (var chCode = charCode_1.CharCode.a; chCode <= charCode_1.CharCode.z; chCode++) {\n        define(chCode, keyCodes_1.KeyCode.KEY_A + (chCode - charCode_1.CharCode.a), false);\n    }\n    define(charCode_1.CharCode.Semicolon, keyCodes_1.KeyCode.US_SEMICOLON, false);\n    define(charCode_1.CharCode.Colon, keyCodes_1.KeyCode.US_SEMICOLON, true);\n    define(charCode_1.CharCode.Equals, keyCodes_1.KeyCode.US_EQUAL, false);\n    define(charCode_1.CharCode.Plus, keyCodes_1.KeyCode.US_EQUAL, true);\n    define(charCode_1.CharCode.Comma, keyCodes_1.KeyCode.US_COMMA, false);\n    define(charCode_1.CharCode.LessThan, keyCodes_1.KeyCode.US_COMMA, true);\n    define(charCode_1.CharCode.Dash, keyCodes_1.KeyCode.US_MINUS, false);\n    define(charCode_1.CharCode.Underline, keyCodes_1.KeyCode.US_MINUS, true);\n    define(charCode_1.CharCode.Period, keyCodes_1.KeyCode.US_DOT, false);\n    define(charCode_1.CharCode.GreaterThan, keyCodes_1.KeyCode.US_DOT, true);\n    define(charCode_1.CharCode.Slash, keyCodes_1.KeyCode.US_SLASH, false);\n    define(charCode_1.CharCode.QuestionMark, keyCodes_1.KeyCode.US_SLASH, true);\n    define(charCode_1.CharCode.BackTick, keyCodes_1.KeyCode.US_BACKTICK, false);\n    define(charCode_1.CharCode.Tilde, keyCodes_1.KeyCode.US_BACKTICK, true);\n    define(charCode_1.CharCode.OpenSquareBracket, keyCodes_1.KeyCode.US_OPEN_SQUARE_BRACKET, false);\n    define(charCode_1.CharCode.OpenCurlyBrace, keyCodes_1.KeyCode.US_OPEN_SQUARE_BRACKET, true);\n    define(charCode_1.CharCode.Backslash, keyCodes_1.KeyCode.US_BACKSLASH, false);\n    define(charCode_1.CharCode.Pipe, keyCodes_1.KeyCode.US_BACKSLASH, true);\n    define(charCode_1.CharCode.CloseSquareBracket, keyCodes_1.KeyCode.US_CLOSE_SQUARE_BRACKET, false);\n    define(charCode_1.CharCode.CloseCurlyBrace, keyCodes_1.KeyCode.US_CLOSE_SQUARE_BRACKET, true);\n    define(charCode_1.CharCode.SingleQuote, keyCodes_1.KeyCode.US_QUOTE, false);\n    define(charCode_1.CharCode.DoubleQuote, keyCodes_1.KeyCode.US_QUOTE, true);\n})();\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/keybinding/common/macLinuxKeyboardMapper.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/keybinding/common/macLinuxKeyboardMapper.ts"],"names":[],"mappings":"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,CAAC,CAAC;YAC9D,wBAAwB,CAAC,mBAAQ,CAAC,CAAC,EAAE,mBAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;YAC9D,wBAAwB,CAAC,mBAAQ,CAAC,CAAC,EAAE,mBAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;YAC9D,wBAAwB,CAAC,mBAAQ,CAAC,CAAC,EAAE,mBAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;YAC9D,wBAAwB,CAAC,mBAAQ,CAAC,CAAC,EAAE,mBAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;YAC9D,wBAAwB,CAAC,mBAAQ,CAAC,CAAC,EAAE,mBAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;YAC9D,wBAAwB,CAAC,mBAAQ,CAAC,CAAC,EAAE,mBAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;YAC9D,wBAAwB,CAAC,mBAAQ,CAAC,CAAC,EAAE,mBAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;YAC9D,wBAAwB,CAAC,mBAAQ,CAAC,CAAC,EAAE,mBAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;YAC9D,wBAAwB,CAAC,mBAAQ,CAAC,CAAC,EAAE,mBAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;YAC9D,wBAAwB,CAAC,mBAAQ,CAAC,CAAC,EAAE,mBAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;YAC9D,wBAAwB,CAAC,mBAAQ,CAAC,CAAC,EAAE,mBAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;YAC9D,wBAAwB,CAAC,mBAAQ,CAAC,CAAC,EAAE,mBAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;YAC9D,wBAAwB,CAAC,mBAAQ,CAAC,CAAC,EAAE,mBAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;YAC9D,wBAAwB,CAAC,mBAAQ,CAAC,CAAC,EAAE,mBAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { KeyCode, KeyCodeUtils, Keybinding, ResolvedKeybinding, SimpleKeybinding } from 'vs/base/common/keyCodes';\nimport { OperatingSystem } from 'vs/base/common/platform';\nimport { IMMUTABLE_CODE_TO_KEY_CODE, IMMUTABLE_KEY_CODE_TO_CODE, ScanCode, ScanCodeBinding, ScanCodeUtils } from 'vs/base/common/scanCode';\nimport { IKeyboardEvent } from 'vs/platform/keybinding/common/keybinding';\nimport { IKeyboardMapper } from 'vs/workbench/services/keybinding/common/keyboardMapper';\nimport { BaseResolvedKeybinding } from 'vs/platform/keybinding/common/baseResolvedKeybinding';\n\nexport interface IMacLinuxKeyMapping {\n\tvalue: string;\n\twithShift: string;\n\twithAltGr: string;\n\twithShiftAltGr: string;\n}\n\nfunction macLinuxKeyMappingEquals(a: IMacLinuxKeyMapping, b: IMacLinuxKeyMapping): boolean {\n\tif (!a && !b) {\n\t\treturn true;\n\t}\n\tif (!a || !b) {\n\t\treturn false;\n\t}\n\treturn (\n\t\ta.value === b.value\n\t\t&& a.withShift === b.withShift\n\t\t&& a.withAltGr === b.withAltGr\n\t\t&& a.withShiftAltGr === b.withShiftAltGr\n\t);\n}\n\nexport interface IMacLinuxKeyboardMapping {\n\t[scanCode: string]: IMacLinuxKeyMapping;\n}\n\nexport function macLinuxKeyboardMappingEquals(a: IMacLinuxKeyboardMapping | null, b: IMacLinuxKeyboardMapping | null): boolean {\n\tif (!a && !b) {\n\t\treturn true;\n\t}\n\tif (!a || !b) {\n\t\treturn false;\n\t}\n\tfor (let scanCode = 0; scanCode < ScanCode.MAX_VALUE; scanCode++) {\n\t\tconst strScanCode = ScanCodeUtils.toString(scanCode);\n\t\tconst aEntry = a[strScanCode];\n\t\tconst bEntry = b[strScanCode];\n\t\tif (!macLinuxKeyMappingEquals(aEntry, bEntry)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * A map from character to key codes.\n * e.g. Contains entries such as:\n *  - '/' => { keyCode: KeyCode.US_SLASH, shiftKey: false }\n *  - '?' => { keyCode: KeyCode.US_SLASH, shiftKey: true }\n */\nconst CHAR_CODE_TO_KEY_CODE: ({ keyCode: KeyCode; shiftKey: boolean } | null)[] = [];\n\nexport class NativeResolvedKeybinding extends BaseResolvedKeybinding<ScanCodeBinding> {\n\n\tprivate readonly _mapper: MacLinuxKeyboardMapper;\n\n\tconstructor(mapper: MacLinuxKeyboardMapper, os: OperatingSystem, parts: ScanCodeBinding[]) {\n\t\tsuper(os, parts);\n\t\tthis._mapper = mapper;\n\t}\n\n\tprotected _getLabel(keybinding: ScanCodeBinding): string | null {\n\t\treturn this._mapper.getUILabelForScanCodeBinding(keybinding);\n\t}\n\n\tprotected _getAriaLabel(keybinding: ScanCodeBinding): string | null {\n\t\treturn this._mapper.getAriaLabelForScanCodeBinding(keybinding);\n\t}\n\n\tprotected _getElectronAccelerator(keybinding: ScanCodeBinding): string | null {\n\t\treturn this._mapper.getElectronAcceleratorLabelForScanCodeBinding(keybinding);\n\t}\n\n\tprotected _getUserSettingsLabel(keybinding: ScanCodeBinding): string | null {\n\t\treturn this._mapper.getUserSettingsLabelForScanCodeBinding(keybinding);\n\t}\n\n\tprotected _isWYSIWYG(binding: ScanCodeBinding | null): boolean {\n\t\tif (!binding) {\n\t\t\treturn true;\n\t\t}\n\t\tif (IMMUTABLE_CODE_TO_KEY_CODE[binding.scanCode] !== -1) {\n\t\t\treturn true;\n\t\t}\n\t\tlet a = this._mapper.getAriaLabelForScanCodeBinding(binding);\n\t\tlet b = this._mapper.getUserSettingsLabelForScanCodeBinding(binding);\n\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!a || !b) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (a.toLowerCase() === b.toLowerCase());\n\t}\n\n\tprotected _getDispatchPart(keybinding: ScanCodeBinding): string | null {\n\t\treturn this._mapper.getDispatchStrForScanCodeBinding(keybinding);\n\t}\n}\n\ninterface IScanCodeMapping {\n\tscanCode: ScanCode;\n\tvalue: number;\n\twithShift: number;\n\twithAltGr: number;\n\twithShiftAltGr: number;\n}\n\nclass ScanCodeCombo {\n\tpublic readonly ctrlKey: boolean;\n\tpublic readonly shiftKey: boolean;\n\tpublic readonly altKey: boolean;\n\tpublic readonly scanCode: ScanCode;\n\n\tconstructor(ctrlKey: boolean, shiftKey: boolean, altKey: boolean, scanCode: ScanCode) {\n\t\tthis.ctrlKey = ctrlKey;\n\t\tthis.shiftKey = shiftKey;\n\t\tthis.altKey = altKey;\n\t\tthis.scanCode = scanCode;\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.ctrlKey ? 'Ctrl+' : ''}${this.shiftKey ? 'Shift+' : ''}${this.altKey ? 'Alt+' : ''}${ScanCodeUtils.toString(this.scanCode)}`;\n\t}\n\n\tpublic equals(other: ScanCodeCombo): boolean {\n\t\treturn (\n\t\t\tthis.ctrlKey === other.ctrlKey\n\t\t\t&& this.shiftKey === other.shiftKey\n\t\t\t&& this.altKey === other.altKey\n\t\t\t&& this.scanCode === other.scanCode\n\t\t);\n\t}\n\n\tprivate getProducedCharCode(mapping: IMacLinuxKeyMapping): string {\n\t\tif (!mapping) {\n\t\t\treturn '';\n\t\t}\n\t\tif (this.ctrlKey && this.shiftKey && this.altKey) {\n\t\t\treturn mapping.withShiftAltGr;\n\t\t}\n\t\tif (this.ctrlKey && this.altKey) {\n\t\t\treturn mapping.withAltGr;\n\t\t}\n\t\tif (this.shiftKey) {\n\t\t\treturn mapping.withShift;\n\t\t}\n\t\treturn mapping.value;\n\t}\n\n\tpublic getProducedChar(mapping: IMacLinuxKeyMapping): string {\n\t\tconst charCode = MacLinuxKeyboardMapper.getCharCode(this.getProducedCharCode(mapping));\n\t\tif (charCode === 0) {\n\t\t\treturn ' --- ';\n\t\t}\n\t\tif (charCode >= CharCode.U_Combining_Grave_Accent && charCode <= CharCode.U_Combining_Latin_Small_Letter_X) {\n\t\t\t// combining\n\t\t\treturn 'U+' + charCode.toString(16);\n\t\t}\n\t\treturn '  ' + String.fromCharCode(charCode) + '  ';\n\t}\n}\n\nclass KeyCodeCombo {\n\tpublic readonly ctrlKey: boolean;\n\tpublic readonly shiftKey: boolean;\n\tpublic readonly altKey: boolean;\n\tpublic readonly keyCode: KeyCode;\n\n\tconstructor(ctrlKey: boolean, shiftKey: boolean, altKey: boolean, keyCode: KeyCode) {\n\t\tthis.ctrlKey = ctrlKey;\n\t\tthis.shiftKey = shiftKey;\n\t\tthis.altKey = altKey;\n\t\tthis.keyCode = keyCode;\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.ctrlKey ? 'Ctrl+' : ''}${this.shiftKey ? 'Shift+' : ''}${this.altKey ? 'Alt+' : ''}${KeyCodeUtils.toString(this.keyCode)}`;\n\t}\n}\n\nclass ScanCodeKeyCodeMapper {\n\n\t/**\n\t * ScanCode combination => KeyCode combination.\n\t * Only covers relevant modifiers ctrl, shift, alt (since meta does not influence the mappings).\n\t */\n\tprivate readonly _scanCodeToKeyCode: number[][] = [];\n\t/**\n\t * inverse of `_scanCodeToKeyCode`.\n\t * KeyCode combination => ScanCode combination.\n\t * Only covers relevant modifiers ctrl, shift, alt (since meta does not influence the mappings).\n\t */\n\tprivate readonly _keyCodeToScanCode: number[][] = [];\n\n\tconstructor() {\n\t\tthis._scanCodeToKeyCode = [];\n\t\tthis._keyCodeToScanCode = [];\n\t}\n\n\tpublic registrationComplete(): void {\n\t\t// IntlHash and IntlBackslash are rare keys, so ensure they don't end up being the preferred...\n\t\tthis._moveToEnd(ScanCode.IntlHash);\n\t\tthis._moveToEnd(ScanCode.IntlBackslash);\n\t}\n\n\tprivate _moveToEnd(scanCode: ScanCode): void {\n\t\tfor (let mod = 0; mod < 8; mod++) {\n\t\t\tconst encodedKeyCodeCombos = this._scanCodeToKeyCode[(scanCode << 3) + mod];\n\t\t\tif (!encodedKeyCodeCombos) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (let i = 0, len = encodedKeyCodeCombos.length; i < len; i++) {\n\t\t\t\tconst encodedScanCodeCombos = this._keyCodeToScanCode[encodedKeyCodeCombos[i]];\n\t\t\t\tif (encodedScanCodeCombos.length === 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (let j = 0, len = encodedScanCodeCombos.length; j < len; j++) {\n\t\t\t\t\tconst entry = encodedScanCodeCombos[j];\n\t\t\t\t\tconst entryScanCode = (entry >>> 3);\n\t\t\t\t\tif (entryScanCode === scanCode) {\n\t\t\t\t\t\t// Move this entry to the end\n\t\t\t\t\t\tfor (let k = j + 1; k < len; k++) {\n\t\t\t\t\t\t\tencodedScanCodeCombos[k - 1] = encodedScanCodeCombos[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencodedScanCodeCombos[len - 1] = entry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic registerIfUnknown(scanCodeCombo: ScanCodeCombo, keyCodeCombo: KeyCodeCombo): void {\n\t\tif (keyCodeCombo.keyCode === KeyCode.Unknown) {\n\t\t\treturn;\n\t\t}\n\t\tconst scanCodeComboEncoded = this._encodeScanCodeCombo(scanCodeCombo);\n\t\tconst keyCodeComboEncoded = this._encodeKeyCodeCombo(keyCodeCombo);\n\n\t\tconst keyCodeIsDigit = (keyCodeCombo.keyCode >= KeyCode.KEY_0 && keyCodeCombo.keyCode <= KeyCode.KEY_9);\n\t\tconst keyCodeIsLetter = (keyCodeCombo.keyCode >= KeyCode.KEY_A && keyCodeCombo.keyCode <= KeyCode.KEY_Z);\n\n\t\tconst existingKeyCodeCombos = this._scanCodeToKeyCode[scanCodeComboEncoded];\n\n\t\t// Allow a scan code to map to multiple key codes if it is a digit or a letter key code\n\t\tif (keyCodeIsDigit || keyCodeIsLetter) {\n\t\t\t// Only check that we don't insert the same entry twice\n\t\t\tif (existingKeyCodeCombos) {\n\t\t\t\tfor (let i = 0, len = existingKeyCodeCombos.length; i < len; i++) {\n\t\t\t\t\tif (existingKeyCodeCombos[i] === keyCodeComboEncoded) {\n\t\t\t\t\t\t// avoid duplicates\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Don't allow multiples\n\t\t\tif (existingKeyCodeCombos && existingKeyCodeCombos.length !== 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis._scanCodeToKeyCode[scanCodeComboEncoded] = this._scanCodeToKeyCode[scanCodeComboEncoded] || [];\n\t\tthis._scanCodeToKeyCode[scanCodeComboEncoded].unshift(keyCodeComboEncoded);\n\n\t\tthis._keyCodeToScanCode[keyCodeComboEncoded] = this._keyCodeToScanCode[keyCodeComboEncoded] || [];\n\t\tthis._keyCodeToScanCode[keyCodeComboEncoded].unshift(scanCodeComboEncoded);\n\t}\n\n\tpublic lookupKeyCodeCombo(keyCodeCombo: KeyCodeCombo): ScanCodeCombo[] {\n\t\tconst keyCodeComboEncoded = this._encodeKeyCodeCombo(keyCodeCombo);\n\t\tconst scanCodeCombosEncoded = this._keyCodeToScanCode[keyCodeComboEncoded];\n\t\tif (!scanCodeCombosEncoded || scanCodeCombosEncoded.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet result: ScanCodeCombo[] = [];\n\t\tfor (let i = 0, len = scanCodeCombosEncoded.length; i < len; i++) {\n\t\t\tconst scanCodeComboEncoded = scanCodeCombosEncoded[i];\n\n\t\t\tconst ctrlKey = (scanCodeComboEncoded & 0b001) ? true : false;\n\t\t\tconst shiftKey = (scanCodeComboEncoded & 0b010) ? true : false;\n\t\t\tconst altKey = (scanCodeComboEncoded & 0b100) ? true : false;\n\t\t\tconst scanCode: ScanCode = (scanCodeComboEncoded >>> 3);\n\n\t\t\tresult[i] = new ScanCodeCombo(ctrlKey, shiftKey, altKey, scanCode);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic lookupScanCodeCombo(scanCodeCombo: ScanCodeCombo): KeyCodeCombo[] {\n\t\tconst scanCodeComboEncoded = this._encodeScanCodeCombo(scanCodeCombo);\n\t\tconst keyCodeCombosEncoded = this._scanCodeToKeyCode[scanCodeComboEncoded];\n\t\tif (!keyCodeCombosEncoded || keyCodeCombosEncoded.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet result: KeyCodeCombo[] = [];\n\t\tfor (let i = 0, len = keyCodeCombosEncoded.length; i < len; i++) {\n\t\t\tconst keyCodeComboEncoded = keyCodeCombosEncoded[i];\n\n\t\t\tconst ctrlKey = (keyCodeComboEncoded & 0b001) ? true : false;\n\t\t\tconst shiftKey = (keyCodeComboEncoded & 0b010) ? true : false;\n\t\t\tconst altKey = (keyCodeComboEncoded & 0b100) ? true : false;\n\t\t\tconst keyCode: KeyCode = (keyCodeComboEncoded >>> 3);\n\n\t\t\tresult[i] = new KeyCodeCombo(ctrlKey, shiftKey, altKey, keyCode);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic guessStableKeyCode(scanCode: ScanCode): KeyCode {\n\t\tif (scanCode >= ScanCode.Digit1 && scanCode <= ScanCode.Digit0) {\n\t\t\t// digits are ok\n\t\t\tswitch (scanCode) {\n\t\t\t\tcase ScanCode.Digit1: return KeyCode.KEY_1;\n\t\t\t\tcase ScanCode.Digit2: return KeyCode.KEY_2;\n\t\t\t\tcase ScanCode.Digit3: return KeyCode.KEY_3;\n\t\t\t\tcase ScanCode.Digit4: return KeyCode.KEY_4;\n\t\t\t\tcase ScanCode.Digit5: return KeyCode.KEY_5;\n\t\t\t\tcase ScanCode.Digit6: return KeyCode.KEY_6;\n\t\t\t\tcase ScanCode.Digit7: return KeyCode.KEY_7;\n\t\t\t\tcase ScanCode.Digit8: return KeyCode.KEY_8;\n\t\t\t\tcase ScanCode.Digit9: return KeyCode.KEY_9;\n\t\t\t\tcase ScanCode.Digit0: return KeyCode.KEY_0;\n\t\t\t}\n\t\t}\n\n\t\t// Lookup the scanCode with and without shift and see if the keyCode is stable\n\t\tconst keyCodeCombos1 = this.lookupScanCodeCombo(new ScanCodeCombo(false, false, false, scanCode));\n\t\tconst keyCodeCombos2 = this.lookupScanCodeCombo(new ScanCodeCombo(false, true, false, scanCode));\n\t\tif (keyCodeCombos1.length === 1 && keyCodeCombos2.length === 1) {\n\t\t\tconst shiftKey1 = keyCodeCombos1[0].shiftKey;\n\t\t\tconst keyCode1 = keyCodeCombos1[0].keyCode;\n\t\t\tconst shiftKey2 = keyCodeCombos2[0].shiftKey;\n\t\t\tconst keyCode2 = keyCodeCombos2[0].keyCode;\n\t\t\tif (keyCode1 === keyCode2 && shiftKey1 !== shiftKey2) {\n\t\t\t\t// This looks like a stable mapping\n\t\t\t\treturn keyCode1;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tprivate _encodeScanCodeCombo(scanCodeCombo: ScanCodeCombo): number {\n\t\treturn this._encode(scanCodeCombo.ctrlKey, scanCodeCombo.shiftKey, scanCodeCombo.altKey, scanCodeCombo.scanCode);\n\t}\n\n\tprivate _encodeKeyCodeCombo(keyCodeCombo: KeyCodeCombo): number {\n\t\treturn this._encode(keyCodeCombo.ctrlKey, keyCodeCombo.shiftKey, keyCodeCombo.altKey, keyCodeCombo.keyCode);\n\t}\n\n\tprivate _encode(ctrlKey: boolean, shiftKey: boolean, altKey: boolean, principal: number): number {\n\t\treturn (\n\t\t\t((ctrlKey ? 1 : 0) << 0)\n\t\t\t| ((shiftKey ? 1 : 0) << 1)\n\t\t\t| ((altKey ? 1 : 0) << 2)\n\t\t\t| principal << 3\n\t\t) >>> 0;\n\t}\n}\n\nexport class MacLinuxKeyboardMapper implements IKeyboardMapper {\n\n\t/**\n\t * Is this the standard US keyboard layout?\n\t */\n\tprivate readonly _isUSStandard: boolean;\n\t/**\n\t * OS (can be Linux or Macintosh)\n\t */\n\tprivate readonly _OS: OperatingSystem;\n\t/**\n\t * used only for debug purposes.\n\t */\n\tprivate readonly _codeInfo: IMacLinuxKeyMapping[];\n\t/**\n\t * Maps ScanCode combos <-> KeyCode combos.\n\t */\n\tprivate readonly _scanCodeKeyCodeMapper: ScanCodeKeyCodeMapper;\n\t/**\n\t * UI label for a ScanCode.\n\t */\n\tprivate readonly _scanCodeToLabel: Array<string | null> = [];\n\t/**\n\t * Dispatching string for a ScanCode.\n\t */\n\tprivate readonly _scanCodeToDispatch: Array<string | null> = [];\n\n\tconstructor(isUSStandard: boolean, rawMappings: IMacLinuxKeyboardMapping, OS: OperatingSystem) {\n\t\tthis._isUSStandard = isUSStandard;\n\t\tthis._OS = OS;\n\t\tthis._codeInfo = [];\n\t\tthis._scanCodeKeyCodeMapper = new ScanCodeKeyCodeMapper();\n\t\tthis._scanCodeToLabel = [];\n\t\tthis._scanCodeToDispatch = [];\n\n\t\tconst _registerIfUnknown = (\n\t\t\thwCtrlKey: 0 | 1, hwShiftKey: 0 | 1, hwAltKey: 0 | 1, scanCode: ScanCode,\n\t\t\tkbCtrlKey: 0 | 1, kbShiftKey: 0 | 1, kbAltKey: 0 | 1, keyCode: KeyCode,\n\t\t): void => {\n\t\t\tthis._scanCodeKeyCodeMapper.registerIfUnknown(\n\t\t\t\tnew ScanCodeCombo(hwCtrlKey ? true : false, hwShiftKey ? true : false, hwAltKey ? true : false, scanCode),\n\t\t\t\tnew KeyCodeCombo(kbCtrlKey ? true : false, kbShiftKey ? true : false, kbAltKey ? true : false, keyCode)\n\t\t\t);\n\t\t};\n\n\t\tconst _registerAllCombos = (_ctrlKey: 0 | 1, _shiftKey: 0 | 1, _altKey: 0 | 1, scanCode: ScanCode, keyCode: KeyCode): void => {\n\t\t\tfor (let ctrlKey = _ctrlKey; ctrlKey <= 1; ctrlKey++) {\n\t\t\t\tfor (let shiftKey = _shiftKey; shiftKey <= 1; shiftKey++) {\n\t\t\t\t\tfor (let altKey = _altKey; altKey <= 1; altKey++) {\n\t\t\t\t\t\t_registerIfUnknown(\n\t\t\t\t\t\t\tctrlKey, shiftKey, altKey, scanCode,\n\t\t\t\t\t\t\tctrlKey, shiftKey, altKey, keyCode\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Initialize `_scanCodeToLabel`\n\t\tfor (let scanCode = ScanCode.None; scanCode < ScanCode.MAX_VALUE; scanCode++) {\n\t\t\tthis._scanCodeToLabel[scanCode] = null;\n\t\t}\n\n\t\t// Initialize `_scanCodeToDispatch`\n\t\tfor (let scanCode = ScanCode.None; scanCode < ScanCode.MAX_VALUE; scanCode++) {\n\t\t\tthis._scanCodeToDispatch[scanCode] = null;\n\t\t}\n\n\t\t// Handle immutable mappings\n\t\tfor (let scanCode = ScanCode.None; scanCode < ScanCode.MAX_VALUE; scanCode++) {\n\t\t\tconst keyCode = IMMUTABLE_CODE_TO_KEY_CODE[scanCode];\n\t\t\tif (keyCode !== -1) {\n\t\t\t\t_registerAllCombos(0, 0, 0, scanCode, keyCode);\n\t\t\t\tthis._scanCodeToLabel[scanCode] = KeyCodeUtils.toString(keyCode);\n\n\t\t\t\tif (keyCode === KeyCode.Unknown || keyCode === KeyCode.Ctrl || keyCode === KeyCode.Meta || keyCode === KeyCode.Alt || keyCode === KeyCode.Shift) {\n\t\t\t\t\tthis._scanCodeToDispatch[scanCode] = null; // cannot dispatch on this ScanCode\n\t\t\t\t} else {\n\t\t\t\t\tthis._scanCodeToDispatch[scanCode] = `[${ScanCodeUtils.toString(scanCode)}]`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Try to identify keyboard layouts where characters A-Z are missing\n\t\t// and forcefully map them to their corresponding scan codes if that is the case\n\t\tconst missingLatinLettersOverride: { [scanCode: string]: IMacLinuxKeyMapping; } = {};\n\n\t\t{\n\t\t\tlet producesLatinLetter: boolean[] = [];\n\t\t\tfor (let strScanCode in rawMappings) {\n\t\t\t\tif (rawMappings.hasOwnProperty(strScanCode)) {\n\t\t\t\t\tconst scanCode = ScanCodeUtils.toEnum(strScanCode);\n\t\t\t\t\tif (scanCode === ScanCode.None) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rawMapping = rawMappings[strScanCode];\n\t\t\t\t\tconst value = MacLinuxKeyboardMapper.getCharCode(rawMapping.value);\n\n\t\t\t\t\tif (value >= CharCode.a && value <= CharCode.z) {\n\t\t\t\t\t\tconst upperCaseValue = CharCode.A + (value - CharCode.a);\n\t\t\t\t\t\tproducesLatinLetter[upperCaseValue] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst _registerLetterIfMissing = (charCode: CharCode, scanCode: ScanCode, value: string, withShift: string): void => {\n\t\t\t\tif (!producesLatinLetter[charCode]) {\n\t\t\t\t\tmissingLatinLettersOverride[ScanCodeUtils.toString(scanCode)] = {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\twithShift: withShift,\n\t\t\t\t\t\twithAltGr: '',\n\t\t\t\t\t\twithShiftAltGr: ''\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Ensure letters are mapped\n\t\t\t_registerLetterIfMissing(CharCode.A, ScanCode.KeyA, 'a', 'A');\n\t\t\t_registerLetterIfMissing(CharCode.B, ScanCode.KeyB, 'b', 'B');\n\t\t\t_registerLetterIfMissing(CharCode.C, ScanCode.KeyC, 'c', 'C');\n\t\t\t_registerLetterIfMissing(CharCode.D, ScanCode.KeyD, 'd', 'D');\n\t\t\t_registerLetterIfMissing(CharCode.E, ScanCode.KeyE, 'e', 'E');\n\t\t\t_registerLetterIfMissing(CharCode.F, ScanCode.KeyF, 'f', 'F');\n\t\t\t_registerLetterIfMissing(CharCode.G, ScanCode.KeyG, 'g', 'G');\n\t\t\t_registerLetterIfMissing(CharCode.H, ScanCode.KeyH, 'h', 'H');\n\t\t\t_registerLetterIfMissing(CharCode.I, ScanCode.KeyI, 'i', 'I');\n\t\t\t_registerLetterIfMissing(CharCode.J, ScanCode.KeyJ, 'j', 'J');\n\t\t\t_registerLetterIfMissing(CharCode.K, ScanCode.KeyK, 'k', 'K');\n\t\t\t_registerLetterIfMissing(CharCode.L, ScanCode.KeyL, 'l', 'L');\n\t\t\t_registerLetterIfMissing(CharCode.M, ScanCode.KeyM, 'm', 'M');\n\t\t\t_registerLetterIfMissing(CharCode.N, ScanCode.KeyN, 'n', 'N');\n\t\t\t_registerLetterIfMissing(CharCode.O, ScanCode.KeyO, 'o', 'O');\n\t\t\t_registerLetterIfMissing(CharCode.P, ScanCode.KeyP, 'p', 'P');\n\t\t\t_registerLetterIfMissing(CharCode.Q, ScanCode.KeyQ, 'q', 'Q');\n\t\t\t_registerLetterIfMissing(CharCode.R, ScanCode.KeyR, 'r', 'R');\n\t\t\t_registerLetterIfMissing(CharCode.S, ScanCode.KeyS, 's', 'S');\n\t\t\t_registerLetterIfMissing(CharCode.T, ScanCode.KeyT, 't', 'T');\n\t\t\t_registerLetterIfMissing(CharCode.U, ScanCode.KeyU, 'u', 'U');\n\t\t\t_registerLetterIfMissing(CharCode.V, ScanCode.KeyV, 'v', 'V');\n\t\t\t_registerLetterIfMissing(CharCode.W, ScanCode.KeyW, 'w', 'W');\n\t\t\t_registerLetterIfMissing(CharCode.X, ScanCode.KeyX, 'x', 'X');\n\t\t\t_registerLetterIfMissing(CharCode.Y, ScanCode.KeyY, 'y', 'Y');\n\t\t\t_registerLetterIfMissing(CharCode.Z, ScanCode.KeyZ, 'z', 'Z');\n\t\t}\n\n\t\tlet mappings: IScanCodeMapping[] = [], mappingsLen = 0;\n\t\tfor (let strScanCode in rawMappings) {\n\t\t\tif (rawMappings.hasOwnProperty(strScanCode)) {\n\t\t\t\tconst scanCode = ScanCodeUtils.toEnum(strScanCode);\n\t\t\t\tif (scanCode === ScanCode.None) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tthis._codeInfo[scanCode] = rawMappings[strScanCode];\n\n\t\t\t\tconst rawMapping = missingLatinLettersOverride[strScanCode] || rawMappings[strScanCode];\n\t\t\t\tconst value = MacLinuxKeyboardMapper.getCharCode(rawMapping.value);\n\t\t\t\tconst withShift = MacLinuxKeyboardMapper.getCharCode(rawMapping.withShift);\n\t\t\t\tconst withAltGr = MacLinuxKeyboardMapper.getCharCode(rawMapping.withAltGr);\n\t\t\t\tconst withShiftAltGr = MacLinuxKeyboardMapper.getCharCode(rawMapping.withShiftAltGr);\n\n\t\t\t\tconst mapping: IScanCodeMapping = {\n\t\t\t\t\tscanCode: scanCode,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\twithShift: withShift,\n\t\t\t\t\twithAltGr: withAltGr,\n\t\t\t\t\twithShiftAltGr: withShiftAltGr,\n\t\t\t\t};\n\t\t\t\tmappings[mappingsLen++] = mapping;\n\n\t\t\t\tthis._scanCodeToDispatch[scanCode] = `[${ScanCodeUtils.toString(scanCode)}]`;\n\n\t\t\t\tif (value >= CharCode.a && value <= CharCode.z) {\n\t\t\t\t\tconst upperCaseValue = CharCode.A + (value - CharCode.a);\n\t\t\t\t\tthis._scanCodeToLabel[scanCode] = String.fromCharCode(upperCaseValue);\n\t\t\t\t} else if (value >= CharCode.A && value <= CharCode.Z) {\n\t\t\t\t\tthis._scanCodeToLabel[scanCode] = String.fromCharCode(value);\n\t\t\t\t} else if (value) {\n\t\t\t\t\tthis._scanCodeToLabel[scanCode] = String.fromCharCode(value);\n\t\t\t\t} else {\n\t\t\t\t\tthis._scanCodeToLabel[scanCode] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handle all `withShiftAltGr` entries\n\t\tfor (let i = mappings.length - 1; i >= 0; i--) {\n\t\t\tconst mapping = mappings[i];\n\t\t\tconst scanCode = mapping.scanCode;\n\t\t\tconst withShiftAltGr = mapping.withShiftAltGr;\n\t\t\tif (withShiftAltGr === mapping.withAltGr || withShiftAltGr === mapping.withShift || withShiftAltGr === mapping.value) {\n\t\t\t\t// handled below\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kb = MacLinuxKeyboardMapper._charCodeToKb(withShiftAltGr);\n\t\t\tif (!kb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kbShiftKey = kb.shiftKey;\n\t\t\tconst keyCode = kb.keyCode;\n\n\t\t\tif (kbShiftKey) {\n\t\t\t\t// Ctrl+Shift+Alt+ScanCode => Shift+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 1, scanCode, 0, 1, 0, keyCode); //       Ctrl+Alt+ScanCode =>          Shift+KeyCode\n\t\t\t} else {\n\t\t\t\t// Ctrl+Shift+Alt+ScanCode => KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 1, scanCode, 0, 0, 0, keyCode); //       Ctrl+Alt+ScanCode =>                KeyCode\n\t\t\t}\n\t\t}\n\t\t// Handle all `withAltGr` entries\n\t\tfor (let i = mappings.length - 1; i >= 0; i--) {\n\t\t\tconst mapping = mappings[i];\n\t\t\tconst scanCode = mapping.scanCode;\n\t\t\tconst withAltGr = mapping.withAltGr;\n\t\t\tif (withAltGr === mapping.withShift || withAltGr === mapping.value) {\n\t\t\t\t// handled below\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kb = MacLinuxKeyboardMapper._charCodeToKb(withAltGr);\n\t\t\tif (!kb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kbShiftKey = kb.shiftKey;\n\t\t\tconst keyCode = kb.keyCode;\n\n\t\t\tif (kbShiftKey) {\n\t\t\t\t// Ctrl+Alt+ScanCode => Shift+KeyCode\n\t\t\t\t_registerIfUnknown(1, 0, 1, scanCode, 0, 1, 0, keyCode); //       Ctrl+Alt+ScanCode =>          Shift+KeyCode\n\t\t\t} else {\n\t\t\t\t// Ctrl+Alt+ScanCode => KeyCode\n\t\t\t\t_registerIfUnknown(1, 0, 1, scanCode, 0, 0, 0, keyCode); //       Ctrl+Alt+ScanCode =>                KeyCode\n\t\t\t}\n\t\t}\n\t\t// Handle all `withShift` entries\n\t\tfor (let i = mappings.length - 1; i >= 0; i--) {\n\t\t\tconst mapping = mappings[i];\n\t\t\tconst scanCode = mapping.scanCode;\n\t\t\tconst withShift = mapping.withShift;\n\t\t\tif (withShift === mapping.value) {\n\t\t\t\t// handled below\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kb = MacLinuxKeyboardMapper._charCodeToKb(withShift);\n\t\t\tif (!kb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kbShiftKey = kb.shiftKey;\n\t\t\tconst keyCode = kb.keyCode;\n\n\t\t\tif (kbShiftKey) {\n\t\t\t\t// Shift+ScanCode => Shift+KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 0, scanCode, 0, 1, 0, keyCode); //          Shift+ScanCode =>          Shift+KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 1, scanCode, 0, 1, 1, keyCode); //      Shift+Alt+ScanCode =>      Shift+Alt+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 0, scanCode, 1, 1, 0, keyCode); //     Ctrl+Shift+ScanCode =>     Ctrl+Shift+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 1, scanCode, 1, 1, 1, keyCode); // Ctrl+Shift+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n\t\t\t} else {\n\t\t\t\t// Shift+ScanCode => KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 0, scanCode, 0, 0, 0, keyCode); //          Shift+ScanCode =>                KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 0, scanCode, 0, 1, 0, keyCode); //          Shift+ScanCode =>          Shift+KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 1, scanCode, 0, 0, 1, keyCode); //      Shift+Alt+ScanCode =>            Alt+KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 1, scanCode, 0, 1, 1, keyCode); //      Shift+Alt+ScanCode =>      Shift+Alt+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 0, scanCode, 1, 0, 0, keyCode); //     Ctrl+Shift+ScanCode =>           Ctrl+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 0, scanCode, 1, 1, 0, keyCode); //     Ctrl+Shift+ScanCode =>     Ctrl+Shift+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 1, scanCode, 1, 0, 1, keyCode); // Ctrl+Shift+Alt+ScanCode =>       Ctrl+Alt+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 1, scanCode, 1, 1, 1, keyCode); // Ctrl+Shift+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n\t\t\t}\n\t\t}\n\t\t// Handle all `value` entries\n\t\tfor (let i = mappings.length - 1; i >= 0; i--) {\n\t\t\tconst mapping = mappings[i];\n\t\t\tconst scanCode = mapping.scanCode;\n\t\t\tconst kb = MacLinuxKeyboardMapper._charCodeToKb(mapping.value);\n\t\t\tif (!kb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst kbShiftKey = kb.shiftKey;\n\t\t\tconst keyCode = kb.keyCode;\n\n\t\t\tif (kbShiftKey) {\n\t\t\t\t// ScanCode => Shift+KeyCode\n\t\t\t\t_registerIfUnknown(0, 0, 0, scanCode, 0, 1, 0, keyCode); //                ScanCode =>          Shift+KeyCode\n\t\t\t\t_registerIfUnknown(0, 0, 1, scanCode, 0, 1, 1, keyCode); //            Alt+ScanCode =>      Shift+Alt+KeyCode\n\t\t\t\t_registerIfUnknown(1, 0, 0, scanCode, 1, 1, 0, keyCode); //           Ctrl+ScanCode =>     Ctrl+Shift+KeyCode\n\t\t\t\t_registerIfUnknown(1, 0, 1, scanCode, 1, 1, 1, keyCode); //       Ctrl+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n\t\t\t} else {\n\t\t\t\t// ScanCode => KeyCode\n\t\t\t\t_registerIfUnknown(0, 0, 0, scanCode, 0, 0, 0, keyCode); //                ScanCode =>                KeyCode\n\t\t\t\t_registerIfUnknown(0, 0, 1, scanCode, 0, 0, 1, keyCode); //            Alt+ScanCode =>            Alt+KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 0, scanCode, 0, 1, 0, keyCode); //          Shift+ScanCode =>          Shift+KeyCode\n\t\t\t\t_registerIfUnknown(0, 1, 1, scanCode, 0, 1, 1, keyCode); //      Shift+Alt+ScanCode =>      Shift+Alt+KeyCode\n\t\t\t\t_registerIfUnknown(1, 0, 0, scanCode, 1, 0, 0, keyCode); //           Ctrl+ScanCode =>           Ctrl+KeyCode\n\t\t\t\t_registerIfUnknown(1, 0, 1, scanCode, 1, 0, 1, keyCode); //       Ctrl+Alt+ScanCode =>       Ctrl+Alt+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 0, scanCode, 1, 1, 0, keyCode); //     Ctrl+Shift+ScanCode =>     Ctrl+Shift+KeyCode\n\t\t\t\t_registerIfUnknown(1, 1, 1, scanCode, 1, 1, 1, keyCode); // Ctrl+Shift+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n\t\t\t}\n\t\t}\n\t\t// Handle all left-over available digits\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit1, KeyCode.KEY_1);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit2, KeyCode.KEY_2);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit3, KeyCode.KEY_3);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit4, KeyCode.KEY_4);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit5, KeyCode.KEY_5);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit6, KeyCode.KEY_6);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit7, KeyCode.KEY_7);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit8, KeyCode.KEY_8);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit9, KeyCode.KEY_9);\n\t\t_registerAllCombos(0, 0, 0, ScanCode.Digit0, KeyCode.KEY_0);\n\n\t\tthis._scanCodeKeyCodeMapper.registrationComplete();\n\t}\n\n\tpublic dumpDebugInfo(): string {\n\t\tlet result: string[] = [];\n\n\t\tlet immutableSamples = [\n\t\t\tScanCode.ArrowUp,\n\t\t\tScanCode.Numpad0\n\t\t];\n\n\t\tlet cnt = 0;\n\t\tresult.push(`isUSStandard: ${this._isUSStandard}`);\n\t\tresult.push(`----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------`);\n\t\tfor (let scanCode = ScanCode.None; scanCode < ScanCode.MAX_VALUE; scanCode++) {\n\t\t\tif (IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== -1) {\n\t\t\t\tif (immutableSamples.indexOf(scanCode) === -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cnt % 4 === 0) {\n\t\t\t\tresult.push(`|       HW Code combination      |  Key  |    KeyCode combination    | Pri |          UI label         |         User settings          |    Electron accelerator   |       Dispatching string       | WYSIWYG |`);\n\t\t\t\tresult.push(`----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------`);\n\t\t\t}\n\t\t\tcnt++;\n\n\t\t\tconst mapping = this._codeInfo[scanCode];\n\n\t\t\tfor (let mod = 0; mod < 8; mod++) {\n\t\t\t\tconst hwCtrlKey = (mod & 0b001) ? true : false;\n\t\t\t\tconst hwShiftKey = (mod & 0b010) ? true : false;\n\t\t\t\tconst hwAltKey = (mod & 0b100) ? true : false;\n\t\t\t\tconst scanCodeCombo = new ScanCodeCombo(hwCtrlKey, hwShiftKey, hwAltKey, scanCode);\n\t\t\t\tconst resolvedKb = this.resolveKeyboardEvent({\n\t\t\t\t\t_standardKeyboardEventBrand: true,\n\t\t\t\t\tctrlKey: scanCodeCombo.ctrlKey,\n\t\t\t\t\tshiftKey: scanCodeCombo.shiftKey,\n\t\t\t\t\taltKey: scanCodeCombo.altKey,\n\t\t\t\t\tmetaKey: false,\n\t\t\t\t\tkeyCode: -1,\n\t\t\t\t\tcode: ScanCodeUtils.toString(scanCode)\n\t\t\t\t});\n\n\t\t\t\tconst outScanCodeCombo = scanCodeCombo.toString();\n\t\t\t\tconst outKey = scanCodeCombo.getProducedChar(mapping);\n\t\t\t\tconst ariaLabel = resolvedKb.getAriaLabel();\n\t\t\t\tconst outUILabel = (ariaLabel ? ariaLabel.replace(/Control\\+/, 'Ctrl+') : null);\n\t\t\t\tconst outUserSettings = resolvedKb.getUserSettingsLabel();\n\t\t\t\tconst outElectronAccelerator = resolvedKb.getElectronAccelerator();\n\t\t\t\tconst outDispatchStr = resolvedKb.getDispatchParts()[0];\n\n\t\t\t\tconst isWYSIWYG = (resolvedKb ? resolvedKb.isWYSIWYG() : false);\n\t\t\t\tconst outWYSIWYG = (isWYSIWYG ? '       ' : '   NO  ');\n\n\t\t\t\tconst kbCombos = this._scanCodeKeyCodeMapper.lookupScanCodeCombo(scanCodeCombo);\n\t\t\t\tif (kbCombos.length === 0) {\n\t\t\t\t\tresult.push(`| ${this._leftPad(outScanCodeCombo, 30)} | ${outKey} | ${this._leftPad('', 25)} | ${this._leftPad('', 3)} | ${this._leftPad(outUILabel, 25)} | ${this._leftPad(outUserSettings, 30)} | ${this._leftPad(outElectronAccelerator, 25)} | ${this._leftPad(outDispatchStr, 30)} | ${outWYSIWYG} |`);\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = 0, len = kbCombos.length; i < len; i++) {\n\t\t\t\t\t\tconst kbCombo = kbCombos[i];\n\t\t\t\t\t\t// find out the priority of this scan code for this key code\n\t\t\t\t\t\tlet colPriority: string;\n\n\t\t\t\t\t\tconst scanCodeCombos = this._scanCodeKeyCodeMapper.lookupKeyCodeCombo(kbCombo);\n\t\t\t\t\t\tif (scanCodeCombos.length === 1) {\n\t\t\t\t\t\t\t// no need for priority, this key code combo maps to precisely this scan code combo\n\t\t\t\t\t\t\tcolPriority = '';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet priority = -1;\n\t\t\t\t\t\t\tfor (let j = 0; j < scanCodeCombos.length; j++) {\n\t\t\t\t\t\t\t\tif (scanCodeCombos[j].equals(scanCodeCombo)) {\n\t\t\t\t\t\t\t\t\tpriority = j + 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcolPriority = String(priority);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst outKeybinding = kbCombo.toString();\n\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\tresult.push(`| ${this._leftPad(outScanCodeCombo, 30)} | ${outKey} | ${this._leftPad(outKeybinding, 25)} | ${this._leftPad(colPriority, 3)} | ${this._leftPad(outUILabel, 25)} | ${this._leftPad(outUserSettings, 30)} | ${this._leftPad(outElectronAccelerator, 25)} | ${this._leftPad(outDispatchStr, 30)} | ${outWYSIWYG} |`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// secondary keybindings\n\t\t\t\t\t\t\tresult.push(`| ${this._leftPad('', 30)} |       | ${this._leftPad(outKeybinding, 25)} | ${this._leftPad(colPriority, 3)} | ${this._leftPad('', 25)} | ${this._leftPad('', 30)} | ${this._leftPad('', 25)} | ${this._leftPad('', 30)} |         |`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tresult.push(`----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------`);\n\t\t}\n\n\t\treturn result.join('\\n');\n\t}\n\n\tprivate _leftPad(str: string | null, cnt: number): string {\n\t\tif (str === null) {\n\t\t\tstr = 'null';\n\t\t}\n\t\twhile (str.length < cnt) {\n\t\t\tstr = ' ' + str;\n\t\t}\n\t\treturn str;\n\t}\n\n\tpublic simpleKeybindingToScanCodeBinding(keybinding: SimpleKeybinding): ScanCodeBinding[] {\n\t\t// Avoid double Enter bindings (both ScanCode.NumpadEnter and ScanCode.Enter point to KeyCode.Enter)\n\t\tif (keybinding.keyCode === KeyCode.Enter) {\n\t\t\treturn [new ScanCodeBinding(keybinding.ctrlKey, keybinding.shiftKey, keybinding.altKey, keybinding.metaKey, ScanCode.Enter)];\n\t\t}\n\n\t\tconst scanCodeCombos = this._scanCodeKeyCodeMapper.lookupKeyCodeCombo(\n\t\t\tnew KeyCodeCombo(keybinding.ctrlKey, keybinding.shiftKey, keybinding.altKey, keybinding.keyCode)\n\t\t);\n\n\t\tlet result: ScanCodeBinding[] = [];\n\t\tfor (let i = 0, len = scanCodeCombos.length; i < len; i++) {\n\t\t\tconst scanCodeCombo = scanCodeCombos[i];\n\t\t\tresult[i] = new ScanCodeBinding(scanCodeCombo.ctrlKey, scanCodeCombo.shiftKey, scanCodeCombo.altKey, keybinding.metaKey, scanCodeCombo.scanCode);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic getUILabelForScanCodeBinding(binding: ScanCodeBinding | null): string | null {\n\t\tif (!binding) {\n\t\t\treturn null;\n\t\t}\n\t\tif (binding.isDuplicateModifierCase()) {\n\t\t\treturn '';\n\t\t}\n\t\tif (this._OS === OperatingSystem.Macintosh) {\n\t\t\tswitch (binding.scanCode) {\n\t\t\t\tcase ScanCode.ArrowLeft:\n\t\t\t\t\treturn '←';\n\t\t\t\tcase ScanCode.ArrowUp:\n\t\t\t\t\treturn '↑';\n\t\t\t\tcase ScanCode.ArrowRight:\n\t\t\t\t\treturn '→';\n\t\t\t\tcase ScanCode.ArrowDown:\n\t\t\t\t\treturn '↓';\n\t\t\t}\n\t\t}\n\t\treturn this._scanCodeToLabel[binding.scanCode];\n\t}\n\n\tpublic getAriaLabelForScanCodeBinding(binding: ScanCodeBinding | null): string | null {\n\t\tif (!binding) {\n\t\t\treturn null;\n\t\t}\n\t\tif (binding.isDuplicateModifierCase()) {\n\t\t\treturn '';\n\t\t}\n\t\treturn this._scanCodeToLabel[binding.scanCode];\n\t}\n\n\tpublic getDispatchStrForScanCodeBinding(keypress: ScanCodeBinding): string | null {\n\t\tconst codeDispatch = this._scanCodeToDispatch[keypress.scanCode];\n\t\tif (!codeDispatch) {\n\t\t\treturn null;\n\t\t}\n\t\tlet result = '';\n\n\t\tif (keypress.ctrlKey) {\n\t\t\tresult += 'ctrl+';\n\t\t}\n\t\tif (keypress.shiftKey) {\n\t\t\tresult += 'shift+';\n\t\t}\n\t\tif (keypress.altKey) {\n\t\t\tresult += 'alt+';\n\t\t}\n\t\tif (keypress.metaKey) {\n\t\t\tresult += 'meta+';\n\t\t}\n\t\tresult += codeDispatch;\n\n\t\treturn result;\n\t}\n\n\tpublic getUserSettingsLabelForScanCodeBinding(binding: ScanCodeBinding | null): string | null {\n\t\tif (!binding) {\n\t\t\treturn null;\n\t\t}\n\t\tif (binding.isDuplicateModifierCase()) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst immutableKeyCode = IMMUTABLE_CODE_TO_KEY_CODE[binding.scanCode];\n\t\tif (immutableKeyCode !== -1) {\n\t\t\treturn KeyCodeUtils.toUserSettingsUS(immutableKeyCode).toLowerCase();\n\t\t}\n\n\t\t// Check if this scanCode always maps to the same keyCode and back\n\t\tlet constantKeyCode: KeyCode = this._scanCodeKeyCodeMapper.guessStableKeyCode(binding.scanCode);\n\t\tif (constantKeyCode !== -1) {\n\t\t\t// Verify that this is a good key code that can be mapped back to the same scan code\n\t\t\tlet reverseBindings = this.simpleKeybindingToScanCodeBinding(new SimpleKeybinding(binding.ctrlKey, binding.shiftKey, binding.altKey, binding.metaKey, constantKeyCode));\n\t\t\tfor (let i = 0, len = reverseBindings.length; i < len; i++) {\n\t\t\t\tconst reverseBinding = reverseBindings[i];\n\t\t\t\tif (reverseBinding.scanCode === binding.scanCode) {\n\t\t\t\t\treturn KeyCodeUtils.toUserSettingsUS(constantKeyCode).toLowerCase();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this._scanCodeToDispatch[binding.scanCode];\n\t}\n\n\tprivate _getElectronLabelForKeyCode(keyCode: KeyCode): string | null {\n\t\tif (keyCode >= KeyCode.NUMPAD_0 && keyCode <= KeyCode.NUMPAD_DIVIDE) {\n\t\t\t// Electron cannot handle numpad keys\n\t\t\treturn null;\n\t\t}\n\n\t\tswitch (keyCode) {\n\t\t\tcase KeyCode.UpArrow:\n\t\t\t\treturn 'Up';\n\t\t\tcase KeyCode.DownArrow:\n\t\t\t\treturn 'Down';\n\t\t\tcase KeyCode.LeftArrow:\n\t\t\t\treturn 'Left';\n\t\t\tcase KeyCode.RightArrow:\n\t\t\t\treturn 'Right';\n\t\t}\n\n\t\t// electron menus always do the correct rendering on Windows\n\t\treturn KeyCodeUtils.toString(keyCode);\n\t}\n\n\tpublic getElectronAcceleratorLabelForScanCodeBinding(binding: ScanCodeBinding | null): string | null {\n\t\tif (!binding) {\n\t\t\treturn null;\n\t\t}\n\t\tif (binding.isDuplicateModifierCase()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst immutableKeyCode = IMMUTABLE_CODE_TO_KEY_CODE[binding.scanCode];\n\t\tif (immutableKeyCode !== -1) {\n\t\t\treturn this._getElectronLabelForKeyCode(immutableKeyCode);\n\t\t}\n\n\t\t// Check if this scanCode always maps to the same keyCode and back\n\t\tconst constantKeyCode: KeyCode = this._scanCodeKeyCodeMapper.guessStableKeyCode(binding.scanCode);\n\n\t\tif (!this._isUSStandard) {\n\t\t\t// Electron cannot handle these key codes on anything else than standard US\n\t\t\tconst isOEMKey = (\n\t\t\t\tconstantKeyCode === KeyCode.US_SEMICOLON\n\t\t\t\t|| constantKeyCode === KeyCode.US_EQUAL\n\t\t\t\t|| constantKeyCode === KeyCode.US_COMMA\n\t\t\t\t|| constantKeyCode === KeyCode.US_MINUS\n\t\t\t\t|| constantKeyCode === KeyCode.US_DOT\n\t\t\t\t|| constantKeyCode === KeyCode.US_SLASH\n\t\t\t\t|| constantKeyCode === KeyCode.US_BACKTICK\n\t\t\t\t|| constantKeyCode === KeyCode.US_OPEN_SQUARE_BRACKET\n\t\t\t\t|| constantKeyCode === KeyCode.US_BACKSLASH\n\t\t\t\t|| constantKeyCode === KeyCode.US_CLOSE_SQUARE_BRACKET\n\t\t\t);\n\n\t\t\tif (isOEMKey) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (constantKeyCode !== -1) {\n\t\t\treturn this._getElectronLabelForKeyCode(constantKeyCode);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic resolveKeybinding(keybinding: Keybinding): NativeResolvedKeybinding[] {\n\t\tlet chordParts: ScanCodeBinding[][] = [];\n\t\tfor (let part of keybinding.parts) {\n\t\t\tchordParts.push(this.simpleKeybindingToScanCodeBinding(part));\n\t\t}\n\t\treturn this._toResolvedKeybinding(chordParts);\n\t}\n\n\tprivate _toResolvedKeybinding(chordParts: ScanCodeBinding[][]): NativeResolvedKeybinding[] {\n\t\tif (chordParts.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\tlet result: NativeResolvedKeybinding[] = [];\n\t\tthis._generateResolvedKeybindings(chordParts, 0, [], result);\n\t\treturn result;\n\t}\n\n\tprivate _generateResolvedKeybindings(chordParts: ScanCodeBinding[][], currentIndex: number, previousParts: ScanCodeBinding[], result: NativeResolvedKeybinding[]) {\n\t\tconst chordPart = chordParts[currentIndex];\n\t\tconst isFinalIndex = currentIndex === chordParts.length - 1;\n\t\tfor (let i = 0, len = chordPart.length; i < len; i++) {\n\t\t\tlet chords = [...previousParts, chordPart[i]];\n\t\t\tif (isFinalIndex) {\n\t\t\t\tresult.push(new NativeResolvedKeybinding(this, this._OS, chords));\n\t\t\t} else {\n\t\t\t\tthis._generateResolvedKeybindings(chordParts, currentIndex + 1, chords, result);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic resolveKeyboardEvent(keyboardEvent: IKeyboardEvent): NativeResolvedKeybinding {\n\t\tlet code = ScanCodeUtils.toEnum(keyboardEvent.code);\n\n\t\t// Treat NumpadEnter as Enter\n\t\tif (code === ScanCode.NumpadEnter) {\n\t\t\tcode = ScanCode.Enter;\n\t\t}\n\n\t\tconst keyCode = keyboardEvent.keyCode;\n\n\t\tif (\n\t\t\t(keyCode === KeyCode.LeftArrow)\n\t\t\t|| (keyCode === KeyCode.UpArrow)\n\t\t\t|| (keyCode === KeyCode.RightArrow)\n\t\t\t|| (keyCode === KeyCode.DownArrow)\n\t\t\t|| (keyCode === KeyCode.Delete)\n\t\t\t|| (keyCode === KeyCode.Insert)\n\t\t\t|| (keyCode === KeyCode.Home)\n\t\t\t|| (keyCode === KeyCode.End)\n\t\t\t|| (keyCode === KeyCode.PageDown)\n\t\t\t|| (keyCode === KeyCode.PageUp)\n\t\t) {\n\t\t\t// \"Dispatch\" on keyCode for these key codes to workaround issues with remote desktoping software\n\t\t\t// where the scan codes appear to be incorrect (see https://github.com/Microsoft/vscode/issues/24107)\n\t\t\tconst immutableScanCode = IMMUTABLE_KEY_CODE_TO_CODE[keyCode];\n\t\t\tif (immutableScanCode !== -1) {\n\t\t\t\tcode = immutableScanCode;\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif (\n\t\t\t\t(code === ScanCode.Numpad1)\n\t\t\t\t|| (code === ScanCode.Numpad2)\n\t\t\t\t|| (code === ScanCode.Numpad3)\n\t\t\t\t|| (code === ScanCode.Numpad4)\n\t\t\t\t|| (code === ScanCode.Numpad5)\n\t\t\t\t|| (code === ScanCode.Numpad6)\n\t\t\t\t|| (code === ScanCode.Numpad7)\n\t\t\t\t|| (code === ScanCode.Numpad8)\n\t\t\t\t|| (code === ScanCode.Numpad9)\n\t\t\t\t|| (code === ScanCode.Numpad0)\n\t\t\t\t|| (code === ScanCode.NumpadDecimal)\n\t\t\t) {\n\t\t\t\t// \"Dispatch\" on keyCode for all numpad keys in order for NumLock to work correctly\n\t\t\t\tif (keyCode >= 0) {\n\t\t\t\t\tconst immutableScanCode = IMMUTABLE_KEY_CODE_TO_CODE[keyCode];\n\t\t\t\t\tif (immutableScanCode !== -1) {\n\t\t\t\t\t\tcode = immutableScanCode;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst keypress = new ScanCodeBinding(keyboardEvent.ctrlKey, keyboardEvent.shiftKey, keyboardEvent.altKey, keyboardEvent.metaKey, code);\n\t\treturn new NativeResolvedKeybinding(this, this._OS, [keypress]);\n\t}\n\n\tprivate _resolveSimpleUserBinding(binding: SimpleKeybinding | ScanCodeBinding | null): ScanCodeBinding[] {\n\t\tif (!binding) {\n\t\t\treturn [];\n\t\t}\n\t\tif (binding instanceof ScanCodeBinding) {\n\t\t\treturn [binding];\n\t\t}\n\t\treturn this.simpleKeybindingToScanCodeBinding(binding);\n\t}\n\n\tpublic resolveUserBinding(input: (SimpleKeybinding | ScanCodeBinding)[]): ResolvedKeybinding[] {\n\t\tconst parts: ScanCodeBinding[][] = input.map(keybinding => this._resolveSimpleUserBinding(keybinding));\n\t\treturn this._toResolvedKeybinding(parts);\n\t}\n\n\tprivate static _charCodeToKb(charCode: number): { keyCode: KeyCode; shiftKey: boolean } | null {\n\t\tif (charCode < CHAR_CODE_TO_KEY_CODE.length) {\n\t\t\treturn CHAR_CODE_TO_KEY_CODE[charCode];\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Attempt to map a combining character to a regular one that renders the same way.\n\t *\n\t * To the brave person following me: Good Luck!\n\t * https://www.compart.com/en/unicode/bidiclass/NSM\n\t */\n\tpublic static getCharCode(char: string): number {\n\t\tif (char.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst charCode = char.charCodeAt(0);\n\t\tswitch (charCode) {\n\t\t\tcase CharCode.U_Combining_Grave_Accent: return CharCode.U_GRAVE_ACCENT;\n\t\t\tcase CharCode.U_Combining_Acute_Accent: return CharCode.U_ACUTE_ACCENT;\n\t\t\tcase CharCode.U_Combining_Circumflex_Accent: return CharCode.U_CIRCUMFLEX;\n\t\t\tcase CharCode.U_Combining_Tilde: return CharCode.U_SMALL_TILDE;\n\t\t\tcase CharCode.U_Combining_Macron: return CharCode.U_MACRON;\n\t\t\tcase CharCode.U_Combining_Overline: return CharCode.U_OVERLINE;\n\t\t\tcase CharCode.U_Combining_Breve: return CharCode.U_BREVE;\n\t\t\tcase CharCode.U_Combining_Dot_Above: return CharCode.U_DOT_ABOVE;\n\t\t\tcase CharCode.U_Combining_Diaeresis: return CharCode.U_DIAERESIS;\n\t\t\tcase CharCode.U_Combining_Ring_Above: return CharCode.U_RING_ABOVE;\n\t\t\tcase CharCode.U_Combining_Double_Acute_Accent: return CharCode.U_DOUBLE_ACUTE_ACCENT;\n\t\t}\n\t\treturn charCode;\n\t}\n}\n\n(function () {\n\tfunction define(charCode: number, keyCode: KeyCode, shiftKey: boolean): void {\n\t\tfor (let i = CHAR_CODE_TO_KEY_CODE.length; i < charCode; i++) {\n\t\t\tCHAR_CODE_TO_KEY_CODE[i] = null;\n\t\t}\n\t\tCHAR_CODE_TO_KEY_CODE[charCode] = { keyCode: keyCode, shiftKey: shiftKey };\n\t}\n\n\tfor (let chCode = CharCode.A; chCode <= CharCode.Z; chCode++) {\n\t\tdefine(chCode, KeyCode.KEY_A + (chCode - CharCode.A), true);\n\t}\n\n\tfor (let chCode = CharCode.a; chCode <= CharCode.z; chCode++) {\n\t\tdefine(chCode, KeyCode.KEY_A + (chCode - CharCode.a), false);\n\t}\n\n\tdefine(CharCode.Semicolon, KeyCode.US_SEMICOLON, false);\n\tdefine(CharCode.Colon, KeyCode.US_SEMICOLON, true);\n\n\tdefine(CharCode.Equals, KeyCode.US_EQUAL, false);\n\tdefine(CharCode.Plus, KeyCode.US_EQUAL, true);\n\n\tdefine(CharCode.Comma, KeyCode.US_COMMA, false);\n\tdefine(CharCode.LessThan, KeyCode.US_COMMA, true);\n\n\tdefine(CharCode.Dash, KeyCode.US_MINUS, false);\n\tdefine(CharCode.Underline, KeyCode.US_MINUS, true);\n\n\tdefine(CharCode.Period, KeyCode.US_DOT, false);\n\tdefine(CharCode.GreaterThan, KeyCode.US_DOT, true);\n\n\tdefine(CharCode.Slash, KeyCode.US_SLASH, false);\n\tdefine(CharCode.QuestionMark, KeyCode.US_SLASH, true);\n\n\tdefine(CharCode.BackTick, KeyCode.US_BACKTICK, false);\n\tdefine(CharCode.Tilde, KeyCode.US_BACKTICK, true);\n\n\tdefine(CharCode.OpenSquareBracket, KeyCode.US_OPEN_SQUARE_BRACKET, false);\n\tdefine(CharCode.OpenCurlyBrace, KeyCode.US_OPEN_SQUARE_BRACKET, true);\n\n\tdefine(CharCode.Backslash, KeyCode.US_BACKSLASH, false);\n\tdefine(CharCode.Pipe, KeyCode.US_BACKSLASH, true);\n\n\tdefine(CharCode.CloseSquareBracket, KeyCode.US_CLOSE_SQUARE_BRACKET, false);\n\tdefine(CharCode.CloseCurlyBrace, KeyCode.US_CLOSE_SQUARE_BRACKET, true);\n\n\tdefine(CharCode.SingleQuote, KeyCode.US_QUOTE, false);\n\tdefine(CharCode.DoubleQuote, KeyCode.US_QUOTE, true);\n})();\n"]}]}