{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/extensionManagement/node/extensionLifecycle.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/extensionManagement/node/extensionLifecycle.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/lifecycle\", \"child_process\", \"vs/base/common/errorMessage\", \"vs/base/common/path\", \"vs/base/common/async\", \"vs/base/common/event\", \"vs/base/common/network\", \"vs/base/node/pfs\"], function (require, exports, lifecycle_1, child_process_1, errorMessage_1, path_1, async_1, event_1, network_1, pfs_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class ExtensionsLifecycle extends lifecycle_1.Disposable {\n        constructor(environmentService, logService) {\n            super();\n            this.environmentService = environmentService;\n            this.logService = logService;\n            this.processesLimiter = new async_1.Limiter(5); // Run max 5 processes in parallel\n        }\n        postUninstall(extension) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const script = this.parseScript(extension, 'uninstall');\n                if (script) {\n                    this.logService.info(extension.identifier.id, extension.manifest.version, `Running post uninstall script`);\n                    yield this.processesLimiter.queue(() => this.runLifecycleHook(script.script, 'uninstall', script.args, true, extension)\n                        .then(() => this.logService.info(extension.identifier.id, extension.manifest.version, `Finished running post uninstall script`), err => this.logService.error(extension.identifier.id, extension.manifest.version, `Failed to run post uninstall script: ${err}`)));\n                }\n                return pfs_1.rimraf(this.getExtensionStoragePath(extension)).then(undefined, e => this.logService.error('Error while removing extension storage path', e));\n            });\n        }\n        parseScript(extension, type) {\n            const scriptKey = `vscode:${type}`;\n            if (extension.location.scheme === network_1.Schemas.file && extension.manifest && extension.manifest['scripts'] && typeof extension.manifest['scripts'][scriptKey] === 'string') {\n                const script = extension.manifest['scripts'][scriptKey].split(' ');\n                if (script.length < 2 || script[0] !== 'node' || !script[1]) {\n                    this.logService.warn(extension.identifier.id, extension.manifest.version, `${scriptKey} should be a node script`);\n                    return null;\n                }\n                return { script: path_1.join(extension.location.fsPath, script[1]), args: script.slice(2) || [] };\n            }\n            return null;\n        }\n        runLifecycleHook(lifecycleHook, lifecycleType, args, timeout, extension) {\n            return new Promise((c, e) => {\n                const extensionLifecycleProcess = this.start(lifecycleHook, lifecycleType, args, extension);\n                let timeoutHandler;\n                const onexit = (error) => {\n                    if (timeoutHandler) {\n                        clearTimeout(timeoutHandler);\n                        timeoutHandler = null;\n                    }\n                    if (error) {\n                        e(error);\n                    }\n                    else {\n                        c(undefined);\n                    }\n                };\n                // on error\n                extensionLifecycleProcess.on('error', (err) => {\n                    onexit(errorMessage_1.toErrorMessage(err) || 'Unknown');\n                });\n                // on exit\n                extensionLifecycleProcess.on('exit', (code, signal) => {\n                    onexit(code ? `post-${lifecycleType} process exited with code ${code}` : undefined);\n                });\n                if (timeout) {\n                    // timeout: kill process after waiting for 5s\n                    timeoutHandler = setTimeout(() => {\n                        timeoutHandler = null;\n                        extensionLifecycleProcess.kill();\n                        e('timed out');\n                    }, 5000);\n                }\n            });\n        }\n        start(uninstallHook, lifecycleType, args, extension) {\n            const opts = {\n                silent: true,\n                execArgv: undefined\n            };\n            const extensionUninstallProcess = child_process_1.fork(uninstallHook, [`--type=extension-post-${lifecycleType}`, ...args], opts);\n            extensionUninstallProcess.stdout.setEncoding('utf8');\n            extensionUninstallProcess.stderr.setEncoding('utf8');\n            const onStdout = event_1.Event.fromNodeEventEmitter(extensionUninstallProcess.stdout, 'data');\n            const onStderr = event_1.Event.fromNodeEventEmitter(extensionUninstallProcess.stderr, 'data');\n            // Log output\n            onStdout(data => this.logService.info(extension.identifier.id, extension.manifest.version, `post-${lifecycleType}`, data));\n            onStderr(data => this.logService.error(extension.identifier.id, extension.manifest.version, `post-${lifecycleType}`, data));\n            const onOutput = event_1.Event.any(event_1.Event.map(onStdout, o => ({ data: `%c${o}`, format: [''] })), event_1.Event.map(onStderr, o => ({ data: `%c${o}`, format: ['color: red'] })));\n            // Debounce all output, so we can render it in the Chrome console as a group\n            const onDebouncedOutput = event_1.Event.debounce(onOutput, (r, o) => {\n                return r\n                    ? { data: r.data + o.data, format: [...r.format, ...o.format] }\n                    : { data: o.data, format: o.format };\n            }, 100);\n            // Print out output\n            onDebouncedOutput(data => {\n                console.group(extension.identifier.id);\n                console.log(data.data, ...data.format);\n                console.groupEnd();\n            });\n            return extensionUninstallProcess;\n        }\n        getExtensionStoragePath(extension) {\n            return path_1.join(this.environmentService.globalStorageHome, extension.identifier.id.toLowerCase());\n        }\n    }\n    exports.ExtensionsLifecycle = ExtensionsLifecycle;\n});\n",null]}