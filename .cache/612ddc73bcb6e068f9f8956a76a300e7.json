{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/standalone/common/monarch/monarchCommon.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/standalone/common/monarch/monarchCommon.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /*\n     * This module exports common types and functionality shared between\n     * the Monarch compiler that compiles JSON to ILexer, and the Monarch\n     * Tokenizer (that highlights at runtime)\n     */\n    /*\n     * Type definitions to be used internally to Monarch.\n     * Inside monarch we use fully typed definitions and compiled versions of the more abstract JSON descriptions.\n     */\n    var MonarchBracket;\n    (function (MonarchBracket) {\n        MonarchBracket[MonarchBracket[\"None\"] = 0] = \"None\";\n        MonarchBracket[MonarchBracket[\"Open\"] = 1] = \"Open\";\n        MonarchBracket[MonarchBracket[\"Close\"] = -1] = \"Close\";\n    })(MonarchBracket = exports.MonarchBracket || (exports.MonarchBracket = {}));\n    function isFuzzyActionArr(what) {\n        return (Array.isArray(what));\n    }\n    exports.isFuzzyActionArr = isFuzzyActionArr;\n    function isFuzzyAction(what) {\n        return !isFuzzyActionArr(what);\n    }\n    exports.isFuzzyAction = isFuzzyAction;\n    function isString(what) {\n        return (typeof what === 'string');\n    }\n    exports.isString = isString;\n    function isIAction(what) {\n        return !isString(what);\n    }\n    exports.isIAction = isIAction;\n    // Small helper functions\n    /**\n     * Is a string null, undefined, or empty?\n     */\n    function empty(s) {\n        return (s ? false : true);\n    }\n    exports.empty = empty;\n    /**\n     * Puts a string to lower case if 'ignoreCase' is set.\n     */\n    function fixCase(lexer, str) {\n        return (lexer.ignoreCase && str ? str.toLowerCase() : str);\n    }\n    exports.fixCase = fixCase;\n    /**\n     * Ensures there are no bad characters in a CSS token class.\n     */\n    function sanitize(s) {\n        return s.replace(/[&<>'\"_]/g, '-'); // used on all output token CSS classes\n    }\n    exports.sanitize = sanitize;\n    // Logging\n    /**\n     * Logs a message.\n     */\n    function log(lexer, msg) {\n        console.log(`${lexer.languageId}: ${msg}`);\n    }\n    exports.log = log;\n    // Throwing errors\n    function createError(lexer, msg) {\n        return new Error(`${lexer.languageId}: ${msg}`);\n    }\n    exports.createError = createError;\n    // Helper functions for rule finding and substitution\n    /**\n     * substituteMatches is used on lexer strings and can substitutes predefined patterns:\n     * \t\t$$  => $\n     * \t\t$#  => id\n     * \t\t$n  => matched entry n\n     * \t\t@attr => contents of lexer[attr]\n     *\n     * See documentation for more info\n     */\n    function substituteMatches(lexer, str, id, matches, state) {\n        const re = /\\$((\\$)|(#)|(\\d\\d?)|[sS](\\d\\d?)|@(\\w+))/g;\n        let stateMatches = null;\n        return str.replace(re, function (full, sub, dollar, hash, n, s, attr, ofs, total) {\n            if (!empty(dollar)) {\n                return '$'; // $$\n            }\n            if (!empty(hash)) {\n                return fixCase(lexer, id); // default $#\n            }\n            if (!empty(n) && n < matches.length) {\n                return fixCase(lexer, matches[n]); // $n\n            }\n            if (!empty(attr) && lexer && typeof (lexer[attr]) === 'string') {\n                return lexer[attr]; //@attribute\n            }\n            if (stateMatches === null) { // split state on demand\n                stateMatches = state.split('.');\n                stateMatches.unshift(state);\n            }\n            if (!empty(s) && s < stateMatches.length) {\n                return fixCase(lexer, stateMatches[s]); //$Sn\n            }\n            return '';\n        });\n    }\n    exports.substituteMatches = substituteMatches;\n    /**\n     * Find the tokenizer rules for a specific state (i.e. next action)\n     */\n    function findRules(lexer, inState) {\n        let state = inState;\n        while (state && state.length > 0) {\n            const rules = lexer.tokenizer[state];\n            if (rules) {\n                return rules;\n            }\n            const idx = state.lastIndexOf('.');\n            if (idx < 0) {\n                state = null; // no further parent\n            }\n            else {\n                state = state.substr(0, idx);\n            }\n        }\n        return null;\n    }\n    exports.findRules = findRules;\n    /**\n     * Is a certain state defined? In contrast to 'findRules' this works on a ILexerMin.\n     * This is used during compilation where we may know the defined states\n     * but not yet whether the corresponding rules are correct.\n     */\n    function stateExists(lexer, inState) {\n        let state = inState;\n        while (state && state.length > 0) {\n            const exist = lexer.stateNames[state];\n            if (exist) {\n                return true;\n            }\n            const idx = state.lastIndexOf('.');\n            if (idx < 0) {\n                state = null; // no further parent\n            }\n            else {\n                state = state.substr(0, idx);\n            }\n        }\n        return false;\n    }\n    exports.stateExists = stateExists;\n});\n",null]}