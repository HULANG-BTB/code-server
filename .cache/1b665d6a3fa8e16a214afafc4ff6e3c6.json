{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/comment/lineCommentCommand.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/comment/lineCommentCommand.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar strings = require(\"vs/base/common/strings\");\nvar editOperation_1 = require(\"vs/editor/common/core/editOperation\");\nvar position_1 = require(\"vs/editor/common/core/position\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar selection_1 = require(\"vs/editor/common/core/selection\");\nvar languageConfigurationRegistry_1 = require(\"vs/editor/common/modes/languageConfigurationRegistry\");\nvar blockCommentCommand_1 = require(\"vs/editor/contrib/comment/blockCommentCommand\");\nvar Type;\n(function (Type) {\n    Type[Type[\"Toggle\"] = 0] = \"Toggle\";\n    Type[Type[\"ForceAdd\"] = 1] = \"ForceAdd\";\n    Type[Type[\"ForceRemove\"] = 2] = \"ForceRemove\";\n})(Type = exports.Type || (exports.Type = {}));\nvar LineCommentCommand = /** @class */ (function () {\n    function LineCommentCommand(selection, tabSize, type) {\n        this._selection = selection;\n        this._tabSize = tabSize;\n        this._type = type;\n        this._deltaColumn = 0;\n    }\n    /**\n     * Do an initial pass over the lines and gather info about the line comment string.\n     * Returns null if any of the lines doesn't support a line comment string.\n     */\n    LineCommentCommand._gatherPreflightCommentStrings = function (model, startLineNumber, endLineNumber) {\n        model.tokenizeIfCheap(startLineNumber);\n        var languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n        var config = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getComments(languageId);\n        var commentStr = (config ? config.lineCommentToken : null);\n        if (!commentStr) {\n            // Mode does not support line comments\n            return null;\n        }\n        var lines = [];\n        for (var i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n            lines[i] = {\n                ignore: false,\n                commentStr: commentStr,\n                commentStrOffset: 0,\n                commentStrLength: commentStr.length\n            };\n        }\n        return lines;\n    };\n    /**\n     * Analyze lines and decide which lines are relevant and what the toggle should do.\n     * Also, build up several offsets and lengths useful in the generation of editor operations.\n     */\n    LineCommentCommand._analyzeLines = function (type, model, lines, startLineNumber) {\n        var onlyWhitespaceLines = true;\n        var shouldRemoveComments;\n        if (type === Type.Toggle) {\n            shouldRemoveComments = true;\n        }\n        else if (type === Type.ForceAdd) {\n            shouldRemoveComments = false;\n        }\n        else {\n            shouldRemoveComments = true;\n        }\n        for (var i = 0, lineCount = lines.length; i < lineCount; i++) {\n            var lineData = lines[i];\n            var lineNumber = startLineNumber + i;\n            var lineContent = model.getLineContent(lineNumber);\n            var lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n            if (lineContentStartOffset === -1) {\n                // Empty or whitespace only line\n                if (type === Type.Toggle) {\n                    lineData.ignore = true;\n                }\n                else if (type === Type.ForceAdd) {\n                    lineData.ignore = true;\n                }\n                else {\n                    lineData.ignore = true;\n                }\n                lineData.commentStrOffset = lineContent.length;\n                continue;\n            }\n            onlyWhitespaceLines = false;\n            lineData.ignore = false;\n            lineData.commentStrOffset = lineContentStartOffset;\n            if (shouldRemoveComments && !blockCommentCommand_1.BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\n                if (type === Type.Toggle) {\n                    // Every line so far has been a line comment, but this one is not\n                    shouldRemoveComments = false;\n                }\n                else if (type === Type.ForceAdd) {\n                    // Will not happen\n                }\n                else {\n                    lineData.ignore = true;\n                }\n            }\n            if (shouldRemoveComments) {\n                var commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n                if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === charCode_1.CharCode.Space) {\n                    lineData.commentStrLength += 1;\n                }\n            }\n        }\n        if (type === Type.Toggle && onlyWhitespaceLines) {\n            // For only whitespace lines, we insert comments\n            shouldRemoveComments = false;\n            // Also, no longer ignore them\n            for (var i = 0, lineCount = lines.length; i < lineCount; i++) {\n                lines[i].ignore = false;\n            }\n        }\n        return {\n            supported: true,\n            shouldRemoveComments: shouldRemoveComments,\n            lines: lines\n        };\n    };\n    /**\n     * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\n     */\n    LineCommentCommand._gatherPreflightData = function (type, model, startLineNumber, endLineNumber) {\n        var lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber);\n        if (lines === null) {\n            return {\n                supported: false\n            };\n        }\n        return LineCommentCommand._analyzeLines(type, model, lines, startLineNumber);\n    };\n    /**\n     * Given a successful analysis, execute either insert line comments, either remove line comments\n     */\n    LineCommentCommand.prototype._executeLineComments = function (model, builder, data, s) {\n        var ops;\n        if (data.shouldRemoveComments) {\n            ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n        }\n        else {\n            LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);\n            ops = LineCommentCommand._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n        }\n        var cursorPosition = new position_1.Position(s.positionLineNumber, s.positionColumn);\n        for (var i = 0, len = ops.length; i < len; i++) {\n            builder.addEditOperation(ops[i].range, ops[i].text);\n            if (ops[i].range.isEmpty() && ops[i].range.getStartPosition().equals(cursorPosition)) {\n                var lineContent = model.getLineContent(cursorPosition.lineNumber);\n                if (lineContent.length + 1 === cursorPosition.column) {\n                    this._deltaColumn = (ops[i].text || '').length;\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n    };\n    LineCommentCommand.prototype._attemptRemoveBlockComment = function (model, s, startToken, endToken) {\n        var startLineNumber = s.startLineNumber;\n        var endLineNumber = s.endLineNumber;\n        var startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\n        var startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n        var endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n        if (startTokenIndex !== -1 && endTokenIndex === -1) {\n            endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n            endLineNumber = startLineNumber;\n        }\n        if (startTokenIndex === -1 && endTokenIndex !== -1) {\n            startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n            startLineNumber = endLineNumber;\n        }\n        if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n            startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n            if (startTokenIndex !== -1) {\n                endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n            }\n        }\n        // We have to adjust to possible inner white space.\n        // For Space after startToken, add Space to startToken - range math will work out.\n        if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === charCode_1.CharCode.Space) {\n            startToken += ' ';\n        }\n        // For Space before endToken, add Space before endToken and shift index one left.\n        if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === charCode_1.CharCode.Space) {\n            endToken = ' ' + endToken;\n            endTokenIndex -= 1;\n        }\n        if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n            return blockCommentCommand_1.BlockCommentCommand._createRemoveBlockCommentOperations(new range_1.Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n        }\n        return null;\n    };\n    /**\n     * Given an unsuccessful analysis, delegate to the block comment command\n     */\n    LineCommentCommand.prototype._executeBlockComment = function (model, builder, s) {\n        model.tokenizeIfCheap(s.startLineNumber);\n        var languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n        var config = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getComments(languageId);\n        if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n            // Mode does not support block comments\n            return;\n        }\n        var startToken = config.blockCommentStartToken;\n        var endToken = config.blockCommentEndToken;\n        var ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n        if (!ops) {\n            if (s.isEmpty()) {\n                var lineContent = model.getLineContent(s.startLineNumber);\n                var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n                if (firstNonWhitespaceIndex === -1) {\n                    // Line is empty or contains only whitespace\n                    firstNonWhitespaceIndex = lineContent.length;\n                }\n                ops = blockCommentCommand_1.BlockCommentCommand._createAddBlockCommentOperations(new range_1.Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken);\n            }\n            else {\n                ops = blockCommentCommand_1.BlockCommentCommand._createAddBlockCommentOperations(new range_1.Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken);\n            }\n            if (ops.length === 1) {\n                // Leave cursor after token and Space\n                this._deltaColumn = startToken.length + 1;\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n        for (var _i = 0, ops_1 = ops; _i < ops_1.length; _i++) {\n            var op = ops_1[_i];\n            builder.addEditOperation(op.range, op.text);\n        }\n    };\n    LineCommentCommand.prototype.getEditOperations = function (model, builder) {\n        var s = this._selection;\n        this._moveEndPositionDown = false;\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n            this._moveEndPositionDown = true;\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n        }\n        var data = LineCommentCommand._gatherPreflightData(this._type, model, s.startLineNumber, s.endLineNumber);\n        if (data.supported) {\n            return this._executeLineComments(model, builder, data, s);\n        }\n        return this._executeBlockComment(model, builder, s);\n    };\n    LineCommentCommand.prototype.computeCursorState = function (model, helper) {\n        var result = helper.getTrackedSelection(this._selectionId);\n        if (this._moveEndPositionDown) {\n            result = result.setEndPosition(result.endLineNumber + 1, 1);\n        }\n        return new selection_1.Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\n    };\n    /**\n     * Generate edit operations in the remove line comment case\n     */\n    LineCommentCommand._createRemoveLineCommentsOperations = function (lines, startLineNumber) {\n        var res = [];\n        for (var i = 0, len = lines.length; i < len; i++) {\n            var lineData = lines[i];\n            if (lineData.ignore) {\n                continue;\n            }\n            res.push(editOperation_1.EditOperation.delete(new range_1.Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\n        }\n        return res;\n    };\n    /**\n     * Generate edit operations in the add line comment case\n     */\n    LineCommentCommand._createAddLineCommentsOperations = function (lines, startLineNumber) {\n        var res = [];\n        for (var i = 0, len = lines.length; i < len; i++) {\n            var lineData = lines[i];\n            if (lineData.ignore) {\n                continue;\n            }\n            res.push(editOperation_1.EditOperation.insert(new position_1.Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + ' '));\n        }\n        return res;\n    };\n    // TODO@Alex -> duplicated in characterHardWrappingLineMapper\n    LineCommentCommand.nextVisibleColumn = function (currentVisibleColumn, tabSize, isTab, columnSize) {\n        if (isTab) {\n            return currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));\n        }\n        return currentVisibleColumn + columnSize;\n    };\n    /**\n     * Adjust insertion points to have them vertically aligned in the add line comment case\n     */\n    LineCommentCommand._normalizeInsertionPoint = function (model, lines, startLineNumber, tabSize) {\n        var minVisibleColumn = Number.MAX_VALUE;\n        var j;\n        var lenJ;\n        for (var i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].ignore) {\n                continue;\n            }\n            var lineContent = model.getLineContent(startLineNumber + i);\n            var currentVisibleColumn = 0;\n            for (var j_1 = 0, lenJ_1 = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j_1 < lenJ_1; j_1++) {\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j_1) === charCode_1.CharCode.Tab, 1);\n            }\n            if (currentVisibleColumn < minVisibleColumn) {\n                minVisibleColumn = currentVisibleColumn;\n            }\n        }\n        minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;\n        for (var i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].ignore) {\n                continue;\n            }\n            var lineContent = model.getLineContent(startLineNumber + i);\n            var currentVisibleColumn = 0;\n            for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === charCode_1.CharCode.Tab, 1);\n            }\n            if (currentVisibleColumn > minVisibleColumn) {\n                lines[i].commentStrOffset = j - 1;\n            }\n            else {\n                lines[i].commentStrOffset = j;\n            }\n        }\n    };\n    return LineCommentCommand;\n}());\nexports.LineCommentCommand = LineCommentCommand;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/comment/lineCommentCommand.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/contrib/comment/lineCommentCommand.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;AAEhG,oDAAmD;AACnD,gDAAkD;AAClD,qEAAoE;AACpE,2DAA0D;AAC1D,qDAAoD;AACpD,6DAA4D;AAG5D,sGAAqG;AACrG,qFAAoF;AA4BpF,IAAkB,IAIjB;AAJD,WAAkB,IAAI;IACrB,mCAAU,CAAA;IACV,uCAAY,CAAA;IACZ,6CAAe,CAAA;AAChB,CAAC,EAJiB,IAAI,GAAJ,YAAI,KAAJ,YAAI,QAIrB;AAED;IASC,4BAAY,SAAoB,EAAE,OAAe,EAAE,IAAU;QAC5D,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAC5B,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;IACvB,CAAC;IAED;;;OAGG;IACW,iDAA8B,GAA5C,UAA6C,KAAiB,EAAE,eAAuB,EAAE,aAAqB;QAE7G,KAAK,CAAC,eAAe,CAAC,eAAe,CAAC,CAAC;QACvC,IAAM,UAAU,GAAG,KAAK,CAAC,uBAAuB,CAAC,eAAe,EAAE,CAAC,CAAC,CAAC;QAErE,IAAM,MAAM,GAAG,6DAA6B,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;QACrE,IAAM,UAAU,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QAC7D,IAAI,CAAC,UAAU,EAAE;YAChB,sCAAsC;YACtC,OAAO,IAAI,CAAC;SACZ;QAED,IAAI,KAAK,GAAyB,EAAE,CAAC;QACrC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,SAAS,GAAG,aAAa,GAAG,eAAe,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE;YACpF,KAAK,CAAC,CAAC,CAAC,GAAG;gBACV,MAAM,EAAE,KAAK;gBACb,UAAU,EAAE,UAAU;gBACtB,gBAAgB,EAAE,CAAC;gBACnB,gBAAgB,EAAE,UAAU,CAAC,MAAM;aACnC,CAAC;SACF;QAED,OAAO,KAAK,CAAC;IACd,CAAC;IAED;;;OAGG;IACW,gCAAa,GAA3B,UAA4B,IAAU,EAAE,KAAmB,EAAE,KAA2B,EAAE,eAAuB;QAChH,IAAI,mBAAmB,GAAG,IAAI,CAAC;QAE/B,IAAI,oBAA6B,CAAC;QAClC,IAAI,IAAI,KAAK,IAAI,CAAC,MAAM,EAAE;YACzB,oBAAoB,GAAG,IAAI,CAAC;SAC5B;aAAM,IAAI,IAAI,KAAK,IAAI,CAAC,QAAQ,EAAE;YAClC,oBAAoB,GAAG,KAAK,CAAC;SAC7B;aAAM;YACN,oBAAoB,GAAG,IAAI,CAAC;SAC5B;QAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,SAAS,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE;YAC7D,IAAM,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YAC1B,IAAM,UAAU,GAAG,eAAe,GAAG,CAAC,CAAC;YAEvC,IAAM,WAAW,GAAG,KAAK,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;YACrD,IAAM,sBAAsB,GAAG,OAAO,CAAC,uBAAuB,CAAC,WAAW,CAAC,CAAC;YAE5E,IAAI,sBAAsB,KAAK,CAAC,CAAC,EAAE;gBAClC,gCAAgC;gBAChC,IAAI,IAAI,KAAK,IAAI,CAAC,MAAM,EAAE;oBACzB,QAAQ,CAAC,MAAM,GAAG,IAAI,CAAC;iBACvB;qBAAM,IAAI,IAAI,KAAK,IAAI,CAAC,QAAQ,EAAE;oBAClC,QAAQ,CAAC,MAAM,GAAG,IAAI,CAAC;iBACvB;qBAAM;oBACN,QAAQ,CAAC,MAAM,GAAG,IAAI,CAAC;iBACvB;gBACD,QAAQ,CAAC,gBAAgB,GAAG,WAAW,CAAC,MAAM,CAAC;gBAC/C,SAAS;aACT;YAED,mBAAmB,GAAG,KAAK,CAAC;YAC5B,QAAQ,CAAC,MAAM,GAAG,KAAK,CAAC;YACxB,QAAQ,CAAC,gBAAgB,GAAG,sBAAsB,CAAC;YAEnD,IAAI,oBAAoB,IAAI,CAAC,yCAAmB,CAAC,0BAA0B,CAAC,WAAW,EAAE,QAAQ,CAAC,UAAU,EAAE,sBAAsB,CAAC,EAAE;gBACtI,IAAI,IAAI,KAAK,IAAI,CAAC,MAAM,EAAE;oBACzB,iEAAiE;oBACjE,oBAAoB,GAAG,KAAK,CAAC;iBAC7B;qBAAM,IAAI,IAAI,KAAK,IAAI,CAAC,QAAQ,EAAE;oBAClC,kBAAkB;iBAClB;qBAAM;oBACN,QAAQ,CAAC,MAAM,GAAG,IAAI,CAAC;iBACvB;aACD;YAED,IAAI,oBAAoB,EAAE;gBACzB,IAAM,mBAAmB,GAAG,sBAAsB,GAAG,QAAQ,CAAC,gBAAgB,CAAC;gBAC/E,IAAI,mBAAmB,GAAG,WAAW,CAAC,MAAM,IAAI,WAAW,CAAC,UAAU,CAAC,mBAAmB,CAAC,KAAK,mBAAQ,CAAC,KAAK,EAAE;oBAC/G,QAAQ,CAAC,gBAAgB,IAAI,CAAC,CAAC;iBAC/B;aACD;SACD;QAED,IAAI,IAAI,KAAK,IAAI,CAAC,MAAM,IAAI,mBAAmB,EAAE;YAChD,gDAAgD;YAChD,oBAAoB,GAAG,KAAK,CAAC;YAE7B,8BAA8B;YAC9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,SAAS,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE;gBAC7D,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,KAAK,CAAC;aACxB;SACD;QAED,OAAO;YACN,SAAS,EAAE,IAAI;YACf,oBAAoB,EAAE,oBAAoB;YAC1C,KAAK,EAAE,KAAK;SACZ,CAAC;IACH,CAAC;IAED;;OAEG;IACW,uCAAoB,GAAlC,UAAmC,IAAU,EAAE,KAAiB,EAAE,eAAuB,EAAE,aAAqB;QAC/G,IAAM,KAAK,GAAG,kBAAkB,CAAC,8BAA8B,CAAC,KAAK,EAAE,eAAe,EAAE,aAAa,CAAC,CAAC;QACvG,IAAI,KAAK,KAAK,IAAI,EAAE;YACnB,OAAO;gBACN,SAAS,EAAE,KAAK;aAChB,CAAC;SACF;QAED,OAAO,kBAAkB,CAAC,aAAa,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,eAAe,CAAC,CAAC;IAC9E,CAAC;IAED;;OAEG;IACK,iDAAoB,GAA5B,UAA6B,KAAmB,EAAE,OAA2C,EAAE,IAA6B,EAAE,CAAY;QAEzI,IAAI,GAAqC,CAAC;QAE1C,IAAI,IAAI,CAAC,oBAAoB,EAAE;YAC9B,GAAG,GAAG,kBAAkB,CAAC,mCAAmC,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,eAAe,CAAC,CAAC;SAC5F;aAAM;YACN,kBAAkB,CAAC,wBAAwB,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,eAAe,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;YACjG,GAAG,GAAG,kBAAkB,CAAC,gCAAgC,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,eAAe,CAAC,CAAC;SACzF;QAED,IAAM,cAAc,GAAG,IAAI,mBAAQ,CAAC,CAAC,CAAC,kBAAkB,EAAE,CAAC,CAAC,cAAc,CAAC,CAAC;QAE5E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YAC/C,OAAO,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;YACpD,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,gBAAgB,EAAE,CAAC,MAAM,CAAC,cAAc,CAAC,EAAE;gBACrF,IAAM,WAAW,GAAG,KAAK,CAAC,cAAc,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;gBACpE,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,KAAK,cAAc,CAAC,MAAM,EAAE;oBACrD,IAAI,CAAC,YAAY,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC,MAAM,CAAC;iBAC/C;aACD;SACD;QAED,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;IAC/C,CAAC;IAEO,uDAA0B,GAAlC,UAAmC,KAAiB,EAAE,CAAY,EAAE,UAAkB,EAAE,QAAgB;QACvG,IAAI,eAAe,GAAG,CAAC,CAAC,eAAe,CAAC;QACxC,IAAI,aAAa,GAAG,CAAC,CAAC,aAAa,CAAC;QAEpC,IAAI,6BAA6B,GAAG,QAAQ,CAAC,MAAM,GAAG,IAAI,CAAC,GAAG,CAC7D,KAAK,CAAC,+BAA+B,CAAC,CAAC,CAAC,eAAe,CAAC,EACxD,CAAC,CAAC,WAAW,CACb,CAAC;QAEF,IAAI,eAAe,GAAG,KAAK,CAAC,cAAc,CAAC,eAAe,CAAC,CAAC,WAAW,CAAC,UAAU,EAAE,6BAA6B,GAAG,CAAC,CAAC,CAAC;QACvH,IAAI,aAAa,GAAG,KAAK,CAAC,cAAc,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC,SAAS,GAAG,CAAC,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC;QAE/G,IAAI,eAAe,KAAK,CAAC,CAAC,IAAI,aAAa,KAAK,CAAC,CAAC,EAAE;YACnD,aAAa,GAAG,KAAK,CAAC,cAAc,CAAC,eAAe,CAAC,CAAC,OAAO,CAAC,QAAQ,EAAE,eAAe,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC;YAC7G,aAAa,GAAG,eAAe,CAAC;SAChC;QAED,IAAI,eAAe,KAAK,CAAC,CAAC,IAAI,aAAa,KAAK,CAAC,CAAC,EAAE;YACnD,eAAe,GAAG,KAAK,CAAC,cAAc,CAAC,aAAa,CAAC,CAAC,WAAW,CAAC,UAAU,EAAE,aAAa,CAAC,CAAC;YAC7F,eAAe,GAAG,aAAa,CAAC;SAChC;QAED,IAAI,CAAC,CAAC,OAAO,EAAE,IAAI,CAAC,eAAe,KAAK,CAAC,CAAC,IAAI,aAAa,KAAK,CAAC,CAAC,CAAC,EAAE;YACpE,eAAe,GAAG,KAAK,CAAC,cAAc,CAAC,eAAe,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;YAC5E,IAAI,eAAe,KAAK,CAAC,CAAC,EAAE;gBAC3B,aAAa,GAAG,KAAK,CAAC,cAAc,CAAC,eAAe,CAAC,CAAC,OAAO,CAAC,QAAQ,EAAE,eAAe,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC;aAC7G;SACD;QAED,mDAAmD;QACnD,kFAAkF;QAClF,IAAI,eAAe,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC,cAAc,CAAC,eAAe,CAAC,CAAC,UAAU,CAAC,eAAe,GAAG,UAAU,CAAC,MAAM,CAAC,KAAK,mBAAQ,CAAC,KAAK,EAAE;YACvI,UAAU,IAAI,GAAG,CAAC;SAClB;QAED,iFAAiF;QACjF,IAAI,aAAa,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC,cAAc,CAAC,aAAa,CAAC,CAAC,UAAU,CAAC,aAAa,GAAG,CAAC,CAAC,KAAK,mBAAQ,CAAC,KAAK,EAAE;YACjH,QAAQ,GAAG,GAAG,GAAG,QAAQ,CAAC;YAC1B,aAAa,IAAI,CAAC,CAAC;SACnB;QAED,IAAI,eAAe,KAAK,CAAC,CAAC,IAAI,aAAa,KAAK,CAAC,CAAC,EAAE;YACnD,OAAO,yCAAmB,CAAC,mCAAmC,CAC7D,IAAI,aAAK,CAAC,eAAe,EAAE,eAAe,GAAG,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,aAAa,EAAE,aAAa,GAAG,CAAC,CAAC,EAAE,UAAU,EAAE,QAAQ,CAC3H,CAAC;SACF;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IAED;;OAEG;IACK,iDAAoB,GAA5B,UAA6B,KAAiB,EAAE,OAA2C,EAAE,CAAY;QACxG,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC;QACzC,IAAI,UAAU,GAAG,KAAK,CAAC,uBAAuB,CAAC,CAAC,CAAC,eAAe,EAAE,CAAC,CAAC,CAAC;QACrE,IAAI,MAAM,GAAG,6DAA6B,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;QACnE,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,sBAAsB,IAAI,CAAC,MAAM,CAAC,oBAAoB,EAAE;YAC9E,uCAAuC;YACvC,OAAO;SACP;QAED,IAAM,UAAU,GAAG,MAAM,CAAC,sBAAsB,CAAC;QACjD,IAAM,QAAQ,GAAG,MAAM,CAAC,oBAAoB,CAAC;QAE7C,IAAI,GAAG,GAAG,IAAI,CAAC,0BAA0B,CAAC,KAAK,EAAE,CAAC,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;QAC1E,IAAI,CAAC,GAAG,EAAE;YACT,IAAI,CAAC,CAAC,OAAO,EAAE,EAAE;gBAChB,IAAM,WAAW,GAAG,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC;gBAC5D,IAAI,uBAAuB,GAAG,OAAO,CAAC,uBAAuB,CAAC,WAAW,CAAC,CAAC;gBAC3E,IAAI,uBAAuB,KAAK,CAAC,CAAC,EAAE;oBACnC,4CAA4C;oBAC5C,uBAAuB,GAAG,WAAW,CAAC,MAAM,CAAC;iBAC7C;gBACD,GAAG,GAAG,yCAAmB,CAAC,gCAAgC,CACzD,IAAI,aAAK,CAAC,CAAC,CAAC,eAAe,EAAE,uBAAuB,GAAG,CAAC,EAAE,CAAC,CAAC,eAAe,EAAE,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,UAAU,EAAE,QAAQ,CAC1H,CAAC;aACF;iBAAM;gBACN,GAAG,GAAG,yCAAmB,CAAC,gCAAgC,CACzD,IAAI,aAAK,CAAC,CAAC,CAAC,eAAe,EAAE,KAAK,CAAC,+BAA+B,CAAC,CAAC,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC,aAAa,EAAE,KAAK,CAAC,gBAAgB,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,EAAE,UAAU,EAAE,QAAQ,CACtK,CAAC;aACF;YAED,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,EAAE;gBACrB,qCAAqC;gBACrC,IAAI,CAAC,YAAY,GAAG,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC;aAC1C;SACD;QACD,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;QAC9C,KAAiB,UAAG,EAAH,WAAG,EAAH,iBAAG,EAAH,IAAG,EAAE;YAAjB,IAAM,EAAE,YAAA;YACZ,OAAO,CAAC,gBAAgB,CAAC,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC;SAC5C;IACF,CAAC;IAEM,8CAAiB,GAAxB,UAAyB,KAAiB,EAAE,OAA2C;QAEtF,IAAI,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC;QACxB,IAAI,CAAC,oBAAoB,GAAG,KAAK,CAAC;QAElC,IAAI,CAAC,CAAC,eAAe,GAAG,CAAC,CAAC,aAAa,IAAI,CAAC,CAAC,SAAS,KAAK,CAAC,EAAE;YAC7D,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC;YACjC,CAAC,GAAG,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,aAAa,GAAG,CAAC,EAAE,KAAK,CAAC,gBAAgB,CAAC,CAAC,CAAC,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;SACvF;QAED,IAAM,IAAI,GAAG,kBAAkB,CAAC,oBAAoB,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,CAAC,eAAe,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC;QAC5G,IAAI,IAAI,CAAC,SAAS,EAAE;YACnB,OAAO,IAAI,CAAC,oBAAoB,CAAC,KAAK,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;SAC1D;QAED,OAAO,IAAI,CAAC,oBAAoB,CAAC,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;IACrD,CAAC;IAEM,+CAAkB,GAAzB,UAA0B,KAAiB,EAAE,MAA6C;QACzF,IAAI,MAAM,GAAG,MAAM,CAAC,mBAAmB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAE3D,IAAI,IAAI,CAAC,oBAAoB,EAAE;YAC9B,MAAM,GAAG,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC,aAAa,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;SAC5D;QAED,OAAO,IAAI,qBAAS,CACnB,MAAM,CAAC,wBAAwB,EAC/B,MAAM,CAAC,oBAAoB,GAAG,IAAI,CAAC,YAAY,EAC/C,MAAM,CAAC,kBAAkB,EACzB,MAAM,CAAC,cAAc,GAAG,IAAI,CAAC,YAAY,CACzC,CAAC;IACH,CAAC;IAED;;OAEG;IACW,sDAAmC,GAAjD,UAAkD,KAA2B,EAAE,eAAuB;QACrG,IAAI,GAAG,GAAqC,EAAE,CAAC;QAE/C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YACjD,IAAM,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YAE1B,IAAI,QAAQ,CAAC,MAAM,EAAE;gBACpB,SAAS;aACT;YAED,GAAG,CAAC,IAAI,CAAC,6BAAa,CAAC,MAAM,CAAC,IAAI,aAAK,CACtC,eAAe,GAAG,CAAC,EAAE,QAAQ,CAAC,gBAAgB,GAAG,CAAC,EAClD,eAAe,GAAG,CAAC,EAAE,QAAQ,CAAC,gBAAgB,GAAG,QAAQ,CAAC,gBAAgB,GAAG,CAAC,CAC9E,CAAC,CAAC,CAAC;SACJ;QAED,OAAO,GAAG,CAAC;IACZ,CAAC;IAED;;OAEG;IACW,mDAAgC,GAA9C,UAA+C,KAA2B,EAAE,eAAuB;QAClG,IAAI,GAAG,GAAqC,EAAE,CAAC;QAE/C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YACjD,IAAM,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YAE1B,IAAI,QAAQ,CAAC,MAAM,EAAE;gBACpB,SAAS;aACT;YAED,GAAG,CAAC,IAAI,CAAC,6BAAa,CAAC,MAAM,CAAC,IAAI,mBAAQ,CAAC,eAAe,GAAG,CAAC,EAAE,QAAQ,CAAC,gBAAgB,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,UAAU,GAAG,GAAG,CAAC,CAAC,CAAC;SAC5H;QAED,OAAO,GAAG,CAAC;IACZ,CAAC;IAED,6DAA6D;IAC9C,oCAAiB,GAAhC,UAAiC,oBAA4B,EAAE,OAAe,EAAE,KAAc,EAAE,UAAkB;QACjH,IAAI,KAAK,EAAE;YACV,OAAO,oBAAoB,GAAG,CAAC,OAAO,GAAG,CAAC,oBAAoB,GAAG,OAAO,CAAC,CAAC,CAAC;SAC3E;QACD,OAAO,oBAAoB,GAAG,UAAU,CAAC;IAC1C,CAAC;IAED;;OAEG;IACW,2CAAwB,GAAtC,UAAuC,KAAmB,EAAE,KAAwB,EAAE,eAAuB,EAAE,OAAe;QAC7H,IAAI,gBAAgB,GAAG,MAAM,CAAC,SAAS,CAAC;QACxC,IAAI,CAAS,CAAC;QACd,IAAI,IAAY,CAAC;QAEjB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YACjD,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE;gBACpB,SAAS;aACT;YAED,IAAM,WAAW,GAAG,KAAK,CAAC,cAAc,CAAC,eAAe,GAAG,CAAC,CAAC,CAAC;YAE9D,IAAI,oBAAoB,GAAG,CAAC,CAAC;YAC7B,KAAK,IAAI,GAAC,GAAG,CAAC,EAAE,MAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,gBAAgB,EAAE,oBAAoB,GAAG,gBAAgB,IAAI,GAAC,GAAG,MAAI,EAAE,GAAC,EAAE,EAAE;gBAC3G,oBAAoB,GAAG,kBAAkB,CAAC,iBAAiB,CAAC,oBAAoB,EAAE,OAAO,EAAE,WAAW,CAAC,UAAU,CAAC,GAAC,CAAC,KAAK,mBAAQ,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;aAC1I;YAED,IAAI,oBAAoB,GAAG,gBAAgB,EAAE;gBAC5C,gBAAgB,GAAG,oBAAoB,CAAC;aACxC;SACD;QAED,gBAAgB,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,GAAG,OAAO,CAAC,GAAG,OAAO,CAAC;QAEpE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YACjD,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE;gBACpB,SAAS;aACT;YAED,IAAM,WAAW,GAAG,KAAK,CAAC,cAAc,CAAC,eAAe,GAAG,CAAC,CAAC,CAAC;YAE9D,IAAI,oBAAoB,GAAG,CAAC,CAAC;YAC7B,KAAK,CAAC,GAAG,CAAC,EAAE,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,gBAAgB,EAAE,oBAAoB,GAAG,gBAAgB,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE;gBACvG,oBAAoB,GAAG,kBAAkB,CAAC,iBAAiB,CAAC,oBAAoB,EAAE,OAAO,EAAE,WAAW,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,mBAAQ,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;aAC1I;YAED,IAAI,oBAAoB,GAAG,gBAAgB,EAAE;gBAC5C,KAAK,CAAC,CAAC,CAAC,CAAC,gBAAgB,GAAG,CAAC,GAAG,CAAC,CAAC;aAClC;iBAAM;gBACN,KAAK,CAAC,CAAC,CAAC,CAAC,gBAAgB,GAAG,CAAC,CAAC;aAC9B;SACD;IACF,CAAC;IACF,yBAAC;AAAD,CAAC,AAlYD,IAkYC;AAlYY,gDAAkB","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as strings from 'vs/base/common/strings';\nimport { EditOperation } from 'vs/editor/common/core/editOperation';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { Selection } from 'vs/editor/common/core/selection';\nimport * as editorCommon from 'vs/editor/common/editorCommon';\nimport { IIdentifiedSingleEditOperation, ITextModel } from 'vs/editor/common/model';\nimport { LanguageConfigurationRegistry } from 'vs/editor/common/modes/languageConfigurationRegistry';\nimport { BlockCommentCommand } from 'vs/editor/contrib/comment/blockCommentCommand';\n\nexport interface IInsertionPoint {\n\tignore: boolean;\n\tcommentStrOffset: number;\n}\n\nexport interface ILinePreflightData {\n\tignore: boolean;\n\tcommentStr: string;\n\tcommentStrOffset: number;\n\tcommentStrLength: number;\n}\n\nexport interface IPreflightDataSupported {\n\tsupported: true;\n\tshouldRemoveComments: boolean;\n\tlines: ILinePreflightData[];\n}\nexport interface IPreflightDataUnsupported {\n\tsupported: false;\n}\nexport type IPreflightData = IPreflightDataSupported | IPreflightDataUnsupported;\n\nexport interface ISimpleModel {\n\tgetLineContent(lineNumber: number): string;\n}\n\nexport const enum Type {\n\tToggle = 0,\n\tForceAdd = 1,\n\tForceRemove = 2\n}\n\nexport class LineCommentCommand implements editorCommon.ICommand {\n\n\tprivate readonly _selection: Selection;\n\tprivate _selectionId: string;\n\tprivate _deltaColumn: number;\n\tprivate _moveEndPositionDown: boolean;\n\tprivate readonly _tabSize: number;\n\tprivate readonly _type: Type;\n\n\tconstructor(selection: Selection, tabSize: number, type: Type) {\n\t\tthis._selection = selection;\n\t\tthis._tabSize = tabSize;\n\t\tthis._type = type;\n\t\tthis._deltaColumn = 0;\n\t}\n\n\t/**\n\t * Do an initial pass over the lines and gather info about the line comment string.\n\t * Returns null if any of the lines doesn't support a line comment string.\n\t */\n\tpublic static _gatherPreflightCommentStrings(model: ITextModel, startLineNumber: number, endLineNumber: number): ILinePreflightData[] | null {\n\n\t\tmodel.tokenizeIfCheap(startLineNumber);\n\t\tconst languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n\n\t\tconst config = LanguageConfigurationRegistry.getComments(languageId);\n\t\tconst commentStr = (config ? config.lineCommentToken : null);\n\t\tif (!commentStr) {\n\t\t\t// Mode does not support line comments\n\t\t\treturn null;\n\t\t}\n\n\t\tlet lines: ILinePreflightData[] = [];\n\t\tfor (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n\t\t\tlines[i] = {\n\t\t\t\tignore: false,\n\t\t\t\tcommentStr: commentStr,\n\t\t\t\tcommentStrOffset: 0,\n\t\t\t\tcommentStrLength: commentStr.length\n\t\t\t};\n\t\t}\n\n\t\treturn lines;\n\t}\n\n\t/**\n\t * Analyze lines and decide which lines are relevant and what the toggle should do.\n\t * Also, build up several offsets and lengths useful in the generation of editor operations.\n\t */\n\tpublic static _analyzeLines(type: Type, model: ISimpleModel, lines: ILinePreflightData[], startLineNumber: number): IPreflightData {\n\t\tlet onlyWhitespaceLines = true;\n\n\t\tlet shouldRemoveComments: boolean;\n\t\tif (type === Type.Toggle) {\n\t\t\tshouldRemoveComments = true;\n\t\t} else if (type === Type.ForceAdd) {\n\t\t\tshouldRemoveComments = false;\n\t\t} else {\n\t\t\tshouldRemoveComments = true;\n\t\t}\n\n\t\tfor (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n\t\t\tconst lineData = lines[i];\n\t\t\tconst lineNumber = startLineNumber + i;\n\n\t\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\t\tconst lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n\n\t\t\tif (lineContentStartOffset === -1) {\n\t\t\t\t// Empty or whitespace only line\n\t\t\t\tif (type === Type.Toggle) {\n\t\t\t\t\tlineData.ignore = true;\n\t\t\t\t} else if (type === Type.ForceAdd) {\n\t\t\t\t\tlineData.ignore = true;\n\t\t\t\t} else {\n\t\t\t\t\tlineData.ignore = true;\n\t\t\t\t}\n\t\t\t\tlineData.commentStrOffset = lineContent.length;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tonlyWhitespaceLines = false;\n\t\t\tlineData.ignore = false;\n\t\t\tlineData.commentStrOffset = lineContentStartOffset;\n\n\t\t\tif (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\n\t\t\t\tif (type === Type.Toggle) {\n\t\t\t\t\t// Every line so far has been a line comment, but this one is not\n\t\t\t\t\tshouldRemoveComments = false;\n\t\t\t\t} else if (type === Type.ForceAdd) {\n\t\t\t\t\t// Will not happen\n\t\t\t\t} else {\n\t\t\t\t\tlineData.ignore = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (shouldRemoveComments) {\n\t\t\t\tconst commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n\t\t\t\tif (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === CharCode.Space) {\n\t\t\t\t\tlineData.commentStrLength += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (type === Type.Toggle && onlyWhitespaceLines) {\n\t\t\t// For only whitespace lines, we insert comments\n\t\t\tshouldRemoveComments = false;\n\n\t\t\t// Also, no longer ignore them\n\t\t\tfor (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n\t\t\t\tlines[i].ignore = false;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsupported: true,\n\t\t\tshouldRemoveComments: shouldRemoveComments,\n\t\t\tlines: lines\n\t\t};\n\t}\n\n\t/**\n\t * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\n\t */\n\tpublic static _gatherPreflightData(type: Type, model: ITextModel, startLineNumber: number, endLineNumber: number): IPreflightData {\n\t\tconst lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber);\n\t\tif (lines === null) {\n\t\t\treturn {\n\t\t\t\tsupported: false\n\t\t\t};\n\t\t}\n\n\t\treturn LineCommentCommand._analyzeLines(type, model, lines, startLineNumber);\n\t}\n\n\t/**\n\t * Given a successful analysis, execute either insert line comments, either remove line comments\n\t */\n\tprivate _executeLineComments(model: ISimpleModel, builder: editorCommon.IEditOperationBuilder, data: IPreflightDataSupported, s: Selection): void {\n\n\t\tlet ops: IIdentifiedSingleEditOperation[];\n\n\t\tif (data.shouldRemoveComments) {\n\t\t\tops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n\t\t} else {\n\t\t\tLineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);\n\t\t\tops = LineCommentCommand._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n\t\t}\n\n\t\tconst cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\n\n\t\tfor (let i = 0, len = ops.length; i < len; i++) {\n\t\t\tbuilder.addEditOperation(ops[i].range, ops[i].text);\n\t\t\tif (ops[i].range.isEmpty() && ops[i].range.getStartPosition().equals(cursorPosition)) {\n\t\t\t\tconst lineContent = model.getLineContent(cursorPosition.lineNumber);\n\t\t\t\tif (lineContent.length + 1 === cursorPosition.column) {\n\t\t\t\t\tthis._deltaColumn = (ops[i].text || '').length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._selectionId = builder.trackSelection(s);\n\t}\n\n\tprivate _attemptRemoveBlockComment(model: ITextModel, s: Selection, startToken: string, endToken: string): IIdentifiedSingleEditOperation[] | null {\n\t\tlet startLineNumber = s.startLineNumber;\n\t\tlet endLineNumber = s.endLineNumber;\n\n\t\tlet startTokenAllowedBeforeColumn = endToken.length + Math.max(\n\t\t\tmodel.getLineFirstNonWhitespaceColumn(s.startLineNumber),\n\t\t\ts.startColumn\n\t\t);\n\n\t\tlet startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n\t\tlet endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n\n\t\tif (startTokenIndex !== -1 && endTokenIndex === -1) {\n\t\t\tendTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n\t\t\tendLineNumber = startLineNumber;\n\t\t}\n\n\t\tif (startTokenIndex === -1 && endTokenIndex !== -1) {\n\t\t\tstartTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n\t\t\tstartLineNumber = endLineNumber;\n\t\t}\n\n\t\tif (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n\t\t\tstartTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n\t\t\tif (startTokenIndex !== -1) {\n\t\t\t\tendTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n\t\t\t}\n\t\t}\n\n\t\t// We have to adjust to possible inner white space.\n\t\t// For Space after startToken, add Space to startToken - range math will work out.\n\t\tif (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === CharCode.Space) {\n\t\t\tstartToken += ' ';\n\t\t}\n\n\t\t// For Space before endToken, add Space before endToken and shift index one left.\n\t\tif (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === CharCode.Space) {\n\t\t\tendToken = ' ' + endToken;\n\t\t\tendTokenIndex -= 1;\n\t\t}\n\n\t\tif (startTokenIndex !== -1 && endTokenIndex !== -1) {\n\t\t\treturn BlockCommentCommand._createRemoveBlockCommentOperations(\n\t\t\t\tnew Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken\n\t\t\t);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Given an unsuccessful analysis, delegate to the block comment command\n\t */\n\tprivate _executeBlockComment(model: ITextModel, builder: editorCommon.IEditOperationBuilder, s: Selection): void {\n\t\tmodel.tokenizeIfCheap(s.startLineNumber);\n\t\tlet languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n\t\tlet config = LanguageConfigurationRegistry.getComments(languageId);\n\t\tif (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n\t\t\t// Mode does not support block comments\n\t\t\treturn;\n\t\t}\n\n\t\tconst startToken = config.blockCommentStartToken;\n\t\tconst endToken = config.blockCommentEndToken;\n\n\t\tlet ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n\t\tif (!ops) {\n\t\t\tif (s.isEmpty()) {\n\t\t\t\tconst lineContent = model.getLineContent(s.startLineNumber);\n\t\t\t\tlet firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n\t\t\t\tif (firstNonWhitespaceIndex === -1) {\n\t\t\t\t\t// Line is empty or contains only whitespace\n\t\t\t\t\tfirstNonWhitespaceIndex = lineContent.length;\n\t\t\t\t}\n\t\t\t\tops = BlockCommentCommand._createAddBlockCommentOperations(\n\t\t\t\t\tnew Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tops = BlockCommentCommand._createAddBlockCommentOperations(\n\t\t\t\t\tnew Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (ops.length === 1) {\n\t\t\t\t// Leave cursor after token and Space\n\t\t\t\tthis._deltaColumn = startToken.length + 1;\n\t\t\t}\n\t\t}\n\t\tthis._selectionId = builder.trackSelection(s);\n\t\tfor (const op of ops) {\n\t\t\tbuilder.addEditOperation(op.range, op.text);\n\t\t}\n\t}\n\n\tpublic getEditOperations(model: ITextModel, builder: editorCommon.IEditOperationBuilder): void {\n\n\t\tlet s = this._selection;\n\t\tthis._moveEndPositionDown = false;\n\n\t\tif (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n\t\t\tthis._moveEndPositionDown = true;\n\t\t\ts = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n\t\t}\n\n\t\tconst data = LineCommentCommand._gatherPreflightData(this._type, model, s.startLineNumber, s.endLineNumber);\n\t\tif (data.supported) {\n\t\t\treturn this._executeLineComments(model, builder, data, s);\n\t\t}\n\n\t\treturn this._executeBlockComment(model, builder, s);\n\t}\n\n\tpublic computeCursorState(model: ITextModel, helper: editorCommon.ICursorStateComputerData): Selection {\n\t\tlet result = helper.getTrackedSelection(this._selectionId);\n\n\t\tif (this._moveEndPositionDown) {\n\t\t\tresult = result.setEndPosition(result.endLineNumber + 1, 1);\n\t\t}\n\n\t\treturn new Selection(\n\t\t\tresult.selectionStartLineNumber,\n\t\t\tresult.selectionStartColumn + this._deltaColumn,\n\t\t\tresult.positionLineNumber,\n\t\t\tresult.positionColumn + this._deltaColumn\n\t\t);\n\t}\n\n\t/**\n\t * Generate edit operations in the remove line comment case\n\t */\n\tpublic static _createRemoveLineCommentsOperations(lines: ILinePreflightData[], startLineNumber: number): IIdentifiedSingleEditOperation[] {\n\t\tlet res: IIdentifiedSingleEditOperation[] = [];\n\n\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\tconst lineData = lines[i];\n\n\t\t\tif (lineData.ignore) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tres.push(EditOperation.delete(new Range(\n\t\t\t\tstartLineNumber + i, lineData.commentStrOffset + 1,\n\t\t\t\tstartLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1\n\t\t\t)));\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * Generate edit operations in the add line comment case\n\t */\n\tpublic static _createAddLineCommentsOperations(lines: ILinePreflightData[], startLineNumber: number): IIdentifiedSingleEditOperation[] {\n\t\tlet res: IIdentifiedSingleEditOperation[] = [];\n\n\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\tconst lineData = lines[i];\n\n\t\t\tif (lineData.ignore) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tres.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + ' '));\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t// TODO@Alex -> duplicated in characterHardWrappingLineMapper\n\tprivate static nextVisibleColumn(currentVisibleColumn: number, tabSize: number, isTab: boolean, columnSize: number): number {\n\t\tif (isTab) {\n\t\t\treturn currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));\n\t\t}\n\t\treturn currentVisibleColumn + columnSize;\n\t}\n\n\t/**\n\t * Adjust insertion points to have them vertically aligned in the add line comment case\n\t */\n\tpublic static _normalizeInsertionPoint(model: ISimpleModel, lines: IInsertionPoint[], startLineNumber: number, tabSize: number): void {\n\t\tlet minVisibleColumn = Number.MAX_VALUE;\n\t\tlet j: number;\n\t\tlet lenJ: number;\n\n\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\tif (lines[i].ignore) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst lineContent = model.getLineContent(startLineNumber + i);\n\n\t\t\tlet currentVisibleColumn = 0;\n\t\t\tfor (let j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n\t\t\t\tcurrentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === CharCode.Tab, 1);\n\t\t\t}\n\n\t\t\tif (currentVisibleColumn < minVisibleColumn) {\n\t\t\t\tminVisibleColumn = currentVisibleColumn;\n\t\t\t}\n\t\t}\n\n\t\tminVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;\n\n\t\tfor (let i = 0, len = lines.length; i < len; i++) {\n\t\t\tif (lines[i].ignore) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst lineContent = model.getLineContent(startLineNumber + i);\n\n\t\t\tlet currentVisibleColumn = 0;\n\t\t\tfor (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n\t\t\t\tcurrentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === CharCode.Tab, 1);\n\t\t\t}\n\n\t\t\tif (currentVisibleColumn > minVisibleColumn) {\n\t\t\t\tlines[i].commentStrOffset = j - 1;\n\t\t\t} else {\n\t\t\t\tlines[i].commentStrOffset = j;\n\t\t\t}\n\t\t}\n\t}\n}\n"]}]}