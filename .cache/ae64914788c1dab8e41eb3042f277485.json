{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/workspaces/electron-main/workspacesMainService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/workspaces/electron-main/workspacesMainService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/platform/workspaces/common/workspaces\", \"vs/platform/environment/common/environment\", \"vs/base/common/path\", \"vs/base/node/pfs\", \"fs\", \"vs/base/common/platform\", \"vs/base/node/extfs\", \"vs/base/common/event\", \"vs/platform/log/common/log\", \"crypto\", \"vs/base/common/json\", \"vs/platform/workspace/common/workspace\", \"vs/base/common/network\", \"vs/base/common/lifecycle\", \"vs/base/common/resources\"], function (require, exports, workspaces_1, environment_1, path_1, pfs_1, fs_1, platform_1, extfs_1, event_1, log_1, crypto_1, json, workspace_1, network_1, lifecycle_1, resources_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let WorkspacesMainService = class WorkspacesMainService extends lifecycle_1.Disposable {\n        constructor(environmentService, logService) {\n            super();\n            this.environmentService = environmentService;\n            this.logService = logService;\n            this._onUntitledWorkspaceDeleted = this._register(new event_1.Emitter());\n            this.untitledWorkspacesHome = environmentService.untitledWorkspacesHome;\n        }\n        get onUntitledWorkspaceDeleted() { return this._onUntitledWorkspaceDeleted.event; }\n        resolveLocalWorkspaceSync(uri) {\n            if (!this.isWorkspacePath(uri)) {\n                return null; // does not look like a valid workspace config file\n            }\n            if (uri.scheme !== network_1.Schemas.file) {\n                return null;\n            }\n            let contents;\n            try {\n                contents = fs_1.readFileSync(uri.fsPath, 'utf8');\n            }\n            catch (error) {\n                return null; // invalid workspace\n            }\n            return this.doResolveWorkspace(uri, contents);\n        }\n        isWorkspacePath(uri) {\n            return this.isInsideWorkspacesHome(uri) || workspaces_1.hasWorkspaceFileExtension(uri.path);\n        }\n        doResolveWorkspace(path, contents) {\n            try {\n                const workspace = this.doParseStoredWorkspace(path, contents);\n                const workspaceIdentifier = getWorkspaceIdentifier(path);\n                return {\n                    id: workspaceIdentifier.id,\n                    configPath: workspaceIdentifier.configPath,\n                    folders: workspace_1.toWorkspaceFolders(workspace.folders, resources_1.dirname(path)),\n                    remoteAuthority: workspace.remoteAuthority\n                };\n            }\n            catch (error) {\n                this.logService.warn(error.toString());\n            }\n            return null;\n        }\n        doParseStoredWorkspace(path, contents) {\n            // Parse workspace file\n            let storedWorkspace = json.parse(contents); // use fault tolerant parser\n            // Filter out folders which do not have a path or uri set\n            if (Array.isArray(storedWorkspace.folders)) {\n                storedWorkspace.folders = storedWorkspace.folders.filter(folder => workspaces_1.isStoredWorkspaceFolder(folder));\n            }\n            // Validate\n            if (!Array.isArray(storedWorkspace.folders)) {\n                throw new Error(`${path.toString()} looks like an invalid workspace file.`);\n            }\n            return storedWorkspace;\n        }\n        isInsideWorkspacesHome(path) {\n            return resources_1.isEqualOrParent(path, this.environmentService.untitledWorkspacesHome);\n        }\n        createUntitledWorkspace(folders, remoteAuthority) {\n            const { workspace, storedWorkspace } = this.newUntitledWorkspace(folders, remoteAuthority);\n            const configPath = workspace.configPath.fsPath;\n            return pfs_1.mkdirp(path_1.dirname(configPath)).then(() => {\n                return pfs_1.writeFile(configPath, JSON.stringify(storedWorkspace, null, '\\t')).then(() => workspace);\n            });\n        }\n        createUntitledWorkspaceSync(folders, remoteAuthority) {\n            const { workspace, storedWorkspace } = this.newUntitledWorkspace(folders, remoteAuthority);\n            const configPath = workspace.configPath.fsPath;\n            const configPathDir = path_1.dirname(configPath);\n            if (!fs_1.existsSync(configPathDir)) {\n                const configPathDirDir = path_1.dirname(configPathDir);\n                if (!fs_1.existsSync(configPathDirDir)) {\n                    fs_1.mkdirSync(configPathDirDir);\n                }\n                fs_1.mkdirSync(configPathDir);\n            }\n            extfs_1.writeFileAndFlushSync(configPath, JSON.stringify(storedWorkspace, null, '\\t'));\n            return workspace;\n        }\n        newUntitledWorkspace(folders = [], remoteAuthority) {\n            const randomId = (Date.now() + Math.round(Math.random() * 1000)).toString();\n            const untitledWorkspaceConfigFolder = resources_1.joinPath(this.untitledWorkspacesHome, randomId);\n            const untitledWorkspaceConfigPath = resources_1.joinPath(untitledWorkspaceConfigFolder, workspaces_1.UNTITLED_WORKSPACE_NAME);\n            const storedWorkspaceFolder = [];\n            for (const folder of folders) {\n                storedWorkspaceFolder.push(workspaces_1.getStoredWorkspaceFolder(folder.uri, folder.name, untitledWorkspaceConfigFolder));\n            }\n            return {\n                workspace: getWorkspaceIdentifier(untitledWorkspaceConfigPath),\n                storedWorkspace: { folders: storedWorkspaceFolder, remoteAuthority }\n            };\n        }\n        getWorkspaceIdentifier(configPath) {\n            return Promise.resolve(getWorkspaceIdentifier(configPath));\n        }\n        isUntitledWorkspace(workspace) {\n            return this.isInsideWorkspacesHome(workspace.configPath);\n        }\n        deleteUntitledWorkspaceSync(workspace) {\n            if (!this.isUntitledWorkspace(workspace)) {\n                return; // only supported for untitled workspaces\n            }\n            // Delete from disk\n            this.doDeleteUntitledWorkspaceSync(workspace);\n            // Event\n            this._onUntitledWorkspaceDeleted.fire(workspace);\n        }\n        deleteUntitledWorkspace(workspace) {\n            this.deleteUntitledWorkspaceSync(workspace);\n            return Promise.resolve();\n        }\n        doDeleteUntitledWorkspaceSync(workspace) {\n            const configPath = resources_1.originalFSPath(workspace.configPath);\n            try {\n                // Delete Workspace\n                extfs_1.delSync(path_1.dirname(configPath));\n                // Mark Workspace Storage to be deleted\n                const workspaceStoragePath = path_1.join(this.environmentService.workspaceStorageHome, workspace.id);\n                if (fs_1.existsSync(workspaceStoragePath)) {\n                    fs_1.writeFileSync(path_1.join(workspaceStoragePath, 'obsolete'), '');\n                }\n            }\n            catch (error) {\n                this.logService.warn(`Unable to delete untitled workspace ${configPath} (${error}).`);\n            }\n        }\n        getUntitledWorkspacesSync() {\n            let untitledWorkspaces = [];\n            try {\n                const untitledWorkspacePaths = extfs_1.readdirSync(this.untitledWorkspacesHome.fsPath).map(folder => resources_1.joinPath(this.untitledWorkspacesHome, folder, workspaces_1.UNTITLED_WORKSPACE_NAME));\n                for (const untitledWorkspacePath of untitledWorkspacePaths) {\n                    const workspace = getWorkspaceIdentifier(untitledWorkspacePath);\n                    const resolvedWorkspace = this.resolveLocalWorkspaceSync(untitledWorkspacePath);\n                    if (!resolvedWorkspace) {\n                        this.doDeleteUntitledWorkspaceSync(workspace);\n                    }\n                    else {\n                        untitledWorkspaces.push({ workspace, remoteAuthority: resolvedWorkspace.remoteAuthority });\n                    }\n                }\n            }\n            catch (error) {\n                if (error && error.code !== 'ENOENT') {\n                    this.logService.warn(`Unable to read folders in ${this.untitledWorkspacesHome} (${error}).`);\n                }\n            }\n            return untitledWorkspaces;\n        }\n    };\n    WorkspacesMainService = __decorate([\n        __param(0, environment_1.IEnvironmentService),\n        __param(1, log_1.ILogService)\n    ], WorkspacesMainService);\n    exports.WorkspacesMainService = WorkspacesMainService;\n    function getWorkspaceId(configPath) {\n        let workspaceConfigPath = configPath.scheme === network_1.Schemas.file ? resources_1.originalFSPath(configPath) : configPath.toString();\n        if (!platform_1.isLinux) {\n            workspaceConfigPath = workspaceConfigPath.toLowerCase(); // sanitize for platform file system\n        }\n        return crypto_1.createHash('md5').update(workspaceConfigPath).digest('hex');\n    }\n    function getWorkspaceIdentifier(configPath) {\n        return {\n            configPath,\n            id: getWorkspaceId(configPath)\n        };\n    }\n    exports.getWorkspaceIdentifier = getWorkspaceIdentifier;\n});\n",null]}