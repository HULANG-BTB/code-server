{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/indexTreeModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/indexTreeModel.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tree_1 = require(\"vs/base/browser/ui/tree/tree\");\nvar arrays_1 = require(\"vs/base/common/arrays\");\nvar event_1 = require(\"vs/base/common/event\");\nvar iterator_1 = require(\"vs/base/common/iterator\");\nfunction isFilterResult(obj) {\n    return typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\n}\nexports.isFilterResult = isFilterResult;\nfunction getVisibleState(visibility) {\n    switch (visibility) {\n        case true: return tree_1.TreeVisibility.Visible;\n        case false: return tree_1.TreeVisibility.Hidden;\n        default: return visibility;\n    }\n}\nexports.getVisibleState = getVisibleState;\nfunction treeNodeToElement(node) {\n    var element = node.element, collapsed = node.collapsed;\n    var children = iterator_1.Iterator.map(iterator_1.Iterator.fromArray(node.children), treeNodeToElement);\n    return { element: element, children: children, collapsed: collapsed };\n}\nvar IndexTreeModel = /** @class */ (function () {\n    function IndexTreeModel(list, rootElement, options) {\n        if (options === void 0) { options = {}; }\n        this.list = list;\n        this.rootRef = [];\n        this.eventBufferer = new event_1.EventBufferer();\n        this._onDidChangeCollapseState = new event_1.Emitter();\n        this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\n        this._onDidChangeRenderNodeCount = new event_1.Emitter();\n        this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\n        this._onDidSplice = new event_1.Emitter();\n        this.onDidSplice = this._onDidSplice.event;\n        this.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\n        this.filter = options.filter;\n        this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n        this.root = {\n            parent: undefined,\n            element: rootElement,\n            children: [],\n            depth: 0,\n            visibleChildrenCount: 0,\n            visibleChildIndex: -1,\n            collapsible: false,\n            collapsed: false,\n            renderNodeCount: 0,\n            visible: true,\n            filterData: undefined\n        };\n    }\n    IndexTreeModel.prototype.splice = function (location, deleteCount, toInsert, onDidCreateNode, onDidDeleteNode) {\n        var _this = this;\n        var _a;\n        if (location.length === 0) {\n            throw new Error('Invalid tree location');\n        }\n        var _b = this.getParentNodeWithListIndex(location), parentNode = _b.parentNode, listIndex = _b.listIndex, revealed = _b.revealed, visible = _b.visible;\n        var treeListElementsToInsert = [];\n        var nodesToInsertIterator = iterator_1.Iterator.map(iterator_1.Iterator.from(toInsert), function (el) { return _this.createTreeNode(el, parentNode, parentNode.visible ? tree_1.TreeVisibility.Visible : tree_1.TreeVisibility.Hidden, revealed, treeListElementsToInsert, onDidCreateNode); });\n        var lastIndex = location[location.length - 1];\n        // figure out what's the visible child start index right before the\n        // splice point\n        var visibleChildStartIndex = 0;\n        for (var i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\n            var child = parentNode.children[i];\n            if (child.visible) {\n                visibleChildStartIndex = child.visibleChildIndex;\n                break;\n            }\n        }\n        var nodesToInsert = [];\n        var insertedVisibleChildrenCount = 0;\n        var renderNodeCount = 0;\n        iterator_1.Iterator.forEach(nodesToInsertIterator, function (child) {\n            nodesToInsert.push(child);\n            renderNodeCount += child.renderNodeCount;\n            if (child.visible) {\n                child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\n            }\n        });\n        var deletedNodes = (_a = parentNode.children).splice.apply(_a, [lastIndex, deleteCount].concat(nodesToInsert));\n        // figure out what is the count of deleted visible children\n        var deletedVisibleChildrenCount = 0;\n        for (var _i = 0, deletedNodes_1 = deletedNodes; _i < deletedNodes_1.length; _i++) {\n            var child = deletedNodes_1[_i];\n            if (child.visible) {\n                deletedVisibleChildrenCount++;\n            }\n        }\n        // and adjust for all visible children after the splice point\n        if (deletedVisibleChildrenCount !== 0) {\n            for (var i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {\n                var child = parentNode.children[i];\n                if (child.visible) {\n                    child.visibleChildIndex -= deletedVisibleChildrenCount;\n                }\n            }\n        }\n        // update parent's visible children count\n        parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\n        if (revealed && visible) {\n            var visibleDeleteCount = deletedNodes.reduce(function (r, node) { return r + node.renderNodeCount; }, 0);\n            this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\n            this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\n        }\n        if (deletedNodes.length > 0 && onDidDeleteNode) {\n            var visit_1 = function (node) {\n                onDidDeleteNode(node);\n                node.children.forEach(visit_1);\n            };\n            deletedNodes.forEach(visit_1);\n        }\n        var result = iterator_1.Iterator.map(iterator_1.Iterator.fromArray(deletedNodes), treeNodeToElement);\n        this._onDidSplice.fire({ insertedNodes: nodesToInsert, deletedNodes: deletedNodes });\n        return result;\n    };\n    IndexTreeModel.prototype.rerender = function (location) {\n        if (location.length === 0) {\n            throw new Error('Invalid tree location');\n        }\n        var _a = this.getTreeNodeWithListIndex(location), node = _a.node, listIndex = _a.listIndex, revealed = _a.revealed;\n        if (revealed) {\n            this.list.splice(listIndex, 1, [node]);\n        }\n    };\n    IndexTreeModel.prototype.getListIndex = function (location) {\n        var _a = this.getTreeNodeWithListIndex(location), listIndex = _a.listIndex, visible = _a.visible, revealed = _a.revealed;\n        return visible && revealed ? listIndex : -1;\n    };\n    IndexTreeModel.prototype.getListRenderCount = function (location) {\n        return this.getTreeNode(location).renderNodeCount;\n    };\n    IndexTreeModel.prototype.isCollapsible = function (location) {\n        return this.getTreeNode(location).collapsible;\n    };\n    IndexTreeModel.prototype.isCollapsed = function (location) {\n        return this.getTreeNode(location).collapsed;\n    };\n    IndexTreeModel.prototype.setCollapsed = function (location, collapsed, recursive) {\n        var _this = this;\n        var node = this.getTreeNode(location);\n        if (typeof collapsed === 'undefined') {\n            collapsed = !node.collapsed;\n        }\n        return this.eventBufferer.bufferEvents(function () { return _this._setCollapsed(location, collapsed, recursive); });\n    };\n    IndexTreeModel.prototype._setCollapsed = function (location, collapsed, recursive) {\n        var _a = this.getTreeNodeWithListIndex(location), node = _a.node, listIndex = _a.listIndex, revealed = _a.revealed;\n        var result = this._setListNodeCollapsed(node, listIndex, revealed, collapsed, recursive || false);\n        if (this.autoExpandSingleChildren && !collapsed && !recursive) {\n            var onlyVisibleChildIndex = -1;\n            for (var i = 0; i < node.children.length; i++) {\n                var child = node.children[i];\n                if (child.visible) {\n                    if (onlyVisibleChildIndex > -1) {\n                        onlyVisibleChildIndex = -1;\n                        break;\n                    }\n                    else {\n                        onlyVisibleChildIndex = i;\n                    }\n                }\n            }\n            if (onlyVisibleChildIndex > -1) {\n                this._setCollapsed(location.concat([onlyVisibleChildIndex]), false, false);\n            }\n        }\n        return result;\n    };\n    IndexTreeModel.prototype._setListNodeCollapsed = function (node, listIndex, revealed, collapsed, recursive) {\n        var result = this._setNodeCollapsed(node, collapsed, recursive, false);\n        if (!revealed || !node.visible) {\n            return result;\n        }\n        var previousRenderNodeCount = node.renderNodeCount;\n        var toInsert = this.updateNodeAfterCollapseChange(node);\n        var deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\n        this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\n        return result;\n    };\n    IndexTreeModel.prototype._setNodeCollapsed = function (node, collapsed, recursive, deep) {\n        var result = node.collapsible && node.collapsed !== collapsed;\n        if (node.collapsible) {\n            node.collapsed = collapsed;\n            if (result) {\n                this._onDidChangeCollapseState.fire({ node: node, deep: deep });\n            }\n        }\n        if (recursive) {\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                var child = _a[_i];\n                result = this._setNodeCollapsed(child, collapsed, true, true) || result;\n            }\n        }\n        return result;\n    };\n    IndexTreeModel.prototype.expandTo = function (location) {\n        var _this = this;\n        this.eventBufferer.bufferEvents(function () {\n            var node = _this.getTreeNode(location);\n            while (node.parent) {\n                node = node.parent;\n                location = location.slice(0, location.length - 1);\n                if (node.collapsed) {\n                    _this._setCollapsed(location, false);\n                }\n            }\n        });\n    };\n    IndexTreeModel.prototype.refilter = function () {\n        var previousRenderNodeCount = this.root.renderNodeCount;\n        var toInsert = this.updateNodeAfterFilterChange(this.root);\n        this.list.splice(0, previousRenderNodeCount, toInsert);\n    };\n    IndexTreeModel.prototype.createTreeNode = function (treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {\n        var _this = this;\n        var node = {\n            parent: parent,\n            element: treeElement.element,\n            children: [],\n            depth: parent.depth + 1,\n            visibleChildrenCount: 0,\n            visibleChildIndex: -1,\n            collapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : (typeof treeElement.collapsed !== 'undefined'),\n            collapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\n            renderNodeCount: 1,\n            visible: true,\n            filterData: undefined\n        };\n        var visibility = this._filterNode(node, parentVisibility);\n        if (revealed) {\n            treeListElements.push(node);\n        }\n        var childElements = iterator_1.Iterator.from(treeElement.children);\n        var childRevealed = revealed && visibility !== tree_1.TreeVisibility.Hidden && !node.collapsed;\n        var childNodes = iterator_1.Iterator.map(childElements, function (el) { return _this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode); });\n        var visibleChildrenCount = 0;\n        var renderNodeCount = 1;\n        iterator_1.Iterator.forEach(childNodes, function (child) {\n            node.children.push(child);\n            renderNodeCount += child.renderNodeCount;\n            if (child.visible) {\n                child.visibleChildIndex = visibleChildrenCount++;\n            }\n        });\n        node.collapsible = node.collapsible || node.children.length > 0;\n        node.visibleChildrenCount = visibleChildrenCount;\n        node.visible = visibility === tree_1.TreeVisibility.Recurse ? visibleChildrenCount > 0 : (visibility === tree_1.TreeVisibility.Visible);\n        if (!node.visible) {\n            node.renderNodeCount = 0;\n            if (revealed) {\n                treeListElements.pop();\n            }\n        }\n        else if (!node.collapsed) {\n            node.renderNodeCount = renderNodeCount;\n        }\n        if (onDidCreateNode) {\n            onDidCreateNode(node);\n        }\n        return node;\n    };\n    IndexTreeModel.prototype.updateNodeAfterCollapseChange = function (node) {\n        var previousRenderNodeCount = node.renderNodeCount;\n        var result = [];\n        this._updateNodeAfterCollapseChange(node, result);\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n        return result;\n    };\n    IndexTreeModel.prototype._updateNodeAfterCollapseChange = function (node, result) {\n        if (node.visible === false) {\n            return 0;\n        }\n        result.push(node);\n        node.renderNodeCount = 1;\n        if (!node.collapsed) {\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                var child = _a[_i];\n                node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\n            }\n        }\n        this._onDidChangeRenderNodeCount.fire(node);\n        return node.renderNodeCount;\n    };\n    IndexTreeModel.prototype.updateNodeAfterFilterChange = function (node) {\n        var previousRenderNodeCount = node.renderNodeCount;\n        var result = [];\n        this._updateNodeAfterFilterChange(node, node.visible ? tree_1.TreeVisibility.Visible : tree_1.TreeVisibility.Hidden, result);\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n        return result;\n    };\n    IndexTreeModel.prototype._updateNodeAfterFilterChange = function (node, parentVisibility, result, revealed) {\n        if (revealed === void 0) { revealed = true; }\n        var visibility;\n        if (node !== this.root) {\n            visibility = this._filterNode(node, parentVisibility);\n            if (visibility === tree_1.TreeVisibility.Hidden) {\n                node.visible = false;\n                return false;\n            }\n            if (revealed) {\n                result.push(node);\n            }\n        }\n        var resultStartLength = result.length;\n        node.renderNodeCount = node === this.root ? 0 : 1;\n        var hasVisibleDescendants = false;\n        if (!node.collapsed || visibility !== tree_1.TreeVisibility.Hidden) {\n            var visibleChildIndex = 0;\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                var child = _a[_i];\n                hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;\n                if (child.visible) {\n                    child.visibleChildIndex = visibleChildIndex++;\n                }\n            }\n            node.visibleChildrenCount = visibleChildIndex;\n        }\n        else {\n            node.visibleChildrenCount = 0;\n        }\n        if (node !== this.root) {\n            node.visible = visibility === tree_1.TreeVisibility.Recurse ? hasVisibleDescendants : (visibility === tree_1.TreeVisibility.Visible);\n        }\n        if (!node.visible) {\n            node.renderNodeCount = 0;\n            if (revealed) {\n                result.pop();\n            }\n        }\n        else if (!node.collapsed) {\n            node.renderNodeCount += result.length - resultStartLength;\n        }\n        this._onDidChangeRenderNodeCount.fire(node);\n        return node.visible;\n    };\n    IndexTreeModel.prototype._updateAncestorsRenderNodeCount = function (node, diff) {\n        if (diff === 0) {\n            return;\n        }\n        while (node) {\n            node.renderNodeCount += diff;\n            this._onDidChangeRenderNodeCount.fire(node);\n            node = node.parent;\n        }\n    };\n    IndexTreeModel.prototype._filterNode = function (node, parentVisibility) {\n        var result = this.filter ? this.filter.filter(node.element, parentVisibility) : tree_1.TreeVisibility.Visible;\n        if (typeof result === 'boolean') {\n            node.filterData = undefined;\n            return result ? tree_1.TreeVisibility.Visible : tree_1.TreeVisibility.Hidden;\n        }\n        else if (isFilterResult(result)) {\n            node.filterData = result.data;\n            return getVisibleState(result.visibility);\n        }\n        else {\n            node.filterData = undefined;\n            return getVisibleState(result);\n        }\n    };\n    // cheap\n    IndexTreeModel.prototype.getTreeNode = function (location, node) {\n        if (node === void 0) { node = this.root; }\n        if (!location || location.length === 0) {\n            return node;\n        }\n        var index = location[0], rest = location.slice(1);\n        if (index < 0 || index > node.children.length) {\n            throw new Error('Invalid tree location');\n        }\n        return this.getTreeNode(rest, node.children[index]);\n    };\n    // expensive\n    IndexTreeModel.prototype.getTreeNodeWithListIndex = function (location) {\n        if (location.length === 0) {\n            return { node: this.root, listIndex: -1, revealed: true, visible: false };\n        }\n        var _a = this.getParentNodeWithListIndex(location), parentNode = _a.parentNode, listIndex = _a.listIndex, revealed = _a.revealed, visible = _a.visible;\n        var index = location[location.length - 1];\n        if (index < 0 || index > parentNode.children.length) {\n            throw new Error('Invalid tree location');\n        }\n        var node = parentNode.children[index];\n        return { node: node, listIndex: listIndex, revealed: revealed, visible: visible && node.visible };\n    };\n    IndexTreeModel.prototype.getParentNodeWithListIndex = function (location, node, listIndex, revealed, visible) {\n        if (node === void 0) { node = this.root; }\n        if (listIndex === void 0) { listIndex = 0; }\n        if (revealed === void 0) { revealed = true; }\n        if (visible === void 0) { visible = true; }\n        var index = location[0], rest = location.slice(1);\n        if (index < 0 || index > node.children.length) {\n            throw new Error('Invalid tree location');\n        }\n        // TODO@joao perf!\n        for (var i = 0; i < index; i++) {\n            listIndex += node.children[i].renderNodeCount;\n        }\n        revealed = revealed && !node.collapsed;\n        visible = visible && node.visible;\n        if (rest.length === 0) {\n            return { parentNode: node, listIndex: listIndex, revealed: revealed, visible: visible };\n        }\n        return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\n    };\n    IndexTreeModel.prototype.getNode = function (location) {\n        if (location === void 0) { location = []; }\n        return this.getTreeNode(location);\n    };\n    // TODO@joao perf!\n    IndexTreeModel.prototype.getNodeLocation = function (node) {\n        var location = [];\n        while (node.parent) {\n            location.push(node.parent.children.indexOf(node));\n            node = node.parent;\n        }\n        return location.reverse();\n    };\n    IndexTreeModel.prototype.getParentNodeLocation = function (location) {\n        if (location.length <= 1) {\n            return [];\n        }\n        return arrays_1.tail2(location)[0];\n    };\n    IndexTreeModel.prototype.getParentElement = function (location) {\n        var parentLocation = this.getParentNodeLocation(location);\n        var node = this.getTreeNode(parentLocation);\n        return node.element;\n    };\n    IndexTreeModel.prototype.getFirstElementChild = function (location) {\n        var node = this.getTreeNode(location);\n        if (node.children.length === 0) {\n            return undefined;\n        }\n        return node.children[0].element;\n    };\n    IndexTreeModel.prototype.getLastElementAncestor = function (location) {\n        if (location === void 0) { location = []; }\n        var node = this.getTreeNode(location);\n        if (node.children.length === 0) {\n            return undefined;\n        }\n        return this._getLastElementAncestor(node);\n    };\n    IndexTreeModel.prototype._getLastElementAncestor = function (node) {\n        if (node.children.length === 0) {\n            return node.element;\n        }\n        return this._getLastElementAncestor(node.children[node.children.length - 1]);\n    };\n    return IndexTreeModel;\n}());\nexports.IndexTreeModel = IndexTreeModel;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/indexTreeModel.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/indexTreeModel.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ICollapseStateChangeEvent, ITreeElement, ITreeFilter, ITreeFilterDataResult, ITreeModel, ITreeNode, TreeVisibility, ITreeModelSpliceEvent } from 'vs/base/browser/ui/tree/tree';\nimport { tail2 } from 'vs/base/common/arrays';\nimport { Emitter, Event, EventBufferer } from 'vs/base/common/event';\nimport { ISequence, Iterator } from 'vs/base/common/iterator';\nimport { ISpliceable } from 'vs/base/common/sequence';\n\ninterface IMutableTreeNode<T, TFilterData> extends ITreeNode<T, TFilterData> {\n\treadonly parent: IMutableTreeNode<T, TFilterData> | undefined;\n\treadonly children: IMutableTreeNode<T, TFilterData>[];\n\tvisibleChildrenCount: number;\n\tvisibleChildIndex: number;\n\tcollapsible: boolean;\n\tcollapsed: boolean;\n\trenderNodeCount: number;\n\tvisible: boolean;\n\tfilterData: TFilterData | undefined;\n}\n\nexport function isFilterResult<T>(obj: any): obj is ITreeFilterDataResult<T> {\n\treturn typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\n}\n\nexport function getVisibleState(visibility: boolean | TreeVisibility): TreeVisibility {\n\tswitch (visibility) {\n\t\tcase true: return TreeVisibility.Visible;\n\t\tcase false: return TreeVisibility.Hidden;\n\t\tdefault: return visibility;\n\t}\n}\n\nfunction treeNodeToElement<T>(node: IMutableTreeNode<T, any>): ITreeElement<T> {\n\tconst { element, collapsed } = node;\n\tconst children = Iterator.map(Iterator.fromArray(node.children), treeNodeToElement);\n\n\treturn { element, children, collapsed };\n}\n\nexport interface IIndexTreeModelOptions<T, TFilterData> {\n\treadonly collapseByDefault?: boolean; // defaults to false\n\treadonly filter?: ITreeFilter<T, TFilterData>;\n\treadonly autoExpandSingleChildren?: boolean;\n}\n\nexport class IndexTreeModel<T extends Exclude<any, undefined>, TFilterData = void> implements ITreeModel<T, TFilterData, number[]> {\n\n\treadonly rootRef = [];\n\n\tprivate root: IMutableTreeNode<T, TFilterData>;\n\tprivate eventBufferer = new EventBufferer();\n\n\tprivate _onDidChangeCollapseState = new Emitter<ICollapseStateChangeEvent<T, TFilterData>>();\n\treadonly onDidChangeCollapseState: Event<ICollapseStateChangeEvent<T, TFilterData>> = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\n\n\tprivate _onDidChangeRenderNodeCount = new Emitter<ITreeNode<T, TFilterData>>();\n\treadonly onDidChangeRenderNodeCount: Event<ITreeNode<T, TFilterData>> = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\n\n\tprivate collapseByDefault: boolean;\n\tprivate filter?: ITreeFilter<T, TFilterData>;\n\tprivate autoExpandSingleChildren: boolean;\n\n\tprivate _onDidSplice = new Emitter<ITreeModelSpliceEvent<T, TFilterData>>();\n\treadonly onDidSplice = this._onDidSplice.event;\n\n\tconstructor(private list: ISpliceable<ITreeNode<T, TFilterData>>, rootElement: T, options: IIndexTreeModelOptions<T, TFilterData> = {}) {\n\t\tthis.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\n\t\tthis.filter = options.filter;\n\t\tthis.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n\n\t\tthis.root = {\n\t\t\tparent: undefined,\n\t\t\telement: rootElement,\n\t\t\tchildren: [],\n\t\t\tdepth: 0,\n\t\t\tvisibleChildrenCount: 0,\n\t\t\tvisibleChildIndex: -1,\n\t\t\tcollapsible: false,\n\t\t\tcollapsed: false,\n\t\t\trenderNodeCount: 0,\n\t\t\tvisible: true,\n\t\t\tfilterData: undefined\n\t\t};\n\t}\n\n\tsplice(\n\t\tlocation: number[],\n\t\tdeleteCount: number,\n\t\ttoInsert?: ISequence<ITreeElement<T>>,\n\t\tonDidCreateNode?: (node: ITreeNode<T, TFilterData>) => void,\n\t\tonDidDeleteNode?: (node: ITreeNode<T, TFilterData>) => void\n\t): Iterator<ITreeElement<T>> {\n\t\tif (location.length === 0) {\n\t\t\tthrow new Error('Invalid tree location');\n\t\t}\n\n\t\tconst { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\n\t\tconst treeListElementsToInsert: ITreeNode<T, TFilterData>[] = [];\n\t\tconst nodesToInsertIterator = Iterator.map(Iterator.from(toInsert), el => this.createTreeNode(el, parentNode, parentNode.visible ? TreeVisibility.Visible : TreeVisibility.Hidden, revealed, treeListElementsToInsert, onDidCreateNode));\n\n\t\tconst lastIndex = location[location.length - 1];\n\n\t\t// figure out what's the visible child start index right before the\n\t\t// splice point\n\t\tlet visibleChildStartIndex = 0;\n\n\t\tfor (let i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\n\t\t\tconst child = parentNode.children[i];\n\n\t\t\tif (child.visible) {\n\t\t\t\tvisibleChildStartIndex = child.visibleChildIndex;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst nodesToInsert: IMutableTreeNode<T, TFilterData>[] = [];\n\t\tlet insertedVisibleChildrenCount = 0;\n\t\tlet renderNodeCount = 0;\n\n\t\tIterator.forEach(nodesToInsertIterator, child => {\n\t\t\tnodesToInsert.push(child);\n\t\t\trenderNodeCount += child.renderNodeCount;\n\n\t\t\tif (child.visible) {\n\t\t\t\tchild.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\n\t\t\t}\n\t\t});\n\n\t\tconst deletedNodes = parentNode.children.splice(lastIndex, deleteCount, ...nodesToInsert);\n\n\t\t// figure out what is the count of deleted visible children\n\t\tlet deletedVisibleChildrenCount = 0;\n\n\t\tfor (const child of deletedNodes) {\n\t\t\tif (child.visible) {\n\t\t\t\tdeletedVisibleChildrenCount++;\n\t\t\t}\n\t\t}\n\n\t\t// and adjust for all visible children after the splice point\n\t\tif (deletedVisibleChildrenCount !== 0) {\n\t\t\tfor (let i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {\n\t\t\t\tconst child = parentNode.children[i];\n\n\t\t\t\tif (child.visible) {\n\t\t\t\t\tchild.visibleChildIndex -= deletedVisibleChildrenCount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// update parent's visible children count\n\t\tparentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\n\n\t\tif (revealed && visible) {\n\t\t\tconst visibleDeleteCount = deletedNodes.reduce((r, node) => r + node.renderNodeCount, 0);\n\n\t\t\tthis._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\n\t\t\tthis.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\n\t\t}\n\n\t\tif (deletedNodes.length > 0 && onDidDeleteNode) {\n\t\t\tconst visit = (node: ITreeNode<T, TFilterData>) => {\n\t\t\t\tonDidDeleteNode(node);\n\t\t\t\tnode.children.forEach(visit);\n\t\t\t};\n\n\t\t\tdeletedNodes.forEach(visit);\n\t\t}\n\n\t\tconst result = Iterator.map(Iterator.fromArray(deletedNodes), treeNodeToElement);\n\t\tthis._onDidSplice.fire({ insertedNodes: nodesToInsert, deletedNodes });\n\t\treturn result;\n\t}\n\n\trerender(location: number[]): void {\n\t\tif (location.length === 0) {\n\t\t\tthrow new Error('Invalid tree location');\n\t\t}\n\n\t\tconst { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\n\n\t\tif (revealed) {\n\t\t\tthis.list.splice(listIndex, 1, [node]);\n\t\t}\n\t}\n\n\tgetListIndex(location: number[]): number {\n\t\tconst { listIndex, visible, revealed } = this.getTreeNodeWithListIndex(location);\n\t\treturn visible && revealed ? listIndex : -1;\n\t}\n\n\tgetListRenderCount(location: number[]): number {\n\t\treturn this.getTreeNode(location).renderNodeCount;\n\t}\n\n\tisCollapsible(location: number[]): boolean {\n\t\treturn this.getTreeNode(location).collapsible;\n\t}\n\n\tisCollapsed(location: number[]): boolean {\n\t\treturn this.getTreeNode(location).collapsed;\n\t}\n\n\tsetCollapsed(location: number[], collapsed?: boolean, recursive?: boolean): boolean {\n\t\tconst node = this.getTreeNode(location);\n\n\t\tif (typeof collapsed === 'undefined') {\n\t\t\tcollapsed = !node.collapsed;\n\t\t}\n\n\t\treturn this.eventBufferer.bufferEvents(() => this._setCollapsed(location, collapsed!, recursive));\n\t}\n\n\tprivate _setCollapsed(location: number[], collapsed: boolean, recursive?: boolean): boolean {\n\t\tconst { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\n\n\t\tconst result = this._setListNodeCollapsed(node, listIndex, revealed, collapsed!, recursive || false);\n\n\t\tif (this.autoExpandSingleChildren && !collapsed! && !recursive) {\n\t\t\tlet onlyVisibleChildIndex = -1;\n\n\t\t\tfor (let i = 0; i < node.children.length; i++) {\n\t\t\t\tconst child = node.children[i];\n\n\t\t\t\tif (child.visible) {\n\t\t\t\t\tif (onlyVisibleChildIndex > -1) {\n\t\t\t\t\t\tonlyVisibleChildIndex = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tonlyVisibleChildIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (onlyVisibleChildIndex > -1) {\n\t\t\t\tthis._setCollapsed([...location, onlyVisibleChildIndex], false, false);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate _setListNodeCollapsed(node: IMutableTreeNode<T, TFilterData>, listIndex: number, revealed: boolean, collapsed: boolean, recursive: boolean): boolean {\n\t\tconst result = this._setNodeCollapsed(node, collapsed, recursive, false);\n\n\t\tif (!revealed || !node.visible) {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst previousRenderNodeCount = node.renderNodeCount;\n\t\tconst toInsert = this.updateNodeAfterCollapseChange(node);\n\t\tconst deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\n\t\tthis.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\n\n\t\treturn result;\n\t}\n\n\tprivate _setNodeCollapsed(node: IMutableTreeNode<T, TFilterData>, collapsed: boolean, recursive: boolean, deep: boolean): boolean {\n\t\tlet result = node.collapsible && node.collapsed !== collapsed;\n\n\t\tif (node.collapsible) {\n\t\t\tnode.collapsed = collapsed;\n\n\t\t\tif (result) {\n\t\t\t\tthis._onDidChangeCollapseState.fire({ node, deep });\n\t\t\t}\n\t\t}\n\n\t\tif (recursive) {\n\t\t\tfor (const child of node.children) {\n\t\t\t\tresult = this._setNodeCollapsed(child, collapsed, true, true) || result;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\texpandTo(location: number[]): void {\n\t\tthis.eventBufferer.bufferEvents(() => {\n\t\t\tlet node = this.getTreeNode(location);\n\n\t\t\twhile (node.parent) {\n\t\t\t\tnode = node.parent;\n\t\t\t\tlocation = location.slice(0, location.length - 1);\n\n\t\t\t\tif (node.collapsed) {\n\t\t\t\t\tthis._setCollapsed(location, false);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\trefilter(): void {\n\t\tconst previousRenderNodeCount = this.root.renderNodeCount;\n\t\tconst toInsert = this.updateNodeAfterFilterChange(this.root);\n\t\tthis.list.splice(0, previousRenderNodeCount, toInsert);\n\t}\n\n\tprivate createTreeNode(\n\t\ttreeElement: ITreeElement<T>,\n\t\tparent: IMutableTreeNode<T, TFilterData>,\n\t\tparentVisibility: TreeVisibility,\n\t\trevealed: boolean,\n\t\ttreeListElements: ITreeNode<T, TFilterData>[],\n\t\tonDidCreateNode?: (node: ITreeNode<T, TFilterData>) => void\n\t): IMutableTreeNode<T, TFilterData> {\n\t\tconst node: IMutableTreeNode<T, TFilterData> = {\n\t\t\tparent,\n\t\t\telement: treeElement.element,\n\t\t\tchildren: [],\n\t\t\tdepth: parent.depth + 1,\n\t\t\tvisibleChildrenCount: 0,\n\t\t\tvisibleChildIndex: -1,\n\t\t\tcollapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : (typeof treeElement.collapsed !== 'undefined'),\n\t\t\tcollapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\n\t\t\trenderNodeCount: 1,\n\t\t\tvisible: true,\n\t\t\tfilterData: undefined\n\t\t};\n\n\t\tconst visibility = this._filterNode(node, parentVisibility);\n\n\t\tif (revealed) {\n\t\t\ttreeListElements.push(node);\n\t\t}\n\n\t\tconst childElements = Iterator.from(treeElement.children);\n\t\tconst childRevealed = revealed && visibility !== TreeVisibility.Hidden && !node.collapsed;\n\t\tconst childNodes = Iterator.map(childElements, el => this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode));\n\n\t\tlet visibleChildrenCount = 0;\n\t\tlet renderNodeCount = 1;\n\n\t\tIterator.forEach(childNodes, child => {\n\t\t\tnode.children.push(child);\n\t\t\trenderNodeCount += child.renderNodeCount;\n\n\t\t\tif (child.visible) {\n\t\t\t\tchild.visibleChildIndex = visibleChildrenCount++;\n\t\t\t}\n\t\t});\n\n\t\tnode.collapsible = node.collapsible || node.children.length > 0;\n\t\tnode.visibleChildrenCount = visibleChildrenCount;\n\t\tnode.visible = visibility === TreeVisibility.Recurse ? visibleChildrenCount > 0 : (visibility === TreeVisibility.Visible);\n\n\t\tif (!node.visible) {\n\t\t\tnode.renderNodeCount = 0;\n\n\t\t\tif (revealed) {\n\t\t\t\ttreeListElements.pop();\n\t\t\t}\n\t\t} else if (!node.collapsed) {\n\t\t\tnode.renderNodeCount = renderNodeCount;\n\t\t}\n\n\t\tif (onDidCreateNode) {\n\t\t\tonDidCreateNode(node);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tprivate updateNodeAfterCollapseChange(node: IMutableTreeNode<T, TFilterData>): ITreeNode<T, TFilterData>[] {\n\t\tconst previousRenderNodeCount = node.renderNodeCount;\n\t\tconst result: ITreeNode<T, TFilterData>[] = [];\n\n\t\tthis._updateNodeAfterCollapseChange(node, result);\n\t\tthis._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n\n\t\treturn result;\n\t}\n\n\tprivate _updateNodeAfterCollapseChange(node: IMutableTreeNode<T, TFilterData>, result: ITreeNode<T, TFilterData>[]): number {\n\t\tif (node.visible === false) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tresult.push(node);\n\t\tnode.renderNodeCount = 1;\n\n\t\tif (!node.collapsed) {\n\t\t\tfor (const child of node.children) {\n\t\t\t\tnode.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\n\t\t\t}\n\t\t}\n\n\t\tthis._onDidChangeRenderNodeCount.fire(node);\n\t\treturn node.renderNodeCount;\n\t}\n\n\tprivate updateNodeAfterFilterChange(node: IMutableTreeNode<T, TFilterData>): ITreeNode<T, TFilterData>[] {\n\t\tconst previousRenderNodeCount = node.renderNodeCount;\n\t\tconst result: ITreeNode<T, TFilterData>[] = [];\n\n\t\tthis._updateNodeAfterFilterChange(node, node.visible ? TreeVisibility.Visible : TreeVisibility.Hidden, result);\n\t\tthis._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n\n\t\treturn result;\n\t}\n\n\tprivate _updateNodeAfterFilterChange(node: IMutableTreeNode<T, TFilterData>, parentVisibility: TreeVisibility, result: ITreeNode<T, TFilterData>[], revealed = true): boolean {\n\t\tlet visibility: TreeVisibility;\n\n\t\tif (node !== this.root) {\n\t\t\tvisibility = this._filterNode(node, parentVisibility);\n\n\t\t\tif (visibility === TreeVisibility.Hidden) {\n\t\t\t\tnode.visible = false;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (revealed) {\n\t\t\t\tresult.push(node);\n\t\t\t}\n\t\t}\n\n\t\tconst resultStartLength = result.length;\n\t\tnode.renderNodeCount = node === this.root ? 0 : 1;\n\n\t\tlet hasVisibleDescendants = false;\n\t\tif (!node.collapsed || visibility! !== TreeVisibility.Hidden) {\n\t\t\tlet visibleChildIndex = 0;\n\n\t\t\tfor (const child of node.children) {\n\t\t\t\thasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility!, result, revealed && !node.collapsed) || hasVisibleDescendants;\n\n\t\t\t\tif (child.visible) {\n\t\t\t\t\tchild.visibleChildIndex = visibleChildIndex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode.visibleChildrenCount = visibleChildIndex;\n\t\t} else {\n\t\t\tnode.visibleChildrenCount = 0;\n\t\t}\n\n\t\tif (node !== this.root) {\n\t\t\tnode.visible = visibility! === TreeVisibility.Recurse ? hasVisibleDescendants : (visibility! === TreeVisibility.Visible);\n\t\t}\n\n\t\tif (!node.visible) {\n\t\t\tnode.renderNodeCount = 0;\n\n\t\t\tif (revealed) {\n\t\t\t\tresult.pop();\n\t\t\t}\n\t\t} else if (!node.collapsed) {\n\t\t\tnode.renderNodeCount += result.length - resultStartLength;\n\t\t}\n\n\t\tthis._onDidChangeRenderNodeCount.fire(node);\n\t\treturn node.visible;\n\t}\n\n\tprivate _updateAncestorsRenderNodeCount(node: IMutableTreeNode<T, TFilterData> | undefined, diff: number): void {\n\t\tif (diff === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\twhile (node) {\n\t\t\tnode.renderNodeCount += diff;\n\t\t\tthis._onDidChangeRenderNodeCount.fire(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t}\n\n\tprivate _filterNode(node: IMutableTreeNode<T, TFilterData>, parentVisibility: TreeVisibility): TreeVisibility {\n\t\tconst result = this.filter ? this.filter.filter(node.element, parentVisibility) : TreeVisibility.Visible;\n\n\t\tif (typeof result === 'boolean') {\n\t\t\tnode.filterData = undefined;\n\t\t\treturn result ? TreeVisibility.Visible : TreeVisibility.Hidden;\n\t\t} else if (isFilterResult<TFilterData>(result)) {\n\t\t\tnode.filterData = result.data;\n\t\t\treturn getVisibleState(result.visibility);\n\t\t} else {\n\t\t\tnode.filterData = undefined;\n\t\t\treturn getVisibleState(result);\n\t\t}\n\t}\n\n\t// cheap\n\tprivate getTreeNode(location: number[], node: IMutableTreeNode<T, TFilterData> = this.root): IMutableTreeNode<T, TFilterData> {\n\t\tif (!location || location.length === 0) {\n\t\t\treturn node;\n\t\t}\n\n\t\tconst [index, ...rest] = location;\n\n\t\tif (index < 0 || index > node.children.length) {\n\t\t\tthrow new Error('Invalid tree location');\n\t\t}\n\n\t\treturn this.getTreeNode(rest, node.children[index]);\n\t}\n\n\t// expensive\n\tprivate getTreeNodeWithListIndex(location: number[]): { node: IMutableTreeNode<T, TFilterData>, listIndex: number, revealed: boolean, visible: boolean } {\n\t\tif (location.length === 0) {\n\t\t\treturn { node: this.root, listIndex: -1, revealed: true, visible: false };\n\t\t}\n\n\t\tconst { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\n\t\tconst index = location[location.length - 1];\n\n\t\tif (index < 0 || index > parentNode.children.length) {\n\t\t\tthrow new Error('Invalid tree location');\n\t\t}\n\n\t\tconst node = parentNode.children[index];\n\n\t\treturn { node, listIndex, revealed, visible: visible && node.visible };\n\t}\n\n\tprivate getParentNodeWithListIndex(location: number[], node: IMutableTreeNode<T, TFilterData> = this.root, listIndex: number = 0, revealed = true, visible = true): { parentNode: IMutableTreeNode<T, TFilterData>; listIndex: number; revealed: boolean; visible: boolean; } {\n\t\tconst [index, ...rest] = location;\n\n\t\tif (index < 0 || index > node.children.length) {\n\t\t\tthrow new Error('Invalid tree location');\n\t\t}\n\n\t\t// TODO@joao perf!\n\t\tfor (let i = 0; i < index; i++) {\n\t\t\tlistIndex += node.children[i].renderNodeCount;\n\t\t}\n\n\t\trevealed = revealed && !node.collapsed;\n\t\tvisible = visible && node.visible;\n\n\t\tif (rest.length === 0) {\n\t\t\treturn { parentNode: node, listIndex, revealed, visible };\n\t\t}\n\n\t\treturn this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\n\t}\n\n\tgetNode(location: number[] = []): ITreeNode<T, TFilterData> {\n\t\treturn this.getTreeNode(location);\n\t}\n\n\t// TODO@joao perf!\n\tgetNodeLocation(node: ITreeNode<T, TFilterData>): number[] {\n\t\tconst location: number[] = [];\n\n\t\twhile (node.parent) {\n\t\t\tlocation.push(node.parent.children.indexOf(node));\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\treturn location.reverse();\n\t}\n\n\tgetParentNodeLocation(location: number[]): number[] {\n\t\tif (location.length <= 1) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn tail2(location)[0];\n\t}\n\n\tgetParentElement(location: number[]): T {\n\t\tconst parentLocation = this.getParentNodeLocation(location);\n\t\tconst node = this.getTreeNode(parentLocation);\n\t\treturn node.element;\n\t}\n\n\tgetFirstElementChild(location: number[]): T | undefined {\n\t\tconst node = this.getTreeNode(location);\n\n\t\tif (node.children.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn node.children[0].element;\n\t}\n\n\tgetLastElementAncestor(location: number[] = []): T | undefined {\n\t\tconst node = this.getTreeNode(location);\n\n\t\tif (node.children.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn this._getLastElementAncestor(node);\n\t}\n\n\tprivate _getLastElementAncestor(node: ITreeNode<T, TFilterData>): T {\n\t\tif (node.children.length === 0) {\n\t\t\treturn node.element;\n\t\t}\n\n\t\treturn this._getLastElementAncestor(node.children[node.children.length - 1]);\n\t}\n}\n"]}]}