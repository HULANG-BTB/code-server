{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/common/sequence.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/sequence.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar event_1 = require(\"vs/base/common/event\");\nvar Sequence = /** @class */ (function () {\n    function Sequence() {\n        this.elements = [];\n        this._onDidSplice = new event_1.Emitter();\n        this.onDidSplice = this._onDidSplice.event;\n    }\n    Sequence.prototype.splice = function (start, deleteCount, toInsert) {\n        if (toInsert === void 0) { toInsert = []; }\n        var _a;\n        (_a = this.elements).splice.apply(_a, [start, deleteCount].concat(toInsert));\n        this._onDidSplice.fire({ start: start, deleteCount: deleteCount, toInsert: toInsert });\n    };\n    return Sequence;\n}());\nexports.Sequence = Sequence;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/common/sequence.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/common/sequence.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;AAEhG,8CAAsD;AAiBtD;IAAA;QAEU,aAAQ,GAAQ,EAAE,CAAC;QAEpB,iBAAY,GAAG,IAAI,eAAO,EAAc,CAAC;QACxC,gBAAW,GAAsB,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC;IAMnE,CAAC;IAJA,yBAAM,GAAN,UAAO,KAAa,EAAE,WAAmB,EAAE,QAAkB;QAAlB,yBAAA,EAAA,aAAkB;;QAC5D,CAAA,KAAA,IAAI,CAAC,QAAQ,CAAA,CAAC,MAAM,YAAC,KAAK,EAAE,WAAW,SAAK,QAAQ,GAAE;QACtD,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,KAAK,OAAA,EAAE,WAAW,aAAA,EAAE,QAAQ,UAAA,EAAE,CAAC,CAAC;IAC1D,CAAC;IACF,eAAC;AAAD,CAAC,AAXD,IAWC;AAXY,4BAAQ","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event, Emitter } from 'vs/base/common/event';\n\nexport interface ISplice<T> {\n\treadonly start: number;\n\treadonly deleteCount: number;\n\treadonly toInsert: T[];\n}\n\nexport interface ISpliceable<T> {\n\tsplice(start: number, deleteCount: number, toInsert: T[]): void;\n}\n\nexport interface ISequence<T> {\n\treadonly elements: T[];\n\treadonly onDidSplice: Event<ISplice<T>>;\n}\n\nexport class Sequence<T> implements ISequence<T>, ISpliceable<T> {\n\n\treadonly elements: T[] = [];\n\n\tprivate _onDidSplice = new Emitter<ISplice<T>>();\n\treadonly onDidSplice: Event<ISplice<T>> = this._onDidSplice.event;\n\n\tsplice(start: number, deleteCount: number, toInsert: T[] = []): void {\n\t\tthis.elements.splice(start, deleteCount, ...toInsert);\n\t\tthis._onDidSplice.fire({ start, deleteCount, toInsert });\n\t}\n}"]}]}