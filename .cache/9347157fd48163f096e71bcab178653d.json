{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/common/terminalService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/common/terminalService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/event\", \"vs/platform/contextkey/common/contextkey\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/workbench/services/panel/common/panelService\", \"vs/workbench/contrib/terminal/common/terminal\", \"vs/platform/storage/common/storage\", \"vs/base/common/uri\", \"vs/editor/contrib/find/findState\", \"vs/platform/notification/common/notification\", \"vs/platform/dialogs/common/dialogs\", \"vs/workbench/services/extensions/common/extensions\", \"vs/platform/files/common/files\", \"vs/workbench/contrib/terminal/common/terminalEnvironment\", \"vs/base/common/platform\", \"vs/base/common/path\"], function (require, exports, nls, event_1, contextkey_1, lifecycle_1, panelService_1, terminal_1, storage_1, uri_1, findState_1, notification_1, dialogs_1, extensions_1, files_1, terminalEnvironment_1, platform_1, path_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let TerminalService = class TerminalService {\n        constructor(_contextKeyService, _panelService, lifecycleService, _storageService, _notificationService, _dialogService, _extensionService, _fileService) {\n            this._contextKeyService = _contextKeyService;\n            this._panelService = _panelService;\n            this._storageService = _storageService;\n            this._notificationService = _notificationService;\n            this._dialogService = _dialogService;\n            this._extensionService = _extensionService;\n            this._fileService = _fileService;\n            this._terminalTabs = [];\n            this._onActiveTabChanged = new event_1.Emitter();\n            this._onInstanceCreated = new event_1.Emitter();\n            this._onInstanceDisposed = new event_1.Emitter();\n            this._onInstanceProcessIdReady = new event_1.Emitter();\n            this._onInstanceRequestExtHostProcess = new event_1.Emitter();\n            this._onInstanceDimensionsChanged = new event_1.Emitter();\n            this._onInstancesChanged = new event_1.Emitter();\n            this._onInstanceTitleChanged = new event_1.Emitter();\n            this._onActiveInstanceChanged = new event_1.Emitter();\n            this._onTabDisposed = new event_1.Emitter();\n            this._activeTabIndex = 0;\n            this._isShuttingDown = false;\n            this._findState = new findState_1.FindReplaceState();\n            lifecycleService.onBeforeShutdown(event => event.veto(this._onBeforeShutdown()));\n            lifecycleService.onShutdown(() => this._onShutdown());\n            this._terminalFocusContextKey = terminal_1.KEYBINDING_CONTEXT_TERMINAL_FOCUS.bindTo(this._contextKeyService);\n            this._findWidgetVisible = terminal_1.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_VISIBLE.bindTo(this._contextKeyService);\n            this.onTabDisposed(tab => this._removeTab(tab));\n            this.onActiveTabChanged(() => {\n                const instance = this.getActiveInstance();\n                this._onActiveInstanceChanged.fire(instance ? instance : undefined);\n            });\n            this._handleContextKeys();\n        }\n        get _terminalInstances() {\n            return this._terminalTabs.reduce((p, c) => p.concat(c.terminalInstances), []);\n        }\n        get activeTabIndex() { return this._activeTabIndex; }\n        get terminalInstances() { return this._terminalInstances; }\n        get terminalTabs() { return this._terminalTabs; }\n        get onActiveTabChanged() { return this._onActiveTabChanged.event; }\n        get onInstanceCreated() { return this._onInstanceCreated.event; }\n        get onInstanceDisposed() { return this._onInstanceDisposed.event; }\n        get onInstanceProcessIdReady() { return this._onInstanceProcessIdReady.event; }\n        get onInstanceRequestExtHostProcess() { return this._onInstanceRequestExtHostProcess.event; }\n        get onInstanceDimensionsChanged() { return this._onInstanceDimensionsChanged.event; }\n        get onInstancesChanged() { return this._onInstancesChanged.event; }\n        get onInstanceTitleChanged() { return this._onInstanceTitleChanged.event; }\n        get onActiveInstanceChanged() { return this._onActiveInstanceChanged.event; }\n        get onTabDisposed() { return this._onTabDisposed.event; }\n        _handleContextKeys() {\n            const terminalIsOpenContext = terminal_1.KEYBINDING_CONTEXT_TERMINAL_IS_OPEN.bindTo(this._contextKeyService);\n            const updateTerminalContextKeys = () => {\n                terminalIsOpenContext.set(this.terminalInstances.length > 0);\n            };\n            this.onInstancesChanged(() => updateTerminalContextKeys());\n        }\n        createTerminalRenderer(name) {\n            return this.createTerminal({ name, isRendererOnly: true });\n        }\n        getActiveOrCreateInstance(wasNewTerminalAction) {\n            const activeInstance = this.getActiveInstance();\n            return activeInstance ? activeInstance : this.createTerminal(undefined, wasNewTerminalAction);\n        }\n        requestExtHostProcess(proxy, shellLaunchConfig, activeWorkspaceRootUri, cols, rows) {\n            // Ensure extension host is ready before requesting a process\n            this._extensionService.whenInstalledExtensionsRegistered().then(() => {\n                // TODO: MainThreadTerminalService is not ready at this point, fix this\n                setTimeout(() => {\n                    this._onInstanceRequestExtHostProcess.fire({ proxy, shellLaunchConfig, activeWorkspaceRootUri, cols, rows });\n                }, 500);\n            });\n        }\n        _onBeforeShutdown() {\n            if (this.terminalInstances.length === 0) {\n                // No terminal instances, don't veto\n                return false;\n            }\n            if (this.configHelper.config.confirmOnExit) {\n                // veto if configured to show confirmation and the user choosed not to exit\n                return this._showTerminalCloseConfirmation().then(veto => {\n                    if (!veto) {\n                        this._isShuttingDown = true;\n                    }\n                    return veto;\n                });\n            }\n            this._isShuttingDown = true;\n            return false;\n        }\n        _onShutdown() {\n            // Dispose of all instances\n            this.terminalInstances.forEach(instance => instance.dispose(true));\n        }\n        getTabLabels() {\n            return this._terminalTabs.filter(tab => tab.terminalInstances.length > 0).map((tab, index) => `${index + 1}: ${tab.title ? tab.title : ''}`);\n        }\n        getFindState() {\n            return this._findState;\n        }\n        _removeTab(tab) {\n            // Get the index of the tab and remove it from the list\n            const index = this._terminalTabs.indexOf(tab);\n            const wasActiveTab = tab === this.getActiveTab();\n            if (index !== -1) {\n                this._terminalTabs.splice(index, 1);\n            }\n            // Adjust focus if the tab was active\n            if (wasActiveTab && this._terminalTabs.length > 0) {\n                // TODO: Only focus the new tab if the removed tab had focus?\n                // const hasFocusOnExit = tab.activeInstance.hadFocusOnExit;\n                const newIndex = index < this._terminalTabs.length ? index : this._terminalTabs.length - 1;\n                this.setActiveTabByIndex(newIndex);\n                const activeInstance = this.getActiveInstance();\n                if (activeInstance) {\n                    activeInstance.focus(true);\n                }\n            }\n            // Hide the panel if there are no more instances, provided that VS Code is not shutting\n            // down. When shutting down the panel is locked in place so that it is restored upon next\n            // launch.\n            if (this._terminalTabs.length === 0 && !this._isShuttingDown) {\n                this.hidePanel();\n                this._onActiveInstanceChanged.fire(undefined);\n            }\n            // Fire events\n            this._onInstancesChanged.fire();\n            if (wasActiveTab) {\n                this._onActiveTabChanged.fire();\n            }\n        }\n        getActiveTab() {\n            if (this._activeTabIndex < 0 || this._activeTabIndex >= this._terminalTabs.length) {\n                return null;\n            }\n            return this._terminalTabs[this._activeTabIndex];\n        }\n        getActiveInstance() {\n            const tab = this.getActiveTab();\n            if (!tab) {\n                return null;\n            }\n            return tab.activeInstance;\n        }\n        getInstanceFromId(terminalId) {\n            return this.terminalInstances[this._getIndexFromId(terminalId)];\n        }\n        getInstanceFromIndex(terminalIndex) {\n            return this.terminalInstances[terminalIndex];\n        }\n        setActiveInstance(terminalInstance) {\n            this.setActiveInstanceByIndex(this._getIndexFromId(terminalInstance.id));\n        }\n        setActiveTabByIndex(tabIndex) {\n            if (tabIndex >= this._terminalTabs.length) {\n                return;\n            }\n            const didTabChange = this._activeTabIndex !== tabIndex;\n            this._activeTabIndex = tabIndex;\n            this._terminalTabs.forEach((t, i) => t.setVisible(i === this._activeTabIndex));\n            if (didTabChange) {\n                this._onActiveTabChanged.fire();\n            }\n        }\n        _getInstanceFromGlobalInstanceIndex(index) {\n            let currentTabIndex = 0;\n            while (index >= 0 && currentTabIndex < this._terminalTabs.length) {\n                const tab = this._terminalTabs[currentTabIndex];\n                const count = tab.terminalInstances.length;\n                if (index < count) {\n                    return {\n                        tab,\n                        tabIndex: currentTabIndex,\n                        instance: tab.terminalInstances[index],\n                        localInstanceIndex: index\n                    };\n                }\n                index -= count;\n                currentTabIndex++;\n            }\n            return null;\n        }\n        setActiveInstanceByIndex(terminalIndex) {\n            const query = this._getInstanceFromGlobalInstanceIndex(terminalIndex);\n            if (!query) {\n                return;\n            }\n            query.tab.setActiveInstanceByIndex(query.localInstanceIndex);\n            const didTabChange = this._activeTabIndex !== query.tabIndex;\n            this._activeTabIndex = query.tabIndex;\n            this._terminalTabs.forEach((t, i) => t.setVisible(i === query.tabIndex));\n            // Only fire the event if there was a change\n            if (didTabChange) {\n                this._onActiveTabChanged.fire();\n            }\n        }\n        setActiveTabToNext() {\n            if (this._terminalTabs.length <= 1) {\n                return;\n            }\n            let newIndex = this._activeTabIndex + 1;\n            if (newIndex >= this._terminalTabs.length) {\n                newIndex = 0;\n            }\n            this.setActiveTabByIndex(newIndex);\n        }\n        setActiveTabToPrevious() {\n            if (this._terminalTabs.length <= 1) {\n                return;\n            }\n            let newIndex = this._activeTabIndex - 1;\n            if (newIndex < 0) {\n                newIndex = this._terminalTabs.length - 1;\n            }\n            this.setActiveTabByIndex(newIndex);\n        }\n        splitInstance(instanceToSplit, shellLaunchConfig = {}) {\n            const tab = this._getTabForInstance(instanceToSplit);\n            if (!tab) {\n                return null;\n            }\n            const instance = tab.split(this._terminalFocusContextKey, this.configHelper, shellLaunchConfig);\n            if (!instance) {\n                this._showNotEnoughSpaceToast();\n                return null;\n            }\n            this._initInstanceListeners(instance);\n            this._onInstancesChanged.fire();\n            this._terminalTabs.forEach((t, i) => t.setVisible(i === this._activeTabIndex));\n            return instance;\n        }\n        _initInstanceListeners(instance) {\n            instance.addDisposable(instance.onDisposed(this._onInstanceDisposed.fire, this._onInstanceDisposed));\n            instance.addDisposable(instance.onTitleChanged(this._onInstanceTitleChanged.fire, this._onInstanceTitleChanged));\n            instance.addDisposable(instance.onProcessIdReady(this._onInstanceProcessIdReady.fire, this._onInstanceProcessIdReady));\n            instance.addDisposable(instance.onDimensionsChanged(() => this._onInstanceDimensionsChanged.fire(instance)));\n            instance.addDisposable(instance.onFocus(this._onActiveInstanceChanged.fire, this._onActiveInstanceChanged));\n        }\n        _getTabForInstance(instance) {\n            for (const tab of this._terminalTabs) {\n                if (tab.terminalInstances.indexOf(instance) !== -1) {\n                    return tab;\n                }\n            }\n            return null;\n        }\n        showPanel(focus) {\n            return new Promise((complete) => {\n                const panel = this._panelService.getActivePanel();\n                if (!panel || panel.getId() !== terminal_1.TERMINAL_PANEL_ID) {\n                    this._panelService.openPanel(terminal_1.TERMINAL_PANEL_ID, focus);\n                    if (focus) {\n                        // Do the focus call asynchronously as going through the\n                        // command palette will force editor focus\n                        setTimeout(() => {\n                            const instance = this.getActiveInstance();\n                            if (instance) {\n                                instance.focusWhenReady(true).then(() => complete(undefined));\n                            }\n                            else {\n                                complete(undefined);\n                            }\n                        }, 0);\n                    }\n                    else {\n                        complete(undefined);\n                    }\n                }\n                else {\n                    if (focus) {\n                        // Do the focus call asynchronously as going through the\n                        // command palette will force editor focus\n                        setTimeout(() => {\n                            const instance = this.getActiveInstance();\n                            if (instance) {\n                                instance.focusWhenReady(true).then(() => complete(undefined));\n                            }\n                            else {\n                                complete(undefined);\n                            }\n                        }, 0);\n                    }\n                    else {\n                        complete(undefined);\n                    }\n                }\n                return undefined;\n            });\n        }\n        _getIndexFromId(terminalId) {\n            let terminalIndex = -1;\n            this.terminalInstances.forEach((terminalInstance, i) => {\n                if (terminalInstance.id === terminalId) {\n                    terminalIndex = i;\n                }\n            });\n            if (terminalIndex === -1) {\n                throw new Error(`Terminal with ID ${terminalId} does not exist (has it already been disposed?)`);\n            }\n            return terminalIndex;\n        }\n        setWorkspaceShellAllowed(isAllowed) {\n            this.configHelper.setWorkspaceShellAllowed(isAllowed);\n        }\n        _showTerminalCloseConfirmation() {\n            let message;\n            if (this.terminalInstances.length === 1) {\n                message = nls.localize('terminalService.terminalCloseConfirmationSingular', \"There is an active terminal session, do you want to kill it?\");\n            }\n            else {\n                message = nls.localize('terminalService.terminalCloseConfirmationPlural', \"There are {0} active terminal sessions, do you want to kill them?\", this.terminalInstances.length);\n            }\n            return this._dialogService.confirm({\n                message,\n                type: 'warning',\n            }).then(res => !res.confirmed);\n        }\n        _showNotEnoughSpaceToast() {\n            this._notificationService.info(nls.localize('terminal.minWidth', \"Not enough space to split terminal.\"));\n        }\n        _validateShellPaths(label, potentialPaths) {\n            if (potentialPaths.length === 0) {\n                return Promise.resolve(null);\n            }\n            const current = potentialPaths.shift();\n            return this._fileService.existsFile(uri_1.URI.file(current)).then(exists => {\n                if (!exists) {\n                    return this._validateShellPaths(label, potentialPaths);\n                }\n                return [label, current];\n            });\n        }\n        preparePathForTerminalAsync(originalPath, executable, title) {\n            return new Promise(c => {\n                const exe = executable;\n                if (!exe) {\n                    c(originalPath);\n                    return;\n                }\n                const hasSpace = originalPath.indexOf(' ') !== -1;\n                const pathBasename = path_1.basename(exe, '.exe');\n                const isPowerShell = pathBasename === 'pwsh' ||\n                    title === 'pwsh' ||\n                    pathBasename === 'powershell' ||\n                    title === 'powershell';\n                if (isPowerShell && (hasSpace || originalPath.indexOf('\\'') !== -1)) {\n                    c(`& '${originalPath.replace(/'/g, '\\'\\'')}'`);\n                    return;\n                }\n                if (platform_1.isWindows) {\n                    // 17063 is the build number where wsl path was introduced.\n                    // Update Windows uriPath to be executed in WSL.\n                    if (((exe.indexOf('wsl') !== -1) || ((exe.indexOf('bash.exe') !== -1) && (exe.indexOf('git') === -1))) && (this._getWindowsBuildNumber() >= 17063)) {\n                        c(this._getWslPath(originalPath));\n                        return;\n                    }\n                    else if (hasSpace) {\n                        c('\"' + originalPath + '\"');\n                    }\n                    else {\n                        c(originalPath);\n                    }\n                    return;\n                }\n                c(terminalEnvironment_1.escapeNonWindowsPath(originalPath));\n            });\n        }\n    };\n    TerminalService = __decorate([\n        __param(0, contextkey_1.IContextKeyService),\n        __param(1, panelService_1.IPanelService),\n        __param(2, lifecycle_1.ILifecycleService),\n        __param(3, storage_1.IStorageService),\n        __param(4, notification_1.INotificationService),\n        __param(5, dialogs_1.IDialogService),\n        __param(6, extensions_1.IExtensionService),\n        __param(7, files_1.IFileService)\n    ], TerminalService);\n    exports.TerminalService = TerminalService;\n});\n",null]}