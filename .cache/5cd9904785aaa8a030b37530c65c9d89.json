{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/common/strings.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/strings.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar charCode_1 = require(\"vs/base/common/charCode\");\n/**\n * The empty string.\n */\nexports.empty = '';\nfunction isFalsyOrWhitespace(str) {\n    if (!str || typeof str !== 'string') {\n        return true;\n    }\n    return str.trim().length === 0;\n}\nexports.isFalsyOrWhitespace = isFalsyOrWhitespace;\n/**\n * @returns the provided number with the given number of preceding zeros.\n */\nfunction pad(n, l, char) {\n    if (char === void 0) { char = '0'; }\n    var str = '' + n;\n    var r = [str];\n    for (var i = str.length; i < l; i++) {\n        r.push(char);\n    }\n    return r.reverse().join('');\n}\nexports.pad = pad;\nvar _formatRegexp = /{(\\d+)}/g;\n/**\n * Helper to produce a string with a variable number of arguments. Insert variable segments\n * into the string using the {n} notation where N is the index of the argument following the string.\n * @param value string to which formatting is applied\n * @param args replacements for {n}-entries\n */\nfunction format(value) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (args.length === 0) {\n        return value;\n    }\n    return value.replace(_formatRegexp, function (match, group) {\n        var idx = parseInt(group, 10);\n        return isNaN(idx) || idx < 0 || idx >= args.length ?\n            match :\n            args[idx];\n    });\n}\nexports.format = format;\n/**\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\n * being used e.g. in HTMLElement.innerHTML.\n */\nfunction escape(html) {\n    return html.replace(/[<>&]/g, function (match) {\n        switch (match) {\n            case '<': return '&lt;';\n            case '>': return '&gt;';\n            case '&': return '&amp;';\n            default: return match;\n        }\n    });\n}\nexports.escape = escape;\n/**\n * Escapes regular expression characters in a given string\n */\nfunction escapeRegExpCharacters(value) {\n    return value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)\\#]/g, '\\\\$&');\n}\nexports.escapeRegExpCharacters = escapeRegExpCharacters;\n/**\n * Removes all occurrences of needle from the beginning and end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim (default is a blank)\n */\nfunction trim(haystack, needle) {\n    if (needle === void 0) { needle = ' '; }\n    var trimmed = ltrim(haystack, needle);\n    return rtrim(trimmed, needle);\n}\nexports.trim = trim;\n/**\n * Removes all occurrences of needle from the beginning of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nfunction ltrim(haystack, needle) {\n    if (!haystack || !needle) {\n        return haystack;\n    }\n    var needleLen = needle.length;\n    if (needleLen === 0 || haystack.length === 0) {\n        return haystack;\n    }\n    var offset = 0;\n    while (haystack.indexOf(needle, offset) === offset) {\n        offset = offset + needleLen;\n    }\n    return haystack.substring(offset);\n}\nexports.ltrim = ltrim;\n/**\n * Removes all occurrences of needle from the end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nfunction rtrim(haystack, needle) {\n    if (!haystack || !needle) {\n        return haystack;\n    }\n    var needleLen = needle.length, haystackLen = haystack.length;\n    if (needleLen === 0 || haystackLen === 0) {\n        return haystack;\n    }\n    var offset = haystackLen, idx = -1;\n    while (true) {\n        idx = haystack.lastIndexOf(needle, offset - 1);\n        if (idx === -1 || idx + needleLen !== offset) {\n            break;\n        }\n        if (idx === 0) {\n            return '';\n        }\n        offset = idx;\n    }\n    return haystack.substring(0, offset);\n}\nexports.rtrim = rtrim;\nfunction convertSimple2RegExpPattern(pattern) {\n    return pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\nexports.convertSimple2RegExpPattern = convertSimple2RegExpPattern;\nfunction stripWildcards(pattern) {\n    return pattern.replace(/\\*/g, '');\n}\nexports.stripWildcards = stripWildcards;\n/**\n * Determines if haystack starts with needle.\n */\nfunction startsWith(haystack, needle) {\n    if (haystack.length < needle.length) {\n        return false;\n    }\n    if (haystack === needle) {\n        return true;\n    }\n    for (var i = 0; i < needle.length; i++) {\n        if (haystack[i] !== needle[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.startsWith = startsWith;\n/**\n * Determines if haystack ends with needle.\n */\nfunction endsWith(haystack, needle) {\n    var diff = haystack.length - needle.length;\n    if (diff > 0) {\n        return haystack.indexOf(needle, diff) === diff;\n    }\n    else if (diff === 0) {\n        return haystack === needle;\n    }\n    else {\n        return false;\n    }\n}\nexports.endsWith = endsWith;\nfunction createRegExp(searchString, isRegex, options) {\n    if (options === void 0) { options = {}; }\n    if (!searchString) {\n        throw new Error('Cannot create regex from empty string');\n    }\n    if (!isRegex) {\n        searchString = escapeRegExpCharacters(searchString);\n    }\n    if (options.wholeWord) {\n        if (!/\\B/.test(searchString.charAt(0))) {\n            searchString = '\\\\b' + searchString;\n        }\n        if (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\n            searchString = searchString + '\\\\b';\n        }\n    }\n    var modifiers = '';\n    if (options.global) {\n        modifiers += 'g';\n    }\n    if (!options.matchCase) {\n        modifiers += 'i';\n    }\n    if (options.multiline) {\n        modifiers += 'm';\n    }\n    if (options.unicode) {\n        modifiers += 'u';\n    }\n    return new RegExp(searchString, modifiers);\n}\nexports.createRegExp = createRegExp;\nfunction regExpLeadsToEndlessLoop(regexp) {\n    // Exit early if it's one of these special cases which are meant to match\n    // against an empty string\n    if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\n        return false;\n    }\n    // We check against an empty string. If the regular expression doesn't advance\n    // (e.g. ends in an endless loop) it will match an empty string.\n    var match = regexp.exec('');\n    return !!(match && regexp.lastIndex === 0);\n}\nexports.regExpLeadsToEndlessLoop = regExpLeadsToEndlessLoop;\nfunction regExpContainsBackreference(regexpValue) {\n    return !!regexpValue.match(/([^\\\\]|^)(\\\\\\\\)*\\\\\\d+/);\n}\nexports.regExpContainsBackreference = regExpContainsBackreference;\nfunction regExpFlags(regexp) {\n    return (regexp.global ? 'g' : '')\n        + (regexp.ignoreCase ? 'i' : '')\n        + (regexp.multiline ? 'm' : '')\n        + (regexp.unicode ? 'u' : '');\n}\nexports.regExpFlags = regExpFlags;\n/**\n * Returns first index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nfunction firstNonWhitespaceIndex(str) {\n    for (var i = 0, len = str.length; i < len; i++) {\n        var chCode = str.charCodeAt(i);\n        if (chCode !== charCode_1.CharCode.Space && chCode !== charCode_1.CharCode.Tab) {\n            return i;\n        }\n    }\n    return -1;\n}\nexports.firstNonWhitespaceIndex = firstNonWhitespaceIndex;\n/**\n * Returns the leading whitespace of the string.\n * If the string contains only whitespaces, returns entire string\n */\nfunction getLeadingWhitespace(str, start, end) {\n    if (start === void 0) { start = 0; }\n    if (end === void 0) { end = str.length; }\n    for (var i = start; i < end; i++) {\n        var chCode = str.charCodeAt(i);\n        if (chCode !== charCode_1.CharCode.Space && chCode !== charCode_1.CharCode.Tab) {\n            return str.substring(start, i);\n        }\n    }\n    return str.substring(start, end);\n}\nexports.getLeadingWhitespace = getLeadingWhitespace;\n/**\n * Returns last index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nfunction lastNonWhitespaceIndex(str, startIndex) {\n    if (startIndex === void 0) { startIndex = str.length - 1; }\n    for (var i = startIndex; i >= 0; i--) {\n        var chCode = str.charCodeAt(i);\n        if (chCode !== charCode_1.CharCode.Space && chCode !== charCode_1.CharCode.Tab) {\n            return i;\n        }\n    }\n    return -1;\n}\nexports.lastNonWhitespaceIndex = lastNonWhitespaceIndex;\nfunction compare(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    else if (a > b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nexports.compare = compare;\nfunction compareIgnoreCase(a, b) {\n    var len = Math.min(a.length, b.length);\n    for (var i = 0; i < len; i++) {\n        var codeA = a.charCodeAt(i);\n        var codeB = b.charCodeAt(i);\n        if (codeA === codeB) {\n            // equal\n            continue;\n        }\n        if (isUpperAsciiLetter(codeA)) {\n            codeA += 32;\n        }\n        if (isUpperAsciiLetter(codeB)) {\n            codeB += 32;\n        }\n        var diff = codeA - codeB;\n        if (diff === 0) {\n            // equal -> ignoreCase\n            continue;\n        }\n        else if (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {\n            //\n            return diff;\n        }\n        else {\n            return compare(a.toLowerCase(), b.toLowerCase());\n        }\n    }\n    if (a.length < b.length) {\n        return -1;\n    }\n    else if (a.length > b.length) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nexports.compareIgnoreCase = compareIgnoreCase;\nfunction isLowerAsciiLetter(code) {\n    return code >= charCode_1.CharCode.a && code <= charCode_1.CharCode.z;\n}\nexports.isLowerAsciiLetter = isLowerAsciiLetter;\nfunction isUpperAsciiLetter(code) {\n    return code >= charCode_1.CharCode.A && code <= charCode_1.CharCode.Z;\n}\nexports.isUpperAsciiLetter = isUpperAsciiLetter;\nfunction isAsciiLetter(code) {\n    return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);\n}\nfunction equalsIgnoreCase(a, b) {\n    var len1 = a ? a.length : 0;\n    var len2 = b ? b.length : 0;\n    if (len1 !== len2) {\n        return false;\n    }\n    return doEqualsIgnoreCase(a, b);\n}\nexports.equalsIgnoreCase = equalsIgnoreCase;\nfunction doEqualsIgnoreCase(a, b, stopAt) {\n    if (stopAt === void 0) { stopAt = a.length; }\n    if (typeof a !== 'string' || typeof b !== 'string') {\n        return false;\n    }\n    for (var i = 0; i < stopAt; i++) {\n        var codeA = a.charCodeAt(i);\n        var codeB = b.charCodeAt(i);\n        if (codeA === codeB) {\n            continue;\n        }\n        // a-z A-Z\n        if (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {\n            var diff = Math.abs(codeA - codeB);\n            if (diff !== 0 && diff !== 32) {\n                return false;\n            }\n        }\n        // Any other charcode\n        else {\n            if (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction startsWithIgnoreCase(str, candidate) {\n    var candidateLength = candidate.length;\n    if (candidate.length > str.length) {\n        return false;\n    }\n    return doEqualsIgnoreCase(str, candidate, candidateLength);\n}\nexports.startsWithIgnoreCase = startsWithIgnoreCase;\n/**\n * @returns the length of the common prefix of the two strings.\n */\nfunction commonPrefixLength(a, b) {\n    var i, len = Math.min(a.length, b.length);\n    for (i = 0; i < len; i++) {\n        if (a.charCodeAt(i) !== b.charCodeAt(i)) {\n            return i;\n        }\n    }\n    return len;\n}\nexports.commonPrefixLength = commonPrefixLength;\n/**\n * @returns the length of the common suffix of the two strings.\n */\nfunction commonSuffixLength(a, b) {\n    var i, len = Math.min(a.length, b.length);\n    var aLastIndex = a.length - 1;\n    var bLastIndex = b.length - 1;\n    for (i = 0; i < len; i++) {\n        if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\n            return i;\n        }\n    }\n    return len;\n}\nexports.commonSuffixLength = commonSuffixLength;\nfunction substrEquals(a, aStart, aEnd, b, bStart, bEnd) {\n    while (aStart < aEnd && bStart < bEnd) {\n        if (a[aStart] !== b[bStart]) {\n            return false;\n        }\n        aStart += 1;\n        bStart += 1;\n    }\n    return true;\n}\n/**\n * Return the overlap between the suffix of `a` and the prefix of `b`.\n * For instance `overlap(\"foobar\", \"arr, I'm a pirate\") === 2`.\n */\nfunction overlap(a, b) {\n    var aEnd = a.length;\n    var bEnd = b.length;\n    var aStart = aEnd - bEnd;\n    if (aStart === 0) {\n        return a === b ? aEnd : 0;\n    }\n    else if (aStart < 0) {\n        bEnd += aStart;\n        aStart = 0;\n    }\n    while (aStart < aEnd && bEnd > 0) {\n        if (substrEquals(a, aStart, aEnd, b, 0, bEnd)) {\n            return bEnd;\n        }\n        bEnd -= 1;\n        aStart += 1;\n    }\n    return 0;\n}\nexports.overlap = overlap;\n// --- unicode\n// http://en.wikipedia.org/wiki/Surrogate_pair\n// Returns the code point starting at a specified index in a string\n// Code points U+0000 to U+D7FF and U+E000 to U+FFFF are represented on a single character\n// Code points U+10000 to U+10FFFF are represented on two consecutive characters\n//export function getUnicodePoint(str:string, index:number, len:number):number {\n//\tconst chrCode = str.charCodeAt(index);\n//\tif (0xD800 <= chrCode && chrCode <= 0xDBFF && index + 1 < len) {\n//\t\tconst nextChrCode = str.charCodeAt(index + 1);\n//\t\tif (0xDC00 <= nextChrCode && nextChrCode <= 0xDFFF) {\n//\t\t\treturn (chrCode - 0xD800) << 10 + (nextChrCode - 0xDC00) + 0x10000;\n//\t\t}\n//\t}\n//\treturn chrCode;\n//}\nfunction isHighSurrogate(charCode) {\n    return (0xD800 <= charCode && charCode <= 0xDBFF);\n}\nexports.isHighSurrogate = isHighSurrogate;\nfunction isLowSurrogate(charCode) {\n    return (0xDC00 <= charCode && charCode <= 0xDFFF);\n}\nexports.isLowSurrogate = isLowSurrogate;\n/**\n * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-rtl-test.js\n */\nvar CONTAINS_RTL = /(?:[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1-\\u07EA\\u07F4\\u07F5\\u07FA-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E-\\u08BD\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFD3D\\uFD50-\\uFDFC\\uFE70-\\uFEFC]|\\uD802[\\uDC00-\\uDD1B\\uDD20-\\uDE00\\uDE10-\\uDE33\\uDE40-\\uDEE4\\uDEEB-\\uDF35\\uDF40-\\uDFFF]|\\uD803[\\uDC00-\\uDCFF]|\\uD83A[\\uDC00-\\uDCCF\\uDD00-\\uDD43\\uDD50-\\uDFFF]|\\uD83B[\\uDC00-\\uDEBB])/;\n/**\n * Returns true if `str` contains any Unicode character that is classified as \"R\" or \"AL\".\n */\nfunction containsRTL(str) {\n    return CONTAINS_RTL.test(str);\n}\nexports.containsRTL = containsRTL;\n/**\n * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-emoji-test.js\n */\nvar CONTAINS_EMOJI = /(?:[\\u231A\\u231B\\u23F0\\u23F3\\u2600-\\u27BF\\u2B50\\u2B55]|\\uD83C[\\uDDE6-\\uDDFF\\uDF00-\\uDFFF]|\\uD83D[\\uDC00-\\uDE4F\\uDE80-\\uDEF8]|\\uD83E[\\uDD00-\\uDDE6])/;\nfunction containsEmoji(str) {\n    return CONTAINS_EMOJI.test(str);\n}\nexports.containsEmoji = containsEmoji;\nvar IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\n/**\n * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \\n, \\r, \\t\n */\nfunction isBasicASCII(str) {\n    return IS_BASIC_ASCII.test(str);\n}\nexports.isBasicASCII = isBasicASCII;\nfunction containsFullWidthCharacter(str) {\n    for (var i = 0, len = str.length; i < len; i++) {\n        if (isFullWidthCharacter(str.charCodeAt(i))) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.containsFullWidthCharacter = containsFullWidthCharacter;\nfunction isFullWidthCharacter(charCode) {\n    // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\n    // http://jrgraphix.net/research/unicode_blocks.php\n    //          2E80 — 2EFF   CJK Radicals Supplement\n    //          2F00 — 2FDF   Kangxi Radicals\n    //          2FF0 — 2FFF   Ideographic Description Characters\n    //          3000 — 303F   CJK Symbols and Punctuation\n    //          3040 — 309F   Hiragana\n    //          30A0 — 30FF   Katakana\n    //          3100 — 312F   Bopomofo\n    //          3130 — 318F   Hangul Compatibility Jamo\n    //          3190 — 319F   Kanbun\n    //          31A0 — 31BF   Bopomofo Extended\n    //          31F0 — 31FF   Katakana Phonetic Extensions\n    //          3200 — 32FF   Enclosed CJK Letters and Months\n    //          3300 — 33FF   CJK Compatibility\n    //          3400 — 4DBF   CJK Unified Ideographs Extension A\n    //          4DC0 — 4DFF   Yijing Hexagram Symbols\n    //          4E00 — 9FFF   CJK Unified Ideographs\n    //          A000 — A48F   Yi Syllables\n    //          A490 — A4CF   Yi Radicals\n    //          AC00 — D7AF   Hangul Syllables\n    // [IGNORE] D800 — DB7F   High Surrogates\n    // [IGNORE] DB80 — DBFF   High Private Use Surrogates\n    // [IGNORE] DC00 — DFFF   Low Surrogates\n    // [IGNORE] E000 — F8FF   Private Use Area\n    //          F900 — FAFF   CJK Compatibility Ideographs\n    // [IGNORE] FB00 — FB4F   Alphabetic Presentation Forms\n    // [IGNORE] FB50 — FDFF   Arabic Presentation Forms-A\n    // [IGNORE] FE00 — FE0F   Variation Selectors\n    // [IGNORE] FE20 — FE2F   Combining Half Marks\n    // [IGNORE] FE30 — FE4F   CJK Compatibility Forms\n    // [IGNORE] FE50 — FE6F   Small Form Variants\n    // [IGNORE] FE70 — FEFF   Arabic Presentation Forms-B\n    //          FF00 — FFEF   Halfwidth and Fullwidth Forms\n    //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\n    //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\n    // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\n    // [IGNORE] FFF0 — FFFF   Specials\n    charCode = +charCode; // @perf\n    return ((charCode >= 0x2E80 && charCode <= 0xD7AF)\n        || (charCode >= 0xF900 && charCode <= 0xFAFF)\n        || (charCode >= 0xFF01 && charCode <= 0xFF5E));\n}\nexports.isFullWidthCharacter = isFullWidthCharacter;\n/**\n * Given a string and a max length returns a shorted version. Shorting\n * happens at favorable positions - such as whitespace or punctuation characters.\n */\nfunction lcut(text, n) {\n    if (text.length < n) {\n        return text;\n    }\n    var re = /\\b/g;\n    var i = 0;\n    while (re.test(text)) {\n        if (text.length - re.lastIndex < n) {\n            break;\n        }\n        i = re.lastIndex;\n        re.lastIndex += 1;\n    }\n    return text.substring(i).replace(/^\\s/, exports.empty);\n}\nexports.lcut = lcut;\n// Escape codes\n// http://en.wikipedia.org/wiki/ANSI_escape_code\nvar EL = /\\x1B\\x5B[12]?K/g; // Erase in line\nvar COLOR_START = /\\x1b\\[\\d+m/g; // Color\nvar COLOR_END = /\\x1b\\[0?m/g; // Color\nfunction removeAnsiEscapeCodes(str) {\n    if (str) {\n        str = str.replace(EL, '');\n        str = str.replace(COLOR_START, '');\n        str = str.replace(COLOR_END, '');\n    }\n    return str;\n}\nexports.removeAnsiEscapeCodes = removeAnsiEscapeCodes;\nexports.removeAccents = (function () {\n    if (typeof String.prototype.normalize !== 'function') {\n        // ☹️ no ES6 features...\n        return function (str) { return str; };\n    }\n    else {\n        // transform into NFD form and remove accents\n        // see: https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript/37511463#37511463\n        var regex_1 = /[\\u0300-\\u036f]/g;\n        return function (str) {\n            return str.normalize('NFD').replace(regex_1, exports.empty);\n        };\n    }\n})();\n// -- UTF-8 BOM\nexports.UTF8_BOM_CHARACTER = String.fromCharCode(charCode_1.CharCode.UTF8_BOM);\nfunction startsWithUTF8BOM(str) {\n    return !!(str && str.length > 0 && str.charCodeAt(0) === charCode_1.CharCode.UTF8_BOM);\n}\nexports.startsWithUTF8BOM = startsWithUTF8BOM;\nfunction stripUTF8BOM(str) {\n    return startsWithUTF8BOM(str) ? str.substr(1) : str;\n}\nexports.stripUTF8BOM = stripUTF8BOM;\nfunction safeBtoa(str) {\n    return btoa(encodeURIComponent(str)); // we use encodeURIComponent because btoa fails for non Latin 1 values\n}\nexports.safeBtoa = safeBtoa;\nfunction repeat(s, count) {\n    var result = '';\n    for (var i = 0; i < count; i++) {\n        result += s;\n    }\n    return result;\n}\nexports.repeat = repeat;\n/**\n * Checks if the characters of the provided query string are included in the\n * target string. The characters do not have to be contiguous within the string.\n */\nfunction fuzzyContains(target, query) {\n    if (!target || !query) {\n        return false; // return early if target or query are undefined\n    }\n    if (target.length < query.length) {\n        return false; // impossible for query to be contained in target\n    }\n    var queryLen = query.length;\n    var targetLower = target.toLowerCase();\n    var index = 0;\n    var lastIndexOf = -1;\n    while (index < queryLen) {\n        var indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);\n        if (indexOf < 0) {\n            return false;\n        }\n        lastIndexOf = indexOf;\n        index++;\n    }\n    return true;\n}\nexports.fuzzyContains = fuzzyContains;\nfunction containsUppercaseCharacter(target, ignoreEscapedChars) {\n    if (ignoreEscapedChars === void 0) { ignoreEscapedChars = false; }\n    if (!target) {\n        return false;\n    }\n    if (ignoreEscapedChars) {\n        target = target.replace(/\\\\./g, '');\n    }\n    return target.toLowerCase() !== target;\n}\nexports.containsUppercaseCharacter = containsUppercaseCharacter;\nfunction uppercaseFirstLetter(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nexports.uppercaseFirstLetter = uppercaseFirstLetter;\nfunction getNLines(str, n) {\n    if (n === void 0) { n = 1; }\n    if (n === 0) {\n        return '';\n    }\n    var idx = -1;\n    do {\n        idx = str.indexOf('\\n', idx + 1);\n        n--;\n    } while (n > 0 && idx >= 0);\n    return idx >= 0 ?\n        str.substr(0, idx) :\n        str;\n}\nexports.getNLines = getNLines;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/common/strings.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/common/strings.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\n\n/**\n * The empty string.\n */\nexport const empty = '';\n\nexport function isFalsyOrWhitespace(str: string | undefined): boolean {\n\tif (!str || typeof str !== 'string') {\n\t\treturn true;\n\t}\n\treturn str.trim().length === 0;\n}\n\n/**\n * @returns the provided number with the given number of preceding zeros.\n */\nexport function pad(n: number, l: number, char: string = '0'): string {\n\tconst str = '' + n;\n\tconst r = [str];\n\n\tfor (let i = str.length; i < l; i++) {\n\t\tr.push(char);\n\t}\n\n\treturn r.reverse().join('');\n}\n\nconst _formatRegexp = /{(\\d+)}/g;\n\n/**\n * Helper to produce a string with a variable number of arguments. Insert variable segments\n * into the string using the {n} notation where N is the index of the argument following the string.\n * @param value string to which formatting is applied\n * @param args replacements for {n}-entries\n */\nexport function format(value: string, ...args: any[]): string {\n\tif (args.length === 0) {\n\t\treturn value;\n\t}\n\treturn value.replace(_formatRegexp, function (match, group) {\n\t\tconst idx = parseInt(group, 10);\n\t\treturn isNaN(idx) || idx < 0 || idx >= args.length ?\n\t\t\tmatch :\n\t\t\targs[idx];\n\t});\n}\n\n/**\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\n * being used e.g. in HTMLElement.innerHTML.\n */\nexport function escape(html: string): string {\n\treturn html.replace(/[<>&]/g, function (match) {\n\t\tswitch (match) {\n\t\t\tcase '<': return '&lt;';\n\t\t\tcase '>': return '&gt;';\n\t\t\tcase '&': return '&amp;';\n\t\t\tdefault: return match;\n\t\t}\n\t});\n}\n\n/**\n * Escapes regular expression characters in a given string\n */\nexport function escapeRegExpCharacters(value: string): string {\n\treturn value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)\\#]/g, '\\\\$&');\n}\n\n/**\n * Removes all occurrences of needle from the beginning and end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim (default is a blank)\n */\nexport function trim(haystack: string, needle: string = ' '): string {\n\tconst trimmed = ltrim(haystack, needle);\n\treturn rtrim(trimmed, needle);\n}\n\n/**\n * Removes all occurrences of needle from the beginning of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function ltrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length;\n\tif (needleLen === 0 || haystack.length === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = 0;\n\n\twhile (haystack.indexOf(needle, offset) === offset) {\n\t\toffset = offset + needleLen;\n\t}\n\treturn haystack.substring(offset);\n}\n\n/**\n * Removes all occurrences of needle from the end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function rtrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length,\n\t\thaystackLen = haystack.length;\n\n\tif (needleLen === 0 || haystackLen === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = haystackLen,\n\t\tidx = -1;\n\n\twhile (true) {\n\t\tidx = haystack.lastIndexOf(needle, offset - 1);\n\t\tif (idx === -1 || idx + needleLen !== offset) {\n\t\t\tbreak;\n\t\t}\n\t\tif (idx === 0) {\n\t\t\treturn '';\n\t\t}\n\t\toffset = idx;\n\t}\n\n\treturn haystack.substring(0, offset);\n}\n\nexport function convertSimple2RegExpPattern(pattern: string): string {\n\treturn pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\n\nexport function stripWildcards(pattern: string): string {\n\treturn pattern.replace(/\\*/g, '');\n}\n\n/**\n * Determines if haystack starts with needle.\n */\nexport function startsWith(haystack: string, needle: string): boolean {\n\tif (haystack.length < needle.length) {\n\t\treturn false;\n\t}\n\n\tif (haystack === needle) {\n\t\treturn true;\n\t}\n\n\tfor (let i = 0; i < needle.length; i++) {\n\t\tif (haystack[i] !== needle[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Determines if haystack ends with needle.\n */\nexport function endsWith(haystack: string, needle: string): boolean {\n\tconst diff = haystack.length - needle.length;\n\tif (diff > 0) {\n\t\treturn haystack.indexOf(needle, diff) === diff;\n\t} else if (diff === 0) {\n\t\treturn haystack === needle;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nexport interface RegExpOptions {\n\tmatchCase?: boolean;\n\twholeWord?: boolean;\n\tmultiline?: boolean;\n\tglobal?: boolean;\n\tunicode?: boolean;\n}\n\nexport function createRegExp(searchString: string, isRegex: boolean, options: RegExpOptions = {}): RegExp {\n\tif (!searchString) {\n\t\tthrow new Error('Cannot create regex from empty string');\n\t}\n\tif (!isRegex) {\n\t\tsearchString = escapeRegExpCharacters(searchString);\n\t}\n\tif (options.wholeWord) {\n\t\tif (!/\\B/.test(searchString.charAt(0))) {\n\t\t\tsearchString = '\\\\b' + searchString;\n\t\t}\n\t\tif (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\n\t\t\tsearchString = searchString + '\\\\b';\n\t\t}\n\t}\n\tlet modifiers = '';\n\tif (options.global) {\n\t\tmodifiers += 'g';\n\t}\n\tif (!options.matchCase) {\n\t\tmodifiers += 'i';\n\t}\n\tif (options.multiline) {\n\t\tmodifiers += 'm';\n\t}\n\tif (options.unicode) {\n\t\tmodifiers += 'u';\n\t}\n\n\treturn new RegExp(searchString, modifiers);\n}\n\nexport function regExpLeadsToEndlessLoop(regexp: RegExp): boolean {\n\t// Exit early if it's one of these special cases which are meant to match\n\t// against an empty string\n\tif (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\n\t\treturn false;\n\t}\n\n\t// We check against an empty string. If the regular expression doesn't advance\n\t// (e.g. ends in an endless loop) it will match an empty string.\n\tconst match = regexp.exec('');\n\treturn !!(match && <any>regexp.lastIndex === 0);\n}\n\nexport function regExpContainsBackreference(regexpValue: string): boolean {\n\treturn !!regexpValue.match(/([^\\\\]|^)(\\\\\\\\)*\\\\\\d+/);\n}\n\nexport function regExpFlags(regexp: RegExp): string {\n\treturn (regexp.global ? 'g' : '')\n\t\t+ (regexp.ignoreCase ? 'i' : '')\n\t\t+ (regexp.multiline ? 'm' : '')\n\t\t+ ((regexp as any).unicode ? 'u' : '');\n}\n\n/**\n * Returns first index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function firstNonWhitespaceIndex(str: string): number {\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * Returns the leading whitespace of the string.\n * If the string contains only whitespaces, returns entire string\n */\nexport function getLeadingWhitespace(str: string, start: number = 0, end: number = str.length): string {\n\tfor (let i = start; i < end; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn str.substring(start, i);\n\t\t}\n\t}\n\treturn str.substring(start, end);\n}\n\n/**\n * Returns last index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function lastNonWhitespaceIndex(str: string, startIndex: number = str.length - 1): number {\n\tfor (let i = startIndex; i >= 0; i--) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nexport function compare(a: string, b: string): number {\n\tif (a < b) {\n\t\treturn -1;\n\t} else if (a > b) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nexport function compareIgnoreCase(a: string, b: string): number {\n\tconst len = Math.min(a.length, b.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tlet codeA = a.charCodeAt(i);\n\t\tlet codeB = b.charCodeAt(i);\n\n\t\tif (codeA === codeB) {\n\t\t\t// equal\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isUpperAsciiLetter(codeA)) {\n\t\t\tcodeA += 32;\n\t\t}\n\n\t\tif (isUpperAsciiLetter(codeB)) {\n\t\t\tcodeB += 32;\n\t\t}\n\n\t\tconst diff = codeA - codeB;\n\n\t\tif (diff === 0) {\n\t\t\t// equal -> ignoreCase\n\t\t\tcontinue;\n\n\t\t} else if (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {\n\t\t\t//\n\t\t\treturn diff;\n\n\t\t} else {\n\t\t\treturn compare(a.toLowerCase(), b.toLowerCase());\n\t\t}\n\t}\n\n\tif (a.length < b.length) {\n\t\treturn -1;\n\t} else if (a.length > b.length) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nexport function isLowerAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.a && code <= CharCode.z;\n}\n\nexport function isUpperAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.A && code <= CharCode.Z;\n}\n\nfunction isAsciiLetter(code: number): boolean {\n\treturn isLowerAsciiLetter(code) || isUpperAsciiLetter(code);\n}\n\nexport function equalsIgnoreCase(a: string, b: string): boolean {\n\tconst len1 = a ? a.length : 0;\n\tconst len2 = b ? b.length : 0;\n\n\tif (len1 !== len2) {\n\t\treturn false;\n\t}\n\n\treturn doEqualsIgnoreCase(a, b);\n}\n\nfunction doEqualsIgnoreCase(a: string, b: string, stopAt = a.length): boolean {\n\tif (typeof a !== 'string' || typeof b !== 'string') {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < stopAt; i++) {\n\t\tconst codeA = a.charCodeAt(i);\n\t\tconst codeB = b.charCodeAt(i);\n\n\t\tif (codeA === codeB) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// a-z A-Z\n\t\tif (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {\n\t\t\tconst diff = Math.abs(codeA - codeB);\n\t\t\tif (diff !== 0 && diff !== 32) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Any other charcode\n\t\telse {\n\t\t\tif (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport function startsWithIgnoreCase(str: string, candidate: string): boolean {\n\tconst candidateLength = candidate.length;\n\tif (candidate.length > str.length) {\n\t\treturn false;\n\t}\n\n\treturn doEqualsIgnoreCase(str, candidate, candidateLength);\n}\n\n/**\n * @returns the length of the common prefix of the two strings.\n */\nexport function commonPrefixLength(a: string, b: string): number {\n\n\tlet i: number,\n\t\tlen = Math.min(a.length, b.length);\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(i) !== b.charCodeAt(i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * @returns the length of the common suffix of the two strings.\n */\nexport function commonSuffixLength(a: string, b: string): number {\n\n\tlet i: number,\n\t\tlen = Math.min(a.length, b.length);\n\n\tconst aLastIndex = a.length - 1;\n\tconst bLastIndex = b.length - 1;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\nfunction substrEquals(a: string, aStart: number, aEnd: number, b: string, bStart: number, bEnd: number): boolean {\n\twhile (aStart < aEnd && bStart < bEnd) {\n\t\tif (a[aStart] !== b[bStart]) {\n\t\t\treturn false;\n\t\t}\n\t\taStart += 1;\n\t\tbStart += 1;\n\t}\n\treturn true;\n}\n\n/**\n * Return the overlap between the suffix of `a` and the prefix of `b`.\n * For instance `overlap(\"foobar\", \"arr, I'm a pirate\") === 2`.\n */\nexport function overlap(a: string, b: string): number {\n\tconst aEnd = a.length;\n\tlet bEnd = b.length;\n\tlet aStart = aEnd - bEnd;\n\n\tif (aStart === 0) {\n\t\treturn a === b ? aEnd : 0;\n\t} else if (aStart < 0) {\n\t\tbEnd += aStart;\n\t\taStart = 0;\n\t}\n\n\twhile (aStart < aEnd && bEnd > 0) {\n\t\tif (substrEquals(a, aStart, aEnd, b, 0, bEnd)) {\n\t\t\treturn bEnd;\n\t\t}\n\t\tbEnd -= 1;\n\t\taStart += 1;\n\t}\n\treturn 0;\n}\n\n// --- unicode\n// http://en.wikipedia.org/wiki/Surrogate_pair\n// Returns the code point starting at a specified index in a string\n// Code points U+0000 to U+D7FF and U+E000 to U+FFFF are represented on a single character\n// Code points U+10000 to U+10FFFF are represented on two consecutive characters\n//export function getUnicodePoint(str:string, index:number, len:number):number {\n//\tconst chrCode = str.charCodeAt(index);\n//\tif (0xD800 <= chrCode && chrCode <= 0xDBFF && index + 1 < len) {\n//\t\tconst nextChrCode = str.charCodeAt(index + 1);\n//\t\tif (0xDC00 <= nextChrCode && nextChrCode <= 0xDFFF) {\n//\t\t\treturn (chrCode - 0xD800) << 10 + (nextChrCode - 0xDC00) + 0x10000;\n//\t\t}\n//\t}\n//\treturn chrCode;\n//}\nexport function isHighSurrogate(charCode: number): boolean {\n\treturn (0xD800 <= charCode && charCode <= 0xDBFF);\n}\n\nexport function isLowSurrogate(charCode: number): boolean {\n\treturn (0xDC00 <= charCode && charCode <= 0xDFFF);\n}\n\n/**\n * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-rtl-test.js\n */\nconst CONTAINS_RTL = /(?:[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1-\\u07EA\\u07F4\\u07F5\\u07FA-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E-\\u08BD\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFD3D\\uFD50-\\uFDFC\\uFE70-\\uFEFC]|\\uD802[\\uDC00-\\uDD1B\\uDD20-\\uDE00\\uDE10-\\uDE33\\uDE40-\\uDEE4\\uDEEB-\\uDF35\\uDF40-\\uDFFF]|\\uD803[\\uDC00-\\uDCFF]|\\uD83A[\\uDC00-\\uDCCF\\uDD00-\\uDD43\\uDD50-\\uDFFF]|\\uD83B[\\uDC00-\\uDEBB])/;\n\n/**\n * Returns true if `str` contains any Unicode character that is classified as \"R\" or \"AL\".\n */\nexport function containsRTL(str: string): boolean {\n\treturn CONTAINS_RTL.test(str);\n}\n\n/**\n * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-emoji-test.js\n */\nconst CONTAINS_EMOJI = /(?:[\\u231A\\u231B\\u23F0\\u23F3\\u2600-\\u27BF\\u2B50\\u2B55]|\\uD83C[\\uDDE6-\\uDDFF\\uDF00-\\uDFFF]|\\uD83D[\\uDC00-\\uDE4F\\uDE80-\\uDEF8]|\\uD83E[\\uDD00-\\uDDE6])/;\n\nexport function containsEmoji(str: string): boolean {\n\treturn CONTAINS_EMOJI.test(str);\n}\n\nconst IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\n/**\n * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \\n, \\r, \\t\n */\nexport function isBasicASCII(str: string): boolean {\n\treturn IS_BASIC_ASCII.test(str);\n}\n\nexport function containsFullWidthCharacter(str: string): boolean {\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tif (isFullWidthCharacter(str.charCodeAt(i))) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nexport function isFullWidthCharacter(charCode: number): boolean {\n\t// Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\n\t// http://jrgraphix.net/research/unicode_blocks.php\n\t//          2E80 — 2EFF   CJK Radicals Supplement\n\t//          2F00 — 2FDF   Kangxi Radicals\n\t//          2FF0 — 2FFF   Ideographic Description Characters\n\t//          3000 — 303F   CJK Symbols and Punctuation\n\t//          3040 — 309F   Hiragana\n\t//          30A0 — 30FF   Katakana\n\t//          3100 — 312F   Bopomofo\n\t//          3130 — 318F   Hangul Compatibility Jamo\n\t//          3190 — 319F   Kanbun\n\t//          31A0 — 31BF   Bopomofo Extended\n\t//          31F0 — 31FF   Katakana Phonetic Extensions\n\t//          3200 — 32FF   Enclosed CJK Letters and Months\n\t//          3300 — 33FF   CJK Compatibility\n\t//          3400 — 4DBF   CJK Unified Ideographs Extension A\n\t//          4DC0 — 4DFF   Yijing Hexagram Symbols\n\t//          4E00 — 9FFF   CJK Unified Ideographs\n\t//          A000 — A48F   Yi Syllables\n\t//          A490 — A4CF   Yi Radicals\n\t//          AC00 — D7AF   Hangul Syllables\n\t// [IGNORE] D800 — DB7F   High Surrogates\n\t// [IGNORE] DB80 — DBFF   High Private Use Surrogates\n\t// [IGNORE] DC00 — DFFF   Low Surrogates\n\t// [IGNORE] E000 — F8FF   Private Use Area\n\t//          F900 — FAFF   CJK Compatibility Ideographs\n\t// [IGNORE] FB00 — FB4F   Alphabetic Presentation Forms\n\t// [IGNORE] FB50 — FDFF   Arabic Presentation Forms-A\n\t// [IGNORE] FE00 — FE0F   Variation Selectors\n\t// [IGNORE] FE20 — FE2F   Combining Half Marks\n\t// [IGNORE] FE30 — FE4F   CJK Compatibility Forms\n\t// [IGNORE] FE50 — FE6F   Small Form Variants\n\t// [IGNORE] FE70 — FEFF   Arabic Presentation Forms-B\n\t//          FF00 — FFEF   Halfwidth and Fullwidth Forms\n\t//               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\n\t//               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\n\t// [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\n\t// [IGNORE] FFF0 — FFFF   Specials\n\tcharCode = +charCode; // @perf\n\treturn (\n\t\t(charCode >= 0x2E80 && charCode <= 0xD7AF)\n\t\t|| (charCode >= 0xF900 && charCode <= 0xFAFF)\n\t\t|| (charCode >= 0xFF01 && charCode <= 0xFF5E)\n\t);\n}\n\n/**\n * Given a string and a max length returns a shorted version. Shorting\n * happens at favorable positions - such as whitespace or punctuation characters.\n */\nexport function lcut(text: string, n: number) {\n\tif (text.length < n) {\n\t\treturn text;\n\t}\n\n\tconst re = /\\b/g;\n\tlet i = 0;\n\twhile (re.test(text)) {\n\t\tif (text.length - re.lastIndex < n) {\n\t\t\tbreak;\n\t\t}\n\n\t\ti = re.lastIndex;\n\t\tre.lastIndex += 1;\n\t}\n\n\treturn text.substring(i).replace(/^\\s/, empty);\n}\n\n// Escape codes\n// http://en.wikipedia.org/wiki/ANSI_escape_code\nconst EL = /\\x1B\\x5B[12]?K/g; // Erase in line\nconst COLOR_START = /\\x1b\\[\\d+m/g; // Color\nconst COLOR_END = /\\x1b\\[0?m/g; // Color\n\nexport function removeAnsiEscapeCodes(str: string): string {\n\tif (str) {\n\t\tstr = str.replace(EL, '');\n\t\tstr = str.replace(COLOR_START, '');\n\t\tstr = str.replace(COLOR_END, '');\n\t}\n\n\treturn str;\n}\n\nexport const removeAccents: (str: string) => string = (function () {\n\tif (typeof (String.prototype as any).normalize !== 'function') {\n\t\t// ☹️ no ES6 features...\n\t\treturn function (str: string) { return str; };\n\t} else {\n\t\t// transform into NFD form and remove accents\n\t\t// see: https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript/37511463#37511463\n\t\tconst regex = /[\\u0300-\\u036f]/g;\n\t\treturn function (str: string) {\n\t\t\treturn (str as any).normalize('NFD').replace(regex, empty);\n\t\t};\n\t}\n})();\n\n\n// -- UTF-8 BOM\n\nexport const UTF8_BOM_CHARACTER = String.fromCharCode(CharCode.UTF8_BOM);\n\nexport function startsWithUTF8BOM(str: string): boolean {\n\treturn !!(str && str.length > 0 && str.charCodeAt(0) === CharCode.UTF8_BOM);\n}\n\nexport function stripUTF8BOM(str: string): string {\n\treturn startsWithUTF8BOM(str) ? str.substr(1) : str;\n}\n\nexport function safeBtoa(str: string): string {\n\treturn btoa(encodeURIComponent(str)); // we use encodeURIComponent because btoa fails for non Latin 1 values\n}\n\nexport function repeat(s: string, count: number): string {\n\tlet result = '';\n\tfor (let i = 0; i < count; i++) {\n\t\tresult += s;\n\t}\n\treturn result;\n}\n\n/**\n * Checks if the characters of the provided query string are included in the\n * target string. The characters do not have to be contiguous within the string.\n */\nexport function fuzzyContains(target: string, query: string): boolean {\n\tif (!target || !query) {\n\t\treturn false; // return early if target or query are undefined\n\t}\n\n\tif (target.length < query.length) {\n\t\treturn false; // impossible for query to be contained in target\n\t}\n\n\tconst queryLen = query.length;\n\tconst targetLower = target.toLowerCase();\n\n\tlet index = 0;\n\tlet lastIndexOf = -1;\n\twhile (index < queryLen) {\n\t\tconst indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);\n\t\tif (indexOf < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlastIndexOf = indexOf;\n\n\t\tindex++;\n\t}\n\n\treturn true;\n}\n\nexport function containsUppercaseCharacter(target: string, ignoreEscapedChars = false): boolean {\n\tif (!target) {\n\t\treturn false;\n\t}\n\n\tif (ignoreEscapedChars) {\n\t\ttarget = target.replace(/\\\\./g, '');\n\t}\n\n\treturn target.toLowerCase() !== target;\n}\n\nexport function uppercaseFirstLetter(str: string): string {\n\treturn str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function getNLines(str: string, n = 1): string {\n\tif (n === 0) {\n\t\treturn '';\n\t}\n\n\tlet idx = -1;\n\tdo {\n\t\tidx = str.indexOf('\\n', idx + 1);\n\t\tn--;\n\t} while (n > 0 && idx >= 0);\n\n\treturn idx >= 0 ?\n\t\tstr.substr(0, idx) :\n\t\tstr;\n}\n"]}]}