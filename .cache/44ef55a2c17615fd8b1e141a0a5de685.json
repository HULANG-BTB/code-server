{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/textToHtmlTokenizer.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/textToHtmlTokenizer.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/charCode\", \"vs/base/common/strings\", \"vs/editor/common/core/lineTokens\", \"vs/editor/common/modes\", \"vs/editor/common/modes/nullMode\"], function (require, exports, charCode_1, strings, lineTokens_1, modes_1, nullMode_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const fallback = {\n        getInitialState: () => nullMode_1.NULL_STATE,\n        tokenize2: (buffer, state, deltaOffset) => nullMode_1.nullTokenize2(modes_1.LanguageId.Null, buffer, state, deltaOffset)\n    };\n    function tokenizeToString(text, tokenizationSupport = fallback) {\n        return _tokenizeToString(text, tokenizationSupport || fallback);\n    }\n    exports.tokenizeToString = tokenizeToString;\n    function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize) {\n        let result = `<div>`;\n        let charIndex = startOffset;\n        let tabsCharDelta = 0;\n        for (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n            const tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n            if (tokenEndIndex <= startOffset) {\n                continue;\n            }\n            let partContent = '';\n            for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n                const charCode = text.charCodeAt(charIndex);\n                switch (charCode) {\n                    case charCode_1.CharCode.Tab:\n                        let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                        tabsCharDelta += insertSpacesCount - 1;\n                        while (insertSpacesCount > 0) {\n                            partContent += '&nbsp;';\n                            insertSpacesCount--;\n                        }\n                        break;\n                    case charCode_1.CharCode.LessThan:\n                        partContent += '&lt;';\n                        break;\n                    case charCode_1.CharCode.GreaterThan:\n                        partContent += '&gt;';\n                        break;\n                    case charCode_1.CharCode.Ampersand:\n                        partContent += '&amp;';\n                        break;\n                    case charCode_1.CharCode.Null:\n                        partContent += '&#00;';\n                        break;\n                    case charCode_1.CharCode.UTF8_BOM:\n                    case charCode_1.CharCode.LINE_SEPARATOR_2028:\n                        partContent += '\\ufffd';\n                        break;\n                    case charCode_1.CharCode.CarriageReturn:\n                        // zero width space, because carriage return would introduce a line break\n                        partContent += '&#8203';\n                        break;\n                    default:\n                        partContent += String.fromCharCode(charCode);\n                }\n            }\n            result += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n            if (tokenEndIndex > endOffset || charIndex >= endOffset) {\n                break;\n            }\n        }\n        result += `</div>`;\n        return result;\n    }\n    exports.tokenizeLineToHTML = tokenizeLineToHTML;\n    function _tokenizeToString(text, tokenizationSupport) {\n        let result = `<div class=\"monaco-tokenized-source\">`;\n        let lines = text.split(/\\r\\n|\\r|\\n/);\n        let currentState = tokenizationSupport.getInitialState();\n        for (let i = 0, len = lines.length; i < len; i++) {\n            let line = lines[i];\n            if (i > 0) {\n                result += `<br/>`;\n            }\n            let tokenizationResult = tokenizationSupport.tokenize2(line, currentState, 0);\n            lineTokens_1.LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n            let lineTokens = new lineTokens_1.LineTokens(tokenizationResult.tokens, line);\n            let viewLineTokens = lineTokens.inflate();\n            let startOffset = 0;\n            for (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n                const type = viewLineTokens.getClassName(j);\n                const endIndex = viewLineTokens.getEndOffset(j);\n                result += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n                startOffset = endIndex;\n            }\n            currentState = tokenizationResult.endState;\n        }\n        result += `</div>`;\n        return result;\n    }\n});\n",null]}