{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/snippet/snippetSession.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/snippet/snippetSession.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrays_1 = require(\"vs/base/common/arrays\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar strings_1 = require(\"vs/base/common/strings\");\nrequire(\"vs/css!./snippetSession\");\nvar editOperation_1 = require(\"vs/editor/common/core/editOperation\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar selection_1 = require(\"vs/editor/common/core/selection\");\nvar model_1 = require(\"vs/editor/common/model\");\nvar textModel_1 = require(\"vs/editor/common/model/textModel\");\nvar clipboardService_1 = require(\"vs/platform/clipboard/common/clipboardService\");\nvar workspace_1 = require(\"vs/platform/workspace/common/workspace\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar snippetParser_1 = require(\"./snippetParser\");\nvar snippetVariables_1 = require(\"./snippetVariables\");\nvar themeService_1 = require(\"vs/platform/theme/common/themeService\");\nvar colors = require(\"vs/platform/theme/common/colorRegistry\");\nvar types_1 = require(\"vs/base/common/types\");\nthemeService_1.registerThemingParticipant(function (theme, collector) {\n    function getColorGraceful(name) {\n        var color = theme.getColor(name);\n        return color ? color.toString() : 'transparent';\n    }\n    collector.addRule(\".monaco-editor .snippet-placeholder { background-color: \" + getColorGraceful(colors.snippetTabstopHighlightBackground) + \"; outline-color: \" + getColorGraceful(colors.snippetTabstopHighlightBorder) + \"; }\");\n    collector.addRule(\".monaco-editor .finish-snippet-placeholder { background-color: \" + getColorGraceful(colors.snippetFinalTabstopHighlightBackground) + \"; outline-color: \" + getColorGraceful(colors.snippetFinalTabstopHighlightBorder) + \"; }\");\n});\nvar OneSnippet = /** @class */ (function () {\n    function OneSnippet(editor, snippet, offset) {\n        this._nestingLevel = 1;\n        this._editor = editor;\n        this._snippet = snippet;\n        this._offset = offset;\n        this._placeholderGroups = arrays_1.groupBy(snippet.placeholders, snippetParser_1.Placeholder.compareByIndex);\n        this._placeholderGroupsIdx = -1;\n    }\n    OneSnippet.prototype.dispose = function () {\n        if (this._placeholderDecorations) {\n            var toRemove_1 = [];\n            this._placeholderDecorations.forEach(function (handle) { return toRemove_1.push(handle); });\n            this._editor.deltaDecorations(toRemove_1, []);\n        }\n        this._placeholderGroups.length = 0;\n    };\n    OneSnippet.prototype._initDecorations = function () {\n        var _this = this;\n        if (this._placeholderDecorations) {\n            // already initialized\n            return;\n        }\n        this._placeholderDecorations = new Map();\n        var model = this._editor.getModel();\n        this._editor.changeDecorations(function (accessor) {\n            // create a decoration for each placeholder\n            for (var _i = 0, _a = _this._snippet.placeholders; _i < _a.length; _i++) {\n                var placeholder = _a[_i];\n                var placeholderOffset = _this._snippet.offset(placeholder);\n                var placeholderLen = _this._snippet.fullLen(placeholder);\n                var range = range_1.Range.fromPositions(model.getPositionAt(_this._offset + placeholderOffset), model.getPositionAt(_this._offset + placeholderOffset + placeholderLen));\n                var options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;\n                var handle = accessor.addDecoration(range, options);\n                _this._placeholderDecorations.set(placeholder, handle);\n            }\n        });\n    };\n    OneSnippet.prototype.move = function (fwd) {\n        var _this = this;\n        if (!this._editor.hasModel()) {\n            return [];\n        }\n        this._initDecorations();\n        // Transform placeholder text if necessary\n        if (this._placeholderGroupsIdx >= 0) {\n            var operations = [];\n            for (var _i = 0, _a = this._placeholderGroups[this._placeholderGroupsIdx]; _i < _a.length; _i++) {\n                var placeholder = _a[_i];\n                // Check if the placeholder has a transformation\n                if (placeholder.transform) {\n                    var id = this._placeholderDecorations.get(placeholder);\n                    var range = this._editor.getModel().getDecorationRange(id);\n                    var currentValue = this._editor.getModel().getValueInRange(range);\n                    operations.push(editOperation_1.EditOperation.replaceMove(range, placeholder.transform.resolve(currentValue)));\n                }\n            }\n            if (operations.length > 0) {\n                this._editor.executeEdits('snippet.placeholderTransform', operations);\n            }\n        }\n        var skipThisPlaceholder = false;\n        if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {\n            this._placeholderGroupsIdx += 1;\n            skipThisPlaceholder = true;\n        }\n        else if (fwd === false && this._placeholderGroupsIdx > 0) {\n            this._placeholderGroupsIdx -= 1;\n            skipThisPlaceholder = true;\n        }\n        else {\n            // the selection of the current placeholder might\n            // not acurate any more -> simply restore it\n        }\n        var newSelections = this._editor.getModel().changeDecorations(function (accessor) {\n            var activePlaceholders = new Set();\n            // change stickiness to always grow when typing at its edges\n            // because these decorations represent the currently active\n            // tabstop.\n            // Special case #1: reaching the final tabstop\n            // Special case #2: placeholders enclosing active placeholders\n            var selections = [];\n            for (var _i = 0, _a = _this._placeholderGroups[_this._placeholderGroupsIdx]; _i < _a.length; _i++) {\n                var placeholder = _a[_i];\n                var id = _this._placeholderDecorations.get(placeholder);\n                var range = _this._editor.getModel().getDecorationRange(id);\n                selections.push(new selection_1.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn));\n                // consider to skip this placeholder index when the decoration\n                // range is empty but when the placeholder wasn't. that's a strong\n                // hint that the placeholder has been deleted. (all placeholder must match this)\n                skipThisPlaceholder = skipThisPlaceholder && (range.isEmpty() && placeholder.toString().length > 0);\n                accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n                activePlaceholders.add(placeholder);\n                for (var _b = 0, _c = _this._snippet.enclosingPlaceholders(placeholder); _b < _c.length; _b++) {\n                    var enclosingPlaceholder = _c[_b];\n                    var id_1 = _this._placeholderDecorations.get(enclosingPlaceholder);\n                    accessor.changeDecorationOptions(id_1, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n                    activePlaceholders.add(enclosingPlaceholder);\n                }\n            }\n            // change stickness to never grow when typing at its edges\n            // so that in-active tabstops never grow\n            _this._placeholderDecorations.forEach(function (id, placeholder) {\n                if (!activePlaceholders.has(placeholder)) {\n                    accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);\n                }\n            });\n            return selections;\n        });\n        return !skipThisPlaceholder ? newSelections : this.move(fwd);\n    };\n    Object.defineProperty(OneSnippet.prototype, \"isAtFirstPlaceholder\", {\n        get: function () {\n            return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(OneSnippet.prototype, \"isAtLastPlaceholder\", {\n        get: function () {\n            return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(OneSnippet.prototype, \"hasPlaceholder\", {\n        get: function () {\n            return this._snippet.placeholders.length > 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    OneSnippet.prototype.computePossibleSelections = function () {\n        var result = new Map();\n        for (var _i = 0, _a = this._placeholderGroups; _i < _a.length; _i++) {\n            var placeholdersWithEqualIndex = _a[_i];\n            var ranges = void 0;\n            for (var _b = 0, placeholdersWithEqualIndex_1 = placeholdersWithEqualIndex; _b < placeholdersWithEqualIndex_1.length; _b++) {\n                var placeholder = placeholdersWithEqualIndex_1[_b];\n                if (!ranges) {\n                    ranges = [];\n                    result.set(placeholder.index, ranges);\n                }\n                var id = this._placeholderDecorations.get(placeholder);\n                var range = this._editor.getModel().getDecorationRange(id);\n                if (!range) {\n                    // one of the placeholder lost its decoration and\n                    // therefore we bail out and pretend the placeholder\n                    // (with its mirrors) doesn't exist anymore.\n                    result.delete(placeholder.index);\n                    break;\n                }\n                ranges.push(range);\n            }\n        }\n        return result;\n    };\n    Object.defineProperty(OneSnippet.prototype, \"choice\", {\n        get: function () {\n            return this._placeholderGroups[this._placeholderGroupsIdx][0].choice;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    OneSnippet.prototype.merge = function (others) {\n        var _this = this;\n        var model = this._editor.getModel();\n        this._nestingLevel *= 10;\n        this._editor.changeDecorations(function (accessor) {\n            // For each active placeholder take one snippet and merge it\n            // in that the placeholder (can be many for `$1foo$1foo`). Because\n            // everything is sorted by editor selection we can simply remove\n            // elements from the beginning of the array\n            for (var _i = 0, _a = _this._placeholderGroups[_this._placeholderGroupsIdx]; _i < _a.length; _i++) {\n                var placeholder = _a[_i];\n                var nested = others.shift();\n                console.assert(!nested._placeholderDecorations);\n                // Massage placeholder-indicies of the nested snippet to be\n                // sorted right after the insertion point. This ensures we move\n                // through the placeholders in the correct order\n                var indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;\n                for (var _b = 0, _c = nested._snippet.placeholderInfo.all; _b < _c.length; _b++) {\n                    var nestedPlaceholder = _c[_b];\n                    if (nestedPlaceholder.isFinalTabstop) {\n                        nestedPlaceholder.index = placeholder.index + ((indexLastPlaceholder + 1) / _this._nestingLevel);\n                    }\n                    else {\n                        nestedPlaceholder.index = placeholder.index + (nestedPlaceholder.index / _this._nestingLevel);\n                    }\n                }\n                _this._snippet.replace(placeholder, nested._snippet.children);\n                // Remove the placeholder at which position are inserting\n                // the snippet and also remove its decoration.\n                var id = _this._placeholderDecorations.get(placeholder);\n                accessor.removeDecoration(id);\n                _this._placeholderDecorations.delete(placeholder);\n                // For each *new* placeholder we create decoration to monitor\n                // how and if it grows/shrinks.\n                for (var _d = 0, _e = nested._snippet.placeholders; _d < _e.length; _d++) {\n                    var placeholder_1 = _e[_d];\n                    var placeholderOffset = nested._snippet.offset(placeholder_1);\n                    var placeholderLen = nested._snippet.fullLen(placeholder_1);\n                    var range = range_1.Range.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));\n                    var handle = accessor.addDecoration(range, OneSnippet._decor.inactive);\n                    _this._placeholderDecorations.set(placeholder_1, handle);\n                }\n            }\n            // Last, re-create the placeholder groups by sorting placeholders by their index.\n            _this._placeholderGroups = arrays_1.groupBy(_this._snippet.placeholders, snippetParser_1.Placeholder.compareByIndex);\n        });\n    };\n    OneSnippet.prototype.getEnclosingRange = function () {\n        var result;\n        var model = this._editor.getModel();\n        this._placeholderDecorations.forEach(function (decorationId) {\n            var placeholderRange = types_1.withNullAsUndefined(model.getDecorationRange(decorationId));\n            if (!result) {\n                result = placeholderRange;\n            }\n            else {\n                result = result.plusRange(placeholderRange);\n            }\n        });\n        return result;\n    };\n    OneSnippet._decor = {\n        active: textModel_1.ModelDecorationOptions.register({ stickiness: model_1.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges, className: 'snippet-placeholder' }),\n        inactive: textModel_1.ModelDecorationOptions.register({ stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges, className: 'snippet-placeholder' }),\n        activeFinal: textModel_1.ModelDecorationOptions.register({ stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges, className: 'finish-snippet-placeholder' }),\n        inactiveFinal: textModel_1.ModelDecorationOptions.register({ stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges, className: 'finish-snippet-placeholder' }),\n    };\n    return OneSnippet;\n}());\nexports.OneSnippet = OneSnippet;\nvar SnippetSession = /** @class */ (function () {\n    function SnippetSession(editor, template, overwriteBefore, overwriteAfter, adjustWhitespace) {\n        if (overwriteBefore === void 0) { overwriteBefore = 0; }\n        if (overwriteAfter === void 0) { overwriteAfter = 0; }\n        if (adjustWhitespace === void 0) { adjustWhitespace = true; }\n        this._templateMerges = [];\n        this._snippets = [];\n        this._editor = editor;\n        this._template = template;\n        this._overwriteBefore = overwriteBefore;\n        this._overwriteAfter = overwriteAfter;\n        this._adjustWhitespace = adjustWhitespace;\n    }\n    SnippetSession.adjustWhitespace = function (model, position, snippet) {\n        var line = model.getLineContent(position.lineNumber);\n        var lineLeadingWhitespace = strings_1.getLeadingWhitespace(line, 0, position.column - 1);\n        snippet.walk(function (marker) {\n            if (marker instanceof snippetParser_1.Text && !(marker.parent instanceof snippetParser_1.Choice)) {\n                // adjust indentation of text markers, except for choise elements\n                // which get adjusted when being selected\n                var lines = marker.value.split(/\\r\\n|\\r|\\n/);\n                for (var i = 1; i < lines.length; i++) {\n                    var templateLeadingWhitespace = strings_1.getLeadingWhitespace(lines[i]);\n                    lines[i] = model.normalizeIndentation(lineLeadingWhitespace + templateLeadingWhitespace) + lines[i].substr(templateLeadingWhitespace.length);\n                }\n                var newValue = lines.join(model.getEOL());\n                if (newValue !== marker.value) {\n                    marker.parent.replace(marker, [new snippetParser_1.Text(newValue)]);\n                }\n            }\n            return true;\n        });\n    };\n    SnippetSession.adjustSelection = function (model, selection, overwriteBefore, overwriteAfter) {\n        if (overwriteBefore !== 0 || overwriteAfter !== 0) {\n            // overwrite[Before|After] is compute using the position, not the whole\n            // selection. therefore we adjust the selection around that position\n            var positionLineNumber = selection.positionLineNumber, positionColumn = selection.positionColumn;\n            var positionColumnBefore = positionColumn - overwriteBefore;\n            var positionColumnAfter = positionColumn + overwriteAfter;\n            var range = model.validateRange({\n                startLineNumber: positionLineNumber,\n                startColumn: positionColumnBefore,\n                endLineNumber: positionLineNumber,\n                endColumn: positionColumnAfter\n            });\n            selection = selection_1.Selection.createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());\n        }\n        return selection;\n    };\n    SnippetSession.createEditsAndSnippets = function (editor, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace) {\n        var edits = [];\n        var snippets = [];\n        if (!editor.hasModel()) {\n            return { edits: edits, snippets: snippets };\n        }\n        var model = editor.getModel();\n        var modelBasedVariableResolver = new snippetVariables_1.ModelBasedVariableResolver(model);\n        var clipboardService = editor.invokeWithinContext(function (accessor) { return accessor.get(clipboardService_1.IClipboardService, instantiation_1.optional); });\n        var workspaceService = editor.invokeWithinContext(function (accessor) { return accessor.get(workspace_1.IWorkspaceContextService, instantiation_1.optional); });\n        var delta = 0;\n        // know what text the overwrite[Before|After] extensions\n        // of the primary curser have selected because only when\n        // secondary selections extend to the same text we can grow them\n        var firstBeforeText = model.getValueInRange(SnippetSession.adjustSelection(model, editor.getSelection(), overwriteBefore, 0));\n        var firstAfterText = model.getValueInRange(SnippetSession.adjustSelection(model, editor.getSelection(), 0, overwriteAfter));\n        // remember the first non-whitespace column to decide if\n        // `keepWhitespace` should be overruled for secondary selections\n        var firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor.getSelection().positionLineNumber);\n        // sort selections by their start position but remeber\n        // the original index. that allows you to create correct\n        // offset-based selection logic without changing the\n        // primary selection\n        var indexedSelections = editor.getSelections()\n            .map(function (selection, idx) { return ({ selection: selection, idx: idx }); })\n            .sort(function (a, b) { return range_1.Range.compareRangesUsingStarts(a.selection, b.selection); });\n        for (var _i = 0, indexedSelections_1 = indexedSelections; _i < indexedSelections_1.length; _i++) {\n            var _a = indexedSelections_1[_i], selection = _a.selection, idx = _a.idx;\n            // extend selection with the `overwriteBefore` and `overwriteAfter` and then\n            // compare if this matches the extensions of the primary selection\n            var extensionBefore = SnippetSession.adjustSelection(model, selection, overwriteBefore, 0);\n            var extensionAfter = SnippetSession.adjustSelection(model, selection, 0, overwriteAfter);\n            if (firstBeforeText !== model.getValueInRange(extensionBefore)) {\n                extensionBefore = selection;\n            }\n            if (firstAfterText !== model.getValueInRange(extensionAfter)) {\n                extensionAfter = selection;\n            }\n            // merge the before and after selection into one\n            var snippetSelection = selection\n                .setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn)\n                .setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);\n            var snippet = new snippetParser_1.SnippetParser().parse(template, true, enforceFinalTabstop);\n            // adjust the template string to match the indentation and\n            // whitespace rules of this insert location (can be different for each cursor)\n            // happens when being asked for (default) or when this is a secondary\n            // cursor and the leading whitespace is different\n            var start = snippetSelection.getStartPosition();\n            if (adjustWhitespace || (idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber))) {\n                SnippetSession.adjustWhitespace(model, start, snippet);\n            }\n            snippet.resolveVariables(new snippetVariables_1.CompositeSnippetVariableResolver([\n                modelBasedVariableResolver,\n                new snippetVariables_1.ClipboardBasedVariableResolver(clipboardService, idx, indexedSelections.length),\n                new snippetVariables_1.SelectionBasedVariableResolver(model, selection),\n                new snippetVariables_1.CommentBasedVariableResolver(model),\n                new snippetVariables_1.TimeBasedVariableResolver,\n                new snippetVariables_1.WorkspaceBasedVariableResolver(workspaceService),\n            ]));\n            var offset = model.getOffsetAt(start) + delta;\n            delta += snippet.toString().length - model.getValueLengthInRange(snippetSelection);\n            // store snippets with the index of their originating selection.\n            // that ensures the primiary cursor stays primary despite not being\n            // the one with lowest start position\n            edits[idx] = editOperation_1.EditOperation.replace(snippetSelection, snippet.toString());\n            snippets[idx] = new OneSnippet(editor, snippet, offset);\n        }\n        return { edits: edits, snippets: snippets };\n    };\n    SnippetSession.prototype.dispose = function () {\n        lifecycle_1.dispose(this._snippets);\n    };\n    SnippetSession.prototype._logInfo = function () {\n        return \"template=\\\"\" + this._template + \"\\\", merged_templates=\\\"\" + this._templateMerges.join(' -> ') + \"\\\"\";\n    };\n    SnippetSession.prototype.insert = function () {\n        var _this = this;\n        if (!this._editor.hasModel()) {\n            return;\n        }\n        var model = this._editor.getModel();\n        // make insert edit and start with first selections\n        var _a = SnippetSession.createEditsAndSnippets(this._editor, this._template, this._overwriteBefore, this._overwriteAfter, false, this._adjustWhitespace), edits = _a.edits, snippets = _a.snippets;\n        this._snippets = snippets;\n        var selections = model.pushEditOperations(this._editor.getSelections(), edits, function (undoEdits) {\n            if (_this._snippets[0].hasPlaceholder) {\n                return _this._move(true);\n            }\n            else {\n                return undoEdits.map(function (edit) { return selection_1.Selection.fromPositions(edit.range.getEndPosition()); });\n            }\n        });\n        this._editor.setSelections(selections);\n        this._editor.revealRange(selections[0]);\n    };\n    SnippetSession.prototype.merge = function (template, overwriteBefore, overwriteAfter, adjustWhitespace) {\n        var _this = this;\n        if (overwriteBefore === void 0) { overwriteBefore = 0; }\n        if (overwriteAfter === void 0) { overwriteAfter = 0; }\n        if (adjustWhitespace === void 0) { adjustWhitespace = true; }\n        if (!this._editor.hasModel()) {\n            return;\n        }\n        this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);\n        var _a = SnippetSession.createEditsAndSnippets(this._editor, template, overwriteBefore, overwriteAfter, true, adjustWhitespace), edits = _a.edits, snippets = _a.snippets;\n        this._editor.setSelections(this._editor.getModel().pushEditOperations(this._editor.getSelections(), edits, function (undoEdits) {\n            for (var _i = 0, _a = _this._snippets; _i < _a.length; _i++) {\n                var snippet = _a[_i];\n                snippet.merge(snippets);\n            }\n            console.assert(snippets.length === 0);\n            if (_this._snippets[0].hasPlaceholder) {\n                return _this._move(undefined);\n            }\n            else {\n                return undoEdits.map(function (edit) { return selection_1.Selection.fromPositions(edit.range.getEndPosition()); });\n            }\n        }));\n    };\n    SnippetSession.prototype.next = function () {\n        var newSelections = this._move(true);\n        this._editor.setSelections(newSelections);\n        this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n    };\n    SnippetSession.prototype.prev = function () {\n        var newSelections = this._move(false);\n        this._editor.setSelections(newSelections);\n        this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n    };\n    SnippetSession.prototype._move = function (fwd) {\n        var selections = [];\n        for (var _i = 0, _a = this._snippets; _i < _a.length; _i++) {\n            var snippet = _a[_i];\n            var oneSelection = snippet.move(fwd);\n            selections.push.apply(selections, oneSelection);\n        }\n        return selections;\n    };\n    Object.defineProperty(SnippetSession.prototype, \"isAtFirstPlaceholder\", {\n        get: function () {\n            return this._snippets[0].isAtFirstPlaceholder;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SnippetSession.prototype, \"isAtLastPlaceholder\", {\n        get: function () {\n            return this._snippets[0].isAtLastPlaceholder;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SnippetSession.prototype, \"hasPlaceholder\", {\n        get: function () {\n            return this._snippets[0].hasPlaceholder;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SnippetSession.prototype, \"choice\", {\n        get: function () {\n            return this._snippets[0].choice;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SnippetSession.prototype.isSelectionWithinPlaceholders = function () {\n        if (!this.hasPlaceholder) {\n            return false;\n        }\n        var selections = this._editor.getSelections();\n        if (selections.length < this._snippets.length) {\n            // this means we started snippet mode with N\n            // selections and have M (N > M) selections.\n            // So one snippet is without selection -> cancel\n            return false;\n        }\n        var allPossibleSelections = new Map();\n        var _loop_1 = function (snippet) {\n            var possibleSelections = snippet.computePossibleSelections();\n            // for the first snippet find the placeholder (and its ranges)\n            // that contain at least one selection. for all remaining snippets\n            // the same placeholder (and their ranges) must be used.\n            if (allPossibleSelections.size === 0) {\n                possibleSelections.forEach(function (ranges, index) {\n                    ranges.sort(range_1.Range.compareRangesUsingStarts);\n                    for (var _i = 0, selections_1 = selections; _i < selections_1.length; _i++) {\n                        var selection = selections_1[_i];\n                        if (ranges[0].containsRange(selection)) {\n                            allPossibleSelections.set(index, []);\n                            break;\n                        }\n                    }\n                });\n            }\n            if (allPossibleSelections.size === 0) {\n                return { value: false };\n            }\n            if (allPossibleSelections.has(0)) {\n                return { value: false };\n            }\n            // add selections from 'this' snippet so that we know all\n            // selections for this placeholder\n            allPossibleSelections.forEach(function (array, index) {\n                array.push.apply(array, possibleSelections.get(index));\n            });\n        };\n        for (var _i = 0, _a = this._snippets; _i < _a.length; _i++) {\n            var snippet = _a[_i];\n            var state_1 = _loop_1(snippet);\n            if (typeof state_1 === \"object\")\n                return state_1.value;\n        }\n        // sort selections (and later placeholder-ranges). then walk both\n        // arrays and make sure the placeholder-ranges contain the corresponding\n        // selection\n        selections.sort(range_1.Range.compareRangesUsingStarts);\n        allPossibleSelections.forEach(function (ranges, index) {\n            if (ranges.length !== selections.length) {\n                allPossibleSelections.delete(index);\n                return;\n            }\n            ranges.sort(range_1.Range.compareRangesUsingStarts);\n            for (var i = 0; i < ranges.length; i++) {\n                if (!ranges[i].containsRange(selections[i])) {\n                    allPossibleSelections.delete(index);\n                    return;\n                }\n            }\n        });\n        // from all possible selections we have deleted those\n        // that don't match with the current selection. if we don't\n        // have any left, we don't have a selection anymore\n        return allPossibleSelections.size > 0;\n    };\n    SnippetSession.prototype.getEnclosingRange = function () {\n        var result;\n        for (var _i = 0, _a = this._snippets; _i < _a.length; _i++) {\n            var snippet = _a[_i];\n            var snippetRange = snippet.getEnclosingRange();\n            if (!result) {\n                result = snippetRange;\n            }\n            else {\n                result = result.plusRange(snippetRange);\n            }\n        }\n        return result;\n    };\n    return SnippetSession;\n}());\nexports.SnippetSession = SnippetSession;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/snippet/snippetSession.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/contrib/snippet/snippetSession.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { groupBy } from 'vs/base/common/arrays';\nimport { dispose } from 'vs/base/common/lifecycle';\nimport { getLeadingWhitespace } from 'vs/base/common/strings';\nimport 'vs/css!./snippetSession';\nimport { IActiveCodeEditor } from 'vs/editor/browser/editorBrowser';\nimport { EditOperation } from 'vs/editor/common/core/editOperation';\nimport { IPosition } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { Selection } from 'vs/editor/common/core/selection';\nimport { IIdentifiedSingleEditOperation, ITextModel, TrackedRangeStickiness } from 'vs/editor/common/model';\nimport { ModelDecorationOptions } from 'vs/editor/common/model/textModel';\nimport { IClipboardService } from 'vs/platform/clipboard/common/clipboardService';\nimport { IWorkspaceContextService } from 'vs/platform/workspace/common/workspace';\nimport { optional } from 'vs/platform/instantiation/common/instantiation';\nimport { Choice, Placeholder, SnippetParser, Text, TextmateSnippet } from './snippetParser';\nimport { ClipboardBasedVariableResolver, CompositeSnippetVariableResolver, ModelBasedVariableResolver, SelectionBasedVariableResolver, TimeBasedVariableResolver, CommentBasedVariableResolver, WorkspaceBasedVariableResolver } from './snippetVariables';\nimport { registerThemingParticipant } from 'vs/platform/theme/common/themeService';\nimport * as colors from 'vs/platform/theme/common/colorRegistry';\nimport { withNullAsUndefined } from 'vs/base/common/types';\n\nregisterThemingParticipant((theme, collector) => {\n\n\tfunction getColorGraceful(name: string) {\n\t\tconst color = theme.getColor(name);\n\t\treturn color ? color.toString() : 'transparent';\n\t}\n\n\tcollector.addRule(`.monaco-editor .snippet-placeholder { background-color: ${getColorGraceful(colors.snippetTabstopHighlightBackground)}; outline-color: ${getColorGraceful(colors.snippetTabstopHighlightBorder)}; }`);\n\tcollector.addRule(`.monaco-editor .finish-snippet-placeholder { background-color: ${getColorGraceful(colors.snippetFinalTabstopHighlightBackground)}; outline-color: ${getColorGraceful(colors.snippetFinalTabstopHighlightBorder)}; }`);\n});\n\nexport class OneSnippet {\n\n\tprivate readonly _editor: IActiveCodeEditor;\n\tprivate readonly _snippet: TextmateSnippet;\n\tprivate readonly _offset: number;\n\n\tprivate _placeholderDecorations: Map<Placeholder, string>;\n\tprivate _placeholderGroups: Placeholder[][];\n\t_placeholderGroupsIdx: number;\n\t_nestingLevel: number = 1;\n\n\tprivate static readonly _decor = {\n\t\tactive: ModelDecorationOptions.register({ stickiness: TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges, className: 'snippet-placeholder' }),\n\t\tinactive: ModelDecorationOptions.register({ stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges, className: 'snippet-placeholder' }),\n\t\tactiveFinal: ModelDecorationOptions.register({ stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges, className: 'finish-snippet-placeholder' }),\n\t\tinactiveFinal: ModelDecorationOptions.register({ stickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges, className: 'finish-snippet-placeholder' }),\n\t};\n\n\tconstructor(editor: IActiveCodeEditor, snippet: TextmateSnippet, offset: number) {\n\t\tthis._editor = editor;\n\t\tthis._snippet = snippet;\n\t\tthis._offset = offset;\n\n\t\tthis._placeholderGroups = groupBy(snippet.placeholders, Placeholder.compareByIndex);\n\t\tthis._placeholderGroupsIdx = -1;\n\t}\n\n\tdispose(): void {\n\t\tif (this._placeholderDecorations) {\n\t\t\tlet toRemove: string[] = [];\n\t\t\tthis._placeholderDecorations.forEach(handle => toRemove.push(handle));\n\t\t\tthis._editor.deltaDecorations(toRemove, []);\n\t\t}\n\t\tthis._placeholderGroups.length = 0;\n\t}\n\n\tprivate _initDecorations(): void {\n\n\t\tif (this._placeholderDecorations) {\n\t\t\t// already initialized\n\t\t\treturn;\n\t\t}\n\n\t\tthis._placeholderDecorations = new Map<Placeholder, string>();\n\t\tconst model = this._editor.getModel();\n\n\t\tthis._editor.changeDecorations(accessor => {\n\t\t\t// create a decoration for each placeholder\n\t\t\tfor (const placeholder of this._snippet.placeholders) {\n\t\t\t\tconst placeholderOffset = this._snippet.offset(placeholder);\n\t\t\t\tconst placeholderLen = this._snippet.fullLen(placeholder);\n\t\t\t\tconst range = Range.fromPositions(\n\t\t\t\t\tmodel.getPositionAt(this._offset + placeholderOffset),\n\t\t\t\t\tmodel.getPositionAt(this._offset + placeholderOffset + placeholderLen)\n\t\t\t\t);\n\t\t\t\tconst options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;\n\t\t\t\tconst handle = accessor.addDecoration(range, options);\n\t\t\t\tthis._placeholderDecorations.set(placeholder, handle);\n\t\t\t}\n\t\t});\n\t}\n\n\tmove(fwd: boolean | undefined): Selection[] {\n\t\tif (!this._editor.hasModel()) {\n\t\t\treturn [];\n\t\t}\n\n\t\tthis._initDecorations();\n\n\t\t// Transform placeholder text if necessary\n\t\tif (this._placeholderGroupsIdx >= 0) {\n\t\t\tlet operations: IIdentifiedSingleEditOperation[] = [];\n\n\t\t\tfor (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n\t\t\t\t// Check if the placeholder has a transformation\n\t\t\t\tif (placeholder.transform) {\n\t\t\t\t\tconst id = this._placeholderDecorations.get(placeholder)!;\n\t\t\t\t\tconst range = this._editor.getModel().getDecorationRange(id)!;\n\t\t\t\t\tconst currentValue = this._editor.getModel().getValueInRange(range);\n\n\t\t\t\t\toperations.push(EditOperation.replaceMove(range, placeholder.transform.resolve(currentValue)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (operations.length > 0) {\n\t\t\t\tthis._editor.executeEdits('snippet.placeholderTransform', operations);\n\t\t\t}\n\t\t}\n\n\t\tlet skipThisPlaceholder = false;\n\t\tif (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {\n\t\t\tthis._placeholderGroupsIdx += 1;\n\t\t\tskipThisPlaceholder = true;\n\n\t\t} else if (fwd === false && this._placeholderGroupsIdx > 0) {\n\t\t\tthis._placeholderGroupsIdx -= 1;\n\t\t\tskipThisPlaceholder = true;\n\n\t\t} else {\n\t\t\t// the selection of the current placeholder might\n\t\t\t// not acurate any more -> simply restore it\n\t\t}\n\n\t\tconst newSelections = this._editor.getModel().changeDecorations(accessor => {\n\n\t\t\tconst activePlaceholders = new Set<Placeholder>();\n\n\t\t\t// change stickiness to always grow when typing at its edges\n\t\t\t// because these decorations represent the currently active\n\t\t\t// tabstop.\n\t\t\t// Special case #1: reaching the final tabstop\n\t\t\t// Special case #2: placeholders enclosing active placeholders\n\t\t\tconst selections: Selection[] = [];\n\t\t\tfor (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n\t\t\t\tconst id = this._placeholderDecorations.get(placeholder)!;\n\t\t\t\tconst range = this._editor.getModel().getDecorationRange(id)!;\n\t\t\t\tselections.push(new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn));\n\n\t\t\t\t// consider to skip this placeholder index when the decoration\n\t\t\t\t// range is empty but when the placeholder wasn't. that's a strong\n\t\t\t\t// hint that the placeholder has been deleted. (all placeholder must match this)\n\t\t\t\tskipThisPlaceholder = skipThisPlaceholder && (range.isEmpty() && placeholder.toString().length > 0);\n\n\t\t\t\taccessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n\t\t\t\tactivePlaceholders.add(placeholder);\n\n\t\t\t\tfor (const enclosingPlaceholder of this._snippet.enclosingPlaceholders(placeholder)) {\n\t\t\t\t\tconst id = this._placeholderDecorations.get(enclosingPlaceholder)!;\n\t\t\t\t\taccessor.changeDecorationOptions(id, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n\t\t\t\t\tactivePlaceholders.add(enclosingPlaceholder);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// change stickness to never grow when typing at its edges\n\t\t\t// so that in-active tabstops never grow\n\t\t\tthis._placeholderDecorations.forEach((id, placeholder) => {\n\t\t\t\tif (!activePlaceholders.has(placeholder)) {\n\t\t\t\t\taccessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn selections;\n\t\t})!;\n\n\t\treturn !skipThisPlaceholder ? newSelections : this.move(fwd);\n\t}\n\n\tget isAtFirstPlaceholder() {\n\t\treturn this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;\n\t}\n\n\tget isAtLastPlaceholder() {\n\t\treturn this._placeholderGroupsIdx === this._placeholderGroups.length - 1;\n\t}\n\n\tget hasPlaceholder() {\n\t\treturn this._snippet.placeholders.length > 0;\n\t}\n\n\tcomputePossibleSelections() {\n\t\tconst result = new Map<number, Range[]>();\n\t\tfor (const placeholdersWithEqualIndex of this._placeholderGroups) {\n\t\t\tlet ranges: Range[] | undefined;\n\n\t\t\tfor (const placeholder of placeholdersWithEqualIndex) {\n\n\t\t\t\tif (!ranges) {\n\t\t\t\t\tranges = [];\n\t\t\t\t\tresult.set(placeholder.index, ranges);\n\t\t\t\t}\n\n\t\t\t\tconst id = this._placeholderDecorations.get(placeholder)!;\n\t\t\t\tconst range = this._editor.getModel().getDecorationRange(id);\n\t\t\t\tif (!range) {\n\t\t\t\t\t// one of the placeholder lost its decoration and\n\t\t\t\t\t// therefore we bail out and pretend the placeholder\n\t\t\t\t\t// (with its mirrors) doesn't exist anymore.\n\t\t\t\t\tresult.delete(placeholder.index);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tranges.push(range);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tget choice(): Choice | undefined {\n\t\treturn this._placeholderGroups[this._placeholderGroupsIdx][0].choice;\n\t}\n\n\tmerge(others: OneSnippet[]): void {\n\n\t\tconst model = this._editor.getModel();\n\t\tthis._nestingLevel *= 10;\n\n\t\tthis._editor.changeDecorations(accessor => {\n\n\t\t\t// For each active placeholder take one snippet and merge it\n\t\t\t// in that the placeholder (can be many for `$1foo$1foo`). Because\n\t\t\t// everything is sorted by editor selection we can simply remove\n\t\t\t// elements from the beginning of the array\n\t\t\tfor (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n\t\t\t\tconst nested = others.shift()!;\n\t\t\t\tconsole.assert(!nested._placeholderDecorations);\n\n\t\t\t\t// Massage placeholder-indicies of the nested snippet to be\n\t\t\t\t// sorted right after the insertion point. This ensures we move\n\t\t\t\t// through the placeholders in the correct order\n\t\t\t\tconst indexLastPlaceholder = nested._snippet.placeholderInfo.last!.index;\n\n\t\t\t\tfor (const nestedPlaceholder of nested._snippet.placeholderInfo.all) {\n\t\t\t\t\tif (nestedPlaceholder.isFinalTabstop) {\n\t\t\t\t\t\tnestedPlaceholder.index = placeholder.index + ((indexLastPlaceholder + 1) / this._nestingLevel);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnestedPlaceholder.index = placeholder.index + (nestedPlaceholder.index / this._nestingLevel);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._snippet.replace(placeholder, nested._snippet.children);\n\n\t\t\t\t// Remove the placeholder at which position are inserting\n\t\t\t\t// the snippet and also remove its decoration.\n\t\t\t\tconst id = this._placeholderDecorations.get(placeholder)!;\n\t\t\t\taccessor.removeDecoration(id);\n\t\t\t\tthis._placeholderDecorations.delete(placeholder);\n\n\t\t\t\t// For each *new* placeholder we create decoration to monitor\n\t\t\t\t// how and if it grows/shrinks.\n\t\t\t\tfor (const placeholder of nested._snippet.placeholders) {\n\t\t\t\t\tconst placeholderOffset = nested._snippet.offset(placeholder);\n\t\t\t\t\tconst placeholderLen = nested._snippet.fullLen(placeholder);\n\t\t\t\t\tconst range = Range.fromPositions(\n\t\t\t\t\t\tmodel.getPositionAt(nested._offset + placeholderOffset),\n\t\t\t\t\t\tmodel.getPositionAt(nested._offset + placeholderOffset + placeholderLen)\n\t\t\t\t\t);\n\t\t\t\t\tconst handle = accessor.addDecoration(range, OneSnippet._decor.inactive);\n\t\t\t\t\tthis._placeholderDecorations.set(placeholder, handle);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Last, re-create the placeholder groups by sorting placeholders by their index.\n\t\t\tthis._placeholderGroups = groupBy(this._snippet.placeholders, Placeholder.compareByIndex);\n\t\t});\n\t}\n\n\tpublic getEnclosingRange(): Range | undefined {\n\t\tlet result: Range | undefined;\n\t\tconst model = this._editor.getModel();\n\t\tthis._placeholderDecorations.forEach((decorationId) => {\n\t\t\tconst placeholderRange = withNullAsUndefined(model.getDecorationRange(decorationId));\n\t\t\tif (!result) {\n\t\t\t\tresult = placeholderRange;\n\t\t\t} else {\n\t\t\t\tresult = result.plusRange(placeholderRange!);\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}\n}\n\nexport class SnippetSession {\n\n\tstatic adjustWhitespace(model: ITextModel, position: IPosition, snippet: TextmateSnippet): void {\n\t\tconst line = model.getLineContent(position.lineNumber);\n\t\tconst lineLeadingWhitespace = getLeadingWhitespace(line, 0, position.column - 1);\n\n\t\tsnippet.walk(marker => {\n\t\t\tif (marker instanceof Text && !(marker.parent instanceof Choice)) {\n\t\t\t\t// adjust indentation of text markers, except for choise elements\n\t\t\t\t// which get adjusted when being selected\n\t\t\t\tconst lines = marker.value.split(/\\r\\n|\\r|\\n/);\n\t\t\t\tfor (let i = 1; i < lines.length; i++) {\n\t\t\t\t\tlet templateLeadingWhitespace = getLeadingWhitespace(lines[i]);\n\t\t\t\t\tlines[i] = model.normalizeIndentation(lineLeadingWhitespace + templateLeadingWhitespace) + lines[i].substr(templateLeadingWhitespace.length);\n\t\t\t\t}\n\t\t\t\tconst newValue = lines.join(model.getEOL());\n\t\t\t\tif (newValue !== marker.value) {\n\t\t\t\t\tmarker.parent.replace(marker, [new Text(newValue)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t}\n\n\tstatic adjustSelection(model: ITextModel, selection: Selection, overwriteBefore: number, overwriteAfter: number): Selection {\n\t\tif (overwriteBefore !== 0 || overwriteAfter !== 0) {\n\t\t\t// overwrite[Before|After] is compute using the position, not the whole\n\t\t\t// selection. therefore we adjust the selection around that position\n\t\t\tconst { positionLineNumber, positionColumn } = selection;\n\t\t\tconst positionColumnBefore = positionColumn - overwriteBefore;\n\t\t\tconst positionColumnAfter = positionColumn + overwriteAfter;\n\n\t\t\tconst range = model.validateRange({\n\t\t\t\tstartLineNumber: positionLineNumber,\n\t\t\t\tstartColumn: positionColumnBefore,\n\t\t\t\tendLineNumber: positionLineNumber,\n\t\t\t\tendColumn: positionColumnAfter\n\t\t\t});\n\n\t\t\tselection = Selection.createWithDirection(\n\t\t\t\trange.startLineNumber, range.startColumn,\n\t\t\t\trange.endLineNumber, range.endColumn,\n\t\t\t\tselection.getDirection()\n\t\t\t);\n\t\t}\n\t\treturn selection;\n\t}\n\n\tstatic createEditsAndSnippets(editor: IActiveCodeEditor, template: string, overwriteBefore: number, overwriteAfter: number, enforceFinalTabstop: boolean, adjustWhitespace: boolean): { edits: IIdentifiedSingleEditOperation[], snippets: OneSnippet[] } {\n\t\tconst edits: IIdentifiedSingleEditOperation[] = [];\n\t\tconst snippets: OneSnippet[] = [];\n\n\t\tif (!editor.hasModel()) {\n\t\t\treturn { edits, snippets };\n\t\t}\n\t\tconst model = editor.getModel();\n\n\t\tconst modelBasedVariableResolver = new ModelBasedVariableResolver(model);\n\t\tconst clipboardService = editor.invokeWithinContext(accessor => accessor.get(IClipboardService, optional));\n\t\tconst workspaceService = editor.invokeWithinContext(accessor => accessor.get(IWorkspaceContextService, optional));\n\n\t\tlet delta = 0;\n\n\t\t// know what text the overwrite[Before|After] extensions\n\t\t// of the primary curser have selected because only when\n\t\t// secondary selections extend to the same text we can grow them\n\t\tlet firstBeforeText = model.getValueInRange(SnippetSession.adjustSelection(model, editor.getSelection(), overwriteBefore, 0));\n\t\tlet firstAfterText = model.getValueInRange(SnippetSession.adjustSelection(model, editor.getSelection(), 0, overwriteAfter));\n\n\t\t// remember the first non-whitespace column to decide if\n\t\t// `keepWhitespace` should be overruled for secondary selections\n\t\tlet firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor.getSelection().positionLineNumber);\n\n\t\t// sort selections by their start position but remeber\n\t\t// the original index. that allows you to create correct\n\t\t// offset-based selection logic without changing the\n\t\t// primary selection\n\t\tconst indexedSelections = editor.getSelections()\n\t\t\t.map((selection, idx) => ({ selection, idx }))\n\t\t\t.sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));\n\n\t\tfor (const { selection, idx } of indexedSelections) {\n\n\t\t\t// extend selection with the `overwriteBefore` and `overwriteAfter` and then\n\t\t\t// compare if this matches the extensions of the primary selection\n\t\t\tlet extensionBefore = SnippetSession.adjustSelection(model, selection, overwriteBefore, 0);\n\t\t\tlet extensionAfter = SnippetSession.adjustSelection(model, selection, 0, overwriteAfter);\n\t\t\tif (firstBeforeText !== model.getValueInRange(extensionBefore)) {\n\t\t\t\textensionBefore = selection;\n\t\t\t}\n\t\t\tif (firstAfterText !== model.getValueInRange(extensionAfter)) {\n\t\t\t\textensionAfter = selection;\n\t\t\t}\n\n\t\t\t// merge the before and after selection into one\n\t\t\tconst snippetSelection = selection\n\t\t\t\t.setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn)\n\t\t\t\t.setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);\n\n\t\t\tconst snippet = new SnippetParser().parse(template, true, enforceFinalTabstop);\n\n\t\t\t// adjust the template string to match the indentation and\n\t\t\t// whitespace rules of this insert location (can be different for each cursor)\n\t\t\t// happens when being asked for (default) or when this is a secondary\n\t\t\t// cursor and the leading whitespace is different\n\t\t\tconst start = snippetSelection.getStartPosition();\n\t\t\tif (adjustWhitespace || (idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber))) {\n\t\t\t\tSnippetSession.adjustWhitespace(model, start, snippet);\n\t\t\t}\n\n\t\t\tsnippet.resolveVariables(new CompositeSnippetVariableResolver([\n\t\t\t\tmodelBasedVariableResolver,\n\t\t\t\tnew ClipboardBasedVariableResolver(clipboardService, idx, indexedSelections.length),\n\t\t\t\tnew SelectionBasedVariableResolver(model, selection),\n\t\t\t\tnew CommentBasedVariableResolver(model),\n\t\t\t\tnew TimeBasedVariableResolver,\n\t\t\t\tnew WorkspaceBasedVariableResolver(workspaceService),\n\t\t\t]));\n\n\t\t\tconst offset = model.getOffsetAt(start) + delta;\n\t\t\tdelta += snippet.toString().length - model.getValueLengthInRange(snippetSelection);\n\n\t\t\t// store snippets with the index of their originating selection.\n\t\t\t// that ensures the primiary cursor stays primary despite not being\n\t\t\t// the one with lowest start position\n\t\t\tedits[idx] = EditOperation.replace(snippetSelection, snippet.toString());\n\t\t\tsnippets[idx] = new OneSnippet(editor, snippet, offset);\n\t\t}\n\n\t\treturn { edits, snippets };\n\t}\n\n\tprivate readonly _editor: IActiveCodeEditor;\n\tprivate readonly _template: string;\n\tprivate readonly _templateMerges: [number, number, string][] = [];\n\tprivate readonly _overwriteBefore: number;\n\tprivate readonly _overwriteAfter: number;\n\tprivate readonly _adjustWhitespace: boolean;\n\tprivate _snippets: OneSnippet[] = [];\n\n\tconstructor(editor: IActiveCodeEditor, template: string, overwriteBefore: number = 0, overwriteAfter: number = 0, adjustWhitespace: boolean = true) {\n\t\tthis._editor = editor;\n\t\tthis._template = template;\n\t\tthis._overwriteBefore = overwriteBefore;\n\t\tthis._overwriteAfter = overwriteAfter;\n\t\tthis._adjustWhitespace = adjustWhitespace;\n\t}\n\n\tdispose(): void {\n\t\tdispose(this._snippets);\n\t}\n\n\t_logInfo(): string {\n\t\treturn `template=\"${this._template}\", merged_templates=\"${this._templateMerges.join(' -> ')}\"`;\n\t}\n\n\tinsert(): void {\n\t\tif (!this._editor.hasModel()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst model = this._editor.getModel();\n\n\t\t// make insert edit and start with first selections\n\t\tconst { edits, snippets } = SnippetSession.createEditsAndSnippets(this._editor, this._template, this._overwriteBefore, this._overwriteAfter, false, this._adjustWhitespace);\n\t\tthis._snippets = snippets;\n\n\t\tconst selections = model.pushEditOperations(this._editor.getSelections(), edits, undoEdits => {\n\t\t\tif (this._snippets[0].hasPlaceholder) {\n\t\t\t\treturn this._move(true);\n\t\t\t} else {\n\t\t\t\treturn undoEdits.map(edit => Selection.fromPositions(edit.range.getEndPosition()));\n\t\t\t}\n\t\t})!;\n\t\tthis._editor.setSelections(selections);\n\t\tthis._editor.revealRange(selections[0]);\n\t}\n\n\tmerge(template: string, overwriteBefore: number = 0, overwriteAfter: number = 0, adjustWhitespace: boolean = true): void {\n\t\tif (!this._editor.hasModel()) {\n\t\t\treturn;\n\t\t}\n\t\tthis._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);\n\t\tconst { edits, snippets } = SnippetSession.createEditsAndSnippets(this._editor, template, overwriteBefore, overwriteAfter, true, adjustWhitespace);\n\n\t\tthis._editor.setSelections(this._editor.getModel().pushEditOperations(this._editor.getSelections(), edits, undoEdits => {\n\n\t\t\tfor (const snippet of this._snippets) {\n\t\t\t\tsnippet.merge(snippets);\n\t\t\t}\n\t\t\tconsole.assert(snippets.length === 0);\n\n\t\t\tif (this._snippets[0].hasPlaceholder) {\n\t\t\t\treturn this._move(undefined);\n\t\t\t} else {\n\t\t\t\treturn undoEdits.map(edit => Selection.fromPositions(edit.range.getEndPosition()));\n\t\t\t}\n\t\t})!);\n\t}\n\n\tnext(): void {\n\t\tconst newSelections = this._move(true);\n\t\tthis._editor.setSelections(newSelections);\n\t\tthis._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n\t}\n\n\tprev(): void {\n\t\tconst newSelections = this._move(false);\n\t\tthis._editor.setSelections(newSelections);\n\t\tthis._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n\t}\n\n\tprivate _move(fwd: boolean | undefined): Selection[] {\n\t\tconst selections: Selection[] = [];\n\t\tfor (const snippet of this._snippets) {\n\t\t\tconst oneSelection = snippet.move(fwd);\n\t\t\tselections.push(...oneSelection);\n\t\t}\n\t\treturn selections;\n\t}\n\n\tget isAtFirstPlaceholder() {\n\t\treturn this._snippets[0].isAtFirstPlaceholder;\n\t}\n\n\tget isAtLastPlaceholder() {\n\t\treturn this._snippets[0].isAtLastPlaceholder;\n\t}\n\n\tget hasPlaceholder() {\n\t\treturn this._snippets[0].hasPlaceholder;\n\t}\n\n\tget choice(): Choice | undefined {\n\t\treturn this._snippets[0].choice;\n\t}\n\n\tisSelectionWithinPlaceholders(): boolean {\n\n\t\tif (!this.hasPlaceholder) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst selections = this._editor.getSelections();\n\t\tif (selections.length < this._snippets.length) {\n\t\t\t// this means we started snippet mode with N\n\t\t\t// selections and have M (N > M) selections.\n\t\t\t// So one snippet is without selection -> cancel\n\t\t\treturn false;\n\t\t}\n\n\t\tlet allPossibleSelections = new Map<number, Range[]>();\n\t\tfor (const snippet of this._snippets) {\n\n\t\t\tconst possibleSelections = snippet.computePossibleSelections();\n\n\t\t\t// for the first snippet find the placeholder (and its ranges)\n\t\t\t// that contain at least one selection. for all remaining snippets\n\t\t\t// the same placeholder (and their ranges) must be used.\n\t\t\tif (allPossibleSelections.size === 0) {\n\t\t\t\tpossibleSelections.forEach((ranges, index) => {\n\n\t\t\t\t\tranges.sort(Range.compareRangesUsingStarts);\n\t\t\t\t\tfor (const selection of selections) {\n\t\t\t\t\t\tif (ranges[0].containsRange(selection)) {\n\t\t\t\t\t\t\tallPossibleSelections.set(index, []);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (allPossibleSelections.size === 0) {\n\t\t\t\t// return false if we couldn't associate a selection to\n\t\t\t\t// this (the first) snippet\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (allPossibleSelections.has(0)) {\n\t\t\t\t// selection overlaps with a final tab stop which means\n\t\t\t\t// we done\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// add selections from 'this' snippet so that we know all\n\t\t\t// selections for this placeholder\n\t\t\tallPossibleSelections.forEach((array, index) => {\n\t\t\t\tarray.push(...possibleSelections.get(index)!);\n\t\t\t});\n\t\t}\n\n\t\t// sort selections (and later placeholder-ranges). then walk both\n\t\t// arrays and make sure the placeholder-ranges contain the corresponding\n\t\t// selection\n\t\tselections.sort(Range.compareRangesUsingStarts);\n\n\t\tallPossibleSelections.forEach((ranges, index) => {\n\n\t\t\tif (ranges.length !== selections.length) {\n\t\t\t\tallPossibleSelections.delete(index);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tranges.sort(Range.compareRangesUsingStarts);\n\n\t\t\tfor (let i = 0; i < ranges.length; i++) {\n\t\t\t\tif (!ranges[i].containsRange(selections[i])) {\n\t\t\t\t\tallPossibleSelections.delete(index);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// from all possible selections we have deleted those\n\t\t// that don't match with the current selection. if we don't\n\t\t// have any left, we don't have a selection anymore\n\t\treturn allPossibleSelections.size > 0;\n\t}\n\n\tpublic getEnclosingRange(): Range | undefined {\n\t\tlet result: Range | undefined;\n\t\tfor (const snippet of this._snippets) {\n\t\t\tconst snippetRange = snippet.getEnclosingRange();\n\t\t\tif (!result) {\n\t\t\t\tresult = snippetRange;\n\t\t\t} else {\n\t\t\t\tresult = result.plusRange(snippetRange!);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n"]}]}