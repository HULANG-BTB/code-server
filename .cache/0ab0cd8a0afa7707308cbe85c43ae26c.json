{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/common/editor/editorGroup.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/common/editor/editorGroup.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/event\", \"vs/workbench/common/editor\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/configuration/common/configuration\", \"vs/base/common/lifecycle\", \"vs/platform/registry/common/platform\", \"vs/base/common/map\", \"vs/base/common/arrays\"], function (require, exports, event_1, editor_1, instantiation_1, configuration_1, lifecycle_1, platform_1, map_1, arrays_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const EditorOpenPositioning = {\n        LEFT: 'left',\n        RIGHT: 'right',\n        FIRST: 'first',\n        LAST: 'last'\n    };\n    function isSerializedEditorGroup(obj) {\n        const group = obj;\n        return obj && typeof obj === 'object' && Array.isArray(group.editors) && Array.isArray(group.mru);\n    }\n    exports.isSerializedEditorGroup = isSerializedEditorGroup;\n    let EditorGroup = class EditorGroup extends lifecycle_1.Disposable {\n        constructor(labelOrSerializedGroup, instantiationService, configurationService) {\n            super();\n            this.instantiationService = instantiationService;\n            this.configurationService = configurationService;\n            //#region events\n            this._onDidEditorActivate = this._register(new event_1.Emitter());\n            this._onDidEditorOpen = this._register(new event_1.Emitter());\n            this._onDidEditorClose = this._register(new event_1.Emitter());\n            this._onDidEditorDispose = this._register(new event_1.Emitter());\n            this._onDidEditorBecomeDirty = this._register(new event_1.Emitter());\n            this._onDidEditorLabelChange = this._register(new event_1.Emitter());\n            this._onDidEditorMove = this._register(new event_1.Emitter());\n            this._onDidEditorPin = this._register(new event_1.Emitter());\n            this._onDidEditorUnpin = this._register(new event_1.Emitter());\n            this.editors = [];\n            this.mru = [];\n            this.mapResourceToEditorCount = new map_1.ResourceMap();\n            if (isSerializedEditorGroup(labelOrSerializedGroup)) {\n                this.deserialize(labelOrSerializedGroup);\n            }\n            else {\n                this._id = EditorGroup.IDS++;\n            }\n            this.onConfigurationUpdated();\n            this.registerListeners();\n        }\n        get onDidEditorActivate() { return this._onDidEditorActivate.event; }\n        get onDidEditorOpen() { return this._onDidEditorOpen.event; }\n        get onDidEditorClose() { return this._onDidEditorClose.event; }\n        get onDidEditorDispose() { return this._onDidEditorDispose.event; }\n        get onDidEditorBecomeDirty() { return this._onDidEditorBecomeDirty.event; }\n        get onDidEditorLabelChange() { return this._onDidEditorLabelChange.event; }\n        get onDidEditorMove() { return this._onDidEditorMove.event; }\n        get onDidEditorPin() { return this._onDidEditorPin.event; }\n        get onDidEditorUnpin() { return this._onDidEditorUnpin.event; }\n        registerListeners() {\n            this._register(this.configurationService.onDidChangeConfiguration(e => this.onConfigurationUpdated(e)));\n        }\n        onConfigurationUpdated(event) {\n            this.editorOpenPositioning = this.configurationService.getValue('workbench.editor.openPositioning');\n            this.focusRecentEditorAfterClose = this.configurationService.getValue('workbench.editor.focusRecentEditorAfterClose');\n        }\n        get id() {\n            return this._id;\n        }\n        get count() {\n            return this.editors.length;\n        }\n        getEditors(mru) {\n            return mru ? this.mru.slice(0) : this.editors.slice(0);\n        }\n        getEditor(arg1) {\n            if (typeof arg1 === 'number') {\n                return this.editors[arg1];\n            }\n            const resource = arg1;\n            if (!this.contains(resource)) {\n                return null; // fast check for resource opened or not\n            }\n            for (const editor of this.editors) {\n                const editorResource = editor_1.toResource(editor, { supportSideBySide: true });\n                if (editorResource && editorResource.toString() === resource.toString()) {\n                    return editor;\n                }\n            }\n            return null;\n        }\n        get activeEditor() {\n            return this.active;\n        }\n        isActive(editor) {\n            return this.matches(this.active, editor);\n        }\n        get previewEditor() {\n            return this.preview;\n        }\n        isPreview(editor) {\n            return this.matches(this.preview, editor);\n        }\n        openEditor(editor, options) {\n            const index = this.indexOf(editor);\n            const makePinned = options && options.pinned;\n            const makeActive = (options && options.active) || !this.activeEditor || (!makePinned && this.matches(this.preview, this.activeEditor));\n            // New editor\n            if (index === -1) {\n                let targetIndex;\n                const indexOfActive = this.indexOf(this.active);\n                // Insert into specific position\n                if (options && typeof options.index === 'number') {\n                    targetIndex = options.index;\n                }\n                // Insert to the BEGINNING\n                else if (this.editorOpenPositioning === EditorOpenPositioning.FIRST) {\n                    targetIndex = 0;\n                }\n                // Insert to the END\n                else if (this.editorOpenPositioning === EditorOpenPositioning.LAST) {\n                    targetIndex = this.editors.length;\n                }\n                // Insert to the LEFT of active editor\n                else if (this.editorOpenPositioning === EditorOpenPositioning.LEFT) {\n                    if (indexOfActive === 0 || !this.editors.length) {\n                        targetIndex = 0; // to the left becoming first editor in list\n                    }\n                    else {\n                        targetIndex = indexOfActive; // to the left of active editor\n                    }\n                }\n                // Insert to the RIGHT of active editor\n                else {\n                    targetIndex = indexOfActive + 1;\n                }\n                // Insert into our list of editors if pinned or we have no preview editor\n                if (makePinned || !this.preview) {\n                    this.splice(targetIndex, false, editor);\n                }\n                // Handle preview\n                if (!makePinned) {\n                    // Replace existing preview with this editor if we have a preview\n                    if (this.preview) {\n                        const indexOfPreview = this.indexOf(this.preview);\n                        if (targetIndex > indexOfPreview) {\n                            targetIndex--; // accomodate for the fact that the preview editor closes\n                        }\n                        this.replaceEditor(this.preview, editor, targetIndex, !makeActive);\n                    }\n                    this.preview = editor;\n                }\n                // Listeners\n                this.registerEditorListeners(editor);\n                // Event\n                this._onDidEditorOpen.fire(editor);\n                // Handle active\n                if (makeActive) {\n                    this.setActive(editor);\n                }\n            }\n            // Existing editor\n            else {\n                // Pin it\n                if (makePinned) {\n                    this.pin(editor);\n                }\n                // Activate it\n                if (makeActive) {\n                    this.setActive(editor);\n                }\n                // Respect index\n                if (options && typeof options.index === 'number') {\n                    this.moveEditor(editor, options.index);\n                }\n            }\n        }\n        registerEditorListeners(editor) {\n            const unbind = [];\n            // Re-emit disposal of editor input as our own event\n            const onceDispose = event_1.Event.once(editor.onDispose);\n            unbind.push(onceDispose(() => {\n                if (this.indexOf(editor) >= 0) {\n                    this._onDidEditorDispose.fire(editor);\n                }\n            }));\n            // Re-Emit dirty state changes\n            unbind.push(editor.onDidChangeDirty(() => {\n                this._onDidEditorBecomeDirty.fire(editor);\n            }));\n            // Re-Emit label changes\n            unbind.push(editor.onDidChangeLabel(() => {\n                this._onDidEditorLabelChange.fire(editor);\n            }));\n            // Clean up dispose listeners once the editor gets closed\n            unbind.push(this.onDidEditorClose(event => {\n                if (event.editor.matches(editor)) {\n                    lifecycle_1.dispose(unbind);\n                }\n            }));\n        }\n        replaceEditor(toReplace, replaceWith, replaceIndex, openNext = true) {\n            const event = this.doCloseEditor(toReplace, openNext, true); // optimization to prevent multiple setActive() in one call\n            // We want to first add the new editor into our model before emitting the close event because\n            // firing the close event can trigger a dispose on the same editor that is now being added.\n            // This can lead into opening a disposed editor which is not what we want.\n            this.splice(replaceIndex, false, replaceWith);\n            if (event) {\n                this._onDidEditorClose.fire(event);\n            }\n        }\n        closeEditor(editor, openNext = true) {\n            const event = this.doCloseEditor(editor, openNext, false);\n            if (event) {\n                this._onDidEditorClose.fire(event);\n                return event.index;\n            }\n            return undefined;\n        }\n        doCloseEditor(editor, openNext, replaced) {\n            const index = this.indexOf(editor);\n            if (index === -1) {\n                return null; // not found\n            }\n            // Active Editor closed\n            if (openNext && this.matches(this.active, editor)) {\n                // More than one editor\n                if (this.mru.length > 1) {\n                    let newActive;\n                    if (this.focusRecentEditorAfterClose) {\n                        newActive = this.mru[1]; // active editor is always first in MRU, so pick second editor after as new active\n                    }\n                    else {\n                        if (index === this.editors.length - 1) {\n                            newActive = this.editors[index - 1]; // last editor is closed, pick previous as new active\n                        }\n                        else {\n                            newActive = this.editors[index + 1]; // pick next editor as new active\n                        }\n                    }\n                    this.setActive(newActive);\n                }\n                // One Editor\n                else {\n                    this.active = null;\n                }\n            }\n            // Preview Editor closed\n            if (this.matches(this.preview, editor)) {\n                this.preview = null;\n            }\n            // Remove from arrays\n            this.splice(index, true);\n            // Event\n            return { editor, replaced, index, groupId: this.id };\n        }\n        closeEditors(except, direction) {\n            const index = this.indexOf(except);\n            if (index === -1) {\n                return; // not found\n            }\n            // Close to the left\n            if (direction === editor_1.CloseDirection.LEFT) {\n                for (let i = index - 1; i >= 0; i--) {\n                    this.closeEditor(this.editors[i]);\n                }\n            }\n            // Close to the right\n            else if (direction === editor_1.CloseDirection.RIGHT) {\n                for (let i = this.editors.length - 1; i > index; i--) {\n                    this.closeEditor(this.editors[i]);\n                }\n            }\n            // Both directions\n            else {\n                this.mru.filter(e => !this.matches(e, except)).forEach(e => this.closeEditor(e));\n            }\n        }\n        closeAllEditors() {\n            // Optimize: close all non active editors first to produce less upstream work\n            this.mru.filter(e => !this.matches(e, this.active)).forEach(e => this.closeEditor(e));\n            if (this.active) {\n                this.closeEditor(this.active);\n            }\n        }\n        moveEditor(editor, toIndex) {\n            const index = this.indexOf(editor);\n            if (index < 0) {\n                return;\n            }\n            // Move\n            this.editors.splice(index, 1);\n            this.editors.splice(toIndex, 0, editor);\n            // Event\n            this._onDidEditorMove.fire(editor);\n        }\n        setActive(editor) {\n            const index = this.indexOf(editor);\n            if (index === -1) {\n                return; // not found\n            }\n            if (this.matches(this.active, editor)) {\n                return; // already active\n            }\n            this.active = editor;\n            // Bring to front in MRU list\n            this.setMostRecentlyUsed(editor);\n            // Event\n            this._onDidEditorActivate.fire(editor);\n        }\n        pin(editor) {\n            const index = this.indexOf(editor);\n            if (index === -1) {\n                return; // not found\n            }\n            if (!this.isPreview(editor)) {\n                return; // can only pin a preview editor\n            }\n            // Convert the preview editor to be a pinned editor\n            this.preview = null;\n            // Event\n            this._onDidEditorPin.fire(editor);\n        }\n        unpin(editor) {\n            const index = this.indexOf(editor);\n            if (index === -1) {\n                return; // not found\n            }\n            if (!this.isPinned(editor)) {\n                return; // can only unpin a pinned editor\n            }\n            // Set new\n            const oldPreview = this.preview;\n            this.preview = editor;\n            // Event\n            this._onDidEditorUnpin.fire(editor);\n            // Close old preview editor if any\n            if (oldPreview) {\n                this.closeEditor(oldPreview);\n            }\n        }\n        isPinned(arg1) {\n            let editor;\n            let index;\n            if (typeof arg1 === 'number') {\n                editor = this.editors[arg1];\n                index = arg1;\n            }\n            else {\n                editor = arg1;\n                index = this.indexOf(editor);\n            }\n            if (index === -1 || !editor) {\n                return false; // editor not found\n            }\n            if (!this.preview) {\n                return true; // no preview editor\n            }\n            return !this.matches(this.preview, editor);\n        }\n        splice(index, del, editor) {\n            const editorToDeleteOrReplace = this.editors[index];\n            const args = [index, del ? 1 : 0];\n            if (editor) {\n                args.push(editor);\n            }\n            // Perform on editors array\n            this.editors.splice.apply(this.editors, args);\n            // Add\n            if (!del && editor) {\n                this.mru.push(editor); // make it LRU editor\n                this.updateResourceMap(editor, false /* add */); // add new to resource map\n            }\n            // Remove / Replace\n            else {\n                const indexInMRU = this.indexOf(editorToDeleteOrReplace, this.mru);\n                // Remove\n                if (del && !editor) {\n                    this.mru.splice(indexInMRU, 1); // remove from MRU\n                    this.updateResourceMap(editorToDeleteOrReplace, true /* delete */); // remove from resource map\n                }\n                // Replace\n                else if (del && editor) {\n                    this.mru.splice(indexInMRU, 1, editor); // replace MRU at location\n                    this.updateResourceMap(editor, false /* add */); // add new to resource map\n                    this.updateResourceMap(editorToDeleteOrReplace, true /* delete */); // remove replaced from resource map\n                }\n            }\n        }\n        updateResourceMap(editor, remove) {\n            const resource = editor_1.toResource(editor, { supportSideBySide: true });\n            if (resource) {\n                // It is possible to have the same resource opened twice (once as normal input and once as diff input)\n                // So we need to do ref counting on the resource to provide the correct picture\n                const counter = this.mapResourceToEditorCount.get(resource) || 0;\n                // Add\n                let newCounter;\n                if (!remove) {\n                    newCounter = counter + 1;\n                }\n                // Delete\n                else {\n                    newCounter = counter - 1;\n                }\n                if (newCounter > 0) {\n                    this.mapResourceToEditorCount.set(resource, newCounter);\n                }\n                else {\n                    this.mapResourceToEditorCount.delete(resource);\n                }\n            }\n        }\n        indexOf(candidate, editors = this.editors) {\n            if (!candidate) {\n                return -1;\n            }\n            for (let i = 0; i < editors.length; i++) {\n                if (this.matches(editors[i], candidate)) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n        contains(editorOrResource, supportSideBySide) {\n            if (editorOrResource instanceof editor_1.EditorInput) {\n                const index = this.indexOf(editorOrResource);\n                if (index >= 0) {\n                    return true;\n                }\n                if (supportSideBySide && editorOrResource instanceof editor_1.SideBySideEditorInput) {\n                    const index = this.indexOf(editorOrResource.master);\n                    if (index >= 0) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            const counter = this.mapResourceToEditorCount.get(editorOrResource);\n            return typeof counter === 'number' && counter > 0;\n        }\n        setMostRecentlyUsed(editor) {\n            const index = this.indexOf(editor);\n            if (index === -1) {\n                return; // editor not found\n            }\n            const mruIndex = this.indexOf(editor, this.mru);\n            // Remove old index\n            this.mru.splice(mruIndex, 1);\n            // Set editor to front\n            this.mru.unshift(editor);\n        }\n        matches(editorA, editorB) {\n            return !!editorA && !!editorB && editorA.matches(editorB);\n        }\n        clone() {\n            const group = this.instantiationService.createInstance(EditorGroup, undefined);\n            group.editors = this.editors.slice(0);\n            group.mru = this.mru.slice(0);\n            group.mapResourceToEditorCount = this.mapResourceToEditorCount.clone();\n            group.preview = this.preview;\n            group.active = this.active;\n            group.editorOpenPositioning = this.editorOpenPositioning;\n            return group;\n        }\n        serialize() {\n            const registry = platform_1.Registry.as(editor_1.Extensions.EditorInputFactories);\n            // Serialize all editor inputs so that we can store them.\n            // Editors that cannot be serialized need to be ignored\n            // from mru, active and preview if any.\n            let serializableEditors = [];\n            let serializedEditors = [];\n            let serializablePreviewIndex;\n            this.editors.forEach(e => {\n                const factory = registry.getEditorInputFactory(e.getTypeId());\n                if (factory) {\n                    const value = factory.serialize(e);\n                    if (typeof value === 'string') {\n                        serializedEditors.push({ id: e.getTypeId(), value });\n                        serializableEditors.push(e);\n                        if (this.preview === e) {\n                            serializablePreviewIndex = serializableEditors.length - 1;\n                        }\n                    }\n                }\n            });\n            const serializableMru = this.mru.map(e => this.indexOf(e, serializableEditors)).filter(i => i >= 0);\n            return {\n                id: this.id,\n                editors: serializedEditors,\n                mru: serializableMru,\n                preview: serializablePreviewIndex,\n            };\n        }\n        deserialize(data) {\n            const registry = platform_1.Registry.as(editor_1.Extensions.EditorInputFactories);\n            if (typeof data.id === 'number') {\n                this._id = data.id;\n                EditorGroup.IDS = Math.max(data.id + 1, EditorGroup.IDS); // make sure our ID generator is always larger\n            }\n            else {\n                this._id = EditorGroup.IDS++; // backwards compatibility\n            }\n            this.editors = arrays_1.coalesce(data.editors.map(e => {\n                const factory = registry.getEditorInputFactory(e.id);\n                if (factory) {\n                    const editor = factory.deserialize(this.instantiationService, e.value);\n                    this.registerEditorListeners(editor);\n                    this.updateResourceMap(editor, false /* add */);\n                    return editor;\n                }\n                return null;\n            }));\n            this.mru = data.mru.map(i => this.editors[i]);\n            this.active = this.mru[0];\n            if (typeof data.preview === 'number') {\n                this.preview = this.editors[data.preview];\n            }\n        }\n    };\n    EditorGroup.IDS = 0;\n    EditorGroup = __decorate([\n        __param(1, instantiation_1.IInstantiationService),\n        __param(2, configuration_1.IConfigurationService)\n    ], EditorGroup);\n    exports.EditorGroup = EditorGroup;\n});\n",null]}