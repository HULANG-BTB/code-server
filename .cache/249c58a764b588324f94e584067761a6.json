{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/diagnostics/electron-main/diagnosticsService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/diagnostics/electron-main/diagnosticsService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/node/ps\", \"vs/platform/product/node/product\", \"vs/platform/product/node/package\", \"os\", \"vs/base/node/id\", \"vs/base/common/strings\", \"vs/base/common/platform\", \"electron\", \"vs/base/common/path\", \"vs/base/common/uri\", \"vs/platform/instantiation/common/instantiation\", \"fs\"], function (require, exports, ps_1, product_1, package_1, os, id_1, strings_1, platform_1, electron_1, path_1, uri_1, instantiation_1, fs_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.ID = 'diagnosticsService';\n    exports.IDiagnosticsService = instantiation_1.createDecorator(exports.ID);\n    class DiagnosticsService {\n        formatEnvironment(info) {\n            const MB = 1024 * 1024;\n            const GB = 1024 * MB;\n            const output = [];\n            output.push(`Version:          ${package_1.default.name} ${package_1.default.version} (${product_1.default.commit || 'Commit unknown'}, ${product_1.default.date || 'Date unknown'})`);\n            output.push(`OS Version:       ${os.type()} ${os.arch()} ${os.release()}`);\n            const cpus = os.cpus();\n            if (cpus && cpus.length > 0) {\n                output.push(`CPUs:             ${cpus[0].model} (${cpus.length} x ${cpus[0].speed})`);\n            }\n            output.push(`Memory (System):  ${(os.totalmem() / GB).toFixed(2)}GB (${(os.freemem() / GB).toFixed(2)}GB free)`);\n            if (!platform_1.isWindows) {\n                output.push(`Load (avg):       ${os.loadavg().map(l => Math.round(l)).join(', ')}`); // only provided on Linux/macOS\n            }\n            output.push(`VM:               ${Math.round((id_1.virtualMachineHint.value() * 100))}%`);\n            output.push(`Screen Reader:    ${electron_1.app.isAccessibilitySupportEnabled() ? 'yes' : 'no'}`);\n            output.push(`Process Argv:     ${info.mainArguments.join(' ')}`);\n            output.push(`GPU Status:       ${this.expandGPUFeatures()}`);\n            return output.join('\\n');\n        }\n        getPerformanceInfo(info) {\n            return ps_1.listProcesses(info.mainPID).then(rootProcess => {\n                const workspaceInfoMessages = [];\n                // Workspace Stats\n                const workspaceStatPromises = [];\n                if (info.windows.some(window => window.folderURIs && window.folderURIs.length > 0)) {\n                    info.windows.forEach(window => {\n                        if (window.folderURIs.length === 0) {\n                            return;\n                        }\n                        workspaceInfoMessages.push(`|  Window (${window.title})`);\n                        window.folderURIs.forEach(uriComponents => {\n                            const folderUri = uri_1.URI.revive(uriComponents);\n                            if (folderUri.scheme === 'file') {\n                                const folder = folderUri.fsPath;\n                                workspaceStatPromises.push(collectWorkspaceStats(folder, ['node_modules', '.git']).then((stats) => __awaiter(this, void 0, void 0, function* () {\n                                    let countMessage = `${stats.fileCount} files`;\n                                    if (stats.maxFilesReached) {\n                                        countMessage = `more than ${countMessage}`;\n                                    }\n                                    workspaceInfoMessages.push(`|    Folder (${path_1.basename(folder)}): ${countMessage}`);\n                                    workspaceInfoMessages.push(this.formatWorkspaceStats(stats));\n                                })));\n                            }\n                            else {\n                                workspaceInfoMessages.push(`|    Folder (${folderUri.toString()}): RPerformance stats not available.`);\n                            }\n                        });\n                    });\n                }\n                return Promise.all(workspaceStatPromises).then(() => {\n                    return {\n                        processInfo: this.formatProcessList(info, rootProcess),\n                        workspaceInfo: workspaceInfoMessages.join('\\n')\n                    };\n                }).catch(error => {\n                    return {\n                        processInfo: this.formatProcessList(info, rootProcess),\n                        workspaceInfo: `Unable to calculate workspace stats: ${error}`\n                    };\n                });\n            });\n        }\n        getSystemInfo(info) {\n            const MB = 1024 * 1024;\n            const GB = 1024 * MB;\n            const systemInfo = {\n                'Memory (System)': `${(os.totalmem() / GB).toFixed(2)}GB (${(os.freemem() / GB).toFixed(2)}GB free)`,\n                VM: `${Math.round((id_1.virtualMachineHint.value() * 100))}%`,\n                'Screen Reader': `${electron_1.app.isAccessibilitySupportEnabled() ? 'yes' : 'no'}`,\n                'Process Argv': `${info.mainArguments.join(' ')}`,\n                'GPU Status': electron_1.app.getGPUFeatureStatus()\n            };\n            const cpus = os.cpus();\n            if (cpus && cpus.length > 0) {\n                systemInfo.CPUs = `${cpus[0].model} (${cpus.length} x ${cpus[0].speed})`;\n            }\n            if (!platform_1.isWindows) {\n                systemInfo['Load (avg)'] = `${os.loadavg().map(l => Math.round(l)).join(', ')}`;\n            }\n            return systemInfo;\n        }\n        getDiagnostics(info) {\n            const output = [];\n            return ps_1.listProcesses(info.mainPID).then(rootProcess => {\n                // Environment Info\n                output.push('');\n                output.push(this.formatEnvironment(info));\n                // Process List\n                output.push('');\n                output.push(this.formatProcessList(info, rootProcess));\n                // Workspace Stats\n                const workspaceStatPromises = [];\n                if (info.windows.some(window => window.folderURIs && window.folderURIs.length > 0)) {\n                    output.push('');\n                    output.push('Workspace Stats: ');\n                    info.windows.forEach(window => {\n                        if (window.folderURIs.length === 0) {\n                            return;\n                        }\n                        output.push(`|  Window (${window.title})`);\n                        window.folderURIs.forEach(uriComponents => {\n                            const folderUri = uri_1.URI.revive(uriComponents);\n                            if (folderUri.scheme === 'file') {\n                                const folder = folderUri.fsPath;\n                                workspaceStatPromises.push(collectWorkspaceStats(folder, ['node_modules', '.git']).then((stats) => __awaiter(this, void 0, void 0, function* () {\n                                    let countMessage = `${stats.fileCount} files`;\n                                    if (stats.maxFilesReached) {\n                                        countMessage = `more than ${countMessage}`;\n                                    }\n                                    output.push(`|    Folder (${path_1.basename(folder)}): ${countMessage}`);\n                                    output.push(this.formatWorkspaceStats(stats));\n                                })).catch(error => {\n                                    output.push(`|      Error: Unable to collect workspace stats for folder ${folder} (${error.toString()})`);\n                                }));\n                            }\n                            else {\n                                output.push(`|    Folder (${folderUri.toString()}): Workspace stats not available.`);\n                            }\n                        });\n                    });\n                }\n                return Promise.all(workspaceStatPromises).then(() => {\n                    output.push('');\n                    output.push('');\n                    return output.join('\\n');\n                });\n            });\n        }\n        formatWorkspaceStats(workspaceStats) {\n            const output = [];\n            const lineLength = 60;\n            let col = 0;\n            const appendAndWrap = (name, count) => {\n                const item = ` ${name}(${count})`;\n                if (col + item.length > lineLength) {\n                    output.push(line);\n                    line = '|                 ';\n                    col = line.length;\n                }\n                else {\n                    col += item.length;\n                }\n                line += item;\n            };\n            // File Types\n            let line = '|      File types:';\n            const maxShown = 10;\n            let max = workspaceStats.fileTypes.length > maxShown ? maxShown : workspaceStats.fileTypes.length;\n            for (let i = 0; i < max; i++) {\n                const item = workspaceStats.fileTypes[i];\n                appendAndWrap(item.name, item.count);\n            }\n            output.push(line);\n            // Conf Files\n            if (workspaceStats.configFiles.length >= 0) {\n                line = '|      Conf files:';\n                col = 0;\n                workspaceStats.configFiles.forEach((item) => {\n                    appendAndWrap(item.name, item.count);\n                });\n                output.push(line);\n            }\n            // if (workspaceStats.launchConfigFiles.length > 0) {\n            // \tlet line = '|      Launch Configs:';\n            // \tworkspaceStats.launchConfigFiles.forEach(each => {\n            // \t\tconst item = each.count > 1 ? ` ${each.name}(${each.count})` : ` ${each.name}`;\n            // \t\tline += item;\n            // \t});\n            // \toutput.push(line);\n            // }\n            return output.join('\\n');\n        }\n        expandGPUFeatures() {\n            const gpuFeatures = electron_1.app.getGPUFeatureStatus();\n            const longestFeatureName = Math.max(...Object.keys(gpuFeatures).map(feature => feature.length));\n            // Make columns aligned by adding spaces after feature name\n            return Object.keys(gpuFeatures).map(feature => `${feature}:  ${strings_1.repeat(' ', longestFeatureName - feature.length)}  ${gpuFeatures[feature]}`).join('\\n                  ');\n        }\n        formatProcessList(info, rootProcess) {\n            const mapPidToWindowTitle = new Map();\n            info.windows.forEach(window => mapPidToWindowTitle.set(window.pid, window.title));\n            const output = [];\n            output.push('CPU %\\tMem MB\\t   PID\\tProcess');\n            if (rootProcess) {\n                this.formatProcessItem(mapPidToWindowTitle, output, rootProcess, 0);\n            }\n            return output.join('\\n');\n        }\n        formatProcessItem(mapPidToWindowTitle, output, item, indent) {\n            const isRoot = (indent === 0);\n            const MB = 1024 * 1024;\n            // Format name with indent\n            let name;\n            if (isRoot) {\n                name = `${product_1.default.applicationName} main`;\n            }\n            else {\n                name = `${strings_1.repeat('  ', indent)} ${item.name}`;\n                if (item.name === 'window') {\n                    name = `${name} (${mapPidToWindowTitle.get(item.pid)})`;\n                }\n            }\n            const memory = process.platform === 'win32' ? item.mem : (os.totalmem() * (item.mem / 100));\n            output.push(`${strings_1.pad(Number(item.load.toFixed(0)), 5, ' ')}\\t${strings_1.pad(Number((memory / MB).toFixed(0)), 6, ' ')}\\t${strings_1.pad(Number((item.pid).toFixed(0)), 6, ' ')}\\t${name}`);\n            // Recurse into children if any\n            if (Array.isArray(item.children)) {\n                item.children.forEach(child => this.formatProcessItem(mapPidToWindowTitle, output, child, indent + 1));\n            }\n        }\n    }\n    exports.DiagnosticsService = DiagnosticsService;\n    function asSortedItems(map) {\n        const a = [];\n        map.forEach((value, index) => a.push({ name: index, count: value }));\n        return a.sort((a, b) => b.count - a.count);\n    }\n    // function collectLaunchConfigs(folder: string): Promise<WorkspaceStatItem[]> {\n    // \tconst launchConfigs = new Map<string, number>();\n    // \tconst launchConfig = join(folder, '.vscode', 'launch.json');\n    // \treturn new Promise((resolve, reject) => {\n    // \t\texists(launchConfig, (doesExist) => {\n    // \t\t\tif (doesExist) {\n    // \t\t\t\treadFile(launchConfig, (err, contents) => {\n    // \t\t\t\t\tif (err) {\n    // \t\t\t\t\t\treturn resolve([]);\n    // \t\t\t\t\t}\n    // \t\t\t\t\tconst errors: ParseError[] = [];\n    // \t\t\t\t\tconst json = parse(contents.toString(), errors);\n    // \t\t\t\t\tif (errors.length) {\n    // \t\t\t\t\t\toutput.push(`Unable to parse ${launchConfig}`);\n    // \t\t\t\t\t\treturn resolve([]);\n    // \t\t\t\t\t}\n    // \t\t\t\t\tif (json['configurations']) {\n    // \t\t\t\t\t\tfor (const each of json['configurations']) {\n    // \t\t\t\t\t\t\tconst type = each['type'];\n    // \t\t\t\t\t\t\tif (type) {\n    // \t\t\t\t\t\t\t\tif (launchConfigs.has(type)) {\n    // \t\t\t\t\t\t\t\t\tlaunchConfigs.set(type, launchConfigs.get(type)! + 1);\n    // \t\t\t\t\t\t\t\t} else {\n    // \t\t\t\t\t\t\t\t\tlaunchConfigs.set(type, 1);\n    // \t\t\t\t\t\t\t\t}\n    // \t\t\t\t\t\t\t}\n    // \t\t\t\t\t\t}\n    // \t\t\t\t\t}\n    // \t\t\t\t\treturn resolve(asSortedItems(launchConfigs));\n    // \t\t\t\t});\n    // \t\t\t} else {\n    // \t\t\t\treturn resolve([]);\n    // \t\t\t}\n    // \t\t});\n    // \t});\n    // }\n    function collectWorkspaceStats(folder, filter) {\n        const configFilePatterns = [\n            { 'tag': 'grunt.js', 'pattern': /^gruntfile\\.js$/i },\n            { 'tag': 'gulp.js', 'pattern': /^gulpfile\\.js$/i },\n            { 'tag': 'tsconfig.json', 'pattern': /^tsconfig\\.json$/i },\n            { 'tag': 'package.json', 'pattern': /^package\\.json$/i },\n            { 'tag': 'jsconfig.json', 'pattern': /^jsconfig\\.json$/i },\n            { 'tag': 'tslint.json', 'pattern': /^tslint\\.json$/i },\n            { 'tag': 'eslint.json', 'pattern': /^eslint\\.json$/i },\n            { 'tag': 'tasks.json', 'pattern': /^tasks\\.json$/i },\n            { 'tag': 'launch.json', 'pattern': /^launch\\.json$/i },\n            { 'tag': 'settings.json', 'pattern': /^settings\\.json$/i },\n            { 'tag': 'webpack.config.js', 'pattern': /^webpack\\.config\\.js$/i },\n            { 'tag': 'project.json', 'pattern': /^project\\.json$/i },\n            { 'tag': 'makefile', 'pattern': /^makefile$/i },\n            { 'tag': 'sln', 'pattern': /^.+\\.sln$/i },\n            { 'tag': 'csproj', 'pattern': /^.+\\.csproj$/i },\n            { 'tag': 'cmake', 'pattern': /^.+\\.cmake$/i }\n        ];\n        const fileTypes = new Map();\n        const configFiles = new Map();\n        const MAX_FILES = 20000;\n        function walk(dir, filter, token, done) {\n            let results = [];\n            fs_1.readdir(dir, (err, files) => __awaiter(this, void 0, void 0, function* () {\n                // Ignore folders that can't be read\n                if (err) {\n                    return done(results);\n                }\n                let pending = files.length;\n                if (pending === 0) {\n                    return done(results);\n                }\n                for (const file of files) {\n                    if (token.maxReached) {\n                        return done(results);\n                    }\n                    fs_1.stat(path_1.join(dir, file), (err, stats) => {\n                        // Ignore files that can't be read\n                        if (err) {\n                            if (--pending === 0) {\n                                return done(results);\n                            }\n                        }\n                        else {\n                            if (stats.isDirectory()) {\n                                if (filter.indexOf(file) === -1) {\n                                    walk(path_1.join(dir, file), filter, token, (res) => {\n                                        results = results.concat(res);\n                                        if (--pending === 0) {\n                                            return done(results);\n                                        }\n                                    });\n                                }\n                                else {\n                                    if (--pending === 0) {\n                                        done(results);\n                                    }\n                                }\n                            }\n                            else {\n                                if (token.count >= MAX_FILES) {\n                                    token.maxReached = true;\n                                }\n                                token.count++;\n                                results.push(file);\n                                if (--pending === 0) {\n                                    done(results);\n                                }\n                            }\n                        }\n                    });\n                }\n            }));\n        }\n        const addFileType = (fileType) => {\n            if (fileTypes.has(fileType)) {\n                fileTypes.set(fileType, fileTypes.get(fileType) + 1);\n            }\n            else {\n                fileTypes.set(fileType, 1);\n            }\n        };\n        const addConfigFiles = (fileName) => {\n            for (const each of configFilePatterns) {\n                if (each.pattern.test(fileName)) {\n                    if (configFiles.has(each.tag)) {\n                        configFiles.set(each.tag, configFiles.get(each.tag) + 1);\n                    }\n                    else {\n                        configFiles.set(each.tag, 1);\n                    }\n                }\n            }\n        };\n        const acceptFile = (name) => {\n            if (name.lastIndexOf('.') >= 0) {\n                const suffix = name.split('.').pop();\n                if (suffix) {\n                    addFileType(suffix);\n                }\n            }\n            addConfigFiles(name);\n        };\n        const token = { count: 0, maxReached: false };\n        return new Promise((resolve, reject) => {\n            walk(folder, filter, token, (files) => __awaiter(this, void 0, void 0, function* () {\n                files.forEach(acceptFile);\n                // TODO@rachel commented out due to severe performance issues\n                // see https://github.com/Microsoft/vscode/issues/70563\n                // const launchConfigs = await collectLaunchConfigs(folder);\n                resolve({\n                    configFiles: asSortedItems(configFiles),\n                    fileTypes: asSortedItems(fileTypes),\n                    fileCount: token.count,\n                    maxFilesReached: token.maxReached,\n                });\n            }));\n        });\n    }\n});\n",null]}