{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/common/taskDefinitionRegistry.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/common/taskDefinitionRegistry.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/types\", \"vs/base/common/objects\", \"vs/workbench/services/extensions/common/extensionsRegistry\"], function (require, exports, nls, Types, Objects, extensionsRegistry_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const taskDefinitionSchema = {\n        type: 'object',\n        additionalProperties: false,\n        properties: {\n            type: {\n                type: 'string',\n                description: nls.localize('TaskDefinition.description', 'The actual task type. Please note that types starting with a \\'$\\' are reserved for internal usage.')\n            },\n            required: {\n                type: 'array',\n                items: {\n                    type: 'string'\n                }\n            },\n            properties: {\n                type: 'object',\n                description: nls.localize('TaskDefinition.properties', 'Additional properties of the task type'),\n                additionalProperties: {\n                    $ref: 'http://json-schema.org/draft-04/schema#'\n                }\n            }\n        }\n    };\n    var Configuration;\n    (function (Configuration) {\n        function from(value, extensionId, messageCollector) {\n            if (!value) {\n                return undefined;\n            }\n            let taskType = Types.isString(value.type) ? value.type : undefined;\n            if (!taskType || taskType.length === 0) {\n                messageCollector.error(nls.localize('TaskTypeConfiguration.noType', 'The task type configuration is missing the required \\'taskType\\' property'));\n                return undefined;\n            }\n            let required = [];\n            if (Array.isArray(value.required)) {\n                for (let element of value.required) {\n                    if (Types.isString(element)) {\n                        required.push(element);\n                    }\n                }\n            }\n            return { extensionId: extensionId.value, taskType, required: required, properties: value.properties ? Objects.deepClone(value.properties) : {} };\n        }\n        Configuration.from = from;\n    })(Configuration || (Configuration = {}));\n    const taskDefinitionsExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint({\n        extensionPoint: 'taskDefinitions',\n        jsonSchema: {\n            description: nls.localize('TaskDefinitionExtPoint', 'Contributes task kinds'),\n            type: 'array',\n            items: taskDefinitionSchema\n        }\n    });\n    class TaskDefinitionRegistryImpl {\n        constructor() {\n            this.taskTypes = Object.create(null);\n            this.readyPromise = new Promise((resolve, reject) => {\n                taskDefinitionsExtPoint.setHandler((extensions, delta) => {\n                    try {\n                        for (let extension of delta.removed) {\n                            let taskTypes = extension.value;\n                            for (let taskType of taskTypes) {\n                                if (this.taskTypes && taskType.type && this.taskTypes[taskType.type]) {\n                                    delete this.taskTypes[taskType.type];\n                                }\n                            }\n                        }\n                        for (let extension of delta.added) {\n                            let taskTypes = extension.value;\n                            for (let taskType of taskTypes) {\n                                let type = Configuration.from(taskType, extension.description.identifier, extension.collector);\n                                if (type) {\n                                    this.taskTypes[type.taskType] = type;\n                                }\n                            }\n                        }\n                    }\n                    catch (error) {\n                    }\n                    resolve(undefined);\n                });\n            });\n        }\n        onReady() {\n            return this.readyPromise;\n        }\n        get(key) {\n            return this.taskTypes[key];\n        }\n        all() {\n            return Object.keys(this.taskTypes).map(key => this.taskTypes[key]);\n        }\n        getJsonSchema() {\n            if (this._schema === undefined) {\n                let schemas = [];\n                for (let definition of this.all()) {\n                    let schema = {\n                        type: 'object',\n                        additionalProperties: false\n                    };\n                    if (definition.required.length > 0) {\n                        schema.required = definition.required.slice(0);\n                    }\n                    if (definition.properties !== undefined) {\n                        schema.properties = Objects.deepClone(definition.properties);\n                    }\n                    else {\n                        schema.properties = Object.create(null);\n                    }\n                    schema.properties.type = {\n                        type: 'string',\n                        enum: [definition.taskType]\n                    };\n                    schemas.push(schema);\n                }\n                this._schema = { oneOf: schemas };\n            }\n            return this._schema;\n        }\n    }\n    exports.TaskDefinitionRegistry = new TaskDefinitionRegistryImpl();\n});\n",null]}