{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/log/common/bufferLog.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/log/common/bufferLog.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/platform/log/common/log\"], function (require, exports, log_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function getLogFunction(logger, level) {\n        switch (level) {\n            case log_1.LogLevel.Trace: return logger.trace;\n            case log_1.LogLevel.Debug: return logger.debug;\n            case log_1.LogLevel.Info: return logger.info;\n            case log_1.LogLevel.Warning: return logger.warn;\n            case log_1.LogLevel.Error: return logger.error;\n            case log_1.LogLevel.Critical: return logger.critical;\n            default: throw new Error('Invalid log level');\n        }\n    }\n    class BufferLogService extends log_1.AbstractLogService {\n        constructor() {\n            super();\n            this.buffer = [];\n            this._logger = undefined;\n            this._register(this.onDidChangeLogLevel(level => {\n                if (this._logger) {\n                    this._logger.setLevel(level);\n                }\n            }));\n        }\n        set logger(logger) {\n            this._logger = logger;\n            for (const { level, args } of this.buffer) {\n                const fn = getLogFunction(logger, level);\n                fn.apply(logger, args);\n            }\n            this.buffer = [];\n        }\n        _log(level, args) {\n            if (this._logger) {\n                const fn = getLogFunction(this._logger, level);\n                fn.apply(this._logger, args);\n            }\n            else if (this.getLevel() <= level) {\n                this.buffer.push({ level, args });\n            }\n        }\n        trace() {\n            this._log(log_1.LogLevel.Trace, arguments);\n        }\n        debug() {\n            this._log(log_1.LogLevel.Debug, arguments);\n        }\n        info() {\n            this._log(log_1.LogLevel.Info, arguments);\n        }\n        warn() {\n            this._log(log_1.LogLevel.Warning, arguments);\n        }\n        error() {\n            this._log(log_1.LogLevel.Error, arguments);\n        }\n        critical() {\n            this._log(log_1.LogLevel.Critical, arguments);\n        }\n        dispose() {\n            if (this._logger) {\n                this._logger.dispose();\n            }\n        }\n    }\n    exports.BufferLogService = BufferLogService;\n});\n",null]}