{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/backup/node/backupFileService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/backup/node/backupFileService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar path = require(\"vs/base/common/path\");\nvar crypto = require(\"crypto\");\nvar pfs = require(\"vs/base/node/pfs\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar async_1 = require(\"vs/base/common/async\");\nvar backup_1 = require(\"vs/workbench/services/backup/common/backup\");\nvar files_1 = require(\"vs/platform/files/common/files\");\nvar stream_1 = require(\"vs/base/node/stream\");\nvar textModel_1 = require(\"vs/editor/common/model/textModel\");\nvar map_1 = require(\"vs/base/common/map\");\nvar network_1 = require(\"vs/base/common/network\");\nvar windows_1 = require(\"vs/platform/windows/common/windows\");\nvar extensions_1 = require(\"vs/platform/instantiation/common/extensions\");\nvar BackupSnapshot = /** @class */ (function () {\n    function BackupSnapshot(snapshot, preamble) {\n        this.snapshot = snapshot;\n        this.preamble = preamble;\n    }\n    BackupSnapshot.prototype.read = function () {\n        var value = this.snapshot.read();\n        if (!this.preambleHandled) {\n            this.preambleHandled = true;\n            if (typeof value === 'string') {\n                value = this.preamble + value;\n            }\n            else {\n                value = this.preamble;\n            }\n        }\n        return value;\n    };\n    return BackupSnapshot;\n}());\nexports.BackupSnapshot = BackupSnapshot;\nvar BackupFilesModel = /** @class */ (function () {\n    function BackupFilesModel() {\n        this.cache = Object.create(null);\n    }\n    BackupFilesModel.prototype.resolve = function (backupRoot) {\n        var _this = this;\n        return pfs.readDirsInDir(backupRoot).then(function (backupSchemas) {\n            // For all supported schemas\n            return Promise.all(backupSchemas.map(function (backupSchema) {\n                // Read backup directory for backups\n                var backupSchemaPath = path.join(backupRoot, backupSchema);\n                return pfs.readdir(backupSchemaPath).then(function (backupHashes) {\n                    // Remember known backups in our caches\n                    backupHashes.forEach(function (backupHash) {\n                        var backupResource = uri_1.URI.file(path.join(backupSchemaPath, backupHash));\n                        _this.add(backupResource);\n                    });\n                });\n            }));\n        }).then(function () { return _this; }, function (error) { return _this; });\n    };\n    BackupFilesModel.prototype.add = function (resource, versionId) {\n        if (versionId === void 0) { versionId = 0; }\n        this.cache[resource.toString()] = versionId;\n    };\n    BackupFilesModel.prototype.count = function () {\n        return Object.keys(this.cache).length;\n    };\n    BackupFilesModel.prototype.has = function (resource, versionId) {\n        var cachedVersionId = this.cache[resource.toString()];\n        if (typeof cachedVersionId !== 'number') {\n            return false; // unknown resource\n        }\n        if (typeof versionId === 'number') {\n            return versionId === cachedVersionId; // if we are asked with a specific version ID, make sure to test for it\n        }\n        return true;\n    };\n    BackupFilesModel.prototype.get = function () {\n        return Object.keys(this.cache).map(function (k) { return uri_1.URI.parse(k); });\n    };\n    BackupFilesModel.prototype.remove = function (resource) {\n        delete this.cache[resource.toString()];\n    };\n    BackupFilesModel.prototype.clear = function () {\n        this.cache = Object.create(null);\n    };\n    return BackupFilesModel;\n}());\nexports.BackupFilesModel = BackupFilesModel;\nvar BackupFileService = /** @class */ (function () {\n    function BackupFileService(windowService, fileService) {\n        var backupWorkspacePath = windowService.getConfiguration().backupPath;\n        if (backupWorkspacePath) {\n            this.impl = new BackupFileServiceImpl(backupWorkspacePath, fileService);\n        }\n        else {\n            this.impl = new InMemoryBackupFileService();\n        }\n    }\n    BackupFileService.prototype.initialize = function (backupWorkspacePath) {\n        if (this.impl instanceof BackupFileServiceImpl) {\n            this.impl.initialize(backupWorkspacePath);\n        }\n    };\n    BackupFileService.prototype.hasBackups = function () {\n        return this.impl.hasBackups();\n    };\n    BackupFileService.prototype.loadBackupResource = function (resource) {\n        return this.impl.loadBackupResource(resource);\n    };\n    BackupFileService.prototype.backupResource = function (resource, content, versionId) {\n        return this.impl.backupResource(resource, content, versionId);\n    };\n    BackupFileService.prototype.discardResourceBackup = function (resource) {\n        return this.impl.discardResourceBackup(resource);\n    };\n    BackupFileService.prototype.discardAllWorkspaceBackups = function () {\n        return this.impl.discardAllWorkspaceBackups();\n    };\n    BackupFileService.prototype.getWorkspaceFileBackups = function () {\n        return this.impl.getWorkspaceFileBackups();\n    };\n    BackupFileService.prototype.resolveBackupContent = function (backup) {\n        return this.impl.resolveBackupContent(backup);\n    };\n    BackupFileService.prototype.toBackupResource = function (resource) {\n        return this.impl.toBackupResource(resource);\n    };\n    BackupFileService = tslib_1.__decorate([\n        tslib_1.__param(0, windows_1.IWindowService),\n        tslib_1.__param(1, files_1.IFileService)\n    ], BackupFileService);\n    return BackupFileService;\n}());\nexports.BackupFileService = BackupFileService;\nvar BackupFileServiceImpl = /** @class */ (function () {\n    function BackupFileServiceImpl(backupWorkspacePath, fileService) {\n        this.fileService = fileService;\n        this.isShuttingDown = false;\n        this.ioOperationQueues = new async_1.ResourceQueue();\n        this.initialize(backupWorkspacePath);\n    }\n    BackupFileServiceImpl.prototype.initialize = function (backupWorkspacePath) {\n        this.backupWorkspacePath = backupWorkspacePath;\n        this.ready = this.init();\n    };\n    BackupFileServiceImpl.prototype.init = function () {\n        var model = new BackupFilesModel();\n        return model.resolve(this.backupWorkspacePath);\n    };\n    BackupFileServiceImpl.prototype.hasBackups = function () {\n        return this.ready.then(function (model) {\n            return model.count() > 0;\n        });\n    };\n    BackupFileServiceImpl.prototype.loadBackupResource = function (resource) {\n        var _this = this;\n        return this.ready.then(function (model) {\n            // Return directly if we have a known backup with that resource\n            var backupResource = _this.toBackupResource(resource);\n            if (model.has(backupResource)) {\n                return backupResource;\n            }\n            return undefined;\n        });\n    };\n    BackupFileServiceImpl.prototype.backupResource = function (resource, content, versionId) {\n        var _this = this;\n        if (this.isShuttingDown) {\n            return Promise.resolve();\n        }\n        return this.ready.then(function (model) {\n            var backupResource = _this.toBackupResource(resource);\n            if (model.has(backupResource, versionId)) {\n                return undefined; // return early if backup version id matches requested one\n            }\n            return _this.ioOperationQueues.queueFor(backupResource).queue(function () {\n                var preamble = \"\" + resource.toString() + BackupFileServiceImpl.META_MARKER;\n                // Update content with value\n                return _this.fileService.updateContent(backupResource, new BackupSnapshot(content, preamble), backup_1.BACKUP_FILE_UPDATE_OPTIONS).then(function () { return model.add(backupResource, versionId); });\n            });\n        });\n    };\n    BackupFileServiceImpl.prototype.discardResourceBackup = function (resource) {\n        var _this = this;\n        return this.ready.then(function (model) {\n            var backupResource = _this.toBackupResource(resource);\n            return _this.ioOperationQueues.queueFor(backupResource).queue(function () {\n                return pfs.del(backupResource.fsPath).then(function () { return model.remove(backupResource); });\n            });\n        });\n    };\n    BackupFileServiceImpl.prototype.discardAllWorkspaceBackups = function () {\n        var _this = this;\n        this.isShuttingDown = true;\n        return this.ready.then(function (model) {\n            return pfs.del(_this.backupWorkspacePath).then(function () { return model.clear(); });\n        });\n    };\n    BackupFileServiceImpl.prototype.getWorkspaceFileBackups = function () {\n        return this.ready.then(function (model) {\n            var readPromises = [];\n            model.get().forEach(function (fileBackup) {\n                readPromises.push(stream_1.readToMatchingString(fileBackup.fsPath, BackupFileServiceImpl.META_MARKER, 2000, 10000).then(uri_1.URI.parse));\n            });\n            return Promise.all(readPromises);\n        });\n    };\n    BackupFileServiceImpl.prototype.resolveBackupContent = function (backup) {\n        return this.fileService.resolveStreamContent(backup, backup_1.BACKUP_FILE_RESOLVE_OPTIONS).then(function (content) {\n            // Add a filter method to filter out everything until the meta marker\n            var metaFound = false;\n            var metaPreambleFilter = function (chunk) {\n                if (!metaFound && chunk) {\n                    var metaIndex = chunk.indexOf(BackupFileServiceImpl.META_MARKER);\n                    if (metaIndex === -1) {\n                        return ''; // meta not yet found, return empty string\n                    }\n                    metaFound = true;\n                    return chunk.substr(metaIndex + 1); // meta found, return everything after\n                }\n                return chunk;\n            };\n            return textModel_1.createTextBufferFactoryFromStream(content.value, metaPreambleFilter);\n        });\n    };\n    BackupFileServiceImpl.prototype.toBackupResource = function (resource) {\n        return uri_1.URI.file(path.join(this.backupWorkspacePath, resource.scheme, hashPath(resource)));\n    };\n    BackupFileServiceImpl.META_MARKER = '\\n';\n    BackupFileServiceImpl = tslib_1.__decorate([\n        tslib_1.__param(1, files_1.IFileService)\n    ], BackupFileServiceImpl);\n    return BackupFileServiceImpl;\n}());\nvar InMemoryBackupFileService = /** @class */ (function () {\n    function InMemoryBackupFileService() {\n        this.backups = new Map();\n    }\n    InMemoryBackupFileService.prototype.hasBackups = function () {\n        return Promise.resolve(this.backups.size > 0);\n    };\n    InMemoryBackupFileService.prototype.loadBackupResource = function (resource) {\n        var backupResource = this.toBackupResource(resource);\n        if (this.backups.has(backupResource.toString())) {\n            return Promise.resolve(backupResource);\n        }\n        return Promise.resolve(undefined);\n    };\n    InMemoryBackupFileService.prototype.backupResource = function (resource, content, versionId) {\n        var backupResource = this.toBackupResource(resource);\n        this.backups.set(backupResource.toString(), content);\n        return Promise.resolve();\n    };\n    InMemoryBackupFileService.prototype.resolveBackupContent = function (backupResource) {\n        var snapshot = this.backups.get(backupResource.toString());\n        if (snapshot) {\n            return Promise.resolve(textModel_1.createTextBufferFactoryFromSnapshot(snapshot));\n        }\n        return Promise.resolve(undefined);\n    };\n    InMemoryBackupFileService.prototype.getWorkspaceFileBackups = function () {\n        return Promise.resolve(map_1.keys(this.backups).map(function (key) { return uri_1.URI.parse(key); }));\n    };\n    InMemoryBackupFileService.prototype.discardResourceBackup = function (resource) {\n        this.backups.delete(this.toBackupResource(resource).toString());\n        return Promise.resolve();\n    };\n    InMemoryBackupFileService.prototype.discardAllWorkspaceBackups = function () {\n        this.backups.clear();\n        return Promise.resolve();\n    };\n    InMemoryBackupFileService.prototype.toBackupResource = function (resource) {\n        return uri_1.URI.file(path.join(resource.scheme, hashPath(resource)));\n    };\n    return InMemoryBackupFileService;\n}());\nexports.InMemoryBackupFileService = InMemoryBackupFileService;\n/*\n * Exported only for testing\n */\nfunction hashPath(resource) {\n    var str = resource.scheme === network_1.Schemas.file || resource.scheme === network_1.Schemas.untitled ? resource.fsPath : resource.toString();\n    return crypto.createHash('md5').update(str).digest('hex');\n}\nexports.hashPath = hashPath;\nextensions_1.registerSingleton(backup_1.IBackupFileService, BackupFileService);\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/backup/node/backupFileService.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/backup/node/backupFileService.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;;AAEhG,0CAA4C;AAC5C,+BAAiC;AACjC,sCAAwC;AACxC,0CAAgD;AAChD,8CAAqD;AACrD,qEAAyI;AACzI,wDAA6E;AAC7E,8CAA2D;AAE3D,8DAA0H;AAC1H,0CAA0C;AAC1C,kDAAiD;AACjD,8DAAoE;AACpE,0EAAgF;AAahF;IAGC,wBAAoB,QAAuB,EAAU,QAAgB;QAAjD,aAAQ,GAAR,QAAQ,CAAe;QAAU,aAAQ,GAAR,QAAQ,CAAQ;IAAI,CAAC;IAE1E,6BAAI,GAAJ;QACC,IAAI,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC;QACjC,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;YAC1B,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;YAE5B,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;gBAC9B,KAAK,GAAG,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;aAC9B;iBAAM;gBACN,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC;aACtB;SACD;QAED,OAAO,KAAK,CAAC;IACd,CAAC;IACF,qBAAC;AAAD,CAAC,AAnBD,IAmBC;AAnBY,wCAAc;AAqB3B;IAAA;QACS,UAAK,GAAoD,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAsDtF,CAAC;IApDA,kCAAO,GAAP,UAAQ,UAAkB;QAA1B,iBAkBC;QAjBA,OAAO,GAAG,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,UAAA,aAAa;YAEtD,4BAA4B;YAC5B,OAAO,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,GAAG,CAAC,UAAA,YAAY;gBAEhD,oCAAoC;gBACpC,IAAM,gBAAgB,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,YAAY,CAAC,CAAC;gBAC7D,OAAO,GAAG,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC,IAAI,CAAC,UAAA,YAAY;oBAErD,uCAAuC;oBACvC,YAAY,CAAC,OAAO,CAAC,UAAA,UAAU;wBAC9B,IAAM,cAAc,GAAG,SAAG,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,UAAU,CAAC,CAAC,CAAC;wBACzE,KAAI,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;oBAC1B,CAAC,CAAC,CAAC;gBACJ,CAAC,CAAC,CAAC;YACJ,CAAC,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC,IAAI,CAAC,cAAM,OAAA,KAAI,EAAJ,CAAI,EAAE,UAAA,KAAK,IAAI,OAAA,KAAI,EAAJ,CAAI,CAAC,CAAC;IACpC,CAAC;IAED,8BAAG,GAAH,UAAI,QAAa,EAAE,SAAa;QAAb,0BAAA,EAAA,aAAa;QAC/B,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,GAAG,SAAS,CAAC;IAC7C,CAAC;IAED,gCAAK,GAAL;QACC,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC;IACvC,CAAC;IAED,8BAAG,GAAH,UAAI,QAAa,EAAE,SAAkB;QACpC,IAAM,eAAe,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;QACxD,IAAI,OAAO,eAAe,KAAK,QAAQ,EAAE;YACxC,OAAO,KAAK,CAAC,CAAC,mBAAmB;SACjC;QAED,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;YAClC,OAAO,SAAS,KAAK,eAAe,CAAC,CAAC,uEAAuE;SAC7G;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IAED,8BAAG,GAAH;QACC,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,SAAG,CAAC,KAAK,CAAC,CAAC,CAAC,EAAZ,CAAY,CAAC,CAAC;IACvD,CAAC;IAED,iCAAM,GAAN,UAAO,QAAa;QACnB,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;IACxC,CAAC;IAED,gCAAK,GAAL;QACC,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAClC,CAAC;IACF,uBAAC;AAAD,CAAC,AAvDD,IAuDC;AAvDY,4CAAgB;AAyD7B;IAMC,2BACiB,aAA6B,EAC/B,WAAyB;QAEvC,IAAM,mBAAmB,GAAG,aAAa,CAAC,gBAAgB,EAAE,CAAC,UAAU,CAAC;QACxE,IAAI,mBAAmB,EAAE;YACxB,IAAI,CAAC,IAAI,GAAG,IAAI,qBAAqB,CAAC,mBAAmB,EAAE,WAAW,CAAC,CAAC;SACxE;aAAM;YACN,IAAI,CAAC,IAAI,GAAG,IAAI,yBAAyB,EAAE,CAAC;SAC5C;IACF,CAAC;IAED,sCAAU,GAAV,UAAW,mBAA2B;QACrC,IAAI,IAAI,CAAC,IAAI,YAAY,qBAAqB,EAAE;YAC/C,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,mBAAmB,CAAC,CAAC;SAC1C;IACF,CAAC;IAED,sCAAU,GAAV;QACC,OAAO,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;IAC/B,CAAC;IAED,8CAAkB,GAAlB,UAAmB,QAAa;QAC/B,OAAO,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;IAC/C,CAAC;IAED,0CAAc,GAAd,UAAe,QAAa,EAAE,OAAsB,EAAE,SAAkB;QACvE,OAAO,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;IAC/D,CAAC;IAED,iDAAqB,GAArB,UAAsB,QAAa;QAClC,OAAO,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CAAC;IAClD,CAAC;IAED,sDAA0B,GAA1B;QACC,OAAO,IAAI,CAAC,IAAI,CAAC,0BAA0B,EAAE,CAAC;IAC/C,CAAC;IAED,mDAAuB,GAAvB;QACC,OAAO,IAAI,CAAC,IAAI,CAAC,uBAAuB,EAAE,CAAC;IAC5C,CAAC;IAED,gDAAoB,GAApB,UAAqB,MAAW;QAC/B,OAAO,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;IAC/C,CAAC;IAED,4CAAgB,GAAhB,UAAiB,QAAa;QAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;IAC7C,CAAC;IAtDW,iBAAiB;QAO3B,mBAAA,wBAAc,CAAA;QACd,mBAAA,oBAAY,CAAA;OARF,iBAAiB,CAuD7B;IAAD,wBAAC;CAAA,AAvDD,IAuDC;AAvDY,8CAAiB;AAyD9B;IAYC,+BACC,mBAA2B,EACI,WAAyB;QAAzB,gBAAW,GAAX,WAAW,CAAc;QAExD,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;QAC5B,IAAI,CAAC,iBAAiB,GAAG,IAAI,qBAAa,EAAE,CAAC;QAE7C,IAAI,CAAC,UAAU,CAAC,mBAAmB,CAAC,CAAC;IACtC,CAAC;IAED,0CAAU,GAAV,UAAW,mBAA2B;QACrC,IAAI,CAAC,mBAAmB,GAAG,mBAAmB,CAAC;QAE/C,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;IAC1B,CAAC;IAEO,oCAAI,GAAZ;QACC,IAAM,KAAK,GAAG,IAAI,gBAAgB,EAAE,CAAC;QAErC,OAAO,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;IAChD,CAAC;IAED,0CAAU,GAAV;QACC,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,UAAA,KAAK;YAC3B,OAAO,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;QAC1B,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,kDAAkB,GAAlB,UAAmB,QAAa;QAAhC,iBAWC;QAVA,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,UAAA,KAAK;YAE3B,+DAA+D;YAC/D,IAAM,cAAc,GAAG,KAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;YACvD,IAAI,KAAK,CAAC,GAAG,CAAC,cAAc,CAAC,EAAE;gBAC9B,OAAO,cAAc,CAAC;aACtB;YAED,OAAO,SAAS,CAAC;QAClB,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,8CAAc,GAAd,UAAe,QAAa,EAAE,OAAsB,EAAE,SAAkB;QAAxE,iBAkBC;QAjBA,IAAI,IAAI,CAAC,cAAc,EAAE;YACxB,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;SACzB;QAED,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,UAAA,KAAK;YAC3B,IAAM,cAAc,GAAG,KAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;YACvD,IAAI,KAAK,CAAC,GAAG,CAAC,cAAc,EAAE,SAAS,CAAC,EAAE;gBACzC,OAAO,SAAS,CAAC,CAAC,0DAA0D;aAC5E;YAED,OAAO,KAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,KAAK,CAAC;gBAC5D,IAAM,QAAQ,GAAG,KAAG,QAAQ,CAAC,QAAQ,EAAE,GAAG,qBAAqB,CAAC,WAAa,CAAC;gBAE9E,4BAA4B;gBAC5B,OAAO,KAAI,CAAC,WAAW,CAAC,aAAa,CAAC,cAAc,EAAE,IAAI,cAAc,CAAC,OAAO,EAAE,QAAQ,CAAC,EAAE,mCAA0B,CAAC,CAAC,IAAI,CAAC,cAAM,OAAA,KAAK,CAAC,GAAG,CAAC,cAAc,EAAE,SAAS,CAAC,EAApC,CAAoC,CAAC,CAAC;YAC3K,CAAC,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,qDAAqB,GAArB,UAAsB,QAAa;QAAnC,iBAQC;QAPA,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,UAAA,KAAK;YAC3B,IAAM,cAAc,GAAG,KAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;YAEvD,OAAO,KAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,KAAK,CAAC;gBAC5D,OAAO,GAAG,CAAC,GAAG,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,cAAM,OAAA,KAAK,CAAC,MAAM,CAAC,cAAc,CAAC,EAA5B,CAA4B,CAAC,CAAC;YAChF,CAAC,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,0DAA0B,GAA1B;QAAA,iBAMC;QALA,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;QAE3B,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,UAAA,KAAK;YAC3B,OAAO,GAAG,CAAC,GAAG,CAAC,KAAI,CAAC,mBAAmB,CAAC,CAAC,IAAI,CAAC,cAAM,OAAA,KAAK,CAAC,KAAK,EAAE,EAAb,CAAa,CAAC,CAAC;QACpE,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,uDAAuB,GAAvB;QACC,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,UAAA,KAAK;YAC3B,IAAM,YAAY,GAAmB,EAAE,CAAC;YAExC,KAAK,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,UAAA,UAAU;gBAC7B,YAAY,CAAC,IAAI,CAChB,6BAAoB,CAAC,UAAU,CAAC,MAAM,EAAE,qBAAqB,CAAC,WAAW,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC,IAAI,CAAC,SAAG,CAAC,KAAK,CAAC,CACvG,CAAC;YACH,CAAC,CAAC,CAAC;YAEH,OAAO,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QAClC,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,oDAAoB,GAApB,UAAqB,MAAW;QAC/B,OAAO,IAAI,CAAC,WAAW,CAAC,oBAAoB,CAAC,MAAM,EAAE,oCAA2B,CAAC,CAAC,IAAI,CAAC,UAAA,OAAO;YAE7F,qEAAqE;YACrE,IAAI,SAAS,GAAG,KAAK,CAAC;YACtB,IAAM,kBAAkB,GAAG,UAAC,KAAa;gBACxC,IAAI,CAAC,SAAS,IAAI,KAAK,EAAE;oBACxB,IAAM,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC,qBAAqB,CAAC,WAAW,CAAC,CAAC;oBACnE,IAAI,SAAS,KAAK,CAAC,CAAC,EAAE;wBACrB,OAAO,EAAE,CAAC,CAAC,0CAA0C;qBACrD;oBAED,SAAS,GAAG,IAAI,CAAC;oBACjB,OAAO,KAAK,CAAC,MAAM,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC,sCAAsC;iBAC1E;gBAED,OAAO,KAAK,CAAC;YACd,CAAC,CAAC;YAEF,OAAO,6CAAiC,CAAC,OAAO,CAAC,KAAK,EAAE,kBAAkB,CAAC,CAAC;QAC7E,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,gDAAgB,GAAhB,UAAiB,QAAa;QAC7B,OAAO,SAAG,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,mBAAmB,EAAE,QAAQ,CAAC,MAAM,EAAE,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;IAC3F,CAAC;IAhIuB,iCAAW,GAAG,IAAI,CAAC;IAFtC,qBAAqB;QAcxB,mBAAA,oBAAY,CAAA;OAdT,qBAAqB,CAmI1B;IAAD,4BAAC;CAAA,AAnID,IAmIC;AAED;IAAA;QAIS,YAAO,GAA+B,IAAI,GAAG,EAAE,CAAC;IAkDzD,CAAC;IAhDA,8CAAU,GAAV;QACC,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;IAC/C,CAAC;IAED,sDAAkB,GAAlB,UAAmB,QAAa;QAC/B,IAAM,cAAc,GAAG,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QACvD,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,QAAQ,EAAE,CAAC,EAAE;YAChD,OAAO,OAAO,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC;SACvC;QAED,OAAO,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IACnC,CAAC;IAED,kDAAc,GAAd,UAAe,QAAa,EAAE,OAAsB,EAAE,SAAkB;QACvE,IAAM,cAAc,GAAG,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QACvD,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,QAAQ,EAAE,EAAE,OAAO,CAAC,CAAC;QAErD,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;IAC1B,CAAC;IAED,wDAAoB,GAApB,UAAqB,cAAmB;QACvC,IAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,QAAQ,EAAE,CAAC,CAAC;QAC7D,IAAI,QAAQ,EAAE;YACb,OAAO,OAAO,CAAC,OAAO,CAAC,+CAAmC,CAAC,QAAQ,CAAC,CAAC,CAAC;SACtE;QAED,OAAO,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IACnC,CAAC;IAED,2DAAuB,GAAvB;QACC,OAAO,OAAO,CAAC,OAAO,CAAC,UAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,UAAA,GAAG,IAAI,OAAA,SAAG,CAAC,KAAK,CAAC,GAAG,CAAC,EAAd,CAAc,CAAC,CAAC,CAAC;IACvE,CAAC;IAED,yDAAqB,GAArB,UAAsB,QAAa;QAClC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;QAEhE,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;IAC1B,CAAC;IAED,8DAA0B,GAA1B;QACC,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;QAErB,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;IAC1B,CAAC;IAED,oDAAgB,GAAhB,UAAiB,QAAa;QAC7B,OAAO,SAAG,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;IACjE,CAAC;IACF,gCAAC;AAAD,CAAC,AAtDD,IAsDC;AAtDY,8DAAyB;AAwDtC;;GAEG;AACH,SAAgB,QAAQ,CAAC,QAAa;IACrC,IAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,KAAK,iBAAO,CAAC,IAAI,IAAI,QAAQ,CAAC,MAAM,KAAK,iBAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC;IAC7H,OAAO,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AAC3D,CAAC;AAHD,4BAGC;AAED,8BAAiB,CAAC,2BAAkB,EAAE,iBAAiB,CAAC,CAAC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from 'vs/base/common/path';\nimport * as crypto from 'crypto';\nimport * as pfs from 'vs/base/node/pfs';\nimport { URI as Uri } from 'vs/base/common/uri';\nimport { ResourceQueue } from 'vs/base/common/async';\nimport { IBackupFileService, BACKUP_FILE_UPDATE_OPTIONS, BACKUP_FILE_RESOLVE_OPTIONS } from 'vs/workbench/services/backup/common/backup';\nimport { IFileService, ITextSnapshot } from 'vs/platform/files/common/files';\nimport { readToMatchingString } from 'vs/base/node/stream';\nimport { ITextBufferFactory } from 'vs/editor/common/model';\nimport { createTextBufferFactoryFromStream, createTextBufferFactoryFromSnapshot } from 'vs/editor/common/model/textModel';\nimport { keys } from 'vs/base/common/map';\nimport { Schemas } from 'vs/base/common/network';\nimport { IWindowService } from 'vs/platform/windows/common/windows';\nimport { registerSingleton } from 'vs/platform/instantiation/common/extensions';\n\nexport interface IBackupFilesModel {\n\tresolve(backupRoot: string): Promise<IBackupFilesModel>;\n\n\tadd(resource: Uri, versionId?: number): void;\n\thas(resource: Uri, versionId?: number): boolean;\n\tget(): Uri[];\n\tremove(resource: Uri): void;\n\tcount(): number;\n\tclear(): void;\n}\n\nexport class BackupSnapshot implements ITextSnapshot {\n\tprivate preambleHandled: boolean;\n\n\tconstructor(private snapshot: ITextSnapshot, private preamble: string) { }\n\n\tread(): string | null {\n\t\tlet value = this.snapshot.read();\n\t\tif (!this.preambleHandled) {\n\t\t\tthis.preambleHandled = true;\n\n\t\t\tif (typeof value === 'string') {\n\t\t\t\tvalue = this.preamble + value;\n\t\t\t} else {\n\t\t\t\tvalue = this.preamble;\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t}\n}\n\nexport class BackupFilesModel implements IBackupFilesModel {\n\tprivate cache: { [resource: string]: number /* version ID */ } = Object.create(null);\n\n\tresolve(backupRoot: string): Promise<IBackupFilesModel> {\n\t\treturn pfs.readDirsInDir(backupRoot).then(backupSchemas => {\n\n\t\t\t// For all supported schemas\n\t\t\treturn Promise.all(backupSchemas.map(backupSchema => {\n\n\t\t\t\t// Read backup directory for backups\n\t\t\t\tconst backupSchemaPath = path.join(backupRoot, backupSchema);\n\t\t\t\treturn pfs.readdir(backupSchemaPath).then(backupHashes => {\n\n\t\t\t\t\t// Remember known backups in our caches\n\t\t\t\t\tbackupHashes.forEach(backupHash => {\n\t\t\t\t\t\tconst backupResource = Uri.file(path.join(backupSchemaPath, backupHash));\n\t\t\t\t\t\tthis.add(backupResource);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}));\n\t\t}).then(() => this, error => this);\n\t}\n\n\tadd(resource: Uri, versionId = 0): void {\n\t\tthis.cache[resource.toString()] = versionId;\n\t}\n\n\tcount(): number {\n\t\treturn Object.keys(this.cache).length;\n\t}\n\n\thas(resource: Uri, versionId?: number): boolean {\n\t\tconst cachedVersionId = this.cache[resource.toString()];\n\t\tif (typeof cachedVersionId !== 'number') {\n\t\t\treturn false; // unknown resource\n\t\t}\n\n\t\tif (typeof versionId === 'number') {\n\t\t\treturn versionId === cachedVersionId; // if we are asked with a specific version ID, make sure to test for it\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tget(): Uri[] {\n\t\treturn Object.keys(this.cache).map(k => Uri.parse(k));\n\t}\n\n\tremove(resource: Uri): void {\n\t\tdelete this.cache[resource.toString()];\n\t}\n\n\tclear(): void {\n\t\tthis.cache = Object.create(null);\n\t}\n}\n\nexport class BackupFileService implements IBackupFileService {\n\n\t_serviceBrand: any;\n\n\tprivate impl: IBackupFileService;\n\n\tconstructor(\n\t\t@IWindowService windowService: IWindowService,\n\t\t@IFileService fileService: IFileService\n\t) {\n\t\tconst backupWorkspacePath = windowService.getConfiguration().backupPath;\n\t\tif (backupWorkspacePath) {\n\t\t\tthis.impl = new BackupFileServiceImpl(backupWorkspacePath, fileService);\n\t\t} else {\n\t\t\tthis.impl = new InMemoryBackupFileService();\n\t\t}\n\t}\n\n\tinitialize(backupWorkspacePath: string): void {\n\t\tif (this.impl instanceof BackupFileServiceImpl) {\n\t\t\tthis.impl.initialize(backupWorkspacePath);\n\t\t}\n\t}\n\n\thasBackups(): Promise<boolean> {\n\t\treturn this.impl.hasBackups();\n\t}\n\n\tloadBackupResource(resource: Uri): Promise<Uri | undefined> {\n\t\treturn this.impl.loadBackupResource(resource);\n\t}\n\n\tbackupResource(resource: Uri, content: ITextSnapshot, versionId?: number): Promise<void> {\n\t\treturn this.impl.backupResource(resource, content, versionId);\n\t}\n\n\tdiscardResourceBackup(resource: Uri): Promise<void> {\n\t\treturn this.impl.discardResourceBackup(resource);\n\t}\n\n\tdiscardAllWorkspaceBackups(): Promise<void> {\n\t\treturn this.impl.discardAllWorkspaceBackups();\n\t}\n\n\tgetWorkspaceFileBackups(): Promise<Uri[]> {\n\t\treturn this.impl.getWorkspaceFileBackups();\n\t}\n\n\tresolveBackupContent(backup: Uri): Promise<ITextBufferFactory | undefined> {\n\t\treturn this.impl.resolveBackupContent(backup);\n\t}\n\n\ttoBackupResource(resource: Uri): Uri {\n\t\treturn this.impl.toBackupResource(resource);\n\t}\n}\n\nclass BackupFileServiceImpl implements IBackupFileService {\n\n\tprivate static readonly META_MARKER = '\\n';\n\n\t_serviceBrand: any;\n\n\tprivate backupWorkspacePath: string;\n\n\tprivate isShuttingDown: boolean;\n\tprivate ready: Promise<IBackupFilesModel>;\n\tprivate ioOperationQueues: ResourceQueue; // queue IO operations to ensure write order\n\n\tconstructor(\n\t\tbackupWorkspacePath: string,\n\t\t@IFileService private readonly fileService: IFileService\n\t) {\n\t\tthis.isShuttingDown = false;\n\t\tthis.ioOperationQueues = new ResourceQueue();\n\n\t\tthis.initialize(backupWorkspacePath);\n\t}\n\n\tinitialize(backupWorkspacePath: string): void {\n\t\tthis.backupWorkspacePath = backupWorkspacePath;\n\n\t\tthis.ready = this.init();\n\t}\n\n\tprivate init(): Promise<IBackupFilesModel> {\n\t\tconst model = new BackupFilesModel();\n\n\t\treturn model.resolve(this.backupWorkspacePath);\n\t}\n\n\thasBackups(): Promise<boolean> {\n\t\treturn this.ready.then(model => {\n\t\t\treturn model.count() > 0;\n\t\t});\n\t}\n\n\tloadBackupResource(resource: Uri): Promise<Uri | undefined> {\n\t\treturn this.ready.then(model => {\n\n\t\t\t// Return directly if we have a known backup with that resource\n\t\t\tconst backupResource = this.toBackupResource(resource);\n\t\t\tif (model.has(backupResource)) {\n\t\t\t\treturn backupResource;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t});\n\t}\n\n\tbackupResource(resource: Uri, content: ITextSnapshot, versionId?: number): Promise<void> {\n\t\tif (this.isShuttingDown) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn this.ready.then(model => {\n\t\t\tconst backupResource = this.toBackupResource(resource);\n\t\t\tif (model.has(backupResource, versionId)) {\n\t\t\t\treturn undefined; // return early if backup version id matches requested one\n\t\t\t}\n\n\t\t\treturn this.ioOperationQueues.queueFor(backupResource).queue(() => {\n\t\t\t\tconst preamble = `${resource.toString()}${BackupFileServiceImpl.META_MARKER}`;\n\n\t\t\t\t// Update content with value\n\t\t\t\treturn this.fileService.updateContent(backupResource, new BackupSnapshot(content, preamble), BACKUP_FILE_UPDATE_OPTIONS).then(() => model.add(backupResource, versionId));\n\t\t\t});\n\t\t});\n\t}\n\n\tdiscardResourceBackup(resource: Uri): Promise<void> {\n\t\treturn this.ready.then(model => {\n\t\t\tconst backupResource = this.toBackupResource(resource);\n\n\t\t\treturn this.ioOperationQueues.queueFor(backupResource).queue(() => {\n\t\t\t\treturn pfs.del(backupResource.fsPath).then(() => model.remove(backupResource));\n\t\t\t});\n\t\t});\n\t}\n\n\tdiscardAllWorkspaceBackups(): Promise<void> {\n\t\tthis.isShuttingDown = true;\n\n\t\treturn this.ready.then(model => {\n\t\t\treturn pfs.del(this.backupWorkspacePath).then(() => model.clear());\n\t\t});\n\t}\n\n\tgetWorkspaceFileBackups(): Promise<Uri[]> {\n\t\treturn this.ready.then(model => {\n\t\t\tconst readPromises: Promise<Uri>[] = [];\n\n\t\t\tmodel.get().forEach(fileBackup => {\n\t\t\t\treadPromises.push(\n\t\t\t\t\treadToMatchingString(fileBackup.fsPath, BackupFileServiceImpl.META_MARKER, 2000, 10000).then(Uri.parse)\n\t\t\t\t);\n\t\t\t});\n\n\t\t\treturn Promise.all(readPromises);\n\t\t});\n\t}\n\n\tresolveBackupContent(backup: Uri): Promise<ITextBufferFactory> {\n\t\treturn this.fileService.resolveStreamContent(backup, BACKUP_FILE_RESOLVE_OPTIONS).then(content => {\n\n\t\t\t// Add a filter method to filter out everything until the meta marker\n\t\t\tlet metaFound = false;\n\t\t\tconst metaPreambleFilter = (chunk: string) => {\n\t\t\t\tif (!metaFound && chunk) {\n\t\t\t\t\tconst metaIndex = chunk.indexOf(BackupFileServiceImpl.META_MARKER);\n\t\t\t\t\tif (metaIndex === -1) {\n\t\t\t\t\t\treturn ''; // meta not yet found, return empty string\n\t\t\t\t\t}\n\n\t\t\t\t\tmetaFound = true;\n\t\t\t\t\treturn chunk.substr(metaIndex + 1); // meta found, return everything after\n\t\t\t\t}\n\n\t\t\t\treturn chunk;\n\t\t\t};\n\n\t\t\treturn createTextBufferFactoryFromStream(content.value, metaPreambleFilter);\n\t\t});\n\t}\n\n\ttoBackupResource(resource: Uri): Uri {\n\t\treturn Uri.file(path.join(this.backupWorkspacePath, resource.scheme, hashPath(resource)));\n\t}\n}\n\nexport class InMemoryBackupFileService implements IBackupFileService {\n\n\t_serviceBrand: any;\n\n\tprivate backups: Map<string, ITextSnapshot> = new Map();\n\n\thasBackups(): Promise<boolean> {\n\t\treturn Promise.resolve(this.backups.size > 0);\n\t}\n\n\tloadBackupResource(resource: Uri): Promise<Uri | undefined> {\n\t\tconst backupResource = this.toBackupResource(resource);\n\t\tif (this.backups.has(backupResource.toString())) {\n\t\t\treturn Promise.resolve(backupResource);\n\t\t}\n\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tbackupResource(resource: Uri, content: ITextSnapshot, versionId?: number): Promise<void> {\n\t\tconst backupResource = this.toBackupResource(resource);\n\t\tthis.backups.set(backupResource.toString(), content);\n\n\t\treturn Promise.resolve();\n\t}\n\n\tresolveBackupContent(backupResource: Uri): Promise<ITextBufferFactory | undefined> {\n\t\tconst snapshot = this.backups.get(backupResource.toString());\n\t\tif (snapshot) {\n\t\t\treturn Promise.resolve(createTextBufferFactoryFromSnapshot(snapshot));\n\t\t}\n\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tgetWorkspaceFileBackups(): Promise<Uri[]> {\n\t\treturn Promise.resolve(keys(this.backups).map(key => Uri.parse(key)));\n\t}\n\n\tdiscardResourceBackup(resource: Uri): Promise<void> {\n\t\tthis.backups.delete(this.toBackupResource(resource).toString());\n\n\t\treturn Promise.resolve();\n\t}\n\n\tdiscardAllWorkspaceBackups(): Promise<void> {\n\t\tthis.backups.clear();\n\n\t\treturn Promise.resolve();\n\t}\n\n\ttoBackupResource(resource: Uri): Uri {\n\t\treturn Uri.file(path.join(resource.scheme, hashPath(resource)));\n\t}\n}\n\n/*\n * Exported only for testing\n */\nexport function hashPath(resource: Uri): string {\n\tconst str = resource.scheme === Schemas.file || resource.scheme === Schemas.untitled ? resource.fsPath : resource.toString();\n\treturn crypto.createHash('md5').update(str).digest('hex');\n}\n\nregisterSingleton(IBackupFileService, BackupFileService);"]}]}