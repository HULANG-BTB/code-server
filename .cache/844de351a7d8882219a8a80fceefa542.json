{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/common.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/common.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar uri_1 = require(\"vs/base/common/uri\");\nvar files_1 = require(\"vs/platform/files/common/files\");\nvar platform_1 = require(\"vs/base/common/platform\");\nfunction toFileChangesEvent(changes) {\n    // map to file changes event that talks about URIs\n    return new files_1.FileChangesEvent(changes.map(function (c) {\n        return {\n            type: c.type,\n            resource: uri_1.URI.file(c.path)\n        };\n    }));\n}\nexports.toFileChangesEvent = toFileChangesEvent;\n/**\n * Given events that occurred, applies some rules to normalize the events\n */\nfunction normalize(changes) {\n    // Build deltas\n    var normalizer = new EventNormalizer();\n    for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {\n        var event = changes_1[_i];\n        normalizer.processEvent(event);\n    }\n    return normalizer.normalize();\n}\nexports.normalize = normalize;\nvar EventNormalizer = /** @class */ (function () {\n    function EventNormalizer() {\n        this.normalized = [];\n        this.mapPathToChange = Object.create(null);\n    }\n    EventNormalizer.prototype.processEvent = function (event) {\n        // Event path already exists\n        var existingEvent = this.mapPathToChange[event.path];\n        if (existingEvent) {\n            var currentChangeType = existingEvent.type;\n            var newChangeType = event.type;\n            // ignore CREATE followed by DELETE in one go\n            if (currentChangeType === files_1.FileChangeType.ADDED && newChangeType === files_1.FileChangeType.DELETED) {\n                delete this.mapPathToChange[event.path];\n                this.normalized.splice(this.normalized.indexOf(existingEvent), 1);\n            }\n            // flatten DELETE followed by CREATE into CHANGE\n            else if (currentChangeType === files_1.FileChangeType.DELETED && newChangeType === files_1.FileChangeType.ADDED) {\n                existingEvent.type = files_1.FileChangeType.UPDATED;\n            }\n            // Do nothing. Keep the created event\n            else if (currentChangeType === files_1.FileChangeType.ADDED && newChangeType === files_1.FileChangeType.UPDATED) {\n            }\n            // Otherwise apply change type\n            else {\n                existingEvent.type = newChangeType;\n            }\n        }\n        // Otherwise Store\n        else {\n            this.normalized.push(event);\n            this.mapPathToChange[event.path] = event;\n        }\n    };\n    EventNormalizer.prototype.normalize = function () {\n        var addedChangeEvents = [];\n        var deletedPaths = [];\n        // This algorithm will remove all DELETE events up to the root folder\n        // that got deleted if any. This ensures that we are not producing\n        // DELETE events for each file inside a folder that gets deleted.\n        //\n        // 1.) split ADD/CHANGE and DELETED events\n        // 2.) sort short deleted paths to the top\n        // 3.) for each DELETE, check if there is a deleted parent and ignore the event in that case\n        return this.normalized.filter(function (e) {\n            if (e.type !== files_1.FileChangeType.DELETED) {\n                addedChangeEvents.push(e);\n                return false; // remove ADD / CHANGE\n            }\n            return true; // keep DELETE\n        }).sort(function (e1, e2) {\n            return e1.path.length - e2.path.length; // shortest path first\n        }).filter(function (e) {\n            if (deletedPaths.some(function (d) { return files_1.isParent(e.path, d, !platform_1.isLinux /* ignorecase */); })) {\n                return false; // DELETE is ignored if parent is deleted already\n            }\n            // otherwise mark as deleted\n            deletedPaths.push(e.path);\n            return true;\n        }).concat(addedChangeEvents);\n    };\n    return EventNormalizer;\n}());\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/common.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/common.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI as uri } from 'vs/base/common/uri';\nimport { FileChangeType, FileChangesEvent, isParent } from 'vs/platform/files/common/files';\nimport { isLinux } from 'vs/base/common/platform';\n\nexport interface IRawFileChange {\n\ttype: FileChangeType;\n\tpath: string;\n}\n\nexport function toFileChangesEvent(changes: IRawFileChange[]): FileChangesEvent {\n\n\t// map to file changes event that talks about URIs\n\treturn new FileChangesEvent(changes.map((c) => {\n\t\treturn {\n\t\t\ttype: c.type,\n\t\t\tresource: uri.file(c.path)\n\t\t};\n\t}));\n}\n\n/**\n * Given events that occurred, applies some rules to normalize the events\n */\nexport function normalize(changes: IRawFileChange[]): IRawFileChange[] {\n\n\t// Build deltas\n\tlet normalizer = new EventNormalizer();\n\tfor (const event of changes) {\n\t\tnormalizer.processEvent(event);\n\t}\n\n\treturn normalizer.normalize();\n}\n\nclass EventNormalizer {\n\tprivate normalized: IRawFileChange[];\n\tprivate mapPathToChange: { [path: string]: IRawFileChange };\n\n\tconstructor() {\n\t\tthis.normalized = [];\n\t\tthis.mapPathToChange = Object.create(null);\n\t}\n\n\tpublic processEvent(event: IRawFileChange): void {\n\n\t\t// Event path already exists\n\t\tlet existingEvent = this.mapPathToChange[event.path];\n\t\tif (existingEvent) {\n\t\t\tlet currentChangeType = existingEvent.type;\n\t\t\tlet newChangeType = event.type;\n\n\t\t\t// ignore CREATE followed by DELETE in one go\n\t\t\tif (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.DELETED) {\n\t\t\t\tdelete this.mapPathToChange[event.path];\n\t\t\t\tthis.normalized.splice(this.normalized.indexOf(existingEvent), 1);\n\t\t\t}\n\n\t\t\t// flatten DELETE followed by CREATE into CHANGE\n\t\t\telse if (currentChangeType === FileChangeType.DELETED && newChangeType === FileChangeType.ADDED) {\n\t\t\t\texistingEvent.type = FileChangeType.UPDATED;\n\t\t\t}\n\n\t\t\t// Do nothing. Keep the created event\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.UPDATED) {\n\t\t\t}\n\n\t\t\t// Otherwise apply change type\n\t\t\telse {\n\t\t\t\texistingEvent.type = newChangeType;\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise Store\n\t\telse {\n\t\t\tthis.normalized.push(event);\n\t\t\tthis.mapPathToChange[event.path] = event;\n\t\t}\n\t}\n\n\tpublic normalize(): IRawFileChange[] {\n\t\tlet addedChangeEvents: IRawFileChange[] = [];\n\t\tlet deletedPaths: string[] = [];\n\n\t\t// This algorithm will remove all DELETE events up to the root folder\n\t\t// that got deleted if any. This ensures that we are not producing\n\t\t// DELETE events for each file inside a folder that gets deleted.\n\t\t//\n\t\t// 1.) split ADD/CHANGE and DELETED events\n\t\t// 2.) sort short deleted paths to the top\n\t\t// 3.) for each DELETE, check if there is a deleted parent and ignore the event in that case\n\t\treturn this.normalized.filter(e => {\n\t\t\tif (e.type !== FileChangeType.DELETED) {\n\t\t\t\taddedChangeEvents.push(e);\n\t\t\t\treturn false; // remove ADD / CHANGE\n\t\t\t}\n\n\t\t\treturn true; // keep DELETE\n\t\t}).sort((e1, e2) => {\n\t\t\treturn e1.path.length - e2.path.length; // shortest path first\n\t\t}).filter(e => {\n\t\t\tif (deletedPaths.some(d => isParent(e.path, d, !isLinux /* ignorecase */))) {\n\t\t\t\treturn false; // DELETE is ignored if parent is deleted already\n\t\t\t}\n\n\t\t\t// otherwise mark as deleted\n\t\t\tdeletedPaths.push(e.path);\n\n\t\t\treturn true;\n\t\t}).concat(addedChangeEvents);\n\t}\n}\n"]}]}