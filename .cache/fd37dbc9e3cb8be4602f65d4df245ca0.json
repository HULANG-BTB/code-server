{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/lifecycle.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/lifecycle.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/functional\"], function (require, exports, functional_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isDisposable(thing) {\n        return typeof thing.dispose === 'function'\n            && thing.dispose.length === 0;\n    }\n    exports.isDisposable = isDisposable;\n    function dispose(first, ...rest) {\n        if (Array.isArray(first)) {\n            first.forEach(d => d && d.dispose());\n            return [];\n        }\n        else if (rest.length === 0) {\n            if (first) {\n                first.dispose();\n                return first;\n            }\n            return undefined;\n        }\n        else {\n            dispose(first);\n            dispose(rest);\n            return [];\n        }\n    }\n    exports.dispose = dispose;\n    function combinedDisposable(disposables) {\n        return { dispose: () => dispose(disposables) };\n    }\n    exports.combinedDisposable = combinedDisposable;\n    function toDisposable(fn) {\n        return { dispose() { fn(); } };\n    }\n    exports.toDisposable = toDisposable;\n    class Disposable {\n        constructor() {\n            this._toDispose = [];\n            this._lifecycle_disposable_isDisposed = false;\n        }\n        get toDispose() { return this._toDispose; }\n        dispose() {\n            this._lifecycle_disposable_isDisposed = true;\n            this._toDispose = dispose(this._toDispose);\n        }\n        _register(t) {\n            if (this._lifecycle_disposable_isDisposed) {\n                console.warn('Registering disposable on object that has already been disposed.');\n                t.dispose();\n            }\n            else {\n                this._toDispose.push(t);\n            }\n            return t;\n        }\n    }\n    Disposable.None = Object.freeze({ dispose() { } });\n    exports.Disposable = Disposable;\n    class ReferenceCollection {\n        constructor() {\n            this.references = Object.create(null);\n        }\n        acquire(key) {\n            let reference = this.references[key];\n            if (!reference) {\n                reference = this.references[key] = { counter: 0, object: this.createReferencedObject(key) };\n            }\n            const { object } = reference;\n            const dispose = functional_1.once(() => {\n                if (--reference.counter === 0) {\n                    this.destroyReferencedObject(key, reference.object);\n                    delete this.references[key];\n                }\n            });\n            reference.counter++;\n            return { object, dispose };\n        }\n    }\n    exports.ReferenceCollection = ReferenceCollection;\n    class ImmortalReference {\n        constructor(object) {\n            this.object = object;\n        }\n        dispose() { }\n    }\n    exports.ImmortalReference = ImmortalReference;\n});\n",null]}