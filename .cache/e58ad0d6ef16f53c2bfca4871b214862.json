{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/electron-browser/runAutomaticTasks.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/electron-browser/runAutomaticTasks.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/lifecycle\", \"vs/workbench/contrib/tasks/common/taskService\", \"vs/base/common/collections\", \"vs/workbench/contrib/tasks/common/tasks\", \"vs/platform/storage/common/storage\", \"vs/platform/notification/common/notification\", \"vs/base/common/actions\"], function (require, exports, nls, lifecycle_1, taskService_1, collections_1, tasks_1, storage_1, notification_1, actions_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const ARE_AUTOMATIC_TASKS_ALLOWED_IN_WORKSPACE = 'tasks.run.allowAutomatic';\n    let RunAutomaticTasks = class RunAutomaticTasks extends lifecycle_1.Disposable {\n        constructor(taskService, storageService) {\n            super();\n            this.taskService = taskService;\n            const isFolderAutomaticAllowed = storageService.getBoolean(ARE_AUTOMATIC_TASKS_ALLOWED_IN_WORKSPACE, storage_1.StorageScope.WORKSPACE, undefined);\n            this.tryRunTasks(isFolderAutomaticAllowed);\n        }\n        tryRunTasks(isAllowed) {\n            // Only run if allowed. Prompting for permission occurs when a user first tries to run a task.\n            if (isAllowed === true) {\n                this.taskService.getWorkspaceTasks(tasks_1.TaskRunSource.FolderOpen).then(workspaceTaskResult => {\n                    let { tasks } = RunAutomaticTasks.findAutoTasks(this.taskService, workspaceTaskResult);\n                    if (tasks.length > 0) {\n                        RunAutomaticTasks.runTasks(this.taskService, tasks);\n                    }\n                });\n            }\n        }\n        static runTasks(taskService, tasks) {\n            tasks.forEach(task => {\n                if (task instanceof Promise) {\n                    task.then(promiseResult => {\n                        if (promiseResult) {\n                            taskService.run(promiseResult);\n                        }\n                    });\n                }\n                else {\n                    taskService.run(task);\n                }\n            });\n        }\n        static findAutoTasks(taskService, workspaceTaskResult) {\n            const tasks = new Array();\n            const taskNames = new Array();\n            if (workspaceTaskResult) {\n                workspaceTaskResult.forEach(resultElement => {\n                    if (resultElement.set) {\n                        resultElement.set.tasks.forEach(task => {\n                            if (task.runOptions.runOn === tasks_1.RunOnOptions.folderOpen) {\n                                tasks.push(task);\n                                taskNames.push(task._label);\n                            }\n                        });\n                    }\n                    if (resultElement.configurations) {\n                        collections_1.forEach(resultElement.configurations.byIdentifier, (configedTask) => {\n                            if (configedTask.value.runOptions.runOn === tasks_1.RunOnOptions.folderOpen) {\n                                tasks.push(new Promise(resolve => {\n                                    taskService.getTask(resultElement.workspaceFolder, configedTask.value._id, true).then(task => resolve(task));\n                                }));\n                                if (configedTask.value._label) {\n                                    taskNames.push(configedTask.value._label);\n                                }\n                                else {\n                                    taskNames.push(configedTask.value.configures.task);\n                                }\n                            }\n                        });\n                    }\n                });\n            }\n            return { tasks, taskNames };\n        }\n        static promptForPermission(taskService, storageService, notificationService, workspaceTaskResult) {\n            const isFolderAutomaticAllowed = storageService.getBoolean(ARE_AUTOMATIC_TASKS_ALLOWED_IN_WORKSPACE, storage_1.StorageScope.WORKSPACE, undefined);\n            if (isFolderAutomaticAllowed !== undefined) {\n                return;\n            }\n            let { tasks, taskNames } = RunAutomaticTasks.findAutoTasks(taskService, workspaceTaskResult);\n            if (taskNames.length > 0) {\n                // We have automatic tasks, prompt to allow.\n                this.showPrompt(notificationService, storageService, taskService, taskNames).then(allow => {\n                    if (allow) {\n                        RunAutomaticTasks.runTasks(taskService, tasks);\n                    }\n                });\n            }\n        }\n        static showPrompt(notificationService, storageService, taskService, taskNames) {\n            return new Promise(resolve => {\n                notificationService.prompt(notification_1.Severity.Info, nls.localize('tasks.run.allowAutomatic', \"This folder has tasks ({0}) defined in \\'tasks.json\\' that run automatically when you open this folder. Do you allow automatic tasks to run when you open this folder?\", taskNames.join(', ')), [{\n                        label: nls.localize('allow', \"Allow and run\"),\n                        run: () => {\n                            resolve(true);\n                            storageService.store(ARE_AUTOMATIC_TASKS_ALLOWED_IN_WORKSPACE, true, storage_1.StorageScope.WORKSPACE);\n                        }\n                    },\n                    {\n                        label: nls.localize('disallow', \"Disallow\"),\n                        run: () => {\n                            resolve(false);\n                            storageService.store(ARE_AUTOMATIC_TASKS_ALLOWED_IN_WORKSPACE, false, storage_1.StorageScope.WORKSPACE);\n                        }\n                    },\n                    {\n                        label: nls.localize('openTasks', \"Open tasks.json\"),\n                        run: () => {\n                            taskService.openConfig(undefined);\n                            resolve(false);\n                        }\n                    }]);\n            });\n        }\n    };\n    RunAutomaticTasks = __decorate([\n        __param(0, taskService_1.ITaskService),\n        __param(1, storage_1.IStorageService)\n    ], RunAutomaticTasks);\n    exports.RunAutomaticTasks = RunAutomaticTasks;\n    let AllowAutomaticTaskRunning = class AllowAutomaticTaskRunning extends actions_1.Action {\n        constructor(id, label, storageService) {\n            super(id, label);\n            this.storageService = storageService;\n        }\n        run(event) {\n            this.storageService.store(ARE_AUTOMATIC_TASKS_ALLOWED_IN_WORKSPACE, true, storage_1.StorageScope.WORKSPACE);\n            return Promise.resolve(undefined);\n        }\n    };\n    AllowAutomaticTaskRunning.ID = 'workbench.action.tasks.allowAutomaticRunning';\n    AllowAutomaticTaskRunning.LABEL = nls.localize('workbench.action.tasks.allowAutomaticRunning', \"Allow Automatic Tasks in Folder\");\n    AllowAutomaticTaskRunning = __decorate([\n        __param(2, storage_1.IStorageService)\n    ], AllowAutomaticTaskRunning);\n    exports.AllowAutomaticTaskRunning = AllowAutomaticTaskRunning;\n    let DisallowAutomaticTaskRunning = class DisallowAutomaticTaskRunning extends actions_1.Action {\n        constructor(id, label, storageService) {\n            super(id, label);\n            this.storageService = storageService;\n        }\n        run(event) {\n            this.storageService.store(ARE_AUTOMATIC_TASKS_ALLOWED_IN_WORKSPACE, false, storage_1.StorageScope.WORKSPACE);\n            return Promise.resolve(undefined);\n        }\n    };\n    DisallowAutomaticTaskRunning.ID = 'workbench.action.tasks.disallowAutomaticRunning';\n    DisallowAutomaticTaskRunning.LABEL = nls.localize('workbench.action.tasks.disallowAutomaticRunning', \"Disallow Automatic Tasks in Folder\");\n    DisallowAutomaticTaskRunning = __decorate([\n        __param(2, storage_1.IStorageService)\n    ], DisallowAutomaticTaskRunning);\n    exports.DisallowAutomaticTaskRunning = DisallowAutomaticTaskRunning;\n});\n",null]}