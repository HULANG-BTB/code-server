{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/snippet/snippetSession.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/snippet/snippetSession.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/arrays\", \"vs/base/common/lifecycle\", \"vs/base/common/strings\", \"vs/editor/common/core/editOperation\", \"vs/editor/common/core/range\", \"vs/editor/common/core/selection\", \"vs/editor/common/model\", \"vs/editor/common/model/textModel\", \"vs/platform/clipboard/common/clipboardService\", \"vs/platform/workspace/common/workspace\", \"vs/platform/instantiation/common/instantiation\", \"./snippetParser\", \"./snippetVariables\", \"vs/platform/theme/common/themeService\", \"vs/platform/theme/common/colorRegistry\", \"vs/base/common/types\", \"vs/css!./snippetSession\"], function (require, exports, arrays_1, lifecycle_1, strings_1, editOperation_1, range_1, selection_1, model_1, textModel_1, clipboardService_1, workspace_1, instantiation_1, snippetParser_1, snippetVariables_1, themeService_1, colors, types_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    themeService_1.registerThemingParticipant((theme, collector) => {\n        function getColorGraceful(name) {\n            const color = theme.getColor(name);\n            return color ? color.toString() : 'transparent';\n        }\n        collector.addRule(`.monaco-editor .snippet-placeholder { background-color: ${getColorGraceful(colors.snippetTabstopHighlightBackground)}; outline-color: ${getColorGraceful(colors.snippetTabstopHighlightBorder)}; }`);\n        collector.addRule(`.monaco-editor .finish-snippet-placeholder { background-color: ${getColorGraceful(colors.snippetFinalTabstopHighlightBackground)}; outline-color: ${getColorGraceful(colors.snippetFinalTabstopHighlightBorder)}; }`);\n    });\n    class OneSnippet {\n        constructor(editor, snippet, offset) {\n            this._nestingLevel = 1;\n            this._editor = editor;\n            this._snippet = snippet;\n            this._offset = offset;\n            this._placeholderGroups = arrays_1.groupBy(snippet.placeholders, snippetParser_1.Placeholder.compareByIndex);\n            this._placeholderGroupsIdx = -1;\n        }\n        dispose() {\n            if (this._placeholderDecorations) {\n                let toRemove = [];\n                this._placeholderDecorations.forEach(handle => toRemove.push(handle));\n                this._editor.deltaDecorations(toRemove, []);\n            }\n            this._placeholderGroups.length = 0;\n        }\n        _initDecorations() {\n            if (this._placeholderDecorations) {\n                // already initialized\n                return;\n            }\n            this._placeholderDecorations = new Map();\n            const model = this._editor.getModel();\n            this._editor.changeDecorations(accessor => {\n                // create a decoration for each placeholder\n                for (const placeholder of this._snippet.placeholders) {\n                    const placeholderOffset = this._snippet.offset(placeholder);\n                    const placeholderLen = this._snippet.fullLen(placeholder);\n                    const range = range_1.Range.fromPositions(model.getPositionAt(this._offset + placeholderOffset), model.getPositionAt(this._offset + placeholderOffset + placeholderLen));\n                    const options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;\n                    const handle = accessor.addDecoration(range, options);\n                    this._placeholderDecorations.set(placeholder, handle);\n                }\n            });\n        }\n        move(fwd) {\n            if (!this._editor.hasModel()) {\n                return [];\n            }\n            this._initDecorations();\n            // Transform placeholder text if necessary\n            if (this._placeholderGroupsIdx >= 0) {\n                let operations = [];\n                for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n                    // Check if the placeholder has a transformation\n                    if (placeholder.transform) {\n                        const id = this._placeholderDecorations.get(placeholder);\n                        const range = this._editor.getModel().getDecorationRange(id);\n                        const currentValue = this._editor.getModel().getValueInRange(range);\n                        operations.push(editOperation_1.EditOperation.replaceMove(range, placeholder.transform.resolve(currentValue)));\n                    }\n                }\n                if (operations.length > 0) {\n                    this._editor.executeEdits('snippet.placeholderTransform', operations);\n                }\n            }\n            let skipThisPlaceholder = false;\n            if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {\n                this._placeholderGroupsIdx += 1;\n                skipThisPlaceholder = true;\n            }\n            else if (fwd === false && this._placeholderGroupsIdx > 0) {\n                this._placeholderGroupsIdx -= 1;\n                skipThisPlaceholder = true;\n            }\n            else {\n                // the selection of the current placeholder might\n                // not acurate any more -> simply restore it\n            }\n            const newSelections = this._editor.getModel().changeDecorations(accessor => {\n                const activePlaceholders = new Set();\n                // change stickiness to always grow when typing at its edges\n                // because these decorations represent the currently active\n                // tabstop.\n                // Special case #1: reaching the final tabstop\n                // Special case #2: placeholders enclosing active placeholders\n                const selections = [];\n                for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n                    const id = this._placeholderDecorations.get(placeholder);\n                    const range = this._editor.getModel().getDecorationRange(id);\n                    selections.push(new selection_1.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn));\n                    // consider to skip this placeholder index when the decoration\n                    // range is empty but when the placeholder wasn't. that's a strong\n                    // hint that the placeholder has been deleted. (all placeholder must match this)\n                    skipThisPlaceholder = skipThisPlaceholder && (range.isEmpty() && placeholder.toString().length > 0);\n                    accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n                    activePlaceholders.add(placeholder);\n                    for (const enclosingPlaceholder of this._snippet.enclosingPlaceholders(placeholder)) {\n                        const id = this._placeholderDecorations.get(enclosingPlaceholder);\n                        accessor.changeDecorationOptions(id, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n                        activePlaceholders.add(enclosingPlaceholder);\n                    }\n                }\n                // change stickness to never grow when typing at its edges\n                // so that in-active tabstops never grow\n                this._placeholderDecorations.forEach((id, placeholder) => {\n                    if (!activePlaceholders.has(placeholder)) {\n                        accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);\n                    }\n                });\n                return selections;\n            });\n            return !skipThisPlaceholder ? newSelections : this.move(fwd);\n        }\n        get isAtFirstPlaceholder() {\n            return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;\n        }\n        get isAtLastPlaceholder() {\n            return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;\n        }\n        get hasPlaceholder() {\n            return this._snippet.placeholders.length > 0;\n        }\n        computePossibleSelections() {\n            const result = new Map();\n            for (const placeholdersWithEqualIndex of this._placeholderGroups) {\n                let ranges;\n                for (const placeholder of placeholdersWithEqualIndex) {\n                    if (!ranges) {\n                        ranges = [];\n                        result.set(placeholder.index, ranges);\n                    }\n                    const id = this._placeholderDecorations.get(placeholder);\n                    const range = this._editor.getModel().getDecorationRange(id);\n                    if (!range) {\n                        // one of the placeholder lost its decoration and\n                        // therefore we bail out and pretend the placeholder\n                        // (with its mirrors) doesn't exist anymore.\n                        result.delete(placeholder.index);\n                        break;\n                    }\n                    ranges.push(range);\n                }\n            }\n            return result;\n        }\n        get choice() {\n            return this._placeholderGroups[this._placeholderGroupsIdx][0].choice;\n        }\n        merge(others) {\n            const model = this._editor.getModel();\n            this._nestingLevel *= 10;\n            this._editor.changeDecorations(accessor => {\n                // For each active placeholder take one snippet and merge it\n                // in that the placeholder (can be many for `$1foo$1foo`). Because\n                // everything is sorted by editor selection we can simply remove\n                // elements from the beginning of the array\n                for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n                    const nested = others.shift();\n                    console.assert(!nested._placeholderDecorations);\n                    // Massage placeholder-indicies of the nested snippet to be\n                    // sorted right after the insertion point. This ensures we move\n                    // through the placeholders in the correct order\n                    const indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;\n                    for (const nestedPlaceholder of nested._snippet.placeholderInfo.all) {\n                        if (nestedPlaceholder.isFinalTabstop) {\n                            nestedPlaceholder.index = placeholder.index + ((indexLastPlaceholder + 1) / this._nestingLevel);\n                        }\n                        else {\n                            nestedPlaceholder.index = placeholder.index + (nestedPlaceholder.index / this._nestingLevel);\n                        }\n                    }\n                    this._snippet.replace(placeholder, nested._snippet.children);\n                    // Remove the placeholder at which position are inserting\n                    // the snippet and also remove its decoration.\n                    const id = this._placeholderDecorations.get(placeholder);\n                    accessor.removeDecoration(id);\n                    this._placeholderDecorations.delete(placeholder);\n                    // For each *new* placeholder we create decoration to monitor\n                    // how and if it grows/shrinks.\n                    for (const placeholder of nested._snippet.placeholders) {\n                        const placeholderOffset = nested._snippet.offset(placeholder);\n                        const placeholderLen = nested._snippet.fullLen(placeholder);\n                        const range = range_1.Range.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));\n                        const handle = accessor.addDecoration(range, OneSnippet._decor.inactive);\n                        this._placeholderDecorations.set(placeholder, handle);\n                    }\n                }\n                // Last, re-create the placeholder groups by sorting placeholders by their index.\n                this._placeholderGroups = arrays_1.groupBy(this._snippet.placeholders, snippetParser_1.Placeholder.compareByIndex);\n            });\n        }\n        getEnclosingRange() {\n            let result;\n            const model = this._editor.getModel();\n            this._placeholderDecorations.forEach((decorationId) => {\n                const placeholderRange = types_1.withNullAsUndefined(model.getDecorationRange(decorationId));\n                if (!result) {\n                    result = placeholderRange;\n                }\n                else {\n                    result = result.plusRange(placeholderRange);\n                }\n            });\n            return result;\n        }\n    }\n    OneSnippet._decor = {\n        active: textModel_1.ModelDecorationOptions.register({ stickiness: model_1.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges, className: 'snippet-placeholder' }),\n        inactive: textModel_1.ModelDecorationOptions.register({ stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges, className: 'snippet-placeholder' }),\n        activeFinal: textModel_1.ModelDecorationOptions.register({ stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges, className: 'finish-snippet-placeholder' }),\n        inactiveFinal: textModel_1.ModelDecorationOptions.register({ stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges, className: 'finish-snippet-placeholder' }),\n    };\n    exports.OneSnippet = OneSnippet;\n    class SnippetSession {\n        constructor(editor, template, overwriteBefore = 0, overwriteAfter = 0, adjustWhitespace = true) {\n            this._templateMerges = [];\n            this._snippets = [];\n            this._editor = editor;\n            this._template = template;\n            this._overwriteBefore = overwriteBefore;\n            this._overwriteAfter = overwriteAfter;\n            this._adjustWhitespace = adjustWhitespace;\n        }\n        static adjustWhitespace(model, position, snippet) {\n            const line = model.getLineContent(position.lineNumber);\n            const lineLeadingWhitespace = strings_1.getLeadingWhitespace(line, 0, position.column - 1);\n            snippet.walk(marker => {\n                if (marker instanceof snippetParser_1.Text && !(marker.parent instanceof snippetParser_1.Choice)) {\n                    // adjust indentation of text markers, except for choise elements\n                    // which get adjusted when being selected\n                    const lines = marker.value.split(/\\r\\n|\\r|\\n/);\n                    for (let i = 1; i < lines.length; i++) {\n                        let templateLeadingWhitespace = strings_1.getLeadingWhitespace(lines[i]);\n                        lines[i] = model.normalizeIndentation(lineLeadingWhitespace + templateLeadingWhitespace) + lines[i].substr(templateLeadingWhitespace.length);\n                    }\n                    const newValue = lines.join(model.getEOL());\n                    if (newValue !== marker.value) {\n                        marker.parent.replace(marker, [new snippetParser_1.Text(newValue)]);\n                    }\n                }\n                return true;\n            });\n        }\n        static adjustSelection(model, selection, overwriteBefore, overwriteAfter) {\n            if (overwriteBefore !== 0 || overwriteAfter !== 0) {\n                // overwrite[Before|After] is compute using the position, not the whole\n                // selection. therefore we adjust the selection around that position\n                const { positionLineNumber, positionColumn } = selection;\n                const positionColumnBefore = positionColumn - overwriteBefore;\n                const positionColumnAfter = positionColumn + overwriteAfter;\n                const range = model.validateRange({\n                    startLineNumber: positionLineNumber,\n                    startColumn: positionColumnBefore,\n                    endLineNumber: positionLineNumber,\n                    endColumn: positionColumnAfter\n                });\n                selection = selection_1.Selection.createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());\n            }\n            return selection;\n        }\n        static createEditsAndSnippets(editor, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace) {\n            const edits = [];\n            const snippets = [];\n            if (!editor.hasModel()) {\n                return { edits, snippets };\n            }\n            const model = editor.getModel();\n            const modelBasedVariableResolver = new snippetVariables_1.ModelBasedVariableResolver(model);\n            const clipboardService = editor.invokeWithinContext(accessor => accessor.get(clipboardService_1.IClipboardService, instantiation_1.optional));\n            const workspaceService = editor.invokeWithinContext(accessor => accessor.get(workspace_1.IWorkspaceContextService, instantiation_1.optional));\n            let delta = 0;\n            // know what text the overwrite[Before|After] extensions\n            // of the primary curser have selected because only when\n            // secondary selections extend to the same text we can grow them\n            let firstBeforeText = model.getValueInRange(SnippetSession.adjustSelection(model, editor.getSelection(), overwriteBefore, 0));\n            let firstAfterText = model.getValueInRange(SnippetSession.adjustSelection(model, editor.getSelection(), 0, overwriteAfter));\n            // remember the first non-whitespace column to decide if\n            // `keepWhitespace` should be overruled for secondary selections\n            let firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor.getSelection().positionLineNumber);\n            // sort selections by their start position but remeber\n            // the original index. that allows you to create correct\n            // offset-based selection logic without changing the\n            // primary selection\n            const indexedSelections = editor.getSelections()\n                .map((selection, idx) => ({ selection, idx }))\n                .sort((a, b) => range_1.Range.compareRangesUsingStarts(a.selection, b.selection));\n            for (const { selection, idx } of indexedSelections) {\n                // extend selection with the `overwriteBefore` and `overwriteAfter` and then\n                // compare if this matches the extensions of the primary selection\n                let extensionBefore = SnippetSession.adjustSelection(model, selection, overwriteBefore, 0);\n                let extensionAfter = SnippetSession.adjustSelection(model, selection, 0, overwriteAfter);\n                if (firstBeforeText !== model.getValueInRange(extensionBefore)) {\n                    extensionBefore = selection;\n                }\n                if (firstAfterText !== model.getValueInRange(extensionAfter)) {\n                    extensionAfter = selection;\n                }\n                // merge the before and after selection into one\n                const snippetSelection = selection\n                    .setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn)\n                    .setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);\n                const snippet = new snippetParser_1.SnippetParser().parse(template, true, enforceFinalTabstop);\n                // adjust the template string to match the indentation and\n                // whitespace rules of this insert location (can be different for each cursor)\n                // happens when being asked for (default) or when this is a secondary\n                // cursor and the leading whitespace is different\n                const start = snippetSelection.getStartPosition();\n                if (adjustWhitespace || (idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber))) {\n                    SnippetSession.adjustWhitespace(model, start, snippet);\n                }\n                snippet.resolveVariables(new snippetVariables_1.CompositeSnippetVariableResolver([\n                    modelBasedVariableResolver,\n                    new snippetVariables_1.ClipboardBasedVariableResolver(clipboardService, idx, indexedSelections.length),\n                    new snippetVariables_1.SelectionBasedVariableResolver(model, selection),\n                    new snippetVariables_1.CommentBasedVariableResolver(model),\n                    new snippetVariables_1.TimeBasedVariableResolver,\n                    new snippetVariables_1.WorkspaceBasedVariableResolver(workspaceService),\n                ]));\n                const offset = model.getOffsetAt(start) + delta;\n                delta += snippet.toString().length - model.getValueLengthInRange(snippetSelection);\n                // store snippets with the index of their originating selection.\n                // that ensures the primiary cursor stays primary despite not being\n                // the one with lowest start position\n                edits[idx] = editOperation_1.EditOperation.replace(snippetSelection, snippet.toString());\n                snippets[idx] = new OneSnippet(editor, snippet, offset);\n            }\n            return { edits, snippets };\n        }\n        dispose() {\n            lifecycle_1.dispose(this._snippets);\n        }\n        _logInfo() {\n            return `template=\"${this._template}\", merged_templates=\"${this._templateMerges.join(' -> ')}\"`;\n        }\n        insert() {\n            if (!this._editor.hasModel()) {\n                return;\n            }\n            const model = this._editor.getModel();\n            // make insert edit and start with first selections\n            const { edits, snippets } = SnippetSession.createEditsAndSnippets(this._editor, this._template, this._overwriteBefore, this._overwriteAfter, false, this._adjustWhitespace);\n            this._snippets = snippets;\n            const selections = model.pushEditOperations(this._editor.getSelections(), edits, undoEdits => {\n                if (this._snippets[0].hasPlaceholder) {\n                    return this._move(true);\n                }\n                else {\n                    return undoEdits.map(edit => selection_1.Selection.fromPositions(edit.range.getEndPosition()));\n                }\n            });\n            this._editor.setSelections(selections);\n            this._editor.revealRange(selections[0]);\n        }\n        merge(template, overwriteBefore = 0, overwriteAfter = 0, adjustWhitespace = true) {\n            if (!this._editor.hasModel()) {\n                return;\n            }\n            this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);\n            const { edits, snippets } = SnippetSession.createEditsAndSnippets(this._editor, template, overwriteBefore, overwriteAfter, true, adjustWhitespace);\n            this._editor.setSelections(this._editor.getModel().pushEditOperations(this._editor.getSelections(), edits, undoEdits => {\n                for (const snippet of this._snippets) {\n                    snippet.merge(snippets);\n                }\n                console.assert(snippets.length === 0);\n                if (this._snippets[0].hasPlaceholder) {\n                    return this._move(undefined);\n                }\n                else {\n                    return undoEdits.map(edit => selection_1.Selection.fromPositions(edit.range.getEndPosition()));\n                }\n            }));\n        }\n        next() {\n            const newSelections = this._move(true);\n            this._editor.setSelections(newSelections);\n            this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n        }\n        prev() {\n            const newSelections = this._move(false);\n            this._editor.setSelections(newSelections);\n            this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n        }\n        _move(fwd) {\n            const selections = [];\n            for (const snippet of this._snippets) {\n                const oneSelection = snippet.move(fwd);\n                selections.push(...oneSelection);\n            }\n            return selections;\n        }\n        get isAtFirstPlaceholder() {\n            return this._snippets[0].isAtFirstPlaceholder;\n        }\n        get isAtLastPlaceholder() {\n            return this._snippets[0].isAtLastPlaceholder;\n        }\n        get hasPlaceholder() {\n            return this._snippets[0].hasPlaceholder;\n        }\n        get choice() {\n            return this._snippets[0].choice;\n        }\n        isSelectionWithinPlaceholders() {\n            if (!this.hasPlaceholder) {\n                return false;\n            }\n            const selections = this._editor.getSelections();\n            if (selections.length < this._snippets.length) {\n                // this means we started snippet mode with N\n                // selections and have M (N > M) selections.\n                // So one snippet is without selection -> cancel\n                return false;\n            }\n            let allPossibleSelections = new Map();\n            for (const snippet of this._snippets) {\n                const possibleSelections = snippet.computePossibleSelections();\n                // for the first snippet find the placeholder (and its ranges)\n                // that contain at least one selection. for all remaining snippets\n                // the same placeholder (and their ranges) must be used.\n                if (allPossibleSelections.size === 0) {\n                    possibleSelections.forEach((ranges, index) => {\n                        ranges.sort(range_1.Range.compareRangesUsingStarts);\n                        for (const selection of selections) {\n                            if (ranges[0].containsRange(selection)) {\n                                allPossibleSelections.set(index, []);\n                                break;\n                            }\n                        }\n                    });\n                }\n                if (allPossibleSelections.size === 0) {\n                    // return false if we couldn't associate a selection to\n                    // this (the first) snippet\n                    return false;\n                }\n                if (allPossibleSelections.has(0)) {\n                    // selection overlaps with a final tab stop which means\n                    // we done\n                    return false;\n                }\n                // add selections from 'this' snippet so that we know all\n                // selections for this placeholder\n                allPossibleSelections.forEach((array, index) => {\n                    array.push(...possibleSelections.get(index));\n                });\n            }\n            // sort selections (and later placeholder-ranges). then walk both\n            // arrays and make sure the placeholder-ranges contain the corresponding\n            // selection\n            selections.sort(range_1.Range.compareRangesUsingStarts);\n            allPossibleSelections.forEach((ranges, index) => {\n                if (ranges.length !== selections.length) {\n                    allPossibleSelections.delete(index);\n                    return;\n                }\n                ranges.sort(range_1.Range.compareRangesUsingStarts);\n                for (let i = 0; i < ranges.length; i++) {\n                    if (!ranges[i].containsRange(selections[i])) {\n                        allPossibleSelections.delete(index);\n                        return;\n                    }\n                }\n            });\n            // from all possible selections we have deleted those\n            // that don't match with the current selection. if we don't\n            // have any left, we don't have a selection anymore\n            return allPossibleSelections.size > 0;\n        }\n        getEnclosingRange() {\n            let result;\n            for (const snippet of this._snippets) {\n                const snippetRange = snippet.getEnclosingRange();\n                if (!result) {\n                    result = snippetRange;\n                }\n                else {\n                    result = result.plusRange(snippetRange);\n                }\n            }\n            return result;\n        }\n    }\n    exports.SnippetSession = SnippetSession;\n});\n",null]}