{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/paging.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/paging.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/types\", \"vs/base/common/cancellation\", \"vs/base/common/errors\", \"vs/base/common/arrays\"], function (require, exports, types_1, cancellation_1, errors_1, arrays_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function createPage(elements) {\n        return {\n            isResolved: !!elements,\n            promise: null,\n            cts: null,\n            promiseIndexes: new Set(),\n            elements: elements || []\n        };\n    }\n    function singlePagePager(elements) {\n        return {\n            firstPage: elements,\n            total: elements.length,\n            pageSize: elements.length,\n            getPage: (pageIndex, cancellationToken) => {\n                return Promise.resolve(elements);\n            }\n        };\n    }\n    exports.singlePagePager = singlePagePager;\n    class PagedModel {\n        constructor(arg) {\n            this.pages = [];\n            this.pager = types_1.isArray(arg) ? singlePagePager(arg) : arg;\n            const totalPages = Math.ceil(this.pager.total / this.pager.pageSize);\n            this.pages = [\n                createPage(this.pager.firstPage.slice()),\n                ...arrays_1.range(totalPages - 1).map(() => createPage())\n            ];\n        }\n        get length() { return this.pager.total; }\n        isResolved(index) {\n            const pageIndex = Math.floor(index / this.pager.pageSize);\n            const page = this.pages[pageIndex];\n            return !!page.isResolved;\n        }\n        get(index) {\n            const pageIndex = Math.floor(index / this.pager.pageSize);\n            const indexInPage = index % this.pager.pageSize;\n            const page = this.pages[pageIndex];\n            return page.elements[indexInPage];\n        }\n        resolve(index, cancellationToken) {\n            if (cancellationToken.isCancellationRequested) {\n                return Promise.reject(errors_1.canceled());\n            }\n            const pageIndex = Math.floor(index / this.pager.pageSize);\n            const indexInPage = index % this.pager.pageSize;\n            const page = this.pages[pageIndex];\n            if (page.isResolved) {\n                return Promise.resolve(page.elements[indexInPage]);\n            }\n            if (!page.promise) {\n                page.cts = new cancellation_1.CancellationTokenSource();\n                page.promise = this.pager.getPage(pageIndex, page.cts.token)\n                    .then(elements => {\n                    page.elements = elements;\n                    page.isResolved = true;\n                    page.promise = null;\n                    page.cts = null;\n                }, err => {\n                    page.isResolved = false;\n                    page.promise = null;\n                    page.cts = null;\n                    return Promise.reject(err);\n                });\n            }\n            cancellationToken.onCancellationRequested(() => {\n                if (!page.cts) {\n                    return;\n                }\n                page.promiseIndexes.delete(index);\n                if (page.promiseIndexes.size === 0) {\n                    page.cts.cancel();\n                }\n            });\n            page.promiseIndexes.add(index);\n            return page.promise.then(() => page.elements[indexInPage]);\n        }\n    }\n    exports.PagedModel = PagedModel;\n    class DelayedPagedModel {\n        constructor(model, timeout = 500) {\n            this.model = model;\n            this.timeout = timeout;\n        }\n        get length() { return this.model.length; }\n        isResolved(index) {\n            return this.model.isResolved(index);\n        }\n        get(index) {\n            return this.model.get(index);\n        }\n        resolve(index, cancellationToken) {\n            return new Promise((c, e) => {\n                if (cancellationToken.isCancellationRequested) {\n                    return e(errors_1.canceled());\n                }\n                const timer = setTimeout(() => {\n                    if (cancellationToken.isCancellationRequested) {\n                        return e(errors_1.canceled());\n                    }\n                    timeoutCancellation.dispose();\n                    this.model.resolve(index, cancellationToken).then(c, e);\n                }, this.timeout);\n                const timeoutCancellation = cancellationToken.onCancellationRequested(() => {\n                    clearTimeout(timer);\n                    timeoutCancellation.dispose();\n                    e(errors_1.canceled());\n                });\n            });\n        }\n    }\n    exports.DelayedPagedModel = DelayedPagedModel;\n    /**\n     * Similar to array.map, `mapPager` lets you map the elements of an\n     * abstract paged collection to another type.\n     */\n    function mapPager(pager, fn) {\n        return {\n            firstPage: pager.firstPage.map(fn),\n            total: pager.total,\n            pageSize: pager.pageSize,\n            getPage: (pageIndex, token) => pager.getPage(pageIndex, token).then(r => r.map(fn))\n        };\n    }\n    exports.mapPager = mapPager;\n    /**\n     * Merges two pagers.\n     */\n    function mergePagers(one, other) {\n        return {\n            firstPage: [...one.firstPage, ...other.firstPage],\n            total: one.total + other.total,\n            pageSize: one.pageSize + other.pageSize,\n            getPage(pageIndex, token) {\n                return Promise.all([one.getPage(pageIndex, token), other.getPage(pageIndex, token)])\n                    .then(([onePage, otherPage]) => [...onePage, ...otherPage]);\n            }\n        };\n    }\n    exports.mergePagers = mergePagers;\n});\n",null]}