{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/storage/node/storageMainService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/storage/node/storageMainService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/platform/instantiation/common/instantiation\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/platform/log/common/log\", \"vs/platform/environment/common/environment\", \"vs/base/node/storage\", \"vs/base/common/path\", \"vs/base/node/pfs\", \"vs/base/common/strings\"], function (require, exports, instantiation_1, event_1, lifecycle_1, log_1, environment_1, storage_1, path_1, pfs_1, strings_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.IStorageMainService = instantiation_1.createDecorator('storageMainService');\n    let StorageMainService = class StorageMainService extends lifecycle_1.Disposable {\n        constructor(logService, environmentService) {\n            super();\n            this.logService = logService;\n            this.environmentService = environmentService;\n            this._onDidChangeStorage = this._register(new event_1.Emitter());\n            this._onWillSaveState = this._register(new event_1.Emitter());\n            // Until the storage has been initialized, it can only be in memory\n            this.storage = new storage_1.Storage(new storage_1.InMemoryStorageDatabase());\n        }\n        get onDidChangeStorage() { return this._onDidChangeStorage.event; }\n        get onWillSaveState() { return this._onWillSaveState.event; }\n        get items() { return this.storage.items; }\n        get storagePath() {\n            if (!!this.environmentService.extensionTestsLocationURI) {\n                return storage_1.SQLiteStorageDatabase.IN_MEMORY_PATH; // no storage during extension tests!\n            }\n            return path_1.join(this.environmentService.globalStorageHome, StorageMainService.STORAGE_NAME);\n        }\n        createLogginOptions() {\n            return {\n                logTrace: (this.logService.getLevel() === log_1.LogLevel.Trace) ? msg => this.logService.trace(msg) : undefined,\n                logError: error => this.logService.error(error)\n            };\n        }\n        initialize() {\n            if (!this.initializePromise) {\n                this.initializePromise = this.doInitialize();\n            }\n            return this.initializePromise;\n        }\n        doInitialize() {\n            const useInMemoryStorage = this.storagePath === storage_1.SQLiteStorageDatabase.IN_MEMORY_PATH;\n            let globalStorageExists;\n            if (useInMemoryStorage) {\n                globalStorageExists = Promise.resolve(true);\n            }\n            else {\n                globalStorageExists = pfs_1.exists(this.storagePath);\n            }\n            return globalStorageExists.then(exists => {\n                this.storage.dispose();\n                this.storage = new storage_1.Storage(new storage_1.SQLiteStorageDatabase(this.storagePath, {\n                    logging: this.createLogginOptions()\n                }));\n                this._register(this.storage.onDidChangeStorage(key => this._onDidChangeStorage.fire({ key })));\n                return this.storage.init().then(() => {\n                    // Migrate storage if this is the first start and we are not using in-memory\n                    let migrationPromise;\n                    if (!useInMemoryStorage && !exists) {\n                        // TODO@Ben remove global storage migration and move Storage creation back to ctor\n                        migrationPromise = this.migrateGlobalStorage().then(() => this.logService.info('[storage] migrated global storage'), error => this.logService.error(`[storage] migration error ${error}`));\n                    }\n                    else {\n                        migrationPromise = Promise.resolve();\n                    }\n                    return migrationPromise;\n                });\n            });\n        }\n        migrateGlobalStorage() {\n            this.logService.info('[storage] migrating global storage from localStorage into SQLite');\n            const localStorageDBBackup = path_1.join(this.environmentService.userDataPath, 'Local Storage', 'file__0.vscmig');\n            return pfs_1.exists(localStorageDBBackup).then(exists => {\n                if (!exists) {\n                    return Promise.resolve(); // return if there is no DB to migrate from\n                }\n                return pfs_1.readdir(this.environmentService.extensionsPath).then(extensions => {\n                    const supportedKeys = new Map();\n                    [\n                        'editorFontInfo',\n                        'peekViewLayout',\n                        'expandSuggestionDocs',\n                        'extensionsIdentifiers/disabled',\n                        'integrityService',\n                        'telemetry.lastSessionDate',\n                        'telemetry.instanceId',\n                        'telemetry.firstSessionDate',\n                        'workbench.sidebar.width',\n                        'workbench.panel.width',\n                        'workbench.panel.height',\n                        'workbench.panel.sizeBeforeMaximized',\n                        'workbench.activity.placeholderViewlets',\n                        'colorThemeData',\n                        'iconThemeData',\n                        'workbench.telemetryOptOutShown',\n                        'workbench.hide.welcome',\n                        'releaseNotes/lastVersion',\n                        'debug.actionswidgetposition',\n                        'debug.actionswidgety',\n                        'editor.neverPromptForLargeFiles',\n                        'menubar/electronFixRecommended',\n                        'learnMoreDirtyWriteError',\n                        'extensions.ignoredAutoUpdateExtension',\n                        'askToInstallRemoteServerExtension',\n                        'hasNotifiedOfSettingsAutosave',\n                        'commandPalette.mru.cache',\n                        'commandPalette.mru.counter',\n                        'parts-splash-data',\n                        'terminal.integrated.neverMeasureRenderTime',\n                        'terminal.integrated.neverSuggestSelectWindowsShell',\n                        'memento/workbench.parts.editor',\n                        'memento/workbench.view.search',\n                        'langugage.update.donotask',\n                        'extensionsAssistant/languagePackSuggestionIgnore',\n                        'workbench.panel.pinnedPanels',\n                        'workbench.activity.pinnedViewlets',\n                        'extensionsAssistant/ignored_recommendations',\n                        'extensionsAssistant/recommendations',\n                        'extensionsAssistant/importantRecommendationsIgnore',\n                        'extensionsAssistant/fileExtensionsSuggestionIgnore',\n                        'nps/skipVersion',\n                        'nps/lastSessionDate',\n                        'nps/sessionCount',\n                        'nps/isCandidate',\n                        'allExperiments',\n                        'currentOrPreviouslyRunExperiments',\n                        'update/win32-64bits',\n                        'update/win32-fast-updates',\n                        'update/lastKnownVersion',\n                        'update/updateNotificationTime'\n                    ].forEach(key => supportedKeys.set(key.toLowerCase(), key));\n                    // https://github.com/Microsoft/vscode/issues/68468\n                    const wellKnownPublishers = ['Microsoft', 'GitHub'];\n                    const wellKnownExtensions = ['ms-vscode.Go', 'WallabyJs.quokka-vscode', 'Telerik.nativescript', 'Shan.code-settings-sync', 'ritwickdey.LiveServer', 'PKief.material-icon-theme', 'PeterJausovec.vscode-docker', 'ms-vscode.PowerShell', 'LaurentTreguier.vscode-simple-icons', 'KnisterPeter.vscode-github', 'DotJoshJohnson.xml', 'Dart-Code.dart-code', 'alefragnani.Bookmarks'];\n                    // Support extension storage as well (always the ID of the extension)\n                    extensions.forEach(extension => {\n                        let extensionId;\n                        if (extension.indexOf('-') >= 0) {\n                            extensionId = extension.substring(0, extension.lastIndexOf('-')); // convert \"author.extension-0.2.5\" => \"author.extension\"\n                        }\n                        else {\n                            extensionId = extension;\n                        }\n                        if (extensionId) {\n                            for (let i = 0; i < wellKnownPublishers.length; i++) {\n                                const publisher = wellKnownPublishers[i];\n                                if (strings_1.startsWith(extensionId, `${publisher.toLowerCase()}.`)) {\n                                    extensionId = `${publisher}${extensionId.substr(publisher.length)}`;\n                                    break;\n                                }\n                            }\n                            for (let j = 0; j < wellKnownExtensions.length; j++) {\n                                const wellKnownExtension = wellKnownExtensions[j];\n                                if (extensionId === wellKnownExtension.toLowerCase()) {\n                                    extensionId = wellKnownExtension;\n                                    break;\n                                }\n                            }\n                            supportedKeys.set(extensionId.toLowerCase(), extensionId);\n                        }\n                    });\n                    return new Promise((resolve_1, reject_1) => { require(['vscode-sqlite3'], resolve_1, reject_1); }).then(sqlite3 => {\n                        return new Promise((resolve, reject) => {\n                            const handleSuffixKey = (row, key, suffix) => {\n                                if (strings_1.endsWith(key, suffix.toLowerCase())) {\n                                    const value = row.value.toString('utf16le');\n                                    const normalizedKey = key.substring(0, key.length - suffix.length) + suffix;\n                                    this.store(normalizedKey, value);\n                                    return true;\n                                }\n                                return false;\n                            };\n                            const db = new (sqlite3.Database)(localStorageDBBackup, error => {\n                                if (error) {\n                                    if (db) {\n                                        db.close();\n                                    }\n                                    return reject(error);\n                                }\n                                db.all('SELECT key, value FROM ItemTable', (error, rows) => {\n                                    if (error) {\n                                        db.close();\n                                        return reject(error);\n                                    }\n                                    try {\n                                        rows.forEach(row => {\n                                            let key = row.key;\n                                            if (key.indexOf('storage://global/') !== 0) {\n                                                return; // not a global key\n                                            }\n                                            // convert storage://global/colorthemedata => colorthemedata\n                                            key = key.substr('storage://global/'.length);\n                                            const supportedKey = supportedKeys.get(key);\n                                            if (supportedKey) {\n                                                const value = row.value.toString('utf16le');\n                                                this.store(supportedKey, value);\n                                            }\n                                            // dynamic values\n                                            else if (strings_1.endsWith(key, '.hidden') ||\n                                                strings_1.startsWith(key, 'experiments.')) {\n                                                const value = row.value.toString('utf16le');\n                                                this.store(key, value);\n                                            }\n                                            // fix lowercased \".sessionCount\"\n                                            else if (handleSuffixKey(row, key, '.sessionCount')) { }\n                                            // fix lowercased \".lastSessionDate\"\n                                            else if (handleSuffixKey(row, key, '.lastSessionDate')) { }\n                                            // fix lowercased \".skipVersion\"\n                                            else if (handleSuffixKey(row, key, '.skipVersion')) { }\n                                            // fix lowercased \".isCandidate\"\n                                            else if (handleSuffixKey(row, key, '.isCandidate')) { }\n                                            // fix lowercased \".editedCount\"\n                                            else if (handleSuffixKey(row, key, '.editedCount')) { }\n                                            // fix lowercased \".editedDate\"\n                                            else if (handleSuffixKey(row, key, '.editedDate')) { }\n                                        });\n                                        db.close();\n                                    }\n                                    catch (error) {\n                                        db.close();\n                                        return reject(error);\n                                    }\n                                    resolve();\n                                });\n                            });\n                        });\n                    });\n                });\n            });\n        }\n        get(key, fallbackValue) {\n            return this.storage.get(key, fallbackValue);\n        }\n        getBoolean(key, fallbackValue) {\n            return this.storage.getBoolean(key, fallbackValue);\n        }\n        getNumber(key, fallbackValue) {\n            return this.storage.getNumber(key, fallbackValue);\n        }\n        store(key, value) {\n            return this.storage.set(key, value);\n        }\n        remove(key) {\n            return this.storage.delete(key);\n        }\n        close() {\n            // Signal as event so that clients can still store data\n            this._onWillSaveState.fire();\n            // Do it\n            return this.storage.close();\n        }\n        checkIntegrity(full) {\n            return this.storage.checkIntegrity(full);\n        }\n    };\n    StorageMainService.STORAGE_NAME = 'state.vscdb';\n    StorageMainService = __decorate([\n        __param(0, log_1.ILogService),\n        __param(1, environment_1.IEnvironmentService)\n    ], StorageMainService);\n    exports.StorageMainService = StorageMainService;\n});\n",null]}