{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/debugUtils.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/debugUtils.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar strings_1 = require(\"vs/base/common/strings\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar path_1 = require(\"vs/base/common/path\");\nvar objects_1 = require(\"vs/base/common/objects\");\nvar arrays_1 = require(\"vs/base/common/arrays\");\nvar _formatPIIRegexp = /{([^}]+)}/g;\nfunction startDebugging(debugService, historyService, noDebug) {\n    var configurationManager = debugService.getConfigurationManager();\n    var launch = configurationManager.selectedConfiguration.launch;\n    if (!launch || launch.getConfigurationNames().length === 0) {\n        var rootUri = historyService.getLastActiveWorkspaceRoot();\n        launch = configurationManager.getLaunch(rootUri);\n        if (!launch || launch.getConfigurationNames().length === 0) {\n            var launches = configurationManager.getLaunches();\n            launch = arrays_1.first(launches, function (l) { return !!(l && l.getConfigurationNames().length); }, launch);\n        }\n        configurationManager.selectConfiguration(launch);\n    }\n    return debugService.startDebugging(launch, undefined, noDebug);\n}\nexports.startDebugging = startDebugging;\nfunction formatPII(value, excludePII, args) {\n    return value.replace(_formatPIIRegexp, function (match, group) {\n        if (excludePII && group.length > 0 && group[0] !== '_') {\n            return match;\n        }\n        return args && args.hasOwnProperty(group) ?\n            args[group] :\n            match;\n    });\n}\nexports.formatPII = formatPII;\nfunction isExtensionHostDebugging(config) {\n    return config.type && strings_1.equalsIgnoreCase(config.type === 'vslsShare' ? config.adapterProxy.configuration.type : config.type, 'extensionhost');\n}\nexports.isExtensionHostDebugging = isExtensionHostDebugging;\n// only a debugger contributions with a label, program, or runtime attribute is considered a \"defining\" or \"main\" debugger contribution\nfunction isDebuggerMainContribution(dbg) {\n    return dbg.type && (dbg.label || dbg.program || dbg.runtime);\n}\nexports.isDebuggerMainContribution = isDebuggerMainContribution;\nfunction getExactExpressionStartAndEnd(lineContent, looseStart, looseEnd) {\n    var matchingExpression = undefined;\n    var startOffset = 0;\n    // Some example supported expressions: myVar.prop, a.b.c.d, myVar?.prop, myVar->prop, MyClass::StaticProp, *myVar\n    // Match any character except a set of characters which often break interesting sub-expressions\n    var expression = /([^()\\[\\]{}<>\\s+\\-/%~#^;=|,`!]|\\->)+/g;\n    var result = null;\n    // First find the full expression under the cursor\n    while (result = expression.exec(lineContent)) {\n        var start = result.index + 1;\n        var end = start + result[0].length;\n        if (start <= looseStart && end >= looseEnd) {\n            matchingExpression = result[0];\n            startOffset = start;\n            break;\n        }\n    }\n    // If there are non-word characters after the cursor, we want to truncate the expression then.\n    // For example in expression 'a.b.c.d', if the focus was under 'b', 'a.b' would be evaluated.\n    if (matchingExpression) {\n        var subExpression = /\\w+/g;\n        var subExpressionResult = null;\n        while (subExpressionResult = subExpression.exec(matchingExpression)) {\n            var subEnd = subExpressionResult.index + 1 + startOffset + subExpressionResult[0].length;\n            if (subEnd >= looseEnd) {\n                break;\n            }\n        }\n        if (subExpressionResult) {\n            matchingExpression = matchingExpression.substring(0, subExpression.lastIndex);\n        }\n    }\n    return matchingExpression ?\n        { start: startOffset, end: startOffset + matchingExpression.length - 1 } :\n        { start: 0, end: 0 };\n}\nexports.getExactExpressionStartAndEnd = getExactExpressionStartAndEnd;\n// RFC 2396, Appendix A: https://www.ietf.org/rfc/rfc2396.txt\nvar _schemePattern = /^[a-zA-Z][a-zA-Z0-9\\+\\-\\.]+:/;\nfunction isUri(s) {\n    // heuristics: a valid uri starts with a scheme and\n    // the scheme has at least 2 characters so that it doesn't look like a drive letter.\n    return !!(s && s.match(_schemePattern));\n}\nexports.isUri = isUri;\nfunction stringToUri(path) {\n    if (typeof path === 'string') {\n        if (isUri(path)) {\n            return uri_1.URI.parse(path);\n        }\n        else {\n            // assume path\n            if (path_1.isAbsolute(path)) {\n                return uri_1.URI.file(path);\n            }\n            else {\n                // leave relative path as is\n            }\n        }\n    }\n    return path;\n}\nfunction uriToString(path) {\n    if (typeof path === 'object') {\n        var u = uri_1.URI.revive(path);\n        if (u.scheme === 'file') {\n            return u.fsPath;\n        }\n        else {\n            return u.toString();\n        }\n    }\n    return path;\n}\nfunction convertToDAPaths(message, toUri) {\n    var fixPath = toUri ? stringToUri : uriToString;\n    // since we modify Source.paths in the message in place, we need to make a copy of it (see #61129)\n    var msg = objects_1.deepClone(message);\n    convertPaths(msg, function (toDA, source) {\n        if (toDA && source) {\n            source.path = source.path ? fixPath(source.path) : undefined;\n        }\n    });\n    return msg;\n}\nexports.convertToDAPaths = convertToDAPaths;\nfunction convertToVSCPaths(message, toUri) {\n    var fixPath = toUri ? stringToUri : uriToString;\n    // since we modify Source.paths in the message in place, we need to make a copy of it (see #61129)\n    var msg = objects_1.deepClone(message);\n    convertPaths(msg, function (toDA, source) {\n        if (!toDA && source) {\n            source.path = source.path ? fixPath(source.path) : undefined;\n        }\n    });\n    return msg;\n}\nexports.convertToVSCPaths = convertToVSCPaths;\nfunction convertPaths(msg, fixSourcePath) {\n    switch (msg.type) {\n        case 'event':\n            var event = msg;\n            switch (event.event) {\n                case 'output':\n                    fixSourcePath(false, event.body.source);\n                    break;\n                case 'loadedSource':\n                    fixSourcePath(false, event.body.source);\n                    break;\n                case 'breakpoint':\n                    fixSourcePath(false, event.body.breakpoint.source);\n                    break;\n                default:\n                    break;\n            }\n            break;\n        case 'request':\n            var request = msg;\n            switch (request.command) {\n                case 'setBreakpoints':\n                    fixSourcePath(true, request.arguments.source);\n                    break;\n                case 'source':\n                    fixSourcePath(true, request.arguments.source);\n                    break;\n                case 'gotoTargets':\n                    fixSourcePath(true, request.arguments.source);\n                    break;\n                case 'launchVSCode':\n                    request.arguments.args.forEach(function (arg) { return fixSourcePath(false, arg); });\n                    break;\n                default:\n                    break;\n            }\n            break;\n        case 'response':\n            var response = msg;\n            if (response.success) {\n                switch (response.command) {\n                    case 'stackTrace':\n                        response.body.stackFrames.forEach(function (frame) { return fixSourcePath(false, frame.source); });\n                        break;\n                    case 'loadedSources':\n                        response.body.sources.forEach(function (source) { return fixSourcePath(false, source); });\n                        break;\n                    case 'scopes':\n                        response.body.scopes.forEach(function (scope) { return fixSourcePath(false, scope.source); });\n                        break;\n                    case 'setFunctionBreakpoints':\n                        response.body.breakpoints.forEach(function (bp) { return fixSourcePath(false, bp.source); });\n                        break;\n                    case 'setBreakpoints':\n                        response.body.breakpoints.forEach(function (bp) { return fixSourcePath(false, bp.source); });\n                        break;\n                    default:\n                        break;\n                }\n            }\n            break;\n    }\n}\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/debugUtils.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/debugUtils.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equalsIgnoreCase } from 'vs/base/common/strings';\nimport { IConfig, IDebuggerContribution, IDebugService } from 'vs/workbench/contrib/debug/common/debug';\nimport { URI as uri } from 'vs/base/common/uri';\nimport { isAbsolute } from 'vs/base/common/path';\nimport { deepClone } from 'vs/base/common/objects';\nimport { IHistoryService } from 'vs/workbench/services/history/common/history';\nimport { first } from 'vs/base/common/arrays';\n\nconst _formatPIIRegexp = /{([^}]+)}/g;\n\nexport function startDebugging(debugService: IDebugService, historyService: IHistoryService, noDebug: boolean, ): Promise<boolean> {\n\tconst configurationManager = debugService.getConfigurationManager();\n\tlet launch = configurationManager.selectedConfiguration.launch;\n\tif (!launch || launch.getConfigurationNames().length === 0) {\n\t\tconst rootUri = historyService.getLastActiveWorkspaceRoot();\n\t\tlaunch = configurationManager.getLaunch(rootUri);\n\t\tif (!launch || launch.getConfigurationNames().length === 0) {\n\t\t\tconst launches = configurationManager.getLaunches();\n\t\t\tlaunch = first(launches, l => !!(l && l.getConfigurationNames().length), launch);\n\t\t}\n\n\t\tconfigurationManager.selectConfiguration(launch);\n\t}\n\n\treturn debugService.startDebugging(launch, undefined, noDebug);\n}\n\nexport function formatPII(value: string, excludePII: boolean, args: { [key: string]: string }): string {\n\treturn value.replace(_formatPIIRegexp, function (match, group) {\n\t\tif (excludePII && group.length > 0 && group[0] !== '_') {\n\t\t\treturn match;\n\t\t}\n\n\t\treturn args && args.hasOwnProperty(group) ?\n\t\t\targs[group] :\n\t\t\tmatch;\n\t});\n}\n\nexport function isExtensionHostDebugging(config: IConfig) {\n\treturn config.type && equalsIgnoreCase(config.type === 'vslsShare' ? (<any>config).adapterProxy.configuration.type : config.type, 'extensionhost');\n}\n\n// only a debugger contributions with a label, program, or runtime attribute is considered a \"defining\" or \"main\" debugger contribution\nexport function isDebuggerMainContribution(dbg: IDebuggerContribution) {\n\treturn dbg.type && (dbg.label || dbg.program || dbg.runtime);\n}\n\nexport function getExactExpressionStartAndEnd(lineContent: string, looseStart: number, looseEnd: number): { start: number, end: number } {\n\tlet matchingExpression: string | undefined = undefined;\n\tlet startOffset = 0;\n\n\t// Some example supported expressions: myVar.prop, a.b.c.d, myVar?.prop, myVar->prop, MyClass::StaticProp, *myVar\n\t// Match any character except a set of characters which often break interesting sub-expressions\n\tlet expression: RegExp = /([^()\\[\\]{}<>\\s+\\-/%~#^;=|,`!]|\\->)+/g;\n\tlet result: RegExpExecArray | null = null;\n\n\t// First find the full expression under the cursor\n\twhile (result = expression.exec(lineContent)) {\n\t\tlet start = result.index + 1;\n\t\tlet end = start + result[0].length;\n\n\t\tif (start <= looseStart && end >= looseEnd) {\n\t\t\tmatchingExpression = result[0];\n\t\t\tstartOffset = start;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// If there are non-word characters after the cursor, we want to truncate the expression then.\n\t// For example in expression 'a.b.c.d', if the focus was under 'b', 'a.b' would be evaluated.\n\tif (matchingExpression) {\n\t\tlet subExpression: RegExp = /\\w+/g;\n\t\tlet subExpressionResult: RegExpExecArray | null = null;\n\t\twhile (subExpressionResult = subExpression.exec(matchingExpression)) {\n\t\t\tlet subEnd = subExpressionResult.index + 1 + startOffset + subExpressionResult[0].length;\n\t\t\tif (subEnd >= looseEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (subExpressionResult) {\n\t\t\tmatchingExpression = matchingExpression.substring(0, subExpression.lastIndex);\n\t\t}\n\t}\n\n\treturn matchingExpression ?\n\t\t{ start: startOffset, end: startOffset + matchingExpression.length - 1 } :\n\t\t{ start: 0, end: 0 };\n}\n\n// RFC 2396, Appendix A: https://www.ietf.org/rfc/rfc2396.txt\nconst _schemePattern = /^[a-zA-Z][a-zA-Z0-9\\+\\-\\.]+:/;\n\nexport function isUri(s: string | undefined): boolean {\n\t// heuristics: a valid uri starts with a scheme and\n\t// the scheme has at least 2 characters so that it doesn't look like a drive letter.\n\treturn !!(s && s.match(_schemePattern));\n}\n\nfunction stringToUri(path: string): string {\n\tif (typeof path === 'string') {\n\t\tif (isUri(path)) {\n\t\t\treturn <string><unknown>uri.parse(path);\n\t\t} else {\n\t\t\t// assume path\n\t\t\tif (isAbsolute(path)) {\n\t\t\t\treturn <string><unknown>uri.file(path);\n\t\t\t} else {\n\t\t\t\t// leave relative path as is\n\t\t\t}\n\t\t}\n\t}\n\treturn path;\n}\n\nfunction uriToString(path: string): string {\n\tif (typeof path === 'object') {\n\t\tconst u = uri.revive(path);\n\t\tif (u.scheme === 'file') {\n\t\t\treturn u.fsPath;\n\t\t} else {\n\t\t\treturn u.toString();\n\t\t}\n\t}\n\treturn path;\n}\n\n// path hooks helpers\n\ninterface PathContainer {\n\tpath?: string;\n}\n\nexport function convertToDAPaths(message: DebugProtocol.ProtocolMessage, toUri: boolean): DebugProtocol.ProtocolMessage {\n\n\tconst fixPath = toUri ? stringToUri : uriToString;\n\n\t// since we modify Source.paths in the message in place, we need to make a copy of it (see #61129)\n\tconst msg = deepClone(message);\n\n\tconvertPaths(msg, (toDA: boolean, source: PathContainer | undefined) => {\n\t\tif (toDA && source) {\n\t\t\tsource.path = source.path ? fixPath(source.path) : undefined;\n\t\t}\n\t});\n\treturn msg;\n}\n\nexport function convertToVSCPaths(message: DebugProtocol.ProtocolMessage, toUri: boolean): DebugProtocol.ProtocolMessage {\n\n\tconst fixPath = toUri ? stringToUri : uriToString;\n\n\t// since we modify Source.paths in the message in place, we need to make a copy of it (see #61129)\n\tconst msg = deepClone(message);\n\n\tconvertPaths(msg, (toDA: boolean, source: PathContainer | undefined) => {\n\t\tif (!toDA && source) {\n\t\t\tsource.path = source.path ? fixPath(source.path) : undefined;\n\t\t}\n\t});\n\treturn msg;\n}\n\nfunction convertPaths(msg: DebugProtocol.ProtocolMessage, fixSourcePath: (toDA: boolean, source: PathContainer | undefined) => void): void {\n\n\tswitch (msg.type) {\n\t\tcase 'event':\n\t\t\tconst event = <DebugProtocol.Event>msg;\n\t\t\tswitch (event.event) {\n\t\t\t\tcase 'output':\n\t\t\t\t\tfixSourcePath(false, (<DebugProtocol.OutputEvent>event).body.source);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'loadedSource':\n\t\t\t\t\tfixSourcePath(false, (<DebugProtocol.LoadedSourceEvent>event).body.source);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'breakpoint':\n\t\t\t\t\tfixSourcePath(false, (<DebugProtocol.BreakpointEvent>event).body.breakpoint.source);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'request':\n\t\t\tconst request = <DebugProtocol.Request>msg;\n\t\t\tswitch (request.command) {\n\t\t\t\tcase 'setBreakpoints':\n\t\t\t\t\tfixSourcePath(true, (<DebugProtocol.SetBreakpointsArguments>request.arguments).source);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'source':\n\t\t\t\t\tfixSourcePath(true, (<DebugProtocol.SourceArguments>request.arguments).source);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'gotoTargets':\n\t\t\t\t\tfixSourcePath(true, (<DebugProtocol.GotoTargetsArguments>request.arguments).source);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'launchVSCode':\n\t\t\t\t\trequest.arguments.args.forEach((arg: PathContainer | undefined) => fixSourcePath(false, arg));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'response':\n\t\t\tconst response = <DebugProtocol.Response>msg;\n\t\t\tif (response.success) {\n\t\t\t\tswitch (response.command) {\n\t\t\t\t\tcase 'stackTrace':\n\t\t\t\t\t\t(<DebugProtocol.StackTraceResponse>response).body.stackFrames.forEach(frame => fixSourcePath(false, frame.source));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'loadedSources':\n\t\t\t\t\t\t(<DebugProtocol.LoadedSourcesResponse>response).body.sources.forEach(source => fixSourcePath(false, source));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'scopes':\n\t\t\t\t\t\t(<DebugProtocol.ScopesResponse>response).body.scopes.forEach(scope => fixSourcePath(false, scope.source));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'setFunctionBreakpoints':\n\t\t\t\t\t\t(<DebugProtocol.SetFunctionBreakpointsResponse>response).body.breakpoints.forEach(bp => fixSourcePath(false, bp.source));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'setBreakpoints':\n\t\t\t\t\t\t(<DebugProtocol.SetBreakpointsResponse>response).body.breakpoints.forEach(bp => fixSourcePath(false, bp.source));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n}\n"]}]}