{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/node/ipc.net.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/node/ipc.net.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar net_1 = require(\"net\");\nvar event_1 = require(\"vs/base/common/event\");\nvar ipc_1 = require(\"vs/base/parts/ipc/common/ipc\");\nvar path_1 = require(\"vs/base/common/path\");\nvar os_1 = require(\"os\");\nvar uuid_1 = require(\"vs/base/common/uuid\");\nvar buffer_1 = require(\"vs/base/common/buffer\");\nvar ipc_net_1 = require(\"vs/base/parts/ipc/common/ipc.net\");\nvar NodeSocket = /** @class */ (function () {\n    function NodeSocket(socket) {\n        this.socket = socket;\n    }\n    NodeSocket.prototype.onData = function (_listener) {\n        var _this = this;\n        var listener = function (buff) { return _listener(buffer_1.VSBuffer.wrap(buff)); };\n        this.socket.on('data', listener);\n        return {\n            dispose: function () { return _this.socket.off('data', listener); }\n        };\n    };\n    NodeSocket.prototype.onClose = function (listener) {\n        var _this = this;\n        this.socket.on('close', listener);\n        return {\n            dispose: function () { return _this.socket.off('close', listener); }\n        };\n    };\n    NodeSocket.prototype.onEnd = function (listener) {\n        var _this = this;\n        this.socket.on('end', listener);\n        return {\n            dispose: function () { return _this.socket.off('end', listener); }\n        };\n    };\n    NodeSocket.prototype.write = function (buffer) {\n        // return early if socket has been destroyed in the meantime\n        if (this.socket.destroyed) {\n            return;\n        }\n        // we ignore the returned value from `write` because we would have to cached the data\n        // anyways and nodejs is already doing that for us:\n        // > https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback\n        // > However, the false return value is only advisory and the writable stream will unconditionally\n        // > accept and buffer chunk even if it has not not been allowed to drain.\n        this.socket.write(buffer.buffer);\n    };\n    NodeSocket.prototype.end = function () {\n        this.socket.end();\n    };\n    return NodeSocket;\n}());\nexports.NodeSocket = NodeSocket;\nfunction generateRandomPipeName() {\n    var randomSuffix = uuid_1.generateUuid();\n    if (process.platform === 'win32') {\n        return \"\\\\\\\\.\\\\pipe\\\\vscode-ipc-\" + randomSuffix + \"-sock\";\n    }\n    else {\n        // Mac/Unix: use socket file\n        return path_1.join(os_1.tmpdir(), \"vscode-ipc-\" + randomSuffix + \".sock\");\n    }\n}\nexports.generateRandomPipeName = generateRandomPipeName;\nvar Server = /** @class */ (function (_super) {\n    tslib_1.__extends(Server, _super);\n    function Server(server) {\n        var _this = _super.call(this, Server.toClientConnectionEvent(server)) || this;\n        _this.server = server;\n        return _this;\n    }\n    Server.toClientConnectionEvent = function (server) {\n        var onConnection = event_1.Event.fromNodeEventEmitter(server, 'connection');\n        return event_1.Event.map(onConnection, function (socket) { return ({\n            protocol: new ipc_net_1.Protocol(new NodeSocket(socket)),\n            onDidClientDisconnect: event_1.Event.once(event_1.Event.fromNodeEventEmitter(socket, 'close'))\n        }); });\n    };\n    Server.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        if (this.server) {\n            this.server.close();\n            this.server = null;\n        }\n    };\n    return Server;\n}(ipc_1.IPCServer));\nexports.Server = Server;\nfunction serve(hook) {\n    return new Promise(function (c, e) {\n        var server = net_1.createServer();\n        server.on('error', e);\n        server.listen(hook, function () {\n            server.removeListener('error', e);\n            c(new Server(server));\n        });\n    });\n}\nexports.serve = serve;\nfunction connect(hook, clientId) {\n    return new Promise(function (c, e) {\n        var socket = net_1.createConnection(hook, function () {\n            socket.removeListener('error', e);\n            c(ipc_net_1.Client.fromSocket(new NodeSocket(socket), clientId));\n        });\n        socket.once('error', e);\n    });\n}\nexports.connect = connect;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/node/ipc.net.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/node/ipc.net.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Socket, Server as NetServer, createConnection, createServer } from 'net';\nimport { Event } from 'vs/base/common/event';\nimport { ClientConnectionEvent, IPCServer } from 'vs/base/parts/ipc/common/ipc';\nimport { join } from 'vs/base/common/path';\nimport { tmpdir } from 'os';\nimport { generateUuid } from 'vs/base/common/uuid';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { ISocket, Protocol, Client } from 'vs/base/parts/ipc/common/ipc.net';\n\nexport class NodeSocket implements ISocket {\n\tpublic readonly socket: Socket;\n\n\tconstructor(socket: Socket) {\n\t\tthis.socket = socket;\n\t}\n\n\tpublic onData(_listener: (e: VSBuffer) => void): IDisposable {\n\t\tconst listener = (buff: Buffer) => _listener(VSBuffer.wrap(buff));\n\t\tthis.socket.on('data', listener);\n\t\treturn {\n\t\t\tdispose: () => this.socket.off('data', listener)\n\t\t};\n\t}\n\n\tpublic onClose(listener: () => void): IDisposable {\n\t\tthis.socket.on('close', listener);\n\t\treturn {\n\t\t\tdispose: () => this.socket.off('close', listener)\n\t\t};\n\t}\n\n\tpublic onEnd(listener: () => void): IDisposable {\n\t\tthis.socket.on('end', listener);\n\t\treturn {\n\t\t\tdispose: () => this.socket.off('end', listener)\n\t\t};\n\t}\n\n\tpublic write(buffer: VSBuffer): void {\n\t\t// return early if socket has been destroyed in the meantime\n\t\tif (this.socket.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// we ignore the returned value from `write` because we would have to cached the data\n\t\t// anyways and nodejs is already doing that for us:\n\t\t// > https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback\n\t\t// > However, the false return value is only advisory and the writable stream will unconditionally\n\t\t// > accept and buffer chunk even if it has not not been allowed to drain.\n\t\tthis.socket.write(<Buffer>buffer.buffer);\n\t}\n\n\tpublic end(): void {\n\t\tthis.socket.end();\n\t}\n}\n\nexport function generateRandomPipeName(): string {\n\tconst randomSuffix = generateUuid();\n\tif (process.platform === 'win32') {\n\t\treturn `\\\\\\\\.\\\\pipe\\\\vscode-ipc-${randomSuffix}-sock`;\n\t} else {\n\t\t// Mac/Unix: use socket file\n\t\treturn join(tmpdir(), `vscode-ipc-${randomSuffix}.sock`);\n\t}\n}\n\nexport class Server extends IPCServer {\n\n\tprivate static toClientConnectionEvent(server: NetServer): Event<ClientConnectionEvent> {\n\t\tconst onConnection = Event.fromNodeEventEmitter<Socket>(server, 'connection');\n\n\t\treturn Event.map(onConnection, socket => ({\n\t\t\tprotocol: new Protocol(new NodeSocket(socket)),\n\t\t\tonDidClientDisconnect: Event.once(Event.fromNodeEventEmitter<void>(socket, 'close'))\n\t\t}));\n\t}\n\n\tprivate server: NetServer | null;\n\n\tconstructor(server: NetServer) {\n\t\tsuper(Server.toClientConnectionEvent(server));\n\t\tthis.server = server;\n\t}\n\n\tdispose(): void {\n\t\tsuper.dispose();\n\t\tif (this.server) {\n\t\t\tthis.server.close();\n\t\t\tthis.server = null;\n\t\t}\n\t}\n}\n\nexport function serve(port: number): Promise<Server>;\nexport function serve(namedPipe: string): Promise<Server>;\nexport function serve(hook: any): Promise<Server> {\n\treturn new Promise<Server>((c, e) => {\n\t\tconst server = createServer();\n\n\t\tserver.on('error', e);\n\t\tserver.listen(hook, () => {\n\t\t\tserver.removeListener('error', e);\n\t\t\tc(new Server(server));\n\t\t});\n\t});\n}\n\nexport function connect(options: { host: string, port: number }, clientId: string): Promise<Client>;\nexport function connect(port: number, clientId: string): Promise<Client>;\nexport function connect(namedPipe: string, clientId: string): Promise<Client>;\nexport function connect(hook: any, clientId: string): Promise<Client> {\n\treturn new Promise<Client>((c, e) => {\n\t\tconst socket = createConnection(hook, () => {\n\t\t\tsocket.removeListener('error', e);\n\t\t\tc(Client.fromSocket(new NodeSocket(socket), clientId));\n\t\t});\n\n\t\tsocket.once('error', e);\n\t});\n}\n"]}]}