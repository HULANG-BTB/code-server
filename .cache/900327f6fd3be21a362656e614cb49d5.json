{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/view/minimapCharRenderer.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/view/minimapCharRenderer.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/event\", \"vs/editor/common/core/rgba\", \"vs/editor/common/modes\"], function (require, exports, event_1, rgba_1, modes_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class MinimapTokensColorTracker {\n        constructor() {\n            this._onDidChange = new event_1.Emitter();\n            this.onDidChange = this._onDidChange.event;\n            this._updateColorMap();\n            modes_1.TokenizationRegistry.onDidChange((e) => {\n                if (e.changedColorMap) {\n                    this._updateColorMap();\n                }\n            });\n        }\n        static getInstance() {\n            if (!this._INSTANCE) {\n                this._INSTANCE = new MinimapTokensColorTracker();\n            }\n            return this._INSTANCE;\n        }\n        _updateColorMap() {\n            const colorMap = modes_1.TokenizationRegistry.getColorMap();\n            if (!colorMap) {\n                this._colors = [rgba_1.RGBA8.Empty];\n                this._backgroundIsLight = true;\n                return;\n            }\n            this._colors = [rgba_1.RGBA8.Empty];\n            for (let colorId = 1; colorId < colorMap.length; colorId++) {\n                const source = colorMap[colorId].rgba;\n                // Use a VM friendly data-type\n                this._colors[colorId] = new rgba_1.RGBA8(source.r, source.g, source.b, Math.round(source.a * 255));\n            }\n            let backgroundLuminosity = colorMap[modes_1.ColorId.DefaultBackground].getRelativeLuminance();\n            this._backgroundIsLight = (backgroundLuminosity >= 0.5);\n            this._onDidChange.fire(undefined);\n        }\n        getColor(colorId) {\n            if (colorId < 1 || colorId >= this._colors.length) {\n                // background color (basically invisible)\n                colorId = modes_1.ColorId.DefaultBackground;\n            }\n            return this._colors[colorId];\n        }\n        backgroundIsLight() {\n            return this._backgroundIsLight;\n        }\n    }\n    MinimapTokensColorTracker._INSTANCE = null;\n    exports.MinimapTokensColorTracker = MinimapTokensColorTracker;\n    var Constants;\n    (function (Constants) {\n        Constants[Constants[\"START_CH_CODE\"] = 32] = \"START_CH_CODE\";\n        Constants[Constants[\"END_CH_CODE\"] = 126] = \"END_CH_CODE\";\n        Constants[Constants[\"CHAR_COUNT\"] = 95] = \"CHAR_COUNT\";\n        Constants[Constants[\"SAMPLED_CHAR_HEIGHT\"] = 16] = \"SAMPLED_CHAR_HEIGHT\";\n        Constants[Constants[\"SAMPLED_CHAR_WIDTH\"] = 10] = \"SAMPLED_CHAR_WIDTH\";\n        Constants[Constants[\"SAMPLED_HALF_CHAR_WIDTH\"] = 5] = \"SAMPLED_HALF_CHAR_WIDTH\";\n        Constants[Constants[\"x2_CHAR_HEIGHT\"] = 4] = \"x2_CHAR_HEIGHT\";\n        Constants[Constants[\"x2_CHAR_WIDTH\"] = 2] = \"x2_CHAR_WIDTH\";\n        Constants[Constants[\"x1_CHAR_HEIGHT\"] = 2] = \"x1_CHAR_HEIGHT\";\n        Constants[Constants[\"x1_CHAR_WIDTH\"] = 1] = \"x1_CHAR_WIDTH\";\n        Constants[Constants[\"RGBA_CHANNELS_CNT\"] = 4] = \"RGBA_CHANNELS_CNT\";\n    })(Constants = exports.Constants || (exports.Constants = {}));\n    class MinimapCharRenderer {\n        constructor(x2CharData, x1CharData) {\n            const x2ExpectedLen = Constants.x2_CHAR_HEIGHT * Constants.x2_CHAR_WIDTH * Constants.CHAR_COUNT;\n            if (x2CharData.length !== x2ExpectedLen) {\n                throw new Error('Invalid x2CharData');\n            }\n            const x1ExpectedLen = Constants.x1_CHAR_HEIGHT * Constants.x1_CHAR_WIDTH * Constants.CHAR_COUNT;\n            if (x1CharData.length !== x1ExpectedLen) {\n                throw new Error('Invalid x1CharData');\n            }\n            this.x2charData = x2CharData;\n            this.x1charData = x1CharData;\n            this.x2charDataLight = MinimapCharRenderer.soften(x2CharData, 12 / 15);\n            this.x1charDataLight = MinimapCharRenderer.soften(x1CharData, 50 / 60);\n        }\n        static soften(input, ratio) {\n            let result = new Uint8ClampedArray(input.length);\n            for (let i = 0, len = input.length; i < len; i++) {\n                result[i] = input[i] * ratio;\n            }\n            return result;\n        }\n        static _getChIndex(chCode) {\n            chCode -= Constants.START_CH_CODE;\n            if (chCode < 0) {\n                chCode += Constants.CHAR_COUNT;\n            }\n            return (chCode % Constants.CHAR_COUNT);\n        }\n        x2RenderChar(target, dx, dy, chCode, color, backgroundColor, useLighterFont) {\n            if (dx + Constants.x2_CHAR_WIDTH > target.width || dy + Constants.x2_CHAR_HEIGHT > target.height) {\n                console.warn('bad render request outside image data');\n                return;\n            }\n            const x2CharData = useLighterFont ? this.x2charDataLight : this.x2charData;\n            const chIndex = MinimapCharRenderer._getChIndex(chCode);\n            const outWidth = target.width * Constants.RGBA_CHANNELS_CNT;\n            const backgroundR = backgroundColor.r;\n            const backgroundG = backgroundColor.g;\n            const backgroundB = backgroundColor.b;\n            const deltaR = color.r - backgroundR;\n            const deltaG = color.g - backgroundG;\n            const deltaB = color.b - backgroundB;\n            const dest = target.data;\n            const sourceOffset = chIndex * Constants.x2_CHAR_HEIGHT * Constants.x2_CHAR_WIDTH;\n            let destOffset = dy * outWidth + dx * Constants.RGBA_CHANNELS_CNT;\n            {\n                const c = x2CharData[sourceOffset] / 255;\n                dest[destOffset + 0] = backgroundR + deltaR * c;\n                dest[destOffset + 1] = backgroundG + deltaG * c;\n                dest[destOffset + 2] = backgroundB + deltaB * c;\n            }\n            {\n                const c = x2CharData[sourceOffset + 1] / 255;\n                dest[destOffset + 4] = backgroundR + deltaR * c;\n                dest[destOffset + 5] = backgroundG + deltaG * c;\n                dest[destOffset + 6] = backgroundB + deltaB * c;\n            }\n            destOffset += outWidth;\n            {\n                const c = x2CharData[sourceOffset + 2] / 255;\n                dest[destOffset + 0] = backgroundR + deltaR * c;\n                dest[destOffset + 1] = backgroundG + deltaG * c;\n                dest[destOffset + 2] = backgroundB + deltaB * c;\n            }\n            {\n                const c = x2CharData[sourceOffset + 3] / 255;\n                dest[destOffset + 4] = backgroundR + deltaR * c;\n                dest[destOffset + 5] = backgroundG + deltaG * c;\n                dest[destOffset + 6] = backgroundB + deltaB * c;\n            }\n            destOffset += outWidth;\n            {\n                const c = x2CharData[sourceOffset + 4] / 255;\n                dest[destOffset + 0] = backgroundR + deltaR * c;\n                dest[destOffset + 1] = backgroundG + deltaG * c;\n                dest[destOffset + 2] = backgroundB + deltaB * c;\n            }\n            {\n                const c = x2CharData[sourceOffset + 5] / 255;\n                dest[destOffset + 4] = backgroundR + deltaR * c;\n                dest[destOffset + 5] = backgroundG + deltaG * c;\n                dest[destOffset + 6] = backgroundB + deltaB * c;\n            }\n            destOffset += outWidth;\n            {\n                const c = x2CharData[sourceOffset + 6] / 255;\n                dest[destOffset + 0] = backgroundR + deltaR * c;\n                dest[destOffset + 1] = backgroundG + deltaG * c;\n                dest[destOffset + 2] = backgroundB + deltaB * c;\n            }\n            {\n                const c = x2CharData[sourceOffset + 7] / 255;\n                dest[destOffset + 4] = backgroundR + deltaR * c;\n                dest[destOffset + 5] = backgroundG + deltaG * c;\n                dest[destOffset + 6] = backgroundB + deltaB * c;\n            }\n        }\n        x1RenderChar(target, dx, dy, chCode, color, backgroundColor, useLighterFont) {\n            if (dx + Constants.x1_CHAR_WIDTH > target.width || dy + Constants.x1_CHAR_HEIGHT > target.height) {\n                console.warn('bad render request outside image data');\n                return;\n            }\n            const x1CharData = useLighterFont ? this.x1charDataLight : this.x1charData;\n            const chIndex = MinimapCharRenderer._getChIndex(chCode);\n            const outWidth = target.width * Constants.RGBA_CHANNELS_CNT;\n            const backgroundR = backgroundColor.r;\n            const backgroundG = backgroundColor.g;\n            const backgroundB = backgroundColor.b;\n            const deltaR = color.r - backgroundR;\n            const deltaG = color.g - backgroundG;\n            const deltaB = color.b - backgroundB;\n            const dest = target.data;\n            const sourceOffset = chIndex * Constants.x1_CHAR_HEIGHT * Constants.x1_CHAR_WIDTH;\n            let destOffset = dy * outWidth + dx * Constants.RGBA_CHANNELS_CNT;\n            {\n                const c = x1CharData[sourceOffset] / 255;\n                dest[destOffset + 0] = backgroundR + deltaR * c;\n                dest[destOffset + 1] = backgroundG + deltaG * c;\n                dest[destOffset + 2] = backgroundB + deltaB * c;\n            }\n            destOffset += outWidth;\n            {\n                const c = x1CharData[sourceOffset + 1] / 255;\n                dest[destOffset + 0] = backgroundR + deltaR * c;\n                dest[destOffset + 1] = backgroundG + deltaG * c;\n                dest[destOffset + 2] = backgroundB + deltaB * c;\n            }\n        }\n        x2BlockRenderChar(target, dx, dy, color, backgroundColor, useLighterFont) {\n            if (dx + Constants.x2_CHAR_WIDTH > target.width || dy + Constants.x2_CHAR_HEIGHT > target.height) {\n                console.warn('bad render request outside image data');\n                return;\n            }\n            const outWidth = target.width * Constants.RGBA_CHANNELS_CNT;\n            const c = 0.5;\n            const backgroundR = backgroundColor.r;\n            const backgroundG = backgroundColor.g;\n            const backgroundB = backgroundColor.b;\n            const deltaR = color.r - backgroundR;\n            const deltaG = color.g - backgroundG;\n            const deltaB = color.b - backgroundB;\n            const colorR = backgroundR + deltaR * c;\n            const colorG = backgroundG + deltaG * c;\n            const colorB = backgroundB + deltaB * c;\n            const dest = target.data;\n            let destOffset = dy * outWidth + dx * Constants.RGBA_CHANNELS_CNT;\n            {\n                dest[destOffset + 0] = colorR;\n                dest[destOffset + 1] = colorG;\n                dest[destOffset + 2] = colorB;\n            }\n            {\n                dest[destOffset + 4] = colorR;\n                dest[destOffset + 5] = colorG;\n                dest[destOffset + 6] = colorB;\n            }\n            destOffset += outWidth;\n            {\n                dest[destOffset + 0] = colorR;\n                dest[destOffset + 1] = colorG;\n                dest[destOffset + 2] = colorB;\n            }\n            {\n                dest[destOffset + 4] = colorR;\n                dest[destOffset + 5] = colorG;\n                dest[destOffset + 6] = colorB;\n            }\n            destOffset += outWidth;\n            {\n                dest[destOffset + 0] = colorR;\n                dest[destOffset + 1] = colorG;\n                dest[destOffset + 2] = colorB;\n            }\n            {\n                dest[destOffset + 4] = colorR;\n                dest[destOffset + 5] = colorG;\n                dest[destOffset + 6] = colorB;\n            }\n            destOffset += outWidth;\n            {\n                dest[destOffset + 0] = colorR;\n                dest[destOffset + 1] = colorG;\n                dest[destOffset + 2] = colorB;\n            }\n            {\n                dest[destOffset + 4] = colorR;\n                dest[destOffset + 5] = colorG;\n                dest[destOffset + 6] = colorB;\n            }\n        }\n        x1BlockRenderChar(target, dx, dy, color, backgroundColor, useLighterFont) {\n            if (dx + Constants.x1_CHAR_WIDTH > target.width || dy + Constants.x1_CHAR_HEIGHT > target.height) {\n                console.warn('bad render request outside image data');\n                return;\n            }\n            const outWidth = target.width * Constants.RGBA_CHANNELS_CNT;\n            const c = 0.5;\n            const backgroundR = backgroundColor.r;\n            const backgroundG = backgroundColor.g;\n            const backgroundB = backgroundColor.b;\n            const deltaR = color.r - backgroundR;\n            const deltaG = color.g - backgroundG;\n            const deltaB = color.b - backgroundB;\n            const colorR = backgroundR + deltaR * c;\n            const colorG = backgroundG + deltaG * c;\n            const colorB = backgroundB + deltaB * c;\n            const dest = target.data;\n            let destOffset = dy * outWidth + dx * Constants.RGBA_CHANNELS_CNT;\n            {\n                dest[destOffset + 0] = colorR;\n                dest[destOffset + 1] = colorG;\n                dest[destOffset + 2] = colorB;\n            }\n            destOffset += outWidth;\n            {\n                dest[destOffset + 0] = colorR;\n                dest[destOffset + 1] = colorG;\n                dest[destOffset + 2] = colorB;\n            }\n        }\n    }\n    exports.MinimapCharRenderer = MinimapCharRenderer;\n});\n",null]}