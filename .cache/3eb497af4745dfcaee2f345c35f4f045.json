{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar strings = require(\"vs/base/common/strings\");\nvar model_1 = require(\"vs/editor/common/model\");\nvar pieceTreeBase_1 = require(\"vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase\");\nvar pieceTreeTextBuffer_1 = require(\"vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer\");\nvar PieceTreeTextBufferFactory = /** @class */ (function () {\n    function PieceTreeTextBufferFactory(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    PieceTreeTextBufferFactory.prototype._getEOL = function (defaultEOL) {\n        var totalEOLCount = this._cr + this._lf + this._crlf;\n        var totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === model_1.DefaultEndOfLine.LF ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    };\n    PieceTreeTextBufferFactory.prototype.create = function (defaultEOL) {\n        var eol = this._getEOL(defaultEOL);\n        var chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (var i = 0, len = chunks.length; i < len; i++) {\n                var str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                var newLineStart = pieceTreeBase_1.createLineStartsFast(str);\n                chunks[i] = new pieceTreeBase_1.StringBuffer(str, newLineStart);\n            }\n        }\n        return new pieceTreeTextBuffer_1.PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._isBasicASCII, this._normalizeEOL);\n    };\n    PieceTreeTextBufferFactory.prototype.getFirstLineText = function (lengthLimit) {\n        return this._chunks[0].buffer.substr(0, 100).split(/\\r\\n|\\r|\\n/)[0];\n    };\n    return PieceTreeTextBufferFactory;\n}());\nexports.PieceTreeTextBufferFactory = PieceTreeTextBufferFactory;\nvar PieceTreeTextBufferBuilder = /** @class */ (function () {\n    function PieceTreeTextBufferBuilder() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.isBasicASCII = true;\n    }\n    PieceTreeTextBufferBuilder.prototype.acceptChunk = function (chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        var lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === charCode_1.CharCode.CarriageReturn || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    };\n    PieceTreeTextBufferBuilder.prototype._acceptChunk1 = function (chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    };\n    PieceTreeTextBufferBuilder.prototype._acceptChunk2 = function (chunk) {\n        var lineStarts = pieceTreeBase_1.createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new pieceTreeBase_1.StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (this.isBasicASCII) {\n            this.isBasicASCII = lineStarts.isBasicASCII;\n        }\n        if (!this.isBasicASCII && !this.containsRTL) {\n            // No need to check if is basic ASCII\n            this.containsRTL = strings.containsRTL(chunk);\n        }\n    };\n    PieceTreeTextBufferBuilder.prototype.finish = function (normalizeEOL) {\n        if (normalizeEOL === void 0) { normalizeEOL = true; }\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.isBasicASCII, normalizeEOL);\n    };\n    PieceTreeTextBufferBuilder.prototype._finish = function () {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            var lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            var newLineStarts = pieceTreeBase_1.createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === charCode_1.CharCode.CarriageReturn) {\n                this.cr++;\n            }\n        }\n    };\n    return PieceTreeTextBufferBuilder;\n}());\nexports.PieceTreeTextBufferBuilder = PieceTreeTextBufferBuilder;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;AAEhG,oDAAmD;AACnD,gDAAkD;AAClD,gDAA+G;AAC/G,0FAAgI;AAChI,sGAAqG;AAErG;IAEC,oCACkB,OAAuB,EACvB,IAAY,EACZ,GAAW,EACX,GAAW,EACX,KAAa,EACb,YAAqB,EACrB,aAAsB,EACtB,aAAsB;QAPtB,YAAO,GAAP,OAAO,CAAgB;QACvB,SAAI,GAAJ,IAAI,CAAQ;QACZ,QAAG,GAAH,GAAG,CAAQ;QACX,QAAG,GAAH,GAAG,CAAQ;QACX,UAAK,GAAL,KAAK,CAAQ;QACb,iBAAY,GAAZ,YAAY,CAAS;QACrB,kBAAa,GAAb,aAAa,CAAS;QACtB,kBAAa,GAAb,aAAa,CAAS;IACpC,CAAC;IAEG,4CAAO,GAAf,UAAgB,UAA4B;QAC3C,IAAM,aAAa,GAAG,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC;QACvD,IAAM,YAAY,GAAG,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC;QAC3C,IAAI,aAAa,KAAK,CAAC,EAAE;YACxB,0DAA0D;YAC1D,OAAO,CAAC,UAAU,KAAK,wBAAgB,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;SAC5D;QACD,IAAI,YAAY,GAAG,aAAa,GAAG,CAAC,EAAE;YACrC,wDAAwD;YACxD,OAAO,MAAM,CAAC;SACd;QACD,oCAAoC;QACpC,OAAO,IAAI,CAAC;IACb,CAAC;IAEM,2CAAM,GAAb,UAAc,UAA4B;QACzC,IAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;QACrC,IAAI,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC;QAE1B,IAAI,IAAI,CAAC,aAAa;YACrB,CAAC,CAAC,GAAG,KAAK,MAAM,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;mBAC/C,CAAC,GAAG,KAAK,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,EACtD;YACD,mBAAmB;YACnB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;gBAClD,IAAI,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;gBACvD,IAAI,YAAY,GAAG,oCAAoB,CAAC,GAAG,CAAC,CAAC;gBAC7C,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,4BAAY,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;aAChD;SACD;QAED,OAAO,IAAI,yCAAmB,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;IACnH,CAAC;IAEM,qDAAgB,GAAvB,UAAwB,WAAmB;QAC1C,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;IACrE,CAAC;IACF,iCAAC;AAAD,CAAC,AAlDD,IAkDC;AAlDY,gEAA0B;AAoDvC;IAcC;QACC,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;QACjB,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;QAEd,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC;QAC9B,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;QACvB,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;QAEzB,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;QACZ,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;QACZ,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;QACd,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;QACzB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;IAC1B,CAAC;IAEM,gDAAW,GAAlB,UAAmB,KAAa;QAC/B,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;YACvB,OAAO;SACP;QAED,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;YAC7B,IAAI,OAAO,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAE;gBACrC,IAAI,CAAC,GAAG,GAAG,OAAO,CAAC,kBAAkB,CAAC;gBACtC,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;aACxB;SACD;QAED,IAAM,QAAQ,GAAG,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACpD,IAAI,QAAQ,KAAK,mBAAQ,CAAC,cAAc,IAAI,CAAC,QAAQ,IAAI,MAAM,IAAI,QAAQ,IAAI,MAAM,CAAC,EAAE;YACvF,2DAA2D;YAC3D,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;YAC7D,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC;YAC7B,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC;SAC9B;aAAM;YACN,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;YACjC,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC;YAC9B,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC;SAC9B;IACF,CAAC;IAEO,kDAAa,GAArB,UAAsB,KAAa,EAAE,iBAA0B;QAC9D,IAAI,CAAC,iBAAiB,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;YAC7C,gBAAgB;YAChB,OAAO;SACP;QAED,IAAI,IAAI,CAAC,gBAAgB,EAAE;YAC1B,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,KAAK,CAAC,CAAC;SACpE;aAAM;YACN,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;SAC1B;IACF,CAAC;IAEO,kDAAa,GAArB,UAAsB,KAAa;QAClC,IAAM,UAAU,GAAG,gCAAgB,CAAC,IAAI,CAAC,cAAc,EAAE,KAAK,CAAC,CAAC;QAEhE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,4BAAY,CAAC,KAAK,EAAE,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC;QACjE,IAAI,CAAC,EAAE,IAAI,UAAU,CAAC,EAAE,CAAC;QACzB,IAAI,CAAC,EAAE,IAAI,UAAU,CAAC,EAAE,CAAC;QACzB,IAAI,CAAC,IAAI,IAAI,UAAU,CAAC,IAAI,CAAC;QAE7B,IAAI,IAAI,CAAC,YAAY,EAAE;YACtB,IAAI,CAAC,YAAY,GAAG,UAAU,CAAC,YAAY,CAAC;SAC5C;QACD,IAAI,CAAC,IAAI,CAAC,YAAY,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YAC5C,qCAAqC;YACrC,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;SAC9C;IACF,CAAC;IAEM,2CAAM,GAAb,UAAc,YAA4B;QAA5B,6BAAA,EAAA,mBAA4B;QACzC,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,OAAO,IAAI,0BAA0B,CACpC,IAAI,CAAC,MAAM,EACX,IAAI,CAAC,GAAG,EACR,IAAI,CAAC,EAAE,EACP,IAAI,CAAC,EAAE,EACP,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,WAAW,EAChB,IAAI,CAAC,YAAY,EACjB,YAAY,CACZ,CAAC;IACH,CAAC;IAEO,4CAAO,GAAf;QACC,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;YAC7B,IAAI,CAAC,aAAa,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;SAC7B;QAED,IAAI,IAAI,CAAC,gBAAgB,EAAE;YAC1B,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC;YAC9B,sBAAsB;YACtB,IAAI,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YACpD,SAAS,CAAC,MAAM,IAAI,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;YAC5D,IAAI,aAAa,GAAG,oCAAoB,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;YAC3D,SAAS,CAAC,UAAU,GAAG,aAAa,CAAC;YACrC,IAAI,IAAI,CAAC,aAAa,KAAK,mBAAQ,CAAC,cAAc,EAAE;gBACnD,IAAI,CAAC,EAAE,EAAE,CAAC;aACV;SACD;IACF,CAAC;IACF,iCAAC;AAAD,CAAC,AAnHD,IAmHC;AAnHY,gEAA0B","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as strings from 'vs/base/common/strings';\nimport { DefaultEndOfLine, ITextBuffer, ITextBufferBuilder, ITextBufferFactory } from 'vs/editor/common/model';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from 'vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase';\nimport { PieceTreeTextBuffer } from 'vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer';\n\nexport class PieceTreeTextBufferFactory implements ITextBufferFactory {\n\n\tconstructor(\n\t\tprivate readonly _chunks: StringBuffer[],\n\t\tprivate readonly _bom: string,\n\t\tprivate readonly _cr: number,\n\t\tprivate readonly _lf: number,\n\t\tprivate readonly _crlf: number,\n\t\tprivate readonly _containsRTL: boolean,\n\t\tprivate readonly _isBasicASCII: boolean,\n\t\tprivate readonly _normalizeEOL: boolean\n\t) { }\n\n\tprivate _getEOL(defaultEOL: DefaultEndOfLine): '\\r\\n' | '\\n' {\n\t\tconst totalEOLCount = this._cr + this._lf + this._crlf;\n\t\tconst totalCRCount = this._cr + this._crlf;\n\t\tif (totalEOLCount === 0) {\n\t\t\t// This is an empty file or a file with precisely one line\n\t\t\treturn (defaultEOL === DefaultEndOfLine.LF ? '\\n' : '\\r\\n');\n\t\t}\n\t\tif (totalCRCount > totalEOLCount / 2) {\n\t\t\t// More than half of the file contains \\r\\n ending lines\n\t\t\treturn '\\r\\n';\n\t\t}\n\t\t// At least one line more ends in \\n\n\t\treturn '\\n';\n\t}\n\n\tpublic create(defaultEOL: DefaultEndOfLine): ITextBuffer {\n\t\tconst eol = this._getEOL(defaultEOL);\n\t\tlet chunks = this._chunks;\n\n\t\tif (this._normalizeEOL &&\n\t\t\t((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n\t\t\t\t|| (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))\n\t\t) {\n\t\t\t// Normalize pieces\n\t\t\tfor (let i = 0, len = chunks.length; i < len; i++) {\n\t\t\t\tlet str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\t\tlet newLineStart = createLineStartsFast(str);\n\t\t\t\tchunks[i] = new StringBuffer(str, newLineStart);\n\t\t\t}\n\t\t}\n\n\t\treturn new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._isBasicASCII, this._normalizeEOL);\n\t}\n\n\tpublic getFirstLineText(lengthLimit: number): string {\n\t\treturn this._chunks[0].buffer.substr(0, 100).split(/\\r\\n|\\r|\\n/)[0];\n\t}\n}\n\nexport class PieceTreeTextBufferBuilder implements ITextBufferBuilder {\n\tprivate readonly chunks: StringBuffer[];\n\tprivate BOM: string;\n\n\tprivate _hasPreviousChar: boolean;\n\tprivate _previousChar: number;\n\tprivate readonly _tmpLineStarts: number[];\n\n\tprivate cr: number;\n\tprivate lf: number;\n\tprivate crlf: number;\n\tprivate containsRTL: boolean;\n\tprivate isBasicASCII: boolean;\n\n\tconstructor() {\n\t\tthis.chunks = [];\n\t\tthis.BOM = '';\n\n\t\tthis._hasPreviousChar = false;\n\t\tthis._previousChar = 0;\n\t\tthis._tmpLineStarts = [];\n\n\t\tthis.cr = 0;\n\t\tthis.lf = 0;\n\t\tthis.crlf = 0;\n\t\tthis.containsRTL = false;\n\t\tthis.isBasicASCII = true;\n\t}\n\n\tpublic acceptChunk(chunk: string): void {\n\t\tif (chunk.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.chunks.length === 0) {\n\t\t\tif (strings.startsWithUTF8BOM(chunk)) {\n\t\t\t\tthis.BOM = strings.UTF8_BOM_CHARACTER;\n\t\t\t\tchunk = chunk.substr(1);\n\t\t\t}\n\t\t}\n\n\t\tconst lastChar = chunk.charCodeAt(chunk.length - 1);\n\t\tif (lastChar === CharCode.CarriageReturn || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n\t\t\t// last character is \\r or a high surrogate => keep it back\n\t\t\tthis._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n\t\t\tthis._hasPreviousChar = true;\n\t\t\tthis._previousChar = lastChar;\n\t\t} else {\n\t\t\tthis._acceptChunk1(chunk, false);\n\t\t\tthis._hasPreviousChar = false;\n\t\t\tthis._previousChar = lastChar;\n\t\t}\n\t}\n\n\tprivate _acceptChunk1(chunk: string, allowEmptyStrings: boolean): void {\n\t\tif (!allowEmptyStrings && chunk.length === 0) {\n\t\t\t// Nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._hasPreviousChar) {\n\t\t\tthis._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n\t\t} else {\n\t\t\tthis._acceptChunk2(chunk);\n\t\t}\n\t}\n\n\tprivate _acceptChunk2(chunk: string): void {\n\t\tconst lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n\n\t\tthis.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n\t\tthis.cr += lineStarts.cr;\n\t\tthis.lf += lineStarts.lf;\n\t\tthis.crlf += lineStarts.crlf;\n\n\t\tif (this.isBasicASCII) {\n\t\t\tthis.isBasicASCII = lineStarts.isBasicASCII;\n\t\t}\n\t\tif (!this.isBasicASCII && !this.containsRTL) {\n\t\t\t// No need to check if is basic ASCII\n\t\t\tthis.containsRTL = strings.containsRTL(chunk);\n\t\t}\n\t}\n\n\tpublic finish(normalizeEOL: boolean = true): PieceTreeTextBufferFactory {\n\t\tthis._finish();\n\t\treturn new PieceTreeTextBufferFactory(\n\t\t\tthis.chunks,\n\t\t\tthis.BOM,\n\t\t\tthis.cr,\n\t\t\tthis.lf,\n\t\t\tthis.crlf,\n\t\t\tthis.containsRTL,\n\t\t\tthis.isBasicASCII,\n\t\t\tnormalizeEOL\n\t\t);\n\t}\n\n\tprivate _finish(): void {\n\t\tif (this.chunks.length === 0) {\n\t\t\tthis._acceptChunk1('', true);\n\t\t}\n\n\t\tif (this._hasPreviousChar) {\n\t\t\tthis._hasPreviousChar = false;\n\t\t\t// recreate last chunk\n\t\t\tlet lastChunk = this.chunks[this.chunks.length - 1];\n\t\t\tlastChunk.buffer += String.fromCharCode(this._previousChar);\n\t\t\tlet newLineStarts = createLineStartsFast(lastChunk.buffer);\n\t\t\tlastChunk.lineStarts = newLineStarts;\n\t\t\tif (this._previousChar === CharCode.CarriageReturn) {\n\t\t\t\tthis.cr++;\n\t\t\t}\n\t\t}\n\t}\n}\n"]}]}