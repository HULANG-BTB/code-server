{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/node/extensionPoints.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/node/extensionPoints.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar nls = require(\"vs/nls\");\nvar path = require(\"vs/base/common/path\");\nvar semver = require(\"semver\");\nvar json = require(\"vs/base/common/json\");\nvar arrays = require(\"vs/base/common/arrays\");\nvar jsonErrorMessages_1 = require(\"vs/base/common/jsonErrorMessages\");\nvar types = require(\"vs/base/common/types\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar pfs = require(\"vs/base/node/pfs\");\nvar extensionManagementUtil_1 = require(\"vs/platform/extensionManagement/common/extensionManagementUtil\");\nvar extensionValidator_1 = require(\"vs/platform/extensions/node/extensionValidator\");\nvar extensions_1 = require(\"vs/platform/extensions/common/extensions\");\nvar MANIFEST_FILE = 'package.json';\nvar Translations;\n(function (Translations) {\n    function equals(a, b) {\n        if (a === b) {\n            return true;\n        }\n        var aKeys = Object.keys(a);\n        var bKeys = new Set();\n        for (var _i = 0, _a = Object.keys(b); _i < _a.length; _i++) {\n            var key = _a[_i];\n            bKeys.add(key);\n        }\n        if (aKeys.length !== bKeys.size) {\n            return false;\n        }\n        for (var _b = 0, aKeys_1 = aKeys; _b < aKeys_1.length; _b++) {\n            var key = aKeys_1[_b];\n            if (a[key] !== b[key]) {\n                return false;\n            }\n            bKeys.delete(key);\n        }\n        return bKeys.size === 0;\n    }\n    Translations.equals = equals;\n})(Translations || (Translations = {}));\nvar ExtensionManifestHandler = /** @class */ (function () {\n    function ExtensionManifestHandler(ourVersion, log, absoluteFolderPath, isBuiltin, isUnderDevelopment) {\n        this._ourVersion = ourVersion;\n        this._log = log;\n        this._absoluteFolderPath = absoluteFolderPath;\n        this._isBuiltin = isBuiltin;\n        this._isUnderDevelopment = isUnderDevelopment;\n        this._absoluteManifestPath = path.join(absoluteFolderPath, MANIFEST_FILE);\n    }\n    return ExtensionManifestHandler;\n}());\nvar ExtensionManifestParser = /** @class */ (function (_super) {\n    tslib_1.__extends(ExtensionManifestParser, _super);\n    function ExtensionManifestParser() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ExtensionManifestParser.prototype.parse = function () {\n        var _this = this;\n        return pfs.readFile(this._absoluteManifestPath).then(function (manifestContents) {\n            try {\n                var manifest = JSON.parse(manifestContents.toString());\n                if (manifest.__metadata) {\n                    manifest.uuid = manifest.__metadata.id;\n                }\n                delete manifest.__metadata;\n                return manifest;\n            }\n            catch (e) {\n                _this._log.error(_this._absoluteFolderPath, nls.localize('jsonParseFail', \"Failed to parse {0}: {1}.\", _this._absoluteManifestPath, jsonErrorMessages_1.getParseErrorMessage(e.message)));\n            }\n            return null;\n        }, function (err) {\n            if (err.code === 'ENOENT') {\n                return null;\n            }\n            _this._log.error(_this._absoluteFolderPath, nls.localize('fileReadFail', \"Cannot read file {0}: {1}.\", _this._absoluteManifestPath, err.message));\n            return null;\n        });\n    };\n    return ExtensionManifestParser;\n}(ExtensionManifestHandler));\nvar ExtensionManifestNLSReplacer = /** @class */ (function (_super) {\n    tslib_1.__extends(ExtensionManifestNLSReplacer, _super);\n    function ExtensionManifestNLSReplacer(ourVersion, log, absoluteFolderPath, isBuiltin, isUnderDevelopment, nlsConfig) {\n        var _this = _super.call(this, ourVersion, log, absoluteFolderPath, isBuiltin, isUnderDevelopment) || this;\n        _this._nlsConfig = nlsConfig;\n        return _this;\n    }\n    ExtensionManifestNLSReplacer.prototype.replaceNLS = function (extensionDescription) {\n        var _this = this;\n        var reportErrors = function (localized, errors) {\n            errors.forEach(function (error) {\n                _this._log.error(_this._absoluteFolderPath, nls.localize('jsonsParseReportErrors', \"Failed to parse {0}: {1}.\", localized, jsonErrorMessages_1.getParseErrorMessage(error.error)));\n            });\n        };\n        var extension = path.extname(this._absoluteManifestPath);\n        var basename = this._absoluteManifestPath.substr(0, this._absoluteManifestPath.length - extension.length);\n        var translationId = extensionDescription.publisher + \".\" + extensionDescription.name;\n        var translationPath = this._nlsConfig.translations[translationId];\n        var localizedMessages;\n        if (translationPath) {\n            localizedMessages = pfs.readFile(translationPath, 'utf8').then(function (content) {\n                var errors = [];\n                var translationBundle = json.parse(content, errors);\n                if (errors.length > 0) {\n                    reportErrors(translationPath, errors);\n                    return { values: undefined, default: basename + \".nls.json\" };\n                }\n                else {\n                    var values = translationBundle.contents ? translationBundle.contents.package : undefined;\n                    return { values: values, default: basename + \".nls.json\" };\n                }\n            }, function (error) {\n                return { values: undefined, default: basename + \".nls.json\" };\n            });\n        }\n        else {\n            localizedMessages = pfs.fileExists(basename + '.nls' + extension).then(function (exists) {\n                if (!exists) {\n                    return undefined;\n                }\n                return ExtensionManifestNLSReplacer.findMessageBundles(_this._nlsConfig, basename).then(function (messageBundle) {\n                    if (!messageBundle.localized) {\n                        return { values: undefined, default: messageBundle.original };\n                    }\n                    return pfs.readFile(messageBundle.localized, 'utf8').then(function (messageBundleContent) {\n                        var errors = [];\n                        var messages = json.parse(messageBundleContent, errors);\n                        if (errors.length > 0) {\n                            reportErrors(messageBundle.localized, errors);\n                            return { values: undefined, default: messageBundle.original };\n                        }\n                        return { values: messages, default: messageBundle.original };\n                    }, function (err) {\n                        return { values: undefined, default: messageBundle.original };\n                    });\n                }, function (err) {\n                    return undefined;\n                });\n            });\n        }\n        return localizedMessages.then(function (localizedMessages) {\n            if (localizedMessages === undefined) {\n                return extensionDescription;\n            }\n            var errors = [];\n            // resolveOriginalMessageBundle returns null if localizedMessages.default === undefined;\n            return ExtensionManifestNLSReplacer.resolveOriginalMessageBundle(localizedMessages.default, errors).then(function (defaults) {\n                if (errors.length > 0) {\n                    reportErrors(localizedMessages.default, errors);\n                    return extensionDescription;\n                }\n                var localized = localizedMessages.values || Object.create(null);\n                ExtensionManifestNLSReplacer._replaceNLStrings(_this._nlsConfig, extensionDescription, localized, defaults, _this._log, _this._absoluteFolderPath);\n                return extensionDescription;\n            });\n        }, function (err) {\n            return extensionDescription;\n        });\n    };\n    /**\n     * Parses original message bundle, returns null if the original message bundle is null.\n     */\n    ExtensionManifestNLSReplacer.resolveOriginalMessageBundle = function (originalMessageBundle, errors) {\n        return new Promise(function (c, e) {\n            if (originalMessageBundle) {\n                pfs.readFile(originalMessageBundle).then(function (originalBundleContent) {\n                    c(json.parse(originalBundleContent.toString(), errors));\n                }, function (err) {\n                    c(null);\n                });\n            }\n            else {\n                c(null);\n            }\n        });\n    };\n    /**\n     * Finds localized message bundle and the original (unlocalized) one.\n     * If the localized file is not present, returns null for the original and marks original as localized.\n     */\n    ExtensionManifestNLSReplacer.findMessageBundles = function (nlsConfig, basename) {\n        return new Promise(function (c, e) {\n            function loop(basename, locale) {\n                var toCheck = basename + \".nls.\" + locale + \".json\";\n                pfs.fileExists(toCheck).then(function (exists) {\n                    if (exists) {\n                        c({ localized: toCheck, original: basename + \".nls.json\" });\n                    }\n                    var index = locale.lastIndexOf('-');\n                    if (index === -1) {\n                        c({ localized: basename + \".nls.json\", original: null });\n                    }\n                    else {\n                        locale = locale.substring(0, index);\n                        loop(basename, locale);\n                    }\n                });\n            }\n            if (nlsConfig.devMode || nlsConfig.pseudo || !nlsConfig.locale) {\n                return c({ localized: basename + '.nls.json', original: null });\n            }\n            loop(basename, nlsConfig.locale);\n        });\n    };\n    /**\n     * This routine makes the following assumptions:\n     * The root element is an object literal\n     */\n    ExtensionManifestNLSReplacer._replaceNLStrings = function (nlsConfig, literal, messages, originalMessages, log, messageScope) {\n        function processEntry(obj, key, command) {\n            var value = obj[key];\n            if (types.isString(value)) {\n                var str = value;\n                var length = str.length;\n                if (length > 1 && str[0] === '%' && str[length - 1] === '%') {\n                    var messageKey = str.substr(1, length - 2);\n                    var message = messages[messageKey];\n                    // If the messages come from a language pack they might miss some keys\n                    // Fill them from the original messages.\n                    if (message === undefined && originalMessages) {\n                        message = originalMessages[messageKey];\n                    }\n                    if (message) {\n                        if (nlsConfig.pseudo) {\n                            // FF3B and FF3D is the Unicode zenkaku representation for [ and ]\n                            message = '\\uFF3B' + message.replace(/[aouei]/g, '$&$&') + '\\uFF3D';\n                        }\n                        obj[key] = command && (key === 'title' || key === 'category') && originalMessages ? { value: message, original: originalMessages[messageKey] } : message;\n                    }\n                    else {\n                        log.warn(messageScope, nls.localize('missingNLSKey', \"Couldn't find message for key {0}.\", messageKey));\n                    }\n                }\n            }\n            else if (types.isObject(value)) {\n                for (var k in value) {\n                    if (value.hasOwnProperty(k)) {\n                        k === 'commands' ? processEntry(value, k, true) : processEntry(value, k, command);\n                    }\n                }\n            }\n            else if (types.isArray(value)) {\n                for (var i = 0; i < value.length; i++) {\n                    processEntry(value, i, command);\n                }\n            }\n        }\n        for (var key in literal) {\n            if (literal.hasOwnProperty(key)) {\n                processEntry(literal, key);\n            }\n        }\n    };\n    return ExtensionManifestNLSReplacer;\n}(ExtensionManifestHandler));\nvar ExtensionManifestValidator = /** @class */ (function (_super) {\n    tslib_1.__extends(ExtensionManifestValidator, _super);\n    function ExtensionManifestValidator() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ExtensionManifestValidator.prototype.validate = function (_extensionDescription) {\n        var _this = this;\n        var extensionDescription = _extensionDescription;\n        extensionDescription.isBuiltin = this._isBuiltin;\n        extensionDescription.isUnderDevelopment = this._isUnderDevelopment;\n        var notices = [];\n        if (!ExtensionManifestValidator.isValidExtensionDescription(this._ourVersion, this._absoluteFolderPath, extensionDescription, notices)) {\n            notices.forEach(function (error) {\n                _this._log.error(_this._absoluteFolderPath, error);\n            });\n            return null;\n        }\n        // in this case the notices are warnings\n        notices.forEach(function (error) {\n            _this._log.warn(_this._absoluteFolderPath, error);\n        });\n        // allow publisher to be undefined to make the initial extension authoring experience smoother\n        if (!extensionDescription.publisher) {\n            extensionDescription.publisher = 'undefined_publisher';\n        }\n        // id := `publisher.name`\n        extensionDescription.id = extensionDescription.publisher + \".\" + extensionDescription.name;\n        extensionDescription.identifier = new extensions_1.ExtensionIdentifier(extensionDescription.id);\n        // main := absolutePath(`main`)\n        if (extensionDescription.main) {\n            extensionDescription.main = path.join(this._absoluteFolderPath, extensionDescription.main);\n        }\n        extensionDescription.extensionLocation = uri_1.URI.file(this._absoluteFolderPath);\n        return extensionDescription;\n    };\n    ExtensionManifestValidator.isValidExtensionDescription = function (version, extensionFolderPath, extensionDescription, notices) {\n        if (!ExtensionManifestValidator.baseIsValidExtensionDescription(extensionFolderPath, extensionDescription, notices)) {\n            return false;\n        }\n        if (!semver.valid(extensionDescription.version)) {\n            notices.push(nls.localize('notSemver', \"Extension version is not semver compatible.\"));\n            return false;\n        }\n        return extensionValidator_1.isValidExtensionVersion(version, extensionDescription, notices);\n    };\n    ExtensionManifestValidator.baseIsValidExtensionDescription = function (extensionFolderPath, extensionDescription, notices) {\n        if (!extensionDescription) {\n            notices.push(nls.localize('extensionDescription.empty', \"Got empty extension description\"));\n            return false;\n        }\n        if (typeof extensionDescription.publisher !== 'undefined' && typeof extensionDescription.publisher !== 'string') {\n            notices.push(nls.localize('extensionDescription.publisher', \"property publisher must be of type `string`.\"));\n            return false;\n        }\n        if (typeof extensionDescription.name !== 'string') {\n            notices.push(nls.localize('extensionDescription.name', \"property `{0}` is mandatory and must be of type `string`\", 'name'));\n            return false;\n        }\n        if (typeof extensionDescription.version !== 'string') {\n            notices.push(nls.localize('extensionDescription.version', \"property `{0}` is mandatory and must be of type `string`\", 'version'));\n            return false;\n        }\n        if (!extensionDescription.engines) {\n            notices.push(nls.localize('extensionDescription.engines', \"property `{0}` is mandatory and must be of type `object`\", 'engines'));\n            return false;\n        }\n        if (typeof extensionDescription.engines.vscode !== 'string') {\n            notices.push(nls.localize('extensionDescription.engines.vscode', \"property `{0}` is mandatory and must be of type `string`\", 'engines.vscode'));\n            return false;\n        }\n        if (typeof extensionDescription.extensionDependencies !== 'undefined') {\n            if (!ExtensionManifestValidator._isStringArray(extensionDescription.extensionDependencies)) {\n                notices.push(nls.localize('extensionDescription.extensionDependencies', \"property `{0}` can be omitted or must be of type `string[]`\", 'extensionDependencies'));\n                return false;\n            }\n        }\n        if (typeof extensionDescription.activationEvents !== 'undefined') {\n            if (!ExtensionManifestValidator._isStringArray(extensionDescription.activationEvents)) {\n                notices.push(nls.localize('extensionDescription.activationEvents1', \"property `{0}` can be omitted or must be of type `string[]`\", 'activationEvents'));\n                return false;\n            }\n            if (typeof extensionDescription.main === 'undefined') {\n                notices.push(nls.localize('extensionDescription.activationEvents2', \"properties `{0}` and `{1}` must both be specified or must both be omitted\", 'activationEvents', 'main'));\n                return false;\n            }\n        }\n        if (typeof extensionDescription.main !== 'undefined') {\n            if (typeof extensionDescription.main !== 'string') {\n                notices.push(nls.localize('extensionDescription.main1', \"property `{0}` can be omitted or must be of type `string`\", 'main'));\n                return false;\n            }\n            else {\n                var normalizedAbsolutePath = path.join(extensionFolderPath, extensionDescription.main);\n                if (normalizedAbsolutePath.indexOf(extensionFolderPath)) {\n                    notices.push(nls.localize('extensionDescription.main2', \"Expected `main` ({0}) to be included inside extension's folder ({1}). This might make the extension non-portable.\", normalizedAbsolutePath, extensionFolderPath));\n                    // not a failure case\n                }\n            }\n            if (typeof extensionDescription.activationEvents === 'undefined') {\n                notices.push(nls.localize('extensionDescription.main3', \"properties `{0}` and `{1}` must both be specified or must both be omitted\", 'activationEvents', 'main'));\n                return false;\n            }\n        }\n        return true;\n    };\n    ExtensionManifestValidator._isStringArray = function (arr) {\n        if (!Array.isArray(arr)) {\n            return false;\n        }\n        for (var i = 0, len = arr.length; i < len; i++) {\n            if (typeof arr[i] !== 'string') {\n                return false;\n            }\n        }\n        return true;\n    };\n    return ExtensionManifestValidator;\n}(ExtensionManifestHandler));\nvar ExtensionScannerInput = /** @class */ (function () {\n    function ExtensionScannerInput(ourVersion, commit, locale, devMode, absoluteFolderPath, isBuiltin, isUnderDevelopment, tanslations) {\n        this.ourVersion = ourVersion;\n        this.commit = commit;\n        this.locale = locale;\n        this.devMode = devMode;\n        this.absoluteFolderPath = absoluteFolderPath;\n        this.isBuiltin = isBuiltin;\n        this.isUnderDevelopment = isUnderDevelopment;\n        this.tanslations = tanslations;\n        // Keep empty!! (JSON.parse)\n    }\n    ExtensionScannerInput.createNLSConfig = function (input) {\n        return {\n            devMode: input.devMode,\n            locale: input.locale,\n            pseudo: input.locale === 'pseudo',\n            translations: input.tanslations\n        };\n    };\n    ExtensionScannerInput.equals = function (a, b) {\n        return (a.ourVersion === b.ourVersion\n            && a.commit === b.commit\n            && a.locale === b.locale\n            && a.devMode === b.devMode\n            && a.absoluteFolderPath === b.absoluteFolderPath\n            && a.isBuiltin === b.isBuiltin\n            && a.isUnderDevelopment === b.isUnderDevelopment\n            && a.mtime === b.mtime\n            && Translations.equals(a.tanslations, b.tanslations));\n    };\n    return ExtensionScannerInput;\n}());\nexports.ExtensionScannerInput = ExtensionScannerInput;\nvar DefaultExtensionResolver = /** @class */ (function () {\n    function DefaultExtensionResolver(root) {\n        this.root = root;\n    }\n    DefaultExtensionResolver.prototype.resolveExtensions = function () {\n        var _this = this;\n        return pfs.readDirsInDir(this.root)\n            .then(function (folders) { return folders.map(function (name) { return ({ name: name, path: path.join(_this.root, name) }); }); });\n    };\n    return DefaultExtensionResolver;\n}());\nvar ExtensionScanner = /** @class */ (function () {\n    function ExtensionScanner() {\n    }\n    /**\n     * Read the extension defined in `absoluteFolderPath`\n     */\n    ExtensionScanner.scanExtension = function (version, log, absoluteFolderPath, isBuiltin, isUnderDevelopment, nlsConfig) {\n        absoluteFolderPath = path.normalize(absoluteFolderPath);\n        var parser = new ExtensionManifestParser(version, log, absoluteFolderPath, isBuiltin, isUnderDevelopment);\n        return parser.parse().then(function (extensionDescription) {\n            if (extensionDescription === null) {\n                return null;\n            }\n            var nlsReplacer = new ExtensionManifestNLSReplacer(version, log, absoluteFolderPath, isBuiltin, isUnderDevelopment, nlsConfig);\n            return nlsReplacer.replaceNLS(extensionDescription);\n        }).then(function (extensionDescription) {\n            if (extensionDescription === null) {\n                return null;\n            }\n            var validator = new ExtensionManifestValidator(version, log, absoluteFolderPath, isBuiltin, isUnderDevelopment);\n            return validator.validate(extensionDescription);\n        });\n    };\n    /**\n     * Scan a list of extensions defined in `absoluteFolderPath`\n     */\n    ExtensionScanner.scanExtensions = function (input, log, resolver) {\n        if (resolver === void 0) { resolver = null; }\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var absoluteFolderPath, isBuiltin, isUnderDevelopment, obsolete_1, obsoleteFileContents, err_1, refs, nlsConfig_1, _extensionDescriptions, extensionDescriptions, byExtension, err_2;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        absoluteFolderPath = input.absoluteFolderPath;\n                        isBuiltin = input.isBuiltin;\n                        isUnderDevelopment = input.isUnderDevelopment;\n                        if (!resolver) {\n                            resolver = new DefaultExtensionResolver(absoluteFolderPath);\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 8, , 9]);\n                        obsolete_1 = {};\n                        if (!!isBuiltin) return [3 /*break*/, 5];\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, pfs.readFile(path.join(absoluteFolderPath, '.obsolete'), 'utf8')];\n                    case 3:\n                        obsoleteFileContents = _a.sent();\n                        obsolete_1 = JSON.parse(obsoleteFileContents);\n                        return [3 /*break*/, 5];\n                    case 4:\n                        err_1 = _a.sent();\n                        return [3 /*break*/, 5];\n                    case 5: return [4 /*yield*/, resolver.resolveExtensions()];\n                    case 6:\n                        refs = _a.sent();\n                        // Ensure the same extension order\n                        refs.sort(function (a, b) { return a.name < b.name ? -1 : 1; });\n                        if (!isBuiltin) {\n                            refs = refs.filter(function (ref) { return ref.name.indexOf('.') !== 0; }); // Do not consider user extension folder starting with `.`\n                        }\n                        nlsConfig_1 = ExtensionScannerInput.createNLSConfig(input);\n                        return [4 /*yield*/, Promise.all(refs.map(function (r) { return _this.scanExtension(input.ourVersion, log, r.path, isBuiltin, isUnderDevelopment, nlsConfig_1); }))];\n                    case 7:\n                        _extensionDescriptions = _a.sent();\n                        extensionDescriptions = arrays.coalesce(_extensionDescriptions);\n                        extensionDescriptions = extensionDescriptions.filter(function (item) { return item !== null && !obsolete_1[new extensions_1.ExtensionIdentifierWithVersion({ id: extensionManagementUtil_1.getGalleryExtensionId(item.publisher, item.name) }, item.version).key()]; });\n                        if (!isBuiltin) {\n                            byExtension = extensionManagementUtil_1.groupByExtension(extensionDescriptions, function (e) { return ({ id: e.identifier.value, uuid: e.uuid }); });\n                            extensionDescriptions = byExtension.map(function (p) { return p.sort(function (a, b) { return semver.rcompare(a.version, b.version); })[0]; });\n                        }\n                        extensionDescriptions.sort(function (a, b) {\n                            if (a.extensionLocation.fsPath < b.extensionLocation.fsPath) {\n                                return -1;\n                            }\n                            return 1;\n                        });\n                        return [2 /*return*/, extensionDescriptions];\n                    case 8:\n                        err_2 = _a.sent();\n                        log.error(absoluteFolderPath, err_2);\n                        return [2 /*return*/, []];\n                    case 9: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Combination of scanExtension and scanExtensions: If an extension manifest is found at root, we load just this extension,\n     * otherwise we assume the folder contains multiple extensions.\n     */\n    ExtensionScanner.scanOneOrMultipleExtensions = function (input, log) {\n        var _this = this;\n        var absoluteFolderPath = input.absoluteFolderPath;\n        var isBuiltin = input.isBuiltin;\n        var isUnderDevelopment = input.isUnderDevelopment;\n        return pfs.fileExists(path.join(absoluteFolderPath, MANIFEST_FILE)).then(function (exists) {\n            if (exists) {\n                var nlsConfig = ExtensionScannerInput.createNLSConfig(input);\n                return _this.scanExtension(input.ourVersion, log, absoluteFolderPath, isBuiltin, isUnderDevelopment, nlsConfig).then(function (extensionDescription) {\n                    if (extensionDescription === null) {\n                        return [];\n                    }\n                    return [extensionDescription];\n                });\n            }\n            return _this.scanExtensions(input, log);\n        }, function (err) {\n            log.error(absoluteFolderPath, err);\n            return [];\n        });\n    };\n    ExtensionScanner.scanSingleExtension = function (input, log) {\n        var absoluteFolderPath = input.absoluteFolderPath;\n        var isBuiltin = input.isBuiltin;\n        var isUnderDevelopment = input.isUnderDevelopment;\n        var nlsConfig = ExtensionScannerInput.createNLSConfig(input);\n        return this.scanExtension(input.ourVersion, log, absoluteFolderPath, isBuiltin, isUnderDevelopment, nlsConfig);\n    };\n    ExtensionScanner.mergeBuiltinExtensions = function (builtinExtensions, extraBuiltinExtensions) {\n        return Promise.all([builtinExtensions, extraBuiltinExtensions]).then(function (_a) {\n            var builtinExtensions = _a[0], extraBuiltinExtensions = _a[1];\n            var resultMap = Object.create(null);\n            for (var i = 0, len = builtinExtensions.length; i < len; i++) {\n                resultMap[extensions_1.ExtensionIdentifier.toKey(builtinExtensions[i].identifier)] = builtinExtensions[i];\n            }\n            // Overwrite with extensions found in extra\n            for (var i = 0, len = extraBuiltinExtensions.length; i < len; i++) {\n                resultMap[extensions_1.ExtensionIdentifier.toKey(extraBuiltinExtensions[i].identifier)] = extraBuiltinExtensions[i];\n            }\n            var resultArr = Object.keys(resultMap).map(function (id) { return resultMap[id]; });\n            resultArr.sort(function (a, b) {\n                var aLastSegment = path.basename(a.extensionLocation.fsPath);\n                var bLastSegment = path.basename(b.extensionLocation.fsPath);\n                if (aLastSegment < bLastSegment) {\n                    return -1;\n                }\n                if (aLastSegment > bLastSegment) {\n                    return 1;\n                }\n                return 0;\n            });\n            return resultArr;\n        });\n    };\n    return ExtensionScanner;\n}());\nexports.ExtensionScanner = ExtensionScanner;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/node/extensionPoints.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/node/extensionPoints.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\nimport * as path from 'vs/base/common/path';\nimport * as semver from 'semver';\nimport * as json from 'vs/base/common/json';\nimport * as arrays from 'vs/base/common/arrays';\nimport { getParseErrorMessage } from 'vs/base/common/jsonErrorMessages';\nimport * as types from 'vs/base/common/types';\nimport { URI } from 'vs/base/common/uri';\nimport * as pfs from 'vs/base/node/pfs';\nimport { getGalleryExtensionId, groupByExtension } from 'vs/platform/extensionManagement/common/extensionManagementUtil';\nimport { isValidExtensionVersion } from 'vs/platform/extensions/node/extensionValidator';\nimport { ExtensionIdentifier, ExtensionIdentifierWithVersion, IExtensionDescription } from 'vs/platform/extensions/common/extensions';\n\nconst MANIFEST_FILE = 'package.json';\n\nexport interface Translations {\n\t[id: string]: string;\n}\n\nnamespace Translations {\n\texport function equals(a: Translations, b: Translations): boolean {\n\t\tif (a === b) {\n\t\t\treturn true;\n\t\t}\n\t\tlet aKeys = Object.keys(a);\n\t\tlet bKeys: Set<string> = new Set<string>();\n\t\tfor (let key of Object.keys(b)) {\n\t\t\tbKeys.add(key);\n\t\t}\n\t\tif (aKeys.length !== bKeys.size) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let key of aKeys) {\n\t\t\tif (a[key] !== b[key]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbKeys.delete(key);\n\t\t}\n\t\treturn bKeys.size === 0;\n\t}\n}\n\nexport interface NlsConfiguration {\n\treadonly devMode: boolean;\n\treadonly locale: string | undefined;\n\treadonly pseudo: boolean;\n\treadonly translations: Translations;\n}\n\nexport interface ILog {\n\terror(source: string, message: string): void;\n\twarn(source: string, message: string): void;\n\tinfo(source: string, message: string): void;\n}\n\nabstract class ExtensionManifestHandler {\n\n\tprotected readonly _ourVersion: string;\n\tprotected readonly _log: ILog;\n\tprotected readonly _absoluteFolderPath: string;\n\tprotected readonly _isBuiltin: boolean;\n\tprotected readonly _isUnderDevelopment: boolean;\n\tprotected readonly _absoluteManifestPath: string;\n\n\tconstructor(ourVersion: string, log: ILog, absoluteFolderPath: string, isBuiltin: boolean, isUnderDevelopment: boolean) {\n\t\tthis._ourVersion = ourVersion;\n\t\tthis._log = log;\n\t\tthis._absoluteFolderPath = absoluteFolderPath;\n\t\tthis._isBuiltin = isBuiltin;\n\t\tthis._isUnderDevelopment = isUnderDevelopment;\n\t\tthis._absoluteManifestPath = path.join(absoluteFolderPath, MANIFEST_FILE);\n\t}\n}\n\nclass ExtensionManifestParser extends ExtensionManifestHandler {\n\n\tpublic parse(): Promise<IExtensionDescription> {\n\t\treturn pfs.readFile(this._absoluteManifestPath).then((manifestContents) => {\n\t\t\ttry {\n\t\t\t\tconst manifest = JSON.parse(manifestContents.toString());\n\t\t\t\tif (manifest.__metadata) {\n\t\t\t\t\tmanifest.uuid = manifest.__metadata.id;\n\t\t\t\t}\n\t\t\t\tdelete manifest.__metadata;\n\t\t\t\treturn manifest;\n\t\t\t} catch (e) {\n\t\t\t\tthis._log.error(this._absoluteFolderPath, nls.localize('jsonParseFail', \"Failed to parse {0}: {1}.\", this._absoluteManifestPath, getParseErrorMessage(e.message)));\n\t\t\t}\n\t\t\treturn null;\n\t\t}, (err) => {\n\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tthis._log.error(this._absoluteFolderPath, nls.localize('fileReadFail', \"Cannot read file {0}: {1}.\", this._absoluteManifestPath, err.message));\n\t\t\treturn null;\n\t\t});\n\t}\n}\n\nclass ExtensionManifestNLSReplacer extends ExtensionManifestHandler {\n\n\tprivate readonly _nlsConfig: NlsConfiguration;\n\n\tconstructor(ourVersion: string, log: ILog, absoluteFolderPath: string, isBuiltin: boolean, isUnderDevelopment: boolean, nlsConfig: NlsConfiguration) {\n\t\tsuper(ourVersion, log, absoluteFolderPath, isBuiltin, isUnderDevelopment);\n\t\tthis._nlsConfig = nlsConfig;\n\t}\n\n\tpublic replaceNLS(extensionDescription: IExtensionDescription): Promise<IExtensionDescription> {\n\t\tinterface MessageBag {\n\t\t\t[key: string]: string;\n\t\t}\n\n\t\tinterface TranslationBundle {\n\t\t\tcontents: {\n\t\t\t\tpackage: MessageBag;\n\t\t\t};\n\t\t}\n\n\t\tinterface LocalizedMessages {\n\t\t\tvalues: MessageBag | undefined;\n\t\t\tdefault: string | null;\n\t\t}\n\n\t\tconst reportErrors = (localized: string | null, errors: json.ParseError[]): void => {\n\t\t\terrors.forEach((error) => {\n\t\t\t\tthis._log.error(this._absoluteFolderPath, nls.localize('jsonsParseReportErrors', \"Failed to parse {0}: {1}.\", localized, getParseErrorMessage(error.error)));\n\t\t\t});\n\t\t};\n\n\t\tlet extension = path.extname(this._absoluteManifestPath);\n\t\tlet basename = this._absoluteManifestPath.substr(0, this._absoluteManifestPath.length - extension.length);\n\n\t\tconst translationId = `${extensionDescription.publisher}.${extensionDescription.name}`;\n\t\tlet translationPath = this._nlsConfig.translations[translationId];\n\t\tlet localizedMessages: Promise<LocalizedMessages | undefined>;\n\t\tif (translationPath) {\n\t\t\tlocalizedMessages = pfs.readFile(translationPath, 'utf8').then<LocalizedMessages, LocalizedMessages>((content) => {\n\t\t\t\tlet errors: json.ParseError[] = [];\n\t\t\t\tlet translationBundle: TranslationBundle = json.parse(content, errors);\n\t\t\t\tif (errors.length > 0) {\n\t\t\t\t\treportErrors(translationPath, errors);\n\t\t\t\t\treturn { values: undefined, default: `${basename}.nls.json` };\n\t\t\t\t} else {\n\t\t\t\t\tlet values = translationBundle.contents ? translationBundle.contents.package : undefined;\n\t\t\t\t\treturn { values: values, default: `${basename}.nls.json` };\n\t\t\t\t}\n\t\t\t}, (error) => {\n\t\t\t\treturn { values: undefined, default: `${basename}.nls.json` };\n\t\t\t});\n\t\t} else {\n\t\t\tlocalizedMessages = pfs.fileExists(basename + '.nls' + extension).then<LocalizedMessages | undefined, LocalizedMessages | undefined>(exists => {\n\t\t\t\tif (!exists) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\treturn ExtensionManifestNLSReplacer.findMessageBundles(this._nlsConfig, basename).then((messageBundle) => {\n\t\t\t\t\tif (!messageBundle.localized) {\n\t\t\t\t\t\treturn { values: undefined, default: messageBundle.original };\n\t\t\t\t\t}\n\t\t\t\t\treturn pfs.readFile(messageBundle.localized, 'utf8').then(messageBundleContent => {\n\t\t\t\t\t\tlet errors: json.ParseError[] = [];\n\t\t\t\t\t\tlet messages: MessageBag = json.parse(messageBundleContent, errors);\n\t\t\t\t\t\tif (errors.length > 0) {\n\t\t\t\t\t\t\treportErrors(messageBundle.localized, errors);\n\t\t\t\t\t\t\treturn { values: undefined, default: messageBundle.original };\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn { values: messages, default: messageBundle.original };\n\t\t\t\t\t}, (err) => {\n\t\t\t\t\t\treturn { values: undefined, default: messageBundle.original };\n\t\t\t\t\t});\n\t\t\t\t}, (err) => {\n\t\t\t\t\treturn undefined;\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\treturn localizedMessages.then((localizedMessages) => {\n\t\t\tif (localizedMessages === undefined) {\n\t\t\t\treturn extensionDescription;\n\t\t\t}\n\t\t\tlet errors: json.ParseError[] = [];\n\t\t\t// resolveOriginalMessageBundle returns null if localizedMessages.default === undefined;\n\t\t\treturn ExtensionManifestNLSReplacer.resolveOriginalMessageBundle(localizedMessages.default, errors).then((defaults) => {\n\t\t\t\tif (errors.length > 0) {\n\t\t\t\t\treportErrors(localizedMessages.default, errors);\n\t\t\t\t\treturn extensionDescription;\n\t\t\t\t}\n\t\t\t\tconst localized = localizedMessages.values || Object.create(null);\n\t\t\t\tExtensionManifestNLSReplacer._replaceNLStrings(this._nlsConfig, extensionDescription, localized, defaults, this._log, this._absoluteFolderPath);\n\t\t\t\treturn extensionDescription;\n\t\t\t});\n\t\t}, (err) => {\n\t\t\treturn extensionDescription;\n\t\t});\n\t}\n\n\t/**\n\t * Parses original message bundle, returns null if the original message bundle is null.\n\t */\n\tprivate static resolveOriginalMessageBundle(originalMessageBundle: string | null, errors: json.ParseError[]) {\n\t\treturn new Promise<{ [key: string]: string; } | null>((c, e) => {\n\t\t\tif (originalMessageBundle) {\n\t\t\t\tpfs.readFile(originalMessageBundle).then(originalBundleContent => {\n\t\t\t\t\tc(json.parse(originalBundleContent.toString(), errors));\n\t\t\t\t}, (err) => {\n\t\t\t\t\tc(null);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tc(null);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Finds localized message bundle and the original (unlocalized) one.\n\t * If the localized file is not present, returns null for the original and marks original as localized.\n\t */\n\tprivate static findMessageBundles(nlsConfig: NlsConfiguration, basename: string): Promise<{ localized: string; original: string | null; }> {\n\t\treturn new Promise<{ localized: string; original: string | null; }>((c, e) => {\n\t\t\tfunction loop(basename: string, locale: string): void {\n\t\t\t\tlet toCheck = `${basename}.nls.${locale}.json`;\n\t\t\t\tpfs.fileExists(toCheck).then(exists => {\n\t\t\t\t\tif (exists) {\n\t\t\t\t\t\tc({ localized: toCheck, original: `${basename}.nls.json` });\n\t\t\t\t\t}\n\t\t\t\t\tlet index = locale.lastIndexOf('-');\n\t\t\t\t\tif (index === -1) {\n\t\t\t\t\t\tc({ localized: `${basename}.nls.json`, original: null });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlocale = locale.substring(0, index);\n\t\t\t\t\t\tloop(basename, locale);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (nlsConfig.devMode || nlsConfig.pseudo || !nlsConfig.locale) {\n\t\t\t\treturn c({ localized: basename + '.nls.json', original: null });\n\t\t\t}\n\t\t\tloop(basename, nlsConfig.locale);\n\t\t});\n\t}\n\n\t/**\n\t * This routine makes the following assumptions:\n\t * The root element is an object literal\n\t */\n\tprivate static _replaceNLStrings<T>(nlsConfig: NlsConfiguration, literal: T, messages: { [key: string]: string; }, originalMessages: { [key: string]: string } | null, log: ILog, messageScope: string): void {\n\t\tfunction processEntry(obj: any, key: string | number, command?: boolean) {\n\t\t\tlet value = obj[key];\n\t\t\tif (types.isString(value)) {\n\t\t\t\tlet str = <string>value;\n\t\t\t\tlet length = str.length;\n\t\t\t\tif (length > 1 && str[0] === '%' && str[length - 1] === '%') {\n\t\t\t\t\tlet messageKey = str.substr(1, length - 2);\n\t\t\t\t\tlet message = messages[messageKey];\n\t\t\t\t\t// If the messages come from a language pack they might miss some keys\n\t\t\t\t\t// Fill them from the original messages.\n\t\t\t\t\tif (message === undefined && originalMessages) {\n\t\t\t\t\t\tmessage = originalMessages[messageKey];\n\t\t\t\t\t}\n\t\t\t\t\tif (message) {\n\t\t\t\t\t\tif (nlsConfig.pseudo) {\n\t\t\t\t\t\t\t// FF3B and FF3D is the Unicode zenkaku representation for [ and ]\n\t\t\t\t\t\t\tmessage = '\\uFF3B' + message.replace(/[aouei]/g, '$&$&') + '\\uFF3D';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tobj[key] = command && (key === 'title' || key === 'category') && originalMessages ? { value: message, original: originalMessages[messageKey] } : message;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.warn(messageScope, nls.localize('missingNLSKey', \"Couldn't find message for key {0}.\", messageKey));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (types.isObject(value)) {\n\t\t\t\tfor (let k in value) {\n\t\t\t\t\tif (value.hasOwnProperty(k)) {\n\t\t\t\t\t\tk === 'commands' ? processEntry(value, k, true) : processEntry(value, k, command);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (types.isArray(value)) {\n\t\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\t\tprocessEntry(value, i, command);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let key in literal) {\n\t\t\tif (literal.hasOwnProperty(key)) {\n\t\t\t\tprocessEntry(literal, key);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Relax the readonly properties here, it is the one place where we check and normalize values\nexport interface IRelaxedExtensionDescription {\n\tid: string;\n\tuuid?: string;\n\tidentifier: ExtensionIdentifier;\n\tname: string;\n\tversion: string;\n\tpublisher: string;\n\tisBuiltin: boolean;\n\tisUnderDevelopment: boolean;\n\textensionLocation: URI;\n\tengines: {\n\t\tvscode: string;\n\t};\n\tmain?: string;\n\tenableProposedApi?: boolean;\n}\n\nclass ExtensionManifestValidator extends ExtensionManifestHandler {\n\tvalidate(_extensionDescription: IExtensionDescription): IExtensionDescription | null {\n\t\tlet extensionDescription = <IRelaxedExtensionDescription>_extensionDescription;\n\t\textensionDescription.isBuiltin = this._isBuiltin;\n\t\textensionDescription.isUnderDevelopment = this._isUnderDevelopment;\n\n\t\tlet notices: string[] = [];\n\t\tif (!ExtensionManifestValidator.isValidExtensionDescription(this._ourVersion, this._absoluteFolderPath, extensionDescription, notices)) {\n\t\t\tnotices.forEach((error) => {\n\t\t\t\tthis._log.error(this._absoluteFolderPath, error);\n\t\t\t});\n\t\t\treturn null;\n\t\t}\n\n\t\t// in this case the notices are warnings\n\t\tnotices.forEach((error) => {\n\t\t\tthis._log.warn(this._absoluteFolderPath, error);\n\t\t});\n\n\t\t// allow publisher to be undefined to make the initial extension authoring experience smoother\n\t\tif (!extensionDescription.publisher) {\n\t\t\textensionDescription.publisher = 'undefined_publisher';\n\t\t}\n\n\t\t// id := `publisher.name`\n\t\textensionDescription.id = `${extensionDescription.publisher}.${extensionDescription.name}`;\n\t\textensionDescription.identifier = new ExtensionIdentifier(extensionDescription.id);\n\n\t\t// main := absolutePath(`main`)\n\t\tif (extensionDescription.main) {\n\t\t\textensionDescription.main = path.join(this._absoluteFolderPath, extensionDescription.main);\n\t\t}\n\n\t\textensionDescription.extensionLocation = URI.file(this._absoluteFolderPath);\n\n\t\treturn extensionDescription;\n\t}\n\n\tprivate static isValidExtensionDescription(version: string, extensionFolderPath: string, extensionDescription: IExtensionDescription, notices: string[]): boolean {\n\n\t\tif (!ExtensionManifestValidator.baseIsValidExtensionDescription(extensionFolderPath, extensionDescription, notices)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!semver.valid(extensionDescription.version)) {\n\t\t\tnotices.push(nls.localize('notSemver', \"Extension version is not semver compatible.\"));\n\t\t\treturn false;\n\t\t}\n\n\t\treturn isValidExtensionVersion(version, extensionDescription, notices);\n\t}\n\n\tprivate static baseIsValidExtensionDescription(extensionFolderPath: string, extensionDescription: IExtensionDescription, notices: string[]): boolean {\n\t\tif (!extensionDescription) {\n\t\t\tnotices.push(nls.localize('extensionDescription.empty', \"Got empty extension description\"));\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof extensionDescription.publisher !== 'undefined' && typeof extensionDescription.publisher !== 'string') {\n\t\t\tnotices.push(nls.localize('extensionDescription.publisher', \"property publisher must be of type `string`.\"));\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof extensionDescription.name !== 'string') {\n\t\t\tnotices.push(nls.localize('extensionDescription.name', \"property `{0}` is mandatory and must be of type `string`\", 'name'));\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof extensionDescription.version !== 'string') {\n\t\t\tnotices.push(nls.localize('extensionDescription.version', \"property `{0}` is mandatory and must be of type `string`\", 'version'));\n\t\t\treturn false;\n\t\t}\n\t\tif (!extensionDescription.engines) {\n\t\t\tnotices.push(nls.localize('extensionDescription.engines', \"property `{0}` is mandatory and must be of type `object`\", 'engines'));\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof extensionDescription.engines.vscode !== 'string') {\n\t\t\tnotices.push(nls.localize('extensionDescription.engines.vscode', \"property `{0}` is mandatory and must be of type `string`\", 'engines.vscode'));\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof extensionDescription.extensionDependencies !== 'undefined') {\n\t\t\tif (!ExtensionManifestValidator._isStringArray(extensionDescription.extensionDependencies)) {\n\t\t\t\tnotices.push(nls.localize('extensionDescription.extensionDependencies', \"property `{0}` can be omitted or must be of type `string[]`\", 'extensionDependencies'));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (typeof extensionDescription.activationEvents !== 'undefined') {\n\t\t\tif (!ExtensionManifestValidator._isStringArray(extensionDescription.activationEvents)) {\n\t\t\t\tnotices.push(nls.localize('extensionDescription.activationEvents1', \"property `{0}` can be omitted or must be of type `string[]`\", 'activationEvents'));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (typeof extensionDescription.main === 'undefined') {\n\t\t\t\tnotices.push(nls.localize('extensionDescription.activationEvents2', \"properties `{0}` and `{1}` must both be specified or must both be omitted\", 'activationEvents', 'main'));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (typeof extensionDescription.main !== 'undefined') {\n\t\t\tif (typeof extensionDescription.main !== 'string') {\n\t\t\t\tnotices.push(nls.localize('extensionDescription.main1', \"property `{0}` can be omitted or must be of type `string`\", 'main'));\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tlet normalizedAbsolutePath = path.join(extensionFolderPath, extensionDescription.main);\n\n\t\t\t\tif (normalizedAbsolutePath.indexOf(extensionFolderPath)) {\n\t\t\t\t\tnotices.push(nls.localize('extensionDescription.main2', \"Expected `main` ({0}) to be included inside extension's folder ({1}). This might make the extension non-portable.\", normalizedAbsolutePath, extensionFolderPath));\n\t\t\t\t\t// not a failure case\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (typeof extensionDescription.activationEvents === 'undefined') {\n\t\t\t\tnotices.push(nls.localize('extensionDescription.main3', \"properties `{0}` and `{1}` must both be specified or must both be omitted\", 'activationEvents', 'main'));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static _isStringArray(arr: string[]): boolean {\n\t\tif (!Array.isArray(arr)) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\t\tif (typeof arr[i] !== 'string') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nexport class ExtensionScannerInput {\n\n\tpublic mtime: number;\n\n\tconstructor(\n\t\tpublic readonly ourVersion: string,\n\t\tpublic readonly commit: string | undefined,\n\t\tpublic readonly locale: string | undefined,\n\t\tpublic readonly devMode: boolean,\n\t\tpublic readonly absoluteFolderPath: string,\n\t\tpublic readonly isBuiltin: boolean,\n\t\tpublic readonly isUnderDevelopment: boolean,\n\t\tpublic readonly tanslations: Translations\n\t) {\n\t\t// Keep empty!! (JSON.parse)\n\t}\n\n\tpublic static createNLSConfig(input: ExtensionScannerInput): NlsConfiguration {\n\t\treturn {\n\t\t\tdevMode: input.devMode,\n\t\t\tlocale: input.locale,\n\t\t\tpseudo: input.locale === 'pseudo',\n\t\t\ttranslations: input.tanslations\n\t\t};\n\t}\n\n\tpublic static equals(a: ExtensionScannerInput, b: ExtensionScannerInput): boolean {\n\t\treturn (\n\t\t\ta.ourVersion === b.ourVersion\n\t\t\t&& a.commit === b.commit\n\t\t\t&& a.locale === b.locale\n\t\t\t&& a.devMode === b.devMode\n\t\t\t&& a.absoluteFolderPath === b.absoluteFolderPath\n\t\t\t&& a.isBuiltin === b.isBuiltin\n\t\t\t&& a.isUnderDevelopment === b.isUnderDevelopment\n\t\t\t&& a.mtime === b.mtime\n\t\t\t&& Translations.equals(a.tanslations, b.tanslations)\n\t\t);\n\t}\n}\n\nexport interface IExtensionReference {\n\tname: string;\n\tpath: string;\n}\n\nexport interface IExtensionResolver {\n\tresolveExtensions(): Promise<IExtensionReference[]>;\n}\n\nclass DefaultExtensionResolver implements IExtensionResolver {\n\n\tconstructor(private root: string) { }\n\n\tresolveExtensions(): Promise<IExtensionReference[]> {\n\t\treturn pfs.readDirsInDir(this.root)\n\t\t\t.then(folders => folders.map(name => ({ name, path: path.join(this.root, name) })));\n\t}\n}\n\nexport class ExtensionScanner {\n\n\t/**\n\t * Read the extension defined in `absoluteFolderPath`\n\t */\n\tprivate static scanExtension(version: string, log: ILog, absoluteFolderPath: string, isBuiltin: boolean, isUnderDevelopment: boolean, nlsConfig: NlsConfiguration): Promise<IExtensionDescription | null> {\n\t\tabsoluteFolderPath = path.normalize(absoluteFolderPath);\n\n\t\tlet parser = new ExtensionManifestParser(version, log, absoluteFolderPath, isBuiltin, isUnderDevelopment);\n\t\treturn parser.parse().then<IExtensionDescription | null>((extensionDescription) => {\n\t\t\tif (extensionDescription === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlet nlsReplacer = new ExtensionManifestNLSReplacer(version, log, absoluteFolderPath, isBuiltin, isUnderDevelopment, nlsConfig);\n\t\t\treturn nlsReplacer.replaceNLS(extensionDescription);\n\t\t}).then((extensionDescription) => {\n\t\t\tif (extensionDescription === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlet validator = new ExtensionManifestValidator(version, log, absoluteFolderPath, isBuiltin, isUnderDevelopment);\n\t\t\treturn validator.validate(extensionDescription);\n\t\t});\n\t}\n\n\t/**\n\t * Scan a list of extensions defined in `absoluteFolderPath`\n\t */\n\tpublic static async scanExtensions(input: ExtensionScannerInput, log: ILog, resolver: IExtensionResolver | null = null): Promise<IExtensionDescription[]> {\n\t\tconst absoluteFolderPath = input.absoluteFolderPath;\n\t\tconst isBuiltin = input.isBuiltin;\n\t\tconst isUnderDevelopment = input.isUnderDevelopment;\n\n\t\tif (!resolver) {\n\t\t\tresolver = new DefaultExtensionResolver(absoluteFolderPath);\n\t\t}\n\n\t\ttry {\n\t\t\tlet obsolete: { [folderName: string]: boolean; } = {};\n\t\t\tif (!isBuiltin) {\n\t\t\t\ttry {\n\t\t\t\t\tconst obsoleteFileContents = await pfs.readFile(path.join(absoluteFolderPath, '.obsolete'), 'utf8');\n\t\t\t\t\tobsolete = JSON.parse(obsoleteFileContents);\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// Don't care\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet refs = await resolver.resolveExtensions();\n\n\t\t\t// Ensure the same extension order\n\t\t\trefs.sort((a, b) => a.name < b.name ? -1 : 1);\n\n\t\t\tif (!isBuiltin) {\n\t\t\t\trefs = refs.filter(ref => ref.name.indexOf('.') !== 0); // Do not consider user extension folder starting with `.`\n\t\t\t}\n\n\t\t\tconst nlsConfig = ExtensionScannerInput.createNLSConfig(input);\n\t\t\tlet _extensionDescriptions = await Promise.all(refs.map(r => this.scanExtension(input.ourVersion, log, r.path, isBuiltin, isUnderDevelopment, nlsConfig)));\n\t\t\tlet extensionDescriptions = arrays.coalesce(_extensionDescriptions);\n\t\t\textensionDescriptions = extensionDescriptions.filter(item => item !== null && !obsolete[new ExtensionIdentifierWithVersion({ id: getGalleryExtensionId(item.publisher, item.name) }, item.version).key()]);\n\n\t\t\tif (!isBuiltin) {\n\t\t\t\t// Filter out outdated extensions\n\t\t\t\tconst byExtension: IExtensionDescription[][] = groupByExtension(extensionDescriptions, e => ({ id: e.identifier.value, uuid: e.uuid }));\n\t\t\t\textensionDescriptions = byExtension.map(p => p.sort((a, b) => semver.rcompare(a.version, b.version))[0]);\n\t\t\t}\n\n\t\t\textensionDescriptions.sort((a, b) => {\n\t\t\t\tif (a.extensionLocation.fsPath < b.extensionLocation.fsPath) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t});\n\t\t\treturn extensionDescriptions;\n\t\t} catch (err) {\n\t\t\tlog.error(absoluteFolderPath, err);\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t/**\n\t * Combination of scanExtension and scanExtensions: If an extension manifest is found at root, we load just this extension,\n\t * otherwise we assume the folder contains multiple extensions.\n\t */\n\tpublic static scanOneOrMultipleExtensions(input: ExtensionScannerInput, log: ILog): Promise<IExtensionDescription[]> {\n\t\tconst absoluteFolderPath = input.absoluteFolderPath;\n\t\tconst isBuiltin = input.isBuiltin;\n\t\tconst isUnderDevelopment = input.isUnderDevelopment;\n\n\t\treturn pfs.fileExists(path.join(absoluteFolderPath, MANIFEST_FILE)).then((exists) => {\n\t\t\tif (exists) {\n\t\t\t\tconst nlsConfig = ExtensionScannerInput.createNLSConfig(input);\n\t\t\t\treturn this.scanExtension(input.ourVersion, log, absoluteFolderPath, isBuiltin, isUnderDevelopment, nlsConfig).then((extensionDescription) => {\n\t\t\t\t\tif (extensionDescription === null) {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\t\t\t\treturn [extensionDescription];\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn this.scanExtensions(input, log);\n\t\t}, (err) => {\n\t\t\tlog.error(absoluteFolderPath, err);\n\t\t\treturn [];\n\t\t});\n\t}\n\n\tpublic static scanSingleExtension(input: ExtensionScannerInput, log: ILog): Promise<IExtensionDescription | null> {\n\t\tconst absoluteFolderPath = input.absoluteFolderPath;\n\t\tconst isBuiltin = input.isBuiltin;\n\t\tconst isUnderDevelopment = input.isUnderDevelopment;\n\t\tconst nlsConfig = ExtensionScannerInput.createNLSConfig(input);\n\t\treturn this.scanExtension(input.ourVersion, log, absoluteFolderPath, isBuiltin, isUnderDevelopment, nlsConfig);\n\t}\n\n\tpublic static mergeBuiltinExtensions(builtinExtensions: Promise<IExtensionDescription[]>, extraBuiltinExtensions: Promise<IExtensionDescription[]>): Promise<IExtensionDescription[]> {\n\t\treturn Promise.all([builtinExtensions, extraBuiltinExtensions]).then(([builtinExtensions, extraBuiltinExtensions]) => {\n\t\t\tlet resultMap: { [id: string]: IExtensionDescription; } = Object.create(null);\n\t\t\tfor (let i = 0, len = builtinExtensions.length; i < len; i++) {\n\t\t\t\tresultMap[ExtensionIdentifier.toKey(builtinExtensions[i].identifier)] = builtinExtensions[i];\n\t\t\t}\n\t\t\t// Overwrite with extensions found in extra\n\t\t\tfor (let i = 0, len = extraBuiltinExtensions.length; i < len; i++) {\n\t\t\t\tresultMap[ExtensionIdentifier.toKey(extraBuiltinExtensions[i].identifier)] = extraBuiltinExtensions[i];\n\t\t\t}\n\n\t\t\tlet resultArr = Object.keys(resultMap).map((id) => resultMap[id]);\n\t\t\tresultArr.sort((a, b) => {\n\t\t\t\tconst aLastSegment = path.basename(a.extensionLocation.fsPath);\n\t\t\t\tconst bLastSegment = path.basename(b.extensionLocation.fsPath);\n\t\t\t\tif (aLastSegment < bLastSegment) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (aLastSegment > bLastSegment) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t\treturn resultArr;\n\t\t});\n\t}\n}"]}]}