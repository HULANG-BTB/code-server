{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true}!/home/coding/workspace/packages/tunnel/src/server.ts","dependencies":[{"path":"/home/coding/workspace/packages/tunnel/src/server.ts","mtime":1555841535694},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst net = require(\"net\");\nconst common_1 = require(\"./common\");\nexports.handle = async (socket, port) => {\n    const hosts = [\n        \"127.0.0.1\",\n        \"::\",\n    ];\n    let localSocket;\n    for (let i = 0; i < hosts.length; i++) {\n        if (localSocket) {\n            break;\n        }\n        localSocket = await new Promise((resolve, reject) => {\n            const socket = net.connect({\n                host: hosts[i],\n                port,\n            }, () => {\n                // Connected\n                resolve(socket);\n            });\n            socket.on(\"error\", (err) => {\n                if (err.code === \"ECONNREFUSED\") {\n                    resolve(undefined);\n                }\n            });\n        });\n    }\n    if (!localSocket) {\n        socket.close(common_1.TunnelCloseCode.ConnectionRefused);\n        return;\n    }\n    socket.binaryType = \"arraybuffer\";\n    socket.addEventListener(\"message\", (event) => localSocket.write(Buffer.from(event.data)));\n    socket.addEventListener(\"close\", () => localSocket.end());\n    localSocket.on(\"data\", (data) => socket.send(data));\n    localSocket.on(\"error\", (err) => socket.close(common_1.TunnelCloseCode.Error, err.toString()));\n    localSocket.on(\"close\", () => socket.close(common_1.TunnelCloseCode.Normal));\n};\n",{"version":3,"file":"/home/coding/workspace/packages/tunnel/src/server.ts","sourceRoot":"","sources":["/home/coding/workspace/packages/tunnel/src/server.ts"],"names":[],"mappings":";;AAAA,2BAA2B;AAC3B,qCAA2C;AAc9B,QAAA,MAAM,GAAG,KAAK,EAAE,MAAU,EAAE,IAAY,EAAiB,EAAE;IACvE,MAAM,KAAK,GAAG;QACb,WAAW;QACX,IAAI;KACJ,CAAC;IAEF,IAAI,WAAmC,CAAC;IACxC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACtC,IAAI,WAAW,EAAE;YAChB,MAAM;SACN;QACD,WAAW,GAAG,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAQ,EAAE;YACzD,MAAM,MAAM,GAAG,GAAG,CAAC,OAAO,CAAC;gBAC1B,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;gBACd,IAAI;aACJ,EAAE,GAAG,EAAE;gBACP,YAAY;gBACZ,OAAO,CAAC,MAAM,CAAC,CAAC;YACjB,CAAC,CAAC,CAAC;YACH,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,GAAsC,EAAE,EAAE;gBAC7D,IAAI,GAAG,CAAC,IAAI,KAAK,cAAc,EAAE;oBAChC,OAAO,CAAC,SAAS,CAAC,CAAC;iBACnB;YACF,CAAC,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;KACH;IACD,IAAI,CAAC,WAAW,EAAE;QACjB,MAAM,CAAC,KAAK,CAAC,wBAAe,CAAC,iBAAiB,CAAC,CAAC;QAEhD,OAAO;KACP;IACD,MAAM,CAAC,UAAU,GAAG,aAAa,CAAC;IAClC,MAAM,CAAC,gBAAgB,CAAC,SAAS,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,WAAY,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAC3F,MAAM,CAAC,gBAAgB,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC,WAAY,CAAC,GAAG,EAAE,CAAC,CAAC;IAC3D,WAAW,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IACpD,WAAW,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,wBAAe,CAAC,KAAK,EAAE,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;IACtF,WAAW,CAAC,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,wBAAe,CAAC,MAAM,CAAC,CAAC,CAAC;AACrE,CAAC,CAAC","sourcesContent":["import * as net from \"net\";\nimport { TunnelCloseCode } from \"./common\";\n\nexport interface WS {\n\taddEventListener(event: \"message\", cb: (event: {\n\t\t// tslint:disable-next-line:no-any\n\t\treadonly data: any;\n\t}) => void): void;\n\taddEventListener(event: \"close\", cb: () => void): void;\n\tbinaryType: string;\n\tclose(code: number, reason?: string): void;\n\t// tslint:disable-next-line:no-any\n\tsend(data: any): void;\n}\n\nexport const handle = async (socket: WS, port: number): Promise<void> => {\n\tconst hosts = [\n\t\t\"127.0.0.1\",\n\t\t\"::\", // localhost\n\t];\n\n\tlet localSocket: net.Socket | undefined;\n\tfor (let i = 0; i < hosts.length; i++) {\n\t\tif (localSocket) {\n\t\t\tbreak;\n\t\t}\n\t\tlocalSocket = await new Promise((resolve, reject): void => {\n\t\t\tconst socket = net.connect({\n\t\t\t\thost: hosts[i],\n\t\t\t\tport,\n\t\t\t}, () => {\n\t\t\t\t// Connected\n\t\t\t\tresolve(socket);\n\t\t\t});\n\t\t\tsocket.on(\"error\", (err: Error & { readonly code: string }) => {\n\t\t\t\tif (err.code === \"ECONNREFUSED\") {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\tif (!localSocket) {\n\t\tsocket.close(TunnelCloseCode.ConnectionRefused);\n\n\t\treturn;\n\t}\n\tsocket.binaryType = \"arraybuffer\";\n\tsocket.addEventListener(\"message\", (event) => localSocket!.write(Buffer.from(event.data)));\n\tsocket.addEventListener(\"close\", () => localSocket!.end());\n\tlocalSocket.on(\"data\", (data) => socket.send(data));\n\tlocalSocket.on(\"error\", (err) => socket.close(TunnelCloseCode.Error, err.toString()));\n\tlocalSocket.on(\"close\", () => socket.close(TunnelCloseCode.Normal));\n};\n"]}]}