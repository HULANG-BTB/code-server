{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true}!/home/coding/workspace/packages/protocol/src/common/proxy.ts","dependencies":[{"path":"/home/coding/workspace/packages/protocol/src/common/proxy.ts","mtime":1555841535686},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst util_1 = require(\"./util\");\n// tslint:disable no-any\n/**\n * Allow using a proxy like it's returned synchronously. This only works because\n * all proxy methods return promises.\n */\nconst unpromisify = (proxyPromise) => {\n    return new Proxy({}, {\n        get: (target, name) => {\n            if (typeof target[name] === \"undefined\") {\n                target[name] = async (...args) => {\n                    const proxy = await proxyPromise;\n                    return proxy ? proxy[name](...args) : undefined;\n                };\n            }\n            return target[name];\n        },\n    });\n};\n/**\n * Client-side emitter that just forwards proxy events to its own emitter.\n * It also turns a promisified proxy into a non-promisified proxy so we don't\n * need a bunch of `then` calls everywhere.\n */\nclass ClientProxy extends events_1.EventEmitter {\n    /**\n     * You can specify not to bind events in order to avoid emitting twice for\n     * duplex streams.\n     */\n    constructor(proxyPromise, bindEvents = true) {\n        super();\n        this.bindEvents = bindEvents;\n        this.initialize(proxyPromise);\n        if (this.bindEvents) {\n            this.on(\"disconnected\", (error) => {\n                try {\n                    this.emit(\"error\", error);\n                }\n                catch (error) {\n                    // If nothing is listening, EventEmitter will throw an error.\n                }\n                this.handleDisconnect();\n            });\n        }\n    }\n    /**\n     * Remove an event listener.\n     */\n    off(event, cb) {\n        // Fill it here because the fill we're using to provide EventEmitter for the\n        // browser doesn't appear to include `off`.\n        this.removeListener(event, cb);\n        return this;\n    }\n    get proxy() {\n        if (!this._proxy) {\n            throw new Error(\"not initialized\");\n        }\n        return this._proxy;\n    }\n    /**\n     * Initialize the proxy by unpromisifying if necessary and binding to its\n     * events.\n     */\n    initialize(proxyPromise) {\n        this._proxy = util_1.isPromise(proxyPromise) ? unpromisify(proxyPromise) : proxyPromise;\n        if (this.bindEvents) {\n            this.catch(this.proxy.onEvent((event, ...args) => {\n                this.emit(event, ...args);\n            }));\n        }\n    }\n    /**\n     * Emit an error event if the promise errors.\n     */\n    catch(promise) {\n        if (promise) {\n            promise.catch((e) => this.emit(\"error\", e));\n        }\n        return this;\n    }\n}\nexports.ClientProxy = ClientProxy;\n/**\n * Supported top-level module proxies.\n */\nvar Module;\n(function (Module) {\n    Module[\"Fs\"] = \"fs\";\n    Module[\"ChildProcess\"] = \"child_process\";\n    Module[\"Net\"] = \"net\";\n    Module[\"Spdlog\"] = \"spdlog\";\n    Module[\"NodePty\"] = \"node-pty\";\n    Module[\"Trash\"] = \"trash\";\n})(Module = exports.Module || (exports.Module = {}));\n/**\n * Batch remote calls.\n */\nclass Batch {\n    constructor(\n    /**\n     * Flush after reaching this amount of time.\n     */\n    maxTime = 1000, \n    /**\n     * Flush after reaching this count.\n     */\n    maxCount = 100, \n    /**\n     * Flush after not receiving more requests for this amount of time.\n     * This is pretty low by default so essentially we just end up batching\n     * requests that are all made at the same time.\n     */\n    idleTime = 1) {\n        this.maxTime = maxTime;\n        this.maxCount = maxCount;\n        this.idleTime = idleTime;\n        this.batch = [];\n        this.add = (args) => {\n            return new Promise((resolve, reject) => {\n                this.batch.push({\n                    args,\n                    resolve,\n                    reject,\n                });\n                if (this.batch.length >= this.maxCount) {\n                    this.flush();\n                }\n                else {\n                    clearTimeout(this.idleTimeout);\n                    this.idleTimeout = setTimeout(this.flush, this.idleTime);\n                    if (typeof this.maxTimeout === \"undefined\") {\n                        this.maxTimeout = setTimeout(this.flush, this.maxTime);\n                    }\n                }\n            });\n        };\n        /**\n         * Flush out the current batch.\n         */\n        this.flush = () => {\n            clearTimeout(this.idleTimeout);\n            clearTimeout(this.maxTimeout);\n            this.maxTimeout = undefined;\n            const batch = this.batch;\n            this.batch = [];\n            this.remoteCall(batch.map((q) => q.args)).then((results) => {\n                batch.forEach((item, i) => {\n                    const result = results[i];\n                    if (result && result instanceof Error) {\n                        item.reject(result);\n                    }\n                    else {\n                        item.resolve(result);\n                    }\n                });\n            }).catch((error) => batch.forEach((item) => item.reject(error)));\n        };\n    }\n}\nexports.Batch = Batch;\n",{"version":3,"file":"/home/coding/workspace/packages/protocol/src/common/proxy.ts","sourceRoot":"","sources":["/home/coding/workspace/packages/protocol/src/common/proxy.ts"],"names":[],"mappings":";;AAAA,mCAAsC;AACtC,iCAAmC;AAEnC,wBAAwB;AAExB;;;GAGG;AACH,MAAM,WAAW,GAAG,CAAwB,YAAwB,EAAK,EAAE;IAC1E,OAAO,IAAI,KAAK,CAAC,EAAE,EAAE;QACpB,GAAG,EAAE,CAAC,MAAW,EAAE,IAAY,EAAO,EAAE;YACvC,IAAI,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,WAAW,EAAE;gBACxC,MAAM,CAAC,IAAI,CAAC,GAAG,KAAK,EAAE,GAAG,IAAW,EAAgB,EAAE;oBACrD,MAAM,KAAK,GAAG,MAAM,YAAY,CAAC;oBAEjC,OAAO,KAAK,CAAC,CAAC,CAAE,KAAa,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;gBAC1D,CAAC,CAAC;aACF;YAED,OAAO,MAAM,CAAC,IAAI,CAAC,CAAC;QACrB,CAAC;KACD,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF;;;;GAIG;AACH,MAAsB,WAAmC,SAAQ,qBAAY;IAG5E;;;OAGG;IACH,YACC,YAA4B,EACX,aAAsB,IAAI;QAE3C,KAAK,EAAE,CAAC;QAFS,eAAU,GAAV,UAAU,CAAgB;QAG3C,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;QAC9B,IAAI,IAAI,CAAC,UAAU,EAAE;YACpB,IAAI,CAAC,EAAE,CAAC,cAAc,EAAE,CAAC,KAAK,EAAE,EAAE;gBACjC,IAAI;oBACH,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;iBAC1B;gBAAC,OAAO,KAAK,EAAE;oBACf,6DAA6D;iBAC7D;gBACD,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACzB,CAAC,CAAC,CAAC;SACH;IACF,CAAC;IAED;;OAEG;IACI,GAAG,CAAC,KAAa,EAAE,EAA4B;QACrD,4EAA4E;QAC5E,2CAA2C;QAC3C,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;QAE/B,OAAO,IAAI,CAAC;IACb,CAAC;IAED,IAAc,KAAK;QAClB,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YACjB,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;SACnC;QAED,OAAO,IAAI,CAAC,MAAM,CAAC;IACpB,CAAC;IAED;;;OAGG;IACO,UAAU,CAAC,YAA4B;QAChD,IAAI,CAAC,MAAM,GAAG,gBAAS,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC;QACjF,IAAI,IAAI,CAAC,UAAU,EAAE;YACpB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,GAAG,IAAI,EAAQ,EAAE;gBACtD,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC,CAAC;YAC3B,CAAC,CAAC,CAAC,CAAC;SACJ;IACF,CAAC;IAOD;;OAEG;IACO,KAAK,CAAC,OAAsB;QACrC,IAAI,OAAO,EAAE;YACZ,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC;SAC5C;QAED,OAAO,IAAI,CAAC;IACb,CAAC;CACD;AAxED,kCAwEC;AAgCD;;GAEG;AACH,IAAY,MAOX;AAPD,WAAY,MAAM;IACjB,mBAAS,CAAA;IACT,wCAA8B,CAAA;IAC9B,qBAAW,CAAA;IACX,2BAAiB,CAAA;IACjB,8BAAoB,CAAA;IACpB,yBAAe,CAAA;AAChB,CAAC,EAPW,MAAM,GAAN,cAAM,KAAN,cAAM,QAOjB;AAQD;;GAEG;AACH,MAAsB,KAAK;IAK1B;IACC;;OAEG;IACc,UAAkB,IAAI;IACvC;;OAEG;IACc,WAAmB,GAAG;IACvC;;;;OAIG;IACc,WAAmB,CAAC;QAVpB,YAAO,GAAP,OAAO,CAAe;QAItB,aAAQ,GAAR,QAAQ,CAAc;QAMtB,aAAQ,GAAR,QAAQ,CAAY;QAhB9B,UAAK,GAAsB,EAAE,CAAC;QAmB/B,QAAG,GAAG,CAAC,IAAO,EAAc,EAAE;YACpC,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAQ,EAAE;gBAC5C,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;oBACf,IAAI;oBACJ,OAAO;oBACP,MAAM;iBACN,CAAC,CAAC;gBACH,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE;oBACvC,IAAI,CAAC,KAAK,EAAE,CAAC;iBACb;qBAAM;oBACN,YAAY,CAAC,IAAI,CAAC,WAAkB,CAAC,CAAC;oBACtC,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;oBACzD,IAAI,OAAO,IAAI,CAAC,UAAU,KAAK,WAAW,EAAE;wBAC3C,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;qBACvD;iBACD;YACF,CAAC,CAAC,CAAC;QACJ,CAAC,CAAA;QAOD;;WAEG;QACc,UAAK,GAAG,GAAS,EAAE;YACnC,YAAY,CAAC,IAAI,CAAC,WAAkB,CAAC,CAAC;YACtC,YAAY,CAAC,IAAI,CAAC,UAAiB,CAAC,CAAC;YACrC,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;YAE5B,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;YACzB,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;YAEhB,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,EAAE;gBAC1D,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE;oBACzB,MAAM,MAAM,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;oBAC1B,IAAI,MAAM,IAAI,MAAM,YAAY,KAAK,EAAE;wBACtC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;qBACpB;yBAAM;wBACN,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;qBACrB;gBACF,CAAC,CAAC,CAAC;YACJ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAClE,CAAC,CAAA;IA/CE,CAAC;CAgDJ;AApED,sBAoEC","sourcesContent":["import { EventEmitter } from \"events\";\nimport { isPromise } from \"./util\";\n\n// tslint:disable no-any\n\n/**\n * Allow using a proxy like it's returned synchronously. This only works because\n * all proxy methods return promises.\n */\nconst unpromisify = <T extends ServerProxy>(proxyPromise: Promise<T>): T => {\n\treturn new Proxy({}, {\n\t\tget: (target: any, name: string): any => {\n\t\t\tif (typeof target[name] === \"undefined\") {\n\t\t\t\ttarget[name] = async (...args: any[]): Promise<any> => {\n\t\t\t\t\tconst proxy = await proxyPromise;\n\n\t\t\t\t\treturn proxy ? (proxy as any)[name](...args) : undefined;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn target[name];\n\t\t},\n\t});\n};\n\n/**\n * Client-side emitter that just forwards proxy events to its own emitter.\n * It also turns a promisified proxy into a non-promisified proxy so we don't\n * need a bunch of `then` calls everywhere.\n */\nexport abstract class ClientProxy<T extends ServerProxy> extends EventEmitter {\n\tprivate _proxy: T | undefined;\n\n\t/**\n\t * You can specify not to bind events in order to avoid emitting twice for\n\t * duplex streams.\n\t */\n\tpublic constructor(\n\t\tproxyPromise: Promise<T> | T,\n\t\tprivate readonly bindEvents: boolean = true,\n\t) {\n\t\tsuper();\n\t\tthis.initialize(proxyPromise);\n\t\tif (this.bindEvents) {\n\t\t\tthis.on(\"disconnected\", (error) => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.emit(\"error\", error);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// If nothing is listening, EventEmitter will throw an error.\n\t\t\t\t}\n\t\t\t\tthis.handleDisconnect();\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Remove an event listener.\n\t */\n\tpublic off(event: string, cb: (...args: any[]) => void): this {\n\t\t// Fill it here because the fill we're using to provide EventEmitter for the\n\t\t// browser doesn't appear to include `off`.\n\t\tthis.removeListener(event, cb);\n\n\t\treturn this;\n\t}\n\n\tprotected get proxy(): T {\n\t\tif (!this._proxy) {\n\t\t\tthrow new Error(\"not initialized\");\n\t\t}\n\n\t\treturn this._proxy;\n\t}\n\n\t/**\n\t * Initialize the proxy by unpromisifying if necessary and binding to its\n\t * events.\n\t */\n\tprotected initialize(proxyPromise: Promise<T> | T): void {\n\t\tthis._proxy = isPromise(proxyPromise) ? unpromisify(proxyPromise) : proxyPromise;\n\t\tif (this.bindEvents) {\n\t\t\tthis.catch(this.proxy.onEvent((event, ...args): void => {\n\t\t\t\tthis.emit(event, ...args);\n\t\t\t}));\n\t\t}\n\t}\n\n\t/**\n\t * Perform necessary cleanup on disconnect (or reconnect).\n\t */\n\tprotected abstract handleDisconnect(): void;\n\n\t/**\n\t * Emit an error event if the promise errors.\n\t */\n\tprotected catch(promise?: Promise<any>): this {\n\t\tif (promise) {\n\t\t\tpromise.catch((e) => this.emit(\"error\", e));\n\t\t}\n\n\t\treturn this;\n\t}\n}\n\n/**\n * Proxy to the actual instance on the server. Every method must only accept\n * serializable arguments and must return promises with serializable values. If\n * a proxy itself has proxies on creation (like how ChildProcess has stdin),\n * then it should return all of those at once, otherwise you will miss events\n * from those child proxies and fail to dispose them properly.\n */\nexport interface ServerProxy {\n\t/**\n\t * Dispose the proxy.\n\t */\n\tdispose(): Promise<void>;\n\n\t/**\n\t * This is used instead of an event to force it to be implemented since there\n\t * would be no guarantee the implementation would remember to emit the event.\n\t */\n\tonDone(cb: () => void): Promise<void>;\n\n\t/**\n\t * Listen to all possible events. On the client, this is to reduce boilerplate\n\t * that would just be a bunch of error-prone forwarding of each individual\n\t * event from the proxy to its own emitter. It also fixes a timing issue\n\t * because we just always send all events from the server, so we never miss\n\t * any due to listening too late.\n\t */\n\t// tslint:disable-next-line no-any\n\tonEvent(cb: (event: string, ...args: any[]) => void): Promise<void>;\n}\n\n/**\n * Supported top-level module proxies.\n */\nexport enum Module {\n\tFs = \"fs\",\n\tChildProcess = \"child_process\",\n\tNet = \"net\",\n\tSpdlog = \"spdlog\",\n\tNodePty = \"node-pty\",\n\tTrash = \"trash\",\n}\n\ninterface BatchItem<T, A> {\n\targs: A;\n\tresolve: (t: T) => void;\n\treject: (e: Error) => void;\n}\n\n/**\n * Batch remote calls.\n */\nexport abstract class Batch<T, A> {\n\tprivate idleTimeout: number | NodeJS.Timer | undefined;\n\tprivate maxTimeout: number | NodeJS.Timer | undefined;\n\tprivate batch = <BatchItem<T, A>[]>[];\n\n\tpublic constructor(\n\t\t/**\n\t\t * Flush after reaching this amount of time.\n\t\t */\n\t\tprivate readonly maxTime: number = 1000,\n\t\t/**\n\t\t * Flush after reaching this count.\n\t\t */\n\t\tprivate readonly maxCount: number = 100,\n\t\t/**\n\t\t * Flush after not receiving more requests for this amount of time.\n\t\t * This is pretty low by default so essentially we just end up batching\n\t\t * requests that are all made at the same time.\n\t\t */\n\t\tprivate readonly idleTime: number = 1,\n\t) {}\n\n\tpublic add = (args: A): Promise<T> => {\n\t\treturn new Promise((resolve, reject): void => {\n\t\t\tthis.batch.push({\n\t\t\t\targs,\n\t\t\t\tresolve,\n\t\t\t\treject,\n\t\t\t});\n\t\t\tif (this.batch.length >= this.maxCount) {\n\t\t\t\tthis.flush();\n\t\t\t} else {\n\t\t\t\tclearTimeout(this.idleTimeout as any);\n\t\t\t\tthis.idleTimeout = setTimeout(this.flush, this.idleTime);\n\t\t\t\tif (typeof this.maxTimeout === \"undefined\") {\n\t\t\t\t\tthis.maxTimeout = setTimeout(this.flush, this.maxTime);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Perform remote call for a batch.\n\t */\n\tprotected abstract remoteCall(batch: A[]): Promise<(T | Error)[]>;\n\n\t/**\n\t * Flush out the current batch.\n\t */\n\tprivate readonly flush = (): void => {\n\t\tclearTimeout(this.idleTimeout as any);\n\t\tclearTimeout(this.maxTimeout as any);\n\t\tthis.maxTimeout = undefined;\n\n\t\tconst batch = this.batch;\n\t\tthis.batch = [];\n\n\t\tthis.remoteCall(batch.map((q) => q.args)).then((results) => {\n\t\t\tbatch.forEach((item, i) => {\n\t\t\t\tconst result = results[i];\n\t\t\t\tif (result && result instanceof Error) {\n\t\t\t\t\titem.reject(result);\n\t\t\t\t} else {\n\t\t\t\t\titem.resolve(result);\n\t\t\t\t}\n\t\t\t});\n\t\t}).catch((error) => batch.forEach((item) => item.reject(error)));\n\t}\n}\n"]}]}