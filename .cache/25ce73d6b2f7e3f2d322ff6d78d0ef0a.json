{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/viewModel/prefixSumComputer.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewModel/prefixSumComputer.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/editor/common/core/uint\"], function (require, exports, uint_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class PrefixSumIndexOfResult {\n        constructor(index, remainder) {\n            this.index = index;\n            this.remainder = remainder;\n        }\n    }\n    exports.PrefixSumIndexOfResult = PrefixSumIndexOfResult;\n    class PrefixSumComputer {\n        constructor(values) {\n            this.values = values;\n            this.prefixSum = new Uint32Array(values.length);\n            this.prefixSumValidIndex = new Int32Array(1);\n            this.prefixSumValidIndex[0] = -1;\n        }\n        getCount() {\n            return this.values.length;\n        }\n        insertValues(insertIndex, insertValues) {\n            insertIndex = uint_1.toUint32(insertIndex);\n            const oldValues = this.values;\n            const oldPrefixSum = this.prefixSum;\n            const insertValuesLen = insertValues.length;\n            if (insertValuesLen === 0) {\n                return false;\n            }\n            this.values = new Uint32Array(oldValues.length + insertValuesLen);\n            this.values.set(oldValues.subarray(0, insertIndex), 0);\n            this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\n            this.values.set(insertValues, insertIndex);\n            if (insertIndex - 1 < this.prefixSumValidIndex[0]) {\n                this.prefixSumValidIndex[0] = insertIndex - 1;\n            }\n            this.prefixSum = new Uint32Array(this.values.length);\n            if (this.prefixSumValidIndex[0] >= 0) {\n                this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n            }\n            return true;\n        }\n        changeValue(index, value) {\n            index = uint_1.toUint32(index);\n            value = uint_1.toUint32(value);\n            if (this.values[index] === value) {\n                return false;\n            }\n            this.values[index] = value;\n            if (index - 1 < this.prefixSumValidIndex[0]) {\n                this.prefixSumValidIndex[0] = index - 1;\n            }\n            return true;\n        }\n        removeValues(startIndex, cnt) {\n            startIndex = uint_1.toUint32(startIndex);\n            cnt = uint_1.toUint32(cnt);\n            const oldValues = this.values;\n            const oldPrefixSum = this.prefixSum;\n            if (startIndex >= oldValues.length) {\n                return false;\n            }\n            let maxCnt = oldValues.length - startIndex;\n            if (cnt >= maxCnt) {\n                cnt = maxCnt;\n            }\n            if (cnt === 0) {\n                return false;\n            }\n            this.values = new Uint32Array(oldValues.length - cnt);\n            this.values.set(oldValues.subarray(0, startIndex), 0);\n            this.values.set(oldValues.subarray(startIndex + cnt), startIndex);\n            this.prefixSum = new Uint32Array(this.values.length);\n            if (startIndex - 1 < this.prefixSumValidIndex[0]) {\n                this.prefixSumValidIndex[0] = startIndex - 1;\n            }\n            if (this.prefixSumValidIndex[0] >= 0) {\n                this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n            }\n            return true;\n        }\n        getTotalValue() {\n            if (this.values.length === 0) {\n                return 0;\n            }\n            return this._getAccumulatedValue(this.values.length - 1);\n        }\n        getAccumulatedValue(index) {\n            if (index < 0) {\n                return 0;\n            }\n            index = uint_1.toUint32(index);\n            return this._getAccumulatedValue(index);\n        }\n        _getAccumulatedValue(index) {\n            if (index <= this.prefixSumValidIndex[0]) {\n                return this.prefixSum[index];\n            }\n            let startIndex = this.prefixSumValidIndex[0] + 1;\n            if (startIndex === 0) {\n                this.prefixSum[0] = this.values[0];\n                startIndex++;\n            }\n            if (index >= this.values.length) {\n                index = this.values.length - 1;\n            }\n            for (let i = startIndex; i <= index; i++) {\n                this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n            }\n            this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\n            return this.prefixSum[index];\n        }\n        getIndexOf(accumulatedValue) {\n            accumulatedValue = Math.floor(accumulatedValue); //@perf\n            // Compute all sums (to get a fully valid prefixSum)\n            this.getTotalValue();\n            let low = 0;\n            let high = this.values.length - 1;\n            let mid = 0;\n            let midStop = 0;\n            let midStart = 0;\n            while (low <= high) {\n                mid = low + ((high - low) / 2) | 0;\n                midStop = this.prefixSum[mid];\n                midStart = midStop - this.values[mid];\n                if (accumulatedValue < midStart) {\n                    high = mid - 1;\n                }\n                else if (accumulatedValue >= midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n            return new PrefixSumIndexOfResult(mid, accumulatedValue - midStart);\n        }\n    }\n    exports.PrefixSumComputer = PrefixSumComputer;\n    class PrefixSumComputerWithCache {\n        constructor(values) {\n            this._cacheAccumulatedValueStart = 0;\n            this._cache = null;\n            this._actual = new PrefixSumComputer(values);\n            this._bustCache();\n        }\n        _bustCache() {\n            this._cacheAccumulatedValueStart = 0;\n            this._cache = null;\n        }\n        insertValues(insertIndex, insertValues) {\n            if (this._actual.insertValues(insertIndex, insertValues)) {\n                this._bustCache();\n            }\n        }\n        changeValue(index, value) {\n            if (this._actual.changeValue(index, value)) {\n                this._bustCache();\n            }\n        }\n        removeValues(startIndex, cnt) {\n            if (this._actual.removeValues(startIndex, cnt)) {\n                this._bustCache();\n            }\n        }\n        getTotalValue() {\n            return this._actual.getTotalValue();\n        }\n        getAccumulatedValue(index) {\n            return this._actual.getAccumulatedValue(index);\n        }\n        getIndexOf(accumulatedValue) {\n            accumulatedValue = Math.floor(accumulatedValue); //@perf\n            if (this._cache !== null) {\n                let cacheIndex = accumulatedValue - this._cacheAccumulatedValueStart;\n                if (cacheIndex >= 0 && cacheIndex < this._cache.length) {\n                    // Cache hit!\n                    return this._cache[cacheIndex];\n                }\n            }\n            // Cache miss!\n            return this._actual.getIndexOf(accumulatedValue);\n        }\n        /**\n         * Gives a hint that a lot of requests are about to come in for these accumulated values.\n         */\n        warmUpCache(accumulatedValueStart, accumulatedValueEnd) {\n            let newCache = [];\n            for (let accumulatedValue = accumulatedValueStart; accumulatedValue <= accumulatedValueEnd; accumulatedValue++) {\n                newCache[accumulatedValue - accumulatedValueStart] = this.getIndexOf(accumulatedValue);\n            }\n            this._cache = newCache;\n            this._cacheAccumulatedValueStart = accumulatedValueStart;\n        }\n    }\n    exports.PrefixSumComputerWithCache = PrefixSumComputerWithCache;\n});\n",null]}