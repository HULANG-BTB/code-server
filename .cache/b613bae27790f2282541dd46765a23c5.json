{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostComments.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostComments.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/async\", \"vs/base/common/uri\", \"vs/editor/common/modes\", \"vs/workbench/api/node/extHostTypeConverters\", \"vs/workbench/api/node/extHostTypes\", \"../common/extHost.protocol\", \"vs/base/common/cancellation\", \"vs/platform/extensions/common/extensions\", \"vs/base/common/event\"], function (require, exports, async_1, uri_1, modes, extHostTypeConverter, types, extHost_protocol_1, cancellation_1, extensions_1, event_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class ExtHostComments {\n        constructor(mainContext, _commands, _documents) {\n            this._commands = _commands;\n            this._documents = _documents;\n            this._commentControllers = new Map();\n            this._commentControllersByExtension = new Map();\n            this._documentProviders = new Map();\n            this._workspaceProviders = new Map();\n            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadComments);\n            _commands.registerArgumentProcessor({\n                processArgument: arg => {\n                    if (arg && arg.$mid === 6) {\n                        const commentController = this._commentControllers.get(arg.handle);\n                        if (!commentController) {\n                            return arg;\n                        }\n                        return commentController;\n                    }\n                    else if (arg && arg.$mid === 7) {\n                        const commentController = this._commentControllers.get(arg.commentControlHandle);\n                        if (!commentController) {\n                            return arg;\n                        }\n                        const commentThread = commentController.getCommentThread(arg.commentThreadHandle);\n                        if (!commentThread) {\n                            return arg;\n                        }\n                        return commentThread;\n                    }\n                    return arg;\n                }\n            });\n        }\n        createCommentController(extension, id, label) {\n            const handle = ExtHostComments.handlePool++;\n            const commentController = new ExtHostCommentController(extension, handle, this._commands.converter, this._proxy, id, label);\n            this._commentControllers.set(commentController.handle, commentController);\n            const commentControllers = this._commentControllersByExtension.get(extensions_1.ExtensionIdentifier.toKey(extension.identifier)) || [];\n            commentControllers.push(commentController);\n            this._commentControllersByExtension.set(extensions_1.ExtensionIdentifier.toKey(extension.identifier), commentControllers);\n            return commentController;\n        }\n        $onCommentWidgetInputChange(commentControllerHandle, input) {\n            const commentController = this._commentControllers.get(commentControllerHandle);\n            if (!commentController) {\n                return Promise.resolve(undefined);\n            }\n            commentController.$onCommentWidgetInputChange(input);\n            return Promise.resolve(commentControllerHandle);\n        }\n        $provideCommentingRanges(commentControllerHandle, uriComponents, token) {\n            const commentController = this._commentControllers.get(commentControllerHandle);\n            if (!commentController || !commentController.commentingRangeProvider) {\n                return Promise.resolve(undefined);\n            }\n            const document = this._documents.getDocument(uri_1.URI.revive(uriComponents));\n            return async_1.asPromise(() => {\n                return commentController.commentingRangeProvider.provideCommentingRanges(document, token);\n            }).then(ranges => ranges ? ranges.map(x => extHostTypeConverter.Range.from(x)) : undefined);\n        }\n        $provideReactionGroup(commentControllerHandle) {\n            const commentController = this._commentControllers.get(commentControllerHandle);\n            if (!commentController || !commentController.reactionProvider) {\n                return Promise.resolve(undefined);\n            }\n            return async_1.asPromise(() => {\n                return commentController.reactionProvider.availableReactions;\n            }).then(reactions => reactions.map(reaction => convertToReaction2(commentController.reactionProvider, reaction)));\n        }\n        $toggleReaction(commentControllerHandle, threadHandle, uri, comment, reaction) {\n            const document = this._documents.getDocument(uri_1.URI.revive(uri));\n            const commentController = this._commentControllers.get(commentControllerHandle);\n            if (!commentController || !commentController.reactionProvider || !commentController.reactionProvider.toggleReaction) {\n                return Promise.resolve(undefined);\n            }\n            return async_1.asPromise(() => {\n                const commentThread = commentController.getCommentThread(threadHandle);\n                if (commentThread) {\n                    const vscodeComment = commentThread.getComment(comment.commentId);\n                    if (commentController !== undefined && commentController.reactionProvider && commentController.reactionProvider.toggleReaction && vscodeComment) {\n                        return commentController.reactionProvider.toggleReaction(document, vscodeComment, convertFromReaction(reaction));\n                    }\n                }\n                return Promise.resolve(undefined);\n            });\n        }\n        $createNewCommentWidgetCallback(commentControllerHandle, uriComponents, range, token) {\n            const commentController = this._commentControllers.get(commentControllerHandle);\n            if (!commentController || !commentController.emptyCommentThreadFactory) {\n                return Promise.resolve();\n            }\n            const document = this._documents.getDocument(uri_1.URI.revive(uriComponents));\n            return async_1.asPromise(() => commentController.emptyCommentThreadFactory.createEmptyCommentThread(document, extHostTypeConverter.Range.to(range))).then(() => Promise.resolve());\n        }\n        registerWorkspaceCommentProvider(extensionId, provider) {\n            const handle = ExtHostComments.handlePool++;\n            this._workspaceProviders.set(handle, {\n                extensionId,\n                provider\n            });\n            this._proxy.$registerWorkspaceCommentProvider(handle, extensionId);\n            this.registerListeners(handle, extensionId, provider);\n            return {\n                dispose: () => {\n                    this._proxy.$unregisterWorkspaceCommentProvider(handle);\n                    this._workspaceProviders.delete(handle);\n                }\n            };\n        }\n        registerDocumentCommentProvider(extensionId, provider) {\n            const handle = ExtHostComments.handlePool++;\n            this._documentProviders.set(handle, {\n                extensionId,\n                provider\n            });\n            this._proxy.$registerDocumentCommentProvider(handle, {\n                startDraftLabel: provider.startDraftLabel,\n                deleteDraftLabel: provider.deleteDraftLabel,\n                finishDraftLabel: provider.finishDraftLabel,\n                reactionGroup: provider.reactionGroup ? provider.reactionGroup.map(reaction => convertToReaction(provider, reaction)) : undefined\n            });\n            this.registerListeners(handle, extensionId, provider);\n            return {\n                dispose: () => {\n                    this._proxy.$unregisterDocumentCommentProvider(handle);\n                    this._documentProviders.delete(handle);\n                }\n            };\n        }\n        $createNewCommentThread(handle, uri, range, text) {\n            const data = this._documents.getDocumentData(uri_1.URI.revive(uri));\n            const ran = extHostTypeConverter.Range.to(range);\n            if (!data || !data.document) {\n                return Promise.resolve(null);\n            }\n            const handlerData = this.getDocumentProvider(handle);\n            return async_1.asPromise(() => {\n                return handlerData.provider.createNewCommentThread(data.document, ran, text, cancellation_1.CancellationToken.None);\n            }).then(commentThread => commentThread ? convertToCommentThread(handlerData.extensionId, handlerData.provider, commentThread, this._commands.converter) : null);\n        }\n        $replyToCommentThread(handle, uri, range, thread, text) {\n            const data = this._documents.getDocumentData(uri_1.URI.revive(uri));\n            const ran = extHostTypeConverter.Range.to(range);\n            if (!data || !data.document) {\n                return Promise.resolve(null);\n            }\n            const handlerData = this.getDocumentProvider(handle);\n            return async_1.asPromise(() => {\n                return handlerData.provider.replyToCommentThread(data.document, ran, convertFromCommentThread(thread), text, cancellation_1.CancellationToken.None);\n            }).then(commentThread => commentThread ? convertToCommentThread(handlerData.extensionId, handlerData.provider, commentThread, this._commands.converter) : null);\n        }\n        $editComment(handle, uri, comment, text) {\n            const document = this._documents.getDocument(uri_1.URI.revive(uri));\n            const handlerData = this.getDocumentProvider(handle);\n            if (!handlerData.provider.editComment) {\n                return Promise.reject(new Error('not implemented'));\n            }\n            return async_1.asPromise(() => {\n                return handlerData.provider.editComment(document, convertFromComment(comment), text, cancellation_1.CancellationToken.None);\n            });\n        }\n        $deleteComment(handle, uri, comment) {\n            const document = this._documents.getDocument(uri_1.URI.revive(uri));\n            const handlerData = this.getDocumentProvider(handle);\n            if (!handlerData.provider.deleteComment) {\n                return Promise.reject(new Error('not implemented'));\n            }\n            return async_1.asPromise(() => {\n                return handlerData.provider.deleteComment(document, convertFromComment(comment), cancellation_1.CancellationToken.None);\n            });\n        }\n        $startDraft(handle, uri) {\n            const document = this._documents.getDocument(uri_1.URI.revive(uri));\n            const handlerData = this.getDocumentProvider(handle);\n            if (!handlerData.provider.startDraft) {\n                return Promise.reject(new Error('not implemented'));\n            }\n            return async_1.asPromise(() => {\n                return handlerData.provider.startDraft(document, cancellation_1.CancellationToken.None);\n            });\n        }\n        $deleteDraft(handle, uri) {\n            const document = this._documents.getDocument(uri_1.URI.revive(uri));\n            const handlerData = this.getDocumentProvider(handle);\n            if (!handlerData.provider.deleteDraft) {\n                return Promise.reject(new Error('not implemented'));\n            }\n            return async_1.asPromise(() => {\n                return handlerData.provider.deleteDraft(document, cancellation_1.CancellationToken.None);\n            });\n        }\n        $finishDraft(handle, uri) {\n            const document = this._documents.getDocument(uri_1.URI.revive(uri));\n            const handlerData = this.getDocumentProvider(handle);\n            if (!handlerData.provider.finishDraft) {\n                return Promise.reject(new Error('not implemented'));\n            }\n            return async_1.asPromise(() => {\n                return handlerData.provider.finishDraft(document, cancellation_1.CancellationToken.None);\n            });\n        }\n        $addReaction(handle, uri, comment, reaction) {\n            const document = this._documents.getDocument(uri_1.URI.revive(uri));\n            const handlerData = this.getDocumentProvider(handle);\n            if (!handlerData.provider.addReaction) {\n                return Promise.reject(new Error('not implemented'));\n            }\n            return async_1.asPromise(() => {\n                return handlerData.provider.addReaction(document, convertFromComment(comment), convertFromReaction(reaction));\n            });\n        }\n        $deleteReaction(handle, uri, comment, reaction) {\n            const document = this._documents.getDocument(uri_1.URI.revive(uri));\n            const handlerData = this.getDocumentProvider(handle);\n            if (!handlerData.provider.deleteReaction) {\n                return Promise.reject(new Error('not implemented'));\n            }\n            return async_1.asPromise(() => {\n                return handlerData.provider.deleteReaction(document, convertFromComment(comment), convertFromReaction(reaction));\n            });\n        }\n        $provideDocumentComments(handle, uri) {\n            const document = this._documents.getDocument(uri_1.URI.revive(uri));\n            const handlerData = this.getDocumentProvider(handle);\n            return async_1.asPromise(() => {\n                return handlerData.provider.provideDocumentComments(document, cancellation_1.CancellationToken.None);\n            }).then(commentInfo => commentInfo ? convertCommentInfo(handle, handlerData.extensionId, handlerData.provider, commentInfo, this._commands.converter) : null);\n        }\n        $provideWorkspaceComments(handle) {\n            const handlerData = this._workspaceProviders.get(handle);\n            if (!handlerData) {\n                return Promise.resolve(null);\n            }\n            return async_1.asPromise(() => {\n                return handlerData.provider.provideWorkspaceComments(cancellation_1.CancellationToken.None);\n            }).then(comments => comments.map(comment => convertToCommentThread(handlerData.extensionId, handlerData.provider, comment, this._commands.converter)));\n        }\n        registerListeners(handle, extensionId, provider) {\n            provider.onDidChangeCommentThreads(event => {\n                this._proxy.$onDidCommentThreadsChange(handle, {\n                    changed: event.changed.map(thread => convertToCommentThread(extensionId, provider, thread, this._commands.converter)),\n                    added: event.added.map(thread => convertToCommentThread(extensionId, provider, thread, this._commands.converter)),\n                    removed: event.removed.map(thread => convertToCommentThread(extensionId, provider, thread, this._commands.converter)),\n                    draftMode: !!provider.startDraft && !!provider.finishDraft ? (event.inDraftMode ? modes.DraftMode.InDraft : modes.DraftMode.NotInDraft) : modes.DraftMode.NotSupported\n                });\n            });\n        }\n        getDocumentProvider(handle) {\n            const provider = this._documentProviders.get(handle);\n            if (!provider) {\n                throw new Error('unknown provider');\n            }\n            return provider;\n        }\n    }\n    ExtHostComments.handlePool = 0;\n    exports.ExtHostComments = ExtHostComments;\n    class ExtHostCommentThread {\n        constructor(_proxy, _commandsConverter, _commentController, _threadId, _resource, _range, _comments) {\n            this._proxy = _proxy;\n            this._commandsConverter = _commandsConverter;\n            this._commentController = _commentController;\n            this._threadId = _threadId;\n            this._resource = _resource;\n            this._range = _range;\n            this._comments = _comments;\n            this.handle = ExtHostCommentThread._handlePool++;\n            this._additionalCommands = [];\n            this._proxy.$createCommentThread(this._commentController.handle, this.handle, this._threadId, this._resource, extHostTypeConverter.Range.from(this._range), this._comments.map(comment => { return convertToModeComment(this._commentController, comment, this._commandsConverter); }), this._acceptInputCommand ? this._commandsConverter.toInternal(this._acceptInputCommand) : undefined, this._additionalCommands ? this._additionalCommands.map(x => this._commandsConverter.toInternal(x)) : [], this._deleteCommand ? this._commandsConverter.toInternal(this._deleteCommand) : undefined, this._collapseState);\n        }\n        get threadId() {\n            return this._threadId;\n        }\n        get resource() {\n            return this._resource;\n        }\n        set range(range) {\n            if (range.isEqual(this._range)) {\n                this._range = range;\n                this._proxy.$updateCommentThreadRange(this._commentController.handle, this.handle, extHostTypeConverter.Range.from(this._range));\n            }\n        }\n        get range() {\n            return this._range;\n        }\n        get label() {\n            return this._label;\n        }\n        set label(label) {\n            this._label = label;\n            this._proxy.$updateCommentThreadLabel(this._commentController.handle, this.handle, this._label);\n        }\n        get comments() {\n            return this._comments;\n        }\n        set comments(newComments) {\n            this._proxy.$updateComments(this._commentController.handle, this.handle, newComments.map(cmt => { return convertToModeComment(this._commentController, cmt, this._commandsConverter); }));\n            this._comments = newComments;\n        }\n        get acceptInputCommand() {\n            return this._acceptInputCommand;\n        }\n        set acceptInputCommand(acceptInputCommand) {\n            this._acceptInputCommand = acceptInputCommand;\n            const internal = this._commandsConverter.toInternal(acceptInputCommand);\n            this._proxy.$updateCommentThreadAcceptInputCommand(this._commentController.handle, this.handle, internal);\n        }\n        get additionalCommands() {\n            return this._additionalCommands;\n        }\n        set additionalCommands(additionalCommands) {\n            this._additionalCommands = additionalCommands;\n            const internals = additionalCommands.map(x => this._commandsConverter.toInternal(x));\n            this._proxy.$updateCommentThreadAdditionalCommands(this._commentController.handle, this.handle, internals);\n        }\n        get deleteComand() {\n            return this._deleteCommand;\n        }\n        set deleteCommand(deleteCommand) {\n            this._deleteCommand = deleteCommand;\n            const internal = this._commandsConverter.toInternal(deleteCommand);\n            this._proxy.$updateCommentThreadDeleteCommand(this._commentController.handle, this.handle, internal);\n        }\n        get collapsibleState() {\n            return this._collapseState;\n        }\n        set collapsibleState(newState) {\n            this._collapseState = newState;\n            this._proxy.$updateCommentThreadCollapsibleState(this._commentController.handle, this.handle, convertToCollapsibleState(newState));\n        }\n        getComment(commentId) {\n            const comments = this._comments.filter(comment => comment.commentId === commentId);\n            if (comments && comments.length) {\n                return comments[0];\n            }\n            return undefined;\n        }\n        dispose() {\n            this._proxy.$deleteCommentThread(this._commentController.handle, this.handle);\n        }\n    }\n    ExtHostCommentThread._handlePool = 0;\n    exports.ExtHostCommentThread = ExtHostCommentThread;\n    class ExtHostCommentInputBox {\n        constructor(_proxy, commentControllerHandle, input) {\n            this._proxy = _proxy;\n            this.commentControllerHandle = commentControllerHandle;\n            this._onDidChangeValue = new event_1.Emitter();\n            this._value = '';\n            this._value = input;\n        }\n        get onDidChangeValue() {\n            return this._onDidChangeValue.event;\n        }\n        get value() {\n            return this._value;\n        }\n        set value(newInput) {\n            this._value = newInput;\n            this._onDidChangeValue.fire(this._value);\n            this._proxy.$setInputValue(this.commentControllerHandle, newInput);\n        }\n        setInput(input) {\n            this._value = input;\n        }\n    }\n    exports.ExtHostCommentInputBox = ExtHostCommentInputBox;\n    class ExtHostCommentController {\n        constructor(_extension, _handle, _commandsConverter, _proxy, _id, _label) {\n            this._handle = _handle;\n            this._commandsConverter = _commandsConverter;\n            this._proxy = _proxy;\n            this._id = _id;\n            this._label = _label;\n            this._threads = new Map();\n            this._proxy.$registerCommentController(this.handle, _id, _label);\n        }\n        get id() {\n            return this._id;\n        }\n        get label() {\n            return this._label;\n        }\n        get handle() {\n            return this._handle;\n        }\n        get reactionProvider() {\n            return this._commentReactionProvider;\n        }\n        set reactionProvider(provider) {\n            this._commentReactionProvider = provider;\n            if (provider) {\n                this._proxy.$updateCommentControllerFeatures(this.handle, { reactionGroup: provider.availableReactions.map(reaction => convertToReaction2(provider, reaction)) });\n            }\n        }\n        createCommentThread(id, resource, range, comments) {\n            const commentThread = new ExtHostCommentThread(this._proxy, this._commandsConverter, this, id, resource, range, comments);\n            this._threads.set(commentThread.handle, commentThread);\n            return commentThread;\n        }\n        $onCommentWidgetInputChange(input) {\n            if (!this.inputBox) {\n                this.inputBox = new ExtHostCommentInputBox(this._proxy, this.handle, input);\n            }\n            else {\n                this.inputBox.setInput(input);\n            }\n        }\n        getCommentThread(handle) {\n            return this._threads.get(handle);\n        }\n        dispose() {\n            this._threads.forEach(value => {\n                value.dispose();\n            });\n            this._proxy.$unregisterCommentController(this.handle);\n        }\n    }\n    function convertCommentInfo(owner, extensionId, provider, vscodeCommentInfo, commandsConverter) {\n        return {\n            extensionId: extensionId.value,\n            threads: vscodeCommentInfo.threads.map(x => convertToCommentThread(extensionId, provider, x, commandsConverter)),\n            commentingRanges: vscodeCommentInfo.commentingRanges ? vscodeCommentInfo.commentingRanges.map(range => extHostTypeConverter.Range.from(range)) : [],\n            draftMode: provider.startDraft && provider.finishDraft ? (vscodeCommentInfo.inDraftMode ? modes.DraftMode.InDraft : modes.DraftMode.NotInDraft) : modes.DraftMode.NotSupported\n        };\n    }\n    function convertToCommentThread(extensionId, provider, vscodeCommentThread, commandsConverter) {\n        return {\n            extensionId: extensionId.value,\n            threadId: vscodeCommentThread.threadId,\n            resource: vscodeCommentThread.resource.toString(),\n            range: extHostTypeConverter.Range.from(vscodeCommentThread.range),\n            comments: vscodeCommentThread.comments.map(comment => convertToComment(provider, comment, commandsConverter)),\n            collapsibleState: vscodeCommentThread.collapsibleState\n        };\n    }\n    function convertFromCommentThread(commentThread) {\n        return {\n            threadId: commentThread.threadId,\n            resource: uri_1.URI.parse(commentThread.resource),\n            range: extHostTypeConverter.Range.to(commentThread.range),\n            comments: commentThread.comments.map(convertFromComment),\n            collapsibleState: commentThread.collapsibleState\n        };\n    }\n    function convertFromComment(comment) {\n        let userIconPath;\n        if (comment.userIconPath) {\n            try {\n                userIconPath = uri_1.URI.parse(comment.userIconPath);\n            }\n            catch (e) {\n                // Ignore\n            }\n        }\n        return {\n            commentId: comment.commentId,\n            body: extHostTypeConverter.MarkdownString.to(comment.body),\n            userName: comment.userName,\n            userIconPath: userIconPath,\n            canEdit: comment.canEdit,\n            canDelete: comment.canDelete,\n            isDraft: comment.isDraft,\n            commentReactions: comment.commentReactions ? comment.commentReactions.map(reaction => {\n                return {\n                    label: reaction.label,\n                    count: reaction.count,\n                    hasReacted: reaction.hasReacted\n                };\n            }) : undefined\n        };\n    }\n    function convertToModeComment(commentController, vscodeComment, commandsConverter) {\n        const iconPath = vscodeComment.userIconPath ? vscodeComment.userIconPath.toString() : vscodeComment.gravatar;\n        return {\n            commentId: vscodeComment.commentId,\n            body: extHostTypeConverter.MarkdownString.from(vscodeComment.body),\n            userName: vscodeComment.userName,\n            userIconPath: iconPath,\n            isDraft: vscodeComment.isDraft,\n            selectCommand: vscodeComment.selectCommand ? commandsConverter.toInternal(vscodeComment.selectCommand) : undefined,\n            editCommand: vscodeComment.editCommand ? commandsConverter.toInternal(vscodeComment.editCommand) : undefined,\n            deleteCommand: vscodeComment.deleteCommand ? commandsConverter.toInternal(vscodeComment.deleteCommand) : undefined,\n            label: vscodeComment.label,\n            commentReactions: vscodeComment.commentReactions ? vscodeComment.commentReactions.map(reaction => convertToReaction2(commentController.reactionProvider, reaction)) : undefined\n        };\n    }\n    function convertToComment(provider, vscodeComment, commandsConverter) {\n        const canEdit = !!provider.editComment && vscodeComment.canEdit;\n        const canDelete = !!provider.deleteComment && vscodeComment.canDelete;\n        const iconPath = vscodeComment.userIconPath ? vscodeComment.userIconPath.toString() : vscodeComment.gravatar;\n        return {\n            commentId: vscodeComment.commentId,\n            body: extHostTypeConverter.MarkdownString.from(vscodeComment.body),\n            userName: vscodeComment.userName,\n            userIconPath: iconPath,\n            canEdit: canEdit,\n            canDelete: canDelete,\n            selectCommand: vscodeComment.command ? commandsConverter.toInternal(vscodeComment.command) : undefined,\n            isDraft: vscodeComment.isDraft,\n            commentReactions: vscodeComment.commentReactions ? vscodeComment.commentReactions.map(reaction => convertToReaction(provider, reaction)) : undefined\n        };\n    }\n    function convertToReaction(provider, reaction) {\n        const providerCanDeleteReaction = !!provider.deleteReaction;\n        const providerCanAddReaction = !!provider.addReaction;\n        return {\n            label: reaction.label,\n            iconPath: reaction.iconPath ? extHostTypeConverter.pathOrURIToURI(reaction.iconPath) : undefined,\n            count: reaction.count,\n            hasReacted: reaction.hasReacted,\n            canEdit: (reaction.hasReacted && providerCanDeleteReaction) || (!reaction.hasReacted && providerCanAddReaction)\n        };\n    }\n    function convertToReaction2(provider, reaction) {\n        return {\n            label: reaction.label,\n            iconPath: reaction.iconPath ? extHostTypeConverter.pathOrURIToURI(reaction.iconPath) : undefined,\n            count: reaction.count,\n            hasReacted: reaction.hasReacted,\n            canEdit: provider !== undefined ? !!provider.toggleReaction : false\n        };\n    }\n    function convertFromReaction(reaction) {\n        return {\n            label: reaction.label,\n            count: reaction.count,\n            hasReacted: reaction.hasReacted\n        };\n    }\n    function convertToCollapsibleState(kind) {\n        if (kind !== undefined) {\n            switch (kind) {\n                case types.CommentThreadCollapsibleState.Expanded:\n                    return modes.CommentThreadCollapsibleState.Expanded;\n                case types.CommentThreadCollapsibleState.Collapsed:\n                    return modes.CommentThreadCollapsibleState.Collapsed;\n            }\n        }\n        return modes.CommentThreadCollapsibleState.Collapsed;\n    }\n});\n",null]}