{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/colorPicker/colorDetector.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/colorPicker/colorDetector.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/async\", \"vs/base/common/color\", \"vs/base/common/errors\", \"vs/base/common/hash\", \"vs/base/common/lifecycle\", \"vs/editor/browser/editorExtensions\", \"vs/editor/browser/services/codeEditorService\", \"vs/editor/common/core/range\", \"vs/editor/common/model/textModel\", \"vs/editor/common/modes\", \"vs/editor/contrib/colorPicker/color\", \"vs/platform/configuration/common/configuration\"], function (require, exports, async_1, color_1, errors_1, hash_1, lifecycle_1, editorExtensions_1, codeEditorService_1, range_1, textModel_1, modes_1, color_2, configuration_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const MAX_DECORATORS = 500;\n    let ColorDetector = class ColorDetector {\n        constructor(_editor, _codeEditorService, _configurationService) {\n            this._editor = _editor;\n            this._codeEditorService = _codeEditorService;\n            this._configurationService = _configurationService;\n            this._globalToDispose = [];\n            this._localToDispose = [];\n            this._decorationsIds = [];\n            this._colorDatas = new Map();\n            this._colorDecoratorIds = [];\n            this._decorationsTypes = {};\n            this._globalToDispose.push(_editor.onDidChangeModel((e) => {\n                this._isEnabled = this.isEnabled();\n                this.onModelChanged();\n            }));\n            this._globalToDispose.push(_editor.onDidChangeModelLanguage((e) => this.onModelChanged()));\n            this._globalToDispose.push(modes_1.ColorProviderRegistry.onDidChange((e) => this.onModelChanged()));\n            this._globalToDispose.push(_editor.onDidChangeConfiguration((e) => {\n                let prevIsEnabled = this._isEnabled;\n                this._isEnabled = this.isEnabled();\n                if (prevIsEnabled !== this._isEnabled) {\n                    if (this._isEnabled) {\n                        this.onModelChanged();\n                    }\n                    else {\n                        this.removeAllDecorations();\n                    }\n                }\n            }));\n            this._timeoutTimer = null;\n            this._computePromise = null;\n            this._isEnabled = this.isEnabled();\n            this.onModelChanged();\n        }\n        isEnabled() {\n            const model = this._editor.getModel();\n            if (!model) {\n                return false;\n            }\n            const languageId = model.getLanguageIdentifier();\n            // handle deprecated settings. [languageId].colorDecorators.enable\n            let deprecatedConfig = this._configurationService.getValue(languageId.language);\n            if (deprecatedConfig) {\n                let colorDecorators = deprecatedConfig['colorDecorators']; // deprecatedConfig.valueOf('.colorDecorators.enable');\n                if (colorDecorators && colorDecorators['enable'] !== undefined && !colorDecorators['enable']) {\n                    return colorDecorators['enable'];\n                }\n            }\n            return this._editor.getConfiguration().contribInfo.colorDecorators;\n        }\n        getId() {\n            return ColorDetector.ID;\n        }\n        static get(editor) {\n            return editor.getContribution(this.ID);\n        }\n        dispose() {\n            this.stop();\n            this.removeAllDecorations();\n            this._globalToDispose = lifecycle_1.dispose(this._globalToDispose);\n        }\n        onModelChanged() {\n            this.stop();\n            if (!this._isEnabled) {\n                return;\n            }\n            const model = this._editor.getModel();\n            if (!model || !modes_1.ColorProviderRegistry.has(model)) {\n                return;\n            }\n            this._localToDispose.push(this._editor.onDidChangeModelContent((e) => {\n                if (!this._timeoutTimer) {\n                    this._timeoutTimer = new async_1.TimeoutTimer();\n                    this._timeoutTimer.cancelAndSet(() => {\n                        this._timeoutTimer = null;\n                        this.beginCompute();\n                    }, ColorDetector.RECOMPUTE_TIME);\n                }\n            }));\n            this.beginCompute();\n        }\n        beginCompute() {\n            this._computePromise = async_1.createCancelablePromise(token => {\n                const model = this._editor.getModel();\n                if (!model) {\n                    return Promise.resolve([]);\n                }\n                return color_2.getColors(model, token);\n            });\n            this._computePromise.then((colorInfos) => {\n                this.updateDecorations(colorInfos);\n                this.updateColorDecorators(colorInfos);\n                this._computePromise = null;\n            }, errors_1.onUnexpectedError);\n        }\n        stop() {\n            if (this._timeoutTimer) {\n                this._timeoutTimer.cancel();\n                this._timeoutTimer = null;\n            }\n            if (this._computePromise) {\n                this._computePromise.cancel();\n                this._computePromise = null;\n            }\n            this._localToDispose = lifecycle_1.dispose(this._localToDispose);\n        }\n        updateDecorations(colorDatas) {\n            const decorations = colorDatas.map(c => ({\n                range: {\n                    startLineNumber: c.colorInfo.range.startLineNumber,\n                    startColumn: c.colorInfo.range.startColumn,\n                    endLineNumber: c.colorInfo.range.endLineNumber,\n                    endColumn: c.colorInfo.range.endColumn\n                },\n                options: textModel_1.ModelDecorationOptions.EMPTY\n            }));\n            this._decorationsIds = this._editor.deltaDecorations(this._decorationsIds, decorations);\n            this._colorDatas = new Map();\n            this._decorationsIds.forEach((id, i) => this._colorDatas.set(id, colorDatas[i]));\n        }\n        updateColorDecorators(colorData) {\n            let decorations = [];\n            let newDecorationsTypes = {};\n            for (let i = 0; i < colorData.length && decorations.length < MAX_DECORATORS; i++) {\n                const { red, green, blue, alpha } = colorData[i].colorInfo.color;\n                const rgba = new color_1.RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);\n                let subKey = hash_1.hash(rgba).toString(16);\n                let color = `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;\n                let key = 'colorBox-' + subKey;\n                if (!this._decorationsTypes[key] && !newDecorationsTypes[key]) {\n                    this._codeEditorService.registerDecorationType(key, {\n                        before: {\n                            contentText: ' ',\n                            border: 'solid 0.1em #000',\n                            margin: '0.1em 0.2em 0 0.2em',\n                            width: '0.8em',\n                            height: '0.8em',\n                            backgroundColor: color\n                        },\n                        dark: {\n                            before: {\n                                border: 'solid 0.1em #eee'\n                            }\n                        }\n                    });\n                }\n                newDecorationsTypes[key] = true;\n                decorations.push({\n                    range: {\n                        startLineNumber: colorData[i].colorInfo.range.startLineNumber,\n                        startColumn: colorData[i].colorInfo.range.startColumn,\n                        endLineNumber: colorData[i].colorInfo.range.endLineNumber,\n                        endColumn: colorData[i].colorInfo.range.endColumn\n                    },\n                    options: this._codeEditorService.resolveDecorationOptions(key, true)\n                });\n            }\n            for (let subType in this._decorationsTypes) {\n                if (!newDecorationsTypes[subType]) {\n                    this._codeEditorService.removeDecorationType(subType);\n                }\n            }\n            this._colorDecoratorIds = this._editor.deltaDecorations(this._colorDecoratorIds, decorations);\n        }\n        removeAllDecorations() {\n            this._decorationsIds = this._editor.deltaDecorations(this._decorationsIds, []);\n            this._colorDecoratorIds = this._editor.deltaDecorations(this._colorDecoratorIds, []);\n            for (let subType in this._decorationsTypes) {\n                this._codeEditorService.removeDecorationType(subType);\n            }\n        }\n        getColorData(position) {\n            const model = this._editor.getModel();\n            if (!model) {\n                return null;\n            }\n            const decorations = model\n                .getDecorationsInRange(range_1.Range.fromPositions(position, position))\n                .filter(d => this._colorDatas.has(d.id));\n            if (decorations.length === 0) {\n                return null;\n            }\n            return this._colorDatas.get(decorations[0].id);\n        }\n    };\n    ColorDetector.ID = 'editor.contrib.colorDetector';\n    ColorDetector.RECOMPUTE_TIME = 1000; // ms\n    ColorDetector = __decorate([\n        __param(1, codeEditorService_1.ICodeEditorService),\n        __param(2, configuration_1.IConfigurationService)\n    ], ColorDetector);\n    exports.ColorDetector = ColorDetector;\n    editorExtensions_1.registerEditorContribution(ColorDetector);\n});\n",null]}