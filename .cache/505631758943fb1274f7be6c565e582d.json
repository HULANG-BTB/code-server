{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/output/common/outputLinkComputer.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/output/common/outputLinkComputer.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/uri\", \"vs/base/common/extpath\", \"vs/base/common/resources\", \"vs/base/common/strings\", \"vs/editor/common/core/range\", \"vs/base/common/platform\", \"vs/base/common/network\"], function (require, exports, uri_1, extpath, resources, strings, range_1, platform_1, network_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class OutputLinkComputer {\n        constructor(ctx, createData) {\n            this.ctx = ctx;\n            this.patterns = new Map();\n            this.computePatterns(createData);\n        }\n        computePatterns(createData) {\n            // Produce patterns for each workspace root we are configured with\n            // This means that we will be able to detect links for paths that\n            // contain any of the workspace roots as segments.\n            const workspaceFolders = createData.workspaceFolders.map(r => uri_1.URI.parse(r));\n            workspaceFolders.forEach(workspaceFolder => {\n                const patterns = OutputLinkComputer.createPatterns(workspaceFolder);\n                this.patterns.set(workspaceFolder, patterns);\n            });\n        }\n        getModel(uri) {\n            const models = this.ctx.getMirrorModels();\n            for (const model of models) {\n                if (model.uri.toString() === uri) {\n                    return model;\n                }\n            }\n            return null;\n        }\n        computeLinks(uri) {\n            const model = this.getModel(uri);\n            if (!model) {\n                return Promise.resolve([]);\n            }\n            const links = [];\n            const lines = model.getValue().split(/\\r\\n|\\r|\\n/);\n            // For each workspace root patterns\n            this.patterns.forEach((folderPatterns, folderUri) => {\n                const resourceCreator = {\n                    toResource: (folderRelativePath) => {\n                        if (typeof folderRelativePath === 'string') {\n                            return resources.joinPath(folderUri, folderRelativePath);\n                        }\n                        return null;\n                    }\n                };\n                for (let i = 0, len = lines.length; i < len; i++) {\n                    links.push(...OutputLinkComputer.detectLinks(lines[i], i + 1, folderPatterns, resourceCreator));\n                }\n            });\n            return Promise.resolve(links);\n        }\n        static createPatterns(workspaceFolder) {\n            const patterns = [];\n            const workspaceFolderPath = workspaceFolder.scheme === network_1.Schemas.file ? workspaceFolder.fsPath : workspaceFolder.path;\n            const workspaceFolderVariants = [workspaceFolderPath];\n            if (platform_1.isWindows && workspaceFolder.scheme === network_1.Schemas.file) {\n                workspaceFolderVariants.push(extpath.toSlashes(workspaceFolderPath));\n            }\n            workspaceFolderVariants.forEach(workspaceFolderVariant => {\n                const validPathCharacterPattern = '[^\\\\s\\\\(\\\\):<>\"]';\n                const validPathCharacterOrSpacePattern = `(?:${validPathCharacterPattern}| ${validPathCharacterPattern})`;\n                const pathPattern = `${validPathCharacterOrSpacePattern}+\\\\.${validPathCharacterPattern}+`;\n                const strictPathPattern = `${validPathCharacterPattern}+`;\n                // Example: /workspaces/express/server.js on line 8, column 13\n                patterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${pathPattern}) on line ((\\\\d+)(, column (\\\\d+))?)`, 'gi'));\n                // Example: /workspaces/express/server.js:line 8, column 13\n                patterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${pathPattern}):line ((\\\\d+)(, column (\\\\d+))?)`, 'gi'));\n                // Example: /workspaces/mankala/Features.ts(45): error\n                // Example: /workspaces/mankala/Features.ts (45): error\n                // Example: /workspaces/mankala/Features.ts(45,18): error\n                // Example: /workspaces/mankala/Features.ts (45,18): error\n                // Example: /workspaces/mankala/Features Special.ts (45,18): error\n                patterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${pathPattern})(\\\\s?\\\\((\\\\d+)(,(\\\\d+))?)\\\\)`, 'gi'));\n                // Example: at /workspaces/mankala/Game.ts\n                // Example: at /workspaces/mankala/Game.ts:336\n                // Example: at /workspaces/mankala/Game.ts:336:9\n                patterns.push(new RegExp(strings.escapeRegExpCharacters(workspaceFolderVariant) + `(${strictPathPattern})(:(\\\\d+))?(:(\\\\d+))?`, 'gi'));\n            });\n            return patterns;\n        }\n        /**\n         * Detect links. Made public static to allow for tests.\n         */\n        static detectLinks(line, lineIndex, patterns, resourceCreator) {\n            const links = [];\n            patterns.forEach(pattern => {\n                pattern.lastIndex = 0; // the holy grail of software development\n                let match;\n                let offset = 0;\n                while ((match = pattern.exec(line)) !== null) {\n                    // Convert the relative path information to a resource that we can use in links\n                    const folderRelativePath = strings.rtrim(match[1], '.').replace(/\\\\/g, '/'); // remove trailing \".\" that likely indicate end of sentence\n                    let resourceString;\n                    try {\n                        const resource = resourceCreator.toResource(folderRelativePath);\n                        if (resource) {\n                            resourceString = resource.toString();\n                        }\n                    }\n                    catch (error) {\n                        continue; // we might find an invalid URI and then we dont want to loose all other links\n                    }\n                    // Append line/col information to URI if matching\n                    if (match[3]) {\n                        const lineNumber = match[3];\n                        if (match[5]) {\n                            const columnNumber = match[5];\n                            resourceString = strings.format('{0}#{1},{2}', resourceString, lineNumber, columnNumber);\n                        }\n                        else {\n                            resourceString = strings.format('{0}#{1}', resourceString, lineNumber);\n                        }\n                    }\n                    const fullMatch = strings.rtrim(match[0], '.'); // remove trailing \".\" that likely indicate end of sentence\n                    const index = line.indexOf(fullMatch, offset);\n                    offset += index + fullMatch.length;\n                    const linkRange = {\n                        startColumn: index + 1,\n                        startLineNumber: lineIndex,\n                        endColumn: index + 1 + fullMatch.length,\n                        endLineNumber: lineIndex\n                    };\n                    if (links.some(link => range_1.Range.areIntersectingOrTouching(link.range, linkRange))) {\n                        return; // Do not detect duplicate links\n                    }\n                    links.push({\n                        range: linkRange,\n                        url: resourceString\n                    });\n                }\n            });\n            return links;\n        }\n    }\n    exports.OutputLinkComputer = OutputLinkComputer;\n    function create(ctx, createData) {\n        return new OutputLinkComputer(ctx, createData);\n    }\n    exports.create = create;\n});\n",null]}