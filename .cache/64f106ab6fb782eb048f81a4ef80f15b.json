{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/model/indentationGuesser.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/indentationGuesser.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar SpacesDiffResult = /** @class */ (function () {\n    function SpacesDiffResult() {\n    }\n    return SpacesDiffResult;\n}());\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    var i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        var aCharCode = a.charCodeAt(i);\n        var bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    var aSpacesCnt = 0, aTabsCount = 0;\n    for (var j = i; j < aLength; j++) {\n        var aCharCode = a.charCodeAt(j);\n        if (aCharCode === charCode_1.CharCode.Space) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    var bSpacesCnt = 0, bTabsCount = 0;\n    for (var j = i; j < bLength; j++) {\n        var bCharCode = b.charCodeAt(j);\n        if (bCharCode === charCode_1.CharCode.Space) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    var tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    var spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== charCode_1.CharCode.Space && a.charCodeAt(bSpacesCnt - 1) === charCode_1.CharCode.Space) {\n                // This looks like an alignment desire: e.g.\n                // const a = b + c,\n                //       d = b - c;\n                result.looksLikeAlignment = true;\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nfunction guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    var linesCount = Math.min(source.getLineCount(), 10000);\n    var linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    var linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    var previousLineText = ''; // content of latest line that contained non-whitespace chars\n    var previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    var ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    var MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    var spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    var tmp = new SpacesDiffResult();\n    for (var lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        var currentLineLength = source.getLineLength(lineNumber);\n        var currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        var useCurrentLineText = (currentLineLength <= 65536);\n        var currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        var currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        var currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        var currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (var j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            var charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === charCode_1.CharCode.Tab) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === charCode_1.CharCode.Space) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // skip this line entirely\n            continue;\n        }\n        var currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    var insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    var tabSize = defaultTabSize;\n    var tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n    // console.log(\"score threshold: \" + tabSizeScore);\n    ALLOWED_TAB_SIZE_GUESSES.forEach(function (possibleTabSize) {\n        var possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n        if (possibleTabSizeScore > tabSizeScore) {\n            tabSizeScore = possibleTabSizeScore;\n            tabSize = possibleTabSize;\n        }\n    });\n    // Let a tabSize of 2 win even if it is not the maximum\n    // (only in case 4 was guessed)\n    if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n        tabSize = 2;\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\nexports.guessIndentation = guessIndentation;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/indentationGuesser.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/model/indentationGuesser.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { ITextBuffer } from 'vs/editor/common/model';\n\nclass SpacesDiffResult {\n\tpublic spacesDiff: number;\n\tpublic looksLikeAlignment: boolean;\n}\n\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a: string, aLength: number, b: string, bLength: number, result: SpacesDiffResult): void {\n\n\tresult.spacesDiff = 0;\n\tresult.looksLikeAlignment = false;\n\n\t// This can go both ways (e.g.):\n\t//  - a: \"\\t\"\n\t//  - b: \"\\t    \"\n\t//  => This should count 1 tab and 4 spaces\n\n\tlet i: number;\n\n\tfor (i = 0; i < aLength && i < bLength; i++) {\n\t\tlet aCharCode = a.charCodeAt(i);\n\t\tlet bCharCode = b.charCodeAt(i);\n\n\t\tif (aCharCode !== bCharCode) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlet aSpacesCnt = 0, aTabsCount = 0;\n\tfor (let j = i; j < aLength; j++) {\n\t\tlet aCharCode = a.charCodeAt(j);\n\t\tif (aCharCode === CharCode.Space) {\n\t\t\taSpacesCnt++;\n\t\t} else {\n\t\t\taTabsCount++;\n\t\t}\n\t}\n\n\tlet bSpacesCnt = 0, bTabsCount = 0;\n\tfor (let j = i; j < bLength; j++) {\n\t\tlet bCharCode = b.charCodeAt(j);\n\t\tif (bCharCode === CharCode.Space) {\n\t\t\tbSpacesCnt++;\n\t\t} else {\n\t\t\tbTabsCount++;\n\t\t}\n\t}\n\n\tif (aSpacesCnt > 0 && aTabsCount > 0) {\n\t\treturn;\n\t}\n\tif (bSpacesCnt > 0 && bTabsCount > 0) {\n\t\treturn;\n\t}\n\n\tlet tabsDiff = Math.abs(aTabsCount - bTabsCount);\n\tlet spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n\n\tif (tabsDiff === 0) {\n\t\t// check if the indentation difference might be caused by alignment reasons\n\t\t// sometime folks like to align their code, but this should not be used as a hint\n\t\tresult.spacesDiff = spacesDiff;\n\n\t\tif (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n\t\t\tif (b.charCodeAt(bSpacesCnt) !== CharCode.Space && a.charCodeAt(bSpacesCnt - 1) === CharCode.Space) {\n\t\t\t\t// This looks like an alignment desire: e.g.\n\t\t\t\t// const a = b + c,\n\t\t\t\t//       d = b - c;\n\n\t\t\t\tresult.looksLikeAlignment = true;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tif (spacesDiff % tabsDiff === 0) {\n\t\tresult.spacesDiff = spacesDiff / tabsDiff;\n\t\treturn;\n\t}\n}\n\n/**\n * Result for a guessIndentation\n */\nexport interface IGuessedIndentation {\n\t/**\n\t * If indentation is based on spaces (`insertSpaces` = true), then what is the number of spaces that make an indent?\n\t */\n\ttabSize: number;\n\t/**\n\t * Is indentation based on spaces?\n\t */\n\tinsertSpaces: boolean;\n}\n\nexport function guessIndentation(source: ITextBuffer, defaultTabSize: number, defaultInsertSpaces: boolean): IGuessedIndentation {\n\t// Look at most at the first 10k lines\n\tconst linesCount = Math.min(source.getLineCount(), 10000);\n\n\tlet linesIndentedWithTabsCount = 0;\t\t\t\t// number of lines that contain at least one tab in indentation\n\tlet linesIndentedWithSpacesCount = 0;\t\t\t// number of lines that contain only spaces in indentation\n\n\tlet previousLineText = '';\t\t\t\t\t\t// content of latest line that contained non-whitespace chars\n\tlet previousLineIndentation = 0;\t\t\t\t// index at which latest line contained the first non-whitespace char\n\n\tconst ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7];\t// prefer even guesses for `tabSize`, limit to [2, 8].\n\tconst MAX_ALLOWED_TAB_SIZE_GUESS = 8;\t\t\t// max(ALLOWED_TAB_SIZE_GUESSES) = 8\n\n\tlet spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0];\t\t// `tabSize` scores\n\tlet tmp = new SpacesDiffResult();\n\n\tfor (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n\t\tlet currentLineLength = source.getLineLength(lineNumber);\n\t\tlet currentLineText = source.getLineContent(lineNumber);\n\n\t\t// if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n\t\t// checking charCode on chunks directly is cheaper.\n\t\tconst useCurrentLineText = (currentLineLength <= 65536);\n\n\t\tlet currentLineHasContent = false;\t\t\t// does `currentLineText` contain non-whitespace chars\n\t\tlet currentLineIndentation = 0;\t\t\t\t// index at which `currentLineText` contains the first non-whitespace char\n\t\tlet currentLineSpacesCount = 0;\t\t\t\t// count of spaces found in `currentLineText` indentation\n\t\tlet currentLineTabsCount = 0;\t\t\t\t// count of tabs found in `currentLineText` indentation\n\t\tfor (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n\t\t\tlet charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n\n\t\t\tif (charCode === CharCode.Tab) {\n\t\t\t\tcurrentLineTabsCount++;\n\t\t\t} else if (charCode === CharCode.Space) {\n\t\t\t\tcurrentLineSpacesCount++;\n\t\t\t} else {\n\t\t\t\t// Hit non whitespace character on this line\n\t\t\t\tcurrentLineHasContent = true;\n\t\t\t\tcurrentLineIndentation = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Ignore empty or only whitespace lines\n\t\tif (!currentLineHasContent) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (currentLineTabsCount > 0) {\n\t\t\tlinesIndentedWithTabsCount++;\n\t\t} else if (currentLineSpacesCount > 1) {\n\t\t\tlinesIndentedWithSpacesCount++;\n\t\t}\n\n\t\tspacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n\n\t\tif (tmp.looksLikeAlignment) {\n\t\t\t// skip this line entirely\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet currentSpacesDiff = tmp.spacesDiff;\n\t\tif (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n\t\t\tspacesDiffCount[currentSpacesDiff]++;\n\t\t}\n\n\t\tpreviousLineText = currentLineText;\n\t\tpreviousLineIndentation = currentLineIndentation;\n\t}\n\n\tlet insertSpaces = defaultInsertSpaces;\n\tif (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n\t\tinsertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n\t}\n\n\tlet tabSize = defaultTabSize;\n\tlet tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n\n\t// console.log(\"score threshold: \" + tabSizeScore);\n\n\tALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n\t\tlet possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n\t\tif (possibleTabSizeScore > tabSizeScore) {\n\t\t\ttabSizeScore = possibleTabSizeScore;\n\t\t\ttabSize = possibleTabSize;\n\t\t}\n\t});\n\n\t// Let a tabSize of 2 win even if it is not the maximum\n\t// (only in case 4 was guessed)\n\tif (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n\t\ttabSize = 2;\n\t}\n\n\n\t// console.log('--------------------------');\n\t// console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n\t// console.log('spacesDiffCount: ' + spacesDiffCount);\n\t// console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n\n\treturn {\n\t\tinsertSpaces: insertSpaces,\n\t\ttabSize: tabSize\n\t};\n}\n"]}]}