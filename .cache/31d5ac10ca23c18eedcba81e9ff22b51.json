{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/browser/terminalCommandTracker.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/browser/terminalCommandTracker.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The minimum size of the prompt in which to assume the line is a command.\n */\nvar MINIMUM_PROMPT_LENGTH = 2;\nvar Boundary;\n(function (Boundary) {\n    Boundary[Boundary[\"Top\"] = 0] = \"Top\";\n    Boundary[Boundary[\"Bottom\"] = 1] = \"Bottom\";\n})(Boundary || (Boundary = {}));\nvar ScrollPosition;\n(function (ScrollPosition) {\n    ScrollPosition[ScrollPosition[\"Top\"] = 0] = \"Top\";\n    ScrollPosition[ScrollPosition[\"Middle\"] = 1] = \"Middle\";\n})(ScrollPosition = exports.ScrollPosition || (exports.ScrollPosition = {}));\nvar TerminalCommandTracker = /** @class */ (function () {\n    function TerminalCommandTracker(_xterm) {\n        var _this = this;\n        this._xterm = _xterm;\n        this._currentMarker = Boundary.Bottom;\n        this._selectionStart = null;\n        this._isDisposable = false;\n        this._xterm.on('key', function (key) { return _this._onKey(key); });\n    }\n    TerminalCommandTracker.prototype.dispose = function () {\n    };\n    TerminalCommandTracker.prototype._onKey = function (key) {\n        if (key === '\\x0d') {\n            this._onEnter();\n        }\n        // Clear the current marker so successive focus/selection actions are performed from the\n        // bottom of the buffer\n        this._currentMarker = Boundary.Bottom;\n        this._selectionStart = null;\n    };\n    TerminalCommandTracker.prototype._onEnter = function () {\n        if (this._xterm._core.buffer.x >= MINIMUM_PROMPT_LENGTH) {\n            this._xterm.addMarker(0);\n        }\n    };\n    TerminalCommandTracker.prototype.scrollToPreviousCommand = function (scrollPosition, retainSelection) {\n        if (scrollPosition === void 0) { scrollPosition = ScrollPosition.Top; }\n        if (retainSelection === void 0) { retainSelection = false; }\n        if (!retainSelection) {\n            this._selectionStart = null;\n        }\n        var markerIndex;\n        if (this._currentMarker === Boundary.Bottom) {\n            markerIndex = this._xterm.markers.length - 1;\n        }\n        else if (this._currentMarker === Boundary.Top) {\n            markerIndex = -1;\n        }\n        else if (this._isDisposable) {\n            markerIndex = this._findPreviousCommand();\n            this._currentMarker.dispose();\n            this._isDisposable = false;\n        }\n        else {\n            markerIndex = this._xterm.markers.indexOf(this._currentMarker) - 1;\n        }\n        if (markerIndex < 0) {\n            this._currentMarker = Boundary.Top;\n            this._xterm.scrollToTop();\n            return;\n        }\n        this._currentMarker = this._xterm.markers[markerIndex];\n        this._scrollToMarker(this._currentMarker, scrollPosition);\n    };\n    TerminalCommandTracker.prototype.scrollToNextCommand = function (scrollPosition, retainSelection) {\n        if (scrollPosition === void 0) { scrollPosition = ScrollPosition.Top; }\n        if (retainSelection === void 0) { retainSelection = false; }\n        if (!retainSelection) {\n            this._selectionStart = null;\n        }\n        var markerIndex;\n        if (this._currentMarker === Boundary.Bottom) {\n            markerIndex = this._xterm.markers.length;\n        }\n        else if (this._currentMarker === Boundary.Top) {\n            markerIndex = 0;\n        }\n        else if (this._isDisposable) {\n            markerIndex = this._findNextCommand();\n            this._currentMarker.dispose();\n            this._isDisposable = false;\n        }\n        else {\n            markerIndex = this._xterm.markers.indexOf(this._currentMarker) + 1;\n        }\n        if (markerIndex >= this._xterm.markers.length) {\n            this._currentMarker = Boundary.Bottom;\n            this._xterm.scrollToBottom();\n            return;\n        }\n        this._currentMarker = this._xterm.markers[markerIndex];\n        this._scrollToMarker(this._currentMarker, scrollPosition);\n    };\n    TerminalCommandTracker.prototype._scrollToMarker = function (marker, position) {\n        var line = marker.line;\n        if (position === ScrollPosition.Middle) {\n            line = Math.max(line - this._xterm.rows / 2, 0);\n        }\n        this._xterm.scrollToLine(line);\n    };\n    TerminalCommandTracker.prototype.selectToPreviousCommand = function () {\n        if (this._selectionStart === null) {\n            this._selectionStart = this._currentMarker;\n        }\n        this.scrollToPreviousCommand(ScrollPosition.Middle, true);\n        this._selectLines(this._currentMarker, this._selectionStart);\n    };\n    TerminalCommandTracker.prototype.selectToNextCommand = function () {\n        if (this._selectionStart === null) {\n            this._selectionStart = this._currentMarker;\n        }\n        this.scrollToNextCommand(ScrollPosition.Middle, true);\n        this._selectLines(this._currentMarker, this._selectionStart);\n    };\n    TerminalCommandTracker.prototype.selectToPreviousLine = function () {\n        if (this._selectionStart === null) {\n            this._selectionStart = this._currentMarker;\n        }\n        this.scrollToPreviousLine(ScrollPosition.Middle, true);\n        this._selectLines(this._currentMarker, this._selectionStart);\n    };\n    TerminalCommandTracker.prototype.selectToNextLine = function () {\n        if (this._selectionStart === null) {\n            this._selectionStart = this._currentMarker;\n        }\n        this.scrollToNextLine(ScrollPosition.Middle, true);\n        this._selectLines(this._currentMarker, this._selectionStart);\n    };\n    TerminalCommandTracker.prototype._selectLines = function (start, end) {\n        if (end === null) {\n            end = Boundary.Bottom;\n        }\n        var startLine = this._getLine(start);\n        var endLine = this._getLine(end);\n        if (startLine > endLine) {\n            var temp = startLine;\n            startLine = endLine;\n            endLine = temp;\n        }\n        // Subtract a line as the marker is on the line the command run, we do not want the next\n        // command in the selection for the current command\n        endLine -= 1;\n        this._xterm.selectLines(startLine, endLine);\n    };\n    TerminalCommandTracker.prototype._getLine = function (marker) {\n        // Use the _second last_ row as the last row is likely the prompt\n        if (marker === Boundary.Bottom) {\n            return this._xterm._core.buffer.ybase + this._xterm.rows - 1;\n        }\n        if (marker === Boundary.Top) {\n            return 0;\n        }\n        return marker.line;\n    };\n    TerminalCommandTracker.prototype.scrollToPreviousLine = function (scrollPosition, retainSelection) {\n        if (scrollPosition === void 0) { scrollPosition = ScrollPosition.Top; }\n        if (retainSelection === void 0) { retainSelection = false; }\n        if (!retainSelection) {\n            this._selectionStart = null;\n        }\n        if (this._currentMarker === Boundary.Top) {\n            this._xterm.scrollToTop();\n            return;\n        }\n        if (this._currentMarker === Boundary.Bottom) {\n            this._currentMarker = this._xterm.addMarker(this._getOffset() - 1);\n        }\n        else {\n            var offset = this._getOffset();\n            if (this._isDisposable) {\n                this._currentMarker.dispose();\n            }\n            this._currentMarker = this._xterm.addMarker(offset - 1);\n        }\n        this._isDisposable = true;\n        this._scrollToMarker(this._currentMarker, scrollPosition);\n    };\n    TerminalCommandTracker.prototype.scrollToNextLine = function (scrollPosition, retainSelection) {\n        if (scrollPosition === void 0) { scrollPosition = ScrollPosition.Top; }\n        if (retainSelection === void 0) { retainSelection = false; }\n        if (!retainSelection) {\n            this._selectionStart = null;\n        }\n        if (this._currentMarker === Boundary.Bottom) {\n            this._xterm.scrollToBottom();\n            return;\n        }\n        if (this._currentMarker === Boundary.Top) {\n            this._currentMarker = this._xterm.addMarker(this._getOffset() + 1);\n        }\n        else {\n            var offset = this._getOffset();\n            if (this._isDisposable) {\n                this._currentMarker.dispose();\n            }\n            this._currentMarker = this._xterm.addMarker(offset + 1);\n        }\n        this._isDisposable = true;\n        this._scrollToMarker(this._currentMarker, scrollPosition);\n    };\n    TerminalCommandTracker.prototype._getOffset = function () {\n        if (this._currentMarker === Boundary.Bottom) {\n            return 0;\n        }\n        else if (this._currentMarker === Boundary.Top) {\n            return 0 - (this._xterm._core.buffer.ybase + this._xterm._core.buffer.y);\n        }\n        else {\n            var offset = this._getLine(this._currentMarker);\n            offset -= this._xterm._core.buffer.ybase + this._xterm._core.buffer.y;\n            return offset;\n        }\n    };\n    TerminalCommandTracker.prototype._findPreviousCommand = function () {\n        if (this._currentMarker === Boundary.Top) {\n            return 0;\n        }\n        else if (this._currentMarker === Boundary.Bottom) {\n            return this._xterm.markers.length - 1;\n        }\n        var i;\n        for (i = this._xterm.markers.length - 1; i >= 0; i--) {\n            if (this._xterm.markers[i].line < this._currentMarker.line) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    TerminalCommandTracker.prototype._findNextCommand = function () {\n        if (this._currentMarker === Boundary.Top) {\n            return 0;\n        }\n        else if (this._currentMarker === Boundary.Bottom) {\n            return this._xterm.markers.length - 1;\n        }\n        var i;\n        for (i = 0; i < this._xterm.markers.length; i++) {\n            if (this._xterm.markers[i].line > this._currentMarker.line) {\n                return i;\n            }\n        }\n        return this._xterm.markers.length;\n    };\n    return TerminalCommandTracker;\n}());\nexports.TerminalCommandTracker = TerminalCommandTracker;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/browser/terminalCommandTracker.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/browser/terminalCommandTracker.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Terminal, IMarker } from 'vscode-xterm';\nimport { ITerminalCommandTracker } from 'vs/workbench/contrib/terminal/common/terminal';\nimport { IDisposable } from 'vs/base/common/lifecycle';\n\n/**\n * The minimum size of the prompt in which to assume the line is a command.\n */\nconst MINIMUM_PROMPT_LENGTH = 2;\n\nenum Boundary {\n\tTop,\n\tBottom\n}\n\nexport const enum ScrollPosition {\n\tTop,\n\tMiddle\n}\n\nexport class TerminalCommandTracker implements ITerminalCommandTracker, IDisposable {\n\tprivate _currentMarker: IMarker | Boundary = Boundary.Bottom;\n\tprivate _selectionStart: IMarker | Boundary | null = null;\n\tprivate _isDisposable: boolean = false;\n\n\tconstructor(\n\t\tprivate _xterm: Terminal\n\t) {\n\t\tthis._xterm.on('key', key => this._onKey(key));\n\t}\n\n\tpublic dispose(): void {\n\t}\n\n\tprivate _onKey(key: string): void {\n\t\tif (key === '\\x0d') {\n\t\t\tthis._onEnter();\n\t\t}\n\n\t\t// Clear the current marker so successive focus/selection actions are performed from the\n\t\t// bottom of the buffer\n\t\tthis._currentMarker = Boundary.Bottom;\n\t\tthis._selectionStart = null;\n\t}\n\n\tprivate _onEnter(): void {\n\t\tif (this._xterm._core.buffer.x >= MINIMUM_PROMPT_LENGTH) {\n\t\t\tthis._xterm.addMarker(0);\n\t\t}\n\t}\n\n\tpublic scrollToPreviousCommand(scrollPosition: ScrollPosition = ScrollPosition.Top, retainSelection: boolean = false): void {\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tlet markerIndex;\n\t\tif (this._currentMarker === Boundary.Bottom) {\n\t\t\tmarkerIndex = this._xterm.markers.length - 1;\n\t\t} else if (this._currentMarker === Boundary.Top) {\n\t\t\tmarkerIndex = -1;\n\t\t} else if (this._isDisposable) {\n\t\t\tmarkerIndex = this._findPreviousCommand();\n\t\t\tthis._currentMarker.dispose();\n\t\t\tthis._isDisposable = false;\n\t\t} else {\n\t\t\tmarkerIndex = this._xterm.markers.indexOf(this._currentMarker) - 1;\n\t\t}\n\n\t\tif (markerIndex < 0) {\n\t\t\tthis._currentMarker = Boundary.Top;\n\t\t\tthis._xterm.scrollToTop();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentMarker = this._xterm.markers[markerIndex];\n\t\tthis._scrollToMarker(this._currentMarker, scrollPosition);\n\t}\n\n\tpublic scrollToNextCommand(scrollPosition: ScrollPosition = ScrollPosition.Top, retainSelection: boolean = false): void {\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tlet markerIndex;\n\t\tif (this._currentMarker === Boundary.Bottom) {\n\t\t\tmarkerIndex = this._xterm.markers.length;\n\t\t} else if (this._currentMarker === Boundary.Top) {\n\t\t\tmarkerIndex = 0;\n\t\t} else if (this._isDisposable) {\n\t\t\tmarkerIndex = this._findNextCommand();\n\t\t\tthis._currentMarker.dispose();\n\t\t\tthis._isDisposable = false;\n\t\t} else {\n\t\t\tmarkerIndex = this._xterm.markers.indexOf(this._currentMarker) + 1;\n\t\t}\n\n\t\tif (markerIndex >= this._xterm.markers.length) {\n\t\t\tthis._currentMarker = Boundary.Bottom;\n\t\t\tthis._xterm.scrollToBottom();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentMarker = this._xterm.markers[markerIndex];\n\t\tthis._scrollToMarker(this._currentMarker, scrollPosition);\n\t}\n\n\tprivate _scrollToMarker(marker: IMarker, position: ScrollPosition): void {\n\t\tlet line = marker.line;\n\t\tif (position === ScrollPosition.Middle) {\n\t\t\tline = Math.max(line - this._xterm.rows / 2, 0);\n\t\t}\n\t\tthis._xterm.scrollToLine(line);\n\t}\n\n\tpublic selectToPreviousCommand(): void {\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\t\tthis.scrollToPreviousCommand(ScrollPosition.Middle, true);\n\t\tthis._selectLines(this._currentMarker, this._selectionStart);\n\t}\n\n\tpublic selectToNextCommand(): void {\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\t\tthis.scrollToNextCommand(ScrollPosition.Middle, true);\n\t\tthis._selectLines(this._currentMarker, this._selectionStart);\n\t}\n\n\tpublic selectToPreviousLine(): void {\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\n\t\tthis.scrollToPreviousLine(ScrollPosition.Middle, true);\n\t\tthis._selectLines(this._currentMarker, this._selectionStart);\n\t}\n\n\tpublic selectToNextLine(): void {\n\t\tif (this._selectionStart === null) {\n\t\t\tthis._selectionStart = this._currentMarker;\n\t\t}\n\n\t\tthis.scrollToNextLine(ScrollPosition.Middle, true);\n\t\tthis._selectLines(this._currentMarker, this._selectionStart);\n\t}\n\n\tprivate _selectLines(start: IMarker | Boundary, end: IMarker | Boundary | null): void {\n\t\tif (end === null) {\n\t\t\tend = Boundary.Bottom;\n\t\t}\n\n\t\tlet startLine = this._getLine(start);\n\t\tlet endLine = this._getLine(end);\n\n\t\tif (startLine > endLine) {\n\t\t\tconst temp = startLine;\n\t\t\tstartLine = endLine;\n\t\t\tendLine = temp;\n\t\t}\n\n\t\t// Subtract a line as the marker is on the line the command run, we do not want the next\n\t\t// command in the selection for the current command\n\t\tendLine -= 1;\n\n\t\tthis._xterm.selectLines(startLine, endLine);\n\t}\n\n\tprivate _getLine(marker: IMarker | Boundary): number {\n\t\t// Use the _second last_ row as the last row is likely the prompt\n\t\tif (marker === Boundary.Bottom) {\n\t\t\treturn this._xterm._core.buffer.ybase + this._xterm.rows - 1;\n\t\t}\n\n\t\tif (marker === Boundary.Top) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn marker.line;\n\t}\n\n\tpublic scrollToPreviousLine(scrollPosition: ScrollPosition = ScrollPosition.Top, retainSelection: boolean = false): void {\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\tthis._xterm.scrollToTop();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Bottom) {\n\t\t\tthis._currentMarker = this._xterm.addMarker(this._getOffset() - 1);\n\t\t} else {\n\t\t\tconst offset = this._getOffset();\n\t\t\tif (this._isDisposable) {\n\t\t\t\tthis._currentMarker.dispose();\n\t\t\t}\n\t\t\tthis._currentMarker = this._xterm.addMarker(offset - 1);\n\t\t}\n\t\tthis._isDisposable = true;\n\t\tthis._scrollToMarker(this._currentMarker, scrollPosition);\n\t}\n\n\tpublic scrollToNextLine(scrollPosition: ScrollPosition = ScrollPosition.Top, retainSelection: boolean = false): void {\n\t\tif (!retainSelection) {\n\t\t\tthis._selectionStart = null;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Bottom) {\n\t\t\tthis._xterm.scrollToBottom();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\tthis._currentMarker = this._xterm.addMarker(this._getOffset() + 1);\n\t\t} else {\n\t\t\tconst offset = this._getOffset();\n\t\t\tif (this._isDisposable) {\n\t\t\t\tthis._currentMarker.dispose();\n\t\t\t}\n\t\t\tthis._currentMarker = this._xterm.addMarker(offset + 1);\n\t\t}\n\t\tthis._isDisposable = true;\n\t\tthis._scrollToMarker(this._currentMarker, scrollPosition);\n\t}\n\n\tprivate _getOffset(): number {\n\t\tif (this._currentMarker === Boundary.Bottom) {\n\t\t\treturn 0;\n\t\t} else if (this._currentMarker === Boundary.Top) {\n\t\t\treturn 0 - (this._xterm._core.buffer.ybase + this._xterm._core.buffer.y);\n\t\t} else {\n\t\t\tlet offset = this._getLine(this._currentMarker);\n\t\t\toffset -= this._xterm._core.buffer.ybase + this._xterm._core.buffer.y;\n\t\t\treturn offset;\n\t\t}\n\t}\n\n\tprivate _findPreviousCommand(): number {\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\treturn 0;\n\t\t} else if (this._currentMarker === Boundary.Bottom) {\n\t\t\treturn this._xterm.markers.length - 1;\n\t\t}\n\n\t\tlet i;\n\t\tfor (i = this._xterm.markers.length - 1; i >= 0; i--) {\n\t\t\tif (this._xterm.markers[i].line < this._currentMarker.line) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tprivate _findNextCommand(): number {\n\t\tif (this._currentMarker === Boundary.Top) {\n\t\t\treturn 0;\n\t\t} else if (this._currentMarker === Boundary.Bottom) {\n\t\t\treturn this._xterm.markers.length - 1;\n\t\t}\n\n\t\tlet i;\n\t\tfor (i = 0; i < this._xterm.markers.length; i++) {\n\t\t\tif (this._xterm.markers[i].line > this._currentMarker.line) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn this._xterm.markers.length;\n\t}\n}\n"]}]}