{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursorWordOperations.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursorWordOperations.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar strings = require(\"vs/base/common/strings\");\nvar cursorCommon_1 = require(\"vs/editor/common/controller/cursorCommon\");\nvar wordCharacterClassifier_1 = require(\"vs/editor/common/controller/wordCharacterClassifier\");\nvar position_1 = require(\"vs/editor/common/core/position\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar WordType;\n(function (WordType) {\n    WordType[WordType[\"None\"] = 0] = \"None\";\n    WordType[WordType[\"Regular\"] = 1] = \"Regular\";\n    WordType[WordType[\"Separator\"] = 2] = \"Separator\";\n})(WordType || (WordType = {}));\nvar WordNavigationType;\n(function (WordNavigationType) {\n    WordNavigationType[WordNavigationType[\"WordStart\"] = 0] = \"WordStart\";\n    WordNavigationType[WordNavigationType[\"WordStartFast\"] = 1] = \"WordStartFast\";\n    WordNavigationType[WordNavigationType[\"WordEnd\"] = 2] = \"WordEnd\";\n})(WordNavigationType = exports.WordNavigationType || (exports.WordNavigationType = {}));\nvar WordOperations = /** @class */ (function () {\n    function WordOperations() {\n    }\n    WordOperations._createWord = function (lineContent, wordType, nextCharClass, start, end) {\n        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n    };\n    WordOperations._findPreviousWordOnLine = function (wordSeparators, model, position) {\n        var lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n    };\n    WordOperations._doFindPreviousWordOnLine = function (lineContent, wordSeparators, position) {\n        var wordType = WordType.None;\n        for (var chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n            var chCode = lineContent.charCodeAt(chIndex);\n            var chClass = wordSeparators.get(chCode);\n            if (chClass === wordCharacterClassifier_1.WordCharacterClass.Regular) {\n                if (wordType === WordType.Separator) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = WordType.Regular;\n            }\n            else if (chClass === wordCharacterClassifier_1.WordCharacterClass.WordSeparator) {\n                if (wordType === WordType.Regular) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = WordType.Separator;\n            }\n            else if (chClass === wordCharacterClassifier_1.WordCharacterClass.Whitespace) {\n                if (wordType !== WordType.None) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n            }\n        }\n        if (wordType !== WordType.None) {\n            return this._createWord(lineContent, wordType, wordCharacterClassifier_1.WordCharacterClass.Whitespace, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n        }\n        return null;\n    };\n    WordOperations._findEndOfWord = function (lineContent, wordSeparators, wordType, startIndex) {\n        var len = lineContent.length;\n        for (var chIndex = startIndex; chIndex < len; chIndex++) {\n            var chCode = lineContent.charCodeAt(chIndex);\n            var chClass = wordSeparators.get(chCode);\n            if (chClass === wordCharacterClassifier_1.WordCharacterClass.Whitespace) {\n                return chIndex;\n            }\n            if (wordType === WordType.Regular && chClass === wordCharacterClassifier_1.WordCharacterClass.WordSeparator) {\n                return chIndex;\n            }\n            if (wordType === WordType.Separator && chClass === wordCharacterClassifier_1.WordCharacterClass.Regular) {\n                return chIndex;\n            }\n        }\n        return len;\n    };\n    WordOperations._findNextWordOnLine = function (wordSeparators, model, position) {\n        var lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n    };\n    WordOperations._doFindNextWordOnLine = function (lineContent, wordSeparators, position) {\n        var wordType = WordType.None;\n        var len = lineContent.length;\n        for (var chIndex = position.column - 1; chIndex < len; chIndex++) {\n            var chCode = lineContent.charCodeAt(chIndex);\n            var chClass = wordSeparators.get(chCode);\n            if (chClass === wordCharacterClassifier_1.WordCharacterClass.Regular) {\n                if (wordType === WordType.Separator) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = WordType.Regular;\n            }\n            else if (chClass === wordCharacterClassifier_1.WordCharacterClass.WordSeparator) {\n                if (wordType === WordType.Regular) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = WordType.Separator;\n            }\n            else if (chClass === wordCharacterClassifier_1.WordCharacterClass.Whitespace) {\n                if (wordType !== WordType.None) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n            }\n        }\n        if (wordType !== WordType.None) {\n            return this._createWord(lineContent, wordType, wordCharacterClassifier_1.WordCharacterClass.Whitespace, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n        }\n        return null;\n    };\n    WordOperations._findStartOfWord = function (lineContent, wordSeparators, wordType, startIndex) {\n        for (var chIndex = startIndex; chIndex >= 0; chIndex--) {\n            var chCode = lineContent.charCodeAt(chIndex);\n            var chClass = wordSeparators.get(chCode);\n            if (chClass === wordCharacterClassifier_1.WordCharacterClass.Whitespace) {\n                return chIndex + 1;\n            }\n            if (wordType === WordType.Regular && chClass === wordCharacterClassifier_1.WordCharacterClass.WordSeparator) {\n                return chIndex + 1;\n            }\n            if (wordType === WordType.Separator && chClass === wordCharacterClassifier_1.WordCharacterClass.Regular) {\n                return chIndex + 1;\n            }\n        }\n        return 0;\n    };\n    WordOperations.moveWordLeft = function (wordSeparators, model, position, wordNavigationType) {\n        var lineNumber = position.lineNumber;\n        var column = position.column;\n        var movedToPreviousLine = false;\n        if (column === 1) {\n            if (lineNumber > 1) {\n                movedToPreviousLine = true;\n                lineNumber = lineNumber - 1;\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        var prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, column));\n        if (wordNavigationType === WordNavigationType.WordStart) {\n            if (prevWordOnLine && !movedToPreviousLine) {\n                // Special case for Visual Studio compatibility:\n                // when starting in the trim whitespace at the end of a line,\n                // go to the end of the last word\n                var lastWhitespaceColumn = model.getLineLastNonWhitespaceColumn(lineNumber);\n                if (lastWhitespaceColumn < column) {\n                    return new position_1.Position(lineNumber, prevWordOnLine.end + 1);\n                }\n            }\n            return new position_1.Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === WordNavigationType.WordStartFast) {\n            if (prevWordOnLine\n                && prevWordOnLine.wordType === WordType.Separator\n                && prevWordOnLine.end - prevWordOnLine.start === 1\n                && prevWordOnLine.nextCharClass === wordCharacterClassifier_1.WordCharacterClass.Regular) {\n                // Skip over a word made up of one single separator and followed by a regular character\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new position_1.Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        // We are stopping at the ending of words\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        return new position_1.Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n    };\n    WordOperations._moveWordPartLeft = function (model, position) {\n        var lineNumber = position.lineNumber;\n        var maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === 1) {\n            return (lineNumber > 1 ? new position_1.Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n        }\n        var lineContent = model.getLineContent(lineNumber);\n        for (var column = position.column - 1; column > 1; column--) {\n            var left = lineContent.charCodeAt(column - 2);\n            var right = lineContent.charCodeAt(column - 1);\n            if (left !== charCode_1.CharCode.Underline && right === charCode_1.CharCode.Underline) {\n                // snake_case_variables\n                return new position_1.Position(lineNumber, column);\n            }\n            if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new position_1.Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    var rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight)) {\n                        return new position_1.Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new position_1.Position(lineNumber, 1);\n    };\n    WordOperations.moveWordRight = function (wordSeparators, model, position, wordNavigationType) {\n        var lineNumber = position.lineNumber;\n        var column = position.column;\n        var movedDown = false;\n        if (column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber < model.getLineCount()) {\n                movedDown = true;\n                lineNumber = lineNumber + 1;\n                column = 1;\n            }\n        }\n        var nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, column));\n        if (wordNavigationType === WordNavigationType.WordEnd) {\n            if (nextWordOnLine && nextWordOnLine.wordType === WordType.Separator) {\n                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === wordCharacterClassifier_1.WordCharacterClass.Regular) {\n                    // Skip over a word made up of one single separator and followed by a regular character\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, nextWordOnLine.end + 1));\n                }\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else {\n            if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        return new position_1.Position(lineNumber, column);\n    };\n    WordOperations._moveWordPartRight = function (model, position) {\n        var lineNumber = position.lineNumber;\n        var maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === maxColumn) {\n            return (lineNumber < model.getLineCount() ? new position_1.Position(lineNumber + 1, 1) : position);\n        }\n        var lineContent = model.getLineContent(lineNumber);\n        for (var column = position.column + 1; column < maxColumn; column++) {\n            var left = lineContent.charCodeAt(column - 2);\n            var right = lineContent.charCodeAt(column - 1);\n            if (left === charCode_1.CharCode.Underline && right !== charCode_1.CharCode.Underline) {\n                // snake_case_variables\n                return new position_1.Position(lineNumber, column);\n            }\n            if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new position_1.Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    var rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight)) {\n                        return new position_1.Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new position_1.Position(lineNumber, maxColumn);\n    };\n    WordOperations._deleteWordLeftWhitespace = function (model, position) {\n        var lineContent = model.getLineContent(position.lineNumber);\n        var startIndex = position.column - 2;\n        var lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n        if (lastNonWhitespace + 1 < startIndex) {\n            return new range_1.Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n        }\n        return null;\n    };\n    WordOperations.deleteWordLeft = function (wordSeparators, model, selection, whitespaceHeuristics, wordNavigationType) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        var position = new position_1.Position(selection.positionLineNumber, selection.positionColumn);\n        var lineNumber = position.lineNumber;\n        var column = position.column;\n        if (lineNumber === 1 && column === 1) {\n            // Ignore deleting at beginning of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            var r = this._deleteWordLeftWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        var prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === WordNavigationType.WordStart) {\n            if (prevWordOnLine) {\n                column = prevWordOnLine.start + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        else {\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            if (prevWordOnLine) {\n                column = prevWordOnLine.end + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        return new range_1.Range(lineNumber, column, position.lineNumber, position.column);\n    };\n    WordOperations._deleteWordPartLeft = function (model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        var pos = selection.getPosition();\n        var toPosition = WordOperations._moveWordPartLeft(model, pos);\n        return new range_1.Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    };\n    WordOperations._findFirstNonWhitespaceChar = function (str, startIndex) {\n        var len = str.length;\n        for (var chIndex = startIndex; chIndex < len; chIndex++) {\n            var ch = str.charAt(chIndex);\n            if (ch !== ' ' && ch !== '\\t') {\n                return chIndex;\n            }\n        }\n        return len;\n    };\n    WordOperations._deleteWordRightWhitespace = function (model, position) {\n        var lineContent = model.getLineContent(position.lineNumber);\n        var startIndex = position.column - 1;\n        var firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n        if (startIndex + 1 < firstNonWhitespace) {\n            // bingo\n            return new range_1.Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n        }\n        return null;\n    };\n    WordOperations.deleteWordRight = function (wordSeparators, model, selection, whitespaceHeuristics, wordNavigationType) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        var position = new position_1.Position(selection.positionLineNumber, selection.positionColumn);\n        var lineNumber = position.lineNumber;\n        var column = position.column;\n        var lineCount = model.getLineCount();\n        var maxColumn = model.getLineMaxColumn(lineNumber);\n        if (lineNumber === lineCount && column === maxColumn) {\n            // Ignore deleting at end of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            var r = this._deleteWordRightWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        var nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === WordNavigationType.WordEnd) {\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        else {\n            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        return new range_1.Range(lineNumber, column, position.lineNumber, position.column);\n    };\n    WordOperations._deleteWordPartRight = function (model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        var pos = selection.getPosition();\n        var toPosition = WordOperations._moveWordPartRight(model, pos);\n        return new range_1.Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    };\n    WordOperations.word = function (config, model, cursor, inSelectionMode, position) {\n        var wordSeparators = wordCharacterClassifier_1.getMapForWordSeparators(config.wordSeparators);\n        var prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        var nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (!inSelectionMode) {\n            // Entering word selection for the first time\n            var startColumn_1;\n            var endColumn_1;\n            if (prevWord && prevWord.wordType === WordType.Regular && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n                // isTouchingPrevWord\n                startColumn_1 = prevWord.start + 1;\n                endColumn_1 = prevWord.end + 1;\n            }\n            else if (nextWord && nextWord.wordType === WordType.Regular && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n                // isTouchingNextWord\n                startColumn_1 = nextWord.start + 1;\n                endColumn_1 = nextWord.end + 1;\n            }\n            else {\n                if (prevWord) {\n                    startColumn_1 = prevWord.end + 1;\n                }\n                else {\n                    startColumn_1 = 1;\n                }\n                if (nextWord) {\n                    endColumn_1 = nextWord.start + 1;\n                }\n                else {\n                    endColumn_1 = model.getLineMaxColumn(position.lineNumber);\n                }\n            }\n            return new cursorCommon_1.SingleCursorState(new range_1.Range(position.lineNumber, startColumn_1, position.lineNumber, endColumn_1), 0, new position_1.Position(position.lineNumber, endColumn_1), 0);\n        }\n        var startColumn;\n        var endColumn;\n        if (prevWord && prevWord.wordType === WordType.Regular && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n            // isInsidePrevWord\n            startColumn = prevWord.start + 1;\n            endColumn = prevWord.end + 1;\n        }\n        else if (nextWord && nextWord.wordType === WordType.Regular && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n            // isInsideNextWord\n            startColumn = nextWord.start + 1;\n            endColumn = nextWord.end + 1;\n        }\n        else {\n            startColumn = position.column;\n            endColumn = position.column;\n        }\n        var lineNumber = position.lineNumber;\n        var column;\n        if (cursor.selectionStart.containsPosition(position)) {\n            column = cursor.selectionStart.endColumn;\n        }\n        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n            column = startColumn;\n            var possiblePosition = new position_1.Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.endColumn;\n            }\n        }\n        else {\n            column = endColumn;\n            var possiblePosition = new position_1.Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.startColumn;\n            }\n        }\n        return cursor.move(true, lineNumber, column, 0);\n    };\n    return WordOperations;\n}());\nexports.WordOperations = WordOperations;\nvar WordPartOperations = /** @class */ (function (_super) {\n    tslib_1.__extends(WordPartOperations, _super);\n    function WordPartOperations() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    WordPartOperations.deleteWordPartLeft = function (wordSeparators, model, selection, whitespaceHeuristics) {\n        var candidates = enforceDefined([\n            WordOperations.deleteWordLeft(wordSeparators, model, selection, whitespaceHeuristics, WordNavigationType.WordStart),\n            WordOperations.deleteWordLeft(wordSeparators, model, selection, whitespaceHeuristics, WordNavigationType.WordEnd),\n            WordOperations._deleteWordPartLeft(model, selection)\n        ]);\n        candidates.sort(range_1.Range.compareRangesUsingEnds);\n        return candidates[2];\n    };\n    WordPartOperations.deleteWordPartRight = function (wordSeparators, model, selection, whitespaceHeuristics) {\n        var candidates = enforceDefined([\n            WordOperations.deleteWordRight(wordSeparators, model, selection, whitespaceHeuristics, WordNavigationType.WordStart),\n            WordOperations.deleteWordRight(wordSeparators, model, selection, whitespaceHeuristics, WordNavigationType.WordEnd),\n            WordOperations._deleteWordPartRight(model, selection)\n        ]);\n        candidates.sort(range_1.Range.compareRangesUsingStarts);\n        return candidates[0];\n    };\n    WordPartOperations.moveWordPartLeft = function (wordSeparators, model, position) {\n        var candidates = enforceDefined([\n            WordOperations.moveWordLeft(wordSeparators, model, position, WordNavigationType.WordStart),\n            WordOperations.moveWordLeft(wordSeparators, model, position, WordNavigationType.WordEnd),\n            WordOperations._moveWordPartLeft(model, position)\n        ]);\n        candidates.sort(position_1.Position.compare);\n        return candidates[2];\n    };\n    WordPartOperations.moveWordPartRight = function (wordSeparators, model, position) {\n        var candidates = enforceDefined([\n            WordOperations.moveWordRight(wordSeparators, model, position, WordNavigationType.WordStart),\n            WordOperations.moveWordRight(wordSeparators, model, position, WordNavigationType.WordEnd),\n            WordOperations._moveWordPartRight(model, position)\n        ]);\n        candidates.sort(position_1.Position.compare);\n        return candidates[0];\n    };\n    return WordPartOperations;\n}(WordOperations));\nexports.WordPartOperations = WordPartOperations;\nfunction enforceDefined(arr) {\n    return arr.filter(function (el) { return Boolean(el); });\n}\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursorWordOperations.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursorWordOperations.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as strings from 'vs/base/common/strings';\nimport { CursorConfiguration, ICursorSimpleModel, SingleCursorState } from 'vs/editor/common/controller/cursorCommon';\nimport { WordCharacterClass, WordCharacterClassifier, getMapForWordSeparators } from 'vs/editor/common/controller/wordCharacterClassifier';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { Selection } from 'vs/editor/common/core/selection';\n\ninterface IFindWordResult {\n\t/**\n\t * The index where the word starts.\n\t */\n\tstart: number;\n\t/**\n\t * The index where the word ends.\n\t */\n\tend: number;\n\t/**\n\t * The word type.\n\t */\n\twordType: WordType;\n\t/**\n\t * The reason the word ended.\n\t */\n\tnextCharClass: WordCharacterClass;\n}\n\nconst enum WordType {\n\tNone = 0,\n\tRegular = 1,\n\tSeparator = 2\n}\n\nexport const enum WordNavigationType {\n\tWordStart = 0,\n\tWordStartFast = 1,\n\tWordEnd = 2\n}\n\nexport class WordOperations {\n\n\tprivate static _createWord(lineContent: string, wordType: WordType, nextCharClass: WordCharacterClass, start: number, end: number): IFindWordResult {\n\t\t// console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n\t\treturn { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n\t}\n\n\tprivate static _findPreviousWordOnLine(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): IFindWordResult | null {\n\t\tlet lineContent = model.getLineContent(position.lineNumber);\n\t\treturn this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n\t}\n\n\tprivate static _doFindPreviousWordOnLine(lineContent: string, wordSeparators: WordCharacterClassifier, position: Position): IFindWordResult | null {\n\t\tlet wordType = WordType.None;\n\t\tfor (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n\t\t\tlet chCode = lineContent.charCodeAt(chIndex);\n\t\t\tlet chClass = wordSeparators.get(chCode);\n\n\t\t\tif (chClass === WordCharacterClass.Regular) {\n\t\t\t\tif (wordType === WordType.Separator) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n\t\t\t\t}\n\t\t\t\twordType = WordType.Regular;\n\t\t\t} else if (chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\tif (wordType === WordType.Regular) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n\t\t\t\t}\n\t\t\t\twordType = WordType.Separator;\n\t\t\t} else if (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\tif (wordType !== WordType.None) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (wordType !== WordType.None) {\n\t\t\treturn this._createWord(lineContent, wordType, WordCharacterClass.Whitespace, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findEndOfWord(lineContent: string, wordSeparators: WordCharacterClassifier, wordType: WordType, startIndex: number): number {\n\t\tlet len = lineContent.length;\n\t\tfor (let chIndex = startIndex; chIndex < len; chIndex++) {\n\t\t\tlet chCode = lineContent.charCodeAt(chIndex);\n\t\t\tlet chClass = wordSeparators.get(chCode);\n\n\t\t\tif (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t\tif (wordType === WordType.Regular && chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t\tif (wordType === WordType.Separator && chClass === WordCharacterClass.Regular) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t}\n\t\treturn len;\n\t}\n\n\tprivate static _findNextWordOnLine(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): IFindWordResult | null {\n\t\tlet lineContent = model.getLineContent(position.lineNumber);\n\t\treturn this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n\t}\n\n\tprivate static _doFindNextWordOnLine(lineContent: string, wordSeparators: WordCharacterClassifier, position: Position): IFindWordResult | null {\n\t\tlet wordType = WordType.None;\n\t\tlet len = lineContent.length;\n\n\t\tfor (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n\t\t\tlet chCode = lineContent.charCodeAt(chIndex);\n\t\t\tlet chClass = wordSeparators.get(chCode);\n\n\t\t\tif (chClass === WordCharacterClass.Regular) {\n\t\t\t\tif (wordType === WordType.Separator) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n\t\t\t\t}\n\t\t\t\twordType = WordType.Regular;\n\t\t\t} else if (chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\tif (wordType === WordType.Regular) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n\t\t\t\t}\n\t\t\t\twordType = WordType.Separator;\n\t\t\t} else if (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\tif (wordType !== WordType.None) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (wordType !== WordType.None) {\n\t\t\treturn this._createWord(lineContent, wordType, WordCharacterClass.Whitespace, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findStartOfWord(lineContent: string, wordSeparators: WordCharacterClassifier, wordType: WordType, startIndex: number): number {\n\t\tfor (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n\t\t\tlet chCode = lineContent.charCodeAt(chIndex);\n\t\t\tlet chClass = wordSeparators.get(chCode);\n\n\t\t\tif (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t\tif (wordType === WordType.Regular && chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t\tif (wordType === WordType.Separator && chClass === WordCharacterClass.Regular) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic static moveWordLeft(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position, wordNavigationType: WordNavigationType): Position {\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\t\tlet movedToPreviousLine = false;\n\n\t\tif (column === 1) {\n\t\t\tif (lineNumber > 1) {\n\t\t\t\tmovedToPreviousLine = true;\n\t\t\t\tlineNumber = lineNumber - 1;\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\tlet prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n\n\t\tif (wordNavigationType === WordNavigationType.WordStart) {\n\n\t\t\tif (prevWordOnLine && !movedToPreviousLine) {\n\t\t\t\t// Special case for Visual Studio compatibility:\n\t\t\t\t// when starting in the trim whitespace at the end of a line,\n\t\t\t\t// go to the end of the last word\n\t\t\t\tconst lastWhitespaceColumn = model.getLineLastNonWhitespaceColumn(lineNumber);\n\t\t\t\tif (lastWhitespaceColumn < column) {\n\t\t\t\t\treturn new Position(lineNumber, prevWordOnLine.end + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n\t\t}\n\n\t\tif (wordNavigationType === WordNavigationType.WordStartFast) {\n\t\t\tif (\n\t\t\t\tprevWordOnLine\n\t\t\t\t&& prevWordOnLine.wordType === WordType.Separator\n\t\t\t\t&& prevWordOnLine.end - prevWordOnLine.start === 1\n\t\t\t\t&& prevWordOnLine.nextCharClass === WordCharacterClass.Regular\n\t\t\t) {\n\t\t\t\t// Skip over a word made up of one single separator and followed by a regular character\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t\t}\n\n\t\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n\t\t}\n\n\t\t// We are stopping at the ending of words\n\n\t\tif (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t}\n\n\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n\t}\n\n\tpublic static _moveWordPartLeft(model: ICursorSimpleModel, position: Position): Position {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\n\t\tif (position.column === 1) {\n\t\t\treturn (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n\t\t}\n\n\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\tfor (let column = position.column - 1; column > 1; column--) {\n\t\t\tconst left = lineContent.charCodeAt(column - 2);\n\t\t\tconst right = lineContent.charCodeAt(column - 1);\n\n\t\t\tif (left !== CharCode.Underline && right === CharCode.Underline) {\n\t\t\t\t// snake_case_variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// camelCaseVariables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// thisIsACamelCaseWithOneLetterWords\n\t\t\t\tif (column + 1 < maxColumn) {\n\t\t\t\t\tconst rightRight = lineContent.charCodeAt(column);\n\t\t\t\t\tif (strings.isLowerAsciiLetter(rightRight)) {\n\t\t\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, 1);\n\t}\n\n\tpublic static moveWordRight(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position, wordNavigationType: WordNavigationType): Position {\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tlet movedDown = false;\n\t\tif (column === model.getLineMaxColumn(lineNumber)) {\n\t\t\tif (lineNumber < model.getLineCount()) {\n\t\t\t\tmovedDown = true;\n\t\t\t\tlineNumber = lineNumber + 1;\n\t\t\t\tcolumn = 1;\n\t\t\t}\n\t\t}\n\n\t\tlet nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n\n\t\tif (wordNavigationType === WordNavigationType.WordEnd) {\n\t\t\tif (nextWordOnLine && nextWordOnLine.wordType === WordType.Separator) {\n\t\t\t\tif (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === WordCharacterClass.Regular) {\n\t\t\t\t\t// Skip over a word made up of one single separator and followed by a regular character\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t} else {\n\t\t\tif (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, column);\n\t}\n\n\tpublic static _moveWordPartRight(model: ICursorSimpleModel, position: Position): Position {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\n\t\tif (position.column === maxColumn) {\n\t\t\treturn (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n\t\t}\n\n\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\tfor (let column = position.column + 1; column < maxColumn; column++) {\n\t\t\tconst left = lineContent.charCodeAt(column - 2);\n\t\t\tconst right = lineContent.charCodeAt(column - 1);\n\n\t\t\tif (left === CharCode.Underline && right !== CharCode.Underline) {\n\t\t\t\t// snake_case_variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// camelCaseVariables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// thisIsACamelCaseWithOneLetterWords\n\t\t\t\tif (column + 1 < maxColumn) {\n\t\t\t\t\tconst rightRight = lineContent.charCodeAt(column);\n\t\t\t\t\tif (strings.isLowerAsciiLetter(rightRight)) {\n\t\t\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, maxColumn);\n\t}\n\n\tprotected static _deleteWordLeftWhitespace(model: ICursorSimpleModel, position: Position): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst startIndex = position.column - 2;\n\t\tconst lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n\t\tif (lastNonWhitespace + 1 < startIndex) {\n\t\t\treturn new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static deleteWordLeft(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, selection: Selection, whitespaceHeuristics: boolean, wordNavigationType: WordNavigationType): Range | null {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tif (lineNumber === 1 && column === 1) {\n\t\t\t// Ignore deleting at beginning of file\n\t\t\treturn null;\n\t\t}\n\n\t\tif (whitespaceHeuristics) {\n\t\t\tlet r = this._deleteWordLeftWhitespace(model, position);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\tlet prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\n\t\tif (wordNavigationType === WordNavigationType.WordStart) {\n\t\t\tif (prevWordOnLine) {\n\t\t\t\tcolumn = prevWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tif (column > 1) {\n\t\t\t\t\tcolumn = 1;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber--;\n\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t\t}\n\t\t\tif (prevWordOnLine) {\n\t\t\t\tcolumn = prevWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tif (column > 1) {\n\t\t\t\t\tcolumn = 1;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber--;\n\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Range(lineNumber, column, position.lineNumber, position.column);\n\t}\n\n\tpublic static _deleteWordPartLeft(model: ICursorSimpleModel, selection: Selection): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst pos = selection.getPosition();\n\t\tconst toPosition = WordOperations._moveWordPartLeft(model, pos);\n\t\treturn new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n\t}\n\n\tprivate static _findFirstNonWhitespaceChar(str: string, startIndex: number): number {\n\t\tlet len = str.length;\n\t\tfor (let chIndex = startIndex; chIndex < len; chIndex++) {\n\t\t\tlet ch = str.charAt(chIndex);\n\t\t\tif (ch !== ' ' && ch !== '\\t') {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t}\n\t\treturn len;\n\t}\n\n\tprotected static _deleteWordRightWhitespace(model: ICursorSimpleModel, position: Position): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst startIndex = position.column - 1;\n\t\tconst firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n\t\tif (startIndex + 1 < firstNonWhitespace) {\n\t\t\t// bingo\n\t\t\treturn new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static deleteWordRight(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, selection: Selection, whitespaceHeuristics: boolean, wordNavigationType: WordNavigationType): Range | null {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tconst lineCount = model.getLineCount();\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\t\tif (lineNumber === lineCount && column === maxColumn) {\n\t\t\t// Ignore deleting at end of file\n\t\t\treturn null;\n\t\t}\n\n\t\tif (whitespaceHeuristics) {\n\t\t\tlet r = this._deleteWordRightWhitespace(model, position);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\tlet nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n\t\tif (wordNavigationType === WordNavigationType.WordEnd) {\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tif (column < maxColumn || lineNumber === lineCount) {\n\t\t\t\t\tcolumn = maxColumn;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber++;\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n\t\t\t\t\tif (nextWordOnLine) {\n\t\t\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tif (column < maxColumn || lineNumber === lineCount) {\n\t\t\t\t\tcolumn = maxColumn;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber++;\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n\t\t\t\t\tif (nextWordOnLine) {\n\t\t\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Range(lineNumber, column, position.lineNumber, position.column);\n\t}\n\n\tpublic static _deleteWordPartRight(model: ICursorSimpleModel, selection: Selection): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst pos = selection.getPosition();\n\t\tconst toPosition = WordOperations._moveWordPartRight(model, pos);\n\t\treturn new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n\t}\n\n\tpublic static word(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean, position: Position): SingleCursorState {\n\t\tconst wordSeparators = getMapForWordSeparators(config.wordSeparators);\n\t\tlet prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\t\tlet nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n\t\tif (!inSelectionMode) {\n\t\t\t// Entering word selection for the first time\n\t\t\tlet startColumn: number;\n\t\t\tlet endColumn: number;\n\n\t\t\tif (prevWord && prevWord.wordType === WordType.Regular && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n\t\t\t\t// isTouchingPrevWord\n\t\t\t\tstartColumn = prevWord.start + 1;\n\t\t\t\tendColumn = prevWord.end + 1;\n\t\t\t} else if (nextWord && nextWord.wordType === WordType.Regular && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n\t\t\t\t// isTouchingNextWord\n\t\t\t\tstartColumn = nextWord.start + 1;\n\t\t\t\tendColumn = nextWord.end + 1;\n\t\t\t} else {\n\t\t\t\tif (prevWord) {\n\t\t\t\t\tstartColumn = prevWord.end + 1;\n\t\t\t\t} else {\n\t\t\t\t\tstartColumn = 1;\n\t\t\t\t}\n\t\t\t\tif (nextWord) {\n\t\t\t\t\tendColumn = nextWord.start + 1;\n\t\t\t\t} else {\n\t\t\t\t\tendColumn = model.getLineMaxColumn(position.lineNumber);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new SingleCursorState(\n\t\t\t\tnew Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 0,\n\t\t\t\tnew Position(position.lineNumber, endColumn), 0\n\t\t\t);\n\t\t}\n\n\t\tlet startColumn: number;\n\t\tlet endColumn: number;\n\n\t\tif (prevWord && prevWord.wordType === WordType.Regular && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n\t\t\t// isInsidePrevWord\n\t\t\tstartColumn = prevWord.start + 1;\n\t\t\tendColumn = prevWord.end + 1;\n\t\t} else if (nextWord && nextWord.wordType === WordType.Regular && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n\t\t\t// isInsideNextWord\n\t\t\tstartColumn = nextWord.start + 1;\n\t\t\tendColumn = nextWord.end + 1;\n\t\t} else {\n\t\t\tstartColumn = position.column;\n\t\t\tendColumn = position.column;\n\t\t}\n\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column: number;\n\t\tif (cursor.selectionStart.containsPosition(position)) {\n\t\t\tcolumn = cursor.selectionStart.endColumn;\n\t\t} else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n\t\t\tcolumn = startColumn;\n\t\t\tlet possiblePosition = new Position(lineNumber, column);\n\t\t\tif (cursor.selectionStart.containsPosition(possiblePosition)) {\n\t\t\t\tcolumn = cursor.selectionStart.endColumn;\n\t\t\t}\n\t\t} else {\n\t\t\tcolumn = endColumn;\n\t\t\tlet possiblePosition = new Position(lineNumber, column);\n\t\t\tif (cursor.selectionStart.containsPosition(possiblePosition)) {\n\t\t\t\tcolumn = cursor.selectionStart.startColumn;\n\t\t\t}\n\t\t}\n\n\t\treturn cursor.move(true, lineNumber, column, 0);\n\t}\n}\n\nexport class WordPartOperations extends WordOperations {\n\tpublic static deleteWordPartLeft(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, selection: Selection, whitespaceHeuristics: boolean): Range {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.deleteWordLeft(wordSeparators, model, selection, whitespaceHeuristics, WordNavigationType.WordStart),\n\t\t\tWordOperations.deleteWordLeft(wordSeparators, model, selection, whitespaceHeuristics, WordNavigationType.WordEnd),\n\t\t\tWordOperations._deleteWordPartLeft(model, selection)\n\t\t]);\n\t\tcandidates.sort(Range.compareRangesUsingEnds);\n\t\treturn candidates[2];\n\t}\n\n\tpublic static deleteWordPartRight(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, selection: Selection, whitespaceHeuristics: boolean): Range {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.deleteWordRight(wordSeparators, model, selection, whitespaceHeuristics, WordNavigationType.WordStart),\n\t\t\tWordOperations.deleteWordRight(wordSeparators, model, selection, whitespaceHeuristics, WordNavigationType.WordEnd),\n\t\t\tWordOperations._deleteWordPartRight(model, selection)\n\t\t]);\n\t\tcandidates.sort(Range.compareRangesUsingStarts);\n\t\treturn candidates[0];\n\t}\n\n\tpublic static moveWordPartLeft(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): Position {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.moveWordLeft(wordSeparators, model, position, WordNavigationType.WordStart),\n\t\t\tWordOperations.moveWordLeft(wordSeparators, model, position, WordNavigationType.WordEnd),\n\t\t\tWordOperations._moveWordPartLeft(model, position)\n\t\t]);\n\t\tcandidates.sort(Position.compare);\n\t\treturn candidates[2];\n\t}\n\n\tpublic static moveWordPartRight(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): Position {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.moveWordRight(wordSeparators, model, position, WordNavigationType.WordStart),\n\t\t\tWordOperations.moveWordRight(wordSeparators, model, position, WordNavigationType.WordEnd),\n\t\t\tWordOperations._moveWordPartRight(model, position)\n\t\t]);\n\t\tcandidates.sort(Position.compare);\n\t\treturn candidates[0];\n\t}\n}\n\nfunction enforceDefined<T>(arr: Array<T | undefined | null>): T[] {\n\treturn <T[]>arr.filter(el => Boolean(el));\n}"]}]}