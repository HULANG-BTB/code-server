{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/foldingRanges.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/foldingRanges.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MAX_FOLDING_REGIONS = 0xFFFF;\nexports.MAX_LINE_NUMBER = 0xFFFFFF;\nvar MASK_INDENT = 0xFF000000;\nvar FoldingRegions = /** @class */ (function () {\n    function FoldingRegions(startIndexes, endIndexes, types) {\n        if (startIndexes.length !== endIndexes.length || startIndexes.length > exports.MAX_FOLDING_REGIONS) {\n            throw new Error('invalid startIndexes or endIndexes size');\n        }\n        this._startIndexes = startIndexes;\n        this._endIndexes = endIndexes;\n        this._collapseStates = new Uint32Array(Math.ceil(startIndexes.length / 32));\n        this._types = types;\n    }\n    FoldingRegions.prototype.ensureParentIndices = function () {\n        var _this = this;\n        if (!this._parentsComputed) {\n            this._parentsComputed = true;\n            var parentIndexes_1 = [];\n            var isInsideLast = function (startLineNumber, endLineNumber) {\n                var index = parentIndexes_1[parentIndexes_1.length - 1];\n                return _this.getStartLineNumber(index) <= startLineNumber && _this.getEndLineNumber(index) >= endLineNumber;\n            };\n            for (var i = 0, len = this._startIndexes.length; i < len; i++) {\n                var startLineNumber = this._startIndexes[i];\n                var endLineNumber = this._endIndexes[i];\n                if (startLineNumber > exports.MAX_LINE_NUMBER || endLineNumber > exports.MAX_LINE_NUMBER) {\n                    throw new Error('startLineNumber or endLineNumber must not exceed ' + exports.MAX_LINE_NUMBER);\n                }\n                while (parentIndexes_1.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {\n                    parentIndexes_1.pop();\n                }\n                var parentIndex = parentIndexes_1.length > 0 ? parentIndexes_1[parentIndexes_1.length - 1] : -1;\n                parentIndexes_1.push(i);\n                this._startIndexes[i] = startLineNumber + ((parentIndex & 0xFF) << 24);\n                this._endIndexes[i] = endLineNumber + ((parentIndex & 0xFF00) << 16);\n            }\n        }\n    };\n    Object.defineProperty(FoldingRegions.prototype, \"length\", {\n        get: function () {\n            return this._startIndexes.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    FoldingRegions.prototype.getStartLineNumber = function (index) {\n        return this._startIndexes[index] & exports.MAX_LINE_NUMBER;\n    };\n    FoldingRegions.prototype.getEndLineNumber = function (index) {\n        return this._endIndexes[index] & exports.MAX_LINE_NUMBER;\n    };\n    FoldingRegions.prototype.getType = function (index) {\n        return this._types ? this._types[index] : undefined;\n    };\n    FoldingRegions.prototype.hasTypes = function () {\n        return !!this._types;\n    };\n    FoldingRegions.prototype.isCollapsed = function (index) {\n        var arrayIndex = (index / 32) | 0;\n        var bit = index % 32;\n        return (this._collapseStates[arrayIndex] & (1 << bit)) !== 0;\n    };\n    FoldingRegions.prototype.setCollapsed = function (index, newState) {\n        var arrayIndex = (index / 32) | 0;\n        var bit = index % 32;\n        var value = this._collapseStates[arrayIndex];\n        if (newState) {\n            this._collapseStates[arrayIndex] = value | (1 << bit);\n        }\n        else {\n            this._collapseStates[arrayIndex] = value & ~(1 << bit);\n        }\n    };\n    FoldingRegions.prototype.toRegion = function (index) {\n        return new FoldingRegion(this, index);\n    };\n    FoldingRegions.prototype.getParentIndex = function (index) {\n        this.ensureParentIndices();\n        var parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);\n        if (parent === exports.MAX_FOLDING_REGIONS) {\n            return -1;\n        }\n        return parent;\n    };\n    FoldingRegions.prototype.contains = function (index, line) {\n        return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;\n    };\n    FoldingRegions.prototype.findIndex = function (line) {\n        var low = 0, high = this._startIndexes.length;\n        if (high === 0) {\n            return -1; // no children\n        }\n        while (low < high) {\n            var mid = Math.floor((low + high) / 2);\n            if (line < this.getStartLineNumber(mid)) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low - 1;\n    };\n    FoldingRegions.prototype.findRange = function (line) {\n        var index = this.findIndex(line);\n        if (index >= 0) {\n            var endLineNumber = this.getEndLineNumber(index);\n            if (endLineNumber >= line) {\n                return index;\n            }\n            index = this.getParentIndex(index);\n            while (index !== -1) {\n                if (this.contains(index, line)) {\n                    return index;\n                }\n                index = this.getParentIndex(index);\n            }\n        }\n        return -1;\n    };\n    FoldingRegions.prototype.toString = function () {\n        var res = [];\n        for (var i = 0; i < this.length; i++) {\n            res[i] = \"[\" + (this.isCollapsed(i) ? '+' : '-') + \"] \" + this.getStartLineNumber(i) + \"/\" + this.getEndLineNumber(i);\n        }\n        return res.join(', ');\n    };\n    return FoldingRegions;\n}());\nexports.FoldingRegions = FoldingRegions;\nvar FoldingRegion = /** @class */ (function () {\n    function FoldingRegion(ranges, index) {\n        this.ranges = ranges;\n        this.index = index;\n    }\n    Object.defineProperty(FoldingRegion.prototype, \"startLineNumber\", {\n        get: function () {\n            return this.ranges.getStartLineNumber(this.index);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FoldingRegion.prototype, \"endLineNumber\", {\n        get: function () {\n            return this.ranges.getEndLineNumber(this.index);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FoldingRegion.prototype, \"regionIndex\", {\n        get: function () {\n            return this.index;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FoldingRegion.prototype, \"parentIndex\", {\n        get: function () {\n            return this.ranges.getParentIndex(this.index);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FoldingRegion.prototype, \"isCollapsed\", {\n        get: function () {\n            return this.ranges.isCollapsed(this.index);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    FoldingRegion.prototype.containedBy = function (range) {\n        return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;\n    };\n    FoldingRegion.prototype.containsLine = function (lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;\n    };\n    FoldingRegion.prototype.hidesLine = function (lineNumber) {\n        return this.startLineNumber < lineNumber && lineNumber <= this.endLineNumber;\n    };\n    return FoldingRegion;\n}());\nexports.FoldingRegion = FoldingRegion;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/foldingRanges.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/foldingRanges.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface ILineRange {\n\tstartLineNumber: number;\n\tendLineNumber: number;\n}\n\nexport const MAX_FOLDING_REGIONS = 0xFFFF;\nexport const MAX_LINE_NUMBER = 0xFFFFFF;\n\nconst MASK_INDENT = 0xFF000000;\n\nexport class FoldingRegions {\n\tprivate readonly _startIndexes: Uint32Array;\n\tprivate readonly _endIndexes: Uint32Array;\n\tprivate readonly _collapseStates: Uint32Array;\n\tprivate _parentsComputed: boolean;\n\tprivate readonly _types: Array<string | undefined> | undefined;\n\n\tconstructor(startIndexes: Uint32Array, endIndexes: Uint32Array, types?: Array<string | undefined>) {\n\t\tif (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {\n\t\t\tthrow new Error('invalid startIndexes or endIndexes size');\n\t\t}\n\t\tthis._startIndexes = startIndexes;\n\t\tthis._endIndexes = endIndexes;\n\t\tthis._collapseStates = new Uint32Array(Math.ceil(startIndexes.length / 32));\n\t\tthis._types = types;\n\t}\n\n\tprivate ensureParentIndices() {\n\t\tif (!this._parentsComputed) {\n\t\t\tthis._parentsComputed = true;\n\t\t\tlet parentIndexes: number[] = [];\n\t\t\tlet isInsideLast = (startLineNumber: number, endLineNumber: number) => {\n\t\t\t\tlet index = parentIndexes[parentIndexes.length - 1];\n\t\t\t\treturn this.getStartLineNumber(index) <= startLineNumber && this.getEndLineNumber(index) >= endLineNumber;\n\t\t\t};\n\t\t\tfor (let i = 0, len = this._startIndexes.length; i < len; i++) {\n\t\t\t\tlet startLineNumber = this._startIndexes[i];\n\t\t\t\tlet endLineNumber = this._endIndexes[i];\n\t\t\t\tif (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n\t\t\t\t\tthrow new Error('startLineNumber or endLineNumber must not exceed ' + MAX_LINE_NUMBER);\n\t\t\t\t}\n\t\t\t\twhile (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {\n\t\t\t\t\tparentIndexes.pop();\n\t\t\t\t}\n\t\t\t\tlet parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;\n\t\t\t\tparentIndexes.push(i);\n\t\t\t\tthis._startIndexes[i] = startLineNumber + ((parentIndex & 0xFF) << 24);\n\t\t\t\tthis._endIndexes[i] = endLineNumber + ((parentIndex & 0xFF00) << 16);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic get length(): number {\n\t\treturn this._startIndexes.length;\n\t}\n\n\tpublic getStartLineNumber(index: number): number {\n\t\treturn this._startIndexes[index] & MAX_LINE_NUMBER;\n\t}\n\n\tpublic getEndLineNumber(index: number): number {\n\t\treturn this._endIndexes[index] & MAX_LINE_NUMBER;\n\t}\n\n\tpublic getType(index: number): string | undefined {\n\t\treturn this._types ? this._types[index] : undefined;\n\t}\n\n\tpublic hasTypes() {\n\t\treturn !!this._types;\n\t}\n\n\tpublic isCollapsed(index: number): boolean {\n\t\tlet arrayIndex = (index / 32) | 0;\n\t\tlet bit = index % 32;\n\t\treturn (this._collapseStates[arrayIndex] & (1 << bit)) !== 0;\n\t}\n\n\tpublic setCollapsed(index: number, newState: boolean) {\n\t\tlet arrayIndex = (index / 32) | 0;\n\t\tlet bit = index % 32;\n\t\tlet value = this._collapseStates[arrayIndex];\n\t\tif (newState) {\n\t\t\tthis._collapseStates[arrayIndex] = value | (1 << bit);\n\t\t} else {\n\t\t\tthis._collapseStates[arrayIndex] = value & ~(1 << bit);\n\t\t}\n\t}\n\n\tpublic toRegion(index: number): FoldingRegion {\n\t\treturn new FoldingRegion(this, index);\n\t}\n\n\tpublic getParentIndex(index: number) {\n\t\tthis.ensureParentIndices();\n\t\tlet parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);\n\t\tif (parent === MAX_FOLDING_REGIONS) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn parent;\n\t}\n\n\tpublic contains(index: number, line: number) {\n\t\treturn this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;\n\t}\n\n\tprivate findIndex(line: number) {\n\t\tlet low = 0, high = this._startIndexes.length;\n\t\tif (high === 0) {\n\t\t\treturn -1; // no children\n\t\t}\n\t\twhile (low < high) {\n\t\t\tlet mid = Math.floor((low + high) / 2);\n\t\t\tif (line < this.getStartLineNumber(mid)) {\n\t\t\t\thigh = mid;\n\t\t\t} else {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn low - 1;\n\t}\n\n\tpublic findRange(line: number): number {\n\t\tlet index = this.findIndex(line);\n\t\tif (index >= 0) {\n\t\t\tlet endLineNumber = this.getEndLineNumber(index);\n\t\t\tif (endLineNumber >= line) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tindex = this.getParentIndex(index);\n\t\t\twhile (index !== -1) {\n\t\t\t\tif (this.contains(index, line)) {\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t\tindex = this.getParentIndex(index);\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic toString() {\n\t\tlet res: string[] = [];\n\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\tres[i] = `[${this.isCollapsed(i) ? '+' : '-'}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;\n\t\t}\n\t\treturn res.join(', ');\n\t}\n}\n\nexport class FoldingRegion {\n\n\tconstructor(private readonly ranges: FoldingRegions, private index: number) {\n\t}\n\n\tpublic get startLineNumber() {\n\t\treturn this.ranges.getStartLineNumber(this.index);\n\t}\n\n\tpublic get endLineNumber() {\n\t\treturn this.ranges.getEndLineNumber(this.index);\n\t}\n\n\tpublic get regionIndex() {\n\t\treturn this.index;\n\t}\n\n\tpublic get parentIndex() {\n\t\treturn this.ranges.getParentIndex(this.index);\n\t}\n\n\tpublic get isCollapsed() {\n\t\treturn this.ranges.isCollapsed(this.index);\n\t}\n\n\tcontainedBy(range: ILineRange): boolean {\n\t\treturn range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;\n\t}\n\tcontainsLine(lineNumber: number) {\n\t\treturn this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;\n\t}\n\thidesLine(lineNumber: number) {\n\t\treturn this.startLineNumber < lineNumber && lineNumber <= this.endLineNumber;\n\t}\n}"]}]}