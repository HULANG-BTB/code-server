{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/electron-browser/extensionService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/electron-browser/extensionService.ts","mtime":1555846338048},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/path\", \"electron\", \"vs/base/common/arrays\", \"vs/base/common/async\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/base/common/performance\", \"vs/base/common/resources\", \"vs/base/common/uri\", \"vs/platform/environment/common/environment\", \"vs/platform/extensionManagement/common/extensionManagement\", \"vs/platform/extensionManagement/common/extensionManagementUtil\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/platform/product/node/package\", \"vs/platform/product/node/product\", \"vs/platform/notification/common/notification\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/windows/common/windows\", \"vs/workbench/services/extensions/common/extensions\", \"vs/workbench/services/extensions/common/extensionsRegistry\", \"vs/workbench/services/extensions/electron-browser/extensionHost\", \"vs/workbench/services/extensions/node/extensionDescriptionRegistry\", \"vs/workbench/services/extensions/node/rpcProtocol\", \"vs/workbench/services/extensions/electron-browser/cachedExtensionScanner\", \"vs/workbench/services/extensions/electron-browser/extensionHostProcessManager\", \"vs/platform/extensions/common/extensions\", \"vs/base/common/network\", \"vs/platform/instantiation/common/extensions\", \"vs/platform/files/common/files\", \"vs/workbench/services/extensions/common/extensionDevOptions\"], function (require, exports, nls, path, electron_1, arrays_1, async_1, event_1, lifecycle_1, perf, resources_1, uri_1, environment_1, extensionManagement_1, extensionManagementUtil_1, instantiation_1, lifecycle_2, package_1, product_1, notification_1, telemetry_1, windows_1, extensions_1, extensionsRegistry_1, extensionHost_1, extensionDescriptionRegistry_1, rpcProtocol_1, cachedExtensionScanner_1, extensionHostProcessManager_1, extensions_2, network_1, extensions_3, files_1, extensionDevOptions_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const hasOwnProperty = Object.hasOwnProperty;\n    const NO_OP_VOID_PROMISE = Promise.resolve(undefined);\n    extensionsRegistry_1.schema.properties.engines.properties.vscode.default = `^${package_1.default.version}`;\n    let productAllowProposedApi = null;\n    function allowProposedApiFromProduct(id) {\n        // create set if needed\n        if (!productAllowProposedApi) {\n            productAllowProposedApi = new Set();\n            if (arrays_1.isNonEmptyArray(product_1.default.extensionAllowedProposedApi)) {\n                product_1.default.extensionAllowedProposedApi.forEach((id) => productAllowProposedApi.add(extensions_2.ExtensionIdentifier.toKey(id)));\n            }\n        }\n        return productAllowProposedApi.has(extensions_2.ExtensionIdentifier.toKey(id));\n    }\n    class DeltaExtensionsQueueItem {\n        constructor(toAdd, toRemove) {\n            this.toAdd = toAdd;\n            this.toRemove = toRemove;\n        }\n    }\n    let ExtensionService = class ExtensionService extends lifecycle_1.Disposable {\n        constructor(_instantiationService, _notificationService, _environmentService, _telemetryService, _extensionEnablementService, _extensionManagementService, _windowService, _lifecycleService, fileService) {\n            super();\n            this._instantiationService = _instantiationService;\n            this._notificationService = _notificationService;\n            this._environmentService = _environmentService;\n            this._telemetryService = _telemetryService;\n            this._extensionEnablementService = _extensionEnablementService;\n            this._extensionManagementService = _extensionManagementService;\n            this._windowService = _windowService;\n            this._lifecycleService = _lifecycleService;\n            this._onDidRegisterExtensions = this._register(new event_1.Emitter());\n            this.onDidRegisterExtensions = this._onDidRegisterExtensions.event;\n            this._onDidChangeExtensionsStatus = this._register(new event_1.Emitter());\n            this.onDidChangeExtensionsStatus = this._onDidChangeExtensionsStatus.event;\n            this._onDidChangeExtensions = this._register(new event_1.Emitter());\n            this.onDidChangeExtensions = this._onDidChangeExtensions.event;\n            this._onWillActivateByEvent = this._register(new event_1.Emitter());\n            this.onWillActivateByEvent = this._onWillActivateByEvent.event;\n            this._onDidChangeResponsiveChange = this._register(new event_1.Emitter());\n            this.onDidChangeResponsiveChange = this._onDidChangeResponsiveChange.event;\n            this.retry = require('vs/../../../../packages/vscode/src/workbench').workbench.retry.register('Extension Host', () => this.startExtensionHost());\n            this._inHandleDeltaExtensions = false;\n            // help the file service to activate providers by activating extensions by file system event\n            this._register(fileService.onWillActivateFileSystemProvider(e => {\n                e.join(this.activateByEvent(`onFileSystem:${e.scheme}`));\n            }));\n            this._extensionHostLogsLocation = uri_1.URI.file(path.join(this._environmentService.logsPath, `exthost${this._windowService.getCurrentWindowId()}`));\n            this._registry = new extensionDescriptionRegistry_1.ExtensionDescriptionRegistry([]);\n            this._installedExtensionsReady = new async_1.Barrier();\n            this._isDev = !this._environmentService.isBuilt || this._environmentService.isExtensionDevelopment;\n            this._extensionsMessages = new Map();\n            this._allRequestedActivateEvents = Object.create(null);\n            this._extensionScanner = this._instantiationService.createInstance(cachedExtensionScanner_1.CachedExtensionScanner);\n            this._deltaExtensionsQueue = [];\n            this._extensionHostProcessManagers = [];\n            this._extensionHostActiveExtensions = new Map();\n            this._extensionHostProcessActivationTimes = new Map();\n            this._extensionHostExtensionRuntimeErrors = new Map();\n            this._startDelayed(this._lifecycleService);\n            if (this._extensionEnablementService.allUserExtensionsDisabled) {\n                this._notificationService.prompt(notification_1.Severity.Info, nls.localize('extensionsDisabled', \"All installed extensions are temporarily disabled. Reload the window to return to the previous state.\"), [{\n                        label: nls.localize('Reload', \"Reload\"),\n                        run: () => {\n                            this._windowService.reloadWindow();\n                        }\n                    }]);\n            }\n            this._register(this._extensionEnablementService.onEnablementChanged((extensions) => {\n                let toAdd = [];\n                let toRemove = [];\n                for (const extension of extensions) {\n                    if (this._extensionEnablementService.isEnabled(extension)) {\n                        // an extension has been enabled\n                        toAdd.push(extension);\n                    }\n                    else {\n                        // an extension has been disabled\n                        toRemove.push(extension.identifier.id);\n                    }\n                }\n                this._handleDeltaExtensions(new DeltaExtensionsQueueItem(toAdd, toRemove));\n            }));\n            this._register(this._extensionManagementService.onDidInstallExtension((event) => {\n                if (event.local) {\n                    if (this._extensionEnablementService.isEnabled(event.local)) {\n                        // an extension has been installed\n                        this._handleDeltaExtensions(new DeltaExtensionsQueueItem([event.local], []));\n                    }\n                }\n            }));\n            this._register(this._extensionManagementService.onDidUninstallExtension((event) => {\n                if (!event.error) {\n                    // an extension has been uninstalled\n                    this._handleDeltaExtensions(new DeltaExtensionsQueueItem([], [event.identifier.id]));\n                }\n            }));\n        }\n        _handleDeltaExtensions(item) {\n            return __awaiter(this, void 0, void 0, function* () {\n                this._deltaExtensionsQueue.push(item);\n                if (this._inHandleDeltaExtensions) {\n                    // Let the current item finish, the new one will be picked up\n                    return;\n                }\n                while (this._deltaExtensionsQueue.length > 0) {\n                    const item = this._deltaExtensionsQueue.shift();\n                    try {\n                        this._inHandleDeltaExtensions = true;\n                        yield this._deltaExtensions(item.toAdd, item.toRemove);\n                    }\n                    finally {\n                        this._inHandleDeltaExtensions = false;\n                    }\n                }\n            });\n        }\n        _deltaExtensions(_toAdd, _toRemove) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (this._windowService.getConfiguration().remoteAuthority) {\n                    return;\n                }\n                let toAdd = [];\n                for (let i = 0, len = _toAdd.length; i < len; i++) {\n                    const extension = _toAdd[i];\n                    if (extension.location.scheme !== network_1.Schemas.file) {\n                        continue;\n                    }\n                    const existingExtensionDescription = this._registry.getExtensionDescription(extension.identifier.id);\n                    if (existingExtensionDescription) {\n                        // this extension is already running (most likely at a different version)\n                        continue;\n                    }\n                    const extensionDescription = yield this._extensionScanner.scanSingleExtension(extension.location.fsPath, extension.type === extensions_2.ExtensionType.System, this.createLogger());\n                    if (!extensionDescription) {\n                        // could not scan extension...\n                        continue;\n                    }\n                    toAdd.push(extensionDescription);\n                }\n                let toRemove = [];\n                for (let i = 0, len = _toRemove.length; i < len; i++) {\n                    const extensionId = _toRemove[i];\n                    const extensionDescription = this._registry.getExtensionDescription(extensionId);\n                    if (!extensionDescription) {\n                        // ignore disabling/uninstalling an extension which is not running\n                        continue;\n                    }\n                    if (!this._canRemoveExtension(extensionDescription)) {\n                        // uses non-dynamic extension point or is activated\n                        continue;\n                    }\n                    toRemove.push(extensionDescription);\n                }\n                if (toAdd.length === 0 && toRemove.length === 0) {\n                    return;\n                }\n                // Update the local registry\n                const result = this._registry.deltaExtensions(toAdd, toRemove.map(e => e.identifier));\n                toRemove = toRemove.concat(result.removedDueToLooping);\n                if (result.removedDueToLooping.length > 0) {\n                    this._logOrShowMessage(notification_1.Severity.Error, nls.localize('looping', \"The following extensions contain dependency loops and have been disabled: {0}\", result.removedDueToLooping.map(e => `'${e.identifier.value}'`).join(', ')));\n                }\n                // Update extension points\n                this._rehandleExtensionPoints([].concat(toAdd).concat(toRemove));\n                // Update the extension host\n                if (this._extensionHostProcessManagers.length > 0) {\n                    yield this._extensionHostProcessManagers[0].deltaExtensions(toAdd, toRemove.map(e => e.identifier));\n                }\n                this._onDidChangeExtensions.fire(undefined);\n                for (let i = 0; i < toAdd.length; i++) {\n                    this._activateAddedExtensionIfNeeded(toAdd[i]);\n                }\n            });\n        }\n        _rehandleExtensionPoints(extensionDescriptions) {\n            const affectedExtensionPoints = Object.create(null);\n            for (let extensionDescription of extensionDescriptions) {\n                if (extensionDescription.contributes) {\n                    for (let extPointName in extensionDescription.contributes) {\n                        if (hasOwnProperty.call(extensionDescription.contributes, extPointName)) {\n                            affectedExtensionPoints[extPointName] = true;\n                        }\n                    }\n                }\n            }\n            const messageHandler = (msg) => this._handleExtensionPointMessage(msg);\n            const availableExtensions = this._registry.getAllExtensionDescriptions();\n            const extensionPoints = extensionsRegistry_1.ExtensionsRegistry.getExtensionPoints();\n            for (let i = 0, len = extensionPoints.length; i < len; i++) {\n                if (affectedExtensionPoints[extensionPoints[i].name]) {\n                    ExtensionService._handleExtensionPoint(extensionPoints[i], availableExtensions, messageHandler);\n                }\n            }\n        }\n        canAddExtension(extension) {\n            if (this._windowService.getConfiguration().remoteAuthority) {\n                return false;\n            }\n            if (extension.extensionLocation.scheme !== network_1.Schemas.file) {\n                return false;\n            }\n            const extensionDescription = this._registry.getExtensionDescription(extension.identifier);\n            if (extensionDescription) {\n                // ignore adding an extension which is already running and cannot be removed\n                if (!this._canRemoveExtension(extensionDescription)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        canRemoveExtension(extension) {\n            if (this._windowService.getConfiguration().remoteAuthority) {\n                return false;\n            }\n            if (extension.extensionLocation.scheme !== network_1.Schemas.file) {\n                return false;\n            }\n            const extensionDescription = this._registry.getExtensionDescription(extension.identifier);\n            if (!extensionDescription) {\n                // ignore removing an extension which is not running\n                return false;\n            }\n            return this._canRemoveExtension(extensionDescription);\n        }\n        _canRemoveExtension(extension) {\n            if (this._extensionHostActiveExtensions.has(extensions_2.ExtensionIdentifier.toKey(extension.identifier))) {\n                // Extension is running, cannot remove it safely\n                return false;\n            }\n            return true;\n        }\n        _activateAddedExtensionIfNeeded(extensionDescription) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let shouldActivate = false;\n                let shouldActivateReason = null;\n                if (Array.isArray(extensionDescription.activationEvents)) {\n                    for (let activationEvent of extensionDescription.activationEvents) {\n                        // TODO@joao: there's no easy way to contribute this\n                        if (activationEvent === 'onUri') {\n                            activationEvent = `onUri:${extensions_2.ExtensionIdentifier.toKey(extensionDescription.identifier)}`;\n                        }\n                        if (this._allRequestedActivateEvents[activationEvent]) {\n                            // This activation event was fired before the extension was added\n                            shouldActivate = true;\n                            shouldActivateReason = activationEvent;\n                            break;\n                        }\n                        if (activationEvent === '*') {\n                            shouldActivate = true;\n                            shouldActivateReason = activationEvent;\n                            break;\n                        }\n                        if (/^workspaceContains/.test(activationEvent)) {\n                            // do not trigger a search, just activate in this case...\n                            shouldActivate = true;\n                            shouldActivateReason = activationEvent;\n                            break;\n                        }\n                    }\n                }\n                if (shouldActivate) {\n                    yield Promise.all(this._extensionHostProcessManagers.map(extHostManager => extHostManager.activate(extensionDescription.identifier, shouldActivateReason))).then(() => { });\n                }\n            });\n        }\n        _startDelayed(lifecycleService) {\n            // delay extension host creation and extension scanning\n            // until the workbench is running. we cannot defer the\n            // extension host more (LifecyclePhase.Restored) because\n            // some editors require the extension host to restore\n            // and this would result in a deadlock\n            // see https://github.com/Microsoft/vscode/issues/41322\n            lifecycleService.when(lifecycle_2.LifecyclePhase.Ready).then(() => {\n                // reschedule to ensure this runs after restoring viewlets, panels, and editors\n                async_1.runWhenIdle(() => {\n                    perf.mark('willLoadExtensions');\n                    this._startExtensionHostProcess(true, []);\n                    this._scanAndHandleExtensions();\n                    this.whenInstalledExtensionsRegistered().then(() => perf.mark('didLoadExtensions'));\n                }, 50 /*max delay*/);\n            });\n        }\n        dispose() {\n            super.dispose();\n            this._onWillActivateByEvent.dispose();\n            this._onDidChangeResponsiveChange.dispose();\n        }\n        restartExtensionHost() {\n            this._stopExtensionHostProcess();\n            this._startExtensionHostProcess(false, Object.keys(this._allRequestedActivateEvents));\n        }\n        startExtensionHost() {\n            this._startExtensionHostProcess(false, Object.keys(this._allRequestedActivateEvents));\n        }\n        stopExtensionHost() {\n            this._stopExtensionHostProcess();\n        }\n        _stopExtensionHostProcess() {\n            let previouslyActivatedExtensionIds = [];\n            this._extensionHostActiveExtensions.forEach((value) => {\n                previouslyActivatedExtensionIds.push(value);\n            });\n            for (const manager of this._extensionHostProcessManagers) {\n                manager.dispose();\n            }\n            this._extensionHostProcessManagers = [];\n            this._extensionHostActiveExtensions = new Map();\n            this._extensionHostProcessActivationTimes = new Map();\n            this._extensionHostExtensionRuntimeErrors = new Map();\n            if (previouslyActivatedExtensionIds.length > 0) {\n                this._onDidChangeExtensionsStatus.fire(previouslyActivatedExtensionIds);\n            }\n        }\n        _startExtensionHostProcess(isInitialStart, initialActivationEvents) {\n            this._stopExtensionHostProcess();\n            let autoStart;\n            let extensions;\n            if (isInitialStart) {\n                autoStart = false;\n                extensions = this._extensionScanner.scannedExtensions;\n            }\n            else {\n                // restart case\n                autoStart = true;\n                extensions = this.getExtensions();\n            }\n            const extHostProcessWorker = this._instantiationService.createInstance(extensionHost_1.ExtensionHostProcessWorker, autoStart, extensions, this._extensionHostLogsLocation);\n            extHostProcessWorker.start().then(() => this.retry.recover());\n            const extHostProcessManager = this._instantiationService.createInstance(extensionHostProcessManager_1.ExtensionHostProcessManager, extHostProcessWorker, null, initialActivationEvents);\n            extHostProcessManager.onDidCrash(([code, signal]) => this._onExtensionHostCrashed(code, signal));\n            extHostProcessManager.onDidChangeResponsiveState((responsiveState) => { this._onDidChangeResponsiveChange.fire({ target: extHostProcessManager, isResponsive: responsiveState === rpcProtocol_1.ResponsiveState.Responsive }); });\n            this._extensionHostProcessManagers.push(extHostProcessManager);\n        }\n        _onExtensionHostCrashed(code, signal) {\n            return this.retry.run();\n            console.error('Extension host terminated unexpectedly. Code: ', code, ' Signal: ', signal);\n            this._stopExtensionHostProcess();\n            if (code === 55) {\n                this._notificationService.prompt(notification_1.Severity.Error, nls.localize('extensionHostProcess.versionMismatchCrash', \"Extension host cannot start: version mismatch.\"), [{\n                        label: nls.localize('relaunch', \"Relaunch VS Code\"),\n                        run: () => {\n                            this._instantiationService.invokeFunction((accessor) => {\n                                const windowsService = accessor.get(windows_1.IWindowsService);\n                                windowsService.relaunch({});\n                            });\n                        }\n                    }]);\n                return;\n            }\n            let message = nls.localize('extensionHostProcess.crash', \"Extension host terminated unexpectedly.\");\n            if (code === 87) {\n                message = nls.localize('extensionHostProcess.unresponsiveCrash', \"Extension host terminated because it was not responsive.\");\n            }\n            this._notificationService.prompt(notification_1.Severity.Error, message, [{\n                    label: nls.localize('devTools', \"Open Developer Tools\"),\n                    run: () => this._windowService.openDevTools()\n                },\n                {\n                    label: nls.localize('restart', \"Restart Extension Host\"),\n                    run: () => this._startExtensionHostProcess(false, Object.keys(this._allRequestedActivateEvents))\n                }]);\n        }\n        // ---- begin IExtensionService\n        activateByEvent(activationEvent) {\n            if (this._installedExtensionsReady.isOpen()) {\n                // Extensions have been scanned and interpreted\n                // Record the fact that this activationEvent was requested (in case of a restart)\n                this._allRequestedActivateEvents[activationEvent] = true;\n                if (!this._registry.containsActivationEvent(activationEvent)) {\n                    // There is no extension that is interested in this activation event\n                    return NO_OP_VOID_PROMISE;\n                }\n                return this._activateByEvent(activationEvent);\n            }\n            else {\n                // Extensions have not been scanned yet.\n                // Record the fact that this activationEvent was requested (in case of a restart)\n                this._allRequestedActivateEvents[activationEvent] = true;\n                return this._installedExtensionsReady.wait().then(() => this._activateByEvent(activationEvent));\n            }\n        }\n        _activateByEvent(activationEvent) {\n            const result = Promise.all(this._extensionHostProcessManagers.map(extHostManager => extHostManager.activateByEvent(activationEvent))).then(() => { });\n            this._onWillActivateByEvent.fire({\n                event: activationEvent,\n                activation: result\n            });\n            return result;\n        }\n        whenInstalledExtensionsRegistered() {\n            return this._installedExtensionsReady.wait();\n        }\n        getExtensions() {\n            return this._installedExtensionsReady.wait().then(() => {\n                return this._registry.getAllExtensionDescriptions();\n            });\n        }\n        getExtension(id) {\n            return this._installedExtensionsReady.wait().then(() => {\n                return this._registry.getExtensionDescription(id);\n            });\n        }\n        readExtensionPointContributions(extPoint) {\n            return this._installedExtensionsReady.wait().then(() => {\n                let availableExtensions = this._registry.getAllExtensionDescriptions();\n                let result = [], resultLen = 0;\n                for (let i = 0, len = availableExtensions.length; i < len; i++) {\n                    let desc = availableExtensions[i];\n                    if (desc.contributes && hasOwnProperty.call(desc.contributes, extPoint.name)) {\n                        result[resultLen++] = new extensions_1.ExtensionPointContribution(desc, desc.contributes[extPoint.name]);\n                    }\n                }\n                return result;\n            });\n        }\n        getExtensionsStatus() {\n            let result = Object.create(null);\n            if (this._registry) {\n                const extensions = this._registry.getAllExtensionDescriptions();\n                for (const extension of extensions) {\n                    const extensionKey = extensions_2.ExtensionIdentifier.toKey(extension.identifier);\n                    result[extension.identifier.value] = {\n                        messages: this._extensionsMessages.get(extensionKey) || [],\n                        activationTimes: this._extensionHostProcessActivationTimes.get(extensionKey),\n                        runtimeErrors: this._extensionHostExtensionRuntimeErrors.get(extensionKey) || [],\n                    };\n                }\n            }\n            return result;\n        }\n        canProfileExtensionHost() {\n            for (let i = 0, len = this._extensionHostProcessManagers.length; i < len; i++) {\n                const extHostProcessManager = this._extensionHostProcessManagers[i];\n                if (extHostProcessManager.canProfileExtensionHost()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        startExtensionHostProfile() {\n            for (let i = 0, len = this._extensionHostProcessManagers.length; i < len; i++) {\n                const extHostProcessManager = this._extensionHostProcessManagers[i];\n                if (extHostProcessManager.canProfileExtensionHost()) {\n                    return extHostProcessManager.startExtensionHostProfile();\n                }\n            }\n            throw new Error('Extension host not running or no inspect port available');\n        }\n        getInspectPort() {\n            if (this._extensionHostProcessManagers.length > 0) {\n                return this._extensionHostProcessManagers[0].getInspectPort();\n            }\n            return 0;\n        }\n        // ---- end IExtensionService\n        // --- impl\n        createLogger() {\n            return new cachedExtensionScanner_1.Logger((severity, source, message) => {\n                if (this._isDev && source) {\n                    this._logOrShowMessage(severity, `[${source}]: ${message}`);\n                }\n                else {\n                    this._logOrShowMessage(severity, message);\n                }\n            });\n        }\n        _scanAndHandleExtensions() {\n            return __awaiter(this, void 0, void 0, function* () {\n                this._extensionScanner.startScanningExtensions(this.createLogger());\n                const extensionHost = this._extensionHostProcessManagers[0];\n                const extensions = yield this._extensionScanner.scannedExtensions;\n                const enabledExtensions = yield this._getRuntimeExtensions(extensions);\n                this._handleExtensionPoints(enabledExtensions);\n                extensionHost.start(enabledExtensions.map(extension => extension.identifier).filter(id => this._registry.containsExtension(id)));\n                this._releaseBarrier();\n            });\n        }\n        _handleExtensionPoints(allExtensions) {\n            const result = this._registry.deltaExtensions(allExtensions, []);\n            if (result.removedDueToLooping.length > 0) {\n                this._logOrShowMessage(notification_1.Severity.Error, nls.localize('looping', \"The following extensions contain dependency loops and have been disabled: {0}\", result.removedDueToLooping.map(e => `'${e.identifier.value}'`).join(', ')));\n            }\n            let availableExtensions = this._registry.getAllExtensionDescriptions();\n            let extensionPoints = extensionsRegistry_1.ExtensionsRegistry.getExtensionPoints();\n            let messageHandler = (msg) => this._handleExtensionPointMessage(msg);\n            for (let i = 0, len = extensionPoints.length; i < len; i++) {\n                ExtensionService._handleExtensionPoint(extensionPoints[i], availableExtensions, messageHandler);\n            }\n        }\n        _releaseBarrier() {\n            perf.mark('extensionHostReady');\n            this._installedExtensionsReady.open();\n            this._onDidRegisterExtensions.fire(undefined);\n            this._onDidChangeExtensionsStatus.fire(this._registry.getAllExtensionDescriptions().map(e => e.identifier));\n        }\n        _getRuntimeExtensions(allExtensions) {\n            return this._extensionEnablementService.getDisabledExtensions()\n                .then(disabledExtensions => {\n                const runtimeExtensions = [];\n                const extensionsToDisable = [];\n                const userMigratedSystemExtensions = [{ id: extensionManagementUtil_1.BetterMergeId }];\n                let enableProposedApiFor = this._environmentService.args['enable-proposed-api'] || [];\n                const notFound = (id) => nls.localize('notFound', \"Extension \\`{0}\\` cannot use PROPOSED API as it cannot be found\", id);\n                if (enableProposedApiFor.length) {\n                    let allProposed = (enableProposedApiFor instanceof Array ? enableProposedApiFor : [enableProposedApiFor]);\n                    allProposed.forEach(id => {\n                        if (!allExtensions.some(description => extensions_2.ExtensionIdentifier.equals(description.identifier, id))) {\n                            console.error(notFound(id));\n                        }\n                    });\n                    // Make enabled proposed API be lowercase for case insensitive comparison\n                    if (Array.isArray(enableProposedApiFor)) {\n                        enableProposedApiFor = enableProposedApiFor.map(id => id.toLowerCase());\n                    }\n                    else {\n                        enableProposedApiFor = enableProposedApiFor.toLowerCase();\n                    }\n                }\n                const enableProposedApiForAll = !this._environmentService.isBuilt ||\n                    (!!this._environmentService.extensionDevelopmentLocationURI && product_1.default.nameLong !== 'Visual Studio Code') ||\n                    (enableProposedApiFor.length === 0 && 'enable-proposed-api' in this._environmentService.args);\n                for (const extension of allExtensions) {\n                    const isExtensionUnderDevelopment = (this._environmentService.isExtensionDevelopment\n                        && this._environmentService.extensionDevelopmentLocationURI\n                        && resources_1.isEqualOrParent(extension.extensionLocation, this._environmentService.extensionDevelopmentLocationURI));\n                    // Do not disable extensions under development\n                    if (!isExtensionUnderDevelopment) {\n                        if (disabledExtensions.some(disabled => extensionManagementUtil_1.areSameExtensions(disabled, { id: extension.identifier.value }))) {\n                            continue;\n                        }\n                    }\n                    if (!extension.isBuiltin) {\n                        // Check if the extension is changed to system extension\n                        const userMigratedSystemExtension = userMigratedSystemExtensions.filter(userMigratedSystemExtension => extensionManagementUtil_1.areSameExtensions(userMigratedSystemExtension, { id: extension.identifier.value }))[0];\n                        if (userMigratedSystemExtension) {\n                            extensionsToDisable.push(extension);\n                            continue;\n                        }\n                    }\n                    runtimeExtensions.push(this._updateEnableProposedApi(extension, enableProposedApiForAll, enableProposedApiFor));\n                }\n                this._telemetryService.publicLog('extensionsScanned', {\n                    totalCount: runtimeExtensions.length,\n                    disabledCount: disabledExtensions.length\n                });\n                if (extensionsToDisable.length) {\n                    return this._extensionEnablementService.setEnablement(extensionsToDisable.map(e => extensions_1.toExtension(e)), extensionManagement_1.EnablementState.Disabled)\n                        .then(() => runtimeExtensions);\n                }\n                else {\n                    return runtimeExtensions;\n                }\n            });\n        }\n        _updateEnableProposedApi(extension, enableProposedApiForAll, enableProposedApiFor) {\n            if (allowProposedApiFromProduct(extension.identifier)) {\n                // fast lane -> proposed api is available to all extensions\n                // that are listed in product.json-files\n                extension.enableProposedApi = true;\n            }\n            else if (extension.enableProposedApi && !extension.isBuiltin) {\n                if (!enableProposedApiForAll &&\n                    enableProposedApiFor.indexOf(extension.identifier.value.toLowerCase()) < 0) {\n                    extension.enableProposedApi = false;\n                    console.error(`Extension '${extension.identifier.value} cannot use PROPOSED API (must started out of dev or enabled via --enable-proposed-api)`);\n                }\n                else {\n                    // proposed api is available when developing or when an extension was explicitly\n                    // spelled out via a command line argument\n                    console.warn(`Extension '${extension.identifier.value}' uses PROPOSED API which is subject to change and removal without notice.`);\n                }\n            }\n            return extension;\n        }\n        _handleExtensionPointMessage(msg) {\n            const extensionKey = extensions_2.ExtensionIdentifier.toKey(msg.extensionId);\n            if (!this._extensionsMessages.has(extensionKey)) {\n                this._extensionsMessages.set(extensionKey, []);\n            }\n            this._extensionsMessages.get(extensionKey).push(msg);\n            const extension = this._registry.getExtensionDescription(msg.extensionId);\n            const strMsg = `[${msg.extensionId.value}]: ${msg.message}`;\n            if (extension && extension.isUnderDevelopment) {\n                // This message is about the extension currently being developed\n                this._showMessageToUser(msg.type, strMsg);\n            }\n            else {\n                this._logMessageInConsole(msg.type, strMsg);\n            }\n            if (!this._isDev && msg.extensionId) {\n                const { type, extensionId, extensionPointId, message } = msg;\n                /* __GDPR__\n                    \"extensionsMessage\" : {\n                        \"type\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                        \"extensionId\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n                        \"extensionPointId\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n                        \"message\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" }\n                    }\n                */\n                this._telemetryService.publicLog('extensionsMessage', {\n                    type, extensionId: extensionId.value, extensionPointId, message\n                });\n            }\n        }\n        static _handleExtensionPoint(extensionPoint, availableExtensions, messageHandler) {\n            let users = [], usersLen = 0;\n            for (let i = 0, len = availableExtensions.length; i < len; i++) {\n                let desc = availableExtensions[i];\n                if (desc.contributes && hasOwnProperty.call(desc.contributes, extensionPoint.name)) {\n                    users[usersLen++] = {\n                        description: desc,\n                        value: desc.contributes[extensionPoint.name],\n                        collector: new extensionsRegistry_1.ExtensionMessageCollector(messageHandler, desc, extensionPoint.name)\n                    };\n                }\n            }\n            extensionPoint.acceptUsers(users);\n        }\n        _showMessageToUser(severity, msg) {\n            if (severity === notification_1.Severity.Error || severity === notification_1.Severity.Warning) {\n                this._notificationService.notify({ severity, message: msg });\n            }\n            else {\n                this._logMessageInConsole(severity, msg);\n            }\n        }\n        _logMessageInConsole(severity, msg) {\n            if (severity === notification_1.Severity.Error) {\n                console.error(msg);\n            }\n            else if (severity === notification_1.Severity.Warning) {\n                console.warn(msg);\n            }\n            else {\n                console.log(msg);\n            }\n        }\n        // -- called by extension host\n        _logOrShowMessage(severity, msg) {\n            if (this._isDev) {\n                this._showMessageToUser(severity, msg);\n            }\n            else {\n                this._logMessageInConsole(severity, msg);\n            }\n        }\n        _activateById(extensionId, activationEvent) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const results = yield Promise.all(this._extensionHostProcessManagers.map(manager => manager.activate(extensionId, activationEvent)));\n                const activated = results.some(e => e);\n                if (!activated) {\n                    throw new Error(`Unknown extension ${extensionId.value}`);\n                }\n            });\n        }\n        _onWillActivateExtension(extensionId) {\n            this._extensionHostActiveExtensions.set(extensions_2.ExtensionIdentifier.toKey(extensionId), extensionId);\n        }\n        _onDidActivateExtension(extensionId, startup, codeLoadingTime, activateCallTime, activateResolvedTime, activationEvent) {\n            this._extensionHostProcessActivationTimes.set(extensions_2.ExtensionIdentifier.toKey(extensionId), new extensions_1.ActivationTimes(startup, codeLoadingTime, activateCallTime, activateResolvedTime, activationEvent));\n            this._onDidChangeExtensionsStatus.fire([extensionId]);\n        }\n        _onExtensionRuntimeError(extensionId, err) {\n            const extensionKey = extensions_2.ExtensionIdentifier.toKey(extensionId);\n            if (!this._extensionHostExtensionRuntimeErrors.has(extensionKey)) {\n                this._extensionHostExtensionRuntimeErrors.set(extensionKey, []);\n            }\n            this._extensionHostExtensionRuntimeErrors.get(extensionKey).push(err);\n            this._onDidChangeExtensionsStatus.fire([extensionId]);\n        }\n        _onExtensionHostExit(code) {\n            // Expected development extension termination: When the extension host goes down we also shutdown the window\n            const devOpts = extensionDevOptions_1.parseExtensionDevOptions(this._environmentService);\n            if (!devOpts.isExtensionDevTestFromCli) {\n                this._windowService.closeWindow();\n            }\n            // When CLI testing make sure to exit with proper exit code\n            else {\n                electron_1.ipcRenderer.send('vscode:exit', code);\n            }\n        }\n    };\n    ExtensionService = __decorate([\n        __param(0, instantiation_1.IInstantiationService),\n        __param(1, notification_1.INotificationService),\n        __param(2, environment_1.IEnvironmentService),\n        __param(3, telemetry_1.ITelemetryService),\n        __param(4, extensionManagement_1.IExtensionEnablementService),\n        __param(5, extensionManagement_1.IExtensionManagementService),\n        __param(6, windows_1.IWindowService),\n        __param(7, lifecycle_2.ILifecycleService),\n        __param(8, files_1.IFileService)\n    ], ExtensionService);\n    exports.ExtensionService = ExtensionService;\n    extensions_3.registerSingleton(extensions_1.IExtensionService, ExtensionService);\n});\n",null]}