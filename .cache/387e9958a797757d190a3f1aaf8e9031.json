{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/octicon.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/octicon.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/filters\", \"vs/base/common/strings\"], function (require, exports, filters_1, strings_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const octiconStartMarker = '$(';\n    function parseOcticons(text) {\n        const firstOcticonIndex = text.indexOf(octiconStartMarker);\n        if (firstOcticonIndex === -1) {\n            return { text }; // return early if the word does not include an octicon\n        }\n        return doParseOcticons(text, firstOcticonIndex);\n    }\n    exports.parseOcticons = parseOcticons;\n    function doParseOcticons(text, firstOcticonIndex) {\n        const octiconOffsets = [];\n        let textWithoutOcticons = '';\n        function appendChars(chars) {\n            if (chars) {\n                textWithoutOcticons += chars;\n                for (const _ of chars) {\n                    octiconOffsets.push(octiconsOffset); // make sure to fill in octicon offsets\n                }\n            }\n        }\n        let currentOcticonStart = -1;\n        let currentOcticonValue = '';\n        let octiconsOffset = 0;\n        let char;\n        let nextChar;\n        let offset = firstOcticonIndex;\n        const length = text.length;\n        // Append all characters until the first octicon\n        appendChars(text.substr(0, firstOcticonIndex));\n        // example: $(file-symlink-file) my cool $(other-octicon) entry\n        while (offset < length) {\n            char = text[offset];\n            nextChar = text[offset + 1];\n            // beginning of octicon: some value $( <--\n            if (char === octiconStartMarker[0] && nextChar === octiconStartMarker[1]) {\n                currentOcticonStart = offset;\n                // if we had a previous potential octicon value without\n                // the closing ')', it was actually not an octicon and\n                // so we have to add it to the actual value\n                appendChars(currentOcticonValue);\n                currentOcticonValue = octiconStartMarker;\n                offset++; // jump over '('\n            }\n            // end of octicon: some value $(some-octicon) <--\n            else if (char === ')' && currentOcticonStart !== -1) {\n                const currentOcticonLength = offset - currentOcticonStart + 1; // +1 to include the closing ')'\n                octiconsOffset += currentOcticonLength;\n                currentOcticonStart = -1;\n                currentOcticonValue = '';\n            }\n            // within octicon\n            else if (currentOcticonStart !== -1) {\n                currentOcticonValue += char;\n            }\n            // any value outside of octicons\n            else {\n                appendChars(char);\n            }\n            offset++;\n        }\n        // if we had a previous potential octicon value without\n        // the closing ')', it was actually not an octicon and\n        // so we have to add it to the actual value\n        appendChars(currentOcticonValue);\n        return { text: textWithoutOcticons, octiconOffsets };\n    }\n    function matchesFuzzyOcticonAware(query, target, enableSeparateSubstringMatching = false) {\n        const { text, octiconOffsets } = target;\n        // Return early if there are no octicon markers in the word to match against\n        if (!octiconOffsets || octiconOffsets.length === 0) {\n            return filters_1.matchesFuzzy(query, text, enableSeparateSubstringMatching);\n        }\n        // Trim the word to match against because it could have leading\n        // whitespace now if the word started with an octicon\n        const wordToMatchAgainstWithoutOcticonsTrimmed = strings_1.ltrim(text, ' ');\n        const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutOcticonsTrimmed.length;\n        // match on value without octicons\n        const matches = filters_1.matchesFuzzy(query, wordToMatchAgainstWithoutOcticonsTrimmed, enableSeparateSubstringMatching);\n        // Map matches back to offsets with octicons and trimming\n        if (matches) {\n            for (const match of matches) {\n                const octiconOffset = octiconOffsets[match.start + leadingWhitespaceOffset] /* octicon offsets at index */ + leadingWhitespaceOffset /* overall leading whitespace offset */;\n                match.start += octiconOffset;\n                match.end += octiconOffset;\n            }\n        }\n        return matches;\n    }\n    exports.matchesFuzzyOcticonAware = matchesFuzzyOcticonAware;\n});\n",null]}