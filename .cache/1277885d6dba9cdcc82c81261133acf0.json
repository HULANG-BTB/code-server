{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/suggest/suggest.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/suggest/suggest.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/async\", \"vs/base/common/objects\", \"vs/base/common/errors\", \"vs/editor/browser/editorExtensions\", \"vs/editor/common/modes\", \"vs/platform/contextkey/common/contextkey\", \"vs/base/common/cancellation\", \"vs/editor/common/core/range\", \"vs/base/common/filters\"], function (require, exports, async_1, objects_1, errors_1, editorExtensions_1, modes, contextkey_1, cancellation_1, range_1, filters_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.Context = {\n        Visible: new contextkey_1.RawContextKey('suggestWidgetVisible', false),\n        MultipleSuggestions: new contextkey_1.RawContextKey('suggestWidgetMultipleSuggestions', false),\n        MakesTextEdit: new contextkey_1.RawContextKey('suggestionMakesTextEdit', true),\n        AcceptSuggestionsOnEnter: new contextkey_1.RawContextKey('acceptSuggestionOnEnter', true)\n    };\n    class CompletionItem {\n        constructor(position, completion, container, provider, model) {\n            this.position = position;\n            this.completion = completion;\n            this.container = container;\n            this.provider = provider;\n            // sorting, filtering\n            this.score = filters_1.FuzzyScore.Default;\n            this.distance = 0;\n            // ensure lower-variants (perf)\n            this.labelLow = completion.label.toLowerCase();\n            this.sortTextLow = completion.sortText && completion.sortText.toLowerCase();\n            this.filterTextLow = completion.filterText && completion.filterText.toLowerCase();\n            // create the suggestion resolver\n            const { resolveCompletionItem } = provider;\n            if (typeof resolveCompletionItem !== 'function') {\n                this.resolve = () => Promise.resolve();\n            }\n            else {\n                let cached;\n                this.resolve = (token) => {\n                    if (!cached) {\n                        let isDone = false;\n                        cached = Promise.resolve(resolveCompletionItem.call(provider, model, position, completion, token)).then(value => {\n                            objects_1.assign(completion, value);\n                            isDone = true;\n                        }, err => {\n                            if (errors_1.isPromiseCanceledError(err)) {\n                                // the IPC queue will reject the request with the\n                                // cancellation error -> reset cached\n                                cached = undefined;\n                            }\n                        });\n                        token.onCancellationRequested(() => {\n                            if (!isDone) {\n                                // cancellation after the request has been\n                                // dispatched -> reset cache\n                                cached = undefined;\n                            }\n                        });\n                    }\n                    return cached;\n                };\n            }\n        }\n    }\n    exports.CompletionItem = CompletionItem;\n    var SnippetSortOrder;\n    (function (SnippetSortOrder) {\n        SnippetSortOrder[SnippetSortOrder[\"Top\"] = 0] = \"Top\";\n        SnippetSortOrder[SnippetSortOrder[\"Inline\"] = 1] = \"Inline\";\n        SnippetSortOrder[SnippetSortOrder[\"Bottom\"] = 2] = \"Bottom\";\n    })(SnippetSortOrder = exports.SnippetSortOrder || (exports.SnippetSortOrder = {}));\n    class CompletionOptions {\n        constructor(snippetSortOrder = SnippetSortOrder.Bottom, kindFilter = new Set(), providerFilter = new Set()) {\n            this.snippetSortOrder = snippetSortOrder;\n            this.kindFilter = kindFilter;\n            this.providerFilter = providerFilter;\n        }\n    }\n    CompletionOptions.default = new CompletionOptions();\n    exports.CompletionOptions = CompletionOptions;\n    let _snippetSuggestSupport;\n    function getSnippetSuggestSupport() {\n        return _snippetSuggestSupport;\n    }\n    exports.getSnippetSuggestSupport = getSnippetSuggestSupport;\n    function setSnippetSuggestSupport(support) {\n        const old = _snippetSuggestSupport;\n        _snippetSuggestSupport = support;\n        return old;\n    }\n    exports.setSnippetSuggestSupport = setSnippetSuggestSupport;\n    function provideSuggestionItems(model, position, options = CompletionOptions.default, context = { triggerKind: modes.CompletionTriggerKind.Invoke }, token = cancellation_1.CancellationToken.None) {\n        const allSuggestions = [];\n        const wordUntil = model.getWordUntilPosition(position);\n        const defaultRange = new range_1.Range(position.lineNumber, wordUntil.startColumn, position.lineNumber, wordUntil.endColumn);\n        position = position.clone();\n        // get provider groups, always add snippet suggestion provider\n        const supports = modes.CompletionProviderRegistry.orderedGroups(model);\n        // add snippets provider unless turned off\n        if (!options.kindFilter.has(modes.CompletionItemKind.Snippet) && _snippetSuggestSupport) {\n            supports.unshift([_snippetSuggestSupport]);\n        }\n        // add suggestions from contributed providers - providers are ordered in groups of\n        // equal score and once a group produces a result the process stops\n        let hasResult = false;\n        const factory = supports.map(supports => () => {\n            // for each support in the group ask for suggestions\n            return Promise.all(supports.map(provider => {\n                if (options.providerFilter.size > 0 && !options.providerFilter.has(provider)) {\n                    return undefined;\n                }\n                return Promise.resolve(provider.provideCompletionItems(model, position, context, token)).then(container => {\n                    const len = allSuggestions.length;\n                    if (container) {\n                        for (let suggestion of container.suggestions || []) {\n                            if (!options.kindFilter.has(suggestion.kind)) {\n                                // fill in default range when missing\n                                if (!suggestion.range) {\n                                    suggestion.range = defaultRange;\n                                }\n                                allSuggestions.push(new CompletionItem(position, suggestion, container, provider, model));\n                            }\n                        }\n                    }\n                    if (len !== allSuggestions.length && provider !== _snippetSuggestSupport) {\n                        hasResult = true;\n                    }\n                }, errors_1.onUnexpectedExternalError);\n            }));\n        });\n        const result = async_1.first(factory, () => {\n            // stop on result or cancellation\n            return hasResult || token.isCancellationRequested;\n        }).then(() => {\n            if (token.isCancellationRequested) {\n                return Promise.reject(errors_1.canceled());\n            }\n            return allSuggestions.sort(getSuggestionComparator(options.snippetSortOrder));\n        });\n        // result.then(items => {\n        // \tconsole.log(model.getWordUntilPosition(position), items.map(item => `${item.suggestion.label}, type=${item.suggestion.type}, incomplete?${item.container.incomplete}, overwriteBefore=${item.suggestion.overwriteBefore}`));\n        // \treturn items;\n        // }, err => {\n        // \tconsole.warn(model.getWordUntilPosition(position), err);\n        // });\n        return result;\n    }\n    exports.provideSuggestionItems = provideSuggestionItems;\n    function defaultComparator(a, b) {\n        // check with 'sortText'\n        if (a.sortTextLow && b.sortTextLow) {\n            if (a.sortTextLow < b.sortTextLow) {\n                return -1;\n            }\n            else if (a.sortTextLow > b.sortTextLow) {\n                return 1;\n            }\n        }\n        // check with 'label'\n        if (a.completion.label < b.completion.label) {\n            return -1;\n        }\n        else if (a.completion.label > b.completion.label) {\n            return 1;\n        }\n        // check with 'type'\n        return a.completion.kind - b.completion.kind;\n    }\n    function snippetUpComparator(a, b) {\n        if (a.completion.kind !== b.completion.kind) {\n            if (a.completion.kind === modes.CompletionItemKind.Snippet) {\n                return -1;\n            }\n            else if (b.completion.kind === modes.CompletionItemKind.Snippet) {\n                return 1;\n            }\n        }\n        return defaultComparator(a, b);\n    }\n    function snippetDownComparator(a, b) {\n        if (a.completion.kind !== b.completion.kind) {\n            if (a.completion.kind === modes.CompletionItemKind.Snippet) {\n                return 1;\n            }\n            else if (b.completion.kind === modes.CompletionItemKind.Snippet) {\n                return -1;\n            }\n        }\n        return defaultComparator(a, b);\n    }\n    const _snippetComparators = new Map();\n    _snippetComparators.set(SnippetSortOrder.Top, snippetUpComparator);\n    _snippetComparators.set(SnippetSortOrder.Bottom, snippetDownComparator);\n    _snippetComparators.set(SnippetSortOrder.Inline, defaultComparator);\n    function getSuggestionComparator(snippetConfig) {\n        return _snippetComparators.get(snippetConfig);\n    }\n    exports.getSuggestionComparator = getSuggestionComparator;\n    editorExtensions_1.registerDefaultLanguageCommand('_executeCompletionItemProvider', (model, position, args) => {\n        const result = {\n            incomplete: false,\n            suggestions: []\n        };\n        let resolving = [];\n        let maxItemsToResolve = args['maxItemsToResolve'] || 0;\n        return provideSuggestionItems(model, position).then(items => {\n            for (const item of items) {\n                if (resolving.length < maxItemsToResolve) {\n                    resolving.push(item.resolve(cancellation_1.CancellationToken.None));\n                }\n                result.incomplete = result.incomplete || item.container.incomplete;\n                result.suggestions.push(item.completion);\n            }\n        }).then(() => {\n            return Promise.all(resolving);\n        }).then(() => {\n            return result;\n        });\n    });\n    const _provider = new class {\n        constructor() {\n            this.onlyOnceSuggestions = [];\n        }\n        provideCompletionItems() {\n            let suggestions = this.onlyOnceSuggestions.slice(0);\n            let result = { suggestions };\n            this.onlyOnceSuggestions.length = 0;\n            return result;\n        }\n    };\n    modes.CompletionProviderRegistry.register('*', _provider);\n    function showSimpleSuggestions(editor, suggestions) {\n        setTimeout(() => {\n            _provider.onlyOnceSuggestions.push(...suggestions);\n            editor.getContribution('editor.contrib.suggestController').triggerSuggest(new Set().add(_provider));\n        }, 0);\n    }\n    exports.showSimpleSuggestions = showSimpleSuggestions;\n});\n",null]}