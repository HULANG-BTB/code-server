{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/referenceSearch/referenceSearch.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/referenceSearch/referenceSearch.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/keyCodes\", \"vs/platform/contextkey/common/contextkey\", \"vs/platform/keybinding/common/keybindingsRegistry\", \"vs/editor/common/core/position\", \"vs/editor/browser/editorExtensions\", \"vs/editor/common/modes\", \"vs/editor/common/core/range\", \"./peekViewWidget\", \"./referencesController\", \"./referencesModel\", \"vs/base/common/async\", \"vs/base/common/errors\", \"vs/editor/common/editorContextKeys\", \"vs/editor/browser/widget/embeddedCodeEditorWidget\", \"vs/editor/browser/editorBrowser\", \"vs/platform/list/browser/listService\", \"vs/editor/contrib/referenceSearch/referencesWidget\", \"vs/platform/commands/common/commands\", \"vs/base/common/uri\", \"vs/editor/browser/services/codeEditorService\", \"vs/base/common/cancellation\"], function (require, exports, nls, keyCodes_1, contextkey_1, keybindingsRegistry_1, position_1, editorExtensions_1, modes_1, range_1, peekViewWidget_1, referencesController_1, referencesModel_1, async_1, errors_1, editorContextKeys_1, embeddedCodeEditorWidget_1, editorBrowser_1, listService_1, referencesWidget_1, commands_1, uri_1, codeEditorService_1, cancellation_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.defaultReferenceSearchOptions = {\n        getMetaTitle(model) {\n            return model.references.length > 1 ? nls.localize('meta.titleReference', \" â€“ {0} references\", model.references.length) : '';\n        }\n    };\n    let ReferenceController = class ReferenceController {\n        constructor(editor, contextKeyService) {\n            if (editor instanceof embeddedCodeEditorWidget_1.EmbeddedCodeEditorWidget) {\n                peekViewWidget_1.PeekContext.inPeekEditor.bindTo(contextKeyService);\n            }\n        }\n        dispose() {\n        }\n        getId() {\n            return ReferenceController.ID;\n        }\n    };\n    ReferenceController.ID = 'editor.contrib.referenceController';\n    ReferenceController = __decorate([\n        __param(1, contextkey_1.IContextKeyService)\n    ], ReferenceController);\n    exports.ReferenceController = ReferenceController;\n    class ReferenceAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.referenceSearch.trigger',\n                label: nls.localize('references.action.label', \"Peek References\"),\n                alias: 'Find All References',\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.hasReferenceProvider, peekViewWidget_1.PeekContext.notInPeekEditor, editorContextKeys_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.F12,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                menuOpts: {\n                    group: 'navigation',\n                    order: 1.5\n                }\n            });\n        }\n        run(_accessor, editor) {\n            let controller = referencesController_1.ReferencesController.get(editor);\n            if (!controller) {\n                return;\n            }\n            if (editor.hasModel()) {\n                const range = editor.getSelection();\n                const model = editor.getModel();\n                const references = async_1.createCancelablePromise(token => provideReferences(model, range.getStartPosition(), token).then(references => new referencesModel_1.ReferencesModel(references)));\n                controller.toggleWidget(range, references, exports.defaultReferenceSearchOptions);\n            }\n        }\n    }\n    exports.ReferenceAction = ReferenceAction;\n    editorExtensions_1.registerEditorContribution(ReferenceController);\n    editorExtensions_1.registerEditorAction(ReferenceAction);\n    let findReferencesCommand = (accessor, resource, position) => {\n        if (!(resource instanceof uri_1.URI)) {\n            throw new Error('illegal argument, uri');\n        }\n        if (!position) {\n            throw new Error('illegal argument, position');\n        }\n        const codeEditorService = accessor.get(codeEditorService_1.ICodeEditorService);\n        return codeEditorService.openCodeEditor({ resource }, codeEditorService.getFocusedCodeEditor()).then(control => {\n            if (!editorBrowser_1.isCodeEditor(control) || !control.hasModel()) {\n                return undefined;\n            }\n            let controller = referencesController_1.ReferencesController.get(control);\n            if (!controller) {\n                return undefined;\n            }\n            let references = async_1.createCancelablePromise(token => provideReferences(control.getModel(), position_1.Position.lift(position), token).then(references => new referencesModel_1.ReferencesModel(references)));\n            let range = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);\n            return Promise.resolve(controller.toggleWidget(range, references, exports.defaultReferenceSearchOptions));\n        });\n    };\n    let showReferencesCommand = (accessor, resource, position, references) => {\n        if (!(resource instanceof uri_1.URI)) {\n            throw new Error('illegal argument, uri expected');\n        }\n        if (!references) {\n            throw new Error('missing references');\n        }\n        const codeEditorService = accessor.get(codeEditorService_1.ICodeEditorService);\n        return codeEditorService.openCodeEditor({ resource }, codeEditorService.getFocusedCodeEditor()).then(control => {\n            if (!editorBrowser_1.isCodeEditor(control)) {\n                return undefined;\n            }\n            let controller = referencesController_1.ReferencesController.get(control);\n            if (!controller) {\n                return undefined;\n            }\n            return controller.toggleWidget(new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column), async_1.createCancelablePromise(_ => Promise.resolve(new referencesModel_1.ReferencesModel(references))), exports.defaultReferenceSearchOptions);\n        });\n    };\n    // register commands\n    commands_1.CommandsRegistry.registerCommand({\n        id: 'editor.action.findReferences',\n        handler: findReferencesCommand\n    });\n    commands_1.CommandsRegistry.registerCommand({\n        id: 'editor.action.showReferences',\n        handler: showReferencesCommand,\n        description: {\n            description: 'Show references at a position in a file',\n            args: [\n                { name: 'uri', description: 'The text document in which to show references', constraint: uri_1.URI },\n                { name: 'position', description: 'The position at which to show', constraint: position_1.Position.isIPosition },\n                { name: 'locations', description: 'An array of locations.', constraint: Array },\n            ]\n        }\n    });\n    function closeActiveReferenceSearch(accessor, args) {\n        withController(accessor, controller => controller.closeWidget());\n    }\n    function openReferenceToSide(accessor, args) {\n        const listService = accessor.get(listService_1.IListService);\n        const focus = listService.lastFocusedList && listService.lastFocusedList.getFocus();\n        if (focus instanceof referencesModel_1.OneReference) {\n            withController(accessor, controller => controller.openReference(focus, true));\n        }\n    }\n    function withController(accessor, fn) {\n        const outerEditor = peekViewWidget_1.getOuterEditor(accessor);\n        if (!outerEditor) {\n            return;\n        }\n        let controller = referencesController_1.ReferencesController.get(outerEditor);\n        if (!controller) {\n            return;\n        }\n        fn(controller);\n    }\n    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({\n        id: 'goToNextReference',\n        weight: keybindingsRegistry_1.KeybindingWeight.WorkbenchContrib + 50,\n        primary: keyCodes_1.KeyCode.F4,\n        when: referencesController_1.ctxReferenceSearchVisible,\n        handler(accessor) {\n            withController(accessor, controller => {\n                controller.goToNextOrPreviousReference(true);\n            });\n        }\n    });\n    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({\n        id: 'goToNextReferenceFromEmbeddedEditor',\n        weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib + 50,\n        primary: keyCodes_1.KeyCode.F4,\n        when: peekViewWidget_1.PeekContext.inPeekEditor,\n        handler(accessor) {\n            withController(accessor, controller => {\n                controller.goToNextOrPreviousReference(true);\n            });\n        }\n    });\n    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({\n        id: 'goToPreviousReference',\n        weight: keybindingsRegistry_1.KeybindingWeight.WorkbenchContrib + 50,\n        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.F4,\n        when: referencesController_1.ctxReferenceSearchVisible,\n        handler(accessor) {\n            withController(accessor, controller => {\n                controller.goToNextOrPreviousReference(false);\n            });\n        }\n    });\n    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({\n        id: 'goToPreviousReferenceFromEmbeddedEditor',\n        weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib + 50,\n        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.F4,\n        when: peekViewWidget_1.PeekContext.inPeekEditor,\n        handler(accessor) {\n            withController(accessor, controller => {\n                controller.goToNextOrPreviousReference(false);\n            });\n        }\n    });\n    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({\n        id: 'closeReferenceSearch',\n        weight: keybindingsRegistry_1.KeybindingWeight.WorkbenchContrib + 50,\n        primary: keyCodes_1.KeyCode.Escape,\n        secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape],\n        when: contextkey_1.ContextKeyExpr.and(referencesController_1.ctxReferenceSearchVisible, contextkey_1.ContextKeyExpr.not('config.editor.stablePeek')),\n        handler: closeActiveReferenceSearch\n    });\n    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({\n        id: 'closeReferenceSearchEditor',\n        weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib - 101,\n        primary: keyCodes_1.KeyCode.Escape,\n        secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape],\n        when: contextkey_1.ContextKeyExpr.and(peekViewWidget_1.PeekContext.inPeekEditor, contextkey_1.ContextKeyExpr.not('config.editor.stablePeek')),\n        handler: closeActiveReferenceSearch\n    });\n    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({\n        id: 'openReferenceToSide',\n        weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib,\n        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.Enter,\n        mac: {\n            primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.Enter\n        },\n        when: contextkey_1.ContextKeyExpr.and(referencesController_1.ctxReferenceSearchVisible, referencesWidget_1.ctxReferenceWidgetSearchTreeFocused),\n        handler: openReferenceToSide\n    });\n    function provideReferences(model, position, token) {\n        // collect references from all providers\n        const promises = modes_1.ReferenceProviderRegistry.ordered(model).map(provider => {\n            return Promise.resolve(provider.provideReferences(model, position, { includeDeclaration: true }, token)).then(result => {\n                if (Array.isArray(result)) {\n                    return result;\n                }\n                return undefined;\n            }, err => {\n                errors_1.onUnexpectedExternalError(err);\n            });\n        });\n        return Promise.all(promises).then(references => {\n            let result = [];\n            for (let ref of references) {\n                if (ref) {\n                    result.push(...ref);\n                }\n            }\n            return result;\n        });\n    }\n    exports.provideReferences = provideReferences;\n    editorExtensions_1.registerDefaultLanguageCommand('_executeReferenceProvider', (model, position) => provideReferences(model, position, cancellation_1.CancellationToken.None));\n});\n",null]}