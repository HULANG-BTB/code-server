{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/codeAction/codeActionModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/codeAction/codeActionModel.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/async\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/editor/common/core/range\", \"vs/editor/common/modes\", \"vs/platform/contextkey/common/contextkey\", \"./codeAction\"], function (require, exports, async_1, event_1, lifecycle_1, range_1, modes_1, contextkey_1, codeAction_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.SUPPORTED_CODE_ACTIONS = new contextkey_1.RawContextKey('supportedCodeAction', '');\n    class CodeActionOracle {\n        constructor(_editor, _markerService, _signalChange, _delay = 250, _progressService) {\n            this._editor = _editor;\n            this._markerService = _markerService;\n            this._signalChange = _signalChange;\n            this._delay = _delay;\n            this._progressService = _progressService;\n            this._disposables = [];\n            this._autoTriggerTimer = new async_1.TimeoutTimer();\n            this._disposables.push(this._markerService.onMarkerChanged(e => this._onMarkerChanges(e)), this._editor.onDidChangeCursorPosition(() => this._onCursorChange()));\n        }\n        dispose() {\n            this._disposables = lifecycle_1.dispose(this._disposables);\n            this._autoTriggerTimer.cancel();\n        }\n        trigger(trigger) {\n            const selection = this._getRangeOfSelectionUnlessWhitespaceEnclosed(trigger);\n            return this._createEventAndSignalChange(trigger, selection);\n        }\n        _onMarkerChanges(resources) {\n            const model = this._editor.getModel();\n            if (!model) {\n                return;\n            }\n            if (resources.some(resource => resource.toString() === model.uri.toString())) {\n                this._autoTriggerTimer.cancelAndSet(() => {\n                    this.trigger({ type: 'auto' });\n                }, this._delay);\n            }\n        }\n        _onCursorChange() {\n            this._autoTriggerTimer.cancelAndSet(() => {\n                this.trigger({ type: 'auto' });\n            }, this._delay);\n        }\n        _getRangeOfMarker(selection) {\n            const model = this._editor.getModel();\n            if (!model) {\n                return undefined;\n            }\n            for (const marker of this._markerService.read({ resource: model.uri })) {\n                if (range_1.Range.intersectRanges(marker, selection)) {\n                    return range_1.Range.lift(marker);\n                }\n            }\n            return undefined;\n        }\n        _getRangeOfSelectionUnlessWhitespaceEnclosed(trigger) {\n            if (!this._editor.hasModel()) {\n                return undefined;\n            }\n            const model = this._editor.getModel();\n            const selection = this._editor.getSelection();\n            if (selection.isEmpty() && trigger.type === 'auto') {\n                const { lineNumber, column } = selection.getPosition();\n                const line = model.getLineContent(lineNumber);\n                if (line.length === 0) {\n                    // empty line\n                    return undefined;\n                }\n                else if (column === 1) {\n                    // look only right\n                    if (/\\s/.test(line[0])) {\n                        return undefined;\n                    }\n                }\n                else if (column === model.getLineMaxColumn(lineNumber)) {\n                    // look only left\n                    if (/\\s/.test(line[line.length - 1])) {\n                        return undefined;\n                    }\n                }\n                else {\n                    // look left and right\n                    if (/\\s/.test(line[column - 2]) && /\\s/.test(line[column - 1])) {\n                        return undefined;\n                    }\n                }\n            }\n            return selection ? selection : undefined;\n        }\n        _createEventAndSignalChange(trigger, selection) {\n            if (!selection) {\n                // cancel\n                this._signalChange(CodeActionsState.Empty);\n                return Promise.resolve(undefined);\n            }\n            else {\n                const model = this._editor.getModel();\n                if (!model) {\n                    // cancel\n                    this._signalChange(CodeActionsState.Empty);\n                    return Promise.resolve(undefined);\n                }\n                const markerRange = this._getRangeOfMarker(selection);\n                const position = markerRange ? markerRange.getStartPosition() : selection.getStartPosition();\n                const actions = async_1.createCancelablePromise(token => codeAction_1.getCodeActions(model, selection, trigger, token));\n                if (this._progressService && trigger.type === 'manual') {\n                    this._progressService.showWhile(actions, 250);\n                }\n                this._signalChange(new CodeActionsState.Triggered(trigger, selection, position, actions));\n                return actions;\n            }\n        }\n    }\n    exports.CodeActionOracle = CodeActionOracle;\n    var CodeActionsState;\n    (function (CodeActionsState) {\n        let Type;\n        (function (Type) {\n            Type[Type[\"Empty\"] = 0] = \"Empty\";\n            Type[Type[\"Triggered\"] = 1] = \"Triggered\";\n        })(Type = CodeActionsState.Type || (CodeActionsState.Type = {}));\n        CodeActionsState.Empty = new class {\n            constructor() {\n                this.type = Type.Empty;\n            }\n        };\n        class Triggered {\n            constructor(trigger, rangeOrSelection, position, actions) {\n                this.trigger = trigger;\n                this.rangeOrSelection = rangeOrSelection;\n                this.position = position;\n                this.actions = actions;\n                this.type = Type.Triggered;\n            }\n        }\n        CodeActionsState.Triggered = Triggered;\n    })(CodeActionsState = exports.CodeActionsState || (exports.CodeActionsState = {}));\n    class CodeActionModel {\n        constructor(_editor, _markerService, contextKeyService, _progressService) {\n            this._editor = _editor;\n            this._markerService = _markerService;\n            this._progressService = _progressService;\n            this._state = CodeActionsState.Empty;\n            this._onDidChangeState = new event_1.Emitter();\n            this._disposables = [];\n            this._supportedCodeActions = exports.SUPPORTED_CODE_ACTIONS.bindTo(contextKeyService);\n            this._disposables.push(this._editor.onDidChangeModel(() => this._update()));\n            this._disposables.push(this._editor.onDidChangeModelLanguage(() => this._update()));\n            this._disposables.push(modes_1.CodeActionProviderRegistry.onDidChange(() => this._update()));\n            this._update();\n        }\n        dispose() {\n            this._disposables = lifecycle_1.dispose(this._disposables);\n            lifecycle_1.dispose(this._codeActionOracle);\n        }\n        get onDidChangeState() {\n            return this._onDidChangeState.event;\n        }\n        _update() {\n            if (this._codeActionOracle) {\n                this._codeActionOracle.dispose();\n                this._codeActionOracle = undefined;\n            }\n            if (this._state.type === CodeActionsState.Type.Triggered) {\n                this._state.actions.cancel();\n            }\n            this.setState(CodeActionsState.Empty);\n            const model = this._editor.getModel();\n            if (model\n                && modes_1.CodeActionProviderRegistry.has(model)\n                && !this._editor.getConfiguration().readOnly) {\n                const supportedActions = [];\n                for (const provider of modes_1.CodeActionProviderRegistry.all(model)) {\n                    if (Array.isArray(provider.providedCodeActionKinds)) {\n                        supportedActions.push(...provider.providedCodeActionKinds);\n                    }\n                }\n                this._supportedCodeActions.set(supportedActions.join(' '));\n                this._codeActionOracle = new CodeActionOracle(this._editor, this._markerService, newState => this.setState(newState), undefined, this._progressService);\n                this._codeActionOracle.trigger({ type: 'auto' });\n            }\n            else {\n                this._supportedCodeActions.reset();\n            }\n        }\n        trigger(trigger) {\n            if (this._codeActionOracle) {\n                return this._codeActionOracle.trigger(trigger);\n            }\n            return Promise.resolve(undefined);\n        }\n        setState(newState) {\n            if (newState === this._state) {\n                return;\n            }\n            this._state = newState;\n            this._onDidChangeState.fire(newState);\n        }\n    }\n    exports.CodeActionModel = CodeActionModel;\n});\n",null]}