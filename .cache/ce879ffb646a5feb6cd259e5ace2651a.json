{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/themes/common/fileIconThemeStore.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/themes/common/fileIconThemeStore.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/types\", \"vs/base/common/resources\", \"vs/workbench/services/extensions/common/extensionsRegistry\", \"vs/workbench/services/extensions/common/extensions\", \"vs/base/common/event\", \"vs/workbench/services/themes/common/fileIconThemeData\"], function (require, exports, nls, types, resources, extensionsRegistry_1, extensions_1, event_1, fileIconThemeData_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const iconThemeExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint({\n        extensionPoint: 'iconThemes',\n        jsonSchema: {\n            description: nls.localize('vscode.extension.contributes.iconThemes', 'Contributes file icon themes.'),\n            type: 'array',\n            items: {\n                type: 'object',\n                defaultSnippets: [{ body: { id: '${1:id}', label: '${2:label}', path: './fileicons/${3:id}-icon-theme.json' } }],\n                properties: {\n                    id: {\n                        description: nls.localize('vscode.extension.contributes.iconThemes.id', 'Id of the icon theme as used in the user settings.'),\n                        type: 'string'\n                    },\n                    label: {\n                        description: nls.localize('vscode.extension.contributes.iconThemes.label', 'Label of the icon theme as shown in the UI.'),\n                        type: 'string'\n                    },\n                    path: {\n                        description: nls.localize('vscode.extension.contributes.iconThemes.path', 'Path of the icon theme definition file. The path is relative to the extension folder and is typically \\'./icons/awesome-icon-theme.json\\'.'),\n                        type: 'string'\n                    }\n                },\n                required: ['path', 'id']\n            }\n        }\n    });\n    let FileIconThemeStore = class FileIconThemeStore {\n        constructor(extensionService) {\n            this.extensionService = extensionService;\n            this.knownIconThemes = [];\n            this.onDidChangeEmitter = new event_1.Emitter();\n            this.initialize();\n        }\n        get onDidChange() { return this.onDidChangeEmitter.event; }\n        initialize() {\n            iconThemeExtPoint.setHandler((extensions) => {\n                const previousIds = {};\n                const added = [];\n                for (const theme of this.knownIconThemes) {\n                    previousIds[theme.id] = true;\n                }\n                this.knownIconThemes.length = 0;\n                for (let ext of extensions) {\n                    let extensionData = {\n                        extensionId: ext.description.identifier.value,\n                        extensionPublisher: ext.description.publisher,\n                        extensionName: ext.description.name,\n                        extensionIsBuiltin: ext.description.isBuiltin\n                    };\n                    this.onIconThemes(ext.description.extensionLocation, extensionData, ext.value, ext.collector);\n                }\n                for (const theme of this.knownIconThemes) {\n                    if (!previousIds[theme.id]) {\n                        added.push(theme);\n                    }\n                }\n                this.onDidChangeEmitter.fire({ themes: this.knownIconThemes, added });\n            });\n        }\n        onIconThemes(extensionLocation, extensionData, iconThemes, collector) {\n            if (!Array.isArray(iconThemes)) {\n                collector.error(nls.localize('reqarray', \"Extension point `{0}` must be an array.\", iconThemeExtPoint.name));\n                return;\n            }\n            iconThemes.forEach(iconTheme => {\n                if (!iconTheme.path || !types.isString(iconTheme.path)) {\n                    collector.error(nls.localize('reqpath', \"Expected string in `contributes.{0}.path`. Provided value: {1}\", iconThemeExtPoint.name, String(iconTheme.path)));\n                    return;\n                }\n                if (!iconTheme.id || !types.isString(iconTheme.id)) {\n                    collector.error(nls.localize('reqid', \"Expected string in `contributes.{0}.id`. Provided value: {1}\", iconThemeExtPoint.name, String(iconTheme.path)));\n                    return;\n                }\n                const iconThemeLocation = resources.joinPath(extensionLocation, iconTheme.path);\n                if (!resources.isEqualOrParent(iconThemeLocation, extensionLocation)) {\n                    collector.warn(nls.localize('invalid.path.1', \"Expected `contributes.{0}.path` ({1}) to be included inside extension's folder ({2}). This might make the extension non-portable.\", iconThemeExtPoint.name, iconThemeLocation.path, extensionLocation.path));\n                }\n                let themeData = fileIconThemeData_1.FileIconThemeData.fromExtensionTheme(iconTheme, iconThemeLocation, extensionData);\n                this.knownIconThemes.push(themeData);\n            });\n        }\n        findThemeData(iconTheme) {\n            if (iconTheme.length === 0) {\n                return Promise.resolve(fileIconThemeData_1.FileIconThemeData.noIconTheme());\n            }\n            return this.getFileIconThemes().then(allIconSets => {\n                for (let iconSet of allIconSets) {\n                    if (iconSet.id === iconTheme) {\n                        return iconSet;\n                    }\n                }\n                return undefined;\n            });\n        }\n        findThemeBySettingsId(settingsId) {\n            if (!settingsId) {\n                return Promise.resolve(fileIconThemeData_1.FileIconThemeData.noIconTheme());\n            }\n            return this.getFileIconThemes().then(allIconSets => {\n                for (let iconSet of allIconSets) {\n                    if (iconSet.settingsId === settingsId) {\n                        return iconSet;\n                    }\n                }\n                return undefined;\n            });\n        }\n        findThemeDataByParentLocation(parentLocation) {\n            if (parentLocation) {\n                return this.getFileIconThemes().then(allThemes => {\n                    return allThemes.filter(t => t.location && resources.isEqualOrParent(t.location, parentLocation));\n                });\n            }\n            return Promise.resolve([]);\n        }\n        getFileIconThemes() {\n            return this.extensionService.whenInstalledExtensionsRegistered().then(isReady => {\n                return this.knownIconThemes;\n            });\n        }\n    };\n    FileIconThemeStore = __decorate([\n        __param(0, extensions_1.IExtensionService)\n    ], FileIconThemeStore);\n    exports.FileIconThemeStore = FileIconThemeStore;\n});\n",null]}