{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/core/lineTokens.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/core/lineTokens.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/editor/common/modes\"], function (require, exports, modes_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class LineTokens {\n        constructor(tokens, text) {\n            this._tokens = tokens;\n            this._tokensCount = (this._tokens.length >>> 1);\n            this._text = text;\n        }\n        equals(other) {\n            if (other instanceof LineTokens) {\n                return this.slicedEquals(other, 0, this._tokensCount);\n            }\n            return false;\n        }\n        slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n            if (this._text !== other._text) {\n                return false;\n            }\n            if (this._tokensCount !== other._tokensCount) {\n                return false;\n            }\n            const from = (sliceFromTokenIndex << 1);\n            const to = from + (sliceTokenCount << 1);\n            for (let i = from; i < to; i++) {\n                if (this._tokens[i] !== other._tokens[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        getLineContent() {\n            return this._text;\n        }\n        getCount() {\n            return this._tokensCount;\n        }\n        getStartOffset(tokenIndex) {\n            if (tokenIndex > 0) {\n                return this._tokens[(tokenIndex - 1) << 1];\n            }\n            return 0;\n        }\n        getLanguageId(tokenIndex) {\n            const metadata = this._tokens[(tokenIndex << 1) + 1];\n            return modes_1.TokenMetadata.getLanguageId(metadata);\n        }\n        getStandardTokenType(tokenIndex) {\n            const metadata = this._tokens[(tokenIndex << 1) + 1];\n            return modes_1.TokenMetadata.getTokenType(metadata);\n        }\n        getForeground(tokenIndex) {\n            const metadata = this._tokens[(tokenIndex << 1) + 1];\n            return modes_1.TokenMetadata.getForeground(metadata);\n        }\n        getClassName(tokenIndex) {\n            const metadata = this._tokens[(tokenIndex << 1) + 1];\n            return modes_1.TokenMetadata.getClassNameFromMetadata(metadata);\n        }\n        getInlineStyle(tokenIndex, colorMap) {\n            const metadata = this._tokens[(tokenIndex << 1) + 1];\n            return modes_1.TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n        }\n        getEndOffset(tokenIndex) {\n            return this._tokens[tokenIndex << 1];\n        }\n        /**\n         * Find the token containing offset `offset`.\n         * @param offset The search offset\n         * @return The index of the token containing the offset.\n         */\n        findTokenIndexAtOffset(offset) {\n            return LineTokens.findIndexInTokensArray(this._tokens, offset);\n        }\n        inflate() {\n            return this;\n        }\n        sliceAndInflate(startOffset, endOffset, deltaOffset) {\n            return new SlicedLineTokens(this, startOffset, endOffset, deltaOffset);\n        }\n        static convertToEndOffset(tokens, lineTextLength) {\n            const tokenCount = (tokens.length >>> 1);\n            const lastTokenIndex = tokenCount - 1;\n            for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n                tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n            }\n            tokens[lastTokenIndex << 1] = lineTextLength;\n        }\n        static findIndexInTokensArray(tokens, desiredIndex) {\n            if (tokens.length <= 2) {\n                return 0;\n            }\n            let low = 0;\n            let high = (tokens.length >>> 1) - 1;\n            while (low < high) {\n                let mid = low + Math.floor((high - low) / 2);\n                let endOffset = tokens[(mid << 1)];\n                if (endOffset === desiredIndex) {\n                    return mid + 1;\n                }\n                else if (endOffset < desiredIndex) {\n                    low = mid + 1;\n                }\n                else if (endOffset > desiredIndex) {\n                    high = mid;\n                }\n            }\n            return low;\n        }\n    }\n    exports.LineTokens = LineTokens;\n    class SlicedLineTokens {\n        constructor(source, startOffset, endOffset, deltaOffset) {\n            this._source = source;\n            this._startOffset = startOffset;\n            this._endOffset = endOffset;\n            this._deltaOffset = deltaOffset;\n            this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n            this._tokensCount = 0;\n            for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n                const tokenStartOffset = source.getStartOffset(i);\n                if (tokenStartOffset >= endOffset) {\n                    break;\n                }\n                this._tokensCount++;\n            }\n        }\n        equals(other) {\n            if (other instanceof SlicedLineTokens) {\n                return (this._startOffset === other._startOffset\n                    && this._endOffset === other._endOffset\n                    && this._deltaOffset === other._deltaOffset\n                    && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n            }\n            return false;\n        }\n        getCount() {\n            return this._tokensCount;\n        }\n        getForeground(tokenIndex) {\n            return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n        }\n        getEndOffset(tokenIndex) {\n            const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n            return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n        }\n        getClassName(tokenIndex) {\n            return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n        }\n        getInlineStyle(tokenIndex, colorMap) {\n            return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n        }\n        findTokenIndexAtOffset(offset) {\n            return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n        }\n    }\n    exports.SlicedLineTokens = SlicedLineTokens;\n});\n",null]}