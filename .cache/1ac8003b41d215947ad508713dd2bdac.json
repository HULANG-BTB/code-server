{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/packages/ide/src/fill/client.ts","dependencies":[{"path":"/home/coding/workspace/packages/ide/src/fill/client.ts","mtime":1555841535682},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar events_1 = require(\"@coder/events\");\nvar logger_1 = require(\"@coder/logger\");\nvar protocol_1 = require(\"@coder/protocol\");\nvar retry_1 = require(\"../retry\");\n/**\n * A connection based on a web socket. Automatically reconnects and buffers\n * messages during connection.\n */\nvar WebsocketConnection = /** @class */ (function () {\n    function WebsocketConnection() {\n        var _this = this;\n        this.messageBuffer = [];\n        this.socketTimeoutDelay = 60 * 1000;\n        this.retry = retry_1.retry.register(\"Socket\", function () { return _this.connect(); });\n        this.isUp = false;\n        this.closed = false;\n        this.messageEmitter = new events_1.Emitter();\n        this.closeEmitter = new events_1.Emitter();\n        this.upEmitter = new events_1.Emitter();\n        this.downEmitter = new events_1.Emitter();\n        this.onUp = this.upEmitter.event;\n        this.onClose = this.closeEmitter.event;\n        this.onDown = this.downEmitter.event;\n        this.onMessage = this.messageEmitter.event;\n        this.retry.block();\n        this.retry.run();\n    }\n    /**\n     * Send data across the socket. If closed, will error. If connecting, will\n     * queue.\n     */\n    WebsocketConnection.prototype.send = function (data) {\n        if (this.closed) {\n            throw new Error(\"web socket is closed\");\n        }\n        if (!this.activeSocket || this.activeSocket.readyState !== this.activeSocket.OPEN) {\n            this.messageBuffer.push(data);\n        }\n        else {\n            this.activeSocket.send(data);\n        }\n    };\n    /**\n     * Close socket connection.\n     */\n    WebsocketConnection.prototype.close = function () {\n        this.closed = true;\n        this.dispose();\n        this.closeEmitter.emit();\n    };\n    /**\n     * Connect to the server.\n     */\n    WebsocketConnection.prototype.connect = function () {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var socket;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.openSocket()];\n                    case 1:\n                        socket = _a.sent();\n                        socket.addEventListener(\"message\", function (event) {\n                            _this.messageEmitter.emit(event.data);\n                        });\n                        socket.addEventListener(\"close\", function (event) {\n                            if (_this.isUp) {\n                                _this.isUp = false;\n                                try {\n                                    _this.downEmitter.emit(undefined);\n                                }\n                                catch (error) {\n                                    // Don't let errors here prevent restarting.\n                                    logger_1.logger.error(error.message);\n                                }\n                            }\n                            logger_1.logger.warn(\"Web socket closed\", logger_1.field(\"code\", event.code), logger_1.field(\"reason\", event.reason), logger_1.field(\"wasClean\", event.wasClean));\n                            if (!_this.closed) {\n                                _this.retry.block();\n                                _this.retry.run();\n                            }\n                        });\n                        // Send any messages that were queued while we were waiting to connect.\n                        while (this.messageBuffer.length > 0) {\n                            socket.send(this.messageBuffer.shift());\n                        }\n                        if (!this.isUp) {\n                            this.isUp = true;\n                            this.upEmitter.emit(undefined);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Open a web socket, disposing the previous connection if any.\n     */\n    WebsocketConnection.prototype.openSocket = function () {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var wsProto, socket, socketWaitTimeout;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.dispose();\n                        wsProto = location.protocol === \"https:\" ? \"wss\" : \"ws\";\n                        socket = new WebSocket(wsProto + \"://\" + location.host + location.pathname);\n                        socket.binaryType = \"arraybuffer\";\n                        this.activeSocket = socket;\n                        socketWaitTimeout = window.setTimeout(function () {\n                            socket.close();\n                        }, this.socketTimeoutDelay);\n                        return [4 /*yield*/, new Promise(function (resolve, reject) {\n                                var doReject = function () {\n                                    clearTimeout(socketWaitTimeout);\n                                    socket.removeEventListener(\"error\", doReject);\n                                    socket.removeEventListener(\"close\", doReject);\n                                    reject();\n                                };\n                                socket.addEventListener(\"error\", doReject);\n                                socket.addEventListener(\"close\", doReject);\n                                socket.addEventListener(\"open\", function () {\n                                    clearTimeout(socketWaitTimeout);\n                                    socket.removeEventListener(\"error\", doReject);\n                                    socket.removeEventListener(\"close\", doReject);\n                                    resolve();\n                                });\n                            })];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, socket];\n                }\n            });\n        });\n    };\n    /**\n     * Dispose the current connection.\n     */\n    WebsocketConnection.prototype.dispose = function () {\n        if (this.activeSocket) {\n            this.activeSocket.close();\n        }\n    };\n    return WebsocketConnection;\n}());\n// Global instance so all fills can use the same client.\nexports.client = new protocol_1.Client(new WebsocketConnection());\n",{"version":3,"file":"/home/coding/workspace/packages/ide/src/fill/client.ts","sourceRoot":"","sources":["/home/coding/workspace/packages/ide/src/fill/client.ts"],"names":[],"mappings":"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","sourcesContent":["import { Emitter } from \"@coder/events\";\nimport { field, logger } from \"@coder/logger\";\nimport { Client, ReadWriteConnection } from \"@coder/protocol\";\nimport { retry } from \"../retry\";\n\n/**\n * A connection based on a web socket. Automatically reconnects and buffers\n * messages during connection.\n */\nclass WebsocketConnection implements ReadWriteConnection {\n\tprivate activeSocket: WebSocket | undefined;\n\tprivate readonly messageBuffer = <Uint8Array[]>[];\n\tprivate readonly socketTimeoutDelay = 60 * 1000;\n\tprivate readonly retry = retry.register(\"Socket\", () => this.connect());\n\tprivate isUp: boolean = false;\n\tprivate closed: boolean = false;\n\n\tprivate readonly messageEmitter = new Emitter<Uint8Array>();\n\tprivate readonly closeEmitter = new Emitter<void>();\n\tprivate readonly upEmitter = new Emitter<void>();\n\tprivate readonly downEmitter = new Emitter<void>();\n\n\tpublic readonly onUp = this.upEmitter.event;\n\tpublic readonly onClose = this.closeEmitter.event;\n\tpublic readonly onDown = this.downEmitter.event;\n\tpublic readonly onMessage = this.messageEmitter.event;\n\n\tpublic constructor() {\n\t\tthis.retry.block();\n\t\tthis.retry.run();\n\t}\n\n\t/**\n\t * Send data across the socket. If closed, will error. If connecting, will\n\t * queue.\n\t */\n\tpublic send(data: Buffer | Uint8Array): void {\n\t\tif (this.closed) {\n\t\t\tthrow new Error(\"web socket is closed\");\n\t\t}\n\t\tif (!this.activeSocket || this.activeSocket.readyState !== this.activeSocket.OPEN) {\n\t\t\tthis.messageBuffer.push(data);\n\t\t} else {\n\t\t\tthis.activeSocket.send(data);\n\t\t}\n\t}\n\n\t/**\n\t * Close socket connection.\n\t */\n\tpublic close(): void {\n\t\tthis.closed = true;\n\t\tthis.dispose();\n\t\tthis.closeEmitter.emit();\n\t}\n\n\t/**\n\t * Connect to the server.\n\t */\n\tprivate async connect(): Promise<void> {\n\t\tconst socket = await this.openSocket();\n\n\t\tsocket.addEventListener(\"message\", (event: MessageEvent) => {\n\t\t\tthis.messageEmitter.emit(event.data);\n\t\t});\n\n\t\tsocket.addEventListener(\"close\", (event) => {\n\t\t\tif (this.isUp) {\n\t\t\t\tthis.isUp = false;\n\t\t\t\ttry {\n\t\t\t\t\tthis.downEmitter.emit(undefined);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Don't let errors here prevent restarting.\n\t\t\t\t\tlogger.error(error.message);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogger.warn(\n\t\t\t\t\"Web socket closed\",\n\t\t\t\tfield(\"code\", event.code),\n\t\t\t\tfield(\"reason\", event.reason),\n\t\t\t\tfield(\"wasClean\", event.wasClean),\n\t\t\t);\n\t\t\tif (!this.closed) {\n\t\t\t\tthis.retry.block();\n\t\t\t\tthis.retry.run();\n\t\t\t}\n\t\t});\n\n\t\t// Send any messages that were queued while we were waiting to connect.\n\t\twhile (this.messageBuffer.length > 0) {\n\t\t\tsocket.send(this.messageBuffer.shift()!);\n\t\t}\n\n\t\tif (!this.isUp) {\n\t\t\tthis.isUp = true;\n\t\t\tthis.upEmitter.emit(undefined);\n\t\t}\n\t}\n\n\t/**\n\t * Open a web socket, disposing the previous connection if any.\n\t */\n\tprivate async openSocket(): Promise<WebSocket> {\n\t\tthis.dispose();\n\t\tconst wsProto = location.protocol === \"https:\" ? \"wss\" : \"ws\";\n\t\tconst socket = new WebSocket(\n\t\t\t`${wsProto}://${location.host}${location.pathname}`,\n\t\t);\n\t\tsocket.binaryType = \"arraybuffer\";\n\t\tthis.activeSocket = socket;\n\n\t\tconst socketWaitTimeout = window.setTimeout(() => {\n\t\t\tsocket.close();\n\t\t}, this.socketTimeoutDelay);\n\n\t\tawait new Promise((resolve, reject): void => {\n\t\t\tconst doReject = (): void => {\n\t\t\t\tclearTimeout(socketWaitTimeout);\n\t\t\t\tsocket.removeEventListener(\"error\", doReject);\n\t\t\t\tsocket.removeEventListener(\"close\", doReject);\n\t\t\t\treject();\n\t\t\t};\n\t\t\tsocket.addEventListener(\"error\", doReject);\n\t\t\tsocket.addEventListener(\"close\", doReject);\n\n\t\t\tsocket.addEventListener(\"open\", () => {\n\t\t\t\tclearTimeout(socketWaitTimeout);\n\t\t\t\tsocket.removeEventListener(\"error\", doReject);\n\t\t\t\tsocket.removeEventListener(\"close\", doReject);\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\n\t\treturn socket;\n\t}\n\n\t/**\n\t * Dispose the current connection.\n\t */\n\tprivate dispose(): void {\n\t\tif (this.activeSocket) {\n\t\t\tthis.activeSocket.close();\n\t\t}\n\t}\n}\n\n// Global instance so all fills can use the same client.\nexport const client = new Client(new WebsocketConnection());\n"]}]}