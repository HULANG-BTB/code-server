{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/editor/common/editorService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/editor/common/editorService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nexports.IEditorService = instantiation_1.createDecorator('editorService');\nexports.ACTIVE_GROUP = -1;\nexports.SIDE_GROUP = -2;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/editor/common/editorService.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/editor/common/editorService.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;AAEhG,gFAAsH;AAQzG,QAAA,cAAc,GAAG,+BAAe,CAAiB,eAAe,CAAC,CAAC;AASlE,QAAA,YAAY,GAAG,CAAC,CAAC,CAAC;AAGlB,QAAA,UAAU,GAAG,CAAC,CAAC,CAAC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator, ServiceIdentifier, ServicesAccessor } from 'vs/platform/instantiation/common/instantiation';\nimport { IResourceInput, IEditorOptions, ITextEditorOptions } from 'vs/platform/editor/common/editor';\nimport { IEditorInput, IEditor, GroupIdentifier, IEditorInputWithOptions, IUntitledResourceInput, IResourceDiffInput, IResourceSideBySideInput, ITextEditor, ITextDiffEditor, ITextSideBySideEditor } from 'vs/workbench/common/editor';\nimport { Event } from 'vs/base/common/event';\nimport { IEditor as ICodeEditor } from 'vs/editor/common/editorCommon';\nimport { IEditorGroup, IEditorReplacement } from 'vs/workbench/services/editor/common/editorGroupsService';\nimport { IDisposable } from 'vs/base/common/lifecycle';\n\nexport const IEditorService = createDecorator<IEditorService>('editorService');\n\nexport type IResourceEditor = IResourceInput | IUntitledResourceInput | IResourceDiffInput | IResourceSideBySideInput;\n\nexport interface IResourceEditorReplacement {\n\teditor: IResourceEditor;\n\treplacement: IResourceEditor;\n}\n\nexport const ACTIVE_GROUP = -1;\nexport type ACTIVE_GROUP_TYPE = typeof ACTIVE_GROUP;\n\nexport const SIDE_GROUP = -2;\nexport type SIDE_GROUP_TYPE = typeof SIDE_GROUP;\n\nexport interface IOpenEditorOverrideHandler {\n\t(editor: IEditorInput, options: IEditorOptions | ITextEditorOptions | undefined, group: IEditorGroup): IOpenEditorOverride | undefined;\n}\n\nexport interface IOpenEditorOverride {\n\n\t/**\n\t * If defined, will prevent the opening of an editor and replace the resulting\n\t * promise with the provided promise for the openEditor() call.\n\t */\n\toverride?: Promise<IEditor | null>;\n}\n\nexport interface IVisibleEditor extends IEditor {\n\tinput: IEditorInput;\n\tgroup: IEditorGroup;\n}\n\nexport interface IEditorService {\n\t_serviceBrand: ServiceIdentifier<any>;\n\n\t/**\n\t * Emitted when the currently active editor changes.\n\t *\n\t * @see `IEditorService.activeEditor`\n\t */\n\treadonly onDidActiveEditorChange: Event<void>;\n\n\t/**\n\t * Emitted when any of the current visible editors changes.\n\t *\n\t * @see `IEditorService.visibleEditors`\n\t */\n\treadonly onDidVisibleEditorsChange: Event<void>;\n\n\t/**\n\t * The currently active editor or `undefined` if none. An editor is active when it is\n\t * located in the currently active editor group. It will be `undefined` if the active\n\t * editor group has no editors open.\n\t */\n\treadonly activeEditor: IEditorInput | undefined;\n\n\t/**\n\t * The currently active editor control or `undefined` if none. The editor control is\n\t * the workbench container for editors of any kind.\n\t *\n\t * @see `IEditorService.activeEditor`\n\t */\n\treadonly activeControl: IVisibleEditor | undefined;\n\n\t/**\n\t * The currently active text editor widget or `undefined` if there is currently no active\n\t * editor or the active editor widget is neither a text nor a diff editor.\n\t *\n\t * @see `IEditorService.activeEditor`\n\t */\n\treadonly activeTextEditorWidget: ICodeEditor | undefined;\n\n\t/**\n\t * All editors that are currently visible. An editor is visible when it is opened in an\n\t * editor group and active in that group. Multiple editor groups can be opened at the same time.\n\t */\n\treadonly visibleEditors: ReadonlyArray<IEditorInput>;\n\n\t/**\n\t * All editor controls that are currently visible across all editor groups.\n\t */\n\treadonly visibleControls: ReadonlyArray<IVisibleEditor>;\n\n\t/**\n\t * All text editor widgets that are currently visible across all editor groups. A text editor\n\t * widget is either a text or a diff editor.\n\t */\n\treadonly visibleTextEditorWidgets: ReadonlyArray<ICodeEditor>;\n\n\t/**\n\t * All editors that are opened across all editor groups. This includes active as well as inactive\n\t * editors in each editor group.\n\t */\n\treadonly editors: ReadonlyArray<IEditorInput>;\n\n\t/**\n\t * Open an editor in an editor group.\n\t *\n\t * @param editor the editor to open\n\t * @param options the options to use for the editor\n\t * @param group the target group. If unspecified, the editor will open in the currently\n\t * active group. Use `SIDE_GROUP_TYPE` to open the editor in a new editor group to the side\n\t * of the currently active group.\n\t *\n\t * @returns the editor that opened or NULL if the operation failed or the editor was not\n\t * opened to be active.\n\t */\n\topenEditor(editor: IEditorInput, options?: IEditorOptions | ITextEditorOptions, group?: IEditorGroup | GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE): Promise<IEditor | null>;\n\topenEditor(editor: IResourceInput | IUntitledResourceInput, group?: IEditorGroup | GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE): Promise<ITextEditor | null>;\n\topenEditor(editor: IResourceDiffInput, group?: IEditorGroup | GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE): Promise<ITextDiffEditor | null>;\n\topenEditor(editor: IResourceSideBySideInput, group?: IEditorGroup | GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE): Promise<ITextSideBySideEditor | null>;\n\n\t/**\n\t * Open editors in an editor group.\n\t *\n\t * @param editors the editors to open with associated options\n\t * @param group the target group. If unspecified, the editor will open in the currently\n\t * active group. Use `SIDE_GROUP_TYPE` to open the editor in a new editor group to the side\n\t * of the currently active group.\n\t *\n\t * @returns the editors that opened. The array can be empty or have less elements for editors\n\t * that failed to open or were instructed to open as inactive.\n\t */\n\topenEditors(editors: IEditorInputWithOptions[], group?: IEditorGroup | GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE): Promise<ReadonlyArray<IEditor>>;\n\topenEditors(editors: IResourceEditor[], group?: IEditorGroup | GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE): Promise<ReadonlyArray<IEditor>>;\n\n\t/**\n\t * Replaces editors in an editor group with the provided replacement.\n\t *\n\t * @param editors the editors to replace\n\t *\n\t * @returns a promise that is resolved when the replaced active\n\t * editor (if any) has finished loading.\n\t */\n\treplaceEditors(editors: IResourceEditorReplacement[], group: IEditorGroup | GroupIdentifier): Promise<void>;\n\treplaceEditors(editors: IEditorReplacement[], group: IEditorGroup | GroupIdentifier): Promise<void>;\n\n\t/**\n\t * Find out if the provided editor (or resource of an editor) is opened in any or\n\t * a specific editor group.\n\t *\n\t * Note: An editor can be opened but not actively visible.\n\t *\n\t * @param group optional to specify a group to check for the editor being opened\n\t */\n\tisOpen(editor: IEditorInput | IResourceInput | IUntitledResourceInput, group?: IEditorGroup | GroupIdentifier): boolean;\n\n\t/**\n\t * Get the actual opened editor input in any or a specific editor group based on the resource.\n\t *\n\t * Note: An editor can be opened but not actively visible.\n\t *\n\t * @param group optional to specify a group to check for the editor\n\t */\n\tgetOpened(editor: IResourceInput | IUntitledResourceInput, group?: IEditorGroup | GroupIdentifier): IEditorInput | undefined;\n\n\t/**\n\t * Allows to override the opening of editors by installing a handler that will\n\t * be called each time an editor is about to open allowing to override the\n\t * operation to open a different editor.\n\t */\n\toverrideOpenEditor(handler: IOpenEditorOverrideHandler): IDisposable;\n\n\t/**\n\t * Invoke a function in the context of the services of the active editor.\n\t */\n\tinvokeWithinEditorContext<T>(fn: (accessor: ServicesAccessor) => T): T;\n\n\t/**\n\t * Converts a lightweight input to a workbench editor input.\n\t */\n\tcreateInput(input: IResourceEditor): IEditorInput | null;\n}"]}]}