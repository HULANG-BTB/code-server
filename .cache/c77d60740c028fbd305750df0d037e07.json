{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/browser/linkDetector.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/browser/linkDetector.ts","mtime":1555846338040},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar strings = require(\"vs/base/common/strings\");\nvar path_1 = require(\"vs/base/common/path\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar browser_1 = require(\"vs/base/browser/browser\");\nvar mouseEvent_1 = require(\"vs/base/browser/mouseEvent\");\nvar nls = require(\"vs/nls\");\nvar editorService_1 = require(\"vs/workbench/services/editor/common/editorService\");\nvar LinkDetector = /** @class */ (function () {\n    function LinkDetector(editorService) {\n        this.editorService = editorService;\n        // noop\n    }\n    /**\n     * Matches and handles absolute file links in the string provided.\n     * Returns <span/> element that wraps the processed string, where matched links are replaced by <a/> and unmatched parts are surrounded by <span/> elements.\n     * 'onclick' event is attached to all anchored links that opens them in the editor.\n     * Each line of the text, even if it contains no links, is wrapped in a <span> and added as a child of the returned <span>.\n     */\n    LinkDetector.prototype.handleLinks = function (text) {\n        var _this = this;\n        var container = document.createElement('span');\n        // Handle the text one line at a time\n        var lines = text.split('\\n');\n        if (strings.endsWith(text, '\\n')) {\n            // Remove the last element ('') that split added\n            lines.pop();\n        }\n        for (var i = 0; i < lines.length; i++) {\n            var line = lines[i];\n            // Re-introduce the newline for every line except the last (unless the last line originally ended with a newline)\n            if (i < lines.length - 1 || strings.endsWith(text, '\\n')) {\n                line += '\\n';\n            }\n            // Don't handle links for lines that are too long\n            if (line.length > LinkDetector.MAX_LENGTH) {\n                var span = document.createElement('span');\n                span.textContent = line;\n                container.appendChild(span);\n                continue;\n            }\n            var lineContainer = document.createElement('span');\n            for (var _i = 0, _a = LinkDetector.FILE_LOCATION_PATTERNS; _i < _a.length; _i++) {\n                var pattern = _a[_i];\n                // Reset the state of the pattern\n                pattern = new RegExp(pattern);\n                var lastMatchIndex = 0;\n                var match = pattern.exec(line);\n                var _loop_1 = function () {\n                    var resource = path_1.isAbsolute(match[1]) ? uri_1.URI.file(match[1]) : null;\n                    if (!resource) {\n                        match = pattern.exec(line);\n                        return \"continue\";\n                    }\n                    var textBeforeLink = line.substring(lastMatchIndex, match.index);\n                    if (textBeforeLink) {\n                        // textBeforeLink may have matches for other patterns, so we run handleLinks on it before adding it.\n                        lineContainer.appendChild(this_1.handleLinks(textBeforeLink));\n                    }\n                    var link = document.createElement('a');\n                    link.textContent = line.substr(match.index, match[0].length);\n                    link.title = browser_1.isMacintosh ? nls.localize('fileLinkMac', \"Click to follow (Cmd + click opens to the side)\") : nls.localize('fileLink', \"Click to follow (Ctrl + click opens to the side)\");\n                    lineContainer.appendChild(link);\n                    var lineNumber = Number(match[3]);\n                    var columnNumber = match[4] ? Number(match[4]) : undefined;\n                    link.onclick = function (e) { return _this.onLinkClick(new mouseEvent_1.StandardMouseEvent(e), resource, lineNumber, columnNumber); };\n                    lastMatchIndex = pattern.lastIndex;\n                    var currentMatch = match;\n                    match = pattern.exec(line);\n                    // Append last string part if no more link matches\n                    if (!match) {\n                        var textAfterLink = line.substr(currentMatch.index + currentMatch[0].length);\n                        if (textAfterLink) {\n                            // textAfterLink may have matches for other patterns, so we run handleLinks on it before adding it.\n                            lineContainer.appendChild(this_1.handleLinks(textAfterLink));\n                        }\n                    }\n                };\n                var this_1 = this;\n                while (match !== null) {\n                    _loop_1();\n                }\n                // If we found any matches for this pattern, don't check any more patterns. Other parts of the line will be checked for the other patterns due to the recursion.\n                if (lineContainer.hasChildNodes()) {\n                    break;\n                }\n            }\n            if (lines.length === 1) {\n                if (lineContainer.hasChildNodes()) {\n                    // Adding lineContainer to container would introduce an unnecessary surrounding span since there is only one line, so instead we just return lineContainer\n                    return lineContainer;\n                }\n                else {\n                    container.textContent = line;\n                }\n            }\n            else {\n                if (lineContainer.hasChildNodes()) {\n                    // Add this line to the container\n                    container.appendChild(lineContainer);\n                }\n                else {\n                    // No links were added, but we still need to surround the unmodified line with a span before adding it\n                    var span = document.createElement('span');\n                    span.textContent = line;\n                    container.appendChild(span);\n                }\n            }\n        }\n        return container;\n    };\n    LinkDetector.prototype.onLinkClick = function (event, resource, line, column) {\n        if (column === void 0) { column = 0; }\n        var selection = window.getSelection();\n        if (selection.type === 'Range') {\n            return; // do not navigate when user is selecting\n        }\n        event.preventDefault();\n        var group = event.ctrlKey || event.metaKey ? editorService_1.SIDE_GROUP : editorService_1.ACTIVE_GROUP;\n        this.editorService.openEditor({\n            resource: resource,\n            options: {\n                selection: {\n                    startLineNumber: line,\n                    startColumn: column\n                }\n            }\n        }, group);\n    };\n    LinkDetector.MAX_LENGTH = 500;\n    LinkDetector.FILE_LOCATION_PATTERNS = [\n        // group 0: full path with line and column\n        // group 1: full path without line and column, matched by `*.*` in the end to work only on paths with extensions in the end (s.t. node:10352 would not match)\n        // group 2: drive letter on windows with trailing backslash or leading slash on mac/linux\n        // group 3: line number, matched by (:(\\d+))\n        // group 4: column number, matched by ((?::(\\d+))?)\n        // eg: at Context.<anonymous> (c:\\Users\\someone\\Desktop\\mocha-runner\\test\\test.js:26:11)\n        /(?![\\(])(?:file:\\/\\/)?((?:([a-zA-Z]+:)|[^\\(\\)<>\\'\\\"\\[\\]:\\s]+)(?:[\\\\/][^\\(\\)<>\\'\\\"\\[\\]:]*)?\\.[a-zA-Z]+[0-9]*):(\\d+)(?::(\\d+))?/g\n    ];\n    LinkDetector = tslib_1.__decorate([\n        tslib_1.__param(0, editorService_1.IEditorService)\n    ], LinkDetector);\n    return LinkDetector;\n}());\nexports.LinkDetector = LinkDetector;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/browser/linkDetector.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/browser/linkDetector.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport strings = require('vs/base/common/strings');\nimport { isAbsolute } from 'vs/base/common/path';\nimport { URI as uri } from 'vs/base/common/uri';\nimport { isMacintosh } from 'vs/base/browser/browser';\nimport { IMouseEvent, StandardMouseEvent } from 'vs/base/browser/mouseEvent';\nimport * as nls from 'vs/nls';\nimport { IEditorService, SIDE_GROUP, ACTIVE_GROUP } from 'vs/workbench/services/editor/common/editorService';\n\nexport class LinkDetector {\n\tprivate static readonly MAX_LENGTH = 500;\n\tprivate static FILE_LOCATION_PATTERNS: RegExp[] = [\n\t\t// group 0: full path with line and column\n\t\t// group 1: full path without line and column, matched by `*.*` in the end to work only on paths with extensions in the end (s.t. node:10352 would not match)\n\t\t// group 2: drive letter on windows with trailing backslash or leading slash on mac/linux\n\t\t// group 3: line number, matched by (:(\\d+))\n\t\t// group 4: column number, matched by ((?::(\\d+))?)\n\t\t// eg: at Context.<anonymous> (c:\\Users\\someone\\Desktop\\mocha-runner\\test\\test.js:26:11)\n\t\t/(?![\\(])(?:file:\\/\\/)?((?:([a-zA-Z]+:)|[^\\(\\)<>\\'\\\"\\[\\]:\\s]+)(?:[\\\\/][^\\(\\)<>\\'\\\"\\[\\]:]*)?\\.[a-zA-Z]+[0-9]*):(\\d+)(?::(\\d+))?/g\n\t];\n\n\tconstructor(\n\t\t@IEditorService private readonly editorService: IEditorService\n\t) {\n\t\t// noop\n\t}\n\n\t/**\n\t * Matches and handles absolute file links in the string provided.\n\t * Returns <span/> element that wraps the processed string, where matched links are replaced by <a/> and unmatched parts are surrounded by <span/> elements.\n\t * 'onclick' event is attached to all anchored links that opens them in the editor.\n\t * Each line of the text, even if it contains no links, is wrapped in a <span> and added as a child of the returned <span>.\n\t */\n\thandleLinks(text: string): HTMLElement {\n\t\tconst container = document.createElement('span');\n\n\t\t// Handle the text one line at a time\n\t\tconst lines = text.split('\\n');\n\n\t\tif (strings.endsWith(text, '\\n')) {\n\t\t\t// Remove the last element ('') that split added\n\t\t\tlines.pop();\n\t\t}\n\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tlet line = lines[i];\n\n\t\t\t// Re-introduce the newline for every line except the last (unless the last line originally ended with a newline)\n\t\t\tif (i < lines.length - 1 || strings.endsWith(text, '\\n')) {\n\t\t\t\tline += '\\n';\n\t\t\t}\n\n\t\t\t// Don't handle links for lines that are too long\n\t\t\tif (line.length > LinkDetector.MAX_LENGTH) {\n\t\t\t\tlet span = document.createElement('span');\n\t\t\t\tspan.textContent = line;\n\t\t\t\tcontainer.appendChild(span);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst lineContainer = document.createElement('span');\n\n\t\t\tfor (let pattern of LinkDetector.FILE_LOCATION_PATTERNS) {\n\t\t\t\t// Reset the state of the pattern\n\t\t\t\tpattern = new RegExp(pattern);\n\t\t\t\tlet lastMatchIndex = 0;\n\n\t\t\t\tlet match = pattern.exec(line);\n\n\t\t\t\twhile (match !== null) {\n\t\t\t\t\tlet resource: uri | null = isAbsolute(match[1]) ? uri.file(match[1]) : null;\n\n\t\t\t\t\tif (!resource) {\n\t\t\t\t\t\tmatch = pattern.exec(line);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst textBeforeLink = line.substring(lastMatchIndex, match.index);\n\t\t\t\t\tif (textBeforeLink) {\n\t\t\t\t\t\t// textBeforeLink may have matches for other patterns, so we run handleLinks on it before adding it.\n\t\t\t\t\t\tlineContainer.appendChild(this.handleLinks(textBeforeLink));\n\t\t\t\t\t}\n\n\t\t\t\t\tconst link = document.createElement('a');\n\t\t\t\t\tlink.textContent = line.substr(match.index, match[0].length);\n\t\t\t\t\tlink.title = isMacintosh ? nls.localize('fileLinkMac', \"Click to follow (Cmd + click opens to the side)\") : nls.localize('fileLink', \"Click to follow (Ctrl + click opens to the side)\");\n\t\t\t\t\tlineContainer.appendChild(link);\n\t\t\t\t\tconst lineNumber = Number(match[3]);\n\t\t\t\t\tconst columnNumber = match[4] ? Number(match[4]) : undefined;\n\t\t\t\t\tlink.onclick = (e) => this.onLinkClick(new StandardMouseEvent(e), resource!, lineNumber, columnNumber);\n\n\t\t\t\t\tlastMatchIndex = pattern.lastIndex;\n\t\t\t\t\tconst currentMatch = match;\n\t\t\t\t\tmatch = pattern.exec(line);\n\n\t\t\t\t\t// Append last string part if no more link matches\n\t\t\t\t\tif (!match) {\n\t\t\t\t\t\tconst textAfterLink = line.substr(currentMatch.index + currentMatch[0].length);\n\t\t\t\t\t\tif (textAfterLink) {\n\t\t\t\t\t\t\t// textAfterLink may have matches for other patterns, so we run handleLinks on it before adding it.\n\t\t\t\t\t\t\tlineContainer.appendChild(this.handleLinks(textAfterLink));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If we found any matches for this pattern, don't check any more patterns. Other parts of the line will be checked for the other patterns due to the recursion.\n\t\t\t\tif (lineContainer.hasChildNodes()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lines.length === 1) {\n\t\t\t\tif (lineContainer.hasChildNodes()) {\n\t\t\t\t\t// Adding lineContainer to container would introduce an unnecessary surrounding span since there is only one line, so instead we just return lineContainer\n\t\t\t\t\treturn lineContainer;\n\t\t\t\t} else {\n\t\t\t\t\tcontainer.textContent = line;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (lineContainer.hasChildNodes()) {\n\t\t\t\t\t// Add this line to the container\n\t\t\t\t\tcontainer.appendChild(lineContainer);\n\t\t\t\t} else {\n\t\t\t\t\t// No links were added, but we still need to surround the unmodified line with a span before adding it\n\t\t\t\t\tlet span = document.createElement('span');\n\t\t\t\t\tspan.textContent = line;\n\t\t\t\t\tcontainer.appendChild(span);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn container;\n\t}\n\n\tprivate onLinkClick(event: IMouseEvent, resource: uri, line: number, column: number = 0): void {\n\t\tconst selection = window.getSelection();\n\t\tif (selection.type === 'Range') {\n\t\t\treturn; // do not navigate when user is selecting\n\t\t}\n\n\t\tevent.preventDefault();\n\t\tconst group = event.ctrlKey || event.metaKey ? SIDE_GROUP : ACTIVE_GROUP;\n\n\t\tthis.editorService.openEditor({\n\t\t\tresource,\n\t\t\toptions: {\n\t\t\t\tselection: {\n\t\t\t\t\tstartLineNumber: line,\n\t\t\t\t\tstartColumn: column\n\t\t\t\t}\n\t\t\t}\n\t\t}, group);\n\t}\n}\n"]}]}