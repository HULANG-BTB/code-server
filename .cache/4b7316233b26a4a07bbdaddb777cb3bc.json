{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/suggest/wordDistance.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/suggest/wordDistance.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/arrays\", \"vs/editor/common/core/range\", \"vs/editor/common/modes\", \"vs/editor/contrib/smartSelect/bracketSelections\"], function (require, exports, arrays_1, range_1, modes_1, bracketSelections_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class WordDistance {\n        static create(service, editor) {\n            if (!editor.getConfiguration().contribInfo.suggest.localityBonus) {\n                return Promise.resolve(WordDistance.None);\n            }\n            if (!editor.hasModel()) {\n                return Promise.resolve(WordDistance.None);\n            }\n            const model = editor.getModel();\n            const position = editor.getPosition();\n            if (!service.canComputeWordRanges(model.uri)) {\n                return Promise.resolve(WordDistance.None);\n            }\n            return new bracketSelections_1.BracketSelectionRangeProvider().provideSelectionRanges(model, [position]).then(ranges => {\n                if (!ranges || ranges.length === 0 || ranges[0].length === 0) {\n                    return WordDistance.None;\n                }\n                return service.computeWordRanges(model.uri, ranges[0][0].range).then(wordRanges => {\n                    return new class extends WordDistance {\n                        distance(anchor, suggestion) {\n                            if (!wordRanges || !position.equals(editor.getPosition())) {\n                                return 0;\n                            }\n                            if (suggestion.kind === modes_1.CompletionItemKind.Keyword) {\n                                return 2 << 20;\n                            }\n                            let word = suggestion.label;\n                            let wordLines = wordRanges[word];\n                            if (arrays_1.isFalsyOrEmpty(wordLines)) {\n                                return 2 << 20;\n                            }\n                            let idx = arrays_1.binarySearch(wordLines, range_1.Range.fromPositions(anchor), range_1.Range.compareRangesUsingStarts);\n                            let bestWordRange = idx >= 0 ? wordLines[idx] : wordLines[Math.max(0, ~idx - 1)];\n                            let blockDistance = ranges.length;\n                            for (const range of ranges[0]) {\n                                if (!range_1.Range.containsRange(range.range, bestWordRange)) {\n                                    break;\n                                }\n                                blockDistance -= 1;\n                            }\n                            return blockDistance;\n                        }\n                    };\n                });\n            });\n        }\n    }\n    WordDistance.None = new class extends WordDistance {\n        distance() { return 0; }\n    };\n    exports.WordDistance = WordDistance;\n});\n",null]}