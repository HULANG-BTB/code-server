{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/extensions/electron-browser/extensionTipsService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/extensions/electron-browser/extensionTipsService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/path\", \"vs/base/common/collections\", \"vs/base/common/lifecycle\", \"vs/base/common/glob\", \"vs/base/common/json\", \"vs/platform/extensionManagement/common/extensionManagement\", \"vs/editor/common/services/modelService\", \"vs/platform/storage/common/storage\", \"vs/platform/product/node/product\", \"vs/platform/instantiation/common/instantiation\", \"vs/workbench/contrib/extensions/electron-browser/extensionsActions\", \"vs/base/common/severity\", \"vs/platform/workspace/common/workspace\", \"vs/platform/files/common/files\", \"vs/workbench/contrib/extensions/common/extensions\", \"vs/platform/configuration/common/configuration\", \"vs/platform/telemetry/common/telemetry\", \"vs/base/node/pfs\", \"os\", \"vs/base/common/arrays\", \"vs/platform/environment/common/environment\", \"vs/base/common/mime\", \"vs/workbench/services/extensions/common/extensions\", \"vs/workbench/contrib/stats/node/workspaceStats\", \"vs/platform/request/node/request\", \"vs/base/node/request\", \"vs/base/common/types\", \"vs/workbench/services/viewlet/browser/viewlet\", \"vs/platform/notification/common/notification\", \"vs/base/common/event\", \"vs/base/common/objects\", \"vs/base/common/uri\", \"vs/platform/extensionManagement/common/extensionManagementUtil\", \"vs/workbench/contrib/experiments/node/experimentService\", \"vs/base/common/cancellation\", \"vs/platform/extensions/common/extensions\", \"vs/base/common/resources\"], function (require, exports, nls_1, path_1, collections_1, lifecycle_1, glob_1, json, extensionManagement_1, modelService_1, storage_1, product_1, instantiation_1, extensionsActions_1, severity_1, workspace_1, files_1, extensions_1, configuration_1, telemetry_1, pfs, os, arrays_1, environment_1, mime_1, extensions_2, workspaceStats_1, request_1, request_2, types_1, viewlet_1, notification_1, event_1, objects_1, uri_1, extensionManagementUtil_1, experimentService_1, cancellation_1, extensions_3, resources_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const milliSecondsInADay = 1000 * 60 * 60 * 24;\n    const choiceNever = nls_1.localize('neverShowAgain', \"Don't Show Again\");\n    const searchMarketplace = nls_1.localize('searchMarketplace', \"Search Marketplace\");\n    const processedFileExtensions = [];\n    function caseInsensitiveGet(obj, key) {\n        if (!obj) {\n            return undefined;\n        }\n        for (const _key in obj) {\n            if (Object.hasOwnProperty.call(obj, _key) && _key.toLowerCase() === key.toLowerCase()) {\n                return obj[_key];\n            }\n        }\n        return undefined;\n    }\n    let ExtensionTipsService = class ExtensionTipsService extends lifecycle_1.Disposable {\n        constructor(_galleryService, _modelService, storageService, extensionsService, instantiationService, fileService, contextService, configurationService, telemetryService, environmentService, extensionService, requestService, viewletService, notificationService, extensionManagementService, extensionWorkbenchService, experimentService) {\n            super();\n            this._galleryService = _galleryService;\n            this._modelService = _modelService;\n            this.storageService = storageService;\n            this.extensionsService = extensionsService;\n            this.instantiationService = instantiationService;\n            this.fileService = fileService;\n            this.contextService = contextService;\n            this.configurationService = configurationService;\n            this.telemetryService = telemetryService;\n            this.environmentService = environmentService;\n            this.extensionService = extensionService;\n            this.requestService = requestService;\n            this.viewletService = viewletService;\n            this.notificationService = notificationService;\n            this.extensionManagementService = extensionManagementService;\n            this.extensionWorkbenchService = extensionWorkbenchService;\n            this.experimentService = experimentService;\n            this._fileBasedRecommendations = Object.create(null);\n            this._exeBasedRecommendations = Object.create(null);\n            this._availableRecommendations = Object.create(null);\n            this._allWorkspaceRecommendedExtensions = [];\n            this._dynamicWorkspaceRecommendations = [];\n            this._experimentalRecommendations = Object.create(null);\n            this._allIgnoredRecommendations = [];\n            this._globallyIgnoredRecommendations = [];\n            this._workspaceIgnoredRecommendations = [];\n            this._disposables = [];\n            this.proactiveRecommendationsFetched = false;\n            this._onRecommendationChange = new event_1.Emitter();\n            this.onRecommendationChange = this._onRecommendationChange.event;\n            if (!this.isEnabled()) {\n                return;\n            }\n            if (product_1.default.extensionsGallery && product_1.default.extensionsGallery.recommendationsUrl) {\n                this._extensionsRecommendationsUrl = product_1.default.extensionsGallery.recommendationsUrl;\n            }\n            this.sessionSeed = +new Date();\n            let globallyIgnored = JSON.parse(this.storageService.get('extensionsAssistant/ignored_recommendations', storage_1.StorageScope.GLOBAL, '[]'));\n            this._globallyIgnoredRecommendations = globallyIgnored.map(id => id.toLowerCase());\n            this.fetchCachedDynamicWorkspaceRecommendations();\n            this.fetchFileBasedRecommendations();\n            this.fetchExperimentalRecommendations();\n            if (!this.configurationService.getValue(extensions_1.ShowRecommendationsOnlyOnDemandKey)) {\n                this.fetchProactiveRecommendations(true);\n            }\n            this.loadWorkspaceConfigPromise = this.getWorkspaceRecommendations().then(() => {\n                this.promptWorkspaceRecommendations();\n                this._modelService.onModelAdded(this.promptFiletypeBasedRecommendations, this, this._disposables);\n                this._modelService.getModels().forEach(model => this.promptFiletypeBasedRecommendations(model));\n            });\n            this._register(this.contextService.onDidChangeWorkspaceFolders(e => this.onWorkspaceFoldersChanged(e)));\n            this._register(this.configurationService.onDidChangeConfiguration(e => {\n                if (!this.proactiveRecommendationsFetched && !this.configurationService.getValue(extensions_1.ShowRecommendationsOnlyOnDemandKey)) {\n                    this.fetchProactiveRecommendations();\n                }\n            }));\n            this._register(this.extensionManagementService.onDidInstallExtension(e => {\n                if (e.gallery && e.operation === extensionManagement_1.InstallOperation.Install) {\n                    const extRecommendations = this.getAllRecommendationsWithReason() || {};\n                    const recommendationReason = extRecommendations[e.gallery.identifier.id.toLowerCase()];\n                    if (recommendationReason) {\n                        /* __GDPR__\n                            \"extensionGallery:install:recommendations\" : {\n                                \"recommendationReason\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                                \"${include}\": [\n                                    \"${GalleryExtensionTelemetryData}\"\n                                ]\n                            }\n                        */\n                        this.telemetryService.publicLog('extensionGallery:install:recommendations', objects_1.assign(e.gallery.telemetryData, { recommendationReason: recommendationReason.reasonId }));\n                    }\n                }\n            }));\n        }\n        isEnabled() {\n            return this._galleryService.isEnabled() && !this.environmentService.extensionDevelopmentLocationURI;\n        }\n        getAllRecommendationsWithReason() {\n            let output = Object.create(null);\n            if (!this.proactiveRecommendationsFetched) {\n                return output;\n            }\n            collections_1.forEach(this._experimentalRecommendations, entry => output[entry.key.toLowerCase()] = {\n                reasonId: extensionManagement_1.ExtensionRecommendationReason.Experimental,\n                reasonText: entry.value\n            });\n            if (this.contextService.getWorkspace().folders && this.contextService.getWorkspace().folders.length === 1) {\n                const currentRepo = this.contextService.getWorkspace().folders[0].name;\n                this._dynamicWorkspaceRecommendations.forEach(id => output[id.toLowerCase()] = {\n                    reasonId: extensionManagement_1.ExtensionRecommendationReason.DynamicWorkspace,\n                    reasonText: nls_1.localize('dynamicWorkspaceRecommendation', \"This extension may interest you because it's popular among users of the {0} repository.\", currentRepo)\n                });\n            }\n            collections_1.forEach(this._exeBasedRecommendations, entry => output[entry.key.toLowerCase()] = {\n                reasonId: extensionManagement_1.ExtensionRecommendationReason.Executable,\n                reasonText: nls_1.localize('exeBasedRecommendation', \"This extension is recommended because you have {0} installed.\", entry.value)\n            });\n            collections_1.forEach(this._fileBasedRecommendations, entry => output[entry.key.toLowerCase()] = {\n                reasonId: extensionManagement_1.ExtensionRecommendationReason.File,\n                reasonText: nls_1.localize('fileBasedRecommendation', \"This extension is recommended based on the files you recently opened.\")\n            });\n            this._allWorkspaceRecommendedExtensions.forEach(({ extensionId }) => output[extensionId.toLowerCase()] = {\n                reasonId: extensionManagement_1.ExtensionRecommendationReason.Workspace,\n                reasonText: nls_1.localize('workspaceRecommendation', \"This extension is recommended by users of the current workspace.\")\n            });\n            for (const id of this._allIgnoredRecommendations) {\n                delete output[id];\n            }\n            return output;\n        }\n        getAllIgnoredRecommendations() {\n            return {\n                global: this._globallyIgnoredRecommendations,\n                workspace: this._workspaceIgnoredRecommendations\n            };\n        }\n        toggleIgnoredRecommendation(extensionId, shouldIgnore) {\n            const lowerId = extensionId.toLowerCase();\n            if (shouldIgnore) {\n                const reason = this.getAllRecommendationsWithReason()[lowerId];\n                if (reason && reason.reasonId) {\n                    /* __GDPR__\n                        \"extensionsRecommendations:ignoreRecommendation\" : {\n                            \"recommendationReason\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                            \"extensionId\": { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" }\n                        }\n                    */\n                    this.telemetryService.publicLog('extensionsRecommendations:ignoreRecommendation', { id: extensionId, recommendationReason: reason.reasonId });\n                }\n            }\n            this._globallyIgnoredRecommendations = shouldIgnore ?\n                arrays_1.distinct([...this._globallyIgnoredRecommendations, lowerId].map(id => id.toLowerCase())) :\n                this._globallyIgnoredRecommendations.filter(id => id !== lowerId);\n            this.storageService.store('extensionsAssistant/ignored_recommendations', JSON.stringify(this._globallyIgnoredRecommendations), storage_1.StorageScope.GLOBAL);\n            this._allIgnoredRecommendations = arrays_1.distinct([...this._globallyIgnoredRecommendations, ...this._workspaceIgnoredRecommendations]);\n            this._onRecommendationChange.fire({ extensionId: extensionId, isRecommended: !shouldIgnore });\n        }\n        getKeymapRecommendations() {\n            return (product_1.default.keymapExtensionTips || [])\n                .filter(extensionId => this.isExtensionAllowedToBeRecommended(extensionId))\n                .map(extensionId => ({ extensionId, sources: ['application'] }));\n        }\n        //#region workspaceRecommendations\n        getWorkspaceRecommendations() {\n            if (!this.isEnabled()) {\n                return Promise.resolve([]);\n            }\n            return this.fetchWorkspaceRecommendations()\n                .then(() => this._allWorkspaceRecommendedExtensions.filter(rec => this.isExtensionAllowedToBeRecommended(rec.extensionId)));\n        }\n        /**\n         * Parse all extensions.json files, fetch workspace recommendations, filter out invalid and unwanted ones\n         */\n        fetchWorkspaceRecommendations() {\n            if (!this.isEnabled) {\n                return Promise.resolve(undefined);\n            }\n            return this.fetchExtensionRecommendationContents()\n                .then(result => this.validateExtensions(result.map(({ contents }) => contents))\n                .then(({ invalidExtensions, message }) => {\n                if (invalidExtensions.length > 0 && this.notificationService) {\n                    this.notificationService.warn(`The below ${invalidExtensions.length} extension(s) in workspace recommendations have issues:\\n${message}`);\n                }\n                const seenUnWantedRecommendations = {};\n                this._allWorkspaceRecommendedExtensions = [];\n                this._workspaceIgnoredRecommendations = [];\n                for (const contentsBySource of result) {\n                    if (contentsBySource.contents.unwantedRecommendations) {\n                        for (const r of contentsBySource.contents.unwantedRecommendations) {\n                            const unwantedRecommendation = r.toLowerCase();\n                            if (!seenUnWantedRecommendations[unwantedRecommendation] && invalidExtensions.indexOf(unwantedRecommendation) === -1) {\n                                this._workspaceIgnoredRecommendations.push(unwantedRecommendation);\n                                seenUnWantedRecommendations[unwantedRecommendation] = true;\n                            }\n                        }\n                    }\n                    if (contentsBySource.contents.recommendations) {\n                        for (const r of contentsBySource.contents.recommendations) {\n                            const extensionId = r.toLowerCase();\n                            if (invalidExtensions.indexOf(extensionId) === -1) {\n                                let recommendation = this._allWorkspaceRecommendedExtensions.filter(r => r.extensionId === extensionId)[0];\n                                if (!recommendation) {\n                                    recommendation = { extensionId, sources: [] };\n                                    this._allWorkspaceRecommendedExtensions.push(recommendation);\n                                }\n                                if (recommendation.sources.indexOf(contentsBySource.source) === -1) {\n                                    recommendation.sources.push(contentsBySource.source);\n                                }\n                            }\n                        }\n                    }\n                }\n                this._allIgnoredRecommendations = arrays_1.distinct([...this._globallyIgnoredRecommendations, ...this._workspaceIgnoredRecommendations]);\n            }));\n        }\n        /**\n         * Parse all extensions.json files, fetch workspace recommendations\n         */\n        fetchExtensionRecommendationContents() {\n            const workspace = this.contextService.getWorkspace();\n            return Promise.all([\n                this.resolveWorkspaceExtensionConfig(workspace).then(contents => contents ? { contents, source: workspace } : null),\n                ...workspace.folders.map(workspaceFolder => this.resolveWorkspaceFolderExtensionConfig(workspaceFolder).then(contents => contents ? { contents, source: workspaceFolder } : null))\n            ]).then(contents => arrays_1.coalesce(contents));\n        }\n        /**\n         * Parse the extensions.json file for given workspace and return the recommendations\n         */\n        resolveWorkspaceExtensionConfig(workspace) {\n            if (!workspace.configuration) {\n                return Promise.resolve(null);\n            }\n            return Promise.resolve(this.fileService.resolveContent(workspace.configuration)\n                .then(content => (json.parse(content.value)['extensions']), err => null));\n        }\n        /**\n         * Parse the extensions.json files for given workspace folder and return the recommendations\n         */\n        resolveWorkspaceFolderExtensionConfig(workspaceFolder) {\n            const extensionsJsonUri = workspaceFolder.toResource(extensions_1.EXTENSIONS_CONFIG);\n            return Promise.resolve(this.fileService.resolveFile(extensionsJsonUri)\n                .then(() => this.fileService.resolveContent(extensionsJsonUri))\n                .then(content => json.parse(content.value), err => null));\n        }\n        /**\n         * Validate the extensions.json file contents using regex and querying the gallery\n         */\n        validateExtensions(contents) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const extensionsContent = {\n                    recommendations: arrays_1.distinct(arrays_1.flatten(contents.map(content => content.recommendations || []))),\n                    unwantedRecommendations: arrays_1.distinct(arrays_1.flatten(contents.map(content => content.unwantedRecommendations || [])))\n                };\n                const regEx = new RegExp(extensionManagement_1.EXTENSION_IDENTIFIER_PATTERN);\n                const invalidExtensions = [];\n                let message = '';\n                const regexFilter = (ids) => {\n                    return ids.filter((element, position) => {\n                        if (ids.indexOf(element) !== position) {\n                            // This is a duplicate entry, it doesn't hurt anybody\n                            // but it shouldn't be sent in the gallery query\n                            return false;\n                        }\n                        else if (!regEx.test(element)) {\n                            invalidExtensions.push(element.toLowerCase());\n                            message += `${element} (bad format) Expected: <provider>.<name>\\n`;\n                            return false;\n                        }\n                        return true;\n                    });\n                };\n                const filteredWanted = regexFilter(extensionsContent.recommendations || []).map(x => x.toLowerCase());\n                if (filteredWanted.length) {\n                    try {\n                        let validRecommendations = (yield this._galleryService.query({ names: filteredWanted, pageSize: filteredWanted.length }, cancellation_1.CancellationToken.None)).firstPage\n                            .map(extension => extension.identifier.id.toLowerCase());\n                        if (validRecommendations.length !== filteredWanted.length) {\n                            filteredWanted.forEach(element => {\n                                if (validRecommendations.indexOf(element.toLowerCase()) === -1) {\n                                    invalidExtensions.push(element.toLowerCase());\n                                    message += `${element} (not found in marketplace)\\n`;\n                                }\n                            });\n                        }\n                    }\n                    catch (e) {\n                        console.warn('Error querying extensions gallery', e);\n                    }\n                }\n                return { invalidExtensions, message };\n            });\n        }\n        onWorkspaceFoldersChanged(event) {\n            if (event.added.length) {\n                const oldWorkspaceRecommended = this._allWorkspaceRecommendedExtensions;\n                this.getWorkspaceRecommendations()\n                    .then(currentWorkspaceRecommended => {\n                    // Suggest only if at least one of the newly added recommendations was not suggested before\n                    if (currentWorkspaceRecommended.some(current => oldWorkspaceRecommended.every(old => current.extensionId !== old.extensionId))) {\n                        this.promptWorkspaceRecommendations();\n                    }\n                });\n            }\n            this._dynamicWorkspaceRecommendations = [];\n        }\n        /**\n         * Prompt the user to install workspace recommendations if there are any not already installed\n         */\n        promptWorkspaceRecommendations() {\n            const storageKey = 'extensionsAssistant/workspaceRecommendationsIgnore';\n            const config = this.configurationService.getValue(extensions_1.ConfigurationKey);\n            const filteredRecs = this._allWorkspaceRecommendedExtensions.filter(rec => this.isExtensionAllowedToBeRecommended(rec.extensionId));\n            if (filteredRecs.length === 0\n                || config.ignoreRecommendations\n                || config.showRecommendationsOnlyOnDemand\n                || this.storageService.getBoolean(storageKey, storage_1.StorageScope.WORKSPACE, false)) {\n                return;\n            }\n            this.extensionsService.getInstalled(extensions_3.ExtensionType.User).then(local => {\n                const recommendations = filteredRecs.filter(({ extensionId }) => local.every(local => !extensionManagementUtil_1.areSameExtensions({ id: extensionId }, local.identifier)));\n                if (!recommendations.length) {\n                    return Promise.resolve(undefined);\n                }\n                return new Promise(c => {\n                    this.notificationService.prompt(severity_1.default.Info, nls_1.localize('workspaceRecommended', \"This workspace has extension recommendations.\"), [{\n                            label: nls_1.localize('installAll', \"Install All\"),\n                            run: () => {\n                                /* __GDPR__\n                                \"extensionWorkspaceRecommendations:popup\" : {\n                                    \"userReaction\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                                }\n                                */\n                                this.telemetryService.publicLog('extensionWorkspaceRecommendations:popup', { userReaction: 'install' });\n                                const installAllAction = this.instantiationService.createInstance(extensionsActions_1.InstallWorkspaceRecommendedExtensionsAction, extensionsActions_1.InstallWorkspaceRecommendedExtensionsAction.ID, nls_1.localize('installAll', \"Install All\"), recommendations);\n                                installAllAction.run();\n                                installAllAction.dispose();\n                                c(undefined);\n                            }\n                        }, {\n                            label: nls_1.localize('showRecommendations', \"Show Recommendations\"),\n                            run: () => {\n                                /* __GDPR__\n                                    \"extensionWorkspaceRecommendations:popup\" : {\n                                        \"userReaction\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                                    }\n                                */\n                                this.telemetryService.publicLog('extensionWorkspaceRecommendations:popup', { userReaction: 'show' });\n                                const showAction = this.instantiationService.createInstance(extensionsActions_1.ShowRecommendedExtensionsAction, extensionsActions_1.ShowRecommendedExtensionsAction.ID, nls_1.localize('showRecommendations', \"Show Recommendations\"));\n                                showAction.run();\n                                showAction.dispose();\n                                c(undefined);\n                            }\n                        }, {\n                            label: choiceNever,\n                            isSecondary: true,\n                            run: () => {\n                                /* __GDPR__\n                                    \"extensionWorkspaceRecommendations:popup\" : {\n                                        \"userReaction\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                                    }\n                                */\n                                this.telemetryService.publicLog('extensionWorkspaceRecommendations:popup', { userReaction: 'neverShowAgain' });\n                                this.storageService.store(storageKey, true, storage_1.StorageScope.WORKSPACE);\n                                c(undefined);\n                            }\n                        }], {\n                        sticky: true,\n                        onCancel: () => {\n                            /* __GDPR__\n                                \"extensionWorkspaceRecommendations:popup\" : {\n                                    \"userReaction\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                                }\n                            */\n                            this.telemetryService.publicLog('extensionWorkspaceRecommendations:popup', { userReaction: 'cancelled' });\n                            c(undefined);\n                        }\n                    });\n                });\n            });\n        }\n        //#endregion\n        //#region fileBasedRecommendations\n        getFileBasedRecommendations() {\n            return Object.keys(this._fileBasedRecommendations)\n                .sort((a, b) => {\n                if (this._fileBasedRecommendations[a].recommendedTime === this._fileBasedRecommendations[b].recommendedTime) {\n                    if (!product_1.default.extensionImportantTips || caseInsensitiveGet(product_1.default.extensionImportantTips, a)) {\n                        return -1;\n                    }\n                    if (caseInsensitiveGet(product_1.default.extensionImportantTips, b)) {\n                        return 1;\n                    }\n                }\n                return this._fileBasedRecommendations[a].recommendedTime > this._fileBasedRecommendations[b].recommendedTime ? -1 : 1;\n            })\n                .filter(extensionId => this.isExtensionAllowedToBeRecommended(extensionId))\n                .map(extensionId => ({ extensionId, sources: this._fileBasedRecommendations[extensionId].sources }));\n        }\n        /**\n         * Parse all file based recommendations from product.extensionTips\n         * Retire existing recommendations if they are older than a week or are not part of product.extensionTips anymore\n         */\n        fetchFileBasedRecommendations() {\n            const extensionTips = product_1.default.extensionTips;\n            if (!extensionTips) {\n                return;\n            }\n            // group ids by pattern, like {**/*.md} -> [ext.foo1, ext.bar2]\n            this._availableRecommendations = Object.create(null);\n            collections_1.forEach(extensionTips, entry => {\n                let { key: id, value: pattern } = entry;\n                let ids = this._availableRecommendations[pattern];\n                if (!ids) {\n                    this._availableRecommendations[pattern] = [id.toLowerCase()];\n                }\n                else {\n                    ids.push(id.toLowerCase());\n                }\n            });\n            collections_1.forEach(product_1.default.extensionImportantTips, entry => {\n                let { key: id, value } = entry;\n                const { pattern } = value;\n                let ids = this._availableRecommendations[pattern];\n                if (!ids) {\n                    this._availableRecommendations[pattern] = [id.toLowerCase()];\n                }\n                else {\n                    ids.push(id.toLowerCase());\n                }\n            });\n            const allRecommendations = arrays_1.flatten((Object.keys(this._availableRecommendations).map(key => this._availableRecommendations[key])));\n            // retrieve ids of previous recommendations\n            const storedRecommendationsJson = JSON.parse(this.storageService.get('extensionsAssistant/recommendations', storage_1.StorageScope.GLOBAL, '[]'));\n            if (Array.isArray(storedRecommendationsJson)) {\n                for (let id of storedRecommendationsJson) {\n                    if (allRecommendations.indexOf(id) > -1) {\n                        this._fileBasedRecommendations[id.toLowerCase()] = { recommendedTime: Date.now(), sources: ['cached'] };\n                    }\n                }\n            }\n            else {\n                const now = Date.now();\n                collections_1.forEach(storedRecommendationsJson, entry => {\n                    if (typeof entry.value === 'number') {\n                        const diff = (now - entry.value) / milliSecondsInADay;\n                        if (diff <= 7 && allRecommendations.indexOf(entry.key) > -1) {\n                            this._fileBasedRecommendations[entry.key.toLowerCase()] = { recommendedTime: entry.value, sources: ['cached'] };\n                        }\n                    }\n                });\n            }\n        }\n        /**\n         * Prompt the user to either install the recommended extension for the file type in the current editor model\n         * or prompt to search the marketplace if it has extensions that can support the file type\n         */\n        promptFiletypeBasedRecommendations(model) {\n            let hasSuggestion = false;\n            const uri = model.uri;\n            if (!uri || !this.fileService.canHandleResource(uri)) {\n                return;\n            }\n            let fileExtension = resources_1.extname(uri);\n            if (fileExtension) {\n                if (processedFileExtensions.indexOf(fileExtension) > -1) {\n                    return;\n                }\n                processedFileExtensions.push(fileExtension);\n            }\n            // re-schedule this bit of the operation to be off\n            // the critical path - in case glob-match is slow\n            setImmediate(() => {\n                let recommendationsToSuggest = [];\n                const now = Date.now();\n                collections_1.forEach(this._availableRecommendations, entry => {\n                    let { key: pattern, value: ids } = entry;\n                    if (glob_1.match(pattern, uri.path)) {\n                        for (let id of ids) {\n                            if (caseInsensitiveGet(product_1.default.extensionImportantTips, id)) {\n                                recommendationsToSuggest.push(id);\n                            }\n                            const filedBasedRecommendation = this._fileBasedRecommendations[id.toLowerCase()] || { recommendedTime: now, sources: [] };\n                            filedBasedRecommendation.recommendedTime = now;\n                            if (!filedBasedRecommendation.sources.some(s => s instanceof uri_1.URI && s.toString() === uri.toString())) {\n                                filedBasedRecommendation.sources.push(uri);\n                            }\n                            this._fileBasedRecommendations[id.toLowerCase()] = filedBasedRecommendation;\n                        }\n                    }\n                });\n                this.storageService.store('extensionsAssistant/recommendations', JSON.stringify(Object.keys(this._fileBasedRecommendations).reduce((result, key) => { result[key] = this._fileBasedRecommendations[key].recommendedTime; return result; }, {})), storage_1.StorageScope.GLOBAL);\n                const config = this.configurationService.getValue(extensions_1.ConfigurationKey);\n                if (config.ignoreRecommendations || config.showRecommendationsOnlyOnDemand) {\n                    return;\n                }\n                const importantRecommendationsIgnoreList = JSON.parse(this.storageService.get('extensionsAssistant/importantRecommendationsIgnore', storage_1.StorageScope.GLOBAL, '[]'));\n                recommendationsToSuggest = recommendationsToSuggest.filter(id => importantRecommendationsIgnoreList.indexOf(id) === -1 && this.isExtensionAllowedToBeRecommended(id));\n                const importantTipsPromise = recommendationsToSuggest.length === 0 ? Promise.resolve(null) : this.extensionWorkbenchService.queryLocal().then(local => {\n                    const localExtensions = local.map(e => e.identifier);\n                    recommendationsToSuggest = recommendationsToSuggest.filter(id => localExtensions.every(local => !extensionManagementUtil_1.areSameExtensions(local, { id })));\n                    if (!recommendationsToSuggest.length) {\n                        return;\n                    }\n                    const id = recommendationsToSuggest[0];\n                    const entry = caseInsensitiveGet(product_1.default.extensionImportantTips, id);\n                    if (!entry) {\n                        return;\n                    }\n                    const name = entry['name'];\n                    // Indicates we have a suggested extension via the whitelist\n                    hasSuggestion = true;\n                    let message = nls_1.localize('reallyRecommended2', \"The '{0}' extension is recommended for this file type.\", name);\n                    // Temporary fix for the only extension pack we recommend. See https://github.com/Microsoft/vscode/issues/35364\n                    if (id === 'vscjava.vscode-java-pack') {\n                        message = nls_1.localize('reallyRecommendedExtensionPack', \"The '{0}' extension pack is recommended for this file type.\", name);\n                    }\n                    const setIgnoreRecommendationsConfig = (configVal) => {\n                        this.configurationService.updateValue('extensions.ignoreRecommendations', configVal, configuration_1.ConfigurationTarget.USER);\n                        if (configVal) {\n                            const ignoreWorkspaceRecommendationsStorageKey = 'extensionsAssistant/workspaceRecommendationsIgnore';\n                            this.storageService.store(ignoreWorkspaceRecommendationsStorageKey, true, storage_1.StorageScope.WORKSPACE);\n                        }\n                    };\n                    this.notificationService.prompt(severity_1.default.Info, message, [{\n                            label: nls_1.localize('install', 'Install'),\n                            run: () => {\n                                /* __GDPR__\n                                \"extensionRecommendations:popup\" : {\n                                    \"userReaction\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                                    \"extensionId\": { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" }\n                                }\n                                */\n                                this.telemetryService.publicLog('extensionRecommendations:popup', { userReaction: 'install', extensionId: name });\n                                this.instantiationService.createInstance(extensionsActions_1.InstallRecommendedExtensionAction, id).run();\n                            }\n                        }, {\n                            label: nls_1.localize('showRecommendations', \"Show Recommendations\"),\n                            run: () => {\n                                /* __GDPR__\n                                    \"extensionRecommendations:popup\" : {\n                                        \"userReaction\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                                        \"extensionId\": { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" }\n                                    }\n                                */\n                                this.telemetryService.publicLog('extensionRecommendations:popup', { userReaction: 'show', extensionId: name });\n                                const recommendationsAction = this.instantiationService.createInstance(extensionsActions_1.ShowRecommendedExtensionsAction, extensionsActions_1.ShowRecommendedExtensionsAction.ID, nls_1.localize('showRecommendations', \"Show Recommendations\"));\n                                recommendationsAction.run();\n                                recommendationsAction.dispose();\n                            }\n                        }, {\n                            label: choiceNever,\n                            isSecondary: true,\n                            run: () => {\n                                importantRecommendationsIgnoreList.push(id);\n                                this.storageService.store('extensionsAssistant/importantRecommendationsIgnore', JSON.stringify(importantRecommendationsIgnoreList), storage_1.StorageScope.GLOBAL);\n                                /* __GDPR__\n                                    \"extensionRecommendations:popup\" : {\n                                        \"userReaction\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                                        \"extensionId\": { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" }\n                                    }\n                                */\n                                this.telemetryService.publicLog('extensionRecommendations:popup', { userReaction: 'neverShowAgain', extensionId: name });\n                                this.notificationService.prompt(severity_1.default.Info, nls_1.localize('ignoreExtensionRecommendations', \"Do you want to ignore all extension recommendations?\"), [{\n                                        label: nls_1.localize('ignoreAll', \"Yes, Ignore All\"),\n                                        run: () => setIgnoreRecommendationsConfig(true)\n                                    }, {\n                                        label: nls_1.localize('no', \"No\"),\n                                        run: () => setIgnoreRecommendationsConfig(false)\n                                    }]);\n                            }\n                        }], {\n                        sticky: true,\n                        onCancel: () => {\n                            /* __GDPR__\n                                \"extensionRecommendations:popup\" : {\n                                    \"userReaction\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                                    \"extensionId\": { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" }\n                                }\n                            */\n                            this.telemetryService.publicLog('extensionRecommendations:popup', { userReaction: 'cancelled', extensionId: name });\n                        }\n                    });\n                });\n                const mimeTypesPromise = this.extensionService.whenInstalledExtensionsRegistered()\n                    .then(() => {\n                    return mime_1.guessMimeTypes(uri.fsPath);\n                });\n                Promise.all([importantTipsPromise, mimeTypesPromise]).then(result => {\n                    const fileExtensionSuggestionIgnoreList = JSON.parse(this.storageService.get('extensionsAssistant/fileExtensionsSuggestionIgnore', storage_1.StorageScope.GLOBAL, '[]'));\n                    const mimeTypes = result[1];\n                    if (fileExtension) {\n                        fileExtension = fileExtension.substr(1); // Strip the dot\n                    }\n                    if (hasSuggestion ||\n                        !fileExtension ||\n                        mimeTypes.length !== 1 ||\n                        mimeTypes[0] !== mime_1.MIME_UNKNOWN ||\n                        fileExtensionSuggestionIgnoreList.indexOf(fileExtension) > -1) {\n                        return;\n                    }\n                    const lookup = product_1.default.extensionKeywords || {};\n                    const keywords = lookup[fileExtension] || [];\n                    this._galleryService.query({ text: `tag:\"__ext_${fileExtension}\" ${keywords.map(tag => `tag:\"${tag}\"`)}` }, cancellation_1.CancellationToken.None).then(pager => {\n                        if (!pager || !pager.firstPage || !pager.firstPage.length) {\n                            return;\n                        }\n                        this.notificationService.prompt(severity_1.default.Info, nls_1.localize('showLanguageExtensions', \"The Marketplace has extensions that can help with '.{0}' files\", fileExtension), [{\n                                label: searchMarketplace,\n                                run: () => {\n                                    /* __GDPR__\n                                        \"fileExtensionSuggestion:popup\" : {\n                                            \"userReaction\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                                            \"fileExtension\": { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" }\n                                        }\n                                    */\n                                    this.telemetryService.publicLog('fileExtensionSuggestion:popup', { userReaction: 'ok', fileExtension: fileExtension });\n                                    this.viewletService.openViewlet('workbench.view.extensions', true)\n                                        .then(viewlet => viewlet)\n                                        .then(viewlet => {\n                                        viewlet.search(`ext:${fileExtension}`);\n                                        viewlet.focus();\n                                    });\n                                }\n                            }, {\n                                label: nls_1.localize('dontShowAgainExtension', \"Don't Show Again for '.{0}' files\", fileExtension),\n                                run: () => {\n                                    fileExtensionSuggestionIgnoreList.push(fileExtension);\n                                    this.storageService.store('extensionsAssistant/fileExtensionsSuggestionIgnore', JSON.stringify(fileExtensionSuggestionIgnoreList), storage_1.StorageScope.GLOBAL);\n                                    /* __GDPR__\n                                        \"fileExtensionSuggestion:popup\" : {\n                                            \"userReaction\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                                            \"fileExtension\": { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" }\n                                        }\n                                    */\n                                    this.telemetryService.publicLog('fileExtensionSuggestion:popup', { userReaction: 'neverShowAgain', fileExtension: fileExtension });\n                                }\n                            }], {\n                            sticky: true,\n                            onCancel: () => {\n                                /* __GDPR__\n                                    \"fileExtensionSuggestion:popup\" : {\n                                        \"userReaction\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                                        \"fileExtension\": { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" }\n                                    }\n                                */\n                                this.telemetryService.publicLog('fileExtensionSuggestion:popup', { userReaction: 'cancelled', fileExtension: fileExtension });\n                            }\n                        });\n                    });\n                });\n            });\n        }\n        //#endregion\n        //#region otherRecommendations\n        getOtherRecommendations() {\n            return this.fetchProactiveRecommendations().then(() => {\n                const others = arrays_1.distinct([\n                    ...Object.keys(this._exeBasedRecommendations),\n                    ...this._dynamicWorkspaceRecommendations,\n                    ...Object.keys(this._experimentalRecommendations),\n                ]).filter(extensionId => this.isExtensionAllowedToBeRecommended(extensionId));\n                arrays_1.shuffle(others, this.sessionSeed);\n                return others.map(extensionId => {\n                    const sources = [];\n                    if (this._exeBasedRecommendations[extensionId]) {\n                        sources.push('executable');\n                    }\n                    if (this._dynamicWorkspaceRecommendations.indexOf(extensionId) !== -1) {\n                        sources.push('dynamic');\n                    }\n                    return { extensionId, sources };\n                });\n            });\n        }\n        fetchProactiveRecommendations(calledDuringStartup) {\n            let fetchPromise = Promise.resolve(undefined);\n            if (!this.proactiveRecommendationsFetched) {\n                this.proactiveRecommendationsFetched = true;\n                // Executable based recommendations carry out a lot of file stats, so run them after 10 secs\n                // So that the startup is not affected\n                fetchPromise = new Promise((c, e) => {\n                    setTimeout(() => {\n                        Promise.all([this.fetchExecutableRecommendations(), this.fetchDynamicWorkspaceRecommendations()]).then(() => c(undefined));\n                    }, calledDuringStartup ? 10000 : 0);\n                });\n            }\n            return fetchPromise;\n        }\n        /**\n         * If user has any of the tools listed in product.exeBasedExtensionTips, fetch corresponding recommendations\n         */\n        fetchExecutableRecommendations() {\n            const homeDir = os.homedir();\n            let foundExecutables = new Set();\n            let findExecutable = (exeName, path) => {\n                return pfs.fileExists(path).then(exists => {\n                    if (exists && !foundExecutables.has(exeName)) {\n                        foundExecutables.add(exeName);\n                        (product_1.default.exeBasedExtensionTips[exeName]['recommendations'] || [])\n                            .forEach(extensionId => {\n                            if (product_1.default.exeBasedExtensionTips[exeName]['friendlyName']) {\n                                this._exeBasedRecommendations[extensionId.toLowerCase()] = product_1.default.exeBasedExtensionTips[exeName]['friendlyName'];\n                            }\n                        });\n                    }\n                });\n            };\n            let promises = [];\n            // Loop through recommended extensions\n            collections_1.forEach(product_1.default.exeBasedExtensionTips, entry => {\n                if (typeof entry.value !== 'object' || !Array.isArray(entry.value['recommendations'])) {\n                    return;\n                }\n                let exeName = entry.key;\n                if (process.platform === 'win32') {\n                    let windowsPath = entry.value['windowsPath'];\n                    if (!windowsPath || typeof windowsPath !== 'string') {\n                        return;\n                    }\n                    windowsPath = windowsPath.replace('%USERPROFILE%', process.env['USERPROFILE'])\n                        .replace('%ProgramFiles(x86)%', process.env['ProgramFiles(x86)'])\n                        .replace('%ProgramFiles%', process.env['ProgramFiles'])\n                        .replace('%APPDATA%', process.env['APPDATA']);\n                    promises.push(findExecutable(exeName, windowsPath));\n                }\n                else {\n                    promises.push(findExecutable(exeName, path_1.join('/usr/local/bin', exeName)));\n                    promises.push(findExecutable(exeName, path_1.join(homeDir, exeName)));\n                }\n            });\n            return Promise.all(promises).then(() => undefined);\n        }\n        /**\n         * Fetch extensions used by others on the same workspace as recommendations from cache\n         */\n        fetchCachedDynamicWorkspaceRecommendations() {\n            if (this.contextService.getWorkbenchState() !== workspace_1.WorkbenchState.FOLDER) {\n                return;\n            }\n            const storageKey = 'extensionsAssistant/dynamicWorkspaceRecommendations';\n            let storedRecommendationsJson = {};\n            try {\n                storedRecommendationsJson = JSON.parse(this.storageService.get(storageKey, storage_1.StorageScope.WORKSPACE, '{}'));\n            }\n            catch (e) {\n                this.storageService.remove(storageKey, storage_1.StorageScope.WORKSPACE);\n            }\n            if (Array.isArray(storedRecommendationsJson['recommendations'])\n                && types_1.isNumber(storedRecommendationsJson['timestamp'])\n                && storedRecommendationsJson['timestamp'] > 0\n                && (Date.now() - storedRecommendationsJson['timestamp']) / milliSecondsInADay < 14) {\n                this._dynamicWorkspaceRecommendations = storedRecommendationsJson['recommendations'];\n                /* __GDPR__\n                    \"dynamicWorkspaceRecommendations\" : {\n                        \"count\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                        \"cache\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n                    }\n                */\n                this.telemetryService.publicLog('dynamicWorkspaceRecommendations', { count: this._dynamicWorkspaceRecommendations.length, cache: 1 });\n            }\n        }\n        /**\n         * Fetch extensions used by others on the same workspace as recommendations from recommendation service\n         */\n        fetchDynamicWorkspaceRecommendations() {\n            if (this.contextService.getWorkbenchState() !== workspace_1.WorkbenchState.FOLDER\n                || !this.fileService.canHandleResource(this.contextService.getWorkspace().folders[0].uri)\n                || this._dynamicWorkspaceRecommendations.length\n                || !this._extensionsRecommendationsUrl) {\n                return Promise.resolve(undefined);\n            }\n            const storageKey = 'extensionsAssistant/dynamicWorkspaceRecommendations';\n            const workspaceUri = this.contextService.getWorkspace().folders[0].uri;\n            return Promise.all([workspaceStats_1.getHashedRemotesFromUri(workspaceUri, this.fileService, false), workspaceStats_1.getHashedRemotesFromUri(workspaceUri, this.fileService, true)]).then(([hashedRemotes1, hashedRemotes2]) => {\n                const hashedRemotes = (hashedRemotes1 || []).concat(hashedRemotes2 || []);\n                if (!hashedRemotes.length) {\n                    return undefined;\n                }\n                return this.requestService.request({ type: 'GET', url: this._extensionsRecommendationsUrl }, cancellation_1.CancellationToken.None).then(context => {\n                    if (context.res.statusCode !== 200) {\n                        return Promise.resolve(undefined);\n                    }\n                    return request_2.asJson(context).then((result) => {\n                        if (!result) {\n                            return;\n                        }\n                        const allRecommendations = Array.isArray(result['workspaceRecommendations']) ? result['workspaceRecommendations'] : [];\n                        if (!allRecommendations.length) {\n                            return;\n                        }\n                        let foundRemote = false;\n                        for (let i = 0; i < hashedRemotes.length && !foundRemote; i++) {\n                            for (let j = 0; j < allRecommendations.length && !foundRemote; j++) {\n                                if (Array.isArray(allRecommendations[j].remoteSet) && allRecommendations[j].remoteSet.indexOf(hashedRemotes[i]) > -1) {\n                                    foundRemote = true;\n                                    this._dynamicWorkspaceRecommendations = allRecommendations[j].recommendations.filter(id => this.isExtensionAllowedToBeRecommended(id)) || [];\n                                    this.storageService.store(storageKey, JSON.stringify({\n                                        recommendations: this._dynamicWorkspaceRecommendations,\n                                        timestamp: Date.now()\n                                    }), storage_1.StorageScope.WORKSPACE);\n                                    /* __GDPR__\n                                        \"dynamicWorkspaceRecommendations\" : {\n                                            \"count\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                                            \"cache\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                                        }\n                                    */\n                                    this.telemetryService.publicLog('dynamicWorkspaceRecommendations', { count: this._dynamicWorkspaceRecommendations.length, cache: 0 });\n                                }\n                            }\n                        }\n                    });\n                });\n            });\n        }\n        /**\n         * Fetch extension recommendations from currently running experiments\n         */\n        fetchExperimentalRecommendations() {\n            this.experimentService.getExperimentsByType(experimentService_1.ExperimentActionType.AddToRecommendations).then(experiments => {\n                (experiments || []).forEach(experiment => {\n                    const action = experiment.action;\n                    if (action && experiment.state === experimentService_1.ExperimentState.Run && action.properties && Array.isArray(action.properties.recommendations) && action.properties.recommendationReason) {\n                        action.properties.recommendations.forEach((id) => {\n                            this._experimentalRecommendations[id] = action.properties.recommendationReason;\n                        });\n                    }\n                });\n            });\n        }\n        //#endregion\n        isExtensionAllowedToBeRecommended(id) {\n            return this._allIgnoredRecommendations.indexOf(id.toLowerCase()) === -1;\n        }\n        dispose() {\n            this._disposables = lifecycle_1.dispose(this._disposables);\n        }\n    };\n    ExtensionTipsService = __decorate([\n        __param(0, extensionManagement_1.IExtensionGalleryService),\n        __param(1, modelService_1.IModelService),\n        __param(2, storage_1.IStorageService),\n        __param(3, extensionManagement_1.IExtensionManagementService),\n        __param(4, instantiation_1.IInstantiationService),\n        __param(5, files_1.IFileService),\n        __param(6, workspace_1.IWorkspaceContextService),\n        __param(7, configuration_1.IConfigurationService),\n        __param(8, telemetry_1.ITelemetryService),\n        __param(9, environment_1.IEnvironmentService),\n        __param(10, extensions_2.IExtensionService),\n        __param(11, request_1.IRequestService),\n        __param(12, viewlet_1.IViewletService),\n        __param(13, notification_1.INotificationService),\n        __param(14, extensionManagement_1.IExtensionManagementService),\n        __param(15, extensions_1.IExtensionsWorkbenchService),\n        __param(16, experimentService_1.IExperimentService)\n    ], ExtensionTipsService);\n    exports.ExtensionTipsService = ExtensionTipsService;\n});\n",null]}