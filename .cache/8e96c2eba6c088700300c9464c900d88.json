{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/linesOperations/moveLinesCommand.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/linesOperations/moveLinesCommand.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/strings\", \"vs/editor/common/commands/shiftCommand\", \"vs/editor/common/core/range\", \"vs/editor/common/core/selection\", \"vs/editor/common/modes/languageConfiguration\", \"vs/editor/common/modes/languageConfigurationRegistry\", \"vs/editor/common/modes/supports/indentRules\", \"vs/editor/contrib/indentation/indentUtils\"], function (require, exports, strings, shiftCommand_1, range_1, selection_1, languageConfiguration_1, languageConfigurationRegistry_1, indentRules_1, indentUtils) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class MoveLinesCommand {\n        constructor(selection, isMovingDown, autoIndent) {\n            this._selection = selection;\n            this._isMovingDown = isMovingDown;\n            this._autoIndent = autoIndent;\n            this._moveEndLineSelectionShrink = false;\n        }\n        getEditOperations(model, builder) {\n            let modelLineCount = model.getLineCount();\n            if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {\n                return;\n            }\n            if (!this._isMovingDown && this._selection.startLineNumber === 1) {\n                return;\n            }\n            this._moveEndPositionDown = false;\n            let s = this._selection;\n            if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n                this._moveEndPositionDown = true;\n                s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n            }\n            const { tabSize, indentSize, insertSpaces } = model.getOptions();\n            let indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);\n            let virtualModel = {\n                getLineTokens: (lineNumber) => {\n                    return model.getLineTokens(lineNumber);\n                },\n                getLanguageIdentifier: () => {\n                    return model.getLanguageIdentifier();\n                },\n                getLanguageIdAtPosition: (lineNumber, column) => {\n                    return model.getLanguageIdAtPosition(lineNumber, column);\n                },\n                getLineContent: null,\n            };\n            if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {\n                // Current line is empty\n                let lineNumber = s.startLineNumber;\n                let otherLineNumber = (this._isMovingDown ? lineNumber + 1 : lineNumber - 1);\n                if (model.getLineMaxColumn(otherLineNumber) === 1) {\n                    // Other line number is empty too, so no editing is needed\n                    // Add a no-op to force running by the model\n                    builder.addEditOperation(new range_1.Range(1, 1, 1, 1), null);\n                }\n                else {\n                    // Type content from other line number on line number\n                    builder.addEditOperation(new range_1.Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));\n                    // Remove content from other line number\n                    builder.addEditOperation(new range_1.Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);\n                }\n                // Track selection at the other line number\n                s = new selection_1.Selection(otherLineNumber, 1, otherLineNumber, 1);\n            }\n            else {\n                let movingLineNumber;\n                let movingLineText;\n                if (this._isMovingDown) {\n                    movingLineNumber = s.endLineNumber + 1;\n                    movingLineText = model.getLineContent(movingLineNumber);\n                    // Delete line that needs to be moved\n                    builder.addEditOperation(new range_1.Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);\n                    let insertingText = movingLineText;\n                    if (this.shouldAutoIndent(model, s)) {\n                        let movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);\n                        // if s.startLineNumber - 1 matches onEnter rule, we still honor that.\n                        if (movingLineMatchResult !== null) {\n                            let oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n                            let newSpaceCnt = movingLineMatchResult + indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                            let newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                            insertingText = newIndentation + this.trimLeft(movingLineText);\n                        }\n                        else {\n                            // no enter rule matches, let's check indentatin rules then.\n                            virtualModel.getLineContent = (lineNumber) => {\n                                if (lineNumber === s.startLineNumber) {\n                                    return model.getLineContent(movingLineNumber);\n                                }\n                                else {\n                                    return model.getLineContent(lineNumber);\n                                }\n                            };\n                            let indentOfMovingLine = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getGoodIndentForLine(virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter);\n                            if (indentOfMovingLine !== null) {\n                                let oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n                                let newSpaceCnt = indentUtils.getSpaceCnt(indentOfMovingLine, tabSize);\n                                let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                                if (newSpaceCnt !== oldSpaceCnt) {\n                                    let newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                                    insertingText = newIndentation + this.trimLeft(movingLineText);\n                                }\n                            }\n                        }\n                        // add edit operations for moving line first to make sure it's executed after we make indentation change\n                        // to s.startLineNumber\n                        builder.addEditOperation(new range_1.Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n                        let ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber, insertingText);\n                        // check if the line being moved before matches onEnter rules, if so let's adjust the indentation by onEnter rules.\n                        if (ret !== null) {\n                            if (ret !== 0) {\n                                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n                            }\n                        }\n                        else {\n                            // it doesn't match onEnter rules, let's check indentation rules then.\n                            virtualModel.getLineContent = (lineNumber) => {\n                                if (lineNumber === s.startLineNumber) {\n                                    return insertingText;\n                                }\n                                else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {\n                                    return model.getLineContent(lineNumber - 1);\n                                }\n                                else {\n                                    return model.getLineContent(lineNumber);\n                                }\n                            };\n                            let newIndentatOfMovingBlock = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getGoodIndentForLine(virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter);\n                            if (newIndentatOfMovingBlock !== null) {\n                                const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n                                const newSpaceCnt = indentUtils.getSpaceCnt(newIndentatOfMovingBlock, tabSize);\n                                const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                                if (newSpaceCnt !== oldSpaceCnt) {\n                                    const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                                    this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        // Insert line that needs to be moved before\n                        builder.addEditOperation(new range_1.Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n                    }\n                }\n                else {\n                    movingLineNumber = s.startLineNumber - 1;\n                    movingLineText = model.getLineContent(movingLineNumber);\n                    // Delete line that needs to be moved\n                    builder.addEditOperation(new range_1.Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);\n                    // Insert line that needs to be moved after\n                    builder.addEditOperation(new range_1.Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\\n' + movingLineText);\n                    if (this.shouldAutoIndent(model, s)) {\n                        virtualModel.getLineContent = (lineNumber) => {\n                            if (lineNumber === movingLineNumber) {\n                                return model.getLineContent(s.startLineNumber);\n                            }\n                            else {\n                                return model.getLineContent(lineNumber);\n                            }\n                        };\n                        let ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);\n                        // check if s.startLineNumber - 2 matches onEnter rules, if so adjust the moving block by onEnter rules.\n                        if (ret !== null) {\n                            if (ret !== 0) {\n                                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n                            }\n                        }\n                        else {\n                            // it doesn't match any onEnter rule, let's check indentation rules then.\n                            let indentOfFirstLine = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getGoodIndentForLine(virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter);\n                            if (indentOfFirstLine !== null) {\n                                // adjust the indentation of the moving block\n                                let oldIndent = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n                                let newSpaceCnt = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\n                                let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndent, tabSize);\n                                if (newSpaceCnt !== oldSpaceCnt) {\n                                    let spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                                    this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            this._selectionId = builder.trackSelection(s);\n        }\n        buildIndentConverter(tabSize, indentSize, insertSpaces) {\n            return {\n                shiftIndent: (indentation) => {\n                    return shiftCommand_1.ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n                },\n                unshiftIndent: (indentation) => {\n                    return shiftCommand_1.ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n                }\n            };\n        }\n        matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, oneLineAboveText) {\n            let validPrecedingLine = oneLineAbove;\n            while (validPrecedingLine >= 1) {\n                // ship empty lines as empty lines just inherit indentation\n                let lineContent;\n                if (validPrecedingLine === oneLineAbove && oneLineAboveText !== undefined) {\n                    lineContent = oneLineAboveText;\n                }\n                else {\n                    lineContent = model.getLineContent(validPrecedingLine);\n                }\n                let nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n                validPrecedingLine--;\n            }\n            if (validPrecedingLine < 1 || line > model.getLineCount()) {\n                return null;\n            }\n            let maxColumn = model.getLineMaxColumn(validPrecedingLine);\n            let enter = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getEnterAction(model, new range_1.Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn));\n            if (enter) {\n                let enterPrefix = enter.indentation;\n                let enterAction = enter.enterAction;\n                if (enterAction.indentAction === languageConfiguration_1.IndentAction.None) {\n                    enterPrefix = enter.indentation + enterAction.appendText;\n                }\n                else if (enterAction.indentAction === languageConfiguration_1.IndentAction.Indent) {\n                    enterPrefix = enter.indentation + enterAction.appendText;\n                }\n                else if (enterAction.indentAction === languageConfiguration_1.IndentAction.IndentOutdent) {\n                    enterPrefix = enter.indentation;\n                }\n                else if (enterAction.indentAction === languageConfiguration_1.IndentAction.Outdent) {\n                    enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enterAction.appendText;\n                }\n                let movingLineText = model.getLineContent(line);\n                if (this.trimLeft(movingLineText).indexOf(this.trimLeft(enterPrefix)) >= 0) {\n                    let oldIndentation = strings.getLeadingWhitespace(model.getLineContent(line));\n                    let newIndentation = strings.getLeadingWhitespace(enterPrefix);\n                    let indentMetadataOfMovelingLine = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getIndentMetadata(model, line);\n                    if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & indentRules_1.IndentConsts.DECREASE_MASK) {\n                        newIndentation = indentConverter.unshiftIndent(newIndentation);\n                    }\n                    let newSpaceCnt = indentUtils.getSpaceCnt(newIndentation, tabSize);\n                    let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                    return newSpaceCnt - oldSpaceCnt;\n                }\n            }\n            return null;\n        }\n        trimLeft(str) {\n            return str.replace(/^\\s+/, '');\n        }\n        shouldAutoIndent(model, selection) {\n            if (!this._autoIndent) {\n                return false;\n            }\n            // if it's not easy to tokenize, we stop auto indent.\n            if (!model.isCheapToTokenize(selection.startLineNumber)) {\n                return false;\n            }\n            let languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);\n            let languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);\n            if (languageAtSelectionStart !== languageAtSelectionEnd) {\n                return false;\n            }\n            if (languageConfigurationRegistry_1.LanguageConfigurationRegistry.getIndentRulesSupport(languageAtSelectionStart) === null) {\n                return false;\n            }\n            return true;\n        }\n        getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {\n            for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {\n                let lineContent = model.getLineContent(i);\n                let originalIndent = strings.getLeadingWhitespace(lineContent);\n                let originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\n                let newSpacesCnt = originalSpacesCnt + offset;\n                let newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\n                if (newIndent !== originalIndent) {\n                    builder.addEditOperation(new range_1.Range(i, 1, i, originalIndent.length + 1), newIndent);\n                    if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === '') {\n                        // as users select part of the original indent white spaces\n                        // when we adjust the indentation of endLine, we should adjust the cursor position as well.\n                        this._moveEndLineSelectionShrink = true;\n                    }\n                }\n            }\n        }\n        computeCursorState(model, helper) {\n            let result = helper.getTrackedSelection(this._selectionId);\n            if (this._moveEndPositionDown) {\n                result = result.setEndPosition(result.endLineNumber + 1, 1);\n            }\n            if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {\n                result = result.setEndPosition(result.endLineNumber, 2);\n            }\n            return result;\n        }\n    }\n    exports.MoveLinesCommand = MoveLinesCommand;\n});\n",null]}