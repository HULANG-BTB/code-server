{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/filters.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/filters.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/charCode\", \"vs/base/common/map\", \"vs/base/common/strings\"], function (require, exports, charCode_1, map_1, strings) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // Combined filters\n    /**\n     * @returns A filter which combines the provided set\n     * of filters with an or. The *first* filters that\n     * matches defined the return value of the returned\n     * filter.\n     */\n    function or(...filter) {\n        return function (word, wordToMatchAgainst) {\n            for (let i = 0, len = filter.length; i < len; i++) {\n                const match = filter[i](word, wordToMatchAgainst);\n                if (match) {\n                    return match;\n                }\n            }\n            return null;\n        };\n    }\n    exports.or = or;\n    // Prefix\n    exports.matchesStrictPrefix = _matchesPrefix.bind(undefined, false);\n    exports.matchesPrefix = _matchesPrefix.bind(undefined, true);\n    function _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n        if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n            return null;\n        }\n        let matches;\n        if (ignoreCase) {\n            matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n        }\n        else {\n            matches = wordToMatchAgainst.indexOf(word) === 0;\n        }\n        if (!matches) {\n            return null;\n        }\n        return word.length > 0 ? [{ start: 0, end: word.length }] : [];\n    }\n    // Contiguous Substring\n    function matchesContiguousSubString(word, wordToMatchAgainst) {\n        const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n        if (index === -1) {\n            return null;\n        }\n        return [{ start: index, end: index + word.length }];\n    }\n    exports.matchesContiguousSubString = matchesContiguousSubString;\n    // Substring\n    function matchesSubString(word, wordToMatchAgainst) {\n        return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n    }\n    exports.matchesSubString = matchesSubString;\n    function _matchesSubString(word, wordToMatchAgainst, i, j) {\n        if (i === word.length) {\n            return [];\n        }\n        else if (j === wordToMatchAgainst.length) {\n            return null;\n        }\n        else {\n            if (word[i] === wordToMatchAgainst[j]) {\n                let result = null;\n                if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n                    return join({ start: j, end: j + 1 }, result);\n                }\n                return null;\n            }\n            return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n        }\n    }\n    // CamelCase\n    function isLower(code) {\n        return charCode_1.CharCode.a <= code && code <= charCode_1.CharCode.z;\n    }\n    function isUpper(code) {\n        return charCode_1.CharCode.A <= code && code <= charCode_1.CharCode.Z;\n    }\n    exports.isUpper = isUpper;\n    function isNumber(code) {\n        return charCode_1.CharCode.Digit0 <= code && code <= charCode_1.CharCode.Digit9;\n    }\n    function isWhitespace(code) {\n        return (code === charCode_1.CharCode.Space\n            || code === charCode_1.CharCode.Tab\n            || code === charCode_1.CharCode.LineFeed\n            || code === charCode_1.CharCode.CarriageReturn);\n    }\n    const wordSeparators = new Set();\n    '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?'\n        .split('')\n        .forEach(s => wordSeparators.add(s.charCodeAt(0)));\n    function isWordSeparator(code) {\n        return wordSeparators.has(code);\n    }\n    function isAlphanumeric(code) {\n        return isLower(code) || isUpper(code) || isNumber(code);\n    }\n    function join(head, tail) {\n        if (tail.length === 0) {\n            tail = [head];\n        }\n        else if (head.end === tail[0].start) {\n            tail[0].start = head.start;\n        }\n        else {\n            tail.unshift(head);\n        }\n        return tail;\n    }\n    function nextAnchor(camelCaseWord, start) {\n        for (let i = start; i < camelCaseWord.length; i++) {\n            const c = camelCaseWord.charCodeAt(i);\n            if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\n                return i;\n            }\n        }\n        return camelCaseWord.length;\n    }\n    function _matchesCamelCase(word, camelCaseWord, i, j) {\n        if (i === word.length) {\n            return [];\n        }\n        else if (j === camelCaseWord.length) {\n            return null;\n        }\n        else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n            return null;\n        }\n        else {\n            let result = null;\n            let nextUpperIndex = j + 1;\n            result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n            while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n                result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n                nextUpperIndex++;\n            }\n            return result === null ? null : join({ start: j, end: j + 1 }, result);\n        }\n    }\n    // Heuristic to avoid computing camel case matcher for words that don't\n    // look like camelCaseWords.\n    function analyzeCamelCaseWord(word) {\n        let upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\n        for (let i = 0; i < word.length; i++) {\n            code = word.charCodeAt(i);\n            if (isUpper(code)) {\n                upper++;\n            }\n            if (isLower(code)) {\n                lower++;\n            }\n            if (isAlphanumeric(code)) {\n                alpha++;\n            }\n            if (isNumber(code)) {\n                numeric++;\n            }\n        }\n        const upperPercent = upper / word.length;\n        const lowerPercent = lower / word.length;\n        const alphaPercent = alpha / word.length;\n        const numericPercent = numeric / word.length;\n        return { upperPercent, lowerPercent, alphaPercent, numericPercent };\n    }\n    function isUpperCaseWord(analysis) {\n        const { upperPercent, lowerPercent } = analysis;\n        return lowerPercent === 0 && upperPercent > 0.6;\n    }\n    function isCamelCaseWord(analysis) {\n        const { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;\n        return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n    }\n    // Heuristic to avoid computing camel case matcher for words that don't\n    // look like camel case patterns.\n    function isCamelCasePattern(word) {\n        let upper = 0, lower = 0, code = 0, whitespace = 0;\n        for (let i = 0; i < word.length; i++) {\n            code = word.charCodeAt(i);\n            if (isUpper(code)) {\n                upper++;\n            }\n            if (isLower(code)) {\n                lower++;\n            }\n            if (isWhitespace(code)) {\n                whitespace++;\n            }\n        }\n        if ((upper === 0 || lower === 0) && whitespace === 0) {\n            return word.length <= 30;\n        }\n        else {\n            return upper <= 5;\n        }\n    }\n    function matchesCamelCase(word, camelCaseWord) {\n        if (!camelCaseWord) {\n            return null;\n        }\n        camelCaseWord = camelCaseWord.trim();\n        if (camelCaseWord.length === 0) {\n            return null;\n        }\n        if (!isCamelCasePattern(word)) {\n            return null;\n        }\n        if (camelCaseWord.length > 60) {\n            return null;\n        }\n        const analysis = analyzeCamelCaseWord(camelCaseWord);\n        if (!isCamelCaseWord(analysis)) {\n            if (!isUpperCaseWord(analysis)) {\n                return null;\n            }\n            camelCaseWord = camelCaseWord.toLowerCase();\n        }\n        let result = null;\n        let i = 0;\n        word = word.toLowerCase();\n        while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n            i = nextAnchor(camelCaseWord, i + 1);\n        }\n        return result;\n    }\n    exports.matchesCamelCase = matchesCamelCase;\n    // Matches beginning of words supporting non-ASCII languages\n    // If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n    // Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n    // Useful in cases where the target is words (e.g. command labels)\n    function matchesWords(word, target, contiguous = false) {\n        if (!target || target.length === 0) {\n            return null;\n        }\n        let result = null;\n        let i = 0;\n        word = word.toLowerCase();\n        target = target.toLowerCase();\n        while (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {\n            i = nextWord(target, i + 1);\n        }\n        return result;\n    }\n    exports.matchesWords = matchesWords;\n    function _matchesWords(word, target, i, j, contiguous) {\n        if (i === word.length) {\n            return [];\n        }\n        else if (j === target.length) {\n            return null;\n        }\n        else if (word[i] !== target[j]) {\n            return null;\n        }\n        else {\n            let result = null;\n            let nextWordIndex = j + 1;\n            result = _matchesWords(word, target, i + 1, j + 1, contiguous);\n            if (!contiguous) {\n                while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n                    result = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);\n                    nextWordIndex++;\n                }\n            }\n            return result === null ? null : join({ start: j, end: j + 1 }, result);\n        }\n    }\n    function nextWord(word, start) {\n        for (let i = start; i < word.length; i++) {\n            const c = word.charCodeAt(i);\n            if (isWhitespace(c) || (i > 0 && isWhitespace(word.charCodeAt(i - 1))) ||\n                isWordSeparator(c) || (i > 0 && isWordSeparator(word.charCodeAt(i - 1)))) {\n                return i;\n            }\n        }\n        return word.length;\n    }\n    // Fuzzy\n    const fuzzyContiguousFilter = or(exports.matchesPrefix, matchesCamelCase, matchesContiguousSubString);\n    const fuzzySeparateFilter = or(exports.matchesPrefix, matchesCamelCase, matchesSubString);\n    const fuzzyRegExpCache = new map_1.LRUCache(10000); // bounded to 10000 elements\n    function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {\n        if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n            return null; // return early for invalid input\n        }\n        // Form RegExp for wildcard matches\n        let regexp = fuzzyRegExpCache.get(word);\n        if (!regexp) {\n            regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n            fuzzyRegExpCache.set(word, regexp);\n        }\n        // RegExp Filter\n        const match = regexp.exec(wordToMatchAgainst);\n        if (match) {\n            return [{ start: match.index, end: match.index + match[0].length }];\n        }\n        // Default Filter\n        return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n    }\n    exports.matchesFuzzy = matchesFuzzy;\n    /**\n     * Match pattern againt word in a fuzzy way. As in IntelliSense and faster and more\n     * powerfull than `matchesFuzzy`\n     */\n    function matchesFuzzy2(pattern, word) {\n        const score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, true);\n        return score ? createMatches(score) : null;\n    }\n    exports.matchesFuzzy2 = matchesFuzzy2;\n    function anyScore(pattern, lowPattern, _patternPos, word, lowWord, _wordPos) {\n        const result = fuzzyScore(pattern, lowPattern, 0, word, lowWord, 0, true);\n        if (result) {\n            return result;\n        }\n        let matches = 0;\n        let score = 0;\n        let idx = _wordPos;\n        for (let patternPos = 0; patternPos < lowPattern.length && patternPos < _maxLen; ++patternPos) {\n            const wordPos = lowWord.indexOf(lowPattern.charAt(patternPos), idx);\n            if (wordPos >= 0) {\n                score += 1;\n                matches += Math.pow(2, wordPos);\n                idx = wordPos + 1;\n            }\n        }\n        return [score, matches, _wordPos];\n    }\n    exports.anyScore = anyScore;\n    //#region --- fuzzyScore ---\n    function createMatches(score) {\n        if (typeof score === 'undefined') {\n            return [];\n        }\n        const matches = score[1].toString(2);\n        const wordStart = score[2];\n        const res = [];\n        for (let pos = wordStart; pos < _maxLen; pos++) {\n            if (matches[matches.length - (pos + 1)] === '1') {\n                const last = res[res.length - 1];\n                if (last && last.end === pos) {\n                    last.end = pos + 1;\n                }\n                else {\n                    res.push({ start: pos, end: pos + 1 });\n                }\n            }\n        }\n        return res;\n    }\n    exports.createMatches = createMatches;\n    const _maxLen = 53;\n    function initTable() {\n        const table = [];\n        const row = [0];\n        for (let i = 1; i <= _maxLen; i++) {\n            row.push(-i);\n        }\n        for (let i = 0; i <= _maxLen; i++) {\n            const thisRow = row.slice(0);\n            thisRow[0] = -i;\n            table.push(thisRow);\n        }\n        return table;\n    }\n    const _table = initTable();\n    const _scores = initTable();\n    const _arrows = initTable();\n    const _debug = false;\n    function printTable(table, pattern, patternLen, word, wordLen) {\n        function pad(s, n, pad = ' ') {\n            while (s.length < n) {\n                s = pad + s;\n            }\n            return s;\n        }\n        let ret = ` |   |${word.split('').map(c => pad(c, 3)).join('|')}\\n`;\n        for (let i = 0; i <= patternLen; i++) {\n            if (i === 0) {\n                ret += ' |';\n            }\n            else {\n                ret += `${pattern[i - 1]}|`;\n            }\n            ret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\\n';\n        }\n        return ret;\n    }\n    function isSeparatorAtPos(value, index) {\n        if (index < 0 || index >= value.length) {\n            return false;\n        }\n        const code = value.charCodeAt(index);\n        switch (code) {\n            case charCode_1.CharCode.Underline:\n            case charCode_1.CharCode.Dash:\n            case charCode_1.CharCode.Period:\n            case charCode_1.CharCode.Space:\n            case charCode_1.CharCode.Slash:\n            case charCode_1.CharCode.Backslash:\n            case charCode_1.CharCode.SingleQuote:\n            case charCode_1.CharCode.DoubleQuote:\n            case charCode_1.CharCode.Colon:\n            case charCode_1.CharCode.DollarSign:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function isWhitespaceAtPos(value, index) {\n        if (index < 0 || index >= value.length) {\n            return false;\n        }\n        const code = value.charCodeAt(index);\n        switch (code) {\n            case charCode_1.CharCode.Space:\n            case charCode_1.CharCode.Tab:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function isUpperCaseAtPos(pos, word, wordLow) {\n        return word[pos] !== wordLow[pos];\n    }\n    function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen) {\n        while (patternPos < patternLen && wordPos < wordLen) {\n            if (patternLow[patternPos] === wordLow[wordPos]) {\n                patternPos += 1;\n            }\n            wordPos += 1;\n        }\n        return patternPos === patternLen; // pattern must be exhausted\n    }\n    var Arrow;\n    (function (Arrow) {\n        Arrow[Arrow[\"Top\"] = 1] = \"Top\";\n        Arrow[Arrow[\"Diag\"] = 2] = \"Diag\";\n        Arrow[Arrow[\"Left\"] = 4] = \"Left\";\n    })(Arrow || (Arrow = {}));\n    var FuzzyScore;\n    (function (FuzzyScore) {\n        /**\n         * No matches and value `-100`\n         */\n        FuzzyScore.Default = [-100, 0, 0];\n        function isDefault(score) {\n            return !score || (score[0] === -100 && score[1] === 0 && score[2] === 0);\n        }\n        FuzzyScore.isDefault = isDefault;\n    })(FuzzyScore = exports.FuzzyScore || (exports.FuzzyScore = {}));\n    function fuzzyScore(pattern, patternLow, patternPos, word, wordLow, wordPos, firstMatchCanBeWeak) {\n        const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n        const wordLen = word.length > _maxLen ? _maxLen : word.length;\n        if (patternPos >= patternLen || wordPos >= wordLen || patternLen > wordLen) {\n            return undefined;\n        }\n        // Run a simple check if the characters of pattern occur\n        // (in order) at all in word. If that isn't the case we\n        // stop because no match will be possible\n        if (!isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen)) {\n            return undefined;\n        }\n        const patternStartPos = patternPos;\n        const wordStartPos = wordPos;\n        // There will be a mach, fill in tables\n        for (patternPos = patternStartPos + 1; patternPos <= patternLen; patternPos++) {\n            for (wordPos = 1; wordPos <= wordLen; wordPos++) {\n                let score = -1;\n                if (patternLow[patternPos - 1] === wordLow[wordPos - 1]) {\n                    if (wordPos === (patternPos - patternStartPos)) {\n                        // common prefix: `foobar <-> foobaz`\n                        //                            ^^^^^\n                        if (pattern[patternPos - 1] === word[wordPos - 1]) {\n                            score = 7;\n                        }\n                        else {\n                            score = 5;\n                        }\n                    }\n                    else if (isUpperCaseAtPos(wordPos - 1, word, wordLow) && (wordPos === 1 || !isUpperCaseAtPos(wordPos - 2, word, wordLow))) {\n                        // hitting upper-case: `foo <-> forOthers`\n                        //                              ^^ ^\n                        if (pattern[patternPos - 1] === word[wordPos - 1]) {\n                            score = 7;\n                        }\n                        else {\n                            score = 5;\n                        }\n                    }\n                    else if (isSeparatorAtPos(wordLow, wordPos - 2) || isWhitespaceAtPos(wordLow, wordPos - 2)) {\n                        // post separator: `foo <-> bar_foo`\n                        //                              ^^^\n                        score = 5;\n                    }\n                    else {\n                        score = 1;\n                    }\n                }\n                _scores[patternPos][wordPos] = score;\n                const diag = _table[patternPos - 1][wordPos - 1] + (score > 1 ? 1 : score);\n                const top = _table[patternPos - 1][wordPos] + -1;\n                const left = _table[patternPos][wordPos - 1] + -1;\n                if (left >= top) {\n                    // left or diag\n                    if (left > diag) {\n                        _table[patternPos][wordPos] = left;\n                        _arrows[patternPos][wordPos] = Arrow.Left;\n                    }\n                    else if (left === diag) {\n                        _table[patternPos][wordPos] = left;\n                        _arrows[patternPos][wordPos] = Arrow.Left | Arrow.Diag;\n                    }\n                    else {\n                        _table[patternPos][wordPos] = diag;\n                        _arrows[patternPos][wordPos] = Arrow.Diag;\n                    }\n                }\n                else {\n                    // top or diag\n                    if (top > diag) {\n                        _table[patternPos][wordPos] = top;\n                        _arrows[patternPos][wordPos] = Arrow.Top;\n                    }\n                    else if (top === diag) {\n                        _table[patternPos][wordPos] = top;\n                        _arrows[patternPos][wordPos] = Arrow.Top | Arrow.Diag;\n                    }\n                    else {\n                        _table[patternPos][wordPos] = diag;\n                        _arrows[patternPos][wordPos] = Arrow.Diag;\n                    }\n                }\n            }\n        }\n        if (_debug) {\n            console.log(printTable(_table, pattern, patternLen, word, wordLen));\n            console.log(printTable(_arrows, pattern, patternLen, word, wordLen));\n            console.log(printTable(_scores, pattern, patternLen, word, wordLen));\n        }\n        _matchesCount = 0;\n        _topScore = -100;\n        _patternStartPos = patternStartPos;\n        _firstMatchCanBeWeak = firstMatchCanBeWeak;\n        _findAllMatches2(patternLen, wordLen, patternLen === wordLen ? 1 : 0, 0, false);\n        if (_matchesCount === 0) {\n            return undefined;\n        }\n        return [_topScore, _topMatch2, wordStartPos];\n    }\n    exports.fuzzyScore = fuzzyScore;\n    let _matchesCount = 0;\n    let _topMatch2 = 0;\n    let _topScore = 0;\n    let _patternStartPos = 0;\n    let _firstMatchCanBeWeak = false;\n    function _findAllMatches2(patternPos, wordPos, total, matches, lastMatched) {\n        if (_matchesCount >= 10 || total < -25) {\n            // stop when having already 10 results, or\n            // when a potential alignment as already 5 gaps\n            return;\n        }\n        let simpleMatchCount = 0;\n        while (patternPos > _patternStartPos && wordPos > 0) {\n            const score = _scores[patternPos][wordPos];\n            const arrow = _arrows[patternPos][wordPos];\n            if (arrow === Arrow.Left) {\n                // left -> no match, skip a word character\n                wordPos -= 1;\n                if (lastMatched) {\n                    total -= 5; // new gap penalty\n                }\n                else if (matches !== 0) {\n                    total -= 1; // gap penalty after first match\n                }\n                lastMatched = false;\n                simpleMatchCount = 0;\n            }\n            else if (arrow & Arrow.Diag) {\n                if (arrow & Arrow.Left) {\n                    // left\n                    _findAllMatches2(patternPos, wordPos - 1, matches !== 0 ? total - 1 : total, // gap penalty after first match\n                    matches, lastMatched);\n                }\n                // diag\n                total += score;\n                patternPos -= 1;\n                wordPos -= 1;\n                lastMatched = true;\n                // match -> set a 1 at the word pos\n                matches += Math.pow(2, wordPos);\n                // count simple matches and boost a row of\n                // simple matches when they yield in a\n                // strong match.\n                if (score === 1) {\n                    simpleMatchCount += 1;\n                    if (patternPos === _patternStartPos && !_firstMatchCanBeWeak) {\n                        // when the first match is a weak\n                        // match we discard it\n                        return undefined;\n                    }\n                }\n                else {\n                    // boost\n                    total += 1 + (simpleMatchCount * (score - 1));\n                    simpleMatchCount = 0;\n                }\n            }\n            else {\n                return undefined;\n            }\n        }\n        total -= wordPos >= 3 ? 9 : wordPos * 3; // late start penalty\n        // dynamically keep track of the current top score\n        // and insert the current best score at head, the rest at tail\n        _matchesCount += 1;\n        if (total > _topScore) {\n            _topScore = total;\n            _topMatch2 = matches;\n        }\n    }\n    //#endregion\n    //#region --- graceful ---\n    function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {\n        return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);\n    }\n    exports.fuzzyScoreGracefulAggressive = fuzzyScoreGracefulAggressive;\n    function fuzzyScoreGraceful(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {\n        return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, false, firstMatchCanBeWeak);\n    }\n    exports.fuzzyScoreGraceful = fuzzyScoreGraceful;\n    function fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, firstMatchCanBeWeak) {\n        let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n        if (top && !aggressive) {\n            // when using the original pattern yield a result we`\n            // return it unless we are aggressive and try to find\n            // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n            return top;\n        }\n        if (pattern.length >= 3) {\n            // When the pattern is long enough then try a few (max 7)\n            // permutations of the pattern to find a better match. The\n            // permutations only swap neighbouring characters, e.g\n            // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n            const tries = Math.min(7, pattern.length - 1);\n            for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n                const newPattern = nextTypoPermutation(pattern, movingPatternPos);\n                if (newPattern) {\n                    const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n                    if (candidate) {\n                        candidate[0] -= 3; // permutation penalty\n                        if (!top || candidate[0] > top[0]) {\n                            top = candidate;\n                        }\n                    }\n                }\n            }\n        }\n        return top;\n    }\n    function nextTypoPermutation(pattern, patternPos) {\n        if (patternPos + 1 >= pattern.length) {\n            return undefined;\n        }\n        const swap1 = pattern[patternPos];\n        const swap2 = pattern[patternPos + 1];\n        if (swap1 === swap2) {\n            return undefined;\n        }\n        return pattern.slice(0, patternPos)\n            + swap2\n            + swap1\n            + pattern.slice(patternPos + 2);\n    }\n});\n//#endregion\n",null]}