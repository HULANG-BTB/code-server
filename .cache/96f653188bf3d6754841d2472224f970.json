{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostFileSystemEventService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostFileSystemEventService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/arrays\", \"vs/base/common/event\", \"vs/base/common/glob\", \"vs/base/common/uri\", \"../common/extHost.protocol\", \"./extHostTypeConverters\", \"./extHostTypes\"], function (require, exports, arrays_1, event_1, glob_1, uri_1, extHost_protocol_1, typeConverter, extHostTypes_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class FileSystemWatcher {\n        constructor(dispatcher, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {\n            this._onDidCreate = new event_1.Emitter();\n            this._onDidChange = new event_1.Emitter();\n            this._onDidDelete = new event_1.Emitter();\n            this._config = 0;\n            if (ignoreCreateEvents) {\n                this._config += 0b001;\n            }\n            if (ignoreChangeEvents) {\n                this._config += 0b010;\n            }\n            if (ignoreDeleteEvents) {\n                this._config += 0b100;\n            }\n            const parsedPattern = glob_1.parse(globPattern);\n            const subscription = dispatcher(events => {\n                if (!ignoreCreateEvents) {\n                    for (let created of events.created) {\n                        const uri = uri_1.URI.revive(created);\n                        if (parsedPattern(uri.fsPath)) {\n                            this._onDidCreate.fire(uri);\n                        }\n                    }\n                }\n                if (!ignoreChangeEvents) {\n                    for (let changed of events.changed) {\n                        const uri = uri_1.URI.revive(changed);\n                        if (parsedPattern(uri.fsPath)) {\n                            this._onDidChange.fire(uri);\n                        }\n                    }\n                }\n                if (!ignoreDeleteEvents) {\n                    for (let deleted of events.deleted) {\n                        const uri = uri_1.URI.revive(deleted);\n                        if (parsedPattern(uri.fsPath)) {\n                            this._onDidDelete.fire(uri);\n                        }\n                    }\n                }\n            });\n            this._disposable = extHostTypes_1.Disposable.from(this._onDidCreate, this._onDidChange, this._onDidDelete, subscription);\n        }\n        get ignoreCreateEvents() {\n            return Boolean(this._config & 0b001);\n        }\n        get ignoreChangeEvents() {\n            return Boolean(this._config & 0b010);\n        }\n        get ignoreDeleteEvents() {\n            return Boolean(this._config & 0b100);\n        }\n        dispose() {\n            this._disposable.dispose();\n        }\n        get onDidCreate() {\n            return this._onDidCreate.event;\n        }\n        get onDidChange() {\n            return this._onDidChange.event;\n        }\n        get onDidDelete() {\n            return this._onDidDelete.event;\n        }\n    }\n    class ExtHostFileSystemEventService {\n        constructor(mainContext, _extHostDocumentsAndEditors, _mainThreadTextEditors = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadTextEditors)) {\n            this._extHostDocumentsAndEditors = _extHostDocumentsAndEditors;\n            this._mainThreadTextEditors = _mainThreadTextEditors;\n            this._onFileEvent = new event_1.Emitter();\n            this._onDidRenameFile = new event_1.Emitter();\n            this._onWillRenameFile = new event_1.AsyncEmitter();\n            this.onDidRenameFile = this._onDidRenameFile.event;\n            //\n        }\n        createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {\n            return new FileSystemWatcher(this._onFileEvent.event, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents);\n        }\n        $onFileEvent(events) {\n            this._onFileEvent.fire(events);\n        }\n        $onFileRename(oldUri, newUri) {\n            this._onDidRenameFile.fire(Object.freeze({ oldUri: uri_1.URI.revive(oldUri), newUri: uri_1.URI.revive(newUri) }));\n        }\n        getOnWillRenameFileEvent(extension) {\n            return (listener, thisArg, disposables) => {\n                const wrappedListener = ((e) => {\n                    listener.call(thisArg, e);\n                });\n                wrappedListener.extension = extension;\n                return this._onWillRenameFile.event(wrappedListener, undefined, disposables);\n            };\n        }\n        $onWillRename(oldUriDto, newUriDto) {\n            const oldUri = uri_1.URI.revive(oldUriDto);\n            const newUri = uri_1.URI.revive(newUriDto);\n            const edits = [];\n            return Promise.resolve(this._onWillRenameFile.fireAsync((bucket, _listener) => {\n                return {\n                    oldUri,\n                    newUri,\n                    waitUntil: (thenable) => {\n                        if (Object.isFrozen(bucket)) {\n                            throw new TypeError('waitUntil cannot be called async');\n                        }\n                        const index = bucket.length;\n                        const wrappedThenable = Promise.resolve(thenable).then(result => {\n                            // ignore all results except for WorkspaceEdits. Those\n                            // are stored in a spare array\n                            if (result instanceof extHostTypes_1.WorkspaceEdit) {\n                                edits[index] = result;\n                            }\n                        });\n                        bucket.push(wrappedThenable);\n                    }\n                };\n            }).then(() => {\n                if (edits.length === 0) {\n                    return undefined;\n                }\n                // flatten all WorkspaceEdits collected via waitUntil-call\n                // and apply them in one go.\n                const allEdits = new Array();\n                for (let edit of edits) {\n                    if (edit) { // sparse array\n                        let { edits } = typeConverter.WorkspaceEdit.from(edit, this._extHostDocumentsAndEditors);\n                        allEdits.push(edits);\n                    }\n                }\n                return this._mainThreadTextEditors.$tryApplyWorkspaceEdit({ edits: arrays_1.flatten(allEdits) });\n            }));\n        }\n    }\n    exports.ExtHostFileSystemEventService = ExtHostFileSystemEventService;\n});\n",null]}