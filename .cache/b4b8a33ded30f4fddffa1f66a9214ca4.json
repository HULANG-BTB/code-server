{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/services/editorWorkerServiceImpl.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/services/editorWorkerServiceImpl.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/async\", \"vs/base/common/lifecycle\", \"vs/base/common/worker/simpleWorker\", \"vs/base/worker/defaultWorkerFactory\", \"vs/editor/common/modes\", \"vs/editor/common/modes/languageConfigurationRegistry\", \"vs/editor/common/services/editorSimpleWorker\", \"vs/editor/common/services/modelService\", \"vs/editor/common/services/resourceConfiguration\", \"vs/base/common/strings\", \"vs/base/common/arrays\"], function (require, exports, async_1, lifecycle_1, simpleWorker_1, defaultWorkerFactory_1, modes, languageConfigurationRegistry_1, editorSimpleWorker_1, modelService_1, resourceConfiguration_1, strings_1, arrays_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Stop syncing a model to the worker if it was not needed for 1 min.\n     */\n    const STOP_SYNC_MODEL_DELTA_TIME_MS = 60 * 1000;\n    /**\n     * Stop the worker if it was not needed for 5 min.\n     */\n    const STOP_WORKER_DELTA_TIME_MS = 5 * 60 * 1000;\n    function canSyncModel(modelService, resource) {\n        let model = modelService.getModel(resource);\n        if (!model) {\n            return false;\n        }\n        if (model.isTooLargeForSyncing()) {\n            return false;\n        }\n        return true;\n    }\n    let EditorWorkerServiceImpl = class EditorWorkerServiceImpl extends lifecycle_1.Disposable {\n        constructor(modelService, configurationService) {\n            super();\n            this._modelService = modelService;\n            this._workerManager = this._register(new WorkerManager(this._modelService));\n            // todo@joh make sure this happens only once\n            this._register(modes.LinkProviderRegistry.register('*', {\n                provideLinks: (model, token) => {\n                    if (!canSyncModel(this._modelService, model.uri)) {\n                        return Promise.resolve([]); // File too large\n                    }\n                    return this._workerManager.withWorker().then(client => client.computeLinks(model.uri));\n                }\n            }));\n            this._register(modes.CompletionProviderRegistry.register('*', new WordBasedCompletionItemProvider(this._workerManager, configurationService, this._modelService)));\n        }\n        dispose() {\n            super.dispose();\n        }\n        canComputeDiff(original, modified) {\n            return (canSyncModel(this._modelService, original) && canSyncModel(this._modelService, modified));\n        }\n        computeDiff(original, modified, ignoreTrimWhitespace) {\n            return this._workerManager.withWorker().then(client => client.computeDiff(original, modified, ignoreTrimWhitespace));\n        }\n        canComputeDirtyDiff(original, modified) {\n            return (canSyncModel(this._modelService, original) && canSyncModel(this._modelService, modified));\n        }\n        computeDirtyDiff(original, modified, ignoreTrimWhitespace) {\n            return this._workerManager.withWorker().then(client => client.computeDirtyDiff(original, modified, ignoreTrimWhitespace));\n        }\n        computeMoreMinimalEdits(resource, edits) {\n            if (arrays_1.isNonEmptyArray(edits)) {\n                if (!canSyncModel(this._modelService, resource)) {\n                    return Promise.resolve(edits); // File too large\n                }\n                return this._workerManager.withWorker().then(client => client.computeMoreMinimalEdits(resource, edits));\n            }\n            else {\n                return Promise.resolve(undefined);\n            }\n        }\n        canNavigateValueSet(resource) {\n            return (canSyncModel(this._modelService, resource));\n        }\n        navigateValueSet(resource, range, up) {\n            return this._workerManager.withWorker().then(client => client.navigateValueSet(resource, range, up));\n        }\n        canComputeWordRanges(resource) {\n            return canSyncModel(this._modelService, resource);\n        }\n        computeWordRanges(resource, range) {\n            return this._workerManager.withWorker().then(client => client.computeWordRanges(resource, range));\n        }\n    };\n    EditorWorkerServiceImpl = __decorate([\n        __param(0, modelService_1.IModelService),\n        __param(1, resourceConfiguration_1.ITextResourceConfigurationService)\n    ], EditorWorkerServiceImpl);\n    exports.EditorWorkerServiceImpl = EditorWorkerServiceImpl;\n    class WordBasedCompletionItemProvider {\n        constructor(workerManager, configurationService, modelService) {\n            this._workerManager = workerManager;\n            this._configurationService = configurationService;\n            this._modelService = modelService;\n        }\n        provideCompletionItems(model, position) {\n            const { wordBasedSuggestions } = this._configurationService.getValue(model.uri, position, 'editor');\n            if (!wordBasedSuggestions) {\n                return undefined;\n            }\n            if (!canSyncModel(this._modelService, model.uri)) {\n                return undefined; // File too large\n            }\n            return this._workerManager.withWorker().then(client => client.textualSuggest(model.uri, position));\n        }\n    }\n    class WorkerManager extends lifecycle_1.Disposable {\n        constructor(modelService) {\n            super();\n            this._modelService = modelService;\n            this._editorWorkerClient = null;\n            let stopWorkerInterval = this._register(new async_1.IntervalTimer());\n            stopWorkerInterval.cancelAndSet(() => this._checkStopIdleWorker(), Math.round(STOP_WORKER_DELTA_TIME_MS / 2));\n            this._register(this._modelService.onModelRemoved(_ => this._checkStopEmptyWorker()));\n        }\n        dispose() {\n            if (this._editorWorkerClient) {\n                this._editorWorkerClient.dispose();\n                this._editorWorkerClient = null;\n            }\n            super.dispose();\n        }\n        /**\n         * Check if the model service has no more models and stop the worker if that is the case.\n         */\n        _checkStopEmptyWorker() {\n            if (!this._editorWorkerClient) {\n                return;\n            }\n            let models = this._modelService.getModels();\n            if (models.length === 0) {\n                // There are no more models => nothing possible for me to do\n                this._editorWorkerClient.dispose();\n                this._editorWorkerClient = null;\n            }\n        }\n        /**\n         * Check if the worker has been idle for a while and then stop it.\n         */\n        _checkStopIdleWorker() {\n            if (!this._editorWorkerClient) {\n                return;\n            }\n            let timeSinceLastWorkerUsedTime = (new Date()).getTime() - this._lastWorkerUsedTime;\n            if (timeSinceLastWorkerUsedTime > STOP_WORKER_DELTA_TIME_MS) {\n                this._editorWorkerClient.dispose();\n                this._editorWorkerClient = null;\n            }\n        }\n        withWorker() {\n            this._lastWorkerUsedTime = (new Date()).getTime();\n            if (!this._editorWorkerClient) {\n                this._editorWorkerClient = new EditorWorkerClient(this._modelService, 'editorWorkerService');\n            }\n            return Promise.resolve(this._editorWorkerClient);\n        }\n    }\n    class EditorModelManager extends lifecycle_1.Disposable {\n        constructor(proxy, modelService, keepIdleModels) {\n            super();\n            this._syncedModels = Object.create(null);\n            this._syncedModelsLastUsedTime = Object.create(null);\n            this._proxy = proxy;\n            this._modelService = modelService;\n            if (!keepIdleModels) {\n                let timer = new async_1.IntervalTimer();\n                timer.cancelAndSet(() => this._checkStopModelSync(), Math.round(STOP_SYNC_MODEL_DELTA_TIME_MS / 2));\n                this._register(timer);\n            }\n        }\n        dispose() {\n            for (let modelUrl in this._syncedModels) {\n                lifecycle_1.dispose(this._syncedModels[modelUrl]);\n            }\n            this._syncedModels = Object.create(null);\n            this._syncedModelsLastUsedTime = Object.create(null);\n            super.dispose();\n        }\n        esureSyncedResources(resources) {\n            for (const resource of resources) {\n                let resourceStr = resource.toString();\n                if (!this._syncedModels[resourceStr]) {\n                    this._beginModelSync(resource);\n                }\n                if (this._syncedModels[resourceStr]) {\n                    this._syncedModelsLastUsedTime[resourceStr] = (new Date()).getTime();\n                }\n            }\n        }\n        _checkStopModelSync() {\n            let currentTime = (new Date()).getTime();\n            let toRemove = [];\n            for (let modelUrl in this._syncedModelsLastUsedTime) {\n                let elapsedTime = currentTime - this._syncedModelsLastUsedTime[modelUrl];\n                if (elapsedTime > STOP_SYNC_MODEL_DELTA_TIME_MS) {\n                    toRemove.push(modelUrl);\n                }\n            }\n            for (const e of toRemove) {\n                this._stopModelSync(e);\n            }\n        }\n        _beginModelSync(resource) {\n            let model = this._modelService.getModel(resource);\n            if (!model) {\n                return;\n            }\n            if (model.isTooLargeForSyncing()) {\n                return;\n            }\n            let modelUrl = resource.toString();\n            this._proxy.acceptNewModel({\n                url: model.uri.toString(),\n                lines: model.getLinesContent(),\n                EOL: model.getEOL(),\n                versionId: model.getVersionId()\n            });\n            let toDispose = [];\n            toDispose.push(model.onDidChangeContent((e) => {\n                this._proxy.acceptModelChanged(modelUrl.toString(), e);\n            }));\n            toDispose.push(model.onWillDispose(() => {\n                this._stopModelSync(modelUrl);\n            }));\n            toDispose.push(lifecycle_1.toDisposable(() => {\n                this._proxy.acceptRemovedModel(modelUrl);\n            }));\n            this._syncedModels[modelUrl] = toDispose;\n        }\n        _stopModelSync(modelUrl) {\n            let toDispose = this._syncedModels[modelUrl];\n            delete this._syncedModels[modelUrl];\n            delete this._syncedModelsLastUsedTime[modelUrl];\n            lifecycle_1.dispose(toDispose);\n        }\n    }\n    class SynchronousWorkerClient {\n        constructor(instance) {\n            this._instance = instance;\n            this._proxyObj = Promise.resolve(this._instance);\n        }\n        dispose() {\n            this._instance.dispose();\n        }\n        getProxyObject() {\n            return this._proxyObj;\n        }\n    }\n    class EditorWorkerClient extends lifecycle_1.Disposable {\n        constructor(modelService, label) {\n            super();\n            this._modelService = modelService;\n            this._workerFactory = new defaultWorkerFactory_1.DefaultWorkerFactory(label);\n            this._worker = null;\n            this._modelManager = null;\n        }\n        _getOrCreateWorker() {\n            if (!this._worker) {\n                try {\n                    this._worker = this._register(new simpleWorker_1.SimpleWorkerClient(this._workerFactory, 'vs/editor/common/services/editorSimpleWorker'));\n                }\n                catch (err) {\n                    simpleWorker_1.logOnceWebWorkerWarning(err);\n                    this._worker = new SynchronousWorkerClient(new editorSimpleWorker_1.EditorSimpleWorkerImpl(null));\n                }\n            }\n            return this._worker;\n        }\n        _getProxy() {\n            return this._getOrCreateWorker().getProxyObject().then(undefined, (err) => {\n                simpleWorker_1.logOnceWebWorkerWarning(err);\n                this._worker = new SynchronousWorkerClient(new editorSimpleWorker_1.EditorSimpleWorkerImpl(null));\n                return this._getOrCreateWorker().getProxyObject();\n            });\n        }\n        _getOrCreateModelManager(proxy) {\n            if (!this._modelManager) {\n                this._modelManager = this._register(new EditorModelManager(proxy, this._modelService, false));\n            }\n            return this._modelManager;\n        }\n        _withSyncedResources(resources) {\n            return this._getProxy().then((proxy) => {\n                this._getOrCreateModelManager(proxy).esureSyncedResources(resources);\n                return proxy;\n            });\n        }\n        computeDiff(original, modified, ignoreTrimWhitespace) {\n            return this._withSyncedResources([original, modified]).then(proxy => {\n                return proxy.computeDiff(original.toString(), modified.toString(), ignoreTrimWhitespace);\n            });\n        }\n        computeDirtyDiff(original, modified, ignoreTrimWhitespace) {\n            return this._withSyncedResources([original, modified]).then(proxy => {\n                return proxy.computeDirtyDiff(original.toString(), modified.toString(), ignoreTrimWhitespace);\n            });\n        }\n        computeMoreMinimalEdits(resource, edits) {\n            return this._withSyncedResources([resource]).then(proxy => {\n                return proxy.computeMoreMinimalEdits(resource.toString(), edits);\n            });\n        }\n        computeLinks(resource) {\n            return this._withSyncedResources([resource]).then(proxy => {\n                return proxy.computeLinks(resource.toString());\n            });\n        }\n        textualSuggest(resource, position) {\n            return this._withSyncedResources([resource]).then(proxy => {\n                let model = this._modelService.getModel(resource);\n                if (!model) {\n                    return null;\n                }\n                let wordDefRegExp = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getWordDefinition(model.getLanguageIdentifier().id);\n                let wordDef = wordDefRegExp.source;\n                let wordDefFlags = strings_1.regExpFlags(wordDefRegExp);\n                return proxy.textualSuggest(resource.toString(), position, wordDef, wordDefFlags);\n            });\n        }\n        computeWordRanges(resource, range) {\n            return this._withSyncedResources([resource]).then(proxy => {\n                let model = this._modelService.getModel(resource);\n                if (!model) {\n                    return Promise.resolve(null);\n                }\n                let wordDefRegExp = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getWordDefinition(model.getLanguageIdentifier().id);\n                let wordDef = wordDefRegExp.source;\n                let wordDefFlags = strings_1.regExpFlags(wordDefRegExp);\n                return proxy.computeWordRanges(resource.toString(), range, wordDef, wordDefFlags);\n            });\n        }\n        navigateValueSet(resource, range, up) {\n            return this._withSyncedResources([resource]).then(proxy => {\n                let model = this._modelService.getModel(resource);\n                if (!model) {\n                    return null;\n                }\n                let wordDefRegExp = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getWordDefinition(model.getLanguageIdentifier().id);\n                let wordDef = wordDefRegExp.source;\n                let wordDefFlags = strings_1.regExpFlags(wordDefRegExp);\n                return proxy.navigateValueSet(resource.toString(), range, up, wordDef, wordDefFlags);\n            });\n        }\n    }\n    exports.EditorWorkerClient = EditorWorkerClient;\n});\n",null]}