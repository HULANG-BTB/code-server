{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostExtensionService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostExtensionService.ts","mtime":1555846338032},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/path\", \"vs/base/common/resources\", \"vs/base/common/async\", \"vs/base/common/lifecycle\", \"vs/base/common/map\", \"vs/base/common/uri\", \"vs/base/node/pfs\", \"vs/workbench/api/node/extHost.api.impl\", \"vs/workbench/api/common/extHost.protocol\", \"vs/workbench/api/node/extHostExtensionActivator\", \"vs/workbench/api/node/extHostStorage\", \"vs/workbench/services/extensions/node/extensionDescriptionRegistry\", \"vs/workbench/services/extensions/node/proxyResolver\", \"vs/base/common/cancellation\", \"vs/base/common/errors\", \"vs/platform/extensions/common/extensions\", \"vs/base/common/network\", \"vs/base/common/types\"], function (require, exports, nls, path, resources_1, async_1, lifecycle_1, map_1, uri_1, pfs, extHost_api_impl_1, extHost_protocol_1, extHostExtensionActivator_1, extHostStorage_1, extensionDescriptionRegistry_1, proxyResolver_1, cancellation_1, errors, extensions_1, network_1, types_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class ExtensionMemento {\n        constructor(id, global, storage) {\n            this._id = id;\n            this._shared = global;\n            this._storage = storage;\n            this._init = this._storage.getValue(this._shared, this._id, Object.create(null)).then(value => {\n                this._value = value;\n                return this;\n            });\n            this._storageListener = this._storage.onDidChangeStorage(e => {\n                if (e.shared === this._shared && e.key === this._id) {\n                    this._value = e.value;\n                }\n            });\n        }\n        get whenReady() {\n            return this._init;\n        }\n        get(key, defaultValue) {\n            let value = this._value[key];\n            if (typeof value === 'undefined') {\n                value = defaultValue;\n            }\n            return value;\n        }\n        update(key, value) {\n            this._value[key] = value;\n            return this._storage\n                .setValue(this._shared, this._id, this._value)\n                .then(() => true);\n        }\n        dispose() {\n            this._storageListener.dispose();\n        }\n    }\n    class ExtensionStoragePath {\n        constructor(workspace, environment) {\n            this._workspace = workspace;\n            this._environment = environment;\n            this._ready = this._getOrCreateWorkspaceStoragePath().then(value => this._value = value);\n        }\n        get whenReady() {\n            return this._ready;\n        }\n        workspaceValue(extension) {\n            if (this._value) {\n                return path.join(this._value, extension.identifier.value);\n            }\n            return undefined;\n        }\n        globalValue(extension) {\n            return path.join(this._environment.globalStorageHome.fsPath, extension.identifier.value.toLowerCase());\n        }\n        _getOrCreateWorkspaceStoragePath() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!this._workspace) {\n                    return Promise.resolve(undefined);\n                }\n                if (!this._environment.appSettingsHome) {\n                    return undefined;\n                }\n                const storageName = this._workspace.id;\n                const storagePath = path.join(this._environment.appSettingsHome.fsPath, 'workspaceStorage', storageName);\n                const exists = yield pfs.dirExists(storagePath);\n                if (exists) {\n                    return storagePath;\n                }\n                try {\n                    yield pfs.mkdirp(storagePath);\n                    yield pfs.writeFile(path.join(storagePath, 'meta.json'), JSON.stringify({\n                        id: this._workspace.id,\n                        configuration: this._workspace.configuration && uri_1.URI.revive(this._workspace.configuration).toString(),\n                        name: this._workspace.name\n                    }, undefined, 2));\n                    return storagePath;\n                }\n                catch (e) {\n                    console.error(e);\n                    return undefined;\n                }\n            });\n        }\n    }\n    class ExtHostExtensionService {\n        constructor(nativeExit, initData, extHostContext, extHostWorkspace, extHostConfiguration, extHostLogService) {\n            this._nativeExit = nativeExit;\n            this._initData = initData;\n            this._extHostContext = extHostContext;\n            this._extHostWorkspace = extHostWorkspace;\n            this._extHostConfiguration = extHostConfiguration;\n            this._extHostLogService = extHostLogService;\n            this._mainThreadWorkspaceProxy = this._extHostContext.getProxy(extHost_protocol_1.MainContext.MainThreadWorkspace);\n            this._mainThreadTelemetryProxy = this._extHostContext.getProxy(extHost_protocol_1.MainContext.MainThreadTelemetry);\n            this._mainThreadExtensionsProxy = this._extHostContext.getProxy(extHost_protocol_1.MainContext.MainThreadExtensionService);\n            this._almostReadyToRunExtensions = new async_1.Barrier();\n            this._readyToRunExtensions = new async_1.Barrier();\n            this._registry = new extensionDescriptionRegistry_1.ExtensionDescriptionRegistry(initData.extensions);\n            this._storage = new extHostStorage_1.ExtHostStorage(this._extHostContext);\n            this._storagePath = new ExtensionStoragePath(types_1.withNullAsUndefined(initData.workspace), initData.environment);\n            const hostExtensions = new Set();\n            initData.hostExtensions.forEach((extensionId) => hostExtensions.add(extensions_1.ExtensionIdentifier.toKey(extensionId)));\n            this._activator = new extHostExtensionActivator_1.ExtensionsActivator(this._registry, initData.resolvedExtensions, initData.hostExtensions, {\n                onExtensionActivationError: (extensionId, error) => {\n                    this._mainThreadExtensionsProxy.$onExtensionActivationError(extensionId, error);\n                },\n                actualActivateExtension: (extensionId, reason) => __awaiter(this, void 0, void 0, function* () {\n                    if (hostExtensions.has(extensions_1.ExtensionIdentifier.toKey(extensionId))) {\n                        const activationEvent = (reason instanceof extHostExtensionActivator_1.ExtensionActivatedByEvent ? reason.activationEvent : null);\n                        yield this._mainThreadExtensionsProxy.$activateExtension(extensionId, activationEvent);\n                        return new extHostExtensionActivator_1.HostExtension();\n                    }\n                    const extensionDescription = this._registry.getExtensionDescription(extensionId);\n                    return this._activateExtension(extensionDescription, reason);\n                })\n            });\n            this._extensionPathIndex = null;\n            // initialize API first (i.e. do not release barrier until the API is initialized)\n            this._extensionApiFactory = extHost_api_impl_1.createApiFactory(this._initData, this._extHostContext, this._extHostWorkspace, this._extHostConfiguration, this, this._extHostLogService, this._storage);\n            this._resolvers = Object.create(null);\n            this._started = false;\n            this._initialize();\n            if (this._initData.autoStart) {\n                this._startExtensionHost();\n            }\n        }\n        _initialize() {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const configProvider = yield this._extHostConfiguration.getConfigProvider();\n                    yield extHost_api_impl_1.initializeExtensionApi(this, this._extensionApiFactory, this._registry, configProvider);\n                    // Do this when extension service exists, but extensions are not being activated yet.\n                    yield proxyResolver_1.connectProxyResolver(this._extHostWorkspace, configProvider, this, this._extHostLogService, this._mainThreadTelemetryProxy);\n                    this._almostReadyToRunExtensions.open();\n                    yield this._extHostWorkspace.waitForInitializeCall();\n                    this._readyToRunExtensions.open();\n                }\n                catch (err) {\n                    errors.onUnexpectedError(err);\n                }\n            });\n        }\n        deactivateAll() {\n            return __awaiter(this, void 0, void 0, function* () {\n                let allPromises = [];\n                try {\n                    const allExtensions = this._registry.getAllExtensionDescriptions();\n                    const allExtensionsIds = allExtensions.map(ext => ext.identifier);\n                    const activatedExtensions = allExtensionsIds.filter(id => this.isActivated(id));\n                    allPromises = activatedExtensions.map((extensionId) => {\n                        return this._deactivate(extensionId);\n                    });\n                }\n                catch (err) {\n                    // TODO: write to log once we have one\n                }\n                yield allPromises;\n            });\n        }\n        isActivated(extensionId) {\n            if (this._readyToRunExtensions.isOpen()) {\n                return this._activator.isActivated(extensionId);\n            }\n            return false;\n        }\n        _activateByEvent(activationEvent, startup) {\n            const reason = new extHostExtensionActivator_1.ExtensionActivatedByEvent(startup, activationEvent);\n            return this._activator.activateByEvent(activationEvent, reason);\n        }\n        _activateById(extensionId, reason) {\n            return this._activator.activateById(extensionId, reason);\n        }\n        activateByIdWithErrors(extensionId, reason) {\n            return this._activateById(extensionId, reason).then(() => {\n                const extension = this._activator.getActivatedExtension(extensionId);\n                if (extension.activationFailed) {\n                    // activation failed => bubble up the error as the promise result\n                    return Promise.reject(extension.activationFailedError);\n                }\n                return undefined;\n            });\n        }\n        getExtensionRegistry() {\n            return this._readyToRunExtensions.wait().then(_ => this._registry);\n        }\n        getExtensionExports(extensionId) {\n            if (this._readyToRunExtensions.isOpen()) {\n                return this._activator.getActivatedExtension(extensionId).exports;\n            }\n            else {\n                return null;\n            }\n        }\n        // create trie to enable fast 'filename -> extension id' look up\n        getExtensionPathIndex() {\n            if (!this._extensionPathIndex) {\n                const tree = map_1.TernarySearchTree.forPaths();\n                const extensions = this._registry.getAllExtensionDescriptions().map(ext => {\n                    if (!ext.main) {\n                        return undefined;\n                    }\n                    return pfs.realpath(ext.extensionLocation.fsPath).then(value => tree.set(uri_1.URI.file(value).fsPath, ext));\n                });\n                this._extensionPathIndex = Promise.all(extensions).then(() => tree);\n            }\n            return this._extensionPathIndex;\n        }\n        _deactivate(extensionId) {\n            let result = Promise.resolve(undefined);\n            if (!this._readyToRunExtensions.isOpen()) {\n                return result;\n            }\n            if (!this._activator.isActivated(extensionId)) {\n                return result;\n            }\n            const extension = this._activator.getActivatedExtension(extensionId);\n            if (!extension) {\n                return result;\n            }\n            // call deactivate if available\n            try {\n                if (typeof extension.module.deactivate === 'function') {\n                    result = Promise.resolve(extension.module.deactivate()).then(undefined, (err) => {\n                        // TODO: Do something with err if this is not the shutdown case\n                        return Promise.resolve(undefined);\n                    });\n                }\n            }\n            catch (err) {\n                // TODO: Do something with err if this is not the shutdown case\n            }\n            // clean up subscriptions\n            try {\n                lifecycle_1.dispose(extension.subscriptions);\n            }\n            catch (err) {\n                // TODO: Do something with err if this is not the shutdown case\n            }\n            return result;\n        }\n        // --- impl\n        _activateExtension(extensionDescription, reason) {\n            this._mainThreadExtensionsProxy.$onWillActivateExtension(extensionDescription.identifier);\n            return this._doActivateExtension(extensionDescription, reason).then((activatedExtension) => {\n                const activationTimes = activatedExtension.activationTimes;\n                const activationEvent = (reason instanceof extHostExtensionActivator_1.ExtensionActivatedByEvent ? reason.activationEvent : null);\n                this._mainThreadExtensionsProxy.$onDidActivateExtension(extensionDescription.identifier, activationTimes.startup, activationTimes.codeLoadingTime, activationTimes.activateCallTime, activationTimes.activateResolvedTime, activationEvent);\n                this._logExtensionActivationTimes(extensionDescription, reason, 'success', activationTimes);\n                return activatedExtension;\n            }, (err) => {\n                this._logExtensionActivationTimes(extensionDescription, reason, 'failure');\n                throw err;\n            });\n        }\n        _logExtensionActivationTimes(extensionDescription, reason, outcome, activationTimes) {\n            const event = getTelemetryActivationEvent(extensionDescription, reason);\n            /* __GDPR__\n                \"extensionActivationTimes\" : {\n                    \"${include}\": [\n                        \"${TelemetryActivationEvent}\",\n                        \"${ExtensionActivationTimes}\"\n                    ],\n                    \"outcome\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                }\n            */\n            this._mainThreadTelemetryProxy.$publicLog('extensionActivationTimes', Object.assign({}, event, (activationTimes || {}), { outcome }));\n        }\n        _doActivateExtension(extensionDescription, reason) {\n            const event = getTelemetryActivationEvent(extensionDescription, reason);\n            /* __GDPR__\n                \"activatePlugin\" : {\n                    \"${include}\": [\n                        \"${TelemetryActivationEvent}\"\n                    ]\n                }\n            */\n            this._mainThreadTelemetryProxy.$publicLog('activatePlugin', event);\n            if (!extensionDescription.main) {\n                // Treat the extension as being empty => NOT AN ERROR CASE\n                return Promise.resolve(new extHostExtensionActivator_1.EmptyExtension(extHostExtensionActivator_1.ExtensionActivationTimes.NONE));\n            }\n            this._extHostLogService.info(`ExtensionService#_doActivateExtension ${extensionDescription.identifier.value} ${JSON.stringify(reason)}`);\n            const activationTimesBuilder = new extHostExtensionActivator_1.ExtensionActivationTimesBuilder(reason.startup);\n            return Promise.all([\n                loadCommonJSModule(this._extHostLogService, extensionDescription.main, activationTimesBuilder),\n                this._loadExtensionContext(extensionDescription)\n            ]).then(values => {\n                return ExtHostExtensionService._callActivate(this._extHostLogService, extensionDescription.identifier, values[0], values[1], activationTimesBuilder);\n            });\n        }\n        _loadExtensionContext(extensionDescription) {\n            const globalState = new ExtensionMemento(extensionDescription.identifier.value, true, this._storage);\n            const workspaceState = new ExtensionMemento(extensionDescription.identifier.value, false, this._storage);\n            this._extHostLogService.trace(`ExtensionService#loadExtensionContext ${extensionDescription.identifier.value}`);\n            return Promise.all([\n                globalState.whenReady,\n                workspaceState.whenReady,\n                this._storagePath.whenReady\n            ]).then(() => {\n                const that = this;\n                return Object.freeze({\n                    globalState,\n                    workspaceState,\n                    subscriptions: [],\n                    get extensionPath() { return extensionDescription.extensionLocation.fsPath; },\n                    storagePath: this._storagePath.workspaceValue(extensionDescription),\n                    globalStoragePath: this._storagePath.globalValue(extensionDescription),\n                    asAbsolutePath: (relativePath) => { return path.join(extensionDescription.extensionLocation.fsPath, relativePath); },\n                    logPath: that._extHostLogService.getLogDirectory(extensionDescription.identifier)\n                });\n            });\n        }\n        static _callActivate(logService, extensionId, extensionModule, context, activationTimesBuilder) {\n            // Make sure the extension's surface is not undefined\n            extensionModule = extensionModule || {\n                activate: undefined,\n                deactivate: undefined\n            };\n            return this._callActivateOptional(logService, extensionId, extensionModule, context, activationTimesBuilder).then((extensionExports) => {\n                return new extHostExtensionActivator_1.ActivatedExtension(false, null, activationTimesBuilder.build(), extensionModule, extensionExports, context.subscriptions);\n            });\n        }\n        static _callActivateOptional(logService, extensionId, extensionModule, context, activationTimesBuilder) {\n            if (typeof extensionModule.activate === 'function') {\n                try {\n                    activationTimesBuilder.activateCallStart();\n                    logService.trace(`ExtensionService#_callActivateOptional ${extensionId.value}`);\n                    const activateResult = extensionModule.activate.apply(global, [context]);\n                    activationTimesBuilder.activateCallStop();\n                    activationTimesBuilder.activateResolveStart();\n                    return Promise.resolve(activateResult).then((value) => {\n                        activationTimesBuilder.activateResolveStop();\n                        return value;\n                    });\n                }\n                catch (err) {\n                    return Promise.reject(err);\n                }\n            }\n            else {\n                // No activate found => the module is the extension's exports\n                return Promise.resolve(extensionModule);\n            }\n        }\n        // -- eager activation\n        // Handle \"eager\" activation extensions\n        _handleEagerExtensions() {\n            this._activateByEvent('*', true).then(undefined, (err) => {\n                console.error(err);\n            });\n            return this._handleWorkspaceContainsEagerExtensions(this._extHostWorkspace.workspace);\n        }\n        _handleWorkspaceContainsEagerExtensions(workspace) {\n            if (!workspace || workspace.folders.length === 0) {\n                return Promise.resolve(undefined);\n            }\n            return Promise.all(this._registry.getAllExtensionDescriptions().map((desc) => {\n                return this._handleWorkspaceContainsEagerExtension(workspace, desc);\n            })).then(() => { });\n        }\n        _handleWorkspaceContainsEagerExtension(workspace, desc) {\n            const activationEvents = desc.activationEvents;\n            if (!activationEvents) {\n                return Promise.resolve(undefined);\n            }\n            const fileNames = [];\n            const globPatterns = [];\n            for (const activationEvent of activationEvents) {\n                if (/^workspaceContains:/.test(activationEvent)) {\n                    const fileNameOrGlob = activationEvent.substr('workspaceContains:'.length);\n                    if (fileNameOrGlob.indexOf('*') >= 0 || fileNameOrGlob.indexOf('?') >= 0) {\n                        globPatterns.push(fileNameOrGlob);\n                    }\n                    else {\n                        fileNames.push(fileNameOrGlob);\n                    }\n                }\n            }\n            if (fileNames.length === 0 && globPatterns.length === 0) {\n                return Promise.resolve(undefined);\n            }\n            const fileNamePromise = Promise.all(fileNames.map((fileName) => this._activateIfFileName(workspace, desc.identifier, fileName))).then(() => { });\n            const globPatternPromise = this._activateIfGlobPatterns(desc.identifier, globPatterns);\n            return Promise.all([fileNamePromise, globPatternPromise]).then(() => { });\n        }\n        _activateIfFileName(workspace, extensionId, fileName) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // find exact path\n                for (const { uri } of workspace.folders) {\n                    if (yield pfs.exists(path.join(uri_1.URI.revive(uri).fsPath, fileName))) {\n                        // the file was found\n                        return (this._activateById(extensionId, new extHostExtensionActivator_1.ExtensionActivatedByEvent(true, `workspaceContains:${fileName}`))\n                            .then(undefined, err => console.error(err)));\n                    }\n                }\n                return undefined;\n            });\n        }\n        _activateIfGlobPatterns(extensionId, globPatterns) {\n            return __awaiter(this, void 0, void 0, function* () {\n                this._extHostLogService.trace(`extensionHostMain#activateIfGlobPatterns: fileSearch, extension: ${extensionId.value}, entryPoint: workspaceContains`);\n                if (globPatterns.length === 0) {\n                    return Promise.resolve(undefined);\n                }\n                const tokenSource = new cancellation_1.CancellationTokenSource();\n                const searchP = this._mainThreadWorkspaceProxy.$checkExists(globPatterns, tokenSource.token);\n                const timer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                    tokenSource.cancel();\n                    this._activateById(extensionId, new extHostExtensionActivator_1.ExtensionActivatedByEvent(true, `workspaceContainsTimeout:${globPatterns.join(',')}`))\n                        .then(undefined, err => console.error(err));\n                }), ExtHostExtensionService.WORKSPACE_CONTAINS_TIMEOUT);\n                let exists = false;\n                try {\n                    exists = yield searchP;\n                }\n                catch (err) {\n                    if (!errors.isPromiseCanceledError(err)) {\n                        console.error(err);\n                    }\n                }\n                tokenSource.dispose();\n                clearTimeout(timer);\n                if (exists) {\n                    // a file was found matching one of the glob patterns\n                    return (this._activateById(extensionId, new extHostExtensionActivator_1.ExtensionActivatedByEvent(true, `workspaceContains:${globPatterns.join(',')}`))\n                        .then(undefined, err => console.error(err)));\n                }\n                return Promise.resolve(undefined);\n            });\n        }\n        _handleExtensionTests() {\n            return this._doHandleExtensionTests().then(undefined, error => {\n                console.error(error); // ensure any error message makes it onto the console\n                return Promise.reject(error);\n            });\n        }\n        _doHandleExtensionTests() {\n            const { extensionDevelopmentLocationURI, extensionTestsLocationURI } = this._initData.environment;\n            if (!(extensionDevelopmentLocationURI && extensionTestsLocationURI && extensionTestsLocationURI.scheme === network_1.Schemas.file)) {\n                return Promise.resolve(undefined);\n            }\n            const extensionTestsPath = resources_1.originalFSPath(extensionTestsLocationURI);\n            // Require the test runner via node require from the provided path\n            let testRunner;\n            let requireError;\n            try {\n                testRunner = require.__$__nodeRequire(extensionTestsPath);\n            }\n            catch (error) {\n                requireError = error;\n            }\n            // Execute the runner if it follows our spec\n            if (testRunner && typeof testRunner.run === 'function') {\n                return new Promise((c, e) => {\n                    testRunner.run(extensionTestsPath, (error, failures) => {\n                        if (error) {\n                            e(error.toString());\n                        }\n                        else {\n                            c(undefined);\n                        }\n                        // after tests have run, we shutdown the host\n                        this._gracefulExit(error || (typeof failures === 'number' && failures > 0) ? 1 /* ERROR */ : 0 /* OK */);\n                    });\n                });\n            }\n            // Otherwise make sure to shutdown anyway even in case of an error\n            else {\n                this._gracefulExit(1 /* ERROR */);\n            }\n            return Promise.reject(new Error(requireError ? requireError.toString() : nls.localize('extensionTestError', \"Path {0} does not point to a valid extension test runner.\", extensionTestsPath)));\n        }\n        _gracefulExit(code) {\n            // to give the PH process a chance to flush any outstanding console\n            // messages to the main process, we delay the exit() by some time\n            setTimeout(() => {\n                // If extension tests are running, give the exit code to the renderer\n                if (this._initData.remoteAuthority && !!this._initData.environment.extensionTestsLocationURI) {\n                    this._mainThreadExtensionsProxy.$onExtensionHostExit(code);\n                    return;\n                }\n                this._nativeExit(code);\n            }, 500);\n        }\n        _startExtensionHost() {\n            if (this._started) {\n                throw new Error(`Extension host is already started!`);\n            }\n            this._started = true;\n            return this._readyToRunExtensions.wait()\n                .then(() => this._handleEagerExtensions())\n                .then(() => this._handleExtensionTests())\n                .then(() => {\n                this._extHostLogService.info(`eager extensions activated`);\n            });\n        }\n        // -- called by extensions\n        registerRemoteAuthorityResolver(authorityPrefix, resolver) {\n            this._resolvers[authorityPrefix] = resolver;\n            return lifecycle_1.toDisposable(() => {\n                delete this._resolvers[authorityPrefix];\n            });\n        }\n        // -- called by main thread\n        $resolveAuthority(remoteAuthority) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const authorityPlusIndex = remoteAuthority.indexOf('+');\n                if (authorityPlusIndex === -1) {\n                    throw new Error(`Not an authority that can be resolved!`);\n                }\n                const authorityPrefix = remoteAuthority.substr(0, authorityPlusIndex);\n                yield this._almostReadyToRunExtensions.wait();\n                yield this._activateByEvent(`onResolveRemoteAuthority:${authorityPrefix}`, false);\n                const resolver = this._resolvers[authorityPrefix];\n                if (!resolver) {\n                    throw new Error(`No resolver available for ${authorityPrefix}`);\n                }\n                const result = yield resolver.resolve(remoteAuthority);\n                return {\n                    authority: remoteAuthority,\n                    host: result.host,\n                    port: result.port,\n                    debugListenPort: result.debugListenPort,\n                    debugConnectPort: result.debugConnectPort,\n                };\n            });\n        }\n        $startExtensionHost(enabledExtensionIds) {\n            this._registry.keepOnly(enabledExtensionIds);\n            return this._startExtensionHost();\n        }\n        $activateByEvent(activationEvent) {\n            return (this._readyToRunExtensions.wait()\n                .then(_ => this._activateByEvent(activationEvent, false)));\n        }\n        $activate(extensionId, activationEvent) {\n            return __awaiter(this, void 0, void 0, function* () {\n                yield this._readyToRunExtensions.wait();\n                if (!this._registry.getExtensionDescription(extensionId)) {\n                    // unknown extension => ignore\n                    return false;\n                }\n                yield this._activateById(extensionId, new extHostExtensionActivator_1.ExtensionActivatedByEvent(false, activationEvent));\n                return true;\n            });\n        }\n        $deltaExtensions(toAdd, toRemove) {\n            return __awaiter(this, void 0, void 0, function* () {\n                toAdd.forEach((extension) => extension.extensionLocation = uri_1.URI.revive(extension.extensionLocation));\n                const trie = yield this.getExtensionPathIndex();\n                yield Promise.all(toRemove.map((extensionId) => __awaiter(this, void 0, void 0, function* () {\n                    const extensionDescription = this._registry.getExtensionDescription(extensionId);\n                    if (!extensionDescription) {\n                        return;\n                    }\n                    const realpath = yield pfs.realpath(extensionDescription.extensionLocation.fsPath);\n                    trie.delete(uri_1.URI.file(realpath).fsPath);\n                })));\n                yield Promise.all(toAdd.map((extensionDescription) => __awaiter(this, void 0, void 0, function* () {\n                    const realpath = yield pfs.realpath(extensionDescription.extensionLocation.fsPath);\n                    trie.set(uri_1.URI.file(realpath).fsPath, extensionDescription);\n                })));\n                this._registry.deltaExtensions(toAdd, toRemove);\n                return Promise.resolve(undefined);\n            });\n        }\n        $test_latency(n) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return n;\n            });\n        }\n        $test_up(b) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return b.length;\n            });\n        }\n        $test_down(size) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const b = Buffer.alloc(size, Math.random() % 256);\n                return b;\n            });\n        }\n    }\n    ExtHostExtensionService.WORKSPACE_CONTAINS_TIMEOUT = 7000;\n    exports.ExtHostExtensionService = ExtHostExtensionService;\n    function loadCommonJSModule(logService, modulePath, activationTimesBuilder) {\n        let r = null;\n        activationTimesBuilder.codeLoadingStart();\n        logService.info(`ExtensionService#loadCommonJSModule ${modulePath}`);\n        try {\n            r = global.nativeNodeRequire(modulePath);\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n        finally {\n            activationTimesBuilder.codeLoadingStop();\n        }\n        return Promise.resolve(r);\n    }\n    function getTelemetryActivationEvent(extensionDescription, reason) {\n        const reasonStr = reason instanceof extHostExtensionActivator_1.ExtensionActivatedByEvent ? reason.activationEvent :\n            reason instanceof extHostExtensionActivator_1.ExtensionActivatedByAPI ? 'api' :\n                '';\n        /* __GDPR__FRAGMENT__\n            \"TelemetryActivationEvent\" : {\n                \"id\": { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" },\n                \"name\": { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" },\n                \"extensionVersion\": { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" },\n                \"publisherDisplayName\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                \"activationEvents\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                \"isBuiltin\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                \"reason\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n            }\n        */\n        const event = {\n            id: extensionDescription.identifier.value,\n            name: extensionDescription.name,\n            extensionVersion: extensionDescription.version,\n            publisherDisplayName: extensionDescription.publisher,\n            activationEvents: extensionDescription.activationEvents ? extensionDescription.activationEvents.join(',') : null,\n            isBuiltin: extensionDescription.isBuiltin,\n            reason: reasonStr\n        };\n        return event;\n    }\n});\n",null]}