{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/viewModel/viewModelImpl.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewModel/viewModelImpl.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/color\", \"vs/base/common/strings\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\", \"vs/editor/common/model\", \"vs/editor/common/model/textModelEvents\", \"vs/editor/common/modes\", \"vs/editor/common/modes/textToHtmlTokenizer\", \"vs/editor/common/view/minimapCharRenderer\", \"vs/editor/common/view/viewEvents\", \"vs/editor/common/viewLayout/viewLayout\", \"vs/editor/common/viewModel/characterHardWrappingLineMapper\", \"vs/editor/common/viewModel/splitLinesCollection\", \"vs/editor/common/viewModel/viewModel\", \"vs/editor/common/viewModel/viewModelDecorations\", \"vs/base/common/async\"], function (require, exports, color_1, strings, position_1, range_1, model_1, textModelEvents, modes_1, textToHtmlTokenizer_1, minimapCharRenderer_1, viewEvents, viewLayout_1, characterHardWrappingLineMapper_1, splitLinesCollection_1, viewModel_1, viewModelDecorations_1, async_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const USE_IDENTITY_LINES_COLLECTION = true;\n    class ViewModel extends viewEvents.ViewEventEmitter {\n        constructor(editorId, configuration, model, scheduleAtNextAnimationFrame) {\n            super();\n            this.editorId = editorId;\n            this.configuration = configuration;\n            this.model = model;\n            this._tokenizeViewportSoon = this._register(new async_1.RunOnceScheduler(() => this.tokenizeViewport(), 50));\n            this.hasFocus = false;\n            this.viewportStartLine = -1;\n            this.viewportStartLineTrackedRange = null;\n            this.viewportStartLineDelta = 0;\n            if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n                this.lines = new splitLinesCollection_1.IdentityLinesCollection(this.model);\n            }\n            else {\n                const conf = this.configuration.editor;\n                let hardWrappingLineMapperFactory = new characterHardWrappingLineMapper_1.CharacterHardWrappingLineMapperFactory(conf.wrappingInfo.wordWrapBreakBeforeCharacters, conf.wrappingInfo.wordWrapBreakAfterCharacters, conf.wrappingInfo.wordWrapBreakObtrusiveCharacters);\n                this.lines = new splitLinesCollection_1.SplitLinesCollection(this.model, hardWrappingLineMapperFactory, this.model.getOptions().tabSize, conf.wrappingInfo.wrappingColumn, conf.fontInfo.typicalFullwidthCharacterWidth / conf.fontInfo.typicalHalfwidthCharacterWidth, conf.wrappingInfo.wrappingIndent);\n            }\n            this.coordinatesConverter = this.lines.createCoordinatesConverter();\n            this.viewLayout = this._register(new viewLayout_1.ViewLayout(this.configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n            this._register(this.viewLayout.onDidScroll((e) => {\n                if (e.scrollTopChanged) {\n                    this._tokenizeViewportSoon.schedule();\n                }\n                try {\n                    const eventsCollector = this._beginEmit();\n                    eventsCollector.emit(new viewEvents.ViewScrollChangedEvent(e));\n                }\n                finally {\n                    this._endEmit();\n                }\n            }));\n            this.decorations = new viewModelDecorations_1.ViewModelDecorations(this.editorId, this.model, this.configuration, this.lines, this.coordinatesConverter);\n            this._registerModelEvents();\n            this._register(this.configuration.onDidChange((e) => {\n                try {\n                    const eventsCollector = this._beginEmit();\n                    this._onConfigurationChanged(eventsCollector, e);\n                }\n                finally {\n                    this._endEmit();\n                }\n            }));\n            this._register(minimapCharRenderer_1.MinimapTokensColorTracker.getInstance().onDidChange(() => {\n                try {\n                    const eventsCollector = this._beginEmit();\n                    eventsCollector.emit(new viewEvents.ViewTokensColorsChangedEvent());\n                }\n                finally {\n                    this._endEmit();\n                }\n            }));\n        }\n        dispose() {\n            // First remove listeners, as disposing the lines might end up sending\n            // model decoration changed events ... and we no longer care about them ...\n            super.dispose();\n            this.decorations.dispose();\n            this.lines.dispose();\n            this.viewportStartLineTrackedRange = this.model._setTrackedRange(this.viewportStartLineTrackedRange, null, model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges);\n        }\n        tokenizeViewport() {\n            const linesViewportData = this.viewLayout.getLinesViewportData();\n            const startPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new position_1.Position(linesViewportData.startLineNumber, 1));\n            const endPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new position_1.Position(linesViewportData.endLineNumber, 1));\n            this.model.tokenizeViewport(startPosition.lineNumber, endPosition.lineNumber);\n        }\n        setHasFocus(hasFocus) {\n            this.hasFocus = hasFocus;\n        }\n        _onConfigurationChanged(eventsCollector, e) {\n            // We might need to restore the current centered view range, so save it (if available)\n            let previousViewportStartModelPosition = null;\n            if (this.viewportStartLine !== -1) {\n                let previousViewportStartViewPosition = new position_1.Position(this.viewportStartLine, this.getLineMinColumn(this.viewportStartLine));\n                previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n            }\n            let restorePreviousViewportStart = false;\n            const conf = this.configuration.editor;\n            if (this.lines.setWrappingSettings(conf.wrappingInfo.wrappingIndent, conf.wrappingInfo.wrappingColumn, conf.fontInfo.typicalFullwidthCharacterWidth / conf.fontInfo.typicalHalfwidthCharacterWidth)) {\n                eventsCollector.emit(new viewEvents.ViewFlushedEvent());\n                eventsCollector.emit(new viewEvents.ViewLineMappingChangedEvent());\n                eventsCollector.emit(new viewEvents.ViewDecorationsChangedEvent());\n                this.decorations.onLineMappingChanged();\n                this.viewLayout.onFlushed(this.getLineCount());\n                if (this.viewLayout.getCurrentScrollTop() !== 0) {\n                    // Never change the scroll position from 0 to something else...\n                    restorePreviousViewportStart = true;\n                }\n            }\n            if (e.readOnly) {\n                // Must read again all decorations due to readOnly filtering\n                this.decorations.reset();\n                eventsCollector.emit(new viewEvents.ViewDecorationsChangedEvent());\n            }\n            eventsCollector.emit(new viewEvents.ViewConfigurationChangedEvent(e));\n            this.viewLayout.onConfigurationChanged(e);\n            if (restorePreviousViewportStart && previousViewportStartModelPosition) {\n                const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(previousViewportStartModelPosition);\n                const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n                this.viewLayout.setScrollPositionNow({ scrollTop: viewPositionTop + this.viewportStartLineDelta });\n            }\n        }\n        _registerModelEvents() {\n            this._register(this.model.onDidChangeRawContentFast((e) => {\n                try {\n                    const eventsCollector = this._beginEmit();\n                    let hadOtherModelChange = false;\n                    let hadModelLineChangeThatChangedLineMapping = false;\n                    const changes = e.changes;\n                    const versionId = e.versionId;\n                    for (let j = 0, lenJ = changes.length; j < lenJ; j++) {\n                        const change = changes[j];\n                        switch (change.changeType) {\n                            case textModelEvents.RawContentChangedType.Flush: {\n                                this.lines.onModelFlushed();\n                                eventsCollector.emit(new viewEvents.ViewFlushedEvent());\n                                this.decorations.reset();\n                                this.viewLayout.onFlushed(this.getLineCount());\n                                hadOtherModelChange = true;\n                                break;\n                            }\n                            case textModelEvents.RawContentChangedType.LinesDeleted: {\n                                const linesDeletedEvent = this.lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n                                if (linesDeletedEvent !== null) {\n                                    eventsCollector.emit(linesDeletedEvent);\n                                    this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                                }\n                                hadOtherModelChange = true;\n                                break;\n                            }\n                            case textModelEvents.RawContentChangedType.LinesInserted: {\n                                const linesInsertedEvent = this.lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, change.detail);\n                                if (linesInsertedEvent !== null) {\n                                    eventsCollector.emit(linesInsertedEvent);\n                                    this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                                }\n                                hadOtherModelChange = true;\n                                break;\n                            }\n                            case textModelEvents.RawContentChangedType.LineChanged: {\n                                const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this.lines.onModelLineChanged(versionId, change.lineNumber, change.detail);\n                                hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n                                if (linesChangedEvent) {\n                                    eventsCollector.emit(linesChangedEvent);\n                                }\n                                if (linesInsertedEvent) {\n                                    eventsCollector.emit(linesInsertedEvent);\n                                    this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                                }\n                                if (linesDeletedEvent) {\n                                    eventsCollector.emit(linesDeletedEvent);\n                                    this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                                }\n                                break;\n                            }\n                            case textModelEvents.RawContentChangedType.EOLChanged: {\n                                // Nothing to do. The new version will be accepted below\n                                break;\n                            }\n                        }\n                    }\n                    this.lines.acceptVersionId(versionId);\n                    this.viewLayout.onHeightMaybeChanged();\n                    if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n                        eventsCollector.emit(new viewEvents.ViewLineMappingChangedEvent());\n                        eventsCollector.emit(new viewEvents.ViewDecorationsChangedEvent());\n                        this.decorations.onLineMappingChanged();\n                    }\n                }\n                finally {\n                    this._endEmit();\n                }\n                // Update the configuration and reset the centered view line\n                this.viewportStartLine = -1;\n                this.configuration.setMaxLineNumber(this.model.getLineCount());\n                // Recover viewport\n                if (!this.hasFocus && this.model.getAttachedEditorCount() >= 2 && this.viewportStartLineTrackedRange) {\n                    const modelRange = this.model._getTrackedRange(this.viewportStartLineTrackedRange);\n                    if (modelRange) {\n                        const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n                        const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n                        this.viewLayout.setScrollPositionNow({ scrollTop: viewPositionTop + this.viewportStartLineDelta });\n                    }\n                }\n            }));\n            this._register(this.model.onDidChangeTokens((e) => {\n                let viewRanges = [];\n                for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n                    const modelRange = e.ranges[j];\n                    const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new position_1.Position(modelRange.fromLineNumber, 1)).lineNumber;\n                    const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new position_1.Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n                    viewRanges[j] = {\n                        fromLineNumber: viewStartLineNumber,\n                        toLineNumber: viewEndLineNumber\n                    };\n                }\n                try {\n                    const eventsCollector = this._beginEmit();\n                    eventsCollector.emit(new viewEvents.ViewTokensChangedEvent(viewRanges));\n                }\n                finally {\n                    this._endEmit();\n                }\n                if (e.tokenizationSupportChanged) {\n                    this._tokenizeViewportSoon.schedule();\n                }\n            }));\n            this._register(this.model.onDidChangeLanguageConfiguration((e) => {\n                try {\n                    const eventsCollector = this._beginEmit();\n                    eventsCollector.emit(new viewEvents.ViewLanguageConfigurationEvent());\n                }\n                finally {\n                    this._endEmit();\n                }\n            }));\n            this._register(this.model.onDidChangeOptions((e) => {\n                // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n                if (this.lines.setTabSize(this.model.getOptions().tabSize)) {\n                    this.decorations.onLineMappingChanged();\n                    this.viewLayout.onFlushed(this.getLineCount());\n                    try {\n                        const eventsCollector = this._beginEmit();\n                        eventsCollector.emit(new viewEvents.ViewFlushedEvent());\n                        eventsCollector.emit(new viewEvents.ViewLineMappingChangedEvent());\n                        eventsCollector.emit(new viewEvents.ViewDecorationsChangedEvent());\n                    }\n                    finally {\n                        this._endEmit();\n                    }\n                }\n            }));\n            this._register(this.model.onDidChangeDecorations((e) => {\n                this.decorations.onModelDecorationsChanged();\n                try {\n                    const eventsCollector = this._beginEmit();\n                    eventsCollector.emit(new viewEvents.ViewDecorationsChangedEvent());\n                }\n                finally {\n                    this._endEmit();\n                }\n            }));\n        }\n        setHiddenAreas(ranges) {\n            try {\n                const eventsCollector = this._beginEmit();\n                let lineMappingChanged = this.lines.setHiddenAreas(ranges);\n                if (lineMappingChanged) {\n                    eventsCollector.emit(new viewEvents.ViewFlushedEvent());\n                    eventsCollector.emit(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emit(new viewEvents.ViewDecorationsChangedEvent());\n                    this.decorations.onLineMappingChanged();\n                    this.viewLayout.onFlushed(this.getLineCount());\n                    this.viewLayout.onHeightMaybeChanged();\n                }\n            }\n            finally {\n                this._endEmit();\n            }\n        }\n        getVisibleRanges() {\n            const visibleViewRange = this.getCompletelyVisibleViewRange();\n            const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n            const hiddenAreas = this.lines.getHiddenAreas();\n            if (hiddenAreas.length === 0) {\n                return [visibleRange];\n            }\n            let result = [], resultLen = 0;\n            let startLineNumber = visibleRange.startLineNumber;\n            let startColumn = visibleRange.startColumn;\n            let endLineNumber = visibleRange.endLineNumber;\n            let endColumn = visibleRange.endColumn;\n            for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n                const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n                const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n                if (hiddenEndLineNumber < startLineNumber) {\n                    continue;\n                }\n                if (hiddenStartLineNumber > endLineNumber) {\n                    continue;\n                }\n                if (startLineNumber < hiddenStartLineNumber) {\n                    result[resultLen++] = new range_1.Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n                }\n                startLineNumber = hiddenEndLineNumber + 1;\n                startColumn = 1;\n            }\n            if (startLineNumber < endLineNumber || (startLineNumber === endLineNumber && startColumn < endColumn)) {\n                result[resultLen++] = new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            return result;\n        }\n        getCompletelyVisibleViewRange() {\n            const partialData = this.viewLayout.getLinesViewportData();\n            const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n            const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n            return new range_1.Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n        }\n        getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n            const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n            const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n            const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n            return new range_1.Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n        }\n        saveState() {\n            const compatViewState = this.viewLayout.saveState();\n            const scrollTop = compatViewState.scrollTop;\n            const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n            const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new position_1.Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n            const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n            return {\n                scrollLeft: compatViewState.scrollLeft,\n                firstPosition: firstPosition,\n                firstPositionDeltaTop: firstPositionDeltaTop\n            };\n        }\n        reduceRestoreState(state) {\n            if (typeof state.firstPosition === 'undefined') {\n                // This is a view state serialized by an older version\n                return this._reduceRestoreStateCompatibility(state);\n            }\n            const modelPosition = this.model.validatePosition(state.firstPosition);\n            const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n            const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n            return {\n                scrollLeft: state.scrollLeft,\n                scrollTop: scrollTop\n            };\n        }\n        _reduceRestoreStateCompatibility(state) {\n            return {\n                scrollLeft: state.scrollLeft,\n                scrollTop: state.scrollTopWithoutViewZones\n            };\n        }\n        getTabSize() {\n            return this.model.getOptions().tabSize;\n        }\n        getOptions() {\n            return this.model.getOptions();\n        }\n        getLineCount() {\n            return this.lines.getViewLineCount();\n        }\n        /**\n         * Gives a hint that a lot of requests are about to come in for these line numbers.\n         */\n        setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n            this.lines.warmUpLookupCache(startLineNumber, endLineNumber);\n            this.viewportStartLine = startLineNumber;\n            let position = this.coordinatesConverter.convertViewPositionToModelPosition(new position_1.Position(startLineNumber, this.getLineMinColumn(startLineNumber)));\n            this.viewportStartLineTrackedRange = this.model._setTrackedRange(this.viewportStartLineTrackedRange, new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column), model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges);\n            const viewportStartLineTop = this.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n            const scrollTop = this.viewLayout.getCurrentScrollTop();\n            this.viewportStartLineDelta = scrollTop - viewportStartLineTop;\n        }\n        getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n            return this.lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n        }\n        getLinesIndentGuides(startLineNumber, endLineNumber) {\n            return this.lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n        }\n        getLineContent(lineNumber) {\n            return this.lines.getViewLineContent(lineNumber);\n        }\n        getLineLength(lineNumber) {\n            return this.lines.getViewLineLength(lineNumber);\n        }\n        getLineMinColumn(lineNumber) {\n            return this.lines.getViewLineMinColumn(lineNumber);\n        }\n        getLineMaxColumn(lineNumber) {\n            return this.lines.getViewLineMaxColumn(lineNumber);\n        }\n        getLineFirstNonWhitespaceColumn(lineNumber) {\n            const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n            if (result === -1) {\n                return 0;\n            }\n            return result + 1;\n        }\n        getLineLastNonWhitespaceColumn(lineNumber) {\n            const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n            if (result === -1) {\n                return 0;\n            }\n            return result + 2;\n        }\n        getDecorationsInViewport(visibleRange) {\n            return this.decorations.getDecorationsViewportData(visibleRange).decorations;\n        }\n        getViewLineRenderingData(visibleRange, lineNumber) {\n            let mightContainRTL = this.model.mightContainRTL();\n            let mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n            let tabSize = this.getTabSize();\n            let lineData = this.lines.getViewLineData(lineNumber);\n            let allInlineDecorations = this.decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n            let inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n            return new viewModel_1.ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize);\n        }\n        getViewLineData(lineNumber) {\n            return this.lines.getViewLineData(lineNumber);\n        }\n        getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n            let result = this.lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n            return new viewModel_1.MinimapLinesRenderingData(this.getTabSize(), result);\n        }\n        getAllOverviewRulerDecorations(theme) {\n            return this.lines.getAllOverviewRulerDecorations(this.editorId, this.configuration.editor.readOnly, theme);\n        }\n        invalidateOverviewRulerColorCache() {\n            const decorations = this.model.getOverviewRulerDecorations();\n            for (const decoration of decorations) {\n                const opts = decoration.options.overviewRuler;\n                if (opts) {\n                    opts.invalidateCachedColor();\n                }\n            }\n        }\n        getValueInRange(range, eol) {\n            const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n            return this.model.getValueInRange(modelRange, eol);\n        }\n        getModelLineMaxColumn(modelLineNumber) {\n            return this.model.getLineMaxColumn(modelLineNumber);\n        }\n        validateModelPosition(position) {\n            return this.model.validatePosition(position);\n        }\n        validateModelRange(range) {\n            return this.model.validateRange(range);\n        }\n        deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n            const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n            if (this.model.getEOL().length === 2) {\n                // This model uses CRLF, so the delta must take that into account\n                if (deltaOffset < 0) {\n                    deltaOffset -= lineFeedCnt;\n                }\n                else {\n                    deltaOffset += lineFeedCnt;\n                }\n            }\n            const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n            const resultOffset = modelAnchorOffset + deltaOffset;\n            return this.model.getPositionAt(resultOffset);\n        }\n        getEOL() {\n            return this.model.getEOL();\n        }\n        getPlainTextToCopy(ranges, emptySelectionClipboard, forceCRLF) {\n            const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n            ranges = ranges.slice(0);\n            ranges.sort(range_1.Range.compareRangesUsingStarts);\n            const nonEmptyRanges = ranges.filter((r) => !r.isEmpty());\n            if (nonEmptyRanges.length === 0) {\n                if (!emptySelectionClipboard) {\n                    return '';\n                }\n                const modelLineNumbers = ranges.map((r) => {\n                    const viewLineStart = new position_1.Position(r.startLineNumber, 1);\n                    return this.coordinatesConverter.convertViewPositionToModelPosition(viewLineStart).lineNumber;\n                });\n                let result = '';\n                for (let i = 0; i < modelLineNumbers.length; i++) {\n                    if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n                        continue;\n                    }\n                    result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n                }\n                return result;\n            }\n            let result = [];\n            for (const nonEmptyRange of nonEmptyRanges) {\n                result.push(this.getValueInRange(nonEmptyRange, forceCRLF ? model_1.EndOfLinePreference.CRLF : model_1.EndOfLinePreference.TextDefined));\n            }\n            return result.length === 1 ? result[0] : result;\n        }\n        getHTMLToCopy(viewRanges, emptySelectionClipboard) {\n            if (this.model.getLanguageIdentifier().id === modes_1.LanguageId.PlainText) {\n                return null;\n            }\n            if (viewRanges.length !== 1) {\n                // no multiple selection support at this time\n                return null;\n            }\n            let range = this.coordinatesConverter.convertViewRangeToModelRange(viewRanges[0]);\n            if (range.isEmpty()) {\n                if (!emptySelectionClipboard) {\n                    // nothing to copy\n                    return null;\n                }\n                let lineNumber = range.startLineNumber;\n                range = new range_1.Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n            }\n            const fontInfo = this.configuration.editor.fontInfo;\n            const colorMap = this._getColorMap();\n            return (`<div style=\"`\n                + `color: ${colorMap[modes_1.ColorId.DefaultForeground]};`\n                + `background-color: ${colorMap[modes_1.ColorId.DefaultBackground]};`\n                + `font-family: ${fontInfo.fontFamily};`\n                + `font-weight: ${fontInfo.fontWeight};`\n                + `font-size: ${fontInfo.fontSize}px;`\n                + `line-height: ${fontInfo.lineHeight}px;`\n                + `white-space: pre;`\n                + `\">`\n                + this._getHTMLToCopy(range, colorMap)\n                + '</div>');\n        }\n        _getHTMLToCopy(modelRange, colorMap) {\n            const startLineNumber = modelRange.startLineNumber;\n            const startColumn = modelRange.startColumn;\n            const endLineNumber = modelRange.endLineNumber;\n            const endColumn = modelRange.endColumn;\n            const tabSize = this.getTabSize();\n            let result = '';\n            for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n                const lineTokens = this.model.getLineTokens(lineNumber);\n                const lineContent = lineTokens.getLineContent();\n                const startOffset = (lineNumber === startLineNumber ? startColumn - 1 : 0);\n                const endOffset = (lineNumber === endLineNumber ? endColumn - 1 : lineContent.length);\n                if (lineContent === '') {\n                    result += '<br>';\n                }\n                else {\n                    result += textToHtmlTokenizer_1.tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize);\n                }\n            }\n            return result;\n        }\n        _getColorMap() {\n            let colorMap = modes_1.TokenizationRegistry.getColorMap();\n            let result = ['#000000'];\n            if (colorMap) {\n                for (let i = 1, len = colorMap.length; i < len; i++) {\n                    result[i] = color_1.Color.Format.CSS.formatHex(colorMap[i]);\n                }\n            }\n            return result;\n        }\n    }\n    exports.ViewModel = ViewModel;\n});\n",null]}