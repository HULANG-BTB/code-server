{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/extpath.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/extpath.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/platform\", \"vs/base/common/strings\", \"vs/base/common/charCode\", \"vs/base/common/path\"], function (require, exports, platform_1, strings_1, charCode_1, path_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isPathSeparator(code) {\n        return code === charCode_1.CharCode.Slash || code === charCode_1.CharCode.Backslash;\n    }\n    /**\n     * Takes a Windows OS path and changes backward slashes to forward slashes.\n     * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n     * Using it on a Linux or MaxOS path might change it.\n     */\n    function toSlashes(osPath) {\n        return osPath.replace(/[\\\\/]/g, path_1.posix.sep);\n    }\n    exports.toSlashes = toSlashes;\n    /**\n     * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n     * `getRoot('files:///files/path') === files:///`,\n     * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n     */\n    function getRoot(path, sep = path_1.posix.sep) {\n        if (!path) {\n            return '';\n        }\n        const len = path.length;\n        const firstLetter = path.charCodeAt(0);\n        if (isPathSeparator(firstLetter)) {\n            if (isPathSeparator(path.charCodeAt(1))) {\n                // UNC candidate \\\\localhost\\shares\\ddd\n                //               ^^^^^^^^^^^^^^^^^^^\n                if (!isPathSeparator(path.charCodeAt(2))) {\n                    let pos = 3;\n                    const start = pos;\n                    for (; pos < len; pos++) {\n                        if (isPathSeparator(path.charCodeAt(pos))) {\n                            break;\n                        }\n                    }\n                    if (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n                        pos += 1;\n                        for (; pos < len; pos++) {\n                            if (isPathSeparator(path.charCodeAt(pos))) {\n                                return path.slice(0, pos + 1) // consume this separator\n                                    .replace(/[\\\\/]/g, sep);\n                            }\n                        }\n                    }\n                }\n            }\n            // /user/far\n            // ^\n            return sep;\n        }\n        else if (isWindowsDriveLetter(firstLetter)) {\n            // check for windows drive letter c:\\ or c:\n            if (path.charCodeAt(1) === charCode_1.CharCode.Colon) {\n                if (isPathSeparator(path.charCodeAt(2))) {\n                    // C:\\fff\n                    // ^^^\n                    return path.slice(0, 2) + sep;\n                }\n                else {\n                    // C:\n                    // ^^\n                    return path.slice(0, 2);\n                }\n            }\n        }\n        // check for URI\n        // scheme://authority/path\n        // ^^^^^^^^^^^^^^^^^^^\n        let pos = path.indexOf('://');\n        if (pos !== -1) {\n            pos += 3; // 3 -> \"://\".length\n            for (; pos < len; pos++) {\n                if (isPathSeparator(path.charCodeAt(pos))) {\n                    return path.slice(0, pos + 1); // consume this separator\n                }\n            }\n        }\n        return '';\n    }\n    exports.getRoot = getRoot;\n    /**\n     * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n     *\n     * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n     * @return A boolean indication if the path is a UNC path, on none-windows\n     * always false.\n     */\n    function isUNC(path) {\n        if (!platform_1.isWindows) {\n            // UNC is a windows concept\n            return false;\n        }\n        if (!path || path.length < 5) {\n            // at least \\\\a\\b\n            return false;\n        }\n        let code = path.charCodeAt(0);\n        if (code !== charCode_1.CharCode.Backslash) {\n            return false;\n        }\n        code = path.charCodeAt(1);\n        if (code !== charCode_1.CharCode.Backslash) {\n            return false;\n        }\n        let pos = 2;\n        const start = pos;\n        for (; pos < path.length; pos++) {\n            code = path.charCodeAt(pos);\n            if (code === charCode_1.CharCode.Backslash) {\n                break;\n            }\n        }\n        if (start === pos) {\n            return false;\n        }\n        code = path.charCodeAt(pos + 1);\n        if (isNaN(code) || code === charCode_1.CharCode.Backslash) {\n            return false;\n        }\n        return true;\n    }\n    exports.isUNC = isUNC;\n    // Reference: https://en.wikipedia.org/wiki/Filename\n    const INVALID_FILE_CHARS = platform_1.isWindows ? /[\\\\/:\\*\\?\"<>\\|]/g : /[\\\\/]/g;\n    const WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])$/i;\n    function isValidBasename(name) {\n        if (!name || name.length === 0 || /^\\s+$/.test(name)) {\n            return false; // require a name that is not just whitespace\n        }\n        INVALID_FILE_CHARS.lastIndex = 0; // the holy grail of software development\n        if (INVALID_FILE_CHARS.test(name)) {\n            return false; // check for certain invalid file characters\n        }\n        if (platform_1.isWindows && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n            return false; // check for certain invalid file names\n        }\n        if (name === '.' || name === '..') {\n            return false; // check for reserved values\n        }\n        if (platform_1.isWindows && name[name.length - 1] === '.') {\n            return false; // Windows: file cannot end with a \".\"\n        }\n        if (platform_1.isWindows && name.length !== name.trim().length) {\n            return false; // Windows: file cannot end with a whitespace\n        }\n        if (name.length > 255) {\n            return false; // most file systems do not allow files > 255 lenth\n        }\n        return true;\n    }\n    exports.isValidBasename = isValidBasename;\n    function isEqual(pathA, pathB, ignoreCase) {\n        const identityEquals = (pathA === pathB);\n        if (!ignoreCase || identityEquals) {\n            return identityEquals;\n        }\n        if (!pathA || !pathB) {\n            return false;\n        }\n        return strings_1.equalsIgnoreCase(pathA, pathB);\n    }\n    exports.isEqual = isEqual;\n    function isEqualOrParent(path, candidate, ignoreCase, separator = path_1.sep) {\n        if (path === candidate) {\n            return true;\n        }\n        if (!path || !candidate) {\n            return false;\n        }\n        if (candidate.length > path.length) {\n            return false;\n        }\n        if (ignoreCase) {\n            const beginsWith = strings_1.startsWithIgnoreCase(path, candidate);\n            if (!beginsWith) {\n                return false;\n            }\n            if (candidate.length === path.length) {\n                return true; // same path, different casing\n            }\n            let sepOffset = candidate.length;\n            if (candidate.charAt(candidate.length - 1) === separator) {\n                sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n            }\n            return path.charAt(sepOffset) === separator;\n        }\n        if (candidate.charAt(candidate.length - 1) !== separator) {\n            candidate += separator;\n        }\n        return path.indexOf(candidate) === 0;\n    }\n    exports.isEqualOrParent = isEqualOrParent;\n    function isWindowsDriveLetter(char0) {\n        return char0 >= charCode_1.CharCode.A && char0 <= charCode_1.CharCode.Z || char0 >= charCode_1.CharCode.a && char0 <= charCode_1.CharCode.z;\n    }\n    exports.isWindowsDriveLetter = isWindowsDriveLetter;\n});\n",null]}