{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/common/resources.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/common/resources.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/uri\", \"vs/base/common/objects\", \"vs/base/common/event\", \"vs/base/common/resources\", \"vs/platform/contextkey/common/contextkey\", \"vs/editor/common/services/modeService\", \"vs/platform/files/common/files\", \"vs/base/common/lifecycle\", \"vs/base/common/glob\", \"vs/platform/workspace/common/workspace\", \"vs/platform/configuration/common/configuration\", \"vs/base/common/types\"], function (require, exports, uri_1, objects, event_1, resources_1, contextkey_1, modeService_1, files_1, lifecycle_1, glob_1, workspace_1, configuration_1, types_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let ResourceContextKey = class ResourceContextKey extends lifecycle_1.Disposable {\n        constructor(contextKeyService, _fileService, _modeService) {\n            super();\n            this._fileService = _fileService;\n            this._modeService = _modeService;\n            this._schemeKey = ResourceContextKey.Scheme.bindTo(contextKeyService);\n            this._filenameKey = ResourceContextKey.Filename.bindTo(contextKeyService);\n            this._langIdKey = ResourceContextKey.LangId.bindTo(contextKeyService);\n            this._resourceKey = ResourceContextKey.Resource.bindTo(contextKeyService);\n            this._extensionKey = ResourceContextKey.Extension.bindTo(contextKeyService);\n            this._hasResource = ResourceContextKey.HasResource.bindTo(contextKeyService);\n            this._isFileSystemResource = ResourceContextKey.IsFileSystemResource.bindTo(contextKeyService);\n            this._register(_fileService.onDidChangeFileSystemProviderRegistrations(() => {\n                const resource = this._resourceKey.get();\n                this._isFileSystemResource.set(Boolean(resource && _fileService.canHandleResource(resource)));\n            }));\n            this._register(_modeService.onDidCreateMode(() => {\n                const value = this._resourceKey.get();\n                this._langIdKey.set(value ? this._modeService.getModeIdByFilepathOrFirstLine(value.fsPath) : null);\n            }));\n        }\n        set(value) {\n            if (!ResourceContextKey._uriEquals(this._resourceKey.get(), value)) {\n                this._resourceKey.set(value);\n                this._schemeKey.set(value ? value.scheme : null);\n                this._filenameKey.set(value ? resources_1.basename(value) : null);\n                this._langIdKey.set(value ? this._modeService.getModeIdByFilepathOrFirstLine(value.fsPath) : null);\n                this._extensionKey.set(value ? resources_1.extname(value) : null);\n                this._hasResource.set(!!value);\n                this._isFileSystemResource.set(value ? this._fileService.canHandleResource(value) : false);\n            }\n        }\n        reset() {\n            this._schemeKey.reset();\n            this._langIdKey.reset();\n            this._resourceKey.reset();\n            this._langIdKey.reset();\n            this._extensionKey.reset();\n            this._hasResource.reset();\n            this._isFileSystemResource.reset();\n        }\n        get() {\n            return types_1.withNullAsUndefined(this._resourceKey.get());\n        }\n        static _uriEquals(a, b) {\n            if (a === b) {\n                return true;\n            }\n            if (!a || !b) {\n                return false;\n            }\n            return a.scheme === b.scheme // checks for not equals (fail fast)\n                && a.authority === b.authority\n                && a.path === b.path\n                && a.query === b.query\n                && a.fragment === b.fragment\n                && a.toString() === b.toString(); // for equal we use the normalized toString-form\n        }\n    };\n    ResourceContextKey.Scheme = new contextkey_1.RawContextKey('resourceScheme', undefined);\n    ResourceContextKey.Filename = new contextkey_1.RawContextKey('resourceFilename', undefined);\n    ResourceContextKey.LangId = new contextkey_1.RawContextKey('resourceLangId', undefined);\n    ResourceContextKey.Resource = new contextkey_1.RawContextKey('resource', undefined);\n    ResourceContextKey.Extension = new contextkey_1.RawContextKey('resourceExtname', undefined);\n    ResourceContextKey.HasResource = new contextkey_1.RawContextKey('resourceSet', false);\n    ResourceContextKey.IsFileSystemResource = new contextkey_1.RawContextKey('isFileSystemResource', false);\n    ResourceContextKey = __decorate([\n        __param(0, contextkey_1.IContextKeyService),\n        __param(1, files_1.IFileService),\n        __param(2, modeService_1.IModeService)\n    ], ResourceContextKey);\n    exports.ResourceContextKey = ResourceContextKey;\n    let ResourceGlobMatcher = class ResourceGlobMatcher extends lifecycle_1.Disposable {\n        constructor(globFn, shouldUpdate, contextService, configurationService) {\n            super();\n            this.globFn = globFn;\n            this.shouldUpdate = shouldUpdate;\n            this.contextService = contextService;\n            this.configurationService = configurationService;\n            this._onExpressionChange = this._register(new event_1.Emitter());\n            this.mapRootToParsedExpression = new Map();\n            this.mapRootToExpressionConfig = new Map();\n            this.updateExcludes(false);\n            this.registerListeners();\n        }\n        get onExpressionChange() { return this._onExpressionChange.event; }\n        registerListeners() {\n            this._register(this.configurationService.onDidChangeConfiguration(e => {\n                if (this.shouldUpdate(e)) {\n                    this.updateExcludes(true);\n                }\n            }));\n            this._register(this.contextService.onDidChangeWorkspaceFolders(() => this.updateExcludes(true)));\n        }\n        updateExcludes(fromEvent) {\n            let changed = false;\n            // Add excludes per workspaces that got added\n            this.contextService.getWorkspace().folders.forEach(folder => {\n                const rootExcludes = this.globFn(folder.uri);\n                if (!this.mapRootToExpressionConfig.has(folder.uri.toString()) || !objects.equals(this.mapRootToExpressionConfig.get(folder.uri.toString()), rootExcludes)) {\n                    changed = true;\n                    this.mapRootToParsedExpression.set(folder.uri.toString(), glob_1.parse(rootExcludes));\n                    this.mapRootToExpressionConfig.set(folder.uri.toString(), objects.deepClone(rootExcludes));\n                }\n            });\n            // Remove excludes per workspace no longer present\n            this.mapRootToExpressionConfig.forEach((value, root) => {\n                if (root === ResourceGlobMatcher.NO_ROOT) {\n                    return; // always keep this one\n                }\n                if (root && !this.contextService.getWorkspaceFolder(uri_1.URI.parse(root))) {\n                    this.mapRootToParsedExpression.delete(root);\n                    this.mapRootToExpressionConfig.delete(root);\n                    changed = true;\n                }\n            });\n            // Always set for resources outside root as well\n            const globalExcludes = this.globFn();\n            if (!this.mapRootToExpressionConfig.has(ResourceGlobMatcher.NO_ROOT) || !objects.equals(this.mapRootToExpressionConfig.get(ResourceGlobMatcher.NO_ROOT), globalExcludes)) {\n                changed = true;\n                this.mapRootToParsedExpression.set(ResourceGlobMatcher.NO_ROOT, glob_1.parse(globalExcludes));\n                this.mapRootToExpressionConfig.set(ResourceGlobMatcher.NO_ROOT, objects.deepClone(globalExcludes));\n            }\n            if (fromEvent && changed) {\n                this._onExpressionChange.fire();\n            }\n        }\n        matches(resource) {\n            const folder = this.contextService.getWorkspaceFolder(resource);\n            let expressionForRoot;\n            if (folder && this.mapRootToParsedExpression.has(folder.uri.toString())) {\n                expressionForRoot = this.mapRootToParsedExpression.get(folder.uri.toString());\n            }\n            else {\n                expressionForRoot = this.mapRootToParsedExpression.get(ResourceGlobMatcher.NO_ROOT);\n            }\n            // If the resource if from a workspace, convert its absolute path to a relative\n            // path so that glob patterns have a higher probability to match. For example\n            // a glob pattern of \"src/**\" will not match on an absolute path \"/folder/src/file.txt\"\n            // but can match on \"src/file.txt\"\n            let resourcePathToMatch;\n            if (folder) {\n                resourcePathToMatch = resources_1.relativePath(folder.uri, resource); // always uses forward slashes\n            }\n            else {\n                resourcePathToMatch = resource.fsPath; // TODO@isidor: support non-file URIs\n            }\n            return !!expressionForRoot(resourcePathToMatch);\n        }\n    };\n    ResourceGlobMatcher.NO_ROOT = null;\n    ResourceGlobMatcher = __decorate([\n        __param(2, workspace_1.IWorkspaceContextService),\n        __param(3, configuration_1.IConfigurationService)\n    ], ResourceGlobMatcher);\n    exports.ResourceGlobMatcher = ResourceGlobMatcher;\n});\n",null]}