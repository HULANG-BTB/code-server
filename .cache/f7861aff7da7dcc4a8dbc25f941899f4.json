{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/strings.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/strings.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/charCode\"], function (require, exports, charCode_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * The empty string.\n     */\n    exports.empty = '';\n    function isFalsyOrWhitespace(str) {\n        if (!str || typeof str !== 'string') {\n            return true;\n        }\n        return str.trim().length === 0;\n    }\n    exports.isFalsyOrWhitespace = isFalsyOrWhitespace;\n    /**\n     * @returns the provided number with the given number of preceding zeros.\n     */\n    function pad(n, l, char = '0') {\n        const str = '' + n;\n        const r = [str];\n        for (let i = str.length; i < l; i++) {\n            r.push(char);\n        }\n        return r.reverse().join('');\n    }\n    exports.pad = pad;\n    const _formatRegexp = /{(\\d+)}/g;\n    /**\n     * Helper to produce a string with a variable number of arguments. Insert variable segments\n     * into the string using the {n} notation where N is the index of the argument following the string.\n     * @param value string to which formatting is applied\n     * @param args replacements for {n}-entries\n     */\n    function format(value, ...args) {\n        if (args.length === 0) {\n            return value;\n        }\n        return value.replace(_formatRegexp, function (match, group) {\n            const idx = parseInt(group, 10);\n            return isNaN(idx) || idx < 0 || idx >= args.length ?\n                match :\n                args[idx];\n        });\n    }\n    exports.format = format;\n    /**\n     * Converts HTML characters inside the string to use entities instead. Makes the string safe from\n     * being used e.g. in HTMLElement.innerHTML.\n     */\n    function escape(html) {\n        return html.replace(/[<>&]/g, function (match) {\n            switch (match) {\n                case '<': return '&lt;';\n                case '>': return '&gt;';\n                case '&': return '&amp;';\n                default: return match;\n            }\n        });\n    }\n    exports.escape = escape;\n    /**\n     * Escapes regular expression characters in a given string\n     */\n    function escapeRegExpCharacters(value) {\n        return value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)\\#]/g, '\\\\$&');\n    }\n    exports.escapeRegExpCharacters = escapeRegExpCharacters;\n    /**\n     * Removes all occurrences of needle from the beginning and end of haystack.\n     * @param haystack string to trim\n     * @param needle the thing to trim (default is a blank)\n     */\n    function trim(haystack, needle = ' ') {\n        const trimmed = ltrim(haystack, needle);\n        return rtrim(trimmed, needle);\n    }\n    exports.trim = trim;\n    /**\n     * Removes all occurrences of needle from the beginning of haystack.\n     * @param haystack string to trim\n     * @param needle the thing to trim\n     */\n    function ltrim(haystack, needle) {\n        if (!haystack || !needle) {\n            return haystack;\n        }\n        const needleLen = needle.length;\n        if (needleLen === 0 || haystack.length === 0) {\n            return haystack;\n        }\n        let offset = 0;\n        while (haystack.indexOf(needle, offset) === offset) {\n            offset = offset + needleLen;\n        }\n        return haystack.substring(offset);\n    }\n    exports.ltrim = ltrim;\n    /**\n     * Removes all occurrences of needle from the end of haystack.\n     * @param haystack string to trim\n     * @param needle the thing to trim\n     */\n    function rtrim(haystack, needle) {\n        if (!haystack || !needle) {\n            return haystack;\n        }\n        const needleLen = needle.length, haystackLen = haystack.length;\n        if (needleLen === 0 || haystackLen === 0) {\n            return haystack;\n        }\n        let offset = haystackLen, idx = -1;\n        while (true) {\n            idx = haystack.lastIndexOf(needle, offset - 1);\n            if (idx === -1 || idx + needleLen !== offset) {\n                break;\n            }\n            if (idx === 0) {\n                return '';\n            }\n            offset = idx;\n        }\n        return haystack.substring(0, offset);\n    }\n    exports.rtrim = rtrim;\n    function convertSimple2RegExpPattern(pattern) {\n        return pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n    }\n    exports.convertSimple2RegExpPattern = convertSimple2RegExpPattern;\n    function stripWildcards(pattern) {\n        return pattern.replace(/\\*/g, '');\n    }\n    exports.stripWildcards = stripWildcards;\n    /**\n     * Determines if haystack starts with needle.\n     */\n    function startsWith(haystack, needle) {\n        if (haystack.length < needle.length) {\n            return false;\n        }\n        if (haystack === needle) {\n            return true;\n        }\n        for (let i = 0; i < needle.length; i++) {\n            if (haystack[i] !== needle[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    exports.startsWith = startsWith;\n    /**\n     * Determines if haystack ends with needle.\n     */\n    function endsWith(haystack, needle) {\n        const diff = haystack.length - needle.length;\n        if (diff > 0) {\n            return haystack.indexOf(needle, diff) === diff;\n        }\n        else if (diff === 0) {\n            return haystack === needle;\n        }\n        else {\n            return false;\n        }\n    }\n    exports.endsWith = endsWith;\n    function createRegExp(searchString, isRegex, options = {}) {\n        if (!searchString) {\n            throw new Error('Cannot create regex from empty string');\n        }\n        if (!isRegex) {\n            searchString = escapeRegExpCharacters(searchString);\n        }\n        if (options.wholeWord) {\n            if (!/\\B/.test(searchString.charAt(0))) {\n                searchString = '\\\\b' + searchString;\n            }\n            if (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\n                searchString = searchString + '\\\\b';\n            }\n        }\n        let modifiers = '';\n        if (options.global) {\n            modifiers += 'g';\n        }\n        if (!options.matchCase) {\n            modifiers += 'i';\n        }\n        if (options.multiline) {\n            modifiers += 'm';\n        }\n        if (options.unicode) {\n            modifiers += 'u';\n        }\n        return new RegExp(searchString, modifiers);\n    }\n    exports.createRegExp = createRegExp;\n    function regExpLeadsToEndlessLoop(regexp) {\n        // Exit early if it's one of these special cases which are meant to match\n        // against an empty string\n        if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\n            return false;\n        }\n        // We check against an empty string. If the regular expression doesn't advance\n        // (e.g. ends in an endless loop) it will match an empty string.\n        const match = regexp.exec('');\n        return !!(match && regexp.lastIndex === 0);\n    }\n    exports.regExpLeadsToEndlessLoop = regExpLeadsToEndlessLoop;\n    function regExpContainsBackreference(regexpValue) {\n        return !!regexpValue.match(/([^\\\\]|^)(\\\\\\\\)*\\\\\\d+/);\n    }\n    exports.regExpContainsBackreference = regExpContainsBackreference;\n    function regExpFlags(regexp) {\n        return (regexp.global ? 'g' : '')\n            + (regexp.ignoreCase ? 'i' : '')\n            + (regexp.multiline ? 'm' : '')\n            + (regexp.unicode ? 'u' : '');\n    }\n    exports.regExpFlags = regExpFlags;\n    /**\n     * Returns first index of the string that is not whitespace.\n     * If string is empty or contains only whitespaces, returns -1\n     */\n    function firstNonWhitespaceIndex(str) {\n        for (let i = 0, len = str.length; i < len; i++) {\n            const chCode = str.charCodeAt(i);\n            if (chCode !== charCode_1.CharCode.Space && chCode !== charCode_1.CharCode.Tab) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    exports.firstNonWhitespaceIndex = firstNonWhitespaceIndex;\n    /**\n     * Returns the leading whitespace of the string.\n     * If the string contains only whitespaces, returns entire string\n     */\n    function getLeadingWhitespace(str, start = 0, end = str.length) {\n        for (let i = start; i < end; i++) {\n            const chCode = str.charCodeAt(i);\n            if (chCode !== charCode_1.CharCode.Space && chCode !== charCode_1.CharCode.Tab) {\n                return str.substring(start, i);\n            }\n        }\n        return str.substring(start, end);\n    }\n    exports.getLeadingWhitespace = getLeadingWhitespace;\n    /**\n     * Returns last index of the string that is not whitespace.\n     * If string is empty or contains only whitespaces, returns -1\n     */\n    function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {\n        for (let i = startIndex; i >= 0; i--) {\n            const chCode = str.charCodeAt(i);\n            if (chCode !== charCode_1.CharCode.Space && chCode !== charCode_1.CharCode.Tab) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    exports.lastNonWhitespaceIndex = lastNonWhitespaceIndex;\n    function compare(a, b) {\n        if (a < b) {\n            return -1;\n        }\n        else if (a > b) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    exports.compare = compare;\n    function compareIgnoreCase(a, b) {\n        const len = Math.min(a.length, b.length);\n        for (let i = 0; i < len; i++) {\n            let codeA = a.charCodeAt(i);\n            let codeB = b.charCodeAt(i);\n            if (codeA === codeB) {\n                // equal\n                continue;\n            }\n            if (isUpperAsciiLetter(codeA)) {\n                codeA += 32;\n            }\n            if (isUpperAsciiLetter(codeB)) {\n                codeB += 32;\n            }\n            const diff = codeA - codeB;\n            if (diff === 0) {\n                // equal -> ignoreCase\n                continue;\n            }\n            else if (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {\n                //\n                return diff;\n            }\n            else {\n                return compare(a.toLowerCase(), b.toLowerCase());\n            }\n        }\n        if (a.length < b.length) {\n            return -1;\n        }\n        else if (a.length > b.length) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    exports.compareIgnoreCase = compareIgnoreCase;\n    function isLowerAsciiLetter(code) {\n        return code >= charCode_1.CharCode.a && code <= charCode_1.CharCode.z;\n    }\n    exports.isLowerAsciiLetter = isLowerAsciiLetter;\n    function isUpperAsciiLetter(code) {\n        return code >= charCode_1.CharCode.A && code <= charCode_1.CharCode.Z;\n    }\n    exports.isUpperAsciiLetter = isUpperAsciiLetter;\n    function isAsciiLetter(code) {\n        return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);\n    }\n    function equalsIgnoreCase(a, b) {\n        const len1 = a ? a.length : 0;\n        const len2 = b ? b.length : 0;\n        if (len1 !== len2) {\n            return false;\n        }\n        return doEqualsIgnoreCase(a, b);\n    }\n    exports.equalsIgnoreCase = equalsIgnoreCase;\n    function doEqualsIgnoreCase(a, b, stopAt = a.length) {\n        if (typeof a !== 'string' || typeof b !== 'string') {\n            return false;\n        }\n        for (let i = 0; i < stopAt; i++) {\n            const codeA = a.charCodeAt(i);\n            const codeB = b.charCodeAt(i);\n            if (codeA === codeB) {\n                continue;\n            }\n            // a-z A-Z\n            if (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {\n                const diff = Math.abs(codeA - codeB);\n                if (diff !== 0 && diff !== 32) {\n                    return false;\n                }\n            }\n            // Any other charcode\n            else {\n                if (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    function startsWithIgnoreCase(str, candidate) {\n        const candidateLength = candidate.length;\n        if (candidate.length > str.length) {\n            return false;\n        }\n        return doEqualsIgnoreCase(str, candidate, candidateLength);\n    }\n    exports.startsWithIgnoreCase = startsWithIgnoreCase;\n    /**\n     * @returns the length of the common prefix of the two strings.\n     */\n    function commonPrefixLength(a, b) {\n        let i, len = Math.min(a.length, b.length);\n        for (i = 0; i < len; i++) {\n            if (a.charCodeAt(i) !== b.charCodeAt(i)) {\n                return i;\n            }\n        }\n        return len;\n    }\n    exports.commonPrefixLength = commonPrefixLength;\n    /**\n     * @returns the length of the common suffix of the two strings.\n     */\n    function commonSuffixLength(a, b) {\n        let i, len = Math.min(a.length, b.length);\n        const aLastIndex = a.length - 1;\n        const bLastIndex = b.length - 1;\n        for (i = 0; i < len; i++) {\n            if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\n                return i;\n            }\n        }\n        return len;\n    }\n    exports.commonSuffixLength = commonSuffixLength;\n    function substrEquals(a, aStart, aEnd, b, bStart, bEnd) {\n        while (aStart < aEnd && bStart < bEnd) {\n            if (a[aStart] !== b[bStart]) {\n                return false;\n            }\n            aStart += 1;\n            bStart += 1;\n        }\n        return true;\n    }\n    /**\n     * Return the overlap between the suffix of `a` and the prefix of `b`.\n     * For instance `overlap(\"foobar\", \"arr, I'm a pirate\") === 2`.\n     */\n    function overlap(a, b) {\n        const aEnd = a.length;\n        let bEnd = b.length;\n        let aStart = aEnd - bEnd;\n        if (aStart === 0) {\n            return a === b ? aEnd : 0;\n        }\n        else if (aStart < 0) {\n            bEnd += aStart;\n            aStart = 0;\n        }\n        while (aStart < aEnd && bEnd > 0) {\n            if (substrEquals(a, aStart, aEnd, b, 0, bEnd)) {\n                return bEnd;\n            }\n            bEnd -= 1;\n            aStart += 1;\n        }\n        return 0;\n    }\n    exports.overlap = overlap;\n    // --- unicode\n    // http://en.wikipedia.org/wiki/Surrogate_pair\n    // Returns the code point starting at a specified index in a string\n    // Code points U+0000 to U+D7FF and U+E000 to U+FFFF are represented on a single character\n    // Code points U+10000 to U+10FFFF are represented on two consecutive characters\n    //export function getUnicodePoint(str:string, index:number, len:number):number {\n    //\tconst chrCode = str.charCodeAt(index);\n    //\tif (0xD800 <= chrCode && chrCode <= 0xDBFF && index + 1 < len) {\n    //\t\tconst nextChrCode = str.charCodeAt(index + 1);\n    //\t\tif (0xDC00 <= nextChrCode && nextChrCode <= 0xDFFF) {\n    //\t\t\treturn (chrCode - 0xD800) << 10 + (nextChrCode - 0xDC00) + 0x10000;\n    //\t\t}\n    //\t}\n    //\treturn chrCode;\n    //}\n    function isHighSurrogate(charCode) {\n        return (0xD800 <= charCode && charCode <= 0xDBFF);\n    }\n    exports.isHighSurrogate = isHighSurrogate;\n    function isLowSurrogate(charCode) {\n        return (0xDC00 <= charCode && charCode <= 0xDFFF);\n    }\n    exports.isLowSurrogate = isLowSurrogate;\n    /**\n     * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-rtl-test.js\n     */\n    const CONTAINS_RTL = /(?:[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1-\\u07EA\\u07F4\\u07F5\\u07FA-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E-\\u08BD\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFD3D\\uFD50-\\uFDFC\\uFE70-\\uFEFC]|\\uD802[\\uDC00-\\uDD1B\\uDD20-\\uDE00\\uDE10-\\uDE33\\uDE40-\\uDEE4\\uDEEB-\\uDF35\\uDF40-\\uDFFF]|\\uD803[\\uDC00-\\uDCFF]|\\uD83A[\\uDC00-\\uDCCF\\uDD00-\\uDD43\\uDD50-\\uDFFF]|\\uD83B[\\uDC00-\\uDEBB])/;\n    /**\n     * Returns true if `str` contains any Unicode character that is classified as \"R\" or \"AL\".\n     */\n    function containsRTL(str) {\n        return CONTAINS_RTL.test(str);\n    }\n    exports.containsRTL = containsRTL;\n    /**\n     * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-emoji-test.js\n     */\n    const CONTAINS_EMOJI = /(?:[\\u231A\\u231B\\u23F0\\u23F3\\u2600-\\u27BF\\u2B50\\u2B55]|\\uD83C[\\uDDE6-\\uDDFF\\uDF00-\\uDFFF]|\\uD83D[\\uDC00-\\uDE4F\\uDE80-\\uDEF8]|\\uD83E[\\uDD00-\\uDDE6])/;\n    function containsEmoji(str) {\n        return CONTAINS_EMOJI.test(str);\n    }\n    exports.containsEmoji = containsEmoji;\n    const IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\n    /**\n     * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \\n, \\r, \\t\n     */\n    function isBasicASCII(str) {\n        return IS_BASIC_ASCII.test(str);\n    }\n    exports.isBasicASCII = isBasicASCII;\n    function containsFullWidthCharacter(str) {\n        for (let i = 0, len = str.length; i < len; i++) {\n            if (isFullWidthCharacter(str.charCodeAt(i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    exports.containsFullWidthCharacter = containsFullWidthCharacter;\n    function isFullWidthCharacter(charCode) {\n        // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\n        // http://jrgraphix.net/research/unicode_blocks.php\n        //          2E80 — 2EFF   CJK Radicals Supplement\n        //          2F00 — 2FDF   Kangxi Radicals\n        //          2FF0 — 2FFF   Ideographic Description Characters\n        //          3000 — 303F   CJK Symbols and Punctuation\n        //          3040 — 309F   Hiragana\n        //          30A0 — 30FF   Katakana\n        //          3100 — 312F   Bopomofo\n        //          3130 — 318F   Hangul Compatibility Jamo\n        //          3190 — 319F   Kanbun\n        //          31A0 — 31BF   Bopomofo Extended\n        //          31F0 — 31FF   Katakana Phonetic Extensions\n        //          3200 — 32FF   Enclosed CJK Letters and Months\n        //          3300 — 33FF   CJK Compatibility\n        //          3400 — 4DBF   CJK Unified Ideographs Extension A\n        //          4DC0 — 4DFF   Yijing Hexagram Symbols\n        //          4E00 — 9FFF   CJK Unified Ideographs\n        //          A000 — A48F   Yi Syllables\n        //          A490 — A4CF   Yi Radicals\n        //          AC00 — D7AF   Hangul Syllables\n        // [IGNORE] D800 — DB7F   High Surrogates\n        // [IGNORE] DB80 — DBFF   High Private Use Surrogates\n        // [IGNORE] DC00 — DFFF   Low Surrogates\n        // [IGNORE] E000 — F8FF   Private Use Area\n        //          F900 — FAFF   CJK Compatibility Ideographs\n        // [IGNORE] FB00 — FB4F   Alphabetic Presentation Forms\n        // [IGNORE] FB50 — FDFF   Arabic Presentation Forms-A\n        // [IGNORE] FE00 — FE0F   Variation Selectors\n        // [IGNORE] FE20 — FE2F   Combining Half Marks\n        // [IGNORE] FE30 — FE4F   CJK Compatibility Forms\n        // [IGNORE] FE50 — FE6F   Small Form Variants\n        // [IGNORE] FE70 — FEFF   Arabic Presentation Forms-B\n        //          FF00 — FFEF   Halfwidth and Fullwidth Forms\n        //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\n        //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\n        // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\n        // [IGNORE] FFF0 — FFFF   Specials\n        charCode = +charCode; // @perf\n        return ((charCode >= 0x2E80 && charCode <= 0xD7AF)\n            || (charCode >= 0xF900 && charCode <= 0xFAFF)\n            || (charCode >= 0xFF01 && charCode <= 0xFF5E));\n    }\n    exports.isFullWidthCharacter = isFullWidthCharacter;\n    /**\n     * Given a string and a max length returns a shorted version. Shorting\n     * happens at favorable positions - such as whitespace or punctuation characters.\n     */\n    function lcut(text, n) {\n        if (text.length < n) {\n            return text;\n        }\n        const re = /\\b/g;\n        let i = 0;\n        while (re.test(text)) {\n            if (text.length - re.lastIndex < n) {\n                break;\n            }\n            i = re.lastIndex;\n            re.lastIndex += 1;\n        }\n        return text.substring(i).replace(/^\\s/, exports.empty);\n    }\n    exports.lcut = lcut;\n    // Escape codes\n    // http://en.wikipedia.org/wiki/ANSI_escape_code\n    const EL = /\\x1B\\x5B[12]?K/g; // Erase in line\n    const COLOR_START = /\\x1b\\[\\d+m/g; // Color\n    const COLOR_END = /\\x1b\\[0?m/g; // Color\n    function removeAnsiEscapeCodes(str) {\n        if (str) {\n            str = str.replace(EL, '');\n            str = str.replace(COLOR_START, '');\n            str = str.replace(COLOR_END, '');\n        }\n        return str;\n    }\n    exports.removeAnsiEscapeCodes = removeAnsiEscapeCodes;\n    exports.removeAccents = (function () {\n        if (typeof String.prototype.normalize !== 'function') {\n            // ☹️ no ES6 features...\n            return function (str) { return str; };\n        }\n        else {\n            // transform into NFD form and remove accents\n            // see: https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript/37511463#37511463\n            const regex = /[\\u0300-\\u036f]/g;\n            return function (str) {\n                return str.normalize('NFD').replace(regex, exports.empty);\n            };\n        }\n    })();\n    // -- UTF-8 BOM\n    exports.UTF8_BOM_CHARACTER = String.fromCharCode(charCode_1.CharCode.UTF8_BOM);\n    function startsWithUTF8BOM(str) {\n        return !!(str && str.length > 0 && str.charCodeAt(0) === charCode_1.CharCode.UTF8_BOM);\n    }\n    exports.startsWithUTF8BOM = startsWithUTF8BOM;\n    function stripUTF8BOM(str) {\n        return startsWithUTF8BOM(str) ? str.substr(1) : str;\n    }\n    exports.stripUTF8BOM = stripUTF8BOM;\n    function safeBtoa(str) {\n        return btoa(encodeURIComponent(str)); // we use encodeURIComponent because btoa fails for non Latin 1 values\n    }\n    exports.safeBtoa = safeBtoa;\n    function repeat(s, count) {\n        let result = '';\n        for (let i = 0; i < count; i++) {\n            result += s;\n        }\n        return result;\n    }\n    exports.repeat = repeat;\n    /**\n     * Checks if the characters of the provided query string are included in the\n     * target string. The characters do not have to be contiguous within the string.\n     */\n    function fuzzyContains(target, query) {\n        if (!target || !query) {\n            return false; // return early if target or query are undefined\n        }\n        if (target.length < query.length) {\n            return false; // impossible for query to be contained in target\n        }\n        const queryLen = query.length;\n        const targetLower = target.toLowerCase();\n        let index = 0;\n        let lastIndexOf = -1;\n        while (index < queryLen) {\n            const indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);\n            if (indexOf < 0) {\n                return false;\n            }\n            lastIndexOf = indexOf;\n            index++;\n        }\n        return true;\n    }\n    exports.fuzzyContains = fuzzyContains;\n    function containsUppercaseCharacter(target, ignoreEscapedChars = false) {\n        if (!target) {\n            return false;\n        }\n        if (ignoreEscapedChars) {\n            target = target.replace(/\\\\./g, '');\n        }\n        return target.toLowerCase() !== target;\n    }\n    exports.containsUppercaseCharacter = containsUppercaseCharacter;\n    function uppercaseFirstLetter(str) {\n        return str.charAt(0).toUpperCase() + str.slice(1);\n    }\n    exports.uppercaseFirstLetter = uppercaseFirstLetter;\n    function getNLines(str, n = 1) {\n        if (n === 0) {\n            return '';\n        }\n        let idx = -1;\n        do {\n            idx = str.indexOf('\\n', idx + 1);\n            n--;\n        } while (n > 0 && idx >= 0);\n        return idx >= 0 ?\n            str.substr(0, idx) :\n            str;\n    }\n    exports.getNLines = getNLines;\n});\n",null]}