{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/editor/common/editorGroupsService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/editor/common/editorGroupsService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nexports.IEditorGroupsService = instantiation_1.createDecorator('editorGroupsService');\nvar GroupDirection;\n(function (GroupDirection) {\n    GroupDirection[GroupDirection[\"UP\"] = 0] = \"UP\";\n    GroupDirection[GroupDirection[\"DOWN\"] = 1] = \"DOWN\";\n    GroupDirection[GroupDirection[\"LEFT\"] = 2] = \"LEFT\";\n    GroupDirection[GroupDirection[\"RIGHT\"] = 3] = \"RIGHT\";\n})(GroupDirection = exports.GroupDirection || (exports.GroupDirection = {}));\nfunction preferredSideBySideGroupDirection(configurationService) {\n    var openSideBySideDirection = configurationService.getValue('workbench.editor.openSideBySideDirection');\n    if (openSideBySideDirection === 'down') {\n        return GroupDirection.DOWN;\n    }\n    return GroupDirection.RIGHT;\n}\nexports.preferredSideBySideGroupDirection = preferredSideBySideGroupDirection;\nvar GroupOrientation;\n(function (GroupOrientation) {\n    GroupOrientation[GroupOrientation[\"HORIZONTAL\"] = 0] = \"HORIZONTAL\";\n    GroupOrientation[GroupOrientation[\"VERTICAL\"] = 1] = \"VERTICAL\";\n})(GroupOrientation = exports.GroupOrientation || (exports.GroupOrientation = {}));\nvar GroupLocation;\n(function (GroupLocation) {\n    GroupLocation[GroupLocation[\"FIRST\"] = 0] = \"FIRST\";\n    GroupLocation[GroupLocation[\"LAST\"] = 1] = \"LAST\";\n    GroupLocation[GroupLocation[\"NEXT\"] = 2] = \"NEXT\";\n    GroupLocation[GroupLocation[\"PREVIOUS\"] = 3] = \"PREVIOUS\";\n})(GroupLocation = exports.GroupLocation || (exports.GroupLocation = {}));\nvar GroupsArrangement;\n(function (GroupsArrangement) {\n    /**\n     * Make the current active group consume the maximum\n     * amount of space possible.\n     */\n    GroupsArrangement[GroupsArrangement[\"MINIMIZE_OTHERS\"] = 0] = \"MINIMIZE_OTHERS\";\n    /**\n     * Size all groups evenly.\n     */\n    GroupsArrangement[GroupsArrangement[\"EVEN\"] = 1] = \"EVEN\";\n})(GroupsArrangement = exports.GroupsArrangement || (exports.GroupsArrangement = {}));\nvar MergeGroupMode;\n(function (MergeGroupMode) {\n    MergeGroupMode[MergeGroupMode[\"COPY_EDITORS\"] = 0] = \"COPY_EDITORS\";\n    MergeGroupMode[MergeGroupMode[\"MOVE_EDITORS\"] = 1] = \"MOVE_EDITORS\";\n})(MergeGroupMode = exports.MergeGroupMode || (exports.MergeGroupMode = {}));\nvar GroupsOrder;\n(function (GroupsOrder) {\n    /**\n     * Groups sorted by creation order (oldest one first)\n     */\n    GroupsOrder[GroupsOrder[\"CREATION_TIME\"] = 0] = \"CREATION_TIME\";\n    /**\n     * Groups sorted by most recent activity (most recent active first)\n     */\n    GroupsOrder[GroupsOrder[\"MOST_RECENTLY_ACTIVE\"] = 1] = \"MOST_RECENTLY_ACTIVE\";\n    /**\n     * Groups sorted by grid widget order\n     */\n    GroupsOrder[GroupsOrder[\"GRID_APPEARANCE\"] = 2] = \"GRID_APPEARANCE\";\n})(GroupsOrder = exports.GroupsOrder || (exports.GroupsOrder = {}));\nvar EditorsOrder;\n(function (EditorsOrder) {\n    /**\n     * Editors sorted by most recent activity (most recent active first)\n     */\n    EditorsOrder[EditorsOrder[\"MOST_RECENTLY_ACTIVE\"] = 0] = \"MOST_RECENTLY_ACTIVE\";\n    /**\n     * Editors sorted by sequential order\n     */\n    EditorsOrder[EditorsOrder[\"SEQUENTIAL\"] = 1] = \"SEQUENTIAL\";\n})(EditorsOrder = exports.EditorsOrder || (exports.EditorsOrder = {}));\nvar GroupChangeKind;\n(function (GroupChangeKind) {\n    /* Group Changes */\n    GroupChangeKind[GroupChangeKind[\"GROUP_ACTIVE\"] = 0] = \"GROUP_ACTIVE\";\n    GroupChangeKind[GroupChangeKind[\"GROUP_LABEL\"] = 1] = \"GROUP_LABEL\";\n    /* Editor Changes */\n    GroupChangeKind[GroupChangeKind[\"EDITOR_OPEN\"] = 2] = \"EDITOR_OPEN\";\n    GroupChangeKind[GroupChangeKind[\"EDITOR_CLOSE\"] = 3] = \"EDITOR_CLOSE\";\n    GroupChangeKind[GroupChangeKind[\"EDITOR_MOVE\"] = 4] = \"EDITOR_MOVE\";\n    GroupChangeKind[GroupChangeKind[\"EDITOR_ACTIVE\"] = 5] = \"EDITOR_ACTIVE\";\n    GroupChangeKind[GroupChangeKind[\"EDITOR_LABEL\"] = 6] = \"EDITOR_LABEL\";\n    GroupChangeKind[GroupChangeKind[\"EDITOR_PIN\"] = 7] = \"EDITOR_PIN\";\n    GroupChangeKind[GroupChangeKind[\"EDITOR_DIRTY\"] = 8] = \"EDITOR_DIRTY\";\n})(GroupChangeKind = exports.GroupChangeKind || (exports.GroupChangeKind = {}));\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/editor/common/editorGroupsService.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/editor/common/editorGroupsService.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;AAGhG,gFAAsH;AAQzG,QAAA,oBAAoB,GAAG,+BAAe,CAAuB,qBAAqB,CAAC,CAAC;AAEjG,IAAkB,cAKjB;AALD,WAAkB,cAAc;IAC/B,+CAAE,CAAA;IACF,mDAAI,CAAA;IACJ,mDAAI,CAAA;IACJ,qDAAK,CAAA;AACN,CAAC,EALiB,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAK/B;AAED,SAAgB,iCAAiC,CAAC,oBAA2C;IAC5F,IAAM,uBAAuB,GAAG,oBAAoB,CAAC,QAAQ,CAAmB,0CAA0C,CAAC,CAAC;IAE5H,IAAI,uBAAuB,KAAK,MAAM,EAAE;QACvC,OAAO,cAAc,CAAC,IAAI,CAAC;KAC3B;IAED,OAAO,cAAc,CAAC,KAAK,CAAC;AAC7B,CAAC;AARD,8EAQC;AAED,IAAkB,gBAGjB;AAHD,WAAkB,gBAAgB;IACjC,mEAAU,CAAA;IACV,+DAAQ,CAAA;AACT,CAAC,EAHiB,gBAAgB,GAAhB,wBAAgB,KAAhB,wBAAgB,QAGjC;AAED,IAAkB,aAKjB;AALD,WAAkB,aAAa;IAC9B,mDAAK,CAAA;IACL,iDAAI,CAAA;IACJ,iDAAI,CAAA;IACJ,yDAAQ,CAAA;AACT,CAAC,EALiB,aAAa,GAAb,qBAAa,KAAb,qBAAa,QAK9B;AAOD,IAAkB,iBAYjB;AAZD,WAAkB,iBAAiB;IAElC;;;OAGG;IACH,+EAAe,CAAA;IAEf;;OAEG;IACH,yDAAI,CAAA;AACL,CAAC,EAZiB,iBAAiB,GAAjB,yBAAiB,KAAjB,yBAAiB,QAYlC;AA4BD,IAAkB,cAGjB;AAHD,WAAkB,cAAc;IAC/B,mEAAY,CAAA;IACZ,mEAAY,CAAA;AACb,CAAC,EAHiB,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAG/B;AAmBD,IAAkB,WAgBjB;AAhBD,WAAkB,WAAW;IAE5B;;OAEG;IACH,+DAAa,CAAA;IAEb;;OAEG;IACH,6EAAoB,CAAA;IAEpB;;OAEG;IACH,mEAAe,CAAA;AAChB,CAAC,EAhBiB,WAAW,GAAX,mBAAW,KAAX,mBAAW,QAgB5B;AAED,IAAkB,YAWjB;AAXD,WAAkB,YAAY;IAE7B;;OAEG;IACH,+EAAoB,CAAA;IAEpB;;OAEG;IACH,2DAAU,CAAA;AACX,CAAC,EAXiB,YAAY,GAAZ,oBAAY,KAAZ,oBAAY,QAW7B;AAmMD,IAAkB,eAcjB;AAdD,WAAkB,eAAe;IAEhC,mBAAmB;IACnB,qEAAY,CAAA;IACZ,mEAAW,CAAA;IAEX,oBAAoB;IACpB,mEAAW,CAAA;IACX,qEAAY,CAAA;IACZ,mEAAW,CAAA;IACX,uEAAa,CAAA;IACb,qEAAY,CAAA;IACZ,iEAAU,CAAA;IACV,qEAAY,CAAA;AACb,CAAC,EAdiB,eAAe,GAAf,uBAAe,KAAf,uBAAe,QAchC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { createDecorator, ServiceIdentifier, ServicesAccessor } from 'vs/platform/instantiation/common/instantiation';\nimport { IEditorInput, IEditor, GroupIdentifier, IEditorInputWithOptions, CloseDirection, IEditorPartOptions } from 'vs/workbench/common/editor';\nimport { IEditorOptions, ITextEditorOptions } from 'vs/platform/editor/common/editor';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { IVisibleEditor } from 'vs/workbench/services/editor/common/editorService';\nimport { IDimension } from 'vs/editor/common/editorCommon';\nimport { IDisposable } from 'vs/base/common/lifecycle';\n\nexport const IEditorGroupsService = createDecorator<IEditorGroupsService>('editorGroupsService');\n\nexport const enum GroupDirection {\n\tUP,\n\tDOWN,\n\tLEFT,\n\tRIGHT\n}\n\nexport function preferredSideBySideGroupDirection(configurationService: IConfigurationService): GroupDirection.DOWN | GroupDirection.RIGHT {\n\tconst openSideBySideDirection = configurationService.getValue<'right' | 'down'>('workbench.editor.openSideBySideDirection');\n\n\tif (openSideBySideDirection === 'down') {\n\t\treturn GroupDirection.DOWN;\n\t}\n\n\treturn GroupDirection.RIGHT;\n}\n\nexport const enum GroupOrientation {\n\tHORIZONTAL,\n\tVERTICAL\n}\n\nexport const enum GroupLocation {\n\tFIRST,\n\tLAST,\n\tNEXT,\n\tPREVIOUS\n}\n\nexport interface IFindGroupScope {\n\tdirection?: GroupDirection;\n\tlocation?: GroupLocation;\n}\n\nexport const enum GroupsArrangement {\n\n\t/**\n\t * Make the current active group consume the maximum\n\t * amount of space possible.\n\t */\n\tMINIMIZE_OTHERS,\n\n\t/**\n\t * Size all groups evenly.\n\t */\n\tEVEN\n}\n\nexport interface GroupLayoutArgument {\n\tsize?: number;\n\tgroups?: GroupLayoutArgument[];\n}\n\nexport interface EditorGroupLayout {\n\torientation: GroupOrientation;\n\tgroups: GroupLayoutArgument[];\n}\n\nexport interface ICloseEditorOptions {\n\tpreserveFocus?: boolean;\n}\n\nexport interface IMoveEditorOptions {\n\tindex?: number;\n\tinactive?: boolean;\n\tpreserveFocus?: boolean;\n}\n\nexport interface ICopyEditorOptions extends IMoveEditorOptions { }\n\nexport interface IAddGroupOptions {\n\tactivate?: boolean;\n}\n\nexport const enum MergeGroupMode {\n\tCOPY_EDITORS,\n\tMOVE_EDITORS\n}\n\nexport interface IMergeGroupOptions {\n\tmode?: MergeGroupMode;\n\tindex?: number;\n}\n\nexport type ICloseEditorsFilter = {\n\texcept?: IEditorInput,\n\tdirection?: CloseDirection,\n\tsavedOnly?: boolean\n};\n\nexport interface IEditorReplacement {\n\teditor: IEditorInput;\n\treplacement: IEditorInput;\n\toptions?: IEditorOptions | ITextEditorOptions;\n}\n\nexport const enum GroupsOrder {\n\n\t/**\n\t * Groups sorted by creation order (oldest one first)\n\t */\n\tCREATION_TIME,\n\n\t/**\n\t * Groups sorted by most recent activity (most recent active first)\n\t */\n\tMOST_RECENTLY_ACTIVE,\n\n\t/**\n\t * Groups sorted by grid widget order\n\t */\n\tGRID_APPEARANCE\n}\n\nexport const enum EditorsOrder {\n\n\t/**\n\t * Editors sorted by most recent activity (most recent active first)\n\t */\n\tMOST_RECENTLY_ACTIVE,\n\n\t/**\n\t * Editors sorted by sequential order\n\t */\n\tSEQUENTIAL\n}\n\nexport interface IEditorGroupsService {\n\n\t_serviceBrand: ServiceIdentifier<any>;\n\n\t/**\n\t * An event for when the active editor group changes. The active editor\n\t * group is the default location for new editors to open.\n\t */\n\treadonly onDidActiveGroupChange: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a new group was added.\n\t */\n\treadonly onDidAddGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a group was removed.\n\t */\n\treadonly onDidRemoveGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a group was moved.\n\t */\n\treadonly onDidMoveGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when a group gets activated.\n\t */\n\treadonly onDidActivateGroup: Event<IEditorGroup>;\n\n\t/**\n\t * An event for when the group container is layed out.\n\t */\n\treadonly onDidLayout: Event<IDimension>;\n\n\t/**\n\t * The size of the editor groups area.\n\t */\n\treadonly dimension: IDimension;\n\n\t/**\n\t * An active group is the default location for new editors to open.\n\t */\n\treadonly activeGroup: IEditorGroup;\n\n\t/**\n\t * All groups that are currently visible in the editor area in the\n\t * order of their creation (oldest first).\n\t */\n\treadonly groups: ReadonlyArray<IEditorGroup>;\n\n\t/**\n\t * The number of editor groups that are currently opened.\n\t */\n\treadonly count: number;\n\n\t/**\n\t * The current layout orientation of the root group.\n\t */\n\treadonly orientation: GroupOrientation;\n\n\t/**\n\t * A promise that resolves when groups have been restored.\n\t */\n\treadonly whenRestored: Promise<void>;\n\n\t/**\n\t * Get all groups that are currently visible in the editor area optionally\n\t * sorted by being most recent active or grid order. Will sort by creation\n\t * time by default (oldest group first).\n\t */\n\tgetGroups(order?: GroupsOrder): ReadonlyArray<IEditorGroup>;\n\n\t/**\n\t * Allows to convert a group identifier to a group.\n\t */\n\tgetGroup(identifier: GroupIdentifier): IEditorGroup | undefined;\n\n\t/**\n\t * Set a group as active. An active group is the default location for new editors to open.\n\t */\n\tactivateGroup(group: IEditorGroup | GroupIdentifier): IEditorGroup;\n\n\t/**\n\t * Returns the size of a group.\n\t */\n\tgetSize(group: IEditorGroup | GroupIdentifier): number;\n\n\t/**\n\t * Sets the size of a group.\n\t */\n\tsetSize(group: IEditorGroup | GroupIdentifier, size: number): void;\n\n\t/**\n\t * Arrange all groups according to the provided arrangement.\n\t */\n\tarrangeGroups(arrangement: GroupsArrangement): void;\n\n\t/**\n\t * Applies the provided layout by either moving existing groups or creating new groups.\n\t */\n\tapplyLayout(layout: EditorGroupLayout): void;\n\n\t/**\n\t * Enable or disable centered editor layout.\n\t */\n\tcenterLayout(active: boolean): void;\n\n\t/**\n\t * Find out if the editor layout is currently centered.\n\t */\n\tisLayoutCentered(): boolean;\n\n\t/**\n\t * Sets the orientation of the root group to be either vertical or horizontal.\n\t */\n\tsetGroupOrientation(orientation: GroupOrientation): void;\n\n\t/**\n\t * Find a groupd in a specific scope:\n\t * * `GroupLocation.FIRST`: the first group\n\t * * `GroupLocation.LAST`: the last group\n\t * * `GroupLocation.NEXT`: the next group from either the active one or `source`\n\t * * `GroupLocation.PREVIOUS`: the previous group from either the active one or `source`\n\t * * `GroupDirection.UP`: the next group above the active one or `source`\n\t * * `GroupDirection.DOWN`: the next group below the active one or `source`\n\t * * `GroupDirection.LEFT`: the next group to the left of the active one or `source`\n\t * * `GroupDirection.RIGHT`: the next group to the right of the active one or `source`\n\t *\n\t * @param scope the scope of the group to search in\n\t * @param source optional source to search from\n\t * @param wrap optionally wrap around if reaching the edge of groups\n\t */\n\tfindGroup(scope: IFindGroupScope, source?: IEditorGroup | GroupIdentifier, wrap?: boolean): IEditorGroup;\n\n\t/**\n\t * Add a new group to the editor area. A new group is added by splitting a provided one in\n\t * one of the four directions.\n\t *\n\t * @param location the group from which to split to add a new group\n\t * @param direction the direction of where to split to\n\t * @param options configure the newly group with options\n\t */\n\taddGroup(location: IEditorGroup | GroupIdentifier, direction: GroupDirection, options?: IAddGroupOptions): IEditorGroup;\n\n\t/**\n\t * Remove a group from the editor area.\n\t */\n\tremoveGroup(group: IEditorGroup | GroupIdentifier): void;\n\n\t/**\n\t * Move a group to a new group in the editor area.\n\t *\n\t * @param group the group to move\n\t * @param location the group from which to split to add the moved group\n\t * @param direction the direction of where to split to\n\t */\n\tmoveGroup(group: IEditorGroup | GroupIdentifier, location: IEditorGroup | GroupIdentifier, direction: GroupDirection): IEditorGroup;\n\n\t/**\n\t * Merge the editors of a group into a target group. By default, all editors will\n\t * move and the source group will close. This behaviour can be configured via the\n\t * `IMergeGroupOptions` options.\n\t *\n\t * @param group the group to merge\n\t * @param target the target group to merge into\n\t * @param options controls how the merge should be performed. by default all editors\n\t * will be moved over to the target and the source group will close. Configure to\n\t * `MOVE_EDITORS_KEEP_GROUP` to prevent the source group from closing. Set to\n\t * `COPY_EDITORS` to copy the editors into the target instead of moding them.\n\t */\n\tmergeGroup(group: IEditorGroup | GroupIdentifier, target: IEditorGroup | GroupIdentifier, options?: IMergeGroupOptions): IEditorGroup;\n\n\t/**\n\t * Copy a group to a new group in the editor area.\n\t *\n\t * @param group the group to copy\n\t * @param location the group from which to split to add the copied group\n\t * @param direction the direction of where to split to\n\t */\n\tcopyGroup(group: IEditorGroup | GroupIdentifier, location: IEditorGroup | GroupIdentifier, direction: GroupDirection): IEditorGroup;\n\n\t/**\n\t * Access the options of the editor part.\n\t */\n\treadonly partOptions: IEditorPartOptions;\n\n\t/**\n\t * Enforce editor part options temporarily.\n\t */\n\tenforcePartOptions(options: IEditorPartOptions): IDisposable;\n}\n\nexport const enum GroupChangeKind {\n\n\t/* Group Changes */\n\tGROUP_ACTIVE,\n\tGROUP_LABEL,\n\n\t/* Editor Changes */\n\tEDITOR_OPEN,\n\tEDITOR_CLOSE,\n\tEDITOR_MOVE,\n\tEDITOR_ACTIVE,\n\tEDITOR_LABEL,\n\tEDITOR_PIN,\n\tEDITOR_DIRTY\n}\n\nexport interface IGroupChangeEvent {\n\tkind: GroupChangeKind;\n\teditor?: IEditorInput;\n\teditorIndex?: number;\n}\n\nexport interface IEditorGroup {\n\n\t/**\n\t * An aggregated event for when the group changes in any way.\n\t */\n\treadonly onDidGroupChange: Event<IGroupChangeEvent>;\n\n\t/**\n\t * A unique identifier of this group that remains identical even if the\n\t * group is moved to different locations.\n\t */\n\treadonly id: GroupIdentifier;\n\n\t/**\n\t * A human readable label for the group. This label can change depending\n\t * on the layout of all editor groups. Clients should listen on the\n\t * `onDidGroupChange` event to react to that.\n\t */\n\treadonly label: string;\n\n\t/**\n\t * The active control is the currently visible control of the group.\n\t */\n\treadonly activeControl: IVisibleEditor | undefined;\n\n\t/**\n\t * The active editor is the currently visible editor of the group\n\t * within the current active control.\n\t */\n\treadonly activeEditor: IEditorInput | null;\n\n\t/**\n\t * The editor in the group that is in preview mode if any. There can\n\t * only ever be one editor in preview mode.\n\t */\n\treadonly previewEditor: IEditorInput | null;\n\n\t/**\n\t * The number of opend editors in this group.\n\t */\n\treadonly count: number;\n\n\t/**\n\t * All opened editors in the group. There can only be one editor active.\n\t */\n\treadonly editors: ReadonlyArray<IEditorInput>;\n\n\t/**\n\t * Returns the editor at a specific index of the group.\n\t */\n\tgetEditor(index: number): IEditorInput | null;\n\n\t/**\n\t * Get all editors that are currently opened in the group optionally\n\t * sorted by being most recent active. Will sort by sequential appearance\n\t * by default (from left to right).\n\t */\n\tgetEditors(order?: EditorsOrder): ReadonlyArray<IEditorInput>;\n\n\t/**\n\t * Returns the index of the editor in the group or -1 if not opened.\n\t */\n\tgetIndexOfEditor(editor: IEditorInput): number;\n\n\t/**\n\t * Open an editor in this group.\n\t *\n\t * @returns a promise that resolves around an IEditor instance unless\n\t * the call failed, or the editor was not opened as active editor.\n\t */\n\topenEditor(editor: IEditorInput, options?: IEditorOptions | ITextEditorOptions): Promise<IEditor | null>;\n\n\t/**\n\t * Opens editors in this group.\n\t *\n\t * @returns a promise that resolves around an IEditor instance unless\n\t * the call failed, or the editor was not opened as active editor. Since\n\t * a group can only ever have one active editor, even if many editors are\n\t * opened, the result will only be one editor.\n\t */\n\topenEditors(editors: IEditorInputWithOptions[]): Promise<IEditor | null>;\n\n\t/**\n\t * Find out if the provided editor is opened in the group.\n\t *\n\t * Note: An editor can be opened but not actively visible.\n\t */\n\tisOpened(editor: IEditorInput): boolean;\n\n\t/**\n\t * Find out if the provided editor is pinned in the group.\n\t */\n\tisPinned(editor: IEditorInput): boolean;\n\n\t/**\n\t * Find out if the provided editor is active in the group.\n\t */\n\tisActive(editor: IEditorInput): boolean;\n\n\t/**\n\t * Move an editor from this group either within this group or to another group.\n\t */\n\tmoveEditor(editor: IEditorInput, target: IEditorGroup, options?: IMoveEditorOptions): void;\n\n\t/**\n\t * Copy an editor from this group to another group.\n\t *\n\t * Note: It is currently not supported to show the same editor more than once in the same group.\n\t */\n\tcopyEditor(editor: IEditorInput, target: IEditorGroup, options?: ICopyEditorOptions): void;\n\n\t/**\n\t * Close an editor from the group. This may trigger a confirmation dialog if\n\t * the editor is dirty and thus returns a promise as value.\n\t *\n\t * @param editor the editor to close, or the currently active editor\n\t * if unspecified.\n\t *\n\t * @returns a promise when the editor is closed.\n\t */\n\tcloseEditor(editor?: IEditorInput, options?: ICloseEditorOptions): Promise<void>;\n\n\t/**\n\t * Closes specific editors in this group. This may trigger a confirmation dialog if\n\t * there are dirty editors and thus returns a promise as value.\n\t *\n\t * @returns a promise when all editors are closed.\n\t */\n\tcloseEditors(editors: IEditorInput[] | ICloseEditorsFilter, options?: ICloseEditorOptions): Promise<void>;\n\n\t/**\n\t * Closes all editors from the group. This may trigger a confirmation dialog if\n\t * there are dirty editors and thus returns a promise as value.\n\t *\n\t * @returns a promise when all editors are closed.\n\t */\n\tcloseAllEditors(): Promise<void>;\n\n\t/**\n\t * Replaces editors in this group with the provided replacement.\n\t *\n\t * @param editors the editors to replace\n\t *\n\t * @returns a promise that is resolved when the replaced active\n\t * editor (if any) has finished loading.\n\t */\n\treplaceEditors(editors: IEditorReplacement[]): Promise<void>;\n\n\t/**\n\t * Set an editor to be pinned. A pinned editor is not replaced\n\t * when another editor opens at the same location.\n\t *\n\t * @param editor the editor to pin, or the currently active editor\n\t * if unspecified.\n\t */\n\tpinEditor(editor?: IEditorInput): void;\n\n\t/**\n\t * Move keyboard focus into the group.\n\t */\n\tfocus(): void;\n\n\t/**\n\t * Invoke a function in the context of the services of this group.\n\t */\n\tinvokeWithinContext<T>(fn: (accessor: ServicesAccessor) => T): T;\n}\n"]}]}