{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true}!/home/coding/workspace/packages/events/src/events.ts","dependencies":[{"path":"/home/coding/workspace/packages/events/src/events.ts","mtime":1555841535682},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Emitter typecasts for a single event type. You can optionally use IDs, but\n * using undefined with IDs will not work. If you emit without an ID, *all*\n * listeners regardless of their ID (or lack thereof) will receive the event.\n * Similarly, if you listen without an ID you will get *all* events for any or\n * no ID.\n */\nclass Emitter {\n    constructor() {\n        this.listeners = [];\n        this.idListeners = new Map();\n    }\n    get event() {\n        return (id, cb) => {\n            if (typeof id !== \"function\") {\n                if (this.idListeners.has(id)) {\n                    this.idListeners.get(id).push(cb);\n                }\n                else {\n                    this.idListeners.set(id, [cb]);\n                }\n                return {\n                    dispose: () => {\n                        if (this.idListeners.has(id)) {\n                            const cbs = this.idListeners.get(id);\n                            const i = cbs.indexOf(cb);\n                            if (i !== -1) {\n                                cbs.splice(i, 1);\n                            }\n                        }\n                    },\n                };\n            }\n            cb = id;\n            this.listeners.push(cb);\n            return {\n                dispose: () => {\n                    const i = this.listeners.indexOf(cb);\n                    if (i !== -1) {\n                        this.listeners.splice(i, 1);\n                    }\n                },\n            };\n        };\n    }\n    emit(id, value) {\n        if ((typeof id === \"number\" || typeof id === \"string\") && typeof value !== \"undefined\") {\n            if (this.idListeners.has(id)) {\n                this.idListeners.get(id).forEach((cb) => cb(value));\n            }\n            this.listeners.forEach((cb) => cb(value));\n        }\n        else {\n            this.idListeners.forEach((cbs) => cbs.forEach((cb) => cb(id)));\n            this.listeners.forEach((cb) => cb(id));\n        }\n    }\n    dispose(id) {\n        if (typeof id !== \"undefined\") {\n            this.idListeners.delete(id);\n        }\n        else {\n            this.listeners = [];\n            this.idListeners.clear();\n        }\n    }\n    get counts() {\n        const counts = {};\n        if (this.listeners.length > 0) {\n            counts[\"n/a\"] = this.listeners.length;\n        }\n        this.idListeners.forEach((cbs, id) => {\n            if (cbs.length > 0) {\n                counts[`${id}`] = cbs.length;\n            }\n        });\n        return counts;\n    }\n}\nexports.Emitter = Emitter;\n",{"version":3,"file":"/home/coding/workspace/packages/events/src/events.ts","sourceRoot":"","sources":["/home/coding/workspace/packages/events/src/events.ts"],"names":[],"mappings":"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","sourcesContent":["import { IDisposable } from \"@coder/disposable\";\n\nexport interface Event<T> {\n\t(listener: (value: T) => void): IDisposable;\n\t(id: number | string, listener: (value: T) => void): IDisposable;\n}\n\n/**\n * Emitter typecasts for a single event type. You can optionally use IDs, but\n * using undefined with IDs will not work. If you emit without an ID, *all*\n * listeners regardless of their ID (or lack thereof) will receive the event.\n * Similarly, if you listen without an ID you will get *all* events for any or\n * no ID.\n */\nexport class Emitter<T> {\n\tprivate listeners = <Array<(value: T) => void>>[];\n\tprivate readonly idListeners = new Map<number | string, Array<(value: T) => void>>();\n\n\tpublic get event(): Event<T> {\n\t\treturn (id: number | string | ((value: T) => void), cb?: (value: T) => void): IDisposable => {\n\t\t\tif (typeof id !== \"function\") {\n\t\t\t\tif (this.idListeners.has(id)) {\n\t\t\t\t\tthis.idListeners.get(id)!.push(cb!);\n\t\t\t\t} else {\n\t\t\t\t\tthis.idListeners.set(id, [cb!]);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tdispose: (): void => {\n\t\t\t\t\t\tif (this.idListeners.has(id)) {\n\t\t\t\t\t\t\tconst cbs = this.idListeners.get(id)!;\n\t\t\t\t\t\t\tconst i = cbs.indexOf(cb!);\n\t\t\t\t\t\t\tif (i !== -1) {\n\t\t\t\t\t\t\t\tcbs.splice(i, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tcb = id;\n\t\t\tthis.listeners.push(cb);\n\n\t\t\treturn {\n\t\t\t\tdispose: (): void => {\n\t\t\t\t\tconst i = this.listeners.indexOf(cb!);\n\t\t\t\t\tif (i !== -1) {\n\t\t\t\t\t\tthis.listeners.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\t\t};\n\t}\n\n\t/**\n\t * Emit an event with a value.\n\t */\n\tpublic emit(value: T): void;\n\tpublic emit(id: number | string, value: T): void;\n\tpublic emit(id: number | string | T, value?: T): void {\n\t\tif ((typeof id === \"number\" || typeof id === \"string\") && typeof value !== \"undefined\") {\n\t\t\tif (this.idListeners.has(id)) {\n\t\t\t\tthis.idListeners.get(id)!.forEach((cb) => cb(value!));\n\t\t\t}\n\t\t\tthis.listeners.forEach((cb) => cb(value!));\n\t\t} else {\n\t\t\tthis.idListeners.forEach((cbs) => cbs.forEach((cb) => cb((id as T)!)));\n\t\t\tthis.listeners.forEach((cb) => cb((id as T)!));\n\t\t}\n\t}\n\n\t/**\n\t * Dispose the current events.\n\t */\n\tpublic dispose(): void;\n\tpublic dispose(id: number | string): void;\n\tpublic dispose(id?: number | string): void {\n\t\tif (typeof id !== \"undefined\") {\n\t\t\tthis.idListeners.delete(id);\n\t\t} else {\n\t\t\tthis.listeners = [];\n\t\t\tthis.idListeners.clear();\n\t\t}\n\t}\n\n\tpublic get counts(): { [key: string]: number } {\n\t\tconst counts = <{ [key: string]: number }>{};\n\t\tif (this.listeners.length > 0) {\n\t\t\tcounts[\"n/a\"] = this.listeners.length;\n\t\t}\n\t\tthis.idListeners.forEach((cbs, id) => {\n\t\t\tif (cbs.length > 0) {\n\t\t\t\tcounts[`${id}`] = cbs.length;\n\t\t\t}\n\t\t});\n\n\t\treturn counts;\n\t}\n}\n"]}]}