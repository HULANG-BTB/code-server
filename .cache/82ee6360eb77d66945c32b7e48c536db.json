{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/linesLayout.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/linesLayout.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar whitespaceComputer_1 = require(\"vs/editor/common/viewLayout/whitespaceComputer\");\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n * This is written with no knowledge of an editor in mind.\n */\nvar LinesLayout = /** @class */ (function () {\n    function LinesLayout(lineCount, lineHeight) {\n        this._lineCount = lineCount;\n        this._lineHeight = lineHeight;\n        this._whitespaces = new whitespaceComputer_1.WhitespaceComputer();\n    }\n    /**\n     * Change the height of a line in pixels.\n     */\n    LinesLayout.prototype.setLineHeight = function (lineHeight) {\n        this._lineHeight = lineHeight;\n    };\n    /**\n     * Set the number of lines.\n     *\n     * @param lineCount New number of lines.\n     */\n    LinesLayout.prototype.onFlushed = function (lineCount) {\n        this._lineCount = lineCount;\n    };\n    /**\n     * Insert a new whitespace of a certain height after a line number.\n     * The whitespace has a \"sticky\" characteristic.\n     * Irrespective of edits above or below `afterLineNumber`, the whitespace will follow the initial line.\n     *\n     * @param afterLineNumber The conceptual position of this whitespace. The whitespace will follow this line as best as possible even when deleting/inserting lines above/below.\n     * @param heightInPx The height of the whitespace, in pixels.\n     * @return An id that can be used later to mutate or delete the whitespace\n     */\n    LinesLayout.prototype.insertWhitespace = function (afterLineNumber, ordinal, heightInPx, minWidth) {\n        return this._whitespaces.insertWhitespace(afterLineNumber, ordinal, heightInPx, minWidth);\n    };\n    /**\n     * Change properties associated with a certain whitespace.\n     */\n    LinesLayout.prototype.changeWhitespace = function (id, newAfterLineNumber, newHeight) {\n        return this._whitespaces.changeWhitespace(id, newAfterLineNumber, newHeight);\n    };\n    /**\n     * Remove an existing whitespace.\n     *\n     * @param id The whitespace to remove\n     * @return Returns true if the whitespace is found and it is removed.\n     */\n    LinesLayout.prototype.removeWhitespace = function (id) {\n        return this._whitespaces.removeWhitespace(id);\n    };\n    /**\n     * Notify the layouter that lines have been deleted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the deletion started, inclusive\n     * @param toLineNumber The line number at which the deletion ended, inclusive\n     */\n    LinesLayout.prototype.onLinesDeleted = function (fromLineNumber, toLineNumber) {\n        this._lineCount -= (toLineNumber - fromLineNumber + 1);\n        this._whitespaces.onLinesDeleted(fromLineNumber, toLineNumber);\n    };\n    /**\n     * Notify the layouter that lines have been inserted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the insertion started, inclusive\n     * @param toLineNumber The line number at which the insertion ended, inclusive.\n     */\n    LinesLayout.prototype.onLinesInserted = function (fromLineNumber, toLineNumber) {\n        this._lineCount += (toLineNumber - fromLineNumber + 1);\n        this._whitespaces.onLinesInserted(fromLineNumber, toLineNumber);\n    };\n    /**\n     * Get the sum of heights for all objects.\n     *\n     * @return The sum of heights for all objects.\n     */\n    LinesLayout.prototype.getLinesTotalHeight = function () {\n        var linesHeight = this._lineHeight * this._lineCount;\n        var whitespacesHeight = this._whitespaces.getTotalHeight();\n        return linesHeight + whitespacesHeight;\n    };\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    LinesLayout.prototype.getVerticalOffsetForLineNumber = function (lineNumber) {\n        lineNumber = lineNumber | 0;\n        var previousLinesHeight;\n        if (lineNumber > 1) {\n            previousLinesHeight = this._lineHeight * (lineNumber - 1);\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        var previousWhitespacesHeight = this._whitespaces.getAccumulatedHeightBeforeLineNumber(lineNumber);\n        return previousLinesHeight + previousWhitespacesHeight;\n    };\n    /**\n     * Returns the accumulated height of whitespaces before the given line number.\n     *\n     * @param lineNumber The line number\n     */\n    LinesLayout.prototype.getWhitespaceAccumulatedHeightBeforeLineNumber = function (lineNumber) {\n        return this._whitespaces.getAccumulatedHeightBeforeLineNumber(lineNumber);\n    };\n    /**\n     * Returns if there is any whitespace in the document.\n     */\n    LinesLayout.prototype.hasWhitespace = function () {\n        return this._whitespaces.getCount() > 0;\n    };\n    LinesLayout.prototype.getWhitespaceMinWidth = function () {\n        return this._whitespaces.getMinWidth();\n    };\n    /**\n     * Check if `verticalOffset` is below all lines.\n     */\n    LinesLayout.prototype.isAfterLines = function (verticalOffset) {\n        var totalHeight = this.getLinesTotalHeight();\n        return verticalOffset > totalHeight;\n    };\n    /**\n     * Find the first line number that is at or after vertical offset `verticalOffset`.\n     * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n     * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n     *\n     * @param verticalOffset The vertical offset to search at.\n     * @return The line number at or after vertical offset `verticalOffset`.\n     */\n    LinesLayout.prototype.getLineNumberAtOrAfterVerticalOffset = function (verticalOffset) {\n        verticalOffset = verticalOffset | 0;\n        if (verticalOffset < 0) {\n            return 1;\n        }\n        var linesCount = this._lineCount | 0;\n        var lineHeight = this._lineHeight;\n        var minLineNumber = 1;\n        var maxLineNumber = linesCount;\n        while (minLineNumber < maxLineNumber) {\n            var midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\n            var midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n            if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n                // vertical offset is after mid line number\n                minLineNumber = midLineNumber + 1;\n            }\n            else if (verticalOffset >= midLineNumberVerticalOffset) {\n                // Hit\n                return midLineNumber;\n            }\n            else {\n                // vertical offset is before mid line number, but mid line number could still be what we're searching for\n                maxLineNumber = midLineNumber;\n            }\n        }\n        if (minLineNumber > linesCount) {\n            return linesCount;\n        }\n        return minLineNumber;\n    };\n    /**\n     * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n     */\n    LinesLayout.prototype.getLinesViewportData = function (verticalOffset1, verticalOffset2) {\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        var lineHeight = this._lineHeight;\n        // Find first line number\n        // We don't live in a perfect world, so the line number might start before or after verticalOffset1\n        var startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n        var startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n        var endLineNumber = this._lineCount | 0;\n        // Also keep track of what whitespace we've got\n        var whitespaceIndex = this._whitespaces.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n        var whitespaceCount = this._whitespaces.getCount() | 0;\n        var currentWhitespaceHeight;\n        var currentWhitespaceAfterLineNumber;\n        if (whitespaceIndex === -1) {\n            whitespaceIndex = whitespaceCount;\n            currentWhitespaceAfterLineNumber = endLineNumber + 1;\n            currentWhitespaceHeight = 0;\n        }\n        else {\n            currentWhitespaceAfterLineNumber = this._whitespaces.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n            currentWhitespaceHeight = this._whitespaces.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n        }\n        var currentVerticalOffset = startLineNumberVerticalOffset;\n        var currentLineRelativeOffset = currentVerticalOffset;\n        // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n        var STEP_SIZE = 500000;\n        var bigNumbersDelta = 0;\n        if (startLineNumberVerticalOffset >= STEP_SIZE) {\n            // Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n            bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n            bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;\n            currentLineRelativeOffset -= bigNumbersDelta;\n        }\n        var linesOffsets = [];\n        var verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n        var centeredLineNumber = -1;\n        // Figure out how far the lines go\n        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            if (centeredLineNumber === -1) {\n                var currentLineTop = currentVerticalOffset;\n                var currentLineBottom = currentVerticalOffset + lineHeight;\n                if ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\n                    centeredLineNumber = lineNumber;\n                }\n            }\n            // Count current line height in the vertical offsets\n            currentVerticalOffset += lineHeight;\n            linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n            // Next line starts immediately after this one\n            currentLineRelativeOffset += lineHeight;\n            while (currentWhitespaceAfterLineNumber === lineNumber) {\n                // Push down next line with the height of the current whitespace\n                currentLineRelativeOffset += currentWhitespaceHeight;\n                // Count current whitespace in the vertical offsets\n                currentVerticalOffset += currentWhitespaceHeight;\n                whitespaceIndex++;\n                if (whitespaceIndex >= whitespaceCount) {\n                    currentWhitespaceAfterLineNumber = endLineNumber + 1;\n                }\n                else {\n                    currentWhitespaceAfterLineNumber = this._whitespaces.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n                    currentWhitespaceHeight = this._whitespaces.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n                }\n            }\n            if (currentVerticalOffset >= verticalOffset2) {\n                // We have covered the entire viewport area, time to stop\n                endLineNumber = lineNumber;\n                break;\n            }\n        }\n        if (centeredLineNumber === -1) {\n            centeredLineNumber = endLineNumber;\n        }\n        var endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n        var completelyVisibleStartLineNumber = startLineNumber;\n        var completelyVisibleEndLineNumber = endLineNumber;\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (startLineNumberVerticalOffset < verticalOffset1) {\n                completelyVisibleStartLineNumber++;\n            }\n        }\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {\n                completelyVisibleEndLineNumber--;\n            }\n        }\n        return {\n            bigNumbersDelta: bigNumbersDelta,\n            startLineNumber: startLineNumber,\n            endLineNumber: endLineNumber,\n            relativeVerticalOffset: linesOffsets,\n            centeredLineNumber: centeredLineNumber,\n            completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n            completelyVisibleEndLineNumber: completelyVisibleEndLineNumber\n        };\n    };\n    LinesLayout.prototype.getVerticalOffsetForWhitespaceIndex = function (whitespaceIndex) {\n        whitespaceIndex = whitespaceIndex | 0;\n        var afterLineNumber = this._whitespaces.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n        var previousLinesHeight;\n        if (afterLineNumber >= 1) {\n            previousLinesHeight = this._lineHeight * afterLineNumber;\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        var previousWhitespacesHeight;\n        if (whitespaceIndex > 0) {\n            previousWhitespacesHeight = this._whitespaces.getAccumulatedHeight(whitespaceIndex - 1);\n        }\n        else {\n            previousWhitespacesHeight = 0;\n        }\n        return previousLinesHeight + previousWhitespacesHeight;\n    };\n    LinesLayout.prototype.getWhitespaceIndexAtOrAfterVerticallOffset = function (verticalOffset) {\n        verticalOffset = verticalOffset | 0;\n        var midWhitespaceIndex, minWhitespaceIndex = 0, maxWhitespaceIndex = this._whitespaces.getCount() - 1, midWhitespaceVerticalOffset, midWhitespaceHeight;\n        if (maxWhitespaceIndex < 0) {\n            return -1;\n        }\n        // Special case: nothing to be found\n        var maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n        var maxWhitespaceHeight = this._whitespaces.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n        if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n            return -1;\n        }\n        while (minWhitespaceIndex < maxWhitespaceIndex) {\n            midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n            midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n            midWhitespaceHeight = this._whitespaces.getHeightForWhitespaceIndex(midWhitespaceIndex);\n            if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n                // vertical offset is after whitespace\n                minWhitespaceIndex = midWhitespaceIndex + 1;\n            }\n            else if (verticalOffset >= midWhitespaceVerticalOffset) {\n                // Hit\n                return midWhitespaceIndex;\n            }\n            else {\n                // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n                maxWhitespaceIndex = midWhitespaceIndex;\n            }\n        }\n        return minWhitespaceIndex;\n    };\n    /**\n     * Get exactly the whitespace that is layouted at `verticalOffset`.\n     *\n     * @param verticalOffset The vertical offset.\n     * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n     */\n    LinesLayout.prototype.getWhitespaceAtVerticalOffset = function (verticalOffset) {\n        verticalOffset = verticalOffset | 0;\n        var candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n        if (candidateIndex < 0) {\n            return null;\n        }\n        if (candidateIndex >= this._whitespaces.getCount()) {\n            return null;\n        }\n        var candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n        if (candidateTop > verticalOffset) {\n            return null;\n        }\n        var candidateHeight = this._whitespaces.getHeightForWhitespaceIndex(candidateIndex);\n        var candidateId = this._whitespaces.getIdForWhitespaceIndex(candidateIndex);\n        var candidateAfterLineNumber = this._whitespaces.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n        return {\n            id: candidateId,\n            afterLineNumber: candidateAfterLineNumber,\n            verticalOffset: candidateTop,\n            height: candidateHeight\n        };\n    };\n    /**\n     * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n     */\n    LinesLayout.prototype.getWhitespaceViewportData = function (verticalOffset1, verticalOffset2) {\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        var startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n        var endIndex = this._whitespaces.getCount() - 1;\n        if (startIndex < 0) {\n            return [];\n        }\n        var result = [];\n        for (var i = startIndex; i <= endIndex; i++) {\n            var top = this.getVerticalOffsetForWhitespaceIndex(i);\n            var height = this._whitespaces.getHeightForWhitespaceIndex(i);\n            if (top >= verticalOffset2) {\n                break;\n            }\n            result.push({\n                id: this._whitespaces.getIdForWhitespaceIndex(i),\n                afterLineNumber: this._whitespaces.getAfterLineNumberForWhitespaceIndex(i),\n                verticalOffset: top,\n                height: height\n            });\n        }\n        return result;\n    };\n    /**\n     * Get all whitespaces.\n     */\n    LinesLayout.prototype.getWhitespaces = function () {\n        return this._whitespaces.getWhitespaces(this._lineHeight);\n    };\n    return LinesLayout;\n}());\nexports.LinesLayout = LinesLayout;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/linesLayout.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/linesLayout.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IPartialViewLinesViewportData } from 'vs/editor/common/viewLayout/viewLinesViewportData';\nimport { IEditorWhitespace, WhitespaceComputer } from 'vs/editor/common/viewLayout/whitespaceComputer';\nimport { IViewWhitespaceViewportData } from 'vs/editor/common/viewModel/viewModel';\n\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n * This is written with no knowledge of an editor in mind.\n */\nexport class LinesLayout {\n\n\t/**\n\t * Keep track of the total number of lines.\n\t * This is useful for doing binary searches or for doing hit-testing.\n\t */\n\tprivate _lineCount: number;\n\n\t/**\n\t * The height of a line in pixels.\n\t */\n\tprivate _lineHeight: number;\n\n\t/**\n\t * Contains whitespace information in pixels\n\t */\n\tprivate readonly _whitespaces: WhitespaceComputer;\n\n\tconstructor(lineCount: number, lineHeight: number) {\n\t\tthis._lineCount = lineCount;\n\t\tthis._lineHeight = lineHeight;\n\t\tthis._whitespaces = new WhitespaceComputer();\n\t}\n\n\t/**\n\t * Change the height of a line in pixels.\n\t */\n\tpublic setLineHeight(lineHeight: number): void {\n\t\tthis._lineHeight = lineHeight;\n\t}\n\n\t/**\n\t * Set the number of lines.\n\t *\n\t * @param lineCount New number of lines.\n\t */\n\tpublic onFlushed(lineCount: number): void {\n\t\tthis._lineCount = lineCount;\n\t}\n\n\t/**\n\t * Insert a new whitespace of a certain height after a line number.\n\t * The whitespace has a \"sticky\" characteristic.\n\t * Irrespective of edits above or below `afterLineNumber`, the whitespace will follow the initial line.\n\t *\n\t * @param afterLineNumber The conceptual position of this whitespace. The whitespace will follow this line as best as possible even when deleting/inserting lines above/below.\n\t * @param heightInPx The height of the whitespace, in pixels.\n\t * @return An id that can be used later to mutate or delete the whitespace\n\t */\n\tpublic insertWhitespace(afterLineNumber: number, ordinal: number, heightInPx: number, minWidth: number): number {\n\t\treturn this._whitespaces.insertWhitespace(afterLineNumber, ordinal, heightInPx, minWidth);\n\t}\n\n\t/**\n\t * Change properties associated with a certain whitespace.\n\t */\n\tpublic changeWhitespace(id: number, newAfterLineNumber: number, newHeight: number): boolean {\n\t\treturn this._whitespaces.changeWhitespace(id, newAfterLineNumber, newHeight);\n\t}\n\n\t/**\n\t * Remove an existing whitespace.\n\t *\n\t * @param id The whitespace to remove\n\t * @return Returns true if the whitespace is found and it is removed.\n\t */\n\tpublic removeWhitespace(id: number): boolean {\n\t\treturn this._whitespaces.removeWhitespace(id);\n\t}\n\n\t/**\n\t * Notify the layouter that lines have been deleted (a continuous zone of lines).\n\t *\n\t * @param fromLineNumber The line number at which the deletion started, inclusive\n\t * @param toLineNumber The line number at which the deletion ended, inclusive\n\t */\n\tpublic onLinesDeleted(fromLineNumber: number, toLineNumber: number): void {\n\t\tthis._lineCount -= (toLineNumber - fromLineNumber + 1);\n\t\tthis._whitespaces.onLinesDeleted(fromLineNumber, toLineNumber);\n\t}\n\n\t/**\n\t * Notify the layouter that lines have been inserted (a continuous zone of lines).\n\t *\n\t * @param fromLineNumber The line number at which the insertion started, inclusive\n\t * @param toLineNumber The line number at which the insertion ended, inclusive.\n\t */\n\tpublic onLinesInserted(fromLineNumber: number, toLineNumber: number): void {\n\t\tthis._lineCount += (toLineNumber - fromLineNumber + 1);\n\t\tthis._whitespaces.onLinesInserted(fromLineNumber, toLineNumber);\n\t}\n\n\t/**\n\t * Get the sum of heights for all objects.\n\t *\n\t * @return The sum of heights for all objects.\n\t */\n\tpublic getLinesTotalHeight(): number {\n\t\tlet linesHeight = this._lineHeight * this._lineCount;\n\t\tlet whitespacesHeight = this._whitespaces.getTotalHeight();\n\t\treturn linesHeight + whitespacesHeight;\n\t}\n\n\t/**\n\t * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n\t *\n\t * @param lineNumber The line number\n\t * @return The sum of heights for all objects above `lineNumber`.\n\t */\n\tpublic getVerticalOffsetForLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\tlet previousLinesHeight: number;\n\t\tif (lineNumber > 1) {\n\t\t\tpreviousLinesHeight = this._lineHeight * (lineNumber - 1);\n\t\t} else {\n\t\t\tpreviousLinesHeight = 0;\n\t\t}\n\n\t\tlet previousWhitespacesHeight = this._whitespaces.getAccumulatedHeightBeforeLineNumber(lineNumber);\n\n\t\treturn previousLinesHeight + previousWhitespacesHeight;\n\t}\n\n\t/**\n\t * Returns the accumulated height of whitespaces before the given line number.\n\t *\n\t * @param lineNumber The line number\n\t */\n\tpublic getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber: number): number {\n\t\treturn this._whitespaces.getAccumulatedHeightBeforeLineNumber(lineNumber);\n\t}\n\n\t/**\n\t * Returns if there is any whitespace in the document.\n\t */\n\tpublic hasWhitespace(): boolean {\n\t\treturn this._whitespaces.getCount() > 0;\n\t}\n\n\tpublic getWhitespaceMinWidth(): number {\n\t\treturn this._whitespaces.getMinWidth();\n\t}\n\n\t/**\n\t * Check if `verticalOffset` is below all lines.\n\t */\n\tpublic isAfterLines(verticalOffset: number): boolean {\n\t\tlet totalHeight = this.getLinesTotalHeight();\n\t\treturn verticalOffset > totalHeight;\n\t}\n\n\t/**\n\t * Find the first line number that is at or after vertical offset `verticalOffset`.\n\t * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n\t * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n\t *\n\t * @param verticalOffset The vertical offset to search at.\n\t * @return The line number at or after vertical offset `verticalOffset`.\n\t */\n\tpublic getLineNumberAtOrAfterVerticalOffset(verticalOffset: number): number {\n\t\tverticalOffset = verticalOffset | 0;\n\n\t\tif (verticalOffset < 0) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tconst linesCount = this._lineCount | 0;\n\t\tconst lineHeight = this._lineHeight;\n\t\tlet minLineNumber = 1;\n\t\tlet maxLineNumber = linesCount;\n\n\t\twhile (minLineNumber < maxLineNumber) {\n\t\t\tlet midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\n\n\t\t\tlet midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n\n\t\t\tif (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n\t\t\t\t// vertical offset is after mid line number\n\t\t\t\tminLineNumber = midLineNumber + 1;\n\t\t\t} else if (verticalOffset >= midLineNumberVerticalOffset) {\n\t\t\t\t// Hit\n\t\t\t\treturn midLineNumber;\n\t\t\t} else {\n\t\t\t\t// vertical offset is before mid line number, but mid line number could still be what we're searching for\n\t\t\t\tmaxLineNumber = midLineNumber;\n\t\t\t}\n\t\t}\n\n\t\tif (minLineNumber > linesCount) {\n\t\t\treturn linesCount;\n\t\t}\n\n\t\treturn minLineNumber;\n\t}\n\n\t/**\n\t * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n\t *\n\t * @param verticalOffset1 The beginning of the viewport.\n\t * @param verticalOffset2 The end of the viewport.\n\t * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n\t */\n\tpublic getLinesViewportData(verticalOffset1: number, verticalOffset2: number): IPartialViewLinesViewportData {\n\t\tverticalOffset1 = verticalOffset1 | 0;\n\t\tverticalOffset2 = verticalOffset2 | 0;\n\t\tconst lineHeight = this._lineHeight;\n\n\t\t// Find first line number\n\t\t// We don't live in a perfect world, so the line number might start before or after verticalOffset1\n\t\tconst startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n\t\tconst startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n\n\t\tlet endLineNumber = this._lineCount | 0;\n\n\t\t// Also keep track of what whitespace we've got\n\t\tlet whitespaceIndex = this._whitespaces.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n\t\tconst whitespaceCount = this._whitespaces.getCount() | 0;\n\t\tlet currentWhitespaceHeight: number;\n\t\tlet currentWhitespaceAfterLineNumber: number;\n\n\t\tif (whitespaceIndex === -1) {\n\t\t\twhitespaceIndex = whitespaceCount;\n\t\t\tcurrentWhitespaceAfterLineNumber = endLineNumber + 1;\n\t\t\tcurrentWhitespaceHeight = 0;\n\t\t} else {\n\t\t\tcurrentWhitespaceAfterLineNumber = this._whitespaces.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t\tcurrentWhitespaceHeight = this._whitespaces.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t}\n\n\t\tlet currentVerticalOffset = startLineNumberVerticalOffset;\n\t\tlet currentLineRelativeOffset = currentVerticalOffset;\n\n\t\t// IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n\t\tconst STEP_SIZE = 500000;\n\t\tlet bigNumbersDelta = 0;\n\t\tif (startLineNumberVerticalOffset >= STEP_SIZE) {\n\t\t\t// Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n\t\t\tbigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n\t\t\tbigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;\n\n\t\t\tcurrentLineRelativeOffset -= bigNumbersDelta;\n\t\t}\n\n\t\tlet linesOffsets: number[] = [];\n\n\t\tconst verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n\t\tlet centeredLineNumber = -1;\n\n\t\t// Figure out how far the lines go\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\n\t\t\tif (centeredLineNumber === -1) {\n\t\t\t\tlet currentLineTop = currentVerticalOffset;\n\t\t\t\tlet currentLineBottom = currentVerticalOffset + lineHeight;\n\t\t\t\tif ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\n\t\t\t\t\tcenteredLineNumber = lineNumber;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Count current line height in the vertical offsets\n\t\t\tcurrentVerticalOffset += lineHeight;\n\t\t\tlinesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n\n\t\t\t// Next line starts immediately after this one\n\t\t\tcurrentLineRelativeOffset += lineHeight;\n\t\t\twhile (currentWhitespaceAfterLineNumber === lineNumber) {\n\t\t\t\t// Push down next line with the height of the current whitespace\n\t\t\t\tcurrentLineRelativeOffset += currentWhitespaceHeight;\n\n\t\t\t\t// Count current whitespace in the vertical offsets\n\t\t\t\tcurrentVerticalOffset += currentWhitespaceHeight;\n\t\t\t\twhitespaceIndex++;\n\n\t\t\t\tif (whitespaceIndex >= whitespaceCount) {\n\t\t\t\t\tcurrentWhitespaceAfterLineNumber = endLineNumber + 1;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentWhitespaceAfterLineNumber = this._whitespaces.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t\t\t\tcurrentWhitespaceHeight = this._whitespaces.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (currentVerticalOffset >= verticalOffset2) {\n\t\t\t\t// We have covered the entire viewport area, time to stop\n\t\t\t\tendLineNumber = lineNumber;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (centeredLineNumber === -1) {\n\t\t\tcenteredLineNumber = endLineNumber;\n\t\t}\n\n\t\tconst endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n\n\t\tlet completelyVisibleStartLineNumber = startLineNumber;\n\t\tlet completelyVisibleEndLineNumber = endLineNumber;\n\n\t\tif (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n\t\t\tif (startLineNumberVerticalOffset < verticalOffset1) {\n\t\t\t\tcompletelyVisibleStartLineNumber++;\n\t\t\t}\n\t\t}\n\t\tif (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n\t\t\tif (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {\n\t\t\t\tcompletelyVisibleEndLineNumber--;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tbigNumbersDelta: bigNumbersDelta,\n\t\t\tstartLineNumber: startLineNumber,\n\t\t\tendLineNumber: endLineNumber,\n\t\t\trelativeVerticalOffset: linesOffsets,\n\t\t\tcenteredLineNumber: centeredLineNumber,\n\t\t\tcompletelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n\t\t\tcompletelyVisibleEndLineNumber: completelyVisibleEndLineNumber\n\t\t};\n\t}\n\n\tpublic getVerticalOffsetForWhitespaceIndex(whitespaceIndex: number): number {\n\t\twhitespaceIndex = whitespaceIndex | 0;\n\n\t\tlet afterLineNumber = this._whitespaces.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n\n\t\tlet previousLinesHeight: number;\n\t\tif (afterLineNumber >= 1) {\n\t\t\tpreviousLinesHeight = this._lineHeight * afterLineNumber;\n\t\t} else {\n\t\t\tpreviousLinesHeight = 0;\n\t\t}\n\n\t\tlet previousWhitespacesHeight: number;\n\t\tif (whitespaceIndex > 0) {\n\t\t\tpreviousWhitespacesHeight = this._whitespaces.getAccumulatedHeight(whitespaceIndex - 1);\n\t\t} else {\n\t\t\tpreviousWhitespacesHeight = 0;\n\t\t}\n\t\treturn previousLinesHeight + previousWhitespacesHeight;\n\t}\n\n\tpublic getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset: number): number {\n\t\tverticalOffset = verticalOffset | 0;\n\n\t\tlet midWhitespaceIndex: number,\n\t\t\tminWhitespaceIndex = 0,\n\t\t\tmaxWhitespaceIndex = this._whitespaces.getCount() - 1,\n\t\t\tmidWhitespaceVerticalOffset: number,\n\t\t\tmidWhitespaceHeight: number;\n\n\t\tif (maxWhitespaceIndex < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// Special case: nothing to be found\n\t\tlet maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n\t\tlet maxWhitespaceHeight = this._whitespaces.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n\t\tif (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (minWhitespaceIndex < maxWhitespaceIndex) {\n\t\t\tmidWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n\n\t\t\tmidWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n\t\t\tmidWhitespaceHeight = this._whitespaces.getHeightForWhitespaceIndex(midWhitespaceIndex);\n\n\t\t\tif (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n\t\t\t\t// vertical offset is after whitespace\n\t\t\t\tminWhitespaceIndex = midWhitespaceIndex + 1;\n\t\t\t} else if (verticalOffset >= midWhitespaceVerticalOffset) {\n\t\t\t\t// Hit\n\t\t\t\treturn midWhitespaceIndex;\n\t\t\t} else {\n\t\t\t\t// vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n\t\t\t\tmaxWhitespaceIndex = midWhitespaceIndex;\n\t\t\t}\n\t\t}\n\t\treturn minWhitespaceIndex;\n\t}\n\n\t/**\n\t * Get exactly the whitespace that is layouted at `verticalOffset`.\n\t *\n\t * @param verticalOffset The vertical offset.\n\t * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n\t */\n\tpublic getWhitespaceAtVerticalOffset(verticalOffset: number): IViewWhitespaceViewportData | null {\n\t\tverticalOffset = verticalOffset | 0;\n\n\t\tlet candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n\n\t\tif (candidateIndex < 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (candidateIndex >= this._whitespaces.getCount()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n\n\t\tif (candidateTop > verticalOffset) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet candidateHeight = this._whitespaces.getHeightForWhitespaceIndex(candidateIndex);\n\t\tlet candidateId = this._whitespaces.getIdForWhitespaceIndex(candidateIndex);\n\t\tlet candidateAfterLineNumber = this._whitespaces.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n\n\t\treturn {\n\t\t\tid: candidateId,\n\t\t\tafterLineNumber: candidateAfterLineNumber,\n\t\t\tverticalOffset: candidateTop,\n\t\t\theight: candidateHeight\n\t\t};\n\t}\n\n\t/**\n\t * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n\t *\n\t * @param verticalOffset1 The beginning of the viewport.\n\t * @param verticalOffset2 The end of the viewport.\n\t * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n\t */\n\tpublic getWhitespaceViewportData(verticalOffset1: number, verticalOffset2: number): IViewWhitespaceViewportData[] {\n\t\tverticalOffset1 = verticalOffset1 | 0;\n\t\tverticalOffset2 = verticalOffset2 | 0;\n\n\t\tlet startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n\t\tlet endIndex = this._whitespaces.getCount() - 1;\n\n\t\tif (startIndex < 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet result: IViewWhitespaceViewportData[] = [];\n\t\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\t\tlet top = this.getVerticalOffsetForWhitespaceIndex(i);\n\t\t\tlet height = this._whitespaces.getHeightForWhitespaceIndex(i);\n\t\t\tif (top >= verticalOffset2) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult.push({\n\t\t\t\tid: this._whitespaces.getIdForWhitespaceIndex(i),\n\t\t\t\tafterLineNumber: this._whitespaces.getAfterLineNumberForWhitespaceIndex(i),\n\t\t\t\tverticalOffset: top,\n\t\t\t\theight: height\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Get all whitespaces.\n\t */\n\tpublic getWhitespaces(): IEditorWhitespace[] {\n\t\treturn this._whitespaces.getWhitespaces(this._lineHeight);\n\t}\n}\n"]}]}