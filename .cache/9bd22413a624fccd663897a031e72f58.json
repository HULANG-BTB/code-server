{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/extensions/node/extensionsWorkbenchService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/extensions/node/extensionsWorkbenchService.ts","mtime":1555846338040},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"semver\", \"vs/base/common/event\", \"vs/base/common/arrays\", \"vs/base/common/async\", \"vs/base/common/errors\", \"vs/base/common/lifecycle\", \"vs/base/common/paging\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/extensionManagement/common/extensionManagement\", \"vs/platform/extensionManagement/common/extensionManagementUtil\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/configuration/common/configuration\", \"vs/platform/windows/common/windows\", \"vs/base/common/severity\", \"vs/base/common/uri\", \"vs/workbench/contrib/extensions/common/extensions\", \"vs/workbench/services/editor/common/editorService\", \"vs/platform/url/common/url\", \"vs/workbench/contrib/extensions/common/extensionsInput\", \"vs/platform/product/node/product\", \"vs/platform/log/common/log\", \"vs/platform/progress/common/progress\", \"vs/platform/notification/common/notification\", \"vs/base/common/resources\", \"vs/base/common/cancellation\", \"vs/platform/storage/common/storage\", \"vs/platform/files/common/files\", \"vs/platform/extensions/common/extensions\", \"vs/workbench/services/extensions/node/extensionsUtil\"], function (require, exports, nls, semver, event_1, arrays_1, async_1, errors_1, lifecycle_1, paging_1, telemetry_1, extensionManagement_1, extensionManagementUtil_1, instantiation_1, configuration_1, windows_1, severity_1, uri_1, extensions_1, editorService_1, url_1, extensionsInput_1, product_1, log_1, progress_1, notification_1, resources, cancellation_1, storage_1, files_1, extensions_2, extensionsUtil_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class Extension {\n        constructor(galleryService, stateProvider, local, gallery, telemetryService, logService, fileService) {\n            this.galleryService = galleryService;\n            this.stateProvider = stateProvider;\n            this.local = local;\n            this.gallery = gallery;\n            this.telemetryService = telemetryService;\n            this.logService = logService;\n            this.fileService = fileService;\n            this.enablementState = extensionManagement_1.EnablementState.Enabled;\n            this.isMalicious = false;\n        }\n        get type() {\n            return this.local ? this.local.type : undefined;\n        }\n        get name() {\n            return this.gallery ? this.gallery.name : this.local.manifest.name;\n        }\n        get displayName() {\n            if (this.gallery) {\n                return this.gallery.displayName || this.gallery.name;\n            }\n            return this.local.manifest.displayName || this.local.manifest.name;\n        }\n        get identifier() {\n            if (this.gallery) {\n                return this.gallery.identifier;\n            }\n            return this.local.identifier;\n        }\n        get uuid() {\n            return this.gallery ? this.gallery.identifier.uuid : this.local.identifier.uuid;\n        }\n        get publisher() {\n            return this.gallery ? this.gallery.publisher : this.local.manifest.publisher;\n        }\n        get publisherDisplayName() {\n            if (this.gallery) {\n                return this.gallery.publisherDisplayName || this.gallery.publisher;\n            }\n            if (this.local.metadata && this.local.metadata.publisherDisplayName) {\n                return this.local.metadata.publisherDisplayName;\n            }\n            return this.local.manifest.publisher;\n        }\n        get version() {\n            return this.local ? this.local.manifest.version : this.latestVersion;\n        }\n        get latestVersion() {\n            return this.gallery ? this.gallery.version : this.local.manifest.version;\n        }\n        get description() {\n            return this.gallery ? this.gallery.description : this.local.manifest.description || '';\n        }\n        get url() {\n            if (!product_1.default.extensionsGallery || !this.gallery) {\n                return undefined;\n            }\n            return undefined; // `${product.extensionsGallery.itemUrl}?itemName=${this.publisher}.${this.name}`;\n        }\n        get iconUrl() {\n            return this.galleryIconUrl || this.localIconUrl || this.defaultIconUrl;\n        }\n        get iconUrlFallback() {\n            return this.galleryIconUrlFallback || this.localIconUrl || this.defaultIconUrl;\n        }\n        get localIconUrl() {\n            if (this.local && this.local.manifest.icon) {\n                return resources.joinPath(this.local.location, this.local.manifest.icon).toString();\n            }\n            return null;\n        }\n        get galleryIconUrl() {\n            return this.gallery ? this.gallery.assets.icon.uri : null;\n        }\n        get galleryIconUrlFallback() {\n            return this.gallery ? this.gallery.assets.icon.fallbackUri : null;\n        }\n        get defaultIconUrl() {\n            if (this.type === extensions_2.ExtensionType.System && this.local) {\n                if (this.local.manifest && this.local.manifest.contributes) {\n                    if (Array.isArray(this.local.manifest.contributes.themes) && this.local.manifest.contributes.themes.length) {\n                        return require.toUrl('../electron-browser/media/theme-icon.png');\n                    }\n                    if (Array.isArray(this.local.manifest.contributes.grammars) && this.local.manifest.contributes.grammars.length) {\n                        return require.toUrl('../electron-browser/media/language-icon.svg');\n                    }\n                }\n            }\n            return require.toUrl('../electron-browser/media/defaultIcon.png');\n        }\n        get repository() {\n            return this.gallery && this.gallery.assets.repository ? this.gallery.assets.repository.uri : undefined;\n        }\n        get licenseUrl() {\n            return this.gallery && this.gallery.assets.license ? this.gallery.assets.license.uri : undefined;\n        }\n        get state() {\n            return this.stateProvider(this);\n        }\n        get installCount() {\n            return this.gallery ? this.gallery.installCount : undefined;\n        }\n        get rating() {\n            return this.gallery ? this.gallery.rating : undefined;\n        }\n        get ratingCount() {\n            return this.gallery ? this.gallery.ratingCount : undefined;\n        }\n        get outdated() {\n            return !!this.gallery && this.type === extensions_2.ExtensionType.User && semver.gt(this.latestVersion, this.version);\n        }\n        get telemetryData() {\n            const { local, gallery } = this;\n            if (gallery) {\n                return extensionManagementUtil_1.getGalleryExtensionTelemetryData(gallery);\n            }\n            else {\n                return extensionManagementUtil_1.getLocalExtensionTelemetryData(local);\n            }\n        }\n        get preview() {\n            return this.gallery ? this.gallery.preview : false;\n        }\n        isGalleryOutdated() {\n            return this.local && this.gallery ? semver.gt(this.local.manifest.version, this.gallery.version) : false;\n        }\n        getManifest(token) {\n            if (this.gallery && !this.isGalleryOutdated()) {\n                if (this.gallery.assets.manifest) {\n                    return this.galleryService.getManifest(this.gallery, token);\n                }\n                this.logService.error(nls.localize('Manifest is not found', \"Manifest is not found\"), this.identifier.id);\n                return Promise.resolve(null);\n            }\n            return Promise.resolve(this.local.manifest);\n        }\n        hasReadme() {\n            if (this.gallery && !this.isGalleryOutdated() && this.gallery.assets.readme) {\n                return true;\n            }\n            if (this.local && this.local.readmeUrl) {\n                return true;\n            }\n            return this.type === extensions_2.ExtensionType.System;\n        }\n        getReadme(token) {\n            if (this.gallery && !this.isGalleryOutdated()) {\n                if (this.gallery.assets.readme) {\n                    return this.galleryService.getReadme(this.gallery, token);\n                }\n                this.telemetryService.publicLog('extensions:NotFoundReadMe', this.telemetryData);\n            }\n            if (this.local && this.local.readmeUrl) {\n                return this.fileService.resolveContent(this.local.readmeUrl, { encoding: 'utf8' }).then(content => content.value);\n            }\n            if (this.type === extensions_2.ExtensionType.System) {\n                return Promise.resolve(`# ${this.displayName || this.name}\n**Notice:** This extension is bundled with Visual Studio Code. It can be disabled but not uninstalled.\n## Features\n${this.description}\n`);\n            }\n            return Promise.reject(new Error('not available'));\n        }\n        hasChangelog() {\n            if (this.gallery && this.gallery.assets.changelog && !this.isGalleryOutdated()) {\n                return true;\n            }\n            if (this.local && this.local.changelogUrl) {\n                return true;\n            }\n            return this.type === extensions_2.ExtensionType.System;\n        }\n        getChangelog(token) {\n            if (this.gallery && this.gallery.assets.changelog && !this.isGalleryOutdated()) {\n                return this.galleryService.getChangelog(this.gallery, token);\n            }\n            const changelogUrl = this.local && this.local.changelogUrl;\n            if (!changelogUrl) {\n                if (this.type === extensions_2.ExtensionType.System) {\n                    return Promise.resolve('Please check the [VS Code Release Notes](command:update.showCurrentReleaseNotes) for changes to the built-in extensions.');\n                }\n                return Promise.reject(new Error('not available'));\n            }\n            return this.fileService.resolveContent(changelogUrl, { encoding: 'utf8' }).then(content => content.value);\n        }\n        get dependencies() {\n            const { local, gallery } = this;\n            if (gallery && !this.isGalleryOutdated()) {\n                return gallery.properties.dependencies || [];\n            }\n            if (local && local.manifest.extensionDependencies) {\n                return local.manifest.extensionDependencies;\n            }\n            return [];\n        }\n        get extensionPack() {\n            const { local, gallery } = this;\n            if (gallery && !this.isGalleryOutdated()) {\n                return gallery.properties.extensionPack || [];\n            }\n            if (local && local.manifest.extensionPack) {\n                return local.manifest.extensionPack;\n            }\n            return [];\n        }\n    }\n    class ExtensionDependencies {\n        constructor(_extension, _identifier, _map, _dependent = null) {\n            this._extension = _extension;\n            this._identifier = _identifier;\n            this._map = _map;\n            this._dependent = _dependent;\n            this._hasDependencies = null;\n        }\n        get hasDependencies() {\n            if (this._hasDependencies === null) {\n                this._hasDependencies = this.computeHasDependencies();\n            }\n            return this._hasDependencies;\n        }\n        get extension() {\n            return this._extension;\n        }\n        get identifier() {\n            return this._identifier;\n        }\n        get dependent() {\n            return this._dependent;\n        }\n        get dependencies() {\n            if (!this.hasDependencies) {\n                return [];\n            }\n            return this._extension.dependencies.map(id => new ExtensionDependencies(this._map.get(id), id, this._map, this));\n        }\n        computeHasDependencies() {\n            if (this._extension && this._extension.dependencies.length > 0) {\n                let dependent = this._dependent;\n                while (dependent !== null) {\n                    if (dependent.identifier === this.identifier) {\n                        return false;\n                    }\n                    dependent = dependent.dependent;\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n    let ExtensionsWorkbenchService = class ExtensionsWorkbenchService {\n        constructor(instantiationService, editorService, extensionService, galleryService, configurationService, telemetryService, notificationService, urlService, extensionEnablementService, windowService, logService, progressService, extensionManagementServerService, storageService, fileService) {\n            this.instantiationService = instantiationService;\n            this.editorService = editorService;\n            this.extensionService = extensionService;\n            this.galleryService = galleryService;\n            this.configurationService = configurationService;\n            this.telemetryService = telemetryService;\n            this.notificationService = notificationService;\n            this.extensionEnablementService = extensionEnablementService;\n            this.windowService = windowService;\n            this.logService = logService;\n            this.progressService = progressService;\n            this.extensionManagementServerService = extensionManagementServerService;\n            this.storageService = storageService;\n            this.fileService = fileService;\n            this.installing = [];\n            this.uninstalling = [];\n            this.installed = [];\n            this.disposables = [];\n            this._onChange = new event_1.Emitter();\n            this.stateProvider = ext => this.getExtensionState(ext);\n            extensionService.onInstallExtension(this.onInstallExtension, this, this.disposables);\n            extensionService.onDidInstallExtension(this.onDidInstallExtension, this, this.disposables);\n            extensionService.onUninstallExtension(this.onUninstallExtension, this, this.disposables);\n            extensionService.onDidUninstallExtension(this.onDidUninstallExtension, this, this.disposables);\n            extensionEnablementService.onEnablementChanged(this.onEnablementChanged, this, this.disposables);\n            this.syncDelayer = new async_1.ThrottledDelayer(ExtensionsWorkbenchService.SyncPeriod);\n            this.autoUpdateDelayer = new async_1.ThrottledDelayer(1000);\n            urlService.registerHandler(this);\n            this.configurationService.onDidChangeConfiguration(e => {\n                if (e.affectsConfiguration(extensions_1.AutoUpdateConfigurationKey)) {\n                    if (this.isAutoUpdateEnabled()) {\n                        this.checkForUpdates();\n                    }\n                }\n                if (e.affectsConfiguration(extensions_1.AutoCheckUpdatesConfigurationKey)) {\n                    if (this.isAutoCheckUpdatesEnabled()) {\n                        this.checkForUpdates();\n                    }\n                }\n            }, this, this.disposables);\n            this.queryLocal().then(() => {\n                this.resetIgnoreAutoUpdateExtensions();\n                this.eventuallySyncWithGallery(true);\n            });\n        }\n        get onChange() { return this._onChange.event; }\n        get local() {\n            const installing = this.installing\n                .filter(e => !this.installed.some(installed => extensionManagementUtil_1.areSameExtensions(installed.identifier, e.identifier)))\n                .map(e => e);\n            return [...this.installed, ...installing];\n        }\n        queryLocal() {\n            return this.extensionService.getInstalled()\n                .then(installed => {\n                if (this.extensionManagementServerService.remoteExtensionManagementServer) {\n                    installed = installed.filter(installed => this.belongsToWindow(installed));\n                }\n                const installedById = arrays_1.index(this.installed, e => e.identifier.id);\n                this.installed = installed.map(local => {\n                    const extension = installedById[local.identifier.id] || new Extension(this.galleryService, this.stateProvider, local, undefined, this.telemetryService, this.logService, this.fileService);\n                    extension.enablementState = this.extensionEnablementService.getEnablementState(local);\n                    return extension;\n                });\n                this._onChange.fire(undefined);\n                return this.local;\n            });\n        }\n        queryGallery(arg1, arg2) {\n            const options = cancellation_1.CancellationToken.isCancellationToken(arg1) ? {} : arg1;\n            const token = cancellation_1.CancellationToken.isCancellationToken(arg1) ? arg1 : arg2;\n            return this.extensionService.getExtensionsReport()\n                .then(report => {\n                const maliciousSet = extensionManagementUtil_1.getMaliciousExtensionsSet(report);\n                return this.galleryService.query(options, token)\n                    .then(result => paging_1.mapPager(result, gallery => this.fromGallery(gallery, maliciousSet)))\n                    .then(undefined, err => {\n                    if (/No extension gallery service configured/.test(err.message)) {\n                        return Promise.resolve(paging_1.singlePagePager([]));\n                    }\n                    return Promise.reject(err);\n                });\n            });\n        }\n        loadDependencies(extension, token) {\n            if (!extension.dependencies.length) {\n                return Promise.resolve(null);\n            }\n            return this.extensionService.getExtensionsReport()\n                .then(report => {\n                const maliciousSet = extensionManagementUtil_1.getMaliciousExtensionsSet(report);\n                return this.galleryService.loadAllDependencies(extension.dependencies.map(id => ({ id })), token)\n                    .then(galleryExtensions => {\n                    const extensions = [...this.local, ...galleryExtensions.map(galleryExtension => this.fromGallery(galleryExtension, maliciousSet))];\n                    const map = new Map();\n                    for (const extension of extensions) {\n                        map.set(extension.identifier.id, extension);\n                    }\n                    return new ExtensionDependencies(extension, extension.identifier.id, map);\n                });\n            });\n        }\n        open(extension, sideByside = false) {\n            return Promise.resolve(this.editorService.openEditor(this.instantiationService.createInstance(extensionsInput_1.ExtensionsInput, extension), undefined, sideByside ? editorService_1.SIDE_GROUP : editorService_1.ACTIVE_GROUP));\n        }\n        belongsToWindow(extension) {\n            if (!this.extensionManagementServerService.remoteExtensionManagementServer) {\n                return true;\n            }\n            const extensionManagementServer = this.extensionManagementServerService.getExtensionManagementServer(extension.location);\n            if (extensionsUtil_1.isUIExtension(extension.manifest, this.configurationService)) {\n                if (this.extensionManagementServerService.localExtensionManagementServer === extensionManagementServer) {\n                    return true;\n                }\n            }\n            else {\n                if (this.extensionManagementServerService.remoteExtensionManagementServer === extensionManagementServer) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        fromGallery(gallery, maliciousExtensionSet) {\n            let result = this.getInstalledExtensionMatchingGallery(gallery);\n            if (result) {\n                // Loading the compatible version only there is an engine property\n                // Otherwise falling back to old way so that we will not make many roundtrips\n                if (gallery.properties.engine) {\n                    this.galleryService.getCompatibleExtension(gallery)\n                        .then(compatible => compatible ? this.syncLocalWithGalleryExtension(result, compatible) : null);\n                }\n                else {\n                    this.syncLocalWithGalleryExtension(result, gallery);\n                }\n            }\n            else {\n                result = new Extension(this.galleryService, this.stateProvider, undefined, gallery, this.telemetryService, this.logService, this.fileService);\n            }\n            if (maliciousExtensionSet.has(result.identifier.id)) {\n                result.isMalicious = true;\n            }\n            return result;\n        }\n        getInstalledExtensionMatchingGallery(gallery) {\n            for (const installed of this.installed) {\n                if (installed.uuid) { // Installed from Gallery\n                    if (installed.uuid === gallery.identifier.uuid) {\n                        return installed;\n                    }\n                }\n                else {\n                    if (extensionManagementUtil_1.areSameExtensions(installed.identifier, gallery.identifier)) { // Installed from other sources\n                        return installed;\n                    }\n                }\n            }\n            return null;\n        }\n        syncLocalWithGalleryExtension(extension, gallery) {\n            // Sync the local extension with gallery extension if local extension doesnot has metadata\n            if (extension.local) {\n                (extension.local.metadata ? Promise.resolve(extension.local) : this.extensionService.updateMetadata(extension.local, { id: gallery.identifier.uuid, publisherDisplayName: gallery.publisherDisplayName, publisherId: gallery.publisherId }))\n                    .then(local => {\n                    extension.local = local;\n                    extension.gallery = gallery;\n                    this._onChange.fire(extension);\n                    this.eventuallyAutoUpdateExtensions();\n                });\n            }\n            else {\n                this._onChange.fire(extension);\n            }\n        }\n        checkForUpdates() {\n            return Promise.resolve(this.syncDelayer.trigger(() => this.syncWithGallery(), 0));\n        }\n        isAutoUpdateEnabled() {\n            return this.configurationService.getValue(extensions_1.AutoUpdateConfigurationKey);\n        }\n        isAutoCheckUpdatesEnabled() {\n            return this.configurationService.getValue(extensions_1.AutoCheckUpdatesConfigurationKey);\n        }\n        eventuallySyncWithGallery(immediate = false) {\n            const shouldSync = this.isAutoUpdateEnabled() || this.isAutoCheckUpdatesEnabled();\n            const loop = () => (shouldSync ? this.syncWithGallery() : Promise.resolve(undefined)).then(() => this.eventuallySyncWithGallery());\n            const delay = immediate ? 0 : ExtensionsWorkbenchService.SyncPeriod;\n            this.syncDelayer.trigger(loop, delay)\n                .then(undefined, err => null);\n        }\n        syncWithGallery() {\n            const ids = [], names = [];\n            for (const installed of this.installed) {\n                if (installed.type === extensions_2.ExtensionType.User) {\n                    if (installed.uuid) {\n                        ids.push(installed.uuid);\n                    }\n                    else {\n                        names.push(installed.identifier.id);\n                    }\n                }\n            }\n            const promises = [];\n            if (ids.length) {\n                promises.push(this.queryGallery({ ids, pageSize: ids.length }, cancellation_1.CancellationToken.None));\n            }\n            if (names.length) {\n                promises.push(this.queryGallery({ names, pageSize: names.length }, cancellation_1.CancellationToken.None));\n            }\n            return Promise.all(promises).then(() => undefined);\n        }\n        eventuallyAutoUpdateExtensions() {\n            this.autoUpdateDelayer.trigger(() => this.autoUpdateExtensions())\n                .then(undefined, err => null);\n        }\n        autoUpdateExtensions() {\n            if (!this.isAutoUpdateEnabled()) {\n                return Promise.resolve();\n            }\n            const toUpdate = this.local.filter(e => e.outdated && e.state !== extensions_1.ExtensionState.Installing\n                && e.local && !this.isAutoUpdateIgnored(new extensions_2.ExtensionIdentifierWithVersion(e.identifier, e.version)));\n            return Promise.all(toUpdate.map(e => this.install(e)));\n        }\n        canInstall(extension) {\n            if (!(extension instanceof Extension)) {\n                return false;\n            }\n            if (extension.isMalicious) {\n                return false;\n            }\n            return !!extension.gallery;\n        }\n        install(extension) {\n            if (typeof extension === 'string') {\n                return this.installWithProgress(() => __awaiter(this, void 0, void 0, function* () {\n                    const extensionIdentifier = yield this.extensionService.install(uri_1.URI.file(extension));\n                    this.checkAndEnableDisabledDependencies(extensionIdentifier);\n                    return this.local.filter(local => extensionManagementUtil_1.areSameExtensions(local.identifier, extensionIdentifier))[0];\n                }));\n            }\n            if (extension.isMalicious) {\n                return Promise.reject(new Error(nls.localize('malicious', \"This extension is reported to be problematic.\")));\n            }\n            const gallery = extension.gallery;\n            if (!gallery) {\n                return Promise.reject(new Error('Missing gallery'));\n            }\n            return this.installWithProgress(() => __awaiter(this, void 0, void 0, function* () {\n                yield this.extensionService.installFromGallery(gallery);\n                this.checkAndEnableDisabledDependencies(gallery.identifier);\n                return this.local.filter(local => extensionManagementUtil_1.areSameExtensions(local.identifier, gallery.identifier))[0];\n            }), gallery.displayName);\n        }\n        setEnablement(extensions, enablementState) {\n            extensions = Array.isArray(extensions) ? extensions : [extensions];\n            return this.promptAndSetEnablement(extensions, enablementState);\n        }\n        uninstall(extension) {\n            const ext = extension.local ? extension : this.installed.filter(e => extensionManagementUtil_1.areSameExtensions(e.identifier, extension.identifier))[0];\n            const toUninstall = ext && ext.local ? ext.local : null;\n            if (!toUninstall) {\n                return Promise.reject(new Error('Missing local'));\n            }\n            this.logService.info(`Requested uninstalling the extension ${extension.identifier.id} from window ${this.windowService.getCurrentWindowId()}`);\n            return this.progressService.withProgress({\n                location: progress_1.ProgressLocation.Extensions,\n                title: nls.localize('uninstallingExtension', 'Uninstalling extension....'),\n                source: `${toUninstall.identifier.id}`\n            }, () => this.extensionService.uninstall(toUninstall).then(() => undefined));\n        }\n        installVersion(extension, version) {\n            if (!(extension instanceof Extension)) {\n                return Promise.resolve(extension);\n            }\n            if (!extension.gallery) {\n                return Promise.reject(new Error('Missing gallery'));\n            }\n            return this.galleryService.getCompatibleExtension(extension.gallery.identifier, version)\n                .then(gallery => {\n                if (!gallery) {\n                    return Promise.reject(new Error(nls.localize('incompatible', \"Unable to install extension '{0}' with version '{1}' as it is not compatible with VS Code.\", extension.gallery.identifier.id, version)));\n                }\n                return this.installWithProgress(() => __awaiter(this, void 0, void 0, function* () {\n                    yield this.extensionService.installFromGallery(gallery);\n                    if (extension.latestVersion !== version) {\n                        this.ignoreAutoUpdate(new extensions_2.ExtensionIdentifierWithVersion(gallery.identifier, version));\n                    }\n                    return this.local.filter(local => extensionManagementUtil_1.areSameExtensions(local.identifier, gallery.identifier))[0];\n                }), gallery.displayName);\n            });\n        }\n        reinstall(extension) {\n            const ext = extension.local ? extension : this.installed.filter(e => extensionManagementUtil_1.areSameExtensions(e.identifier, extension.identifier))[0];\n            const toReinstall = ext && ext.local ? ext.local : null;\n            if (!toReinstall) {\n                return Promise.reject(new Error('Missing local'));\n            }\n            return this.progressService.withProgress({\n                location: progress_1.ProgressLocation.Extensions,\n                source: `${toReinstall.identifier.id}`\n            }, () => this.extensionService.reinstallFromGallery(toReinstall).then(() => this.local.filter(local => extensionManagementUtil_1.areSameExtensions(local.identifier, extension.identifier))[0]));\n        }\n        installWithProgress(installTask, extensionName) {\n            const title = extensionName ? nls.localize('installing named extension', \"Installing '{0}' extension....\", extensionName) : nls.localize('installing extension', 'Installing extension....');\n            return this.progressService.withProgress({\n                location: progress_1.ProgressLocation.Extensions,\n                title\n            }, () => installTask());\n        }\n        checkAndEnableDisabledDependencies(extensionIdentifier) {\n            const extension = this.local.filter(e => (e.local || e.gallery) && extensionManagementUtil_1.areSameExtensions(extensionIdentifier, e.identifier))[0];\n            if (extension) {\n                const disabledDepencies = this.getExtensionsRecursively([extension], this.local, extensionManagement_1.EnablementState.Enabled, { dependencies: true, pack: false });\n                if (disabledDepencies.length) {\n                    return this.setEnablement(disabledDepencies, extensionManagement_1.EnablementState.Enabled);\n                }\n            }\n            return Promise.resolve();\n        }\n        promptAndSetEnablement(extensions, enablementState) {\n            const enable = enablementState === extensionManagement_1.EnablementState.Enabled || enablementState === extensionManagement_1.EnablementState.WorkspaceEnabled;\n            if (enable) {\n                const allDependenciesAndPackedExtensions = this.getExtensionsRecursively(extensions, this.local, enablementState, { dependencies: true, pack: true });\n                return this.checkAndSetEnablement(extensions, allDependenciesAndPackedExtensions, enablementState);\n            }\n            else {\n                const packedExtensions = this.getExtensionsRecursively(extensions, this.local, enablementState, { dependencies: false, pack: true });\n                if (packedExtensions.length) {\n                    return this.checkAndSetEnablement(extensions, packedExtensions, enablementState);\n                }\n                return this.checkAndSetEnablement(extensions, [], enablementState);\n            }\n        }\n        checkAndSetEnablement(extensions, otherExtensions, enablementState) {\n            const allExtensions = [...extensions, ...otherExtensions];\n            const enable = enablementState === extensionManagement_1.EnablementState.Enabled || enablementState === extensionManagement_1.EnablementState.WorkspaceEnabled;\n            if (!enable) {\n                for (const extension of extensions) {\n                    let dependents = this.getDependentsAfterDisablement(extension, allExtensions, this.local);\n                    if (dependents.length) {\n                        return Promise.reject(new Error(this.getDependentsErrorMessage(extension, allExtensions, dependents)));\n                    }\n                }\n            }\n            return this.doSetEnablement(allExtensions, enablementState);\n        }\n        getExtensionsRecursively(extensions, installed, enablementState, options, checked = []) {\n            const toCheck = extensions.filter(e => checked.indexOf(e) === -1);\n            if (toCheck.length) {\n                for (const extension of toCheck) {\n                    checked.push(extension);\n                }\n                const extensionsToDisable = installed.filter(i => {\n                    if (checked.indexOf(i) !== -1) {\n                        return false;\n                    }\n                    if (i.enablementState === enablementState) {\n                        return false;\n                    }\n                    const enable = enablementState === extensionManagement_1.EnablementState.Enabled || enablementState === extensionManagement_1.EnablementState.WorkspaceEnabled;\n                    return (enable || i.type === extensions_2.ExtensionType.User) // Include all Extensions for enablement and only user extensions for disablement\n                        && (options.dependencies || options.pack)\n                        && extensions.some(extension => (options.dependencies && extension.dependencies.some(id => extensionManagementUtil_1.areSameExtensions({ id }, i.identifier)))\n                            || (options.pack && extension.extensionPack.some(id => extensionManagementUtil_1.areSameExtensions({ id }, i.identifier))));\n                });\n                if (extensionsToDisable.length) {\n                    extensionsToDisable.push(...this.getExtensionsRecursively(extensionsToDisable, installed, enablementState, options, checked));\n                }\n                return extensionsToDisable;\n            }\n            return [];\n        }\n        getDependentsAfterDisablement(extension, extensionsToDisable, installed) {\n            return installed.filter(i => {\n                if (i.dependencies.length === 0) {\n                    return false;\n                }\n                if (i === extension) {\n                    return false;\n                }\n                if (i.enablementState === extensionManagement_1.EnablementState.WorkspaceDisabled || i.enablementState === extensionManagement_1.EnablementState.Disabled) {\n                    return false;\n                }\n                if (extensionsToDisable.indexOf(i) !== -1) {\n                    return false;\n                }\n                return i.dependencies.some(dep => [extension, ...extensionsToDisable].some(d => extensionManagementUtil_1.areSameExtensions(d.identifier, { id: dep })));\n            });\n        }\n        getDependentsErrorMessage(extension, allDisabledExtensions, dependents) {\n            for (const e of [extension, ...allDisabledExtensions]) {\n                let dependentsOfTheExtension = dependents.filter(d => d.dependencies.some(id => extensionManagementUtil_1.areSameExtensions({ id }, e.identifier)));\n                if (dependentsOfTheExtension.length) {\n                    return this.getErrorMessageForDisablingAnExtensionWithDependents(e, dependentsOfTheExtension);\n                }\n            }\n            return '';\n        }\n        getErrorMessageForDisablingAnExtensionWithDependents(extension, dependents) {\n            if (dependents.length === 1) {\n                return nls.localize('singleDependentError', \"Cannot disable extension '{0}'. Extension '{1}' depends on this.\", extension.displayName, dependents[0].displayName);\n            }\n            if (dependents.length === 2) {\n                return nls.localize('twoDependentsError', \"Cannot disable extension '{0}'. Extensions '{1}' and '{2}' depend on this.\", extension.displayName, dependents[0].displayName, dependents[1].displayName);\n            }\n            return nls.localize('multipleDependentsError', \"Cannot disable extension '{0}'. Extensions '{1}', '{2}' and others depend on this.\", extension.displayName, dependents[0].displayName, dependents[1].displayName);\n        }\n        doSetEnablement(extensions, enablementState) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const changed = yield this.extensionEnablementService.setEnablement(extensions.map(e => e.local), enablementState);\n                for (let i = 0; i < changed.length; i++) {\n                    if (changed[i]) {\n                        /* __GDPR__\n                        \"extension:enable\" : {\n                            \"${include}\": [\n                                \"${GalleryExtensionTelemetryData}\"\n                            ]\n                        }\n                        */\n                        /* __GDPR__\n                        \"extension:disable\" : {\n                            \"${include}\": [\n                                \"${GalleryExtensionTelemetryData}\"\n                            ]\n                        }\n                        */\n                        this.telemetryService.publicLog(enablementState === extensionManagement_1.EnablementState.Enabled || enablementState === extensionManagement_1.EnablementState.WorkspaceEnabled ? 'extension:enable' : 'extension:disable', extensions[i].telemetryData);\n                    }\n                }\n                return changed;\n            });\n        }\n        get allowedBadgeProviders() {\n            if (!this._extensionAllowedBadgeProviders) {\n                this._extensionAllowedBadgeProviders = (product_1.default.extensionAllowedBadgeProviders || []).map(s => s.toLowerCase());\n            }\n            return this._extensionAllowedBadgeProviders;\n        }\n        onInstallExtension(event) {\n            const { gallery } = event;\n            if (!gallery) {\n                return;\n            }\n            let extension = this.installed.filter(e => extensionManagementUtil_1.areSameExtensions(e.identifier, gallery.identifier))[0];\n            if (!extension) {\n                extension = new Extension(this.galleryService, this.stateProvider, undefined, gallery, this.telemetryService, this.logService, this.fileService);\n            }\n            this.installing.push(extension);\n            this._onChange.fire(extension);\n        }\n        onDidInstallExtension(event) {\n            const { local, zipPath, error, gallery } = event;\n            const installingExtension = gallery ? this.installing.filter(e => extensionManagementUtil_1.areSameExtensions(e.identifier, gallery.identifier))[0] : null;\n            this.installing = installingExtension ? this.installing.filter(e => e !== installingExtension) : this.installing;\n            if (local && !this.belongsToWindow(local)) {\n                return;\n            }\n            let extension = installingExtension ? installingExtension : zipPath ? new Extension(this.galleryService, this.stateProvider, local, undefined, this.telemetryService, this.logService, this.fileService) : undefined;\n            if (extension) {\n                if (local) {\n                    const installed = this.installed.filter(e => extensionManagementUtil_1.areSameExtensions(e.identifier, extension.identifier))[0];\n                    if (installed) {\n                        extension = installed;\n                    }\n                    else {\n                        this.installed.push(extension);\n                    }\n                    extension.local = local;\n                    extension.gallery = gallery;\n                }\n            }\n            this._onChange.fire(error ? undefined : extension);\n        }\n        onUninstallExtension(identifier) {\n            const extension = this.installed.filter(e => extensionManagementUtil_1.areSameExtensions(e.identifier, identifier))[0];\n            if (!extension) {\n                return;\n            }\n            const uninstalling = this.uninstalling.filter(e => extensionManagementUtil_1.areSameExtensions(e.identifier, identifier))[0] || extension;\n            this.uninstalling = [uninstalling, ...this.uninstalling.filter(e => !extensionManagementUtil_1.areSameExtensions(e.identifier, identifier))];\n            this._onChange.fire(uninstalling);\n        }\n        onDidUninstallExtension({ identifier, error }) {\n            if (!error) {\n                this.installed = this.installed.filter(e => !extensionManagementUtil_1.areSameExtensions(e.identifier, identifier));\n            }\n            const uninstalling = this.uninstalling.filter(e => extensionManagementUtil_1.areSameExtensions(e.identifier, identifier))[0];\n            this.uninstalling = this.uninstalling.filter(e => !extensionManagementUtil_1.areSameExtensions(e.identifier, identifier));\n            if (!uninstalling) {\n                return;\n            }\n            this._onChange.fire(uninstalling);\n        }\n        onEnablementChanged(platformExtensions) {\n            const extensions = this.local.filter(e => platformExtensions.some(p => extensionManagementUtil_1.areSameExtensions(e.identifier, p.identifier)));\n            for (const extension of extensions) {\n                if (extension.local) {\n                    const enablementState = this.extensionEnablementService.getEnablementState(extension.local);\n                    if (enablementState !== extension.enablementState) {\n                        extension.enablementState = enablementState;\n                        this._onChange.fire(extension);\n                    }\n                }\n            }\n        }\n        getExtensionState(extension) {\n            if (extension.gallery && this.installing.some(e => !!e.gallery && extensionManagementUtil_1.areSameExtensions(e.gallery.identifier, extension.gallery.identifier))) {\n                return extensions_1.ExtensionState.Installing;\n            }\n            if (this.uninstalling.some(e => extensionManagementUtil_1.areSameExtensions(e.identifier, extension.identifier))) {\n                return extensions_1.ExtensionState.Uninstalling;\n            }\n            const local = this.installed.filter(e => e === extension || (e.gallery && extension.gallery && extensionManagementUtil_1.areSameExtensions(e.gallery.identifier, extension.gallery.identifier)))[0];\n            return local ? extensions_1.ExtensionState.Installed : extensions_1.ExtensionState.Uninstalled;\n        }\n        onError(err) {\n            if (errors_1.isPromiseCanceledError(err)) {\n                return;\n            }\n            const message = err && err.message || '';\n            if (/getaddrinfo ENOTFOUND|getaddrinfo ENOENT|connect EACCES|connect ECONNREFUSED/.test(message)) {\n                return;\n            }\n            this.notificationService.error(err);\n        }\n        handleURL(uri) {\n            if (!/^extension/.test(uri.path)) {\n                return Promise.resolve(false);\n            }\n            this.onOpenExtensionUrl(uri);\n            return Promise.resolve(true);\n        }\n        onOpenExtensionUrl(uri) {\n            const match = /^extension\\/([^/]+)$/.exec(uri.path);\n            if (!match) {\n                return;\n            }\n            const extensionId = match[1];\n            this.queryLocal().then(local => {\n                const extension = local.filter(local => extensionManagementUtil_1.areSameExtensions(local.identifier, { id: extensionId }))[0];\n                if (extension) {\n                    return this.windowService.focusWindow()\n                        .then(() => this.open(extension));\n                }\n                return this.queryGallery({ names: [extensionId], source: 'uri' }, cancellation_1.CancellationToken.None).then(result => {\n                    if (result.total < 1) {\n                        return Promise.resolve(null);\n                    }\n                    const extension = result.firstPage[0];\n                    return this.windowService.focusWindow().then(() => {\n                        return this.open(extension).then(() => {\n                            this.notificationService.prompt(severity_1.default.Info, nls.localize('installConfirmation', \"Would you like to install the '{0}' extension?\", extension.displayName, extension.publisher), [{\n                                    label: nls.localize('install', \"Install\"),\n                                    run: () => this.install(extension).then(undefined, error => this.onError(error))\n                                }], { sticky: true });\n                        });\n                    });\n                });\n            }).then(undefined, error => this.onError(error));\n        }\n        get ignoredAutoUpdateExtensions() {\n            if (!this._ignoredAutoUpdateExtensions) {\n                this._ignoredAutoUpdateExtensions = JSON.parse(this.storageService.get('extensions.ignoredAutoUpdateExtension', storage_1.StorageScope.GLOBAL, '[]') || '[]');\n            }\n            return this._ignoredAutoUpdateExtensions;\n        }\n        set ignoredAutoUpdateExtensions(extensionIds) {\n            this._ignoredAutoUpdateExtensions = arrays_1.distinct(extensionIds.map(id => id.toLowerCase()));\n            this.storageService.store('extensions.ignoredAutoUpdateExtension', JSON.stringify(this._ignoredAutoUpdateExtensions), storage_1.StorageScope.GLOBAL);\n        }\n        ignoreAutoUpdate(identifierWithVersion) {\n            if (!this.isAutoUpdateIgnored(identifierWithVersion)) {\n                this.ignoredAutoUpdateExtensions = [...this.ignoredAutoUpdateExtensions, identifierWithVersion.key()];\n            }\n        }\n        isAutoUpdateIgnored(identifierWithVersion) {\n            return this.ignoredAutoUpdateExtensions.indexOf(identifierWithVersion.key()) !== -1;\n        }\n        resetIgnoreAutoUpdateExtensions() {\n            this.ignoredAutoUpdateExtensions = this.ignoredAutoUpdateExtensions.filter(extensionId => this.local.some(local => !!local.local && new extensions_2.ExtensionIdentifierWithVersion(local.identifier, local.version).key() === extensionId));\n        }\n        dispose() {\n            this.syncDelayer.cancel();\n            this.disposables = lifecycle_1.dispose(this.disposables);\n        }\n    };\n    ExtensionsWorkbenchService.SyncPeriod = 1000 * 60 * 60 * 12; // 12 hours\n    ExtensionsWorkbenchService = __decorate([\n        __param(0, instantiation_1.IInstantiationService),\n        __param(1, editorService_1.IEditorService),\n        __param(2, extensionManagement_1.IExtensionManagementService),\n        __param(3, extensionManagement_1.IExtensionGalleryService),\n        __param(4, configuration_1.IConfigurationService),\n        __param(5, telemetry_1.ITelemetryService),\n        __param(6, notification_1.INotificationService),\n        __param(7, url_1.IURLService),\n        __param(8, extensionManagement_1.IExtensionEnablementService),\n        __param(9, windows_1.IWindowService),\n        __param(10, log_1.ILogService),\n        __param(11, progress_1.IProgressService2),\n        __param(12, extensionManagement_1.IExtensionManagementServerService),\n        __param(13, storage_1.IStorageService),\n        __param(14, files_1.IFileService)\n    ], ExtensionsWorkbenchService);\n    exports.ExtensionsWorkbenchService = ExtensionsWorkbenchService;\n});\n",null]}