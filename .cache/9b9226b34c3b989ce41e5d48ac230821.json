{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/objectTreeModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/objectTreeModel.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar iterator_1 = require(\"vs/base/common/iterator\");\nvar indexTreeModel_1 = require(\"vs/base/browser/ui/tree/indexTreeModel\");\nvar ObjectTreeModel = /** @class */ (function () {\n    function ObjectTreeModel(list, options) {\n        if (options === void 0) { options = {}; }\n        this.rootRef = null;\n        this.nodes = new Map();\n        this.model = new indexTreeModel_1.IndexTreeModel(list, null, options);\n        this.onDidSplice = this.model.onDidSplice;\n        this.onDidChangeCollapseState = this.model.onDidChangeCollapseState;\n        this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount;\n        if (options.sorter) {\n            this.sorter = {\n                compare: function (a, b) {\n                    return options.sorter.compare(a.element, b.element);\n                }\n            };\n        }\n    }\n    Object.defineProperty(ObjectTreeModel.prototype, \"size\", {\n        get: function () { return this.nodes.size; },\n        enumerable: true,\n        configurable: true\n    });\n    ObjectTreeModel.prototype.setChildren = function (element, children, onDidCreateNode, onDidDeleteNode) {\n        var location = this.getElementLocation(element);\n        return this._setChildren(location, this.preserveCollapseState(children), onDidCreateNode, onDidDeleteNode);\n    };\n    ObjectTreeModel.prototype._setChildren = function (location, children, onDidCreateNode, onDidDeleteNode) {\n        var _this = this;\n        var insertedElements = new Set();\n        var _onDidCreateNode = function (node) {\n            insertedElements.add(node.element);\n            _this.nodes.set(node.element, node);\n            if (onDidCreateNode) {\n                onDidCreateNode(node);\n            }\n        };\n        var _onDidDeleteNode = function (node) {\n            if (!insertedElements.has(node.element)) {\n                _this.nodes.delete(node.element);\n            }\n            if (onDidDeleteNode) {\n                onDidDeleteNode(node);\n            }\n        };\n        return this.model.splice(location.concat([0]), Number.MAX_VALUE, children, _onDidCreateNode, _onDidDeleteNode);\n    };\n    ObjectTreeModel.prototype.preserveCollapseState = function (elements) {\n        var _this = this;\n        var iterator = elements ? iterator_1.getSequenceIterator(elements) : iterator_1.Iterator.empty();\n        if (this.sorter) {\n            iterator = iterator_1.Iterator.fromArray(iterator_1.Iterator.collect(iterator).sort(this.sorter.compare.bind(this.sorter)));\n        }\n        return iterator_1.Iterator.map(iterator, function (treeElement) {\n            var node = _this.nodes.get(treeElement.element);\n            if (!node) {\n                return tslib_1.__assign({}, treeElement, { children: _this.preserveCollapseState(treeElement.children) });\n            }\n            var collapsible = typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : node.collapsible;\n            var collapsed = typeof treeElement.collapsed !== 'undefined' ? treeElement.collapsed : node.collapsed;\n            return tslib_1.__assign({}, treeElement, { collapsible: collapsible,\n                collapsed: collapsed, children: _this.preserveCollapseState(treeElement.children) });\n        });\n    };\n    ObjectTreeModel.prototype.rerender = function (element) {\n        var location = this.getElementLocation(element);\n        this.model.rerender(location);\n    };\n    ObjectTreeModel.prototype.resort = function (element, recursive) {\n        if (element === void 0) { element = null; }\n        if (recursive === void 0) { recursive = true; }\n        if (!this.sorter) {\n            return;\n        }\n        var location = this.getElementLocation(element);\n        var node = this.model.getNode(location);\n        this._setChildren(location, this.resortChildren(node, recursive));\n    };\n    ObjectTreeModel.prototype.resortChildren = function (node, recursive, first) {\n        var _this = this;\n        if (first === void 0) { first = true; }\n        var childrenNodes = iterator_1.Iterator.fromArray(node.children);\n        if (recursive || first) {\n            childrenNodes = iterator_1.Iterator.fromArray(iterator_1.Iterator.collect(childrenNodes).sort(this.sorter.compare.bind(this.sorter)));\n        }\n        return iterator_1.Iterator.map(childrenNodes, function (node) { return ({\n            element: node.element,\n            collapsible: node.collapsible,\n            collapsed: node.collapsed,\n            children: _this.resortChildren(node, recursive, false)\n        }); });\n    };\n    ObjectTreeModel.prototype.getParentElement = function (ref) {\n        if (ref === void 0) { ref = null; }\n        var location = this.getElementLocation(ref);\n        return this.model.getParentElement(location);\n    };\n    ObjectTreeModel.prototype.getFirstElementChild = function (ref) {\n        if (ref === void 0) { ref = null; }\n        var location = this.getElementLocation(ref);\n        return this.model.getFirstElementChild(location);\n    };\n    ObjectTreeModel.prototype.getLastElementAncestor = function (ref) {\n        if (ref === void 0) { ref = null; }\n        var location = this.getElementLocation(ref);\n        return this.model.getLastElementAncestor(location);\n    };\n    ObjectTreeModel.prototype.getListIndex = function (element) {\n        var location = this.getElementLocation(element);\n        return this.model.getListIndex(location);\n    };\n    ObjectTreeModel.prototype.getListRenderCount = function (element) {\n        var location = this.getElementLocation(element);\n        return this.model.getListRenderCount(location);\n    };\n    ObjectTreeModel.prototype.isCollapsible = function (element) {\n        var location = this.getElementLocation(element);\n        return this.model.isCollapsible(location);\n    };\n    ObjectTreeModel.prototype.isCollapsed = function (element) {\n        var location = this.getElementLocation(element);\n        return this.model.isCollapsed(location);\n    };\n    ObjectTreeModel.prototype.setCollapsed = function (element, collapsed, recursive) {\n        var location = this.getElementLocation(element);\n        return this.model.setCollapsed(location, collapsed, recursive);\n    };\n    ObjectTreeModel.prototype.expandTo = function (element) {\n        var location = this.getElementLocation(element);\n        this.model.expandTo(location);\n    };\n    ObjectTreeModel.prototype.refilter = function () {\n        this.model.refilter();\n    };\n    ObjectTreeModel.prototype.getNode = function (element) {\n        if (element === void 0) { element = null; }\n        if (element === null) {\n            return this.model.getNode(this.model.rootRef);\n        }\n        var node = this.nodes.get(element);\n        if (!node) {\n            throw new Error(\"Tree element not found: \" + element);\n        }\n        return node;\n    };\n    ObjectTreeModel.prototype.getNodeLocation = function (node) {\n        return node.element;\n    };\n    ObjectTreeModel.prototype.getParentNodeLocation = function (element) {\n        var node = this.nodes.get(element);\n        if (!node) {\n            throw new Error(\"Tree element not found: \" + element);\n        }\n        return node.parent.element;\n    };\n    ObjectTreeModel.prototype.getElementLocation = function (element) {\n        if (element === null) {\n            return [];\n        }\n        var node = this.nodes.get(element);\n        if (!node) {\n            throw new Error(\"Tree element not found: \" + element);\n        }\n        return this.model.getNodeLocation(node);\n    };\n    return ObjectTreeModel;\n}());\nexports.ObjectTreeModel = ObjectTreeModel;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/objectTreeModel.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/objectTreeModel.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ISpliceable } from 'vs/base/common/sequence';\nimport { Iterator, ISequence, getSequenceIterator } from 'vs/base/common/iterator';\nimport { IndexTreeModel, IIndexTreeModelOptions } from 'vs/base/browser/ui/tree/indexTreeModel';\nimport { Event } from 'vs/base/common/event';\nimport { ITreeModel, ITreeNode, ITreeElement, ITreeSorter, ICollapseStateChangeEvent, ITreeModelSpliceEvent } from 'vs/base/browser/ui/tree/tree';\n\nexport interface IObjectTreeModelOptions<T, TFilterData> extends IIndexTreeModelOptions<T, TFilterData> {\n\treadonly sorter?: ITreeSorter<T>;\n}\n\nexport class ObjectTreeModel<T extends NonNullable<any>, TFilterData extends NonNullable<any> = void> implements ITreeModel<T | null, TFilterData, T | null> {\n\n\treadonly rootRef = null;\n\n\tprivate model: IndexTreeModel<T | null, TFilterData>;\n\tprivate nodes = new Map<T | null, ITreeNode<T, TFilterData>>();\n\tprivate sorter?: ITreeSorter<{ element: T; }>;\n\n\treadonly onDidSplice: Event<ITreeModelSpliceEvent<T | null, TFilterData>>;\n\treadonly onDidChangeCollapseState: Event<ICollapseStateChangeEvent<T, TFilterData>>;\n\treadonly onDidChangeRenderNodeCount: Event<ITreeNode<T, TFilterData>>;\n\n\tget size(): number { return this.nodes.size; }\n\n\tconstructor(list: ISpliceable<ITreeNode<T, TFilterData>>, options: IObjectTreeModelOptions<T, TFilterData> = {}) {\n\t\tthis.model = new IndexTreeModel(list, null, options);\n\t\tthis.onDidSplice = this.model.onDidSplice;\n\t\tthis.onDidChangeCollapseState = this.model.onDidChangeCollapseState as Event<ICollapseStateChangeEvent<T, TFilterData>>;\n\t\tthis.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount as Event<ITreeNode<T, TFilterData>>;\n\n\t\tif (options.sorter) {\n\t\t\tthis.sorter = {\n\t\t\t\tcompare(a, b) {\n\t\t\t\t\treturn options.sorter!.compare(a.element, b.element);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\tsetChildren(\n\t\telement: T | null,\n\t\tchildren: ISequence<ITreeElement<T>> | undefined,\n\t\tonDidCreateNode?: (node: ITreeNode<T, TFilterData>) => void,\n\t\tonDidDeleteNode?: (node: ITreeNode<T, TFilterData>) => void\n\t): Iterator<ITreeElement<T | null>> {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this._setChildren(location, this.preserveCollapseState(children), onDidCreateNode, onDidDeleteNode);\n\t}\n\n\tprivate _setChildren(\n\t\tlocation: number[],\n\t\tchildren: ISequence<ITreeElement<T>> | undefined,\n\t\tonDidCreateNode?: (node: ITreeNode<T, TFilterData>) => void,\n\t\tonDidDeleteNode?: (node: ITreeNode<T, TFilterData>) => void\n\t): Iterator<ITreeElement<T | null>> {\n\t\tconst insertedElements = new Set<T | null>();\n\n\t\tconst _onDidCreateNode = (node: ITreeNode<T, TFilterData>) => {\n\t\t\tinsertedElements.add(node.element);\n\t\t\tthis.nodes.set(node.element, node);\n\n\t\t\tif (onDidCreateNode) {\n\t\t\t\tonDidCreateNode(node);\n\t\t\t}\n\t\t};\n\n\t\tconst _onDidDeleteNode = (node: ITreeNode<T, TFilterData>) => {\n\t\t\tif (!insertedElements.has(node.element)) {\n\t\t\t\tthis.nodes.delete(node.element);\n\t\t\t}\n\n\t\t\tif (onDidDeleteNode) {\n\t\t\t\tonDidDeleteNode(node);\n\t\t\t}\n\t\t};\n\n\t\treturn this.model.splice(\n\t\t\t[...location, 0],\n\t\t\tNumber.MAX_VALUE,\n\t\t\tchildren,\n\t\t\t_onDidCreateNode,\n\t\t\t_onDidDeleteNode\n\t\t);\n\t}\n\n\tprivate preserveCollapseState(elements: ISequence<ITreeElement<T>> | undefined): ISequence<ITreeElement<T>> {\n\t\tlet iterator = elements ? getSequenceIterator(elements) : Iterator.empty<ITreeElement<T>>();\n\n\t\tif (this.sorter) {\n\t\t\titerator = Iterator.fromArray(Iterator.collect(iterator).sort(this.sorter.compare.bind(this.sorter)));\n\t\t}\n\n\t\treturn Iterator.map(iterator, treeElement => {\n\t\t\tconst node = this.nodes.get(treeElement.element);\n\n\t\t\tif (!node) {\n\t\t\t\treturn {\n\t\t\t\t\t...treeElement,\n\t\t\t\t\tchildren: this.preserveCollapseState(treeElement.children)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst collapsible = typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : node.collapsible;\n\t\t\tconst collapsed = typeof treeElement.collapsed !== 'undefined' ? treeElement.collapsed : node.collapsed;\n\n\t\t\treturn {\n\t\t\t\t...treeElement,\n\t\t\t\tcollapsible,\n\t\t\t\tcollapsed,\n\t\t\t\tchildren: this.preserveCollapseState(treeElement.children)\n\t\t\t};\n\t\t});\n\t}\n\n\trerender(element: T): void {\n\t\tconst location = this.getElementLocation(element);\n\t\tthis.model.rerender(location);\n\t}\n\n\tresort(element: T | null = null, recursive = true): void {\n\t\tif (!this.sorter) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst location = this.getElementLocation(element);\n\t\tconst node = this.model.getNode(location);\n\n\t\tthis._setChildren(location, this.resortChildren(node, recursive));\n\t}\n\n\tprivate resortChildren(node: ITreeNode<T | null, TFilterData>, recursive: boolean, first = true): ISequence<ITreeElement<T>> {\n\t\tlet childrenNodes = Iterator.fromArray(node.children as ITreeNode<T, TFilterData>[]);\n\n\t\tif (recursive || first) {\n\t\t\tchildrenNodes = Iterator.fromArray(Iterator.collect(childrenNodes).sort(this.sorter!.compare.bind(this.sorter)));\n\t\t}\n\n\t\treturn Iterator.map<ITreeNode<T | null, TFilterData>, ITreeElement<T>>(childrenNodes, node => ({\n\t\t\telement: node.element as T,\n\t\t\tcollapsible: node.collapsible,\n\t\t\tcollapsed: node.collapsed,\n\t\t\tchildren: this.resortChildren(node, recursive, false)\n\t\t}));\n\t}\n\n\tgetParentElement(ref: T | null = null): T | null {\n\t\tconst location = this.getElementLocation(ref);\n\t\treturn this.model.getParentElement(location);\n\t}\n\n\tgetFirstElementChild(ref: T | null = null): T | null | undefined {\n\t\tconst location = this.getElementLocation(ref);\n\t\treturn this.model.getFirstElementChild(location);\n\t}\n\n\tgetLastElementAncestor(ref: T | null = null): T | null | undefined {\n\t\tconst location = this.getElementLocation(ref);\n\t\treturn this.model.getLastElementAncestor(location);\n\t}\n\n\tgetListIndex(element: T): number {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.getListIndex(location);\n\t}\n\n\tgetListRenderCount(element: T): number {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.getListRenderCount(location);\n\t}\n\n\tisCollapsible(element: T): boolean {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.isCollapsible(location);\n\t}\n\n\tisCollapsed(element: T): boolean {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.isCollapsed(location);\n\t}\n\n\tsetCollapsed(element: T, collapsed?: boolean, recursive?: boolean): boolean {\n\t\tconst location = this.getElementLocation(element);\n\t\treturn this.model.setCollapsed(location, collapsed, recursive);\n\t}\n\n\texpandTo(element: T): void {\n\t\tconst location = this.getElementLocation(element);\n\t\tthis.model.expandTo(location);\n\t}\n\n\trefilter(): void {\n\t\tthis.model.refilter();\n\t}\n\n\tgetNode(element: T | null = null): ITreeNode<T | null, TFilterData> {\n\t\tif (element === null) {\n\t\t\treturn this.model.getNode(this.model.rootRef);\n\t\t}\n\n\t\tconst node = this.nodes.get(element);\n\n\t\tif (!node) {\n\t\t\tthrow new Error(`Tree element not found: ${element}`);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tgetNodeLocation(node: ITreeNode<T, TFilterData>): T {\n\t\treturn node.element;\n\t}\n\n\tgetParentNodeLocation(element: T): T | null {\n\t\tconst node = this.nodes.get(element);\n\n\t\tif (!node) {\n\t\t\tthrow new Error(`Tree element not found: ${element}`);\n\t\t}\n\n\t\treturn node.parent!.element;\n\t}\n\n\tprivate getElementLocation(element: T | null): number[] {\n\t\tif (element === null) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst node = this.nodes.get(element);\n\n\t\tif (!node) {\n\t\t\tthrow new Error(`Tree element not found: ${element}`);\n\t\t}\n\n\t\treturn this.model.getNodeLocation(node);\n\t}\n}\n"]}]}