{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/backup/common/backupRestorer.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/backup/common/backupRestorer.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar backup_1 = require(\"vs/workbench/services/backup/common/backup\");\nvar editorService_1 = require(\"vs/workbench/services/editor/common/editorService\");\nvar network_1 = require(\"vs/base/common/network\");\nvar lifecycle_1 = require(\"vs/platform/lifecycle/common/lifecycle\");\nvar BackupRestorer = /** @class */ (function () {\n    function BackupRestorer(editorService, backupFileService, lifecycleService) {\n        this.editorService = editorService;\n        this.backupFileService = backupFileService;\n        this.lifecycleService = lifecycleService;\n        this.restoreBackups();\n    }\n    BackupRestorer.prototype.restoreBackups = function () {\n        var _this = this;\n        this.lifecycleService.when(lifecycle_1.LifecyclePhase.Restored).then(function () { return _this.doRestoreBackups(); });\n    };\n    BackupRestorer.prototype.doRestoreBackups = function () {\n        var _this = this;\n        // Find all files and untitled with backups\n        return this.backupFileService.getWorkspaceFileBackups().then(function (backups) {\n            // Resolve backups that are opened\n            return _this.doResolveOpenedBackups(backups).then(function (unresolved) {\n                // Some failed to restore or were not opened at all so we open and resolve them manually\n                if (unresolved.length > 0) {\n                    return _this.doOpenEditors(unresolved).then(function () { return _this.doResolveOpenedBackups(unresolved); });\n                }\n                return undefined;\n            });\n        });\n    };\n    BackupRestorer.prototype.doResolveOpenedBackups = function (backups) {\n        var _this = this;\n        var restorePromises = [];\n        var unresolved = [];\n        backups.forEach(function (backup) {\n            var openedEditor = _this.editorService.getOpened({ resource: backup });\n            if (openedEditor) {\n                restorePromises.push(openedEditor.resolve().then(undefined, function () { return unresolved.push(backup); }));\n            }\n            else {\n                unresolved.push(backup);\n            }\n        });\n        return Promise.all(restorePromises).then(function () { return unresolved; }, function () { return unresolved; });\n    };\n    BackupRestorer.prototype.doOpenEditors = function (resources) {\n        var _this = this;\n        var hasOpenedEditors = this.editorService.visibleEditors.length > 0;\n        var inputs = resources.map(function (resource, index) { return _this.resolveInput(resource, index, hasOpenedEditors); });\n        // Open all remaining backups as editors and resolve them to load their backups\n        return this.editorService.openEditors(inputs).then(function () { return undefined; });\n    };\n    BackupRestorer.prototype.resolveInput = function (resource, index, hasOpenedEditors) {\n        var options = { pinned: true, preserveFocus: true, inactive: index > 0 || hasOpenedEditors };\n        if (resource.scheme === network_1.Schemas.untitled && !BackupRestorer.UNTITLED_REGEX.test(resource.fsPath)) {\n            return { filePath: resource.fsPath, options: options };\n        }\n        return { resource: resource, options: options };\n    };\n    BackupRestorer.UNTITLED_REGEX = /Untitled-\\d+/;\n    BackupRestorer = tslib_1.__decorate([\n        tslib_1.__param(0, editorService_1.IEditorService),\n        tslib_1.__param(1, backup_1.IBackupFileService),\n        tslib_1.__param(2, lifecycle_1.ILifecycleService)\n    ], BackupRestorer);\n    return BackupRestorer;\n}());\nexports.BackupRestorer = BackupRestorer;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/backup/common/backupRestorer.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/backup/common/backupRestorer.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport { IWorkbenchContribution } from 'vs/workbench/common/contributions';\nimport { IBackupFileService } from 'vs/workbench/services/backup/common/backup';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\nimport { IResourceInput } from 'vs/platform/editor/common/editor';\nimport { Schemas } from 'vs/base/common/network';\nimport { ILifecycleService, LifecyclePhase } from 'vs/platform/lifecycle/common/lifecycle';\nimport { IUntitledResourceInput } from 'vs/workbench/common/editor';\n\nexport class BackupRestorer implements IWorkbenchContribution {\n\n\tprivate static readonly UNTITLED_REGEX = /Untitled-\\d+/;\n\n\tconstructor(\n\t\t@IEditorService private readonly editorService: IEditorService,\n\t\t@IBackupFileService private readonly backupFileService: IBackupFileService,\n\t\t@ILifecycleService private readonly lifecycleService: ILifecycleService\n\t) {\n\t\tthis.restoreBackups();\n\t}\n\n\tprivate restoreBackups(): void {\n\t\tthis.lifecycleService.when(LifecyclePhase.Restored).then(() => this.doRestoreBackups());\n\t}\n\n\tprivate doRestoreBackups(): Promise<URI[] | undefined> {\n\n\t\t// Find all files and untitled with backups\n\t\treturn this.backupFileService.getWorkspaceFileBackups().then(backups => {\n\n\t\t\t// Resolve backups that are opened\n\t\t\treturn this.doResolveOpenedBackups(backups).then((unresolved): Promise<URI[] | undefined> | undefined => {\n\n\t\t\t\t// Some failed to restore or were not opened at all so we open and resolve them manually\n\t\t\t\tif (unresolved.length > 0) {\n\t\t\t\t\treturn this.doOpenEditors(unresolved).then(() => this.doResolveOpenedBackups(unresolved));\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate doResolveOpenedBackups(backups: URI[]): Promise<URI[]> {\n\t\tconst restorePromises: Promise<any>[] = [];\n\t\tconst unresolved: URI[] = [];\n\n\t\tbackups.forEach(backup => {\n\t\t\tconst openedEditor = this.editorService.getOpened({ resource: backup });\n\t\t\tif (openedEditor) {\n\t\t\t\trestorePromises.push(openedEditor.resolve().then(undefined, () => unresolved.push(backup)));\n\t\t\t} else {\n\t\t\t\tunresolved.push(backup);\n\t\t\t}\n\t\t});\n\n\t\treturn Promise.all(restorePromises).then(() => unresolved, () => unresolved);\n\t}\n\n\tprivate doOpenEditors(resources: URI[]): Promise<void> {\n\t\tconst hasOpenedEditors = this.editorService.visibleEditors.length > 0;\n\t\tconst inputs = resources.map((resource, index) => this.resolveInput(resource, index, hasOpenedEditors));\n\n\t\t// Open all remaining backups as editors and resolve them to load their backups\n\t\treturn this.editorService.openEditors(inputs).then(() => undefined);\n\t}\n\n\tprivate resolveInput(resource: URI, index: number, hasOpenedEditors: boolean): IResourceInput | IUntitledResourceInput {\n\t\tconst options = { pinned: true, preserveFocus: true, inactive: index > 0 || hasOpenedEditors };\n\n\t\tif (resource.scheme === Schemas.untitled && !BackupRestorer.UNTITLED_REGEX.test(resource.fsPath)) {\n\t\t\treturn { filePath: resource.fsPath, options };\n\t\t}\n\n\t\treturn { resource, options };\n\t}\n}"]}]}