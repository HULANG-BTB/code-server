{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/win32/csharpWatcherService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/win32/csharpWatcherService.ts","mtime":1555846338048},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar cp = require(\"child_process\");\nvar files_1 = require(\"vs/platform/files/common/files\");\nvar decoder = require(\"vs/base/node/decoder\");\nvar glob = require(\"vs/base/common/glob\");\nvar amd_1 = require(\"vs/base/common/amd\");\nvar OutOfProcessWin32FolderWatcher = /** @class */ (function () {\n    function OutOfProcessWin32FolderWatcher(watchedFolder, ignored, eventCallback, errorCallback, verboseLogging) {\n        var _this = this;\n        this.watchedFolder = watchedFolder;\n        this.eventCallback = eventCallback;\n        this.errorCallback = errorCallback;\n        this.verboseLogging = verboseLogging;\n        this.retry = require('vs/../../../../packages/vscode/src/workbench').workbench.retry.register('Watcher', function () { return _this.startWatcher(); });\n        this.restartCounter = 0;\n        if (Array.isArray(ignored)) {\n            this.ignored = ignored.map(function (i) { return glob.parse(i); });\n        }\n        else {\n            this.ignored = [];\n        }\n        this.startWatcher();\n    }\n    OutOfProcessWin32FolderWatcher.prototype.startWatcher = function () {\n        var _this = this;\n        var args = [this.watchedFolder];\n        if (this.verboseLogging) {\n            args.push('-verbose');\n        }\n        this.handle = cp.spawn(amd_1.getPathFromAmdModule(require, 'vs/workbench/services/files/node/watcher/win32/CodeHelper.exe'), args);\n        var stdoutLineDecoder = new decoder.LineDecoder();\n        this.handle.stdout.once('data', function () { return _this.retry.recover(); });\n        // Events over stdout\n        this.handle.stdout.on('data', function (data) {\n            // Collect raw events from output\n            var rawEvents = [];\n            stdoutLineDecoder.write(data).forEach(function (line) {\n                var eventParts = line.split('|');\n                if (eventParts.length === 2) {\n                    var changeType = Number(eventParts[0]);\n                    var absolutePath_1 = eventParts[1];\n                    // File Change Event (0 Changed, 1 Created, 2 Deleted)\n                    if (changeType >= 0 && changeType < 3) {\n                        // Support ignores\n                        if (_this.ignored && _this.ignored.some(function (ignore) { return ignore(absolutePath_1); })) {\n                            if (_this.verboseLogging) {\n                                console.log('%c[File Watcher (C#)]', 'color: blue', ' >> ignored', absolutePath_1);\n                            }\n                            return;\n                        }\n                        // Otherwise record as event\n                        rawEvents.push({\n                            type: OutOfProcessWin32FolderWatcher.changeTypeMap[changeType],\n                            path: absolutePath_1\n                        });\n                    }\n                    // 3 Logging\n                    else {\n                        console.log('%c[File Watcher (C#)]', 'color: blue', eventParts[1]);\n                    }\n                }\n            });\n            // Trigger processing of events through the delayer to batch them up properly\n            if (rawEvents.length > 0) {\n                _this.eventCallback(rawEvents);\n            }\n        });\n        // Errors\n        this.handle.on('error', function (error) { return _this.onError(error); });\n        this.handle.stderr.on('data', function (data) { return _this.onError(data); });\n        // Exit\n        this.handle.on('exit', function (code, signal) { return _this.onExit(code, signal); });\n    };\n    OutOfProcessWin32FolderWatcher.prototype.onError = function (error) {\n        this.errorCallback('[File Watcher (C#)] process error: ' + error.toString());\n    };\n    OutOfProcessWin32FolderWatcher.prototype.onExit = function (code, signal) {\n        if (this.handle) { // exit while not yet being disposed is unexpected!\n            return this.retry.run();\n            this.errorCallback(\"[File Watcher (C#)] terminated unexpectedly (code: \" + code + \", signal: \" + signal + \")\");\n            if (this.restartCounter <= OutOfProcessWin32FolderWatcher.MAX_RESTARTS) {\n                this.errorCallback('[File Watcher (C#)] is restarted again...');\n                this.restartCounter++;\n                this.startWatcher(); // restart\n            }\n            else {\n                this.errorCallback('[File Watcher (C#)] Watcher failed to start after retrying for some time, giving up. Please report this as a bug report!');\n            }\n        }\n    };\n    OutOfProcessWin32FolderWatcher.prototype.dispose = function () {\n        if (this.handle) {\n            this.handle.kill();\n            this.handle = null; // StrictNullOverride: nulling out ok in dispose\n        }\n    };\n    OutOfProcessWin32FolderWatcher.MAX_RESTARTS = 5;\n    OutOfProcessWin32FolderWatcher.changeTypeMap = [files_1.FileChangeType.UPDATED, files_1.FileChangeType.ADDED, files_1.FileChangeType.DELETED];\n    return OutOfProcessWin32FolderWatcher;\n}());\nexports.OutOfProcessWin32FolderWatcher = OutOfProcessWin32FolderWatcher;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/win32/csharpWatcherService.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/win32/csharpWatcherService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cp from 'child_process';\n\nimport { FileChangeType } from 'vs/platform/files/common/files';\nimport * as decoder from 'vs/base/node/decoder';\nimport * as glob from 'vs/base/common/glob';\n\nimport { IRawFileChange } from 'vs/workbench/services/files/node/watcher/common';\nimport { getPathFromAmdModule } from 'vs/base/common/amd';\n\nexport class OutOfProcessWin32FolderWatcher {\n\n\tprivate static readonly MAX_RESTARTS = 5;\n\n\tprivate static changeTypeMap: FileChangeType[] = [FileChangeType.UPDATED, FileChangeType.ADDED, FileChangeType.DELETED];\n\n\tprivate ignored: glob.ParsedPattern[];\n\n\tprivate handle: cp.ChildProcess;\n\tprivate restartCounter: number;\n\n\tprivate readonly retry = (require('vs/../../../../packages/vscode/src/workbench') as typeof import ('vs/../../../../packages/vscode/src/workbench')).workbench.retry.register('Watcher', () => this.startWatcher());\n\tconstructor(\n\t\tprivate watchedFolder: string,\n\t\tignored: string[],\n\t\tprivate eventCallback: (events: IRawFileChange[]) => void,\n\t\tprivate errorCallback: (error: string) => void,\n\t\tprivate verboseLogging: boolean\n\t) {\n\t\tthis.restartCounter = 0;\n\n\t\tif (Array.isArray(ignored)) {\n\t\t\tthis.ignored = ignored.map(i => glob.parse(i));\n\t\t} else {\n\t\t\tthis.ignored = [];\n\t\t}\n\n\t\tthis.startWatcher();\n\t}\n\n\tprivate startWatcher(): void {\n\t\tconst args = [this.watchedFolder];\n\t\tif (this.verboseLogging) {\n\t\t\targs.push('-verbose');\n\t\t}\n\n\t\tthis.handle = cp.spawn(getPathFromAmdModule(require, 'vs/workbench/services/files/node/watcher/win32/CodeHelper.exe'), args);\n\n\t\tconst stdoutLineDecoder = new decoder.LineDecoder();\n\t\tthis.handle.stdout.once('data', () => this.retry.recover());\n\n\t\t// Events over stdout\n\t\tthis.handle.stdout.on('data', (data: Buffer) => {\n\n\t\t\t// Collect raw events from output\n\t\t\tconst rawEvents: IRawFileChange[] = [];\n\t\t\tstdoutLineDecoder.write(data).forEach((line) => {\n\t\t\t\tconst eventParts = line.split('|');\n\t\t\t\tif (eventParts.length === 2) {\n\t\t\t\t\tconst changeType = Number(eventParts[0]);\n\t\t\t\t\tconst absolutePath = eventParts[1];\n\n\t\t\t\t\t// File Change Event (0 Changed, 1 Created, 2 Deleted)\n\t\t\t\t\tif (changeType >= 0 && changeType < 3) {\n\n\t\t\t\t\t\t// Support ignores\n\t\t\t\t\t\tif (this.ignored && this.ignored.some(ignore => ignore(absolutePath))) {\n\t\t\t\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\t\t\t\tconsole.log('%c[File Watcher (C#)]', 'color: blue', ' >> ignored', absolutePath);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise record as event\n\t\t\t\t\t\trawEvents.push({\n\t\t\t\t\t\t\ttype: OutOfProcessWin32FolderWatcher.changeTypeMap[changeType],\n\t\t\t\t\t\t\tpath: absolutePath\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// 3 Logging\n\t\t\t\t\telse {\n\t\t\t\t\t\tconsole.log('%c[File Watcher (C#)]', 'color: blue', eventParts[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Trigger processing of events through the delayer to batch them up properly\n\t\t\tif (rawEvents.length > 0) {\n\t\t\t\tthis.eventCallback(rawEvents);\n\t\t\t}\n\t\t});\n\n\t\t// Errors\n\t\tthis.handle.on('error', (error: Error) => this.onError(error));\n\t\tthis.handle.stderr.on('data', (data: Buffer) => this.onError(data));\n\n\t\t// Exit\n\t\tthis.handle.on('exit', (code: number, signal: string) => this.onExit(code, signal));\n\t}\n\n\tprivate onError(error: Error | Buffer): void {\n\t\tthis.errorCallback('[File Watcher (C#)] process error: ' + error.toString());\n\t}\n\n\tprivate onExit(code: number, signal: string): void {\n\t\tif (this.handle) { // exit while not yet being disposed is unexpected!\n\t\t\treturn this.retry.run();\n\t\t\tthis.errorCallback(`[File Watcher (C#)] terminated unexpectedly (code: ${code}, signal: ${signal})`);\n\n\t\t\tif (this.restartCounter <= OutOfProcessWin32FolderWatcher.MAX_RESTARTS) {\n\t\t\t\tthis.errorCallback('[File Watcher (C#)] is restarted again...');\n\t\t\t\tthis.restartCounter++;\n\t\t\t\tthis.startWatcher(); // restart\n\t\t\t} else {\n\t\t\t\tthis.errorCallback('[File Watcher (C#)] Watcher failed to start after retrying for some time, giving up. Please report this as a bug report!');\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.handle) {\n\t\t\tthis.handle.kill();\n\t\t\tthis.handle = null!; // StrictNullOverride: nulling out ok in dispose\n\t\t}\n\t}\n}\n"]}]}