{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/bracketMatching/bracketMatching.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/bracketMatching/bracketMatching.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/async\", \"vs/base/common/keyCodes\", \"vs/base/common/lifecycle\", \"vs/editor/browser/editorExtensions\", \"vs/editor/common/core/position\", \"vs/editor/common/core/selection\", \"vs/editor/common/editorContextKeys\", \"vs/editor/common/model\", \"vs/editor/common/model/textModel\", \"vs/editor/common/view/editorColorRegistry\", \"vs/platform/keybinding/common/keybindingsRegistry\", \"vs/platform/theme/common/colorRegistry\", \"vs/platform/theme/common/themeService\", \"vs/platform/actions/common/actions\", \"vs/css!./bracketMatching\"], function (require, exports, nls, async_1, keyCodes_1, lifecycle_1, editorExtensions_1, position_1, selection_1, editorContextKeys_1, model_1, textModel_1, editorColorRegistry_1, keybindingsRegistry_1, colorRegistry_1, themeService_1, actions_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const overviewRulerBracketMatchForeground = colorRegistry_1.registerColor('editorOverviewRuler.bracketMatchForeground', { dark: '#A0A0A0', light: '#A0A0A0', hc: '#A0A0A0' }, nls.localize('overviewRulerBracketMatchForeground', 'Overview ruler marker color for matching brackets.'));\n    class JumpToBracketAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.jumpToBracket',\n                label: nls.localize('smartSelect.jumpBracket', \"Go to Bracket\"),\n                alias: 'Go to Bracket',\n                precondition: null,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.US_BACKSLASH,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        run(accessor, editor) {\n            let controller = BracketMatchingController.get(editor);\n            if (!controller) {\n                return;\n            }\n            controller.jumpToBracket();\n        }\n    }\n    class SelectToBracketAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.selectToBracket',\n                label: nls.localize('smartSelect.selectToBracket', \"Select to Bracket\"),\n                alias: 'Select to Bracket',\n                precondition: null\n            });\n        }\n        run(accessor, editor) {\n            let controller = BracketMatchingController.get(editor);\n            if (!controller) {\n                return;\n            }\n            controller.selectToBracket();\n        }\n    }\n    class BracketsData {\n        constructor(position, brackets) {\n            this.position = position;\n            this.brackets = brackets;\n        }\n    }\n    class BracketMatchingController extends lifecycle_1.Disposable {\n        constructor(editor) {\n            super();\n            this._editor = editor;\n            this._lastBracketsData = [];\n            this._lastVersionId = 0;\n            this._decorations = [];\n            this._updateBracketsSoon = this._register(new async_1.RunOnceScheduler(() => this._updateBrackets(), 50));\n            this._matchBrackets = this._editor.getConfiguration().contribInfo.matchBrackets;\n            this._updateBracketsSoon.schedule();\n            this._register(editor.onDidChangeCursorPosition((e) => {\n                if (!this._matchBrackets) {\n                    // Early exit if nothing needs to be done!\n                    // Leave some form of early exit check here if you wish to continue being a cursor position change listener ;)\n                    return;\n                }\n                this._updateBracketsSoon.schedule();\n            }));\n            this._register(editor.onDidChangeModelContent((e) => {\n                this._updateBracketsSoon.schedule();\n            }));\n            this._register(editor.onDidChangeModel((e) => {\n                this._lastBracketsData = [];\n                this._decorations = [];\n                this._updateBracketsSoon.schedule();\n            }));\n            this._register(editor.onDidChangeModelLanguageConfiguration((e) => {\n                this._lastBracketsData = [];\n                this._updateBracketsSoon.schedule();\n            }));\n            this._register(editor.onDidChangeConfiguration((e) => {\n                this._matchBrackets = this._editor.getConfiguration().contribInfo.matchBrackets;\n                if (!this._matchBrackets && this._decorations.length > 0) {\n                    // Remove existing decorations if bracket matching is off\n                    this._decorations = this._editor.deltaDecorations(this._decorations, []);\n                }\n                this._updateBracketsSoon.schedule();\n            }));\n        }\n        static get(editor) {\n            return editor.getContribution(BracketMatchingController.ID);\n        }\n        getId() {\n            return BracketMatchingController.ID;\n        }\n        jumpToBracket() {\n            if (!this._editor.hasModel()) {\n                return;\n            }\n            const model = this._editor.getModel();\n            const newSelections = this._editor.getSelections().map(selection => {\n                const position = selection.getStartPosition();\n                // find matching brackets if position is on a bracket\n                const brackets = model.matchBracket(position);\n                let newCursorPosition = null;\n                if (brackets) {\n                    if (brackets[0].containsPosition(position)) {\n                        newCursorPosition = brackets[1].getStartPosition();\n                    }\n                    else if (brackets[1].containsPosition(position)) {\n                        newCursorPosition = brackets[0].getStartPosition();\n                    }\n                }\n                else {\n                    // find the next bracket if the position isn't on a matching bracket\n                    const nextBracket = model.findNextBracket(position);\n                    if (nextBracket && nextBracket.range) {\n                        newCursorPosition = nextBracket.range.getStartPosition();\n                    }\n                }\n                if (newCursorPosition) {\n                    return new selection_1.Selection(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);\n                }\n                return new selection_1.Selection(position.lineNumber, position.column, position.lineNumber, position.column);\n            });\n            this._editor.setSelections(newSelections);\n            this._editor.revealRange(newSelections[0]);\n        }\n        selectToBracket() {\n            if (!this._editor.hasModel()) {\n                return;\n            }\n            const model = this._editor.getModel();\n            const newSelections = [];\n            this._editor.getSelections().forEach(selection => {\n                const position = selection.getStartPosition();\n                let brackets = model.matchBracket(position);\n                let openBracket = null;\n                let closeBracket = null;\n                if (!brackets) {\n                    const nextBracket = model.findNextBracket(position);\n                    if (nextBracket && nextBracket.range) {\n                        brackets = model.matchBracket(nextBracket.range.getStartPosition());\n                    }\n                }\n                if (brackets) {\n                    if (brackets[0].startLineNumber === brackets[1].startLineNumber) {\n                        openBracket = brackets[1].startColumn < brackets[0].startColumn ?\n                            brackets[1].getStartPosition() : brackets[0].getStartPosition();\n                        closeBracket = brackets[1].startColumn < brackets[0].startColumn ?\n                            brackets[0].getEndPosition() : brackets[1].getEndPosition();\n                    }\n                    else {\n                        openBracket = brackets[1].startLineNumber < brackets[0].startLineNumber ?\n                            brackets[1].getStartPosition() : brackets[0].getStartPosition();\n                        closeBracket = brackets[1].startLineNumber < brackets[0].startLineNumber ?\n                            brackets[0].getEndPosition() : brackets[1].getEndPosition();\n                    }\n                }\n                if (openBracket && closeBracket) {\n                    newSelections.push(new selection_1.Selection(openBracket.lineNumber, openBracket.column, closeBracket.lineNumber, closeBracket.column));\n                }\n            });\n            if (newSelections.length > 0) {\n                this._editor.setSelections(newSelections);\n                this._editor.revealRange(newSelections[0]);\n            }\n        }\n        _updateBrackets() {\n            if (!this._matchBrackets) {\n                return;\n            }\n            this._recomputeBrackets();\n            let newDecorations = [], newDecorationsLen = 0;\n            for (let i = 0, len = this._lastBracketsData.length; i < len; i++) {\n                let brackets = this._lastBracketsData[i].brackets;\n                if (brackets) {\n                    newDecorations[newDecorationsLen++] = { range: brackets[0], options: BracketMatchingController._DECORATION_OPTIONS };\n                    newDecorations[newDecorationsLen++] = { range: brackets[1], options: BracketMatchingController._DECORATION_OPTIONS };\n                }\n            }\n            this._decorations = this._editor.deltaDecorations(this._decorations, newDecorations);\n        }\n        _recomputeBrackets() {\n            if (!this._editor.hasModel()) {\n                // no model => no brackets!\n                this._lastBracketsData = [];\n                this._lastVersionId = 0;\n                return;\n            }\n            const model = this._editor.getModel();\n            const versionId = model.getVersionId();\n            let previousData = [];\n            if (this._lastVersionId === versionId) {\n                // use the previous data only if the model is at the same version id\n                previousData = this._lastBracketsData;\n            }\n            const selections = this._editor.getSelections();\n            let positions = [], positionsLen = 0;\n            for (let i = 0, len = selections.length; i < len; i++) {\n                let selection = selections[i];\n                if (selection.isEmpty()) {\n                    // will bracket match a cursor only if the selection is collapsed\n                    positions[positionsLen++] = selection.getStartPosition();\n                }\n            }\n            // sort positions for `previousData` cache hits\n            if (positions.length > 1) {\n                positions.sort(position_1.Position.compare);\n            }\n            let newData = [], newDataLen = 0;\n            let previousIndex = 0, previousLen = previousData.length;\n            for (let i = 0, len = positions.length; i < len; i++) {\n                let position = positions[i];\n                while (previousIndex < previousLen && previousData[previousIndex].position.isBefore(position)) {\n                    previousIndex++;\n                }\n                if (previousIndex < previousLen && previousData[previousIndex].position.equals(position)) {\n                    newData[newDataLen++] = previousData[previousIndex];\n                }\n                else {\n                    let brackets = model.matchBracket(position);\n                    newData[newDataLen++] = new BracketsData(position, brackets);\n                }\n            }\n            this._lastBracketsData = newData;\n            this._lastVersionId = versionId;\n        }\n    }\n    BracketMatchingController.ID = 'editor.contrib.bracketMatchingController';\n    BracketMatchingController._DECORATION_OPTIONS = textModel_1.ModelDecorationOptions.register({\n        stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n        className: 'bracket-match',\n        overviewRuler: {\n            color: themeService_1.themeColorFromId(overviewRulerBracketMatchForeground),\n            position: model_1.OverviewRulerLane.Center\n        }\n    });\n    exports.BracketMatchingController = BracketMatchingController;\n    editorExtensions_1.registerEditorContribution(BracketMatchingController);\n    editorExtensions_1.registerEditorAction(SelectToBracketAction);\n    editorExtensions_1.registerEditorAction(JumpToBracketAction);\n    themeService_1.registerThemingParticipant((theme, collector) => {\n        const bracketMatchBackground = theme.getColor(editorColorRegistry_1.editorBracketMatchBackground);\n        if (bracketMatchBackground) {\n            collector.addRule(`.monaco-editor .bracket-match { background-color: ${bracketMatchBackground}; }`);\n        }\n        const bracketMatchBorder = theme.getColor(editorColorRegistry_1.editorBracketMatchBorder);\n        if (bracketMatchBorder) {\n            collector.addRule(`.monaco-editor .bracket-match { border: 1px solid ${bracketMatchBorder}; }`);\n        }\n    });\n    // Go to menu\n    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.MenubarGoMenu, {\n        group: '5_infile_nav',\n        command: {\n            id: 'editor.action.jumpToBracket',\n            title: nls.localize({ key: 'miGoToBracket', comment: ['&& denotes a mnemonic'] }, \"Go to &&Bracket\")\n        },\n        order: 2\n    });\n});\n",null]}