{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/jsonEdit.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/jsonEdit.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"./json\", \"./jsonFormatter\"], function (require, exports, json_1, jsonFormatter_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function removeProperty(text, path, formattingOptions) {\n        return setProperty(text, path, undefined, formattingOptions);\n    }\n    exports.removeProperty = removeProperty;\n    function setProperty(text, originalPath, value, formattingOptions, getInsertionIndex) {\n        const path = originalPath.slice();\n        const errors = [];\n        const root = json_1.parseTree(text, errors);\n        let parent = undefined;\n        let lastSegment = undefined;\n        while (path.length > 0) {\n            lastSegment = path.pop();\n            parent = json_1.findNodeAtLocation(root, path);\n            if (parent === undefined && value !== undefined) {\n                if (typeof lastSegment === 'string') {\n                    value = { [lastSegment]: value };\n                }\n                else {\n                    value = [value];\n                }\n            }\n            else {\n                break;\n            }\n        }\n        if (!parent) {\n            // empty document\n            if (value === undefined) { // delete\n                throw new Error('Can not delete in empty document');\n            }\n            return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, formattingOptions);\n        }\n        else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n            const existing = json_1.findNodeAtLocation(parent, [lastSegment]);\n            if (existing !== undefined) {\n                if (value === undefined) { // delete\n                    if (!existing.parent) {\n                        throw new Error('Malformed AST');\n                    }\n                    const propertyIndex = parent.children.indexOf(existing.parent);\n                    let removeBegin;\n                    let removeEnd = existing.parent.offset + existing.parent.length;\n                    if (propertyIndex > 0) {\n                        // remove the comma of the previous node\n                        const previous = parent.children[propertyIndex - 1];\n                        removeBegin = previous.offset + previous.length;\n                    }\n                    else {\n                        removeBegin = parent.offset + 1;\n                        if (parent.children.length > 1) {\n                            // remove the comma of the next node\n                            const next = parent.children[1];\n                            removeEnd = next.offset;\n                        }\n                    }\n                    return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, formattingOptions);\n                }\n                else {\n                    // set value of existing property\n                    return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, formattingOptions);\n                }\n            }\n            else {\n                if (value === undefined) { // delete\n                    return []; // property does not exist, nothing to do\n                }\n                const newProperty = `${JSON.stringify(lastSegment)}: ${JSON.stringify(value)}`;\n                const index = getInsertionIndex ? getInsertionIndex(parent.children.map(p => p.children[0].value)) : parent.children.length;\n                let edit;\n                if (index > 0) {\n                    const previous = parent.children[index - 1];\n                    edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n                }\n                else if (parent.children.length === 0) {\n                    edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n                }\n                else {\n                    edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };\n                }\n                return withFormatting(text, edit, formattingOptions);\n            }\n        }\n        else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n            const insertIndex = lastSegment;\n            if (insertIndex === -1) {\n                // Insert\n                const newProperty = `${JSON.stringify(value)}`;\n                let edit;\n                if (parent.children.length === 0) {\n                    edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n                }\n                else {\n                    const previous = parent.children[parent.children.length - 1];\n                    edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n                }\n                return withFormatting(text, edit, formattingOptions);\n            }\n            else {\n                if (value === undefined && parent.children.length >= 0) {\n                    //Removal\n                    const removalIndex = lastSegment;\n                    const toRemove = parent.children[removalIndex];\n                    let edit;\n                    if (parent.children.length === 1) {\n                        // only item\n                        edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };\n                    }\n                    else if (parent.children.length - 1 === removalIndex) {\n                        // last item\n                        const previous = parent.children[removalIndex - 1];\n                        const offset = previous.offset + previous.length;\n                        const parentEndOffset = parent.offset + parent.length;\n                        edit = { offset, length: parentEndOffset - 2 - offset, content: '' };\n                    }\n                    else {\n                        edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };\n                    }\n                    return withFormatting(text, edit, formattingOptions);\n                }\n                else {\n                    throw new Error('Array modification not supported yet');\n                }\n            }\n        }\n        else {\n            throw new Error(`Can not add ${typeof lastSegment !== 'number' ? 'index' : 'property'} to parent of type ${parent.type}`);\n        }\n    }\n    exports.setProperty = setProperty;\n    function withFormatting(text, edit, formattingOptions) {\n        // apply the edit\n        let newText = applyEdit(text, edit);\n        // format the new text\n        let begin = edit.offset;\n        let end = edit.offset + edit.content.length;\n        if (edit.length === 0 || edit.content.length === 0) { // insert or remove\n            while (begin > 0 && !jsonFormatter_1.isEOL(newText, begin - 1)) {\n                begin--;\n            }\n            while (end < newText.length && !jsonFormatter_1.isEOL(newText, end)) {\n                end++;\n            }\n        }\n        const edits = jsonFormatter_1.format(newText, { offset: begin, length: end - begin }, formattingOptions);\n        // apply the formatting edits and track the begin and end offsets of the changes\n        for (let i = edits.length - 1; i >= 0; i--) {\n            const edit = edits[i];\n            newText = applyEdit(newText, edit);\n            begin = Math.min(begin, edit.offset);\n            end = Math.max(end, edit.offset + edit.length);\n            end += edit.content.length - edit.length;\n        }\n        // create a single edit with all changes\n        const editLength = text.length - (newText.length - end) - begin;\n        return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];\n    }\n    function applyEdit(text, edit) {\n        return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n    }\n    exports.applyEdit = applyEdit;\n    function isWS(text, offset) {\n        return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n    }\n    exports.isWS = isWS;\n});\n",null]}