{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/documentSymbols/outlineModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/documentSymbols/outlineModel.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/arrays\", \"vs/base/common/cancellation\", \"vs/base/common/collections\", \"vs/base/common/errors\", \"vs/base/common/map\", \"vs/base/common/strings\", \"vs/editor/common/core/range\", \"vs/editor/common/modes\"], function (require, exports, arrays_1, cancellation_1, collections_1, errors_1, map_1, strings_1, range_1, modes_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class TreeElement {\n        remove() {\n            if (this.parent) {\n                delete this.parent.children[this.id];\n            }\n        }\n        static findId(candidate, container) {\n            // complex id-computation which contains the origin/extension,\n            // the parent path, and some dedupe logic when names collide\n            let candidateId;\n            if (typeof candidate === 'string') {\n                candidateId = `${container.id}/${candidate}`;\n            }\n            else {\n                candidateId = `${container.id}/${candidate.name}`;\n                if (container.children[candidateId] !== undefined) {\n                    candidateId = `${container.id}/${candidate.name}_${candidate.range.startLineNumber}_${candidate.range.startColumn}`;\n                }\n            }\n            let id = candidateId;\n            for (let i = 0; container.children[id] !== undefined; i++) {\n                id = `${candidateId}_${i}`;\n            }\n            return id;\n        }\n        static getElementById(id, element) {\n            if (!id) {\n                return undefined;\n            }\n            let len = strings_1.commonPrefixLength(id, element.id);\n            if (len === id.length) {\n                return element;\n            }\n            if (len < element.id.length) {\n                return undefined;\n            }\n            for (const key in element.children) {\n                let candidate = TreeElement.getElementById(id, element.children[key]);\n                if (candidate) {\n                    return candidate;\n                }\n            }\n            return undefined;\n        }\n        static size(element) {\n            let res = 1;\n            for (const key in element.children) {\n                res += TreeElement.size(element.children[key]);\n            }\n            return res;\n        }\n        static empty(element) {\n            for (const _key in element.children) {\n                return false;\n            }\n            return true;\n        }\n    }\n    exports.TreeElement = TreeElement;\n    class OutlineElement extends TreeElement {\n        constructor(id, parent, symbol) {\n            super();\n            this.id = id;\n            this.parent = parent;\n            this.symbol = symbol;\n            this.children = Object.create(null);\n        }\n        adopt(parent) {\n            let res = new OutlineElement(this.id, parent, this.symbol);\n            collections_1.forEach(this.children, entry => res.children[entry.key] = entry.value.adopt(res));\n            return res;\n        }\n    }\n    exports.OutlineElement = OutlineElement;\n    class OutlineGroup extends TreeElement {\n        constructor(id, parent, provider, providerIndex) {\n            super();\n            this.id = id;\n            this.parent = parent;\n            this.provider = provider;\n            this.providerIndex = providerIndex;\n            this.children = Object.create(null);\n        }\n        adopt(parent) {\n            let res = new OutlineGroup(this.id, parent, this.provider, this.providerIndex);\n            collections_1.forEach(this.children, entry => res.children[entry.key] = entry.value.adopt(res));\n            return res;\n        }\n        getItemEnclosingPosition(position) {\n            return position ? this._getItemEnclosingPosition(position, this.children) : undefined;\n        }\n        _getItemEnclosingPosition(position, children) {\n            for (let key in children) {\n                let item = children[key];\n                if (!item.symbol.range || !range_1.Range.containsPosition(item.symbol.range, position)) {\n                    continue;\n                }\n                return this._getItemEnclosingPosition(position, item.children) || item;\n            }\n            return undefined;\n        }\n        updateMarker(marker) {\n            for (const key in this.children) {\n                this._updateMarker(marker, this.children[key]);\n            }\n        }\n        _updateMarker(markers, item) {\n            item.marker = undefined;\n            // find the proper start index to check for item/marker overlap.\n            let idx = arrays_1.binarySearch(markers, item.symbol.range, range_1.Range.compareRangesUsingStarts);\n            let start;\n            if (idx < 0) {\n                start = ~idx;\n                if (start > 0 && range_1.Range.areIntersecting(markers[start - 1], item.symbol.range)) {\n                    start -= 1;\n                }\n            }\n            else {\n                start = idx;\n            }\n            let myMarkers = [];\n            let myTopSev;\n            for (; start < markers.length && range_1.Range.areIntersecting(item.symbol.range, markers[start]); start++) {\n                // remove markers intersecting with this outline element\n                // and store them in a 'private' array.\n                let marker = markers[start];\n                myMarkers.push(marker);\n                markers[start] = undefined;\n                if (!myTopSev || marker.severity > myTopSev) {\n                    myTopSev = marker.severity;\n                }\n            }\n            // Recurse into children and let them match markers that have matched\n            // this outline element. This might remove markers from this element and\n            // therefore we remember that we have had markers. That allows us to render\n            // the dot, saying 'this element has children with markers'\n            for (const key in item.children) {\n                this._updateMarker(myMarkers, item.children[key]);\n            }\n            if (myTopSev) {\n                item.marker = {\n                    count: myMarkers.length,\n                    topSev: myTopSev\n                };\n            }\n            arrays_1.coalesceInPlace(markers);\n        }\n    }\n    exports.OutlineGroup = OutlineGroup;\n    class OutlineModel extends TreeElement {\n        constructor(textModel) {\n            super();\n            this.textModel = textModel;\n            this.id = 'root';\n            this.parent = undefined;\n            this._groups = Object.create(null);\n            this.children = Object.create(null);\n        }\n        static create(textModel, token) {\n            let key = this._keys.for(textModel);\n            let data = OutlineModel._requests.get(key);\n            if (!data) {\n                let source = new cancellation_1.CancellationTokenSource();\n                data = {\n                    promiseCnt: 0,\n                    source,\n                    promise: OutlineModel._create(textModel, source.token),\n                    model: undefined,\n                };\n                OutlineModel._requests.set(key, data);\n            }\n            if (data.model) {\n                // resolved -> return data\n                return Promise.resolve(data.model);\n            }\n            // increase usage counter\n            data.promiseCnt += 1;\n            token.onCancellationRequested(() => {\n                // last -> cancel provider request, remove cached promise\n                if (--data.promiseCnt === 0) {\n                    data.source.cancel();\n                    OutlineModel._requests.delete(key);\n                }\n            });\n            return new Promise((resolve, reject) => {\n                data.promise.then(model => {\n                    data.model = model;\n                    resolve(model);\n                }, err => {\n                    OutlineModel._requests.delete(key);\n                    reject(err);\n                });\n            });\n        }\n        static _create(textModel, token) {\n            const chainedCancellation = new cancellation_1.CancellationTokenSource();\n            token.onCancellationRequested(() => chainedCancellation.cancel());\n            const result = new OutlineModel(textModel);\n            const provider = modes_1.DocumentSymbolProviderRegistry.ordered(textModel);\n            const promises = provider.map((provider, index) => {\n                let id = TreeElement.findId(`provider_${index}`, result);\n                let group = new OutlineGroup(id, result, provider, index);\n                return Promise.resolve(provider.provideDocumentSymbols(result.textModel, chainedCancellation.token)).then(result => {\n                    for (const info of result || []) {\n                        OutlineModel._makeOutlineElement(info, group);\n                    }\n                    return group;\n                }, err => {\n                    errors_1.onUnexpectedExternalError(err);\n                    return group;\n                }).then(group => {\n                    if (!TreeElement.empty(group)) {\n                        result._groups[id] = group;\n                    }\n                    else {\n                        group.remove();\n                    }\n                });\n            });\n            const listener = modes_1.DocumentSymbolProviderRegistry.onDidChange(() => {\n                const newProvider = modes_1.DocumentSymbolProviderRegistry.ordered(textModel);\n                if (!arrays_1.equals(newProvider, provider)) {\n                    chainedCancellation.cancel();\n                }\n            });\n            return Promise.all(promises).then(() => {\n                if (chainedCancellation.token.isCancellationRequested && !token.isCancellationRequested) {\n                    return OutlineModel._create(textModel, token);\n                }\n                else {\n                    return result._compact();\n                }\n            }).finally(() => {\n                listener.dispose();\n            });\n        }\n        static _makeOutlineElement(info, container) {\n            let id = TreeElement.findId(info, container);\n            let res = new OutlineElement(id, container, info);\n            if (info.children) {\n                for (const childInfo of info.children) {\n                    OutlineModel._makeOutlineElement(childInfo, res);\n                }\n            }\n            container.children[res.id] = res;\n        }\n        static get(element) {\n            while (element) {\n                if (element instanceof OutlineModel) {\n                    return element;\n                }\n                element = element.parent;\n            }\n            return undefined;\n        }\n        adopt() {\n            let res = new OutlineModel(this.textModel);\n            collections_1.forEach(this._groups, entry => res._groups[entry.key] = entry.value.adopt(res));\n            return res._compact();\n        }\n        _compact() {\n            let count = 0;\n            for (const key in this._groups) {\n                let group = this._groups[key];\n                if (collections_1.first(group.children) === undefined) { // empty\n                    delete this._groups[key];\n                }\n                else {\n                    count += 1;\n                }\n            }\n            if (count !== 1) {\n                //\n                this.children = this._groups;\n            }\n            else {\n                // adopt all elements of the first group\n                let group = collections_1.first(this._groups);\n                for (let key in group.children) {\n                    let child = group.children[key];\n                    child.parent = this;\n                    this.children[child.id] = child;\n                }\n            }\n            return this;\n        }\n        merge(other) {\n            if (this.textModel.uri.toString() !== other.textModel.uri.toString()) {\n                return false;\n            }\n            if (collections_1.size(this._groups) !== collections_1.size(other._groups)) {\n                return false;\n            }\n            this._groups = other._groups;\n            this.children = other.children;\n            return true;\n        }\n        getItemEnclosingPosition(position, context) {\n            let preferredGroup;\n            if (context) {\n                let candidate = context.parent;\n                while (candidate && !preferredGroup) {\n                    if (candidate instanceof OutlineGroup) {\n                        preferredGroup = candidate;\n                    }\n                    candidate = candidate.parent;\n                }\n            }\n            let result = undefined;\n            for (const key in this._groups) {\n                const group = this._groups[key];\n                result = group.getItemEnclosingPosition(position);\n                if (result && (!preferredGroup || preferredGroup === group)) {\n                    break;\n                }\n            }\n            return result;\n        }\n        getItemById(id) {\n            return TreeElement.getElementById(id, this);\n        }\n        updateMarker(marker) {\n            // sort markers by start range so that we can use\n            // outline element starts for quicker look up\n            marker.sort(range_1.Range.compareRangesUsingStarts);\n            for (const key in this._groups) {\n                this._groups[key].updateMarker(marker.slice(0));\n            }\n        }\n    }\n    OutlineModel._requests = new map_1.LRUCache(9, 0.75);\n    OutlineModel._keys = new class {\n        constructor() {\n            this._counter = 1;\n            this._data = new WeakMap();\n        }\n        for(textModel) {\n            return `${textModel.id}/${textModel.getVersionId()}/${this._hash(modes_1.DocumentSymbolProviderRegistry.all(textModel))}`;\n        }\n        _hash(providers) {\n            let result = '';\n            for (const provider of providers) {\n                let n = this._data.get(provider);\n                if (typeof n === 'undefined') {\n                    n = this._counter++;\n                    this._data.set(provider, n);\n                }\n                result += n;\n            }\n            return result;\n        }\n    };\n    exports.OutlineModel = OutlineModel;\n});\n",null]}