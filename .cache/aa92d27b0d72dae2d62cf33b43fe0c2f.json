{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/common/notifications.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/common/notifications.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/platform/notification/common/notification\", \"vs/base/common/errorMessage\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/base/common/errors\", \"vs/base/common/actions\", \"vs/base/common/errorsWithActions\"], function (require, exports, notification_1, errorMessage_1, event_1, lifecycle_1, errors_1, actions_1, errorsWithActions_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var NotificationChangeType;\n    (function (NotificationChangeType) {\n        NotificationChangeType[NotificationChangeType[\"ADD\"] = 0] = \"ADD\";\n        NotificationChangeType[NotificationChangeType[\"CHANGE\"] = 1] = \"CHANGE\";\n        NotificationChangeType[NotificationChangeType[\"REMOVE\"] = 2] = \"REMOVE\";\n    })(NotificationChangeType = exports.NotificationChangeType || (exports.NotificationChangeType = {}));\n    class NotificationHandle {\n        constructor(item, closeItem) {\n            this.item = item;\n            this.closeItem = closeItem;\n            this._onDidClose = new event_1.Emitter();\n            this.registerListeners();\n        }\n        get onDidClose() { return this._onDidClose.event; }\n        registerListeners() {\n            event_1.Event.once(this.item.onDidClose)(() => {\n                this._onDidClose.fire();\n                this._onDidClose.dispose();\n            });\n        }\n        get progress() {\n            return this.item.progress;\n        }\n        updateSeverity(severity) {\n            this.item.updateSeverity(severity);\n        }\n        updateMessage(message) {\n            this.item.updateMessage(message);\n        }\n        updateActions(actions) {\n            this.item.updateActions(actions);\n        }\n        close() {\n            this.closeItem(this.item);\n            this._onDidClose.dispose();\n        }\n    }\n    exports.NotificationHandle = NotificationHandle;\n    class NotificationsModel extends lifecycle_1.Disposable {\n        constructor() {\n            super(...arguments);\n            this._onDidNotificationChange = this._register(new event_1.Emitter());\n            this._notifications = [];\n        }\n        get onDidNotificationChange() { return this._onDidNotificationChange.event; }\n        get notifications() {\n            return this._notifications;\n        }\n        notify(notification) {\n            const item = this.createViewItem(notification);\n            if (!item) {\n                return NotificationsModel.NO_OP_NOTIFICATION; // return early if this is a no-op\n            }\n            // Deduplicate\n            const duplicate = this.findNotification(item);\n            if (duplicate) {\n                duplicate.close();\n            }\n            // Add to list as first entry\n            this._notifications.splice(0, 0, item);\n            // Events\n            this._onDidNotificationChange.fire({ item, index: 0, kind: NotificationChangeType.ADD });\n            // Wrap into handle\n            return new NotificationHandle(item, item => this.closeItem(item));\n        }\n        closeItem(item) {\n            const liveItem = this.findNotification(item);\n            if (liveItem && liveItem !== item) {\n                liveItem.close(); // item could have been replaced with another one, make sure to close the live item\n            }\n            else {\n                item.close(); // otherwise just close the item that was passed in\n            }\n        }\n        findNotification(item) {\n            for (const notification of this._notifications) {\n                if (notification.equals(item)) {\n                    return notification;\n                }\n            }\n            return undefined;\n        }\n        createViewItem(notification) {\n            const item = NotificationViewItem.create(notification);\n            if (!item) {\n                return null;\n            }\n            // Item Events\n            const onItemChangeEvent = () => {\n                const index = this._notifications.indexOf(item);\n                if (index >= 0) {\n                    this._onDidNotificationChange.fire({ item, index, kind: NotificationChangeType.CHANGE });\n                }\n            };\n            const itemExpansionChangeListener = item.onDidExpansionChange(() => onItemChangeEvent());\n            const itemLabelChangeListener = item.onDidLabelChange(e => {\n                // a label change in the area of actions or the message is a change that potentially has an impact\n                // on the size of the notification and as such we emit a change event so that viewers can redraw\n                if (e.kind === NotificationViewItemLabelKind.ACTIONS || e.kind === NotificationViewItemLabelKind.MESSAGE) {\n                    onItemChangeEvent();\n                }\n            });\n            event_1.Event.once(item.onDidClose)(() => {\n                itemExpansionChangeListener.dispose();\n                itemLabelChangeListener.dispose();\n                const index = this._notifications.indexOf(item);\n                if (index >= 0) {\n                    this._notifications.splice(index, 1);\n                    this._onDidNotificationChange.fire({ item, index, kind: NotificationChangeType.REMOVE });\n                }\n            });\n            return item;\n        }\n    }\n    NotificationsModel.NO_OP_NOTIFICATION = new notification_1.NoOpNotification();\n    exports.NotificationsModel = NotificationsModel;\n    function isNotificationViewItem(obj) {\n        return obj instanceof NotificationViewItem;\n    }\n    exports.isNotificationViewItem = isNotificationViewItem;\n    var NotificationViewItemLabelKind;\n    (function (NotificationViewItemLabelKind) {\n        NotificationViewItemLabelKind[NotificationViewItemLabelKind[\"SEVERITY\"] = 0] = \"SEVERITY\";\n        NotificationViewItemLabelKind[NotificationViewItemLabelKind[\"MESSAGE\"] = 1] = \"MESSAGE\";\n        NotificationViewItemLabelKind[NotificationViewItemLabelKind[\"ACTIONS\"] = 2] = \"ACTIONS\";\n        NotificationViewItemLabelKind[NotificationViewItemLabelKind[\"PROGRESS\"] = 3] = \"PROGRESS\";\n    })(NotificationViewItemLabelKind = exports.NotificationViewItemLabelKind || (exports.NotificationViewItemLabelKind = {}));\n    class NotificationViewItemProgress extends lifecycle_1.Disposable {\n        constructor() {\n            super();\n            this._onDidChange = this._register(new event_1.Emitter());\n            this._state = Object.create(null);\n        }\n        get onDidChange() { return this._onDidChange.event; }\n        get state() {\n            return this._state;\n        }\n        infinite() {\n            if (this._state.infinite) {\n                return;\n            }\n            this._state.infinite = true;\n            this._state.total = undefined;\n            this._state.worked = undefined;\n            this._state.done = undefined;\n            this._onDidChange.fire();\n        }\n        done() {\n            if (this._state.done) {\n                return;\n            }\n            this._state.done = true;\n            this._state.infinite = undefined;\n            this._state.total = undefined;\n            this._state.worked = undefined;\n            this._onDidChange.fire();\n        }\n        total(value) {\n            if (this._state.total === value) {\n                return;\n            }\n            this._state.total = value;\n            this._state.infinite = undefined;\n            this._state.done = undefined;\n            this._onDidChange.fire();\n        }\n        worked(value) {\n            if (typeof this._state.worked === 'number') {\n                this._state.worked += value;\n            }\n            else {\n                this._state.worked = value;\n            }\n            this._state.infinite = undefined;\n            this._state.done = undefined;\n            this._onDidChange.fire();\n        }\n    }\n    exports.NotificationViewItemProgress = NotificationViewItemProgress;\n    class NotificationViewItem extends lifecycle_1.Disposable {\n        constructor(_severity, _sticky, _silent, _message, _source, actions) {\n            super();\n            this._severity = _severity;\n            this._sticky = _sticky;\n            this._silent = _silent;\n            this._message = _message;\n            this._source = _source;\n            this._onDidExpansionChange = this._register(new event_1.Emitter());\n            this._onDidClose = this._register(new event_1.Emitter());\n            this._onDidLabelChange = this._register(new event_1.Emitter());\n            this.setActions(actions);\n        }\n        get onDidExpansionChange() { return this._onDidExpansionChange.event; }\n        get onDidClose() { return this._onDidClose.event; }\n        get onDidLabelChange() { return this._onDidLabelChange.event; }\n        static create(notification) {\n            if (!notification || !notification.message || errors_1.isPromiseCanceledError(notification.message)) {\n                return null; // we need a message to show\n            }\n            let severity;\n            if (typeof notification.severity === 'number') {\n                severity = notification.severity;\n            }\n            else {\n                severity = notification_1.Severity.Info;\n            }\n            const message = NotificationViewItem.parseNotificationMessage(notification.message);\n            if (!message) {\n                return null; // we need a message to show\n            }\n            let actions;\n            if (notification.actions) {\n                actions = notification.actions;\n            }\n            else if (errorsWithActions_1.isErrorWithActions(notification.message)) {\n                actions = { primary: notification.message.actions };\n            }\n            return new NotificationViewItem(severity, notification.sticky, notification.silent, message, notification.source, actions);\n        }\n        static parseNotificationMessage(input) {\n            let message;\n            if (input instanceof Error) {\n                message = errorMessage_1.toErrorMessage(input, false);\n            }\n            else if (typeof input === 'string') {\n                message = input;\n            }\n            if (!message) {\n                return undefined; // we need a message to show\n            }\n            const raw = message;\n            // Make sure message is in the limits\n            if (message.length > NotificationViewItem.MAX_MESSAGE_LENGTH) {\n                message = `${message.substr(0, NotificationViewItem.MAX_MESSAGE_LENGTH)}...`;\n            }\n            // Remove newlines from messages as we do not support that and it makes link parsing hard\n            message = message.replace(/(\\r\\n|\\n|\\r)/gm, ' ').trim();\n            // Parse Links\n            const links = [];\n            message.replace(NotificationViewItem.LINK_REGEX, (matchString, name, href, offset) => {\n                links.push({ name, href, offset, length: matchString.length });\n                return matchString;\n            });\n            return { raw, value: message, links, original: input };\n        }\n        setActions(actions = { primary: [], secondary: [] }) {\n            if (!Array.isArray(actions.primary)) {\n                actions.primary = [];\n            }\n            if (!Array.isArray(actions.secondary)) {\n                actions.secondary = [];\n            }\n            this._actions = actions;\n            this._expanded = actions.primary.length > 0;\n        }\n        get canCollapse() {\n            return !this.hasPrompt();\n        }\n        get expanded() {\n            return this._expanded;\n        }\n        get severity() {\n            return this._severity;\n        }\n        get sticky() {\n            if (this._sticky) {\n                return true; // explicitly sticky\n            }\n            const hasPrompt = this.hasPrompt();\n            if ((hasPrompt && this._severity === notification_1.Severity.Error) || // notification errors with actions are sticky\n                (!hasPrompt && this._expanded) || // notifications that got expanded are sticky\n                (this._progress && !this._progress.state.done) // notifications with running progress are sticky\n            ) {\n                return true;\n            }\n            return false; // not sticky\n        }\n        get silent() {\n            return !!this._silent;\n        }\n        hasPrompt() {\n            if (!this._actions.primary) {\n                return false;\n            }\n            return this._actions.primary.length > 0;\n        }\n        hasProgress() {\n            return !!this._progress;\n        }\n        get progress() {\n            if (!this._progress) {\n                this._progress = this._register(new NotificationViewItemProgress());\n                this._register(this._progress.onDidChange(() => this._onDidLabelChange.fire({ kind: NotificationViewItemLabelKind.PROGRESS })));\n            }\n            return this._progress;\n        }\n        get message() {\n            return this._message;\n        }\n        get source() {\n            return this._source;\n        }\n        get actions() {\n            return this._actions;\n        }\n        updateSeverity(severity) {\n            this._severity = severity;\n            this._onDidLabelChange.fire({ kind: NotificationViewItemLabelKind.SEVERITY });\n        }\n        updateMessage(input) {\n            const message = NotificationViewItem.parseNotificationMessage(input);\n            if (!message) {\n                return;\n            }\n            this._message = message;\n            this._onDidLabelChange.fire({ kind: NotificationViewItemLabelKind.MESSAGE });\n        }\n        updateActions(actions) {\n            this.setActions(actions);\n            this._onDidLabelChange.fire({ kind: NotificationViewItemLabelKind.ACTIONS });\n        }\n        expand() {\n            if (this._expanded || !this.canCollapse) {\n                return;\n            }\n            this._expanded = true;\n            this._onDidExpansionChange.fire();\n        }\n        collapse(skipEvents) {\n            if (!this._expanded || !this.canCollapse) {\n                return;\n            }\n            this._expanded = false;\n            if (!skipEvents) {\n                this._onDidExpansionChange.fire();\n            }\n        }\n        toggle() {\n            if (this._expanded) {\n                this.collapse();\n            }\n            else {\n                this.expand();\n            }\n        }\n        close() {\n            this._onDidClose.fire();\n            this.dispose();\n        }\n        equals(other) {\n            if (this.hasProgress() || other.hasProgress()) {\n                return false;\n            }\n            if (this._source !== other.source) {\n                return false;\n            }\n            if (this._message.value !== other.message.value) {\n                return false;\n            }\n            const primaryActions = this._actions.primary || [];\n            const otherPrimaryActions = other.actions.primary || [];\n            if (primaryActions.length !== otherPrimaryActions.length) {\n                return false;\n            }\n            for (let i = 0; i < primaryActions.length; i++) {\n                if ((primaryActions[i].id + primaryActions[i].label) !== (otherPrimaryActions[i].id + otherPrimaryActions[i].label)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    NotificationViewItem.MAX_MESSAGE_LENGTH = 1000;\n    // Example link: \"Some message with [link text](http://link.href).\"\n    // RegEx: [, anything not ], ], (, http:|https:, //, no whitespace)\n    NotificationViewItem.LINK_REGEX = /\\[([^\\]]+)\\]\\((https?:\\/\\/[^\\)\\s]+)\\)/gi;\n    exports.NotificationViewItem = NotificationViewItem;\n    class ChoiceAction extends actions_1.Action {\n        constructor(id, choice) {\n            super(id, choice.label, undefined, true, () => {\n                // Pass to runner\n                choice.run();\n                // Emit Event\n                this._onDidRun.fire();\n                return Promise.resolve();\n            });\n            this._onDidRun = new event_1.Emitter();\n            this._keepOpen = !!choice.keepOpen;\n        }\n        get onDidRun() { return this._onDidRun.event; }\n        get keepOpen() {\n            return this._keepOpen;\n        }\n        dispose() {\n            super.dispose();\n            this._onDidRun.dispose();\n        }\n    }\n    exports.ChoiceAction = ChoiceAction;\n});\n",null]}