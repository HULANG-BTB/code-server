{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/common/uint.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/uint.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction toUint8ArrayBuffer(str) {\n    if (typeof TextEncoder !== 'undefined') {\n        return new TextEncoder().encode(str).buffer;\n    }\n    var i, len, length = 0, charCode = 0, trailCharCode = 0, codepoint = 0;\n    // First pass, for the size\n    for (i = 0, len = str.length; i < len; i++) {\n        charCode = str.charCodeAt(i);\n        // Surrogate pair\n        if (charCode >= 0xD800 && charCode < 0xDC00) {\n            trailCharCode = str.charCodeAt(++i);\n            if (!(trailCharCode >= 0xDC00 && trailCharCode < 0xE000)) {\n                throw new Error('Invalid char code');\n            }\n            // Code point can be obtained by subtracting 0xD800 and 0xDC00 from both char codes respectively\n            // and joining the 10 least significant bits from each, finally adding 0x10000.\n            codepoint = ((((charCode - 0xD800) & 0x3FF) << 10) | ((trailCharCode - 0xDC00) & 0x3FF)) + 0x10000;\n        }\n        else {\n            codepoint = charCode;\n        }\n        length += byteSizeInUTF8(codepoint);\n    }\n    var result = new ArrayBuffer(length);\n    var view = new Uint8Array(result);\n    var pos = 0;\n    // Second pass, for the data\n    for (i = 0, len = str.length; i < len; i++) {\n        charCode = str.charCodeAt(i);\n        if (charCode >= 0xD800 && charCode < 0xDC00) {\n            trailCharCode = str.charCodeAt(++i);\n            codepoint = ((((charCode - 0xD800) & 0x3FF) << 10) | ((trailCharCode - 0xDC00) & 0x3FF)) + 0x10000;\n        }\n        else {\n            codepoint = charCode;\n        }\n        pos += writeUTF8(codepoint, view, pos);\n    }\n    return result;\n}\nexports.toUint8ArrayBuffer = toUint8ArrayBuffer;\nfunction byteSizeInUTF8(codePoint) {\n    codePoint = codePoint >>> 0;\n    if (codePoint < 0x80) {\n        return 1;\n    }\n    else if (codePoint < 0x800) {\n        return 2;\n    }\n    else if (codePoint < 0x10000) {\n        return 3;\n    }\n    else if (codePoint < 0x200000) {\n        return 4;\n    }\n    else if (codePoint < 0x4000000) {\n        return 5;\n    }\n    else if (codePoint < 0x80000000) {\n        return 6;\n    }\n    else {\n        throw new Error('Code point 0x' + toHexString(codePoint) + ' not encodable in UTF8.');\n    }\n}\nfunction writeUTF8(codePoint, buffer, pos) {\n    // How many bits needed for codePoint\n    var byteSize = byteSizeInUTF8(codePoint);\n    // 0xxxxxxx\n    if (byteSize === 1) {\n        buffer[pos] = codePoint;\n        return 1;\n    }\n    // 110xxxxx 10xxxxxx\n    // 1110xxxx 10xxxxxx 10xxxxxx\n    // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n    // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n    // 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n    // first byte\n    buffer[pos] = ((0xFC << (6 - byteSize)) | (codePoint >>> (6 * (byteSize - 1)))) & 0xFF;\n    // successive bytes\n    for (var i = 1; i < byteSize; i++) {\n        buffer[pos + i] = (0x80 | (0x3F & (codePoint >>> (6 * (byteSize - i - 1))))) & 0xFF;\n    }\n    return byteSize;\n}\nfunction leftPad(value, length, char) {\n    if (char === void 0) { char = '0'; }\n    return new Array(length - value.length + 1).join(char) + value;\n}\nfunction toHexString(value, bitsize) {\n    if (bitsize === void 0) { bitsize = 32; }\n    return leftPad((value >>> 0).toString(16), bitsize / 4);\n}\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/common/uint.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/common/uint.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport function toUint8ArrayBuffer(str: string): ArrayBuffer {\n\n\tif (typeof TextEncoder !== 'undefined') {\n\t\treturn new TextEncoder().encode(str).buffer;\n\t}\n\n\tlet i: number, len: number, length = 0, charCode = 0, trailCharCode = 0, codepoint = 0;\n\n\t// First pass, for the size\n\tfor (i = 0, len = str.length; i < len; i++) {\n\t\tcharCode = str.charCodeAt(i);\n\n\t\t// Surrogate pair\n\t\tif (charCode >= 0xD800 && charCode < 0xDC00) {\n\t\t\ttrailCharCode = str.charCodeAt(++i);\n\n\t\t\tif (!(trailCharCode >= 0xDC00 && trailCharCode < 0xE000)) {\n\t\t\t\tthrow new Error('Invalid char code');\n\t\t\t}\n\n\t\t\t// Code point can be obtained by subtracting 0xD800 and 0xDC00 from both char codes respectively\n\t\t\t// and joining the 10 least significant bits from each, finally adding 0x10000.\n\t\t\tcodepoint = ((((charCode - 0xD800) & 0x3FF) << 10) | ((trailCharCode - 0xDC00) & 0x3FF)) + 0x10000;\n\n\t\t} else {\n\t\t\tcodepoint = charCode;\n\t\t}\n\n\t\tlength += byteSizeInUTF8(codepoint);\n\t}\n\n\tlet result = new ArrayBuffer(length);\n\tlet view = new Uint8Array(result);\n\tlet pos = 0;\n\n\t// Second pass, for the data\n\tfor (i = 0, len = str.length; i < len; i++) {\n\t\tcharCode = str.charCodeAt(i);\n\n\t\tif (charCode >= 0xD800 && charCode < 0xDC00) {\n\t\t\ttrailCharCode = str.charCodeAt(++i);\n\t\t\tcodepoint = ((((charCode - 0xD800) & 0x3FF) << 10) | ((trailCharCode - 0xDC00) & 0x3FF)) + 0x10000;\n\t\t} else {\n\t\t\tcodepoint = charCode;\n\t\t}\n\n\t\tpos += writeUTF8(codepoint, view, pos);\n\t}\n\n\treturn result;\n}\n\nfunction byteSizeInUTF8(codePoint: number): number {\n\tcodePoint = codePoint >>> 0;\n\n\tif (codePoint < 0x80) {\n\t\treturn 1;\n\t} else if (codePoint < 0x800) {\n\t\treturn 2;\n\t} else if (codePoint < 0x10000) {\n\t\treturn 3;\n\t} else if (codePoint < 0x200000) {\n\t\treturn 4;\n\t} else if (codePoint < 0x4000000) {\n\t\treturn 5;\n\t} else if (codePoint < 0x80000000) {\n\t\treturn 6;\n\t} else {\n\t\tthrow new Error('Code point 0x' + toHexString(codePoint) + ' not encodable in UTF8.');\n\t}\n}\n\nfunction writeUTF8(codePoint: number, buffer: Uint8Array, pos: number): number {\n\n\t// How many bits needed for codePoint\n\tlet byteSize = byteSizeInUTF8(codePoint);\n\n\t// 0xxxxxxx\n\tif (byteSize === 1) {\n\t\tbuffer[pos] = codePoint;\n\t\treturn 1;\n\t}\n\n\t// 110xxxxx 10xxxxxx\n\t// 1110xxxx 10xxxxxx 10xxxxxx\n\t// 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\t// 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n\t// 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n\t// first byte\n\tbuffer[pos] = ((0xFC << (6 - byteSize)) | (codePoint >>> (6 * (byteSize - 1)))) & 0xFF;\n\n\t// successive bytes\n\tfor (let i = 1; i < byteSize; i++) {\n\t\tbuffer[pos + i] = (0x80 | (0x3F & (codePoint >>> (6 * (byteSize - i - 1))))) & 0xFF;\n\t}\n\n\treturn byteSize;\n}\n\nfunction leftPad(value: string, length: number, char: string = '0'): string {\n\treturn new Array(length - value.length + 1).join(char) + value;\n}\n\nfunction toHexString(value: number, bitsize: number = 32): string {\n\treturn leftPad((value >>> 0).toString(16), bitsize / 4);\n}\n"]}]}