{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/configuration/common/configurationModels.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/configuration/common/configurationModels.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/json\", \"vs/base/common/map\", \"vs/base/common/arrays\", \"vs/base/common/types\", \"vs/base/common/objects\", \"vs/platform/configuration/common/configurationRegistry\", \"vs/platform/configuration/common/configuration\"], function (require, exports, json, map_1, arrays, types, objects, configurationRegistry_1, configuration_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class ConfigurationModel {\n        constructor(_contents = {}, _keys = [], _overrides = []) {\n            this._contents = _contents;\n            this._keys = _keys;\n            this._overrides = _overrides;\n            this.isFrozen = false;\n        }\n        get contents() {\n            return this.checkAndFreeze(this._contents);\n        }\n        get overrides() {\n            return this.checkAndFreeze(this._overrides);\n        }\n        get keys() {\n            return this.checkAndFreeze(this._keys);\n        }\n        isEmpty() {\n            return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;\n        }\n        getValue(section) {\n            return section ? configuration_1.getConfigurationValue(this.contents, section) : this.contents;\n        }\n        override(identifier) {\n            const overrideContents = this.getContentsForOverrideIdentifer(identifier);\n            if (!overrideContents || typeof overrideContents !== 'object' || !Object.keys(overrideContents).length) {\n                // If there are no valid overrides, return self\n                return this;\n            }\n            let contents = {};\n            for (const key of arrays.distinct([...Object.keys(this.contents), ...Object.keys(overrideContents)])) {\n                let contentsForKey = this.contents[key];\n                let overrideContentsForKey = overrideContents[key];\n                // If there are override contents for the key, clone and merge otherwise use base contents\n                if (overrideContentsForKey) {\n                    // Clone and merge only if base contents and override contents are of type object otherwise just override\n                    if (typeof contentsForKey === 'object' && typeof overrideContentsForKey === 'object') {\n                        contentsForKey = objects.deepClone(contentsForKey);\n                        this.mergeContents(contentsForKey, overrideContentsForKey);\n                    }\n                    else {\n                        contentsForKey = overrideContentsForKey;\n                    }\n                }\n                contents[key] = contentsForKey;\n            }\n            return new ConfigurationModel(contents);\n        }\n        merge(...others) {\n            const contents = objects.deepClone(this.contents);\n            const overrides = objects.deepClone(this.overrides);\n            const keys = [...this.keys];\n            for (const other of others) {\n                this.mergeContents(contents, other.contents);\n                for (const otherOverride of other.overrides) {\n                    const [override] = overrides.filter(o => arrays.equals(o.identifiers, otherOverride.identifiers));\n                    if (override) {\n                        this.mergeContents(override.contents, otherOverride.contents);\n                    }\n                    else {\n                        overrides.push(objects.deepClone(otherOverride));\n                    }\n                }\n                for (const key of other.keys) {\n                    if (keys.indexOf(key) === -1) {\n                        keys.push(key);\n                    }\n                }\n            }\n            return new ConfigurationModel(contents, keys, overrides);\n        }\n        freeze() {\n            this.isFrozen = true;\n            return this;\n        }\n        mergeContents(source, target) {\n            for (const key of Object.keys(target)) {\n                if (key in source) {\n                    if (types.isObject(source[key]) && types.isObject(target[key])) {\n                        this.mergeContents(source[key], target[key]);\n                        continue;\n                    }\n                }\n                source[key] = objects.deepClone(target[key]);\n            }\n        }\n        checkAndFreeze(data) {\n            if (this.isFrozen && !Object.isFrozen(data)) {\n                return objects.deepFreeze(data);\n            }\n            return data;\n        }\n        getContentsForOverrideIdentifer(identifier) {\n            for (const override of this.overrides) {\n                if (override.identifiers.indexOf(identifier) !== -1) {\n                    return override.contents;\n                }\n            }\n            return null;\n        }\n        toJSON() {\n            return {\n                contents: this.contents,\n                overrides: this.overrides,\n                keys: this.keys\n            };\n        }\n        // Update methods\n        setValue(key, value) {\n            this.addKey(key);\n            configuration_1.addToValueTree(this.contents, key, value, e => { throw new Error(e); });\n        }\n        removeValue(key) {\n            if (this.removeKey(key)) {\n                configuration_1.removeFromValueTree(this.contents, key);\n            }\n        }\n        addKey(key) {\n            let index = this.keys.length;\n            for (let i = 0; i < index; i++) {\n                if (key.indexOf(this.keys[i]) === 0) {\n                    index = i;\n                }\n            }\n            this.keys.splice(index, 1, key);\n        }\n        removeKey(key) {\n            let index = this.keys.indexOf(key);\n            if (index !== -1) {\n                this.keys.splice(index, 1);\n                return true;\n            }\n            return false;\n        }\n    }\n    exports.ConfigurationModel = ConfigurationModel;\n    class DefaultConfigurationModel extends ConfigurationModel {\n        constructor() {\n            const contents = configuration_1.getDefaultValues();\n            const keys = configuration_1.getConfigurationKeys();\n            const overrides = [];\n            for (const key of Object.keys(contents)) {\n                if (configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(key)) {\n                    overrides.push({\n                        identifiers: [configuration_1.overrideIdentifierFromKey(key).trim()],\n                        contents: configuration_1.toValuesTree(contents[key], message => console.error(`Conflict in default settings file: ${message}`))\n                    });\n                }\n            }\n            super(contents, keys, overrides);\n        }\n    }\n    exports.DefaultConfigurationModel = DefaultConfigurationModel;\n    class ConfigurationModelParser {\n        constructor(_name) {\n            this._name = _name;\n            this._configurationModel = null;\n            this._parseErrors = [];\n        }\n        get configurationModel() {\n            return this._configurationModel || new ConfigurationModel();\n        }\n        get errors() {\n            return this._parseErrors;\n        }\n        parse(content) {\n            if (content) {\n                const raw = this.parseContent(content);\n                const configurationModel = this.parseRaw(raw);\n                this._configurationModel = new ConfigurationModel(configurationModel.contents, configurationModel.keys, configurationModel.overrides);\n            }\n        }\n        parseContent(content) {\n            let raw = {};\n            let currentProperty = null;\n            let currentParent = [];\n            let previousParents = [];\n            let parseErrors = [];\n            function onValue(value) {\n                if (Array.isArray(currentParent)) {\n                    currentParent.push(value);\n                }\n                else if (currentProperty) {\n                    currentParent[currentProperty] = value;\n                }\n            }\n            let visitor = {\n                onObjectBegin: () => {\n                    let object = {};\n                    onValue(object);\n                    previousParents.push(currentParent);\n                    currentParent = object;\n                    currentProperty = null;\n                },\n                onObjectProperty: (name) => {\n                    currentProperty = name;\n                },\n                onObjectEnd: () => {\n                    currentParent = previousParents.pop();\n                },\n                onArrayBegin: () => {\n                    let array = [];\n                    onValue(array);\n                    previousParents.push(currentParent);\n                    currentParent = array;\n                    currentProperty = null;\n                },\n                onArrayEnd: () => {\n                    currentParent = previousParents.pop();\n                },\n                onLiteralValue: onValue,\n                onError: (error, offset, length) => {\n                    parseErrors.push({ error, offset, length });\n                }\n            };\n            if (content) {\n                try {\n                    json.visit(content, visitor);\n                    raw = currentParent[0] || {};\n                }\n                catch (e) {\n                    console.error(`Error while parsing settings file ${this._name}: ${e}`);\n                    this._parseErrors = [e];\n                }\n            }\n            return raw;\n        }\n        parseRaw(raw) {\n            const contents = configuration_1.toValuesTree(raw, message => console.error(`Conflict in settings file ${this._name}: ${message}`));\n            const keys = Object.keys(raw);\n            const overrides = configuration_1.toOverrides(raw, message => console.error(`Conflict in settings file ${this._name}: ${message}`));\n            return { contents, keys, overrides };\n        }\n    }\n    exports.ConfigurationModelParser = ConfigurationModelParser;\n    class Configuration {\n        constructor(_defaultConfiguration, _localUserConfiguration, _remoteUserConfiguration = new ConfigurationModel(), _workspaceConfiguration = new ConfigurationModel(), _folderConfigurations = new map_1.ResourceMap(), _memoryConfiguration = new ConfigurationModel(), _memoryConfigurationByResource = new map_1.ResourceMap(), _freeze = true) {\n            this._defaultConfiguration = _defaultConfiguration;\n            this._localUserConfiguration = _localUserConfiguration;\n            this._remoteUserConfiguration = _remoteUserConfiguration;\n            this._workspaceConfiguration = _workspaceConfiguration;\n            this._folderConfigurations = _folderConfigurations;\n            this._memoryConfiguration = _memoryConfiguration;\n            this._memoryConfigurationByResource = _memoryConfigurationByResource;\n            this._freeze = _freeze;\n            this._workspaceConsolidatedConfiguration = null;\n            this._foldersConsolidatedConfigurations = new map_1.ResourceMap();\n        }\n        getValue(section, overrides, workspace) {\n            const consolidateConfigurationModel = this.getConsolidateConfigurationModel(overrides, workspace);\n            return consolidateConfigurationModel.getValue(section);\n        }\n        updateValue(key, value, overrides = {}) {\n            let memoryConfiguration;\n            if (overrides.resource) {\n                memoryConfiguration = this._memoryConfigurationByResource.get(overrides.resource);\n                if (!memoryConfiguration) {\n                    memoryConfiguration = new ConfigurationModel();\n                    this._memoryConfigurationByResource.set(overrides.resource, memoryConfiguration);\n                }\n            }\n            else {\n                memoryConfiguration = this._memoryConfiguration;\n            }\n            if (value === undefined) {\n                memoryConfiguration.removeValue(key);\n            }\n            else {\n                memoryConfiguration.setValue(key, value);\n            }\n            if (!overrides.resource) {\n                this._workspaceConsolidatedConfiguration = null;\n            }\n        }\n        inspect(key, overrides, workspace) {\n            const consolidateConfigurationModel = this.getConsolidateConfigurationModel(overrides, workspace);\n            const folderConfigurationModel = this.getFolderConfigurationModelForResource(overrides.resource, workspace);\n            const memoryConfigurationModel = overrides.resource ? this._memoryConfigurationByResource.get(overrides.resource) || this._memoryConfiguration : this._memoryConfiguration;\n            return {\n                default: overrides.overrideIdentifier ? this._defaultConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._defaultConfiguration.freeze().getValue(key),\n                user: overrides.overrideIdentifier ? this.userConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this.userConfiguration.freeze().getValue(key),\n                userLocal: overrides.overrideIdentifier ? this.localUserConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this.localUserConfiguration.freeze().getValue(key),\n                userRemote: overrides.overrideIdentifier ? this.remoteUserConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this.remoteUserConfiguration.freeze().getValue(key),\n                workspace: workspace ? overrides.overrideIdentifier ? this._workspaceConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._workspaceConfiguration.freeze().getValue(key) : undefined,\n                workspaceFolder: folderConfigurationModel ? overrides.overrideIdentifier ? folderConfigurationModel.freeze().override(overrides.overrideIdentifier).getValue(key) : folderConfigurationModel.freeze().getValue(key) : undefined,\n                memory: overrides.overrideIdentifier ? memoryConfigurationModel.override(overrides.overrideIdentifier).getValue(key) : memoryConfigurationModel.getValue(key),\n                value: consolidateConfigurationModel.getValue(key)\n            };\n        }\n        keys(workspace) {\n            const folderConfigurationModel = this.getFolderConfigurationModelForResource(undefined, workspace);\n            return {\n                default: this._defaultConfiguration.freeze().keys,\n                user: this.userConfiguration.freeze().keys,\n                workspace: this._workspaceConfiguration.freeze().keys,\n                workspaceFolder: folderConfigurationModel ? folderConfigurationModel.freeze().keys : []\n            };\n        }\n        updateDefaultConfiguration(defaultConfiguration) {\n            this._defaultConfiguration = defaultConfiguration;\n            this._workspaceConsolidatedConfiguration = null;\n            this._foldersConsolidatedConfigurations.clear();\n        }\n        updateLocalUserConfiguration(localUserConfiguration) {\n            this._localUserConfiguration = localUserConfiguration;\n            this._userConfiguration = null;\n            this._workspaceConsolidatedConfiguration = null;\n            this._foldersConsolidatedConfigurations.clear();\n        }\n        updateRemoteUserConfiguration(remoteUserConfiguration) {\n            this._remoteUserConfiguration = remoteUserConfiguration;\n            this._userConfiguration = null;\n            this._workspaceConsolidatedConfiguration = null;\n            this._foldersConsolidatedConfigurations.clear();\n        }\n        updateWorkspaceConfiguration(workspaceConfiguration) {\n            this._workspaceConfiguration = workspaceConfiguration;\n            this._workspaceConsolidatedConfiguration = null;\n            this._foldersConsolidatedConfigurations.clear();\n        }\n        updateFolderConfiguration(resource, configuration) {\n            this._folderConfigurations.set(resource, configuration);\n            this._foldersConsolidatedConfigurations.delete(resource);\n        }\n        deleteFolderConfiguration(resource) {\n            this.folderConfigurations.delete(resource);\n            this._foldersConsolidatedConfigurations.delete(resource);\n        }\n        get defaults() {\n            return this._defaultConfiguration;\n        }\n        get userConfiguration() {\n            if (!this._userConfiguration) {\n                this._userConfiguration = this._remoteUserConfiguration.isEmpty() ? this._localUserConfiguration : this._localUserConfiguration.merge(this._remoteUserConfiguration);\n                if (this._freeze) {\n                    this._userConfiguration.freeze();\n                }\n            }\n            return this._userConfiguration;\n        }\n        get localUserConfiguration() {\n            return this._localUserConfiguration;\n        }\n        get remoteUserConfiguration() {\n            return this._remoteUserConfiguration;\n        }\n        get workspaceConfiguration() {\n            return this._workspaceConfiguration;\n        }\n        get folderConfigurations() {\n            return this._folderConfigurations;\n        }\n        getConsolidateConfigurationModel(overrides, workspace) {\n            let configurationModel = this.getConsolidatedConfigurationModelForResource(overrides, workspace);\n            return overrides.overrideIdentifier ? configurationModel.override(overrides.overrideIdentifier) : configurationModel;\n        }\n        getConsolidatedConfigurationModelForResource({ resource }, workspace) {\n            let consolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();\n            if (workspace && resource) {\n                const root = workspace.getFolder(resource);\n                if (root) {\n                    consolidateConfiguration = this.getFolderConsolidatedConfiguration(root.uri) || consolidateConfiguration;\n                }\n                const memoryConfigurationForResource = this._memoryConfigurationByResource.get(resource);\n                if (memoryConfigurationForResource) {\n                    consolidateConfiguration = consolidateConfiguration.merge(memoryConfigurationForResource);\n                }\n            }\n            return consolidateConfiguration;\n        }\n        getWorkspaceConsolidatedConfiguration() {\n            if (!this._workspaceConsolidatedConfiguration) {\n                this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);\n                if (this._freeze) {\n                    this._workspaceConfiguration = this._workspaceConfiguration.freeze();\n                }\n            }\n            return this._workspaceConsolidatedConfiguration;\n        }\n        getFolderConsolidatedConfiguration(folder) {\n            let folderConsolidatedConfiguration = this._foldersConsolidatedConfigurations.get(folder);\n            if (!folderConsolidatedConfiguration) {\n                const workspaceConsolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();\n                const folderConfiguration = this._folderConfigurations.get(folder);\n                if (folderConfiguration) {\n                    folderConsolidatedConfiguration = workspaceConsolidateConfiguration.merge(folderConfiguration);\n                    if (this._freeze) {\n                        folderConsolidatedConfiguration = folderConsolidatedConfiguration.freeze();\n                    }\n                    this._foldersConsolidatedConfigurations.set(folder, folderConsolidatedConfiguration);\n                }\n                else {\n                    folderConsolidatedConfiguration = workspaceConsolidateConfiguration;\n                }\n            }\n            return folderConsolidatedConfiguration;\n        }\n        getFolderConfigurationModelForResource(resource, workspace) {\n            if (workspace && resource) {\n                const root = workspace.getFolder(resource);\n                if (root) {\n                    return types.withUndefinedAsNull(this._folderConfigurations.get(root.uri));\n                }\n            }\n            return null;\n        }\n        toData() {\n            return {\n                defaults: {\n                    contents: this._defaultConfiguration.contents,\n                    overrides: this._defaultConfiguration.overrides,\n                    keys: this._defaultConfiguration.keys\n                },\n                user: {\n                    contents: this.userConfiguration.contents,\n                    overrides: this.userConfiguration.overrides,\n                    keys: this.userConfiguration.keys\n                },\n                workspace: {\n                    contents: this._workspaceConfiguration.contents,\n                    overrides: this._workspaceConfiguration.overrides,\n                    keys: this._workspaceConfiguration.keys\n                },\n                folders: this._folderConfigurations.keys().reduce((result, folder) => {\n                    const { contents, overrides, keys } = this._folderConfigurations.get(folder);\n                    result[folder.toString()] = { contents, overrides, keys };\n                    return result;\n                }, Object.create({})),\n                isComplete: true\n            };\n        }\n        allKeys(workspace) {\n            let keys = this.keys(workspace);\n            let all = [...keys.default];\n            const addKeys = (keys) => {\n                for (const key of keys) {\n                    if (all.indexOf(key) === -1) {\n                        all.push(key);\n                    }\n                }\n            };\n            addKeys(keys.user);\n            addKeys(keys.workspace);\n            for (const resource of this.folderConfigurations.keys()) {\n                addKeys(this.folderConfigurations.get(resource).keys);\n            }\n            return all;\n        }\n    }\n    exports.Configuration = Configuration;\n    class AbstractConfigurationChangeEvent {\n        doesConfigurationContains(configuration, config) {\n            let changedKeysTree = configuration.contents;\n            let requestedTree = configuration_1.toValuesTree({ [config]: true }, () => { });\n            let key;\n            while (typeof requestedTree === 'object' && (key = Object.keys(requestedTree)[0])) { // Only one key should present, since we added only one property\n                changedKeysTree = changedKeysTree[key];\n                if (!changedKeysTree) {\n                    return false; // Requested tree is not found\n                }\n                requestedTree = requestedTree[key];\n            }\n            return true;\n        }\n        updateKeys(configuration, keys, resource) {\n            for (const key of keys) {\n                configuration.setValue(key, {});\n            }\n        }\n    }\n    exports.AbstractConfigurationChangeEvent = AbstractConfigurationChangeEvent;\n    class ConfigurationChangeEvent extends AbstractConfigurationChangeEvent {\n        constructor(_changedConfiguration = new ConfigurationModel(), _changedConfigurationByResource = new map_1.ResourceMap()) {\n            super();\n            this._changedConfiguration = _changedConfiguration;\n            this._changedConfigurationByResource = _changedConfigurationByResource;\n        }\n        get changedConfiguration() {\n            return this._changedConfiguration;\n        }\n        get changedConfigurationByResource() {\n            return this._changedConfigurationByResource;\n        }\n        change(arg1, arg2) {\n            if (arg1 instanceof ConfigurationChangeEvent) {\n                this._changedConfiguration = this._changedConfiguration.merge(arg1._changedConfiguration);\n                for (const resource of arg1._changedConfigurationByResource.keys()) {\n                    let changedConfigurationByResource = this.getOrSetChangedConfigurationForResource(resource);\n                    changedConfigurationByResource = changedConfigurationByResource.merge(arg1._changedConfigurationByResource.get(resource));\n                    this._changedConfigurationByResource.set(resource, changedConfigurationByResource);\n                }\n            }\n            else {\n                this.changeWithKeys(arg1, arg2);\n            }\n            return this;\n        }\n        telemetryData(source, sourceConfig) {\n            this._source = source;\n            this._sourceConfig = sourceConfig;\n            return this;\n        }\n        get affectedKeys() {\n            const keys = [...this._changedConfiguration.keys];\n            this._changedConfigurationByResource.forEach(model => keys.push(...model.keys));\n            return arrays.distinct(keys);\n        }\n        get source() {\n            return this._source;\n        }\n        get sourceConfig() {\n            return this._sourceConfig;\n        }\n        affectsConfiguration(config, resource) {\n            let configurationModelsToSearch = [this._changedConfiguration];\n            if (resource) {\n                let model = this._changedConfigurationByResource.get(resource);\n                if (model) {\n                    configurationModelsToSearch.push(model);\n                }\n            }\n            else {\n                configurationModelsToSearch.push(...this._changedConfigurationByResource.values());\n            }\n            for (const configuration of configurationModelsToSearch) {\n                if (this.doesConfigurationContains(configuration, config)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        changeWithKeys(keys, resource) {\n            let changedConfiguration = resource ? this.getOrSetChangedConfigurationForResource(resource) : this._changedConfiguration;\n            this.updateKeys(changedConfiguration, keys);\n        }\n        getOrSetChangedConfigurationForResource(resource) {\n            let changedConfigurationByResource = this._changedConfigurationByResource.get(resource);\n            if (!changedConfigurationByResource) {\n                changedConfigurationByResource = new ConfigurationModel();\n                this._changedConfigurationByResource.set(resource, changedConfigurationByResource);\n            }\n            return changedConfigurationByResource;\n        }\n    }\n    exports.ConfigurationChangeEvent = ConfigurationChangeEvent;\n});\n",null]}