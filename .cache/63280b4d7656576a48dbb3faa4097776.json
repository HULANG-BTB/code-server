{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/node/zip.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/zip.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar nls = require(\"vs/nls\");\nvar path = require(\"vs/base/common/path\");\nvar fs_1 = require(\"fs\");\nvar async_1 = require(\"vs/base/common/async\");\nvar pfs_1 = require(\"vs/base/node/pfs\");\nvar yauzl_1 = require(\"yauzl\");\nvar yazl = require(\"yazl\");\nvar event_1 = require(\"vs/base/common/event\");\nvar ExtractError = /** @class */ (function (_super) {\n    tslib_1.__extends(ExtractError, _super);\n    function ExtractError(type, cause) {\n        var _this = this;\n        var message = cause.message;\n        switch (type) {\n            case 'CorruptZip':\n                message = \"Corrupt ZIP: \" + message;\n                break;\n        }\n        _this = _super.call(this, message) || this;\n        _this.type = type;\n        _this.cause = cause;\n        return _this;\n    }\n    return ExtractError;\n}(Error));\nexports.ExtractError = ExtractError;\nfunction modeFromEntry(entry) {\n    var attr = entry.externalFileAttributes >> 16 || 33188;\n    return [448 /* S_IRWXU */, 56 /* S_IRWXG */, 7 /* S_IRWXO */]\n        .map(function (mask) { return attr & mask; })\n        .reduce(function (a, b) { return a + b; }, attr & 61440 /* S_IFMT */);\n}\nfunction toExtractError(err) {\n    if (err instanceof ExtractError) {\n        return err;\n    }\n    var type = undefined;\n    if (/end of central directory record signature not found/.test(err.message)) {\n        type = 'CorruptZip';\n    }\n    return new ExtractError(type, err);\n}\nfunction extractEntry(stream, fileName, mode, targetPath, options, token) {\n    var dirName = path.dirname(fileName);\n    var targetDirName = path.join(targetPath, dirName);\n    if (targetDirName.indexOf(targetPath) !== 0) {\n        return Promise.reject(new Error(nls.localize('invalid file', \"Error extracting {0}. Invalid file.\", fileName)));\n    }\n    var targetFileName = path.join(targetPath, fileName);\n    var istream;\n    event_1.Event.once(token.onCancellationRequested)(function () {\n        if (istream) {\n            istream.destroy();\n        }\n    });\n    return Promise.resolve(pfs_1.mkdirp(targetDirName, undefined, token)).then(function () { return new Promise(function (c, e) {\n        if (token.isCancellationRequested) {\n            return;\n        }\n        try {\n            istream = fs_1.createWriteStream(targetFileName, { mode: mode });\n            istream.once('close', function () { return c(); });\n            istream.once('error', e);\n            stream.once('error', e);\n            stream.pipe(istream);\n        }\n        catch (error) {\n            e(error);\n        }\n    }); });\n}\nfunction extractZip(zipfile, targetPath, options, token) {\n    var last = async_1.createCancelablePromise(function () { return Promise.resolve(); });\n    var extractedEntriesCount = 0;\n    event_1.Event.once(token.onCancellationRequested)(function () {\n        last.cancel();\n        zipfile.close();\n    });\n    return new Promise(function (c, e) {\n        var throttler = new async_1.Sequencer();\n        var readNextEntry = function (token) {\n            if (token.isCancellationRequested) {\n                return;\n            }\n            extractedEntriesCount++;\n            zipfile.readEntry();\n        };\n        zipfile.once('error', e);\n        zipfile.once('close', function () { return last.then(function () {\n            if (token.isCancellationRequested || zipfile.entryCount === extractedEntriesCount) {\n                c();\n            }\n            else {\n                e(new ExtractError('Incomplete', new Error(nls.localize('incompleteExtract', \"Incomplete. Found {0} of {1} entries\", extractedEntriesCount, zipfile.entryCount))));\n            }\n        }, e); });\n        zipfile.readEntry();\n        zipfile.on('entry', function (entry) {\n            if (token.isCancellationRequested) {\n                return;\n            }\n            if (!options.sourcePathRegex.test(entry.fileName)) {\n                readNextEntry(token);\n                return;\n            }\n            var fileName = entry.fileName.replace(options.sourcePathRegex, '');\n            // directory file names end with '/'\n            if (/\\/$/.test(fileName)) {\n                var targetFileName_1 = path.join(targetPath, fileName);\n                last = async_1.createCancelablePromise(function (token) { return pfs_1.mkdirp(targetFileName_1, undefined, token).then(function () { return readNextEntry(token); }).then(undefined, e); });\n                return;\n            }\n            var stream = async_1.ninvoke(zipfile, zipfile.openReadStream, entry);\n            var mode = modeFromEntry(entry);\n            last = async_1.createCancelablePromise(function (token) { return throttler.queue(function () { return stream.then(function (stream) { return extractEntry(stream, fileName, mode, targetPath, options, token).then(function () { return readNextEntry(token); }); }); }).then(null, e); });\n        });\n    });\n}\nfunction openZip(zipFile, lazy) {\n    if (lazy === void 0) { lazy = false; }\n    return async_1.nfcall(yauzl_1.open, zipFile, lazy ? { lazyEntries: true } : undefined)\n        .then(undefined, function (err) { return Promise.reject(toExtractError(err)); });\n}\nfunction zip(zipPath, files) {\n    return new Promise(function (c, e) {\n        var zip = new yazl.ZipFile();\n        files.forEach(function (f) {\n            if (f.contents) {\n                zip.addBuffer(typeof f.contents === 'string' ? Buffer.from(f.contents, 'utf8') : f.contents, f.path);\n            }\n            else if (f.localPath) {\n                zip.addFile(f.localPath, f.path);\n            }\n        });\n        zip.end();\n        var zipStream = fs_1.createWriteStream(zipPath);\n        zip.outputStream.pipe(zipStream);\n        zip.outputStream.once('error', e);\n        zipStream.once('error', e);\n        zipStream.once('finish', function () { return c(zipPath); });\n    });\n}\nexports.zip = zip;\nfunction extract(zipPath, targetPath, options, token) {\n    if (options === void 0) { options = {}; }\n    var sourcePathRegex = new RegExp(options.sourcePath ? \"^\" + options.sourcePath : '');\n    var promise = openZip(zipPath, true);\n    if (options.overwrite) {\n        promise = promise.then(function (zipfile) { return pfs_1.rimraf(targetPath).then(function () { return zipfile; }); });\n    }\n    return promise.then(function (zipfile) { return extractZip(zipfile, targetPath, { sourcePathRegex: sourcePathRegex }, token); });\n}\nexports.extract = extract;\nfunction read(zipPath, filePath) {\n    return openZip(zipPath).then(function (zipfile) {\n        return new Promise(function (c, e) {\n            zipfile.on('entry', function (entry) {\n                if (entry.fileName === filePath) {\n                    async_1.ninvoke(zipfile, zipfile.openReadStream, entry).then(function (stream) { return c(stream); }, function (err) { return e(err); });\n                }\n            });\n            zipfile.once('close', function () { return e(new Error(nls.localize('notFound', \"{0} not found inside zip.\", filePath))); });\n        });\n    });\n}\nfunction buffer(zipPath, filePath) {\n    return read(zipPath, filePath).then(function (stream) {\n        return new Promise(function (c, e) {\n            var buffers = [];\n            stream.once('error', e);\n            stream.on('data', function (b) { return buffers.push(b); });\n            stream.on('end', function () { return c(Buffer.concat(buffers)); });\n        });\n    });\n}\nexports.buffer = buffer;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/node/zip.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/node/zip.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\nimport * as path from 'vs/base/common/path';\nimport { createWriteStream, WriteStream } from 'fs';\nimport { Readable } from 'stream';\nimport { nfcall, ninvoke, Sequencer, createCancelablePromise } from 'vs/base/common/async';\nimport { mkdirp, rimraf } from 'vs/base/node/pfs';\nimport { open as _openZip, Entry, ZipFile } from 'yauzl';\nimport * as yazl from 'yazl';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { Event } from 'vs/base/common/event';\n\nexport interface IExtractOptions {\n\toverwrite?: boolean;\n\n\t/**\t\n\t * Source path within the ZIP archive. Only the files contained in this\n\t * path will be extracted.\n\t */\n\tsourcePath?: string;\n}\n\ninterface IOptions {\n\tsourcePathRegex: RegExp;\n}\n\nexport type ExtractErrorType = 'CorruptZip' | 'Incomplete';\n\nexport class ExtractError extends Error {\n\n\treadonly type?: ExtractErrorType;\n\treadonly cause: Error;\n\n\tconstructor(type: ExtractErrorType | undefined, cause: Error) {\n\t\tlet message = cause.message;\n\n\t\tswitch (type) {\n\t\t\tcase 'CorruptZip': message = `Corrupt ZIP: ${message}`; break;\n\t\t}\n\n\t\tsuper(message);\n\t\tthis.type = type;\n\t\tthis.cause = cause;\n\t}\n}\n\nfunction modeFromEntry(entry: Entry) {\n\tconst attr = entry.externalFileAttributes >> 16 || 33188;\n\n\treturn [448 /* S_IRWXU */, 56 /* S_IRWXG */, 7 /* S_IRWXO */]\n\t\t.map(mask => attr & mask)\n\t\t.reduce((a, b) => a + b, attr & 61440 /* S_IFMT */);\n}\n\nfunction toExtractError(err: Error): ExtractError {\n\tif (err instanceof ExtractError) {\n\t\treturn err;\n\t}\n\n\tlet type: ExtractErrorType | undefined = undefined;\n\n\tif (/end of central directory record signature not found/.test(err.message)) {\n\t\ttype = 'CorruptZip';\n\t}\n\n\treturn new ExtractError(type, err);\n}\n\nfunction extractEntry(stream: Readable, fileName: string, mode: number, targetPath: string, options: IOptions, token: CancellationToken): Promise<void> {\n\tconst dirName = path.dirname(fileName);\n\tconst targetDirName = path.join(targetPath, dirName);\n\tif (targetDirName.indexOf(targetPath) !== 0) {\n\t\treturn Promise.reject(new Error(nls.localize('invalid file', \"Error extracting {0}. Invalid file.\", fileName)));\n\t}\n\tconst targetFileName = path.join(targetPath, fileName);\n\n\tlet istream: WriteStream;\n\n\tEvent.once(token.onCancellationRequested)(() => {\n\t\tif (istream) {\n\t\t\tistream.destroy();\n\t\t}\n\t});\n\n\treturn Promise.resolve(mkdirp(targetDirName, undefined, token)).then(() => new Promise<void>((c, e) => {\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tistream = createWriteStream(targetFileName, { mode });\n\t\t\tistream.once('close', () => c());\n\t\t\tistream.once('error', e);\n\t\t\tstream.once('error', e);\n\t\t\tstream.pipe(istream);\n\t\t} catch (error) {\n\t\t\te(error);\n\t\t}\n\t}));\n}\n\nfunction extractZip(zipfile: ZipFile, targetPath: string, options: IOptions, token: CancellationToken): Promise<void> {\n\tlet last = createCancelablePromise<void>(() => Promise.resolve());\n\tlet extractedEntriesCount = 0;\n\n\tEvent.once(token.onCancellationRequested)(() => {\n\t\tlast.cancel();\n\t\tzipfile.close();\n\t});\n\n\treturn new Promise((c, e) => {\n\t\tconst throttler = new Sequencer();\n\n\t\tconst readNextEntry = (token: CancellationToken) => {\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\textractedEntriesCount++;\n\t\t\tzipfile.readEntry();\n\t\t};\n\n\t\tzipfile.once('error', e);\n\t\tzipfile.once('close', () => last.then(() => {\n\t\t\tif (token.isCancellationRequested || zipfile.entryCount === extractedEntriesCount) {\n\t\t\t\tc();\n\t\t\t} else {\n\t\t\t\te(new ExtractError('Incomplete', new Error(nls.localize('incompleteExtract', \"Incomplete. Found {0} of {1} entries\", extractedEntriesCount, zipfile.entryCount))));\n\t\t\t}\n\t\t}, e));\n\t\tzipfile.readEntry();\n\t\tzipfile.on('entry', (entry: Entry) => {\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!options.sourcePathRegex.test(entry.fileName)) {\n\t\t\t\treadNextEntry(token);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst fileName = entry.fileName.replace(options.sourcePathRegex, '');\n\n\t\t\t// directory file names end with '/'\n\t\t\tif (/\\/$/.test(fileName)) {\n\t\t\t\tconst targetFileName = path.join(targetPath, fileName);\n\t\t\t\tlast = createCancelablePromise(token => mkdirp(targetFileName, undefined, token).then(() => readNextEntry(token)).then(undefined, e));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst stream = ninvoke(zipfile, zipfile.openReadStream, entry);\n\t\t\tconst mode = modeFromEntry(entry);\n\n\t\t\tlast = createCancelablePromise(token => throttler.queue(() => stream.then(stream => extractEntry(stream, fileName, mode, targetPath, options, token).then(() => readNextEntry(token)))).then(null!, e));\n\t\t});\n\t});\n}\n\nfunction openZip(zipFile: string, lazy: boolean = false): Promise<ZipFile> {\n\treturn nfcall<ZipFile>(_openZip, zipFile, lazy ? { lazyEntries: true } : undefined)\n\t\t.then(undefined, err => Promise.reject(toExtractError(err)));\n}\n\nexport interface IFile {\n\tpath: string;\n\tcontents?: Buffer | string;\n\tlocalPath?: string;\n}\n\nexport function zip(zipPath: string, files: IFile[]): Promise<string> {\n\treturn new Promise<string>((c, e) => {\n\t\tconst zip = new yazl.ZipFile();\n\t\tfiles.forEach(f => {\n\t\t\tif (f.contents) {\n\t\t\t\tzip.addBuffer(typeof f.contents === 'string' ? Buffer.from(f.contents, 'utf8') : f.contents, f.path);\n\t\t\t} else if (f.localPath) {\n\t\t\t\tzip.addFile(f.localPath, f.path);\n\t\t\t}\n\t\t});\n\t\tzip.end();\n\n\t\tconst zipStream = createWriteStream(zipPath);\n\t\tzip.outputStream.pipe(zipStream);\n\n\t\tzip.outputStream.once('error', e);\n\t\tzipStream.once('error', e);\n\t\tzipStream.once('finish', () => c(zipPath));\n\t});\n}\n\nexport function extract(zipPath: string, targetPath: string, options: IExtractOptions = {}, token: CancellationToken): Promise<void> {\n\tconst sourcePathRegex = new RegExp(options.sourcePath ? `^${options.sourcePath}` : '');\n\n\tlet promise = openZip(zipPath, true);\n\n\tif (options.overwrite) {\n\t\tpromise = promise.then(zipfile => rimraf(targetPath).then(() => zipfile));\n\t}\n\n\treturn promise.then(zipfile => extractZip(zipfile, targetPath, { sourcePathRegex }, token));\n}\n\nfunction read(zipPath: string, filePath: string): Promise<Readable> {\n\treturn openZip(zipPath).then(zipfile => {\n\t\treturn new Promise<Readable>((c, e) => {\n\t\t\tzipfile.on('entry', (entry: Entry) => {\n\t\t\t\tif (entry.fileName === filePath) {\n\t\t\t\t\tninvoke<Readable>(zipfile, zipfile.openReadStream, entry).then(stream => c(stream), err => e(err));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tzipfile.once('close', () => e(new Error(nls.localize('notFound', \"{0} not found inside zip.\", filePath))));\n\t\t});\n\t});\n}\n\nexport function buffer(zipPath: string, filePath: string): Promise<Buffer> {\n\treturn read(zipPath, filePath).then(stream => {\n\t\treturn new Promise<Buffer>((c, e) => {\n\t\t\tconst buffers: Buffer[] = [];\n\t\t\tstream.once('error', e);\n\t\t\tstream.on('data', b => buffers.push(b as Buffer));\n\t\t\tstream.on('end', () => c(Buffer.concat(buffers)));\n\t\t});\n\t});\n}\n"]}]}