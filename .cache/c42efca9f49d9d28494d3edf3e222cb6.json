{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/common/ipc.net.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/common/ipc.net.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar event_1 = require(\"vs/base/common/event\");\nvar ipc_1 = require(\"vs/base/parts/ipc/common/ipc\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar buffer_1 = require(\"vs/base/common/buffer\");\nvar platform = require(\"vs/base/common/platform\");\nvar emptyBuffer = null;\nfunction getEmptyBuffer() {\n    if (!emptyBuffer) {\n        emptyBuffer = buffer_1.VSBuffer.alloc(0);\n    }\n    return emptyBuffer;\n}\nvar ChunkStream = /** @class */ (function () {\n    function ChunkStream() {\n        this._chunks = [];\n        this._totalLength = 0;\n    }\n    Object.defineProperty(ChunkStream.prototype, \"byteLength\", {\n        get: function () {\n            return this._totalLength;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ChunkStream.prototype.acceptChunk = function (buff) {\n        this._chunks.push(buff);\n        this._totalLength += buff.byteLength;\n    };\n    ChunkStream.prototype.read = function (byteCount) {\n        if (byteCount === 0) {\n            return getEmptyBuffer();\n        }\n        if (byteCount > this._totalLength) {\n            throw new Error(\"Cannot read so many bytes!\");\n        }\n        if (this._chunks[0].byteLength === byteCount) {\n            // super fast path, precisely first chunk must be returned\n            var result_1 = this._chunks.shift();\n            this._totalLength -= byteCount;\n            return result_1;\n        }\n        if (this._chunks[0].byteLength > byteCount) {\n            // fast path, the reading is entirely within the first chunk\n            var result_2 = this._chunks[0].slice(0, byteCount);\n            this._chunks[0] = this._chunks[0].slice(byteCount);\n            this._totalLength -= byteCount;\n            return result_2;\n        }\n        var result = buffer_1.VSBuffer.alloc(byteCount);\n        var resultOffset = 0;\n        while (byteCount > 0) {\n            var chunk = this._chunks[0];\n            if (chunk.byteLength > byteCount) {\n                // this chunk will survive\n                this._chunks[0] = chunk.slice(byteCount);\n                var chunkPart = chunk.slice(0, byteCount);\n                result.set(chunkPart, resultOffset);\n                resultOffset += byteCount;\n                this._totalLength -= byteCount;\n                byteCount -= byteCount;\n            }\n            else {\n                // this chunk will be entirely read\n                this._chunks.shift();\n                result.set(chunk, resultOffset);\n                resultOffset += chunk.byteLength;\n                this._totalLength -= chunk.byteLength;\n                byteCount -= chunk.byteLength;\n            }\n        }\n        return result;\n    };\n    return ChunkStream;\n}());\nvar ProtocolMessageType;\n(function (ProtocolMessageType) {\n    ProtocolMessageType[ProtocolMessageType[\"None\"] = 0] = \"None\";\n    ProtocolMessageType[ProtocolMessageType[\"Regular\"] = 1] = \"Regular\";\n    ProtocolMessageType[ProtocolMessageType[\"Control\"] = 2] = \"Control\";\n    ProtocolMessageType[ProtocolMessageType[\"Ack\"] = 3] = \"Ack\";\n    ProtocolMessageType[ProtocolMessageType[\"KeepAlive\"] = 4] = \"KeepAlive\";\n})(ProtocolMessageType || (ProtocolMessageType = {}));\nvar ProtocolConstants;\n(function (ProtocolConstants) {\n    ProtocolConstants[ProtocolConstants[\"HeaderLength\"] = 13] = \"HeaderLength\";\n    /**\n     * Send an Acknowledge message at most 2 seconds later...\n     */\n    ProtocolConstants[ProtocolConstants[\"AcknowledgeTime\"] = 2000] = \"AcknowledgeTime\";\n    /**\n     * If there is a message that has been unacknowledged for 10 seconds, consider the connection closed...\n     */\n    ProtocolConstants[ProtocolConstants[\"AcknowledgeTimeoutTime\"] = 10000] = \"AcknowledgeTimeoutTime\";\n    /**\n     * Send at least a message every 30s for keep alive reasons.\n     */\n    ProtocolConstants[ProtocolConstants[\"KeepAliveTime\"] = 30000] = \"KeepAliveTime\";\n    /**\n     * If there is no message received for 60 seconds, consider the connection closed...\n     */\n    ProtocolConstants[ProtocolConstants[\"KeepAliveTimeoutTime\"] = 60000] = \"KeepAliveTimeoutTime\";\n    /**\n     * If there is no reconnection within this time-frame, consider the connection permanently closed...\n     */\n    ProtocolConstants[ProtocolConstants[\"ReconnectionGraceTime\"] = 3600000] = \"ReconnectionGraceTime\";\n})(ProtocolConstants = exports.ProtocolConstants || (exports.ProtocolConstants = {}));\nvar ProtocolMessage = /** @class */ (function () {\n    function ProtocolMessage(type, id, ack, data) {\n        this.type = type;\n        this.id = id;\n        this.ack = ack;\n        this.data = data;\n        this.writtenTime = 0;\n    }\n    Object.defineProperty(ProtocolMessage.prototype, \"size\", {\n        get: function () {\n            return this.data.byteLength;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return ProtocolMessage;\n}());\nvar ProtocolReader = /** @class */ (function (_super) {\n    tslib_1.__extends(ProtocolReader, _super);\n    function ProtocolReader(socket) {\n        var _this = _super.call(this) || this;\n        _this._onMessage = new event_1.Emitter();\n        _this.onMessage = _this._onMessage.event;\n        _this._state = {\n            readHead: true,\n            readLen: ProtocolConstants.HeaderLength,\n            messageType: ProtocolMessageType.None,\n            id: 0,\n            ack: 0\n        };\n        _this._socket = socket;\n        _this._isDisposed = false;\n        _this._incomingData = new ChunkStream();\n        _this._register(_this._socket.onData(function (data) { return _this.acceptChunk(data); }));\n        _this.lastReadTime = Date.now();\n        return _this;\n    }\n    ProtocolReader.prototype.acceptChunk = function (data) {\n        if (!data || data.byteLength === 0) {\n            return;\n        }\n        this.lastReadTime = Date.now();\n        this._incomingData.acceptChunk(data);\n        while (this._incomingData.byteLength >= this._state.readLen) {\n            var buff = this._incomingData.read(this._state.readLen);\n            if (this._state.readHead) {\n                // buff is the header\n                // save new state => next time will read the body\n                this._state.readHead = false;\n                this._state.readLen = buff.readUint32BE(9);\n                this._state.messageType = buff.readUint8(0);\n                this._state.id = buff.readUint32BE(1);\n                this._state.ack = buff.readUint32BE(5);\n            }\n            else {\n                // buff is the body\n                var messageType = this._state.messageType;\n                var id = this._state.id;\n                var ack = this._state.ack;\n                // save new state => next time will read the header\n                this._state.readHead = true;\n                this._state.readLen = ProtocolConstants.HeaderLength;\n                this._state.messageType = ProtocolMessageType.None;\n                this._state.id = 0;\n                this._state.ack = 0;\n                this._onMessage.fire(new ProtocolMessage(messageType, id, ack, buff));\n                if (this._isDisposed) {\n                    // check if an event listener lead to our disposal\n                    break;\n                }\n            }\n        }\n    };\n    ProtocolReader.prototype.readEntireBuffer = function () {\n        return this._incomingData.read(this._incomingData.byteLength);\n    };\n    ProtocolReader.prototype.dispose = function () {\n        this._isDisposed = true;\n        _super.prototype.dispose.call(this);\n    };\n    return ProtocolReader;\n}(lifecycle_1.Disposable));\nvar ProtocolWriter = /** @class */ (function () {\n    function ProtocolWriter(socket) {\n        this._isDisposed = false;\n        this._socket = socket;\n        this._data = [];\n        this._totalLength = 0;\n        this.lastWriteTime = 0;\n    }\n    ProtocolWriter.prototype.dispose = function () {\n        this.flush();\n        this._isDisposed = true;\n    };\n    ProtocolWriter.prototype.flush = function () {\n        // flush\n        this._writeNow();\n    };\n    ProtocolWriter.prototype.write = function (msg) {\n        if (this._isDisposed) {\n            console.warn(\"Cannot write message in a disposed ProtocolWriter\");\n            console.warn(msg);\n            return;\n        }\n        msg.writtenTime = Date.now();\n        this.lastWriteTime = Date.now();\n        var header = buffer_1.VSBuffer.alloc(ProtocolConstants.HeaderLength);\n        header.writeUint8(msg.type, 0);\n        header.writeUint32BE(msg.id, 1);\n        header.writeUint32BE(msg.ack, 5);\n        header.writeUint32BE(msg.data.byteLength, 9);\n        this._writeSoon(header, msg.data);\n    };\n    ProtocolWriter.prototype._bufferAdd = function (head, body) {\n        var wasEmpty = this._totalLength === 0;\n        this._data.push(head, body);\n        this._totalLength += head.byteLength + body.byteLength;\n        return wasEmpty;\n    };\n    ProtocolWriter.prototype._bufferTake = function () {\n        var ret = buffer_1.VSBuffer.concat(this._data, this._totalLength);\n        this._data.length = 0;\n        this._totalLength = 0;\n        return ret;\n    };\n    ProtocolWriter.prototype._writeSoon = function (header, data) {\n        var _this = this;\n        if (this._bufferAdd(header, data)) {\n            platform.setImmediate(function () {\n                _this._writeNow();\n            });\n        }\n    };\n    ProtocolWriter.prototype._writeNow = function () {\n        if (this._totalLength === 0) {\n            return;\n        }\n        this._socket.write(this._bufferTake());\n    };\n    return ProtocolWriter;\n}());\n/**\n * A message has the following format:\n * ```\n *     /-------------------------------|------\\\n *     |             HEADER            |      |\n *     |-------------------------------| DATA |\n *     | TYPE | ID | ACK | DATA_LENGTH |      |\n *     \\-------------------------------|------/\n * ```\n * The header is 9 bytes and consists of:\n *  - TYPE is 1 byte (ProtocolMessageType) - the message type\n *  - ID is 4 bytes (u32be) - the message id (can be 0 to indicate to be ignored)\n *  - ACK is 4 bytes (u32be) - the acknowledged message id (can be 0 to indicate to be ignored)\n *  - DATA_LENGTH is 4 bytes (u32be) - the length in bytes of DATA\n *\n * Only Regular messages are counted, other messages are not counted, nor acknowledged.\n */\nvar Protocol = /** @class */ (function (_super) {\n    tslib_1.__extends(Protocol, _super);\n    function Protocol(socket) {\n        var _this = _super.call(this) || this;\n        _this._onMessage = new event_1.Emitter();\n        _this.onMessage = _this._onMessage.event;\n        _this._onClose = new event_1.Emitter();\n        _this.onClose = _this._onClose.event;\n        _this._socket = socket;\n        _this._socketWriter = _this._register(new ProtocolWriter(_this._socket));\n        _this._socketReader = _this._register(new ProtocolReader(_this._socket));\n        _this._register(_this._socketReader.onMessage(function (msg) {\n            if (msg.type === ProtocolMessageType.Regular) {\n                _this._onMessage.fire(msg.data);\n            }\n        }));\n        _this._register(_this._socket.onClose(function () { return _this._onClose.fire(); }));\n        return _this;\n    }\n    Protocol.prototype.getSocket = function () {\n        return this._socket;\n    };\n    Protocol.prototype.send = function (buffer) {\n        this._socketWriter.write(new ProtocolMessage(ProtocolMessageType.Regular, 0, 0, buffer));\n    };\n    return Protocol;\n}(lifecycle_1.Disposable));\nexports.Protocol = Protocol;\nvar Client = /** @class */ (function (_super) {\n    tslib_1.__extends(Client, _super);\n    function Client(protocol, id) {\n        var _this = _super.call(this, protocol, id) || this;\n        _this.protocol = protocol;\n        return _this;\n    }\n    Client.fromSocket = function (socket, id) {\n        return new Client(new Protocol(socket), id);\n    };\n    Object.defineProperty(Client.prototype, \"onClose\", {\n        get: function () { return this.protocol.onClose; },\n        enumerable: true,\n        configurable: true\n    });\n    Client.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        var socket = this.protocol.getSocket();\n        this.protocol.dispose();\n        socket.end();\n    };\n    return Client;\n}(ipc_1.IPCClient));\nexports.Client = Client;\n/**\n * Will ensure no messages are lost if there are no event listeners.\n */\nfunction createBufferedEvent(source) {\n    var emitter;\n    var hasListeners = false;\n    var isDeliveringMessages = false;\n    var bufferedMessages = [];\n    var deliverMessages = function () {\n        if (isDeliveringMessages) {\n            return;\n        }\n        isDeliveringMessages = true;\n        while (hasListeners && bufferedMessages.length > 0) {\n            emitter.fire(bufferedMessages.shift());\n        }\n        isDeliveringMessages = false;\n    };\n    source(function (e) {\n        bufferedMessages.push(e);\n        deliverMessages();\n    });\n    emitter = new event_1.Emitter({\n        onFirstListenerAdd: function () {\n            hasListeners = true;\n            // it is important to deliver these messages after this call, but before\n            // other messages have a chance to be received (to guarantee in order delivery)\n            // that's why we're using here nextTick and not other types of timeouts\n            if (typeof process !== 'undefined') {\n                process.nextTick(deliverMessages);\n            }\n            else {\n                platform.setImmediate(deliverMessages);\n            }\n        },\n        onLastListenerRemove: function () {\n            hasListeners = false;\n        }\n    });\n    return emitter.event;\n}\nvar QueueElement = /** @class */ (function () {\n    function QueueElement(data) {\n        this.data = data;\n        this.next = null;\n    }\n    return QueueElement;\n}());\nvar Queue = /** @class */ (function () {\n    function Queue() {\n        this._first = null;\n        this._last = null;\n    }\n    Queue.prototype.peek = function () {\n        if (!this._first) {\n            return null;\n        }\n        return this._first.data;\n    };\n    Queue.prototype.toArray = function () {\n        var result = [], resultLen = 0;\n        var it = this._first;\n        while (it) {\n            result[resultLen++] = it.data;\n            it = it.next;\n        }\n        return result;\n    };\n    Queue.prototype.pop = function () {\n        if (!this._first) {\n            return;\n        }\n        if (this._first === this._last) {\n            this._first = null;\n            this._last = null;\n            return;\n        }\n        this._first = this._first.next;\n    };\n    Queue.prototype.push = function (item) {\n        var element = new QueueElement(item);\n        if (!this._first) {\n            this._first = element;\n            this._last = element;\n            return;\n        }\n        this._last.next = element;\n        this._last = element;\n    };\n    return Queue;\n}());\n/**\n * Same as Protocol, but will actually track messages and acks.\n * Moreover, it will ensure no messages are lost if there are no event listeners.\n */\nvar PersistentProtocol = /** @class */ (function () {\n    function PersistentProtocol(socket, initialChunk) {\n        if (initialChunk === void 0) { initialChunk = null; }\n        var _this = this;\n        this._onControlMessage = new event_1.Emitter();\n        this.onControlMessage = createBufferedEvent(this._onControlMessage.event);\n        this._onMessage = new event_1.Emitter();\n        this.onMessage = createBufferedEvent(this._onMessage.event);\n        this._onClose = new event_1.Emitter();\n        this.onClose = createBufferedEvent(this._onClose.event);\n        this._onSocketClose = new event_1.Emitter();\n        this.onSocketClose = createBufferedEvent(this._onSocketClose.event);\n        this._onSocketTimeout = new event_1.Emitter();\n        this.onSocketTimeout = createBufferedEvent(this._onSocketTimeout.event);\n        this._isReconnecting = false;\n        this._outgoingUnackMsg = new Queue();\n        this._outgoingMsgId = 0;\n        this._outgoingAckId = 0;\n        this._outgoingAckTimeout = null;\n        this._incomingMsgId = 0;\n        this._incomingAckId = 0;\n        this._incomingMsgLastTime = 0;\n        this._incomingAckTimeout = null;\n        this._outgoingKeepAliveTimeout = null;\n        this._incomingKeepAliveTimeout = null;\n        this._socketDisposables = [];\n        this._socket = socket;\n        this._socketWriter = new ProtocolWriter(this._socket);\n        this._socketDisposables.push(this._socketWriter);\n        this._socketReader = new ProtocolReader(this._socket);\n        this._socketDisposables.push(this._socketReader);\n        this._socketDisposables.push(this._socketReader.onMessage(function (msg) { return _this._receiveMessage(msg); }));\n        this._socketDisposables.push(this._socket.onClose(function () { return _this._onSocketClose.fire(); }));\n        this._socketDisposables.push(this._socket.onEnd(function () { return _this._onClose.fire(); }));\n        if (initialChunk) {\n            this._socketReader.acceptChunk(initialChunk);\n        }\n        this._sendKeepAliveCheck();\n        this._recvKeepAliveCheck();\n    }\n    Object.defineProperty(PersistentProtocol.prototype, \"unacknowledgedCount\", {\n        get: function () {\n            return this._outgoingMsgId - this._outgoingAckId;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PersistentProtocol.prototype.dispose = function () {\n        if (this._outgoingAckTimeout) {\n            clearTimeout(this._outgoingAckTimeout);\n            this._outgoingAckTimeout = null;\n        }\n        if (this._incomingAckTimeout) {\n            clearTimeout(this._incomingAckTimeout);\n            this._incomingAckTimeout = null;\n        }\n        if (this._outgoingKeepAliveTimeout) {\n            clearTimeout(this._outgoingKeepAliveTimeout);\n            this._outgoingKeepAliveTimeout = null;\n        }\n        if (this._incomingKeepAliveTimeout) {\n            clearTimeout(this._incomingKeepAliveTimeout);\n            this._incomingKeepAliveTimeout = null;\n        }\n        this._socketDisposables = lifecycle_1.dispose(this._socketDisposables);\n    };\n    PersistentProtocol.prototype._sendKeepAliveCheck = function () {\n        var _this = this;\n        if (this._outgoingKeepAliveTimeout) {\n            // there will be a check in the near future\n            return;\n        }\n        var timeSinceLastOutgoingMsg = Date.now() - this._socketWriter.lastWriteTime;\n        if (timeSinceLastOutgoingMsg >= ProtocolConstants.KeepAliveTime) {\n            // sufficient time has passed since last message was written,\n            // and no message from our side needed to be sent in the meantime,\n            // so we will send a message containing only a keep alive.\n            var msg = new ProtocolMessage(ProtocolMessageType.KeepAlive, 0, 0, getEmptyBuffer());\n            this._socketWriter.write(msg);\n            this._sendKeepAliveCheck();\n            return;\n        }\n        this._outgoingKeepAliveTimeout = setTimeout(function () {\n            _this._outgoingKeepAliveTimeout = null;\n            _this._sendKeepAliveCheck();\n        }, ProtocolConstants.KeepAliveTime - timeSinceLastOutgoingMsg + 5);\n    };\n    PersistentProtocol.prototype._recvKeepAliveCheck = function () {\n        var _this = this;\n        if (this._incomingKeepAliveTimeout) {\n            // there will be a check in the near future\n            return;\n        }\n        var timeSinceLastIncomingMsg = Date.now() - this._socketReader.lastReadTime;\n        if (timeSinceLastIncomingMsg >= ProtocolConstants.KeepAliveTimeoutTime) {\n            // Trash the socket\n            this._onSocketTimeout.fire(undefined);\n            return;\n        }\n        this._incomingKeepAliveTimeout = setTimeout(function () {\n            _this._incomingKeepAliveTimeout = null;\n            _this._recvKeepAliveCheck();\n        }, ProtocolConstants.KeepAliveTimeoutTime - timeSinceLastIncomingMsg + 5);\n    };\n    PersistentProtocol.prototype.getSocket = function () {\n        return this._socket;\n    };\n    PersistentProtocol.prototype.beginAcceptReconnection = function (socket, initialDataChunk) {\n        var _this = this;\n        this._isReconnecting = true;\n        this._socketDisposables = lifecycle_1.dispose(this._socketDisposables);\n        this._socket = socket;\n        this._socketWriter = new ProtocolWriter(this._socket);\n        this._socketDisposables.push(this._socketWriter);\n        this._socketReader = new ProtocolReader(this._socket);\n        this._socketDisposables.push(this._socketReader);\n        this._socketDisposables.push(this._socketReader.onMessage(function (msg) { return _this._receiveMessage(msg); }));\n        this._socketDisposables.push(this._socket.onClose(function () { return _this._onSocketClose.fire(); }));\n        this._socketDisposables.push(this._socket.onEnd(function () { return _this._onClose.fire(); }));\n        this._socketReader.acceptChunk(initialDataChunk);\n    };\n    PersistentProtocol.prototype.endAcceptReconnection = function () {\n        this._isReconnecting = false;\n        // Send again all unacknowledged messages\n        var toSend = this._outgoingUnackMsg.toArray();\n        for (var i = 0, len = toSend.length; i < len; i++) {\n            this._socketWriter.write(toSend[i]);\n        }\n        this._recvAckCheck();\n        this._sendKeepAliveCheck();\n        this._recvKeepAliveCheck();\n    };\n    PersistentProtocol.prototype._receiveMessage = function (msg) {\n        if (msg.ack > this._outgoingAckId) {\n            this._outgoingAckId = msg.ack;\n            do {\n                var first = this._outgoingUnackMsg.peek();\n                if (first && first.id <= msg.ack) {\n                    // this message has been confirmed, remove it\n                    this._outgoingUnackMsg.pop();\n                }\n                else {\n                    break;\n                }\n            } while (true);\n        }\n        if (msg.type === ProtocolMessageType.Regular) {\n            if (msg.id > this._incomingMsgId) {\n                if (msg.id !== this._incomingMsgId + 1) {\n                    console.error(\"PROTOCOL CORRUPTION, LAST SAW MSG \" + this._incomingMsgId + \" AND HAVE NOW RECEIVED MSG \" + msg.id);\n                }\n                this._incomingMsgId = msg.id;\n                this._incomingMsgLastTime = Date.now();\n                this._sendAckCheck();\n                this._onMessage.fire(msg.data);\n            }\n        }\n        else if (msg.type === ProtocolMessageType.Control) {\n            this._onControlMessage.fire(msg.data);\n        }\n    };\n    PersistentProtocol.prototype.readEntireBuffer = function () {\n        return this._socketReader.readEntireBuffer();\n    };\n    PersistentProtocol.prototype.flush = function () {\n        this._socketWriter.flush();\n    };\n    PersistentProtocol.prototype.send = function (buffer) {\n        var myId = ++this._outgoingMsgId;\n        this._incomingAckId = this._incomingMsgId;\n        var msg = new ProtocolMessage(ProtocolMessageType.Regular, myId, this._incomingAckId, buffer);\n        this._outgoingUnackMsg.push(msg);\n        if (!this._isReconnecting) {\n            this._socketWriter.write(msg);\n            this._recvAckCheck();\n        }\n    };\n    /**\n     * Send a message which will not be part of the regular acknowledge flow.\n     * Use this for early control messages which are repeated in case of reconnection.\n     */\n    PersistentProtocol.prototype.sendControl = function (buffer) {\n        var msg = new ProtocolMessage(ProtocolMessageType.Control, 0, 0, buffer);\n        this._socketWriter.write(msg);\n    };\n    PersistentProtocol.prototype._sendAckCheck = function () {\n        var _this = this;\n        if (this._incomingMsgId <= this._incomingAckId) {\n            // nothink to acknowledge\n            return;\n        }\n        if (this._incomingAckTimeout) {\n            // there will be a check in the near future\n            return;\n        }\n        var timeSinceLastIncomingMsg = Date.now() - this._incomingMsgLastTime;\n        if (timeSinceLastIncomingMsg >= ProtocolConstants.AcknowledgeTime) {\n            // sufficient time has passed since this message has been received,\n            // and no message from our side needed to be sent in the meantime,\n            // so we will send a message containing only an ack.\n            this._sendAck();\n            return;\n        }\n        this._incomingAckTimeout = setTimeout(function () {\n            _this._incomingAckTimeout = null;\n            _this._sendAckCheck();\n        }, ProtocolConstants.AcknowledgeTime - timeSinceLastIncomingMsg + 5);\n    };\n    PersistentProtocol.prototype._recvAckCheck = function () {\n        var _this = this;\n        if (this._outgoingMsgId <= this._outgoingAckId) {\n            // everything has been acknowledged\n            return;\n        }\n        if (this._outgoingAckTimeout) {\n            // there will be a check in the near future\n            return;\n        }\n        var oldestUnacknowledgedMsg = this._outgoingUnackMsg.peek();\n        var timeSinceOldestUnacknowledgedMsg = Date.now() - oldestUnacknowledgedMsg.writtenTime;\n        if (timeSinceOldestUnacknowledgedMsg >= ProtocolConstants.AcknowledgeTimeoutTime) {\n            // Trash the socket\n            this._onSocketTimeout.fire(undefined);\n            return;\n        }\n        this._outgoingAckTimeout = setTimeout(function () {\n            _this._outgoingAckTimeout = null;\n            _this._recvAckCheck();\n        }, ProtocolConstants.AcknowledgeTimeoutTime - timeSinceOldestUnacknowledgedMsg + 5);\n    };\n    PersistentProtocol.prototype._sendAck = function () {\n        if (this._incomingMsgId <= this._incomingAckId) {\n            // nothink to acknowledge\n            return;\n        }\n        this._incomingAckId = this._incomingMsgId;\n        var msg = new ProtocolMessage(ProtocolMessageType.Ack, 0, this._incomingAckId, getEmptyBuffer());\n        this._socketWriter.write(msg);\n    };\n    return PersistentProtocol;\n}());\nexports.PersistentProtocol = PersistentProtocol;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/common/ipc.net.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/common/ipc.net.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { IMessagePassingProtocol, IPCClient } from 'vs/base/parts/ipc/common/ipc';\nimport { IDisposable, Disposable, dispose } from 'vs/base/common/lifecycle';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport * as platform from 'vs/base/common/platform';\n\ndeclare var process: any;\n\nexport interface ISocket {\n\tonData(listener: (e: VSBuffer) => void): IDisposable;\n\tonClose(listener: () => void): IDisposable;\n\tonEnd(listener: () => void): IDisposable;\n\twrite(buffer: VSBuffer): void;\n\tend(): void;\n}\n\nlet emptyBuffer: VSBuffer | null = null;\nfunction getEmptyBuffer(): VSBuffer {\n\tif (!emptyBuffer) {\n\t\temptyBuffer = VSBuffer.alloc(0);\n\t}\n\treturn emptyBuffer;\n}\n\nclass ChunkStream {\n\n\tprivate _chunks: VSBuffer[];\n\tprivate _totalLength: number;\n\n\tpublic get byteLength() {\n\t\treturn this._totalLength;\n\t}\n\n\tconstructor() {\n\t\tthis._chunks = [];\n\t\tthis._totalLength = 0;\n\t}\n\n\tpublic acceptChunk(buff: VSBuffer) {\n\t\tthis._chunks.push(buff);\n\t\tthis._totalLength += buff.byteLength;\n\t}\n\n\tpublic read(byteCount: number): VSBuffer {\n\t\tif (byteCount === 0) {\n\t\t\treturn getEmptyBuffer();\n\t\t}\n\n\t\tif (byteCount > this._totalLength) {\n\t\t\tthrow new Error(`Cannot read so many bytes!`);\n\t\t}\n\n\t\tif (this._chunks[0].byteLength === byteCount) {\n\t\t\t// super fast path, precisely first chunk must be returned\n\t\t\tconst result = this._chunks.shift()!;\n\t\t\tthis._totalLength -= byteCount;\n\t\t\treturn result;\n\t\t}\n\n\t\tif (this._chunks[0].byteLength > byteCount) {\n\t\t\t// fast path, the reading is entirely within the first chunk\n\t\t\tconst result = this._chunks[0].slice(0, byteCount);\n\t\t\tthis._chunks[0] = this._chunks[0].slice(byteCount);\n\t\t\tthis._totalLength -= byteCount;\n\t\t\treturn result;\n\t\t}\n\n\t\tlet result = VSBuffer.alloc(byteCount);\n\t\tlet resultOffset = 0;\n\t\twhile (byteCount > 0) {\n\t\t\tconst chunk = this._chunks[0];\n\t\t\tif (chunk.byteLength > byteCount) {\n\t\t\t\t// this chunk will survive\n\t\t\t\tthis._chunks[0] = chunk.slice(byteCount);\n\n\t\t\t\tconst chunkPart = chunk.slice(0, byteCount);\n\t\t\t\tresult.set(chunkPart, resultOffset);\n\t\t\t\tresultOffset += byteCount;\n\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t\tbyteCount -= byteCount;\n\t\t\t} else {\n\t\t\t\t// this chunk will be entirely read\n\t\t\t\tthis._chunks.shift();\n\n\t\t\t\tresult.set(chunk, resultOffset);\n\t\t\t\tresultOffset += chunk.byteLength;\n\t\t\t\tthis._totalLength -= chunk.byteLength;\n\t\t\t\tbyteCount -= chunk.byteLength;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nconst enum ProtocolMessageType {\n\tNone = 0,\n\tRegular = 1,\n\tControl = 2,\n\tAck = 3,\n\tKeepAlive = 4\n}\n\nexport const enum ProtocolConstants {\n\tHeaderLength = 13,\n\t/**\n\t * Send an Acknowledge message at most 2 seconds later...\n\t */\n\tAcknowledgeTime = 2000, // 2 seconds\n\t/**\n\t * If there is a message that has been unacknowledged for 10 seconds, consider the connection closed...\n\t */\n\tAcknowledgeTimeoutTime = 10000, // 10 seconds\n\t/**\n\t * Send at least a message every 30s for keep alive reasons.\n\t */\n\tKeepAliveTime = 30000, // 30 seconds\n\t/**\n\t * If there is no message received for 60 seconds, consider the connection closed...\n\t */\n\tKeepAliveTimeoutTime = 60000, // 60 seconds\n\t/**\n\t * If there is no reconnection within this time-frame, consider the connection permanently closed...\n\t */\n\tReconnectionGraceTime = 60 * 60 * 1000, // 1hr\n}\n\nclass ProtocolMessage {\n\n\tpublic writtenTime: number;\n\n\tconstructor(\n\t\tpublic readonly type: ProtocolMessageType,\n\t\tpublic readonly id: number,\n\t\tpublic readonly ack: number,\n\t\tpublic readonly data: VSBuffer\n\t) {\n\t\tthis.writtenTime = 0;\n\t}\n\n\tpublic get size(): number {\n\t\treturn this.data.byteLength;\n\t}\n}\n\nclass ProtocolReader extends Disposable {\n\n\tprivate readonly _socket: ISocket;\n\tprivate _isDisposed: boolean;\n\tprivate readonly _incomingData: ChunkStream;\n\tpublic lastReadTime: number;\n\n\tprivate readonly _onMessage = new Emitter<ProtocolMessage>();\n\tpublic readonly onMessage: Event<ProtocolMessage> = this._onMessage.event;\n\n\tprivate readonly _state = {\n\t\treadHead: true,\n\t\treadLen: ProtocolConstants.HeaderLength,\n\t\tmessageType: ProtocolMessageType.None,\n\t\tid: 0,\n\t\tack: 0\n\t};\n\n\tconstructor(socket: ISocket) {\n\t\tsuper();\n\t\tthis._socket = socket;\n\t\tthis._isDisposed = false;\n\t\tthis._incomingData = new ChunkStream();\n\t\tthis._register(this._socket.onData(data => this.acceptChunk(data)));\n\t\tthis.lastReadTime = Date.now();\n\t}\n\n\tpublic acceptChunk(data: VSBuffer | null): void {\n\t\tif (!data || data.byteLength === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.lastReadTime = Date.now();\n\n\t\tthis._incomingData.acceptChunk(data);\n\n\t\twhile (this._incomingData.byteLength >= this._state.readLen) {\n\n\t\t\tconst buff = this._incomingData.read(this._state.readLen);\n\n\t\t\tif (this._state.readHead) {\n\t\t\t\t// buff is the header\n\n\t\t\t\t// save new state => next time will read the body\n\t\t\t\tthis._state.readHead = false;\n\t\t\t\tthis._state.readLen = buff.readUint32BE(9);\n\t\t\t\tthis._state.messageType = <ProtocolMessageType>buff.readUint8(0);\n\t\t\t\tthis._state.id = buff.readUint32BE(1);\n\t\t\t\tthis._state.ack = buff.readUint32BE(5);\n\t\t\t} else {\n\t\t\t\t// buff is the body\n\t\t\t\tconst messageType = this._state.messageType;\n\t\t\t\tconst id = this._state.id;\n\t\t\t\tconst ack = this._state.ack;\n\n\t\t\t\t// save new state => next time will read the header\n\t\t\t\tthis._state.readHead = true;\n\t\t\t\tthis._state.readLen = ProtocolConstants.HeaderLength;\n\t\t\t\tthis._state.messageType = ProtocolMessageType.None;\n\t\t\t\tthis._state.id = 0;\n\t\t\t\tthis._state.ack = 0;\n\n\t\t\t\tthis._onMessage.fire(new ProtocolMessage(messageType, id, ack, buff));\n\n\t\t\t\tif (this._isDisposed) {\n\t\t\t\t\t// check if an event listener lead to our disposal\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic readEntireBuffer(): VSBuffer {\n\t\treturn this._incomingData.read(this._incomingData.byteLength);\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._isDisposed = true;\n\t\tsuper.dispose();\n\t}\n}\n\nclass ProtocolWriter {\n\n\tprivate _isDisposed: boolean;\n\tprivate readonly _socket: ISocket;\n\tprivate _data: VSBuffer[];\n\tprivate _totalLength: number;\n\tpublic lastWriteTime: number;\n\n\tconstructor(socket: ISocket) {\n\t\tthis._isDisposed = false;\n\t\tthis._socket = socket;\n\t\tthis._data = [];\n\t\tthis._totalLength = 0;\n\t\tthis.lastWriteTime = 0;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.flush();\n\t\tthis._isDisposed = true;\n\t}\n\n\tpublic flush(): void {\n\t\t// flush\n\t\tthis._writeNow();\n\t}\n\n\tpublic write(msg: ProtocolMessage) {\n\t\tif (this._isDisposed) {\n\t\t\tconsole.warn(`Cannot write message in a disposed ProtocolWriter`);\n\t\t\tconsole.warn(msg);\n\t\t\treturn;\n\t\t}\n\t\tmsg.writtenTime = Date.now();\n\t\tthis.lastWriteTime = Date.now();\n\t\tconst header = VSBuffer.alloc(ProtocolConstants.HeaderLength);\n\t\theader.writeUint8(msg.type, 0);\n\t\theader.writeUint32BE(msg.id, 1);\n\t\theader.writeUint32BE(msg.ack, 5);\n\t\theader.writeUint32BE(msg.data.byteLength, 9);\n\t\tthis._writeSoon(header, msg.data);\n\t}\n\n\tprivate _bufferAdd(head: VSBuffer, body: VSBuffer): boolean {\n\t\tconst wasEmpty = this._totalLength === 0;\n\t\tthis._data.push(head, body);\n\t\tthis._totalLength += head.byteLength + body.byteLength;\n\t\treturn wasEmpty;\n\t}\n\n\tprivate _bufferTake(): VSBuffer {\n\t\tconst ret = VSBuffer.concat(this._data, this._totalLength);\n\t\tthis._data.length = 0;\n\t\tthis._totalLength = 0;\n\t\treturn ret;\n\t}\n\n\tprivate _writeSoon(header: VSBuffer, data: VSBuffer): void {\n\t\tif (this._bufferAdd(header, data)) {\n\t\t\tplatform.setImmediate(() => {\n\t\t\t\tthis._writeNow();\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate _writeNow(): void {\n\t\tif (this._totalLength === 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis._socket.write(this._bufferTake());\n\t}\n}\n\n/**\n * A message has the following format:\n * ```\n *     /-------------------------------|------\\\n *     |             HEADER            |      |\n *     |-------------------------------| DATA |\n *     | TYPE | ID | ACK | DATA_LENGTH |      |\n *     \\-------------------------------|------/\n * ```\n * The header is 9 bytes and consists of:\n *  - TYPE is 1 byte (ProtocolMessageType) - the message type\n *  - ID is 4 bytes (u32be) - the message id (can be 0 to indicate to be ignored)\n *  - ACK is 4 bytes (u32be) - the acknowledged message id (can be 0 to indicate to be ignored)\n *  - DATA_LENGTH is 4 bytes (u32be) - the length in bytes of DATA\n *\n * Only Regular messages are counted, other messages are not counted, nor acknowledged.\n */\nexport class Protocol extends Disposable implements IMessagePassingProtocol {\n\n\tprivate _socket: ISocket;\n\tprivate _socketWriter: ProtocolWriter;\n\tprivate _socketReader: ProtocolReader;\n\n\tprivate _onMessage = new Emitter<VSBuffer>();\n\treadonly onMessage: Event<VSBuffer> = this._onMessage.event;\n\n\tprivate _onClose = new Emitter<void>();\n\treadonly onClose: Event<void> = this._onClose.event;\n\n\tconstructor(socket: ISocket) {\n\t\tsuper();\n\t\tthis._socket = socket;\n\t\tthis._socketWriter = this._register(new ProtocolWriter(this._socket));\n\t\tthis._socketReader = this._register(new ProtocolReader(this._socket));\n\n\t\tthis._register(this._socketReader.onMessage((msg) => {\n\t\t\tif (msg.type === ProtocolMessageType.Regular) {\n\t\t\t\tthis._onMessage.fire(msg.data);\n\t\t\t}\n\t\t}));\n\n\t\tthis._register(this._socket.onClose(() => this._onClose.fire()));\n\t}\n\n\tgetSocket(): ISocket {\n\t\treturn this._socket;\n\t}\n\n\tsend(buffer: VSBuffer): void {\n\t\tthis._socketWriter.write(new ProtocolMessage(ProtocolMessageType.Regular, 0, 0, buffer));\n\t}\n}\n\nexport class Client<TContext = string> extends IPCClient<TContext> {\n\n\tstatic fromSocket<TContext = string>(socket: ISocket, id: TContext): Client<TContext> {\n\t\treturn new Client(new Protocol(socket), id);\n\t}\n\n\tget onClose(): Event<void> { return this.protocol.onClose; }\n\n\tconstructor(private protocol: Protocol | PersistentProtocol, id: TContext) {\n\t\tsuper(protocol, id);\n\t}\n\n\tdispose(): void {\n\t\tsuper.dispose();\n\t\tconst socket = this.protocol.getSocket();\n\t\tthis.protocol.dispose();\n\t\tsocket.end();\n\t}\n}\n\n/**\n * Will ensure no messages are lost if there are no event listeners.\n */\nfunction createBufferedEvent<T>(source: Event<T>): Event<T> {\n\tlet emitter: Emitter<T>;\n\tlet hasListeners = false;\n\tlet isDeliveringMessages = false;\n\tlet bufferedMessages: T[] = [];\n\n\tconst deliverMessages = () => {\n\t\tif (isDeliveringMessages) {\n\t\t\treturn;\n\t\t}\n\t\tisDeliveringMessages = true;\n\t\twhile (hasListeners && bufferedMessages.length > 0) {\n\t\t\temitter.fire(bufferedMessages.shift()!);\n\t\t}\n\t\tisDeliveringMessages = false;\n\t};\n\n\tsource((e: T) => {\n\t\tbufferedMessages.push(e);\n\t\tdeliverMessages();\n\t});\n\n\temitter = new Emitter<T>({\n\t\tonFirstListenerAdd: () => {\n\t\t\thasListeners = true;\n\t\t\t// it is important to deliver these messages after this call, but before\n\t\t\t// other messages have a chance to be received (to guarantee in order delivery)\n\t\t\t// that's why we're using here nextTick and not other types of timeouts\n\t\t\tif (typeof process !== 'undefined') {\n\t\t\t\tprocess.nextTick(deliverMessages);\n\t\t\t} else {\n\t\t\t\tplatform.setImmediate(deliverMessages);\n\t\t\t}\n\t\t},\n\t\tonLastListenerRemove: () => {\n\t\t\thasListeners = false;\n\t\t}\n\t});\n\n\treturn emitter.event;\n}\n\nclass QueueElement<T> {\n\tpublic readonly data: T;\n\tpublic next: QueueElement<T> | null;\n\n\tconstructor(data: T) {\n\t\tthis.data = data;\n\t\tthis.next = null;\n\t}\n}\n\nclass Queue<T> {\n\n\tprivate _first: QueueElement<T> | null;\n\tprivate _last: QueueElement<T> | null;\n\n\tconstructor() {\n\t\tthis._first = null;\n\t\tthis._last = null;\n\t}\n\n\tpublic peek(): T | null {\n\t\tif (!this._first) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._first.data;\n\t}\n\n\tpublic toArray(): T[] {\n\t\tlet result: T[] = [], resultLen = 0;\n\t\tlet it = this._first;\n\t\twhile (it) {\n\t\t\tresult[resultLen++] = it.data;\n\t\t\tit = it.next;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic pop(): void {\n\t\tif (!this._first) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._first === this._last) {\n\t\t\tthis._first = null;\n\t\t\tthis._last = null;\n\t\t\treturn;\n\t\t}\n\t\tthis._first = this._first.next;\n\t}\n\n\tpublic push(item: T): void {\n\t\tconst element = new QueueElement(item);\n\t\tif (!this._first) {\n\t\t\tthis._first = element;\n\t\t\tthis._last = element;\n\t\t\treturn;\n\t\t}\n\t\tthis._last!.next = element;\n\t\tthis._last = element;\n\t}\n}\n\n/**\n * Same as Protocol, but will actually track messages and acks.\n * Moreover, it will ensure no messages are lost if there are no event listeners.\n */\nexport class PersistentProtocol {\n\n\tprivate _isReconnecting: boolean;\n\n\tprivate _outgoingUnackMsg: Queue<ProtocolMessage>;\n\tprivate _outgoingMsgId: number;\n\tprivate _outgoingAckId: number;\n\tprivate _outgoingAckTimeout: any | null;\n\n\tprivate _incomingMsgId: number;\n\tprivate _incomingAckId: number;\n\tprivate _incomingMsgLastTime: number;\n\tprivate _incomingAckTimeout: any | null;\n\n\tprivate _outgoingKeepAliveTimeout: any | null;\n\tprivate _incomingKeepAliveTimeout: any | null;\n\n\tprivate _socket: ISocket;\n\tprivate _socketWriter: ProtocolWriter;\n\tprivate _socketReader: ProtocolReader;\n\tprivate _socketDisposables: IDisposable[];\n\n\tprivate _onControlMessage = new Emitter<VSBuffer>();\n\treadonly onControlMessage: Event<VSBuffer> = createBufferedEvent(this._onControlMessage.event);\n\n\tprivate _onMessage = new Emitter<VSBuffer>();\n\treadonly onMessage: Event<VSBuffer> = createBufferedEvent(this._onMessage.event);\n\n\tprivate _onClose = new Emitter<void>();\n\treadonly onClose: Event<void> = createBufferedEvent(this._onClose.event);\n\n\tprivate _onSocketClose = new Emitter<void>();\n\treadonly onSocketClose: Event<void> = createBufferedEvent(this._onSocketClose.event);\n\n\tprivate _onSocketTimeout = new Emitter<void>();\n\treadonly onSocketTimeout: Event<void> = createBufferedEvent(this._onSocketTimeout.event);\n\n\tpublic get unacknowledgedCount(): number {\n\t\treturn this._outgoingMsgId - this._outgoingAckId;\n\t}\n\n\tconstructor(socket: ISocket, initialChunk: VSBuffer | null = null) {\n\t\tthis._isReconnecting = false;\n\t\tthis._outgoingUnackMsg = new Queue<ProtocolMessage>();\n\t\tthis._outgoingMsgId = 0;\n\t\tthis._outgoingAckId = 0;\n\t\tthis._outgoingAckTimeout = null;\n\n\t\tthis._incomingMsgId = 0;\n\t\tthis._incomingAckId = 0;\n\t\tthis._incomingMsgLastTime = 0;\n\t\tthis._incomingAckTimeout = null;\n\n\t\tthis._outgoingKeepAliveTimeout = null;\n\t\tthis._incomingKeepAliveTimeout = null;\n\n\t\tthis._socketDisposables = [];\n\t\tthis._socket = socket;\n\t\tthis._socketWriter = new ProtocolWriter(this._socket);\n\t\tthis._socketDisposables.push(this._socketWriter);\n\t\tthis._socketReader = new ProtocolReader(this._socket);\n\t\tthis._socketDisposables.push(this._socketReader);\n\t\tthis._socketDisposables.push(this._socketReader.onMessage(msg => this._receiveMessage(msg)));\n\t\tthis._socketDisposables.push(this._socket.onClose(() => this._onSocketClose.fire()));\n\t\tthis._socketDisposables.push(this._socket.onEnd(() => this._onClose.fire()));\n\t\tif (initialChunk) {\n\t\t\tthis._socketReader.acceptChunk(initialChunk);\n\t\t}\n\n\t\tthis._sendKeepAliveCheck();\n\t\tthis._recvKeepAliveCheck();\n\t}\n\n\tdispose(): void {\n\t\tif (this._outgoingAckTimeout) {\n\t\t\tclearTimeout(this._outgoingAckTimeout);\n\t\t\tthis._outgoingAckTimeout = null;\n\t\t}\n\t\tif (this._incomingAckTimeout) {\n\t\t\tclearTimeout(this._incomingAckTimeout);\n\t\t\tthis._incomingAckTimeout = null;\n\t\t}\n\t\tif (this._outgoingKeepAliveTimeout) {\n\t\t\tclearTimeout(this._outgoingKeepAliveTimeout);\n\t\t\tthis._outgoingKeepAliveTimeout = null;\n\t\t}\n\t\tif (this._incomingKeepAliveTimeout) {\n\t\t\tclearTimeout(this._incomingKeepAliveTimeout);\n\t\t\tthis._incomingKeepAliveTimeout = null;\n\t\t}\n\t\tthis._socketDisposables = dispose(this._socketDisposables);\n\t}\n\n\tprivate _sendKeepAliveCheck(): void {\n\t\tif (this._outgoingKeepAliveTimeout) {\n\t\t\t// there will be a check in the near future\n\t\t\treturn;\n\t\t}\n\n\t\tconst timeSinceLastOutgoingMsg = Date.now() - this._socketWriter.lastWriteTime;\n\t\tif (timeSinceLastOutgoingMsg >= ProtocolConstants.KeepAliveTime) {\n\t\t\t// sufficient time has passed since last message was written,\n\t\t\t// and no message from our side needed to be sent in the meantime,\n\t\t\t// so we will send a message containing only a keep alive.\n\t\t\tconst msg = new ProtocolMessage(ProtocolMessageType.KeepAlive, 0, 0, getEmptyBuffer());\n\t\t\tthis._socketWriter.write(msg);\n\t\t\tthis._sendKeepAliveCheck();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._outgoingKeepAliveTimeout = setTimeout(() => {\n\t\t\tthis._outgoingKeepAliveTimeout = null;\n\t\t\tthis._sendKeepAliveCheck();\n\t\t}, ProtocolConstants.KeepAliveTime - timeSinceLastOutgoingMsg + 5);\n\t}\n\n\tprivate _recvKeepAliveCheck(): void {\n\t\tif (this._incomingKeepAliveTimeout) {\n\t\t\t// there will be a check in the near future\n\t\t\treturn;\n\t\t}\n\n\t\tconst timeSinceLastIncomingMsg = Date.now() - this._socketReader.lastReadTime;\n\t\tif (timeSinceLastIncomingMsg >= ProtocolConstants.KeepAliveTimeoutTime) {\n\t\t\t// Trash the socket\n\t\t\tthis._onSocketTimeout.fire(undefined);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingKeepAliveTimeout = setTimeout(() => {\n\t\t\tthis._incomingKeepAliveTimeout = null;\n\t\t\tthis._recvKeepAliveCheck();\n\t\t}, ProtocolConstants.KeepAliveTimeoutTime - timeSinceLastIncomingMsg + 5);\n\t}\n\n\tpublic getSocket(): ISocket {\n\t\treturn this._socket;\n\t}\n\n\tpublic beginAcceptReconnection(socket: ISocket, initialDataChunk: VSBuffer | null): void {\n\t\tthis._isReconnecting = true;\n\n\t\tthis._socketDisposables = dispose(this._socketDisposables);\n\n\t\tthis._socket = socket;\n\t\tthis._socketWriter = new ProtocolWriter(this._socket);\n\t\tthis._socketDisposables.push(this._socketWriter);\n\t\tthis._socketReader = new ProtocolReader(this._socket);\n\t\tthis._socketDisposables.push(this._socketReader);\n\t\tthis._socketDisposables.push(this._socketReader.onMessage(msg => this._receiveMessage(msg)));\n\t\tthis._socketDisposables.push(this._socket.onClose(() => this._onSocketClose.fire()));\n\t\tthis._socketDisposables.push(this._socket.onEnd(() => this._onClose.fire()));\n\t\tthis._socketReader.acceptChunk(initialDataChunk);\n\t}\n\n\tpublic endAcceptReconnection(): void {\n\t\tthis._isReconnecting = false;\n\n\t\t// Send again all unacknowledged messages\n\t\tconst toSend = this._outgoingUnackMsg.toArray();\n\t\tfor (let i = 0, len = toSend.length; i < len; i++) {\n\t\t\tthis._socketWriter.write(toSend[i]);\n\t\t}\n\t\tthis._recvAckCheck();\n\n\t\tthis._sendKeepAliveCheck();\n\t\tthis._recvKeepAliveCheck();\n\t}\n\n\tprivate _receiveMessage(msg: ProtocolMessage): void {\n\t\tif (msg.ack > this._outgoingAckId) {\n\t\t\tthis._outgoingAckId = msg.ack;\n\t\t\tdo {\n\t\t\t\tconst first = this._outgoingUnackMsg.peek();\n\t\t\t\tif (first && first.id <= msg.ack) {\n\t\t\t\t\t// this message has been confirmed, remove it\n\t\t\t\t\tthis._outgoingUnackMsg.pop();\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (true);\n\t\t}\n\n\t\tif (msg.type === ProtocolMessageType.Regular) {\n\t\t\tif (msg.id > this._incomingMsgId) {\n\t\t\t\tif (msg.id !== this._incomingMsgId + 1) {\n\t\t\t\t\tconsole.error(`PROTOCOL CORRUPTION, LAST SAW MSG ${this._incomingMsgId} AND HAVE NOW RECEIVED MSG ${msg.id}`);\n\t\t\t\t}\n\t\t\t\tthis._incomingMsgId = msg.id;\n\t\t\t\tthis._incomingMsgLastTime = Date.now();\n\t\t\t\tthis._sendAckCheck();\n\t\t\t\tthis._onMessage.fire(msg.data);\n\t\t\t}\n\t\t} else if (msg.type === ProtocolMessageType.Control) {\n\t\t\tthis._onControlMessage.fire(msg.data);\n\t\t}\n\t}\n\n\treadEntireBuffer(): VSBuffer {\n\t\treturn this._socketReader.readEntireBuffer();\n\t}\n\n\tflush(): void {\n\t\tthis._socketWriter.flush();\n\t}\n\n\tsend(buffer: VSBuffer): void {\n\t\tconst myId = ++this._outgoingMsgId;\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Regular, myId, this._incomingAckId, buffer);\n\t\tthis._outgoingUnackMsg.push(msg);\n\t\tif (!this._isReconnecting) {\n\t\t\tthis._socketWriter.write(msg);\n\t\t\tthis._recvAckCheck();\n\t\t}\n\t}\n\n\t/**\n\t * Send a message which will not be part of the regular acknowledge flow.\n\t * Use this for early control messages which are repeated in case of reconnection.\n\t */\n\tsendControl(buffer: VSBuffer): void {\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Control, 0, 0, buffer);\n\t\tthis._socketWriter.write(msg);\n\t}\n\n\tprivate _sendAckCheck(): void {\n\t\tif (this._incomingMsgId <= this._incomingAckId) {\n\t\t\t// nothink to acknowledge\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._incomingAckTimeout) {\n\t\t\t// there will be a check in the near future\n\t\t\treturn;\n\t\t}\n\n\t\tconst timeSinceLastIncomingMsg = Date.now() - this._incomingMsgLastTime;\n\t\tif (timeSinceLastIncomingMsg >= ProtocolConstants.AcknowledgeTime) {\n\t\t\t// sufficient time has passed since this message has been received,\n\t\t\t// and no message from our side needed to be sent in the meantime,\n\t\t\t// so we will send a message containing only an ack.\n\t\t\tthis._sendAck();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingAckTimeout = setTimeout(() => {\n\t\t\tthis._incomingAckTimeout = null;\n\t\t\tthis._sendAckCheck();\n\t\t}, ProtocolConstants.AcknowledgeTime - timeSinceLastIncomingMsg + 5);\n\t}\n\n\tprivate _recvAckCheck(): void {\n\t\tif (this._outgoingMsgId <= this._outgoingAckId) {\n\t\t\t// everything has been acknowledged\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._outgoingAckTimeout) {\n\t\t\t// there will be a check in the near future\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldestUnacknowledgedMsg = this._outgoingUnackMsg.peek()!;\n\t\tconst timeSinceOldestUnacknowledgedMsg = Date.now() - oldestUnacknowledgedMsg.writtenTime;\n\t\tif (timeSinceOldestUnacknowledgedMsg >= ProtocolConstants.AcknowledgeTimeoutTime) {\n\t\t\t// Trash the socket\n\t\t\tthis._onSocketTimeout.fire(undefined);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._outgoingAckTimeout = setTimeout(() => {\n\t\t\tthis._outgoingAckTimeout = null;\n\t\t\tthis._recvAckCheck();\n\t\t}, ProtocolConstants.AcknowledgeTimeoutTime - timeSinceOldestUnacknowledgedMsg + 5);\n\t}\n\n\tprivate _sendAck(): void {\n\t\tif (this._incomingMsgId <= this._incomingAckId) {\n\t\t\t// nothink to acknowledge\n\t\t\treturn;\n\t\t}\n\n\t\tthis._incomingAckId = this._incomingMsgId;\n\t\tconst msg = new ProtocolMessage(ProtocolMessageType.Ack, 0, this._incomingAckId, getEmptyBuffer());\n\t\tthis._socketWriter.write(msg);\n\t}\n}\n"]}]}