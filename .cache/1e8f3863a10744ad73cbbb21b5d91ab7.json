{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/node/extensionDescriptionRegistry.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/node/extensionDescriptionRegistry.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/platform/extensions/common/extensions\", \"vs/base/common/event\"], function (require, exports, extensions_1, event_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class DeltaExtensionsResult {\n        constructor(removedDueToLooping) {\n            this.removedDueToLooping = removedDueToLooping;\n        }\n    }\n    exports.DeltaExtensionsResult = DeltaExtensionsResult;\n    class ExtensionDescriptionRegistry {\n        constructor(extensionDescriptions) {\n            this._onDidChange = new event_1.Emitter();\n            this.onDidChange = this._onDidChange.event;\n            this._extensionDescriptions = extensionDescriptions;\n            this._initialize();\n        }\n        _initialize() {\n            this._extensionsMap = new Map();\n            this._extensionsArr = [];\n            this._activationMap = new Map();\n            for (const extensionDescription of this._extensionDescriptions) {\n                if (this._extensionsMap.has(extensions_1.ExtensionIdentifier.toKey(extensionDescription.identifier))) {\n                    // No overwriting allowed!\n                    console.error('Extension `' + extensionDescription.identifier.value + '` is already registered');\n                    continue;\n                }\n                this._extensionsMap.set(extensions_1.ExtensionIdentifier.toKey(extensionDescription.identifier), extensionDescription);\n                this._extensionsArr.push(extensionDescription);\n                if (Array.isArray(extensionDescription.activationEvents)) {\n                    for (let activationEvent of extensionDescription.activationEvents) {\n                        // TODO@joao: there's no easy way to contribute this\n                        if (activationEvent === 'onUri') {\n                            activationEvent = `onUri:${extensions_1.ExtensionIdentifier.toKey(extensionDescription.identifier)}`;\n                        }\n                        if (!this._activationMap.has(activationEvent)) {\n                            this._activationMap.set(activationEvent, []);\n                        }\n                        this._activationMap.get(activationEvent).push(extensionDescription);\n                    }\n                }\n            }\n        }\n        keepOnly(extensionIds) {\n            const toKeep = new Set();\n            extensionIds.forEach(extensionId => toKeep.add(extensions_1.ExtensionIdentifier.toKey(extensionId)));\n            this._extensionDescriptions = this._extensionDescriptions.filter(extension => toKeep.has(extensions_1.ExtensionIdentifier.toKey(extension.identifier)));\n            this._initialize();\n            this._onDidChange.fire(undefined);\n        }\n        deltaExtensions(toAdd, toRemove) {\n            if (toAdd.length > 0) {\n                this._extensionDescriptions = this._extensionDescriptions.concat(toAdd);\n            }\n            // Immediately remove looping extensions!\n            const looping = ExtensionDescriptionRegistry._findLoopingExtensions(this._extensionDescriptions);\n            toRemove = toRemove.concat(looping.map(ext => ext.identifier));\n            if (toRemove.length > 0) {\n                const toRemoveSet = new Set();\n                toRemove.forEach(extensionId => toRemoveSet.add(extensions_1.ExtensionIdentifier.toKey(extensionId)));\n                this._extensionDescriptions = this._extensionDescriptions.filter(extension => !toRemoveSet.has(extensions_1.ExtensionIdentifier.toKey(extension.identifier)));\n            }\n            this._initialize();\n            this._onDidChange.fire(undefined);\n            return new DeltaExtensionsResult(looping);\n        }\n        static _findLoopingExtensions(extensionDescriptions) {\n            const G = new class {\n                constructor() {\n                    this._arcs = new Map();\n                    this._nodesSet = new Set();\n                    this._nodesArr = [];\n                }\n                addNode(id) {\n                    if (!this._nodesSet.has(id)) {\n                        this._nodesSet.add(id);\n                        this._nodesArr.push(id);\n                    }\n                }\n                addArc(from, to) {\n                    this.addNode(from);\n                    this.addNode(to);\n                    if (this._arcs.has(from)) {\n                        this._arcs.get(from).push(to);\n                    }\n                    else {\n                        this._arcs.set(from, [to]);\n                    }\n                }\n                getArcs(id) {\n                    if (this._arcs.has(id)) {\n                        return this._arcs.get(id);\n                    }\n                    return [];\n                }\n                hasOnlyGoodArcs(id, good) {\n                    const dependencies = G.getArcs(id);\n                    for (let i = 0; i < dependencies.length; i++) {\n                        if (!good.has(dependencies[i])) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                getNodes() {\n                    return this._nodesArr;\n                }\n            };\n            let descs = new Map();\n            for (let extensionDescription of extensionDescriptions) {\n                const extensionId = extensions_1.ExtensionIdentifier.toKey(extensionDescription.identifier);\n                descs.set(extensionId, extensionDescription);\n                if (extensionDescription.extensionDependencies) {\n                    for (let _depId of extensionDescription.extensionDependencies) {\n                        const depId = extensions_1.ExtensionIdentifier.toKey(_depId);\n                        G.addArc(extensionId, depId);\n                    }\n                }\n            }\n            // initialize with all extensions with no dependencies.\n            let good = new Set();\n            G.getNodes().filter(id => G.getArcs(id).length === 0).forEach(id => good.add(id));\n            // all other extensions will be processed below.\n            let nodes = G.getNodes().filter(id => !good.has(id));\n            let madeProgress;\n            do {\n                madeProgress = false;\n                // find one extension which has only good deps\n                for (let i = 0; i < nodes.length; i++) {\n                    const id = nodes[i];\n                    if (G.hasOnlyGoodArcs(id, good)) {\n                        nodes.splice(i, 1);\n                        i--;\n                        good.add(id);\n                        madeProgress = true;\n                    }\n                }\n            } while (madeProgress);\n            // The remaining nodes are bad and have loops\n            return nodes.map(id => descs.get(id));\n        }\n        containsActivationEvent(activationEvent) {\n            return this._activationMap.has(activationEvent);\n        }\n        containsExtension(extensionId) {\n            return this._extensionsMap.has(extensions_1.ExtensionIdentifier.toKey(extensionId));\n        }\n        getExtensionDescriptionsForActivationEvent(activationEvent) {\n            const extensions = this._activationMap.get(activationEvent);\n            return extensions ? extensions.slice(0) : [];\n        }\n        getAllExtensionDescriptions() {\n            return this._extensionsArr.slice(0);\n        }\n        getExtensionDescription(extensionId) {\n            const extension = this._extensionsMap.get(extensions_1.ExtensionIdentifier.toKey(extensionId));\n            return extension ? extension : undefined;\n        }\n    }\n    exports.ExtensionDescriptionRegistry = ExtensionDescriptionRegistry;\n});\n",null]}