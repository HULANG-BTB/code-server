{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/suggest/completionModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/suggest/completionModel.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar filters_1 = require(\"vs/base/common/filters\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar modes_1 = require(\"vs/editor/common/modes\");\nvar editorOptions_1 = require(\"vs/editor/common/config/editorOptions\");\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar LineContext = /** @class */ (function () {\n    function LineContext() {\n    }\n    return LineContext;\n}());\nexports.LineContext = LineContext;\nvar Refilter;\n(function (Refilter) {\n    Refilter[Refilter[\"Nothing\"] = 0] = \"Nothing\";\n    Refilter[Refilter[\"All\"] = 1] = \"All\";\n    Refilter[Refilter[\"Incr\"] = 2] = \"Incr\";\n})(Refilter || (Refilter = {}));\nvar CompletionModel = /** @class */ (function () {\n    function CompletionModel(items, column, lineContext, wordDistance, options) {\n        if (options === void 0) { options = editorOptions_1.EDITOR_DEFAULTS.contribInfo.suggest; }\n        this._snippetCompareFn = CompletionModel._compareCompletionItems;\n        this._items = items;\n        this._column = column;\n        this._wordDistance = wordDistance;\n        this._options = options;\n        this._refilterKind = Refilter.All;\n        this._lineContext = lineContext;\n        if (options.snippets === 'top') {\n            this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsUp;\n        }\n        else if (options.snippets === 'bottom') {\n            this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsDown;\n        }\n    }\n    CompletionModel.prototype.dispose = function () {\n        var seen = new Set();\n        for (var _i = 0, _a = this._items; _i < _a.length; _i++) {\n            var container = _a[_i].container;\n            if (!seen.has(container)) {\n                seen.add(container);\n                if (lifecycle_1.isDisposable(container)) {\n                    container.dispose();\n                }\n            }\n        }\n    };\n    Object.defineProperty(CompletionModel.prototype, \"lineContext\", {\n        get: function () {\n            return this._lineContext;\n        },\n        set: function (value) {\n            if (this._lineContext.leadingLineContent !== value.leadingLineContent\n                || this._lineContext.characterCountDelta !== value.characterCountDelta) {\n                this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? Refilter.Incr : Refilter.All;\n                this._lineContext = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompletionModel.prototype, \"items\", {\n        get: function () {\n            this._ensureCachedState();\n            return this._filteredItems;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompletionModel.prototype, \"incomplete\", {\n        get: function () {\n            this._ensureCachedState();\n            return this._isIncomplete;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CompletionModel.prototype.adopt = function (except) {\n        var res = new Array();\n        for (var i = 0; i < this._items.length;) {\n            if (!except.has(this._items[i].provider)) {\n                res.push(this._items[i]);\n                // unordered removed\n                this._items[i] = this._items[this._items.length - 1];\n                this._items.pop();\n            }\n            else {\n                // continue with next item\n                i++;\n            }\n        }\n        this._refilterKind = Refilter.All;\n        return res;\n    };\n    Object.defineProperty(CompletionModel.prototype, \"stats\", {\n        get: function () {\n            this._ensureCachedState();\n            return this._stats;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CompletionModel.prototype._ensureCachedState = function () {\n        if (this._refilterKind !== Refilter.Nothing) {\n            this._createCachedState();\n        }\n    };\n    CompletionModel.prototype._createCachedState = function () {\n        this._isIncomplete = new Set();\n        this._stats = { suggestionCount: 0, snippetCount: 0, textCount: 0 };\n        var _a = this._lineContext, leadingLineContent = _a.leadingLineContent, characterCountDelta = _a.characterCountDelta;\n        var word = '';\n        var wordLow = '';\n        // incrementally filter less\n        var source = this._refilterKind === Refilter.All ? this._items : this._filteredItems;\n        var target = [];\n        // picks a score function based on the number of\n        // items that we have to score/filter and based on the\n        // user-configuration\n        var scoreFn = (!this._options.filterGraceful || source.length > 2000) ? filters_1.fuzzyScore : filters_1.fuzzyScoreGracefulAggressive;\n        for (var i = 0; i < source.length; i++) {\n            var item = source[i];\n            // collect those supports that signaled having\n            // an incomplete result\n            if (item.container.incomplete) {\n                this._isIncomplete.add(item.provider);\n            }\n            // 'word' is that remainder of the current line that we\n            // filter and score against. In theory each suggestion uses a\n            // different word, but in practice not - that's why we cache\n            var overwriteBefore = item.position.column - item.completion.range.startColumn;\n            var wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);\n            if (word.length !== wordLen) {\n                word = wordLen === 0 ? '' : leadingLineContent.slice(-wordLen);\n                wordLow = word.toLowerCase();\n            }\n            // remember the word against which this item was\n            // scored\n            item.word = word;\n            if (wordLen === 0) {\n                // when there is nothing to score against, don't\n                // event try to do. Use a const rank and rely on\n                // the fallback-sort using the initial sort order.\n                // use a score of `-100` because that is out of the\n                // bound of values `fuzzyScore` will return\n                item.score = filters_1.FuzzyScore.Default;\n            }\n            else {\n                // skip word characters that are whitespace until\n                // we have hit the replace range (overwriteBefore)\n                var wordPos = 0;\n                while (wordPos < overwriteBefore) {\n                    var ch = word.charCodeAt(wordPos);\n                    if (ch === charCode_1.CharCode.Space || ch === charCode_1.CharCode.Tab) {\n                        wordPos += 1;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                if (wordPos >= wordLen) {\n                    // the wordPos at which scoring starts is the whole word\n                    // and therefore the same rules as not having a word apply\n                    item.score = filters_1.FuzzyScore.Default;\n                }\n                else if (typeof item.completion.filterText === 'string') {\n                    // when there is a `filterText` it must match the `word`.\n                    // if it matches we check with the label to compute highlights\n                    // and if that doesn't yield a result we have no highlights,\n                    // despite having the match\n                    var match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow, 0, false);\n                    if (!match) {\n                        continue; // NO match\n                    }\n                    item.score = filters_1.anyScore(word, wordLow, 0, item.completion.label, item.labelLow, 0);\n                    item.score[0] = match[0]; // use score from filterText\n                }\n                else {\n                    // by default match `word` against the `label`\n                    var match = scoreFn(word, wordLow, wordPos, item.completion.label, item.labelLow, 0, false);\n                    if (!match) {\n                        continue; // NO match\n                    }\n                    item.score = match;\n                }\n            }\n            item.idx = i;\n            item.distance = this._wordDistance.distance(item.position, item.completion);\n            target.push(item);\n            // update stats\n            this._stats.suggestionCount++;\n            switch (item.completion.kind) {\n                case modes_1.CompletionItemKind.Snippet:\n                    this._stats.snippetCount++;\n                    break;\n                case modes_1.CompletionItemKind.Text:\n                    this._stats.textCount++;\n                    break;\n            }\n        }\n        this._filteredItems = target.sort(this._snippetCompareFn);\n        this._refilterKind = Refilter.Nothing;\n    };\n    CompletionModel._compareCompletionItems = function (a, b) {\n        if (a.score[0] > b.score[0]) {\n            return -1;\n        }\n        else if (a.score[0] < b.score[0]) {\n            return 1;\n        }\n        else if (a.distance < b.distance) {\n            return -1;\n        }\n        else if (a.distance > b.distance) {\n            return 1;\n        }\n        else if (a.idx < b.idx) {\n            return -1;\n        }\n        else if (a.idx > b.idx) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    };\n    CompletionModel._compareCompletionItemsSnippetsDown = function (a, b) {\n        if (a.completion.kind !== b.completion.kind) {\n            if (a.completion.kind === modes_1.CompletionItemKind.Snippet) {\n                return 1;\n            }\n            else if (b.completion.kind === modes_1.CompletionItemKind.Snippet) {\n                return -1;\n            }\n        }\n        return CompletionModel._compareCompletionItems(a, b);\n    };\n    CompletionModel._compareCompletionItemsSnippetsUp = function (a, b) {\n        if (a.completion.kind !== b.completion.kind) {\n            if (a.completion.kind === modes_1.CompletionItemKind.Snippet) {\n                return -1;\n            }\n            else if (b.completion.kind === modes_1.CompletionItemKind.Snippet) {\n                return 1;\n            }\n        }\n        return CompletionModel._compareCompletionItems(a, b);\n    };\n    return CompletionModel;\n}());\nexports.CompletionModel = CompletionModel;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/suggest/completionModel.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/contrib/suggest/completionModel.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { fuzzyScore, fuzzyScoreGracefulAggressive, anyScore, FuzzyScorer, FuzzyScore } from 'vs/base/common/filters';\nimport { isDisposable } from 'vs/base/common/lifecycle';\nimport { CompletionList, CompletionItemProvider, CompletionItemKind } from 'vs/editor/common/modes';\nimport { CompletionItem } from './suggest';\nimport { InternalSuggestOptions, EDITOR_DEFAULTS } from 'vs/editor/common/config/editorOptions';\nimport { WordDistance } from 'vs/editor/contrib/suggest/wordDistance';\nimport { CharCode } from 'vs/base/common/charCode';\n\ntype StrictCompletionItem = Required<CompletionItem>;\n\n/* __GDPR__FRAGMENT__\n\t\"ICompletionStats\" : {\n\t\t\"suggestionCount\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"snippetCount\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"textCount\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n\t}\n*/\n// __GDPR__TODO__: This is a dynamically extensible structure which can not be declared statically.\nexport interface ICompletionStats {\n\tsuggestionCount: number;\n\tsnippetCount: number;\n\ttextCount: number;\n\t[name: string]: any;\n}\n\nexport class LineContext {\n\tleadingLineContent: string;\n\tcharacterCountDelta: number;\n}\n\nconst enum Refilter {\n\tNothing = 0,\n\tAll = 1,\n\tIncr = 2\n}\n\nexport class CompletionModel {\n\n\tprivate readonly _items: CompletionItem[];\n\tprivate readonly _column: number;\n\tprivate readonly _wordDistance: WordDistance;\n\tprivate readonly _options: InternalSuggestOptions;\n\tprivate readonly _snippetCompareFn = CompletionModel._compareCompletionItems;\n\n\tprivate _lineContext: LineContext;\n\tprivate _refilterKind: Refilter;\n\tprivate _filteredItems: StrictCompletionItem[];\n\tprivate _isIncomplete: Set<CompletionItemProvider>;\n\tprivate _stats: ICompletionStats;\n\n\tconstructor(\n\t\titems: CompletionItem[],\n\t\tcolumn: number,\n\t\tlineContext: LineContext,\n\t\twordDistance: WordDistance,\n\t\toptions: InternalSuggestOptions = EDITOR_DEFAULTS.contribInfo.suggest\n\t) {\n\t\tthis._items = items;\n\t\tthis._column = column;\n\t\tthis._wordDistance = wordDistance;\n\t\tthis._options = options;\n\t\tthis._refilterKind = Refilter.All;\n\t\tthis._lineContext = lineContext;\n\n\t\tif (options.snippets === 'top') {\n\t\t\tthis._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsUp;\n\t\t} else if (options.snippets === 'bottom') {\n\t\t\tthis._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsDown;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tconst seen = new Set<CompletionList>();\n\t\tfor (const { container } of this._items) {\n\t\t\tif (!seen.has(container)) {\n\t\t\t\tseen.add(container);\n\t\t\t\tif (isDisposable(container)) {\n\t\t\t\t\tcontainer.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget lineContext(): LineContext {\n\t\treturn this._lineContext;\n\t}\n\n\tset lineContext(value: LineContext) {\n\t\tif (this._lineContext.leadingLineContent !== value.leadingLineContent\n\t\t\t|| this._lineContext.characterCountDelta !== value.characterCountDelta\n\t\t) {\n\t\t\tthis._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? Refilter.Incr : Refilter.All;\n\t\t\tthis._lineContext = value;\n\t\t}\n\t}\n\n\tget items(): CompletionItem[] {\n\t\tthis._ensureCachedState();\n\t\treturn this._filteredItems;\n\t}\n\n\tget incomplete(): Set<CompletionItemProvider> {\n\t\tthis._ensureCachedState();\n\t\treturn this._isIncomplete;\n\t}\n\n\tadopt(except: Set<CompletionItemProvider>): CompletionItem[] {\n\t\tlet res = new Array<CompletionItem>();\n\t\tfor (let i = 0; i < this._items.length;) {\n\t\t\tif (!except.has(this._items[i].provider)) {\n\t\t\t\tres.push(this._items[i]);\n\n\t\t\t\t// unordered removed\n\t\t\t\tthis._items[i] = this._items[this._items.length - 1];\n\t\t\t\tthis._items.pop();\n\t\t\t} else {\n\t\t\t\t// continue with next item\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tthis._refilterKind = Refilter.All;\n\t\treturn res;\n\t}\n\n\tget stats(): ICompletionStats {\n\t\tthis._ensureCachedState();\n\t\treturn this._stats;\n\t}\n\n\tprivate _ensureCachedState(): void {\n\t\tif (this._refilterKind !== Refilter.Nothing) {\n\t\t\tthis._createCachedState();\n\t\t}\n\t}\n\n\tprivate _createCachedState(): void {\n\n\t\tthis._isIncomplete = new Set();\n\t\tthis._stats = { suggestionCount: 0, snippetCount: 0, textCount: 0 };\n\n\t\tconst { leadingLineContent, characterCountDelta } = this._lineContext;\n\t\tlet word = '';\n\t\tlet wordLow = '';\n\n\t\t// incrementally filter less\n\t\tconst source = this._refilterKind === Refilter.All ? this._items : this._filteredItems;\n\t\tconst target: StrictCompletionItem[] = [];\n\n\t\t// picks a score function based on the number of\n\t\t// items that we have to score/filter and based on the\n\t\t// user-configuration\n\t\tconst scoreFn: FuzzyScorer = (!this._options.filterGraceful || source.length > 2000) ? fuzzyScore : fuzzyScoreGracefulAggressive;\n\n\t\tfor (let i = 0; i < source.length; i++) {\n\n\t\t\tconst item = source[i];\n\n\t\t\t// collect those supports that signaled having\n\t\t\t// an incomplete result\n\t\t\tif (item.container.incomplete) {\n\t\t\t\tthis._isIncomplete.add(item.provider);\n\t\t\t}\n\n\t\t\t// 'word' is that remainder of the current line that we\n\t\t\t// filter and score against. In theory each suggestion uses a\n\t\t\t// different word, but in practice not - that's why we cache\n\t\t\tconst overwriteBefore = item.position.column - item.completion.range.startColumn;\n\t\t\tconst wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);\n\t\t\tif (word.length !== wordLen) {\n\t\t\t\tword = wordLen === 0 ? '' : leadingLineContent.slice(-wordLen);\n\t\t\t\twordLow = word.toLowerCase();\n\t\t\t}\n\n\t\t\t// remember the word against which this item was\n\t\t\t// scored\n\t\t\titem.word = word;\n\n\t\t\tif (wordLen === 0) {\n\t\t\t\t// when there is nothing to score against, don't\n\t\t\t\t// event try to do. Use a const rank and rely on\n\t\t\t\t// the fallback-sort using the initial sort order.\n\t\t\t\t// use a score of `-100` because that is out of the\n\t\t\t\t// bound of values `fuzzyScore` will return\n\t\t\t\titem.score = FuzzyScore.Default;\n\n\t\t\t} else {\n\t\t\t\t// skip word characters that are whitespace until\n\t\t\t\t// we have hit the replace range (overwriteBefore)\n\t\t\t\tlet wordPos = 0;\n\t\t\t\twhile (wordPos < overwriteBefore) {\n\t\t\t\t\tconst ch = word.charCodeAt(wordPos);\n\t\t\t\t\tif (ch === CharCode.Space || ch === CharCode.Tab) {\n\t\t\t\t\t\twordPos += 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (wordPos >= wordLen) {\n\t\t\t\t\t// the wordPos at which scoring starts is the whole word\n\t\t\t\t\t// and therefore the same rules as not having a word apply\n\t\t\t\t\titem.score = FuzzyScore.Default;\n\n\t\t\t\t} else if (typeof item.completion.filterText === 'string') {\n\t\t\t\t\t// when there is a `filterText` it must match the `word`.\n\t\t\t\t\t// if it matches we check with the label to compute highlights\n\t\t\t\t\t// and if that doesn't yield a result we have no highlights,\n\t\t\t\t\t// despite having the match\n\t\t\t\t\tlet match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow!, 0, false);\n\t\t\t\t\tif (!match) {\n\t\t\t\t\t\tcontinue; // NO match\n\t\t\t\t\t}\n\t\t\t\t\titem.score = anyScore(word, wordLow, 0, item.completion.label, item.labelLow, 0);\n\t\t\t\t\titem.score[0] = match[0]; // use score from filterText\n\n\t\t\t\t} else {\n\t\t\t\t\t// by default match `word` against the `label`\n\t\t\t\t\tlet match = scoreFn(word, wordLow, wordPos, item.completion.label, item.labelLow, 0, false);\n\t\t\t\t\tif (!match) {\n\t\t\t\t\t\tcontinue; // NO match\n\t\t\t\t\t}\n\t\t\t\t\titem.score = match;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titem.idx = i;\n\t\t\titem.distance = this._wordDistance.distance(item.position, item.completion);\n\t\t\ttarget.push(item as StrictCompletionItem);\n\n\t\t\t// update stats\n\t\t\tthis._stats.suggestionCount++;\n\t\t\tswitch (item.completion.kind) {\n\t\t\t\tcase CompletionItemKind.Snippet: this._stats.snippetCount++; break;\n\t\t\t\tcase CompletionItemKind.Text: this._stats.textCount++; break;\n\t\t\t}\n\t\t}\n\n\t\tthis._filteredItems = target.sort(this._snippetCompareFn);\n\t\tthis._refilterKind = Refilter.Nothing;\n\t}\n\n\tprivate static _compareCompletionItems(a: StrictCompletionItem, b: StrictCompletionItem): number {\n\t\tif (a.score[0] > b.score[0]) {\n\t\t\treturn -1;\n\t\t} else if (a.score[0] < b.score[0]) {\n\t\t\treturn 1;\n\t\t} else if (a.distance < b.distance) {\n\t\t\treturn -1;\n\t\t} else if (a.distance > b.distance) {\n\t\t\treturn 1;\n\t\t} else if (a.idx < b.idx) {\n\t\t\treturn -1;\n\t\t} else if (a.idx > b.idx) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate static _compareCompletionItemsSnippetsDown(a: StrictCompletionItem, b: StrictCompletionItem): number {\n\t\tif (a.completion.kind !== b.completion.kind) {\n\t\t\tif (a.completion.kind === CompletionItemKind.Snippet) {\n\t\t\t\treturn 1;\n\t\t\t} else if (b.completion.kind === CompletionItemKind.Snippet) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn CompletionModel._compareCompletionItems(a, b);\n\t}\n\n\tprivate static _compareCompletionItemsSnippetsUp(a: StrictCompletionItem, b: StrictCompletionItem): number {\n\t\tif (a.completion.kind !== b.completion.kind) {\n\t\t\tif (a.completion.kind === CompletionItemKind.Snippet) {\n\t\t\t\treturn -1;\n\t\t\t} else if (b.completion.kind === CompletionItemKind.Snippet) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn CompletionModel._compareCompletionItems(a, b);\n\t}\n}\n"]}]}