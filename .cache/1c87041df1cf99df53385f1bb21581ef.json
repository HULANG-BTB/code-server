{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/win32/csharpWatcherService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/win32/csharpWatcherService.ts","mtime":1555846338048},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"child_process\", \"vs/platform/files/common/files\", \"vs/base/node/decoder\", \"vs/base/common/glob\", \"vs/base/common/amd\"], function (require, exports, cp, files_1, decoder, glob, amd_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class OutOfProcessWin32FolderWatcher {\n        constructor(watchedFolder, ignored, eventCallback, errorCallback, verboseLogging) {\n            this.watchedFolder = watchedFolder;\n            this.eventCallback = eventCallback;\n            this.errorCallback = errorCallback;\n            this.verboseLogging = verboseLogging;\n            this.retry = require('vs/../../../../packages/vscode/src/workbench').workbench.retry.register('Watcher', () => this.startWatcher());\n            this.restartCounter = 0;\n            if (Array.isArray(ignored)) {\n                this.ignored = ignored.map(i => glob.parse(i));\n            }\n            else {\n                this.ignored = [];\n            }\n            this.startWatcher();\n        }\n        startWatcher() {\n            const args = [this.watchedFolder];\n            if (this.verboseLogging) {\n                args.push('-verbose');\n            }\n            this.handle = cp.spawn(amd_1.getPathFromAmdModule(require, 'vs/workbench/services/files/node/watcher/win32/CodeHelper.exe'), args);\n            const stdoutLineDecoder = new decoder.LineDecoder();\n            this.handle.stdout.once('data', () => this.retry.recover());\n            // Events over stdout\n            this.handle.stdout.on('data', (data) => {\n                // Collect raw events from output\n                const rawEvents = [];\n                stdoutLineDecoder.write(data).forEach((line) => {\n                    const eventParts = line.split('|');\n                    if (eventParts.length === 2) {\n                        const changeType = Number(eventParts[0]);\n                        const absolutePath = eventParts[1];\n                        // File Change Event (0 Changed, 1 Created, 2 Deleted)\n                        if (changeType >= 0 && changeType < 3) {\n                            // Support ignores\n                            if (this.ignored && this.ignored.some(ignore => ignore(absolutePath))) {\n                                if (this.verboseLogging) {\n                                    console.log('%c[File Watcher (C#)]', 'color: blue', ' >> ignored', absolutePath);\n                                }\n                                return;\n                            }\n                            // Otherwise record as event\n                            rawEvents.push({\n                                type: OutOfProcessWin32FolderWatcher.changeTypeMap[changeType],\n                                path: absolutePath\n                            });\n                        }\n                        // 3 Logging\n                        else {\n                            console.log('%c[File Watcher (C#)]', 'color: blue', eventParts[1]);\n                        }\n                    }\n                });\n                // Trigger processing of events through the delayer to batch them up properly\n                if (rawEvents.length > 0) {\n                    this.eventCallback(rawEvents);\n                }\n            });\n            // Errors\n            this.handle.on('error', (error) => this.onError(error));\n            this.handle.stderr.on('data', (data) => this.onError(data));\n            // Exit\n            this.handle.on('exit', (code, signal) => this.onExit(code, signal));\n        }\n        onError(error) {\n            this.errorCallback('[File Watcher (C#)] process error: ' + error.toString());\n        }\n        onExit(code, signal) {\n            if (this.handle) { // exit while not yet being disposed is unexpected!\n                return this.retry.run();\n                this.errorCallback(`[File Watcher (C#)] terminated unexpectedly (code: ${code}, signal: ${signal})`);\n                if (this.restartCounter <= OutOfProcessWin32FolderWatcher.MAX_RESTARTS) {\n                    this.errorCallback('[File Watcher (C#)] is restarted again...');\n                    this.restartCounter++;\n                    this.startWatcher(); // restart\n                }\n                else {\n                    this.errorCallback('[File Watcher (C#)] Watcher failed to start after retrying for some time, giving up. Please report this as a bug report!');\n                }\n            }\n        }\n        dispose() {\n            if (this.handle) {\n                this.handle.kill();\n                this.handle = null; // StrictNullOverride: nulling out ok in dispose\n            }\n        }\n    }\n    OutOfProcessWin32FolderWatcher.MAX_RESTARTS = 5;\n    OutOfProcessWin32FolderWatcher.changeTypeMap = [files_1.FileChangeType.UPDATED, files_1.FileChangeType.ADDED, files_1.FileChangeType.DELETED];\n    exports.OutOfProcessWin32FolderWatcher = OutOfProcessWin32FolderWatcher;\n});\n",null]}