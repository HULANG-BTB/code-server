{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/files2/common/fileService2.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files2/common/fileService2.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar files_1 = require(\"vs/platform/files/common/files\");\nvar event_1 = require(\"vs/base/common/event\");\nvar resources_1 = require(\"vs/base/common/resources\");\nvar nls_1 = require(\"vs/nls\");\nvar map_1 = require(\"vs/base/common/map\");\nvar arrays_1 = require(\"vs/base/common/arrays\");\nvar labels_1 = require(\"vs/base/common/labels\");\nvar log_1 = require(\"vs/platform/log/common/log\");\nvar FileService2 = /** @class */ (function (_super) {\n    tslib_1.__extends(FileService2, _super);\n    function FileService2(logService) {\n        var _this = _super.call(this) || this;\n        _this.logService = logService;\n        //#region File System Provider\n        _this._onDidChangeFileSystemProviderRegistrations = _this._register(new event_1.Emitter());\n        _this._onWillActivateFileSystemProvider = _this._register(new event_1.Emitter());\n        _this.provider = new Map();\n        //#endregion\n        _this._onAfterOperation = _this._register(new event_1.Emitter());\n        //#endregion\n        //#region File Watching\n        _this._onFileChanges = _this._register(new event_1.Emitter());\n        _this.joinOnLegacy = new Promise(function (resolve) {\n            _this.joinOnImplResolve = resolve;\n        });\n        return _this;\n    }\n    FileService2.prototype.setLegacyService = function (legacy) {\n        var _this = this;\n        this._legacy = this._register(legacy);\n        this._register(legacy.onFileChanges(function (e) { return _this._onFileChanges.fire(e); }));\n        this._register(legacy.onAfterOperation(function (e) { return _this._onAfterOperation.fire(e); }));\n        this.provider.forEach(function (provider, scheme) {\n            legacy.registerProvider(scheme, provider);\n        });\n        this.joinOnImplResolve(legacy);\n    };\n    Object.defineProperty(FileService2.prototype, \"onDidChangeFileSystemProviderRegistrations\", {\n        get: function () { return this._onDidChangeFileSystemProviderRegistrations.event; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FileService2.prototype, \"onWillActivateFileSystemProvider\", {\n        get: function () { return this._onWillActivateFileSystemProvider.event; },\n        enumerable: true,\n        configurable: true\n    });\n    FileService2.prototype.registerProvider = function (scheme, provider) {\n        var _this = this;\n        if (this.provider.has(scheme)) {\n            throw new Error(\"A provider for the scheme \" + scheme + \" is already registered.\");\n        }\n        var legacyDisposal;\n        if (this._legacy) {\n            legacyDisposal = this._legacy.registerProvider(scheme, provider);\n        }\n        else {\n            legacyDisposal = lifecycle_1.Disposable.None;\n        }\n        // Add provider with event\n        this.provider.set(scheme, provider);\n        this._onDidChangeFileSystemProviderRegistrations.fire({ added: true, scheme: scheme, provider: provider });\n        // Forward change events from provider\n        var providerFileListener = provider.onDidChangeFile(function (changes) { return _this._onFileChanges.fire(new files_1.FileChangesEvent(changes)); });\n        return lifecycle_1.combinedDisposable([\n            lifecycle_1.toDisposable(function () {\n                _this._onDidChangeFileSystemProviderRegistrations.fire({ added: false, scheme: scheme, provider: provider });\n                _this.provider.delete(scheme);\n                providerFileListener.dispose();\n            }),\n            legacyDisposal\n        ]);\n    };\n    FileService2.prototype.activateProvider = function (scheme) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var joiners;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        joiners = [];\n                        this._onWillActivateFileSystemProvider.fire({\n                            scheme: scheme,\n                            join: function (promise) {\n                                if (promise) {\n                                    joiners.push(promise);\n                                }\n                            },\n                        });\n                        if (this.provider.has(scheme)) {\n                            return [2 /*return*/, Promise.resolve()]; // provider is already here so we can return directly\n                        }\n                        // If the provider is not yet there, make sure to join on the listeners assuming\n                        // that it takes a bit longer to register the file system provider.\n                        return [4 /*yield*/, Promise.all(joiners)];\n                    case 1:\n                        // If the provider is not yet there, make sure to join on the listeners assuming\n                        // that it takes a bit longer to register the file system provider.\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    FileService2.prototype.canHandleResource = function (resource) {\n        return this.provider.has(resource.scheme);\n    };\n    FileService2.prototype.hasCapability = function (resource, capability) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var provider;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.withProvider(resource)];\n                    case 1:\n                        provider = _a.sent();\n                        return [2 /*return*/, !!(provider.capabilities & capability)];\n                }\n            });\n        });\n    };\n    FileService2.prototype.withProvider = function (resource) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var provider, err;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // Assert path is absolute\n                        if (!resources_1.isAbsolutePath(resource)) {\n                            throw new files_1.FileOperationError(nls_1.localize('invalidPath', \"The path of resource '{0}' must be absolute\", resource.toString(true)), files_1.FileOperationResult.FILE_INVALID_PATH);\n                        }\n                        // Activate provider\n                        return [4 /*yield*/, this.activateProvider(resource.scheme)];\n                    case 1:\n                        // Activate provider\n                        _a.sent();\n                        provider = this.provider.get(resource.scheme);\n                        if (!provider) {\n                            err = new Error();\n                            err.name = 'ENOPRO';\n                            err.message = \"No provider found for \" + resource.toString();\n                            throw err;\n                        }\n                        return [2 /*return*/, provider];\n                }\n            });\n        });\n    };\n    Object.defineProperty(FileService2.prototype, \"onAfterOperation\", {\n        get: function () { return this._onAfterOperation.event; },\n        enumerable: true,\n        configurable: true\n    });\n    FileService2.prototype.resolveFile = function (resource, options) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var error_1;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.doResolveFile(resource, options)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_1 = _a.sent();\n                        // Specially handle file not found case as file operation result\n                        if (files_1.toFileSystemProviderErrorCode(error_1) === files_1.FileSystemProviderErrorCode.FileNotFound) {\n                            throw new files_1.FileOperationError(nls_1.localize('fileNotFoundError', \"File not found ({0})\", resource.toString(true)), files_1.FileOperationResult.FILE_NOT_FOUND);\n                        }\n                        // Bubble up any other error as is\n                        throw error_1;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    FileService2.prototype.doResolveFile = function (resource, options) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var provider, resolveTo, trie, resolveSingleChildDescendants, resolveMetadata, stat;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.withProvider(resource)];\n                    case 1:\n                        provider = _a.sent();\n                        resolveTo = options && options.resolveTo;\n                        trie = map_1.TernarySearchTree.forPaths();\n                        trie.set(resource.toString(), true);\n                        if (arrays_1.isNonEmptyArray(resolveTo)) {\n                            resolveTo.forEach(function (uri) { return trie.set(uri.toString(), true); });\n                        }\n                        resolveSingleChildDescendants = !!(options && options.resolveSingleChildDescendants);\n                        resolveMetadata = !!(options && options.resolveMetadata);\n                        return [4 /*yield*/, provider.stat(resource)];\n                    case 2:\n                        stat = _a.sent();\n                        return [4 /*yield*/, this.toFileStat(provider, resource, stat, undefined, resolveMetadata, function (stat, siblings) {\n                                // check for recursive resolving\n                                if (Boolean(trie.findSuperstr(stat.resource.toString()) || trie.get(stat.resource.toString()))) {\n                                    return true;\n                                }\n                                // check for resolving single child folders\n                                if (stat.isDirectory && resolveSingleChildDescendants) {\n                                    return siblings === 1;\n                                }\n                                return false;\n                            })];\n                    case 3: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    FileService2.prototype.toFileStat = function (provider, resource, stat, siblings, resolveMetadata, recurse) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var fileStat, entries_1, resolvedEntries, error_2;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        fileStat = {\n                            resource: resource,\n                            name: labels_1.getBaseLabel(resource),\n                            isDirectory: (stat.type & files_1.FileType.Directory) !== 0,\n                            isSymbolicLink: (stat.type & files_1.FileType.SymbolicLink) !== 0,\n                            isReadonly: !!(provider.capabilities & files_1.FileSystemProviderCapabilities.Readonly),\n                            mtime: stat.mtime,\n                            size: stat.size,\n                            etag: files_1.etag(stat.mtime, stat.size)\n                        };\n                        if (!(fileStat.isDirectory && recurse(fileStat, siblings))) return [3 /*break*/, 6];\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 4, , 5]);\n                        return [4 /*yield*/, provider.readdir(resource)];\n                    case 2:\n                        entries_1 = _a.sent();\n                        return [4 /*yield*/, Promise.all(entries_1.map(function (_a) {\n                                var name = _a[0], type = _a[1];\n                                return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                                    var childResource, childStat, _b, error_3;\n                                    return tslib_1.__generator(this, function (_c) {\n                                        switch (_c.label) {\n                                            case 0:\n                                                _c.trys.push([0, 5, , 6]);\n                                                childResource = resources_1.joinPath(resource, name);\n                                                if (!resolveMetadata) return [3 /*break*/, 2];\n                                                return [4 /*yield*/, provider.stat(childResource)];\n                                            case 1:\n                                                _b = _c.sent();\n                                                return [3 /*break*/, 3];\n                                            case 2:\n                                                _b = { type: type };\n                                                _c.label = 3;\n                                            case 3:\n                                                childStat = _b;\n                                                return [4 /*yield*/, this.toFileStat(provider, childResource, childStat, entries_1.length, resolveMetadata, recurse)];\n                                            case 4: return [2 /*return*/, _c.sent()];\n                                            case 5:\n                                                error_3 = _c.sent();\n                                                this.logService.trace(error_3);\n                                                return [2 /*return*/, null]; // can happen e.g. due to permission errors\n                                            case 6: return [2 /*return*/];\n                                        }\n                                    });\n                                });\n                            }))];\n                    case 3:\n                        resolvedEntries = _a.sent();\n                        // make sure to get rid of null values that signal a failure to resolve a particular entry\n                        fileStat.children = arrays_1.coalesce(resolvedEntries);\n                        return [3 /*break*/, 5];\n                    case 4:\n                        error_2 = _a.sent();\n                        this.logService.trace(error_2);\n                        fileStat.children = []; // gracefully handle errors, we may not have permissions to read\n                        return [3 /*break*/, 5];\n                    case 5: return [2 /*return*/, fileStat];\n                    case 6: return [2 /*return*/, Promise.resolve(fileStat)];\n                }\n            });\n        });\n    };\n    FileService2.prototype.resolveFiles = function (toResolve) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                return [2 /*return*/, Promise.all(toResolve.map(function (entry) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                        var _a, error_4;\n                        return tslib_1.__generator(this, function (_b) {\n                            switch (_b.label) {\n                                case 0:\n                                    _b.trys.push([0, 2, , 3]);\n                                    _a = {};\n                                    return [4 /*yield*/, this.doResolveFile(entry.resource, entry.options)];\n                                case 1: return [2 /*return*/, (_a.stat = _b.sent(), _a.success = true, _a)];\n                                case 2:\n                                    error_4 = _b.sent();\n                                    this.logService.trace(error_4);\n                                    return [2 /*return*/, { stat: undefined, success: false }];\n                                case 3: return [2 /*return*/];\n                            }\n                        });\n                    }); }))];\n            });\n        });\n    };\n    FileService2.prototype.existsFile = function (resource) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var error_5;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.resolveFile(resource)];\n                    case 1: return [2 /*return*/, !!(_a.sent())];\n                    case 2:\n                        error_5 = _a.sent();\n                        return [2 /*return*/, false];\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Object.defineProperty(FileService2.prototype, \"encoding\", {\n        //#endregion\n        //#region File Reading/Writing\n        get: function () {\n            if (!this._legacy) {\n                throw new Error('Legacy file service not ready yet');\n            }\n            return this._legacy.encoding;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    FileService2.prototype.createFile = function (resource, content, options) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var useLegacy, provider, _a, overwrite, error_6, fileStat;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        useLegacy = true;\n                        if (useLegacy) {\n                            return [2 /*return*/, this.joinOnLegacy.then(function (legacy) { return legacy.createFile(resource, content, options); })];\n                        }\n                        _a = this.throwIfFileSystemIsReadonly;\n                        return [4 /*yield*/, this.withProvider(resource)];\n                    case 1:\n                        provider = _a.apply(this, [_b.sent()]);\n                        overwrite = !!(options && options.overwrite);\n                        return [4 /*yield*/, this.existsFile(resource)];\n                    case 2:\n                        if (!_b.sent()) return [3 /*break*/, 4];\n                        if (!overwrite) {\n                            throw new files_1.FileOperationError(nls_1.localize('fileExists', \"File to create already exists ({0})\", resource.toString(true)), files_1.FileOperationResult.FILE_MODIFIED_SINCE, options);\n                        }\n                        // delete otherwise\n                        return [4 /*yield*/, this.del(resource, { recursive: true })];\n                    case 3:\n                        // delete otherwise\n                        _b.sent();\n                        _b.label = 4;\n                    case 4:\n                        _b.trys.push([4, 11, , 12]);\n                        // mkdir recursively\n                        return [4 /*yield*/, this.mkdirp(provider, resources_1.dirname(resource))];\n                    case 5:\n                        // mkdir recursively\n                        _b.sent();\n                        if (!files_1.hasOpenReadWriteCloseCapability(provider)) return [3 /*break*/, 7];\n                        return [4 /*yield*/, this.doWriteBuffered(provider, resource, new TextEncoder().encode(content))];\n                    case 6:\n                        _b.sent();\n                        return [3 /*break*/, 10];\n                    case 7:\n                        if (!files_1.hasReadWriteCapability(provider)) return [3 /*break*/, 9];\n                        return [4 /*yield*/, this.doWriteUnbuffered(provider, resource, new TextEncoder().encode(content), overwrite)];\n                    case 8:\n                        _b.sent();\n                        return [3 /*break*/, 10];\n                    case 9: return [2 /*return*/, Promise.reject('Provider neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed to support creating a file.')];\n                    case 10: return [3 /*break*/, 12];\n                    case 11:\n                        error_6 = _b.sent();\n                        throw new files_1.FileOperationError(nls_1.localize('err.create', \"Failed to create file {0}\", resource.toString(false)), files_1.toFileOperationResult(error_6), options);\n                    case 12: return [4 /*yield*/, this.resolveFile(resource, { resolveMetadata: true })];\n                    case 13:\n                        fileStat = _b.sent();\n                        this._onAfterOperation.fire(new files_1.FileOperationEvent(resource, files_1.FileOperation.CREATE, fileStat));\n                        return [2 /*return*/, fileStat];\n                }\n            });\n        });\n    };\n    FileService2.prototype.resolveContent = function (resource, options) {\n        return this.joinOnLegacy.then(function (legacy) { return legacy.resolveContent(resource, options); });\n    };\n    FileService2.prototype.resolveStreamContent = function (resource, options) {\n        return this.joinOnLegacy.then(function (legacy) { return legacy.resolveStreamContent(resource, options); });\n    };\n    FileService2.prototype.updateContent = function (resource, value, options) {\n        return this.joinOnLegacy.then(function (legacy) { return legacy.updateContent(resource, value, options); });\n    };\n    //#endregion\n    //#region Move/Copy/Delete/Create Folder\n    FileService2.prototype.moveFile = function (source, target, overwrite) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var sourceProvider, _a, targetProvider, _b, mode, fileStat;\n            return tslib_1.__generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        _a = this.throwIfFileSystemIsReadonly;\n                        return [4 /*yield*/, this.withProvider(source)];\n                    case 1:\n                        sourceProvider = _a.apply(this, [_c.sent()]);\n                        _b = this.throwIfFileSystemIsReadonly;\n                        return [4 /*yield*/, this.withProvider(target)];\n                    case 2:\n                        targetProvider = _b.apply(this, [_c.sent()]);\n                        return [4 /*yield*/, this.doMoveCopy(sourceProvider, source, targetProvider, target, 'move', overwrite)];\n                    case 3:\n                        mode = _c.sent();\n                        return [4 /*yield*/, this.resolveFile(target, { resolveMetadata: true })];\n                    case 4:\n                        fileStat = _c.sent();\n                        this._onAfterOperation.fire(new files_1.FileOperationEvent(source, mode === 'move' ? files_1.FileOperation.MOVE : files_1.FileOperation.COPY, fileStat));\n                        return [2 /*return*/, fileStat];\n                }\n            });\n        });\n    };\n    FileService2.prototype.copyFile = function (source, target, overwrite) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var sourceProvider, targetProvider, _a, mode, fileStat;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, this.withProvider(source)];\n                    case 1:\n                        sourceProvider = _b.sent();\n                        _a = this.throwIfFileSystemIsReadonly;\n                        return [4 /*yield*/, this.withProvider(target)];\n                    case 2:\n                        targetProvider = _a.apply(this, [_b.sent()]);\n                        return [4 /*yield*/, this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', overwrite)];\n                    case 3:\n                        mode = _b.sent();\n                        return [4 /*yield*/, this.resolveFile(target, { resolveMetadata: true })];\n                    case 4:\n                        fileStat = _b.sent();\n                        this._onAfterOperation.fire(new files_1.FileOperationEvent(source, mode === 'copy' ? files_1.FileOperation.COPY : files_1.FileOperation.MOVE, fileStat));\n                        return [2 /*return*/, fileStat];\n                }\n            });\n        });\n    };\n    FileService2.prototype.doMoveCopy = function (sourceProvider, source, targetProvider, target, mode, overwrite) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var _a, exists, isCaseChange, sourceFile;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, overwrite)];\n                    case 1:\n                        _a = _b.sent(), exists = _a.exists, isCaseChange = _a.isCaseChange;\n                        if (!(exists && !isCaseChange && overwrite)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.del(target, { recursive: true })];\n                    case 2:\n                        _b.sent();\n                        _b.label = 3;\n                    case 3: \n                    // create parent folders\n                    return [4 /*yield*/, this.mkdirp(targetProvider, resources_1.dirname(target))];\n                    case 4:\n                        // create parent folders\n                        _b.sent();\n                        if (!(mode === 'copy')) return [3 /*break*/, 6];\n                        // same provider with fast copy: leverage copy() functionality\n                        if (sourceProvider === targetProvider && files_1.hasFileFolderCopyCapability(sourceProvider)) {\n                            return [2 /*return*/, sourceProvider.copy(source, target, { overwrite: !!overwrite }).then(function () { return mode; })];\n                        }\n                        // otherwise, ensure we got the capabilities to do this\n                        if (!(files_1.hasOpenReadWriteCloseCapability(sourceProvider) || files_1.hasReadWriteCapability(sourceProvider)) ||\n                            !(files_1.hasOpenReadWriteCloseCapability(targetProvider) || files_1.hasReadWriteCapability(targetProvider))) {\n                            return [2 /*return*/, Promise.reject('Provider neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed to support copy.')];\n                        }\n                        return [4 /*yield*/, this.resolveFile(source)];\n                    case 5:\n                        sourceFile = _b.sent();\n                        if (sourceFile.isDirectory) {\n                            return [2 /*return*/, this.doCopyFolder(sourceProvider, sourceFile, targetProvider, target, overwrite).then(function () { return mode; })];\n                        }\n                        else {\n                            return [2 /*return*/, this.doCopyFile(sourceProvider, source, targetProvider, target, overwrite).then(function () { return mode; })];\n                        }\n                        return [3 /*break*/, 9];\n                    case 6:\n                        if (!(sourceProvider === targetProvider)) return [3 /*break*/, 7];\n                        return [2 /*return*/, sourceProvider.rename(source, target, { overwrite: !!overwrite }).then(function () { return mode; })];\n                    case 7: return [4 /*yield*/, this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', overwrite)];\n                    case 8:\n                        _b.sent();\n                        return [2 /*return*/, this.del(source, { recursive: true }).then(function () { return 'copy'; })];\n                    case 9: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    FileService2.prototype.doCopyFile = function (sourceProvider, source, targetProvider, target, overwrite) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            return tslib_1.__generator(this, function (_a) {\n                // copy: source (buffered) => target (buffered)\n                if (files_1.hasOpenReadWriteCloseCapability(sourceProvider) && files_1.hasOpenReadWriteCloseCapability(targetProvider)) {\n                    return [2 /*return*/, this.doPipeBuffered(sourceProvider, source, targetProvider, target)];\n                }\n                // copy: source (buffered) => target (unbuffered)\n                if (files_1.hasOpenReadWriteCloseCapability(sourceProvider) && files_1.hasReadWriteCapability(targetProvider)) {\n                    return [2 /*return*/, this.doPipeBufferedToUnbuffered(sourceProvider, source, targetProvider, target, !!overwrite)];\n                }\n                // copy: source (unbuffered) => target (buffered)\n                if (files_1.hasReadWriteCapability(sourceProvider) && files_1.hasOpenReadWriteCloseCapability(targetProvider)) {\n                    return [2 /*return*/, this.doPipeUnbufferedToBuffered(sourceProvider, source, targetProvider, target)];\n                }\n                // copy: source (unbuffered) => target (unbuffered)\n                if (files_1.hasReadWriteCapability(sourceProvider) && files_1.hasReadWriteCapability(targetProvider)) {\n                    return [2 /*return*/, this.doPipeUnbuffered(sourceProvider, source, targetProvider, target, !!overwrite)];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    FileService2.prototype.doCopyFolder = function (sourceProvider, sourceFolder, targetProvider, targetFolder, overwrite) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: \n                    // create folder in target\n                    return [4 /*yield*/, targetProvider.mkdir(targetFolder)];\n                    case 1:\n                        // create folder in target\n                        _a.sent();\n                        if (!Array.isArray(sourceFolder.children)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, Promise.all(sourceFolder.children.map(function (sourceChild) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                                var targetChild, _a, _b;\n                                return tslib_1.__generator(this, function (_c) {\n                                    switch (_c.label) {\n                                        case 0:\n                                            targetChild = resources_1.joinPath(targetFolder, sourceChild.name);\n                                            if (!sourceChild.isDirectory) return [3 /*break*/, 2];\n                                            _a = this.doCopyFolder;\n                                            _b = [sourceProvider];\n                                            return [4 /*yield*/, this.resolveFile(sourceChild.resource)];\n                                        case 1: return [2 /*return*/, _a.apply(this, _b.concat([_c.sent(), targetProvider, targetChild, overwrite]))];\n                                        case 2: return [2 /*return*/, this.doCopyFile(sourceProvider, sourceChild.resource, targetProvider, targetChild, overwrite)];\n                                    }\n                                });\n                            }); }))];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    FileService2.prototype.doValidateMoveCopy = function (sourceProvider, source, targetProvider, target, overwrite) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var isCaseChange, isPathCaseSensitive, isPathCaseSensitive_1, exists;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        isCaseChange = false;\n                        isPathCaseSensitive = false;\n                        // Check if source is equal or parent to target (requires providers to be the same)\n                        if (sourceProvider === targetProvider) {\n                            isPathCaseSensitive_1 = !!(sourceProvider.capabilities & files_1.FileSystemProviderCapabilities.PathCaseSensitive);\n                            isCaseChange = isPathCaseSensitive_1 ? false : resources_1.isEqual(source, target, true /* ignore case */);\n                            if (!isCaseChange && resources_1.isEqualOrParent(target, source, !isPathCaseSensitive_1)) {\n                                return [2 /*return*/, Promise.reject(new Error(nls_1.localize('unableToMoveCopyError1', \"Unable to move/copy when source path is equal or parent of target path\")))];\n                            }\n                        }\n                        return [4 /*yield*/, this.existsFile(target)];\n                    case 1:\n                        exists = _a.sent();\n                        if (exists && !isCaseChange) {\n                            // Bail out if target exists and we are not about to overwrite\n                            if (!overwrite) {\n                                throw new files_1.FileOperationError(nls_1.localize('unableToMoveCopyError2', \"Unable to move/copy. File already exists at destination.\"), files_1.FileOperationResult.FILE_MOVE_CONFLICT);\n                            }\n                            // Special case: if the target is a parent of the source, we cannot delete\n                            // it as it would delete the source as well. In this case we have to throw\n                            if (sourceProvider === targetProvider && resources_1.isEqualOrParent(source, target, !isPathCaseSensitive)) {\n                                return [2 /*return*/, Promise.reject(new Error(nls_1.localize('unableToMoveCopyError3', \"Unable to move/copy. File would replace folder it is contained in.\")))];\n                            }\n                        }\n                        return [2 /*return*/, { exists: exists, isCaseChange: isCaseChange }];\n                }\n            });\n        });\n    };\n    FileService2.prototype.createFolder = function (resource) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var provider, _a, fileStat;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = this.throwIfFileSystemIsReadonly;\n                        return [4 /*yield*/, this.withProvider(resource)];\n                    case 1:\n                        provider = _a.apply(this, [_b.sent()]);\n                        // mkdir recursively\n                        return [4 /*yield*/, this.mkdirp(provider, resource)];\n                    case 2:\n                        // mkdir recursively\n                        _b.sent();\n                        return [4 /*yield*/, this.resolveFile(resource, { resolveMetadata: true })];\n                    case 3:\n                        fileStat = _b.sent();\n                        this._onAfterOperation.fire(new files_1.FileOperationEvent(resource, files_1.FileOperation.CREATE, fileStat));\n                        return [2 /*return*/, fileStat];\n                }\n            });\n        });\n    };\n    FileService2.prototype.mkdirp = function (provider, directory) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var directoriesToCreate, stat, error_7, i;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        directoriesToCreate = [];\n                        _a.label = 1;\n                    case 1:\n                        if (!!resources_1.isEqual(directory, resources_1.dirname(directory))) return [3 /*break*/, 6];\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, provider.stat(directory)];\n                    case 3:\n                        stat = _a.sent();\n                        if ((stat.type & files_1.FileType.Directory) === 0) {\n                            throw new Error(nls_1.localize('mkdirExistsError', \"{0} exists, but is not a directory\", directory.toString()));\n                        }\n                        return [3 /*break*/, 6]; // we have hit a directory that exists -> good\n                    case 4:\n                        error_7 = _a.sent();\n                        // Bubble up any other error that is not file not found\n                        if (files_1.toFileSystemProviderErrorCode(error_7) !== files_1.FileSystemProviderErrorCode.FileNotFound) {\n                            throw error_7;\n                        }\n                        // Upon error, remember directories that need to be created\n                        directoriesToCreate.push(resources_1.basename(directory));\n                        // Continue up\n                        directory = resources_1.dirname(directory);\n                        return [3 /*break*/, 5];\n                    case 5: return [3 /*break*/, 1];\n                    case 6:\n                        i = directoriesToCreate.length - 1;\n                        _a.label = 7;\n                    case 7:\n                        if (!(i >= 0)) return [3 /*break*/, 10];\n                        directory = resources_1.joinPath(directory, directoriesToCreate[i]);\n                        return [4 /*yield*/, provider.mkdir(directory)];\n                    case 8:\n                        _a.sent();\n                        _a.label = 9;\n                    case 9:\n                        i--;\n                        return [3 /*break*/, 7];\n                    case 10: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    FileService2.prototype.del = function (resource, options) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var provider, _a, useTrash, recursive, _b, stat;\n            return tslib_1.__generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        _a = this.throwIfFileSystemIsReadonly;\n                        return [4 /*yield*/, this.withProvider(resource)];\n                    case 1:\n                        provider = _a.apply(this, [_c.sent()]);\n                        useTrash = !!(options && options.useTrash);\n                        if (useTrash && !(provider.capabilities & files_1.FileSystemProviderCapabilities.Trash)) {\n                            throw new Error(nls_1.localize('err.trash', \"Provider does not support trash.\"));\n                        }\n                        recursive = !!(options && options.recursive);\n                        _b = !recursive;\n                        if (!_b) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.existsFile(resource)];\n                    case 2:\n                        _b = (_c.sent());\n                        _c.label = 3;\n                    case 3:\n                        if (!_b) return [3 /*break*/, 5];\n                        return [4 /*yield*/, this.resolveFile(resource)];\n                    case 4:\n                        stat = _c.sent();\n                        if (stat.isDirectory && Array.isArray(stat.children) && stat.children.length > 0) {\n                            throw new Error(nls_1.localize('deleteFailed', \"Failed to delete non-empty folder '{0}'.\", resource.toString()));\n                        }\n                        _c.label = 5;\n                    case 5: \n                    // Delete through provider\n                    return [4 /*yield*/, provider.delete(resource, { recursive: recursive, useTrash: useTrash })];\n                    case 6:\n                        // Delete through provider\n                        _c.sent();\n                        // Events\n                        this._onAfterOperation.fire(new files_1.FileOperationEvent(resource, files_1.FileOperation.DELETE));\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Object.defineProperty(FileService2.prototype, \"onFileChanges\", {\n        get: function () { return this._onFileChanges.event; },\n        enumerable: true,\n        configurable: true\n    });\n    FileService2.prototype.watchFileChanges = function (resource) {\n        this.joinOnLegacy.then(function (legacy) { return legacy.watchFileChanges(resource); });\n    };\n    FileService2.prototype.unwatchFileChanges = function (resource) {\n        this.joinOnLegacy.then(function (legacy) { return legacy.unwatchFileChanges(resource); });\n    };\n    //#endregion\n    //#region Helpers\n    FileService2.prototype.doWriteBuffered = function (provider, resource, buffer) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var handle, error_8;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, provider.open(resource, { create: true })];\n                    case 1:\n                        handle = _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, 5, 7]);\n                        return [4 /*yield*/, this.doWriteBuffer(provider, handle, buffer, buffer.byteLength, 0, 0)];\n                    case 3:\n                        _a.sent();\n                        return [3 /*break*/, 7];\n                    case 4:\n                        error_8 = _a.sent();\n                        throw error_8;\n                    case 5: return [4 /*yield*/, provider.close(handle)];\n                    case 6:\n                        _a.sent();\n                        return [7 /*endfinally*/];\n                    case 7: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    FileService2.prototype.doWriteBuffer = function (provider, handle, buffer, length, posInFile, posInBuffer) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var totalBytesWritten, bytesWritten;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        totalBytesWritten = 0;\n                        _a.label = 1;\n                    case 1:\n                        if (!(totalBytesWritten < length)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, provider.write(handle, posInFile + totalBytesWritten, buffer, posInBuffer + totalBytesWritten, length - totalBytesWritten)];\n                    case 2:\n                        bytesWritten = _a.sent();\n                        totalBytesWritten += bytesWritten;\n                        return [3 /*break*/, 1];\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    FileService2.prototype.doWriteUnbuffered = function (provider, resource, buffer, overwrite) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            return tslib_1.__generator(this, function (_a) {\n                return [2 /*return*/, provider.writeFile(resource, buffer, { create: true, overwrite: overwrite })];\n            });\n        });\n    };\n    FileService2.prototype.doPipeBuffered = function (sourceProvider, source, targetProvider, target) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var sourceHandle, targetHandle, buffer, posInFile, posInBuffer, bytesRead, error_9;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        sourceHandle = undefined;\n                        targetHandle = undefined;\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 9, 10, 12]);\n                        return [4 /*yield*/, sourceProvider.open(source, { create: false })];\n                    case 2:\n                        // Open handles\n                        sourceHandle = _a.sent();\n                        return [4 /*yield*/, targetProvider.open(target, { create: true })];\n                    case 3:\n                        targetHandle = _a.sent();\n                        buffer = new Uint8Array(16 * 1024);\n                        posInFile = 0;\n                        posInBuffer = 0;\n                        bytesRead = 0;\n                        _a.label = 4;\n                    case 4: return [4 /*yield*/, sourceProvider.read(sourceHandle, posInFile, buffer, posInBuffer, buffer.byteLength - posInBuffer)];\n                    case 5:\n                        // read from source (sourceHandle) at current position (posInFile) into buffer (buffer) at\n                        // buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n                        bytesRead = _a.sent();\n                        // write into target (targetHandle) at current position (posInFile) from buffer (buffer) at\n                        // buffer position (posInBuffer) all bytes we read (bytesRead).\n                        return [4 /*yield*/, this.doWriteBuffer(targetProvider, targetHandle, buffer, bytesRead, posInFile, posInBuffer)];\n                    case 6:\n                        // write into target (targetHandle) at current position (posInFile) from buffer (buffer) at\n                        // buffer position (posInBuffer) all bytes we read (bytesRead).\n                        _a.sent();\n                        posInFile += bytesRead;\n                        posInBuffer += bytesRead;\n                        // when buffer full, fill it again from the beginning\n                        if (posInBuffer === buffer.length) {\n                            posInBuffer = 0;\n                        }\n                        _a.label = 7;\n                    case 7:\n                        if (bytesRead > 0) return [3 /*break*/, 4];\n                        _a.label = 8;\n                    case 8: return [3 /*break*/, 12];\n                    case 9:\n                        error_9 = _a.sent();\n                        throw error_9;\n                    case 10: return [4 /*yield*/, Promise.all([\n                            typeof sourceHandle === 'number' ? sourceProvider.close(sourceHandle) : Promise.resolve(),\n                            typeof targetHandle === 'number' ? targetProvider.close(targetHandle) : Promise.resolve(),\n                        ])];\n                    case 11:\n                        _a.sent();\n                        return [7 /*endfinally*/];\n                    case 12: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    FileService2.prototype.doPipeUnbuffered = function (sourceProvider, source, targetProvider, target, overwrite) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var _a, _b, _c;\n            return tslib_1.__generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        _b = (_a = targetProvider).writeFile;\n                        _c = [target];\n                        return [4 /*yield*/, sourceProvider.readFile(source)];\n                    case 1: return [2 /*return*/, _b.apply(_a, _c.concat([_d.sent(), { create: true, overwrite: overwrite }]))];\n                }\n            });\n        });\n    };\n    FileService2.prototype.doPipeUnbufferedToBuffered = function (sourceProvider, source, targetProvider, target) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var targetHandle, buffer, error_10;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, targetProvider.open(target, { create: true })];\n                    case 1:\n                        targetHandle = _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 5, 6, 8]);\n                        return [4 /*yield*/, sourceProvider.readFile(source)];\n                    case 3:\n                        buffer = _a.sent();\n                        return [4 /*yield*/, this.doWriteBuffer(targetProvider, targetHandle, buffer, buffer.byteLength, 0, 0)];\n                    case 4:\n                        _a.sent();\n                        return [3 /*break*/, 8];\n                    case 5:\n                        error_10 = _a.sent();\n                        throw error_10;\n                    case 6: return [4 /*yield*/, targetProvider.close(targetHandle)];\n                    case 7:\n                        _a.sent();\n                        return [7 /*endfinally*/];\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    FileService2.prototype.doPipeBufferedToUnbuffered = function (sourceProvider, source, targetProvider, target, overwrite) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var size, sourceHandle, buffer, pos, bytesRead, error_11;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.resolveFile(source, { resolveMetadata: true })];\n                    case 1:\n                        size = (_a.sent()).size;\n                        return [4 /*yield*/, sourceProvider.open(source, { create: false })];\n                    case 2:\n                        sourceHandle = _a.sent();\n                        _a.label = 3;\n                    case 3:\n                        _a.trys.push([3, 9, 10, 12]);\n                        buffer = new Uint8Array(size);\n                        pos = 0;\n                        bytesRead = 0;\n                        _a.label = 4;\n                    case 4: return [4 /*yield*/, sourceProvider.read(sourceHandle, pos, buffer, pos, buffer.byteLength - pos)];\n                    case 5:\n                        // read from source (sourceHandle) at current position (posInFile) into buffer (buffer) at\n                        // buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n                        bytesRead = _a.sent();\n                        pos += bytesRead;\n                        _a.label = 6;\n                    case 6:\n                        if (bytesRead > 0 && pos < size) return [3 /*break*/, 4];\n                        _a.label = 7;\n                    case 7: \n                    // Write buffer into target at once\n                    return [4 /*yield*/, this.doWriteUnbuffered(targetProvider, target, buffer, overwrite)];\n                    case 8:\n                        // Write buffer into target at once\n                        _a.sent();\n                        return [3 /*break*/, 12];\n                    case 9:\n                        error_11 = _a.sent();\n                        throw error_11;\n                    case 10: return [4 /*yield*/, sourceProvider.close(sourceHandle)];\n                    case 11:\n                        _a.sent();\n                        return [7 /*endfinally*/];\n                    case 12: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    FileService2.prototype.throwIfFileSystemIsReadonly = function (provider) {\n        if (provider.capabilities & files_1.FileSystemProviderCapabilities.Readonly) {\n            throw new files_1.FileOperationError(nls_1.localize('err.readonly', \"Resource can not be modified.\"), files_1.FileOperationResult.FILE_PERMISSION_DENIED);\n        }\n        return provider;\n    };\n    FileService2 = tslib_1.__decorate([\n        tslib_1.__param(0, log_1.ILogService)\n    ], FileService2);\n    return FileService2;\n}(lifecycle_1.Disposable));\nexports.FileService2 = FileService2;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files2/common/fileService2.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/files2/common/fileService2.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable, IDisposable, toDisposable, combinedDisposable } from 'vs/base/common/lifecycle';\nimport { IFileService, IResolveFileOptions, IResourceEncodings, FileChangesEvent, FileOperationEvent, IFileSystemProviderRegistrationEvent, IFileSystemProvider, IFileStat, IResolveFileResult, IResolveContentOptions, IContent, IStreamContent, ITextSnapshot, IUpdateContentOptions, ICreateFileOptions, IFileSystemProviderActivationEvent, FileOperationError, FileOperationResult, FileOperation, FileSystemProviderCapabilities, FileType, toFileSystemProviderErrorCode, FileSystemProviderErrorCode, IStat, IFileStatWithMetadata, IResolveMetadataFileOptions, etag, hasReadWriteCapability, hasFileFolderCopyCapability, hasOpenReadWriteCloseCapability, toFileOperationResult, IFileSystemProviderWithOpenReadWriteCloseCapability, IFileSystemProviderWithFileReadWriteCapability, IResolveFileResultWithMetadata } from 'vs/platform/files/common/files';\nimport { URI } from 'vs/base/common/uri';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { ServiceIdentifier } from 'vs/platform/instantiation/common/instantiation';\nimport { isAbsolutePath, dirname, basename, joinPath, isEqual, isEqualOrParent } from 'vs/base/common/resources';\nimport { localize } from 'vs/nls';\nimport { TernarySearchTree } from 'vs/base/common/map';\nimport { isNonEmptyArray, coalesce } from 'vs/base/common/arrays';\nimport { getBaseLabel } from 'vs/base/common/labels';\nimport { ILogService } from 'vs/platform/log/common/log';\n\nexport class FileService2 extends Disposable implements IFileService {\n\n\t//#region TODO@Ben HACKS\n\n\tprivate _legacy: IFileService | null;\n\n\tsetLegacyService(legacy: IFileService): void {\n\t\tthis._legacy = this._register(legacy);\n\n\t\tthis._register(legacy.onFileChanges(e => this._onFileChanges.fire(e)));\n\t\tthis._register(legacy.onAfterOperation(e => this._onAfterOperation.fire(e)));\n\n\t\tthis.provider.forEach((provider, scheme) => {\n\t\t\tlegacy.registerProvider(scheme, provider);\n\t\t});\n\n\t\tthis.joinOnImplResolve(legacy);\n\t}\n\n\t//#endregion\n\n\t_serviceBrand: ServiceIdentifier<any>;\n\n\tprivate joinOnLegacy: Promise<IFileService>;\n\tprivate joinOnImplResolve: (service: IFileService) => void;\n\n\tconstructor(@ILogService private logService: ILogService) {\n\t\tsuper();\n\n\t\tthis.joinOnLegacy = new Promise(resolve => {\n\t\t\tthis.joinOnImplResolve = resolve;\n\t\t});\n\t}\n\n\t//#region File System Provider\n\n\tprivate _onDidChangeFileSystemProviderRegistrations: Emitter<IFileSystemProviderRegistrationEvent> = this._register(new Emitter<IFileSystemProviderRegistrationEvent>());\n\tget onDidChangeFileSystemProviderRegistrations(): Event<IFileSystemProviderRegistrationEvent> { return this._onDidChangeFileSystemProviderRegistrations.event; }\n\n\tprivate _onWillActivateFileSystemProvider: Emitter<IFileSystemProviderActivationEvent> = this._register(new Emitter<IFileSystemProviderActivationEvent>());\n\tget onWillActivateFileSystemProvider(): Event<IFileSystemProviderActivationEvent> { return this._onWillActivateFileSystemProvider.event; }\n\n\tprivate readonly provider = new Map<string, IFileSystemProvider>();\n\n\tregisterProvider(scheme: string, provider: IFileSystemProvider): IDisposable {\n\t\tif (this.provider.has(scheme)) {\n\t\t\tthrow new Error(`A provider for the scheme ${scheme} is already registered.`);\n\t\t}\n\n\t\tlet legacyDisposal: IDisposable;\n\t\tif (this._legacy) {\n\t\t\tlegacyDisposal = this._legacy.registerProvider(scheme, provider);\n\t\t} else {\n\t\t\tlegacyDisposal = Disposable.None;\n\t\t}\n\n\t\t// Add provider with event\n\t\tthis.provider.set(scheme, provider);\n\t\tthis._onDidChangeFileSystemProviderRegistrations.fire({ added: true, scheme, provider });\n\n\t\t// Forward change events from provider\n\t\tconst providerFileListener = provider.onDidChangeFile(changes => this._onFileChanges.fire(new FileChangesEvent(changes)));\n\n\t\treturn combinedDisposable([\n\t\t\ttoDisposable(() => {\n\t\t\t\tthis._onDidChangeFileSystemProviderRegistrations.fire({ added: false, scheme, provider });\n\t\t\t\tthis.provider.delete(scheme);\n\n\t\t\t\tproviderFileListener.dispose();\n\t\t\t}),\n\t\t\tlegacyDisposal\n\t\t]);\n\t}\n\n\tasync activateProvider(scheme: string): Promise<void> {\n\n\t\t// Emit an event that we are about to activate a provider with the given scheme.\n\t\t// Listeners can participate in the activation by registering a provider for it.\n\t\tconst joiners: Promise<void>[] = [];\n\t\tthis._onWillActivateFileSystemProvider.fire({\n\t\t\tscheme,\n\t\t\tjoin(promise) {\n\t\t\t\tif (promise) {\n\t\t\t\t\tjoiners.push(promise);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\n\t\tif (this.provider.has(scheme)) {\n\t\t\treturn Promise.resolve(); // provider is already here so we can return directly\n\t\t}\n\n\t\t// If the provider is not yet there, make sure to join on the listeners assuming\n\t\t// that it takes a bit longer to register the file system provider.\n\t\tawait Promise.all(joiners);\n\t}\n\n\tcanHandleResource(resource: URI): boolean {\n\t\treturn this.provider.has(resource.scheme);\n\t}\n\n\tasync hasCapability(resource: URI, capability: FileSystemProviderCapabilities): Promise<boolean> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\treturn !!(provider.capabilities & capability);\n\t}\n\n\tprivate async withProvider(resource: URI): Promise<IFileSystemProvider> {\n\n\t\t// Assert path is absolute\n\t\tif (!isAbsolutePath(resource)) {\n\t\t\tthrow new FileOperationError(localize('invalidPath', \"The path of resource '{0}' must be absolute\", resource.toString(true)), FileOperationResult.FILE_INVALID_PATH);\n\t\t}\n\n\t\t// Activate provider\n\t\tawait this.activateProvider(resource.scheme);\n\n\t\t// Assert provider\n\t\tconst provider = this.provider.get(resource.scheme);\n\t\tif (!provider) {\n\t\t\tconst err = new Error();\n\t\t\terr.name = 'ENOPRO';\n\t\t\terr.message = `No provider found for ${resource.toString()}`;\n\n\t\t\tthrow err;\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\t//#endregion\n\n\tprivate _onAfterOperation: Emitter<FileOperationEvent> = this._register(new Emitter<FileOperationEvent>());\n\tget onAfterOperation(): Event<FileOperationEvent> { return this._onAfterOperation.event; }\n\n\t//#region File Metadata Resolving\n\n\tasync resolveFile(resource: URI, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tasync resolveFile(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;\n\tasync resolveFile(resource: URI, options?: IResolveFileOptions): Promise<IFileStat> {\n\t\ttry {\n\t\t\treturn await this.doResolveFile(resource, options);\n\t\t} catch (error) {\n\n\t\t\t// Specially handle file not found case as file operation result\n\t\t\tif (toFileSystemProviderErrorCode(error) === FileSystemProviderErrorCode.FileNotFound) {\n\t\t\t\tthrow new FileOperationError(\n\t\t\t\t\tlocalize('fileNotFoundError', \"File not found ({0})\", resource.toString(true)),\n\t\t\t\t\tFileOperationResult.FILE_NOT_FOUND\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Bubble up any other error as is\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate async doResolveFile(resource: URI, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tprivate async doResolveFile(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;\n\tprivate async doResolveFile(resource: URI, options?: IResolveFileOptions): Promise<IFileStat> {\n\t\tconst provider = await this.withProvider(resource);\n\n\t\t// leverage a trie to check for recursive resolving\n\t\tconst resolveTo = options && options.resolveTo;\n\t\tconst trie = TernarySearchTree.forPaths<true>();\n\t\ttrie.set(resource.toString(), true);\n\t\tif (isNonEmptyArray(resolveTo)) {\n\t\t\tresolveTo.forEach(uri => trie.set(uri.toString(), true));\n\t\t}\n\n\t\tconst resolveSingleChildDescendants = !!(options && options.resolveSingleChildDescendants);\n\t\tconst resolveMetadata = !!(options && options.resolveMetadata);\n\n\t\tconst stat = await provider.stat(resource);\n\n\t\treturn await this.toFileStat(provider, resource, stat, undefined, resolveMetadata, (stat, siblings) => {\n\n\t\t\t// check for recursive resolving\n\t\t\tif (Boolean(trie.findSuperstr(stat.resource.toString()) || trie.get(stat.resource.toString()))) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// check for resolving single child folders\n\t\t\tif (stat.isDirectory && resolveSingleChildDescendants) {\n\t\t\t\treturn siblings === 1;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t});\n\t}\n\n\tprivate async toFileStat(provider: IFileSystemProvider, resource: URI, stat: IStat | { type: FileType } & Partial<IStat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: IFileStat, siblings?: number) => boolean): Promise<IFileStat> {\n\n\t\t// convert to file stat\n\t\tconst fileStat: IFileStat = {\n\t\t\tresource,\n\t\t\tname: getBaseLabel(resource),\n\t\t\tisDirectory: (stat.type & FileType.Directory) !== 0,\n\t\t\tisSymbolicLink: (stat.type & FileType.SymbolicLink) !== 0,\n\t\t\tisReadonly: !!(provider.capabilities & FileSystemProviderCapabilities.Readonly),\n\t\t\tmtime: stat.mtime,\n\t\t\tsize: stat.size,\n\t\t\tetag: etag(stat.mtime, stat.size)\n\t\t};\n\n\t\t// check to recurse for directories\n\t\tif (fileStat.isDirectory && recurse(fileStat, siblings)) {\n\t\t\ttry {\n\t\t\t\tconst entries = await provider.readdir(resource);\n\t\t\t\tconst resolvedEntries = await Promise.all(entries.map(async ([name, type]) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst childResource = joinPath(resource, name);\n\t\t\t\t\t\tconst childStat = resolveMetadata ? await provider.stat(childResource) : { type };\n\n\t\t\t\t\t\treturn await this.toFileStat(provider, childResource, childStat, entries.length, resolveMetadata, recurse);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\t\t\treturn null; // can happen e.g. due to permission errors\n\t\t\t\t\t}\n\t\t\t\t}));\n\n\t\t\t\t// make sure to get rid of null values that signal a failure to resolve a particular entry\n\t\t\t\tfileStat.children = coalesce(resolvedEntries);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\tfileStat.children = []; // gracefully handle errors, we may not have permissions to read\n\t\t\t}\n\n\t\t\treturn fileStat;\n\t\t}\n\n\t\treturn Promise.resolve(fileStat);\n\t}\n\n\tasync resolveFiles(toResolve: { resource: URI, options?: IResolveFileOptions }[]): Promise<IResolveFileResult[]>;\n\tasync resolveFiles(toResolve: { resource: URI, options: IResolveMetadataFileOptions }[]): Promise<IResolveFileResultWithMetadata[]>;\n\tasync resolveFiles(toResolve: { resource: URI; options?: IResolveFileOptions; }[]): Promise<IResolveFileResult[]> {\n\t\treturn Promise.all(toResolve.map(async entry => {\n\t\t\ttry {\n\t\t\t\treturn { stat: await this.doResolveFile(entry.resource, entry.options), success: true };\n\t\t\t} catch (error) {\n\t\t\t\tthis.logService.trace(error);\n\n\t\t\t\treturn { stat: undefined, success: false };\n\t\t\t}\n\t\t}));\n\t}\n\n\tasync existsFile(resource: URI): Promise<boolean> {\n\t\ttry {\n\t\t\treturn !!(await this.resolveFile(resource));\n\t\t} catch (error) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region File Reading/Writing\n\n\tget encoding(): IResourceEncodings {\n\t\tif (!this._legacy) {\n\t\t\tthrow new Error('Legacy file service not ready yet');\n\t\t}\n\n\t\treturn this._legacy.encoding;\n\t}\n\n\tasync createFile(resource: URI, content?: string, options?: ICreateFileOptions): Promise<IFileStatWithMetadata> {\n\t\tconst useLegacy = true; // can only disable this when encoding is sorted out\n\t\tif (useLegacy) {\n\t\t\treturn this.joinOnLegacy.then(legacy => legacy.createFile(resource, content, options));\n\t\t}\n\n\t\tconst provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource));\n\n\t\t// validate overwrite\n\t\tconst overwrite = !!(options && options.overwrite);\n\t\tif (await this.existsFile(resource)) {\n\t\t\tif (!overwrite) {\n\t\t\t\tthrow new FileOperationError(localize('fileExists', \"File to create already exists ({0})\", resource.toString(true)), FileOperationResult.FILE_MODIFIED_SINCE, options);\n\t\t\t}\n\n\t\t\t// delete otherwise\n\t\t\tawait this.del(resource, { recursive: true });\n\t\t}\n\n\t\ttry {\n\n\t\t\t// mkdir recursively\n\t\t\tawait this.mkdirp(provider, dirname(resource));\n\n\t\t\t// create file: buffered\n\t\t\tif (hasOpenReadWriteCloseCapability(provider)) {\n\t\t\t\tawait this.doWriteBuffered(provider, resource, new TextEncoder().encode(content));\n\t\t\t}\n\n\t\t\t// create file: unbuffered\n\t\t\telse if (hasReadWriteCapability(provider)) {\n\t\t\t\tawait this.doWriteUnbuffered(provider, resource, new TextEncoder().encode(content), overwrite);\n\t\t\t}\n\n\t\t\t// give up if provider has insufficient capabilities\n\t\t\telse {\n\t\t\t\treturn Promise.reject('Provider neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed to support creating a file.');\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow new FileOperationError(localize('err.create', \"Failed to create file {0}\", resource.toString(false)), toFileOperationResult(error), options);\n\t\t}\n\n\t\t// events\n\t\tconst fileStat = await this.resolveFile(resource, { resolveMetadata: true });\n\t\tthis._onAfterOperation.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tresolveContent(resource: URI, options?: IResolveContentOptions): Promise<IContent> {\n\t\treturn this.joinOnLegacy.then(legacy => legacy.resolveContent(resource, options));\n\t}\n\n\tresolveStreamContent(resource: URI, options?: IResolveContentOptions): Promise<IStreamContent> {\n\t\treturn this.joinOnLegacy.then(legacy => legacy.resolveStreamContent(resource, options));\n\t}\n\n\tupdateContent(resource: URI, value: string | ITextSnapshot, options?: IUpdateContentOptions): Promise<IFileStatWithMetadata> {\n\t\treturn this.joinOnLegacy.then(legacy => legacy.updateContent(resource, value, options));\n\t}\n\n\t//#endregion\n\n\t//#region Move/Copy/Delete/Create Folder\n\n\tasync moveFile(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata> {\n\t\tconst sourceProvider = this.throwIfFileSystemIsReadonly(await this.withProvider(source));\n\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withProvider(target));\n\n\t\t// move\n\t\tconst mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'move', overwrite);\n\n\t\t// resolve and send events\n\t\tconst fileStat = await this.resolveFile(target, { resolveMetadata: true });\n\t\tthis._onAfterOperation.fire(new FileOperationEvent(source, mode === 'move' ? FileOperation.MOVE : FileOperation.COPY, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tasync copyFile(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata> {\n\t\tconst sourceProvider = await this.withProvider(source);\n\t\tconst targetProvider = this.throwIfFileSystemIsReadonly(await this.withProvider(target));\n\n\t\t// copy\n\t\tconst mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', overwrite);\n\n\t\t// resolve and send events\n\t\tconst fileStat = await this.resolveFile(target, { resolveMetadata: true });\n\t\tthis._onAfterOperation.fire(new FileOperationEvent(source, mode === 'copy' ? FileOperation.COPY : FileOperation.MOVE, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tprivate async doMoveCopy(sourceProvider: IFileSystemProvider, source: URI, targetProvider: IFileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<'move' | 'copy'> {\n\n\t\t// validation\n\t\tconst { exists, isCaseChange } = await this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, overwrite);\n\n\t\t// delete as needed\n\t\tif (exists && !isCaseChange && overwrite) {\n\t\t\tawait this.del(target, { recursive: true });\n\t\t}\n\n\t\t// create parent folders\n\t\tawait this.mkdirp(targetProvider, dirname(target));\n\n\t\t// copy source => target\n\t\tif (mode === 'copy') {\n\n\t\t\t// same provider with fast copy: leverage copy() functionality\n\t\t\tif (sourceProvider === targetProvider && hasFileFolderCopyCapability(sourceProvider)) {\n\t\t\t\treturn sourceProvider.copy(source, target, { overwrite: !!overwrite }).then(() => mode);\n\t\t\t}\n\n\t\t\t// otherwise, ensure we got the capabilities to do this\n\t\t\tif (\n\t\t\t\t!(hasOpenReadWriteCloseCapability(sourceProvider) || hasReadWriteCapability(sourceProvider)) ||\n\t\t\t\t!(hasOpenReadWriteCloseCapability(targetProvider) || hasReadWriteCapability(targetProvider))\n\t\t\t) {\n\t\t\t\treturn Promise.reject('Provider neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed to support copy.');\n\t\t\t}\n\n\t\t\t// when copying via buffer/unbuffered, we have to manually\n\t\t\t// traverse the source if it is a folder and not a file\n\t\t\tconst sourceFile = await this.resolveFile(source);\n\t\t\tif (sourceFile.isDirectory) {\n\t\t\t\treturn this.doCopyFolder(sourceProvider, sourceFile, targetProvider, target, overwrite).then(() => mode);\n\t\t\t} else {\n\t\t\t\treturn this.doCopyFile(sourceProvider, source, targetProvider, target, overwrite).then(() => mode);\n\t\t\t}\n\t\t}\n\n\t\t// move source => target\n\t\telse {\n\n\t\t\t// same provider: leverage rename() functionality\n\t\t\tif (sourceProvider === targetProvider) {\n\t\t\t\treturn sourceProvider.rename(source, target, { overwrite: !!overwrite }).then(() => mode);\n\t\t\t}\n\n\t\t\t// across providers: copy to target & delete at source\n\t\t\telse {\n\t\t\t\tawait this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', overwrite);\n\n\t\t\t\treturn this.del(source, { recursive: true }).then(() => 'copy' as 'move' | 'copy');\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async doCopyFile(sourceProvider: IFileSystemProvider, source: URI, targetProvider: IFileSystemProvider, target: URI, overwrite?: boolean): Promise<void> {\n\n\t\t// copy: source (buffered) => target (buffered)\n\t\tif (hasOpenReadWriteCloseCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\n\t\t\treturn this.doPipeBuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\n\t\t// copy: source (buffered) => target (unbuffered)\n\t\tif (hasOpenReadWriteCloseCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\n\t\t\treturn this.doPipeBufferedToUnbuffered(sourceProvider, source, targetProvider, target, !!overwrite);\n\t\t}\n\n\t\t// copy: source (unbuffered) => target (buffered)\n\t\tif (hasReadWriteCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\n\t\t\treturn this.doPipeUnbufferedToBuffered(sourceProvider, source, targetProvider, target);\n\t\t}\n\n\t\t// copy: source (unbuffered) => target (unbuffered)\n\t\tif (hasReadWriteCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\n\t\t\treturn this.doPipeUnbuffered(sourceProvider, source, targetProvider, target, !!overwrite);\n\t\t}\n\t}\n\n\tprivate async doCopyFolder(sourceProvider: IFileSystemProvider, sourceFolder: IFileStat, targetProvider: IFileSystemProvider, targetFolder: URI, overwrite?: boolean): Promise<void> {\n\n\t\t// create folder in target\n\t\tawait targetProvider.mkdir(targetFolder);\n\n\t\t// create children in target\n\t\tif (Array.isArray(sourceFolder.children)) {\n\t\t\tawait Promise.all(sourceFolder.children.map(async sourceChild => {\n\t\t\t\tconst targetChild = joinPath(targetFolder, sourceChild.name);\n\t\t\t\tif (sourceChild.isDirectory) {\n\t\t\t\t\treturn this.doCopyFolder(sourceProvider, await this.resolveFile(sourceChild.resource), targetProvider, targetChild, overwrite);\n\t\t\t\t} else {\n\t\t\t\t\treturn this.doCopyFile(sourceProvider, sourceChild.resource, targetProvider, targetChild, overwrite);\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t}\n\n\tprivate async doValidateMoveCopy(sourceProvider: IFileSystemProvider, source: URI, targetProvider: IFileSystemProvider, target: URI, overwrite?: boolean): Promise<{ exists: boolean, isCaseChange: boolean }> {\n\t\tlet isCaseChange = false;\n\t\tlet isPathCaseSensitive = false;\n\n\t\t// Check if source is equal or parent to target (requires providers to be the same)\n\t\tif (sourceProvider === targetProvider) {\n\t\t\tconst isPathCaseSensitive = !!(sourceProvider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n\t\t\tisCaseChange = isPathCaseSensitive ? false : isEqual(source, target, true /* ignore case */);\n\t\t\tif (!isCaseChange && isEqualOrParent(target, source, !isPathCaseSensitive)) {\n\t\t\t\treturn Promise.reject(new Error(localize('unableToMoveCopyError1', \"Unable to move/copy when source path is equal or parent of target path\")));\n\t\t\t}\n\t\t}\n\n\t\t// Extra checks if target exists and this is not a rename\n\t\tconst exists = await this.existsFile(target);\n\t\tif (exists && !isCaseChange) {\n\n\t\t\t// Bail out if target exists and we are not about to overwrite\n\t\t\tif (!overwrite) {\n\t\t\t\tthrow new FileOperationError(localize('unableToMoveCopyError2', \"Unable to move/copy. File already exists at destination.\"), FileOperationResult.FILE_MOVE_CONFLICT);\n\t\t\t}\n\n\t\t\t// Special case: if the target is a parent of the source, we cannot delete\n\t\t\t// it as it would delete the source as well. In this case we have to throw\n\t\t\tif (sourceProvider === targetProvider && isEqualOrParent(source, target, !isPathCaseSensitive)) {\n\t\t\t\treturn Promise.reject(new Error(localize('unableToMoveCopyError3', \"Unable to move/copy. File would replace folder it is contained in.\")));\n\t\t\t}\n\t\t}\n\n\t\treturn { exists, isCaseChange };\n\t}\n\n\tasync createFolder(resource: URI): Promise<IFileStatWithMetadata> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource));\n\n\t\t// mkdir recursively\n\t\tawait this.mkdirp(provider, resource);\n\n\t\t// events\n\t\tconst fileStat = await this.resolveFile(resource, { resolveMetadata: true });\n\t\tthis._onAfterOperation.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\n\n\t\treturn fileStat;\n\t}\n\n\tprivate async mkdirp(provider: IFileSystemProvider, directory: URI): Promise<void> {\n\t\tconst directoriesToCreate: string[] = [];\n\n\t\t// mkdir until we reach root\n\t\twhile (!isEqual(directory, dirname(directory))) {\n\t\t\ttry {\n\t\t\t\tconst stat = await provider.stat(directory);\n\t\t\t\tif ((stat.type & FileType.Directory) === 0) {\n\t\t\t\t\tthrow new Error(localize('mkdirExistsError', \"{0} exists, but is not a directory\", directory.toString()));\n\t\t\t\t}\n\n\t\t\t\tbreak; // we have hit a directory that exists -> good\n\t\t\t} catch (error) {\n\n\t\t\t\t// Bubble up any other error that is not file not found\n\t\t\t\tif (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileNotFound) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\t// Upon error, remember directories that need to be created\n\t\t\t\tdirectoriesToCreate.push(basename(directory));\n\n\t\t\t\t// Continue up\n\t\t\t\tdirectory = dirname(directory);\n\t\t\t}\n\t\t}\n\n\t\t// Create directories as needed\n\t\tfor (let i = directoriesToCreate.length - 1; i >= 0; i--) {\n\t\t\tdirectory = joinPath(directory, directoriesToCreate[i]);\n\t\t\tawait provider.mkdir(directory);\n\t\t}\n\t}\n\n\tasync del(resource: URI, options?: { useTrash?: boolean; recursive?: boolean; }): Promise<void> {\n\t\tconst provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource));\n\n\t\t// Validate trash support\n\t\tconst useTrash = !!(options && options.useTrash);\n\t\tif (useTrash && !(provider.capabilities & FileSystemProviderCapabilities.Trash)) {\n\t\t\tthrow new Error(localize('err.trash', \"Provider does not support trash.\"));\n\t\t}\n\n\t\t// Validate recursive\n\t\tconst recursive = !!(options && options.recursive);\n\t\tif (!recursive && await this.existsFile(resource)) {\n\t\t\tconst stat = await this.resolveFile(resource);\n\t\t\tif (stat.isDirectory && Array.isArray(stat.children) && stat.children.length > 0) {\n\t\t\t\tthrow new Error(localize('deleteFailed', \"Failed to delete non-empty folder '{0}'.\", resource.toString()));\n\t\t\t}\n\t\t}\n\n\t\t// Delete through provider\n\t\tawait provider.delete(resource, { recursive, useTrash });\n\n\t\t// Events\n\t\tthis._onAfterOperation.fire(new FileOperationEvent(resource, FileOperation.DELETE));\n\t}\n\n\t//#endregion\n\n\t//#region File Watching\n\n\tprivate _onFileChanges: Emitter<FileChangesEvent> = this._register(new Emitter<FileChangesEvent>());\n\tget onFileChanges(): Event<FileChangesEvent> { return this._onFileChanges.event; }\n\n\twatchFileChanges(resource: URI): void {\n\t\tthis.joinOnLegacy.then(legacy => legacy.watchFileChanges(resource));\n\t}\n\n\tunwatchFileChanges(resource: URI): void {\n\t\tthis.joinOnLegacy.then(legacy => legacy.unwatchFileChanges(resource));\n\t}\n\n\t//#endregion\n\n\t//#region Helpers\n\n\tprivate async doWriteBuffered(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, buffer: Uint8Array): Promise<void> {\n\n\t\t// open handle\n\t\tconst handle = await provider.open(resource, { create: true });\n\n\t\t// write into handle until all bytes from buffer have been written\n\t\ttry {\n\t\t\tawait this.doWriteBuffer(provider, handle, buffer, buffer.byteLength, 0, 0);\n\t\t} catch (error) {\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tawait provider.close(handle);\n\t\t}\n\t}\n\n\tprivate async doWriteBuffer(provider: IFileSystemProviderWithOpenReadWriteCloseCapability, handle: number, buffer: Uint8Array, length: number, posInFile: number, posInBuffer: number): Promise<void> {\n\t\tlet totalBytesWritten = 0;\n\t\twhile (totalBytesWritten < length) {\n\t\t\tconst bytesWritten = await provider.write(handle, posInFile + totalBytesWritten, buffer, posInBuffer + totalBytesWritten, length - totalBytesWritten);\n\t\t\ttotalBytesWritten += bytesWritten;\n\t\t}\n\t}\n\n\tprivate async doWriteUnbuffered(provider: IFileSystemProviderWithFileReadWriteCapability, resource: URI, buffer: Uint8Array, overwrite: boolean): Promise<void> {\n\t\treturn provider.writeFile(resource, buffer, { create: true, overwrite });\n\t}\n\n\tprivate async doPipeBuffered(sourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\t\tlet sourceHandle: number | undefined = undefined;\n\t\tlet targetHandle: number | undefined = undefined;\n\n\t\ttry {\n\n\t\t\t// Open handles\n\t\t\tsourceHandle = await sourceProvider.open(source, { create: false });\n\t\t\ttargetHandle = await targetProvider.open(target, { create: true });\n\n\t\t\tconst buffer = new Uint8Array(16 * 1024);\n\n\t\t\tlet posInFile = 0;\n\t\t\tlet posInBuffer = 0;\n\t\t\tlet bytesRead = 0;\n\t\t\tdo {\n\t\t\t\t// read from source (sourceHandle) at current position (posInFile) into buffer (buffer) at\n\t\t\t\t// buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n\t\t\t\tbytesRead = await sourceProvider.read(sourceHandle, posInFile, buffer, posInBuffer, buffer.byteLength - posInBuffer);\n\n\t\t\t\t// write into target (targetHandle) at current position (posInFile) from buffer (buffer) at\n\t\t\t\t// buffer position (posInBuffer) all bytes we read (bytesRead).\n\t\t\t\tawait this.doWriteBuffer(targetProvider, targetHandle, buffer, bytesRead, posInFile, posInBuffer);\n\n\t\t\t\tposInFile += bytesRead;\n\t\t\t\tposInBuffer += bytesRead;\n\n\t\t\t\t// when buffer full, fill it again from the beginning\n\t\t\t\tif (posInBuffer === buffer.length) {\n\t\t\t\t\tposInBuffer = 0;\n\t\t\t\t}\n\t\t\t} while (bytesRead > 0);\n\t\t} catch (error) {\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tawait Promise.all([\n\t\t\t\ttypeof sourceHandle === 'number' ? sourceProvider.close(sourceHandle) : Promise.resolve(),\n\t\t\t\ttypeof targetHandle === 'number' ? targetProvider.close(targetHandle) : Promise.resolve(),\n\t\t\t]);\n\t\t}\n\t}\n\n\tprivate async doPipeUnbuffered(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithFileReadWriteCapability, target: URI, overwrite: boolean): Promise<void> {\n\t\treturn targetProvider.writeFile(target, await sourceProvider.readFile(source), { create: true, overwrite });\n\t}\n\n\tprivate async doPipeUnbufferedToBuffered(sourceProvider: IFileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\n\t\t// Open handle\n\t\tconst targetHandle = await targetProvider.open(target, { create: true });\n\n\t\t// Read entire buffer from source and write buffered\n\t\ttry {\n\t\t\tconst buffer = await sourceProvider.readFile(source);\n\t\t\tawait this.doWriteBuffer(targetProvider, targetHandle, buffer, buffer.byteLength, 0, 0);\n\t\t} catch (error) {\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tawait targetProvider.close(targetHandle);\n\t\t}\n\t}\n\n\tprivate async doPipeBufferedToUnbuffered(sourceProvider: IFileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: IFileSystemProviderWithFileReadWriteCapability, target: URI, overwrite: boolean): Promise<void> {\n\n\t\t// Determine file size\n\t\tconst size = (await this.resolveFile(source, { resolveMetadata: true })).size;\n\n\t\t// Open handle\n\t\tconst sourceHandle = await sourceProvider.open(source, { create: false });\n\n\t\ttry {\n\t\t\tconst buffer = new Uint8Array(size);\n\n\t\t\tlet pos = 0;\n\t\t\tlet bytesRead = 0;\n\t\t\tdo {\n\t\t\t\t// read from source (sourceHandle) at current position (posInFile) into buffer (buffer) at\n\t\t\t\t// buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n\t\t\t\tbytesRead = await sourceProvider.read(sourceHandle, pos, buffer, pos, buffer.byteLength - pos);\n\n\t\t\t\tpos += bytesRead;\n\t\t\t} while (bytesRead > 0 && pos < size);\n\n\t\t\t// Write buffer into target at once\n\t\t\tawait this.doWriteUnbuffered(targetProvider, target, buffer, overwrite);\n\t\t} catch (error) {\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tawait sourceProvider.close(sourceHandle);\n\t\t}\n\t}\n\n\tprivate throwIfFileSystemIsReadonly(provider: IFileSystemProvider): IFileSystemProvider {\n\t\tif (provider.capabilities & FileSystemProviderCapabilities.Readonly) {\n\t\t\tthrow new FileOperationError(localize('err.readonly', \"Resource can not be modified.\"), FileOperationResult.FILE_PERMISSION_DENIED);\n\t\t}\n\n\t\treturn provider;\n\t}\n\n\t//#endregion\n}"]}]}