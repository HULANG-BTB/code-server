{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/browser/viewParts/lines/viewLines.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/browser/viewParts/lines/viewLines.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nrequire(\"vs/css!./viewLines\");\nvar async_1 = require(\"vs/base/common/async\");\nvar configuration_1 = require(\"vs/editor/browser/config/configuration\");\nvar viewLayer_1 = require(\"vs/editor/browser/view/viewLayer\");\nvar viewPart_1 = require(\"vs/editor/browser/view/viewPart\");\nvar viewLine_1 = require(\"vs/editor/browser/viewParts/lines/viewLine\");\nvar position_1 = require(\"vs/editor/common/core/position\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar editorCommon_1 = require(\"vs/editor/common/editorCommon\");\nvar renderingContext_1 = require(\"vs/editor/common/view/renderingContext\");\nvar viewEvents = require(\"vs/editor/common/view/viewEvents\");\nvar LastRenderedData = /** @class */ (function () {\n    function LastRenderedData() {\n        this._currentVisibleRange = new range_1.Range(1, 1, 1, 1);\n    }\n    LastRenderedData.prototype.getCurrentVisibleRange = function () {\n        return this._currentVisibleRange;\n    };\n    LastRenderedData.prototype.setCurrentVisibleRange = function (currentVisibleRange) {\n        this._currentVisibleRange = currentVisibleRange;\n    };\n    return LastRenderedData;\n}());\nvar HorizontalRevealRequest = /** @class */ (function () {\n    function HorizontalRevealRequest(lineNumber, startColumn, endColumn, startScrollTop, stopScrollTop, scrollType) {\n        this.lineNumber = lineNumber;\n        this.startColumn = startColumn;\n        this.endColumn = endColumn;\n        this.startScrollTop = startScrollTop;\n        this.stopScrollTop = stopScrollTop;\n        this.scrollType = scrollType;\n    }\n    return HorizontalRevealRequest;\n}());\nvar ViewLines = /** @class */ (function (_super) {\n    tslib_1.__extends(ViewLines, _super);\n    function ViewLines(context, linesContent) {\n        var _this = _super.call(this, context) || this;\n        _this._linesContent = linesContent;\n        _this._textRangeRestingSpot = document.createElement('div');\n        _this._visibleLines = new viewLayer_1.VisibleLinesCollection(_this);\n        _this.domNode = _this._visibleLines.domNode;\n        var conf = _this._context.configuration;\n        _this._lineHeight = conf.editor.lineHeight;\n        _this._typicalHalfwidthCharacterWidth = conf.editor.fontInfo.typicalHalfwidthCharacterWidth;\n        _this._isViewportWrapping = conf.editor.wrappingInfo.isViewportWrapping;\n        _this._revealHorizontalRightPadding = conf.editor.viewInfo.revealHorizontalRightPadding;\n        _this._canUseLayerHinting = conf.editor.canUseLayerHinting;\n        _this._viewLineOptions = new viewLine_1.ViewLineOptions(conf, _this._context.theme.type);\n        viewPart_1.PartFingerprints.write(_this.domNode, viewPart_1.PartFingerprint.ViewLines);\n        _this.domNode.setClassName('view-lines');\n        configuration_1.Configuration.applyFontInfo(_this.domNode, conf.editor.fontInfo);\n        // --- width & height\n        _this._maxLineWidth = 0;\n        _this._asyncUpdateLineWidths = new async_1.RunOnceScheduler(function () {\n            _this._updateLineWidthsSlow();\n        }, 200);\n        _this._lastRenderedData = new LastRenderedData();\n        _this._horizontalRevealRequest = null;\n        return _this;\n    }\n    ViewLines.prototype.dispose = function () {\n        this._asyncUpdateLineWidths.dispose();\n        _super.prototype.dispose.call(this);\n    };\n    ViewLines.prototype.getDomNode = function () {\n        return this.domNode;\n    };\n    // ---- begin IVisibleLinesHost\n    ViewLines.prototype.createVisibleLine = function () {\n        return new viewLine_1.ViewLine(this._viewLineOptions);\n    };\n    // ---- end IVisibleLinesHost\n    // ---- begin view event handlers\n    ViewLines.prototype.onConfigurationChanged = function (e) {\n        this._visibleLines.onConfigurationChanged(e);\n        if (e.wrappingInfo) {\n            this._maxLineWidth = 0;\n        }\n        var conf = this._context.configuration;\n        if (e.lineHeight) {\n            this._lineHeight = conf.editor.lineHeight;\n        }\n        if (e.fontInfo) {\n            this._typicalHalfwidthCharacterWidth = conf.editor.fontInfo.typicalHalfwidthCharacterWidth;\n        }\n        if (e.wrappingInfo) {\n            this._isViewportWrapping = conf.editor.wrappingInfo.isViewportWrapping;\n        }\n        if (e.viewInfo) {\n            this._revealHorizontalRightPadding = conf.editor.viewInfo.revealHorizontalRightPadding;\n        }\n        if (e.canUseLayerHinting) {\n            this._canUseLayerHinting = conf.editor.canUseLayerHinting;\n        }\n        if (e.fontInfo) {\n            configuration_1.Configuration.applyFontInfo(this.domNode, conf.editor.fontInfo);\n        }\n        this._onOptionsMaybeChanged();\n        if (e.layoutInfo) {\n            this._maxLineWidth = 0;\n        }\n        return true;\n    };\n    ViewLines.prototype._onOptionsMaybeChanged = function () {\n        var conf = this._context.configuration;\n        var newViewLineOptions = new viewLine_1.ViewLineOptions(conf, this._context.theme.type);\n        if (!this._viewLineOptions.equals(newViewLineOptions)) {\n            this._viewLineOptions = newViewLineOptions;\n            var startLineNumber = this._visibleLines.getStartLineNumber();\n            var endLineNumber = this._visibleLines.getEndLineNumber();\n            for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n                var line = this._visibleLines.getVisibleLine(lineNumber);\n                line.onOptionsChanged(this._viewLineOptions);\n            }\n            return true;\n        }\n        return false;\n    };\n    ViewLines.prototype.onCursorStateChanged = function (e) {\n        var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        var r = false;\n        for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n            r = this._visibleLines.getVisibleLine(lineNumber).onSelectionChanged() || r;\n        }\n        return r;\n    };\n    ViewLines.prototype.onDecorationsChanged = function (e) {\n        if (true /*e.inlineDecorationsChanged*/) {\n            var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n            var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n            for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n                this._visibleLines.getVisibleLine(lineNumber).onDecorationsChanged();\n            }\n        }\n        return true;\n    };\n    ViewLines.prototype.onFlushed = function (e) {\n        var shouldRender = this._visibleLines.onFlushed(e);\n        this._maxLineWidth = 0;\n        return shouldRender;\n    };\n    ViewLines.prototype.onLinesChanged = function (e) {\n        return this._visibleLines.onLinesChanged(e);\n    };\n    ViewLines.prototype.onLinesDeleted = function (e) {\n        return this._visibleLines.onLinesDeleted(e);\n    };\n    ViewLines.prototype.onLinesInserted = function (e) {\n        return this._visibleLines.onLinesInserted(e);\n    };\n    ViewLines.prototype.onRevealRangeRequest = function (e) {\n        // Using the future viewport here in order to handle multiple\n        // incoming reveal range requests that might all desire to be animated\n        var desiredScrollTop = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.range, e.verticalType);\n        // validate the new desired scroll top\n        var newScrollPosition = this._context.viewLayout.validateScrollPosition({ scrollTop: desiredScrollTop });\n        if (e.revealHorizontal) {\n            if (e.range.startLineNumber !== e.range.endLineNumber) {\n                // Two or more lines? => scroll to base (That's how you see most of the two lines)\n                newScrollPosition = {\n                    scrollTop: newScrollPosition.scrollTop,\n                    scrollLeft: 0\n                };\n            }\n            else {\n                // We don't necessarily know the horizontal offset of this range since the line might not be in the view...\n                this._horizontalRevealRequest = new HorizontalRevealRequest(e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\n            }\n        }\n        else {\n            this._horizontalRevealRequest = null;\n        }\n        var scrollTopDelta = Math.abs(this._context.viewLayout.getCurrentScrollTop() - newScrollPosition.scrollTop);\n        if (e.scrollType === editorCommon_1.ScrollType.Smooth && scrollTopDelta > this._lineHeight) {\n            this._context.viewLayout.setScrollPositionSmooth(newScrollPosition);\n        }\n        else {\n            this._context.viewLayout.setScrollPositionNow(newScrollPosition);\n        }\n        return true;\n    };\n    ViewLines.prototype.onScrollChanged = function (e) {\n        if (this._horizontalRevealRequest && e.scrollLeftChanged) {\n            // cancel any outstanding horizontal reveal request if someone else scrolls horizontally.\n            this._horizontalRevealRequest = null;\n        }\n        if (this._horizontalRevealRequest && e.scrollTopChanged) {\n            var min = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n            var max = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n            if (e.scrollTop < min || e.scrollTop > max) {\n                // cancel any outstanding horizontal reveal request if someone else scrolls vertically.\n                this._horizontalRevealRequest = null;\n            }\n        }\n        this.domNode.setWidth(e.scrollWidth);\n        return this._visibleLines.onScrollChanged(e) || true;\n    };\n    ViewLines.prototype.onTokensChanged = function (e) {\n        return this._visibleLines.onTokensChanged(e);\n    };\n    ViewLines.prototype.onZonesChanged = function (e) {\n        this._context.viewLayout.onMaxLineWidthChanged(this._maxLineWidth);\n        return this._visibleLines.onZonesChanged(e);\n    };\n    ViewLines.prototype.onThemeChanged = function (e) {\n        return this._onOptionsMaybeChanged();\n    };\n    // ---- end view event handlers\n    // ----------- HELPERS FOR OTHERS\n    ViewLines.prototype.getPositionFromDOMInfo = function (spanNode, offset) {\n        var viewLineDomNode = this._getViewLineDomNode(spanNode);\n        if (viewLineDomNode === null) {\n            // Couldn't find view line node\n            return null;\n        }\n        var lineNumber = this._getLineNumberFor(viewLineDomNode);\n        if (lineNumber === -1) {\n            // Couldn't find view line node\n            return null;\n        }\n        if (lineNumber < 1 || lineNumber > this._context.model.getLineCount()) {\n            // lineNumber is outside range\n            return null;\n        }\n        if (this._context.model.getLineMaxColumn(lineNumber) === 1) {\n            // Line is empty\n            return new position_1.Position(lineNumber, 1);\n        }\n        var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n            // Couldn't find line\n            return null;\n        }\n        var column = this._visibleLines.getVisibleLine(lineNumber).getColumnOfNodeOffset(lineNumber, spanNode, offset);\n        var minColumn = this._context.model.getLineMinColumn(lineNumber);\n        if (column < minColumn) {\n            column = minColumn;\n        }\n        return new position_1.Position(lineNumber, column);\n    };\n    ViewLines.prototype._getViewLineDomNode = function (node) {\n        while (node && node.nodeType === 1) {\n            if (node.className === viewLine_1.ViewLine.CLASS_NAME) {\n                return node;\n            }\n            node = node.parentElement;\n        }\n        return null;\n    };\n    /**\n     * @returns the line number of this view line dom node.\n     */\n    ViewLines.prototype._getLineNumberFor = function (domNode) {\n        var startLineNumber = this._visibleLines.getStartLineNumber();\n        var endLineNumber = this._visibleLines.getEndLineNumber();\n        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            var line = this._visibleLines.getVisibleLine(lineNumber);\n            if (domNode === line.getDomNode()) {\n                return lineNumber;\n            }\n        }\n        return -1;\n    };\n    ViewLines.prototype.getLineWidth = function (lineNumber) {\n        var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n            // Couldn't find line\n            return -1;\n        }\n        return this._visibleLines.getVisibleLine(lineNumber).getWidth();\n    };\n    ViewLines.prototype.linesVisibleRangesForRange = function (_range, includeNewLines) {\n        if (this.shouldRender()) {\n            // Cannot read from the DOM because it is dirty\n            // i.e. the model & the dom are out of sync, so I'd be reading something stale\n            return null;\n        }\n        var originalEndLineNumber = _range.endLineNumber;\n        var range = range_1.Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());\n        if (!range) {\n            return null;\n        }\n        var visibleRanges = [], visibleRangesLen = 0;\n        var domReadingContext = new viewLine_1.DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\n        var nextLineModelLineNumber = 0;\n        if (includeNewLines) {\n            nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new position_1.Position(range.startLineNumber, 1)).lineNumber;\n        }\n        var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        for (var lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n            if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n                continue;\n            }\n            var startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\n            var endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);\n            var visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);\n            if (!visibleRangesForLine || visibleRangesForLine.length === 0) {\n                continue;\n            }\n            if (includeNewLines && lineNumber < originalEndLineNumber) {\n                var currentLineModelLineNumber = nextLineModelLineNumber;\n                nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new position_1.Position(lineNumber + 1, 1)).lineNumber;\n                if (currentLineModelLineNumber !== nextLineModelLineNumber) {\n                    visibleRangesForLine[visibleRangesForLine.length - 1].width += this._typicalHalfwidthCharacterWidth;\n                }\n            }\n            visibleRanges[visibleRangesLen++] = new renderingContext_1.LineVisibleRanges(lineNumber, visibleRangesForLine);\n        }\n        if (visibleRangesLen === 0) {\n            return null;\n        }\n        return visibleRanges;\n    };\n    ViewLines.prototype.visibleRangesForRange2 = function (_range) {\n        if (this.shouldRender()) {\n            // Cannot read from the DOM because it is dirty\n            // i.e. the model & the dom are out of sync, so I'd be reading something stale\n            return null;\n        }\n        var range = range_1.Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());\n        if (!range) {\n            return null;\n        }\n        var result = [];\n        var domReadingContext = new viewLine_1.DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\n        var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        for (var lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n            if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n                continue;\n            }\n            var startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\n            var endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);\n            var visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);\n            if (!visibleRangesForLine || visibleRangesForLine.length === 0) {\n                continue;\n            }\n            result = result.concat(visibleRangesForLine);\n        }\n        if (result.length === 0) {\n            return null;\n        }\n        return result;\n    };\n    ViewLines.prototype.visibleRangeForPosition = function (position) {\n        var visibleRanges = this.visibleRangesForRange2(new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column));\n        if (!visibleRanges) {\n            return null;\n        }\n        return visibleRanges[0];\n    };\n    // --- implementation\n    ViewLines.prototype.updateLineWidths = function () {\n        this._updateLineWidths(false);\n    };\n    /**\n     * Updates the max line width if it is fast to compute.\n     * Returns true if all lines were taken into account.\n     * Returns false if some lines need to be reevaluated (in a slow fashion).\n     */\n    ViewLines.prototype._updateLineWidthsFast = function () {\n        return this._updateLineWidths(true);\n    };\n    ViewLines.prototype._updateLineWidthsSlow = function () {\n        this._updateLineWidths(false);\n    };\n    ViewLines.prototype._updateLineWidths = function (fast) {\n        var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        var localMaxLineWidth = 1;\n        var allWidthsComputed = true;\n        for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n            var visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n            if (fast && !visibleLine.getWidthIsFast()) {\n                // Cannot compute width in a fast way for this line\n                allWidthsComputed = false;\n                continue;\n            }\n            localMaxLineWidth = Math.max(localMaxLineWidth, visibleLine.getWidth());\n        }\n        if (allWidthsComputed && rendStartLineNumber === 1 && rendEndLineNumber === this._context.model.getLineCount()) {\n            // we know the max line width for all the lines\n            this._maxLineWidth = 0;\n        }\n        this._ensureMaxLineWidth(localMaxLineWidth);\n        return allWidthsComputed;\n    };\n    ViewLines.prototype.prepareRender = function () {\n        throw new Error('Not supported');\n    };\n    ViewLines.prototype.render = function () {\n        throw new Error('Not supported');\n    };\n    ViewLines.prototype.renderText = function (viewportData) {\n        // (1) render lines - ensures lines are in the DOM\n        this._visibleLines.renderLines(viewportData);\n        this._lastRenderedData.setCurrentVisibleRange(viewportData.visibleRange);\n        this.domNode.setWidth(this._context.viewLayout.getScrollWidth());\n        this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1000000));\n        // (2) compute horizontal scroll position:\n        //  - this must happen after the lines are in the DOM since it might need a line that rendered just now\n        //  - it might change `scrollWidth` and `scrollLeft`\n        if (this._horizontalRevealRequest) {\n            var revealLineNumber = this._horizontalRevealRequest.lineNumber;\n            var revealStartColumn = this._horizontalRevealRequest.startColumn;\n            var revealEndColumn = this._horizontalRevealRequest.endColumn;\n            var scrollType = this._horizontalRevealRequest.scrollType;\n            // Check that we have the line that contains the horizontal range in the viewport\n            if (viewportData.startLineNumber <= revealLineNumber && revealLineNumber <= viewportData.endLineNumber) {\n                this._horizontalRevealRequest = null;\n                // allow `visibleRangesForRange2` to work\n                this.onDidRender();\n                // compute new scroll position\n                var newScrollLeft = this._computeScrollLeftToRevealRange(revealLineNumber, revealStartColumn, revealEndColumn);\n                var isViewportWrapping = this._isViewportWrapping;\n                if (!isViewportWrapping) {\n                    // ensure `scrollWidth` is large enough\n                    this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);\n                }\n                // set `scrollLeft`\n                if (scrollType === editorCommon_1.ScrollType.Smooth) {\n                    this._context.viewLayout.setScrollPositionSmooth({\n                        scrollLeft: newScrollLeft.scrollLeft\n                    });\n                }\n                else {\n                    this._context.viewLayout.setScrollPositionNow({\n                        scrollLeft: newScrollLeft.scrollLeft\n                    });\n                }\n            }\n        }\n        // Update max line width (not so important, it is just so the horizontal scrollbar doesn't get too small)\n        if (!this._updateLineWidthsFast()) {\n            // Computing the width of some lines would be slow => delay it\n            this._asyncUpdateLineWidths.schedule();\n        }\n        // (3) handle scrolling\n        this._linesContent.setLayerHinting(this._canUseLayerHinting);\n        var adjustedScrollTop = this._context.viewLayout.getCurrentScrollTop() - viewportData.bigNumbersDelta;\n        this._linesContent.setTop(-adjustedScrollTop);\n        this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());\n    };\n    // --- width\n    ViewLines.prototype._ensureMaxLineWidth = function (lineWidth) {\n        var iLineWidth = Math.ceil(lineWidth);\n        if (this._maxLineWidth < iLineWidth) {\n            this._maxLineWidth = iLineWidth;\n            this._context.viewLayout.onMaxLineWidthChanged(this._maxLineWidth);\n        }\n    };\n    ViewLines.prototype._computeScrollTopToRevealRange = function (viewport, range, verticalType) {\n        var viewportStartY = viewport.top;\n        var viewportHeight = viewport.height;\n        var viewportEndY = viewportStartY + viewportHeight;\n        var boxStartY;\n        var boxEndY;\n        // Have a box that includes one extra line height (for the horizontal scrollbar)\n        boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.startLineNumber);\n        boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.endLineNumber) + this._lineHeight;\n        if (verticalType === viewEvents.VerticalRevealType.Simple || verticalType === viewEvents.VerticalRevealType.Bottom) {\n            // Reveal one line more when the last line would be covered by the scrollbar - arrow down case or revealing a line explicitly at bottom\n            boxEndY += this._lineHeight;\n        }\n        var newScrollTop;\n        if (verticalType === viewEvents.VerticalRevealType.Center || verticalType === viewEvents.VerticalRevealType.CenterIfOutsideViewport) {\n            if (verticalType === viewEvents.VerticalRevealType.CenterIfOutsideViewport && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\n                // Box is already in the viewport... do nothing\n                newScrollTop = viewportStartY;\n            }\n            else {\n                // Box is outside the viewport... center it\n                var boxMiddleY = (boxStartY + boxEndY) / 2;\n                newScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);\n            }\n        }\n        else {\n            newScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY, verticalType === viewEvents.VerticalRevealType.Top, verticalType === viewEvents.VerticalRevealType.Bottom);\n        }\n        return newScrollTop;\n    };\n    ViewLines.prototype._computeScrollLeftToRevealRange = function (lineNumber, startColumn, endColumn) {\n        var maxHorizontalOffset = 0;\n        var viewport = this._context.viewLayout.getCurrentViewport();\n        var viewportStartX = viewport.left;\n        var viewportEndX = viewportStartX + viewport.width;\n        var visibleRanges = this.visibleRangesForRange2(new range_1.Range(lineNumber, startColumn, lineNumber, endColumn));\n        var boxStartX = Number.MAX_VALUE;\n        var boxEndX = 0;\n        if (!visibleRanges) {\n            // Unknown\n            return {\n                scrollLeft: viewportStartX,\n                maxHorizontalOffset: maxHorizontalOffset\n            };\n        }\n        for (var _i = 0, visibleRanges_1 = visibleRanges; _i < visibleRanges_1.length; _i++) {\n            var visibleRange = visibleRanges_1[_i];\n            if (visibleRange.left < boxStartX) {\n                boxStartX = visibleRange.left;\n            }\n            if (visibleRange.left + visibleRange.width > boxEndX) {\n                boxEndX = visibleRange.left + visibleRange.width;\n            }\n        }\n        maxHorizontalOffset = boxEndX;\n        boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);\n        boxEndX += this._revealHorizontalRightPadding;\n        var newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);\n        return {\n            scrollLeft: newScrollLeft,\n            maxHorizontalOffset: maxHorizontalOffset\n        };\n    };\n    ViewLines.prototype._computeMinimumScrolling = function (viewportStart, viewportEnd, boxStart, boxEnd, revealAtStart, revealAtEnd) {\n        viewportStart = viewportStart | 0;\n        viewportEnd = viewportEnd | 0;\n        boxStart = boxStart | 0;\n        boxEnd = boxEnd | 0;\n        revealAtStart = !!revealAtStart;\n        revealAtEnd = !!revealAtEnd;\n        var viewportLength = viewportEnd - viewportStart;\n        var boxLength = boxEnd - boxStart;\n        if (boxLength < viewportLength) {\n            // The box would fit in the viewport\n            if (revealAtStart) {\n                return boxStart;\n            }\n            if (revealAtEnd) {\n                return Math.max(0, boxEnd - viewportLength);\n            }\n            if (boxStart < viewportStart) {\n                // The box is above the viewport\n                return boxStart;\n            }\n            else if (boxEnd > viewportEnd) {\n                // The box is below the viewport\n                return Math.max(0, boxEnd - viewportLength);\n            }\n        }\n        else {\n            // The box would not fit in the viewport\n            // Reveal the beginning of the box\n            return boxStart;\n        }\n        return viewportStart;\n    };\n    /**\n     * Adds this amount of pixels to the right of lines (no-one wants to type near the edge of the viewport)\n     */\n    ViewLines.HORIZONTAL_EXTRA_PX = 30;\n    return ViewLines;\n}(viewPart_1.ViewPart));\nexports.ViewLines = ViewLines;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/browser/viewParts/lines/viewLines.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/browser/viewParts/lines/viewLines.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;;AAEhG,8BAA4B;AAE5B,8CAAwD;AACxD,wEAAuE;AACvE,8DAA6F;AAC7F,4DAA8F;AAC9F,uEAA0G;AAC1G,2DAA0D;AAC1D,qDAAoD;AACpD,8DAA2D;AAC3D,2EAAwG;AAExG,6DAA+D;AAI/D;IAIC;QACC,IAAI,CAAC,oBAAoB,GAAG,IAAI,aAAK,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IACnD,CAAC;IAEM,iDAAsB,GAA7B;QACC,OAAO,IAAI,CAAC,oBAAoB,CAAC;IAClC,CAAC;IAEM,iDAAsB,GAA7B,UAA8B,mBAA0B;QACvD,IAAI,CAAC,oBAAoB,GAAG,mBAAmB,CAAC;IACjD,CAAC;IACF,uBAAC;AAAD,CAAC,AAfD,IAeC;AAED;IASC,iCAAY,UAAkB,EAAE,WAAmB,EAAE,SAAiB,EAAE,cAAsB,EAAE,aAAqB,EAAE,UAAsB;QAC5I,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;QACrC,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;QACnC,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;IAC9B,CAAC;IACF,8BAAC;AAAD,CAAC,AAjBD,IAiBC;AAED;IAA+B,qCAAQ;IA0BtC,mBAAY,OAAoB,EAAE,YAAsC;QAAxE,YACC,kBAAM,OAAO,CAAC,SA4Bd;QA3BA,KAAI,CAAC,aAAa,GAAG,YAAY,CAAC;QAClC,KAAI,CAAC,qBAAqB,GAAG,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;QAC3D,KAAI,CAAC,aAAa,GAAG,IAAI,kCAAsB,CAAC,KAAI,CAAC,CAAC;QACtD,KAAI,CAAC,OAAO,GAAG,KAAI,CAAC,aAAa,CAAC,OAAO,CAAC;QAE1C,IAAM,IAAI,GAAG,KAAI,CAAC,QAAQ,CAAC,aAAa,CAAC;QAEzC,KAAI,CAAC,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC;QAC1C,KAAI,CAAC,+BAA+B,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,8BAA8B,CAAC;QAC3F,KAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,kBAAkB,CAAC;QACvE,KAAI,CAAC,6BAA6B,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,4BAA4B,CAAC;QACvF,KAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,MAAM,CAAC,kBAAkB,CAAC;QAC1D,KAAI,CAAC,gBAAgB,GAAG,IAAI,0BAAe,CAAC,IAAI,EAAE,KAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAE5E,2BAAgB,CAAC,KAAK,CAAC,KAAI,CAAC,OAAO,EAAE,0BAAe,CAAC,SAAS,CAAC,CAAC;QAChE,KAAI,CAAC,OAAO,CAAC,YAAY,CAAC,YAAY,CAAC,CAAC;QACxC,6BAAa,CAAC,aAAa,CAAC,KAAI,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAEhE,qBAAqB;QACrB,KAAI,CAAC,aAAa,GAAG,CAAC,CAAC;QACvB,KAAI,CAAC,sBAAsB,GAAG,IAAI,wBAAgB,CAAC;YAClD,KAAI,CAAC,qBAAqB,EAAE,CAAC;QAC9B,CAAC,EAAE,GAAG,CAAC,CAAC;QAER,KAAI,CAAC,iBAAiB,GAAG,IAAI,gBAAgB,EAAE,CAAC;QAEhD,KAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC;;IACtC,CAAC;IAEM,2BAAO,GAAd;QACC,IAAI,CAAC,sBAAsB,CAAC,OAAO,EAAE,CAAC;QACtC,iBAAM,OAAO,WAAE,CAAC;IACjB,CAAC;IAEM,8BAAU,GAAjB;QACC,OAAO,IAAI,CAAC,OAAO,CAAC;IACrB,CAAC;IAED,+BAA+B;IAExB,qCAAiB,GAAxB;QACC,OAAO,IAAI,mBAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IAC5C,CAAC;IAED,6BAA6B;IAE7B,iCAAiC;IAE1B,0CAAsB,GAA7B,UAA8B,CAA2C;QACxE,IAAI,CAAC,aAAa,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC;QAC7C,IAAI,CAAC,CAAC,YAAY,EAAE;YACnB,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;SACvB;QAED,IAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC;QAEzC,IAAI,CAAC,CAAC,UAAU,EAAE;YACjB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC;SAC1C;QACD,IAAI,CAAC,CAAC,QAAQ,EAAE;YACf,IAAI,CAAC,+BAA+B,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,8BAA8B,CAAC;SAC3F;QACD,IAAI,CAAC,CAAC,YAAY,EAAE;YACnB,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,kBAAkB,CAAC;SACvE;QACD,IAAI,CAAC,CAAC,QAAQ,EAAE;YACf,IAAI,CAAC,6BAA6B,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,4BAA4B,CAAC;SACvF;QACD,IAAI,CAAC,CAAC,kBAAkB,EAAE;YACzB,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,MAAM,CAAC,kBAAkB,CAAC;SAC1D;QACD,IAAI,CAAC,CAAC,QAAQ,EAAE;YACf,6BAAa,CAAC,aAAa,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;SAChE;QAED,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAE9B,IAAI,CAAC,CAAC,UAAU,EAAE;YACjB,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;SACvB;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IACO,0CAAsB,GAA9B;QACC,IAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC;QAEzC,IAAM,kBAAkB,GAAG,IAAI,0BAAe,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC/E,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,kBAAkB,CAAC,EAAE;YACtD,IAAI,CAAC,gBAAgB,GAAG,kBAAkB,CAAC;YAE3C,IAAM,eAAe,GAAG,IAAI,CAAC,aAAa,CAAC,kBAAkB,EAAE,CAAC;YAChE,IAAM,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC;YAC5D,KAAK,IAAI,UAAU,GAAG,eAAe,EAAE,UAAU,IAAI,aAAa,EAAE,UAAU,EAAE,EAAE;gBACjF,IAAM,IAAI,GAAG,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;gBAC3D,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;aAC7C;YACD,OAAO,IAAI,CAAC;SACZ;QAED,OAAO,KAAK,CAAC;IACd,CAAC;IACM,wCAAoB,GAA3B,UAA4B,CAAyC;QACpE,IAAM,mBAAmB,GAAG,IAAI,CAAC,aAAa,CAAC,kBAAkB,EAAE,CAAC;QACpE,IAAM,iBAAiB,GAAG,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC;QAChE,IAAI,CAAC,GAAG,KAAK,CAAC;QACd,KAAK,IAAI,UAAU,GAAG,mBAAmB,EAAE,UAAU,IAAI,iBAAiB,EAAE,UAAU,EAAE,EAAE;YACzF,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC,kBAAkB,EAAE,IAAI,CAAC,CAAC;SAC5E;QACD,OAAO,CAAC,CAAC;IACV,CAAC;IACM,wCAAoB,GAA3B,UAA4B,CAAyC;QACpE,IAAI,IAAI,CAAA,8BAA8B,EAAE;YACvC,IAAM,mBAAmB,GAAG,IAAI,CAAC,aAAa,CAAC,kBAAkB,EAAE,CAAC;YACpE,IAAM,iBAAiB,GAAG,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC;YAChE,KAAK,IAAI,UAAU,GAAG,mBAAmB,EAAE,UAAU,IAAI,iBAAiB,EAAE,UAAU,EAAE,EAAE;gBACzF,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC,oBAAoB,EAAE,CAAC;aACrE;SACD;QACD,OAAO,IAAI,CAAC;IACb,CAAC;IACM,6BAAS,GAAhB,UAAiB,CAA8B;QAC9C,IAAM,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QACrD,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;QACvB,OAAO,YAAY,CAAC;IACrB,CAAC;IACM,kCAAc,GAArB,UAAsB,CAAmC;QACxD,OAAO,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;IAC7C,CAAC;IACM,kCAAc,GAArB,UAAsB,CAAmC;QACxD,OAAO,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;IAC7C,CAAC;IACM,mCAAe,GAAtB,UAAuB,CAAoC;QAC1D,OAAO,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;IAC9C,CAAC;IACM,wCAAoB,GAA3B,UAA4B,CAAyC;QACpE,6DAA6D;QAC7D,sEAAsE;QACtE,IAAM,gBAAgB,GAAG,IAAI,CAAC,8BAA8B,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,iBAAiB,EAAE,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC;QAEpI,sCAAsC;QACtC,IAAI,iBAAiB,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,sBAAsB,CAAC,EAAE,SAAS,EAAE,gBAAgB,EAAE,CAAC,CAAC;QAEzG,IAAI,CAAC,CAAC,gBAAgB,EAAE;YACvB,IAAI,CAAC,CAAC,KAAK,CAAC,eAAe,KAAK,CAAC,CAAC,KAAK,CAAC,aAAa,EAAE;gBACtD,kFAAkF;gBAClF,iBAAiB,GAAG;oBACnB,SAAS,EAAE,iBAAiB,CAAC,SAAS;oBACtC,UAAU,EAAE,CAAC;iBACb,CAAC;aACF;iBAAM;gBACN,2GAA2G;gBAC3G,IAAI,CAAC,wBAAwB,GAAG,IAAI,uBAAuB,CAAC,CAAC,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC,KAAK,CAAC,SAAS,EAAE,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,mBAAmB,EAAE,EAAE,iBAAiB,CAAC,SAAS,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC;aACxN;SACD;aAAM;YACN,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC;SACrC;QAED,IAAM,cAAc,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,mBAAmB,EAAE,GAAG,iBAAiB,CAAC,SAAS,CAAC,CAAC;QAC9G,IAAI,CAAC,CAAC,UAAU,KAAK,yBAAU,CAAC,MAAM,IAAI,cAAc,GAAG,IAAI,CAAC,WAAW,EAAE;YAC5E,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,uBAAuB,CAAC,iBAAiB,CAAC,CAAC;SACpE;aAAM;YACN,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,oBAAoB,CAAC,iBAAiB,CAAC,CAAC;SACjE;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IACM,mCAAe,GAAtB,UAAuB,CAAoC;QAC1D,IAAI,IAAI,CAAC,wBAAwB,IAAI,CAAC,CAAC,iBAAiB,EAAE;YACzD,yFAAyF;YACzF,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC;SACrC;QACD,IAAI,IAAI,CAAC,wBAAwB,IAAI,CAAC,CAAC,gBAAgB,EAAE;YACxD,IAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,wBAAwB,CAAC,cAAc,EAAE,IAAI,CAAC,wBAAwB,CAAC,aAAa,CAAC,CAAC;YAChH,IAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,wBAAwB,CAAC,cAAc,EAAE,IAAI,CAAC,wBAAwB,CAAC,aAAa,CAAC,CAAC;YAChH,IAAI,CAAC,CAAC,SAAS,GAAG,GAAG,IAAI,CAAC,CAAC,SAAS,GAAG,GAAG,EAAE;gBAC3C,uFAAuF;gBACvF,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC;aACrC;SACD;QACD,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC;QACrC,OAAO,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC;IACtD,CAAC;IAEM,mCAAe,GAAtB,UAAuB,CAAoC;QAC1D,OAAO,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;IAC9C,CAAC;IACM,kCAAc,GAArB,UAAsB,CAAmC;QACxD,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,qBAAqB,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QACnE,OAAO,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;IAC7C,CAAC;IACM,kCAAc,GAArB,UAAsB,CAAmC;QACxD,OAAO,IAAI,CAAC,sBAAsB,EAAE,CAAC;IACtC,CAAC;IAED,+BAA+B;IAE/B,iCAAiC;IAE1B,0CAAsB,GAA7B,UAA8B,QAAqB,EAAE,MAAc;QAClE,IAAM,eAAe,GAAG,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC;QAC3D,IAAI,eAAe,KAAK,IAAI,EAAE;YAC7B,+BAA+B;YAC/B,OAAO,IAAI,CAAC;SACZ;QACD,IAAM,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,eAAe,CAAC,CAAC;QAE3D,IAAI,UAAU,KAAK,CAAC,CAAC,EAAE;YACtB,+BAA+B;YAC/B,OAAO,IAAI,CAAC;SACZ;QAED,IAAI,UAAU,GAAG,CAAC,IAAI,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,YAAY,EAAE,EAAE;YACtE,8BAA8B;YAC9B,OAAO,IAAI,CAAC;SACZ;QAED,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,gBAAgB,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;YAC3D,gBAAgB;YAChB,OAAO,IAAI,mBAAQ,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC;SACnC;QAED,IAAM,mBAAmB,GAAG,IAAI,CAAC,aAAa,CAAC,kBAAkB,EAAE,CAAC;QACpE,IAAM,iBAAiB,GAAG,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC;QAChE,IAAI,UAAU,GAAG,mBAAmB,IAAI,UAAU,GAAG,iBAAiB,EAAE;YACvE,qBAAqB;YACrB,OAAO,IAAI,CAAC;SACZ;QAED,IAAI,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC,qBAAqB,CAAC,UAAU,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;QAC/G,IAAM,SAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;QACnE,IAAI,MAAM,GAAG,SAAS,EAAE;YACvB,MAAM,GAAG,SAAS,CAAC;SACnB;QACD,OAAO,IAAI,mBAAQ,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;IACzC,CAAC;IAEO,uCAAmB,GAA3B,UAA4B,IAAwB;QACnD,OAAO,IAAI,IAAI,IAAI,CAAC,QAAQ,KAAK,CAAC,EAAE;YACnC,IAAI,IAAI,CAAC,SAAS,KAAK,mBAAQ,CAAC,UAAU,EAAE;gBAC3C,OAAO,IAAI,CAAC;aACZ;YACD,IAAI,GAAG,IAAI,CAAC,aAAa,CAAC;SAC1B;QACD,OAAO,IAAI,CAAC;IACb,CAAC;IAED;;OAEG;IACK,qCAAiB,GAAzB,UAA0B,OAAoB;QAC7C,IAAM,eAAe,GAAG,IAAI,CAAC,aAAa,CAAC,kBAAkB,EAAE,CAAC;QAChE,IAAM,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC;QAC5D,KAAK,IAAI,UAAU,GAAG,eAAe,EAAE,UAAU,IAAI,aAAa,EAAE,UAAU,EAAE,EAAE;YACjF,IAAM,IAAI,GAAG,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;YAC3D,IAAI,OAAO,KAAK,IAAI,CAAC,UAAU,EAAE,EAAE;gBAClC,OAAO,UAAU,CAAC;aAClB;SACD;QACD,OAAO,CAAC,CAAC,CAAC;IACX,CAAC;IAEM,gCAAY,GAAnB,UAAoB,UAAkB;QACrC,IAAM,mBAAmB,GAAG,IAAI,CAAC,aAAa,CAAC,kBAAkB,EAAE,CAAC;QACpE,IAAM,iBAAiB,GAAG,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC;QAChE,IAAI,UAAU,GAAG,mBAAmB,IAAI,UAAU,GAAG,iBAAiB,EAAE;YACvE,qBAAqB;YACrB,OAAO,CAAC,CAAC,CAAC;SACV;QAED,OAAO,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC,QAAQ,EAAE,CAAC;IACjE,CAAC;IAEM,8CAA0B,GAAjC,UAAkC,MAAa,EAAE,eAAwB;QACxE,IAAI,IAAI,CAAC,YAAY,EAAE,EAAE;YACxB,+CAA+C;YAC/C,8EAA8E;YAC9E,OAAO,IAAI,CAAC;SACZ;QAED,IAAM,qBAAqB,GAAG,MAAM,CAAC,aAAa,CAAC;QACnD,IAAM,KAAK,GAAG,aAAK,CAAC,eAAe,CAAC,MAAM,EAAE,IAAI,CAAC,iBAAiB,CAAC,sBAAsB,EAAE,CAAC,CAAC;QAC7F,IAAI,CAAC,KAAK,EAAE;YACX,OAAO,IAAI,CAAC;SACZ;QAED,IAAI,aAAa,GAAwB,EAAE,EAAE,gBAAgB,GAAG,CAAC,CAAC;QAClE,IAAM,iBAAiB,GAAG,IAAI,4BAAiB,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,qBAAqB,CAAC,CAAC;QAElG,IAAI,uBAAuB,GAAW,CAAC,CAAC;QACxC,IAAI,eAAe,EAAE;YACpB,uBAAuB,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,oBAAoB,CAAC,kCAAkC,CAAC,IAAI,mBAAQ,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;SACzJ;QAED,IAAM,mBAAmB,GAAG,IAAI,CAAC,aAAa,CAAC,kBAAkB,EAAE,CAAC;QACpE,IAAM,iBAAiB,GAAG,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC;QAChE,KAAK,IAAI,UAAU,GAAG,KAAK,CAAC,eAAe,EAAE,UAAU,IAAI,KAAK,CAAC,aAAa,EAAE,UAAU,EAAE,EAAE;YAE7F,IAAI,UAAU,GAAG,mBAAmB,IAAI,UAAU,GAAG,iBAAiB,EAAE;gBACvE,SAAS;aACT;YAED,IAAM,WAAW,GAAG,UAAU,KAAK,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;YACjF,IAAM,SAAS,GAAG,UAAU,KAAK,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;YAC1H,IAAM,oBAAoB,GAAG,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC,wBAAwB,CAAC,WAAW,EAAE,SAAS,EAAE,iBAAiB,CAAC,CAAC;YAE/I,IAAI,CAAC,oBAAoB,IAAI,oBAAoB,CAAC,MAAM,KAAK,CAAC,EAAE;gBAC/D,SAAS;aACT;YAED,IAAI,eAAe,IAAI,UAAU,GAAG,qBAAqB,EAAE;gBAC1D,IAAM,0BAA0B,GAAG,uBAAuB,CAAC;gBAC3D,uBAAuB,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,oBAAoB,CAAC,kCAAkC,CAAC,IAAI,mBAAQ,CAAC,UAAU,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;gBAElJ,IAAI,0BAA0B,KAAK,uBAAuB,EAAE;oBAC3D,oBAAoB,CAAC,oBAAoB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,+BAA+B,CAAC;iBACpG;aACD;YAED,aAAa,CAAC,gBAAgB,EAAE,CAAC,GAAG,IAAI,oCAAiB,CAAC,UAAU,EAAE,oBAAoB,CAAC,CAAC;SAC5F;QAED,IAAI,gBAAgB,KAAK,CAAC,EAAE;YAC3B,OAAO,IAAI,CAAC;SACZ;QAED,OAAO,aAAa,CAAC;IACtB,CAAC;IAEO,0CAAsB,GAA9B,UAA+B,MAAa;QAE3C,IAAI,IAAI,CAAC,YAAY,EAAE,EAAE;YACxB,+CAA+C;YAC/C,8EAA8E;YAC9E,OAAO,IAAI,CAAC;SACZ;QAED,IAAM,KAAK,GAAG,aAAK,CAAC,eAAe,CAAC,MAAM,EAAE,IAAI,CAAC,iBAAiB,CAAC,sBAAsB,EAAE,CAAC,CAAC;QAC7F,IAAI,CAAC,KAAK,EAAE;YACX,OAAO,IAAI,CAAC;SACZ;QAED,IAAI,MAAM,GAAsB,EAAE,CAAC;QACnC,IAAM,iBAAiB,GAAG,IAAI,4BAAiB,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,qBAAqB,CAAC,CAAC;QAElG,IAAM,mBAAmB,GAAG,IAAI,CAAC,aAAa,CAAC,kBAAkB,EAAE,CAAC;QACpE,IAAM,iBAAiB,GAAG,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC;QAChE,KAAK,IAAI,UAAU,GAAG,KAAK,CAAC,eAAe,EAAE,UAAU,IAAI,KAAK,CAAC,aAAa,EAAE,UAAU,EAAE,EAAE;YAE7F,IAAI,UAAU,GAAG,mBAAmB,IAAI,UAAU,GAAG,iBAAiB,EAAE;gBACvE,SAAS;aACT;YAED,IAAM,WAAW,GAAG,UAAU,KAAK,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;YACjF,IAAM,SAAS,GAAG,UAAU,KAAK,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;YAC1H,IAAM,oBAAoB,GAAG,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC,wBAAwB,CAAC,WAAW,EAAE,SAAS,EAAE,iBAAiB,CAAC,CAAC;YAE/I,IAAI,CAAC,oBAAoB,IAAI,oBAAoB,CAAC,MAAM,KAAK,CAAC,EAAE;gBAC/D,SAAS;aACT;YAED,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,oBAAoB,CAAC,CAAC;SAC7C;QAED,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;YACxB,OAAO,IAAI,CAAC;SACZ;QAED,OAAO,MAAM,CAAC;IACf,CAAC;IAEM,2CAAuB,GAA9B,UAA+B,QAAkB;QAChD,IAAM,aAAa,GAAG,IAAI,CAAC,sBAAsB,CAAC,IAAI,aAAK,CAAC,QAAQ,CAAC,UAAU,EAAE,QAAQ,CAAC,MAAM,EAAE,QAAQ,CAAC,UAAU,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;QACzI,IAAI,CAAC,aAAa,EAAE;YACnB,OAAO,IAAI,CAAC;SACZ;QACD,OAAO,aAAa,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC;IAED,qBAAqB;IAEd,oCAAgB,GAAvB;QACC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;IAC/B,CAAC;IAED;;;;OAIG;IACK,yCAAqB,GAA7B;QACC,OAAO,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;IACrC,CAAC;IAEO,yCAAqB,GAA7B;QACC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;IAC/B,CAAC;IAEO,qCAAiB,GAAzB,UAA0B,IAAa;QACtC,IAAM,mBAAmB,GAAG,IAAI,CAAC,aAAa,CAAC,kBAAkB,EAAE,CAAC;QACpE,IAAM,iBAAiB,GAAG,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC;QAEhE,IAAI,iBAAiB,GAAG,CAAC,CAAC;QAC1B,IAAI,iBAAiB,GAAG,IAAI,CAAC;QAC7B,KAAK,IAAI,UAAU,GAAG,mBAAmB,EAAE,UAAU,IAAI,iBAAiB,EAAE,UAAU,EAAE,EAAE;YACzF,IAAM,WAAW,GAAG,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;YAElE,IAAI,IAAI,IAAI,CAAC,WAAW,CAAC,cAAc,EAAE,EAAE;gBAC1C,mDAAmD;gBACnD,iBAAiB,GAAG,KAAK,CAAC;gBAC1B,SAAS;aACT;YAED,iBAAiB,GAAG,IAAI,CAAC,GAAG,CAAC,iBAAiB,EAAE,WAAW,CAAC,QAAQ,EAAE,CAAC,CAAC;SACxE;QAED,IAAI,iBAAiB,IAAI,mBAAmB,KAAK,CAAC,IAAI,iBAAiB,KAAK,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,YAAY,EAAE,EAAE;YAC/G,+CAA+C;YAC/C,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;SACvB;QAED,IAAI,CAAC,mBAAmB,CAAC,iBAAiB,CAAC,CAAC;QAE5C,OAAO,iBAAiB,CAAC;IAC1B,CAAC;IAEM,iCAAa,GAApB;QACC,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;IAClC,CAAC;IAEM,0BAAM,GAAb;QACC,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;IAClC,CAAC;IAEM,8BAAU,GAAjB,UAAkB,YAA0B;QAC3C,kDAAkD;QAClD,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;QAC7C,IAAI,CAAC,iBAAiB,CAAC,sBAAsB,CAAC,YAAY,CAAC,YAAY,CAAC,CAAC;QACzE,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,cAAc,EAAE,CAAC,CAAC;QACjE,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,eAAe,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC;QAEtF,0CAA0C;QAC1C,uGAAuG;QACvG,oDAAoD;QACpD,IAAI,IAAI,CAAC,wBAAwB,EAAE;YAElC,IAAM,gBAAgB,GAAG,IAAI,CAAC,wBAAwB,CAAC,UAAU,CAAC;YAClE,IAAM,iBAAiB,GAAG,IAAI,CAAC,wBAAwB,CAAC,WAAW,CAAC;YACpE,IAAM,eAAe,GAAG,IAAI,CAAC,wBAAwB,CAAC,SAAS,CAAC;YAChE,IAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,UAAU,CAAC;YAE5D,iFAAiF;YACjF,IAAI,YAAY,CAAC,eAAe,IAAI,gBAAgB,IAAI,gBAAgB,IAAI,YAAY,CAAC,aAAa,EAAE;gBAEvG,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC;gBAErC,yCAAyC;gBACzC,IAAI,CAAC,WAAW,EAAE,CAAC;gBAEnB,8BAA8B;gBAC9B,IAAM,aAAa,GAAG,IAAI,CAAC,+BAA+B,CAAC,gBAAgB,EAAE,iBAAiB,EAAE,eAAe,CAAC,CAAC;gBAEjH,IAAM,kBAAkB,GAAG,IAAI,CAAC,mBAAmB,CAAC;gBACpD,IAAI,CAAC,kBAAkB,EAAE;oBACxB,uCAAuC;oBACvC,IAAI,CAAC,mBAAmB,CAAC,aAAa,CAAC,mBAAmB,CAAC,CAAC;iBAC5D;gBAED,mBAAmB;gBACnB,IAAI,UAAU,KAAK,yBAAU,CAAC,MAAM,EAAE;oBACrC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,uBAAuB,CAAC;wBAChD,UAAU,EAAE,aAAa,CAAC,UAAU;qBACpC,CAAC,CAAC;iBACH;qBAAM;oBACN,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,oBAAoB,CAAC;wBAC7C,UAAU,EAAE,aAAa,CAAC,UAAU;qBACpC,CAAC,CAAC;iBACH;aACD;SACD;QAED,yGAAyG;QACzG,IAAI,CAAC,IAAI,CAAC,qBAAqB,EAAE,EAAE;YAClC,8DAA8D;YAC9D,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,CAAC;SACvC;QAED,uBAAuB;QACvB,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;QAC7D,IAAM,iBAAiB,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,mBAAmB,EAAE,GAAG,YAAY,CAAC,eAAe,CAAC;QACxG,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,iBAAiB,CAAC,CAAC;QAC9C,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,oBAAoB,EAAE,CAAC,CAAC;IAC9E,CAAC;IAED,YAAY;IAEJ,uCAAmB,GAA3B,UAA4B,SAAiB;QAC5C,IAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACxC,IAAI,IAAI,CAAC,aAAa,GAAG,UAAU,EAAE;YACpC,IAAI,CAAC,aAAa,GAAG,UAAU,CAAC;YAChC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,qBAAqB,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;SACnE;IACF,CAAC;IAEO,kDAA8B,GAAtC,UAAuC,QAAkB,EAAE,KAAY,EAAE,YAA2C;QACnH,IAAM,cAAc,GAAG,QAAQ,CAAC,GAAG,CAAC;QACpC,IAAM,cAAc,GAAG,QAAQ,CAAC,MAAM,CAAC;QACvC,IAAM,YAAY,GAAG,cAAc,GAAG,cAAc,CAAC;QACrD,IAAI,SAAiB,CAAC;QACtB,IAAI,OAAe,CAAC;QAEpB,gFAAgF;QAChF,SAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,8BAA8B,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;QAC3F,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,8BAA8B,CAAC,KAAK,CAAC,aAAa,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC;QAC1G,IAAI,YAAY,KAAK,UAAU,CAAC,kBAAkB,CAAC,MAAM,IAAI,YAAY,KAAK,UAAU,CAAC,kBAAkB,CAAC,MAAM,EAAE;YACnH,uIAAuI;YACvI,OAAO,IAAI,IAAI,CAAC,WAAW,CAAC;SAC5B;QAED,IAAI,YAAoB,CAAC;QAEzB,IAAI,YAAY,KAAK,UAAU,CAAC,kBAAkB,CAAC,MAAM,IAAI,YAAY,KAAK,UAAU,CAAC,kBAAkB,CAAC,uBAAuB,EAAE;YACpI,IAAI,YAAY,KAAK,UAAU,CAAC,kBAAkB,CAAC,uBAAuB,IAAI,cAAc,IAAI,SAAS,IAAI,OAAO,IAAI,YAAY,EAAE;gBACrI,+CAA+C;gBAC/C,YAAY,GAAG,cAAc,CAAC;aAC9B;iBAAM;gBACN,2CAA2C;gBAC3C,IAAM,UAAU,GAAG,CAAC,SAAS,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC;gBAC7C,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,UAAU,GAAG,cAAc,GAAG,CAAC,CAAC,CAAC;aAC5D;SACD;aAAM;YACN,YAAY,GAAG,IAAI,CAAC,wBAAwB,CAAC,cAAc,EAAE,YAAY,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,KAAK,UAAU,CAAC,kBAAkB,CAAC,GAAG,EAAE,YAAY,KAAK,UAAU,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC;SAC1M;QAED,OAAO,YAAY,CAAC;IACrB,CAAC;IAEO,mDAA+B,GAAvC,UAAwC,UAAkB,EAAE,WAAmB,EAAE,SAAiB;QAEjG,IAAI,mBAAmB,GAAG,CAAC,CAAC;QAE5B,IAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,kBAAkB,EAAE,CAAC;QAC/D,IAAM,cAAc,GAAG,QAAQ,CAAC,IAAI,CAAC;QACrC,IAAM,YAAY,GAAG,cAAc,GAAG,QAAQ,CAAC,KAAK,CAAC;QAErD,IAAM,aAAa,GAAG,IAAI,CAAC,sBAAsB,CAAC,IAAI,aAAK,CAAC,UAAU,EAAE,WAAW,EAAE,UAAU,EAAE,SAAS,CAAC,CAAC,CAAC;QAC7G,IAAI,SAAS,GAAG,MAAM,CAAC,SAAS,CAAC;QACjC,IAAI,OAAO,GAAG,CAAC,CAAC;QAEhB,IAAI,CAAC,aAAa,EAAE;YACnB,UAAU;YACV,OAAO;gBACN,UAAU,EAAE,cAAc;gBAC1B,mBAAmB,EAAE,mBAAmB;aACxC,CAAC;SACF;QAED,KAA2B,UAAa,EAAb,+BAAa,EAAb,2BAAa,EAAb,IAAa,EAAE;YAArC,IAAM,YAAY,sBAAA;YACtB,IAAI,YAAY,CAAC,IAAI,GAAG,SAAS,EAAE;gBAClC,SAAS,GAAG,YAAY,CAAC,IAAI,CAAC;aAC9B;YACD,IAAI,YAAY,CAAC,IAAI,GAAG,YAAY,CAAC,KAAK,GAAG,OAAO,EAAE;gBACrD,OAAO,GAAG,YAAY,CAAC,IAAI,GAAG,YAAY,CAAC,KAAK,CAAC;aACjD;SACD;QAED,mBAAmB,GAAG,OAAO,CAAC;QAE9B,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,SAAS,GAAG,SAAS,CAAC,mBAAmB,CAAC,CAAC;QACnE,OAAO,IAAI,IAAI,CAAC,6BAA6B,CAAC;QAE9C,IAAM,aAAa,GAAG,IAAI,CAAC,wBAAwB,CAAC,cAAc,EAAE,YAAY,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;QACtG,OAAO;YACN,UAAU,EAAE,aAAa;YACzB,mBAAmB,EAAE,mBAAmB;SACxC,CAAC;IACH,CAAC;IAEO,4CAAwB,GAAhC,UAAiC,aAAqB,EAAE,WAAmB,EAAE,QAAgB,EAAE,MAAc,EAAE,aAAuB,EAAE,WAAqB;QAC5J,aAAa,GAAG,aAAa,GAAG,CAAC,CAAC;QAClC,WAAW,GAAG,WAAW,GAAG,CAAC,CAAC;QAC9B,QAAQ,GAAG,QAAQ,GAAG,CAAC,CAAC;QACxB,MAAM,GAAG,MAAM,GAAG,CAAC,CAAC;QACpB,aAAa,GAAG,CAAC,CAAC,aAAa,CAAC;QAChC,WAAW,GAAG,CAAC,CAAC,WAAW,CAAC;QAE5B,IAAM,cAAc,GAAG,WAAW,GAAG,aAAa,CAAC;QACnD,IAAM,SAAS,GAAG,MAAM,GAAG,QAAQ,CAAC;QAEpC,IAAI,SAAS,GAAG,cAAc,EAAE;YAC/B,oCAAoC;YAEpC,IAAI,aAAa,EAAE;gBAClB,OAAO,QAAQ,CAAC;aAChB;YAED,IAAI,WAAW,EAAE;gBAChB,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,MAAM,GAAG,cAAc,CAAC,CAAC;aAC5C;YAED,IAAI,QAAQ,GAAG,aAAa,EAAE;gBAC7B,gCAAgC;gBAChC,OAAO,QAAQ,CAAC;aAChB;iBAAM,IAAI,MAAM,GAAG,WAAW,EAAE;gBAChC,gCAAgC;gBAChC,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,MAAM,GAAG,cAAc,CAAC,CAAC;aAC5C;SACD;aAAM;YACN,wCAAwC;YACxC,kCAAkC;YAClC,OAAO,QAAQ,CAAC;SAChB;QAED,OAAO,aAAa,CAAC;IACtB,CAAC;IAhoBD;;OAEG;IACqB,6BAAmB,GAAG,EAAE,CAAC;IA8nBlD,gBAAC;CAAA,AAloBD,CAA+B,mBAAQ,GAkoBtC;AAloBY,8BAAS","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport 'vs/css!./viewLines';\nimport { FastDomNode } from 'vs/base/browser/fastDomNode';\nimport { RunOnceScheduler } from 'vs/base/common/async';\nimport { Configuration } from 'vs/editor/browser/config/configuration';\nimport { IVisibleLinesHost, VisibleLinesCollection } from 'vs/editor/browser/view/viewLayer';\nimport { PartFingerprint, PartFingerprints, ViewPart } from 'vs/editor/browser/view/viewPart';\nimport { DomReadingContext, ViewLine, ViewLineOptions } from 'vs/editor/browser/viewParts/lines/viewLine';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { ScrollType } from 'vs/editor/common/editorCommon';\nimport { HorizontalRange, IViewLines, LineVisibleRanges } from 'vs/editor/common/view/renderingContext';\nimport { ViewContext } from 'vs/editor/common/view/viewContext';\nimport * as viewEvents from 'vs/editor/common/view/viewEvents';\nimport { ViewportData } from 'vs/editor/common/viewLayout/viewLinesViewportData';\nimport { Viewport } from 'vs/editor/common/viewModel/viewModel';\n\nclass LastRenderedData {\n\n\tprivate _currentVisibleRange: Range;\n\n\tconstructor() {\n\t\tthis._currentVisibleRange = new Range(1, 1, 1, 1);\n\t}\n\n\tpublic getCurrentVisibleRange(): Range {\n\t\treturn this._currentVisibleRange;\n\t}\n\n\tpublic setCurrentVisibleRange(currentVisibleRange: Range): void {\n\t\tthis._currentVisibleRange = currentVisibleRange;\n\t}\n}\n\nclass HorizontalRevealRequest {\n\n\tpublic readonly lineNumber: number;\n\tpublic readonly startColumn: number;\n\tpublic readonly endColumn: number;\n\tpublic readonly startScrollTop: number;\n\tpublic readonly stopScrollTop: number;\n\tpublic readonly scrollType: ScrollType;\n\n\tconstructor(lineNumber: number, startColumn: number, endColumn: number, startScrollTop: number, stopScrollTop: number, scrollType: ScrollType) {\n\t\tthis.lineNumber = lineNumber;\n\t\tthis.startColumn = startColumn;\n\t\tthis.endColumn = endColumn;\n\t\tthis.startScrollTop = startScrollTop;\n\t\tthis.stopScrollTop = stopScrollTop;\n\t\tthis.scrollType = scrollType;\n\t}\n}\n\nexport class ViewLines extends ViewPart implements IVisibleLinesHost<ViewLine>, IViewLines {\n\t/**\n\t * Adds this amount of pixels to the right of lines (no-one wants to type near the edge of the viewport)\n\t */\n\tprivate static readonly HORIZONTAL_EXTRA_PX = 30;\n\n\tprivate readonly _linesContent: FastDomNode<HTMLElement>;\n\tprivate readonly _textRangeRestingSpot: HTMLElement;\n\tprivate readonly _visibleLines: VisibleLinesCollection<ViewLine>;\n\tprivate readonly domNode: FastDomNode<HTMLElement>;\n\n\t// --- config\n\tprivate _lineHeight: number;\n\tprivate _typicalHalfwidthCharacterWidth: number;\n\tprivate _isViewportWrapping: boolean;\n\tprivate _revealHorizontalRightPadding: number;\n\tprivate _canUseLayerHinting: boolean;\n\tprivate _viewLineOptions: ViewLineOptions;\n\n\t// --- width\n\tprivate _maxLineWidth: number;\n\tprivate readonly _asyncUpdateLineWidths: RunOnceScheduler;\n\n\tprivate _horizontalRevealRequest: HorizontalRevealRequest | null;\n\tprivate readonly _lastRenderedData: LastRenderedData;\n\n\tconstructor(context: ViewContext, linesContent: FastDomNode<HTMLElement>) {\n\t\tsuper(context);\n\t\tthis._linesContent = linesContent;\n\t\tthis._textRangeRestingSpot = document.createElement('div');\n\t\tthis._visibleLines = new VisibleLinesCollection(this);\n\t\tthis.domNode = this._visibleLines.domNode;\n\n\t\tconst conf = this._context.configuration;\n\n\t\tthis._lineHeight = conf.editor.lineHeight;\n\t\tthis._typicalHalfwidthCharacterWidth = conf.editor.fontInfo.typicalHalfwidthCharacterWidth;\n\t\tthis._isViewportWrapping = conf.editor.wrappingInfo.isViewportWrapping;\n\t\tthis._revealHorizontalRightPadding = conf.editor.viewInfo.revealHorizontalRightPadding;\n\t\tthis._canUseLayerHinting = conf.editor.canUseLayerHinting;\n\t\tthis._viewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\n\n\t\tPartFingerprints.write(this.domNode, PartFingerprint.ViewLines);\n\t\tthis.domNode.setClassName('view-lines');\n\t\tConfiguration.applyFontInfo(this.domNode, conf.editor.fontInfo);\n\n\t\t// --- width & height\n\t\tthis._maxLineWidth = 0;\n\t\tthis._asyncUpdateLineWidths = new RunOnceScheduler(() => {\n\t\t\tthis._updateLineWidthsSlow();\n\t\t}, 200);\n\n\t\tthis._lastRenderedData = new LastRenderedData();\n\n\t\tthis._horizontalRevealRequest = null;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._asyncUpdateLineWidths.dispose();\n\t\tsuper.dispose();\n\t}\n\n\tpublic getDomNode(): FastDomNode<HTMLElement> {\n\t\treturn this.domNode;\n\t}\n\n\t// ---- begin IVisibleLinesHost\n\n\tpublic createVisibleLine(): ViewLine {\n\t\treturn new ViewLine(this._viewLineOptions);\n\t}\n\n\t// ---- end IVisibleLinesHost\n\n\t// ---- begin view event handlers\n\n\tpublic onConfigurationChanged(e: viewEvents.ViewConfigurationChangedEvent): boolean {\n\t\tthis._visibleLines.onConfigurationChanged(e);\n\t\tif (e.wrappingInfo) {\n\t\t\tthis._maxLineWidth = 0;\n\t\t}\n\n\t\tconst conf = this._context.configuration;\n\n\t\tif (e.lineHeight) {\n\t\t\tthis._lineHeight = conf.editor.lineHeight;\n\t\t}\n\t\tif (e.fontInfo) {\n\t\t\tthis._typicalHalfwidthCharacterWidth = conf.editor.fontInfo.typicalHalfwidthCharacterWidth;\n\t\t}\n\t\tif (e.wrappingInfo) {\n\t\t\tthis._isViewportWrapping = conf.editor.wrappingInfo.isViewportWrapping;\n\t\t}\n\t\tif (e.viewInfo) {\n\t\t\tthis._revealHorizontalRightPadding = conf.editor.viewInfo.revealHorizontalRightPadding;\n\t\t}\n\t\tif (e.canUseLayerHinting) {\n\t\t\tthis._canUseLayerHinting = conf.editor.canUseLayerHinting;\n\t\t}\n\t\tif (e.fontInfo) {\n\t\t\tConfiguration.applyFontInfo(this.domNode, conf.editor.fontInfo);\n\t\t}\n\n\t\tthis._onOptionsMaybeChanged();\n\n\t\tif (e.layoutInfo) {\n\t\t\tthis._maxLineWidth = 0;\n\t\t}\n\n\t\treturn true;\n\t}\n\tprivate _onOptionsMaybeChanged(): boolean {\n\t\tconst conf = this._context.configuration;\n\n\t\tconst newViewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\n\t\tif (!this._viewLineOptions.equals(newViewLineOptions)) {\n\t\t\tthis._viewLineOptions = newViewLineOptions;\n\n\t\t\tconst startLineNumber = this._visibleLines.getStartLineNumber();\n\t\t\tconst endLineNumber = this._visibleLines.getEndLineNumber();\n\t\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\t\tconst line = this._visibleLines.getVisibleLine(lineNumber);\n\t\t\t\tline.onOptionsChanged(this._viewLineOptions);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\tpublic onCursorStateChanged(e: viewEvents.ViewCursorStateChangedEvent): boolean {\n\t\tconst rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\t\tconst rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\t\tlet r = false;\n\t\tfor (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n\t\t\tr = this._visibleLines.getVisibleLine(lineNumber).onSelectionChanged() || r;\n\t\t}\n\t\treturn r;\n\t}\n\tpublic onDecorationsChanged(e: viewEvents.ViewDecorationsChangedEvent): boolean {\n\t\tif (true/*e.inlineDecorationsChanged*/) {\n\t\t\tconst rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\t\t\tconst rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\t\t\tfor (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n\t\t\t\tthis._visibleLines.getVisibleLine(lineNumber).onDecorationsChanged();\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic onFlushed(e: viewEvents.ViewFlushedEvent): boolean {\n\t\tconst shouldRender = this._visibleLines.onFlushed(e);\n\t\tthis._maxLineWidth = 0;\n\t\treturn shouldRender;\n\t}\n\tpublic onLinesChanged(e: viewEvents.ViewLinesChangedEvent): boolean {\n\t\treturn this._visibleLines.onLinesChanged(e);\n\t}\n\tpublic onLinesDeleted(e: viewEvents.ViewLinesDeletedEvent): boolean {\n\t\treturn this._visibleLines.onLinesDeleted(e);\n\t}\n\tpublic onLinesInserted(e: viewEvents.ViewLinesInsertedEvent): boolean {\n\t\treturn this._visibleLines.onLinesInserted(e);\n\t}\n\tpublic onRevealRangeRequest(e: viewEvents.ViewRevealRangeRequestEvent): boolean {\n\t\t// Using the future viewport here in order to handle multiple\n\t\t// incoming reveal range requests that might all desire to be animated\n\t\tconst desiredScrollTop = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.range, e.verticalType);\n\n\t\t// validate the new desired scroll top\n\t\tlet newScrollPosition = this._context.viewLayout.validateScrollPosition({ scrollTop: desiredScrollTop });\n\n\t\tif (e.revealHorizontal) {\n\t\t\tif (e.range.startLineNumber !== e.range.endLineNumber) {\n\t\t\t\t// Two or more lines? => scroll to base (That's how you see most of the two lines)\n\t\t\t\tnewScrollPosition = {\n\t\t\t\t\tscrollTop: newScrollPosition.scrollTop,\n\t\t\t\t\tscrollLeft: 0\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// We don't necessarily know the horizontal offset of this range since the line might not be in the view...\n\t\t\t\tthis._horizontalRevealRequest = new HorizontalRevealRequest(e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._horizontalRevealRequest = null;\n\t\t}\n\n\t\tconst scrollTopDelta = Math.abs(this._context.viewLayout.getCurrentScrollTop() - newScrollPosition.scrollTop);\n\t\tif (e.scrollType === ScrollType.Smooth && scrollTopDelta > this._lineHeight) {\n\t\t\tthis._context.viewLayout.setScrollPositionSmooth(newScrollPosition);\n\t\t} else {\n\t\t\tthis._context.viewLayout.setScrollPositionNow(newScrollPosition);\n\t\t}\n\n\t\treturn true;\n\t}\n\tpublic onScrollChanged(e: viewEvents.ViewScrollChangedEvent): boolean {\n\t\tif (this._horizontalRevealRequest && e.scrollLeftChanged) {\n\t\t\t// cancel any outstanding horizontal reveal request if someone else scrolls horizontally.\n\t\t\tthis._horizontalRevealRequest = null;\n\t\t}\n\t\tif (this._horizontalRevealRequest && e.scrollTopChanged) {\n\t\t\tconst min = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n\t\t\tconst max = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n\t\t\tif (e.scrollTop < min || e.scrollTop > max) {\n\t\t\t\t// cancel any outstanding horizontal reveal request if someone else scrolls vertically.\n\t\t\t\tthis._horizontalRevealRequest = null;\n\t\t\t}\n\t\t}\n\t\tthis.domNode.setWidth(e.scrollWidth);\n\t\treturn this._visibleLines.onScrollChanged(e) || true;\n\t}\n\n\tpublic onTokensChanged(e: viewEvents.ViewTokensChangedEvent): boolean {\n\t\treturn this._visibleLines.onTokensChanged(e);\n\t}\n\tpublic onZonesChanged(e: viewEvents.ViewZonesChangedEvent): boolean {\n\t\tthis._context.viewLayout.onMaxLineWidthChanged(this._maxLineWidth);\n\t\treturn this._visibleLines.onZonesChanged(e);\n\t}\n\tpublic onThemeChanged(e: viewEvents.ViewThemeChangedEvent): boolean {\n\t\treturn this._onOptionsMaybeChanged();\n\t}\n\n\t// ---- end view event handlers\n\n\t// ----------- HELPERS FOR OTHERS\n\n\tpublic getPositionFromDOMInfo(spanNode: HTMLElement, offset: number): Position | null {\n\t\tconst viewLineDomNode = this._getViewLineDomNode(spanNode);\n\t\tif (viewLineDomNode === null) {\n\t\t\t// Couldn't find view line node\n\t\t\treturn null;\n\t\t}\n\t\tconst lineNumber = this._getLineNumberFor(viewLineDomNode);\n\n\t\tif (lineNumber === -1) {\n\t\t\t// Couldn't find view line node\n\t\t\treturn null;\n\t\t}\n\n\t\tif (lineNumber < 1 || lineNumber > this._context.model.getLineCount()) {\n\t\t\t// lineNumber is outside range\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this._context.model.getLineMaxColumn(lineNumber) === 1) {\n\t\t\t// Line is empty\n\t\t\treturn new Position(lineNumber, 1);\n\t\t}\n\n\t\tconst rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\t\tconst rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\t\tif (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n\t\t\t// Couldn't find line\n\t\t\treturn null;\n\t\t}\n\n\t\tlet column = this._visibleLines.getVisibleLine(lineNumber).getColumnOfNodeOffset(lineNumber, spanNode, offset);\n\t\tconst minColumn = this._context.model.getLineMinColumn(lineNumber);\n\t\tif (column < minColumn) {\n\t\t\tcolumn = minColumn;\n\t\t}\n\t\treturn new Position(lineNumber, column);\n\t}\n\n\tprivate _getViewLineDomNode(node: HTMLElement | null): HTMLElement | null {\n\t\twhile (node && node.nodeType === 1) {\n\t\t\tif (node.className === ViewLine.CLASS_NAME) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t\tnode = node.parentElement;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * @returns the line number of this view line dom node.\n\t */\n\tprivate _getLineNumberFor(domNode: HTMLElement): number {\n\t\tconst startLineNumber = this._visibleLines.getStartLineNumber();\n\t\tconst endLineNumber = this._visibleLines.getEndLineNumber();\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst line = this._visibleLines.getVisibleLine(lineNumber);\n\t\t\tif (domNode === line.getDomNode()) {\n\t\t\t\treturn lineNumber;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic getLineWidth(lineNumber: number): number {\n\t\tconst rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\t\tconst rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\t\tif (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n\t\t\t// Couldn't find line\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn this._visibleLines.getVisibleLine(lineNumber).getWidth();\n\t}\n\n\tpublic linesVisibleRangesForRange(_range: Range, includeNewLines: boolean): LineVisibleRanges[] | null {\n\t\tif (this.shouldRender()) {\n\t\t\t// Cannot read from the DOM because it is dirty\n\t\t\t// i.e. the model & the dom are out of sync, so I'd be reading something stale\n\t\t\treturn null;\n\t\t}\n\n\t\tconst originalEndLineNumber = _range.endLineNumber;\n\t\tconst range = Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());\n\t\tif (!range) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet visibleRanges: LineVisibleRanges[] = [], visibleRangesLen = 0;\n\t\tconst domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\n\n\t\tlet nextLineModelLineNumber: number = 0;\n\t\tif (includeNewLines) {\n\t\t\tnextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(range.startLineNumber, 1)).lineNumber;\n\t\t}\n\n\t\tconst rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\t\tconst rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\t\tfor (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n\n\t\t\tif (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\n\t\t\tconst endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);\n\t\t\tconst visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);\n\n\t\t\tif (!visibleRangesForLine || visibleRangesForLine.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (includeNewLines && lineNumber < originalEndLineNumber) {\n\t\t\t\tconst currentLineModelLineNumber = nextLineModelLineNumber;\n\t\t\t\tnextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber + 1, 1)).lineNumber;\n\n\t\t\t\tif (currentLineModelLineNumber !== nextLineModelLineNumber) {\n\t\t\t\t\tvisibleRangesForLine[visibleRangesForLine.length - 1].width += this._typicalHalfwidthCharacterWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvisibleRanges[visibleRangesLen++] = new LineVisibleRanges(lineNumber, visibleRangesForLine);\n\t\t}\n\n\t\tif (visibleRangesLen === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn visibleRanges;\n\t}\n\n\tprivate visibleRangesForRange2(_range: Range): HorizontalRange[] | null {\n\n\t\tif (this.shouldRender()) {\n\t\t\t// Cannot read from the DOM because it is dirty\n\t\t\t// i.e. the model & the dom are out of sync, so I'd be reading something stale\n\t\t\treturn null;\n\t\t}\n\n\t\tconst range = Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());\n\t\tif (!range) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet result: HorizontalRange[] = [];\n\t\tconst domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\n\n\t\tconst rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\t\tconst rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\t\tfor (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n\n\t\t\tif (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\n\t\t\tconst endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);\n\t\t\tconst visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);\n\n\t\t\tif (!visibleRangesForLine || visibleRangesForLine.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresult = result.concat(visibleRangesForLine);\n\t\t}\n\n\t\tif (result.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic visibleRangeForPosition(position: Position): HorizontalRange | null {\n\t\tconst visibleRanges = this.visibleRangesForRange2(new Range(position.lineNumber, position.column, position.lineNumber, position.column));\n\t\tif (!visibleRanges) {\n\t\t\treturn null;\n\t\t}\n\t\treturn visibleRanges[0];\n\t}\n\n\t// --- implementation\n\n\tpublic updateLineWidths(): void {\n\t\tthis._updateLineWidths(false);\n\t}\n\n\t/**\n\t * Updates the max line width if it is fast to compute.\n\t * Returns true if all lines were taken into account.\n\t * Returns false if some lines need to be reevaluated (in a slow fashion).\n\t */\n\tprivate _updateLineWidthsFast(): boolean {\n\t\treturn this._updateLineWidths(true);\n\t}\n\n\tprivate _updateLineWidthsSlow(): void {\n\t\tthis._updateLineWidths(false);\n\t}\n\n\tprivate _updateLineWidths(fast: boolean): boolean {\n\t\tconst rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\t\tconst rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n\t\tlet localMaxLineWidth = 1;\n\t\tlet allWidthsComputed = true;\n\t\tfor (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n\t\t\tconst visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n\n\t\t\tif (fast && !visibleLine.getWidthIsFast()) {\n\t\t\t\t// Cannot compute width in a fast way for this line\n\t\t\t\tallWidthsComputed = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlocalMaxLineWidth = Math.max(localMaxLineWidth, visibleLine.getWidth());\n\t\t}\n\n\t\tif (allWidthsComputed && rendStartLineNumber === 1 && rendEndLineNumber === this._context.model.getLineCount()) {\n\t\t\t// we know the max line width for all the lines\n\t\t\tthis._maxLineWidth = 0;\n\t\t}\n\n\t\tthis._ensureMaxLineWidth(localMaxLineWidth);\n\n\t\treturn allWidthsComputed;\n\t}\n\n\tpublic prepareRender(): void {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic render(): void {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic renderText(viewportData: ViewportData): void {\n\t\t// (1) render lines - ensures lines are in the DOM\n\t\tthis._visibleLines.renderLines(viewportData);\n\t\tthis._lastRenderedData.setCurrentVisibleRange(viewportData.visibleRange);\n\t\tthis.domNode.setWidth(this._context.viewLayout.getScrollWidth());\n\t\tthis.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1000000));\n\n\t\t// (2) compute horizontal scroll position:\n\t\t//  - this must happen after the lines are in the DOM since it might need a line that rendered just now\n\t\t//  - it might change `scrollWidth` and `scrollLeft`\n\t\tif (this._horizontalRevealRequest) {\n\n\t\t\tconst revealLineNumber = this._horizontalRevealRequest.lineNumber;\n\t\t\tconst revealStartColumn = this._horizontalRevealRequest.startColumn;\n\t\t\tconst revealEndColumn = this._horizontalRevealRequest.endColumn;\n\t\t\tconst scrollType = this._horizontalRevealRequest.scrollType;\n\n\t\t\t// Check that we have the line that contains the horizontal range in the viewport\n\t\t\tif (viewportData.startLineNumber <= revealLineNumber && revealLineNumber <= viewportData.endLineNumber) {\n\n\t\t\t\tthis._horizontalRevealRequest = null;\n\n\t\t\t\t// allow `visibleRangesForRange2` to work\n\t\t\t\tthis.onDidRender();\n\n\t\t\t\t// compute new scroll position\n\t\t\t\tconst newScrollLeft = this._computeScrollLeftToRevealRange(revealLineNumber, revealStartColumn, revealEndColumn);\n\n\t\t\t\tconst isViewportWrapping = this._isViewportWrapping;\n\t\t\t\tif (!isViewportWrapping) {\n\t\t\t\t\t// ensure `scrollWidth` is large enough\n\t\t\t\t\tthis._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);\n\t\t\t\t}\n\n\t\t\t\t// set `scrollLeft`\n\t\t\t\tif (scrollType === ScrollType.Smooth) {\n\t\t\t\t\tthis._context.viewLayout.setScrollPositionSmooth({\n\t\t\t\t\t\tscrollLeft: newScrollLeft.scrollLeft\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthis._context.viewLayout.setScrollPositionNow({\n\t\t\t\t\t\tscrollLeft: newScrollLeft.scrollLeft\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Update max line width (not so important, it is just so the horizontal scrollbar doesn't get too small)\n\t\tif (!this._updateLineWidthsFast()) {\n\t\t\t// Computing the width of some lines would be slow => delay it\n\t\t\tthis._asyncUpdateLineWidths.schedule();\n\t\t}\n\n\t\t// (3) handle scrolling\n\t\tthis._linesContent.setLayerHinting(this._canUseLayerHinting);\n\t\tconst adjustedScrollTop = this._context.viewLayout.getCurrentScrollTop() - viewportData.bigNumbersDelta;\n\t\tthis._linesContent.setTop(-adjustedScrollTop);\n\t\tthis._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());\n\t}\n\n\t// --- width\n\n\tprivate _ensureMaxLineWidth(lineWidth: number): void {\n\t\tconst iLineWidth = Math.ceil(lineWidth);\n\t\tif (this._maxLineWidth < iLineWidth) {\n\t\t\tthis._maxLineWidth = iLineWidth;\n\t\t\tthis._context.viewLayout.onMaxLineWidthChanged(this._maxLineWidth);\n\t\t}\n\t}\n\n\tprivate _computeScrollTopToRevealRange(viewport: Viewport, range: Range, verticalType: viewEvents.VerticalRevealType): number {\n\t\tconst viewportStartY = viewport.top;\n\t\tconst viewportHeight = viewport.height;\n\t\tconst viewportEndY = viewportStartY + viewportHeight;\n\t\tlet boxStartY: number;\n\t\tlet boxEndY: number;\n\n\t\t// Have a box that includes one extra line height (for the horizontal scrollbar)\n\t\tboxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.startLineNumber);\n\t\tboxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.endLineNumber) + this._lineHeight;\n\t\tif (verticalType === viewEvents.VerticalRevealType.Simple || verticalType === viewEvents.VerticalRevealType.Bottom) {\n\t\t\t// Reveal one line more when the last line would be covered by the scrollbar - arrow down case or revealing a line explicitly at bottom\n\t\t\tboxEndY += this._lineHeight;\n\t\t}\n\n\t\tlet newScrollTop: number;\n\n\t\tif (verticalType === viewEvents.VerticalRevealType.Center || verticalType === viewEvents.VerticalRevealType.CenterIfOutsideViewport) {\n\t\t\tif (verticalType === viewEvents.VerticalRevealType.CenterIfOutsideViewport && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\n\t\t\t\t// Box is already in the viewport... do nothing\n\t\t\t\tnewScrollTop = viewportStartY;\n\t\t\t} else {\n\t\t\t\t// Box is outside the viewport... center it\n\t\t\t\tconst boxMiddleY = (boxStartY + boxEndY) / 2;\n\t\t\t\tnewScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);\n\t\t\t}\n\t\t} else {\n\t\t\tnewScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY, verticalType === viewEvents.VerticalRevealType.Top, verticalType === viewEvents.VerticalRevealType.Bottom);\n\t\t}\n\n\t\treturn newScrollTop;\n\t}\n\n\tprivate _computeScrollLeftToRevealRange(lineNumber: number, startColumn: number, endColumn: number): { scrollLeft: number; maxHorizontalOffset: number; } {\n\n\t\tlet maxHorizontalOffset = 0;\n\n\t\tconst viewport = this._context.viewLayout.getCurrentViewport();\n\t\tconst viewportStartX = viewport.left;\n\t\tconst viewportEndX = viewportStartX + viewport.width;\n\n\t\tconst visibleRanges = this.visibleRangesForRange2(new Range(lineNumber, startColumn, lineNumber, endColumn));\n\t\tlet boxStartX = Number.MAX_VALUE;\n\t\tlet boxEndX = 0;\n\n\t\tif (!visibleRanges) {\n\t\t\t// Unknown\n\t\t\treturn {\n\t\t\t\tscrollLeft: viewportStartX,\n\t\t\t\tmaxHorizontalOffset: maxHorizontalOffset\n\t\t\t};\n\t\t}\n\n\t\tfor (const visibleRange of visibleRanges) {\n\t\t\tif (visibleRange.left < boxStartX) {\n\t\t\t\tboxStartX = visibleRange.left;\n\t\t\t}\n\t\t\tif (visibleRange.left + visibleRange.width > boxEndX) {\n\t\t\t\tboxEndX = visibleRange.left + visibleRange.width;\n\t\t\t}\n\t\t}\n\n\t\tmaxHorizontalOffset = boxEndX;\n\n\t\tboxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);\n\t\tboxEndX += this._revealHorizontalRightPadding;\n\n\t\tconst newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);\n\t\treturn {\n\t\t\tscrollLeft: newScrollLeft,\n\t\t\tmaxHorizontalOffset: maxHorizontalOffset\n\t\t};\n\t}\n\n\tprivate _computeMinimumScrolling(viewportStart: number, viewportEnd: number, boxStart: number, boxEnd: number, revealAtStart?: boolean, revealAtEnd?: boolean): number {\n\t\tviewportStart = viewportStart | 0;\n\t\tviewportEnd = viewportEnd | 0;\n\t\tboxStart = boxStart | 0;\n\t\tboxEnd = boxEnd | 0;\n\t\trevealAtStart = !!revealAtStart;\n\t\trevealAtEnd = !!revealAtEnd;\n\n\t\tconst viewportLength = viewportEnd - viewportStart;\n\t\tconst boxLength = boxEnd - boxStart;\n\n\t\tif (boxLength < viewportLength) {\n\t\t\t// The box would fit in the viewport\n\n\t\t\tif (revealAtStart) {\n\t\t\t\treturn boxStart;\n\t\t\t}\n\n\t\t\tif (revealAtEnd) {\n\t\t\t\treturn Math.max(0, boxEnd - viewportLength);\n\t\t\t}\n\n\t\t\tif (boxStart < viewportStart) {\n\t\t\t\t// The box is above the viewport\n\t\t\t\treturn boxStart;\n\t\t\t} else if (boxEnd > viewportEnd) {\n\t\t\t\t// The box is below the viewport\n\t\t\t\treturn Math.max(0, boxEnd - viewportLength);\n\t\t\t}\n\t\t} else {\n\t\t\t// The box would not fit in the viewport\n\t\t\t// Reveal the beginning of the box\n\t\t\treturn boxStart;\n\t\t}\n\n\t\treturn viewportStart;\n\t}\n}\n"]}]}