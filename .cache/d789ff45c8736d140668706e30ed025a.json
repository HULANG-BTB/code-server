{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/webview/electron-browser/webviewEditor.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/webview/electron-browser/webviewEditor.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/browser/dom\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/platform/contextkey/common/contextkey\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/storage/common/storage\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/theme/common/themeService\", \"vs/platform/windows/common/windows\", \"vs/platform/workspace/common/workspace\", \"vs/workbench/browser/parts/editor/baseEditor\", \"vs/workbench/contrib/webview/electron-browser/webviewEditorInput\", \"vs/workbench/services/editor/common/editorService\", \"vs/workbench/services/layout/browser/layoutService\", \"./webviewElement\"], function (require, exports, DOM, event_1, lifecycle_1, contextkey_1, instantiation_1, storage_1, telemetry_1, themeService_1, windows_1, workspace_1, baseEditor_1, webviewEditorInput_1, editorService_1, layoutService_1, webviewElement_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**  A context key that is set when the find widget in a webview is visible. */\n    exports.KEYBINDING_CONTEXT_WEBVIEW_FIND_WIDGET_VISIBLE = new contextkey_1.RawContextKey('webviewFindWidgetVisible', false);\n    let WebviewEditor = class WebviewEditor extends baseEditor_1.BaseEditor {\n        constructor(telemetryService, themeService, _contextKeyService, _layoutService, _contextService, _instantiationService, _editorService, _windowService, storageService) {\n            super(WebviewEditor.ID, telemetryService, themeService, storageService);\n            this._contextKeyService = _contextKeyService;\n            this._layoutService = _layoutService;\n            this._contextService = _contextService;\n            this._instantiationService = _instantiationService;\n            this._editorService = _editorService;\n            this._windowService = _windowService;\n            this._webviewFocusTrackerDisposables = [];\n            this._onDidFocusWebview = this._register(new event_1.Emitter());\n            this.pendingMessages = [];\n            if (_contextKeyService) {\n                this.findWidgetVisible = exports.KEYBINDING_CONTEXT_WEBVIEW_FIND_WIDGET_VISIBLE.bindTo(_contextKeyService);\n            }\n        }\n        get onDidFocus() { return this._onDidFocusWebview.event; }\n        createEditor(parent) {\n            this._editorFrame = parent;\n            this._content = document.createElement('div');\n            parent.appendChild(this._content);\n        }\n        doUpdateContainer() {\n            const webviewContainer = this.input && this.input.container;\n            if (webviewContainer && webviewContainer.parentElement) {\n                const frameRect = this._editorFrame.getBoundingClientRect();\n                const containerRect = webviewContainer.parentElement.getBoundingClientRect();\n                webviewContainer.style.position = 'absolute';\n                webviewContainer.style.top = `${frameRect.top - containerRect.top}px`;\n                webviewContainer.style.left = `${frameRect.left - containerRect.left}px`;\n                webviewContainer.style.width = `${frameRect.width}px`;\n                webviewContainer.style.height = `${frameRect.height}px`;\n            }\n        }\n        dispose() {\n            this.pendingMessages = [];\n            // Let the editor input dispose of the webview.\n            this._webview = undefined;\n            this._webviewContent = undefined;\n            if (this._content && this._content.parentElement) {\n                this._content.parentElement.removeChild(this._content);\n                this._content = undefined;\n            }\n            this._webviewFocusTrackerDisposables = lifecycle_1.dispose(this._webviewFocusTrackerDisposables);\n            if (this._onFocusWindowHandler) {\n                this._onFocusWindowHandler.dispose();\n            }\n            super.dispose();\n        }\n        sendMessage(data) {\n            if (this._webview) {\n                this._webview.sendMessage(data);\n            }\n            else {\n                this.pendingMessages.push(data);\n            }\n        }\n        showFind() {\n            if (this._webview) {\n                this._webview.showFind();\n                this.findWidgetVisible.set(true);\n            }\n        }\n        hideFind() {\n            this.findWidgetVisible.reset();\n            if (this._webview) {\n                this._webview.hideFind();\n            }\n        }\n        get isWebviewEditor() {\n            return true;\n        }\n        reload() {\n            this.withWebviewElement(webview => webview.reload());\n        }\n        layout(_dimension) {\n            this.withWebviewElement(webview => {\n                this.doUpdateContainer();\n                webview.layout();\n            });\n        }\n        focus() {\n            super.focus();\n            if (!this._onFocusWindowHandler) {\n                // Make sure we restore focus when switching back to a VS Code window\n                this._onFocusWindowHandler = this._windowService.onDidChangeFocus(focused => {\n                    if (focused && this._editorService.activeControl === this) {\n                        this.focus();\n                    }\n                });\n            }\n            this.withWebviewElement(webview => webview.focus());\n        }\n        selectAll() {\n            this.withWebviewElement(webview => webview.selectAll());\n        }\n        copy() {\n            this.withWebviewElement(webview => webview.copy());\n        }\n        paste() {\n            this.withWebviewElement(webview => webview.paste());\n        }\n        cut() {\n            this.withWebviewElement(webview => webview.cut());\n        }\n        undo() {\n            this.withWebviewElement(webview => webview.undo());\n        }\n        redo() {\n            this.withWebviewElement(webview => webview.redo());\n        }\n        withWebviewElement(f) {\n            if (this._webview) {\n                f(this._webview);\n            }\n        }\n        setEditorVisible(visible, group) {\n            if (this.input && this.input instanceof webviewEditorInput_1.WebviewEditorInput) {\n                if (visible) {\n                    this.input.claimWebview(this);\n                }\n                else {\n                    this.input.releaseWebview(this);\n                }\n                this.updateWebview(this.input);\n            }\n            if (this._webviewContent) {\n                if (visible) {\n                    this._webviewContent.style.visibility = 'visible';\n                    this.doUpdateContainer();\n                }\n                else {\n                    this._webviewContent.style.visibility = 'hidden';\n                }\n            }\n            super.setEditorVisible(visible, group);\n        }\n        clearInput() {\n            if (this.input && this.input instanceof webviewEditorInput_1.WebviewEditorInput) {\n                this.input.releaseWebview(this);\n            }\n            this._webview = undefined;\n            this._webviewContent = undefined;\n            this.pendingMessages = [];\n            super.clearInput();\n        }\n        setInput(input, options, token) {\n            if (this.input) {\n                this.input.releaseWebview(this);\n                this._webview = undefined;\n                this._webviewContent = undefined;\n            }\n            this.pendingMessages = [];\n            return super.setInput(input, options, token)\n                .then(() => input.resolve())\n                .then(() => {\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                if (this.group) {\n                    input.updateGroup(this.group.id);\n                }\n                this.updateWebview(input);\n            });\n        }\n        updateWebview(input) {\n            const webview = this.getWebview(input);\n            input.claimWebview(this);\n            webview.update(input.html, {\n                allowScripts: input.options.enableScripts,\n                localResourceRoots: input.options.localResourceRoots || this.getDefaultLocalResourceRoots(),\n                portMappings: input.options.portMapping,\n            }, !!input.options.retainContextWhenHidden);\n            if (this._webviewContent) {\n                this._webviewContent.style.visibility = 'visible';\n            }\n            this.doUpdateContainer();\n        }\n        getDefaultLocalResourceRoots() {\n            const rootPaths = this._contextService.getWorkspace().folders.map(x => x.uri);\n            const extension = this.input.extension;\n            if (extension) {\n                rootPaths.push(extension.location);\n            }\n            return rootPaths;\n        }\n        getWebview(input) {\n            if (this._webview) {\n                return this._webview;\n            }\n            this._webviewContent = input.container;\n            if (input.webview) {\n                this._webview = input.webview;\n            }\n            else {\n                if (input.options.enableFindWidget) {\n                    this._contextKeyService = this._register(this._contextKeyService.createScoped(this._webviewContent));\n                    this.findWidgetVisible = exports.KEYBINDING_CONTEXT_WEBVIEW_FIND_WIDGET_VISIBLE.bindTo(this._contextKeyService);\n                }\n                this._webview = this._instantiationService.createInstance(webviewElement_1.WebviewElement, this._layoutService.getContainer(layoutService_1.Parts.EDITOR_PART), {\n                    allowSvgs: true,\n                    extension: input.extension,\n                    enableFindWidget: input.options.enableFindWidget\n                }, {});\n                this._webview.mountTo(this._webviewContent);\n                input.webview = this._webview;\n                if (input.options.tryRestoreScrollPosition) {\n                    this._webview.initialScrollProgress = input.scrollYPercentage;\n                }\n                this._webview.state = input.webviewState;\n                this._content.setAttribute('aria-flowto', this._webviewContent.id);\n                this.doUpdateContainer();\n            }\n            for (const message of this.pendingMessages) {\n                this._webview.sendMessage(message);\n            }\n            this.pendingMessages = [];\n            this.trackFocus();\n            return this._webview;\n        }\n        trackFocus() {\n            this._webviewFocusTrackerDisposables = lifecycle_1.dispose(this._webviewFocusTrackerDisposables);\n            // Track focus in webview content\n            const webviewContentFocusTracker = DOM.trackFocus(this._webviewContent);\n            this._webviewFocusTrackerDisposables.push(webviewContentFocusTracker);\n            this._webviewFocusTrackerDisposables.push(webviewContentFocusTracker.onDidFocus(() => this._onDidFocusWebview.fire()));\n            // Track focus in webview element\n            this._webviewFocusTrackerDisposables.push(this._webview.onDidFocus(() => this._onDidFocusWebview.fire()));\n        }\n    };\n    WebviewEditor.ID = 'WebviewEditor';\n    WebviewEditor = __decorate([\n        __param(0, telemetry_1.ITelemetryService),\n        __param(1, themeService_1.IThemeService),\n        __param(2, contextkey_1.IContextKeyService),\n        __param(3, layoutService_1.IWorkbenchLayoutService),\n        __param(4, workspace_1.IWorkspaceContextService),\n        __param(5, instantiation_1.IInstantiationService),\n        __param(6, editorService_1.IEditorService),\n        __param(7, windows_1.IWindowService),\n        __param(8, storage_1.IStorageService)\n    ], WebviewEditor);\n    exports.WebviewEditor = WebviewEditor;\n});\n",null]}