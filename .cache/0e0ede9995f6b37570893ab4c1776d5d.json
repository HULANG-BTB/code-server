{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/common/editor/untitledEditorModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/common/editor/untitledEditorModel.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/workbench/common/editor/textEditorModel\", \"vs/editor/common/modes/modesRegistry\", \"vs/platform/files/common/files\", \"vs/editor/common/services/modeService\", \"vs/editor/common/services/modelService\", \"vs/base/common/event\", \"vs/base/common/async\", \"vs/workbench/services/backup/common/backup\", \"vs/editor/common/services/resourceConfiguration\", \"vs/editor/common/model/textModel\"], function (require, exports, textEditorModel_1, modesRegistry_1, files_1, modeService_1, modelService_1, event_1, async_1, backup_1, resourceConfiguration_1, textModel_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let UntitledEditorModel = class UntitledEditorModel extends textEditorModel_1.BaseTextEditorModel {\n        constructor(modeId, resource, _hasAssociatedFilePath, initialValue, preferredEncoding, modeService, modelService, backupFileService, configurationService) {\n            super(modelService, modeService);\n            this.modeId = modeId;\n            this.resource = resource;\n            this._hasAssociatedFilePath = _hasAssociatedFilePath;\n            this.initialValue = initialValue;\n            this.preferredEncoding = preferredEncoding;\n            this.backupFileService = backupFileService;\n            this.configurationService = configurationService;\n            this._onDidChangeContent = this._register(new event_1.Emitter());\n            this._onDidChangeDirty = this._register(new event_1.Emitter());\n            this._onDidChangeEncoding = this._register(new event_1.Emitter());\n            this.dirty = false;\n            this.versionId = 0;\n            this.contentChangeEventScheduler = this._register(new async_1.RunOnceScheduler(() => this._onDidChangeContent.fire(), UntitledEditorModel.DEFAULT_CONTENT_CHANGE_BUFFER_DELAY));\n            this.registerListeners();\n        }\n        get onDidChangeContent() { return this._onDidChangeContent.event; }\n        get onDidChangeDirty() { return this._onDidChangeDirty.event; }\n        get onDidChangeEncoding() { return this._onDidChangeEncoding.event; }\n        get hasAssociatedFilePath() {\n            return this._hasAssociatedFilePath;\n        }\n        getOrCreateMode(modeService, modeId, firstLineText) {\n            if (!modeId || modeId === modesRegistry_1.PLAINTEXT_MODE_ID) {\n                return modeService.createByFilepathOrFirstLine(this.resource.fsPath, firstLineText); // lookup mode via resource path if the provided modeId is unspecific\n            }\n            return super.getOrCreateMode(modeService, modeId, firstLineText);\n        }\n        registerListeners() {\n            // Config Changes\n            this._register(this.configurationService.onDidChangeConfiguration(e => this.onConfigurationChange()));\n        }\n        onConfigurationChange() {\n            const configuredEncoding = this.configurationService.getValue(this.resource, 'files.encoding');\n            if (this.configuredEncoding !== configuredEncoding) {\n                this.configuredEncoding = configuredEncoding;\n                if (!this.preferredEncoding) {\n                    this._onDidChangeEncoding.fire(); // do not fire event if we have a preferred encoding set\n                }\n            }\n        }\n        getVersionId() {\n            return this.versionId;\n        }\n        getModeId() {\n            if (this.textEditorModel) {\n                return this.textEditorModel.getLanguageIdentifier().language;\n            }\n            return this.modeId;\n        }\n        getEncoding() {\n            return this.preferredEncoding || this.configuredEncoding;\n        }\n        setEncoding(encoding) {\n            const oldEncoding = this.getEncoding();\n            this.preferredEncoding = encoding;\n            // Emit if it changed\n            if (oldEncoding !== this.preferredEncoding) {\n                this._onDidChangeEncoding.fire();\n            }\n        }\n        isDirty() {\n            return this.dirty;\n        }\n        setDirty(dirty) {\n            if (this.dirty === dirty) {\n                return;\n            }\n            this.dirty = dirty;\n            this._onDidChangeDirty.fire();\n        }\n        getResource() {\n            return this.resource;\n        }\n        revert() {\n            this.setDirty(false);\n            // Handle content change event buffered\n            this.contentChangeEventScheduler.schedule();\n        }\n        load() {\n            // Check for backups first\n            return this.backupFileService.loadBackupResource(this.resource).then((backupResource) => {\n                if (backupResource) {\n                    return this.backupFileService.resolveBackupContent(backupResource);\n                }\n                return undefined;\n            }).then(backupTextBufferFactory => {\n                const hasBackup = !!backupTextBufferFactory;\n                // untitled associated to file path are dirty right away as well as untitled with content\n                this.setDirty(this._hasAssociatedFilePath || hasBackup);\n                let untitledContents;\n                if (backupTextBufferFactory) {\n                    untitledContents = backupTextBufferFactory;\n                }\n                else {\n                    untitledContents = textModel_1.createTextBufferFactory(this.initialValue || '');\n                }\n                // Create text editor model if not yet done\n                if (!this.textEditorModel) {\n                    this.createTextEditorModel(untitledContents, this.resource, this.modeId);\n                }\n                // Otherwise update\n                else {\n                    this.updateTextEditorModel(untitledContents);\n                }\n                // Encoding\n                this.configuredEncoding = this.configurationService.getValue(this.resource, 'files.encoding');\n                // We know for a fact there is a text editor model here\n                const textEditorModel = this.textEditorModel;\n                // Listen to content changes\n                this._register(textEditorModel.onDidChangeContent(() => this.onModelContentChanged()));\n                // Listen to mode changes\n                this._register(textEditorModel.onDidChangeLanguage(() => this.onConfigurationChange())); // mode change can have impact on config\n                return this;\n            });\n        }\n        onModelContentChanged() {\n            if (!this.isResolved()) {\n                return;\n            }\n            this.versionId++;\n            // mark the untitled editor as non-dirty once its content becomes empty and we do\n            // not have an associated path set. we never want dirty indicator in that case.\n            if (!this._hasAssociatedFilePath && this.textEditorModel && this.textEditorModel.getLineCount() === 1 && this.textEditorModel.getLineContent(1) === '') {\n                this.setDirty(false);\n            }\n            // turn dirty otherwise\n            else {\n                this.setDirty(true);\n            }\n            // Handle content change event buffered\n            this.contentChangeEventScheduler.schedule();\n        }\n        isReadonly() {\n            return false;\n        }\n    };\n    UntitledEditorModel.DEFAULT_CONTENT_CHANGE_BUFFER_DELAY = files_1.CONTENT_CHANGE_EVENT_BUFFER_DELAY;\n    UntitledEditorModel = __decorate([\n        __param(5, modeService_1.IModeService),\n        __param(6, modelService_1.IModelService),\n        __param(7, backup_1.IBackupFileService),\n        __param(8, resourceConfiguration_1.ITextResourceConfigurationService)\n    ], UntitledEditorModel);\n    exports.UntitledEditorModel = UntitledEditorModel;\n});\n",null]}