{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/hover/modesGlyphHover.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/hover/modesGlyphHover.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/browser/dom\", \"vs/base/common/htmlContent\", \"vs/base/common/lifecycle\", \"vs/editor/contrib/hover/hoverOperation\", \"vs/editor/contrib/hover/hoverWidgets\", \"vs/editor/contrib/markdown/markdownRenderer\", \"vs/platform/opener/common/opener\", \"vs/base/common/arrays\"], function (require, exports, dom_1, htmlContent_1, lifecycle_1, hoverOperation_1, hoverWidgets_1, markdownRenderer_1, opener_1, arrays_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class MarginComputer {\n        constructor(editor) {\n            this._editor = editor;\n            this._lineNumber = -1;\n        }\n        setLineNumber(lineNumber) {\n            this._lineNumber = lineNumber;\n            this._result = [];\n        }\n        clearResult() {\n            this._result = [];\n        }\n        computeSync() {\n            const toHoverMessage = (contents) => {\n                return {\n                    value: contents\n                };\n            };\n            const lineDecorations = this._editor.getLineDecorations(this._lineNumber);\n            const result = [];\n            if (!lineDecorations) {\n                return result;\n            }\n            for (const d of lineDecorations) {\n                if (!d.options.glyphMarginClassName) {\n                    continue;\n                }\n                const hoverMessage = d.options.glyphMarginHoverMessage;\n                if (!hoverMessage || htmlContent_1.isEmptyMarkdownString(hoverMessage)) {\n                    continue;\n                }\n                result.push(...arrays_1.asArray(hoverMessage).map(toHoverMessage));\n            }\n            return result;\n        }\n        onResult(result, isFromSynchronousComputation) {\n            this._result = this._result.concat(result);\n        }\n        getResult() {\n            return this._result;\n        }\n        getResultWithLoadingMessage() {\n            return this.getResult();\n        }\n    }\n    class ModesGlyphHoverWidget extends hoverWidgets_1.GlyphHoverWidget {\n        constructor(editor, modeService, openerService = opener_1.NullOpenerService) {\n            super(ModesGlyphHoverWidget.ID, editor);\n            this._lastLineNumber = -1;\n            this._markdownRenderer = new markdownRenderer_1.MarkdownRenderer(this._editor, modeService, openerService);\n            this._computer = new MarginComputer(this._editor);\n            this._hoverOperation = new hoverOperation_1.HoverOperation(this._computer, (result) => this._withResult(result), undefined, (result) => this._withResult(result), 300);\n        }\n        dispose() {\n            this._renderDisposeables = lifecycle_1.dispose(this._renderDisposeables);\n            this._hoverOperation.cancel();\n            super.dispose();\n        }\n        onModelDecorationsChanged() {\n            if (this.isVisible) {\n                // The decorations have changed and the hover is visible,\n                // we need to recompute the displayed text\n                this._hoverOperation.cancel();\n                this._computer.clearResult();\n                this._hoverOperation.start(hoverOperation_1.HoverStartMode.Delayed);\n            }\n        }\n        startShowingAt(lineNumber) {\n            if (this._lastLineNumber === lineNumber) {\n                // We have to show the widget at the exact same line number as before, so no work is needed\n                return;\n            }\n            this._hoverOperation.cancel();\n            this.hide();\n            this._lastLineNumber = lineNumber;\n            this._computer.setLineNumber(lineNumber);\n            this._hoverOperation.start(hoverOperation_1.HoverStartMode.Delayed);\n        }\n        hide() {\n            this._lastLineNumber = -1;\n            this._hoverOperation.cancel();\n            super.hide();\n        }\n        _withResult(result) {\n            this._messages = result;\n            if (this._messages.length > 0) {\n                this._renderMessages(this._lastLineNumber, this._messages);\n            }\n            else {\n                this.hide();\n            }\n        }\n        _renderMessages(lineNumber, messages) {\n            lifecycle_1.dispose(this._renderDisposeables);\n            this._renderDisposeables = [];\n            const fragment = document.createDocumentFragment();\n            messages.forEach((msg) => {\n                const renderedContents = this._markdownRenderer.render(msg.value);\n                this._renderDisposeables.push(renderedContents);\n                fragment.appendChild(dom_1.$('div.hover-row', undefined, renderedContents.element));\n            });\n            this.updateContents(fragment);\n            this.showAt(lineNumber);\n        }\n    }\n    ModesGlyphHoverWidget.ID = 'editor.contrib.modesGlyphHoverWidget';\n    exports.ModesGlyphHoverWidget = ModesGlyphHoverWidget;\n});\n",null]}