{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/indentRangeProvider.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/indentRangeProvider.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/editor/contrib/folding/foldingRanges\", \"vs/editor/common/model/textModel\", \"vs/editor/common/modes/languageConfigurationRegistry\"], function (require, exports, foldingRanges_1, textModel_1, languageConfigurationRegistry_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT = 5000;\n    exports.ID_INDENT_PROVIDER = 'indent';\n    class IndentRangeProvider {\n        constructor(editorModel) {\n            this.editorModel = editorModel;\n            this.id = exports.ID_INDENT_PROVIDER;\n        }\n        dispose() {\n        }\n        compute(cancelationToken) {\n            let foldingRules = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getFoldingRules(this.editorModel.getLanguageIdentifier().id);\n            let offSide = foldingRules && !!foldingRules.offSide;\n            let markers = foldingRules && foldingRules.markers;\n            return Promise.resolve(computeRanges(this.editorModel, offSide, markers));\n        }\n    }\n    exports.IndentRangeProvider = IndentRangeProvider;\n    // public only for testing\n    class RangesCollector {\n        constructor(foldingRangesLimit) {\n            this._startIndexes = [];\n            this._endIndexes = [];\n            this._indentOccurrences = [];\n            this._length = 0;\n            this._foldingRangesLimit = foldingRangesLimit;\n        }\n        insertFirst(startLineNumber, endLineNumber, indent) {\n            if (startLineNumber > foldingRanges_1.MAX_LINE_NUMBER || endLineNumber > foldingRanges_1.MAX_LINE_NUMBER) {\n                return;\n            }\n            let index = this._length;\n            this._startIndexes[index] = startLineNumber;\n            this._endIndexes[index] = endLineNumber;\n            this._length++;\n            if (indent < 1000) {\n                this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;\n            }\n        }\n        toIndentRanges(model) {\n            if (this._length <= this._foldingRangesLimit) {\n                // reverse and create arrays of the exact length\n                let startIndexes = new Uint32Array(this._length);\n                let endIndexes = new Uint32Array(this._length);\n                for (let i = this._length - 1, k = 0; i >= 0; i--, k++) {\n                    startIndexes[k] = this._startIndexes[i];\n                    endIndexes[k] = this._endIndexes[i];\n                }\n                return new foldingRanges_1.FoldingRegions(startIndexes, endIndexes);\n            }\n            else {\n                let entries = 0;\n                let maxIndent = this._indentOccurrences.length;\n                for (let i = 0; i < this._indentOccurrences.length; i++) {\n                    let n = this._indentOccurrences[i];\n                    if (n) {\n                        if (n + entries > this._foldingRangesLimit) {\n                            maxIndent = i;\n                            break;\n                        }\n                        entries += n;\n                    }\n                }\n                const tabSize = model.getOptions().tabSize;\n                // reverse and create arrays of the exact length\n                let startIndexes = new Uint32Array(this._foldingRangesLimit);\n                let endIndexes = new Uint32Array(this._foldingRangesLimit);\n                for (let i = this._length - 1, k = 0; i >= 0; i--) {\n                    let startIndex = this._startIndexes[i];\n                    let lineContent = model.getLineContent(startIndex);\n                    let indent = textModel_1.TextModel.computeIndentLevel(lineContent, tabSize);\n                    if (indent < maxIndent || (indent === maxIndent && entries++ < this._foldingRangesLimit)) {\n                        startIndexes[k] = startIndex;\n                        endIndexes[k] = this._endIndexes[i];\n                        k++;\n                    }\n                }\n                return new foldingRanges_1.FoldingRegions(startIndexes, endIndexes);\n            }\n        }\n    }\n    exports.RangesCollector = RangesCollector;\n    function computeRanges(model, offSide, markers, foldingRangesLimit = MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT) {\n        const tabSize = model.getOptions().tabSize;\n        let result = new RangesCollector(foldingRangesLimit);\n        let pattern = undefined;\n        if (markers) {\n            pattern = new RegExp(`(${markers.start.source})|(?:${markers.end.source})`);\n        }\n        let previousRegions = [];\n        previousRegions.push({ indent: -1, line: model.getLineCount() + 1, marker: false }); // sentinel, to make sure there's at least one entry\n        for (let line = model.getLineCount(); line > 0; line--) {\n            let lineContent = model.getLineContent(line);\n            let indent = textModel_1.TextModel.computeIndentLevel(lineContent, tabSize);\n            let previous = previousRegions[previousRegions.length - 1];\n            if (indent === -1) {\n                if (offSide && !previous.marker) {\n                    // for offSide languages, empty lines are associated to the next block\n                    previous.line = line;\n                }\n                continue; // only whitespace\n            }\n            let m;\n            if (pattern && (m = lineContent.match(pattern))) {\n                // folding pattern match\n                if (m[1]) { // start pattern match\n                    // discard all regions until the folding pattern\n                    let i = previousRegions.length - 1;\n                    while (i > 0 && !previousRegions[i].marker) {\n                        i--;\n                    }\n                    if (i > 0) {\n                        previousRegions.length = i + 1;\n                        previous = previousRegions[i];\n                        // new folding range from pattern, includes the end line\n                        result.insertFirst(line, previous.line, indent);\n                        previous.marker = false;\n                        previous.indent = indent;\n                        previous.line = line;\n                        continue;\n                    }\n                    else {\n                        // no end marker found, treat line as a regular line\n                    }\n                }\n                else { // end pattern match\n                    previousRegions.push({ indent: -2, line, marker: true });\n                    continue;\n                }\n            }\n            if (previous.indent > indent) {\n                // discard all regions with larger indent\n                do {\n                    previousRegions.pop();\n                    previous = previousRegions[previousRegions.length - 1];\n                } while (previous.indent > indent);\n                // new folding range\n                let endLineNumber = previous.line - 1;\n                if (endLineNumber - line >= 1) { // needs at east size 1\n                    result.insertFirst(line, endLineNumber, indent);\n                }\n            }\n            if (previous.indent === indent) {\n                previous.line = line;\n            }\n            else { // previous.indent < indent\n                // new region with a bigger indent\n                previousRegions.push({ indent, line, marker: false });\n            }\n        }\n        return result.toIndentRanges(model);\n    }\n    exports.computeRanges = computeRanges;\n});\n",null]}