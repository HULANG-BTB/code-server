{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/progress/browser/progressService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/progress/browser/progressService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar types = require(\"vs/base/common/types\");\nvar viewlet_1 = require(\"vs/workbench/services/viewlet/browser/viewlet\");\nvar panelService_1 = require(\"vs/workbench/services/panel/common/panelService\");\nvar ProgressState;\n(function (ProgressState) {\n    var Type;\n    (function (Type) {\n        Type[Type[\"None\"] = 0] = \"None\";\n        Type[Type[\"Done\"] = 1] = \"Done\";\n        Type[Type[\"Infinite\"] = 2] = \"Infinite\";\n        Type[Type[\"While\"] = 3] = \"While\";\n        Type[Type[\"Work\"] = 4] = \"Work\";\n    })(Type = ProgressState.Type || (ProgressState.Type = {}));\n    ProgressState.None = new /** @class */ (function () {\n        function class_1() {\n            this.type = Type.None;\n        }\n        return class_1;\n    }());\n    ProgressState.Done = new /** @class */ (function () {\n        function class_2() {\n            this.type = Type.Done;\n        }\n        return class_2;\n    }());\n    ProgressState.Infinite = new /** @class */ (function () {\n        function class_3() {\n            this.type = Type.Infinite;\n        }\n        return class_3;\n    }());\n    var While = /** @class */ (function () {\n        function While(whilePromise, whileStart, whileDelay) {\n            this.whilePromise = whilePromise;\n            this.whileStart = whileStart;\n            this.whileDelay = whileDelay;\n            this.type = Type.While;\n        }\n        return While;\n    }());\n    ProgressState.While = While;\n    var Work = /** @class */ (function () {\n        function Work(total, worked) {\n            this.total = total;\n            this.worked = worked;\n            this.type = Type.Work;\n        }\n        return Work;\n    }());\n    ProgressState.Work = Work;\n})(ProgressState || (ProgressState = {}));\nvar ScopedService = /** @class */ (function (_super) {\n    tslib_1.__extends(ScopedService, _super);\n    function ScopedService(viewletService, panelService, scopeId) {\n        var _this = _super.call(this) || this;\n        _this.viewletService = viewletService;\n        _this.panelService = panelService;\n        _this.scopeId = scopeId;\n        _this.registerListeners();\n        return _this;\n    }\n    ScopedService.prototype.registerListeners = function () {\n        var _this = this;\n        this._register(this.viewletService.onDidViewletOpen(function (viewlet) { return _this.onScopeOpened(viewlet.getId()); }));\n        this._register(this.panelService.onDidPanelOpen(function (_a) {\n            var panel = _a.panel;\n            return _this.onScopeOpened(panel.getId());\n        }));\n        this._register(this.viewletService.onDidViewletClose(function (viewlet) { return _this.onScopeClosed(viewlet.getId()); }));\n        this._register(this.panelService.onDidPanelClose(function (panel) { return _this.onScopeClosed(panel.getId()); }));\n    };\n    ScopedService.prototype.onScopeClosed = function (scopeId) {\n        if (scopeId === this.scopeId) {\n            this.onScopeDeactivated();\n        }\n    };\n    ScopedService.prototype.onScopeOpened = function (scopeId) {\n        if (scopeId === this.scopeId) {\n            this.onScopeActivated();\n        }\n    };\n    return ScopedService;\n}(lifecycle_1.Disposable));\nexports.ScopedService = ScopedService;\nvar ScopedProgressService = /** @class */ (function (_super) {\n    tslib_1.__extends(ScopedProgressService, _super);\n    function ScopedProgressService(progressbar, scopeId, isActive, viewletService, panelService) {\n        var _this = _super.call(this, viewletService, panelService, scopeId) || this;\n        _this.progressState = ProgressState.None;\n        _this.progressbar = progressbar;\n        _this.isActive = isActive || types.isUndefinedOrNull(scopeId); // If service is unscoped, enable by default\n        return _this;\n    }\n    ScopedProgressService.prototype.onScopeDeactivated = function () {\n        this.isActive = false;\n    };\n    ScopedProgressService.prototype.onScopeActivated = function () {\n        this.isActive = true;\n        // Return early if progress state indicates that progress is done\n        if (this.progressState.type === ProgressState.Done.type) {\n            return;\n        }\n        // Replay Infinite Progress from Promise\n        if (this.progressState.type === ProgressState.Type.While) {\n            var delay = void 0;\n            if (this.progressState.whileDelay > 0) {\n                var remainingDelay = this.progressState.whileDelay - (Date.now() - this.progressState.whileStart);\n                if (remainingDelay > 0) {\n                    delay = remainingDelay;\n                }\n            }\n            this.doShowWhile(delay);\n        }\n        // Replay Infinite Progress\n        else if (this.progressState.type === ProgressState.Type.Infinite) {\n            this.progressbar.infinite().show();\n        }\n        // Replay Finite Progress (Total & Worked)\n        else if (this.progressState.type === ProgressState.Type.Work) {\n            if (this.progressState.total) {\n                this.progressbar.total(this.progressState.total).show();\n            }\n            if (this.progressState.worked) {\n                this.progressbar.worked(this.progressState.worked).show();\n            }\n        }\n    };\n    ScopedProgressService.prototype.show = function (infiniteOrTotal, delay) {\n        var _this = this;\n        // Sort out Arguments\n        if (typeof infiniteOrTotal === 'boolean') {\n            this.progressState = ProgressState.Infinite;\n        }\n        else {\n            this.progressState = new ProgressState.Work(infiniteOrTotal, undefined);\n        }\n        // Active: Show Progress\n        if (this.isActive) {\n            // Infinite: Start Progressbar and Show after Delay\n            if (this.progressState.type === ProgressState.Type.Infinite) {\n                this.progressbar.infinite().show(delay);\n            }\n            // Finite: Start Progressbar and Show after Delay\n            else if (this.progressState.type === ProgressState.Type.Work && typeof this.progressState.total === 'number') {\n                this.progressbar.total(this.progressState.total).show(delay);\n            }\n        }\n        return {\n            total: function (total) {\n                _this.progressState = new ProgressState.Work(total, _this.progressState.type === ProgressState.Type.Work ? _this.progressState.worked : undefined);\n                if (_this.isActive) {\n                    _this.progressbar.total(total);\n                }\n            },\n            worked: function (worked) {\n                // Verify first that we are either not active or the progressbar has a total set\n                if (!_this.isActive || _this.progressbar.hasTotal()) {\n                    _this.progressState = new ProgressState.Work(_this.progressState.type === ProgressState.Type.Work ? _this.progressState.total : undefined, _this.progressState.type === ProgressState.Type.Work && typeof _this.progressState.worked === 'number' ? _this.progressState.worked + worked : worked);\n                    if (_this.isActive) {\n                        _this.progressbar.worked(worked);\n                    }\n                }\n                // Otherwise the progress bar does not support worked(), we fallback to infinite() progress\n                else {\n                    _this.progressState = ProgressState.Infinite;\n                    _this.progressbar.infinite().show();\n                }\n            },\n            done: function () {\n                _this.progressState = ProgressState.Done;\n                if (_this.isActive) {\n                    _this.progressbar.stop().hide();\n                }\n            }\n        };\n    };\n    ScopedProgressService.prototype.showWhile = function (promise, delay) {\n        var _this = this;\n        // Join with existing running promise to ensure progress is accurate\n        if (this.progressState.type === ProgressState.Type.While) {\n            promise = Promise.all([promise, this.progressState.whilePromise]);\n        }\n        // Keep Promise in State\n        this.progressState = new ProgressState.While(promise, delay || 0, Date.now());\n        var stop = function () {\n            // If this is not the last promise in the list of joined promises, return early\n            if (_this.progressState.type === ProgressState.Type.While && _this.progressState.whilePromise !== promise) {\n                return;\n            }\n            // The while promise is either null or equal the promise we last hooked on\n            _this.progressState = ProgressState.None;\n            if (_this.isActive) {\n                _this.progressbar.stop().hide();\n            }\n        };\n        this.doShowWhile(delay);\n        return promise.then(stop, stop);\n    };\n    ScopedProgressService.prototype.doShowWhile = function (delay) {\n        // Show Progress when active\n        if (this.isActive) {\n            this.progressbar.infinite().show(delay);\n        }\n    };\n    ScopedProgressService = tslib_1.__decorate([\n        tslib_1.__param(3, viewlet_1.IViewletService),\n        tslib_1.__param(4, panelService_1.IPanelService)\n    ], ScopedProgressService);\n    return ScopedProgressService;\n}(ScopedService));\nexports.ScopedProgressService = ScopedProgressService;\nvar ProgressService = /** @class */ (function () {\n    function ProgressService(progressbar) {\n        this.progressbar = progressbar;\n    }\n    ProgressService.prototype.show = function (infiniteOrTotal, delay) {\n        var _this = this;\n        if (typeof infiniteOrTotal === 'boolean') {\n            this.progressbar.infinite().show(delay);\n        }\n        else {\n            this.progressbar.total(infiniteOrTotal).show(delay);\n        }\n        return {\n            total: function (total) {\n                _this.progressbar.total(total);\n            },\n            worked: function (worked) {\n                if (_this.progressbar.hasTotal()) {\n                    _this.progressbar.worked(worked);\n                }\n                else {\n                    _this.progressbar.infinite().show();\n                }\n            },\n            done: function () {\n                _this.progressbar.stop().hide();\n            }\n        };\n    };\n    ProgressService.prototype.showWhile = function (promise, delay) {\n        var _this = this;\n        var stop = function () {\n            _this.progressbar.stop().hide();\n        };\n        this.progressbar.infinite().show(delay);\n        return promise.then(stop, stop);\n    };\n    return ProgressService;\n}());\nexports.ProgressService = ProgressService;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/progress/browser/progressService.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/progress/browser/progressService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport * as types from 'vs/base/common/types';\nimport { ProgressBar } from 'vs/base/browser/ui/progressbar/progressbar';\nimport { IViewletService } from 'vs/workbench/services/viewlet/browser/viewlet';\nimport { IPanelService } from 'vs/workbench/services/panel/common/panelService';\nimport { IProgressService, IProgressRunner } from 'vs/platform/progress/common/progress';\n\n\nnamespace ProgressState {\n\texport const enum Type {\n\t\tNone,\n\t\tDone,\n\t\tInfinite,\n\t\tWhile,\n\t\tWork\n\t}\n\n\texport const None = new class { readonly type = Type.None; };\n\texport const Done = new class { readonly type = Type.Done; };\n\texport const Infinite = new class { readonly type = Type.Infinite; };\n\n\texport class While {\n\t\tpublic readonly type = Type.While;\n\t\tconstructor(\n\t\t\tpublic readonly whilePromise: Promise<any>,\n\t\t\tpublic readonly whileStart: number,\n\t\t\tpublic readonly whileDelay: number,\n\t\t) { }\n\t}\n\n\texport class Work {\n\t\tpublic readonly type = Type.Work;\n\t\tconstructor(\n\t\t\tpublic readonly total: number | undefined,\n\t\t\tpublic readonly worked: number | undefined\n\t\t) { }\n\t}\n\n\texport type State =\n\t\ttypeof None\n\t\t| typeof Done\n\t\t| typeof Infinite\n\t\t| While\n\t\t| Work;\n}\n\nexport abstract class ScopedService extends Disposable {\n\n\tconstructor(private viewletService: IViewletService, private panelService: IPanelService, private scopeId: string) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tregisterListeners(): void {\n\t\tthis._register(this.viewletService.onDidViewletOpen(viewlet => this.onScopeOpened(viewlet.getId())));\n\t\tthis._register(this.panelService.onDidPanelOpen(({ panel }) => this.onScopeOpened(panel.getId())));\n\n\t\tthis._register(this.viewletService.onDidViewletClose(viewlet => this.onScopeClosed(viewlet.getId())));\n\t\tthis._register(this.panelService.onDidPanelClose(panel => this.onScopeClosed(panel.getId())));\n\t}\n\n\tprivate onScopeClosed(scopeId: string) {\n\t\tif (scopeId === this.scopeId) {\n\t\t\tthis.onScopeDeactivated();\n\t\t}\n\t}\n\n\tprivate onScopeOpened(scopeId: string) {\n\t\tif (scopeId === this.scopeId) {\n\t\t\tthis.onScopeActivated();\n\t\t}\n\t}\n\n\tabstract onScopeActivated(): void;\n\n\tabstract onScopeDeactivated(): void;\n}\n\nexport class ScopedProgressService extends ScopedService implements IProgressService {\n\t_serviceBrand: any;\n\tprivate isActive: boolean;\n\tprivate progressbar: ProgressBar;\n\tprivate progressState: ProgressState.State = ProgressState.None;\n\n\tconstructor(\n\t\tprogressbar: ProgressBar,\n\t\tscopeId: string,\n\t\tisActive: boolean,\n\t\t@IViewletService viewletService: IViewletService,\n\t\t@IPanelService panelService: IPanelService\n\t) {\n\t\tsuper(viewletService, panelService, scopeId);\n\n\t\tthis.progressbar = progressbar;\n\t\tthis.isActive = isActive || types.isUndefinedOrNull(scopeId); // If service is unscoped, enable by default\n\t}\n\n\tonScopeDeactivated(): void {\n\t\tthis.isActive = false;\n\t}\n\n\tonScopeActivated(): void {\n\t\tthis.isActive = true;\n\n\t\t// Return early if progress state indicates that progress is done\n\t\tif (this.progressState.type === ProgressState.Done.type) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Replay Infinite Progress from Promise\n\t\tif (this.progressState.type === ProgressState.Type.While) {\n\t\t\tlet delay: number | undefined;\n\t\t\tif (this.progressState.whileDelay > 0) {\n\t\t\t\tconst remainingDelay = this.progressState.whileDelay - (Date.now() - this.progressState.whileStart);\n\t\t\t\tif (remainingDelay > 0) {\n\t\t\t\t\tdelay = remainingDelay;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.doShowWhile(delay);\n\t\t}\n\n\t\t// Replay Infinite Progress\n\t\telse if (this.progressState.type === ProgressState.Type.Infinite) {\n\t\t\tthis.progressbar.infinite().show();\n\t\t}\n\n\t\t// Replay Finite Progress (Total & Worked)\n\t\telse if (this.progressState.type === ProgressState.Type.Work) {\n\t\t\tif (this.progressState.total) {\n\t\t\t\tthis.progressbar.total(this.progressState.total).show();\n\t\t\t}\n\n\t\t\tif (this.progressState.worked) {\n\t\t\t\tthis.progressbar.worked(this.progressState.worked).show();\n\t\t\t}\n\t\t}\n\t}\n\n\tshow(infinite: true, delay?: number): IProgressRunner;\n\tshow(total: number, delay?: number): IProgressRunner;\n\tshow(infiniteOrTotal: true | number, delay?: number): IProgressRunner {\n\t\t// Sort out Arguments\n\t\tif (typeof infiniteOrTotal === 'boolean') {\n\t\t\tthis.progressState = ProgressState.Infinite;\n\t\t} else {\n\t\t\tthis.progressState = new ProgressState.Work(infiniteOrTotal, undefined);\n\t\t}\n\n\t\t// Active: Show Progress\n\t\tif (this.isActive) {\n\n\t\t\t// Infinite: Start Progressbar and Show after Delay\n\t\t\tif (this.progressState.type === ProgressState.Type.Infinite) {\n\t\t\t\tthis.progressbar.infinite().show(delay);\n\t\t\t}\n\n\t\t\t// Finite: Start Progressbar and Show after Delay\n\t\t\telse if (this.progressState.type === ProgressState.Type.Work && typeof this.progressState.total === 'number') {\n\t\t\t\tthis.progressbar.total(this.progressState.total).show(delay);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttotal: (total: number) => {\n\t\t\t\tthis.progressState = new ProgressState.Work(\n\t\t\t\t\ttotal,\n\t\t\t\t\tthis.progressState.type === ProgressState.Type.Work ? this.progressState.worked : undefined);\n\n\t\t\t\tif (this.isActive) {\n\t\t\t\t\tthis.progressbar.total(total);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tworked: (worked: number) => {\n\n\t\t\t\t// Verify first that we are either not active or the progressbar has a total set\n\t\t\t\tif (!this.isActive || this.progressbar.hasTotal()) {\n\t\t\t\t\tthis.progressState = new ProgressState.Work(\n\t\t\t\t\t\tthis.progressState.type === ProgressState.Type.Work ? this.progressState.total : undefined,\n\t\t\t\t\t\tthis.progressState.type === ProgressState.Type.Work && typeof this.progressState.worked === 'number' ? this.progressState.worked + worked : worked);\n\n\t\t\t\t\tif (this.isActive) {\n\t\t\t\t\t\tthis.progressbar.worked(worked);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Otherwise the progress bar does not support worked(), we fallback to infinite() progress\n\t\t\t\telse {\n\t\t\t\t\tthis.progressState = ProgressState.Infinite;\n\t\t\t\t\tthis.progressbar.infinite().show();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tdone: () => {\n\t\t\t\tthis.progressState = ProgressState.Done;\n\n\t\t\t\tif (this.isActive) {\n\t\t\t\t\tthis.progressbar.stop().hide();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tshowWhile(promise: Promise<any>, delay?: number): Promise<void> {\n\t\t// Join with existing running promise to ensure progress is accurate\n\t\tif (this.progressState.type === ProgressState.Type.While) {\n\t\t\tpromise = Promise.all([promise, this.progressState.whilePromise]);\n\t\t}\n\n\t\t// Keep Promise in State\n\t\tthis.progressState = new ProgressState.While(promise, delay || 0, Date.now());\n\n\t\tlet stop = () => {\n\n\t\t\t// If this is not the last promise in the list of joined promises, return early\n\t\t\tif (this.progressState.type === ProgressState.Type.While && this.progressState.whilePromise !== promise) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// The while promise is either null or equal the promise we last hooked on\n\t\t\tthis.progressState = ProgressState.None;\n\n\t\t\tif (this.isActive) {\n\t\t\t\tthis.progressbar.stop().hide();\n\t\t\t}\n\t\t};\n\n\t\tthis.doShowWhile(delay);\n\n\t\treturn promise.then(stop, stop);\n\t}\n\n\tprivate doShowWhile(delay?: number): void {\n\n\t\t// Show Progress when active\n\t\tif (this.isActive) {\n\t\t\tthis.progressbar.infinite().show(delay);\n\t\t}\n\t}\n}\n\nexport class ProgressService implements IProgressService {\n\n\t_serviceBrand: any;\n\n\tconstructor(private progressbar: ProgressBar) { }\n\n\tshow(infinite: true, delay?: number): IProgressRunner;\n\tshow(total: number, delay?: number): IProgressRunner;\n\tshow(infiniteOrTotal: true | number, delay?: number): IProgressRunner {\n\t\tif (typeof infiniteOrTotal === 'boolean') {\n\t\t\tthis.progressbar.infinite().show(delay);\n\t\t} else {\n\t\t\tthis.progressbar.total(infiniteOrTotal).show(delay);\n\t\t}\n\n\t\treturn {\n\t\t\ttotal: (total: number) => {\n\t\t\t\tthis.progressbar.total(total);\n\t\t\t},\n\n\t\t\tworked: (worked: number) => {\n\t\t\t\tif (this.progressbar.hasTotal()) {\n\t\t\t\t\tthis.progressbar.worked(worked);\n\t\t\t\t} else {\n\t\t\t\t\tthis.progressbar.infinite().show();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tdone: () => {\n\t\t\t\tthis.progressbar.stop().hide();\n\t\t\t}\n\t\t};\n\t}\n\n\tshowWhile(promise: Promise<any>, delay?: number): Promise<void> {\n\t\tconst stop = () => {\n\t\t\tthis.progressbar.stop().hide();\n\t\t};\n\n\t\tthis.progressbar.infinite().show(delay);\n\n\t\treturn promise.then(stop, stop);\n\t}\n}\n"]}]}