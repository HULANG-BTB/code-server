{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/fileService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/fileService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/path\", \"fs\", \"os\", \"crypto\", \"assert\", \"vs/platform/files/common/files\", \"vs/platform/files/node/fileConstants\", \"vs/base/common/extpath\", \"vs/base/common/map\", \"vs/base/common/arrays\", \"vs/base/common/objects\", \"vs/base/node/extfs\", \"vs/base/common/async\", \"vs/base/common/uri\", \"vs/nls\", \"vs/base/common/platform\", \"vs/base/common/lifecycle\", \"vs/platform/workspace/common/workspace\", \"vs/base/node/pfs\", \"vs/base/node/encoding\", \"vs/base/node/flow\", \"vs/workbench/services/files/node/watcher/unix/watcherService\", \"vs/workbench/services/files/node/watcher/win32/watcherService\", \"vs/workbench/services/files/node/watcher/common\", \"vs/base/common/event\", \"vs/workbench/services/files/node/watcher/nsfw/watcherService\", \"vs/base/common/cancellation\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/base/common/labels\", \"vs/base/common/network\", \"vs/platform/storage/common/storage\", \"vs/platform/notification/common/notification\", \"vs/base/common/errors\", \"vs/platform/product/node/product\", \"vs/workbench/services/files/node/encoding\", \"vs/workbench/services/files/node/streams\", \"vs/base/common/types\"], function (require, exports, paths, fs, os, crypto, assert, files_1, fileConstants_1, extpath_1, map_1, arrays, objects, extfs, async_1, uri_1, nls, platform_1, lifecycle_1, workspace_1, pfs, encoding_1, flow, watcherService_1, watcherService_2, common_1, event_1, watcherService_3, cancellation_1, lifecycle_2, labels_1, network_1, storage_1, notification_1, errors_1, product_1, encoding_2, streams_1, types_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class FileService extends lifecycle_1.Disposable {\n        constructor(contextService, environmentService, textResourceConfigurationService, configurationService, lifecycleService, storageService, notificationService, options = Object.create(null)) {\n            super();\n            this.contextService = contextService;\n            this.environmentService = environmentService;\n            this.textResourceConfigurationService = textResourceConfigurationService;\n            this.configurationService = configurationService;\n            this.lifecycleService = lifecycleService;\n            this.storageService = storageService;\n            this.notificationService = notificationService;\n            this.options = options;\n            this._onFileChanges = this._register(new event_1.Emitter());\n            this._onAfterOperation = this._register(new event_1.Emitter());\n            this._onDidChangeFileSystemProviderRegistrations = this._register(new event_1.Emitter());\n            this.onWillActivateFileSystemProvider = event_1.Event.None;\n            this.activeFileChangesWatchers = new map_1.ResourceMap();\n            this.fileChangesWatchDelayer = new async_1.ThrottledDelayer(FileService.FS_EVENT_DELAY);\n            this.undeliveredRawFileChangesEvents = [];\n            this._encoding = new encoding_2.ResourceEncodings(textResourceConfigurationService, environmentService, contextService, this.options.encodingOverride);\n            this.registerListeners();\n        }\n        get onFileChanges() { return this._onFileChanges.event; }\n        get onAfterOperation() { return this._onAfterOperation.event; }\n        get onDidChangeFileSystemProviderRegistrations() { return this._onDidChangeFileSystemProviderRegistrations.event; }\n        get encoding() {\n            return this._encoding;\n        }\n        registerListeners() {\n            // Wait until we are fully running before starting file watchers\n            this.lifecycleService.when(lifecycle_2.LifecyclePhase.Restored).then(() => {\n                this.setupFileWatching();\n            });\n            // Workbench State Change\n            this._register(this.contextService.onDidChangeWorkbenchState(() => {\n                if (this.lifecycleService.phase >= lifecycle_2.LifecyclePhase.Restored) {\n                    this.setupFileWatching();\n                }\n            }));\n            // Lifecycle\n            this.lifecycleService.onShutdown(this.dispose, this);\n        }\n        handleError(error) {\n            const msg = error ? error.toString() : undefined;\n            if (!msg) {\n                return;\n            }\n            // Forward to unexpected error handler\n            errors_1.onUnexpectedError(msg);\n            // Detect if we run < .NET Framework 4.5 (TODO@ben remove with new watcher impl)\n            if (msg.indexOf(FileService.NET_VERSION_ERROR) >= 0 && !this.storageService.getBoolean(FileService.NET_VERSION_ERROR_IGNORE_KEY, storage_1.StorageScope.WORKSPACE)) {\n                this.notificationService.prompt(notification_1.Severity.Warning, nls.localize('netVersionError', \"The Microsoft .NET Framework 4.5 is required. Please follow the link to install it.\"), [{\n                        label: nls.localize('installNet', \"Download .NET Framework 4.5\"),\n                        run: () => window.open('https://go.microsoft.com/fwlink/?LinkId=786533')\n                    },\n                    {\n                        label: nls.localize('neverShowAgain', \"Don't Show Again\"),\n                        isSecondary: true,\n                        run: () => this.storageService.store(FileService.NET_VERSION_ERROR_IGNORE_KEY, true, storage_1.StorageScope.WORKSPACE)\n                    }], { sticky: true });\n            }\n            // Detect if we run into ENOSPC issues\n            if (msg.indexOf(FileService.ENOSPC_ERROR) >= 0 && !this.storageService.getBoolean(FileService.ENOSPC_ERROR_IGNORE_KEY, storage_1.StorageScope.WORKSPACE)) {\n                this.notificationService.prompt(notification_1.Severity.Warning, nls.localize('enospcError', \"{0} is unable to watch for file changes in this large workspace. Please follow the instructions link to resolve this issue.\", product_1.default.nameLong), [{\n                        label: nls.localize('learnMore', \"Instructions\"),\n                        run: () => window.open('https://go.microsoft.com/fwlink/?linkid=867693')\n                    },\n                    {\n                        label: nls.localize('neverShowAgain', \"Don't Show Again\"),\n                        isSecondary: true,\n                        run: () => this.storageService.store(FileService.ENOSPC_ERROR_IGNORE_KEY, true, storage_1.StorageScope.WORKSPACE)\n                    }], { sticky: true });\n            }\n        }\n        setupFileWatching() {\n            // dispose old if any\n            if (this.activeWorkspaceFileChangeWatcher) {\n                this.activeWorkspaceFileChangeWatcher.dispose();\n            }\n            // Return if not aplicable\n            const workbenchState = this.contextService.getWorkbenchState();\n            if (workbenchState === workspace_1.WorkbenchState.EMPTY || this.options.disableWatcher) {\n                return;\n            }\n            // new watcher: use it if setting tells us so or we run in multi-root environment\n            const configuration = this.configurationService.getValue();\n            if ((configuration.files && configuration.files.useExperimentalFileWatcher) || workbenchState === workspace_1.WorkbenchState.WORKSPACE) {\n                const multiRootWatcher = new watcherService_3.FileWatcher(this.contextService, this.configurationService, e => this._onFileChanges.fire(e), err => this.handleError(err), this.environmentService.verbose);\n                this.activeWorkspaceFileChangeWatcher = lifecycle_1.toDisposable(multiRootWatcher.startWatching());\n            }\n            // legacy watcher\n            else {\n                let watcherIgnoredPatterns = [];\n                if (configuration.files && configuration.files.watcherExclude) {\n                    watcherIgnoredPatterns = Object.keys(configuration.files.watcherExclude).filter(k => !!configuration.files.watcherExclude[k]);\n                }\n                if (platform_1.isWindows) {\n                    const legacyWindowsWatcher = new watcherService_2.FileWatcher(this.contextService, watcherIgnoredPatterns, e => this._onFileChanges.fire(e), err => this.handleError(err), this.environmentService.verbose);\n                    this.activeWorkspaceFileChangeWatcher = lifecycle_1.toDisposable(legacyWindowsWatcher.startWatching());\n                }\n                else {\n                    const legacyUnixWatcher = new watcherService_1.FileWatcher(this.contextService, this.configurationService, e => this._onFileChanges.fire(e), err => this.handleError(err), this.environmentService.verbose);\n                    this.activeWorkspaceFileChangeWatcher = lifecycle_1.toDisposable(legacyUnixWatcher.startWatching());\n                }\n            }\n        }\n        registerProvider(scheme, provider) {\n            return lifecycle_1.Disposable.None;\n        }\n        activateProvider(scheme) {\n            return Promise.reject(new Error('not implemented'));\n        }\n        canHandleResource(resource) {\n            return resource.scheme === network_1.Schemas.file;\n        }\n        hasCapability(resource, capability) {\n            return Promise.resolve(false);\n        }\n        resolveContent(resource, options) {\n            return this.resolveStreamContent(resource, options).then(streamContent => {\n                return new Promise((resolve, reject) => {\n                    const result = {\n                        resource: streamContent.resource,\n                        name: streamContent.name,\n                        mtime: streamContent.mtime,\n                        etag: streamContent.etag,\n                        encoding: streamContent.encoding,\n                        isReadonly: streamContent.isReadonly,\n                        size: streamContent.size,\n                        value: ''\n                    };\n                    streamContent.value.on('data', chunk => result.value += chunk);\n                    streamContent.value.on('error', err => reject(err));\n                    streamContent.value.on('end', () => resolve(result));\n                    return result;\n                });\n            });\n        }\n        resolveStreamContent(resource, options) {\n            // Guard early against attempts to resolve an invalid file path\n            if (resource.scheme !== network_1.Schemas.file || !resource.fsPath) {\n                return Promise.reject(new files_1.FileOperationError(nls.localize('fileInvalidPath', \"Invalid file resource ({0})\", resource.toString(true)), files_1.FileOperationResult.FILE_INVALID_PATH, options));\n            }\n            const result = {\n                resource: undefined,\n                name: undefined,\n                mtime: undefined,\n                etag: undefined,\n                encoding: undefined,\n                isReadonly: false,\n                value: undefined\n            };\n            const contentResolverTokenSource = new cancellation_1.CancellationTokenSource();\n            const onStatError = (error) => {\n                // error: stop reading the file the stat and content resolve call\n                // usually race, mostly likely the stat call will win and cancel\n                // the content call\n                contentResolverTokenSource.cancel();\n                // forward error\n                return Promise.reject(error);\n            };\n            const statsPromise = this.resolveFile(resource).then(stat => {\n                result.resource = stat.resource;\n                result.name = stat.name;\n                result.mtime = stat.mtime;\n                result.etag = stat.etag;\n                result.size = stat.size;\n                // Return early if resource is a directory\n                if (stat.isDirectory) {\n                    return onStatError(new files_1.FileOperationError(nls.localize('fileIsDirectoryError', \"File is directory\"), files_1.FileOperationResult.FILE_IS_DIRECTORY, options));\n                }\n                // Return early if file not modified since\n                if (options && options.etag && options.etag === stat.etag) {\n                    return onStatError(new files_1.FileOperationError(nls.localize('fileNotModifiedError', \"File not modified since\"), files_1.FileOperationResult.FILE_NOT_MODIFIED_SINCE, options));\n                }\n                // Return early if file is too large to load\n                if (typeof stat.size === 'number') {\n                    if (stat.size > Math.max(typeof this.environmentService.args['max-memory'] === 'string' ? parseInt(this.environmentService.args['max-memory']) * 1024 * 1024 || 0 : 0, fileConstants_1.MAX_HEAP_SIZE)) {\n                        return onStatError(new files_1.FileOperationError(nls.localize('fileTooLargeForHeapError', \"To open a file of this size, you need to restart VS Code and allow it to use more memory\"), files_1.FileOperationResult.FILE_EXCEED_MEMORY_LIMIT));\n                    }\n                    if (stat.size > fileConstants_1.MAX_FILE_SIZE) {\n                        return onStatError(new files_1.FileOperationError(nls.localize('fileTooLargeError', \"File too large to open\"), files_1.FileOperationResult.FILE_TOO_LARGE));\n                    }\n                }\n                return undefined;\n            }, err => {\n                // Wrap file not found errors\n                if (err.code === 'ENOENT') {\n                    return onStatError(new files_1.FileOperationError(nls.localize('fileNotFoundError', \"File not found ({0})\", resource.toString(true)), files_1.FileOperationResult.FILE_NOT_FOUND, options));\n                }\n                return onStatError(err);\n            });\n            let completePromise;\n            // await the stat iff we already have an etag so that we compare the\n            // etag from the stat before we actually read the file again.\n            if (options && options.etag) {\n                completePromise = statsPromise.then(() => {\n                    return this.fillInContents(result, resource, options, contentResolverTokenSource.token); // Waterfall -> only now resolve the contents\n                });\n            }\n            // a fresh load without a previous etag which means we can resolve the file stat\n            // and the content at the same time, avoiding the waterfall.\n            else {\n                let statsError;\n                let contentsError;\n                completePromise = Promise.all([\n                    statsPromise.then(() => undefined, error => statsError = error),\n                    this.fillInContents(result, resource, options, contentResolverTokenSource.token).then(() => undefined, error => contentsError = error)\n                ]).then(() => {\n                    // Since each file operation can return a FileOperationError\n                    // we want to prefer that one if possible. Otherwise we just\n                    // return with the first error we get.\n                    if (files_1.FileOperationError.isFileOperationError(statsError)) {\n                        return Promise.reject(statsError);\n                    }\n                    if (files_1.FileOperationError.isFileOperationError(contentsError)) {\n                        return Promise.reject(contentsError);\n                    }\n                    if (statsError || contentsError) {\n                        return Promise.reject(statsError || contentsError);\n                    }\n                    return undefined;\n                });\n            }\n            return completePromise.then(() => {\n                contentResolverTokenSource.dispose();\n                return result;\n            }, error => {\n                contentResolverTokenSource.dispose();\n                return Promise.reject(error);\n            });\n        }\n        fillInContents(content, resource, options, token) {\n            return this.resolveFileData(resource, options, token).then(data => {\n                content.encoding = data.encoding;\n                content.value = data.stream;\n            });\n        }\n        resolveFileData(resource, options, token) {\n            const chunkBuffer = Buffer.allocUnsafe(64 * 1024);\n            const result = {\n                encoding: undefined,\n                stream: undefined\n            };\n            return new Promise((resolve, reject) => {\n                fs.open(this.toAbsolutePath(resource), 'r', (err, fd) => {\n                    if (err) {\n                        if (err.code === 'ENOENT') {\n                            // Wrap file not found errors\n                            err = new files_1.FileOperationError(nls.localize('fileNotFoundError', \"File not found ({0})\", resource.toString(true)), files_1.FileOperationResult.FILE_NOT_FOUND, options);\n                        }\n                        return reject(err);\n                    }\n                    let decoder;\n                    let totalBytesRead = 0;\n                    const finish = (err) => {\n                        if (err) {\n                            if (err.code === 'EISDIR') {\n                                // Wrap EISDIR errors (fs.open on a directory works, but you cannot read from it)\n                                err = new files_1.FileOperationError(nls.localize('fileIsDirectoryError', \"File is directory\"), files_1.FileOperationResult.FILE_IS_DIRECTORY, options);\n                            }\n                            if (decoder) {\n                                // If the decoder already started, we have to emit the error through it as\n                                // event because the promise is already resolved!\n                                decoder.emit('error', err);\n                            }\n                            else {\n                                reject(err);\n                            }\n                        }\n                        if (decoder) {\n                            decoder.end();\n                        }\n                        if (fd) {\n                            fs.close(fd, err => {\n                                if (err) {\n                                    this.handleError(`resolveFileData#close(): ${err.toString()}`);\n                                }\n                            });\n                        }\n                    };\n                    const handleChunk = (bytesRead) => {\n                        if (token.isCancellationRequested) {\n                            // cancellation -> finish\n                            finish(new Error('cancelled'));\n                        }\n                        else if (bytesRead === 0) {\n                            // no more data -> finish\n                            finish();\n                        }\n                        else if (bytesRead < chunkBuffer.length) {\n                            // write the sub-part of data we received -> repeat\n                            decoder.write(chunkBuffer.slice(0, bytesRead), readChunk);\n                        }\n                        else {\n                            // write all data we received -> repeat\n                            decoder.write(chunkBuffer, readChunk);\n                        }\n                    };\n                    let currentPosition = types_1.withUndefinedAsNull(options && options.position);\n                    const readChunk = () => {\n                        fs.read(fd, chunkBuffer, 0, chunkBuffer.length, currentPosition, (err, bytesRead) => {\n                            totalBytesRead += bytesRead;\n                            if (typeof currentPosition === 'number') {\n                                // if we received a position argument as option we need to ensure that\n                                // we advance the position by the number of bytesread\n                                currentPosition += bytesRead;\n                            }\n                            if (totalBytesRead > Math.max(typeof this.environmentService.args['max-memory'] === 'number' ? parseInt(this.environmentService.args['max-memory']) * 1024 * 1024 || 0 : 0, fileConstants_1.MAX_HEAP_SIZE)) {\n                                finish(new files_1.FileOperationError(nls.localize('fileTooLargeForHeapError', \"To open a file of this size, you need to restart VS Code and allow it to use more memory\"), files_1.FileOperationResult.FILE_EXCEED_MEMORY_LIMIT));\n                            }\n                            if (totalBytesRead > fileConstants_1.MAX_FILE_SIZE) {\n                                // stop when reading too much\n                                finish(new files_1.FileOperationError(nls.localize('fileTooLargeError', \"File too large to open\"), files_1.FileOperationResult.FILE_TOO_LARGE, options));\n                            }\n                            else if (err) {\n                                // some error happened\n                                finish(err);\n                            }\n                            else if (decoder) {\n                                // pass on to decoder\n                                handleChunk(bytesRead);\n                            }\n                            else {\n                                // when receiving the first chunk of data we need to create the\n                                // decoding stream which is then used to drive the string stream.\n                                Promise.resolve(encoding_1.detectEncodingFromBuffer({ buffer: chunkBuffer, bytesRead }, (options && options.autoGuessEncoding) || this.textResourceConfigurationService.getValue(resource, 'files.autoGuessEncoding'))).then(detected => {\n                                    if (options && options.acceptTextOnly && detected.seemsBinary) {\n                                        // Return error early if client only accepts text and this is not text\n                                        finish(new files_1.FileOperationError(nls.localize('fileBinaryError', \"File seems to be binary and cannot be opened as text\"), files_1.FileOperationResult.FILE_IS_BINARY, options));\n                                    }\n                                    else {\n                                        result.encoding = this._encoding.getReadEncoding(resource, options, detected);\n                                        result.stream = decoder = encoding_1.decodeStream(result.encoding);\n                                        resolve(result);\n                                        handleChunk(bytesRead);\n                                    }\n                                }).then(undefined, err => {\n                                    // failed to get encoding\n                                    finish(err);\n                                });\n                            }\n                        });\n                    };\n                    // start reading\n                    readChunk();\n                });\n            });\n        }\n        updateContent(resource, value, options = Object.create(null)) {\n            if (options.writeElevated) {\n                return this.doUpdateContentElevated(resource, value, options);\n            }\n            return this.doUpdateContent(resource, value, options);\n        }\n        doUpdateContent(resource, value, options = Object.create(null)) {\n            const absolutePath = this.toAbsolutePath(resource);\n            // 1.) check file for writing\n            return this.checkFileBeforeWriting(absolutePath, options).then(exists => {\n                let createParentsPromise;\n                if (exists) {\n                    createParentsPromise = Promise.resolve();\n                }\n                else {\n                    createParentsPromise = pfs.mkdirp(paths.dirname(absolutePath));\n                }\n                // 2.) create parents as needed\n                return createParentsPromise.then(() => {\n                    const { encoding, hasBOM } = this._encoding.getWriteEncoding(resource, options.encoding);\n                    let addBomPromise = Promise.resolve(false);\n                    // Some encodings come with a BOM automatically\n                    if (hasBOM) {\n                        addBomPromise = Promise.resolve(hasBOM);\n                    }\n                    // Existing UTF-8 file: check for options regarding BOM\n                    else if (exists && encoding === encoding_1.UTF8) {\n                        if (options.overwriteEncoding) {\n                            addBomPromise = Promise.resolve(false); // if we are to overwrite the encoding, we do not preserve it if found\n                        }\n                        else {\n                            addBomPromise = encoding_1.detectEncodingByBOM(absolutePath).then(enc => enc === encoding_1.UTF8); // otherwise preserve it if found\n                        }\n                    }\n                    // 3.) check to add UTF BOM\n                    return addBomPromise.then(addBom => {\n                        // 4.) set contents and resolve\n                        if (!exists || !platform_1.isWindows) {\n                            return this.doSetContentsAndResolve(resource, absolutePath, value, addBom, encoding);\n                        }\n                        // On Windows and if the file exists, we use a different strategy of saving the file\n                        // by first truncating the file and then writing with r+ mode. This helps to save hidden files on Windows\n                        // (see https://github.com/Microsoft/vscode/issues/931) and prevent removing alternate data streams\n                        // (see https://github.com/Microsoft/vscode/issues/6363)\n                        else {\n                            // 4.) truncate\n                            return pfs.truncate(absolutePath, 0).then(() => {\n                                // 5.) set contents (with r+ mode) and resolve\n                                return this.doSetContentsAndResolve(resource, absolutePath, value, addBom, encoding, { flag: 'r+' }).then(undefined, error => {\n                                    if (this.environmentService.verbose) {\n                                        console.error(`Truncate succeeded, but save failed (${error}), retrying after 100ms`);\n                                    }\n                                    // We heard from one user that fs.truncate() succeeds, but the save fails (https://github.com/Microsoft/vscode/issues/61310)\n                                    // In that case, the file is now entirely empty and the contents are gone. This can happen if an external file watcher is\n                                    // installed that reacts on the truncate and keeps the file busy right after. Our workaround is to retry to save after a\n                                    // short timeout, assuming that the file is free to write then.\n                                    return async_1.timeout(100).then(() => this.doSetContentsAndResolve(resource, absolutePath, value, addBom, encoding, { flag: 'r+' }));\n                                });\n                            }, error => {\n                                if (this.environmentService.verbose) {\n                                    console.error(`Truncate failed (${error}), falling back to normal save`);\n                                }\n                                // we heard from users that fs.truncate() fails (https://github.com/Microsoft/vscode/issues/59561)\n                                // in that case we simply save the file without truncating first (same as macOS and Linux)\n                                return this.doSetContentsAndResolve(resource, absolutePath, value, addBom, encoding);\n                            });\n                        }\n                    });\n                });\n            }).then(undefined, error => {\n                if (error.code === 'EACCES' || error.code === 'EPERM') {\n                    return Promise.reject(new files_1.FileOperationError(nls.localize('filePermission', \"Permission denied writing to file ({0})\", resource.toString(true)), files_1.FileOperationResult.FILE_PERMISSION_DENIED, options));\n                }\n                return Promise.reject(error);\n            });\n        }\n        doSetContentsAndResolve(resource, absolutePath, value, addBOM, encodingToWrite, options) {\n            // Configure encoding related options as needed\n            const writeFileOptions = options ? options : Object.create(null);\n            if (addBOM || encodingToWrite !== encoding_1.UTF8) {\n                writeFileOptions.encoding = {\n                    charset: encodingToWrite,\n                    addBOM\n                };\n            }\n            let writeFilePromise;\n            if (typeof value === 'string') {\n                writeFilePromise = pfs.writeFile(absolutePath, value, writeFileOptions);\n            }\n            else {\n                writeFilePromise = pfs.writeFile(absolutePath, streams_1.createReadableOfSnapshot(value), writeFileOptions);\n            }\n            // set contents\n            return writeFilePromise.then(() => {\n                // resolve\n                return this.resolve(resource);\n            });\n        }\n        doUpdateContentElevated(resource, value, options = Object.create(null)) {\n            const absolutePath = this.toAbsolutePath(resource);\n            // 1.) check file for writing\n            return this.checkFileBeforeWriting(absolutePath, options, options.overwriteReadonly /* ignore readonly if we overwrite readonly, this is handled via sudo later */).then(exists => {\n                const writeOptions = objects.assign(Object.create(null), options);\n                writeOptions.writeElevated = false;\n                writeOptions.encoding = this._encoding.getWriteEncoding(resource, options.encoding).encoding;\n                // 2.) write to a temporary file to be able to copy over later\n                const tmpPath = paths.join(os.tmpdir(), `code-elevated-${Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 6)}`);\n                return this.updateContent(uri_1.URI.file(tmpPath), value, writeOptions).then(() => {\n                    // 3.) invoke our CLI as super user\n                    return new Promise((resolve_1, reject_1) => { require(['sudo-prompt'], resolve_1, reject_1); }).then(sudoPrompt => {\n                        return new Promise((resolve, reject) => {\n                            const promptOptions = {\n                                name: this.environmentService.appNameLong.replace('-', ''),\n                                icns: (platform_1.isMacintosh && this.environmentService.isBuilt) ? paths.join(paths.dirname(this.environmentService.appRoot), `${product_1.default.nameShort}.icns`) : undefined\n                            };\n                            const sudoCommand = [`\"${this.environmentService.cliPath}\"`];\n                            if (options.overwriteReadonly) {\n                                sudoCommand.push('--file-chmod');\n                            }\n                            sudoCommand.push('--file-write', `\"${tmpPath}\"`, `\"${absolutePath}\"`);\n                            sudoPrompt.exec(sudoCommand.join(' '), promptOptions, (error, stdout, stderr) => {\n                                if (error || stderr) {\n                                    reject(error || stderr);\n                                }\n                                else {\n                                    resolve(undefined);\n                                }\n                            });\n                        });\n                    }).then(() => {\n                        // 3.) delete temp file\n                        return pfs.del(tmpPath, os.tmpdir()).then(() => {\n                            // 4.) resolve again\n                            return this.resolve(resource);\n                        });\n                    });\n                });\n            }).then(undefined, error => {\n                if (this.environmentService.verbose) {\n                    this.handleError(`Unable to write to file '${resource.toString(true)}' as elevated user (${error})`);\n                }\n                if (!files_1.FileOperationError.isFileOperationError(error)) {\n                    error = new files_1.FileOperationError(nls.localize('filePermission', \"Permission denied writing to file ({0})\", resource.toString(true)), files_1.FileOperationResult.FILE_PERMISSION_DENIED, options);\n                }\n                return Promise.reject(error);\n            });\n        }\n        createFile(resource, content = '', options = Object.create(null)) {\n            const absolutePath = this.toAbsolutePath(resource);\n            let checkFilePromise;\n            if (options.overwrite) {\n                checkFilePromise = Promise.resolve(false);\n            }\n            else {\n                checkFilePromise = pfs.exists(absolutePath);\n            }\n            // Check file exists\n            return checkFilePromise.then(exists => {\n                if (exists && !options.overwrite) {\n                    return Promise.reject(new files_1.FileOperationError(nls.localize('fileExists', \"File to create already exists ({0})\", resource.toString(true)), files_1.FileOperationResult.FILE_MODIFIED_SINCE, options));\n                }\n                // Create file\n                return this.updateContent(resource, content).then(result => {\n                    // Events\n                    this._onAfterOperation.fire(new files_1.FileOperationEvent(resource, files_1.FileOperation.CREATE, result));\n                    return result;\n                });\n            });\n        }\n        checkFileBeforeWriting(absolutePath, options = Object.create(null), ignoreReadonly) {\n            return pfs.exists(absolutePath).then(exists => {\n                if (exists) {\n                    return pfs.stat(absolutePath).then(stat => {\n                        if (stat.isDirectory()) {\n                            return Promise.reject(new Error('Expected file is actually a directory'));\n                        }\n                        // Dirty write prevention: if the file on disk has been changed and does not match our expected\n                        // mtime and etag, we bail out to prevent dirty writing.\n                        //\n                        // First, we check for a mtime that is in the future before we do more checks. The assumption is\n                        // that only the mtime is an indicator for a file that has changd on disk.\n                        //\n                        // Second, if the mtime has advanced, we compare the size of the file on disk with our previous\n                        // one using the etag() function. Relying only on the mtime check has prooven to produce false\n                        // positives due to file system weirdness (especially around remote file systems). As such, the\n                        // check for size is a weaker check because it can return a false negative if the file has changed\n                        // but to the same length. This is a compromise we take to avoid having to produce checksums of\n                        // the file content for comparison which would be much slower to compute.\n                        if (typeof options.mtime === 'number' && typeof options.etag === 'string' && options.mtime < stat.mtime.getTime() && options.etag !== etag(stat.size, options.mtime)) {\n                            return Promise.reject(new files_1.FileOperationError(nls.localize('fileModifiedError', \"File Modified Since\"), files_1.FileOperationResult.FILE_MODIFIED_SINCE, options));\n                        }\n                        // Throw if file is readonly and we are not instructed to overwrite\n                        if (!ignoreReadonly && !(stat.mode & 128) /* readonly */) {\n                            if (!options.overwriteReadonly) {\n                                return this.readOnlyError(options);\n                            }\n                            // Try to change mode to writeable\n                            let mode = stat.mode;\n                            mode = mode | 128;\n                            return pfs.chmod(absolutePath, mode).then(() => {\n                                // Make sure to check the mode again, it could have failed\n                                return pfs.stat(absolutePath).then(stat => {\n                                    if (!(stat.mode & 128) /* readonly */) {\n                                        return this.readOnlyError(options);\n                                    }\n                                    return exists;\n                                });\n                            });\n                        }\n                        return exists;\n                    });\n                }\n                return exists;\n            });\n        }\n        readOnlyError(options) {\n            return Promise.reject(new files_1.FileOperationError(nls.localize('fileReadOnlyError', \"File is Read Only\"), files_1.FileOperationResult.FILE_READ_ONLY, options));\n        }\n        moveFile(source, target, overwrite) {\n            return this.moveOrCopyFile(source, target, false, !!overwrite);\n        }\n        copyFile(source, target, overwrite) {\n            return this.moveOrCopyFile(source, target, true, !!overwrite);\n        }\n        moveOrCopyFile(source, target, keepCopy, overwrite) {\n            const sourcePath = this.toAbsolutePath(source);\n            const targetPath = this.toAbsolutePath(target);\n            // 1.) move / copy\n            return this.doMoveOrCopyFile(sourcePath, targetPath, keepCopy, overwrite).then(() => {\n                // 2.) resolve\n                return this.resolve(target, { resolveMetadata: true }).then(result => {\n                    // Events (unless it was a no-op because paths are identical)\n                    if (sourcePath !== targetPath) {\n                        this._onAfterOperation.fire(new files_1.FileOperationEvent(source, keepCopy ? files_1.FileOperation.COPY : files_1.FileOperation.MOVE, result));\n                    }\n                    return result;\n                });\n            });\n        }\n        doMoveOrCopyFile(sourcePath, targetPath, keepCopy, overwrite) {\n            // 1.) validate operation\n            if (files_1.isParent(targetPath, sourcePath, !platform_1.isLinux)) {\n                return Promise.reject(new Error('Unable to move/copy when source path is parent of target path'));\n            }\n            else if (sourcePath === targetPath) {\n                return Promise.resolve(); // no-op but not an error\n            }\n            // 2.) check if target exists\n            return pfs.exists(targetPath).then(exists => {\n                const isCaseRename = sourcePath.toLowerCase() === targetPath.toLowerCase();\n                // Return early with conflict if target exists and we are not told to overwrite\n                if (exists && !isCaseRename && !overwrite) {\n                    return Promise.reject(new files_1.FileOperationError(nls.localize('fileMoveConflict', \"Unable to move/copy. File already exists at destination.\"), files_1.FileOperationResult.FILE_MOVE_CONFLICT));\n                }\n                // 3.) make sure target is deleted before we move/copy unless this is a case rename of the same file\n                let deleteTargetPromise = Promise.resolve();\n                if (exists && !isCaseRename) {\n                    if (extpath_1.isEqualOrParent(sourcePath, targetPath, !platform_1.isLinux /* ignorecase */)) {\n                        return Promise.reject(new Error(nls.localize('unableToMoveCopyError', \"Unable to move/copy. File would replace folder it is contained in.\"))); // catch this corner case!\n                    }\n                    deleteTargetPromise = this.del(uri_1.URI.file(targetPath), { recursive: true });\n                }\n                return deleteTargetPromise.then(() => {\n                    // 4.) make sure parents exists\n                    return pfs.mkdirp(paths.dirname(targetPath)).then(() => {\n                        // 4.) copy/move\n                        if (keepCopy) {\n                            return async_1.nfcall(extfs.copy, sourcePath, targetPath);\n                        }\n                        else {\n                            return async_1.nfcall(extfs.mv, sourcePath, targetPath);\n                        }\n                    });\n                });\n            });\n        }\n        del(resource, options) {\n            if (options && options.useTrash) {\n                return this.doMoveItemToTrash(resource);\n            }\n            return this.doDelete(resource, !!(options && options.recursive));\n        }\n        doMoveItemToTrash(resource) {\n            const absolutePath = resource.fsPath;\n            const shell = require('electron').shell; // workaround for being able to run tests out of VSCode debugger\n            const result = shell.moveItemToTrash(absolutePath);\n            if (!result) {\n                return Promise.reject(new Error(platform_1.isWindows ? nls.localize('binFailed', \"Failed to move '{0}' to the recycle bin\", paths.basename(absolutePath)) : nls.localize('trashFailed', \"Failed to move '{0}' to the trash\", paths.basename(absolutePath))));\n            }\n            this._onAfterOperation.fire(new files_1.FileOperationEvent(resource, files_1.FileOperation.DELETE));\n            return Promise.resolve();\n        }\n        doDelete(resource, recursive) {\n            const absolutePath = this.toAbsolutePath(resource);\n            let assertNonRecursiveDelete;\n            if (!recursive) {\n                assertNonRecursiveDelete = pfs.stat(absolutePath).then(stat => {\n                    if (!stat.isDirectory()) {\n                        return undefined;\n                    }\n                    return pfs.readdir(absolutePath).then(children => {\n                        if (children.length === 0) {\n                            return undefined;\n                        }\n                        return Promise.reject(new Error(nls.localize('deleteFailed', \"Failed to delete non-empty folder '{0}'.\", paths.basename(absolutePath))));\n                    });\n                }, error => Promise.resolve() /* ignore errors */);\n            }\n            else {\n                assertNonRecursiveDelete = Promise.resolve();\n            }\n            return assertNonRecursiveDelete.then(() => {\n                return pfs.del(absolutePath, os.tmpdir()).then(() => {\n                    // Events\n                    this._onAfterOperation.fire(new files_1.FileOperationEvent(resource, files_1.FileOperation.DELETE));\n                });\n            });\n        }\n        // Helpers\n        toAbsolutePath(arg1) {\n            let resource;\n            if (arg1 instanceof uri_1.URI) {\n                resource = arg1;\n            }\n            else {\n                resource = arg1.resource;\n            }\n            assert.ok(resource && resource.scheme === network_1.Schemas.file, `Invalid resource: ${resource}`);\n            return paths.normalize(resource.fsPath);\n        }\n        resolve(resource, options = Object.create(null)) {\n            return this.toStatResolver(resource).then(model => model.resolve(options));\n        }\n        toStatResolver(resource) {\n            const absolutePath = this.toAbsolutePath(resource);\n            return pfs.statLink(absolutePath).then(({ isSymbolicLink, stat }) => {\n                return new StatResolver(resource, isSymbolicLink, stat.isDirectory(), stat.mtime.getTime(), stat.size, this.environmentService.verbose ? err => this.handleError(err) : undefined);\n            });\n        }\n        watchFileChanges(resource) {\n            assert.ok(resource && resource.scheme === network_1.Schemas.file, `Invalid resource for watching: ${resource}`);\n            // Check for existing watcher first\n            const entry = this.activeFileChangesWatchers.get(resource);\n            if (entry) {\n                entry.count += 1;\n                return;\n            }\n            // Create or get watcher for provided path\n            const fsPath = resource.fsPath;\n            const fsName = paths.basename(resource.fsPath);\n            const watcherDisposable = extfs.watch(fsPath, (eventType, filename) => {\n                const renamedOrDeleted = ((filename && filename !== fsName) || eventType === 'rename');\n                // The file was either deleted or renamed. Many tools apply changes to files in an\n                // atomic way (\"Atomic Save\") by first renaming the file to a temporary name and then\n                // renaming it back to the original name. Our watcher will detect this as a rename\n                // and then stops to work on Mac and Linux because the watcher is applied to the\n                // inode and not the name. The fix is to detect this case and trying to watch the file\n                // again after a certain delay.\n                // In addition, we send out a delete event if after a timeout we detect that the file\n                // does indeed not exist anymore.\n                if (renamedOrDeleted) {\n                    // Very important to dispose the watcher which now points to a stale inode\n                    watcherDisposable.dispose();\n                    this.activeFileChangesWatchers.delete(resource);\n                    // Wait a bit and try to install watcher again, assuming that the file was renamed quickly (\"Atomic Save\")\n                    setTimeout(() => {\n                        this.existsFile(resource).then(exists => {\n                            // File still exists, so reapply the watcher\n                            if (exists) {\n                                this.watchFileChanges(resource);\n                            }\n                            // File seems to be really gone, so emit a deleted event\n                            else {\n                                this.onRawFileChange({\n                                    type: files_1.FileChangeType.DELETED,\n                                    path: fsPath\n                                });\n                            }\n                        });\n                    }, FileService.FS_REWATCH_DELAY);\n                }\n                // Handle raw file change\n                this.onRawFileChange({\n                    type: files_1.FileChangeType.UPDATED,\n                    path: fsPath\n                });\n            }, (error) => this.handleError(error));\n            // Remember in map\n            this.activeFileChangesWatchers.set(resource, {\n                count: 1,\n                unwatch: () => watcherDisposable.dispose()\n            });\n        }\n        onRawFileChange(event) {\n            // add to bucket of undelivered events\n            this.undeliveredRawFileChangesEvents.push(event);\n            if (this.environmentService.verbose) {\n                console.log('%c[File Watcher (node.js)]%c', 'color: blue', 'color: black', `${event.type === files_1.FileChangeType.ADDED ? '[ADDED]' : event.type === files_1.FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.path}`);\n            }\n            // handle emit through delayer to accommodate for bulk changes\n            this.fileChangesWatchDelayer.trigger(() => {\n                const buffer = this.undeliveredRawFileChangesEvents;\n                this.undeliveredRawFileChangesEvents = [];\n                // Normalize\n                const normalizedEvents = common_1.normalize(buffer);\n                // Logging\n                if (this.environmentService.verbose) {\n                    normalizedEvents.forEach(r => {\n                        console.log('%c[File Watcher (node.js)]%c >> normalized', 'color: blue', 'color: black', `${r.type === files_1.FileChangeType.ADDED ? '[ADDED]' : r.type === files_1.FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${r.path}`);\n                    });\n                }\n                // Emit\n                this._onFileChanges.fire(common_1.toFileChangesEvent(normalizedEvents));\n                return Promise.resolve();\n            });\n        }\n        unwatchFileChanges(resource) {\n            const watcher = this.activeFileChangesWatchers.get(resource);\n            if (watcher && --watcher.count === 0) {\n                watcher.unwatch();\n                this.activeFileChangesWatchers.delete(resource);\n            }\n        }\n        dispose() {\n            super.dispose();\n            if (this.activeWorkspaceFileChangeWatcher) {\n                this.activeWorkspaceFileChangeWatcher.dispose();\n                this.activeWorkspaceFileChangeWatcher = null;\n            }\n            this.activeFileChangesWatchers.forEach(watcher => watcher.unwatch());\n            this.activeFileChangesWatchers.clear();\n        }\n        resolveFile(resource, options) {\n            return this.resolve(resource, options);\n        }\n        resolveFiles(toResolve) {\n            return Promise.all(toResolve.map(resourceAndOptions => this.resolve(resourceAndOptions.resource, resourceAndOptions.options)\n                .then(stat => ({ stat, success: true }), error => ({ stat: undefined, success: false }))));\n        }\n        createFolder(resource) {\n            // 1.) Create folder\n            const absolutePath = this.toAbsolutePath(resource);\n            return pfs.mkdirp(absolutePath).then(() => {\n                // 2.) Resolve\n                return this.resolve(resource, { resolveMetadata: true }).then(result => {\n                    // Events\n                    this._onAfterOperation.fire(new files_1.FileOperationEvent(resource, files_1.FileOperation.CREATE, result));\n                    return result;\n                });\n            });\n        }\n        existsFile(resource) {\n            return this.resolveFile(resource).then(() => true, () => false);\n        }\n    }\n    FileService.FS_EVENT_DELAY = 50; // aggregate and only emit events when changes have stopped for this duration (in ms)\n    FileService.FS_REWATCH_DELAY = 300; // delay to rewatch a file that was renamed or deleted (in ms)\n    FileService.NET_VERSION_ERROR = 'System.MissingMethodException';\n    FileService.NET_VERSION_ERROR_IGNORE_KEY = 'ignoreNetVersionError';\n    FileService.ENOSPC_ERROR = 'ENOSPC';\n    FileService.ENOSPC_ERROR_IGNORE_KEY = 'ignoreEnospcError';\n    exports.FileService = FileService;\n    function etag(arg1, arg2) {\n        let size;\n        let mtime;\n        if (typeof arg2 === 'number') {\n            size = arg1;\n            mtime = arg2;\n        }\n        else {\n            size = arg1.size;\n            mtime = arg1.mtime.getTime();\n        }\n        return `\"${crypto.createHash('sha1').update(String(size) + String(mtime)).digest('hex')}\"`;\n    }\n    class StatResolver {\n        constructor(resource, isSymbolicLink, isDirectory, mtime, size, errorLogger) {\n            this.resource = resource;\n            this.isSymbolicLink = isSymbolicLink;\n            this.isDirectory = isDirectory;\n            this.mtime = mtime;\n            this.size = size;\n            this.errorLogger = errorLogger;\n            assert.ok(resource && resource.scheme === network_1.Schemas.file, `Invalid resource: ${resource}`);\n            this.name = labels_1.getBaseLabel(resource);\n            this.etag = etag(size, mtime);\n        }\n        resolve(options) {\n            // General Data\n            const fileStat = {\n                resource: this.resource,\n                isDirectory: this.isDirectory,\n                isSymbolicLink: this.isSymbolicLink,\n                isReadonly: false,\n                name: this.name,\n                etag: this.etag,\n                size: this.size,\n                mtime: this.mtime\n            };\n            // File Specific Data\n            if (!this.isDirectory) {\n                return Promise.resolve(fileStat);\n            }\n            // Directory Specific Data\n            else {\n                // Convert the paths from options.resolveTo to absolute paths\n                let absoluteTargetPaths = null;\n                if (options && options.resolveTo) {\n                    absoluteTargetPaths = [];\n                    for (const resource of options.resolveTo) {\n                        absoluteTargetPaths.push(resource.fsPath);\n                    }\n                }\n                return new Promise(resolve => {\n                    // Load children\n                    this.resolveChildren(this.resource.fsPath, absoluteTargetPaths, !!(options && options.resolveSingleChildDescendants), children => {\n                        if (children) {\n                            children = arrays.coalesce(children); // we don't want those null children (could be permission denied when reading a child)\n                        }\n                        fileStat.children = children || [];\n                        resolve(fileStat);\n                    });\n                });\n            }\n        }\n        resolveChildren(absolutePath, absoluteTargetPaths, resolveSingleChildDescendants, callback) {\n            extfs.readdir(absolutePath, (error, files) => {\n                if (error) {\n                    if (this.errorLogger) {\n                        this.errorLogger(error);\n                    }\n                    return callback(null); // return - we might not have permissions to read the folder\n                }\n                // for each file in the folder\n                flow.parallel(files, (file, clb) => {\n                    const fileResource = uri_1.URI.file(paths.resolve(absolutePath, file));\n                    let fileStat;\n                    let isSymbolicLink = false;\n                    const $this = this;\n                    flow.sequence(function onError(error) {\n                        if ($this.errorLogger) {\n                            $this.errorLogger(error);\n                        }\n                        clb(null, null); // return - we might not have permissions to read the folder or stat the file\n                    }, function stat() {\n                        extfs.statLink(fileResource.fsPath, this);\n                    }, function countChildren(statAndLink) {\n                        fileStat = statAndLink.stat;\n                        isSymbolicLink = statAndLink.isSymbolicLink;\n                        if (fileStat.isDirectory()) {\n                            extfs.readdir(fileResource.fsPath, (error, result) => {\n                                this(null, result ? result.length : 0);\n                            });\n                        }\n                        else {\n                            this(null, 0);\n                        }\n                    }, function resolve(childCount) {\n                        const childStat = {\n                            resource: fileResource,\n                            isDirectory: fileStat.isDirectory(),\n                            isSymbolicLink,\n                            isReadonly: false,\n                            name: file,\n                            mtime: fileStat.mtime.getTime(),\n                            etag: etag(fileStat),\n                            size: fileStat.size\n                        };\n                        // Return early for files\n                        if (!fileStat.isDirectory()) {\n                            return clb(null, childStat);\n                        }\n                        // Handle Folder\n                        let resolveFolderChildren = false;\n                        if (files.length === 1 && resolveSingleChildDescendants) {\n                            resolveFolderChildren = true;\n                        }\n                        else if (childCount > 0 && absoluteTargetPaths && absoluteTargetPaths.some(targetPath => extpath_1.isEqualOrParent(targetPath, fileResource.fsPath, !platform_1.isLinux /* ignorecase */))) {\n                            resolveFolderChildren = true;\n                        }\n                        // Continue resolving children based on condition\n                        if (resolveFolderChildren) {\n                            $this.resolveChildren(fileResource.fsPath, absoluteTargetPaths, resolveSingleChildDescendants, children => {\n                                if (children) {\n                                    children = arrays.coalesce(children); // we don't want those null children\n                                }\n                                childStat.children = children || [];\n                                clb(null, childStat);\n                            });\n                        }\n                        // Otherwise return result\n                        else {\n                            clb(null, childStat);\n                        }\n                    });\n                }, (errors, result) => {\n                    callback(result);\n                });\n            });\n        }\n    }\n    exports.StatResolver = StatResolver;\n});\n",null]}