{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/linesLayout.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/linesLayout.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/editor/common/viewLayout/whitespaceComputer\"], function (require, exports, whitespaceComputer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Layouting of objects that take vertical space (by having a height) and push down other objects.\n     *\n     * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n     * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n     * This is written with no knowledge of an editor in mind.\n     */\n    class LinesLayout {\n        constructor(lineCount, lineHeight) {\n            this._lineCount = lineCount;\n            this._lineHeight = lineHeight;\n            this._whitespaces = new whitespaceComputer_1.WhitespaceComputer();\n        }\n        /**\n         * Change the height of a line in pixels.\n         */\n        setLineHeight(lineHeight) {\n            this._lineHeight = lineHeight;\n        }\n        /**\n         * Set the number of lines.\n         *\n         * @param lineCount New number of lines.\n         */\n        onFlushed(lineCount) {\n            this._lineCount = lineCount;\n        }\n        /**\n         * Insert a new whitespace of a certain height after a line number.\n         * The whitespace has a \"sticky\" characteristic.\n         * Irrespective of edits above or below `afterLineNumber`, the whitespace will follow the initial line.\n         *\n         * @param afterLineNumber The conceptual position of this whitespace. The whitespace will follow this line as best as possible even when deleting/inserting lines above/below.\n         * @param heightInPx The height of the whitespace, in pixels.\n         * @return An id that can be used later to mutate or delete the whitespace\n         */\n        insertWhitespace(afterLineNumber, ordinal, heightInPx, minWidth) {\n            return this._whitespaces.insertWhitespace(afterLineNumber, ordinal, heightInPx, minWidth);\n        }\n        /**\n         * Change properties associated with a certain whitespace.\n         */\n        changeWhitespace(id, newAfterLineNumber, newHeight) {\n            return this._whitespaces.changeWhitespace(id, newAfterLineNumber, newHeight);\n        }\n        /**\n         * Remove an existing whitespace.\n         *\n         * @param id The whitespace to remove\n         * @return Returns true if the whitespace is found and it is removed.\n         */\n        removeWhitespace(id) {\n            return this._whitespaces.removeWhitespace(id);\n        }\n        /**\n         * Notify the layouter that lines have been deleted (a continuous zone of lines).\n         *\n         * @param fromLineNumber The line number at which the deletion started, inclusive\n         * @param toLineNumber The line number at which the deletion ended, inclusive\n         */\n        onLinesDeleted(fromLineNumber, toLineNumber) {\n            this._lineCount -= (toLineNumber - fromLineNumber + 1);\n            this._whitespaces.onLinesDeleted(fromLineNumber, toLineNumber);\n        }\n        /**\n         * Notify the layouter that lines have been inserted (a continuous zone of lines).\n         *\n         * @param fromLineNumber The line number at which the insertion started, inclusive\n         * @param toLineNumber The line number at which the insertion ended, inclusive.\n         */\n        onLinesInserted(fromLineNumber, toLineNumber) {\n            this._lineCount += (toLineNumber - fromLineNumber + 1);\n            this._whitespaces.onLinesInserted(fromLineNumber, toLineNumber);\n        }\n        /**\n         * Get the sum of heights for all objects.\n         *\n         * @return The sum of heights for all objects.\n         */\n        getLinesTotalHeight() {\n            let linesHeight = this._lineHeight * this._lineCount;\n            let whitespacesHeight = this._whitespaces.getTotalHeight();\n            return linesHeight + whitespacesHeight;\n        }\n        /**\n         * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n         *\n         * @param lineNumber The line number\n         * @return The sum of heights for all objects above `lineNumber`.\n         */\n        getVerticalOffsetForLineNumber(lineNumber) {\n            lineNumber = lineNumber | 0;\n            let previousLinesHeight;\n            if (lineNumber > 1) {\n                previousLinesHeight = this._lineHeight * (lineNumber - 1);\n            }\n            else {\n                previousLinesHeight = 0;\n            }\n            let previousWhitespacesHeight = this._whitespaces.getAccumulatedHeightBeforeLineNumber(lineNumber);\n            return previousLinesHeight + previousWhitespacesHeight;\n        }\n        /**\n         * Returns the accumulated height of whitespaces before the given line number.\n         *\n         * @param lineNumber The line number\n         */\n        getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {\n            return this._whitespaces.getAccumulatedHeightBeforeLineNumber(lineNumber);\n        }\n        /**\n         * Returns if there is any whitespace in the document.\n         */\n        hasWhitespace() {\n            return this._whitespaces.getCount() > 0;\n        }\n        getWhitespaceMinWidth() {\n            return this._whitespaces.getMinWidth();\n        }\n        /**\n         * Check if `verticalOffset` is below all lines.\n         */\n        isAfterLines(verticalOffset) {\n            let totalHeight = this.getLinesTotalHeight();\n            return verticalOffset > totalHeight;\n        }\n        /**\n         * Find the first line number that is at or after vertical offset `verticalOffset`.\n         * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n         * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n         *\n         * @param verticalOffset The vertical offset to search at.\n         * @return The line number at or after vertical offset `verticalOffset`.\n         */\n        getLineNumberAtOrAfterVerticalOffset(verticalOffset) {\n            verticalOffset = verticalOffset | 0;\n            if (verticalOffset < 0) {\n                return 1;\n            }\n            const linesCount = this._lineCount | 0;\n            const lineHeight = this._lineHeight;\n            let minLineNumber = 1;\n            let maxLineNumber = linesCount;\n            while (minLineNumber < maxLineNumber) {\n                let midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\n                let midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n                if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n                    // vertical offset is after mid line number\n                    minLineNumber = midLineNumber + 1;\n                }\n                else if (verticalOffset >= midLineNumberVerticalOffset) {\n                    // Hit\n                    return midLineNumber;\n                }\n                else {\n                    // vertical offset is before mid line number, but mid line number could still be what we're searching for\n                    maxLineNumber = midLineNumber;\n                }\n            }\n            if (minLineNumber > linesCount) {\n                return linesCount;\n            }\n            return minLineNumber;\n        }\n        /**\n         * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n         *\n         * @param verticalOffset1 The beginning of the viewport.\n         * @param verticalOffset2 The end of the viewport.\n         * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n         */\n        getLinesViewportData(verticalOffset1, verticalOffset2) {\n            verticalOffset1 = verticalOffset1 | 0;\n            verticalOffset2 = verticalOffset2 | 0;\n            const lineHeight = this._lineHeight;\n            // Find first line number\n            // We don't live in a perfect world, so the line number might start before or after verticalOffset1\n            const startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n            const startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n            let endLineNumber = this._lineCount | 0;\n            // Also keep track of what whitespace we've got\n            let whitespaceIndex = this._whitespaces.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n            const whitespaceCount = this._whitespaces.getCount() | 0;\n            let currentWhitespaceHeight;\n            let currentWhitespaceAfterLineNumber;\n            if (whitespaceIndex === -1) {\n                whitespaceIndex = whitespaceCount;\n                currentWhitespaceAfterLineNumber = endLineNumber + 1;\n                currentWhitespaceHeight = 0;\n            }\n            else {\n                currentWhitespaceAfterLineNumber = this._whitespaces.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n                currentWhitespaceHeight = this._whitespaces.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n            }\n            let currentVerticalOffset = startLineNumberVerticalOffset;\n            let currentLineRelativeOffset = currentVerticalOffset;\n            // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n            const STEP_SIZE = 500000;\n            let bigNumbersDelta = 0;\n            if (startLineNumberVerticalOffset >= STEP_SIZE) {\n                // Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n                bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n                bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;\n                currentLineRelativeOffset -= bigNumbersDelta;\n            }\n            let linesOffsets = [];\n            const verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n            let centeredLineNumber = -1;\n            // Figure out how far the lines go\n            for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n                if (centeredLineNumber === -1) {\n                    let currentLineTop = currentVerticalOffset;\n                    let currentLineBottom = currentVerticalOffset + lineHeight;\n                    if ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\n                        centeredLineNumber = lineNumber;\n                    }\n                }\n                // Count current line height in the vertical offsets\n                currentVerticalOffset += lineHeight;\n                linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n                // Next line starts immediately after this one\n                currentLineRelativeOffset += lineHeight;\n                while (currentWhitespaceAfterLineNumber === lineNumber) {\n                    // Push down next line with the height of the current whitespace\n                    currentLineRelativeOffset += currentWhitespaceHeight;\n                    // Count current whitespace in the vertical offsets\n                    currentVerticalOffset += currentWhitespaceHeight;\n                    whitespaceIndex++;\n                    if (whitespaceIndex >= whitespaceCount) {\n                        currentWhitespaceAfterLineNumber = endLineNumber + 1;\n                    }\n                    else {\n                        currentWhitespaceAfterLineNumber = this._whitespaces.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n                        currentWhitespaceHeight = this._whitespaces.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n                    }\n                }\n                if (currentVerticalOffset >= verticalOffset2) {\n                    // We have covered the entire viewport area, time to stop\n                    endLineNumber = lineNumber;\n                    break;\n                }\n            }\n            if (centeredLineNumber === -1) {\n                centeredLineNumber = endLineNumber;\n            }\n            const endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n            let completelyVisibleStartLineNumber = startLineNumber;\n            let completelyVisibleEndLineNumber = endLineNumber;\n            if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n                if (startLineNumberVerticalOffset < verticalOffset1) {\n                    completelyVisibleStartLineNumber++;\n                }\n            }\n            if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n                if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {\n                    completelyVisibleEndLineNumber--;\n                }\n            }\n            return {\n                bigNumbersDelta: bigNumbersDelta,\n                startLineNumber: startLineNumber,\n                endLineNumber: endLineNumber,\n                relativeVerticalOffset: linesOffsets,\n                centeredLineNumber: centeredLineNumber,\n                completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n                completelyVisibleEndLineNumber: completelyVisibleEndLineNumber\n            };\n        }\n        getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {\n            whitespaceIndex = whitespaceIndex | 0;\n            let afterLineNumber = this._whitespaces.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n            let previousLinesHeight;\n            if (afterLineNumber >= 1) {\n                previousLinesHeight = this._lineHeight * afterLineNumber;\n            }\n            else {\n                previousLinesHeight = 0;\n            }\n            let previousWhitespacesHeight;\n            if (whitespaceIndex > 0) {\n                previousWhitespacesHeight = this._whitespaces.getAccumulatedHeight(whitespaceIndex - 1);\n            }\n            else {\n                previousWhitespacesHeight = 0;\n            }\n            return previousLinesHeight + previousWhitespacesHeight;\n        }\n        getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {\n            verticalOffset = verticalOffset | 0;\n            let midWhitespaceIndex, minWhitespaceIndex = 0, maxWhitespaceIndex = this._whitespaces.getCount() - 1, midWhitespaceVerticalOffset, midWhitespaceHeight;\n            if (maxWhitespaceIndex < 0) {\n                return -1;\n            }\n            // Special case: nothing to be found\n            let maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n            let maxWhitespaceHeight = this._whitespaces.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n            if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n                return -1;\n            }\n            while (minWhitespaceIndex < maxWhitespaceIndex) {\n                midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n                midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n                midWhitespaceHeight = this._whitespaces.getHeightForWhitespaceIndex(midWhitespaceIndex);\n                if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n                    // vertical offset is after whitespace\n                    minWhitespaceIndex = midWhitespaceIndex + 1;\n                }\n                else if (verticalOffset >= midWhitespaceVerticalOffset) {\n                    // Hit\n                    return midWhitespaceIndex;\n                }\n                else {\n                    // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n                    maxWhitespaceIndex = midWhitespaceIndex;\n                }\n            }\n            return minWhitespaceIndex;\n        }\n        /**\n         * Get exactly the whitespace that is layouted at `verticalOffset`.\n         *\n         * @param verticalOffset The vertical offset.\n         * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n         */\n        getWhitespaceAtVerticalOffset(verticalOffset) {\n            verticalOffset = verticalOffset | 0;\n            let candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n            if (candidateIndex < 0) {\n                return null;\n            }\n            if (candidateIndex >= this._whitespaces.getCount()) {\n                return null;\n            }\n            let candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n            if (candidateTop > verticalOffset) {\n                return null;\n            }\n            let candidateHeight = this._whitespaces.getHeightForWhitespaceIndex(candidateIndex);\n            let candidateId = this._whitespaces.getIdForWhitespaceIndex(candidateIndex);\n            let candidateAfterLineNumber = this._whitespaces.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n            return {\n                id: candidateId,\n                afterLineNumber: candidateAfterLineNumber,\n                verticalOffset: candidateTop,\n                height: candidateHeight\n            };\n        }\n        /**\n         * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n         *\n         * @param verticalOffset1 The beginning of the viewport.\n         * @param verticalOffset2 The end of the viewport.\n         * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n         */\n        getWhitespaceViewportData(verticalOffset1, verticalOffset2) {\n            verticalOffset1 = verticalOffset1 | 0;\n            verticalOffset2 = verticalOffset2 | 0;\n            let startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n            let endIndex = this._whitespaces.getCount() - 1;\n            if (startIndex < 0) {\n                return [];\n            }\n            let result = [];\n            for (let i = startIndex; i <= endIndex; i++) {\n                let top = this.getVerticalOffsetForWhitespaceIndex(i);\n                let height = this._whitespaces.getHeightForWhitespaceIndex(i);\n                if (top >= verticalOffset2) {\n                    break;\n                }\n                result.push({\n                    id: this._whitespaces.getIdForWhitespaceIndex(i),\n                    afterLineNumber: this._whitespaces.getAfterLineNumberForWhitespaceIndex(i),\n                    verticalOffset: top,\n                    height: height\n                });\n            }\n            return result;\n        }\n        /**\n         * Get all whitespaces.\n         */\n        getWhitespaces() {\n            return this._whitespaces.getWhitespaces(this._lineHeight);\n        }\n    }\n    exports.LinesLayout = LinesLayout;\n});\n",null]}