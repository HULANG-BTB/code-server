{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/platform/telemetry/browser/errorTelemetry.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/telemetry/browser/errorTelemetry.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrays_1 = require(\"vs/base/common/arrays\");\nvar platform_1 = require(\"vs/base/common/platform\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar Errors = require(\"vs/base/common/errors\");\nvar objects_1 = require(\"vs/base/common/objects\");\nvar ErrorEvent;\n(function (ErrorEvent) {\n    function compare(a, b) {\n        if (a.callstack < b.callstack) {\n            return -1;\n        }\n        else if (a.callstack > b.callstack) {\n            return 1;\n        }\n        return 0;\n    }\n    ErrorEvent.compare = compare;\n})(ErrorEvent || (ErrorEvent = {}));\nvar ErrorTelemetry = /** @class */ (function () {\n    function ErrorTelemetry(telemetryService, flushDelay) {\n        if (flushDelay === void 0) { flushDelay = ErrorTelemetry.ERROR_FLUSH_TIMEOUT; }\n        var _this = this;\n        this._flushHandle = -1;\n        this._buffer = [];\n        this._disposables = [];\n        this._telemetryService = telemetryService;\n        this._flushDelay = flushDelay;\n        // (1) check for unexpected but handled errors\n        var unbind = Errors.errorHandler.addListener(function (err) { return _this._onErrorEvent(err); });\n        this._disposables.push(lifecycle_1.toDisposable(unbind));\n        // (2) check for uncaught global errors\n        var oldOnError;\n        var that = this;\n        if (typeof platform_1.globals.onerror === 'function') {\n            oldOnError = platform_1.globals.onerror;\n        }\n        platform_1.globals.onerror = function (message, filename, line, column, e) {\n            that._onUncaughtError(message, filename, line, column, e);\n            if (oldOnError) {\n                oldOnError.apply(this, arguments);\n            }\n        };\n        this._disposables.push(lifecycle_1.toDisposable(function () {\n            if (oldOnError) {\n                platform_1.globals.onerror = oldOnError;\n            }\n        }));\n    }\n    ErrorTelemetry.prototype.dispose = function () {\n        clearTimeout(this._flushHandle);\n        this._flushBuffer();\n        this._disposables = lifecycle_1.dispose(this._disposables);\n    };\n    ErrorTelemetry.prototype._onErrorEvent = function (err) {\n        if (!err) {\n            return;\n        }\n        // unwrap nested errors from loader\n        if (err.detail && err.detail.stack) {\n            err = err.detail;\n        }\n        // work around behavior in workerServer.ts that breaks up Error.stack\n        var callstack = Array.isArray(err.stack) ? err.stack.join('\\n') : err.stack;\n        var msg = err.message ? err.message : objects_1.safeStringify(err);\n        // errors without a stack are not useful telemetry\n        if (!callstack) {\n            return;\n        }\n        this._enqueue({ msg: msg, callstack: callstack });\n    };\n    ErrorTelemetry.prototype._onUncaughtError = function (msg, file, line, column, err) {\n        var data = {\n            callstack: msg,\n            msg: msg,\n            file: file,\n            line: line,\n            column: column\n        };\n        if (err) {\n            var name = err.name, message = err.message, stack = err.stack;\n            data.uncaught_error_name = name;\n            if (message) {\n                data.uncaught_error_msg = message;\n            }\n            if (stack) {\n                data.callstack = Array.isArray(err.stack)\n                    ? err.stack = err.stack.join('\\n')\n                    : err.stack;\n            }\n        }\n        this._enqueue(data);\n    };\n    ErrorTelemetry.prototype._enqueue = function (e) {\n        var _this = this;\n        var idx = arrays_1.binarySearch(this._buffer, e, ErrorEvent.compare);\n        if (idx < 0) {\n            e.count = 1;\n            this._buffer.splice(~idx, 0, e);\n        }\n        else {\n            if (!this._buffer[idx].count) {\n                this._buffer[idx].count = 0;\n            }\n            this._buffer[idx].count += 1;\n        }\n        if (this._flushHandle === -1) {\n            this._flushHandle = setTimeout(function () {\n                _this._flushBuffer();\n                _this._flushHandle = -1;\n            }, this._flushDelay);\n        }\n    };\n    ErrorTelemetry.prototype._flushBuffer = function () {\n        for (var _i = 0, _a = this._buffer; _i < _a.length; _i++) {\n            var error = _a[_i];\n            /* __GDPR__\n            \"UnhandledError\" : {\n                    \"${include}\": [ \"${ErrorEvent}\" ]\n                }\n            */\n            this._telemetryService.publicLog('UnhandledError', error, true);\n        }\n        this._buffer.length = 0;\n    };\n    ErrorTelemetry.ERROR_FLUSH_TIMEOUT = 5 * 1000;\n    return ErrorTelemetry;\n}());\nexports.default = ErrorTelemetry;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/platform/telemetry/browser/errorTelemetry.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/platform/telemetry/browser/errorTelemetry.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { binarySearch } from 'vs/base/common/arrays';\nimport { globals } from 'vs/base/common/platform';\nimport { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';\nimport { IDisposable, toDisposable, dispose } from 'vs/base/common/lifecycle';\nimport * as Errors from 'vs/base/common/errors';\nimport { safeStringify } from 'vs/base/common/objects';\n\n/* __GDPR__FRAGMENT__\n\t\"ErrorEvent\" : {\n\t\t\"stack\": { \"classification\": \"CustomerContent\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"message\" : { \"classification\": \"CustomerContent\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"filename\" : { \"classification\": \"CustomerContent\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"callstack\": { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"msg\" : { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"file\" : { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"line\": { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"column\": { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n\t\t\"uncaught_error_name\": { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"uncaught_error_msg\": { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\" },\n\t\t\"count\": { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true }\n\t}\n */\ninterface ErrorEvent {\n\tcallstack: string;\n\tmsg?: string;\n\tfile?: string;\n\tline?: number;\n\tcolumn?: number;\n\tuncaught_error_name?: string;\n\tuncaught_error_msg?: string;\n\tcount?: number;\n}\n\nnamespace ErrorEvent {\n\texport function compare(a: ErrorEvent, b: ErrorEvent) {\n\t\tif (a.callstack < b.callstack) {\n\t\t\treturn -1;\n\t\t} else if (a.callstack > b.callstack) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\nexport default class ErrorTelemetry {\n\n\tpublic static ERROR_FLUSH_TIMEOUT: number = 5 * 1000;\n\n\tprivate _telemetryService: ITelemetryService;\n\tprivate _flushDelay: number;\n\tprivate _flushHandle: any = -1;\n\tprivate _buffer: ErrorEvent[] = [];\n\tprivate _disposables: IDisposable[] = [];\n\n\tconstructor(telemetryService: ITelemetryService, flushDelay = ErrorTelemetry.ERROR_FLUSH_TIMEOUT) {\n\t\tthis._telemetryService = telemetryService;\n\t\tthis._flushDelay = flushDelay;\n\n\t\t// (1) check for unexpected but handled errors\n\t\tconst unbind = Errors.errorHandler.addListener((err) => this._onErrorEvent(err));\n\t\tthis._disposables.push(toDisposable(unbind));\n\n\t\t// (2) check for uncaught global errors\n\t\tlet oldOnError: Function;\n\t\tlet that = this;\n\t\tif (typeof globals.onerror === 'function') {\n\t\t\toldOnError = globals.onerror;\n\t\t}\n\t\tglobals.onerror = function (message: string, filename: string, line: number, column?: number, e?: any) {\n\t\t\tthat._onUncaughtError(message, filename, line, column, e);\n\t\t\tif (oldOnError) {\n\t\t\t\toldOnError.apply(this, arguments);\n\t\t\t}\n\t\t};\n\t\tthis._disposables.push(toDisposable(function () {\n\t\t\tif (oldOnError) {\n\t\t\t\tglobals.onerror = oldOnError;\n\t\t\t}\n\t\t}));\n\t}\n\n\tdispose() {\n\t\tclearTimeout(this._flushHandle);\n\t\tthis._flushBuffer();\n\t\tthis._disposables = dispose(this._disposables);\n\t}\n\n\tprivate _onErrorEvent(err: any): void {\n\n\t\tif (!err) {\n\t\t\treturn;\n\t\t}\n\n\t\t// unwrap nested errors from loader\n\t\tif (err.detail && err.detail.stack) {\n\t\t\terr = err.detail;\n\t\t}\n\n\t\t// work around behavior in workerServer.ts that breaks up Error.stack\n\t\tlet callstack = Array.isArray(err.stack) ? err.stack.join('\\n') : err.stack;\n\t\tlet msg = err.message ? err.message : safeStringify(err);\n\n\t\t// errors without a stack are not useful telemetry\n\t\tif (!callstack) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._enqueue({ msg, callstack });\n\t}\n\n\tprivate _onUncaughtError(msg: string, file: string, line: number, column?: number, err?: any): void {\n\n\t\tlet data: ErrorEvent = {\n\t\t\tcallstack: msg,\n\t\t\tmsg,\n\t\t\tfile,\n\t\t\tline,\n\t\t\tcolumn\n\t\t};\n\n\t\tif (err) {\n\t\t\tlet { name, message, stack } = err;\n\t\t\tdata.uncaught_error_name = name;\n\t\t\tif (message) {\n\t\t\t\tdata.uncaught_error_msg = message;\n\t\t\t}\n\t\t\tif (stack) {\n\t\t\t\tdata.callstack = Array.isArray(err.stack)\n\t\t\t\t\t? err.stack = err.stack.join('\\n')\n\t\t\t\t\t: err.stack;\n\t\t\t}\n\t\t}\n\n\t\tthis._enqueue(data);\n\t}\n\n\tprivate _enqueue(e: ErrorEvent): void {\n\n\t\tconst idx = binarySearch(this._buffer, e, ErrorEvent.compare);\n\t\tif (idx < 0) {\n\t\t\te.count = 1;\n\t\t\tthis._buffer.splice(~idx, 0, e);\n\t\t} else {\n\t\t\tif (!this._buffer[idx].count) {\n\t\t\t\tthis._buffer[idx].count = 0;\n\t\t\t}\n\t\t\tthis._buffer[idx].count! += 1;\n\t\t}\n\n\t\tif (this._flushHandle === -1) {\n\t\t\tthis._flushHandle = setTimeout(() => {\n\t\t\t\tthis._flushBuffer();\n\t\t\t\tthis._flushHandle = -1;\n\t\t\t}, this._flushDelay);\n\t\t}\n\t}\n\n\tprivate _flushBuffer(): void {\n\t\tfor (let error of this._buffer) {\n\t\t\t/* __GDPR__\n\t\t\t\"UnhandledError\" : {\n\t\t\t\t\t\"${include}\": [ \"${ErrorEvent}\" ]\n\t\t\t\t}\n\t\t\t*/\n\t\t\tthis._telemetryService.publicLog('UnhandledError', error, true);\n\t\t}\n\t\tthis._buffer.length = 0;\n\t}\n}\n"]}]}