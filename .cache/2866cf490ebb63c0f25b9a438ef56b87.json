{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/actions/common/menuService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/actions/common/menuService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/platform/actions/common/actions\", \"vs/platform/commands/common/commands\", \"vs/platform/contextkey/common/contextkey\"], function (require, exports, event_1, lifecycle_1, actions_1, commands_1, contextkey_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let MenuService = class MenuService {\n        constructor(_commandService) {\n            this._commandService = _commandService;\n            //\n        }\n        createMenu(id, contextKeyService) {\n            return new Menu(id, this._commandService, contextKeyService);\n        }\n    };\n    MenuService = __decorate([\n        __param(0, commands_1.ICommandService)\n    ], MenuService);\n    exports.MenuService = MenuService;\n    let Menu = class Menu {\n        constructor(_id, _commandService, _contextKeyService) {\n            this._id = _id;\n            this._commandService = _commandService;\n            this._contextKeyService = _contextKeyService;\n            this._onDidChange = new event_1.Emitter();\n            this._disposables = [];\n            this._build();\n            // rebuild this menu whenever the menu registry reports an\n            // event for this MenuId\n            event_1.Event.debounce(event_1.Event.filter(actions_1.MenuRegistry.onDidChangeMenu, menuId => menuId === this._id), () => { }, 50)(this._build, this, this._disposables);\n            // when context keys change we need to check if the menu also\n            // has changed\n            event_1.Event.debounce(this._contextKeyService.onDidChangeContext, (last, event) => last || event.affectsSome(this._contextKeys), 50)(e => e && this._onDidChange.fire(undefined), this, this._disposables);\n        }\n        _build() {\n            // reset\n            this._menuGroups = [];\n            this._contextKeys = new Set();\n            const menuItems = actions_1.MenuRegistry.getMenuItems(this._id);\n            let group;\n            menuItems.sort(Menu._compareMenuItems);\n            for (let item of menuItems) {\n                // group by groupId\n                const groupName = item.group || '';\n                if (!group || group[0] !== groupName) {\n                    group = [groupName, []];\n                    this._menuGroups.push(group);\n                }\n                group[1].push(item);\n                // keep keys for eventing\n                Menu._fillInKbExprKeys(item.when, this._contextKeys);\n                // keep precondition keys for event if applicable\n                if (actions_1.isIMenuItem(item) && item.command.precondition) {\n                    Menu._fillInKbExprKeys(item.command.precondition, this._contextKeys);\n                }\n                // keep toggled keys for event if applicable\n                if (actions_1.isIMenuItem(item) && item.command.toggled) {\n                    Menu._fillInKbExprKeys(item.command.toggled, this._contextKeys);\n                }\n            }\n            this._onDidChange.fire(this);\n        }\n        dispose() {\n            lifecycle_1.dispose(this._disposables);\n            this._onDidChange.dispose();\n        }\n        get onDidChange() {\n            return this._onDidChange.event;\n        }\n        getActions(options) {\n            const result = [];\n            for (let group of this._menuGroups) {\n                const [id, items] = group;\n                const activeActions = [];\n                for (const item of items) {\n                    if (this._contextKeyService.contextMatchesRules(item.when)) {\n                        const action = actions_1.isIMenuItem(item) ? new actions_1.MenuItemAction(item.command, item.alt, options, this._contextKeyService, this._commandService) : new actions_1.SubmenuItemAction(item);\n                        activeActions.push(action);\n                    }\n                }\n                if (activeActions.length > 0) {\n                    result.push([id, activeActions]);\n                }\n            }\n            return result;\n        }\n        static _fillInKbExprKeys(exp, set) {\n            if (exp) {\n                for (let key of exp.keys()) {\n                    set.add(key);\n                }\n            }\n        }\n        static _compareMenuItems(a, b) {\n            let aGroup = a.group;\n            let bGroup = b.group;\n            if (aGroup !== bGroup) {\n                // Falsy groups come last\n                if (!aGroup) {\n                    return 1;\n                }\n                else if (!bGroup) {\n                    return -1;\n                }\n                // 'navigation' group comes first\n                if (aGroup === 'navigation') {\n                    return -1;\n                }\n                else if (bGroup === 'navigation') {\n                    return 1;\n                }\n                // lexical sort for groups\n                let value = aGroup.localeCompare(bGroup);\n                if (value !== 0) {\n                    return value;\n                }\n            }\n            // sort on priority - default is 0\n            let aPrio = a.order || 0;\n            let bPrio = b.order || 0;\n            if (aPrio < bPrio) {\n                return -1;\n            }\n            else if (aPrio > bPrio) {\n                return 1;\n            }\n            // sort on titles\n            const aTitle = typeof a.command.title === 'string' ? a.command.title : a.command.title.value;\n            const bTitle = typeof b.command.title === 'string' ? b.command.title : b.command.title.value;\n            return aTitle.localeCompare(bTitle);\n        }\n    };\n    Menu = __decorate([\n        __param(1, commands_1.ICommandService),\n        __param(2, contextkey_1.IContextKeyService)\n    ], Menu);\n});\n",null]}