{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/strings\", \"vs/editor/common/core/range\", \"vs/editor/common/model\", \"vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase\"], function (require, exports, strings, range_1, model_1, pieceTreeBase_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class PieceTreeTextBuffer {\n        constructor(chunks, BOM, eol, containsRTL, isBasicASCII, eolNormalized) {\n            this._BOM = BOM;\n            this._mightContainNonBasicASCII = !isBasicASCII;\n            this._mightContainRTL = containsRTL;\n            this._pieceTree = new pieceTreeBase_1.PieceTreeBase(chunks, eol, eolNormalized);\n        }\n        // #region TextBuffer\n        equals(other) {\n            if (!(other instanceof PieceTreeTextBuffer)) {\n                return false;\n            }\n            if (this._BOM !== other._BOM) {\n                return false;\n            }\n            if (this.getEOL() !== other.getEOL()) {\n                return false;\n            }\n            return this._pieceTree.equal(other._pieceTree);\n        }\n        mightContainRTL() {\n            return this._mightContainRTL;\n        }\n        mightContainNonBasicASCII() {\n            return this._mightContainNonBasicASCII;\n        }\n        getBOM() {\n            return this._BOM;\n        }\n        getEOL() {\n            return this._pieceTree.getEOL();\n        }\n        createSnapshot(preserveBOM) {\n            return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n        }\n        getOffsetAt(lineNumber, column) {\n            return this._pieceTree.getOffsetAt(lineNumber, column);\n        }\n        getPositionAt(offset) {\n            return this._pieceTree.getPositionAt(offset);\n        }\n        getRangeAt(start, length) {\n            let end = start + length;\n            const startPosition = this.getPositionAt(start);\n            const endPosition = this.getPositionAt(end);\n            return new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n        }\n        getValueInRange(range, eol = model_1.EndOfLinePreference.TextDefined) {\n            if (range.isEmpty()) {\n                return '';\n            }\n            const lineEnding = this._getEndOfLine(eol);\n            return this._pieceTree.getValueInRange(range, lineEnding);\n        }\n        getValueLengthInRange(range, eol = model_1.EndOfLinePreference.TextDefined) {\n            if (range.isEmpty()) {\n                return 0;\n            }\n            if (range.startLineNumber === range.endLineNumber) {\n                return (range.endColumn - range.startColumn);\n            }\n            let startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n            let endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n            return endOffset - startOffset;\n        }\n        getLength() {\n            return this._pieceTree.getLength();\n        }\n        getLineCount() {\n            return this._pieceTree.getLineCount();\n        }\n        getLinesContent() {\n            return this._pieceTree.getLinesContent();\n        }\n        getLineContent(lineNumber) {\n            return this._pieceTree.getLineContent(lineNumber);\n        }\n        getLineCharCode(lineNumber, index) {\n            return this._pieceTree.getLineCharCode(lineNumber, index);\n        }\n        getLineLength(lineNumber) {\n            return this._pieceTree.getLineLength(lineNumber);\n        }\n        getLineMinColumn(lineNumber) {\n            return 1;\n        }\n        getLineMaxColumn(lineNumber) {\n            return this.getLineLength(lineNumber) + 1;\n        }\n        getLineFirstNonWhitespaceColumn(lineNumber) {\n            const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n            if (result === -1) {\n                return 0;\n            }\n            return result + 1;\n        }\n        getLineLastNonWhitespaceColumn(lineNumber) {\n            const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n            if (result === -1) {\n                return 0;\n            }\n            return result + 2;\n        }\n        _getEndOfLine(eol) {\n            switch (eol) {\n                case model_1.EndOfLinePreference.LF:\n                    return '\\n';\n                case model_1.EndOfLinePreference.CRLF:\n                    return '\\r\\n';\n                case model_1.EndOfLinePreference.TextDefined:\n                    return this.getEOL();\n            }\n            throw new Error('Unknown EOL preference');\n        }\n        setEOL(newEOL) {\n            this._pieceTree.setEOL(newEOL);\n        }\n        applyEdits(rawOperations, recordTrimAutoWhitespace) {\n            let mightContainRTL = this._mightContainRTL;\n            let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n            let canReduceOperations = true;\n            let operations = [];\n            for (let i = 0; i < rawOperations.length; i++) {\n                let op = rawOperations[i];\n                if (canReduceOperations && op._isTracked) {\n                    canReduceOperations = false;\n                }\n                let validatedRange = op.range;\n                if (!mightContainRTL && op.text) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainNonBasicASCII && op.text) {\n                    mightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                }\n                operations[i] = {\n                    sortIndex: i,\n                    identifier: op.identifier || null,\n                    range: validatedRange,\n                    rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                    rangeLength: this.getValueLengthInRange(validatedRange),\n                    lines: op.text ? op.text.split(/\\r\\n|\\r|\\n/) : null,\n                    forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                    isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n                };\n            }\n            // Sort operations ascending\n            operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n            let hasTouchingRanges = false;\n            for (let i = 0, count = operations.length - 1; i < count; i++) {\n                let rangeEnd = operations[i].range.getEndPosition();\n                let nextRangeStart = operations[i + 1].range.getStartPosition();\n                if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                    if (nextRangeStart.isBefore(rangeEnd)) {\n                        // overlapping ranges\n                        throw new Error('Overlapping ranges are not allowed!');\n                    }\n                    hasTouchingRanges = true;\n                }\n            }\n            if (canReduceOperations) {\n                operations = this._reduceOperations(operations);\n            }\n            // Delta encode operations\n            let reverseRanges = PieceTreeTextBuffer._getInverseEditRanges(operations);\n            let newTrimAutoWhitespaceCandidates = [];\n            for (let i = 0; i < operations.length; i++) {\n                let op = operations[i];\n                let reverseRange = reverseRanges[i];\n                if (recordTrimAutoWhitespace && op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n            let reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                let op = operations[i];\n                let reverseRange = reverseRanges[i];\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: this.getValueInRange(op.range),\n                    forceMoveMarkers: op.forceMoveMarkers\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n            this._mightContainRTL = mightContainRTL;\n            this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n            const contentChanges = this._doApplyEdits(operations);\n            let trimAutoWhitespaceLineNumbers = null;\n            if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n                // sort line numbers auto whitespace removal candidates for next edit descending\n                newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n                trimAutoWhitespaceLineNumbers = [];\n                for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                    let lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                    if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                        // Do not have the same line number twice\n                        continue;\n                    }\n                    let prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                    let lineContent = this.getLineContent(lineNumber);\n                    if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                        continue;\n                    }\n                    trimAutoWhitespaceLineNumbers.push(lineNumber);\n                }\n            }\n            return new model_1.ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n        }\n        /**\n         * Transform operations such that they represent the same logic edit,\n         * but that they also do not cause OOM crashes.\n         */\n        _reduceOperations(operations) {\n            if (operations.length < 1000) {\n                // We know from empirical testing that a thousand edits work fine regardless of their shape.\n                return operations;\n            }\n            // At one point, due to how events are emitted and how each operation is handled,\n            // some operations can trigger a high amount of temporary string allocations,\n            // that will immediately get edited again.\n            // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n            // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n            return [this._toSingleEditOperation(operations)];\n        }\n        _toSingleEditOperation(operations) {\n            let forceMoveMarkers = false, firstEditRange = operations[0].range, lastEditRange = operations[operations.length - 1].range, entireEditRange = new range_1.Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn), lastEndLineNumber = firstEditRange.startLineNumber, lastEndColumn = firstEditRange.startColumn, result = [];\n            for (let i = 0, len = operations.length; i < len; i++) {\n                let operation = operations[i], range = operation.range;\n                forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n                // (1) -- Push old text\n                for (let lineNumber = lastEndLineNumber; lineNumber < range.startLineNumber; lineNumber++) {\n                    if (lineNumber === lastEndLineNumber) {\n                        result.push(this.getLineContent(lineNumber).substring(lastEndColumn - 1));\n                    }\n                    else {\n                        result.push('\\n');\n                        result.push(this.getLineContent(lineNumber));\n                    }\n                }\n                if (range.startLineNumber === lastEndLineNumber) {\n                    result.push(this.getLineContent(range.startLineNumber).substring(lastEndColumn - 1, range.startColumn - 1));\n                }\n                else {\n                    result.push('\\n');\n                    result.push(this.getLineContent(range.startLineNumber).substring(0, range.startColumn - 1));\n                }\n                // (2) -- Push new text\n                if (operation.lines) {\n                    for (let j = 0, lenJ = operation.lines.length; j < lenJ; j++) {\n                        if (j !== 0) {\n                            result.push('\\n');\n                        }\n                        result.push(operation.lines[j]);\n                    }\n                }\n                lastEndLineNumber = operation.range.endLineNumber;\n                lastEndColumn = operation.range.endColumn;\n            }\n            return {\n                sortIndex: 0,\n                identifier: operations[0].identifier,\n                range: entireEditRange,\n                rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n                rangeLength: this.getValueLengthInRange(entireEditRange, model_1.EndOfLinePreference.TextDefined),\n                lines: result.join('').split('\\n'),\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: false\n            };\n        }\n        _doApplyEdits(operations) {\n            operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n            let contentChanges = [];\n            // operations are from bottom to top\n            for (let i = 0; i < operations.length; i++) {\n                let op = operations[i];\n                const startLineNumber = op.range.startLineNumber;\n                const startColumn = op.range.startColumn;\n                const endLineNumber = op.range.endLineNumber;\n                const endColumn = op.range.endColumn;\n                if (startLineNumber === endLineNumber && startColumn === endColumn && (!op.lines || op.lines.length === 0)) {\n                    // no-op\n                    continue;\n                }\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = (op.lines ? op.lines.length - 1 : 0);\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const text = (op.lines ? op.lines.join(this.getEOL()) : '');\n                if (text) {\n                    // replacement\n                    this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                    this._pieceTree.insert(op.rangeOffset, text, true);\n                }\n                else {\n                    // deletion\n                    this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    let newLinesContent = [];\n                    for (let j = editingLinesCnt + 1; j <= insertingLinesCnt; j++) {\n                        newLinesContent.push(op.lines[j]);\n                    }\n                    newLinesContent[newLinesContent.length - 1] = this.getLineContent(startLineNumber + insertingLinesCnt - 1);\n                }\n                const contentChangeRange = new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);\n                contentChanges.push({\n                    range: contentChangeRange,\n                    rangeLength: op.rangeLength,\n                    text: text,\n                    rangeOffset: op.rangeOffset,\n                    forceMoveMarkers: op.forceMoveMarkers\n                });\n            }\n            return contentChanges;\n        }\n        findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n            return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        // #endregion\n        // #region helper\n        // testing purpose.\n        getPieceTree() {\n            return this._pieceTree;\n        }\n        /**\n         * Assumes `operations` are validated and sorted ascending\n         */\n        static _getInverseEditRanges(operations) {\n            let result = [];\n            let prevOpEndLineNumber = 0;\n            let prevOpEndColumn = 0;\n            let prevOp = null;\n            for (let i = 0, len = operations.length; i < len; i++) {\n                let op = operations[i];\n                let startLineNumber;\n                let startColumn;\n                if (prevOp) {\n                    if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                        startLineNumber = prevOpEndLineNumber;\n                        startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                    }\n                    else {\n                        startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                        startColumn = op.range.startColumn;\n                    }\n                }\n                else {\n                    startLineNumber = op.range.startLineNumber;\n                    startColumn = op.range.startColumn;\n                }\n                let resultRange;\n                if (op.lines && op.lines.length > 0) {\n                    // the operation inserts something\n                    let lineCount = op.lines.length;\n                    let firstLine = op.lines[0];\n                    let lastLine = op.lines[lineCount - 1];\n                    if (lineCount === 1) {\n                        // single line insert\n                        resultRange = new range_1.Range(startLineNumber, startColumn, startLineNumber, startColumn + firstLine.length);\n                    }\n                    else {\n                        // multi line insert\n                        resultRange = new range_1.Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLine.length + 1);\n                    }\n                }\n                else {\n                    // There is nothing to insert\n                    resultRange = new range_1.Range(startLineNumber, startColumn, startLineNumber, startColumn);\n                }\n                prevOpEndLineNumber = resultRange.endLineNumber;\n                prevOpEndColumn = resultRange.endColumn;\n                result.push(resultRange);\n                prevOp = op;\n            }\n            return result;\n        }\n        static _sortOpsAscending(a, b) {\n            let r = range_1.Range.compareRangesUsingEnds(a.range, b.range);\n            if (r === 0) {\n                return a.sortIndex - b.sortIndex;\n            }\n            return r;\n        }\n        static _sortOpsDescending(a, b) {\n            let r = range_1.Range.compareRangesUsingEnds(a.range, b.range);\n            if (r === 0) {\n                return b.sortIndex - a.sortIndex;\n            }\n            return -r;\n        }\n    }\n    exports.PieceTreeTextBuffer = PieceTreeTextBuffer;\n});\n",null]}