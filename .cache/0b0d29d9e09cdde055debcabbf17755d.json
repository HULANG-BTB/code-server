{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/node/fileSearchManager.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/node/fileSearchManager.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/path\", \"vs/base/common/cancellation\", \"vs/base/common/errorMessage\", \"vs/base/common/glob\", \"vs/base/common/resources\", \"vs/base/common/stopwatch\", \"vs/workbench/services/search/common/search\"], function (require, exports, path, cancellation_1, errorMessage_1, glob, resources, stopwatch_1, search_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class FileSearchEngine {\n        constructor(config, provider, sessionToken) {\n            this.config = config;\n            this.provider = provider;\n            this.sessionToken = sessionToken;\n            this.isLimitHit = false;\n            this.resultCount = 0;\n            this.isCanceled = false;\n            this.filePattern = config.filePattern;\n            this.includePattern = config.includePattern && glob.parse(config.includePattern);\n            this.maxResults = config.maxResults || undefined;\n            this.exists = config.exists;\n            this.activeCancellationTokens = new Set();\n            this.globalExcludePattern = config.excludePattern && glob.parse(config.excludePattern);\n        }\n        cancel() {\n            this.isCanceled = true;\n            this.activeCancellationTokens.forEach(t => t.cancel());\n            this.activeCancellationTokens = new Set();\n        }\n        search(_onResult) {\n            const folderQueries = this.config.folderQueries || [];\n            return new Promise((resolve, reject) => {\n                const onResult = (match) => {\n                    this.resultCount++;\n                    _onResult(match);\n                };\n                // Support that the file pattern is a full path to a file that exists\n                if (this.isCanceled) {\n                    return resolve({ limitHit: this.isLimitHit });\n                }\n                // For each extra file\n                if (this.config.extraFileResources) {\n                    this.config.extraFileResources\n                        .forEach(extraFile => {\n                        const extraFileStr = extraFile.toString(); // ?\n                        const basename = path.basename(extraFileStr);\n                        if (this.globalExcludePattern && this.globalExcludePattern(extraFileStr, basename)) {\n                            return; // excluded\n                        }\n                        // File: Check for match on file pattern and include pattern\n                        this.matchFile(onResult, { base: extraFile, basename });\n                    });\n                }\n                // For each root folder\n                Promise.all(folderQueries.map(fq => {\n                    return this.searchInFolder(fq, onResult);\n                })).then(stats => {\n                    resolve({\n                        limitHit: this.isLimitHit,\n                        stats: stats[0] || undefined // Only looking at single-folder workspace stats...\n                    });\n                }, (err) => {\n                    reject(new Error(errorMessage_1.toErrorMessage(err)));\n                });\n            });\n        }\n        searchInFolder(fq, onResult) {\n            const cancellation = new cancellation_1.CancellationTokenSource();\n            return new Promise((resolve, reject) => {\n                const options = this.getSearchOptionsForFolder(fq);\n                const tree = this.initDirectoryTree();\n                const queryTester = new search_1.QueryGlobTester(this.config, fq);\n                const noSiblingsClauses = !queryTester.hasSiblingExcludeClauses();\n                let providerSW;\n                new Promise(_resolve => process.nextTick(_resolve))\n                    .then(() => {\n                    this.activeCancellationTokens.add(cancellation);\n                    providerSW = stopwatch_1.StopWatch.create();\n                    return this.provider.provideFileSearchResults({\n                        pattern: this.config.filePattern || ''\n                    }, options, cancellation.token);\n                })\n                    .then(results => {\n                    const providerTime = providerSW.elapsed();\n                    const postProcessSW = stopwatch_1.StopWatch.create();\n                    if (this.isCanceled && !this.isLimitHit) {\n                        return null;\n                    }\n                    if (results) {\n                        results.forEach(result => {\n                            const relativePath = path.posix.relative(fq.folder.path, result.path);\n                            if (noSiblingsClauses) {\n                                const basename = path.basename(result.path);\n                                this.matchFile(onResult, { base: fq.folder, relativePath, basename });\n                                return;\n                            }\n                            // TODO: Optimize siblings clauses with ripgrep here.\n                            this.addDirectoryEntries(tree, fq.folder, relativePath, onResult);\n                        });\n                    }\n                    this.activeCancellationTokens.delete(cancellation);\n                    if (this.isCanceled && !this.isLimitHit) {\n                        return null;\n                    }\n                    this.matchDirectoryTree(tree, queryTester, onResult);\n                    return {\n                        providerTime,\n                        postProcessTime: postProcessSW.elapsed()\n                    };\n                }).then(stats => {\n                    cancellation.dispose();\n                    resolve(stats);\n                }, err => {\n                    cancellation.dispose();\n                    reject(err);\n                });\n            });\n        }\n        getSearchOptionsForFolder(fq) {\n            const includes = search_1.resolvePatternsForProvider(this.config.includePattern, fq.includePattern);\n            const excludes = search_1.resolvePatternsForProvider(this.config.excludePattern, fq.excludePattern);\n            return {\n                folder: fq.folder,\n                excludes,\n                includes,\n                useIgnoreFiles: !fq.disregardIgnoreFiles,\n                useGlobalIgnoreFiles: !fq.disregardGlobalIgnoreFiles,\n                followSymlinks: !fq.ignoreSymlinks,\n                maxResults: this.config.maxResults,\n                session: this.sessionToken\n            };\n        }\n        initDirectoryTree() {\n            const tree = {\n                rootEntries: [],\n                pathToEntries: Object.create(null)\n            };\n            tree.pathToEntries['.'] = tree.rootEntries;\n            return tree;\n        }\n        addDirectoryEntries({ pathToEntries }, base, relativeFile, onResult) {\n            // Support relative paths to files from a root resource (ignores excludes)\n            if (relativeFile === this.filePattern) {\n                const basename = path.basename(this.filePattern);\n                this.matchFile(onResult, { base: base, relativePath: this.filePattern, basename });\n            }\n            function add(relativePath) {\n                const basename = path.basename(relativePath);\n                const dirname = path.dirname(relativePath);\n                let entries = pathToEntries[dirname];\n                if (!entries) {\n                    entries = pathToEntries[dirname] = [];\n                    add(dirname);\n                }\n                entries.push({\n                    base,\n                    relativePath,\n                    basename\n                });\n            }\n            add(relativeFile);\n        }\n        matchDirectoryTree({ rootEntries, pathToEntries }, queryTester, onResult) {\n            const self = this;\n            const filePattern = this.filePattern;\n            function matchDirectory(entries) {\n                const hasSibling = glob.hasSiblingFn(() => entries.map(entry => entry.basename));\n                for (let i = 0, n = entries.length; i < n; i++) {\n                    const entry = entries[i];\n                    const { relativePath, basename } = entry;\n                    // Check exclude pattern\n                    // If the user searches for the exact file name, we adjust the glob matching\n                    // to ignore filtering by siblings because the user seems to know what she\n                    // is searching for and we want to include the result in that case anyway\n                    if (!queryTester.includedInQuerySync(relativePath, basename, filePattern !== basename ? hasSibling : undefined)) {\n                        continue;\n                    }\n                    const sub = pathToEntries[relativePath];\n                    if (sub) {\n                        matchDirectory(sub);\n                    }\n                    else {\n                        if (relativePath === filePattern) {\n                            continue; // ignore file if its path matches with the file pattern because that is already matched above\n                        }\n                        self.matchFile(onResult, entry);\n                    }\n                    if (self.isLimitHit) {\n                        break;\n                    }\n                }\n            }\n            matchDirectory(rootEntries);\n        }\n        matchFile(onResult, candidate) {\n            if (!this.includePattern || (candidate.relativePath && this.includePattern(candidate.relativePath, candidate.basename))) {\n                if (this.exists || (this.maxResults && this.resultCount >= this.maxResults)) {\n                    this.isLimitHit = true;\n                    this.cancel();\n                }\n                if (!this.isLimitHit) {\n                    onResult(candidate);\n                }\n            }\n        }\n    }\n    class FileSearchManager {\n        constructor() {\n            this.sessions = new Map();\n        }\n        fileSearch(config, provider, onBatch, token) {\n            const sessionTokenSource = this.getSessionTokenSource(config.cacheKey);\n            const engine = new FileSearchEngine(config, provider, sessionTokenSource && sessionTokenSource.token);\n            let resultCount = 0;\n            const onInternalResult = (batch) => {\n                resultCount += batch.length;\n                onBatch(batch.map(m => this.rawMatchToSearchItem(m)));\n            };\n            return this.doSearch(engine, FileSearchManager.BATCH_SIZE, onInternalResult, token).then(result => {\n                return {\n                    limitHit: result.limitHit,\n                    stats: {\n                        fromCache: false,\n                        type: 'fileSearchProvider',\n                        resultCount,\n                        detailStats: result.stats\n                    }\n                };\n            });\n        }\n        clearCache(cacheKey) {\n            const sessionTokenSource = this.getSessionTokenSource(cacheKey);\n            if (sessionTokenSource) {\n                sessionTokenSource.cancel();\n            }\n        }\n        getSessionTokenSource(cacheKey) {\n            if (!cacheKey) {\n                return undefined;\n            }\n            if (!this.sessions.has(cacheKey)) {\n                this.sessions.set(cacheKey, new cancellation_1.CancellationTokenSource());\n            }\n            return this.sessions.get(cacheKey);\n        }\n        rawMatchToSearchItem(match) {\n            if (match.relativePath) {\n                return {\n                    resource: resources.joinPath(match.base, match.relativePath)\n                };\n            }\n            else {\n                // extraFileResources\n                return {\n                    resource: match.base\n                };\n            }\n        }\n        doSearch(engine, batchSize, onResultBatch, token) {\n            token.onCancellationRequested(() => {\n                engine.cancel();\n            });\n            const _onResult = (match) => {\n                if (match) {\n                    batch.push(match);\n                    if (batchSize > 0 && batch.length >= batchSize) {\n                        onResultBatch(batch);\n                        batch = [];\n                    }\n                }\n            };\n            let batch = [];\n            return engine.search(_onResult).then(result => {\n                if (batch.length) {\n                    onResultBatch(batch);\n                }\n                return result;\n            }, error => {\n                if (batch.length) {\n                    onResultBatch(batch);\n                }\n                return Promise.reject(error);\n            });\n        }\n    }\n    FileSearchManager.BATCH_SIZE = 512;\n    exports.FileSearchManager = FileSearchManager;\n});\n",null]}