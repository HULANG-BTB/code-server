{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/linesOperations/linesOperations.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/linesOperations/linesOperations.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/keyCodes\", \"vs/editor/browser/controller/coreCommands\", \"vs/editor/browser/editorExtensions\", \"vs/editor/common/commands/replaceCommand\", \"vs/editor/common/commands/trimTrailingWhitespaceCommand\", \"vs/editor/common/controller/cursorTypeOperations\", \"vs/editor/common/core/editOperation\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\", \"vs/editor/common/core/selection\", \"vs/editor/common/editorContextKeys\", \"vs/editor/contrib/linesOperations/copyLinesCommand\", \"vs/editor/contrib/linesOperations/moveLinesCommand\", \"vs/editor/contrib/linesOperations/sortLinesCommand\", \"vs/platform/actions/common/actions\", \"vs/platform/keybinding/common/keybindingsRegistry\"], function (require, exports, nls, keyCodes_1, coreCommands_1, editorExtensions_1, replaceCommand_1, trimTrailingWhitespaceCommand_1, cursorTypeOperations_1, editOperation_1, position_1, range_1, selection_1, editorContextKeys_1, copyLinesCommand_1, moveLinesCommand_1, sortLinesCommand_1, actions_1, keybindingsRegistry_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // copy lines\n    class AbstractCopyLinesAction extends editorExtensions_1.EditorAction {\n        constructor(down, opts) {\n            super(opts);\n            this.down = down;\n        }\n        run(_accessor, editor) {\n            const commands = [];\n            const selections = editor.getSelections() || [];\n            for (const selection of selections) {\n                commands.push(new copyLinesCommand_1.CopyLinesCommand(selection, this.down));\n            }\n            editor.pushUndoStop();\n            editor.executeCommands(this.id, commands);\n            editor.pushUndoStop();\n        }\n    }\n    class CopyLinesUpAction extends AbstractCopyLinesAction {\n        constructor() {\n            super(false, {\n                id: 'editor.action.copyLinesUpAction',\n                label: nls.localize('lines.copyUp', \"Copy Line Up\"),\n                alias: 'Copy Line Up',\n                precondition: editorContextKeys_1.EditorContextKeys.writable,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.UpArrow,\n                    linux: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.UpArrow },\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                menubarOpts: {\n                    menuId: actions_1.MenuId.MenubarSelectionMenu,\n                    group: '2_line',\n                    title: nls.localize({ key: 'miCopyLinesUp', comment: ['&& denotes a mnemonic'] }, \"&&Copy Line Up\"),\n                    order: 1\n                }\n            });\n        }\n    }\n    class CopyLinesDownAction extends AbstractCopyLinesAction {\n        constructor() {\n            super(true, {\n                id: 'editor.action.copyLinesDownAction',\n                label: nls.localize('lines.copyDown', \"Copy Line Down\"),\n                alias: 'Copy Line Down',\n                precondition: editorContextKeys_1.EditorContextKeys.writable,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.DownArrow,\n                    linux: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.DownArrow },\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                menubarOpts: {\n                    menuId: actions_1.MenuId.MenubarSelectionMenu,\n                    group: '2_line',\n                    title: nls.localize({ key: 'miCopyLinesDown', comment: ['&& denotes a mnemonic'] }, \"Co&&py Line Down\"),\n                    order: 2\n                }\n            });\n        }\n    }\n    // move lines\n    class AbstractMoveLinesAction extends editorExtensions_1.EditorAction {\n        constructor(down, opts) {\n            super(opts);\n            this.down = down;\n        }\n        run(_accessor, editor) {\n            let commands = [];\n            let selections = editor.getSelections() || [];\n            let autoIndent = editor.getConfiguration().autoIndent;\n            for (const selection of selections) {\n                commands.push(new moveLinesCommand_1.MoveLinesCommand(selection, this.down, autoIndent));\n            }\n            editor.pushUndoStop();\n            editor.executeCommands(this.id, commands);\n            editor.pushUndoStop();\n        }\n    }\n    class MoveLinesUpAction extends AbstractMoveLinesAction {\n        constructor() {\n            super(false, {\n                id: 'editor.action.moveLinesUpAction',\n                label: nls.localize('lines.moveUp', \"Move Line Up\"),\n                alias: 'Move Line Up',\n                precondition: editorContextKeys_1.EditorContextKeys.writable,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.UpArrow,\n                    linux: { primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.UpArrow },\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                menubarOpts: {\n                    menuId: actions_1.MenuId.MenubarSelectionMenu,\n                    group: '2_line',\n                    title: nls.localize({ key: 'miMoveLinesUp', comment: ['&& denotes a mnemonic'] }, \"Mo&&ve Line Up\"),\n                    order: 3\n                }\n            });\n        }\n    }\n    class MoveLinesDownAction extends AbstractMoveLinesAction {\n        constructor() {\n            super(true, {\n                id: 'editor.action.moveLinesDownAction',\n                label: nls.localize('lines.moveDown', \"Move Line Down\"),\n                alias: 'Move Line Down',\n                precondition: editorContextKeys_1.EditorContextKeys.writable,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.DownArrow,\n                    linux: { primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.DownArrow },\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                menubarOpts: {\n                    menuId: actions_1.MenuId.MenubarSelectionMenu,\n                    group: '2_line',\n                    title: nls.localize({ key: 'miMoveLinesDown', comment: ['&& denotes a mnemonic'] }, \"Move &&Line Down\"),\n                    order: 4\n                }\n            });\n        }\n    }\n    class AbstractSortLinesAction extends editorExtensions_1.EditorAction {\n        constructor(descending, opts) {\n            super(opts);\n            this.descending = descending;\n        }\n        run(_accessor, editor) {\n            const selections = editor.getSelections() || [];\n            for (const selection of selections) {\n                if (!sortLinesCommand_1.SortLinesCommand.canRun(editor.getModel(), selection, this.descending)) {\n                    return;\n                }\n            }\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = new sortLinesCommand_1.SortLinesCommand(selections[i], this.descending);\n            }\n            editor.pushUndoStop();\n            editor.executeCommands(this.id, commands);\n            editor.pushUndoStop();\n        }\n    }\n    exports.AbstractSortLinesAction = AbstractSortLinesAction;\n    class SortLinesAscendingAction extends AbstractSortLinesAction {\n        constructor() {\n            super(false, {\n                id: 'editor.action.sortLinesAscending',\n                label: nls.localize('lines.sortAscending', \"Sort Lines Ascending\"),\n                alias: 'Sort Lines Ascending',\n                precondition: editorContextKeys_1.EditorContextKeys.writable\n            });\n        }\n    }\n    exports.SortLinesAscendingAction = SortLinesAscendingAction;\n    class SortLinesDescendingAction extends AbstractSortLinesAction {\n        constructor() {\n            super(true, {\n                id: 'editor.action.sortLinesDescending',\n                label: nls.localize('lines.sortDescending', \"Sort Lines Descending\"),\n                alias: 'Sort Lines Descending',\n                precondition: editorContextKeys_1.EditorContextKeys.writable\n            });\n        }\n    }\n    exports.SortLinesDescendingAction = SortLinesDescendingAction;\n    class TrimTrailingWhitespaceAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: TrimTrailingWhitespaceAction.ID,\n                label: nls.localize('lines.trimTrailingWhitespace', \"Trim Trailing Whitespace\"),\n                alias: 'Trim Trailing Whitespace',\n                precondition: editorContextKeys_1.EditorContextKeys.writable,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyChord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_X),\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        run(_accessor, editor, args) {\n            let cursors = [];\n            if (args.reason === 'auto-save') {\n                // See https://github.com/editorconfig/editorconfig-vscode/issues/47\n                // It is very convenient for the editor config extension to invoke this action.\n                // So, if we get a reason:'auto-save' passed in, let's preserve cursor positions.\n                cursors = (editor.getSelections() || []).map(s => new position_1.Position(s.positionLineNumber, s.positionColumn));\n            }\n            let selection = editor.getSelection();\n            if (selection === null) {\n                return;\n            }\n            let command = new trimTrailingWhitespaceCommand_1.TrimTrailingWhitespaceCommand(selection, cursors);\n            editor.pushUndoStop();\n            editor.executeCommands(this.id, [command]);\n            editor.pushUndoStop();\n        }\n    }\n    TrimTrailingWhitespaceAction.ID = 'editor.action.trimTrailingWhitespace';\n    exports.TrimTrailingWhitespaceAction = TrimTrailingWhitespaceAction;\n    class DeleteLinesAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.deleteLines',\n                label: nls.localize('lines.delete', \"Delete Line\"),\n                alias: 'Delete Line',\n                precondition: editorContextKeys_1.EditorContextKeys.writable,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.textInputFocus,\n                    primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_K,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        run(_accessor, editor) {\n            if (!editor.hasModel()) {\n                return;\n            }\n            let ops = this._getLinesToRemove(editor);\n            let model = editor.getModel();\n            if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {\n                // Model is empty\n                return;\n            }\n            let linesDeleted = 0;\n            let edits = [];\n            let cursorState = [];\n            for (let i = 0, len = ops.length; i < len; i++) {\n                const op = ops[i];\n                let startLineNumber = op.startLineNumber;\n                let endLineNumber = op.endLineNumber;\n                let startColumn = 1;\n                let endColumn = model.getLineMaxColumn(endLineNumber);\n                if (endLineNumber < model.getLineCount()) {\n                    endLineNumber += 1;\n                    endColumn = 1;\n                }\n                else if (startLineNumber > 1) {\n                    startLineNumber -= 1;\n                    startColumn = model.getLineMaxColumn(startLineNumber);\n                }\n                edits.push(editOperation_1.EditOperation.replace(new selection_1.Selection(startLineNumber, startColumn, endLineNumber, endColumn), ''));\n                cursorState.push(new selection_1.Selection(startLineNumber - linesDeleted, op.positionColumn, startLineNumber - linesDeleted, op.positionColumn));\n                linesDeleted += (op.endLineNumber - op.startLineNumber + 1);\n            }\n            editor.pushUndoStop();\n            editor.executeEdits(this.id, edits, cursorState);\n            editor.pushUndoStop();\n        }\n        _getLinesToRemove(editor) {\n            // Construct delete operations\n            let operations = editor.getSelections().map((s) => {\n                let endLineNumber = s.endLineNumber;\n                if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n                    endLineNumber -= 1;\n                }\n                return {\n                    startLineNumber: s.startLineNumber,\n                    selectionStartColumn: s.selectionStartColumn,\n                    endLineNumber: endLineNumber,\n                    positionColumn: s.positionColumn\n                };\n            });\n            // Sort delete operations\n            operations.sort((a, b) => {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.endLineNumber - b.endLineNumber;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            });\n            // Merge delete operations which are adjacent or overlapping\n            let mergedOperations = [];\n            let previousOperation = operations[0];\n            for (let i = 1; i < operations.length; i++) {\n                if (previousOperation.endLineNumber + 1 >= operations[i].startLineNumber) {\n                    // Merge current operations into the previous one\n                    previousOperation.endLineNumber = operations[i].endLineNumber;\n                }\n                else {\n                    // Push previous operation\n                    mergedOperations.push(previousOperation);\n                    previousOperation = operations[i];\n                }\n            }\n            // Push the last operation\n            mergedOperations.push(previousOperation);\n            return mergedOperations;\n        }\n    }\n    exports.DeleteLinesAction = DeleteLinesAction;\n    class IndentLinesAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.indentLines',\n                label: nls.localize('lines.indent', \"Indent Line\"),\n                alias: 'Indent Line',\n                precondition: editorContextKeys_1.EditorContextKeys.writable,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.US_CLOSE_SQUARE_BRACKET,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        run(_accessor, editor) {\n            const cursors = editor._getCursors();\n            if (!cursors) {\n                return;\n            }\n            editor.pushUndoStop();\n            editor.executeCommands(this.id, cursorTypeOperations_1.TypeOperations.indent(cursors.context.config, editor.getModel(), editor.getSelections()));\n            editor.pushUndoStop();\n        }\n    }\n    exports.IndentLinesAction = IndentLinesAction;\n    class OutdentLinesAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.outdentLines',\n                label: nls.localize('lines.outdent', \"Outdent Line\"),\n                alias: 'Outdent Line',\n                precondition: editorContextKeys_1.EditorContextKeys.writable,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.US_OPEN_SQUARE_BRACKET,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        run(_accessor, editor) {\n            coreCommands_1.CoreEditingCommands.Outdent.runEditorCommand(_accessor, editor, null);\n        }\n    }\n    class InsertLineBeforeAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.insertLineBefore',\n                label: nls.localize('lines.insertBefore', \"Insert Line Above\"),\n                alias: 'Insert Line Above',\n                precondition: editorContextKeys_1.EditorContextKeys.writable,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Enter,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        run(_accessor, editor) {\n            const cursors = editor._getCursors();\n            if (!cursors) {\n                return;\n            }\n            editor.pushUndoStop();\n            editor.executeCommands(this.id, cursorTypeOperations_1.TypeOperations.lineInsertBefore(cursors.context.config, editor.getModel(), editor.getSelections()));\n        }\n    }\n    exports.InsertLineBeforeAction = InsertLineBeforeAction;\n    class InsertLineAfterAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.insertLineAfter',\n                label: nls.localize('lines.insertAfter', \"Insert Line Below\"),\n                alias: 'Insert Line Below',\n                precondition: editorContextKeys_1.EditorContextKeys.writable,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.Enter,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        run(_accessor, editor) {\n            const cursors = editor._getCursors();\n            if (!cursors) {\n                return;\n            }\n            editor.pushUndoStop();\n            editor.executeCommands(this.id, cursorTypeOperations_1.TypeOperations.lineInsertAfter(cursors.context.config, editor.getModel(), editor.getSelections()));\n        }\n    }\n    exports.InsertLineAfterAction = InsertLineAfterAction;\n    class AbstractDeleteAllToBoundaryAction extends editorExtensions_1.EditorAction {\n        run(_accessor, editor) {\n            if (!editor.hasModel()) {\n                return;\n            }\n            const primaryCursor = editor.getSelection();\n            let rangesToDelete = this._getRangesToDelete(editor);\n            // merge overlapping selections\n            let effectiveRanges = [];\n            for (let i = 0, count = rangesToDelete.length - 1; i < count; i++) {\n                let range = rangesToDelete[i];\n                let nextRange = rangesToDelete[i + 1];\n                if (range_1.Range.intersectRanges(range, nextRange) === null) {\n                    effectiveRanges.push(range);\n                }\n                else {\n                    rangesToDelete[i + 1] = range_1.Range.plusRange(range, nextRange);\n                }\n            }\n            effectiveRanges.push(rangesToDelete[rangesToDelete.length - 1]);\n            let endCursorState = this._getEndCursorState(primaryCursor, effectiveRanges);\n            let edits = effectiveRanges.map(range => {\n                return editOperation_1.EditOperation.replace(range, '');\n            });\n            editor.pushUndoStop();\n            editor.executeEdits(this.id, edits, endCursorState);\n            editor.pushUndoStop();\n        }\n    }\n    exports.AbstractDeleteAllToBoundaryAction = AbstractDeleteAllToBoundaryAction;\n    class DeleteAllLeftAction extends AbstractDeleteAllToBoundaryAction {\n        constructor() {\n            super({\n                id: 'deleteAllLeft',\n                label: nls.localize('lines.deleteAllLeft', \"Delete All Left\"),\n                alias: 'Delete All Left',\n                precondition: editorContextKeys_1.EditorContextKeys.writable,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.textInputFocus,\n                    primary: 0,\n                    mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.Backspace },\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        _getEndCursorState(primaryCursor, rangesToDelete) {\n            let endPrimaryCursor = null;\n            let endCursorState = [];\n            let deletedLines = 0;\n            rangesToDelete.forEach(range => {\n                let endCursor;\n                if (range.endColumn === 1 && deletedLines > 0) {\n                    let newStartLine = range.startLineNumber - deletedLines;\n                    endCursor = new selection_1.Selection(newStartLine, range.startColumn, newStartLine, range.startColumn);\n                }\n                else {\n                    endCursor = new selection_1.Selection(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n                }\n                deletedLines += range.endLineNumber - range.startLineNumber;\n                if (range.intersectRanges(primaryCursor)) {\n                    endPrimaryCursor = endCursor;\n                }\n                else {\n                    endCursorState.push(endCursor);\n                }\n            });\n            if (endPrimaryCursor) {\n                endCursorState.unshift(endPrimaryCursor);\n            }\n            return endCursorState;\n        }\n        _getRangesToDelete(editor) {\n            let selections = editor.getSelections();\n            if (selections === null) {\n                return [];\n            }\n            let rangesToDelete = selections;\n            let model = editor.getModel();\n            if (model === null) {\n                return [];\n            }\n            rangesToDelete.sort(range_1.Range.compareRangesUsingStarts);\n            rangesToDelete = rangesToDelete.map(selection => {\n                if (selection.isEmpty()) {\n                    if (selection.startColumn === 1) {\n                        let deleteFromLine = Math.max(1, selection.startLineNumber - 1);\n                        let deleteFromColumn = selection.startLineNumber === 1 ? 1 : model.getLineContent(deleteFromLine).length + 1;\n                        return new range_1.Range(deleteFromLine, deleteFromColumn, selection.startLineNumber, 1);\n                    }\n                    else {\n                        return new range_1.Range(selection.startLineNumber, 1, selection.startLineNumber, selection.startColumn);\n                    }\n                }\n                else {\n                    return selection;\n                }\n            });\n            return rangesToDelete;\n        }\n    }\n    exports.DeleteAllLeftAction = DeleteAllLeftAction;\n    class DeleteAllRightAction extends AbstractDeleteAllToBoundaryAction {\n        constructor() {\n            super({\n                id: 'deleteAllRight',\n                label: nls.localize('lines.deleteAllRight', \"Delete All Right\"),\n                alias: 'Delete All Right',\n                precondition: editorContextKeys_1.EditorContextKeys.writable,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.textInputFocus,\n                    primary: 0,\n                    mac: { primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_K, secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.Delete] },\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        _getEndCursorState(primaryCursor, rangesToDelete) {\n            let endPrimaryCursor = null;\n            let endCursorState = [];\n            for (let i = 0, len = rangesToDelete.length, offset = 0; i < len; i++) {\n                let range = rangesToDelete[i];\n                let endCursor = new selection_1.Selection(range.startLineNumber - offset, range.startColumn, range.startLineNumber - offset, range.startColumn);\n                if (range.intersectRanges(primaryCursor)) {\n                    endPrimaryCursor = endCursor;\n                }\n                else {\n                    endCursorState.push(endCursor);\n                }\n            }\n            if (endPrimaryCursor) {\n                endCursorState.unshift(endPrimaryCursor);\n            }\n            return endCursorState;\n        }\n        _getRangesToDelete(editor) {\n            let model = editor.getModel();\n            if (model === null) {\n                return [];\n            }\n            let selections = editor.getSelections();\n            if (selections === null) {\n                return [];\n            }\n            let rangesToDelete = selections.map((sel) => {\n                if (sel.isEmpty()) {\n                    const maxColumn = model.getLineMaxColumn(sel.startLineNumber);\n                    if (sel.startColumn === maxColumn) {\n                        return new range_1.Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber + 1, 1);\n                    }\n                    else {\n                        return new range_1.Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber, maxColumn);\n                    }\n                }\n                return sel;\n            });\n            rangesToDelete.sort(range_1.Range.compareRangesUsingStarts);\n            return rangesToDelete;\n        }\n    }\n    exports.DeleteAllRightAction = DeleteAllRightAction;\n    class JoinLinesAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.joinLines',\n                label: nls.localize('lines.joinLines', \"Join Lines\"),\n                alias: 'Join Lines',\n                precondition: editorContextKeys_1.EditorContextKeys.writable,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: 0,\n                    mac: { primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_J },\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        run(_accessor, editor) {\n            let selections = editor.getSelections();\n            if (selections === null) {\n                return;\n            }\n            let primaryCursor = editor.getSelection();\n            if (primaryCursor === null) {\n                return;\n            }\n            selections.sort(range_1.Range.compareRangesUsingStarts);\n            let reducedSelections = [];\n            let lastSelection = selections.reduce((previousValue, currentValue) => {\n                if (previousValue.isEmpty()) {\n                    if (previousValue.endLineNumber === currentValue.startLineNumber) {\n                        if (primaryCursor.equalsSelection(previousValue)) {\n                            primaryCursor = currentValue;\n                        }\n                        return currentValue;\n                    }\n                    if (currentValue.startLineNumber > previousValue.endLineNumber + 1) {\n                        reducedSelections.push(previousValue);\n                        return currentValue;\n                    }\n                    else {\n                        return new selection_1.Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);\n                    }\n                }\n                else {\n                    if (currentValue.startLineNumber > previousValue.endLineNumber) {\n                        reducedSelections.push(previousValue);\n                        return currentValue;\n                    }\n                    else {\n                        return new selection_1.Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);\n                    }\n                }\n            });\n            reducedSelections.push(lastSelection);\n            let model = editor.getModel();\n            if (model === null) {\n                return;\n            }\n            let edits = [];\n            let endCursorState = [];\n            let endPrimaryCursor = primaryCursor;\n            let lineOffset = 0;\n            for (let i = 0, len = reducedSelections.length; i < len; i++) {\n                let selection = reducedSelections[i];\n                let startLineNumber = selection.startLineNumber;\n                let startColumn = 1;\n                let columnDeltaOffset = 0;\n                let endLineNumber, endColumn;\n                let selectionEndPositionOffset = model.getLineContent(selection.endLineNumber).length - selection.endColumn;\n                if (selection.isEmpty() || selection.startLineNumber === selection.endLineNumber) {\n                    let position = selection.getStartPosition();\n                    if (position.lineNumber < model.getLineCount()) {\n                        endLineNumber = startLineNumber + 1;\n                        endColumn = model.getLineMaxColumn(endLineNumber);\n                    }\n                    else {\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                }\n                else {\n                    endLineNumber = selection.endLineNumber;\n                    endColumn = model.getLineMaxColumn(endLineNumber);\n                }\n                let trimmedLinesContent = model.getLineContent(startLineNumber);\n                for (let i = startLineNumber + 1; i <= endLineNumber; i++) {\n                    let lineText = model.getLineContent(i);\n                    let firstNonWhitespaceIdx = model.getLineFirstNonWhitespaceColumn(i);\n                    if (firstNonWhitespaceIdx >= 1) {\n                        let insertSpace = true;\n                        if (trimmedLinesContent === '') {\n                            insertSpace = false;\n                        }\n                        if (insertSpace && (trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === ' ' ||\n                            trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === '\\t')) {\n                            insertSpace = false;\n                            trimmedLinesContent = trimmedLinesContent.replace(/[\\s\\uFEFF\\xA0]+$/g, ' ');\n                        }\n                        let lineTextWithoutIndent = lineText.substr(firstNonWhitespaceIdx - 1);\n                        trimmedLinesContent += (insertSpace ? ' ' : '') + lineTextWithoutIndent;\n                        if (insertSpace) {\n                            columnDeltaOffset = lineTextWithoutIndent.length + 1;\n                        }\n                        else {\n                            columnDeltaOffset = lineTextWithoutIndent.length;\n                        }\n                    }\n                    else {\n                        columnDeltaOffset = 0;\n                    }\n                }\n                let deleteSelection = new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);\n                if (!deleteSelection.isEmpty()) {\n                    let resultSelection;\n                    if (selection.isEmpty()) {\n                        edits.push(editOperation_1.EditOperation.replace(deleteSelection, trimmedLinesContent));\n                        resultSelection = new selection_1.Selection(deleteSelection.startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1, startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1);\n                    }\n                    else {\n                        if (selection.startLineNumber === selection.endLineNumber) {\n                            edits.push(editOperation_1.EditOperation.replace(deleteSelection, trimmedLinesContent));\n                            resultSelection = new selection_1.Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.endLineNumber - lineOffset, selection.endColumn);\n                        }\n                        else {\n                            edits.push(editOperation_1.EditOperation.replace(deleteSelection, trimmedLinesContent));\n                            resultSelection = new selection_1.Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.startLineNumber - lineOffset, trimmedLinesContent.length - selectionEndPositionOffset);\n                        }\n                    }\n                    if (range_1.Range.intersectRanges(deleteSelection, primaryCursor) !== null) {\n                        endPrimaryCursor = resultSelection;\n                    }\n                    else {\n                        endCursorState.push(resultSelection);\n                    }\n                }\n                lineOffset += deleteSelection.endLineNumber - deleteSelection.startLineNumber;\n            }\n            endCursorState.unshift(endPrimaryCursor);\n            editor.pushUndoStop();\n            editor.executeEdits(this.id, edits, endCursorState);\n            editor.pushUndoStop();\n        }\n    }\n    exports.JoinLinesAction = JoinLinesAction;\n    class TransposeAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.transpose',\n                label: nls.localize('editor.transpose', \"Transpose characters around the cursor\"),\n                alias: 'Transpose characters around the cursor',\n                precondition: editorContextKeys_1.EditorContextKeys.writable\n            });\n        }\n        run(_accessor, editor) {\n            let selections = editor.getSelections();\n            if (selections === null) {\n                return;\n            }\n            let model = editor.getModel();\n            if (model === null) {\n                return;\n            }\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                let selection = selections[i];\n                if (!selection.isEmpty()) {\n                    continue;\n                }\n                let cursor = selection.getStartPosition();\n                let maxColumn = model.getLineMaxColumn(cursor.lineNumber);\n                if (cursor.column >= maxColumn) {\n                    if (cursor.lineNumber === model.getLineCount()) {\n                        continue;\n                    }\n                    // The cursor is at the end of current line and current line is not empty\n                    // then we transpose the character before the cursor and the line break if there is any following line.\n                    let deleteSelection = new range_1.Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1);\n                    let chars = model.getValueInRange(deleteSelection).split('').reverse().join('');\n                    commands.push(new replaceCommand_1.ReplaceCommand(new selection_1.Selection(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1), chars));\n                }\n                else {\n                    let deleteSelection = new range_1.Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber, cursor.column + 1);\n                    let chars = model.getValueInRange(deleteSelection).split('').reverse().join('');\n                    commands.push(new replaceCommand_1.ReplaceCommandThatPreservesSelection(deleteSelection, chars, new selection_1.Selection(cursor.lineNumber, cursor.column + 1, cursor.lineNumber, cursor.column + 1)));\n                }\n            }\n            editor.pushUndoStop();\n            editor.executeCommands(this.id, commands);\n            editor.pushUndoStop();\n        }\n    }\n    exports.TransposeAction = TransposeAction;\n    class AbstractCaseAction extends editorExtensions_1.EditorAction {\n        run(_accessor, editor) {\n            let selections = editor.getSelections();\n            if (selections === null) {\n                return;\n            }\n            let model = editor.getModel();\n            if (model === null) {\n                return;\n            }\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                let selection = selections[i];\n                if (selection.isEmpty()) {\n                    let cursor = selection.getStartPosition();\n                    let word = model.getWordAtPosition(cursor);\n                    if (!word) {\n                        continue;\n                    }\n                    let wordRange = new range_1.Range(cursor.lineNumber, word.startColumn, cursor.lineNumber, word.endColumn);\n                    let text = model.getValueInRange(wordRange);\n                    commands.push(new replaceCommand_1.ReplaceCommandThatPreservesSelection(wordRange, this._modifyText(text), new selection_1.Selection(cursor.lineNumber, cursor.column, cursor.lineNumber, cursor.column)));\n                }\n                else {\n                    let text = model.getValueInRange(selection);\n                    commands.push(new replaceCommand_1.ReplaceCommandThatPreservesSelection(selection, this._modifyText(text), selection));\n                }\n            }\n            editor.pushUndoStop();\n            editor.executeCommands(this.id, commands);\n            editor.pushUndoStop();\n        }\n    }\n    exports.AbstractCaseAction = AbstractCaseAction;\n    class UpperCaseAction extends AbstractCaseAction {\n        constructor() {\n            super({\n                id: 'editor.action.transformToUppercase',\n                label: nls.localize('editor.transformToUppercase', \"Transform to Uppercase\"),\n                alias: 'Transform to Uppercase',\n                precondition: editorContextKeys_1.EditorContextKeys.writable\n            });\n        }\n        _modifyText(text) {\n            return text.toLocaleUpperCase();\n        }\n    }\n    exports.UpperCaseAction = UpperCaseAction;\n    class LowerCaseAction extends AbstractCaseAction {\n        constructor() {\n            super({\n                id: 'editor.action.transformToLowercase',\n                label: nls.localize('editor.transformToLowercase', \"Transform to Lowercase\"),\n                alias: 'Transform to Lowercase',\n                precondition: editorContextKeys_1.EditorContextKeys.writable\n            });\n        }\n        _modifyText(text) {\n            return text.toLocaleLowerCase();\n        }\n    }\n    exports.LowerCaseAction = LowerCaseAction;\n    editorExtensions_1.registerEditorAction(CopyLinesUpAction);\n    editorExtensions_1.registerEditorAction(CopyLinesDownAction);\n    editorExtensions_1.registerEditorAction(MoveLinesUpAction);\n    editorExtensions_1.registerEditorAction(MoveLinesDownAction);\n    editorExtensions_1.registerEditorAction(SortLinesAscendingAction);\n    editorExtensions_1.registerEditorAction(SortLinesDescendingAction);\n    editorExtensions_1.registerEditorAction(TrimTrailingWhitespaceAction);\n    editorExtensions_1.registerEditorAction(DeleteLinesAction);\n    editorExtensions_1.registerEditorAction(IndentLinesAction);\n    editorExtensions_1.registerEditorAction(OutdentLinesAction);\n    editorExtensions_1.registerEditorAction(InsertLineBeforeAction);\n    editorExtensions_1.registerEditorAction(InsertLineAfterAction);\n    editorExtensions_1.registerEditorAction(DeleteAllLeftAction);\n    editorExtensions_1.registerEditorAction(DeleteAllRightAction);\n    editorExtensions_1.registerEditorAction(JoinLinesAction);\n    editorExtensions_1.registerEditorAction(TransposeAction);\n    editorExtensions_1.registerEditorAction(UpperCaseAction);\n    editorExtensions_1.registerEditorAction(LowerCaseAction);\n});\n",null]}