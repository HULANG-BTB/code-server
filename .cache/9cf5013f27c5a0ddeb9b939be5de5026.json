{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/node/proxyResolver.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/node/proxyResolver.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"http\", \"https\", \"tls\", \"url\", \"os\", \"fs\", \"child_process\", \"vs/base/common/objects\", \"vs/base/common/strings\", \"vscode-proxy-agent\", \"vs/base/common/errorMessage\", \"vs/base/common/uri\", \"util\"], function (require, exports, http, https, tls, nodeurl, os, fs, cp, objects_1, strings_1, vscode_proxy_agent_1, errorMessage_1, uri_1, util_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function connectProxyResolver(extHostWorkspace, configProvider, extensionService, extHostLogService, mainThreadTelemetry) {\n        const resolveProxy = setupProxyResolution(extHostWorkspace, configProvider, extHostLogService, mainThreadTelemetry);\n        const lookup = createPatchedModules(configProvider, resolveProxy);\n        return configureModuleLoading(extensionService, lookup);\n    }\n    exports.connectProxyResolver = connectProxyResolver;\n    const maxCacheEntries = 5000; // Cache can grow twice that much due to 'oldCache'.\n    function setupProxyResolution(extHostWorkspace, configProvider, extHostLogService, mainThreadTelemetry) {\n        const env = process.env;\n        let settingsProxy = proxyFromConfigURL(configProvider.getConfiguration('http')\n            .get('proxy'));\n        configProvider.onDidChangeConfiguration(e => {\n            settingsProxy = proxyFromConfigURL(configProvider.getConfiguration('http')\n                .get('proxy'));\n        });\n        let envProxy = proxyFromConfigURL(env.https_proxy || env.HTTPS_PROXY || env.http_proxy || env.HTTP_PROXY); // Not standardized.\n        let envNoProxy = noProxyFromEnv(env.no_proxy || env.NO_PROXY); // Not standardized.\n        let cacheRolls = 0;\n        let oldCache = new Map();\n        let cache = new Map();\n        function getCacheKey(url) {\n            // Expecting proxies to usually be the same per scheme://host:port. Assuming that for performance.\n            return nodeurl.format(Object.assign({}, url, { pathname: undefined, search: undefined, hash: undefined }));\n        }\n        function getCachedProxy(key) {\n            let proxy = cache.get(key);\n            if (proxy) {\n                return proxy;\n            }\n            proxy = oldCache.get(key);\n            if (proxy) {\n                oldCache.delete(key);\n                cacheProxy(key, proxy);\n            }\n            return proxy;\n        }\n        function cacheProxy(key, proxy) {\n            cache.set(key, proxy);\n            if (cache.size >= maxCacheEntries) {\n                oldCache = cache;\n                cache = new Map();\n                cacheRolls++;\n                extHostLogService.trace('ProxyResolver#cacheProxy cacheRolls', cacheRolls);\n            }\n        }\n        let timeout;\n        let count = 0;\n        let duration = 0;\n        let errorCount = 0;\n        let cacheCount = 0;\n        let envCount = 0;\n        let settingsCount = 0;\n        let localhostCount = 0;\n        let envNoProxyCount = 0;\n        let results = [];\n        function logEvent() {\n            timeout = undefined;\n            /* __GDPR__\n                \"resolveProxy\" : {\n                    \"count\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                    \"duration\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                    \"errorCount\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                    \"cacheCount\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                    \"cacheSize\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                    \"cacheRolls\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                    \"envCount\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                    \"settingsCount\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                    \"localhostCount\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                    \"envNoProxyCount\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                    \"results\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" }\n                }\n            */\n            mainThreadTelemetry.$publicLog('resolveProxy', { count, duration, errorCount, cacheCount, cacheSize: cache.size, cacheRolls, envCount, settingsCount, localhostCount, envNoProxyCount, results });\n            count = duration = errorCount = cacheCount = envCount = settingsCount = localhostCount = envNoProxyCount = 0;\n            results = [];\n        }\n        function resolveProxy(flags, req, opts, url, callback) {\n            if (!timeout) {\n                timeout = setTimeout(logEvent, 10 * 60 * 1000);\n            }\n            useSystemCertificates(extHostLogService, flags.useSystemCertificates, opts, () => {\n                useProxySettings(flags.useProxySettings, req, opts, url, callback);\n            });\n        }\n        function useProxySettings(useProxySettings, req, opts, url, callback) {\n            if (!useProxySettings) {\n                callback('DIRECT');\n                return;\n            }\n            const parsedUrl = nodeurl.parse(url); // Coming from Node's URL, sticking with that.\n            const hostname = parsedUrl.hostname;\n            if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname === '::1' || hostname === '::ffff:127.0.0.1') {\n                localhostCount++;\n                callback('DIRECT');\n                extHostLogService.trace('ProxyResolver#resolveProxy localhost', url, 'DIRECT');\n                return;\n            }\n            if (typeof hostname === 'string' && envNoProxy(hostname, String(parsedUrl.port || opts.agent.defaultPort))) {\n                envNoProxyCount++;\n                callback('DIRECT');\n                extHostLogService.trace('ProxyResolver#resolveProxy envNoProxy', url, 'DIRECT');\n                return;\n            }\n            if (settingsProxy) {\n                settingsCount++;\n                callback(settingsProxy);\n                extHostLogService.trace('ProxyResolver#resolveProxy settings', url, settingsProxy);\n                return;\n            }\n            if (envProxy) {\n                envCount++;\n                callback(envProxy);\n                extHostLogService.trace('ProxyResolver#resolveProxy env', url, envProxy);\n                return;\n            }\n            const key = getCacheKey(parsedUrl);\n            const proxy = getCachedProxy(key);\n            if (proxy) {\n                cacheCount++;\n                collectResult(results, proxy, parsedUrl.protocol === 'https:' ? 'HTTPS' : 'HTTP', req);\n                callback(proxy);\n                extHostLogService.trace('ProxyResolver#resolveProxy cached', url, proxy);\n                return;\n            }\n            const start = Date.now();\n            extHostWorkspace.resolveProxy(url) // Use full URL to ensure it is an actually used one.\n                .then(proxy => {\n                if (proxy) {\n                    cacheProxy(key, proxy);\n                    collectResult(results, proxy, parsedUrl.protocol === 'https:' ? 'HTTPS' : 'HTTP', req);\n                }\n                callback(proxy);\n                extHostLogService.debug('ProxyResolver#resolveProxy', url, proxy);\n            }).then(() => {\n                count++;\n                duration = Date.now() - start + duration;\n            }, err => {\n                errorCount++;\n                callback();\n                extHostLogService.error('ProxyResolver#resolveProxy', errorMessage_1.toErrorMessage(err));\n            });\n        }\n        return resolveProxy;\n    }\n    function collectResult(results, resolveProxy, connection, req) {\n        const proxy = resolveProxy ? String(resolveProxy).trim().split(/\\s+/, 1)[0] : 'EMPTY';\n        req.on('response', res => {\n            const code = `HTTP_${res.statusCode}`;\n            const result = findOrCreateResult(results, proxy, connection, code);\n            result.count++;\n        });\n        req.on('error', err => {\n            const code = err && typeof err.code === 'string' && err.code || 'UNKNOWN_ERROR';\n            const result = findOrCreateResult(results, proxy, connection, code);\n            result.count++;\n        });\n    }\n    function findOrCreateResult(results, proxy, connection, code) {\n        for (const result of results) {\n            if (result.proxy === proxy && result.connection === connection && result.code === code) {\n                return result;\n            }\n        }\n        const result = { proxy, connection, code, count: 0 };\n        results.push(result);\n        return result;\n    }\n    function proxyFromConfigURL(configURL) {\n        const url = (configURL || '').trim();\n        const i = url.indexOf('://');\n        if (i === -1) {\n            return undefined;\n        }\n        const scheme = url.substr(0, i).toLowerCase();\n        const proxy = url.substr(i + 3);\n        if (scheme === 'http') {\n            return 'PROXY ' + proxy;\n        }\n        else if (scheme === 'https') {\n            return 'HTTPS ' + proxy;\n        }\n        else if (scheme === 'socks') {\n            return 'SOCKS ' + proxy;\n        }\n        return undefined;\n    }\n    function noProxyFromEnv(envValue) {\n        const value = (envValue || '')\n            .trim()\n            .toLowerCase();\n        if (value === '*') {\n            return () => true;\n        }\n        const filters = value\n            .split(',')\n            .map(s => s.trim().split(':', 2))\n            .map(([name, port]) => ({ name, port }))\n            .filter(filter => !!filter.name)\n            .map(({ name, port }) => {\n            const domain = name[0] === '.' ? name : `.${name}`;\n            return { domain, port };\n        });\n        if (!filters.length) {\n            return () => false;\n        }\n        return (hostname, port) => filters.some(({ domain, port: filterPort }) => {\n            return strings_1.endsWith(`.${hostname.toLowerCase()}`, domain) && (!filterPort || port === filterPort);\n        });\n    }\n    function createPatchedModules(configProvider, resolveProxy) {\n        const proxySetting = {\n            config: configProvider.getConfiguration('http')\n                .get('proxySupport') || 'off'\n        };\n        configProvider.onDidChangeConfiguration(e => {\n            proxySetting.config = configProvider.getConfiguration('http')\n                .get('proxySupport') || 'off';\n        });\n        const certSetting = {\n            config: !!configProvider.getConfiguration('http')\n                .get('systemCertificates')\n        };\n        configProvider.onDidChangeConfiguration(e => {\n            certSetting.config = !!configProvider.getConfiguration('http')\n                .get('systemCertificates');\n        });\n        return {\n            http: {\n                off: objects_1.assign({}, http, patches(http, resolveProxy, { config: 'off' }, certSetting, true)),\n                on: objects_1.assign({}, http, patches(http, resolveProxy, { config: 'on' }, certSetting, true)),\n                override: objects_1.assign({}, http, patches(http, resolveProxy, { config: 'override' }, certSetting, true)),\n                onRequest: objects_1.assign({}, http, patches(http, resolveProxy, proxySetting, certSetting, true)),\n                default: objects_1.assign(http, patches(http, resolveProxy, proxySetting, certSetting, false)) // run last\n            },\n            https: {\n                off: objects_1.assign({}, https, patches(https, resolveProxy, { config: 'off' }, certSetting, true)),\n                on: objects_1.assign({}, https, patches(https, resolveProxy, { config: 'on' }, certSetting, true)),\n                override: objects_1.assign({}, https, patches(https, resolveProxy, { config: 'override' }, certSetting, true)),\n                onRequest: objects_1.assign({}, https, patches(https, resolveProxy, proxySetting, certSetting, true)),\n                default: objects_1.assign(https, patches(https, resolveProxy, proxySetting, certSetting, false)) // run last\n            },\n            tls: objects_1.assign(tls, tlsPatches(tls))\n        };\n    }\n    function patches(originals, resolveProxy, proxySetting, certSetting, onRequest) {\n        return {\n            get: patch(originals.get),\n            request: patch(originals.request)\n        };\n        function patch(original) {\n            function patched(url, options, callback) {\n                if (typeof url !== 'string' && !(url && url.searchParams)) {\n                    callback = options;\n                    options = url;\n                    url = null;\n                }\n                if (typeof options === 'function') {\n                    callback = options;\n                    options = null;\n                }\n                options = options || {};\n                if (options.socketPath) {\n                    return original.apply(null, arguments);\n                }\n                const optionsPatched = options.agent instanceof vscode_proxy_agent_1.ProxyAgent;\n                const config = onRequest && (options._vscodeProxySupport || /* LS */ options._vscodeSystemProxy) || proxySetting.config;\n                const useProxySettings = !optionsPatched && (config === 'override' || config === 'on' && !options.agent);\n                const useSystemCertificates = !optionsPatched && certSetting.config && originals === https && !options.ca;\n                if (useProxySettings || useSystemCertificates) {\n                    if (url) {\n                        const parsed = typeof url === 'string' ? new nodeurl.URL(url) : url;\n                        const urlOptions = {\n                            protocol: parsed.protocol,\n                            hostname: parsed.hostname.lastIndexOf('[', 0) === 0 ? parsed.hostname.slice(1, -1) : parsed.hostname,\n                            port: parsed.port,\n                            path: `${parsed.pathname}${parsed.search}`\n                        };\n                        if (parsed.username || parsed.password) {\n                            options.auth = `${parsed.username}:${parsed.password}`;\n                        }\n                        options = Object.assign({}, urlOptions, options);\n                    }\n                    else {\n                        options = Object.assign({}, options);\n                    }\n                    options.agent = new vscode_proxy_agent_1.ProxyAgent({\n                        resolveProxy: resolveProxy.bind(undefined, { useProxySettings, useSystemCertificates }),\n                        defaultPort: originals === https ? 443 : 80,\n                        originalAgent: options.agent\n                    });\n                    return original(options, callback);\n                }\n                return original.apply(null, arguments);\n            }\n            return patched;\n        }\n    }\n    function tlsPatches(originals) {\n        return {\n            createSecureContext: patch(originals.createSecureContext)\n        };\n        function patch(original) {\n            return function (details) {\n                const context = original.apply(null, arguments);\n                const certs = details._vscodeAdditionalCaCerts;\n                if (certs) {\n                    for (const cert of certs) {\n                        context.context.addCACert(cert);\n                    }\n                }\n                return context;\n            };\n        }\n    }\n    function configureModuleLoading(extensionService, lookup) {\n        return extensionService.getExtensionPathIndex()\n            .then(extensionPaths => {\n            const node_module = require.__$__nodeRequire('module');\n            const original = node_module._load;\n            node_module._load = function load(request, parent, isMain) {\n                if (request === 'tls') {\n                    return lookup.tls;\n                }\n                if (request !== 'http' && request !== 'https') {\n                    return original.apply(this, arguments);\n                }\n                const modules = lookup[request];\n                const ext = extensionPaths.findSubstr(uri_1.URI.file(parent.filename).fsPath);\n                if (ext && ext.enableProposedApi) {\n                    return modules[ext.proxySupport] || modules.onRequest;\n                }\n                return modules.default;\n            };\n        });\n    }\n    function useSystemCertificates(extHostLogService, useSystemCertificates, opts, callback) {\n        if (useSystemCertificates) {\n            getCaCertificates(extHostLogService)\n                .then(caCertificates => {\n                if (caCertificates) {\n                    if (caCertificates.append) {\n                        opts._vscodeAdditionalCaCerts = caCertificates.certs;\n                    }\n                    else {\n                        opts.ca = caCertificates.certs;\n                    }\n                }\n                callback();\n            })\n                .catch(err => {\n                extHostLogService.error('ProxyResolver#useSystemCertificates', errorMessage_1.toErrorMessage(err));\n            });\n        }\n        else {\n            callback();\n        }\n    }\n    let _caCertificates;\n    function getCaCertificates(extHostLogService) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!_caCertificates) {\n                _caCertificates = readCaCertificates()\n                    .then(res => res && res.certs.length ? res : undefined)\n                    .catch(err => {\n                    extHostLogService.error('ProxyResolver#getCertificates', errorMessage_1.toErrorMessage(err));\n                    return undefined;\n                });\n            }\n            return _caCertificates;\n        });\n    }\n    function readCaCertificates() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (process.platform === 'win32') {\n                return readWindowsCaCertificates();\n            }\n            if (process.platform === 'darwin') {\n                return readMacCaCertificates();\n            }\n            if (process.platform === 'linux') {\n                return readLinuxCaCertificates();\n            }\n            return undefined;\n        });\n    }\n    function readWindowsCaCertificates() {\n        const winCA = require.__$__nodeRequire('vscode-windows-ca-certs');\n        let ders = [];\n        const store = winCA();\n        try {\n            let der;\n            while (der = store.next()) {\n                ders.push(der);\n            }\n        }\n        finally {\n            store.done();\n        }\n        const seen = {};\n        const certs = ders.map(derToPem)\n            .filter(pem => !seen[pem] && (seen[pem] = true));\n        return {\n            certs,\n            append: true\n        };\n    }\n    function readMacCaCertificates() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const stdout = (yield util_1.promisify(cp.execFile)('/usr/bin/security', ['find-certificate', '-a', '-p'], { encoding: 'utf8' })).stdout;\n            const seen = {};\n            const certs = stdout.split(/(?=-----BEGIN CERTIFICATE-----)/g)\n                .filter(pem => !!pem.length && !seen[pem] && (seen[pem] = true));\n            return {\n                certs,\n                append: true\n            };\n        });\n    }\n    const linuxCaCertificatePaths = [\n        '/etc/ssl/certs/ca-certificates.crt',\n        '/etc/ssl/certs/ca-bundle.crt',\n    ];\n    function readLinuxCaCertificates() {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const certPath of linuxCaCertificatePaths) {\n                try {\n                    const content = yield util_1.promisify(fs.readFile)(certPath, { encoding: 'utf8' });\n                    const seen = {};\n                    const certs = content.split(/(?=-----BEGIN CERTIFICATE-----)/g)\n                        .filter(pem => !!pem.length && !seen[pem] && (seen[pem] = true));\n                    return {\n                        certs,\n                        append: false\n                    };\n                }\n                catch (err) {\n                    if (err.code !== 'ENOENT') {\n                        throw err;\n                    }\n                }\n            }\n            return undefined;\n        });\n    }\n    function derToPem(blob) {\n        const lines = ['-----BEGIN CERTIFICATE-----'];\n        const der = blob.toString('base64');\n        for (let i = 0; i < der.length; i += 64) {\n            lines.push(der.substr(i, 64));\n        }\n        lines.push('-----END CERTIFICATE-----', '');\n        return lines.join(os.EOL);\n    }\n});\n",null]}