{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/node/stream.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/stream.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar fs = require(\"fs\");\n/**\n * Reads totalBytes from the provided file.\n */\nfunction readExactlyByFile(file, totalBytes) {\n    return new Promise(function (resolve, reject) {\n        fs.open(file, 'r', null, function (err, fd) {\n            if (err) {\n                return reject(err);\n            }\n            function end(err, resultBuffer, bytesRead) {\n                fs.close(fd, function (closeError) {\n                    if (closeError) {\n                        return reject(closeError);\n                    }\n                    if (err && err.code === 'EISDIR') {\n                        return reject(err); // we want to bubble this error up (file is actually a folder)\n                    }\n                    return resolve({ buffer: resultBuffer, bytesRead: bytesRead });\n                });\n            }\n            var buffer = Buffer.allocUnsafe(totalBytes);\n            var offset = 0;\n            function readChunk() {\n                fs.read(fd, buffer, offset, totalBytes - offset, null, function (err, bytesRead) {\n                    if (err) {\n                        return end(err, null, 0);\n                    }\n                    if (bytesRead === 0) {\n                        return end(null, buffer, offset);\n                    }\n                    offset += bytesRead;\n                    if (offset === totalBytes) {\n                        return end(null, buffer, offset);\n                    }\n                    return readChunk();\n                });\n            }\n            readChunk();\n        });\n    });\n}\nexports.readExactlyByFile = readExactlyByFile;\n/**\n * Reads a file until a matching string is found.\n *\n * @param file The file to read.\n * @param matchingString The string to search for.\n * @param chunkBytes The number of bytes to read each iteration.\n * @param maximumBytesToRead The maximum number of bytes to read before giving up.\n * @param callback The finished callback.\n */\nfunction readToMatchingString(file, matchingString, chunkBytes, maximumBytesToRead) {\n    return new Promise(function (resolve, reject) {\n        return fs.open(file, 'r', null, function (err, fd) {\n            if (err) {\n                return reject(err);\n            }\n            function end(err, result) {\n                fs.close(fd, function (closeError) {\n                    if (closeError) {\n                        return reject(closeError);\n                    }\n                    if (err && err.code === 'EISDIR') {\n                        return reject(err); // we want to bubble this error up (file is actually a folder)\n                    }\n                    return resolve(result);\n                });\n            }\n            var buffer = Buffer.allocUnsafe(maximumBytesToRead);\n            var offset = 0;\n            function readChunk() {\n                fs.read(fd, buffer, offset, chunkBytes, null, function (err, bytesRead) {\n                    if (err) {\n                        return end(err, null);\n                    }\n                    if (bytesRead === 0) {\n                        return end(null, null);\n                    }\n                    offset += bytesRead;\n                    var newLineIndex = buffer.indexOf(matchingString);\n                    if (newLineIndex >= 0) {\n                        return end(null, buffer.toString('utf8').substr(0, newLineIndex));\n                    }\n                    if (offset >= maximumBytesToRead) {\n                        return end(new Error(\"Could not find \" + matchingString + \" in first \" + maximumBytesToRead + \" bytes of \" + file), null);\n                    }\n                    return readChunk();\n                });\n            }\n            readChunk();\n        });\n    });\n}\nexports.readToMatchingString = readToMatchingString;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/node/stream.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/node/stream.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\n\nexport interface ReadResult {\n\tbuffer: Buffer | null;\n\tbytesRead: number;\n}\n\n/**\n * Reads totalBytes from the provided file.\n */\nexport function readExactlyByFile(file: string, totalBytes: number): Promise<ReadResult> {\n\treturn new Promise<ReadResult>((resolve, reject) => {\n\t\tfs.open(file, 'r', null, (err, fd) => {\n\t\t\tif (err) {\n\t\t\t\treturn reject(err);\n\t\t\t}\n\n\t\t\tfunction end(err: Error | null, resultBuffer: Buffer | null, bytesRead: number): void {\n\t\t\t\tfs.close(fd, closeError => {\n\t\t\t\t\tif (closeError) {\n\t\t\t\t\t\treturn reject(closeError);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (err && (<any>err).code === 'EISDIR') {\n\t\t\t\t\t\treturn reject(err); // we want to bubble this error up (file is actually a folder)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ buffer: resultBuffer, bytesRead });\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst buffer = Buffer.allocUnsafe(totalBytes);\n\t\t\tlet offset = 0;\n\n\t\t\tfunction readChunk(): void {\n\t\t\t\tfs.read(fd, buffer, offset, totalBytes - offset, null, (err, bytesRead) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn end(err, null, 0);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bytesRead === 0) {\n\t\t\t\t\t\treturn end(null, buffer, offset);\n\t\t\t\t\t}\n\n\t\t\t\t\toffset += bytesRead;\n\n\t\t\t\t\tif (offset === totalBytes) {\n\t\t\t\t\t\treturn end(null, buffer, offset);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn readChunk();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treadChunk();\n\t\t});\n\t});\n}\n\n/**\n * Reads a file until a matching string is found.\n *\n * @param file The file to read.\n * @param matchingString The string to search for.\n * @param chunkBytes The number of bytes to read each iteration.\n * @param maximumBytesToRead The maximum number of bytes to read before giving up.\n * @param callback The finished callback.\n */\nexport function readToMatchingString(file: string, matchingString: string, chunkBytes: number, maximumBytesToRead: number): Promise<string | null> {\n\treturn new Promise<string | null>((resolve, reject) =>\n\t\tfs.open(file, 'r', null, (err, fd) => {\n\t\t\tif (err) {\n\t\t\t\treturn reject(err);\n\t\t\t}\n\n\t\t\tfunction end(err: Error | null, result: string | null): void {\n\t\t\t\tfs.close(fd, closeError => {\n\t\t\t\t\tif (closeError) {\n\t\t\t\t\t\treturn reject(closeError);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (err && (<any>err).code === 'EISDIR') {\n\t\t\t\t\t\treturn reject(err); // we want to bubble this error up (file is actually a folder)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve(result);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst buffer = Buffer.allocUnsafe(maximumBytesToRead);\n\t\t\tlet offset = 0;\n\n\t\t\tfunction readChunk(): void {\n\t\t\t\tfs.read(fd, buffer, offset, chunkBytes, null, (err, bytesRead) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn end(err, null);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bytesRead === 0) {\n\t\t\t\t\t\treturn end(null, null);\n\t\t\t\t\t}\n\n\t\t\t\t\toffset += bytesRead;\n\n\t\t\t\t\tconst newLineIndex = buffer.indexOf(matchingString);\n\t\t\t\t\tif (newLineIndex >= 0) {\n\t\t\t\t\t\treturn end(null, buffer.toString('utf8').substr(0, newLineIndex));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (offset >= maximumBytesToRead) {\n\t\t\t\t\t\treturn end(new Error(`Could not find ${matchingString} in first ${maximumBytesToRead} bytes of ${file}`), null);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn readChunk();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treadChunk();\n\t\t})\n\t);\n}"]}]}