{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/suggest/suggestController.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/suggest/suggestController.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/browser/ui/aria/aria\", \"vs/base/common/arrays\", \"vs/base/common/errors\", \"vs/base/common/keyCodes\", \"vs/base/common/lifecycle\", \"vs/editor/browser/editorExtensions\", \"vs/editor/common/core/editOperation\", \"vs/editor/common/core/range\", \"vs/editor/common/editorCommon\", \"vs/editor/common/editorContextKeys\", \"vs/editor/common/modes\", \"vs/editor/contrib/snippet/snippetController2\", \"vs/editor/contrib/snippet/snippetParser\", \"vs/editor/contrib/suggest/suggestMemory\", \"vs/nls\", \"vs/platform/commands/common/commands\", \"vs/platform/contextkey/common/contextkey\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/keybinding/common/keybindingsRegistry\", \"./suggest\", \"./suggestAlternatives\", \"./suggestModel\", \"./suggestWidget\", \"vs/editor/contrib/suggest/wordContextKey\", \"vs/base/common/event\", \"vs/editor/common/services/editorWorkerService\", \"vs/base/common/async\", \"vs/editor/common/core/characterClassifier\", \"vs/base/common/types\"], function (require, exports, aria_1, arrays_1, errors_1, keyCodes_1, lifecycle_1, editorExtensions_1, editOperation_1, range_1, editorCommon_1, editorContextKeys_1, modes_1, snippetController2_1, snippetParser_1, suggestMemory_1, nls, commands_1, contextkey_1, instantiation_1, keybindingsRegistry_1, suggest_1, suggestAlternatives_1, suggestModel_1, suggestWidget_1, wordContextKey_1, event_1, editorWorkerService_1, async_1, characterClassifier_1, types_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class AcceptOnCharacterOracle {\n        constructor(editor, widget, accept) {\n            this._disposables = [];\n            this._disposables.push(widget.onDidShow(() => this._onItem(widget.getFocusedItem())));\n            this._disposables.push(widget.onDidFocus(this._onItem, this));\n            this._disposables.push(widget.onDidHide(this.reset, this));\n            this._disposables.push(editor.onWillType(text => {\n                if (this._active) {\n                    const ch = text.charCodeAt(text.length - 1);\n                    if (this._active.acceptCharacters.has(ch) && editor.getConfiguration().contribInfo.acceptSuggestionOnCommitCharacter) {\n                        accept(this._active.item);\n                    }\n                }\n            }));\n        }\n        _onItem(selected) {\n            if (!selected || !arrays_1.isNonEmptyArray(selected.item.completion.commitCharacters)) {\n                this.reset();\n                return;\n            }\n            const acceptCharacters = new characterClassifier_1.CharacterSet();\n            for (const ch of selected.item.completion.commitCharacters) {\n                if (ch.length > 0) {\n                    acceptCharacters.add(ch.charCodeAt(0));\n                }\n            }\n            this._active = { acceptCharacters, item: selected };\n        }\n        reset() {\n            this._active = undefined;\n        }\n        dispose() {\n            lifecycle_1.dispose(this._disposables);\n        }\n    }\n    let SuggestController = class SuggestController {\n        constructor(_editor, editorWorker, _memoryService, _commandService, _contextKeyService, _instantiationService) {\n            this._editor = _editor;\n            this._memoryService = _memoryService;\n            this._commandService = _commandService;\n            this._contextKeyService = _contextKeyService;\n            this._instantiationService = _instantiationService;\n            this._toDispose = [];\n            this._sticky = false; // for development purposes only\n            this._model = new suggestModel_1.SuggestModel(this._editor, editorWorker);\n            this._widget = new async_1.IdleValue(() => {\n                const widget = this._instantiationService.createInstance(suggestWidget_1.SuggestWidget, this._editor);\n                this._toDispose.push(widget);\n                this._toDispose.push(widget.onDidSelect(item => this._onDidSelectItem(item, false, true), this));\n                // Wire up logic to accept a suggestion on certain characters\n                const autoAcceptOracle = new AcceptOnCharacterOracle(this._editor, widget, item => this._onDidSelectItem(item, false, true));\n                this._toDispose.push(autoAcceptOracle, this._model.onDidSuggest(e => {\n                    if (e.completionModel.items.length === 0) {\n                        autoAcceptOracle.reset();\n                    }\n                }));\n                // Wire up makes text edit context key\n                let makesTextEdit = suggest_1.Context.MakesTextEdit.bindTo(this._contextKeyService);\n                this._toDispose.push(widget.onDidFocus(({ item }) => {\n                    const position = this._editor.getPosition();\n                    const startColumn = item.completion.range.startColumn;\n                    const endColumn = position.column;\n                    let value = true;\n                    if (this._editor.getConfiguration().contribInfo.acceptSuggestionOnEnter === 'smart'\n                        && this._model.state === suggestModel_1.State.Auto\n                        && !item.completion.command\n                        && !item.completion.additionalTextEdits\n                        && !(item.completion.insertTextRules & modes_1.CompletionItemInsertTextRule.InsertAsSnippet)\n                        && endColumn - startColumn === item.completion.insertText.length) {\n                        const oldText = this._editor.getModel().getValueInRange({\n                            startLineNumber: position.lineNumber,\n                            startColumn,\n                            endLineNumber: position.lineNumber,\n                            endColumn\n                        });\n                        value = oldText !== item.completion.insertText;\n                    }\n                    makesTextEdit.set(value);\n                }));\n                this._toDispose.push({\n                    dispose() { makesTextEdit.reset(); }\n                });\n                return widget;\n            });\n            this._alternatives = new async_1.IdleValue(() => {\n                let res = new suggestAlternatives_1.SuggestAlternatives(this._editor, this._contextKeyService);\n                this._toDispose.push(res);\n                return res;\n            });\n            this._toDispose.push(_instantiationService.createInstance(wordContextKey_1.WordContextKey, _editor));\n            this._toDispose.push(this._model.onDidTrigger(e => {\n                this._widget.getValue().showTriggered(e.auto, e.shy ? 250 : 50);\n            }));\n            this._toDispose.push(this._model.onDidSuggest(e => {\n                if (!e.shy) {\n                    let index = this._memoryService.select(this._editor.getModel(), this._editor.getPosition(), e.completionModel.items);\n                    this._widget.getValue().showSuggestions(e.completionModel, index, e.isFrozen, e.auto);\n                }\n            }));\n            this._toDispose.push(this._model.onDidCancel(e => {\n                if (this._widget && !e.retrigger) {\n                    this._widget.getValue().hideWidget();\n                }\n            }));\n            this._toDispose.push(this._editor.onDidBlurEditorWidget(() => {\n                if (!this._sticky) {\n                    this._model.cancel();\n                }\n            }));\n            // Manage the acceptSuggestionsOnEnter context key\n            let acceptSuggestionsOnEnter = suggest_1.Context.AcceptSuggestionsOnEnter.bindTo(_contextKeyService);\n            let updateFromConfig = () => {\n                const { acceptSuggestionOnEnter } = this._editor.getConfiguration().contribInfo;\n                acceptSuggestionsOnEnter.set(acceptSuggestionOnEnter === 'on' || acceptSuggestionOnEnter === 'smart');\n            };\n            this._toDispose.push(this._editor.onDidChangeConfiguration((e) => updateFromConfig()));\n            updateFromConfig();\n        }\n        static get(editor) {\n            return editor.getContribution(SuggestController.ID);\n        }\n        getId() {\n            return SuggestController.ID;\n        }\n        dispose() {\n            this._toDispose = lifecycle_1.dispose(this._toDispose);\n            this._widget.dispose();\n            if (this._model) {\n                this._model.dispose();\n            }\n        }\n        _onDidSelectItem(event, keepAlternativeSuggestions, undoStops) {\n            if (!event || !event.item) {\n                this._alternatives.getValue().reset();\n                this._model.cancel();\n                return;\n            }\n            if (!this._editor.hasModel()) {\n                return;\n            }\n            const model = this._editor.getModel();\n            const modelVersionNow = model.getAlternativeVersionId();\n            const { completion: suggestion, position } = event.item;\n            const editorColumn = this._editor.getPosition().column;\n            const columnDelta = editorColumn - position.column;\n            // pushing undo stops *before* additional text edits and\n            // *after* the main edit\n            if (undoStops) {\n                this._editor.pushUndoStop();\n            }\n            if (Array.isArray(suggestion.additionalTextEdits)) {\n                this._editor.executeEdits('suggestController.additionalTextEdits', suggestion.additionalTextEdits.map(edit => editOperation_1.EditOperation.replace(range_1.Range.lift(edit.range), edit.text)));\n            }\n            // keep item in memory\n            this._memoryService.memorize(model, this._editor.getPosition(), event.item);\n            let { insertText } = suggestion;\n            if (!(suggestion.insertTextRules & modes_1.CompletionItemInsertTextRule.InsertAsSnippet)) {\n                insertText = snippetParser_1.SnippetParser.escape(insertText);\n            }\n            const overwriteBefore = position.column - suggestion.range.startColumn;\n            const overwriteAfter = suggestion.range.endColumn - position.column;\n            snippetController2_1.SnippetController2.get(this._editor).insert(insertText, overwriteBefore + columnDelta, overwriteAfter, false, false, !(suggestion.insertTextRules & modes_1.CompletionItemInsertTextRule.KeepWhitespace));\n            if (undoStops) {\n                this._editor.pushUndoStop();\n            }\n            if (!suggestion.command) {\n                // done\n                this._model.cancel();\n            }\n            else if (suggestion.command.id === TriggerSuggestAction.id) {\n                // retigger\n                this._model.trigger({ auto: true, shy: false }, true);\n            }\n            else {\n                // exec command, done\n                this._commandService.executeCommand(suggestion.command.id, ...(suggestion.command.arguments ? [...suggestion.command.arguments] : [])).catch(errors_1.onUnexpectedError);\n                this._model.cancel();\n            }\n            if (keepAlternativeSuggestions) {\n                this._alternatives.getValue().set(event, next => {\n                    // this is not so pretty. when inserting the 'next'\n                    // suggestion we undo until we are at the state at\n                    // which we were before inserting the previous suggestion...\n                    while (model.canUndo()) {\n                        if (modelVersionNow !== model.getAlternativeVersionId()) {\n                            model.undo();\n                        }\n                        this._onDidSelectItem(next, false, false);\n                        break;\n                    }\n                });\n            }\n            this._alertCompletionItem(event.item);\n        }\n        _alertCompletionItem({ completion: suggestion }) {\n            if (arrays_1.isNonEmptyArray(suggestion.additionalTextEdits)) {\n                let msg = nls.localize('arai.alert.snippet', \"Accepting '{0}' made {1} additional edits\", suggestion.label, suggestion.additionalTextEdits.length);\n                aria_1.alert(msg);\n            }\n        }\n        triggerSuggest(onlyFrom) {\n            if (this._editor.hasModel()) {\n                this._model.trigger({ auto: false, shy: false }, false, onlyFrom);\n                this._editor.revealLine(this._editor.getPosition().lineNumber, editorCommon_1.ScrollType.Smooth);\n                this._editor.focus();\n            }\n        }\n        triggerSuggestAndAcceptBest(arg) {\n            if (!this._editor.hasModel()) {\n                return;\n            }\n            const positionNow = this._editor.getPosition();\n            const fallback = () => {\n                if (positionNow.equals(this._editor.getPosition())) {\n                    this._commandService.executeCommand(arg.fallback);\n                }\n            };\n            const makesTextEdit = (item) => {\n                if (item.completion.insertTextRules & modes_1.CompletionItemInsertTextRule.InsertAsSnippet || item.completion.additionalTextEdits) {\n                    // snippet, other editor -> makes edit\n                    return true;\n                }\n                const position = this._editor.getPosition();\n                const startColumn = item.completion.range.startColumn;\n                const endColumn = position.column;\n                if (endColumn - startColumn !== item.completion.insertText.length) {\n                    // unequal lengths -> makes edit\n                    return true;\n                }\n                const textNow = this._editor.getModel().getValueInRange({\n                    startLineNumber: position.lineNumber,\n                    startColumn,\n                    endLineNumber: position.lineNumber,\n                    endColumn\n                });\n                // unequal text -> makes edit\n                return textNow !== item.completion.insertText;\n            };\n            event_1.Event.once(this._model.onDidTrigger)(_ => {\n                // wait for trigger because only then the cancel-event is trustworthy\n                let listener = [];\n                event_1.Event.any(this._model.onDidTrigger, this._model.onDidCancel)(() => {\n                    // retrigger or cancel -> try to type default text\n                    lifecycle_1.dispose(listener);\n                    fallback();\n                }, undefined, listener);\n                this._model.onDidSuggest(({ completionModel }) => {\n                    lifecycle_1.dispose(listener);\n                    if (completionModel.items.length === 0) {\n                        fallback();\n                        return;\n                    }\n                    const index = this._memoryService.select(this._editor.getModel(), this._editor.getPosition(), completionModel.items);\n                    const item = completionModel.items[index];\n                    if (!makesTextEdit(item)) {\n                        fallback();\n                        return;\n                    }\n                    this._editor.pushUndoStop();\n                    this._onDidSelectItem({ index, item, model: completionModel }, true, false);\n                }, undefined, listener);\n            });\n            this._model.trigger({ auto: false, shy: true });\n            this._editor.revealLine(positionNow.lineNumber, editorCommon_1.ScrollType.Smooth);\n            this._editor.focus();\n        }\n        acceptSelectedSuggestion(keepAlternativeSuggestions) {\n            if (this._widget) {\n                const item = this._widget.getValue().getFocusedItem();\n                this._onDidSelectItem(item, !!keepAlternativeSuggestions, true);\n            }\n        }\n        acceptNextSuggestion() {\n            this._alternatives.getValue().next();\n        }\n        acceptPrevSuggestion() {\n            this._alternatives.getValue().prev();\n        }\n        cancelSuggestWidget() {\n            if (this._widget) {\n                this._model.cancel();\n                this._widget.getValue().hideWidget();\n            }\n        }\n        selectNextSuggestion() {\n            if (this._widget) {\n                this._widget.getValue().selectNext();\n            }\n        }\n        selectNextPageSuggestion() {\n            if (this._widget) {\n                this._widget.getValue().selectNextPage();\n            }\n        }\n        selectLastSuggestion() {\n            if (this._widget) {\n                this._widget.getValue().selectLast();\n            }\n        }\n        selectPrevSuggestion() {\n            if (this._widget) {\n                this._widget.getValue().selectPrevious();\n            }\n        }\n        selectPrevPageSuggestion() {\n            if (this._widget) {\n                this._widget.getValue().selectPreviousPage();\n            }\n        }\n        selectFirstSuggestion() {\n            if (this._widget) {\n                this._widget.getValue().selectFirst();\n            }\n        }\n        toggleSuggestionDetails() {\n            if (this._widget) {\n                this._widget.getValue().toggleDetails();\n            }\n        }\n        toggleSuggestionFocus() {\n            if (this._widget) {\n                this._widget.getValue().toggleDetailsFocus();\n            }\n        }\n    };\n    SuggestController.ID = 'editor.contrib.suggestController';\n    SuggestController = __decorate([\n        __param(1, editorWorkerService_1.IEditorWorkerService),\n        __param(2, suggestMemory_1.ISuggestMemoryService),\n        __param(3, commands_1.ICommandService),\n        __param(4, contextkey_1.IContextKeyService),\n        __param(5, instantiation_1.IInstantiationService)\n    ], SuggestController);\n    exports.SuggestController = SuggestController;\n    class TriggerSuggestAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: TriggerSuggestAction.id,\n                label: nls.localize('suggest.trigger.label', \"Trigger Suggest\"),\n                alias: 'Trigger Suggest',\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, editorContextKeys_1.EditorContextKeys.hasCompletionItemProvider),\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.textInputFocus,\n                    primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.Space,\n                    mac: { primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.Space },\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        run(accessor, editor) {\n            const controller = SuggestController.get(editor);\n            if (!controller) {\n                return;\n            }\n            controller.triggerSuggest();\n        }\n    }\n    TriggerSuggestAction.id = 'editor.action.triggerSuggest';\n    exports.TriggerSuggestAction = TriggerSuggestAction;\n    editorExtensions_1.registerEditorContribution(SuggestController);\n    editorExtensions_1.registerEditorAction(TriggerSuggestAction);\n    const weight = keybindingsRegistry_1.KeybindingWeight.EditorContrib + 90;\n    const SuggestCommand = editorExtensions_1.EditorCommand.bindToContribution(SuggestController.get);\n    editorExtensions_1.registerEditorCommand(new SuggestCommand({\n        id: 'acceptSelectedSuggestion',\n        precondition: suggest_1.Context.Visible,\n        handler: x => x.acceptSelectedSuggestion(true),\n        kbOpts: {\n            weight: weight,\n            kbExpr: editorContextKeys_1.EditorContextKeys.textInputFocus,\n            primary: keyCodes_1.KeyCode.Tab\n        }\n    }));\n    editorExtensions_1.registerEditorCommand(new SuggestCommand({\n        id: 'acceptSelectedSuggestionOnEnter',\n        precondition: suggest_1.Context.Visible,\n        handler: x => x.acceptSelectedSuggestion(false),\n        kbOpts: {\n            weight: weight,\n            kbExpr: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.textInputFocus, suggest_1.Context.AcceptSuggestionsOnEnter, suggest_1.Context.MakesTextEdit),\n            primary: keyCodes_1.KeyCode.Enter\n        }\n    }));\n    editorExtensions_1.registerEditorCommand(new SuggestCommand({\n        id: 'hideSuggestWidget',\n        precondition: suggest_1.Context.Visible,\n        handler: x => x.cancelSuggestWidget(),\n        kbOpts: {\n            weight: weight,\n            kbExpr: editorContextKeys_1.EditorContextKeys.textInputFocus,\n            primary: keyCodes_1.KeyCode.Escape,\n            secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape]\n        }\n    }));\n    editorExtensions_1.registerEditorCommand(new SuggestCommand({\n        id: 'selectNextSuggestion',\n        precondition: contextkey_1.ContextKeyExpr.and(suggest_1.Context.Visible, suggest_1.Context.MultipleSuggestions),\n        handler: c => c.selectNextSuggestion(),\n        kbOpts: {\n            weight: weight,\n            kbExpr: editorContextKeys_1.EditorContextKeys.textInputFocus,\n            primary: keyCodes_1.KeyCode.DownArrow,\n            secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.DownArrow],\n            mac: { primary: keyCodes_1.KeyCode.DownArrow, secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.DownArrow, keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_N] }\n        }\n    }));\n    editorExtensions_1.registerEditorCommand(new SuggestCommand({\n        id: 'selectNextPageSuggestion',\n        precondition: contextkey_1.ContextKeyExpr.and(suggest_1.Context.Visible, suggest_1.Context.MultipleSuggestions),\n        handler: c => c.selectNextPageSuggestion(),\n        kbOpts: {\n            weight: weight,\n            kbExpr: editorContextKeys_1.EditorContextKeys.textInputFocus,\n            primary: keyCodes_1.KeyCode.PageDown,\n            secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.PageDown]\n        }\n    }));\n    editorExtensions_1.registerEditorCommand(new SuggestCommand({\n        id: 'selectLastSuggestion',\n        precondition: contextkey_1.ContextKeyExpr.and(suggest_1.Context.Visible, suggest_1.Context.MultipleSuggestions),\n        handler: c => c.selectLastSuggestion()\n    }));\n    editorExtensions_1.registerEditorCommand(new SuggestCommand({\n        id: 'selectPrevSuggestion',\n        precondition: contextkey_1.ContextKeyExpr.and(suggest_1.Context.Visible, suggest_1.Context.MultipleSuggestions),\n        handler: c => c.selectPrevSuggestion(),\n        kbOpts: {\n            weight: weight,\n            kbExpr: editorContextKeys_1.EditorContextKeys.textInputFocus,\n            primary: keyCodes_1.KeyCode.UpArrow,\n            secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.UpArrow],\n            mac: { primary: keyCodes_1.KeyCode.UpArrow, secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.UpArrow, keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_P] }\n        }\n    }));\n    editorExtensions_1.registerEditorCommand(new SuggestCommand({\n        id: 'selectPrevPageSuggestion',\n        precondition: contextkey_1.ContextKeyExpr.and(suggest_1.Context.Visible, suggest_1.Context.MultipleSuggestions),\n        handler: c => c.selectPrevPageSuggestion(),\n        kbOpts: {\n            weight: weight,\n            kbExpr: editorContextKeys_1.EditorContextKeys.textInputFocus,\n            primary: keyCodes_1.KeyCode.PageUp,\n            secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.PageUp]\n        }\n    }));\n    editorExtensions_1.registerEditorCommand(new SuggestCommand({\n        id: 'selectFirstSuggestion',\n        precondition: contextkey_1.ContextKeyExpr.and(suggest_1.Context.Visible, suggest_1.Context.MultipleSuggestions),\n        handler: c => c.selectFirstSuggestion()\n    }));\n    editorExtensions_1.registerEditorCommand(new SuggestCommand({\n        id: 'toggleSuggestionDetails',\n        precondition: suggest_1.Context.Visible,\n        handler: x => x.toggleSuggestionDetails(),\n        kbOpts: {\n            weight: weight,\n            kbExpr: editorContextKeys_1.EditorContextKeys.textInputFocus,\n            primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.Space,\n            mac: { primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.Space }\n        }\n    }));\n    editorExtensions_1.registerEditorCommand(new SuggestCommand({\n        id: 'toggleSuggestionFocus',\n        precondition: suggest_1.Context.Visible,\n        handler: x => x.toggleSuggestionFocus(),\n        kbOpts: {\n            weight: weight,\n            kbExpr: editorContextKeys_1.EditorContextKeys.textInputFocus,\n            primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.Space,\n            mac: { primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.Space }\n        }\n    }));\n    //#region tab completions\n    editorExtensions_1.registerEditorCommand(new SuggestCommand({\n        id: 'insertBestCompletion',\n        precondition: contextkey_1.ContextKeyExpr.and(contextkey_1.ContextKeyExpr.equals('config.editor.tabCompletion', 'on'), wordContextKey_1.WordContextKey.AtEnd, suggest_1.Context.Visible.toNegated(), suggestAlternatives_1.SuggestAlternatives.OtherSuggestions.toNegated(), snippetController2_1.SnippetController2.InSnippetMode.toNegated()),\n        handler: (x, arg) => {\n            x.triggerSuggestAndAcceptBest(types_1.isObject(arg) ? Object.assign({ fallback: 'tab' }, arg) : { fallback: 'tab' });\n        },\n        kbOpts: {\n            weight,\n            primary: keyCodes_1.KeyCode.Tab\n        }\n    }));\n    editorExtensions_1.registerEditorCommand(new SuggestCommand({\n        id: 'insertNextSuggestion',\n        precondition: contextkey_1.ContextKeyExpr.and(contextkey_1.ContextKeyExpr.equals('config.editor.tabCompletion', 'on'), suggestAlternatives_1.SuggestAlternatives.OtherSuggestions, suggest_1.Context.Visible.toNegated(), snippetController2_1.SnippetController2.InSnippetMode.toNegated()),\n        handler: x => x.acceptNextSuggestion(),\n        kbOpts: {\n            weight: weight,\n            kbExpr: editorContextKeys_1.EditorContextKeys.textInputFocus,\n            primary: keyCodes_1.KeyCode.Tab\n        }\n    }));\n    editorExtensions_1.registerEditorCommand(new SuggestCommand({\n        id: 'insertPrevSuggestion',\n        precondition: contextkey_1.ContextKeyExpr.and(contextkey_1.ContextKeyExpr.equals('config.editor.tabCompletion', 'on'), suggestAlternatives_1.SuggestAlternatives.OtherSuggestions, suggest_1.Context.Visible.toNegated(), snippetController2_1.SnippetController2.InSnippetMode.toNegated()),\n        handler: x => x.acceptPrevSuggestion(),\n        kbOpts: {\n            weight: weight,\n            kbExpr: editorContextKeys_1.EditorContextKeys.textInputFocus,\n            primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Tab\n        }\n    }));\n});\n",null]}