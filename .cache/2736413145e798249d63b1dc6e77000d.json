{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostDocumentData.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostDocumentData.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/assert\", \"vs/base/common/network\", \"vs/base/common/strings\", \"vs/editor/common/model/mirrorTextModel\", \"vs/editor/common/model/wordHelper\", \"vs/workbench/api/node/extHostTypes\"], function (require, exports, assert_1, network_1, strings_1, mirrorTextModel_1, wordHelper_1, extHostTypes_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const _modeId2WordDefinition = new Map();\n    function setWordDefinitionFor(modeId, wordDefinition) {\n        _modeId2WordDefinition.set(modeId, wordDefinition);\n    }\n    exports.setWordDefinitionFor = setWordDefinitionFor;\n    function getWordDefinitionFor(modeId) {\n        return _modeId2WordDefinition.get(modeId);\n    }\n    exports.getWordDefinitionFor = getWordDefinitionFor;\n    class ExtHostDocumentData extends mirrorTextModel_1.MirrorTextModel {\n        constructor(proxy, uri, lines, eol, languageId, versionId, isDirty) {\n            super(uri, lines, eol, versionId);\n            this._textLines = [];\n            this._isDisposed = false;\n            this._proxy = proxy;\n            this._languageId = languageId;\n            this._isDirty = isDirty;\n        }\n        dispose() {\n            // we don't really dispose documents but let\n            // extensions still read from them. some\n            // operations, live saving, will now error tho\n            assert_1.ok(!this._isDisposed);\n            this._isDisposed = true;\n            this._isDirty = false;\n        }\n        equalLines(lines) {\n            const len = lines.length;\n            if (len !== this._lines.length) {\n                return false;\n            }\n            for (let i = 0; i < len; i++) {\n                if (lines[i] !== this._lines[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        get document() {\n            if (!this._document) {\n                const data = this;\n                this._document = {\n                    get uri() { return data._uri; },\n                    get fileName() { return data._uri.fsPath; },\n                    get isUntitled() { return data._uri.scheme === network_1.Schemas.untitled; },\n                    get languageId() { return data._languageId; },\n                    get version() { return data._versionId; },\n                    get isClosed() { return data._isDisposed; },\n                    get isDirty() { return data._isDirty; },\n                    save() { return data._save(); },\n                    getText(range) { return range ? data._getTextInRange(range) : data.getText(); },\n                    get eol() { return data._eol === '\\n' ? extHostTypes_1.EndOfLine.LF : extHostTypes_1.EndOfLine.CRLF; },\n                    get lineCount() { return data._lines.length; },\n                    lineAt(lineOrPos) { return data._lineAt(lineOrPos); },\n                    offsetAt(pos) { return data._offsetAt(pos); },\n                    positionAt(offset) { return data._positionAt(offset); },\n                    validateRange(ran) { return data._validateRange(ran); },\n                    validatePosition(pos) { return data._validatePosition(pos); },\n                    getWordRangeAtPosition(pos, regexp) { return data._getWordRangeAtPosition(pos, regexp); }\n                };\n            }\n            return Object.freeze(this._document);\n        }\n        _acceptLanguageId(newLanguageId) {\n            assert_1.ok(!this._isDisposed);\n            this._languageId = newLanguageId;\n        }\n        _acceptIsDirty(isDirty) {\n            assert_1.ok(!this._isDisposed);\n            this._isDirty = isDirty;\n        }\n        _save() {\n            if (this._isDisposed) {\n                return Promise.reject(new Error('Document has been closed'));\n            }\n            return this._proxy.$trySaveDocument(this._uri);\n        }\n        _getTextInRange(_range) {\n            const range = this._validateRange(_range);\n            if (range.isEmpty) {\n                return '';\n            }\n            if (range.isSingleLine) {\n                return this._lines[range.start.line].substring(range.start.character, range.end.character);\n            }\n            const lineEnding = this._eol, startLineIndex = range.start.line, endLineIndex = range.end.line, resultLines = [];\n            resultLines.push(this._lines[startLineIndex].substring(range.start.character));\n            for (let i = startLineIndex + 1; i < endLineIndex; i++) {\n                resultLines.push(this._lines[i]);\n            }\n            resultLines.push(this._lines[endLineIndex].substring(0, range.end.character));\n            return resultLines.join(lineEnding);\n        }\n        _lineAt(lineOrPosition) {\n            let line;\n            if (lineOrPosition instanceof extHostTypes_1.Position) {\n                line = lineOrPosition.line;\n            }\n            else if (typeof lineOrPosition === 'number') {\n                line = lineOrPosition;\n            }\n            if (typeof line !== 'number' || line < 0 || line >= this._lines.length) {\n                throw new Error('Illegal value for `line`');\n            }\n            let result = this._textLines[line];\n            if (!result || result.lineNumber !== line || result.text !== this._lines[line]) {\n                const text = this._lines[line];\n                const firstNonWhitespaceCharacterIndex = /^(\\s*)/.exec(text)[1].length;\n                const range = new extHostTypes_1.Range(line, 0, line, text.length);\n                const rangeIncludingLineBreak = line < this._lines.length - 1\n                    ? new extHostTypes_1.Range(line, 0, line + 1, 0)\n                    : range;\n                result = Object.freeze({\n                    lineNumber: line,\n                    range,\n                    rangeIncludingLineBreak,\n                    text,\n                    firstNonWhitespaceCharacterIndex,\n                    isEmptyOrWhitespace: firstNonWhitespaceCharacterIndex === text.length\n                });\n                this._textLines[line] = result;\n            }\n            return result;\n        }\n        _offsetAt(position) {\n            position = this._validatePosition(position);\n            this._ensureLineStarts();\n            return this._lineStarts.getAccumulatedValue(position.line - 1) + position.character;\n        }\n        _positionAt(offset) {\n            offset = Math.floor(offset);\n            offset = Math.max(0, offset);\n            this._ensureLineStarts();\n            const out = this._lineStarts.getIndexOf(offset);\n            const lineLength = this._lines[out.index].length;\n            // Ensure we return a valid position\n            return new extHostTypes_1.Position(out.index, Math.min(out.remainder, lineLength));\n        }\n        // ---- range math\n        _validateRange(range) {\n            if (!(range instanceof extHostTypes_1.Range)) {\n                throw new Error('Invalid argument');\n            }\n            const start = this._validatePosition(range.start);\n            const end = this._validatePosition(range.end);\n            if (start === range.start && end === range.end) {\n                return range;\n            }\n            return new extHostTypes_1.Range(start.line, start.character, end.line, end.character);\n        }\n        _validatePosition(position) {\n            if (!(position instanceof extHostTypes_1.Position)) {\n                throw new Error('Invalid argument');\n            }\n            let { line, character } = position;\n            let hasChanged = false;\n            if (line < 0) {\n                line = 0;\n                character = 0;\n                hasChanged = true;\n            }\n            else if (line >= this._lines.length) {\n                line = this._lines.length - 1;\n                character = this._lines[line].length;\n                hasChanged = true;\n            }\n            else {\n                const maxCharacter = this._lines[line].length;\n                if (character < 0) {\n                    character = 0;\n                    hasChanged = true;\n                }\n                else if (character > maxCharacter) {\n                    character = maxCharacter;\n                    hasChanged = true;\n                }\n            }\n            if (!hasChanged) {\n                return position;\n            }\n            return new extHostTypes_1.Position(line, character);\n        }\n        _getWordRangeAtPosition(_position, regexp) {\n            const position = this._validatePosition(_position);\n            if (!regexp) {\n                // use default when custom-regexp isn't provided\n                regexp = getWordDefinitionFor(this._languageId);\n            }\n            else if (strings_1.regExpLeadsToEndlessLoop(regexp)) {\n                // use default when custom-regexp is bad\n                console.warn(`[getWordRangeAtPosition]: ignoring custom regexp '${regexp.source}' because it matches the empty string.`);\n                regexp = getWordDefinitionFor(this._languageId);\n            }\n            const wordAtText = wordHelper_1.getWordAtText(position.character + 1, wordHelper_1.ensureValidWordDefinition(regexp), this._lines[position.line], 0);\n            if (wordAtText) {\n                return new extHostTypes_1.Range(position.line, wordAtText.startColumn - 1, position.line, wordAtText.endColumn - 1);\n            }\n            return undefined;\n        }\n    }\n    exports.ExtHostDocumentData = ExtHostDocumentData;\n});\n",null]}