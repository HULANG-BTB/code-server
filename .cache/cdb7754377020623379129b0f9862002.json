{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/driver/electron-browser/driver.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/driver/electron-browser/driver.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/lifecycle\", \"vs/platform/driver/node/driver\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/ipc/electron-browser/mainProcessService\", \"vs/base/browser/dom\", \"electron\", \"vs/platform/windows/common/windows\", \"vs/base/common/async\", \"vs/base/common/arrays\"], function (require, exports, lifecycle_1, driver_1, instantiation_1, mainProcessService_1, dom_1, electron, windows_1, async_1, arrays_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function serializeElement(element, recursive) {\n        const attributes = Object.create(null);\n        for (let j = 0; j < element.attributes.length; j++) {\n            const attr = element.attributes.item(j);\n            if (attr) {\n                attributes[attr.name] = attr.value;\n            }\n        }\n        const children = [];\n        if (recursive) {\n            for (let i = 0; i < element.children.length; i++) {\n                const child = element.children.item(i);\n                if (child) {\n                    children.push(serializeElement(child, true));\n                }\n            }\n        }\n        const { left, top } = dom_1.getTopLeftOffset(element);\n        return {\n            tagName: element.tagName,\n            className: element.className,\n            textContent: element.textContent || '',\n            attributes,\n            children,\n            left,\n            top\n        };\n    }\n    let WindowDriver = class WindowDriver {\n        constructor(windowService) {\n            this.windowService = windowService;\n        }\n        click(selector, xoffset, yoffset) {\n            const offset = typeof xoffset === 'number' && typeof yoffset === 'number' ? { x: xoffset, y: yoffset } : undefined;\n            return this._click(selector, 1, offset);\n        }\n        doubleClick(selector) {\n            return this._click(selector, 2);\n        }\n        _getElementXY(selector, offset) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const element = document.querySelector(selector);\n                if (!element) {\n                    return Promise.reject(new Error(`Element not found: ${selector}`));\n                }\n                const { left, top } = dom_1.getTopLeftOffset(element);\n                const { width, height } = dom_1.getClientArea(element);\n                let x, y;\n                if (offset) {\n                    x = left + offset.x;\n                    y = top + offset.y;\n                }\n                else {\n                    x = left + (width / 2);\n                    y = top + (height / 2);\n                }\n                x = Math.round(x);\n                y = Math.round(y);\n                return { x, y };\n            });\n        }\n        _click(selector, clickCount, offset) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const { x, y } = yield this._getElementXY(selector, offset);\n                const webContents = electron.remote.getCurrentWebContents();\n                webContents.sendInputEvent({ type: 'mouseDown', x, y, button: 'left', clickCount });\n                yield async_1.timeout(10);\n                webContents.sendInputEvent({ type: 'mouseUp', x, y, button: 'left', clickCount });\n                yield async_1.timeout(100);\n            });\n        }\n        setValue(selector, text) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const element = document.querySelector(selector);\n                if (!element) {\n                    return Promise.reject(new Error(`Element not found: ${selector}`));\n                }\n                const inputElement = element;\n                inputElement.value = text;\n                const event = new Event('input', { bubbles: true, cancelable: true });\n                inputElement.dispatchEvent(event);\n            });\n        }\n        getTitle() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return document.title;\n            });\n        }\n        isActiveElement(selector) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const element = document.querySelector(selector);\n                if (element !== document.activeElement) {\n                    const chain = [];\n                    let el = document.activeElement;\n                    while (el) {\n                        const tagName = el.tagName;\n                        const id = el.id ? `#${el.id}` : '';\n                        const classes = arrays_1.coalesce(el.className.split(/\\s+/g).map(c => c.trim())).map(c => `.${c}`).join('');\n                        chain.unshift(`${tagName}${id}${classes}`);\n                        el = el.parentElement;\n                    }\n                    throw new Error(`Active element not found. Current active element is '${chain.join(' > ')}'. Looking for ${selector}`);\n                }\n                return true;\n            });\n        }\n        getElements(selector, recursive) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const query = document.querySelectorAll(selector);\n                const result = [];\n                for (let i = 0; i < query.length; i++) {\n                    const element = query.item(i);\n                    result.push(serializeElement(element, recursive));\n                }\n                return result;\n            });\n        }\n        typeInEditor(selector, text) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const element = document.querySelector(selector);\n                if (!element) {\n                    throw new Error(`Editor not found: ${selector}`);\n                }\n                const textarea = element;\n                const start = textarea.selectionStart;\n                const newStart = start + text.length;\n                const value = textarea.value;\n                const newValue = value.substr(0, start) + text + value.substr(start);\n                textarea.value = newValue;\n                textarea.setSelectionRange(newStart, newStart);\n                const event = new Event('input', { 'bubbles': true, 'cancelable': true });\n                textarea.dispatchEvent(event);\n            });\n        }\n        getTerminalBuffer(selector) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const element = document.querySelector(selector);\n                if (!element) {\n                    throw new Error(`Terminal not found: ${selector}`);\n                }\n                const xterm = element.xterm;\n                if (!xterm) {\n                    throw new Error(`Xterm not found: ${selector}`);\n                }\n                const lines = [];\n                for (let i = 0; i < xterm._core.buffer.lines.length; i++) {\n                    lines.push(xterm._core.buffer.translateBufferLineToString(i, true));\n                }\n                return lines;\n            });\n        }\n        writeInTerminal(selector, text) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const element = document.querySelector(selector);\n                if (!element) {\n                    throw new Error(`Element not found: ${selector}`);\n                }\n                const xterm = element.xterm;\n                if (!xterm) {\n                    throw new Error(`Xterm not found: ${selector}`);\n                }\n                xterm._core.handler(text);\n            });\n        }\n        openDevTools() {\n            return __awaiter(this, void 0, void 0, function* () {\n                yield this.windowService.openDevTools({ mode: 'detach' });\n            });\n        }\n    };\n    WindowDriver = __decorate([\n        __param(0, windows_1.IWindowService)\n    ], WindowDriver);\n    function registerWindowDriver(accessor) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const instantiationService = accessor.get(instantiation_1.IInstantiationService);\n            const mainProcessService = accessor.get(mainProcessService_1.IMainProcessService);\n            const windowService = accessor.get(windows_1.IWindowService);\n            const windowDriver = instantiationService.createInstance(WindowDriver);\n            const windowDriverChannel = new driver_1.WindowDriverChannel(windowDriver);\n            mainProcessService.registerChannel('windowDriver', windowDriverChannel);\n            const windowDriverRegistryChannel = mainProcessService.getChannel('windowDriverRegistry');\n            const windowDriverRegistry = new driver_1.WindowDriverRegistryChannelClient(windowDriverRegistryChannel);\n            yield windowDriverRegistry.registerWindowDriver(windowService.getCurrentWindowId());\n            // const options = await windowDriverRegistry.registerWindowDriver(windowId);\n            // if (options.verbose) {\n            // \twindowDriver.openDevTools();\n            // }\n            return lifecycle_1.toDisposable(() => windowDriverRegistry.reloadWindowDriver(windowService.getCurrentWindowId()));\n        });\n    }\n    exports.registerWindowDriver = registerWindowDriver;\n});\n",null]}