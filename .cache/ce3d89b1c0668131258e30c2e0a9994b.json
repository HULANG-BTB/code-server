{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/find/replaceAllCommand.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/find/replaceAllCommand.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/editor/common/core/range\"], function (require, exports, range_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class ReplaceAllCommand {\n        constructor(editorSelection, ranges, replaceStrings) {\n            this._editorSelection = editorSelection;\n            this._ranges = ranges;\n            this._replaceStrings = replaceStrings;\n        }\n        getEditOperations(model, builder) {\n            if (this._ranges.length > 0) {\n                // Collect all edit operations\n                let ops = [];\n                for (let i = 0; i < this._ranges.length; i++) {\n                    ops.push({\n                        range: this._ranges[i],\n                        text: this._replaceStrings[i]\n                    });\n                }\n                // Sort them in ascending order by range starts\n                ops.sort((o1, o2) => {\n                    return range_1.Range.compareRangesUsingStarts(o1.range, o2.range);\n                });\n                // Merge operations that touch each other\n                let resultOps = [];\n                let previousOp = ops[0];\n                for (let i = 1; i < ops.length; i++) {\n                    if (previousOp.range.endLineNumber === ops[i].range.startLineNumber && previousOp.range.endColumn === ops[i].range.startColumn) {\n                        // These operations are one after another and can be merged\n                        previousOp.range = previousOp.range.plusRange(ops[i].range);\n                        previousOp.text = previousOp.text + ops[i].text;\n                    }\n                    else {\n                        resultOps.push(previousOp);\n                        previousOp = ops[i];\n                    }\n                }\n                resultOps.push(previousOp);\n                for (const op of resultOps) {\n                    builder.addEditOperation(op.range, op.text);\n                }\n            }\n            this._trackedEditorSelectionId = builder.trackSelection(this._editorSelection);\n        }\n        computeCursorState(model, helper) {\n            return helper.getTrackedSelection(this._trackedEditorSelectionId);\n        }\n    }\n    exports.ReplaceAllCommand = ReplaceAllCommand;\n});\n",null]}