{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/languageConfigurationRegistry.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/languageConfigurationRegistry.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar errors_1 = require(\"vs/base/common/errors\");\nvar event_1 = require(\"vs/base/common/event\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar strings = require(\"vs/base/common/strings\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar wordHelper_1 = require(\"vs/editor/common/model/wordHelper\");\nvar languageConfiguration_1 = require(\"vs/editor/common/modes/languageConfiguration\");\nvar supports_1 = require(\"vs/editor/common/modes/supports\");\nvar characterPair_1 = require(\"vs/editor/common/modes/supports/characterPair\");\nvar electricCharacter_1 = require(\"vs/editor/common/modes/supports/electricCharacter\");\nvar indentRules_1 = require(\"vs/editor/common/modes/supports/indentRules\");\nvar onEnter_1 = require(\"vs/editor/common/modes/supports/onEnter\");\nvar richEditBrackets_1 = require(\"vs/editor/common/modes/supports/richEditBrackets\");\nvar RichEditSupport = /** @class */ (function () {\n    function RichEditSupport(languageIdentifier, previous, rawConf) {\n        this._languageIdentifier = languageIdentifier;\n        this._brackets = null;\n        this._electricCharacter = null;\n        var prev = null;\n        if (previous) {\n            prev = previous._conf;\n        }\n        this._conf = RichEditSupport._mergeConf(prev, rawConf);\n        this.onEnter = RichEditSupport._handleOnEnter(this._conf);\n        this.comments = RichEditSupport._handleComments(this._conf);\n        this.characterPair = new characterPair_1.CharacterPairSupport(this._conf);\n        this.wordDefinition = this._conf.wordPattern || wordHelper_1.DEFAULT_WORD_REGEXP;\n        this.indentationRules = this._conf.indentationRules;\n        if (this._conf.indentationRules) {\n            this.indentRulesSupport = new indentRules_1.IndentRulesSupport(this._conf.indentationRules);\n        }\n        this.foldingRules = this._conf.folding || {};\n    }\n    Object.defineProperty(RichEditSupport.prototype, \"brackets\", {\n        get: function () {\n            if (!this._brackets && this._conf.brackets) {\n                this._brackets = new richEditBrackets_1.RichEditBrackets(this._languageIdentifier, this._conf.brackets);\n            }\n            return this._brackets;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RichEditSupport.prototype, \"electricCharacter\", {\n        get: function () {\n            if (!this._electricCharacter) {\n                var autoClosingPairs = [];\n                if (this._conf.autoClosingPairs) {\n                    autoClosingPairs = this._conf.autoClosingPairs;\n                }\n                else if (this._conf.brackets) {\n                    autoClosingPairs = this._conf.brackets.map(function (b) {\n                        return { open: b[0], close: b[1] };\n                    });\n                }\n                this._electricCharacter = new electricCharacter_1.BracketElectricCharacterSupport(this.brackets, autoClosingPairs, this._conf.__electricCharacterSupport);\n            }\n            return this._electricCharacter;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    RichEditSupport._mergeConf = function (prev, current) {\n        return {\n            comments: (prev ? current.comments || prev.comments : current.comments),\n            brackets: (prev ? current.brackets || prev.brackets : current.brackets),\n            wordPattern: (prev ? current.wordPattern || prev.wordPattern : current.wordPattern),\n            indentationRules: (prev ? current.indentationRules || prev.indentationRules : current.indentationRules),\n            onEnterRules: (prev ? current.onEnterRules || prev.onEnterRules : current.onEnterRules),\n            autoClosingPairs: (prev ? current.autoClosingPairs || prev.autoClosingPairs : current.autoClosingPairs),\n            surroundingPairs: (prev ? current.surroundingPairs || prev.surroundingPairs : current.surroundingPairs),\n            autoCloseBefore: (prev ? current.autoCloseBefore || prev.autoCloseBefore : current.autoCloseBefore),\n            folding: (prev ? current.folding || prev.folding : current.folding),\n            __electricCharacterSupport: (prev ? current.__electricCharacterSupport || prev.__electricCharacterSupport : current.__electricCharacterSupport),\n        };\n    };\n    RichEditSupport._handleOnEnter = function (conf) {\n        // on enter\n        var onEnter = {};\n        var empty = true;\n        if (conf.brackets) {\n            empty = false;\n            onEnter.brackets = conf.brackets;\n        }\n        if (conf.indentationRules) {\n            empty = false;\n        }\n        if (conf.onEnterRules) {\n            empty = false;\n            onEnter.regExpRules = conf.onEnterRules;\n        }\n        if (!empty) {\n            return new onEnter_1.OnEnterSupport(onEnter);\n        }\n        return null;\n    };\n    RichEditSupport._handleComments = function (conf) {\n        var commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        var comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            var _a = commentRule.blockComment, blockStart = _a[0], blockEnd = _a[1];\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    };\n    return RichEditSupport;\n}());\nexports.RichEditSupport = RichEditSupport;\nvar LanguageConfigurationChangeEvent = /** @class */ (function () {\n    function LanguageConfigurationChangeEvent() {\n    }\n    return LanguageConfigurationChangeEvent;\n}());\nexports.LanguageConfigurationChangeEvent = LanguageConfigurationChangeEvent;\nvar LanguageConfigurationRegistryImpl = /** @class */ (function () {\n    function LanguageConfigurationRegistryImpl() {\n        this._entries = new Map();\n        this._onDidChange = new event_1.Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    LanguageConfigurationRegistryImpl.prototype.register = function (languageIdentifier, configuration) {\n        var _this = this;\n        var previous = this._getRichEditSupport(languageIdentifier.id);\n        var current = new RichEditSupport(languageIdentifier, previous, configuration);\n        this._entries.set(languageIdentifier.id, current);\n        this._onDidChange.fire({ languageIdentifier: languageIdentifier });\n        return lifecycle_1.toDisposable(function () {\n            if (_this._entries.get(languageIdentifier.id) === current) {\n                _this._entries.set(languageIdentifier.id, previous);\n                _this._onDidChange.fire({ languageIdentifier: languageIdentifier });\n            }\n        });\n    };\n    LanguageConfigurationRegistryImpl.prototype._getRichEditSupport = function (languageId) {\n        return this._entries.get(languageId);\n    };\n    LanguageConfigurationRegistryImpl.prototype.getIndentationRules = function (languageId) {\n        var value = this._entries.get(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.indentationRules || null;\n    };\n    // begin electricCharacter\n    LanguageConfigurationRegistryImpl.prototype._getElectricCharacterSupport = function (languageId) {\n        var value = this._getRichEditSupport(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.electricCharacter || null;\n    };\n    LanguageConfigurationRegistryImpl.prototype.getElectricCharacters = function (languageId) {\n        var electricCharacterSupport = this._getElectricCharacterSupport(languageId);\n        if (!electricCharacterSupport) {\n            return [];\n        }\n        return electricCharacterSupport.getElectricCharacters();\n    };\n    /**\n     * Should return opening bracket type to match indentation with\n     */\n    LanguageConfigurationRegistryImpl.prototype.onElectricCharacter = function (character, context, column) {\n        var scopedLineTokens = supports_1.createScopedLineTokens(context, column - 1);\n        var electricCharacterSupport = this._getElectricCharacterSupport(scopedLineTokens.languageId);\n        if (!electricCharacterSupport) {\n            return null;\n        }\n        return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n    };\n    // end electricCharacter\n    LanguageConfigurationRegistryImpl.prototype.getComments = function (languageId) {\n        var value = this._getRichEditSupport(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.comments || null;\n    };\n    // begin characterPair\n    LanguageConfigurationRegistryImpl.prototype._getCharacterPairSupport = function (languageId) {\n        var value = this._getRichEditSupport(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.characterPair || null;\n    };\n    LanguageConfigurationRegistryImpl.prototype.getAutoClosingPairs = function (languageId) {\n        var characterPairSupport = this._getCharacterPairSupport(languageId);\n        if (!characterPairSupport) {\n            return [];\n        }\n        return characterPairSupport.getAutoClosingPairs();\n    };\n    LanguageConfigurationRegistryImpl.prototype.getAutoCloseBeforeSet = function (languageId) {\n        var characterPairSupport = this._getCharacterPairSupport(languageId);\n        if (!characterPairSupport) {\n            return characterPair_1.CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;\n        }\n        return characterPairSupport.getAutoCloseBeforeSet();\n    };\n    LanguageConfigurationRegistryImpl.prototype.getSurroundingPairs = function (languageId) {\n        var characterPairSupport = this._getCharacterPairSupport(languageId);\n        if (!characterPairSupport) {\n            return [];\n        }\n        return characterPairSupport.getSurroundingPairs();\n    };\n    LanguageConfigurationRegistryImpl.prototype.shouldAutoClosePair = function (character, context, column) {\n        var scopedLineTokens = supports_1.createScopedLineTokens(context, column - 1);\n        var characterPairSupport = this._getCharacterPairSupport(scopedLineTokens.languageId);\n        if (!characterPairSupport) {\n            return false;\n        }\n        return characterPairSupport.shouldAutoClosePair(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n    };\n    // end characterPair\n    LanguageConfigurationRegistryImpl.prototype.getWordDefinition = function (languageId) {\n        var value = this._getRichEditSupport(languageId);\n        if (!value) {\n            return wordHelper_1.ensureValidWordDefinition(null);\n        }\n        return wordHelper_1.ensureValidWordDefinition(value.wordDefinition || null);\n    };\n    LanguageConfigurationRegistryImpl.prototype.getFoldingRules = function (languageId) {\n        var value = this._getRichEditSupport(languageId);\n        if (!value) {\n            return {};\n        }\n        return value.foldingRules;\n    };\n    // begin Indent Rules\n    LanguageConfigurationRegistryImpl.prototype.getIndentRulesSupport = function (languageId) {\n        var value = this._getRichEditSupport(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.indentRulesSupport || null;\n    };\n    /**\n     * Get nearest preceiding line which doesn't match unIndentPattern or contains all whitespace.\n     * Result:\n     * -1: run into the boundary of embedded languages\n     * 0: every line above are invalid\n     * else: nearest preceding line of the same language\n     */\n    LanguageConfigurationRegistryImpl.prototype.getPrecedingValidLine = function (model, lineNumber, indentRulesSupport) {\n        var languageID = model.getLanguageIdAtPosition(lineNumber, 0);\n        if (lineNumber > 1) {\n            var lastLineNumber = void 0;\n            var resultLineNumber = -1;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageID) {\n                    return resultLineNumber;\n                }\n                var text = model.getLineContent(lastLineNumber);\n                if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n                    resultLineNumber = lastLineNumber;\n                    continue;\n                }\n                return lastLineNumber;\n            }\n        }\n        return -1;\n    };\n    /**\n     * Get inherited indentation from above lines.\n     * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n     * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n     * 3. If this line doesn't match any indent rules\n     *   a. check whether the line above it matches indentNextLinePattern\n     *   b. If not, the indent level of this line is the result\n     *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n     * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n     *\n     * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n     */\n    LanguageConfigurationRegistryImpl.prototype.getInheritIndentForLine = function (model, lineNumber, honorIntentialIndent) {\n        if (honorIntentialIndent === void 0) { honorIntentialIndent = true; }\n        var indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        if (lineNumber <= 1) {\n            return {\n                indentation: '',\n                action: null\n            };\n        }\n        var precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n        if (precedingUnIgnoredLine < 0) {\n            return null;\n        }\n        else if (precedingUnIgnoredLine < 1) {\n            return {\n                indentation: '',\n                action: null\n            };\n        }\n        var precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n        if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n            return {\n                indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n                action: languageConfiguration_1.IndentAction.Indent,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n            return {\n                indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else {\n            // precedingUnIgnoredLine can not be ignored.\n            // it doesn't increase indent of following lines\n            // it doesn't increase just next line\n            // so current line is not affect by precedingUnIgnoredLine\n            // and then we should get a correct inheritted indentation from above lines\n            if (precedingUnIgnoredLine === 1) {\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                    action: null,\n                    line: precedingUnIgnoredLine\n                };\n            }\n            var previousLine = precedingUnIgnoredLine - 1;\n            var previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n            if (!(previousLineIndentMetadata & (indentRules_1.IndentConsts.INCREASE_MASK | indentRules_1.IndentConsts.DECREASE_MASK)) &&\n                (previousLineIndentMetadata & indentRules_1.IndentConsts.INDENT_NEXTLINE_MASK)) {\n                var stopLine = 0;\n                for (var i = previousLine - 1; i > 0; i--) {\n                    if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                        continue;\n                    }\n                    stopLine = i;\n                    break;\n                }\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                    action: null,\n                    line: stopLine + 1\n                };\n            }\n            if (honorIntentialIndent) {\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                    action: null,\n                    line: precedingUnIgnoredLine\n                };\n            }\n            else {\n                // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n                for (var i = precedingUnIgnoredLine; i > 0; i--) {\n                    var lineContent = model.getLineContent(i);\n                    if (indentRulesSupport.shouldIncrease(lineContent)) {\n                        return {\n                            indentation: strings.getLeadingWhitespace(lineContent),\n                            action: languageConfiguration_1.IndentAction.Indent,\n                            line: i\n                        };\n                    }\n                    else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n                        var stopLine = 0;\n                        for (var j = i - 1; j > 0; j--) {\n                            if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                                continue;\n                            }\n                            stopLine = j;\n                            break;\n                        }\n                        return {\n                            indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                            action: null,\n                            line: stopLine + 1\n                        };\n                    }\n                    else if (indentRulesSupport.shouldDecrease(lineContent)) {\n                        return {\n                            indentation: strings.getLeadingWhitespace(lineContent),\n                            action: null,\n                            line: i\n                        };\n                    }\n                }\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n                    action: null,\n                    line: 1\n                };\n            }\n        }\n    };\n    LanguageConfigurationRegistryImpl.prototype.getGoodIndentForLine = function (virtualModel, languageId, lineNumber, indentConverter) {\n        var indentRulesSupport = this.getIndentRulesSupport(languageId);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        var indent = this.getInheritIndentForLine(virtualModel, lineNumber);\n        var lineContent = virtualModel.getLineContent(lineNumber);\n        if (indent) {\n            var inheritLine = indent.line;\n            if (inheritLine !== undefined) {\n                var onEnterSupport = this._getOnEnterSupport(languageId);\n                var enterResult = null;\n                try {\n                    if (onEnterSupport) {\n                        enterResult = onEnterSupport.onEnter('', virtualModel.getLineContent(inheritLine), '');\n                    }\n                }\n                catch (e) {\n                    errors_1.onUnexpectedError(e);\n                }\n                if (enterResult) {\n                    var indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n                    if (enterResult.removeText) {\n                        indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n                    }\n                    if ((enterResult.indentAction === languageConfiguration_1.IndentAction.Indent) ||\n                        (enterResult.indentAction === languageConfiguration_1.IndentAction.IndentOutdent)) {\n                        indentation = indentConverter.shiftIndent(indentation);\n                    }\n                    else if (enterResult.indentAction === languageConfiguration_1.IndentAction.Outdent) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (indentRulesSupport.shouldDecrease(lineContent)) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (enterResult.appendText) {\n                        indentation += enterResult.appendText;\n                    }\n                    return strings.getLeadingWhitespace(indentation);\n                }\n            }\n            if (indentRulesSupport.shouldDecrease(lineContent)) {\n                if (indent.action === languageConfiguration_1.IndentAction.Indent) {\n                    return indent.indentation;\n                }\n                else {\n                    return indentConverter.unshiftIndent(indent.indentation);\n                }\n            }\n            else {\n                if (indent.action === languageConfiguration_1.IndentAction.Indent) {\n                    return indentConverter.shiftIndent(indent.indentation);\n                }\n                else {\n                    return indent.indentation;\n                }\n            }\n        }\n        return null;\n    };\n    LanguageConfigurationRegistryImpl.prototype.getIndentForEnter = function (model, range, indentConverter, autoIndent) {\n        model.forceTokenization(range.startLineNumber);\n        var lineTokens = model.getLineTokens(range.startLineNumber);\n        var beforeEnterText;\n        var afterEnterText;\n        var scopedLineTokens = supports_1.createScopedLineTokens(lineTokens, range.startColumn - 1);\n        var scopedLineText = scopedLineTokens.getLineContent();\n        var embeddedLanguage = false;\n        if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n            // we are in the embeded language content\n            embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n            beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n        }\n        if (range.isEmpty()) {\n            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        var indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        var beforeEnterResult = beforeEnterText;\n        var beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n        if (!autoIndent && !embeddedLanguage) {\n            var beforeEnterIndentAction = this.getInheritIndentForLine(model, range.startLineNumber);\n            if (indentRulesSupport.shouldDecrease(beforeEnterText)) {\n                if (beforeEnterIndentAction) {\n                    beforeEnterIndent = beforeEnterIndentAction.indentation;\n                    if (beforeEnterIndentAction.action !== languageConfiguration_1.IndentAction.Indent) {\n                        beforeEnterIndent = indentConverter.unshiftIndent(beforeEnterIndent);\n                    }\n                }\n            }\n            beforeEnterResult = beforeEnterIndent + strings.ltrim(strings.ltrim(beforeEnterText, ' '), '\\t');\n        }\n        var virtualModel = {\n            getLineTokens: function (lineNumber) {\n                return model.getLineTokens(lineNumber);\n            },\n            getLanguageIdentifier: function () {\n                return model.getLanguageIdentifier();\n            },\n            getLanguageIdAtPosition: function (lineNumber, column) {\n                return model.getLanguageIdAtPosition(lineNumber, column);\n            },\n            getLineContent: function (lineNumber) {\n                if (lineNumber === range.startLineNumber) {\n                    return beforeEnterResult;\n                }\n                else {\n                    return model.getLineContent(lineNumber);\n                }\n            }\n        };\n        var currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n        var afterEnterAction = this.getInheritIndentForLine(virtualModel, range.startLineNumber + 1);\n        if (!afterEnterAction) {\n            var beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n            return {\n                beforeEnter: beforeEnter,\n                afterEnter: beforeEnter\n            };\n        }\n        var afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n        if (afterEnterAction.action === languageConfiguration_1.IndentAction.Indent) {\n            afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n        }\n        if (indentRulesSupport.shouldDecrease(afterEnterText)) {\n            afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n        }\n        return {\n            beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n            afterEnter: afterEnterIndent\n        };\n    };\n    /**\n     * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n     * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n     */\n    LanguageConfigurationRegistryImpl.prototype.getIndentActionForType = function (model, range, ch, indentConverter) {\n        var scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n        var indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        var scopedLineText = scopedLineTokens.getLineContent();\n        var beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        var afterTypeText;\n        // selection support\n        if (range.isEmpty()) {\n            afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n            afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n        // Users might change the indentation by purpose and we should honor that instead of readjusting.\n        if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n            // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n            // 1. Get inherited indent action\n            var r = this.getInheritIndentForLine(model, range.startLineNumber, false);\n            if (!r) {\n                return null;\n            }\n            var indentation = r.indentation;\n            if (r.action !== languageConfiguration_1.IndentAction.Indent) {\n                indentation = indentConverter.unshiftIndent(indentation);\n            }\n            return indentation;\n        }\n        return null;\n    };\n    LanguageConfigurationRegistryImpl.prototype.getIndentMetadata = function (model, lineNumber) {\n        var indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n            return null;\n        }\n        return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n    };\n    // end Indent Rules\n    // begin onEnter\n    LanguageConfigurationRegistryImpl.prototype._getOnEnterSupport = function (languageId) {\n        var value = this._getRichEditSupport(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.onEnter || null;\n    };\n    LanguageConfigurationRegistryImpl.prototype.getRawEnterActionAtPosition = function (model, lineNumber, column) {\n        var r = this.getEnterAction(model, new range_1.Range(lineNumber, column, lineNumber, column));\n        return r ? r.enterAction : null;\n    };\n    LanguageConfigurationRegistryImpl.prototype.getEnterAction = function (model, range) {\n        var indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        var scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n        var onEnterSupport = this._getOnEnterSupport(scopedLineTokens.languageId);\n        if (!onEnterSupport) {\n            return null;\n        }\n        var scopedLineText = scopedLineTokens.getLineContent();\n        var beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        var afterEnterText;\n        // selection support\n        if (range.isEmpty()) {\n            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        var lineNumber = range.startLineNumber;\n        var oneLineAboveText = '';\n        if (lineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\n            // This is not the first line and the entire line belongs to this mode\n            var oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, lineNumber - 1);\n            if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\n                // The line above ends with text belonging to the same mode\n                oneLineAboveText = oneLineAboveScopedLineTokens.getLineContent();\n            }\n        }\n        var enterResult = null;\n        try {\n            enterResult = onEnterSupport.onEnter(oneLineAboveText, beforeEnterText, afterEnterText);\n        }\n        catch (e) {\n            errors_1.onUnexpectedError(e);\n        }\n        if (!enterResult) {\n            return null;\n        }\n        else {\n            // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n            if (!enterResult.appendText) {\n                if ((enterResult.indentAction === languageConfiguration_1.IndentAction.Indent) ||\n                    (enterResult.indentAction === languageConfiguration_1.IndentAction.IndentOutdent)) {\n                    enterResult.appendText = '\\t';\n                }\n                else {\n                    enterResult.appendText = '';\n                }\n            }\n        }\n        if (enterResult.removeText) {\n            indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n        }\n        return {\n            enterAction: enterResult,\n            indentation: indentation,\n        };\n    };\n    LanguageConfigurationRegistryImpl.prototype.getIndentationAtPosition = function (model, lineNumber, column) {\n        var lineText = model.getLineContent(lineNumber);\n        var indentation = strings.getLeadingWhitespace(lineText);\n        if (indentation.length > column - 1) {\n            indentation = indentation.substring(0, column - 1);\n        }\n        return indentation;\n    };\n    LanguageConfigurationRegistryImpl.prototype.getScopedLineTokens = function (model, lineNumber, columnNumber) {\n        model.forceTokenization(lineNumber);\n        var lineTokens = model.getLineTokens(lineNumber);\n        var column = (typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1);\n        var scopedLineTokens = supports_1.createScopedLineTokens(lineTokens, column);\n        return scopedLineTokens;\n    };\n    // end onEnter\n    LanguageConfigurationRegistryImpl.prototype.getBracketsSupport = function (languageId) {\n        var value = this._getRichEditSupport(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.brackets || null;\n    };\n    return LanguageConfigurationRegistryImpl;\n}());\nexports.LanguageConfigurationRegistryImpl = LanguageConfigurationRegistryImpl;\nexports.LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/languageConfigurationRegistry.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/languageConfigurationRegistry.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport * as strings from 'vs/base/common/strings';\nimport { LineTokens } from 'vs/editor/common/core/lineTokens';\nimport { Range } from 'vs/editor/common/core/range';\nimport { ITextModel } from 'vs/editor/common/model';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from 'vs/editor/common/model/wordHelper';\nimport { LanguageId, LanguageIdentifier } from 'vs/editor/common/modes';\nimport { EnterAction, FoldingRules, IAutoClosingPair, IAutoClosingPairConditional, IndentAction, IndentationRule, LanguageConfiguration } from 'vs/editor/common/modes/languageConfiguration';\nimport { createScopedLineTokens } from 'vs/editor/common/modes/supports';\nimport { CharacterPairSupport } from 'vs/editor/common/modes/supports/characterPair';\nimport { BracketElectricCharacterSupport, IElectricAction } from 'vs/editor/common/modes/supports/electricCharacter';\nimport { IndentConsts, IndentRulesSupport } from 'vs/editor/common/modes/supports/indentRules';\nimport { IOnEnterSupportOptions, OnEnterSupport } from 'vs/editor/common/modes/supports/onEnter';\nimport { RichEditBrackets } from 'vs/editor/common/modes/supports/richEditBrackets';\n\n/**\n * Interface used to support insertion of mode specific comments.\n */\nexport interface ICommentsConfiguration {\n\tlineCommentToken?: string;\n\tblockCommentStartToken?: string;\n\tblockCommentEndToken?: string;\n}\n\nexport interface IVirtualModel {\n\tgetLineTokens(lineNumber: number): LineTokens;\n\tgetLanguageIdentifier(): LanguageIdentifier;\n\tgetLanguageIdAtPosition(lineNumber: number, column: number): LanguageId;\n\tgetLineContent(lineNumber: number): string;\n}\n\nexport interface IIndentConverter {\n\tshiftIndent(indentation: string): string;\n\tunshiftIndent(indentation: string): string;\n\tnormalizeIndentation?(indentation: string): string;\n}\n\nexport class RichEditSupport {\n\n\tprivate readonly _conf: LanguageConfiguration;\n\tprivate readonly _languageIdentifier: LanguageIdentifier;\n\tprivate _brackets: RichEditBrackets | null;\n\tprivate _electricCharacter: BracketElectricCharacterSupport | null;\n\n\tpublic readonly comments: ICommentsConfiguration | null;\n\tpublic readonly characterPair: CharacterPairSupport;\n\tpublic readonly wordDefinition: RegExp;\n\tpublic readonly onEnter: OnEnterSupport | null;\n\tpublic readonly indentRulesSupport: IndentRulesSupport;\n\tpublic readonly indentationRules: IndentationRule | undefined;\n\tpublic readonly foldingRules: FoldingRules;\n\n\tconstructor(languageIdentifier: LanguageIdentifier, previous: RichEditSupport | undefined, rawConf: LanguageConfiguration) {\n\t\tthis._languageIdentifier = languageIdentifier;\n\n\t\tthis._brackets = null;\n\t\tthis._electricCharacter = null;\n\n\t\tlet prev: LanguageConfiguration | null = null;\n\t\tif (previous) {\n\t\t\tprev = previous._conf;\n\t\t}\n\n\t\tthis._conf = RichEditSupport._mergeConf(prev, rawConf);\n\n\t\tthis.onEnter = RichEditSupport._handleOnEnter(this._conf);\n\n\t\tthis.comments = RichEditSupport._handleComments(this._conf);\n\n\t\tthis.characterPair = new CharacterPairSupport(this._conf);\n\n\t\tthis.wordDefinition = this._conf.wordPattern || DEFAULT_WORD_REGEXP;\n\n\t\tthis.indentationRules = this._conf.indentationRules;\n\t\tif (this._conf.indentationRules) {\n\t\t\tthis.indentRulesSupport = new IndentRulesSupport(this._conf.indentationRules);\n\t\t}\n\n\t\tthis.foldingRules = this._conf.folding || {};\n\t}\n\n\tpublic get brackets(): RichEditBrackets | null {\n\t\tif (!this._brackets && this._conf.brackets) {\n\t\t\tthis._brackets = new RichEditBrackets(this._languageIdentifier, this._conf.brackets);\n\t\t}\n\t\treturn this._brackets;\n\t}\n\n\tpublic get electricCharacter(): BracketElectricCharacterSupport | null {\n\t\tif (!this._electricCharacter) {\n\t\t\tlet autoClosingPairs: IAutoClosingPairConditional[] = [];\n\t\t\tif (this._conf.autoClosingPairs) {\n\t\t\t\tautoClosingPairs = this._conf.autoClosingPairs;\n\t\t\t} else if (this._conf.brackets) {\n\t\t\t\tautoClosingPairs = this._conf.brackets.map(b => {\n\t\t\t\t\treturn { open: b[0], close: b[1] };\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._electricCharacter = new BracketElectricCharacterSupport(this.brackets, autoClosingPairs, this._conf.__electricCharacterSupport);\n\t\t}\n\t\treturn this._electricCharacter;\n\t}\n\n\tprivate static _mergeConf(prev: LanguageConfiguration | null, current: LanguageConfiguration): LanguageConfiguration {\n\t\treturn {\n\t\t\tcomments: (prev ? current.comments || prev.comments : current.comments),\n\t\t\tbrackets: (prev ? current.brackets || prev.brackets : current.brackets),\n\t\t\twordPattern: (prev ? current.wordPattern || prev.wordPattern : current.wordPattern),\n\t\t\tindentationRules: (prev ? current.indentationRules || prev.indentationRules : current.indentationRules),\n\t\t\tonEnterRules: (prev ? current.onEnterRules || prev.onEnterRules : current.onEnterRules),\n\t\t\tautoClosingPairs: (prev ? current.autoClosingPairs || prev.autoClosingPairs : current.autoClosingPairs),\n\t\t\tsurroundingPairs: (prev ? current.surroundingPairs || prev.surroundingPairs : current.surroundingPairs),\n\t\t\tautoCloseBefore: (prev ? current.autoCloseBefore || prev.autoCloseBefore : current.autoCloseBefore),\n\t\t\tfolding: (prev ? current.folding || prev.folding : current.folding),\n\t\t\t__electricCharacterSupport: (prev ? current.__electricCharacterSupport || prev.__electricCharacterSupport : current.__electricCharacterSupport),\n\t\t};\n\t}\n\n\tprivate static _handleOnEnter(conf: LanguageConfiguration): OnEnterSupport | null {\n\t\t// on enter\n\t\tlet onEnter: IOnEnterSupportOptions = {};\n\t\tlet empty = true;\n\n\t\tif (conf.brackets) {\n\t\t\tempty = false;\n\t\t\tonEnter.brackets = conf.brackets;\n\t\t}\n\t\tif (conf.indentationRules) {\n\t\t\tempty = false;\n\t\t}\n\t\tif (conf.onEnterRules) {\n\t\t\tempty = false;\n\t\t\tonEnter.regExpRules = conf.onEnterRules;\n\t\t}\n\n\t\tif (!empty) {\n\t\t\treturn new OnEnterSupport(onEnter);\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static _handleComments(conf: LanguageConfiguration): ICommentsConfiguration | null {\n\t\tlet commentRule = conf.comments;\n\t\tif (!commentRule) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// comment configuration\n\t\tlet comments: ICommentsConfiguration = {};\n\n\t\tif (commentRule.lineComment) {\n\t\t\tcomments.lineCommentToken = commentRule.lineComment;\n\t\t}\n\t\tif (commentRule.blockComment) {\n\t\t\tlet [blockStart, blockEnd] = commentRule.blockComment;\n\t\t\tcomments.blockCommentStartToken = blockStart;\n\t\t\tcomments.blockCommentEndToken = blockEnd;\n\t\t}\n\n\t\treturn comments;\n\t}\n}\n\nexport class LanguageConfigurationChangeEvent {\n\tlanguageIdentifier: LanguageIdentifier;\n}\n\nexport class LanguageConfigurationRegistryImpl {\n\n\tprivate readonly _entries = new Map<LanguageId, RichEditSupport>();\n\n\tprivate readonly _onDidChange = new Emitter<LanguageConfigurationChangeEvent>();\n\tpublic readonly onDidChange: Event<LanguageConfigurationChangeEvent> = this._onDidChange.event;\n\n\tpublic register(languageIdentifier: LanguageIdentifier, configuration: LanguageConfiguration): IDisposable {\n\t\tlet previous = this._getRichEditSupport(languageIdentifier.id);\n\t\tlet current = new RichEditSupport(languageIdentifier, previous, configuration);\n\t\tthis._entries.set(languageIdentifier.id, current);\n\t\tthis._onDidChange.fire({ languageIdentifier });\n\t\treturn toDisposable(() => {\n\t\t\tif (this._entries.get(languageIdentifier.id) === current) {\n\t\t\t\tthis._entries.set(languageIdentifier.id, previous);\n\t\t\t\tthis._onDidChange.fire({ languageIdentifier });\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate _getRichEditSupport(languageId: LanguageId): RichEditSupport | undefined {\n\t\treturn this._entries.get(languageId);\n\t}\n\n\tpublic getIndentationRules(languageId: LanguageId) {\n\t\tconst value = this._entries.get(languageId);\n\n\t\tif (!value) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn value.indentationRules || null;\n\t}\n\n\t// begin electricCharacter\n\n\tprivate _getElectricCharacterSupport(languageId: LanguageId): BracketElectricCharacterSupport | null {\n\t\tlet value = this._getRichEditSupport(languageId);\n\t\tif (!value) {\n\t\t\treturn null;\n\t\t}\n\t\treturn value.electricCharacter || null;\n\t}\n\n\tpublic getElectricCharacters(languageId: LanguageId): string[] {\n\t\tlet electricCharacterSupport = this._getElectricCharacterSupport(languageId);\n\t\tif (!electricCharacterSupport) {\n\t\t\treturn [];\n\t\t}\n\t\treturn electricCharacterSupport.getElectricCharacters();\n\t}\n\n\t/**\n\t * Should return opening bracket type to match indentation with\n\t */\n\tpublic onElectricCharacter(character: string, context: LineTokens, column: number): IElectricAction | null {\n\t\tlet scopedLineTokens = createScopedLineTokens(context, column - 1);\n\t\tlet electricCharacterSupport = this._getElectricCharacterSupport(scopedLineTokens.languageId);\n\t\tif (!electricCharacterSupport) {\n\t\t\treturn null;\n\t\t}\n\t\treturn electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n\t}\n\n\t// end electricCharacter\n\n\tpublic getComments(languageId: LanguageId): ICommentsConfiguration | null {\n\t\tlet value = this._getRichEditSupport(languageId);\n\t\tif (!value) {\n\t\t\treturn null;\n\t\t}\n\t\treturn value.comments || null;\n\t}\n\n\t// begin characterPair\n\n\tprivate _getCharacterPairSupport(languageId: LanguageId): CharacterPairSupport | null {\n\t\tlet value = this._getRichEditSupport(languageId);\n\t\tif (!value) {\n\t\t\treturn null;\n\t\t}\n\t\treturn value.characterPair || null;\n\t}\n\n\tpublic getAutoClosingPairs(languageId: LanguageId): IAutoClosingPair[] {\n\t\tlet characterPairSupport = this._getCharacterPairSupport(languageId);\n\t\tif (!characterPairSupport) {\n\t\t\treturn [];\n\t\t}\n\t\treturn characterPairSupport.getAutoClosingPairs();\n\t}\n\n\tpublic getAutoCloseBeforeSet(languageId: LanguageId): string {\n\t\tlet characterPairSupport = this._getCharacterPairSupport(languageId);\n\t\tif (!characterPairSupport) {\n\t\t\treturn CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;\n\t\t}\n\t\treturn characterPairSupport.getAutoCloseBeforeSet();\n\t}\n\n\tpublic getSurroundingPairs(languageId: LanguageId): IAutoClosingPair[] {\n\t\tlet characterPairSupport = this._getCharacterPairSupport(languageId);\n\t\tif (!characterPairSupport) {\n\t\t\treturn [];\n\t\t}\n\t\treturn characterPairSupport.getSurroundingPairs();\n\t}\n\n\tpublic shouldAutoClosePair(character: string, context: LineTokens, column: number): boolean {\n\t\tlet scopedLineTokens = createScopedLineTokens(context, column - 1);\n\t\tlet characterPairSupport = this._getCharacterPairSupport(scopedLineTokens.languageId);\n\t\tif (!characterPairSupport) {\n\t\t\treturn false;\n\t\t}\n\t\treturn characterPairSupport.shouldAutoClosePair(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n\t}\n\n\t// end characterPair\n\n\tpublic getWordDefinition(languageId: LanguageId): RegExp {\n\t\tlet value = this._getRichEditSupport(languageId);\n\t\tif (!value) {\n\t\t\treturn ensureValidWordDefinition(null);\n\t\t}\n\t\treturn ensureValidWordDefinition(value.wordDefinition || null);\n\t}\n\n\tpublic getFoldingRules(languageId: LanguageId): FoldingRules {\n\t\tlet value = this._getRichEditSupport(languageId);\n\t\tif (!value) {\n\t\t\treturn {};\n\t\t}\n\t\treturn value.foldingRules;\n\t}\n\n\t// begin Indent Rules\n\n\tpublic getIndentRulesSupport(languageId: LanguageId): IndentRulesSupport | null {\n\t\tlet value = this._getRichEditSupport(languageId);\n\t\tif (!value) {\n\t\t\treturn null;\n\t\t}\n\t\treturn value.indentRulesSupport || null;\n\t}\n\n\t/**\n\t * Get nearest preceiding line which doesn't match unIndentPattern or contains all whitespace.\n\t * Result:\n\t * -1: run into the boundary of embedded languages\n\t * 0: every line above are invalid\n\t * else: nearest preceding line of the same language\n\t */\n\tprivate getPrecedingValidLine(model: IVirtualModel, lineNumber: number, indentRulesSupport: IndentRulesSupport) {\n\t\tlet languageID = model.getLanguageIdAtPosition(lineNumber, 0);\n\t\tif (lineNumber > 1) {\n\t\t\tlet lastLineNumber: number;\n\t\t\tlet resultLineNumber = -1;\n\n\t\t\tfor (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n\t\t\t\tif (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageID) {\n\t\t\t\t\treturn resultLineNumber;\n\t\t\t\t}\n\t\t\t\tlet text = model.getLineContent(lastLineNumber);\n\t\t\t\tif (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n\t\t\t\t\tresultLineNumber = lastLineNumber;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\treturn lastLineNumber;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Get inherited indentation from above lines.\n\t * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n\t * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n\t * 3. If this line doesn't match any indent rules\n\t *   a. check whether the line above it matches indentNextLinePattern\n\t *   b. If not, the indent level of this line is the result\n\t *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n\t * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n\t *\n\t * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n\t */\n\tpublic getInheritIndentForLine(model: IVirtualModel, lineNumber: number, honorIntentialIndent: boolean = true): { indentation: string; action: IndentAction | null; line?: number; } | null {\n\t\tlet indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);\n\t\tif (!indentRulesSupport) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (lineNumber <= 1) {\n\t\t\treturn {\n\t\t\t\tindentation: '',\n\t\t\t\taction: null\n\t\t\t};\n\t\t}\n\n\t\tlet precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n\t\tif (precedingUnIgnoredLine < 0) {\n\t\t\treturn null;\n\t\t} else if (precedingUnIgnoredLine < 1) {\n\t\t\treturn {\n\t\t\t\tindentation: '',\n\t\t\t\taction: null\n\t\t\t};\n\t\t}\n\n\t\tlet precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n\n\t\tif (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n\t\t\t\taction: IndentAction.Indent,\n\t\t\t\tline: precedingUnIgnoredLine\n\t\t\t};\n\t\t} else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n\t\t\treturn {\n\t\t\t\tindentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n\t\t\t\taction: null,\n\t\t\t\tline: precedingUnIgnoredLine\n\t\t\t};\n\t\t} else {\n\t\t\t// precedingUnIgnoredLine can not be ignored.\n\t\t\t// it doesn't increase indent of following lines\n\t\t\t// it doesn't increase just next line\n\t\t\t// so current line is not affect by precedingUnIgnoredLine\n\t\t\t// and then we should get a correct inheritted indentation from above lines\n\t\t\tif (precedingUnIgnoredLine === 1) {\n\t\t\t\treturn {\n\t\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n\t\t\t\t\taction: null,\n\t\t\t\t\tline: precedingUnIgnoredLine\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tlet previousLine = precedingUnIgnoredLine - 1;\n\n\t\t\tlet previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n\t\t\tif (!(previousLineIndentMetadata & (IndentConsts.INCREASE_MASK | IndentConsts.DECREASE_MASK)) &&\n\t\t\t\t(previousLineIndentMetadata & IndentConsts.INDENT_NEXTLINE_MASK)) {\n\t\t\t\tlet stopLine = 0;\n\t\t\t\tfor (let i = previousLine - 1; i > 0; i--) {\n\t\t\t\t\tif (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tstopLine = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n\t\t\t\t\taction: null,\n\t\t\t\t\tline: stopLine + 1\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (honorIntentialIndent) {\n\t\t\t\treturn {\n\t\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n\t\t\t\t\taction: null,\n\t\t\t\t\tline: precedingUnIgnoredLine\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// search from precedingUnIgnoredLine until we find one whose indent is not temporary\n\t\t\t\tfor (let i = precedingUnIgnoredLine; i > 0; i--) {\n\t\t\t\t\tlet lineContent = model.getLineContent(i);\n\t\t\t\t\tif (indentRulesSupport.shouldIncrease(lineContent)) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tindentation: strings.getLeadingWhitespace(lineContent),\n\t\t\t\t\t\t\taction: IndentAction.Indent,\n\t\t\t\t\t\t\tline: i\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n\t\t\t\t\t\tlet stopLine = 0;\n\t\t\t\t\t\tfor (let j = i - 1; j > 0; j--) {\n\t\t\t\t\t\t\tif (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstopLine = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n\t\t\t\t\t\t\taction: null,\n\t\t\t\t\t\t\tline: stopLine + 1\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (indentRulesSupport.shouldDecrease(lineContent)) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tindentation: strings.getLeadingWhitespace(lineContent),\n\t\t\t\t\t\t\taction: null,\n\t\t\t\t\t\t\tline: i\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tindentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n\t\t\t\t\taction: null,\n\t\t\t\t\tline: 1\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic getGoodIndentForLine(virtualModel: IVirtualModel, languageId: LanguageId, lineNumber: number, indentConverter: IIndentConverter): string | null {\n\t\tlet indentRulesSupport = this.getIndentRulesSupport(languageId);\n\t\tif (!indentRulesSupport) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet indent = this.getInheritIndentForLine(virtualModel, lineNumber);\n\t\tlet lineContent = virtualModel.getLineContent(lineNumber);\n\n\t\tif (indent) {\n\t\t\tlet inheritLine = indent.line;\n\t\t\tif (inheritLine !== undefined) {\n\t\t\t\tlet onEnterSupport = this._getOnEnterSupport(languageId);\n\t\t\t\tlet enterResult: EnterAction | null = null;\n\t\t\t\ttry {\n\t\t\t\t\tif (onEnterSupport) {\n\t\t\t\t\t\tenterResult = onEnterSupport.onEnter('', virtualModel.getLineContent(inheritLine), '');\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tonUnexpectedError(e);\n\t\t\t\t}\n\n\t\t\t\tif (enterResult) {\n\t\t\t\t\tlet indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n\n\t\t\t\t\tif (enterResult.removeText) {\n\t\t\t\t\t\tindentation = indentation.substring(0, indentation.length - enterResult.removeText);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t(enterResult.indentAction === IndentAction.Indent) ||\n\t\t\t\t\t\t(enterResult.indentAction === IndentAction.IndentOutdent)\n\t\t\t\t\t) {\n\t\t\t\t\t\tindentation = indentConverter.shiftIndent(indentation);\n\t\t\t\t\t} else if (enterResult.indentAction === IndentAction.Outdent) {\n\t\t\t\t\t\tindentation = indentConverter.unshiftIndent(indentation);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (indentRulesSupport.shouldDecrease(lineContent)) {\n\t\t\t\t\t\tindentation = indentConverter.unshiftIndent(indentation);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (enterResult.appendText) {\n\t\t\t\t\t\tindentation += enterResult.appendText;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn strings.getLeadingWhitespace(indentation);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (indentRulesSupport.shouldDecrease(lineContent)) {\n\t\t\t\tif (indent.action === IndentAction.Indent) {\n\t\t\t\t\treturn indent.indentation;\n\t\t\t\t} else {\n\t\t\t\t\treturn indentConverter.unshiftIndent(indent.indentation);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (indent.action === IndentAction.Indent) {\n\t\t\t\t\treturn indentConverter.shiftIndent(indent.indentation);\n\t\t\t\t} else {\n\t\t\t\t\treturn indent.indentation;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic getIndentForEnter(model: ITextModel, range: Range, indentConverter: IIndentConverter, autoIndent: boolean): { beforeEnter: string, afterEnter: string } | null {\n\t\tmodel.forceTokenization(range.startLineNumber);\n\t\tlet lineTokens = model.getLineTokens(range.startLineNumber);\n\n\t\tlet beforeEnterText;\n\t\tlet afterEnterText;\n\t\tlet scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n\t\tlet scopedLineText = scopedLineTokens.getLineContent();\n\n\t\tlet embeddedLanguage = false;\n\t\tif (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n\t\t\t// we are in the embeded language content\n\t\t\tembeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n\t\t\tbeforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n\t\t} else {\n\t\t\tbeforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n\t\t}\n\n\t\tif (range.isEmpty()) {\n\t\t\tafterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n\t\t} else {\n\t\t\tconst endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n\t\t\tafterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n\t\t}\n\n\t\tlet indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n\n\t\tif (!indentRulesSupport) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet beforeEnterResult = beforeEnterText;\n\t\tlet beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n\n\t\tif (!autoIndent && !embeddedLanguage) {\n\t\t\tlet beforeEnterIndentAction = this.getInheritIndentForLine(model, range.startLineNumber);\n\n\t\t\tif (indentRulesSupport.shouldDecrease(beforeEnterText)) {\n\t\t\t\tif (beforeEnterIndentAction) {\n\t\t\t\t\tbeforeEnterIndent = beforeEnterIndentAction.indentation;\n\t\t\t\t\tif (beforeEnterIndentAction.action !== IndentAction.Indent) {\n\t\t\t\t\t\tbeforeEnterIndent = indentConverter.unshiftIndent(beforeEnterIndent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbeforeEnterResult = beforeEnterIndent + strings.ltrim(strings.ltrim(beforeEnterText, ' '), '\\t');\n\t\t}\n\n\t\tlet virtualModel: IVirtualModel = {\n\t\t\tgetLineTokens: (lineNumber: number) => {\n\t\t\t\treturn model.getLineTokens(lineNumber);\n\t\t\t},\n\t\t\tgetLanguageIdentifier: () => {\n\t\t\t\treturn model.getLanguageIdentifier();\n\t\t\t},\n\t\t\tgetLanguageIdAtPosition: (lineNumber: number, column: number) => {\n\t\t\t\treturn model.getLanguageIdAtPosition(lineNumber, column);\n\t\t\t},\n\t\t\tgetLineContent: (lineNumber: number) => {\n\t\t\t\tif (lineNumber === range.startLineNumber) {\n\t\t\t\t\treturn beforeEnterResult;\n\t\t\t\t} else {\n\t\t\t\t\treturn model.getLineContent(lineNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n\t\tlet afterEnterAction = this.getInheritIndentForLine(virtualModel, range.startLineNumber + 1);\n\t\tif (!afterEnterAction) {\n\t\t\tlet beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n\t\t\treturn {\n\t\t\t\tbeforeEnter: beforeEnter,\n\t\t\t\tafterEnter: beforeEnter\n\t\t\t};\n\t\t}\n\n\t\tlet afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n\n\t\tif (afterEnterAction.action === IndentAction.Indent) {\n\t\t\tafterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n\t\t}\n\n\t\tif (indentRulesSupport.shouldDecrease(afterEnterText)) {\n\t\t\tafterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n\t\t}\n\n\t\treturn {\n\t\t\tbeforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n\t\t\tafterEnter: afterEnterIndent\n\t\t};\n\t}\n\n\t/**\n\t * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n\t * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n\t */\n\tpublic getIndentActionForType(model: ITextModel, range: Range, ch: string, indentConverter: IIndentConverter): string | null {\n\t\tlet scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n\t\tlet indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n\t\tif (!indentRulesSupport) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet scopedLineText = scopedLineTokens.getLineContent();\n\t\tlet beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n\t\tlet afterTypeText;\n\n\t\t// selection support\n\t\tif (range.isEmpty()) {\n\t\t\tafterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n\t\t} else {\n\t\t\tconst endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n\t\t\tafterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n\t\t}\n\n\t\t// If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n\t\t// Users might change the indentation by purpose and we should honor that instead of readjusting.\n\t\tif (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n\t\t\t// after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n\t\t\t// 1. Get inherited indent action\n\t\t\tlet r = this.getInheritIndentForLine(model, range.startLineNumber, false);\n\t\t\tif (!r) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlet indentation = r.indentation;\n\n\t\t\tif (r.action !== IndentAction.Indent) {\n\t\t\t\tindentation = indentConverter.unshiftIndent(indentation);\n\t\t\t}\n\n\t\t\treturn indentation;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic getIndentMetadata(model: ITextModel, lineNumber: number): number | null {\n\t\tlet indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);\n\t\tif (!indentRulesSupport) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (lineNumber < 1 || lineNumber > model.getLineCount()) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n\t}\n\n\t// end Indent Rules\n\n\t// begin onEnter\n\n\tprivate _getOnEnterSupport(languageId: LanguageId): OnEnterSupport | null {\n\t\tlet value = this._getRichEditSupport(languageId);\n\t\tif (!value) {\n\t\t\treturn null;\n\t\t}\n\t\treturn value.onEnter || null;\n\t}\n\n\tpublic getRawEnterActionAtPosition(model: ITextModel, lineNumber: number, column: number): EnterAction | null {\n\t\tlet r = this.getEnterAction(model, new Range(lineNumber, column, lineNumber, column));\n\n\t\treturn r ? r.enterAction : null;\n\t}\n\n\tpublic getEnterAction(model: ITextModel, range: Range): { enterAction: EnterAction; indentation: string; } | null {\n\t\tlet indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n\n\t\tlet scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n\t\tlet onEnterSupport = this._getOnEnterSupport(scopedLineTokens.languageId);\n\t\tif (!onEnterSupport) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet scopedLineText = scopedLineTokens.getLineContent();\n\t\tlet beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n\t\tlet afterEnterText;\n\n\t\t// selection support\n\t\tif (range.isEmpty()) {\n\t\t\tafterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n\t\t} else {\n\t\t\tconst endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n\t\t\tafterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n\t\t}\n\n\t\tlet lineNumber = range.startLineNumber;\n\t\tlet oneLineAboveText = '';\n\n\t\tif (lineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\n\t\t\t// This is not the first line and the entire line belongs to this mode\n\t\t\tlet oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, lineNumber - 1);\n\t\t\tif (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\n\t\t\t\t// The line above ends with text belonging to the same mode\n\t\t\t\toneLineAboveText = oneLineAboveScopedLineTokens.getLineContent();\n\t\t\t}\n\t\t}\n\n\t\tlet enterResult: EnterAction | null = null;\n\t\ttry {\n\t\t\tenterResult = onEnterSupport.onEnter(oneLineAboveText, beforeEnterText, afterEnterText);\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t}\n\n\t\tif (!enterResult) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\t// Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n\t\t\tif (!enterResult.appendText) {\n\t\t\t\tif (\n\t\t\t\t\t(enterResult.indentAction === IndentAction.Indent) ||\n\t\t\t\t\t(enterResult.indentAction === IndentAction.IndentOutdent)\n\t\t\t\t) {\n\t\t\t\t\tenterResult.appendText = '\\t';\n\t\t\t\t} else {\n\t\t\t\t\tenterResult.appendText = '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (enterResult.removeText) {\n\t\t\tindentation = indentation.substring(0, indentation.length - enterResult.removeText);\n\t\t}\n\n\t\treturn {\n\t\t\tenterAction: enterResult,\n\t\t\tindentation: indentation,\n\t\t};\n\t}\n\n\tpublic getIndentationAtPosition(model: ITextModel, lineNumber: number, column: number): string {\n\t\tlet lineText = model.getLineContent(lineNumber);\n\t\tlet indentation = strings.getLeadingWhitespace(lineText);\n\t\tif (indentation.length > column - 1) {\n\t\t\tindentation = indentation.substring(0, column - 1);\n\t\t}\n\n\t\treturn indentation;\n\t}\n\n\tprivate getScopedLineTokens(model: ITextModel, lineNumber: number, columnNumber?: number) {\n\t\tmodel.forceTokenization(lineNumber);\n\t\tlet lineTokens = model.getLineTokens(lineNumber);\n\t\tlet column = (typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1);\n\t\tlet scopedLineTokens = createScopedLineTokens(lineTokens, column);\n\t\treturn scopedLineTokens;\n\t}\n\n\t// end onEnter\n\n\tpublic getBracketsSupport(languageId: LanguageId): RichEditBrackets | null {\n\t\tlet value = this._getRichEditSupport(languageId);\n\t\tif (!value) {\n\t\t\treturn null;\n\t\t}\n\t\treturn value.brackets || null;\n\t}\n}\n\nexport const LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();\n"]}]}