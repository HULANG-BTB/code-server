{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/common/glob.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/glob.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrays = require(\"vs/base/common/arrays\");\nvar strings = require(\"vs/base/common/strings\");\nvar extpath = require(\"vs/base/common/extpath\");\nvar paths = require(\"vs/base/common/path\");\nvar map_1 = require(\"vs/base/common/map\");\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar async_1 = require(\"vs/base/common/async\");\nfunction getEmptyExpression() {\n    return Object.create(null);\n}\nexports.getEmptyExpression = getEmptyExpression;\nvar GLOBSTAR = '**';\nvar GLOB_SPLIT = '/';\nvar PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\nvar NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\nvar ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount) {\n    switch (starCount) {\n        case 0:\n            return '';\n        case 1:\n            return NO_PATH_REGEX + \"*?\"; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n        default:\n            // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n            // Group is non capturing because we don't need to capture at all (?:...)\n            // Overall we use non-greedy matching because it could be that we match too much\n            return \"(?:\" + PATH_REGEX + \"|\" + NO_PATH_REGEX + \"+\" + PATH_REGEX + \"|\" + PATH_REGEX + NO_PATH_REGEX + \"+)*?\";\n    }\n}\nfunction splitGlobAware(pattern, splitChar) {\n    if (!pattern) {\n        return [];\n    }\n    var segments = [];\n    var inBraces = false;\n    var inBrackets = false;\n    var curVal = '';\n    for (var _i = 0, pattern_1 = pattern; _i < pattern_1.length; _i++) {\n        var char = pattern_1[_i];\n        switch (char) {\n            case splitChar:\n                if (!inBraces && !inBrackets) {\n                    segments.push(curVal);\n                    curVal = '';\n                    continue;\n                }\n                break;\n            case '{':\n                inBraces = true;\n                break;\n            case '}':\n                inBraces = false;\n                break;\n            case '[':\n                inBrackets = true;\n                break;\n            case ']':\n                inBrackets = false;\n                break;\n        }\n        curVal += char;\n    }\n    // Tail\n    if (curVal) {\n        segments.push(curVal);\n    }\n    return segments;\n}\nexports.splitGlobAware = splitGlobAware;\nfunction parseRegExp(pattern) {\n    if (!pattern) {\n        return '';\n    }\n    var regEx = '';\n    // Split up into segments for each slash found\n    var segments = splitGlobAware(pattern, GLOB_SPLIT);\n    // Special case where we only have globstars\n    if (segments.every(function (s) { return s === GLOBSTAR; })) {\n        regEx = '.*';\n    }\n    // Build regex over segments\n    else {\n        var previousSegmentWasGlobStar_1 = false;\n        segments.forEach(function (segment, index) {\n            // Globstar is special\n            if (segment === GLOBSTAR) {\n                // if we have more than one globstar after another, just ignore it\n                if (!previousSegmentWasGlobStar_1) {\n                    regEx += starsToRegExp(2);\n                    previousSegmentWasGlobStar_1 = true;\n                }\n                return;\n            }\n            // States\n            var inBraces = false;\n            var braceVal = '';\n            var inBrackets = false;\n            var bracketVal = '';\n            for (var _i = 0, segment_1 = segment; _i < segment_1.length; _i++) {\n                var char = segment_1[_i];\n                // Support brace expansion\n                if (char !== '}' && inBraces) {\n                    braceVal += char;\n                    continue;\n                }\n                // Support brackets\n                if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n                    var res = void 0;\n                    // range operator\n                    if (char === '-') {\n                        res = char;\n                    }\n                    // negation operator (only valid on first index in bracket)\n                    else if ((char === '^' || char === '!') && !bracketVal) {\n                        res = '^';\n                    }\n                    // glob split matching is not allowed within character ranges\n                    // see http://man7.org/linux/man-pages/man7/glob.7.html\n                    else if (char === GLOB_SPLIT) {\n                        res = '';\n                    }\n                    // anything else gets escaped\n                    else {\n                        res = strings.escapeRegExpCharacters(char);\n                    }\n                    bracketVal += res;\n                    continue;\n                }\n                switch (char) {\n                    case '{':\n                        inBraces = true;\n                        continue;\n                    case '[':\n                        inBrackets = true;\n                        continue;\n                    case '}':\n                        var choices = splitGlobAware(braceVal, ',');\n                        // Converts {foo,bar} => [foo|bar]\n                        var braceRegExp = \"(?:\" + choices.map(function (c) { return parseRegExp(c); }).join('|') + \")\";\n                        regEx += braceRegExp;\n                        inBraces = false;\n                        braceVal = '';\n                        break;\n                    case ']':\n                        regEx += ('[' + bracketVal + ']');\n                        inBrackets = false;\n                        bracketVal = '';\n                        break;\n                    case '?':\n                        regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n                        continue;\n                    case '*':\n                        regEx += starsToRegExp(1);\n                        continue;\n                    default:\n                        regEx += strings.escapeRegExpCharacters(char);\n                }\n            }\n            // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n            // For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n            // a folder called \"something\" to match as well.\n            // However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n            // is to match 0-N segments.\n            if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n                regEx += PATH_REGEX;\n            }\n            // reset state\n            previousSegmentWasGlobStar_1 = false;\n        });\n    }\n    return regEx;\n}\n// regexes to check for trival glob patterns that just check for String#endsWith\nvar T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\nvar T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\nvar T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\nvar T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\nvar T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\nvar T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\nvar CACHE = new map_1.LRUCache(10000); // bounded to 10000 elements\nvar FALSE = function () {\n    return false;\n};\nvar NULL = function () {\n    return null;\n};\nfunction parsePattern(arg1, options) {\n    if (!arg1) {\n        return NULL;\n    }\n    // Handle IRelativePattern\n    var pattern;\n    if (typeof arg1 !== 'string') {\n        pattern = arg1.pattern;\n    }\n    else {\n        pattern = arg1;\n    }\n    // Whitespace trimming\n    pattern = pattern.trim();\n    // Check cache\n    var patternKey = pattern + \"_\" + !!options.trimForExclusions;\n    var parsedPattern = CACHE.get(patternKey);\n    if (parsedPattern) {\n        return wrapRelativePattern(parsedPattern, arg1);\n    }\n    // Check for Trivias\n    var match;\n    if (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check\n        var base_1 = pattern.substr(4); // '**/*'.length === 4\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && strings.endsWith(path, base_1) ? pattern : null;\n        };\n    }\n    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n        parsedPattern = trivia2(match[1], pattern);\n    }\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n        parsedPattern = trivia3(pattern, options);\n    }\n    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n    }\n    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n        parsedPattern = trivia4and5(match[1], pattern, false);\n    }\n    // Otherwise convert to pattern\n    else {\n        parsedPattern = toRegExp(pattern);\n    }\n    // Cache\n    CACHE.set(patternKey, parsedPattern);\n    return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n    if (typeof arg2 === 'string') {\n        return parsedPattern;\n    }\n    return function (path, basename) {\n        if (!extpath.isEqualOrParent(path, arg2.base)) {\n            return null;\n        }\n        return parsedPattern(paths.relative(arg2.base, path), basename);\n    };\n}\nfunction trimForExclusions(pattern, options) {\n    return options.trimForExclusions && strings.endsWith(pattern, '/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base, originalPattern) {\n    var slashBase = \"/\" + base;\n    var backslashBase = \"\\\\\" + base;\n    var parsedPattern = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (basename) {\n            return basename === base ? originalPattern : null;\n        }\n        return path === base || strings.endsWith(path, slashBase) || strings.endsWith(path, backslashBase) ? originalPattern : null;\n    };\n    var basenames = [base];\n    parsedPattern.basenames = basenames;\n    parsedPattern.patterns = [originalPattern];\n    parsedPattern.allBasenames = basenames;\n    return parsedPattern;\n}\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern, options) {\n    var parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')\n        .map(function (pattern) { return parsePattern(pattern, options); })\n        .filter(function (pattern) { return pattern !== NULL; }), pattern);\n    var n = parsedPatterns.length;\n    if (!n) {\n        return NULL;\n    }\n    if (n === 1) {\n        return parsedPatterns[0];\n    }\n    var parsedPattern = function (path, basename) {\n        for (var i = 0, n_1 = parsedPatterns.length; i < n_1; i++) {\n            if (parsedPatterns[i](path, basename)) {\n                return pattern;\n            }\n        }\n        return null;\n    };\n    var withBasenames = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });\n    if (withBasenames) {\n        parsedPattern.allBasenames = withBasenames.allBasenames;\n    }\n    var allPaths = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);\n    if (allPaths.length) {\n        parsedPattern.allPaths = allPaths;\n    }\n    return parsedPattern;\n}\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(path, pattern, matchPathEnds) {\n    var nativePath = paths.sep !== paths.posix.sep ? path.replace(ALL_FORWARD_SLASHES, paths.sep) : path;\n    var nativePathEnd = paths.sep + nativePath;\n    var parsedPattern = matchPathEnds ? function (path, basename) {\n        return typeof path === 'string' && (path === nativePath || strings.endsWith(path, nativePathEnd)) ? pattern : null;\n    } : function (path, basename) {\n        return typeof path === 'string' && path === nativePath ? pattern : null;\n    };\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];\n    return parsedPattern;\n}\nfunction toRegExp(pattern) {\n    try {\n        var regExp_1 = new RegExp(\"^\" + parseRegExp(pattern) + \"$\");\n        return function (path, basename) {\n            regExp_1.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n            return typeof path === 'string' && regExp_1.test(path) ? pattern : null;\n        };\n    }\n    catch (error) {\n        return NULL;\n    }\n}\nfunction match(arg1, path, hasSibling) {\n    if (!arg1 || typeof path !== 'string') {\n        return false;\n    }\n    return parse(arg1)(path, undefined, hasSibling);\n}\nexports.match = match;\nfunction parse(arg1, options) {\n    if (options === void 0) { options = {}; }\n    if (!arg1) {\n        return FALSE;\n    }\n    // Glob with String\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n        var parsedPattern_1 = parsePattern(arg1, options);\n        if (parsedPattern_1 === NULL) {\n            return FALSE;\n        }\n        var resultPattern = function (path, basename) {\n            return !!parsedPattern_1(path, basename);\n        };\n        if (parsedPattern_1.allBasenames) {\n            resultPattern.allBasenames = parsedPattern_1.allBasenames;\n        }\n        if (parsedPattern_1.allPaths) {\n            resultPattern.allPaths = parsedPattern_1.allPaths;\n        }\n        return resultPattern;\n    }\n    // Glob with Expression\n    return parsedExpression(arg1, options);\n}\nexports.parse = parse;\nfunction hasSiblingPromiseFn(siblingsFn) {\n    if (!siblingsFn) {\n        return undefined;\n    }\n    var siblings;\n    return function (name) {\n        if (!siblings) {\n            siblings = (siblingsFn() || Promise.resolve([]))\n                .then(function (list) { return list ? listToMap(list) : {}; });\n        }\n        return siblings.then(function (map) { return !!map[name]; });\n    };\n}\nexports.hasSiblingPromiseFn = hasSiblingPromiseFn;\nfunction hasSiblingFn(siblingsFn) {\n    if (!siblingsFn) {\n        return undefined;\n    }\n    var siblings;\n    return function (name) {\n        if (!siblings) {\n            var list = siblingsFn();\n            siblings = list ? listToMap(list) : {};\n        }\n        return !!siblings[name];\n    };\n}\nexports.hasSiblingFn = hasSiblingFn;\nfunction listToMap(list) {\n    var map = {};\n    for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {\n        var key = list_1[_i];\n        map[key] = true;\n    }\n    return map;\n}\nfunction isRelativePattern(obj) {\n    var rp = obj;\n    return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nexports.isRelativePattern = isRelativePattern;\n/**\n * Same as `parse`, but the ParsedExpression is guaranteed to return a Promise\n */\nfunction parseToAsync(expression, options) {\n    var parsedExpression = parse(expression, options);\n    return function (path, basename, hasSibling) {\n        var result = parsedExpression(path, basename, hasSibling);\n        return async_1.isThenable(result) ? result : Promise.resolve(result);\n    };\n}\nexports.parseToAsync = parseToAsync;\nfunction getBasenameTerms(patternOrExpression) {\n    return patternOrExpression.allBasenames || [];\n}\nexports.getBasenameTerms = getBasenameTerms;\nfunction getPathTerms(patternOrExpression) {\n    return patternOrExpression.allPaths || [];\n}\nexports.getPathTerms = getPathTerms;\nfunction parsedExpression(expression, options) {\n    var parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n        .map(function (pattern) { return parseExpressionPattern(pattern, expression[pattern], options); })\n        .filter(function (pattern) { return pattern !== NULL; }));\n    var n = parsedPatterns.length;\n    if (!n) {\n        return NULL;\n    }\n    if (!parsedPatterns.some(function (parsedPattern) { return !!parsedPattern.requiresSiblings; })) {\n        if (n === 1) {\n            return parsedPatterns[0];\n        }\n        var resultExpression_1 = function (path, basename) {\n            for (var i = 0, n_2 = parsedPatterns.length; i < n_2; i++) {\n                // Pattern matches path\n                var result = parsedPatterns[i](path, basename);\n                if (result) {\n                    return result;\n                }\n            }\n            return null;\n        };\n        var withBasenames_1 = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });\n        if (withBasenames_1) {\n            resultExpression_1.allBasenames = withBasenames_1.allBasenames;\n        }\n        var allPaths_1 = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);\n        if (allPaths_1.length) {\n            resultExpression_1.allPaths = allPaths_1;\n        }\n        return resultExpression_1;\n    }\n    var resultExpression = function (path, basename, hasSibling) {\n        var name = undefined;\n        for (var i = 0, n_3 = parsedPatterns.length; i < n_3; i++) {\n            // Pattern matches path\n            var parsedPattern = parsedPatterns[i];\n            if (parsedPattern.requiresSiblings && hasSibling) {\n                if (!basename) {\n                    basename = paths.basename(path);\n                }\n                if (!name) {\n                    name = basename.substr(0, basename.length - paths.extname(path).length);\n                }\n            }\n            var result = parsedPattern(path, basename, name, hasSibling);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    };\n    var withBasenames = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });\n    if (withBasenames) {\n        resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n    var allPaths = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);\n    if (allPaths.length) {\n        resultExpression.allPaths = allPaths;\n    }\n    return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n    if (value === false) {\n        return NULL; // pattern is disabled\n    }\n    var parsedPattern = parsePattern(pattern, options);\n    if (parsedPattern === NULL) {\n        return NULL;\n    }\n    // Expression Pattern is <boolean>\n    if (typeof value === 'boolean') {\n        return parsedPattern;\n    }\n    // Expression Pattern is <SiblingClause>\n    if (value) {\n        var when_1 = value.when;\n        if (typeof when_1 === 'string') {\n            var result = function (path, basename, name, hasSibling) {\n                if (!hasSibling || !parsedPattern(path, basename)) {\n                    return null;\n                }\n                var clausePattern = when_1.replace('$(basename)', name);\n                var matched = hasSibling(clausePattern);\n                return async_1.isThenable(matched) ?\n                    matched.then(function (m) { return m ? pattern : null; }) :\n                    matched ? pattern : null;\n            };\n            result.requiresSiblings = true;\n            return result;\n        }\n    }\n    // Expression is Anything\n    return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n    var basenamePatterns = parsedPatterns.filter(function (parsedPattern) { return !!parsedPattern.basenames; });\n    if (basenamePatterns.length < 2) {\n        return parsedPatterns;\n    }\n    var basenames = basenamePatterns.reduce(function (all, current) {\n        var basenames = current.basenames;\n        return basenames ? all.concat(basenames) : all;\n    }, []);\n    var patterns;\n    if (result) {\n        patterns = [];\n        for (var i = 0, n = basenames.length; i < n; i++) {\n            patterns.push(result);\n        }\n    }\n    else {\n        patterns = basenamePatterns.reduce(function (all, current) {\n            var patterns = current.patterns;\n            return patterns ? all.concat(patterns) : all;\n        }, []);\n    }\n    var aggregate = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (!basename) {\n            var i = void 0;\n            for (i = path.length; i > 0; i--) {\n                var ch = path.charCodeAt(i - 1);\n                if (ch === charCode_1.CharCode.Slash || ch === charCode_1.CharCode.Backslash) {\n                    break;\n                }\n            }\n            basename = path.substr(i);\n        }\n        var index = basenames.indexOf(basename);\n        return index !== -1 ? patterns[index] : null;\n    };\n    aggregate.basenames = basenames;\n    aggregate.patterns = patterns;\n    aggregate.allBasenames = basenames;\n    var aggregatedPatterns = parsedPatterns.filter(function (parsedPattern) { return !parsedPattern.basenames; });\n    aggregatedPatterns.push(aggregate);\n    return aggregatedPatterns;\n}\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/common/glob.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/common/glob.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from 'vs/base/common/arrays';\nimport * as strings from 'vs/base/common/strings';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as paths from 'vs/base/common/path';\nimport { LRUCache } from 'vs/base/common/map';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isThenable } from 'vs/base/common/async';\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause | any;\n}\n\nexport interface IRelativePattern {\n\tbase: string;\n\tpattern: string;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\nexport interface SiblingClause {\n\twhen: string;\n}\n\nconst GLOBSTAR = '**';\nconst GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(s => s === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Globstar is special\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (!previousSegmentWasGlobStar) {\n\t\t\t\t\tregEx += starsToRegExp(2);\n\t\t\t\t\tpreviousSegmentWasGlobStar = true;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// States\n\t\t\tlet inBraces = false;\n\t\t\tlet braceVal = '';\n\n\t\t\tlet inBrackets = false;\n\t\t\tlet bracketVal = '';\n\n\t\t\tfor (const char of segment) {\n\t\t\t\t// Support brace expansion\n\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\tbraceVal += char;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Support brackets\n\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t// range operator\n\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\tres = char;\n\t\t\t\t\t}\n\n\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\tres = '^';\n\t\t\t\t\t}\n\n\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t}\n\n\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\telse {\n\t\t\t\t\t\tres = strings.escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\n\t\t\t\t\tbracketVal += res;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tswitch (char) {\n\t\t\t\t\tcase '{':\n\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '}':\n\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(c => parseRegExp(c)).join('|')})`;\n\n\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tregEx += strings.escapeRegExpCharacters(char);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n\t\t\t// a folder called \"something\" to match as well.\n\t\t\t// However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n\t\t\t// is to match 0-N segments.\n\t\t\tif (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n\t\t\t\tregEx += PATH_REGEX;\n\t\t\t}\n\n\t\t\t// reset state\n\t\t\tpreviousSegmentWasGlobStar = false;\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trival glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t   \t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t   \t\t\t// **/something\nconst T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; \t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t   \t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t   \t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The ParsedExpression returns a Promise iff hasSibling returns a Promise.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\nexport interface IGlobOptions {\n\t/**\n\t * Simplify patterns for use as exclusion filters during tree traversal to skip entire subtrees. Cannot be used outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\ninterface ParsedExpressionPattern {\n\t(path: string, basename: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle IRelativePattern\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tconst patternKey = `${pattern}_${!!options.trimForExclusions}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1);\n\t}\n\n\t// Check for Trivias\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check\n\t\tconst base = pattern.substr(4); // '**/*'.length === 4\n\t\tparsedPattern = function (path, basename) {\n\t\t\treturn typeof path === 'string' && strings.endsWith(path, base) ? pattern : null;\n\t\t};\n\t} else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, options);\n\t} else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n\t} else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\treturn function (path, basename) {\n\t\tif (!extpath.isEqualOrParent(path, arg2.base)) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn parsedPattern(paths.relative(arg2.base, path), basename);\n\t};\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && strings.endsWith(pattern, '/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, originalPattern: string): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\tconst parsedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\t\tif (basename) {\n\t\t\treturn basename === base ? originalPattern : null;\n\t\t}\n\t\treturn path === base || strings.endsWith(path, slashBase) || strings.endsWith(path, backslashBase) ? originalPattern : null;\n\t};\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [originalPattern];\n\tparsedPattern.allBasenames = basenames;\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\tconst n = parsedPatterns.length;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\tif (n === 1) {\n\t\treturn <ParsedStringPattern>parsedPatterns[0];\n\t}\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif ((<ParsedStringPattern>parsedPatterns[i])(path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\tconst withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t}\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(path: string, pattern: string, matchPathEnds: boolean): ParsedStringPattern {\n\tconst nativePath = paths.sep !== paths.posix.sep ? path.replace(ALL_FORWARD_SLASHES, paths.sep) : path;\n\tconst nativePathEnd = paths.sep + nativePath;\n\tconst parsedPattern: ParsedStringPattern = matchPathEnds ? function (path, basename) {\n\t\treturn typeof path === 'string' && (path === nativePath || strings.endsWith(path, nativePathEnd)) ? pattern : null;\n\t} : function (path, basename) {\n\t\treturn typeof path === 'string' && path === nativePath ? pattern : null;\n\t};\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n\t\treturn function (path: string, basename: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch (error) {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function match(pattern: string | IRelativePattern, path: string): boolean;\nexport function match(expression: IExpression, path: string, hasSibling?: (name: string) => boolean): string /* the matching pattern */;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, hasSibling?: (name: string) => boolean): any {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(<IExpression>arg1)(path, undefined, hasSibling);\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): any {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1 as string | IRelativePattern, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\t\tconst resultPattern = function (path: string, basename: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\t\tif (parsedPattern.allBasenames) {\n\t\t\t(<ParsedStringPattern><any>resultPattern).allBasenames = parsedPattern.allBasenames;\n\t\t}\n\t\tif (parsedPattern.allPaths) {\n\t\t\t(<ParsedStringPattern><any>resultPattern).allPaths = parsedPattern.allPaths;\n\t\t}\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(<IExpression>arg1, options);\n}\n\nexport function hasSiblingPromiseFn(siblingsFn?: () => Promise<string[]>) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Promise<Record<string, true>>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tsiblings = (siblingsFn() || Promise.resolve([]))\n\t\t\t\t.then(list => list ? listToMap(list) : {});\n\t\t}\n\t\treturn siblings.then(map => !!map[name]);\n\t};\n}\n\nexport function hasSiblingFn(siblingsFn?: () => string[]) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Record<string, true>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tconst list = siblingsFn();\n\t\t\tsiblings = list ? listToMap(list) : {};\n\t\t}\n\t\treturn !!siblings[name];\n\t};\n}\n\nfunction listToMap(list: string[]) {\n\tconst map: Record<string, true> = {};\n\tfor (const key of list) {\n\t\tmap[key] = true;\n\t}\n\treturn map;\n}\n\nexport function isRelativePattern(obj: any): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern;\n\n\treturn rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\n/**\n * Same as `parse`, but the ParsedExpression is guaranteed to return a Promise\n */\nexport function parseToAsync(expression: IExpression, options?: IGlobOptions): ParsedExpression {\n\tconst parsedExpression = parse(expression, options);\n\treturn (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> => {\n\t\tconst result = parsedExpression(path, basename, hasSibling);\n\t\treturn isThenable(result) ? result : Promise.resolve(result);\n\t};\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst n = parsedPatterns.length;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (n === 1) {\n\t\t\treturn <ParsedStringPattern>parsedPatterns[0];\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename: string) {\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\t// Pattern matches path\n\t\t\t\tconst result = (<ParsedStringPattern>parsedPatterns[i])(path, basename);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, basename: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!basename) {\n\t\t\t\t\tbasename = paths.basename(path);\n\t\t\t\t}\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = basename.substr(0, basename.length - paths.extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst result = parsedPattern(path, basename, name, hasSibling);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: any, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = (<SiblingClause>value).when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename: string, name: string, hasSibling: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', name);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(m => m ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\t\t\tresult.requiresSiblings = true;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is Anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, <string[]>[]);\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, <string[]>[]);\n\t}\n\tconst aggregate: ParsedStringPattern = function (path, basename) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbasename = path.substr(i);\n\t\t}\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\treturn aggregatedPatterns;\n}\n"]}]}