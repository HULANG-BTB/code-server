{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostTask.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostTask.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/path\", \"vs/base/common/uri\", \"vs/base/common/objects\", \"vs/base/common/async\", \"vs/base/common/event\", \"vs/base/node/processes\", \"vs/workbench/api/common/extHost.protocol\", \"vs/workbench/api/node/extHostTypes\", \"vs/workbench/api/node/extHostDebugService\", \"vs/workbench/api/node/extHostTerminalService\", \"vs/base/common/cancellation\", \"vs/base/common/lifecycle\"], function (require, exports, path, uri_1, Objects, async_1, event_1, processes_1, extHost_protocol_1, types, extHostDebugService_1, extHostTerminalService_1, cancellation_1, lifecycle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var TaskDefinitionDTO;\n    (function (TaskDefinitionDTO) {\n        function from(value) {\n            if (value === undefined || value === null) {\n                return undefined;\n            }\n            return value;\n        }\n        TaskDefinitionDTO.from = from;\n        function to(value) {\n            if (value === undefined || value === null) {\n                return undefined;\n            }\n            return value;\n        }\n        TaskDefinitionDTO.to = to;\n    })(TaskDefinitionDTO || (TaskDefinitionDTO = {}));\n    var TaskPresentationOptionsDTO;\n    (function (TaskPresentationOptionsDTO) {\n        function from(value) {\n            if (value === undefined || value === null) {\n                return undefined;\n            }\n            return value;\n        }\n        TaskPresentationOptionsDTO.from = from;\n        function to(value) {\n            if (value === undefined || value === null) {\n                return undefined;\n            }\n            return value;\n        }\n        TaskPresentationOptionsDTO.to = to;\n    })(TaskPresentationOptionsDTO || (TaskPresentationOptionsDTO = {}));\n    var ProcessExecutionOptionsDTO;\n    (function (ProcessExecutionOptionsDTO) {\n        function from(value) {\n            if (value === undefined || value === null) {\n                return undefined;\n            }\n            return value;\n        }\n        ProcessExecutionOptionsDTO.from = from;\n        function to(value) {\n            if (value === undefined || value === null) {\n                return undefined;\n            }\n            return value;\n        }\n        ProcessExecutionOptionsDTO.to = to;\n    })(ProcessExecutionOptionsDTO || (ProcessExecutionOptionsDTO = {}));\n    var ProcessExecutionDTO;\n    (function (ProcessExecutionDTO) {\n        function is(value) {\n            if (value) {\n                const candidate = value;\n                return candidate && !!candidate.process;\n            }\n            else {\n                return false;\n            }\n        }\n        ProcessExecutionDTO.is = is;\n        function from(value) {\n            if (value === undefined || value === null) {\n                return undefined;\n            }\n            const result = {\n                process: value.process,\n                args: value.args\n            };\n            if (value.options) {\n                result.options = ProcessExecutionOptionsDTO.from(value.options);\n            }\n            return result;\n        }\n        ProcessExecutionDTO.from = from;\n        function to(value) {\n            if (value === undefined || value === null) {\n                return undefined;\n            }\n            return new types.ProcessExecution(value.process, value.args, value.options);\n        }\n        ProcessExecutionDTO.to = to;\n    })(ProcessExecutionDTO || (ProcessExecutionDTO = {}));\n    var ShellExecutionOptionsDTO;\n    (function (ShellExecutionOptionsDTO) {\n        function from(value) {\n            if (value === undefined || value === null) {\n                return undefined;\n            }\n            return value;\n        }\n        ShellExecutionOptionsDTO.from = from;\n        function to(value) {\n            if (value === undefined || value === null) {\n                return undefined;\n            }\n            return value;\n        }\n        ShellExecutionOptionsDTO.to = to;\n    })(ShellExecutionOptionsDTO || (ShellExecutionOptionsDTO = {}));\n    var ShellExecutionDTO;\n    (function (ShellExecutionDTO) {\n        function is(value) {\n            if (value) {\n                const candidate = value;\n                return candidate && (!!candidate.commandLine || !!candidate.command);\n            }\n            else {\n                return false;\n            }\n        }\n        ShellExecutionDTO.is = is;\n        function from(value) {\n            if (value === undefined || value === null) {\n                return undefined;\n            }\n            const result = {};\n            if (value.commandLine !== undefined) {\n                result.commandLine = value.commandLine;\n            }\n            else {\n                result.command = value.command;\n                result.args = value.args;\n            }\n            if (value.options) {\n                result.options = ShellExecutionOptionsDTO.from(value.options);\n            }\n            return result;\n        }\n        ShellExecutionDTO.from = from;\n        function to(value) {\n            if (value === undefined || value === null || (value.command === undefined && value.commandLine === undefined)) {\n                return undefined;\n            }\n            if (value.commandLine) {\n                return new types.ShellExecution(value.commandLine, value.options);\n            }\n            else {\n                return new types.ShellExecution(value.command, value.args ? value.args : [], value.options);\n            }\n        }\n        ShellExecutionDTO.to = to;\n    })(ShellExecutionDTO || (ShellExecutionDTO = {}));\n    var CustomExecutionDTO;\n    (function (CustomExecutionDTO) {\n        function is(value) {\n            if (value) {\n                let candidate = value;\n                return candidate && candidate.customExecution === 'customExecution';\n            }\n            else {\n                return false;\n            }\n        }\n        CustomExecutionDTO.is = is;\n        function from(value) {\n            return {\n                customExecution: 'customExecution'\n            };\n        }\n        CustomExecutionDTO.from = from;\n    })(CustomExecutionDTO || (CustomExecutionDTO = {}));\n    var TaskHandleDTO;\n    (function (TaskHandleDTO) {\n        function from(value) {\n            let folder;\n            if (value.scope !== undefined && typeof value.scope !== 'number') {\n                folder = value.scope.uri;\n            }\n            return {\n                id: value._id,\n                workspaceFolder: folder\n            };\n        }\n        TaskHandleDTO.from = from;\n    })(TaskHandleDTO || (TaskHandleDTO = {}));\n    var TaskDTO;\n    (function (TaskDTO) {\n        function fromMany(tasks, extension) {\n            if (tasks === undefined || tasks === null) {\n                return [];\n            }\n            const result = [];\n            for (let task of tasks) {\n                const converted = from(task, extension);\n                if (converted) {\n                    result.push(converted);\n                }\n            }\n            return result;\n        }\n        TaskDTO.fromMany = fromMany;\n        function from(value, extension) {\n            if (value === undefined || value === null) {\n                return undefined;\n            }\n            let execution;\n            if (value.execution instanceof types.ProcessExecution) {\n                execution = ProcessExecutionDTO.from(value.execution);\n            }\n            else if (value.execution instanceof types.ShellExecution) {\n                execution = ShellExecutionDTO.from(value.execution);\n            }\n            else if (value.execution2 && value.execution2 instanceof types.CustomExecution) {\n                execution = CustomExecutionDTO.from(value.execution2);\n            }\n            const definition = TaskDefinitionDTO.from(value.definition);\n            let scope;\n            if (value.scope) {\n                if (typeof value.scope === 'number') {\n                    scope = value.scope;\n                }\n                else {\n                    scope = value.scope.uri;\n                }\n            }\n            else {\n                // To continue to support the deprecated task constructor that doesn't take a scope, we must add a scope here:\n                scope = types.TaskScope.Workspace;\n            }\n            if (!definition || !scope) {\n                return undefined;\n            }\n            const group = value.group ? value.group.id : undefined;\n            const result = {\n                _id: value._id,\n                definition,\n                name: value.name,\n                source: {\n                    extensionId: extension.identifier.value,\n                    label: value.source,\n                    scope: scope\n                },\n                execution: execution,\n                isBackground: value.isBackground,\n                group: group,\n                presentationOptions: TaskPresentationOptionsDTO.from(value.presentationOptions),\n                problemMatchers: value.problemMatchers,\n                hasDefinedMatchers: value.hasDefinedMatchers,\n                runOptions: value.runOptions ? value.runOptions : { reevaluateOnRerun: true },\n            };\n            return result;\n        }\n        TaskDTO.from = from;\n        function to(value, workspace) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (value === undefined || value === null) {\n                    return undefined;\n                }\n                let execution;\n                if (ProcessExecutionDTO.is(value.execution)) {\n                    execution = ProcessExecutionDTO.to(value.execution);\n                }\n                else if (ShellExecutionDTO.is(value.execution)) {\n                    execution = ShellExecutionDTO.to(value.execution);\n                }\n                const definition = TaskDefinitionDTO.to(value.definition);\n                let scope;\n                if (value.source) {\n                    if (value.source.scope !== undefined) {\n                        if (typeof value.source.scope === 'number') {\n                            scope = value.source.scope;\n                        }\n                        else {\n                            scope = yield workspace.resolveWorkspaceFolder(uri_1.URI.revive(value.source.scope));\n                        }\n                    }\n                    else {\n                        scope = types.TaskScope.Workspace;\n                    }\n                }\n                if (!definition || !scope) {\n                    return undefined;\n                }\n                const result = new types.Task(definition, scope, value.name, value.source.label, execution, value.problemMatchers);\n                if (value.isBackground !== undefined) {\n                    result.isBackground = value.isBackground;\n                }\n                if (value.group !== undefined) {\n                    result.group = types.TaskGroup.from(value.group);\n                }\n                if (value.presentationOptions) {\n                    result.presentationOptions = TaskPresentationOptionsDTO.to(value.presentationOptions);\n                }\n                if (value._id) {\n                    result._id = value._id;\n                }\n                return result;\n            });\n        }\n        TaskDTO.to = to;\n    })(TaskDTO || (TaskDTO = {}));\n    var TaskFilterDTO;\n    (function (TaskFilterDTO) {\n        function from(value) {\n            return value;\n        }\n        TaskFilterDTO.from = from;\n        function to(value) {\n            if (!value) {\n                return undefined;\n            }\n            return Objects.assign(Object.create(null), value);\n        }\n        TaskFilterDTO.to = to;\n    })(TaskFilterDTO || (TaskFilterDTO = {}));\n    class TaskExecutionImpl {\n        constructor(_tasks, _id, _task) {\n            this._tasks = _tasks;\n            this._id = _id;\n            this._task = _task;\n        }\n        get task() {\n            return this._task;\n        }\n        terminate() {\n            this._tasks.terminateTask(this);\n        }\n        fireDidStartProcess(value) {\n        }\n        fireDidEndProcess(value) {\n        }\n    }\n    var TaskExecutionDTO;\n    (function (TaskExecutionDTO) {\n        function to(value, tasks, workspaceProvider) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const task = yield TaskDTO.to(value.task, workspaceProvider);\n                if (!task) {\n                    throw new Error('Unexpected: Task cannot be created.');\n                }\n                return new TaskExecutionImpl(tasks, value.id, task);\n            });\n        }\n        TaskExecutionDTO.to = to;\n        function from(value) {\n            return {\n                id: value._id,\n                task: undefined\n            };\n        }\n        TaskExecutionDTO.from = from;\n    })(TaskExecutionDTO || (TaskExecutionDTO = {}));\n    class CustomExecutionData {\n        constructor(customExecution, terminalService) {\n            this.customExecution = customExecution;\n            this.terminalService = terminalService;\n            this._onTaskExecutionComplete = new event_1.Emitter();\n            this._disposables = [];\n        }\n        dispose() {\n            this._cancellationSource = undefined;\n            lifecycle_1.dispose(this._disposables);\n        }\n        get onTaskExecutionComplete() {\n            return this._onTaskExecutionComplete.event;\n        }\n        onDidCloseTerminal(terminal) {\n            if ((this.terminal === terminal) && this._cancellationSource) {\n                this._cancellationSource.cancel();\n            }\n        }\n        onDidOpenTerminal(terminal) {\n            if (!(terminal instanceof extHostTerminalService_1.ExtHostTerminal)) {\n                throw new Error('How could this not be a extension host terminal?');\n            }\n            if (this.terminalId && terminal._id === this.terminalId) {\n                this.startCallback(this.terminalId);\n            }\n        }\n        startCallback(terminalId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                this.terminalId = terminalId;\n                // If we have already started the extension task callback, then\n                // do not start it again.\n                // It is completely valid for multiple terminals to be opened\n                // before the one for our task.\n                if (this._cancellationSource) {\n                    return undefined;\n                }\n                const callbackTerminals = this.terminalService.terminals.filter((terminal) => terminal._id === terminalId);\n                if (!callbackTerminals || callbackTerminals.length === 0) {\n                    this._disposables.push(this.terminalService.onDidOpenTerminal(this.onDidOpenTerminal.bind(this)));\n                    return;\n                }\n                if (callbackTerminals.length !== 1) {\n                    throw new Error(`Expected to only have one terminal at this point`);\n                }\n                this.terminal = callbackTerminals[0];\n                const terminalRenderer = yield this.terminalService.resolveTerminalRenderer(terminalId);\n                // If we don't have the maximum dimensions yet, then we need to wait for them (but not indefinitely).\n                // Custom executions will expect the dimensions to be set properly before they are launched.\n                // BUT, due to the API contract VSCode has for terminals and dimensions, they are still responsible for\n                // handling cases where they are not set.\n                if (!terminalRenderer.maximumDimensions) {\n                    const dimensionTimeout = new Promise((resolve) => {\n                        setTimeout(() => {\n                            resolve();\n                        }, CustomExecutionData.waitForDimensionsTimeoutInMs);\n                    });\n                    let dimensionsRegistration;\n                    const dimensionsPromise = new Promise((resolve) => {\n                        dimensionsRegistration = terminalRenderer.onDidChangeMaximumDimensions((newDimensions) => {\n                            resolve();\n                        });\n                    });\n                    yield Promise.race([dimensionTimeout, dimensionsPromise]);\n                    if (dimensionsRegistration) {\n                        dimensionsRegistration.dispose();\n                    }\n                }\n                this._cancellationSource = new cancellation_1.CancellationTokenSource();\n                this._disposables.push(this._cancellationSource);\n                this._disposables.push(this.terminalService.onDidCloseTerminal(this.onDidCloseTerminal.bind(this)));\n                // Regardless of how the task completes, we are done with this custom execution task.\n                this.customExecution.callback(terminalRenderer, this._cancellationSource.token).then((success) => {\n                    this.result = success;\n                    this._onTaskExecutionComplete.fire(this);\n                }, (rejected) => {\n                    this._onTaskExecutionComplete.fire(this);\n                });\n            });\n        }\n    }\n    CustomExecutionData.waitForDimensionsTimeoutInMs = 5000;\n    class ExtHostTask {\n        constructor(mainContext, workspaceService, editorService, configurationService, extHostTerminalService) {\n            this._onDidExecuteTask = new event_1.Emitter();\n            this._onDidTerminateTask = new event_1.Emitter();\n            this._onDidTaskProcessStarted = new event_1.Emitter();\n            this._onDidTaskProcessEnded = new event_1.Emitter();\n            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadTask);\n            this._workspaceProvider = workspaceService;\n            this._editorService = editorService;\n            this._configurationService = configurationService;\n            this._terminalService = extHostTerminalService;\n            this._handleCounter = 0;\n            this._handlers = new Map();\n            this._taskExecutions = new Map();\n            this._providedCustomExecutions = new Map();\n            this._activeCustomExecutions = new Map();\n        }\n        registerTaskProvider(extension, provider) {\n            if (!provider) {\n                return new types.Disposable(() => { });\n            }\n            const handle = this.nextHandle();\n            this._handlers.set(handle, { provider, extension });\n            this._proxy.$registerTaskProvider(handle);\n            return new types.Disposable(() => {\n                this._handlers.delete(handle);\n                this._proxy.$unregisterTaskProvider(handle);\n            });\n        }\n        registerTaskSystem(scheme, info) {\n            this._proxy.$registerTaskSystem(scheme, info);\n        }\n        fetchTasks(filter) {\n            return this._proxy.$fetchTasks(TaskFilterDTO.from(filter)).then((values) => __awaiter(this, void 0, void 0, function* () {\n                const result = [];\n                for (let value of values) {\n                    const task = yield TaskDTO.to(value, this._workspaceProvider);\n                    if (task) {\n                        result.push(task);\n                    }\n                }\n                return result;\n            }));\n        }\n        executeTask(extension, task) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const tTask = task;\n                // We have a preserved ID. So the task didn't change.\n                if (tTask._id !== undefined) {\n                    return this._proxy.$executeTask(TaskHandleDTO.from(tTask)).then(value => this.getTaskExecution(value, task));\n                }\n                else {\n                    const dto = TaskDTO.from(task, extension);\n                    if (dto === undefined) {\n                        return Promise.reject(new Error('Task is not valid'));\n                    }\n                    return this._proxy.$executeTask(dto).then(value => this.getTaskExecution(value, task));\n                }\n            });\n        }\n        get taskExecutions() {\n            const result = [];\n            this._taskExecutions.forEach(value => result.push(value));\n            return result;\n        }\n        terminateTask(execution) {\n            if (!(execution instanceof TaskExecutionImpl)) {\n                throw new Error('No valid task execution provided');\n            }\n            return this._proxy.$terminateTask(execution._id);\n        }\n        get onDidStartTask() {\n            return this._onDidExecuteTask.event;\n        }\n        $onDidStartTask(execution, terminalId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // Once a terminal is spun up for the custom execution task this event will be fired.\n                // At that point, we need to actually start the callback, but\n                // only if it hasn't already begun.\n                const extensionCallback = this._providedCustomExecutions.get(execution.id);\n                if (extensionCallback) {\n                    if (this._activeCustomExecutions.get(execution.id) !== undefined) {\n                        throw new Error('We should not be trying to start the same custom task executions twice.');\n                    }\n                    this._activeCustomExecutions.set(execution.id, extensionCallback);\n                    const taskExecutionComplete = extensionCallback.onTaskExecutionComplete(() => {\n                        this.customExecutionComplete(execution);\n                        taskExecutionComplete.dispose();\n                    });\n                    extensionCallback.startCallback(terminalId);\n                }\n                this._onDidExecuteTask.fire({\n                    execution: yield this.getTaskExecution(execution)\n                });\n            });\n        }\n        get onDidEndTask() {\n            return this._onDidTerminateTask.event;\n        }\n        $OnDidEndTask(execution) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const _execution = yield this.getTaskExecution(execution);\n                this._taskExecutions.delete(execution.id);\n                this.customExecutionComplete(execution);\n                this._onDidTerminateTask.fire({\n                    execution: _execution\n                });\n            });\n        }\n        get onDidStartTaskProcess() {\n            return this._onDidTaskProcessStarted.event;\n        }\n        $onDidStartTaskProcess(value) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const execution = yield this.getTaskExecution(value.id);\n                if (execution) {\n                    this._onDidTaskProcessStarted.fire({\n                        execution: execution,\n                        processId: value.processId\n                    });\n                }\n            });\n        }\n        get onDidEndTaskProcess() {\n            return this._onDidTaskProcessEnded.event;\n        }\n        $onDidEndTaskProcess(value) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const execution = yield this.getTaskExecution(value.id);\n                if (execution) {\n                    this._onDidTaskProcessEnded.fire({\n                        execution: execution,\n                        exitCode: value.exitCode\n                    });\n                }\n            });\n        }\n        $provideTasks(handle, validTypes) {\n            const handler = this._handlers.get(handle);\n            if (!handler) {\n                return Promise.reject(new Error('no handler found'));\n            }\n            // For custom execution tasks, we need to store the execution objects locally\n            // since we obviously cannot send callback functions through the proxy.\n            // So, clear out any existing ones.\n            this._providedCustomExecutions.clear();\n            // Set up a list of task ID promises that we can wait on\n            // before returning the provided tasks. The ensures that\n            // our task IDs are calculated for any custom execution tasks.\n            // Knowing this ID ahead of time is needed because when a task\n            // start event is fired this is when the custom execution is called.\n            // The task start event is also the first time we see the ID from the main\n            // thread, which is too late for us because we need to save an map\n            // from an ID to the custom execution function. (Kind of a cart before the horse problem).\n            const taskIdPromises = [];\n            const fetchPromise = async_1.asPromise(() => handler.provider.provideTasks(cancellation_1.CancellationToken.None)).then(value => {\n                const taskDTOs = [];\n                if (value) {\n                    for (let task of value) {\n                        if (!task.definition || !validTypes[task.definition.type]) {\n                            console.warn(`The task [${task.source}, ${task.name}] uses an undefined task type. The task will be ignored in the future.`);\n                        }\n                        const taskDTO = TaskDTO.from(task, handler.extension);\n                        if (taskDTO) {\n                            taskDTOs.push(taskDTO);\n                            if (CustomExecutionDTO.is(taskDTO.execution)) {\n                                taskIdPromises.push(new Promise((resolve) => {\n                                    // The ID is calculated on the main thread task side, so, let's call into it here.\n                                    // We need the task id's pre-computed for custom task executions because when OnDidStartTask\n                                    // is invoked, we have to be able to map it back to our data.\n                                    this._proxy.$createTaskId(taskDTO).then((taskId) => {\n                                        this._providedCustomExecutions.set(taskId, new CustomExecutionData(task.execution2, this._terminalService));\n                                        resolve();\n                                    });\n                                }));\n                            }\n                        }\n                    }\n                }\n                return {\n                    tasks: taskDTOs,\n                    extension: handler.extension\n                };\n            });\n            return new Promise((resolve) => {\n                fetchPromise.then((result) => {\n                    Promise.all(taskIdPromises).then(() => {\n                        resolve(result);\n                    });\n                });\n            });\n        }\n        $resolveVariables(uriComponents, toResolve) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const configProvider = yield this._configurationService.getConfigProvider();\n                const uri = uri_1.URI.revive(uriComponents);\n                const result = {\n                    process: undefined,\n                    variables: Object.create(null)\n                };\n                const workspaceFolder = yield this._workspaceProvider.resolveWorkspaceFolder(uri);\n                const workspaceFolders = yield this._workspaceProvider.getWorkspaceFolders2();\n                if (!workspaceFolders || !workspaceFolder) {\n                    throw new Error('Unexpected: Tasks can only be run in a workspace folder');\n                }\n                const resolver = new extHostDebugService_1.ExtHostVariableResolverService(workspaceFolders, this._editorService, configProvider);\n                const ws = {\n                    uri: workspaceFolder.uri,\n                    name: workspaceFolder.name,\n                    index: workspaceFolder.index,\n                    toResource: () => {\n                        throw new Error('Not implemented');\n                    }\n                };\n                for (let variable of toResolve.variables) {\n                    result.variables[variable] = resolver.resolve(ws, variable);\n                }\n                if (toResolve.process !== undefined) {\n                    let paths = undefined;\n                    if (toResolve.process.path !== undefined) {\n                        paths = toResolve.process.path.split(path.delimiter);\n                        for (let i = 0; i < paths.length; i++) {\n                            paths[i] = resolver.resolve(ws, paths[i]);\n                        }\n                    }\n                    result.process = processes_1.win32.findExecutable(resolver.resolve(ws, toResolve.process.name), toResolve.process.cwd !== undefined ? resolver.resolve(ws, toResolve.process.cwd) : undefined, paths);\n                }\n                return result;\n            });\n        }\n        nextHandle() {\n            return this._handleCounter++;\n        }\n        getTaskExecution(execution, task) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (typeof execution === 'string') {\n                    const taskExecution = this._taskExecutions.get(execution);\n                    if (!taskExecution) {\n                        throw new Error('Unexpected: The specified task is missing an execution');\n                    }\n                    return taskExecution;\n                }\n                let result = this._taskExecutions.get(execution.id);\n                if (result) {\n                    return result;\n                }\n                const taskToCreate = task ? task : yield TaskDTO.to(execution.task, this._workspaceProvider);\n                if (!taskToCreate) {\n                    throw new Error('Unexpected: Task does not exist.');\n                }\n                const createdResult = new TaskExecutionImpl(this, execution.id, taskToCreate);\n                this._taskExecutions.set(execution.id, createdResult);\n                return createdResult;\n            });\n        }\n        customExecutionComplete(execution) {\n            const extensionCallback = this._activeCustomExecutions.get(execution.id);\n            if (extensionCallback) {\n                this._activeCustomExecutions.delete(execution.id);\n                this._proxy.$customExecutionComplete(execution.id, extensionCallback.result);\n                extensionCallback.dispose();\n            }\n        }\n    }\n    exports.ExtHostTask = ExtHostTask;\n});\n",null]}