{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true}!/home/coding/workspace/packages/ide/src/retry.ts","dependencies":[{"path":"/home/coding/workspace/packages/ide/src/retry.ts","mtime":1555841535682},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst logger_1 = require(\"@coder/logger\");\nconst notification_1 = require(\"./fill/notification\");\n/**\n * Retry services. Handles multiple services so when a connection drops the\n * user doesn't get a separate notification for each service.\n *\n * Attempts to restart services silently up to a maximum number of tries, then\n * starts waiting for a delay that grows exponentially with each attempt with a\n * cap on the delay. Once the delay is long enough, it will show a notification\n * to the user explaining what is happening with an option to immediately retry.\n */\nclass Retry {\n    constructor(_notificationService) {\n        this._notificationService = _notificationService;\n        this.items = new Map();\n        // Times are in seconds.\n        this.retryMinDelay = 1;\n        this.retryMaxDelay = 3;\n        this.maxImmediateRetries = 5;\n        this.retryExponent = 1.5;\n        this.updateDelay = 1;\n        this.notificationThreshold = 3;\n        // Time in milliseconds to wait before restarting a service. (See usage below\n        // for reasoning.)\n        this.waitDelay = 50;\n    }\n    set notificationService(service) {\n        this._notificationService = service;\n    }\n    get notificationService() {\n        return this._notificationService;\n    }\n    /**\n     * Register a function to retry that starts/connects to a service.\n     */\n    register(name, fn) {\n        if (this.items.has(name)) {\n            throw new Error(`\"${name}\" is already registered`);\n        }\n        this.items.set(name, { fn });\n        return {\n            block: () => this.block(name),\n            run: (error) => this.run(name, error),\n            recover: () => this.recover(name),\n        };\n    }\n    /**\n     * Un-register a function to retry.\n     */\n    unregister(name) {\n        if (!this.items.has(name)) {\n            throw new Error(`\"${name}\" is not registered`);\n        }\n        this.items.delete(name);\n    }\n    /**\n     * Block retries when we know they will fail (for example when the socket is\n     * down ). If a name is passed, that service will still be allowed to retry\n     * (unless we have already blocked).\n     *\n     * Blocking without a name will override a block with a name.\n     */\n    block(name) {\n        if (!this.blocked || !name) {\n            this.blocked = name || true;\n            this.items.forEach((item) => {\n                this.stopItem(item);\n            });\n        }\n    }\n    /**\n     * Unblock retries and run any that are pending.\n     */\n    unblock() {\n        this.blocked = false;\n        this.items.forEach((item, name) => {\n            if (item.running) {\n                this.runItem(name, item);\n            }\n        });\n    }\n    /**\n     * Retry a service.\n     */\n    run(name, error) {\n        if (!this.items.has(name)) {\n            throw new Error(`\"${name}\" is not registered`);\n        }\n        const item = this.items.get(name);\n        if (item.running) {\n            throw new Error(`\"${name}\" is already retrying`);\n        }\n        item.running = true;\n        // This timeout is for the case when the connection drops; this allows time\n        // for the socket service to come in and block everything because some other\n        // services might make it here first and try to restart, which will fail.\n        setTimeout(() => {\n            if (this.blocked && this.blocked !== name) {\n                return;\n            }\n            if (!item.count || item.count < this.maxImmediateRetries) {\n                return this.runItem(name, item, error);\n            }\n            if (!item.delay) {\n                item.delay = this.retryMinDelay;\n            }\n            else {\n                item.delay = Math.ceil(item.delay * this.retryExponent);\n                if (item.delay > this.retryMaxDelay) {\n                    item.delay = this.retryMaxDelay;\n                }\n            }\n            logger_1.logger.info(`Retrying ${name.toLowerCase()} in ${item.delay}s`, error && logger_1.field(\"error\", error.message));\n            const itemDelayMs = item.delay * 1000;\n            item.end = Date.now() + itemDelayMs;\n            item.timeout = setTimeout(() => this.runItem(name, item, error), itemDelayMs);\n            this.updateNotification();\n        }, this.waitDelay);\n    }\n    /**\n     * Reset a service after a successfully recovering.\n     */\n    recover(name) {\n        if (!this.items.has(name)) {\n            throw new Error(`\"${name}\" is not registered`);\n        }\n        const item = this.items.get(name);\n        if (typeof item.timeout === \"undefined\" && !item.running && typeof item.count !== \"undefined\") {\n            logger_1.logger.info(`Connected to ${name.toLowerCase()}`);\n            item.delay = undefined;\n            item.count = undefined;\n        }\n    }\n    /**\n     * Run an item.\n     */\n    runItem(name, item, error) {\n        if (!item.count) {\n            item.count = 1;\n        }\n        else {\n            ++item.count;\n        }\n        const retryCountText = item.count <= this.maxImmediateRetries\n            ? `[${item.count}/${this.maxImmediateRetries}]`\n            : `[${item.count}]`;\n        logger_1.logger.info(`Starting ${name.toLowerCase()} ${retryCountText}...`, error && logger_1.field(\"error\", error.message));\n        const endItem = () => {\n            this.stopItem(item);\n            item.running = false;\n        };\n        try {\n            const maybePromise = item.fn();\n            if (maybePromise instanceof Promise) {\n                maybePromise.then(() => {\n                    endItem();\n                    this.recover(name);\n                    if (this.blocked === name) {\n                        this.unblock();\n                    }\n                }).catch((error) => {\n                    endItem();\n                    this.run(name, error);\n                });\n            }\n            else {\n                endItem();\n            }\n        }\n        catch (error) {\n            // Prevent an exception from causing the item to never run again.\n            endItem();\n            throw error;\n        }\n    }\n    /**\n     * Update, close, or show the notification.\n     */\n    updateNotification() {\n        // tslint:disable-next-line no-any because NodeJS.Timer is valid.\n        clearTimeout(this.updateTimeout);\n        const now = Date.now();\n        const items = Array.from(this.items.entries()).filter(([_, item]) => {\n            return typeof item.end !== \"undefined\"\n                && item.end > now\n                && item.delay && item.delay >= this.notificationThreshold;\n        }).sort((a, b) => {\n            return a[1] < b[1] ? -1 : 1;\n        });\n        if (items.length === 0) {\n            if (this.notificationHandle) {\n                this.notificationHandle.close();\n                this.notificationHandle = undefined;\n            }\n            return;\n        }\n        const join = (arr) => {\n            const last = arr.pop(); // Assume length > 0.\n            return arr.length > 0 ? `${arr.join(\", \")} and ${last}` : last;\n        };\n        const servicesStr = join(items.map(([name, _]) => name.toLowerCase()));\n        const message = `Lost connection to ${servicesStr}. Retrying in ${join(items.map(([_, item]) => `${Math.ceil((item.end - now) / 1000)}s`))}.`;\n        const buttons = [{\n                label: `Retry ${items.length > 1 ? \"Services\" : items[0][0]} Now`,\n                run: () => {\n                    logger_1.logger.info(`Forcing ${servicesStr} to restart now`);\n                    items.forEach(([name, item]) => {\n                        this.runItem(name, item);\n                    });\n                    this.updateNotification();\n                },\n            }];\n        if (!this.notificationHandle) {\n            this.notificationHandle = this.notificationService.prompt(notification_1.Severity.Info, message, buttons, () => {\n                this.notificationHandle = undefined;\n                // tslint:disable-next-line no-any because NodeJS.Timer is valid.\n                clearTimeout(this.updateTimeout);\n            });\n        }\n        else {\n            this.notificationHandle.updateMessage(message);\n            this.notificationHandle.updateButtons(buttons);\n        }\n        this.updateTimeout = setTimeout(() => this.updateNotification(), this.updateDelay * 1000);\n    }\n    /**\n     * Stop an item's timer.\n     */\n    stopItem(item) {\n        // tslint:disable-next-line no-any because NodeJS.Timer is valid.\n        clearTimeout(item.timeout);\n        item.timeout = undefined;\n        item.end = undefined;\n    }\n}\nexports.Retry = Retry;\n// Global instance so we can block other retries when retrying the main\n// connection.\nexports.retry = new Retry(new notification_1.NotificationService());\n",{"version":3,"file":"/home/coding/workspace/packages/ide/src/retry.ts","sourceRoot":"","sources":["/home/coding/workspace/packages/ide/src/retry.ts"],"names":[],"mappings":"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","sourcesContent":["import { logger, field } from \"@coder/logger\";\nimport { NotificationService, INotificationHandle, INotificationService, Severity } from \"./fill/notification\";\n\n// tslint:disable no-any can have different return values\n\ninterface IRetryItem {\n\t/**\n\t * How many times this item has been retried.\n\t */\n\tcount?: number;\n\n\t/**\n\t * In seconds.\n\t */\n\tdelay?: number;\n\n\t/**\n\t * In milliseconds.\n\t */\n\tend?: number;\n\n\t/**\n\t * Function to run when retrying.\n\t */\n\tfn(): any;\n\n\t/**\n\t * Timer for running this item.\n\t */\n\ttimeout?: number | NodeJS.Timer;\n\n\t/**\n\t * Whether the item is retrying or waiting to retry.\n\t */\n\trunning?: boolean;\n}\n\n/**\n * An retry-able instance.\n */\nexport interface RetryInstance {\n\t/**\n\t * Run this retry.\n\t */\n\trun(error?: Error): void;\n\n\t/**\n\t * Block on this instance.\n\t */\n\tblock(): void;\n}\n\n/**\n * A retry-able instance that doesn't use a promise so it must be manually\n * ran again on failure and recovered on success.\n */\nexport interface ManualRetryInstance extends RetryInstance {\n\t/**\n\t * Mark this item as recovered.\n\t */\n\trecover(): void;\n}\n\n/**\n * Retry services. Handles multiple services so when a connection drops the\n * user doesn't get a separate notification for each service.\n *\n * Attempts to restart services silently up to a maximum number of tries, then\n * starts waiting for a delay that grows exponentially with each attempt with a\n * cap on the delay. Once the delay is long enough, it will show a notification\n * to the user explaining what is happening with an option to immediately retry.\n */\nexport class Retry {\n\tprivate readonly items = new Map<string, IRetryItem>();\n\n\t// Times are in seconds.\n\tprivate readonly retryMinDelay = 1;\n\tprivate readonly retryMaxDelay = 3;\n\tprivate readonly maxImmediateRetries = 5;\n\tprivate readonly retryExponent = 1.5;\n\tprivate blocked: string | boolean | undefined;\n\n\tprivate notificationHandle: INotificationHandle | undefined;\n\tprivate readonly updateDelay = 1;\n\tprivate updateTimeout: number | NodeJS.Timer | undefined;\n\tprivate readonly notificationThreshold = 3;\n\n\t// Time in milliseconds to wait before restarting a service. (See usage below\n\t// for reasoning.)\n\tprivate readonly waitDelay = 50;\n\n\tpublic constructor(private _notificationService: INotificationService) {}\n\n\tpublic set notificationService(service: INotificationService) {\n\t\tthis._notificationService = service;\n\t}\n\n\tpublic get notificationService(): INotificationService {\n\t\treturn this._notificationService;\n\t}\n\n\t/**\n\t * Register a function to retry that starts/connects to a service.\n\t *\n\t * The service is automatically retried or recovered when the promise resolves\n\t * or rejects. If the service dies after starting, it must be manually\n\t * retried.\n\t */\n\tpublic register(name: string, fn: () => Promise<any>): RetryInstance;\n\t/**\n\t * Register a function to retry that starts/connects to a service.\n\t *\n\t * Must manually retry if it fails to start again or dies after restarting and\n\t * manually recover if it succeeds in starting again.\n\t */\n\tpublic register(name: string, fn: () => any): ManualRetryInstance;\n\t/**\n\t * Register a function to retry that starts/connects to a service.\n\t */\n\tpublic register(name: string, fn: () => any): RetryInstance | ManualRetryInstance {\n\t\tif (this.items.has(name)) {\n\t\t\tthrow new Error(`\"${name}\" is already registered`);\n\t\t}\n\t\tthis.items.set(name, { fn });\n\n\t\treturn {\n\t\t\tblock: (): void => this.block(name),\n\t\t\trun: (error?: Error): void => this.run(name, error),\n\t\t\trecover: (): void => this.recover(name),\n\t\t};\n\t}\n\n\t/**\n\t * Un-register a function to retry.\n\t */\n\tpublic unregister(name: string): void {\n\t\tif (!this.items.has(name)) {\n\t\t\tthrow new Error(`\"${name}\" is not registered`);\n\t\t}\n\t\tthis.items.delete(name);\n\t}\n\n\t/**\n\t * Block retries when we know they will fail (for example when the socket is\n\t * down ). If a name is passed, that service will still be allowed to retry\n\t * (unless we have already blocked).\n\t *\n\t * Blocking without a name will override a block with a name.\n\t */\n\tpublic block(name?: string): void {\n\t\tif (!this.blocked || !name) {\n\t\t\tthis.blocked = name || true;\n\t\t\tthis.items.forEach((item) => {\n\t\t\t\tthis.stopItem(item);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Unblock retries and run any that are pending.\n\t */\n\tprivate unblock(): void {\n\t\tthis.blocked = false;\n\t\tthis.items.forEach((item, name) => {\n\t\t\tif (item.running) {\n\t\t\t\tthis.runItem(name, item);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Retry a service.\n\t */\n\tprivate run(name: string, error?: Error): void {\n\t\tif (!this.items.has(name)) {\n\t\t\tthrow new Error(`\"${name}\" is not registered`);\n\t\t}\n\n\t\tconst item = this.items.get(name)!;\n\t\tif (item.running) {\n\t\t\tthrow new Error(`\"${name}\" is already retrying`);\n\t\t}\n\n\t\titem.running = true;\n\t\t// This timeout is for the case when the connection drops; this allows time\n\t\t// for the socket service to come in and block everything because some other\n\t\t// services might make it here first and try to restart, which will fail.\n\t\tsetTimeout(() => {\n\t\t\tif (this.blocked && this.blocked !== name) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!item.count || item.count < this.maxImmediateRetries) {\n\t\t\t\treturn this.runItem(name, item, error);\n\t\t\t}\n\n\t\t\tif (!item.delay) {\n\t\t\t\titem.delay = this.retryMinDelay;\n\t\t\t} else {\n\t\t\t\titem.delay = Math.ceil(item.delay * this.retryExponent);\n\t\t\t\tif (item.delay > this.retryMaxDelay) {\n\t\t\t\t\titem.delay = this.retryMaxDelay;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogger.info(`Retrying ${name.toLowerCase()} in ${item.delay}s`, error && field(\"error\", error.message));\n\t\t\tconst itemDelayMs = item.delay * 1000;\n\t\t\titem.end = Date.now() + itemDelayMs;\n\t\t\titem.timeout = setTimeout(() => this.runItem(name, item, error), itemDelayMs);\n\n\t\t\tthis.updateNotification();\n\t\t}, this.waitDelay);\n\t}\n\n\t/**\n\t * Reset a service after a successfully recovering.\n\t */\n\tprivate recover(name: string): void {\n\t\tif (!this.items.has(name)) {\n\t\t\tthrow new Error(`\"${name}\" is not registered`);\n\t\t}\n\n\t\tconst item = this.items.get(name)!;\n\t\tif (typeof item.timeout === \"undefined\" && !item.running && typeof item.count !== \"undefined\") {\n\t\t\tlogger.info(`Connected to ${name.toLowerCase()}`);\n\t\t\titem.delay = undefined;\n\t\t\titem.count = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Run an item.\n\t */\n\tprivate runItem(name: string, item: IRetryItem, error?: Error): void {\n\t\tif (!item.count) {\n\t\t\titem.count = 1;\n\t\t} else {\n\t\t\t++item.count;\n\t\t}\n\n\t\tconst retryCountText = item.count <= this.maxImmediateRetries\n\t\t\t? `[${item.count}/${this.maxImmediateRetries}]`\n\t\t\t: `[${item.count}]`;\n\t\tlogger.info(`Starting ${name.toLowerCase()} ${retryCountText}...`, error && field(\"error\", error.message));\n\n\t\tconst endItem = (): void => {\n\t\t\tthis.stopItem(item);\n\t\t\titem.running = false;\n\t\t};\n\n\t\ttry {\n\t\t\tconst maybePromise = item.fn();\n\t\t\tif (maybePromise instanceof Promise) {\n\t\t\t\tmaybePromise.then(() => {\n\t\t\t\t\tendItem();\n\t\t\t\t\tthis.recover(name);\n\t\t\t\t\tif (this.blocked === name) {\n\t\t\t\t\t\tthis.unblock();\n\t\t\t\t\t}\n\t\t\t\t}).catch((error) => {\n\t\t\t\t\tendItem();\n\t\t\t\t\tthis.run(name, error);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tendItem();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Prevent an exception from causing the item to never run again.\n\t\t\tendItem();\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Update, close, or show the notification.\n\t */\n\tprivate updateNotification(): void {\n\t\t// tslint:disable-next-line no-any because NodeJS.Timer is valid.\n\t\tclearTimeout(this.updateTimeout as any);\n\n\t\tconst now = Date.now();\n\t\tconst items = Array.from(this.items.entries()).filter(([_, item]) => {\n\t\t\treturn typeof item.end !== \"undefined\"\n\t\t\t\t&& item.end > now\n\t\t\t\t&& item.delay && item.delay >= this.notificationThreshold;\n\t\t}).sort((a, b) => {\n\t\t\treturn a[1] < b[1] ? -1 : 1;\n\t\t});\n\n\t\tif (items.length === 0) {\n\t\t\tif (this.notificationHandle) {\n\t\t\t\tthis.notificationHandle.close();\n\t\t\t\tthis.notificationHandle = undefined;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst join = (arr: string[]): string => {\n\t\t\tconst last = arr.pop()!; // Assume length > 0.\n\n\t\t\treturn arr.length > 0 ? `${arr.join(\", \")} and ${last}` : last;\n\t\t};\n\n\t\tconst servicesStr = join(items.map(([name, _]) => name.toLowerCase()));\n\t\tconst message = `Lost connection to ${servicesStr}. Retrying in ${\n\t\t\tjoin(items.map(([_, item]) => `${Math.ceil((item.end! - now) / 1000)}s`))\n\t\t}.`;\n\n\t\tconst buttons = [{\n\t\t\tlabel: `Retry ${items.length > 1 ? \"Services\" : items[0][0]} Now`,\n\t\t\trun: (): void => {\n\t\t\t\tlogger.info(`Forcing ${servicesStr} to restart now`);\n\t\t\t\titems.forEach(([name, item]) => {\n\t\t\t\t\tthis.runItem(name, item);\n\t\t\t\t});\n\t\t\t\tthis.updateNotification();\n\t\t\t},\n\t\t}];\n\n\t\tif (!this.notificationHandle) {\n\t\t\tthis.notificationHandle = this.notificationService.prompt(\n\t\t\t\tSeverity.Info,\n\t\t\t\tmessage,\n\t\t\t\tbuttons,\n\t\t\t\t() => {\n\t\t\t\t\tthis.notificationHandle = undefined;\n\t\t\t\t\t// tslint:disable-next-line no-any because NodeJS.Timer is valid.\n\t\t\t\t\tclearTimeout(this.updateTimeout as any);\n\t\t\t\t},\n\t\t\t);\n\t\t} else {\n\t\t\tthis.notificationHandle.updateMessage(message);\n\t\t\tthis.notificationHandle.updateButtons(buttons);\n\t\t}\n\n\t\tthis.updateTimeout = setTimeout(() => this.updateNotification(), this.updateDelay * 1000);\n\t}\n\n\t/**\n\t * Stop an item's timer.\n\t */\n\tprivate stopItem(item: IRetryItem): void {\n\t\t// tslint:disable-next-line no-any because NodeJS.Timer is valid.\n\t\tclearTimeout(item.timeout as any);\n\t\titem.timeout = undefined;\n\t\titem.end = undefined;\n\t}\n}\n\n// Global instance so we can block other retries when retrying the main\n// connection.\nexport const retry = new Retry(new NotificationService());\n"]}]}