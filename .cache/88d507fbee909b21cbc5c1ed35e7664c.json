{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/launch/electron-main/launchService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/launch/electron-main/launchService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/platform/log/common/log\", \"vs/platform/url/common/url\", \"vs/base/common/platform\", \"vs/platform/environment/common/environment\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/windows/common/windows\", \"vs/platform/windows/electron-main/windows\", \"vs/base/node/pfs\", \"vs/platform/workspaces/common/workspaces\", \"vs/platform/configuration/common/configuration\", \"vs/base/common/uri\", \"electron\", \"vs/platform/environment/node/argv\", \"vs/base/common/arrays\"], function (require, exports, log_1, url_1, platform_1, environment_1, instantiation_1, windows_1, windows_2, pfs_1, workspaces_1, configuration_1, uri_1, electron_1, argv_1, arrays_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.ID = 'launchService';\n    exports.ILaunchService = instantiation_1.createDecorator(exports.ID);\n    function parseOpenUrl(args) {\n        if (args['open-url'] && args._urls && args._urls.length > 0) {\n            // --open-url must contain -- followed by the url(s)\n            // process.argv is used over args._ as args._ are resolved to file paths at this point\n            return arrays_1.coalesce(args._urls\n                .map(url => {\n                try {\n                    return uri_1.URI.parse(url);\n                }\n                catch (err) {\n                    return null;\n                }\n            }));\n        }\n        return [];\n    }\n    class LaunchChannel {\n        constructor(service) {\n            this.service = service;\n        }\n        listen(_, event) {\n            throw new Error(`Event not found: ${event}`);\n        }\n        call(_, command, arg) {\n            switch (command) {\n                case 'start':\n                    const { args, userEnv } = arg;\n                    return this.service.start(args, userEnv);\n                case 'get-main-process-id':\n                    return this.service.getMainProcessId();\n                case 'get-main-process-info':\n                    return this.service.getMainProcessInfo();\n                case 'get-logs-path':\n                    return this.service.getLogsPath();\n            }\n            throw new Error(`Call not found: ${command}`);\n        }\n    }\n    exports.LaunchChannel = LaunchChannel;\n    class LaunchChannelClient {\n        constructor(channel) {\n            this.channel = channel;\n        }\n        start(args, userEnv) {\n            return this.channel.call('start', { args, userEnv });\n        }\n        getMainProcessId() {\n            return this.channel.call('get-main-process-id', null);\n        }\n        getMainProcessInfo() {\n            return this.channel.call('get-main-process-info', null);\n        }\n        getLogsPath() {\n            return this.channel.call('get-logs-path', null);\n        }\n    }\n    exports.LaunchChannelClient = LaunchChannelClient;\n    let LaunchService = class LaunchService {\n        constructor(logService, windowsMainService, urlService, workspacesMainService, environmentService, configurationService) {\n            this.logService = logService;\n            this.windowsMainService = windowsMainService;\n            this.urlService = urlService;\n            this.workspacesMainService = workspacesMainService;\n            this.environmentService = environmentService;\n            this.configurationService = configurationService;\n        }\n        start(args, userEnv) {\n            this.logService.trace('Received data from other instance: ', args, userEnv);\n            const urlsToOpen = parseOpenUrl(args);\n            // Check early for open-url which is handled in URL service\n            if (urlsToOpen.length) {\n                let whenWindowReady = Promise.resolve(null);\n                // Create a window if there is none\n                if (this.windowsMainService.getWindowCount() === 0) {\n                    const window = this.windowsMainService.openNewWindow(windows_1.OpenContext.DESKTOP)[0];\n                    whenWindowReady = window.ready();\n                }\n                // Make sure a window is open, ready to receive the url event\n                whenWindowReady.then(() => {\n                    for (const url of urlsToOpen) {\n                        this.urlService.open(url);\n                    }\n                });\n                return Promise.resolve(undefined);\n            }\n            // Otherwise handle in windows service\n            return this.startOpenWindow(args, userEnv);\n        }\n        startOpenWindow(args, userEnv) {\n            const context = !!userEnv['VSCODE_CLI'] ? windows_1.OpenContext.CLI : windows_1.OpenContext.DESKTOP;\n            let usedWindows = [];\n            const waitMarkerFileURI = args.wait && args.waitMarkerFilePath ? uri_1.URI.file(args.waitMarkerFilePath) : undefined;\n            // Special case extension development\n            if (!!args.extensionDevelopmentPath) {\n                this.windowsMainService.openExtensionDevelopmentHostWindow(args.extensionDevelopmentPath, { context, cli: args, userEnv, waitMarkerFileURI });\n            }\n            // Start without file/folder arguments\n            else if (!argv_1.hasArgs(args._) && !argv_1.hasArgs(args['folder-uri']) && !argv_1.hasArgs(args['file-uri'])) {\n                let openNewWindow = false;\n                // Force new window\n                if (args['new-window'] || args['unity-launch']) {\n                    openNewWindow = true;\n                }\n                // Force reuse window\n                else if (args['reuse-window']) {\n                    openNewWindow = false;\n                }\n                // Otherwise check for settings\n                else {\n                    const windowConfig = this.configurationService.getValue('window');\n                    const openWithoutArgumentsInNewWindowConfig = (windowConfig && windowConfig.openWithoutArgumentsInNewWindow) || 'default' /* default */;\n                    switch (openWithoutArgumentsInNewWindowConfig) {\n                        case 'on':\n                            openNewWindow = true;\n                            break;\n                        case 'off':\n                            openNewWindow = false;\n                            break;\n                        default:\n                            openNewWindow = !platform_1.isMacintosh; // prefer to restore running instance on macOS\n                    }\n                }\n                if (openNewWindow) {\n                    usedWindows = this.windowsMainService.open({\n                        context,\n                        cli: args,\n                        userEnv,\n                        forceNewWindow: true,\n                        forceEmpty: true,\n                        waitMarkerFileURI\n                    });\n                }\n                else {\n                    usedWindows = [this.windowsMainService.focusLastActive(args, context)];\n                }\n            }\n            // Start with file/folder arguments\n            else {\n                usedWindows = this.windowsMainService.open({\n                    context,\n                    cli: args,\n                    userEnv,\n                    forceNewWindow: args['new-window'],\n                    preferNewWindow: !args['reuse-window'] && !args.wait,\n                    forceReuseWindow: args['reuse-window'],\n                    diffMode: args.diff,\n                    addMode: args.add,\n                    noRecentEntry: !!args['skip-add-to-recently-opened'],\n                    waitMarkerFileURI\n                });\n            }\n            // If the other instance is waiting to be killed, we hook up a window listener if one window\n            // is being used and only then resolve the startup promise which will kill this second instance.\n            // In addition, we poll for the wait marker file to be deleted to return.\n            if (waitMarkerFileURI && usedWindows.length === 1 && usedWindows[0]) {\n                return Promise.race([\n                    this.windowsMainService.waitForWindowCloseOrLoad(usedWindows[0].id),\n                    pfs_1.whenDeleted(waitMarkerFileURI.fsPath)\n                ]).then(() => undefined, () => undefined);\n            }\n            return Promise.resolve(undefined);\n        }\n        getMainProcessId() {\n            this.logService.trace('Received request for process ID from other instance.');\n            return Promise.resolve(process.pid);\n        }\n        getMainProcessInfo() {\n            this.logService.trace('Received request for main process info from other instance.');\n            const windows = [];\n            electron_1.BrowserWindow.getAllWindows().forEach(window => {\n                const codeWindow = this.windowsMainService.getWindowById(window.id);\n                if (codeWindow) {\n                    windows.push(this.codeWindowToInfo(codeWindow));\n                }\n                else {\n                    windows.push(this.browserWindowToInfo(window));\n                }\n            });\n            return Promise.resolve({\n                mainPID: process.pid,\n                mainArguments: process.argv.slice(1),\n                windows\n            });\n        }\n        getLogsPath() {\n            this.logService.trace('Received request for logs path from other instance.');\n            return Promise.resolve(this.environmentService.logsPath);\n        }\n        codeWindowToInfo(window) {\n            const folderURIs = [];\n            if (window.openedFolderUri) {\n                folderURIs.push(window.openedFolderUri);\n            }\n            else if (window.openedWorkspace) {\n                // workspace folders can only be shown for local workspaces\n                const workspaceConfigPath = window.openedWorkspace.configPath;\n                const resolvedWorkspace = this.workspacesMainService.resolveLocalWorkspaceSync(workspaceConfigPath);\n                if (resolvedWorkspace) {\n                    const rootFolders = resolvedWorkspace.folders;\n                    rootFolders.forEach(root => {\n                        folderURIs.push(root.uri);\n                    });\n                }\n                else {\n                    //TODO: can we add the workspace file here?\n                }\n            }\n            return this.browserWindowToInfo(window.win, folderURIs);\n        }\n        browserWindowToInfo(win, folderURIs = []) {\n            return {\n                pid: win.webContents.getOSProcessId(),\n                title: win.getTitle(),\n                folderURIs\n            };\n        }\n    };\n    LaunchService = __decorate([\n        __param(0, log_1.ILogService),\n        __param(1, windows_2.IWindowsMainService),\n        __param(2, url_1.IURLService),\n        __param(3, workspaces_1.IWorkspacesMainService),\n        __param(4, environment_1.IEnvironmentService),\n        __param(5, configuration_1.IConfigurationService)\n    ], LaunchService);\n    exports.LaunchService = LaunchService;\n});\n",null]}