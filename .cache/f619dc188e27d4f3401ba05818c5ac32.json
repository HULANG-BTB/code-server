{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class TreeNode {\n        constructor(piece, color) {\n            this.piece = piece;\n            this.color = color;\n            this.size_left = 0;\n            this.lf_left = 0;\n            this.parent = this;\n            this.left = this;\n            this.right = this;\n        }\n        next() {\n            if (this.right !== exports.SENTINEL) {\n                return leftest(this.right);\n            }\n            let node = this;\n            while (node.parent !== exports.SENTINEL) {\n                if (node.parent.left === node) {\n                    break;\n                }\n                node = node.parent;\n            }\n            if (node.parent === exports.SENTINEL) {\n                return exports.SENTINEL;\n            }\n            else {\n                return node.parent;\n            }\n        }\n        prev() {\n            if (this.left !== exports.SENTINEL) {\n                return righttest(this.left);\n            }\n            let node = this;\n            while (node.parent !== exports.SENTINEL) {\n                if (node.parent.right === node) {\n                    break;\n                }\n                node = node.parent;\n            }\n            if (node.parent === exports.SENTINEL) {\n                return exports.SENTINEL;\n            }\n            else {\n                return node.parent;\n            }\n        }\n        detach() {\n            this.parent = null;\n            this.left = null;\n            this.right = null;\n        }\n    }\n    exports.TreeNode = TreeNode;\n    var NodeColor;\n    (function (NodeColor) {\n        NodeColor[NodeColor[\"Black\"] = 0] = \"Black\";\n        NodeColor[NodeColor[\"Red\"] = 1] = \"Red\";\n    })(NodeColor = exports.NodeColor || (exports.NodeColor = {}));\n    exports.SENTINEL = new TreeNode(null, NodeColor.Black);\n    exports.SENTINEL.parent = exports.SENTINEL;\n    exports.SENTINEL.left = exports.SENTINEL;\n    exports.SENTINEL.right = exports.SENTINEL;\n    exports.SENTINEL.color = NodeColor.Black;\n    function leftest(node) {\n        while (node.left !== exports.SENTINEL) {\n            node = node.left;\n        }\n        return node;\n    }\n    exports.leftest = leftest;\n    function righttest(node) {\n        while (node.right !== exports.SENTINEL) {\n            node = node.right;\n        }\n        return node;\n    }\n    exports.righttest = righttest;\n    function calculateSize(node) {\n        if (node === exports.SENTINEL) {\n            return 0;\n        }\n        return node.size_left + node.piece.length + calculateSize(node.right);\n    }\n    exports.calculateSize = calculateSize;\n    function calculateLF(node) {\n        if (node === exports.SENTINEL) {\n            return 0;\n        }\n        return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n    }\n    exports.calculateLF = calculateLF;\n    function resetSentinel() {\n        exports.SENTINEL.parent = exports.SENTINEL;\n    }\n    exports.resetSentinel = resetSentinel;\n    function leftRotate(tree, x) {\n        let y = x.right;\n        // fix size_left\n        y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n        y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n        x.right = y.left;\n        if (y.left !== exports.SENTINEL) {\n            y.left.parent = x;\n        }\n        y.parent = x.parent;\n        if (x.parent === exports.SENTINEL) {\n            tree.root = y;\n        }\n        else if (x.parent.left === x) {\n            x.parent.left = y;\n        }\n        else {\n            x.parent.right = y;\n        }\n        y.left = x;\n        x.parent = y;\n    }\n    exports.leftRotate = leftRotate;\n    function rightRotate(tree, y) {\n        let x = y.left;\n        y.left = x.right;\n        if (x.right !== exports.SENTINEL) {\n            x.right.parent = y;\n        }\n        x.parent = y.parent;\n        // fix size_left\n        y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n        y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n        if (y.parent === exports.SENTINEL) {\n            tree.root = x;\n        }\n        else if (y === y.parent.right) {\n            y.parent.right = x;\n        }\n        else {\n            y.parent.left = x;\n        }\n        x.right = y;\n        y.parent = x;\n    }\n    exports.rightRotate = rightRotate;\n    function rbDelete(tree, z) {\n        let x;\n        let y;\n        if (z.left === exports.SENTINEL) {\n            y = z;\n            x = y.right;\n        }\n        else if (z.right === exports.SENTINEL) {\n            y = z;\n            x = y.left;\n        }\n        else {\n            y = leftest(z.right);\n            x = y.right;\n        }\n        if (y === tree.root) {\n            tree.root = x;\n            // if x is null, we are removing the only node\n            x.color = NodeColor.Black;\n            z.detach();\n            resetSentinel();\n            tree.root.parent = exports.SENTINEL;\n            return;\n        }\n        let yWasRed = (y.color === NodeColor.Red);\n        if (y === y.parent.left) {\n            y.parent.left = x;\n        }\n        else {\n            y.parent.right = x;\n        }\n        if (y === z) {\n            x.parent = y.parent;\n            recomputeTreeMetadata(tree, x);\n        }\n        else {\n            if (y.parent === z) {\n                x.parent = y;\n            }\n            else {\n                x.parent = y.parent;\n            }\n            // as we make changes to x's hierarchy, update size_left of subtree first\n            recomputeTreeMetadata(tree, x);\n            y.left = z.left;\n            y.right = z.right;\n            y.parent = z.parent;\n            y.color = z.color;\n            if (z === tree.root) {\n                tree.root = y;\n            }\n            else {\n                if (z === z.parent.left) {\n                    z.parent.left = y;\n                }\n                else {\n                    z.parent.right = y;\n                }\n            }\n            if (y.left !== exports.SENTINEL) {\n                y.left.parent = y;\n            }\n            if (y.right !== exports.SENTINEL) {\n                y.right.parent = y;\n            }\n            // update metadata\n            // we replace z with y, so in this sub tree, the length change is z.item.length\n            y.size_left = z.size_left;\n            y.lf_left = z.lf_left;\n            recomputeTreeMetadata(tree, y);\n        }\n        z.detach();\n        if (x.parent.left === x) {\n            let newSizeLeft = calculateSize(x);\n            let newLFLeft = calculateLF(x);\n            if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n                let delta = newSizeLeft - x.parent.size_left;\n                let lf_delta = newLFLeft - x.parent.lf_left;\n                x.parent.size_left = newSizeLeft;\n                x.parent.lf_left = newLFLeft;\n                updateTreeMetadata(tree, x.parent, delta, lf_delta);\n            }\n        }\n        recomputeTreeMetadata(tree, x.parent);\n        if (yWasRed) {\n            resetSentinel();\n            return;\n        }\n        // RB-DELETE-FIXUP\n        let w;\n        while (x !== tree.root && x.color === NodeColor.Black) {\n            if (x === x.parent.left) {\n                w = x.parent.right;\n                if (w.color === NodeColor.Red) {\n                    w.color = NodeColor.Black;\n                    x.parent.color = NodeColor.Red;\n                    leftRotate(tree, x.parent);\n                    w = x.parent.right;\n                }\n                if (w.left.color === NodeColor.Black && w.right.color === NodeColor.Black) {\n                    w.color = NodeColor.Red;\n                    x = x.parent;\n                }\n                else {\n                    if (w.right.color === NodeColor.Black) {\n                        w.left.color = NodeColor.Black;\n                        w.color = NodeColor.Red;\n                        rightRotate(tree, w);\n                        w = x.parent.right;\n                    }\n                    w.color = x.parent.color;\n                    x.parent.color = NodeColor.Black;\n                    w.right.color = NodeColor.Black;\n                    leftRotate(tree, x.parent);\n                    x = tree.root;\n                }\n            }\n            else {\n                w = x.parent.left;\n                if (w.color === NodeColor.Red) {\n                    w.color = NodeColor.Black;\n                    x.parent.color = NodeColor.Red;\n                    rightRotate(tree, x.parent);\n                    w = x.parent.left;\n                }\n                if (w.left.color === NodeColor.Black && w.right.color === NodeColor.Black) {\n                    w.color = NodeColor.Red;\n                    x = x.parent;\n                }\n                else {\n                    if (w.left.color === NodeColor.Black) {\n                        w.right.color = NodeColor.Black;\n                        w.color = NodeColor.Red;\n                        leftRotate(tree, w);\n                        w = x.parent.left;\n                    }\n                    w.color = x.parent.color;\n                    x.parent.color = NodeColor.Black;\n                    w.left.color = NodeColor.Black;\n                    rightRotate(tree, x.parent);\n                    x = tree.root;\n                }\n            }\n        }\n        x.color = NodeColor.Black;\n        resetSentinel();\n    }\n    exports.rbDelete = rbDelete;\n    function fixInsert(tree, x) {\n        recomputeTreeMetadata(tree, x);\n        while (x !== tree.root && x.parent.color === NodeColor.Red) {\n            if (x.parent === x.parent.parent.left) {\n                const y = x.parent.parent.right;\n                if (y.color === NodeColor.Red) {\n                    x.parent.color = NodeColor.Black;\n                    y.color = NodeColor.Black;\n                    x.parent.parent.color = NodeColor.Red;\n                    x = x.parent.parent;\n                }\n                else {\n                    if (x === x.parent.right) {\n                        x = x.parent;\n                        leftRotate(tree, x);\n                    }\n                    x.parent.color = NodeColor.Black;\n                    x.parent.parent.color = NodeColor.Red;\n                    rightRotate(tree, x.parent.parent);\n                }\n            }\n            else {\n                const y = x.parent.parent.left;\n                if (y.color === NodeColor.Red) {\n                    x.parent.color = NodeColor.Black;\n                    y.color = NodeColor.Black;\n                    x.parent.parent.color = NodeColor.Red;\n                    x = x.parent.parent;\n                }\n                else {\n                    if (x === x.parent.left) {\n                        x = x.parent;\n                        rightRotate(tree, x);\n                    }\n                    x.parent.color = NodeColor.Black;\n                    x.parent.parent.color = NodeColor.Red;\n                    leftRotate(tree, x.parent.parent);\n                }\n            }\n        }\n        tree.root.color = NodeColor.Black;\n    }\n    exports.fixInsert = fixInsert;\n    function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n        // node length change or line feed count change\n        while (x !== tree.root && x !== exports.SENTINEL) {\n            if (x.parent.left === x) {\n                x.parent.size_left += delta;\n                x.parent.lf_left += lineFeedCntDelta;\n            }\n            x = x.parent;\n        }\n    }\n    exports.updateTreeMetadata = updateTreeMetadata;\n    function recomputeTreeMetadata(tree, x) {\n        let delta = 0;\n        let lf_delta = 0;\n        if (x === tree.root) {\n            return;\n        }\n        if (delta === 0) {\n            // go upwards till the node whose left subtree is changed.\n            while (x !== tree.root && x === x.parent.right) {\n                x = x.parent;\n            }\n            if (x === tree.root) {\n                // well, it means we add a node to the end (inorder)\n                return;\n            }\n            // x is the node whose right subtree is changed.\n            x = x.parent;\n            delta = calculateSize(x.left) - x.size_left;\n            lf_delta = calculateLF(x.left) - x.lf_left;\n            x.size_left += delta;\n            x.lf_left += lf_delta;\n        }\n        // go upwards till root. O(logN)\n        while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n            if (x.parent.left === x) {\n                x.parent.size_left += delta;\n                x.parent.lf_left += lf_delta;\n            }\n            x = x.parent;\n        }\n    }\n    exports.recomputeTreeMetadata = recomputeTreeMetadata;\n});\n",null]}