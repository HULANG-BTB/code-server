{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/common/search.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/common/search.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/arrays\", \"vs/base/common/glob\", \"vs/base/common/objects\", \"vs/base/common/extpath\", \"vs/base/common/strings\", \"vs/platform/instantiation/common/instantiation\", \"vs/workbench/common/views\", \"vs/platform/registry/common/platform\"], function (require, exports, arrays_1, glob, objects, extpath, strings_1, instantiation_1, views_1, platform_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.VIEWLET_ID = 'workbench.view.search';\n    exports.PANEL_ID = 'workbench.view.search';\n    exports.VIEW_ID = 'workbench.view.search';\n    /**\n     * Search viewlet container.\n     */\n    exports.VIEW_CONTAINER = platform_1.Registry.as(views_1.Extensions.ViewContainersRegistry).registerViewContainer(exports.VIEWLET_ID, true);\n    exports.ISearchService = instantiation_1.createDecorator('searchService');\n    /**\n     * TODO@roblou - split text from file search entirely, or share code in a more natural way.\n     */\n    var SearchProviderType;\n    (function (SearchProviderType) {\n        SearchProviderType[SearchProviderType[\"file\"] = 0] = \"file\";\n        SearchProviderType[SearchProviderType[\"text\"] = 1] = \"text\";\n    })(SearchProviderType = exports.SearchProviderType || (exports.SearchProviderType = {}));\n    var QueryType;\n    (function (QueryType) {\n        QueryType[QueryType[\"File\"] = 1] = \"File\";\n        QueryType[QueryType[\"Text\"] = 2] = \"Text\";\n    })(QueryType = exports.QueryType || (exports.QueryType = {}));\n    function resultIsMatch(result) {\n        return !!result.preview;\n    }\n    exports.resultIsMatch = resultIsMatch;\n    function isFileMatch(p) {\n        return !!p.resource;\n    }\n    exports.isFileMatch = isFileMatch;\n    function isProgressMessage(p) {\n        return !isFileMatch(p);\n    }\n    exports.isProgressMessage = isProgressMessage;\n    class FileMatch {\n        constructor(resource) {\n            this.resource = resource;\n            this.results = [];\n            // empty\n        }\n    }\n    exports.FileMatch = FileMatch;\n    class TextSearchMatch {\n        constructor(text, range, previewOptions) {\n            this.ranges = range;\n            if (previewOptions && previewOptions.matchLines === 1 && !Array.isArray(range)) {\n                // 1 line preview requested\n                text = strings_1.getNLines(text, previewOptions.matchLines);\n                const leadingChars = Math.floor(previewOptions.charsPerLine / 5);\n                const previewStart = Math.max(range.startColumn - leadingChars, 0);\n                const previewText = text.substring(previewStart, previewOptions.charsPerLine + previewStart);\n                const endColInPreview = (range.endLineNumber - range.startLineNumber + 1) <= previewOptions.matchLines ?\n                    Math.min(previewText.length, range.endColumn - previewStart) : // if number of match lines will not be trimmed by previewOptions\n                    previewText.length; // if number of lines is trimmed\n                this.preview = {\n                    text: previewText,\n                    matches: new OneLineRange(0, range.startColumn - previewStart, endColInPreview)\n                };\n            }\n            else {\n                const firstMatchLine = Array.isArray(range) ? range[0].startLineNumber : range.startLineNumber;\n                // n line, no preview requested, or multiple matches in the preview\n                this.preview = {\n                    text,\n                    matches: arrays_1.mapArrayOrNot(range, r => new SearchRange(r.startLineNumber - firstMatchLine, r.startColumn, r.endLineNumber - firstMatchLine, r.endColumn))\n                };\n            }\n        }\n    }\n    exports.TextSearchMatch = TextSearchMatch;\n    class SearchRange {\n        constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    exports.SearchRange = SearchRange;\n    class OneLineRange extends SearchRange {\n        constructor(lineNumber, startColumn, endColumn) {\n            super(lineNumber, startColumn, lineNumber, endColumn);\n        }\n    }\n    exports.OneLineRange = OneLineRange;\n    function getExcludes(configuration, includeSearchExcludes = true) {\n        const fileExcludes = configuration && configuration.files && configuration.files.exclude;\n        const searchExcludes = includeSearchExcludes && configuration && configuration.search && configuration.search.exclude;\n        if (!fileExcludes && !searchExcludes) {\n            return undefined;\n        }\n        if (!fileExcludes || !searchExcludes) {\n            return fileExcludes || searchExcludes;\n        }\n        let allExcludes = Object.create(null);\n        // clone the config as it could be frozen\n        allExcludes = objects.mixin(allExcludes, objects.deepClone(fileExcludes));\n        allExcludes = objects.mixin(allExcludes, objects.deepClone(searchExcludes), true);\n        return allExcludes;\n    }\n    exports.getExcludes = getExcludes;\n    function pathIncludedInQuery(queryProps, fsPath) {\n        if (queryProps.excludePattern && glob.match(queryProps.excludePattern, fsPath)) {\n            return false;\n        }\n        if (queryProps.includePattern && !glob.match(queryProps.includePattern, fsPath)) {\n            return false;\n        }\n        // If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present\n        if (queryProps.usingSearchPaths) {\n            return !!queryProps.folderQueries && queryProps.folderQueries.every(fq => {\n                const searchPath = fq.folder.fsPath;\n                if (extpath.isEqualOrParent(fsPath, searchPath)) {\n                    return !fq.includePattern || !!glob.match(fq.includePattern, fsPath);\n                }\n                else {\n                    return false;\n                }\n            });\n        }\n        return true;\n    }\n    exports.pathIncludedInQuery = pathIncludedInQuery;\n    var SearchErrorCode;\n    (function (SearchErrorCode) {\n        SearchErrorCode[SearchErrorCode[\"unknownEncoding\"] = 1] = \"unknownEncoding\";\n        SearchErrorCode[SearchErrorCode[\"regexParseError\"] = 2] = \"regexParseError\";\n        SearchErrorCode[SearchErrorCode[\"globParseError\"] = 3] = \"globParseError\";\n        SearchErrorCode[SearchErrorCode[\"invalidLiteral\"] = 4] = \"invalidLiteral\";\n        SearchErrorCode[SearchErrorCode[\"rgProcessError\"] = 5] = \"rgProcessError\";\n        SearchErrorCode[SearchErrorCode[\"other\"] = 6] = \"other\";\n    })(SearchErrorCode = exports.SearchErrorCode || (exports.SearchErrorCode = {}));\n    class SearchError extends Error {\n        constructor(message, code) {\n            super(message);\n            this.code = code;\n        }\n    }\n    exports.SearchError = SearchError;\n    function deserializeSearchError(errorMsg) {\n        try {\n            const details = JSON.parse(errorMsg);\n            return new SearchError(details.message, details.code);\n        }\n        catch (e) {\n            return new SearchError(errorMsg, SearchErrorCode.other);\n        }\n    }\n    exports.deserializeSearchError = deserializeSearchError;\n    function serializeSearchError(searchError) {\n        const details = { message: searchError.message, code: searchError.code };\n        return new Error(JSON.stringify(details));\n    }\n    exports.serializeSearchError = serializeSearchError;\n    function isSerializedSearchComplete(arg) {\n        if (arg.type === 'error') {\n            return true;\n        }\n        else if (arg.type === 'success') {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    exports.isSerializedSearchComplete = isSerializedSearchComplete;\n    function isSerializedSearchSuccess(arg) {\n        return arg.type === 'success';\n    }\n    exports.isSerializedSearchSuccess = isSerializedSearchSuccess;\n    function isSerializedFileMatch(arg) {\n        return !!arg.path;\n    }\n    exports.isSerializedFileMatch = isSerializedFileMatch;\n    class SerializableFileMatch {\n        constructor(path) {\n            this.path = path;\n            this.results = [];\n        }\n        addMatch(match) {\n            this.results.push(match);\n        }\n        serialize() {\n            return {\n                path: this.path,\n                results: this.results,\n                numMatches: this.results.length\n            };\n        }\n    }\n    exports.SerializableFileMatch = SerializableFileMatch;\n    /**\n     *  Computes the patterns that the provider handles. Discards sibling clauses and 'false' patterns\n     */\n    function resolvePatternsForProvider(globalPattern, folderPattern) {\n        const merged = Object.assign({}, (globalPattern || {}), (folderPattern || {}));\n        return Object.keys(merged)\n            .filter(key => {\n            const value = merged[key];\n            return typeof value === 'boolean' && value;\n        });\n    }\n    exports.resolvePatternsForProvider = resolvePatternsForProvider;\n    class QueryGlobTester {\n        constructor(config, folderQuery) {\n            this._excludeExpression = Object.assign({}, (config.excludePattern || {}), (folderQuery.excludePattern || {}));\n            this._parsedExcludeExpression = glob.parse(this._excludeExpression);\n            // Empty includeExpression means include nothing, so no {} shortcuts\n            let includeExpression = config.includePattern;\n            if (folderQuery.includePattern) {\n                if (includeExpression) {\n                    includeExpression = Object.assign({}, includeExpression, folderQuery.includePattern);\n                }\n                else {\n                    includeExpression = folderQuery.includePattern;\n                }\n            }\n            if (includeExpression) {\n                this._parsedIncludeExpression = glob.parse(includeExpression);\n            }\n        }\n        /**\n         * Guaranteed sync - siblingsFn should not return a promise.\n         */\n        includedInQuerySync(testPath, basename, hasSibling) {\n            if (this._parsedExcludeExpression && this._parsedExcludeExpression(testPath, basename, hasSibling)) {\n                return false;\n            }\n            if (this._parsedIncludeExpression && !this._parsedIncludeExpression(testPath, basename, hasSibling)) {\n                return false;\n            }\n            return true;\n        }\n        /**\n         * Guaranteed async.\n         */\n        includedInQuery(testPath, basename, hasSibling) {\n            const excludeP = this._parsedExcludeExpression ?\n                Promise.resolve(this._parsedExcludeExpression(testPath, basename, hasSibling)).then(result => !!result) :\n                Promise.resolve(false);\n            return excludeP.then(excluded => {\n                if (excluded) {\n                    return false;\n                }\n                return this._parsedIncludeExpression ?\n                    Promise.resolve(this._parsedIncludeExpression(testPath, basename, hasSibling)).then(result => !!result) :\n                    Promise.resolve(true);\n            }).then(included => {\n                return included;\n            });\n        }\n        hasSiblingExcludeClauses() {\n            return hasSiblingClauses(this._excludeExpression);\n        }\n    }\n    exports.QueryGlobTester = QueryGlobTester;\n    function hasSiblingClauses(pattern) {\n        for (const key in pattern) {\n            if (typeof pattern[key] !== 'boolean') {\n                return true;\n            }\n        }\n        return false;\n    }\n});\n",null]}