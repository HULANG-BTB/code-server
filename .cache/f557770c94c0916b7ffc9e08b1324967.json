{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/list/rangeMap.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/list/rangeMap.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar range_1 = require(\"vs/base/common/range\");\n/**\n * Returns the intersection between a ranged group and a range.\n * Returns `[]` if the intersection is empty.\n */\nfunction groupIntersect(range, groups) {\n    var result = [];\n    for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {\n        var r = groups_1[_i];\n        if (range.start >= r.range.end) {\n            continue;\n        }\n        if (range.end < r.range.start) {\n            break;\n        }\n        var intersection = range_1.Range.intersect(range, r.range);\n        if (range_1.Range.isEmpty(intersection)) {\n            continue;\n        }\n        result.push({\n            range: intersection,\n            size: r.size\n        });\n    }\n    return result;\n}\nexports.groupIntersect = groupIntersect;\n/**\n * Shifts a range by that `much`.\n */\nfunction shift(_a, much) {\n    var start = _a.start, end = _a.end;\n    return { start: start + much, end: end + much };\n}\nexports.shift = shift;\n/**\n * Consolidates a collection of ranged groups.\n *\n * Consolidation is the process of merging consecutive ranged groups\n * that share the same `size`.\n */\nfunction consolidate(groups) {\n    var result = [];\n    var previousGroup = null;\n    for (var _i = 0, groups_2 = groups; _i < groups_2.length; _i++) {\n        var group = groups_2[_i];\n        var start = group.range.start;\n        var end = group.range.end;\n        var size = group.size;\n        if (previousGroup && size === previousGroup.size) {\n            previousGroup.range.end = end;\n            continue;\n        }\n        previousGroup = { range: { start: start, end: end }, size: size };\n        result.push(previousGroup);\n    }\n    return result;\n}\nexports.consolidate = consolidate;\n/**\n * Concatenates several collections of ranged groups into a single\n * collection.\n */\nfunction concat() {\n    var groups = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        groups[_i] = arguments[_i];\n    }\n    return consolidate(groups.reduce(function (r, g) { return r.concat(g); }, []));\n}\nvar RangeMap = /** @class */ (function () {\n    function RangeMap() {\n        this.groups = [];\n        this._size = 0;\n    }\n    RangeMap.prototype.splice = function (index, deleteCount, items) {\n        if (items === void 0) { items = []; }\n        var diff = items.length - deleteCount;\n        var before = groupIntersect({ start: 0, end: index }, this.groups);\n        var after = groupIntersect({ start: index + deleteCount, end: Number.POSITIVE_INFINITY }, this.groups)\n            .map(function (g) { return ({ range: shift(g.range, diff), size: g.size }); });\n        var middle = items.map(function (item, i) { return ({\n            range: { start: index + i, end: index + i + 1 },\n            size: item.size\n        }); });\n        this.groups = concat(before, middle, after);\n        this._size = this.groups.reduce(function (t, g) { return t + (g.size * (g.range.end - g.range.start)); }, 0);\n    };\n    Object.defineProperty(RangeMap.prototype, \"count\", {\n        /**\n         * Returns the number of items in the range map.\n         */\n        get: function () {\n            var len = this.groups.length;\n            if (!len) {\n                return 0;\n            }\n            return this.groups[len - 1].range.end;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RangeMap.prototype, \"size\", {\n        /**\n         * Returns the sum of the sizes of all items in the range map.\n         */\n        get: function () {\n            return this._size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns the index of the item at the given position.\n     */\n    RangeMap.prototype.indexAt = function (position) {\n        if (position < 0) {\n            return -1;\n        }\n        var index = 0;\n        var size = 0;\n        for (var _i = 0, _a = this.groups; _i < _a.length; _i++) {\n            var group = _a[_i];\n            var count = group.range.end - group.range.start;\n            var newSize = size + (count * group.size);\n            if (position < newSize) {\n                return index + Math.floor((position - size) / group.size);\n            }\n            index += count;\n            size = newSize;\n        }\n        return index;\n    };\n    /**\n     * Returns the index of the item right after the item at the\n     * index of the given position.\n     */\n    RangeMap.prototype.indexAfter = function (position) {\n        return Math.min(this.indexAt(position) + 1, this.count);\n    };\n    /**\n     * Returns the start position of the item at the given index.\n     */\n    RangeMap.prototype.positionAt = function (index) {\n        if (index < 0) {\n            return -1;\n        }\n        var position = 0;\n        var count = 0;\n        for (var _i = 0, _a = this.groups; _i < _a.length; _i++) {\n            var group = _a[_i];\n            var groupCount = group.range.end - group.range.start;\n            var newCount = count + groupCount;\n            if (index < newCount) {\n                return position + ((index - count) * group.size);\n            }\n            position += groupCount * group.size;\n            count = newCount;\n        }\n        return -1;\n    };\n    RangeMap.prototype.dispose = function () {\n        this.groups = null; // StrictNullOverride: nulling out ok in dispose\n    };\n    return RangeMap;\n}());\nexports.RangeMap = RangeMap;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/list/rangeMap.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/list/rangeMap.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IRange, Range } from 'vs/base/common/range';\n\nexport interface IItem {\n\tsize: number;\n}\n\nexport interface IRangedGroup {\n\trange: IRange;\n\tsize: number;\n}\n\n/**\n * Returns the intersection between a ranged group and a range.\n * Returns `[]` if the intersection is empty.\n */\nexport function groupIntersect(range: IRange, groups: IRangedGroup[]): IRangedGroup[] {\n\tconst result: IRangedGroup[] = [];\n\n\tfor (let r of groups) {\n\t\tif (range.start >= r.range.end) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (range.end < r.range.start) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconst intersection = Range.intersect(range, r.range);\n\n\t\tif (Range.isEmpty(intersection)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult.push({\n\t\t\trange: intersection,\n\t\t\tsize: r.size\n\t\t});\n\t}\n\n\treturn result;\n}\n\n/**\n * Shifts a range by that `much`.\n */\nexport function shift({ start, end }: IRange, much: number): IRange {\n\treturn { start: start + much, end: end + much };\n}\n\n/**\n * Consolidates a collection of ranged groups.\n *\n * Consolidation is the process of merging consecutive ranged groups\n * that share the same `size`.\n */\nexport function consolidate(groups: IRangedGroup[]): IRangedGroup[] {\n\tconst result: IRangedGroup[] = [];\n\tlet previousGroup: IRangedGroup | null = null;\n\n\tfor (let group of groups) {\n\t\tconst start = group.range.start;\n\t\tconst end = group.range.end;\n\t\tconst size = group.size;\n\n\t\tif (previousGroup && size === previousGroup.size) {\n\t\t\tpreviousGroup.range.end = end;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpreviousGroup = { range: { start, end }, size };\n\t\tresult.push(previousGroup);\n\t}\n\n\treturn result;\n}\n\n/**\n * Concatenates several collections of ranged groups into a single\n * collection.\n */\nfunction concat(...groups: IRangedGroup[][]): IRangedGroup[] {\n\treturn consolidate(groups.reduce((r, g) => r.concat(g), [] as IRangedGroup[]));\n}\n\nexport class RangeMap {\n\n\tprivate groups: IRangedGroup[] = [];\n\tprivate _size = 0;\n\n\tsplice(index: number, deleteCount: number, items: IItem[] = []): void {\n\t\tconst diff = items.length - deleteCount;\n\t\tconst before = groupIntersect({ start: 0, end: index }, this.groups);\n\t\tconst after = groupIntersect({ start: index + deleteCount, end: Number.POSITIVE_INFINITY }, this.groups)\n\t\t\t.map<IRangedGroup>(g => ({ range: shift(g.range, diff), size: g.size }));\n\n\t\tconst middle = items.map<IRangedGroup>((item, i) => ({\n\t\t\trange: { start: index + i, end: index + i + 1 },\n\t\t\tsize: item.size\n\t\t}));\n\n\t\tthis.groups = concat(before, middle, after);\n\t\tthis._size = this.groups.reduce((t, g) => t + (g.size * (g.range.end - g.range.start)), 0);\n\t}\n\n\t/**\n\t * Returns the number of items in the range map.\n\t */\n\tget count(): number {\n\t\tconst len = this.groups.length;\n\n\t\tif (!len) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn this.groups[len - 1].range.end;\n\t}\n\n\t/**\n\t * Returns the sum of the sizes of all items in the range map.\n\t */\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\t/**\n\t * Returns the index of the item at the given position.\n\t */\n\tindexAt(position: number): number {\n\t\tif (position < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tlet index = 0;\n\t\tlet size = 0;\n\n\t\tfor (let group of this.groups) {\n\t\t\tconst count = group.range.end - group.range.start;\n\t\t\tconst newSize = size + (count * group.size);\n\n\t\t\tif (position < newSize) {\n\t\t\t\treturn index + Math.floor((position - size) / group.size);\n\t\t\t}\n\n\t\t\tindex += count;\n\t\t\tsize = newSize;\n\t\t}\n\n\t\treturn index;\n\t}\n\n\t/**\n\t * Returns the index of the item right after the item at the\n\t * index of the given position.\n\t */\n\tindexAfter(position: number): number {\n\t\treturn Math.min(this.indexAt(position) + 1, this.count);\n\t}\n\n\t/**\n\t * Returns the start position of the item at the given index.\n\t */\n\tpositionAt(index: number): number {\n\t\tif (index < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tlet position = 0;\n\t\tlet count = 0;\n\n\t\tfor (let group of this.groups) {\n\t\t\tconst groupCount = group.range.end - group.range.start;\n\t\t\tconst newCount = count + groupCount;\n\n\t\t\tif (index < newCount) {\n\t\t\t\treturn position + ((index - count) * group.size);\n\t\t\t}\n\n\t\t\tposition += groupCount * group.size;\n\t\t\tcount = newCount;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tdispose() {\n\t\tthis.groups = null!; // StrictNullOverride: nulling out ok in dispose\n\t}\n}"]}]}