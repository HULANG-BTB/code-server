{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/electron-browser/rawDebugSession.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/electron-browser/rawDebugSession.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/event\", \"vs/base/common/objects\", \"vs/base/common/actions\", \"vs/base/common/errors\", \"vs/workbench/contrib/debug/common/debugUtils\", \"vs/base/common/errorsWithActions\", \"child_process\"], function (require, exports, nls, event_1, objects, actions_1, errors, debugUtils_1, errorsWithActions_1, cp) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Encapsulates the DebugAdapter lifecycle and some idiosyncrasies of the Debug Adapter Protocol.\n     */\n    class RawDebugSession {\n        constructor(debugAdapter, dbgr, telemetryService, customTelemetryService, environmentService) {\n            this.telemetryService = telemetryService;\n            this.customTelemetryService = customTelemetryService;\n            this.environmentService = environmentService;\n            this.debugAdapter = debugAdapter;\n            this._capabilities = Object.create(null);\n            this._readyForBreakpoints = false;\n            this.inShutdown = false;\n            this.debugAdapterStopped = false;\n            this.firedAdapterExitEvent = false;\n            this.didReceiveStoppedEvent = false;\n            this.allThreadsContinued = true;\n            this._onDidInitialize = new event_1.Emitter();\n            this._onDidStop = new event_1.Emitter();\n            this._onDidContinued = new event_1.Emitter();\n            this._onDidTerminateDebugee = new event_1.Emitter();\n            this._onDidExitDebugee = new event_1.Emitter();\n            this._onDidThread = new event_1.Emitter();\n            this._onDidOutput = new event_1.Emitter();\n            this._onDidBreakpoint = new event_1.Emitter();\n            this._onDidLoadedSource = new event_1.Emitter();\n            this._onDidCustomEvent = new event_1.Emitter();\n            this._onDidEvent = new event_1.Emitter();\n            this._onDidExitAdapter = new event_1.Emitter();\n            this.debugAdapter.onError(err => {\n                this.shutdown(err);\n            });\n            this.debugAdapter.onExit(code => {\n                if (code !== 0) {\n                    this.shutdown(new Error(`exit code: ${code}`));\n                }\n                else {\n                    // normal exit\n                    this.shutdown();\n                }\n            });\n            this.debugAdapter.onEvent(event => {\n                switch (event.event) {\n                    case 'initialized':\n                        this._readyForBreakpoints = true;\n                        this._onDidInitialize.fire(event);\n                        break;\n                    case 'loadedSource':\n                        this._onDidLoadedSource.fire(event);\n                        break;\n                    case 'capabilities':\n                        if (event.body) {\n                            const capabilites = event.body.capabilities;\n                            this.mergeCapabilities(capabilites);\n                        }\n                        break;\n                    case 'stopped':\n                        this.didReceiveStoppedEvent = true; // telemetry: remember that debugger stopped successfully\n                        this._onDidStop.fire(event);\n                        break;\n                    case 'continued':\n                        this.allThreadsContinued = event.body.allThreadsContinued === false ? false : true;\n                        this._onDidContinued.fire(event);\n                        break;\n                    case 'thread':\n                        this._onDidThread.fire(event);\n                        break;\n                    case 'output':\n                        this._onDidOutput.fire(event);\n                        break;\n                    case 'breakpoint':\n                        this._onDidBreakpoint.fire(event);\n                        break;\n                    case 'terminated':\n                        this._onDidTerminateDebugee.fire(event);\n                        break;\n                    case 'exit':\n                        this._onDidExitDebugee.fire(event);\n                        break;\n                    default:\n                        this._onDidCustomEvent.fire(event);\n                        break;\n                }\n                this._onDidEvent.fire(event);\n            });\n            this.debugAdapter.onRequest(request => this.dispatchRequest(request, dbgr));\n        }\n        get onDidExitAdapter() {\n            return this._onDidExitAdapter.event;\n        }\n        get capabilities() {\n            return this._capabilities;\n        }\n        /**\n         * DA is ready to accepts setBreakpoint requests.\n         * Becomes true after \"initialized\" events has been received.\n         */\n        get readyForBreakpoints() {\n            return this._readyForBreakpoints;\n        }\n        //---- DAP events\n        get onDidInitialize() {\n            return this._onDidInitialize.event;\n        }\n        get onDidStop() {\n            return this._onDidStop.event;\n        }\n        get onDidContinued() {\n            return this._onDidContinued.event;\n        }\n        get onDidTerminateDebugee() {\n            return this._onDidTerminateDebugee.event;\n        }\n        get onDidExitDebugee() {\n            return this._onDidExitDebugee.event;\n        }\n        get onDidThread() {\n            return this._onDidThread.event;\n        }\n        get onDidOutput() {\n            return this._onDidOutput.event;\n        }\n        get onDidBreakpoint() {\n            return this._onDidBreakpoint.event;\n        }\n        get onDidLoadedSource() {\n            return this._onDidLoadedSource.event;\n        }\n        get onDidCustomEvent() {\n            return this._onDidCustomEvent.event;\n        }\n        get onDidEvent() {\n            return this._onDidEvent.event;\n        }\n        //---- DebugAdapter lifecycle\n        /**\n         * Starts the underlying debug adapter and tracks the session time for telemetry.\n         */\n        start() {\n            if (!this.debugAdapter) {\n                return Promise.reject(new Error('no debug adapter'));\n            }\n            return this.debugAdapter.startSession().then(() => {\n                this.startTime = new Date().getTime();\n            }, err => {\n                return Promise.reject(err);\n            });\n        }\n        /**\n         * Send client capabilities to the debug adapter and receive DA capabilities in return.\n         */\n        initialize(args) {\n            return this.send('initialize', args).then((response) => {\n                this.mergeCapabilities(response.body);\n                return response;\n            });\n        }\n        /**\n         * Terminate the debuggee and shutdown the adapter\n         */\n        disconnect(restart = false) {\n            return this.shutdown(undefined, restart);\n        }\n        //---- DAP requests\n        launchOrAttach(config) {\n            return this.send(config.request, config).then(response => {\n                this.mergeCapabilities(response.body);\n                return response;\n            });\n        }\n        /**\n         * Try killing the debuggee softly...\n         */\n        terminate(restart = false) {\n            if (this.capabilities.supportsTerminateRequest) {\n                if (!this.terminated) {\n                    this.terminated = true;\n                    return this.send('terminate', { restart });\n                }\n                return this.disconnect(restart);\n            }\n            return Promise.reject(new Error('terminated not supported'));\n        }\n        restart() {\n            if (this.capabilities.supportsRestartRequest) {\n                return this.send('restart', null);\n            }\n            return Promise.reject(new Error('restart not supported'));\n        }\n        next(args) {\n            return this.send('next', args).then(response => {\n                this.fireSimulatedContinuedEvent(args.threadId);\n                return response;\n            });\n        }\n        stepIn(args) {\n            return this.send('stepIn', args).then(response => {\n                this.fireSimulatedContinuedEvent(args.threadId);\n                return response;\n            });\n        }\n        stepOut(args) {\n            return this.send('stepOut', args).then(response => {\n                this.fireSimulatedContinuedEvent(args.threadId);\n                return response;\n            });\n        }\n        continue(args) {\n            return this.send('continue', args).then(response => {\n                if (response && response.body && response.body.allThreadsContinued !== undefined) {\n                    this.allThreadsContinued = response.body.allThreadsContinued;\n                }\n                this.fireSimulatedContinuedEvent(args.threadId, this.allThreadsContinued);\n                return response;\n            });\n        }\n        pause(args) {\n            return this.send('pause', args);\n        }\n        terminateThreads(args) {\n            if (this.capabilities.supportsTerminateThreadsRequest) {\n                return this.send('terminateThreads', args);\n            }\n            return Promise.reject(new Error('terminateThreads not supported'));\n        }\n        setVariable(args) {\n            if (this.capabilities.supportsSetVariable) {\n                return this.send('setVariable', args);\n            }\n            return Promise.reject(new Error('setVariable not supported'));\n        }\n        restartFrame(args, threadId) {\n            if (this.capabilities.supportsRestartFrame) {\n                return this.send('restartFrame', args).then(response => {\n                    this.fireSimulatedContinuedEvent(threadId);\n                    return response;\n                });\n            }\n            return Promise.reject(new Error('restartFrame not supported'));\n        }\n        completions(args) {\n            if (this.capabilities.supportsCompletionsRequest) {\n                return this.send('completions', args);\n            }\n            return Promise.reject(new Error('completions not supported'));\n        }\n        setBreakpoints(args) {\n            return this.send('setBreakpoints', args);\n        }\n        setFunctionBreakpoints(args) {\n            if (this.capabilities.supportsFunctionBreakpoints) {\n                return this.send('setFunctionBreakpoints', args);\n            }\n            return Promise.reject(new Error('setFunctionBreakpoints not supported'));\n        }\n        setExceptionBreakpoints(args) {\n            return this.send('setExceptionBreakpoints', args);\n        }\n        configurationDone() {\n            if (this.capabilities.supportsConfigurationDoneRequest) {\n                return this.send('configurationDone', null);\n            }\n            return Promise.reject(new Error('configurationDone not supported'));\n        }\n        stackTrace(args) {\n            return this.send('stackTrace', args);\n        }\n        exceptionInfo(args) {\n            if (this.capabilities.supportsExceptionInfoRequest) {\n                return this.send('exceptionInfo', args);\n            }\n            return Promise.reject(new Error('exceptionInfo not supported'));\n        }\n        scopes(args) {\n            return this.send('scopes', args);\n        }\n        variables(args) {\n            return this.send('variables', args);\n        }\n        source(args) {\n            return this.send('source', args);\n        }\n        loadedSources(args) {\n            if (this.capabilities.supportsLoadedSourcesRequest) {\n                return this.send('loadedSources', args);\n            }\n            return Promise.reject(new Error('loadedSources not supported'));\n        }\n        threads() {\n            return this.send('threads', null);\n        }\n        evaluate(args) {\n            return this.send('evaluate', args);\n        }\n        stepBack(args) {\n            if (this.capabilities.supportsStepBack) {\n                return this.send('stepBack', args).then(response => {\n                    if (response.body === undefined) { // TODO@AW why this check?\n                        this.fireSimulatedContinuedEvent(args.threadId);\n                    }\n                    return response;\n                });\n            }\n            return Promise.reject(new Error('stepBack not supported'));\n        }\n        reverseContinue(args) {\n            if (this.capabilities.supportsStepBack) {\n                return this.send('reverseContinue', args).then(response => {\n                    if (response.body === undefined) { // TODO@AW why this check?\n                        this.fireSimulatedContinuedEvent(args.threadId);\n                    }\n                    return response;\n                });\n            }\n            return Promise.reject(new Error('reverseContinue not supported'));\n        }\n        custom(request, args) {\n            return this.send(request, args);\n        }\n        //---- private\n        shutdown(error, restart = false) {\n            if (!this.inShutdown) {\n                this.inShutdown = true;\n                if (this.debugAdapter) {\n                    return this.send('disconnect', { restart }, 500).then(() => {\n                        this.stopAdapter(error);\n                    }, () => {\n                        // ignore error\n                        this.stopAdapter(error);\n                    });\n                }\n                return this.stopAdapter(error);\n            }\n            return Promise.resolve(undefined);\n        }\n        stopAdapter(error) {\n            if (this.debugAdapter) {\n                const da = this.debugAdapter;\n                this.debugAdapter = null;\n                return da.stopSession().then(_ => {\n                    this.debugAdapterStopped = true;\n                    this.fireAdapterExitEvent(error);\n                }, err => {\n                    this.fireAdapterExitEvent(error);\n                });\n            }\n            else {\n                this.fireAdapterExitEvent(error);\n            }\n            return Promise.resolve(undefined);\n        }\n        fireAdapterExitEvent(error) {\n            if (!this.firedAdapterExitEvent) {\n                this.firedAdapterExitEvent = true;\n                const e = {\n                    emittedStopped: this.didReceiveStoppedEvent,\n                    sessionLengthInSeconds: (new Date().getTime() - this.startTime) / 1000\n                };\n                if (error && !this.debugAdapterStopped) {\n                    e.error = error;\n                }\n                this._onDidExitAdapter.fire(e);\n            }\n        }\n        dispatchRequest(request, dbgr) {\n            const response = {\n                type: 'response',\n                seq: 0,\n                command: request.command,\n                request_seq: request.seq,\n                success: true\n            };\n            const safeSendResponse = (response) => this.debugAdapter && this.debugAdapter.sendResponse(response);\n            switch (request.command) {\n                case 'launchVSCode':\n                    this.launchVsCode(request.arguments).then(pid => {\n                        response.body = {\n                            processId: pid\n                        };\n                        safeSendResponse(response);\n                    }, err => {\n                        response.success = false;\n                        response.message = err.message;\n                        safeSendResponse(response);\n                    });\n                    break;\n                case 'runInTerminal':\n                    dbgr.runInTerminal(request.arguments).then(shellProcessId => {\n                        const resp = response;\n                        resp.body = {};\n                        if (typeof shellProcessId === 'number') {\n                            resp.body.shellProcessId = shellProcessId;\n                        }\n                        safeSendResponse(resp);\n                    }, err => {\n                        response.success = false;\n                        response.message = err.message;\n                        safeSendResponse(response);\n                    });\n                    break;\n                case 'handshake':\n                    try {\n                        const vsda = require.__$__nodeRequire('vsda');\n                        const obj = new vsda.signer();\n                        const sig = obj.sign(request.arguments.value);\n                        response.body = {\n                            signature: sig\n                        };\n                        safeSendResponse(response);\n                    }\n                    catch (e) {\n                        response.success = false;\n                        response.message = e.message;\n                        safeSendResponse(response);\n                    }\n                    break;\n                default:\n                    response.success = false;\n                    response.message = `unknown request '${request.command}'`;\n                    safeSendResponse(response);\n                    break;\n            }\n        }\n        launchVsCode(vscodeArgs) {\n            const spawnOpts = {\n                detached: false // https://github.com/Microsoft/vscode/issues/57018\n            };\n            if (vscodeArgs.env) {\n                // merge environment variables into a copy of the process.env\n                const envArgs = objects.mixin(objects.mixin({}, process.env), vscodeArgs.env);\n                // and delete some if necessary\n                Object.keys(envArgs).filter(k => envArgs[k] === null).forEach(key => delete envArgs[key]);\n                spawnOpts.env = envArgs;\n            }\n            let spawnArgs = vscodeArgs.args.map(a => {\n                if ((a.prefix === '--file-uri=' || a.prefix === '--folder-uri=') && !debugUtils_1.isUri(a.path)) {\n                    return (a.path || '');\n                }\n                return (a.prefix || '') + (a.path || '');\n            });\n            let runtimeExecutable = this.environmentService['execPath'];\n            if (!runtimeExecutable) {\n                return Promise.reject(new Error(`VS Code executable unknown`));\n            }\n            // if VS Code runs out of sources, add the VS Code workspace path as the first argument so that Electron turns into VS Code\n            const electronIdx = runtimeExecutable.indexOf(process.platform === 'win32' ? '\\\\.build\\\\electron\\\\' : '/.build/electron/');\n            if (electronIdx > 0) {\n                // guess the VS Code workspace path from the executable\n                const vscodeWorkspacePath = runtimeExecutable.substr(0, electronIdx);\n                // only add VS Code workspace path if user hasn't already added that path as a (folder) argument\n                const x = spawnArgs.filter(a => a.indexOf(vscodeWorkspacePath) === 0);\n                if (x.length === 0) {\n                    spawnArgs.unshift(vscodeWorkspacePath);\n                }\n            }\n            // Workaround for bug Microsoft/vscode#45832\n            if (process.platform === 'win32' && runtimeExecutable.indexOf(' ') > 0) {\n                let foundArgWithSpace = false;\n                // check whether there is one arg with a space\n                const args = [];\n                for (const a of spawnArgs) {\n                    if (a.indexOf(' ') > 0) {\n                        args.push(`\"${a}\"`);\n                        foundArgWithSpace = true;\n                    }\n                    else {\n                        args.push(a);\n                    }\n                }\n                if (foundArgWithSpace) {\n                    spawnArgs = args;\n                    runtimeExecutable = `\"${runtimeExecutable}\"`;\n                    spawnOpts.shell = true;\n                }\n            }\n            return new Promise((resolve, reject) => {\n                const process = cp.spawn(runtimeExecutable, spawnArgs, spawnOpts);\n                process.on('error', error => {\n                    reject(error);\n                });\n                process.on('exit', code => {\n                    if (code === 0) {\n                        resolve(process.pid);\n                    }\n                    else {\n                        reject(new Error(`VS Code exited with ${code}`));\n                    }\n                });\n            });\n        }\n        send(command, args, timeout) {\n            return new Promise((completeDispatch, errorDispatch) => {\n                if (!this.debugAdapter) {\n                    errorDispatch(new Error('no debug adapter found'));\n                    return;\n                }\n                this.debugAdapter.sendRequest(command, args, (response) => {\n                    if (response.success) {\n                        completeDispatch(response);\n                    }\n                    else {\n                        errorDispatch(response);\n                    }\n                }, timeout);\n            }).then(response => response, err => Promise.reject(this.handleErrorResponse(err)));\n        }\n        handleErrorResponse(errorResponse) {\n            if (errorResponse.command === 'canceled' && errorResponse.message === 'canceled') {\n                return errors.canceled();\n            }\n            const error = errorResponse && errorResponse.body ? errorResponse.body.error : null;\n            const errorMessage = errorResponse ? errorResponse.message || '' : '';\n            if (error && error.sendTelemetry) {\n                const telemetryMessage = error ? debugUtils_1.formatPII(error.format, true, error.variables) : errorMessage;\n                this.telemetryDebugProtocolErrorResponse(telemetryMessage);\n            }\n            const userMessage = error ? debugUtils_1.formatPII(error.format, false, error.variables) : errorMessage;\n            if (error && error.url) {\n                const label = error.urlLabel ? error.urlLabel : nls.localize('moreInfo', \"More Info\");\n                return errorsWithActions_1.createErrorWithActions(userMessage, {\n                    actions: [new actions_1.Action('debug.moreInfo', label, undefined, true, () => {\n                            window.open(error.url);\n                            return Promise.resolve(null);\n                        })]\n                });\n            }\n            return new Error(userMessage);\n        }\n        mergeCapabilities(capabilities) {\n            if (capabilities) {\n                this._capabilities = objects.mixin(this._capabilities, capabilities);\n            }\n        }\n        fireSimulatedContinuedEvent(threadId, allThreadsContinued = false) {\n            this._onDidContinued.fire({\n                type: 'event',\n                event: 'continued',\n                body: {\n                    threadId,\n                    allThreadsContinued\n                },\n                seq: undefined\n            });\n        }\n        telemetryDebugProtocolErrorResponse(telemetryMessage) {\n            /* __GDPR__\n                \"debugProtocolErrorResponse\" : {\n                    \"error\" : { \"classification\": \"CallstackOrException\", \"purpose\": \"FeatureInsight\" }\n                }\n            */\n            this.telemetryService.publicLog('debugProtocolErrorResponse', { error: telemetryMessage });\n            if (this.customTelemetryService) {\n                /* __GDPR__TODO__\n                    The message is sent in the name of the adapter but the adapter doesn't know about it.\n                    However, since adapters are an open-ended set, we can not declared the events statically either.\n                */\n                this.customTelemetryService.publicLog('debugProtocolErrorResponse', { error: telemetryMessage });\n            }\n        }\n    }\n    exports.RawDebugSession = RawDebugSession;\n});\n",null]}