{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/configurationResolver/common/variableResolver.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/configurationResolver/common/variableResolver.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/path\", \"vs/base/common/process\", \"vs/base/common/types\", \"vs/base/common/objects\", \"vs/base/common/platform\", \"vs/base/common/labels\", \"vs/nls\"], function (require, exports, paths, process, types, objects, platform_1, labels_1, nls_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class AbstractVariableResolverService {\n        constructor(_context, _envVariables) {\n            this._context = _context;\n            this._envVariables = _envVariables;\n            if (platform_1.isWindows) {\n                this._envVariables = Object.create(null);\n                Object.keys(_envVariables).forEach(key => {\n                    this._envVariables[key.toLowerCase()] = _envVariables[key];\n                });\n            }\n        }\n        resolve(root, value) {\n            return this.recursiveResolve(root ? root.uri : undefined, value);\n        }\n        resolveAnyBase(workspaceFolder, config, commandValueMapping, resolvedVariables) {\n            const result = objects.deepClone(config);\n            // hoist platform specific attributes to top level\n            if (platform_1.isWindows && result.windows) {\n                Object.keys(result.windows).forEach(key => result[key] = result.windows[key]);\n            }\n            else if (platform_1.isMacintosh && result.osx) {\n                Object.keys(result.osx).forEach(key => result[key] = result.osx[key]);\n            }\n            else if (platform_1.isLinux && result.linux) {\n                Object.keys(result.linux).forEach(key => result[key] = result.linux[key]);\n            }\n            // delete all platform specific sections\n            delete result.windows;\n            delete result.osx;\n            delete result.linux;\n            // substitute all variables recursively in string values\n            return this.recursiveResolve(workspaceFolder ? workspaceFolder.uri : undefined, result, commandValueMapping, resolvedVariables);\n        }\n        resolveAny(workspaceFolder, config, commandValueMapping) {\n            return this.resolveAnyBase(workspaceFolder, config, commandValueMapping);\n        }\n        resolveAnyMap(workspaceFolder, config, commandValueMapping) {\n            const resolvedVariables = new Map();\n            const newConfig = this.resolveAnyBase(workspaceFolder, config, commandValueMapping, resolvedVariables);\n            return { newConfig, resolvedVariables };\n        }\n        resolveWithInteractionReplace(folder, config, section, variables) {\n            throw new Error('resolveWithInteractionReplace not implemented.');\n        }\n        resolveWithInteraction(folder, config, section, variables) {\n            throw new Error('resolveWithInteraction not implemented.');\n        }\n        recursiveResolve(folderUri, value, commandValueMapping, resolvedVariables) {\n            if (types.isString(value)) {\n                return this.resolveString(folderUri, value, commandValueMapping, resolvedVariables);\n            }\n            else if (types.isArray(value)) {\n                return value.map(s => this.recursiveResolve(folderUri, s, commandValueMapping, resolvedVariables));\n            }\n            else if (types.isObject(value)) {\n                let result = Object.create(null);\n                Object.keys(value).forEach(key => {\n                    const replaced = this.resolveString(folderUri, key, commandValueMapping, resolvedVariables);\n                    result[replaced] = this.recursiveResolve(folderUri, value[key], commandValueMapping, resolvedVariables);\n                });\n                return result;\n            }\n            return value;\n        }\n        resolveString(folderUri, value, commandValueMapping, resolvedVariables) {\n            // loop through all variables occurrences in 'value'\n            const replaced = value.replace(AbstractVariableResolverService.VARIABLE_REGEXP, (match, variable) => {\n                let resolvedValue = this.evaluateSingleVariable(match, variable, folderUri, commandValueMapping);\n                if (resolvedVariables) {\n                    resolvedVariables.set(variable, resolvedValue);\n                }\n                return resolvedValue;\n            });\n            return replaced;\n        }\n        evaluateSingleVariable(match, variable, folderUri, commandValueMapping) {\n            // try to separate variable arguments from variable name\n            let argument;\n            const parts = variable.split(':');\n            if (parts.length > 1) {\n                variable = parts[0];\n                argument = parts[1];\n            }\n            // common error handling for all variables that require an open editor\n            const getFilePath = () => {\n                const filePath = this._context.getFilePath();\n                if (filePath) {\n                    return filePath;\n                }\n                throw new Error(nls_1.localize('canNotResolveFile', \"'{0}' can not be resolved. Please open an editor.\", match));\n            };\n            // common error handling for all variables that require an open folder and accept a folder name argument\n            const getFolderUri = (withArg = true) => {\n                if (withArg && argument) {\n                    const folder = this._context.getFolderUri(argument);\n                    if (folder) {\n                        return folder;\n                    }\n                    throw new Error(nls_1.localize('canNotFindFolder', \"'{0}' can not be resolved. No such folder '{1}'.\", match, argument));\n                }\n                if (folderUri) {\n                    return folderUri;\n                }\n                if (this._context.getWorkspaceFolderCount() > 1) {\n                    throw new Error(nls_1.localize('canNotResolveWorkspaceFolderMultiRoot', \"'{0}' can not be resolved in a multi folder workspace. Scope this variable using ':' and a workspace folder name.\", match));\n                }\n                throw new Error(nls_1.localize('canNotResolveWorkspaceFolder', \"'{0}' can not be resolved. Please open a folder.\", match));\n            };\n            switch (variable) {\n                case 'env':\n                    if (argument) {\n                        if (platform_1.isWindows) {\n                            argument = argument.toLowerCase();\n                        }\n                        const env = this._envVariables[argument];\n                        if (types.isString(env)) {\n                            return env;\n                        }\n                        // For `env` we should do the same as a normal shell does - evaluates missing envs to an empty string #46436\n                        return '';\n                    }\n                    throw new Error(nls_1.localize('missingEnvVarName', \"'{0}' can not be resolved because no environment variable name is given.\", match));\n                case 'config':\n                    if (argument) {\n                        const config = this._context.getConfigurationValue(getFolderUri(false), argument);\n                        if (types.isUndefinedOrNull(config)) {\n                            throw new Error(nls_1.localize('configNotFound', \"'{0}' can not be resolved because setting '{1}' not found.\", match, argument));\n                        }\n                        if (types.isObject(config)) {\n                            throw new Error(nls_1.localize('configNoString', \"'{0}' can not be resolved because '{1}' is a structured value.\", match, argument));\n                        }\n                        return config;\n                    }\n                    throw new Error(nls_1.localize('missingConfigName', \"'{0}' can not be resolved because no settings name is given.\", match));\n                case 'command':\n                    return this.resolveFromMap(match, argument, commandValueMapping, 'command');\n                case 'input':\n                    return this.resolveFromMap(match, argument, commandValueMapping, 'input');\n                default: {\n                    switch (variable) {\n                        case 'workspaceRoot':\n                        case 'workspaceFolder':\n                            return labels_1.normalizeDriveLetter(getFolderUri().fsPath);\n                        case 'cwd':\n                            return (folderUri ? labels_1.normalizeDriveLetter(getFolderUri().fsPath) : process.cwd());\n                        case 'workspaceRootFolderName':\n                        case 'workspaceFolderBasename':\n                            return paths.basename(getFolderUri().fsPath);\n                        case 'lineNumber':\n                            const lineNumber = this._context.getLineNumber();\n                            if (lineNumber) {\n                                return lineNumber;\n                            }\n                            throw new Error(nls_1.localize('canNotResolveLineNumber', \"'{0}' can not be resolved. Make sure to have a line selected in the active editor.\", match));\n                        case 'selectedText':\n                            const selectedText = this._context.getSelectedText();\n                            if (selectedText) {\n                                return selectedText;\n                            }\n                            throw new Error(nls_1.localize('canNotResolveSelectedText', \"'{0}' can not be resolved. Make sure to have some text selected in the active editor.\", match));\n                        case 'file':\n                            return getFilePath();\n                        case 'relativeFile':\n                            if (folderUri) {\n                                return paths.normalize(paths.relative(getFolderUri().fsPath, getFilePath()));\n                            }\n                            return getFilePath();\n                        case 'fileDirname':\n                            return paths.dirname(getFilePath());\n                        case 'fileExtname':\n                            return paths.extname(getFilePath());\n                        case 'fileBasename':\n                            return paths.basename(getFilePath());\n                        case 'fileBasenameNoExtension':\n                            const basename = paths.basename(getFilePath());\n                            return (basename.slice(0, basename.length - paths.extname(basename).length));\n                        case 'execPath':\n                            const ep = this._context.getExecPath();\n                            if (ep) {\n                                return ep;\n                            }\n                            return match;\n                        default:\n                            return match;\n                    }\n                }\n            }\n        }\n        resolveFromMap(match, argument, commandValueMapping, prefix) {\n            if (argument && commandValueMapping) {\n                const v = commandValueMapping[prefix + ':' + argument];\n                if (typeof v === 'string') {\n                    return v;\n                }\n                throw new Error(nls_1.localize('noValueForCommand', \"'{0}' can not be resolved because the command has no value.\", match));\n            }\n            return match;\n        }\n    }\n    AbstractVariableResolverService.VARIABLE_REGEXP = /\\$\\{(.*?)\\}/g;\n    exports.AbstractVariableResolverService = AbstractVariableResolverService;\n});\n",null]}