{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursorTypeOperations.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursorTypeOperations.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/charCode\", \"vs/base/common/errors\", \"vs/base/common/strings\", \"vs/editor/common/commands/replaceCommand\", \"vs/editor/common/commands/shiftCommand\", \"vs/editor/common/commands/surroundSelectionCommand\", \"vs/editor/common/controller/cursorCommon\", \"vs/editor/common/controller/wordCharacterClassifier\", \"vs/editor/common/core/range\", \"vs/editor/common/modes/languageConfiguration\", \"vs/editor/common/modes/languageConfigurationRegistry\"], function (require, exports, charCode_1, errors_1, strings, replaceCommand_1, shiftCommand_1, surroundSelectionCommand_1, cursorCommon_1, wordCharacterClassifier_1, range_1, languageConfiguration_1, languageConfigurationRegistry_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class TypeOperations {\n        static indent(config, model, selections) {\n            if (model === null || selections === null) {\n                return [];\n            }\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = new shiftCommand_1.ShiftCommand(selections[i], {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops\n                });\n            }\n            return commands;\n        }\n        static outdent(config, model, selections) {\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = new shiftCommand_1.ShiftCommand(selections[i], {\n                    isUnshift: true,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops\n                });\n            }\n            return commands;\n        }\n        static shiftIndent(config, indentation, count) {\n            count = count || 1;\n            return shiftCommand_1.ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n        }\n        static unshiftIndent(config, indentation, count) {\n            count = count || 1;\n            return shiftCommand_1.ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n        }\n        static _distributedPaste(config, model, selections, text) {\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = new replaceCommand_1.ReplaceCommand(selections[i], text[i]);\n            }\n            return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Other, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: true\n            });\n        }\n        static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                const selection = selections[i];\n                let position = selection.getPosition();\n                if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                    pasteOnNewLine = false;\n                }\n                if (pasteOnNewLine && selection.startLineNumber !== selection.endLineNumber) {\n                    pasteOnNewLine = false;\n                }\n                if (pasteOnNewLine && selection.startColumn === model.getLineMinColumn(selection.startLineNumber) && selection.endColumn === model.getLineMaxColumn(selection.startLineNumber)) {\n                    pasteOnNewLine = false;\n                }\n                if (pasteOnNewLine) {\n                    // Paste entire line at the beginning of line\n                    let typeSelection = new range_1.Range(position.lineNumber, 1, position.lineNumber, 1);\n                    commands[i] = new replaceCommand_1.ReplaceCommand(typeSelection, text);\n                }\n                else {\n                    commands[i] = new replaceCommand_1.ReplaceCommand(selection, text);\n                }\n            }\n            return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Other, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: true\n            });\n        }\n        static _distributePasteToCursors(selections, text, pasteOnNewLine, multicursorText) {\n            if (pasteOnNewLine) {\n                return null;\n            }\n            if (selections.length === 1) {\n                return null;\n            }\n            if (multicursorText && multicursorText.length === selections.length) {\n                return multicursorText;\n            }\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === charCode_1.CharCode.LineFeed) {\n                text = text.substr(0, text.length - 1);\n            }\n            let lines = text.split(/\\r\\n|\\r|\\n/);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n            return null;\n        }\n        static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n            const distributedPaste = this._distributePasteToCursors(selections, text, pasteOnNewLine, multicursorText);\n            if (distributedPaste) {\n                selections = selections.sort(range_1.Range.compareRangesUsingStarts);\n                return this._distributedPaste(config, model, selections, distributedPaste);\n            }\n            else {\n                return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n            }\n        }\n        static _goodIndentForLine(config, model, lineNumber) {\n            let action = null;\n            let indentation = '';\n            let expectedIndentAction = config.autoIndent ? languageConfigurationRegistry_1.LanguageConfigurationRegistry.getInheritIndentForLine(model, lineNumber, false) : null;\n            if (expectedIndentAction) {\n                action = expectedIndentAction.action;\n                indentation = expectedIndentAction.indentation;\n            }\n            else if (lineNumber > 1) {\n                let lastLineNumber;\n                for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                    let lineText = model.getLineContent(lastLineNumber);\n                    let nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                    if (nonWhitespaceIdx >= 0) {\n                        break;\n                    }\n                }\n                if (lastLineNumber < 1) {\n                    // No previous line with content found\n                    return null;\n                }\n                let maxColumn = model.getLineMaxColumn(lastLineNumber);\n                let expectedEnterAction = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getEnterAction(model, new range_1.Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn));\n                if (expectedEnterAction) {\n                    indentation = expectedEnterAction.indentation;\n                    action = expectedEnterAction.enterAction;\n                    if (action) {\n                        indentation += action.appendText;\n                    }\n                }\n            }\n            if (action) {\n                if (action === languageConfiguration_1.IndentAction.Indent) {\n                    indentation = TypeOperations.shiftIndent(config, indentation);\n                }\n                if (action === languageConfiguration_1.IndentAction.Outdent) {\n                    indentation = TypeOperations.unshiftIndent(config, indentation);\n                }\n                indentation = config.normalizeIndentation(indentation);\n            }\n            if (!indentation) {\n                return null;\n            }\n            return indentation;\n        }\n        static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n            let typeText = '';\n            let position = selection.getStartPosition();\n            if (config.insertSpaces) {\n                let visibleColumnFromColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn2(config, model, position);\n                let indentSize = config.indentSize;\n                let spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n                for (let i = 0; i < spacesCnt; i++) {\n                    typeText += ' ';\n                }\n            }\n            else {\n                typeText = '\\t';\n            }\n            return new replaceCommand_1.ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n        }\n        static tab(config, model, selections) {\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                const selection = selections[i];\n                if (selection.isEmpty()) {\n                    let lineText = model.getLineContent(selection.startLineNumber);\n                    if (/^\\s*$/.test(lineText) && model.isCheapToTokenize(selection.startLineNumber)) {\n                        let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                        goodIndent = goodIndent || '\\t';\n                        let possibleTypeText = config.normalizeIndentation(goodIndent);\n                        if (!strings.startsWith(lineText, possibleTypeText)) {\n                            commands[i] = new replaceCommand_1.ReplaceCommand(new range_1.Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                            continue;\n                        }\n                    }\n                    commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n                }\n                else {\n                    if (selection.startLineNumber === selection.endLineNumber) {\n                        let lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                        if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                            // This is a single line selection that is not the entire line\n                            commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                            continue;\n                        }\n                    }\n                    commands[i] = new shiftCommand_1.ShiftCommand(selection, {\n                        isUnshift: false,\n                        tabSize: config.tabSize,\n                        indentSize: config.indentSize,\n                        insertSpaces: config.insertSpaces,\n                        useTabStops: config.useTabStops\n                    });\n                }\n            }\n            return commands;\n        }\n        static replacePreviousChar(prevEditOperationType, config, model, selections, txt, replaceCharCnt) {\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                const selection = selections[i];\n                if (!selection.isEmpty()) {\n                    // looks like https://github.com/Microsoft/vscode/issues/2773\n                    // where a cursor operation occurred before a canceled composition\n                    // => ignore composition\n                    commands[i] = null;\n                    continue;\n                }\n                let pos = selection.getPosition();\n                let startColumn = Math.max(1, pos.column - replaceCharCnt);\n                let range = new range_1.Range(pos.lineNumber, startColumn, pos.lineNumber, pos.column);\n                commands[i] = new replaceCommand_1.ReplaceCommand(range, txt);\n            }\n            return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, commands, {\n                shouldPushStackElementBefore: (prevEditOperationType !== cursorCommon_1.EditOperationType.Typing),\n                shouldPushStackElementAfter: false\n            });\n        }\n        static _typeCommand(range, text, keepPosition) {\n            if (keepPosition) {\n                return new replaceCommand_1.ReplaceCommandWithoutChangingPosition(range, text, true);\n            }\n            else {\n                return new replaceCommand_1.ReplaceCommand(range, text, true);\n            }\n        }\n        static _enter(config, model, keepPosition, range) {\n            if (!model.isCheapToTokenize(range.getStartPosition().lineNumber)) {\n                let lineText = model.getLineContent(range.startLineNumber);\n                let indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n            }\n            let r = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getEnterAction(model, range);\n            if (r) {\n                let enterAction = r.enterAction;\n                let indentation = r.indentation;\n                if (enterAction.indentAction === languageConfiguration_1.IndentAction.None) {\n                    // Nothing special\n                    return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation + enterAction.appendText), keepPosition);\n                }\n                else if (enterAction.indentAction === languageConfiguration_1.IndentAction.Indent) {\n                    // Indent once\n                    return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation + enterAction.appendText), keepPosition);\n                }\n                else if (enterAction.indentAction === languageConfiguration_1.IndentAction.IndentOutdent) {\n                    // Ultra special\n                    let normalIndent = config.normalizeIndentation(indentation);\n                    let increasedIndent = config.normalizeIndentation(indentation + enterAction.appendText);\n                    let typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                    if (keepPosition) {\n                        return new replaceCommand_1.ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                    }\n                    else {\n                        return new replaceCommand_1.ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                    }\n                }\n                else if (enterAction.indentAction === languageConfiguration_1.IndentAction.Outdent) {\n                    let actualIndentation = TypeOperations.unshiftIndent(config, indentation);\n                    return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + enterAction.appendText), keepPosition);\n                }\n            }\n            // no enter rules applied, we should check indentation rules then.\n            if (!config.autoIndent) {\n                // Nothing special\n                let lineText = model.getLineContent(range.startLineNumber);\n                let indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n            }\n            let ir = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getIndentForEnter(model, range, {\n                unshiftIndent: (indent) => {\n                    return TypeOperations.unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return TypeOperations.shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            }, config.autoIndent);\n            let lineText = model.getLineContent(range.startLineNumber);\n            let indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            if (ir) {\n                let oldEndViewColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn2(config, model, range.getEndPosition());\n                let oldEndColumn = range.endColumn;\n                let beforeText = '\\n';\n                if (indentation !== config.normalizeIndentation(ir.beforeEnter)) {\n                    beforeText = config.normalizeIndentation(ir.beforeEnter) + lineText.substring(indentation.length, range.startColumn - 1) + '\\n';\n                    range = new range_1.Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn);\n                }\n                let newLineContent = model.getLineContent(range.endLineNumber);\n                let firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new replaceCommand_1.ReplaceCommandWithoutChangingPosition(range, beforeText + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new replaceCommand_1.ReplaceCommandWithOffsetCursorState(range, beforeText + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n            else {\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n            }\n        }\n        static _isAutoIndentType(config, model, selections) {\n            if (!config.autoIndent) {\n                return false;\n            }\n            for (let i = 0, len = selections.length; i < len; i++) {\n                if (!model.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        static _runAutoIndentType(config, model, range, ch) {\n            let currentIndentation = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n            let actualIndentation = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getIndentActionForType(model, range, ch, {\n                shiftIndent: (indentation) => {\n                    return TypeOperations.shiftIndent(config, indentation);\n                },\n                unshiftIndent: (indentation) => {\n                    return TypeOperations.unshiftIndent(config, indentation);\n                },\n            });\n            if (actualIndentation === null) {\n                return null;\n            }\n            if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n                let firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n                if (firstNonWhitespace === 0) {\n                    return TypeOperations._typeCommand(new range_1.Range(range.startLineNumber, 0, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n                }\n                else {\n                    return TypeOperations._typeCommand(new range_1.Range(range.startLineNumber, 0, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +\n                        model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n                }\n            }\n            return null;\n        }\n        static _isAutoClosingCloseCharType(config, model, selections, ch) {\n            const autoCloseConfig = cursorCommon_1.isQuote(ch) ? config.autoClosingQuotes : config.autoClosingBrackets;\n            if (autoCloseConfig === 'never' || !config.autoClosingPairsClose.hasOwnProperty(ch)) {\n                return false;\n            }\n            const isEqualPair = (ch === config.autoClosingPairsClose[ch]);\n            for (let i = 0, len = selections.length; i < len; i++) {\n                const selection = selections[i];\n                if (!selection.isEmpty()) {\n                    return false;\n                }\n                const position = selection.getPosition();\n                const lineText = model.getLineContent(position.lineNumber);\n                const afterCharacter = lineText.charAt(position.column - 1);\n                if (afterCharacter !== ch) {\n                    return false;\n                }\n                if (isEqualPair) {\n                    const lineTextBeforeCursor = lineText.substr(0, position.column - 1);\n                    const chCntBefore = this._countNeedlesInHaystack(lineTextBeforeCursor, ch);\n                    if (chCntBefore % 2 === 0) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        static _countNeedlesInHaystack(haystack, needle) {\n            let cnt = 0;\n            let lastIndex = -1;\n            while ((lastIndex = haystack.indexOf(needle, lastIndex + 1)) !== -1) {\n                cnt++;\n            }\n            return cnt;\n        }\n        static _runAutoClosingCloseCharType(prevEditOperationType, config, model, selections, ch) {\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                const selection = selections[i];\n                const position = selection.getPosition();\n                const typeSelection = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n                commands[i] = new replaceCommand_1.ReplaceCommand(typeSelection, ch);\n            }\n            return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, commands, {\n                shouldPushStackElementBefore: (prevEditOperationType !== cursorCommon_1.EditOperationType.Typing),\n                shouldPushStackElementAfter: false\n            });\n        }\n        static _isBeforeClosingBrace(config, ch, characterAfter) {\n            const thisBraceIsSymmetric = (config.autoClosingPairsOpen[ch] === ch);\n            let isBeforeCloseBrace = false;\n            for (let otherCloseBrace in config.autoClosingPairsClose) {\n                const otherBraceIsSymmetric = (config.autoClosingPairsOpen[otherCloseBrace] === otherCloseBrace);\n                if (!thisBraceIsSymmetric && otherBraceIsSymmetric) {\n                    continue;\n                }\n                if (characterAfter === otherCloseBrace) {\n                    isBeforeCloseBrace = true;\n                    break;\n                }\n            }\n            return isBeforeCloseBrace;\n        }\n        static _isAutoClosingOpenCharType(config, model, selections, ch) {\n            const chIsQuote = cursorCommon_1.isQuote(ch);\n            const autoCloseConfig = chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets;\n            if (autoCloseConfig === 'never' || !config.autoClosingPairsOpen.hasOwnProperty(ch)) {\n                return false;\n            }\n            let shouldAutoCloseBefore = chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket;\n            for (let i = 0, len = selections.length; i < len; i++) {\n                const selection = selections[i];\n                if (!selection.isEmpty()) {\n                    return false;\n                }\n                const position = selection.getPosition();\n                const lineText = model.getLineContent(position.lineNumber);\n                // Do not auto-close ' or \" after a word character\n                if ((chIsQuote && position.column > 1) && autoCloseConfig !== 'always') {\n                    const wordSeparators = wordCharacterClassifier_1.getMapForWordSeparators(config.wordSeparators);\n                    const characterBeforeCode = lineText.charCodeAt(position.column - 2);\n                    const characterBeforeType = wordSeparators.get(characterBeforeCode);\n                    if (characterBeforeType === wordCharacterClassifier_1.WordCharacterClass.Regular) {\n                        return false;\n                    }\n                }\n                // Only consider auto closing the pair if a space follows or if another autoclosed pair follows\n                const characterAfter = lineText.charAt(position.column - 1);\n                if (characterAfter) {\n                    let isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, ch, characterAfter);\n                    if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                        return false;\n                    }\n                }\n                if (!model.isCheapToTokenize(position.lineNumber)) {\n                    // Do not force tokenization\n                    return false;\n                }\n                model.forceTokenization(position.lineNumber);\n                const lineTokens = model.getLineTokens(position.lineNumber);\n                let shouldAutoClosePair = false;\n                try {\n                    shouldAutoClosePair = languageConfigurationRegistry_1.LanguageConfigurationRegistry.shouldAutoClosePair(ch, lineTokens, position.column);\n                }\n                catch (e) {\n                    errors_1.onUnexpectedError(e);\n                }\n                if (!shouldAutoClosePair) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch) {\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                const selection = selections[i];\n                const closeCharacter = config.autoClosingPairsOpen[ch];\n                commands[i] = new replaceCommand_1.ReplaceCommandWithOffsetCursorState(selection, ch + closeCharacter, 0, -closeCharacter.length);\n            }\n            return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        static _shouldSurroundChar(config, ch) {\n            if (cursorCommon_1.isQuote(ch)) {\n                return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n            }\n            else {\n                // Character is a bracket\n                return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n            }\n        }\n        static _isSurroundSelectionType(config, model, selections, ch) {\n            if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n                return false;\n            }\n            const isTypingAQuoteCharacter = cursorCommon_1.isQuote(ch);\n            for (let i = 0, len = selections.length; i < len; i++) {\n                const selection = selections[i];\n                if (selection.isEmpty()) {\n                    return false;\n                }\n                let selectionContainsOnlyWhitespace = true;\n                for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                    const lineText = model.getLineContent(lineNumber);\n                    const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                    const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                    const selectedText = lineText.substring(startIndex, endIndex);\n                    if (/[^ \\t]/.test(selectedText)) {\n                        // this selected text contains something other than whitespace\n                        selectionContainsOnlyWhitespace = false;\n                        break;\n                    }\n                }\n                if (selectionContainsOnlyWhitespace) {\n                    return false;\n                }\n                if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                    const selectionText = model.getValueInRange(selection);\n                    if (cursorCommon_1.isQuote(selectionText)) {\n                        // Typing a quote character on top of another quote character\n                        // => disable surround selection type\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                const selection = selections[i];\n                const closeCharacter = config.surroundingPairs[ch];\n                commands[i] = new surroundSelectionCommand_1.SurroundSelectionCommand(selection, ch, closeCharacter);\n            }\n            return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Other, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: true\n            });\n        }\n        static _isTypeInterceptorElectricChar(config, model, selections) {\n            if (selections.length === 1 && model.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n                return true;\n            }\n            return false;\n        }\n        static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n            if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n                return null;\n            }\n            let position = selection.getPosition();\n            model.forceTokenization(position.lineNumber);\n            let lineTokens = model.getLineTokens(position.lineNumber);\n            let electricAction;\n            try {\n                electricAction = languageConfigurationRegistry_1.LanguageConfigurationRegistry.onElectricCharacter(ch, lineTokens, position.column);\n            }\n            catch (e) {\n                errors_1.onUnexpectedError(e);\n                return null;\n            }\n            if (!electricAction) {\n                return null;\n            }\n            if (electricAction.appendText) {\n                const command = new replaceCommand_1.ReplaceCommandWithOffsetCursorState(selection, ch + electricAction.appendText, 0, -electricAction.appendText.length);\n                return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n            if (electricAction.matchOpenBracket) {\n                let endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n                let match = model.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                    lineNumber: position.lineNumber,\n                    column: endColumn\n                });\n                if (match) {\n                    if (match.startLineNumber === position.lineNumber) {\n                        // matched something on the same line => no change in indentation\n                        return null;\n                    }\n                    let matchLine = model.getLineContent(match.startLineNumber);\n                    let matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                    let newIndentation = config.normalizeIndentation(matchLineIndentation);\n                    let lineText = model.getLineContent(position.lineNumber);\n                    let lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                    let prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                    let typeText = newIndentation + prefix + ch;\n                    let typeSelection = new range_1.Range(position.lineNumber, 1, position.lineNumber, position.column);\n                    const command = new replaceCommand_1.ReplaceCommand(typeSelection, typeText);\n                    return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, [command], {\n                        shouldPushStackElementBefore: false,\n                        shouldPushStackElementAfter: true\n                    });\n                }\n            }\n            return null;\n        }\n        static compositionEndWithInterceptors(prevEditOperationType, config, model, selections) {\n            if (config.autoClosingQuotes === 'never') {\n                return null;\n            }\n            let commands = [];\n            for (let i = 0; i < selections.length; i++) {\n                if (!selections[i].isEmpty()) {\n                    continue;\n                }\n                const position = selections[i].getPosition();\n                const lineText = model.getLineContent(position.lineNumber);\n                const ch = lineText.charAt(position.column - 2);\n                if (config.autoClosingPairsClose.hasOwnProperty(ch)) { // first of all, it's a closing tag\n                    if (ch === config.autoClosingPairsClose[ch] /** isEqualPair */) {\n                        const lineTextBeforeCursor = lineText.substr(0, position.column - 2);\n                        const chCntBefore = this._countNeedlesInHaystack(lineTextBeforeCursor, ch);\n                        if (chCntBefore % 2 === 1) {\n                            continue; // it pairs with the opening tag.\n                        }\n                    }\n                }\n                // As we are not typing in a new character, so we don't need to run `_runAutoClosingCloseCharType`\n                // Next step, let's try to check if it's an open char.\n                if (config.autoClosingPairsOpen.hasOwnProperty(ch)) {\n                    if (cursorCommon_1.isQuote(ch) && position.column > 2) {\n                        const wordSeparators = wordCharacterClassifier_1.getMapForWordSeparators(config.wordSeparators);\n                        const characterBeforeCode = lineText.charCodeAt(position.column - 3);\n                        const characterBeforeType = wordSeparators.get(characterBeforeCode);\n                        if (characterBeforeType === wordCharacterClassifier_1.WordCharacterClass.Regular) {\n                            continue;\n                        }\n                    }\n                    const characterAfter = lineText.charAt(position.column - 1);\n                    if (characterAfter) {\n                        let isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, ch, characterAfter);\n                        let shouldAutoCloseBefore = cursorCommon_1.isQuote(ch) ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket;\n                        if (isBeforeCloseBrace) {\n                            // In normal auto closing logic, we will auto close if the cursor is even before a closing brace intentionally.\n                            // However for composition mode, we do nothing here as users might clear all the characters for composition and we don't want to do a unnecessary auto close.\n                            // Related: microsoft/vscode#57250.\n                            continue;\n                        }\n                        if (!shouldAutoCloseBefore(characterAfter)) {\n                            continue;\n                        }\n                    }\n                    if (!model.isCheapToTokenize(position.lineNumber)) {\n                        // Do not force tokenization\n                        continue;\n                    }\n                    model.forceTokenization(position.lineNumber);\n                    const lineTokens = model.getLineTokens(position.lineNumber);\n                    let shouldAutoClosePair = false;\n                    try {\n                        shouldAutoClosePair = languageConfigurationRegistry_1.LanguageConfigurationRegistry.shouldAutoClosePair(ch, lineTokens, position.column - 1);\n                    }\n                    catch (e) {\n                        errors_1.onUnexpectedError(e);\n                    }\n                    if (shouldAutoClosePair) {\n                        const closeCharacter = config.autoClosingPairsOpen[ch];\n                        commands[i] = new replaceCommand_1.ReplaceCommandWithOffsetCursorState(selections[i], closeCharacter, 0, -closeCharacter.length);\n                    }\n                }\n            }\n            return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        static typeWithInterceptors(prevEditOperationType, config, model, selections, ch) {\n            if (ch === '\\n') {\n                let commands = [];\n                for (let i = 0, len = selections.length; i < len; i++) {\n                    commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n                }\n                return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, commands, {\n                    shouldPushStackElementBefore: true,\n                    shouldPushStackElementAfter: false,\n                });\n            }\n            if (this._isAutoIndentType(config, model, selections)) {\n                let commands = [];\n                let autoIndentFails = false;\n                for (let i = 0, len = selections.length; i < len; i++) {\n                    commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n                    if (!commands[i]) {\n                        autoIndentFails = true;\n                        break;\n                    }\n                }\n                if (!autoIndentFails) {\n                    return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, commands, {\n                        shouldPushStackElementBefore: true,\n                        shouldPushStackElementAfter: false,\n                    });\n                }\n            }\n            if (this._isAutoClosingCloseCharType(config, model, selections, ch)) {\n                return this._runAutoClosingCloseCharType(prevEditOperationType, config, model, selections, ch);\n            }\n            if (this._isAutoClosingOpenCharType(config, model, selections, ch)) {\n                return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch);\n            }\n            if (this._isSurroundSelectionType(config, model, selections, ch)) {\n                return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n            }\n            // Electric characters make sense only when dealing with a single cursor,\n            // as multiple cursors typing brackets for example would interfer with bracket matching\n            if (this._isTypeInterceptorElectricChar(config, model, selections)) {\n                const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n                if (r) {\n                    return r;\n                }\n            }\n            // A simple character type\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = new replaceCommand_1.ReplaceCommand(selections[i], ch);\n            }\n            let shouldPushStackElementBefore = (prevEditOperationType !== cursorCommon_1.EditOperationType.Typing);\n            if (ch === ' ') {\n                shouldPushStackElementBefore = true;\n            }\n            return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, commands, {\n                shouldPushStackElementBefore: shouldPushStackElementBefore,\n                shouldPushStackElementAfter: false\n            });\n        }\n        static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = new replaceCommand_1.ReplaceCommand(selections[i], str);\n            }\n            return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, commands, {\n                shouldPushStackElementBefore: (prevEditOperationType !== cursorCommon_1.EditOperationType.Typing),\n                shouldPushStackElementAfter: false\n            });\n        }\n        static lineInsertBefore(config, model, selections) {\n            if (model === null || selections === null) {\n                return [];\n            }\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                let lineNumber = selections[i].positionLineNumber;\n                if (lineNumber === 1) {\n                    commands[i] = new replaceCommand_1.ReplaceCommandWithoutChangingPosition(new range_1.Range(1, 1, 1, 1), '\\n');\n                }\n                else {\n                    lineNumber--;\n                    let column = model.getLineMaxColumn(lineNumber);\n                    commands[i] = this._enter(config, model, false, new range_1.Range(lineNumber, column, lineNumber, column));\n                }\n            }\n            return commands;\n        }\n        static lineInsertAfter(config, model, selections) {\n            if (model === null || selections === null) {\n                return [];\n            }\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                const lineNumber = selections[i].positionLineNumber;\n                let column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new range_1.Range(lineNumber, column, lineNumber, column));\n            }\n            return commands;\n        }\n        static lineBreakInsert(config, model, selections) {\n            let commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._enter(config, model, true, selections[i]);\n            }\n            return commands;\n        }\n    }\n    exports.TypeOperations = TypeOperations;\n});\n",null]}