{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/hover/modesContentHover.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/hover/modesContentHover.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/browser/dom\", \"vs/base/common/cancellation\", \"vs/base/common/color\", \"vs/base/common/htmlContent\", \"vs/base/common/lifecycle\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\", \"vs/editor/common/model/textModel\", \"vs/editor/common/modes\", \"vs/editor/contrib/colorPicker/color\", \"vs/editor/contrib/colorPicker/colorDetector\", \"vs/editor/contrib/colorPicker/colorPickerModel\", \"vs/editor/contrib/colorPicker/colorPickerWidget\", \"vs/editor/contrib/hover/getHover\", \"vs/editor/contrib/hover/hoverOperation\", \"vs/editor/contrib/hover/hoverWidgets\", \"vs/editor/contrib/markdown/markdownRenderer\", \"vs/base/common/arrays\", \"vs/platform/markers/common/markers\", \"vs/base/common/resources\", \"vs/base/common/errors\", \"vs/platform/opener/common/opener\", \"vs/editor/contrib/gotoError/gotoError\", \"vs/base/common/async\", \"vs/editor/contrib/codeAction/codeAction\", \"vs/editor/contrib/codeAction/codeActionCommands\", \"vs/base/common/actions\", \"vs/editor/contrib/codeAction/codeActionTrigger\", \"vs/base/common/types\"], function (require, exports, nls, dom, cancellation_1, color_1, htmlContent_1, lifecycle_1, position_1, range_1, textModel_1, modes_1, color_2, colorDetector_1, colorPickerModel_1, colorPickerWidget_1, getHover_1, hoverOperation_1, hoverWidgets_1, markdownRenderer_1, arrays_1, markers_1, resources_1, errors_1, opener_1, gotoError_1, async_1, codeAction_1, codeActionCommands_1, actions_1, codeActionTrigger_1, types_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const $ = dom.$;\n    class ColorHover {\n        constructor(range, color, provider) {\n            this.range = range;\n            this.color = color;\n            this.provider = provider;\n        }\n    }\n    class MarkerHover {\n        constructor(range, marker) {\n            this.range = range;\n            this.marker = marker;\n        }\n    }\n    class ModesContentComputer {\n        constructor(editor, _markerDecorationsService) {\n            this._markerDecorationsService = _markerDecorationsService;\n            this._editor = editor;\n            this._range = null;\n        }\n        setRange(range) {\n            this._range = range;\n            this._result = [];\n        }\n        clearResult() {\n            this._result = [];\n        }\n        computeAsync(token) {\n            if (!this._editor.hasModel() || !this._range) {\n                return Promise.resolve([]);\n            }\n            const model = this._editor.getModel();\n            if (!modes_1.HoverProviderRegistry.has(model)) {\n                return Promise.resolve([]);\n            }\n            return getHover_1.getHover(model, new position_1.Position(this._range.startLineNumber, this._range.startColumn), token);\n        }\n        computeSync() {\n            if (!this._editor.hasModel() || !this._range) {\n                return [];\n            }\n            const model = this._editor.getModel();\n            const lineNumber = this._range.startLineNumber;\n            if (lineNumber > this._editor.getModel().getLineCount()) {\n                // Illegal line number => no results\n                return [];\n            }\n            const colorDetector = colorDetector_1.ColorDetector.get(this._editor);\n            const maxColumn = model.getLineMaxColumn(lineNumber);\n            const lineDecorations = this._editor.getLineDecorations(lineNumber);\n            let didFindColor = false;\n            const hoverRange = this._range;\n            const result = lineDecorations.map((d) => {\n                const startColumn = (d.range.startLineNumber === lineNumber) ? d.range.startColumn : 1;\n                const endColumn = (d.range.endLineNumber === lineNumber) ? d.range.endColumn : maxColumn;\n                if (startColumn > hoverRange.startColumn || hoverRange.endColumn > endColumn) {\n                    return null;\n                }\n                const range = new range_1.Range(hoverRange.startLineNumber, startColumn, hoverRange.startLineNumber, endColumn);\n                const marker = this._markerDecorationsService.getMarker(model, d);\n                if (marker) {\n                    return new MarkerHover(range, marker);\n                }\n                const colorData = colorDetector.getColorData(d.range.getStartPosition());\n                if (!didFindColor && colorData) {\n                    didFindColor = true;\n                    const { color, range } = colorData.colorInfo;\n                    return new ColorHover(range, color, colorData.provider);\n                }\n                else {\n                    if (htmlContent_1.isEmptyMarkdownString(d.options.hoverMessage)) {\n                        return null;\n                    }\n                    const contents = d.options.hoverMessage ? arrays_1.asArray(d.options.hoverMessage) : [];\n                    return { contents, range };\n                }\n            });\n            return arrays_1.coalesce(result);\n        }\n        onResult(result, isFromSynchronousComputation) {\n            // Always put synchronous messages before asynchronous ones\n            if (isFromSynchronousComputation) {\n                this._result = result.concat(this._result.sort((a, b) => {\n                    if (a instanceof ColorHover) { // sort picker messages at to the top\n                        return -1;\n                    }\n                    else if (b instanceof ColorHover) {\n                        return 1;\n                    }\n                    return 0;\n                }));\n            }\n            else {\n                this._result = this._result.concat(result);\n            }\n        }\n        getResult() {\n            return this._result.slice(0);\n        }\n        getResultWithLoadingMessage() {\n            return this._result.slice(0).concat([this._getLoadingMessage()]);\n        }\n        _getLoadingMessage() {\n            return {\n                range: types_1.withNullAsUndefined(this._range),\n                contents: [new htmlContent_1.MarkdownString().appendText(nls.localize('modesContentHover.loading', \"Loading...\"))]\n            };\n        }\n    }\n    class ModesContentHoverWidget extends hoverWidgets_1.ContentHoverWidget {\n        constructor(editor, markerDecorationsService, _themeService, _keybindingService, _contextMenuService, _bulkEditService, _commandService, _modeService, _openerService = opener_1.NullOpenerService) {\n            super(ModesContentHoverWidget.ID, editor);\n            this._themeService = _themeService;\n            this._keybindingService = _keybindingService;\n            this._contextMenuService = _contextMenuService;\n            this._bulkEditService = _bulkEditService;\n            this._commandService = _commandService;\n            this._modeService = _modeService;\n            this._openerService = _openerService;\n            this.renderDisposable = lifecycle_1.Disposable.None;\n            this._messages = [];\n            this._lastRange = null;\n            this._computer = new ModesContentComputer(this._editor, markerDecorationsService);\n            this._highlightDecorations = [];\n            this._isChangingDecorations = false;\n            this._hoverOperation = new hoverOperation_1.HoverOperation(this._computer, result => this._withResult(result, true), null, result => this._withResult(result, false), this._editor.getConfiguration().contribInfo.hover.delay);\n            this._register(dom.addStandardDisposableListener(this.getDomNode(), dom.EventType.FOCUS, () => {\n                if (this._colorPicker) {\n                    dom.addClass(this.getDomNode(), 'colorpicker-hover');\n                }\n            }));\n            this._register(dom.addStandardDisposableListener(this.getDomNode(), dom.EventType.BLUR, () => {\n                dom.removeClass(this.getDomNode(), 'colorpicker-hover');\n            }));\n            this._register(editor.onDidChangeConfiguration((e) => {\n                this._hoverOperation.setHoverTime(this._editor.getConfiguration().contribInfo.hover.delay);\n            }));\n        }\n        dispose() {\n            this.renderDisposable.dispose();\n            this.renderDisposable = lifecycle_1.Disposable.None;\n            this._hoverOperation.cancel();\n            super.dispose();\n        }\n        onModelDecorationsChanged() {\n            if (this._isChangingDecorations) {\n                return;\n            }\n            if (this.isVisible) {\n                // The decorations have changed and the hover is visible,\n                // we need to recompute the displayed text\n                this._hoverOperation.cancel();\n                this._computer.clearResult();\n                if (!this._colorPicker) { // TODO@Michel ensure that displayed text for other decorations is computed even if color picker is in place\n                    this._hoverOperation.start(hoverOperation_1.HoverStartMode.Delayed);\n                }\n            }\n        }\n        startShowingAt(range, mode, focus) {\n            if (this._lastRange && this._lastRange.equalsRange(range)) {\n                // We have to show the widget at the exact same range as before, so no work is needed\n                return;\n            }\n            this._hoverOperation.cancel();\n            if (this.isVisible) {\n                // The range might have changed, but the hover is visible\n                // Instead of hiding it completely, filter out messages that are still in the new range and\n                // kick off a new computation\n                if (!this._showAtPosition || this._showAtPosition.lineNumber !== range.startLineNumber) {\n                    this.hide();\n                }\n                else {\n                    let filteredMessages = [];\n                    for (let i = 0, len = this._messages.length; i < len; i++) {\n                        const msg = this._messages[i];\n                        const rng = msg.range;\n                        if (rng && rng.startColumn <= range.startColumn && rng.endColumn >= range.endColumn) {\n                            filteredMessages.push(msg);\n                        }\n                    }\n                    if (filteredMessages.length > 0) {\n                        if (hoverContentsEquals(filteredMessages, this._messages)) {\n                            return;\n                        }\n                        this._renderMessages(range, filteredMessages);\n                    }\n                    else {\n                        this.hide();\n                    }\n                }\n            }\n            this._lastRange = range;\n            this._computer.setRange(range);\n            this._shouldFocus = focus;\n            this._hoverOperation.start(mode);\n        }\n        hide() {\n            this._lastRange = null;\n            this._hoverOperation.cancel();\n            super.hide();\n            this._isChangingDecorations = true;\n            this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, []);\n            this._isChangingDecorations = false;\n            this.renderDisposable.dispose();\n            this.renderDisposable = lifecycle_1.Disposable.None;\n            this._colorPicker = null;\n        }\n        isColorPickerVisible() {\n            if (this._colorPicker) {\n                return true;\n            }\n            return false;\n        }\n        _withResult(result, complete) {\n            this._messages = result;\n            if (this._lastRange && this._messages.length > 0) {\n                this._renderMessages(this._lastRange, this._messages);\n            }\n            else if (complete) {\n                this.hide();\n            }\n        }\n        _renderMessages(renderRange, messages) {\n            this.renderDisposable.dispose();\n            this._colorPicker = null;\n            // update column from which to show\n            let renderColumn = Number.MAX_VALUE;\n            let highlightRange = messages[0].range ? range_1.Range.lift(messages[0].range) : null;\n            let fragment = document.createDocumentFragment();\n            let isEmptyHoverContent = true;\n            let containColorPicker = false;\n            let markdownDisposeables = [];\n            const markerMessages = [];\n            messages.forEach((msg) => {\n                if (!msg.range) {\n                    return;\n                }\n                renderColumn = Math.min(renderColumn, msg.range.startColumn);\n                highlightRange = highlightRange ? range_1.Range.plusRange(highlightRange, msg.range) : range_1.Range.lift(msg.range);\n                if (msg instanceof ColorHover) {\n                    containColorPicker = true;\n                    const { red, green, blue, alpha } = msg.color;\n                    const rgba = new color_1.RGBA(red * 255, green * 255, blue * 255, alpha);\n                    const color = new color_1.Color(rgba);\n                    if (!this._editor.hasModel()) {\n                        return;\n                    }\n                    const editorModel = this._editor.getModel();\n                    let range = new range_1.Range(msg.range.startLineNumber, msg.range.startColumn, msg.range.endLineNumber, msg.range.endColumn);\n                    let colorInfo = { range: msg.range, color: msg.color };\n                    // create blank olor picker model and widget first to ensure it's positioned correctly.\n                    const model = new colorPickerModel_1.ColorPickerModel(color, [], 0);\n                    const widget = new colorPickerWidget_1.ColorPickerWidget(fragment, model, this._editor.getConfiguration().pixelRatio, this._themeService);\n                    color_2.getColorPresentations(editorModel, colorInfo, msg.provider, cancellation_1.CancellationToken.None).then(colorPresentations => {\n                        model.colorPresentations = colorPresentations || [];\n                        if (!this._editor.hasModel()) {\n                            // gone...\n                            return;\n                        }\n                        const originalText = this._editor.getModel().getValueInRange(msg.range);\n                        model.guessColorPresentation(color, originalText);\n                        const updateEditorModel = () => {\n                            let textEdits;\n                            let newRange;\n                            if (model.presentation.textEdit) {\n                                textEdits = [model.presentation.textEdit];\n                                newRange = new range_1.Range(model.presentation.textEdit.range.startLineNumber, model.presentation.textEdit.range.startColumn, model.presentation.textEdit.range.endLineNumber, model.presentation.textEdit.range.endColumn);\n                                newRange = newRange.setEndPosition(newRange.endLineNumber, newRange.startColumn + model.presentation.textEdit.text.length);\n                            }\n                            else {\n                                textEdits = [{ identifier: null, range, text: model.presentation.label, forceMoveMarkers: false }];\n                                newRange = range.setEndPosition(range.endLineNumber, range.startColumn + model.presentation.label.length);\n                            }\n                            this._editor.pushUndoStop();\n                            this._editor.executeEdits('colorpicker', textEdits);\n                            if (model.presentation.additionalTextEdits) {\n                                textEdits = [...model.presentation.additionalTextEdits];\n                                this._editor.executeEdits('colorpicker', textEdits);\n                                this.hide();\n                            }\n                            this._editor.pushUndoStop();\n                            range = newRange;\n                        };\n                        const updateColorPresentations = (color) => {\n                            return color_2.getColorPresentations(editorModel, {\n                                range: range,\n                                color: {\n                                    red: color.rgba.r / 255,\n                                    green: color.rgba.g / 255,\n                                    blue: color.rgba.b / 255,\n                                    alpha: color.rgba.a\n                                }\n                            }, msg.provider, cancellation_1.CancellationToken.None).then((colorPresentations) => {\n                                model.colorPresentations = colorPresentations || [];\n                            });\n                        };\n                        const colorListener = model.onColorFlushed((color) => {\n                            updateColorPresentations(color).then(updateEditorModel);\n                        });\n                        const colorChangeListener = model.onDidChangeColor(updateColorPresentations);\n                        this._colorPicker = widget;\n                        this.showAt(range.getStartPosition(), range, this._shouldFocus);\n                        this.updateContents(fragment);\n                        this._colorPicker.layout();\n                        this.renderDisposable = lifecycle_1.combinedDisposable([colorListener, colorChangeListener, widget, ...markdownDisposeables]);\n                    });\n                }\n                else {\n                    if (msg instanceof MarkerHover) {\n                        markerMessages.push(msg);\n                        isEmptyHoverContent = false;\n                    }\n                    else {\n                        msg.contents\n                            .filter(contents => !htmlContent_1.isEmptyMarkdownString(contents))\n                            .forEach(contents => {\n                            const markdownHoverElement = $('div.hover-row.markdown-hover');\n                            const hoverContentsElement = dom.append(markdownHoverElement, $('div.hover-contents'));\n                            const renderer = new markdownRenderer_1.MarkdownRenderer(this._editor, this._modeService, this._openerService);\n                            markdownDisposeables.push(renderer.onDidRenderCodeBlock(() => {\n                                hoverContentsElement.className = 'hover-contents code-hover-contents';\n                                this.onContentsChange();\n                            }));\n                            const renderedContents = renderer.render(contents);\n                            hoverContentsElement.appendChild(renderedContents.element);\n                            fragment.appendChild(markdownHoverElement);\n                            markdownDisposeables.push(renderedContents);\n                            isEmptyHoverContent = false;\n                        });\n                    }\n                }\n            });\n            if (markerMessages.length) {\n                markerMessages.forEach(msg => fragment.appendChild(this.renderMarkerHover(msg)));\n                const markerHoverForStatusbar = markerMessages.length === 1 ? markerMessages[0] : markerMessages.sort((a, b) => markers_1.MarkerSeverity.compare(a.marker.severity, b.marker.severity))[0];\n                fragment.appendChild(this.renderMarkerStatusbar(markerHoverForStatusbar));\n            }\n            // show\n            if (!containColorPicker && !isEmptyHoverContent) {\n                this.showAt(new position_1.Position(renderRange.startLineNumber, renderColumn), highlightRange, this._shouldFocus);\n                this.updateContents(fragment);\n            }\n            this._isChangingDecorations = true;\n            this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, highlightRange ? [{\n                    range: highlightRange,\n                    options: ModesContentHoverWidget._DECORATION_OPTIONS\n                }] : []);\n            this._isChangingDecorations = false;\n        }\n        renderMarkerHover(markerHover) {\n            const hoverElement = $('div.hover-row');\n            const markerElement = dom.append(hoverElement, $('div.marker.hover-contents'));\n            const { source, message, code, relatedInformation } = markerHover.marker;\n            this._editor.applyFontInfo(markerElement);\n            const messageElement = dom.append(markerElement, $('span'));\n            messageElement.style.whiteSpace = 'pre-wrap';\n            messageElement.innerText = message;\n            if (source || code) {\n                const detailsElement = dom.append(markerElement, $('span'));\n                detailsElement.style.opacity = '0.6';\n                detailsElement.style.paddingLeft = '6px';\n                detailsElement.innerText = source && code ? `${source}(${code})` : source ? source : `(${code})`;\n            }\n            if (arrays_1.isNonEmptyArray(relatedInformation)) {\n                for (const { message, resource, startLineNumber, startColumn } of relatedInformation) {\n                    const relatedInfoContainer = dom.append(markerElement, $('div'));\n                    relatedInfoContainer.style.marginTop = '8px';\n                    const a = dom.append(relatedInfoContainer, $('a'));\n                    a.innerText = `${resources_1.basename(resource)}(${startLineNumber}, ${startColumn}): `;\n                    a.style.cursor = 'pointer';\n                    a.onclick = e => {\n                        e.stopPropagation();\n                        e.preventDefault();\n                        if (this._openerService) {\n                            this._openerService.open(resource.with({ fragment: `${startLineNumber},${startColumn}` })).catch(errors_1.onUnexpectedError);\n                        }\n                    };\n                    const messageElement = dom.append(relatedInfoContainer, $('span'));\n                    messageElement.innerText = message;\n                    this._editor.applyFontInfo(messageElement);\n                }\n            }\n            return hoverElement;\n        }\n        renderMarkerStatusbar(markerHover) {\n            const hoverElement = $('div.hover-row.status-bar');\n            const disposables = [];\n            const actionsElement = dom.append(hoverElement, $('div.actions'));\n            disposables.push(this.renderAction(actionsElement, {\n                label: nls.localize('quick fixes', \"Quick Fix...\"),\n                commandId: codeActionCommands_1.QuickFixAction.Id,\n                run: (target) => __awaiter(this, void 0, void 0, function* () {\n                    const codeActionsPromise = this.getCodeActions(markerHover.marker);\n                    disposables.push(lifecycle_1.toDisposable(() => codeActionsPromise.cancel()));\n                    const actions = yield codeActionsPromise;\n                    const elementPosition = dom.getDomNodePagePosition(target);\n                    this._contextMenuService.showContextMenu({\n                        getAnchor: () => ({ x: elementPosition.left + 6, y: elementPosition.top + elementPosition.height + 6 }),\n                        getActions: () => actions\n                    });\n                })\n            }));\n            if (markerHover.marker.severity === markers_1.MarkerSeverity.Error || markerHover.marker.severity === markers_1.MarkerSeverity.Warning || markerHover.marker.severity === markers_1.MarkerSeverity.Info) {\n                disposables.push(this.renderAction(actionsElement, {\n                    label: nls.localize('peek problem', \"Peek Problem\"),\n                    commandId: gotoError_1.NextMarkerAction.ID,\n                    run: () => {\n                        this.hide();\n                        gotoError_1.MarkerController.get(this._editor).show(markerHover.marker);\n                        this._editor.focus();\n                    }\n                }));\n            }\n            this.renderDisposable = lifecycle_1.combinedDisposable(disposables);\n            return hoverElement;\n        }\n        getCodeActions(marker) {\n            return async_1.createCancelablePromise((cancellationToken) => __awaiter(this, void 0, void 0, function* () {\n                const codeActions = yield codeAction_1.getCodeActions(this._editor.getModel(), new range_1.Range(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn), { type: 'manual', filter: { kind: codeActionTrigger_1.CodeActionKind.QuickFix } }, cancellationToken);\n                if (codeActions.actions.length) {\n                    return codeActions.actions.map(codeAction => new actions_1.Action(codeAction.command ? codeAction.command.id : codeAction.title, codeAction.title, undefined, true, () => codeActionCommands_1.applyCodeAction(codeAction, this._bulkEditService, this._commandService)));\n                }\n                return [\n                    new actions_1.Action('', nls.localize('editor.action.quickFix.noneMessage', \"No code actions available\"))\n                ];\n            }));\n        }\n        renderAction(parent, actionOptions) {\n            const actionContainer = dom.append(parent, $('div.action-container'));\n            const action = dom.append(actionContainer, $('a.action'));\n            if (actionOptions.iconClass) {\n                dom.append(action, $(`span.icon.${actionOptions.iconClass}`));\n            }\n            const label = dom.append(action, $('span'));\n            label.textContent = actionOptions.label;\n            const keybinding = this._keybindingService.lookupKeybinding(actionOptions.commandId);\n            if (keybinding) {\n                label.title = `${actionOptions.label} (${keybinding.getLabel()})`;\n            }\n            return dom.addDisposableListener(actionContainer, dom.EventType.CLICK, e => {\n                e.stopPropagation();\n                e.preventDefault();\n                actionOptions.run(actionContainer);\n            });\n        }\n    }\n    ModesContentHoverWidget.ID = 'editor.contrib.modesContentHoverWidget';\n    ModesContentHoverWidget._DECORATION_OPTIONS = textModel_1.ModelDecorationOptions.register({\n        className: 'hoverHighlight'\n    });\n    exports.ModesContentHoverWidget = ModesContentHoverWidget;\n    function hoverContentsEquals(first, second) {\n        if ((!first && second) || (first && !second) || first.length !== second.length) {\n            return false;\n        }\n        for (let i = 0; i < first.length; i++) {\n            const firstElement = first[i];\n            const secondElement = second[i];\n            if (firstElement instanceof MarkerHover && secondElement instanceof MarkerHover) {\n                return markers_1.IMarkerData.makeKey(firstElement.marker) === markers_1.IMarkerData.makeKey(secondElement.marker);\n            }\n            if (firstElement instanceof ColorHover || secondElement instanceof ColorHover) {\n                return false;\n            }\n            if (firstElement instanceof MarkerHover || secondElement instanceof MarkerHover) {\n                return false;\n            }\n            if (!htmlContent_1.markedStringsEquals(firstElement.contents, secondElement.contents)) {\n                return false;\n            }\n        }\n        return true;\n    }\n});\n",null]}