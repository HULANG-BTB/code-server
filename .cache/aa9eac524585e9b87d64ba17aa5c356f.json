{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/packages/ide/src/upload.ts","dependencies":[{"path":"/home/coding/workspace/packages/ide/src/upload.ts","mtime":1555841535682},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"child_process\", \"fs\", \"util\", \"@coder/logger\", \"@coder/protocol\", \"./fill/notification\"], function (require, exports, child_process_1, fs_1, util_1, logger_1, protocol_1, notification_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Handles file uploads.\n     */\n    class Upload {\n        constructor(_notificationService, _progressService) {\n            this._notificationService = _notificationService;\n            this._progressService = _progressService;\n            this.maxParallelUploads = 100;\n            this.readSize = 32000; // ~32kb max while reading in the file.\n            this.packetSize = 32000; // ~32kb max when writing.\n            this.logger = logger_1.logger.named(\"Upload\");\n            this.currentlyUploadingFiles = new Map();\n            this.queueByDirectory = new Map();\n            this.finished = 0;\n            this.uploadedFilePaths = [];\n            this.total = 0;\n        }\n        set notificationService(service) {\n            this._notificationService = service;\n        }\n        get notificationService() {\n            return this._notificationService;\n        }\n        set progressService(service) {\n            this._progressService = service;\n        }\n        get progressService() {\n            return this._progressService;\n        }\n        /**\n         * Upload dropped files. This will try to upload everything it can. Errors\n         * will show via notifications. If an upload operation is ongoing, the files\n         * will be added to that operation.\n         */\n        uploadDropped(event, uploadDir) {\n            return __awaiter(this, void 0, void 0, function* () {\n                this.addDirectory(uploadDir.path);\n                yield this.queueFiles(event, uploadDir);\n                this.logger.debug(// -1 so we don't include the uploadDir itself.\n                `Uploading ${this.queueByDirectory.size - 1} directories and ${this.total} files`);\n                yield this.prepareDirectories();\n                if (!this.uploadPromise) {\n                    this.uploadPromise = this.progressService.start(\"Uploading files...\", (progress) => {\n                        return new Promise((resolve) => {\n                            this.progress = progress;\n                            this.resolveUploadPromise = () => {\n                                const uploaded = this.uploadedFilePaths;\n                                this.uploadPromise = undefined;\n                                this.resolveUploadPromise = undefined;\n                                this.uploadedFilePaths = [];\n                                this.finished = 0;\n                                this.total = 0;\n                                resolve(uploaded);\n                            };\n                        });\n                    }, () => {\n                        this.cancel();\n                    });\n                }\n                this.uploadFiles();\n                return this.uploadPromise;\n            });\n        }\n        /**\n         * Cancel all file uploads.\n         */\n        cancel() {\n            return __awaiter(this, void 0, void 0, function* () {\n                this.currentlyUploadingFiles.clear();\n                this.queueByDirectory.clear();\n            });\n        }\n        /**\n         * Create directories and get existing files.\n         * On failure, show the error and remove the failed directory from the queue.\n         */\n        prepareDirectories() {\n            return __awaiter(this, void 0, void 0, function* () {\n                yield Promise.all(Array.from(this.queueByDirectory).map(([path, dir]) => {\n                    if (!dir.preparePromise) {\n                        dir.preparePromise = this.prepareDirectory(path, dir);\n                    }\n                    return dir.preparePromise;\n                }));\n            });\n        }\n        /**\n         * Create a directory and get existing files.\n         * On failure, show the error and remove the directory from the queue.\n         */\n        prepareDirectory(path, dir) {\n            return __awaiter(this, void 0, void 0, function* () {\n                yield Promise.all([\n                    util_1.promisify(child_process_1.exec)(`mkdir -p ${protocol_1.escapePath(path)}`).catch((error) => {\n                        const message = error.message.toLowerCase();\n                        if (message.includes(\"file exists\")) {\n                            throw new Error(`Unable to create directory at ${path} because a file exists there`);\n                        }\n                        throw new Error(error.message || `Unable to upload ${path}`);\n                    }),\n                    // Only get files, so we don't show an override option that will just\n                    // fail anyway.\n                    util_1.promisify(child_process_1.exec)(`find ${protocol_1.escapePath(path)} -maxdepth 1 -not -type d`).then((stdio) => {\n                        dir.existingFiles = stdio.stdout.split(\"\\n\");\n                    }),\n                ]).catch((error) => {\n                    this.queueByDirectory.delete(path);\n                    this.notificationService.error(error);\n                });\n            });\n        }\n        /**\n         * Upload as many files as possible. When finished, resolve the upload promise.\n         */\n        uploadFiles() {\n            const finishFileUpload = (path) => {\n                ++this.finished;\n                this.currentlyUploadingFiles.delete(path);\n                this.progress.report(Math.floor((this.finished / this.total) * 100));\n                this.uploadFiles();\n            };\n            while (this.queueByDirectory.size > 0 && this.currentlyUploadingFiles.size < this.maxParallelUploads) {\n                const [dirPath, dir] = this.queueByDirectory.entries().next().value;\n                if (dir.filesToUpload.size === 0) {\n                    this.queueByDirectory.delete(dirPath);\n                    continue;\n                }\n                const [filePath, item] = dir.filesToUpload.entries().next().value;\n                this.currentlyUploadingFiles.set(filePath, item);\n                dir.filesToUpload.delete(filePath);\n                this.uploadFile(filePath, item, dir.existingFiles).then(() => {\n                    finishFileUpload(filePath);\n                }).catch((error) => {\n                    this.notificationService.error(error);\n                    finishFileUpload(filePath);\n                });\n            }\n            if (this.queueByDirectory.size === 0 && this.currentlyUploadingFiles.size === 0) {\n                this.resolveUploadPromise();\n            }\n        }\n        /**\n         * Upload a file.\n         */\n        uploadFile(path, file, existingFiles) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (existingFiles.includes(path)) {\n                    const shouldOverwrite = yield new Promise((resolve) => {\n                        this.notificationService.prompt(notification_1.Severity.Error, `${path} already exists. Overwrite?`, [{\n                                label: \"Yes\",\n                                run: () => resolve(true),\n                            }, {\n                                label: \"No\",\n                                run: () => resolve(false),\n                            }], () => resolve(false));\n                    });\n                    if (!shouldOverwrite) {\n                        return;\n                    }\n                }\n                yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    let readOffset = 0;\n                    const reader = new FileReader();\n                    const seek = () => {\n                        const slice = file.slice(readOffset, readOffset + this.readSize);\n                        readOffset += this.readSize;\n                        reader.readAsArrayBuffer(slice);\n                    };\n                    const rm = () => __awaiter(this, void 0, void 0, function* () {\n                        yield util_1.promisify(child_process_1.exec)(`rm -f ${protocol_1.escapePath(path)}`);\n                    });\n                    yield rm();\n                    const load = () => __awaiter(this, void 0, void 0, function* () {\n                        const buffer = new Uint8Array(reader.result);\n                        let bufferOffset = 0;\n                        while (bufferOffset <= buffer.length) {\n                            // Got canceled while sending data.\n                            if (!this.currentlyUploadingFiles.has(path)) {\n                                yield rm();\n                                return resolve();\n                            }\n                            const data = buffer.slice(bufferOffset, bufferOffset + this.packetSize);\n                            try {\n                                yield util_1.promisify(fs_1.appendFile)(path, data);\n                            }\n                            catch (error) {\n                                yield rm();\n                                const message = error.message.toLowerCase();\n                                if (message.includes(\"no space\")) {\n                                    return reject(new Error(\"You are out of disk space\"));\n                                }\n                                else if (message.includes(\"is a directory\")) {\n                                    return reject(new Error(`Unable to upload ${path} because there is a directory there`));\n                                }\n                                return reject(new Error(error.message || `Unable to upload ${path}`));\n                            }\n                            bufferOffset += this.packetSize;\n                        }\n                        if (readOffset >= file.size) {\n                            this.uploadedFilePaths.push(path);\n                            return resolve();\n                        }\n                        seek();\n                    });\n                    reader.addEventListener(\"load\", load);\n                    seek();\n                }));\n            });\n        }\n        /**\n         * Queue files from a drop event. We have to get the files first; we can't do\n         * it in tandem with uploading or the entries will disappear.\n         */\n        queueFiles(event, uploadDir) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!event.dataTransfer || !event.dataTransfer.items) {\n                    return;\n                }\n                const promises = [];\n                for (let i = 0; i < event.dataTransfer.items.length; i++) {\n                    const item = event.dataTransfer.items[i];\n                    if (typeof item.webkitGetAsEntry === \"function\") {\n                        promises.push(this.traverseItem(item.webkitGetAsEntry(), uploadDir.fsPath).catch(this.notificationService.error));\n                    }\n                    else {\n                        const file = item.getAsFile();\n                        if (file) {\n                            this.addFile(uploadDir.fsPath, uploadDir.fsPath + \"/\" + file.name, file);\n                        }\n                    }\n                }\n                yield Promise.all(promises);\n            });\n        }\n        /**\n         * Traverses an entry and add files to the queue.\n         */\n        traverseItem(entry, parentPath) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (entry.isFile) {\n                    return new Promise((resolve) => {\n                        entry.file((file) => {\n                            this.addFile(parentPath, parentPath + \"/\" + file.name, file);\n                            resolve();\n                        });\n                    });\n                }\n                parentPath += \"/\" + entry.name;\n                this.addDirectory(parentPath);\n                yield new Promise((resolve) => {\n                    const promises = [];\n                    const dirReader = entry.createReader();\n                    // According to the spec, readEntries() must be called until it calls\n                    // the callback with an empty array.\n                    const readEntries = () => {\n                        dirReader.readEntries((entries) => {\n                            if (entries.length === 0) {\n                                Promise.all(promises).then(resolve).catch((error) => {\n                                    this.notificationService.error(error);\n                                    resolve();\n                                });\n                            }\n                            else {\n                                promises.push(...entries.map((child) => this.traverseItem(child, parentPath)));\n                                readEntries();\n                            }\n                        });\n                    };\n                    readEntries();\n                });\n            });\n        }\n        /**\n         * Add a file to the queue.\n         */\n        addFile(parentPath, path, file) {\n            ++this.total;\n            this.addDirectory(parentPath);\n            this.queueByDirectory.get(parentPath).filesToUpload.set(path, file);\n        }\n        /**\n         * Add a directory to the queue.\n         */\n        addDirectory(path) {\n            if (!this.queueByDirectory.has(path)) {\n                this.queueByDirectory.set(path, {\n                    existingFiles: [],\n                    filesToUpload: new Map(),\n                });\n            }\n        }\n    }\n    exports.Upload = Upload;\n    // Global instance.\n    exports.upload = new Upload(new notification_1.NotificationService(), new notification_1.ProgressService());\n});\n",null]}