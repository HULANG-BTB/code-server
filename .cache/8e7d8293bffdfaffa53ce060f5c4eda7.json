{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/common/buffer.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/buffer.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar hasBuffer = (typeof Buffer !== 'undefined');\nvar VSBuffer = /** @class */ (function () {\n    function VSBuffer(buffer) {\n        this.buffer = buffer;\n        this.byteLength = this.buffer.byteLength;\n    }\n    VSBuffer.alloc = function (byteLength) {\n        if (hasBuffer) {\n            return new VSBuffer(Buffer.allocUnsafe(byteLength));\n        }\n        else {\n            return new VSBuffer(new Uint8Array(byteLength));\n        }\n    };\n    VSBuffer.wrap = function (actual) {\n        return new VSBuffer(actual);\n    };\n    VSBuffer.fromString = function (source) {\n        return new VSBuffer(Buffer.from(source));\n    };\n    VSBuffer.concat = function (buffers, totalLength) {\n        if (typeof totalLength === 'undefined') {\n            totalLength = 0;\n            for (var i = 0, len = buffers.length; i < len; i++) {\n                totalLength += buffers[i].byteLength;\n            }\n        }\n        var ret = VSBuffer.alloc(totalLength);\n        var offset = 0;\n        for (var i = 0, len = buffers.length; i < len; i++) {\n            var element = buffers[i];\n            ret.set(element, offset);\n            offset += element.byteLength;\n        }\n        return ret;\n    };\n    VSBuffer.prototype.toString = function () {\n        return this.buffer.toString();\n    };\n    VSBuffer.prototype.slice = function (start, end) {\n        return new VSBuffer(this.buffer.slice(start, end));\n    };\n    VSBuffer.prototype.set = function (array, offset) {\n        this.buffer.set(array.buffer, offset);\n    };\n    VSBuffer.prototype.readUint32BE = function (offset) {\n        return readUint32BE(this.buffer, offset);\n    };\n    VSBuffer.prototype.writeUint32BE = function (value, offset) {\n        writeUint32BE(this.buffer, value, offset);\n    };\n    VSBuffer.prototype.readUint8 = function (offset) {\n        return readUint8(this.buffer, offset);\n    };\n    VSBuffer.prototype.writeUint8 = function (value, offset) {\n        writeUint8(this.buffer, value, offset);\n    };\n    return VSBuffer;\n}());\nexports.VSBuffer = VSBuffer;\nfunction readUint32BE(source, offset) {\n    return (source[offset] * Math.pow(2, 24)\n        + source[offset + 1] * Math.pow(2, 16)\n        + source[offset + 2] * Math.pow(2, 8)\n        + source[offset + 3]);\n}\nfunction writeUint32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value = value >>> 8;\n    destination[offset + 2] = value;\n    value = value >>> 8;\n    destination[offset + 1] = value;\n    value = value >>> 8;\n    destination[offset] = value;\n}\nfunction readUint8(source, offset) {\n    return source[offset];\n}\nfunction writeUint8(destination, value, offset) {\n    destination[offset] = value;\n}\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/common/buffer.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/common/buffer.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\ndeclare var Buffer: any;\nconst hasBuffer = (typeof Buffer !== 'undefined');\n\nexport class VSBuffer {\n\n\tpublic static alloc(byteLength: number): VSBuffer {\n\t\tif (hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.allocUnsafe(byteLength));\n\t\t} else {\n\t\t\treturn new VSBuffer(new Uint8Array(byteLength));\n\t\t}\n\t}\n\n\tpublic static wrap(actual: Uint8Array): VSBuffer {\n\t\treturn new VSBuffer(actual);\n\t}\n\n\tpublic static fromString(source: string): VSBuffer {\n\t\treturn new VSBuffer(Buffer.from(source));\n\t}\n\n\tpublic static concat(buffers: VSBuffer[], totalLength?: number): VSBuffer {\n\t\tif (typeof totalLength === 'undefined') {\n\t\t\ttotalLength = 0;\n\t\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\t\ttotalLength += buffers[i].byteLength;\n\t\t\t}\n\t\t}\n\n\t\tconst ret = VSBuffer.alloc(totalLength);\n\t\tlet offset = 0;\n\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\tconst element = buffers[i];\n\t\t\tret.set(element, offset);\n\t\t\toffset += element.byteLength;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tpublic readonly buffer: Uint8Array;\n\tpublic readonly byteLength: number;\n\n\tprivate constructor(buffer: Uint8Array) {\n\t\tthis.buffer = buffer;\n\t\tthis.byteLength = this.buffer.byteLength;\n\t}\n\n\tpublic toString(): string {\n\t\treturn this.buffer.toString();\n\t}\n\n\tpublic slice(start?: number, end?: number): VSBuffer {\n\t\treturn new VSBuffer(this.buffer.slice(start, end));\n\t}\n\n\tpublic set(array: VSBuffer, offset?: number): void {\n\t\tthis.buffer.set(array.buffer, offset);\n\t}\n\n\tpublic readUint32BE(offset: number): number {\n\t\treturn readUint32BE(this.buffer, offset);\n\t}\n\n\tpublic writeUint32BE(value: number, offset: number): void {\n\t\twriteUint32BE(this.buffer, value, offset);\n\t}\n\n\tpublic readUint8(offset: number): number {\n\t\treturn readUint8(this.buffer, offset);\n\t}\n\n\tpublic writeUint8(value: number, offset: number): void {\n\t\twriteUint8(this.buffer, value, offset);\n\t}\n\n}\n\nfunction readUint32BE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\tsource[offset] * 2 ** 24\n\t\t+ source[offset + 1] * 2 ** 16\n\t\t+ source[offset + 2] * 2 ** 8\n\t\t+ source[offset + 3]\n\t);\n}\n\nfunction writeUint32BE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 3] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = value;\n\tvalue = value >>> 8;\n\tdestination[offset] = value;\n}\n\nfunction readUint8(source: Uint8Array, offset: number): number {\n\treturn source[offset];\n}\n\nfunction writeUint8(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset] = value;\n}\n"]}]}