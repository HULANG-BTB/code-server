{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/configuration/common/configurationEditingService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/configuration/common/configurationEditingService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/uri\", \"vs/base/common/json\", \"vs/base/common/strings\", \"vs/base/common/jsonEdit\", \"vs/base/common/async\", \"vs/editor/common/core/editOperation\", \"vs/platform/registry/common/platform\", \"vs/editor/common/core/range\", \"vs/editor/common/core/selection\", \"vs/platform/workspace/common/workspace\", \"vs/platform/environment/common/environment\", \"vs/workbench/services/textfile/common/textfiles\", \"vs/platform/configuration/common/configuration\", \"vs/workbench/services/configuration/common/configuration\", \"vs/platform/files/common/files\", \"vs/editor/common/services/resolverService\", \"vs/platform/configuration/common/configurationRegistry\", \"vs/workbench/services/editor/common/editorService\", \"vs/platform/notification/common/notification\", \"vs/workbench/services/preferences/common/preferences\", \"vs/base/common/types\", \"vs/workbench/services/remote/common/remoteAgentService\"], function (require, exports, nls, uri_1, json, strings, jsonEdit_1, async_1, editOperation_1, platform_1, range_1, selection_1, workspace_1, environment_1, textfiles_1, configuration_1, configuration_2, files_1, resolverService_1, configurationRegistry_1, editorService_1, notification_1, preferences_1, types_1, remoteAgentService_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var ConfigurationEditingErrorCode;\n    (function (ConfigurationEditingErrorCode) {\n        /**\n         * Error when trying to write a configuration key that is not registered.\n         */\n        ConfigurationEditingErrorCode[ConfigurationEditingErrorCode[\"ERROR_UNKNOWN_KEY\"] = 0] = \"ERROR_UNKNOWN_KEY\";\n        /**\n         * Error when trying to write an application setting into workspace settings.\n         */\n        ConfigurationEditingErrorCode[ConfigurationEditingErrorCode[\"ERROR_INVALID_WORKSPACE_CONFIGURATION_APPLICATION\"] = 1] = \"ERROR_INVALID_WORKSPACE_CONFIGURATION_APPLICATION\";\n        /**\n         * Error when trying to write an invalid folder configuration key to folder settings.\n         */\n        ConfigurationEditingErrorCode[ConfigurationEditingErrorCode[\"ERROR_INVALID_FOLDER_CONFIGURATION\"] = 2] = \"ERROR_INVALID_FOLDER_CONFIGURATION\";\n        /**\n         * Error when trying to write to user target but not supported for provided key.\n         */\n        ConfigurationEditingErrorCode[ConfigurationEditingErrorCode[\"ERROR_INVALID_USER_TARGET\"] = 3] = \"ERROR_INVALID_USER_TARGET\";\n        /**\n         * Error when trying to write to user target but not supported for provided key.\n         */\n        ConfigurationEditingErrorCode[ConfigurationEditingErrorCode[\"ERROR_INVALID_WORKSPACE_TARGET\"] = 4] = \"ERROR_INVALID_WORKSPACE_TARGET\";\n        /**\n         * Error when trying to write a configuration key to folder target\n         */\n        ConfigurationEditingErrorCode[ConfigurationEditingErrorCode[\"ERROR_INVALID_FOLDER_TARGET\"] = 5] = \"ERROR_INVALID_FOLDER_TARGET\";\n        /**\n         * Error when trying to write to the workspace configuration without having a workspace opened.\n         */\n        ConfigurationEditingErrorCode[ConfigurationEditingErrorCode[\"ERROR_NO_WORKSPACE_OPENED\"] = 6] = \"ERROR_NO_WORKSPACE_OPENED\";\n        /**\n         * Error when trying to write and save to the configuration file while it is dirty in the editor.\n         */\n        ConfigurationEditingErrorCode[ConfigurationEditingErrorCode[\"ERROR_CONFIGURATION_FILE_DIRTY\"] = 7] = \"ERROR_CONFIGURATION_FILE_DIRTY\";\n        /**\n         * Error when trying to write to a configuration file that contains JSON errors.\n         */\n        ConfigurationEditingErrorCode[ConfigurationEditingErrorCode[\"ERROR_INVALID_CONFIGURATION\"] = 8] = \"ERROR_INVALID_CONFIGURATION\";\n    })(ConfigurationEditingErrorCode = exports.ConfigurationEditingErrorCode || (exports.ConfigurationEditingErrorCode = {}));\n    class ConfigurationEditingError extends Error {\n        constructor(message, code) {\n            super(message);\n            this.code = code;\n        }\n    }\n    exports.ConfigurationEditingError = ConfigurationEditingError;\n    let ConfigurationEditingService = class ConfigurationEditingService {\n        constructor(configurationService, contextService, environmentService, fileService, textModelResolverService, textFileService, notificationService, preferencesService, editorService, remoteAgentService) {\n            this.configurationService = configurationService;\n            this.contextService = contextService;\n            this.environmentService = environmentService;\n            this.fileService = fileService;\n            this.textModelResolverService = textModelResolverService;\n            this.textFileService = textFileService;\n            this.notificationService = notificationService;\n            this.preferencesService = preferencesService;\n            this.editorService = editorService;\n            this.queue = new async_1.Queue();\n            remoteAgentService.getEnvironment().then(environment => {\n                if (environment) {\n                    this.remoteSettingsResource = environment.appSettingsPath;\n                }\n            });\n        }\n        writeConfiguration(target, value, options = {}) {\n            const operation = this.getConfigurationEditOperation(target, value, options.scopes || {});\n            return Promise.resolve(this.queue.queue(() => this.doWriteConfiguration(operation, options) // queue up writes to prevent race conditions\n                .then(() => null, error => {\n                if (!options.donotNotifyError) {\n                    this.onError(error, operation, options.scopes);\n                }\n                return Promise.reject(error);\n            })));\n        }\n        doWriteConfiguration(operation, options) {\n            const checkDirtyConfiguration = !(options.force || options.donotSave);\n            const saveConfiguration = options.force || !options.donotSave;\n            return this.resolveAndValidate(operation.target, operation, checkDirtyConfiguration, options.scopes || {})\n                .then(reference => this.writeToBuffer(reference.object.textEditorModel, operation, saveConfiguration)\n                .then(() => reference.dispose()));\n        }\n        writeToBuffer(model, operation, save) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const edit = this.getEdits(model, operation)[0];\n                if (edit && this.applyEditsToBuffer(edit, model) && save) {\n                    return this.textFileService.save(operation.resource, { skipSaveParticipants: true /* programmatic change */ });\n                }\n            });\n        }\n        applyEditsToBuffer(edit, model) {\n            const startPosition = model.getPositionAt(edit.offset);\n            const endPosition = model.getPositionAt(edit.offset + edit.length);\n            const range = new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n            let currentText = model.getValueInRange(range);\n            if (edit.content !== currentText) {\n                const editOperation = currentText ? editOperation_1.EditOperation.replace(range, edit.content) : editOperation_1.EditOperation.insert(startPosition, edit.content);\n                model.pushEditOperations([new selection_1.Selection(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column)], [editOperation], () => []);\n                return true;\n            }\n            return false;\n        }\n        onError(error, operation, scopes) {\n            switch (error.code) {\n                case ConfigurationEditingErrorCode.ERROR_INVALID_CONFIGURATION:\n                    this.onInvalidConfigurationError(error, operation);\n                    break;\n                case ConfigurationEditingErrorCode.ERROR_CONFIGURATION_FILE_DIRTY:\n                    this.onConfigurationFileDirtyError(error, operation, scopes);\n                    break;\n                default:\n                    this.notificationService.error(error.message);\n            }\n        }\n        onInvalidConfigurationError(error, operation) {\n            const openStandAloneConfigurationActionLabel = operation.workspaceStandAloneConfigurationKey === configuration_2.TASKS_CONFIGURATION_KEY ? nls.localize('openTasksConfiguration', \"Open Tasks Configuration\")\n                : operation.workspaceStandAloneConfigurationKey === configuration_2.LAUNCH_CONFIGURATION_KEY ? nls.localize('openLaunchConfiguration', \"Open Launch Configuration\")\n                    : null;\n            if (openStandAloneConfigurationActionLabel) {\n                this.notificationService.prompt(notification_1.Severity.Error, error.message, [{\n                        label: openStandAloneConfigurationActionLabel,\n                        run: () => this.openFile(operation.resource)\n                    }]);\n            }\n            else {\n                this.notificationService.prompt(notification_1.Severity.Error, error.message, [{\n                        label: nls.localize('open', \"Open Settings\"),\n                        run: () => this.openSettings(operation)\n                    }]);\n            }\n        }\n        onConfigurationFileDirtyError(error, operation, scopes) {\n            const openStandAloneConfigurationActionLabel = operation.workspaceStandAloneConfigurationKey === configuration_2.TASKS_CONFIGURATION_KEY ? nls.localize('openTasksConfiguration', \"Open Tasks Configuration\")\n                : operation.workspaceStandAloneConfigurationKey === configuration_2.LAUNCH_CONFIGURATION_KEY ? nls.localize('openLaunchConfiguration', \"Open Launch Configuration\")\n                    : null;\n            if (openStandAloneConfigurationActionLabel) {\n                this.notificationService.prompt(notification_1.Severity.Error, error.message, [{\n                        label: nls.localize('saveAndRetry', \"Save and Retry\"),\n                        run: () => {\n                            const key = operation.key ? `${operation.workspaceStandAloneConfigurationKey}.${operation.key}` : operation.workspaceStandAloneConfigurationKey;\n                            this.writeConfiguration(operation.target, { key, value: operation.value }, { force: true, scopes });\n                        }\n                    },\n                    {\n                        label: openStandAloneConfigurationActionLabel,\n                        run: () => this.openFile(operation.resource)\n                    }]);\n            }\n            else {\n                this.notificationService.prompt(notification_1.Severity.Error, error.message, [{\n                        label: nls.localize('saveAndRetry', \"Save and Retry\"),\n                        run: () => this.writeConfiguration(operation.target, { key: operation.key, value: operation.value }, { force: true, scopes })\n                    },\n                    {\n                        label: nls.localize('open', \"Open Settings\"),\n                        run: () => this.openSettings(operation)\n                    }]);\n            }\n        }\n        openSettings(operation) {\n            switch (operation.target) {\n                case configuration_1.ConfigurationTarget.USER:\n                    this.preferencesService.openGlobalSettings(true);\n                    break;\n                case configuration_1.ConfigurationTarget.WORKSPACE:\n                    this.preferencesService.openWorkspaceSettings(true);\n                    break;\n                case configuration_1.ConfigurationTarget.WORKSPACE_FOLDER:\n                    if (operation.resource) {\n                        const workspaceFolder = this.contextService.getWorkspaceFolder(operation.resource);\n                        if (workspaceFolder) {\n                            this.preferencesService.openFolderSettings(workspaceFolder.uri, true);\n                        }\n                    }\n                    break;\n            }\n        }\n        openFile(resource) {\n            this.editorService.openEditor({ resource });\n        }\n        reject(code, target, operation) {\n            const message = this.toErrorMessage(code, target, operation);\n            return Promise.reject(new ConfigurationEditingError(message, code));\n        }\n        toErrorMessage(error, target, operation) {\n            switch (error) {\n                // API constraints\n                case ConfigurationEditingErrorCode.ERROR_UNKNOWN_KEY: return nls.localize('errorUnknownKey', \"Unable to write to {0} because {1} is not a registered configuration.\", this.stringifyTarget(target), operation.key);\n                case ConfigurationEditingErrorCode.ERROR_INVALID_WORKSPACE_CONFIGURATION_APPLICATION: return nls.localize('errorInvalidWorkspaceConfigurationApplication', \"Unable to write {0} to Workspace Settings. This setting can be written only into User settings.\", operation.key);\n                case ConfigurationEditingErrorCode.ERROR_INVALID_FOLDER_CONFIGURATION: return nls.localize('errorInvalidFolderConfiguration', \"Unable to write to Folder Settings because {0} does not support the folder resource scope.\", operation.key);\n                case ConfigurationEditingErrorCode.ERROR_INVALID_USER_TARGET: return nls.localize('errorInvalidUserTarget', \"Unable to write to User Settings because {0} does not support for global scope.\", operation.key);\n                case ConfigurationEditingErrorCode.ERROR_INVALID_WORKSPACE_TARGET: return nls.localize('errorInvalidWorkspaceTarget', \"Unable to write to Workspace Settings because {0} does not support for workspace scope in a multi folder workspace.\", operation.key);\n                case ConfigurationEditingErrorCode.ERROR_INVALID_FOLDER_TARGET: return nls.localize('errorInvalidFolderTarget', \"Unable to write to Folder Settings because no resource is provided.\");\n                case ConfigurationEditingErrorCode.ERROR_NO_WORKSPACE_OPENED: return nls.localize('errorNoWorkspaceOpened', \"Unable to write to {0} because no workspace is opened. Please open a workspace first and try again.\", this.stringifyTarget(target));\n                // User issues\n                case ConfigurationEditingErrorCode.ERROR_INVALID_CONFIGURATION: {\n                    if (operation.workspaceStandAloneConfigurationKey === configuration_2.TASKS_CONFIGURATION_KEY) {\n                        return nls.localize('errorInvalidTaskConfiguration', \"Unable to write into the tasks configuration file. Please open it to correct errors/warnings in it and try again.\");\n                    }\n                    if (operation.workspaceStandAloneConfigurationKey === configuration_2.LAUNCH_CONFIGURATION_KEY) {\n                        return nls.localize('errorInvalidLaunchConfiguration', \"Unable to write into the launch configuration file. Please open it to correct errors/warnings in it and try again.\");\n                    }\n                    switch (target) {\n                        case configuration_1.ConfigurationTarget.USER:\n                            return nls.localize('errorInvalidConfiguration', \"Unable to write into user settings. Please open the user settings to correct errors/warnings in it and try again.\");\n                        case configuration_1.ConfigurationTarget.WORKSPACE:\n                            return nls.localize('errorInvalidConfigurationWorkspace', \"Unable to write into workspace settings. Please open the workspace settings to correct errors/warnings in the file and try again.\");\n                        case configuration_1.ConfigurationTarget.WORKSPACE_FOLDER:\n                            let workspaceFolderName = '<<unknown>>';\n                            if (operation.resource) {\n                                const folder = this.contextService.getWorkspaceFolder(operation.resource);\n                                if (folder) {\n                                    workspaceFolderName = folder.name;\n                                }\n                            }\n                            return nls.localize('errorInvalidConfigurationFolder', \"Unable to write into folder settings. Please open the '{0}' folder settings to correct errors/warnings in it and try again.\", workspaceFolderName);\n                    }\n                    return '';\n                }\n                case ConfigurationEditingErrorCode.ERROR_CONFIGURATION_FILE_DIRTY: {\n                    if (operation.workspaceStandAloneConfigurationKey === configuration_2.TASKS_CONFIGURATION_KEY) {\n                        return nls.localize('errorTasksConfigurationFileDirty', \"Unable to write into tasks configuration file because the file is dirty. Please save it first and then try again.\");\n                    }\n                    if (operation.workspaceStandAloneConfigurationKey === configuration_2.LAUNCH_CONFIGURATION_KEY) {\n                        return nls.localize('errorLaunchConfigurationFileDirty', \"Unable to write into launch configuration file because the file is dirty. Please save it first and then try again.\");\n                    }\n                    switch (target) {\n                        case configuration_1.ConfigurationTarget.USER:\n                            return nls.localize('errorConfigurationFileDirty', \"Unable to write into user settings because the file is dirty. Please save the user settings file first and then try again.\");\n                        case configuration_1.ConfigurationTarget.WORKSPACE:\n                            return nls.localize('errorConfigurationFileDirtyWorkspace', \"Unable to write into workspace settings because the file is dirty. Please save the workspace settings file first and then try again.\");\n                        case configuration_1.ConfigurationTarget.WORKSPACE_FOLDER:\n                            let workspaceFolderName = '<<unknown>>';\n                            if (operation.resource) {\n                                const folder = this.contextService.getWorkspaceFolder(operation.resource);\n                                if (folder) {\n                                    workspaceFolderName = folder.name;\n                                }\n                            }\n                            return nls.localize('errorConfigurationFileDirtyFolder', \"Unable to write into folder settings because the file is dirty. Please save the '{0}' folder settings file first and then try again.\", workspaceFolderName);\n                    }\n                    return '';\n                }\n            }\n        }\n        stringifyTarget(target) {\n            switch (target) {\n                case configuration_1.ConfigurationTarget.USER:\n                    return nls.localize('userTarget', \"User Settings\");\n                case configuration_1.ConfigurationTarget.WORKSPACE:\n                    return nls.localize('workspaceTarget', \"Workspace Settings\");\n                case configuration_1.ConfigurationTarget.WORKSPACE_FOLDER:\n                    return nls.localize('folderTarget', \"Folder Settings\");\n            }\n            return '';\n        }\n        getEdits(model, edit) {\n            const { tabSize, insertSpaces } = model.getOptions();\n            const eol = model.getEOL();\n            const { value, jsonPath } = edit;\n            // Without jsonPath, the entire configuration file is being replaced, so we just use JSON.stringify\n            if (!jsonPath.length) {\n                const content = JSON.stringify(value, null, insertSpaces ? strings.repeat(' ', tabSize) : '\\t');\n                return [{\n                        content,\n                        length: model.getValue().length,\n                        offset: 0\n                    }];\n            }\n            return jsonEdit_1.setProperty(model.getValue(), jsonPath, value, { tabSize, insertSpaces, eol });\n        }\n        resolveModelReference(resource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const exists = yield this.fileService.existsFile(resource);\n                if (!exists) {\n                    yield this.fileService.updateContent(resource, '{}', { encoding: 'utf8' });\n                }\n                return this.textModelResolverService.createModelReference(resource);\n            });\n        }\n        hasParseErrors(model, operation) {\n            // If we write to a workspace standalone file and replace the entire contents (no key provided)\n            // we can return here because any parse errors can safely be ignored since all contents are replaced\n            if (operation.workspaceStandAloneConfigurationKey && !operation.key) {\n                return false;\n            }\n            const parseErrors = [];\n            json.parse(model.getValue(), parseErrors);\n            return parseErrors.length > 0;\n        }\n        resolveAndValidate(target, operation, checkDirty, overrides) {\n            // Any key must be a known setting from the registry (unless this is a standalone config)\n            if (!operation.workspaceStandAloneConfigurationKey) {\n                const validKeys = this.configurationService.keys().default;\n                if (validKeys.indexOf(operation.key) < 0 && !configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(operation.key)) {\n                    return this.reject(ConfigurationEditingErrorCode.ERROR_UNKNOWN_KEY, target, operation);\n                }\n            }\n            if (operation.workspaceStandAloneConfigurationKey) {\n                // Global tasks and launches are not supported\n                if (target === configuration_1.ConfigurationTarget.USER) {\n                    return this.reject(ConfigurationEditingErrorCode.ERROR_INVALID_USER_TARGET, target, operation);\n                }\n                // Workspace tasks are not supported\n                if (operation.workspaceStandAloneConfigurationKey === configuration_2.TASKS_CONFIGURATION_KEY && this.contextService.getWorkbenchState() === workspace_1.WorkbenchState.WORKSPACE && operation.target === configuration_1.ConfigurationTarget.WORKSPACE) {\n                    return this.reject(ConfigurationEditingErrorCode.ERROR_INVALID_WORKSPACE_TARGET, target, operation);\n                }\n            }\n            // Target cannot be workspace or folder if no workspace opened\n            if ((target === configuration_1.ConfigurationTarget.WORKSPACE || target === configuration_1.ConfigurationTarget.WORKSPACE_FOLDER) && this.contextService.getWorkbenchState() === workspace_1.WorkbenchState.EMPTY) {\n                return this.reject(ConfigurationEditingErrorCode.ERROR_NO_WORKSPACE_OPENED, target, operation);\n            }\n            if (target === configuration_1.ConfigurationTarget.WORKSPACE) {\n                if (!operation.workspaceStandAloneConfigurationKey) {\n                    const configurationProperties = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();\n                    if (configurationProperties[operation.key].scope === configurationRegistry_1.ConfigurationScope.APPLICATION) {\n                        return this.reject(ConfigurationEditingErrorCode.ERROR_INVALID_WORKSPACE_CONFIGURATION_APPLICATION, target, operation);\n                    }\n                }\n            }\n            if (target === configuration_1.ConfigurationTarget.WORKSPACE_FOLDER) {\n                if (!operation.resource) {\n                    return this.reject(ConfigurationEditingErrorCode.ERROR_INVALID_FOLDER_TARGET, target, operation);\n                }\n                if (!operation.workspaceStandAloneConfigurationKey) {\n                    const configurationProperties = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();\n                    if (configurationProperties[operation.key].scope !== configurationRegistry_1.ConfigurationScope.RESOURCE) {\n                        return this.reject(ConfigurationEditingErrorCode.ERROR_INVALID_FOLDER_CONFIGURATION, target, operation);\n                    }\n                }\n            }\n            if (!operation.resource) {\n                return this.reject(ConfigurationEditingErrorCode.ERROR_INVALID_FOLDER_TARGET, target, operation);\n            }\n            return this.resolveModelReference(operation.resource)\n                .then(reference => {\n                const model = reference.object.textEditorModel;\n                if (this.hasParseErrors(model, operation)) {\n                    return this.reject(ConfigurationEditingErrorCode.ERROR_INVALID_CONFIGURATION, target, operation);\n                }\n                // Target cannot be dirty if not writing into buffer\n                if (checkDirty && this.textFileService.isDirty(operation.resource)) {\n                    return this.reject(ConfigurationEditingErrorCode.ERROR_CONFIGURATION_FILE_DIRTY, target, operation);\n                }\n                return reference;\n            });\n        }\n        getConfigurationEditOperation(target, config, overrides) {\n            // Check for standalone workspace configurations\n            if (config.key) {\n                const standaloneConfigurationKeys = Object.keys(configuration_2.WORKSPACE_STANDALONE_CONFIGURATIONS);\n                for (const key of standaloneConfigurationKeys) {\n                    const resource = this.getConfigurationFileResource(target, config, configuration_2.WORKSPACE_STANDALONE_CONFIGURATIONS[key], overrides.resource);\n                    // Check for prefix\n                    if (config.key === key) {\n                        const jsonPath = this.isWorkspaceConfigurationResource(resource) ? [key] : [];\n                        return { key: jsonPath[jsonPath.length - 1], jsonPath, value: config.value, resource: types_1.withNullAsUndefined(resource), workspaceStandAloneConfigurationKey: key, target };\n                    }\n                    // Check for prefix.<setting>\n                    const keyPrefix = `${key}.`;\n                    if (config.key.indexOf(keyPrefix) === 0) {\n                        const jsonPath = this.isWorkspaceConfigurationResource(resource) ? [key, config.key.substr(keyPrefix.length)] : [config.key.substr(keyPrefix.length)];\n                        return { key: jsonPath[jsonPath.length - 1], jsonPath, value: config.value, resource: types_1.withNullAsUndefined(resource), workspaceStandAloneConfigurationKey: key, target };\n                    }\n                }\n            }\n            let key = config.key;\n            let jsonPath = overrides.overrideIdentifier ? [configuration_1.keyFromOverrideIdentifier(overrides.overrideIdentifier), key] : [key];\n            if (target === configuration_1.ConfigurationTarget.USER) {\n                return { key, jsonPath, value: config.value, resource: types_1.withNullAsUndefined(this.getConfigurationFileResource(target, config, '', null)), target };\n            }\n            const resource = this.getConfigurationFileResource(target, config, configuration_2.FOLDER_SETTINGS_PATH, overrides.resource);\n            if (this.isWorkspaceConfigurationResource(resource)) {\n                jsonPath = ['settings', ...jsonPath];\n            }\n            return { key, jsonPath, value: config.value, resource: types_1.withNullAsUndefined(resource), target };\n        }\n        isWorkspaceConfigurationResource(resource) {\n            const workspace = this.contextService.getWorkspace();\n            return !!(workspace.configuration && resource && workspace.configuration.fsPath === resource.fsPath);\n        }\n        getConfigurationFileResource(target, config, relativePath, resource) {\n            if (target === configuration_1.ConfigurationTarget.USER_LOCAL) {\n                return uri_1.URI.file(this.environmentService.appSettingsPath);\n            }\n            if (target === configuration_1.ConfigurationTarget.USER_REMOTE) {\n                return this.remoteSettingsResource;\n            }\n            if (target === configuration_1.ConfigurationTarget.USER) {\n                if (this.configurationService.inspect(config.key).userRemote !== undefined) {\n                    return this.remoteSettingsResource;\n                }\n                return uri_1.URI.file(this.environmentService.appSettingsPath);\n            }\n            const workbenchState = this.contextService.getWorkbenchState();\n            if (workbenchState !== workspace_1.WorkbenchState.EMPTY) {\n                const workspace = this.contextService.getWorkspace();\n                if (target === configuration_1.ConfigurationTarget.WORKSPACE) {\n                    if (workbenchState === workspace_1.WorkbenchState.WORKSPACE) {\n                        return types_1.withUndefinedAsNull(workspace.configuration);\n                    }\n                    if (workbenchState === workspace_1.WorkbenchState.FOLDER) {\n                        return workspace.folders[0].toResource(relativePath);\n                    }\n                }\n                if (target === configuration_1.ConfigurationTarget.WORKSPACE_FOLDER) {\n                    if (resource) {\n                        const folder = this.contextService.getWorkspaceFolder(resource);\n                        if (folder) {\n                            return folder.toResource(relativePath);\n                        }\n                    }\n                }\n            }\n            return null;\n        }\n    };\n    ConfigurationEditingService = __decorate([\n        __param(0, configuration_1.IConfigurationService),\n        __param(1, workspace_1.IWorkspaceContextService),\n        __param(2, environment_1.IEnvironmentService),\n        __param(3, files_1.IFileService),\n        __param(4, resolverService_1.ITextModelService),\n        __param(5, textfiles_1.ITextFileService),\n        __param(6, notification_1.INotificationService),\n        __param(7, preferences_1.IPreferencesService),\n        __param(8, editorService_1.IEditorService),\n        __param(9, remoteAgentService_1.IRemoteAgentService)\n    ], ConfigurationEditingService);\n    exports.ConfigurationEditingService = ConfigurationEditingService;\n});\n",null]}