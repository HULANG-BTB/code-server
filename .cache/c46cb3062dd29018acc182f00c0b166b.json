{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/electron-browser/window.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/electron-browser/window.ts","mtime":1555846338048},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/uri\", \"vs/base/common/errors\", \"vs/base/common/objects\", \"vs/base/browser/dom\", \"vs/base/browser/ui/actionbar/actionbar\", \"vs/base/common/actions\", \"vs/platform/files/common/files\", \"vs/workbench/common/editor\", \"vs/workbench/services/editor/common/editorService\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/windows/common/windows\", \"vs/platform/contextview/browser/contextView\", \"vs/workbench/services/title/common/titleService\", \"vs/workbench/services/themes/common/workbenchThemeService\", \"vs/base/browser/browser\", \"vs/platform/commands/common/commands\", \"vs/workbench/services/keybinding/electron-browser/keybindingService\", \"electron\", \"vs/workbench/services/workspace/common/workspaceEditing\", \"vs/platform/actions/common/actions\", \"vs/platform/contextkey/common/contextkey\", \"vs/platform/actions/browser/menuItemActionItem\", \"vs/base/common/async\", \"vs/base/common/lifecycle\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/workbench/services/integrity/common/integrity\", \"vs/base/common/platform\", \"vs/platform/product/node/product\", \"vs/platform/product/node/package\", \"vs/platform/notification/common/notification\", \"vs/platform/keybinding/common/keybinding\", \"vs/platform/environment/common/environment\", \"vs/platform/accessibility/common/accessibility\", \"vs/platform/workspace/common/workspace\", \"vs/base/common/arrays\", \"vs/platform/configuration/common/configuration\"], function (require, exports, nls, uri_1, errors, objects_1, DOM, actionbar_1, actions_1, files_1, editor_1, editorService_1, telemetry_1, windows_1, contextView_1, titleService_1, workbenchThemeService_1, browser, commands_1, keybindingService_1, electron_1, workspaceEditing_1, actions_2, contextkey_1, menuItemActionItem_1, async_1, lifecycle_1, lifecycle_2, integrity_1, platform_1, product_1, package_1, notification_1, keybinding_1, environment_1, accessibility_1, workspace_1, arrays_1, configuration_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const TextInputActions = [\n        new actions_1.Action('undo', nls.localize('undo', \"Undo\"), undefined, true, () => Promise.resolve(document.execCommand('undo'))),\n        new actions_1.Action('redo', nls.localize('redo', \"Redo\"), undefined, true, () => Promise.resolve(document.execCommand('redo'))),\n        new actionbar_1.Separator(),\n        new actions_1.Action('editor.action.clipboardCutAction', nls.localize('cut', \"Cut\"), undefined, true, () => Promise.resolve(document.execCommand('cut'))),\n        new actions_1.Action('editor.action.clipboardCopyAction', nls.localize('copy', \"Copy\"), undefined, true, () => Promise.resolve(document.execCommand('copy'))),\n        require('vs/../../../../packages/vscode/src/workbench').workbench.pasteAction,\n        new actionbar_1.Separator(),\n        new actions_1.Action('editor.action.selectAll', nls.localize('selectAll', \"Select All\"), undefined, true, () => Promise.resolve(document.execCommand('selectAll')))\n    ];\n    let ElectronWindow = class ElectronWindow extends lifecycle_1.Disposable {\n        constructor(editorService, windowsService, windowService, configurationService, titleService, themeService, notificationService, commandService, keybindingService, contextMenuService, telemetryService, workspaceEditingService, fileService, menuService, lifecycleService, integrityService, environmentService, accessibilityService, contextService) {\n            super();\n            this.editorService = editorService;\n            this.windowsService = windowsService;\n            this.windowService = windowService;\n            this.configurationService = configurationService;\n            this.titleService = titleService;\n            this.themeService = themeService;\n            this.notificationService = notificationService;\n            this.commandService = commandService;\n            this.keybindingService = keybindingService;\n            this.contextMenuService = contextMenuService;\n            this.telemetryService = telemetryService;\n            this.workspaceEditingService = workspaceEditingService;\n            this.fileService = fileService;\n            this.menuService = menuService;\n            this.lifecycleService = lifecycleService;\n            this.integrityService = integrityService;\n            this.environmentService = environmentService;\n            this.accessibilityService = accessibilityService;\n            this.contextService = contextService;\n            this.closeEmptyWindowScheduler = this._register(new async_1.RunOnceScheduler(() => this.onAllEditorsClosed(), 50));\n            this.touchBarDisposables = [];\n            this.pendingFoldersToAdd = [];\n            this.addFoldersScheduler = this._register(new async_1.RunOnceScheduler(() => this.doAddFolders(), 100));\n            this.registerListeners();\n            this.create();\n        }\n        registerListeners() {\n            // React to editor input changes\n            this._register(this.editorService.onDidActiveEditorChange(() => this.updateTouchbarMenu()));\n            // prevent opening a real URL inside the shell\n            [DOM.EventType.DRAG_OVER, DOM.EventType.DROP].forEach(event => {\n                window.document.body.addEventListener(event, (e) => {\n                    DOM.EventHelper.stop(e);\n                });\n            });\n            // Support runAction event\n            electron_1.ipcRenderer.on('vscode:runAction', (event, request) => {\n                const args = request.args || [];\n                // If we run an action from the touchbar, we fill in the currently active resource\n                // as payload because the touch bar items are context aware depending on the editor\n                if (request.from === 'touchbar') {\n                    const activeEditor = this.editorService.activeEditor;\n                    if (activeEditor) {\n                        const resource = editor_1.toResource(activeEditor, { supportSideBySide: true });\n                        if (resource) {\n                            args.push(resource);\n                        }\n                    }\n                }\n                else {\n                    args.push({ from: request.from }); // TODO@telemetry this is a bit weird to send this to every action?\n                }\n                this.commandService.executeCommand(request.id, ...args).then(_ => {\n                    /* __GDPR__\n                        \"commandExecuted\" : {\n                            \"id\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                            \"from\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                        }\n                    */\n                    this.telemetryService.publicLog('commandExecuted', { id: request.id, from: request.from });\n                }, err => {\n                    this.notificationService.error(err);\n                });\n            });\n            // Support runKeybinding event\n            electron_1.ipcRenderer.on('vscode:runKeybinding', (event, request) => {\n                if (document.activeElement) {\n                    this.keybindingService.dispatchByUserSettingsLabel(request.userSettingsLabel, document.activeElement);\n                }\n            });\n            // Error reporting from main\n            electron_1.ipcRenderer.on('vscode:reportError', (event, error) => {\n                if (error) {\n                    errors.onUnexpectedError(JSON.parse(error));\n                }\n            });\n            // Support openFiles event for existing and new files\n            electron_1.ipcRenderer.on('vscode:openFiles', (event, request) => this.onOpenFiles(request));\n            // Support addFolders event if we have a workspace opened\n            electron_1.ipcRenderer.on('vscode:addFolders', (event, request) => this.onAddFoldersRequest(request));\n            // Message support\n            electron_1.ipcRenderer.on('vscode:showInfoMessage', (event, message) => {\n                this.notificationService.info(message);\n            });\n            // Fullscreen Events\n            electron_1.ipcRenderer.on('vscode:enterFullScreen', () => {\n                this.lifecycleService.when(lifecycle_2.LifecyclePhase.Ready).then(() => {\n                    browser.setFullscreen(true);\n                });\n            });\n            electron_1.ipcRenderer.on('vscode:leaveFullScreen', () => {\n                this.lifecycleService.when(lifecycle_2.LifecyclePhase.Ready).then(() => {\n                    browser.setFullscreen(false);\n                });\n            });\n            // High Contrast Events\n            electron_1.ipcRenderer.on('vscode:enterHighContrast', () => {\n                const windowConfig = this.configurationService.getValue('window');\n                if (windowConfig && windowConfig.autoDetectHighContrast) {\n                    this.lifecycleService.when(lifecycle_2.LifecyclePhase.Ready).then(() => {\n                        this.themeService.setColorTheme(workbenchThemeService_1.VS_HC_THEME, undefined);\n                    });\n                }\n            });\n            electron_1.ipcRenderer.on('vscode:leaveHighContrast', () => {\n                const windowConfig = this.configurationService.getValue('window');\n                if (windowConfig && windowConfig.autoDetectHighContrast) {\n                    this.lifecycleService.when(lifecycle_2.LifecyclePhase.Ready).then(() => {\n                        this.themeService.restoreColorTheme();\n                    });\n                }\n            });\n            // keyboard layout changed event\n            electron_1.ipcRenderer.on('vscode:keyboardLayoutChanged', () => {\n                keybindingService_1.KeyboardMapperFactory.INSTANCE._onKeyboardLayoutChanged();\n            });\n            // keyboard layout changed event\n            electron_1.ipcRenderer.on('vscode:accessibilitySupportChanged', (event, accessibilitySupportEnabled) => {\n                this.accessibilityService.setAccessibilitySupport(accessibilitySupportEnabled ? accessibility_1.AccessibilitySupport.Enabled : accessibility_1.AccessibilitySupport.Disabled);\n            });\n            // Zoom level changes\n            this.updateWindowZoomLevel();\n            this._register(this.configurationService.onDidChangeConfiguration(e => {\n                if (e.affectsConfiguration('window.zoomLevel')) {\n                    this.updateWindowZoomLevel();\n                }\n            }));\n            // Context menu support in input/textarea\n            window.document.addEventListener('contextmenu', e => this.onContextMenu(e));\n            // Listen to visible editor changes\n            this._register(this.editorService.onDidVisibleEditorsChange(() => this.onDidVisibleEditorsChange()));\n            // Listen to editor closing (if we run with --wait)\n            const filesToWait = this.windowService.getConfiguration().filesToWait;\n            if (filesToWait) {\n                const resourcesToWaitFor = arrays_1.coalesce(filesToWait.paths.map(p => p.fileUri));\n                const waitMarkerFile = filesToWait.waitMarkerFileUri;\n                const listenerDispose = this.editorService.onDidCloseEditor(() => this.onEditorClosed(listenerDispose, resourcesToWaitFor, waitMarkerFile));\n                this._register(listenerDispose);\n            }\n        }\n        onDidVisibleEditorsChange() {\n            // Close when empty: check if we should close the window based on the setting\n            // Overruled by: window has a workspace opened or this window is for extension development\n            // or setting is disabled. Also enabled when running with --wait from the command line.\n            const visibleEditors = this.editorService.visibleControls;\n            if (visibleEditors.length === 0 && this.contextService.getWorkbenchState() === workspace_1.WorkbenchState.EMPTY && !this.environmentService.isExtensionDevelopment) {\n                const closeWhenEmpty = this.configurationService.getValue('window.closeWhenEmpty');\n                if (closeWhenEmpty || this.environmentService.args.wait) {\n                    this.closeEmptyWindowScheduler.schedule();\n                }\n            }\n        }\n        onAllEditorsClosed() {\n            const visibleEditors = this.editorService.visibleControls.length;\n            if (visibleEditors === 0) {\n                this.windowService.closeWindow();\n            }\n        }\n        onEditorClosed(listenerDispose, resourcesToWaitFor, waitMarkerFile) {\n            // In wait mode, listen to changes to the editors and wait until the files\n            // are closed that the user wants to wait for. When this happens we delete\n            // the wait marker file to signal to the outside that editing is done.\n            if (resourcesToWaitFor.every(resource => !this.editorService.isOpen({ resource }))) {\n                listenerDispose.dispose();\n                this.fileService.del(waitMarkerFile);\n            }\n        }\n        onContextMenu(e) {\n            if (e.target instanceof HTMLElement) {\n                const target = e.target;\n                if (target.nodeName && (target.nodeName.toLowerCase() === 'input' || target.nodeName.toLowerCase() === 'textarea')) {\n                    DOM.EventHelper.stop(e, true);\n                    this.contextMenuService.showContextMenu({\n                        getAnchor: () => e,\n                        getActions: () => TextInputActions,\n                        onHide: () => target.focus() // fixes https://github.com/Microsoft/vscode/issues/52948\n                    });\n                }\n            }\n        }\n        updateWindowZoomLevel() {\n            const windowConfig = this.configurationService.getValue();\n            let newZoomLevel = 0;\n            if (windowConfig.window && typeof windowConfig.window.zoomLevel === 'number') {\n                newZoomLevel = windowConfig.window.zoomLevel;\n                // Leave early if the configured zoom level did not change (https://github.com/Microsoft/vscode/issues/1536)\n                if (this.previousConfiguredZoomLevel === newZoomLevel) {\n                    return;\n                }\n                this.previousConfiguredZoomLevel = newZoomLevel;\n            }\n            if (electron_1.webFrame.getZoomLevel() !== newZoomLevel) {\n                electron_1.webFrame.setZoomLevel(newZoomLevel);\n                browser.setZoomFactor(electron_1.webFrame.getZoomFactor());\n                // See https://github.com/Microsoft/vscode/issues/26151\n                // Cannot be trusted because the webFrame might take some time\n                // until it really applies the new zoom level\n                browser.setZoomLevel(electron_1.webFrame.getZoomLevel(), /*isTrusted*/ false);\n            }\n        }\n        create() {\n            // Handle window.open() calls\n            const $this = this;\n            window.open = function (url, target, features, replace) {\n                $this.windowsService.openExternal(url);\n                return null;\n            };\n            // Emit event when vscode is ready\n            this.lifecycleService.when(lifecycle_2.LifecyclePhase.Ready).then(() => {\n                electron_1.ipcRenderer.send('vscode:workbenchReady', this.windowService.getCurrentWindowId());\n            });\n            // Integrity warning\n            this.integrityService.isPure().then(res => this.titleService.updateProperties({ isPure: res.isPure }));\n            // Root warning\n            this.lifecycleService.when(lifecycle_2.LifecyclePhase.Restored).then(() => {\n                let isAdminPromise;\n                if (platform_1.isWindows) {\n                    isAdminPromise = new Promise((resolve_1, reject_1) => { require(['native-is-elevated'], resolve_1, reject_1); }).then(isElevated => isElevated());\n                }\n                else {\n                    isAdminPromise = Promise.resolve(platform_1.isRootUser());\n                }\n                return isAdminPromise.then(isAdmin => {\n                    // Update title\n                    this.titleService.updateProperties({ isAdmin });\n                    // Show warning message (unix only)\n                    if (isAdmin && !platform_1.isWindows) {\n                        this.notificationService.warn(nls.localize('runningAsRoot', \"It is not recommended to run {0} as root user.\", product_1.default.nameShort));\n                    }\n                });\n            });\n            // Touchbar menu (if enabled)\n            this.updateTouchbarMenu();\n            // Crash reporter (if enabled)\n            if (!this.environmentService.disableCrashReporter && product_1.default.crashReporter && product_1.default.hockeyApp && this.configurationService.getValue('telemetry.enableCrashReporter')) {\n                this.setupCrashReporter();\n            }\n        }\n        updateTouchbarMenu() {\n            if (!browser.isMacintosh || // macOS only\n                !this.configurationService.getValue('keyboard.touchbar.enabled') // disabled via setting\n            ) {\n                return;\n            }\n            // Dispose old\n            this.touchBarDisposables = lifecycle_1.dispose(this.touchBarDisposables);\n            this.touchBarMenu = undefined;\n            // Create new (delayed)\n            this.touchBarUpdater = new async_1.RunOnceScheduler(() => this.doUpdateTouchbarMenu(), 300);\n            this.touchBarDisposables.push(this.touchBarUpdater);\n            this.touchBarUpdater.schedule();\n        }\n        doUpdateTouchbarMenu() {\n            if (!this.touchBarMenu) {\n                this.touchBarMenu = this.editorService.invokeWithinEditorContext(accessor => this.menuService.createMenu(actions_2.MenuId.TouchBarContext, accessor.get(contextkey_1.IContextKeyService)));\n                this.touchBarDisposables.push(this.touchBarMenu);\n                this.touchBarDisposables.push(this.touchBarMenu.onDidChange(() => this.touchBarUpdater.schedule()));\n            }\n            const actions = [];\n            // Fill actions into groups respecting order\n            menuItemActionItem_1.fillInActionBarActions(this.touchBarMenu, undefined, actions);\n            // Convert into command action multi array\n            const items = [];\n            let group = [];\n            for (const action of actions) {\n                // Command\n                if (action instanceof actions_2.MenuItemAction) {\n                    group.push(action.item);\n                }\n                // Separator\n                else if (action instanceof actionbar_1.Separator) {\n                    if (group.length) {\n                        items.push(group);\n                    }\n                    group = [];\n                }\n            }\n            if (group.length) {\n                items.push(group);\n            }\n            // Only update if the actions have changed\n            if (!objects_1.equals(this.lastInstalledTouchedBar, items)) {\n                this.lastInstalledTouchedBar = items;\n                this.windowService.updateTouchBar(items);\n            }\n        }\n        setupCrashReporter() {\n            // base options with product info\n            const options = {\n                companyName: product_1.default.crashReporter.companyName,\n                productName: product_1.default.crashReporter.productName,\n                submitURL: platform_1.isWindows ? product_1.default.hockeyApp[`win32-${process.arch}`] : platform_1.isLinux ? product_1.default.hockeyApp[`linux-${process.arch}`] : product_1.default.hockeyApp.darwin,\n                extra: {\n                    vscode_version: package_1.default.version,\n                    vscode_commit: product_1.default.commit\n                }\n            };\n            // mixin telemetry info\n            this.telemetryService.getTelemetryInfo()\n                .then(info => {\n                objects_1.assign(options.extra, {\n                    vscode_sessionId: info.sessionId\n                });\n                // start crash reporter right here\n                electron_1.crashReporter.start(objects_1.deepClone(options));\n                // start crash reporter in the main process\n                return this.windowsService.startCrashReporter(options);\n            });\n        }\n        onAddFoldersRequest(request) {\n            // Buffer all pending requests\n            this.pendingFoldersToAdd.push(...request.foldersToAdd.map(f => uri_1.URI.revive(f)));\n            // Delay the adding of folders a bit to buffer in case more requests are coming\n            if (!this.addFoldersScheduler.isScheduled()) {\n                this.addFoldersScheduler.schedule();\n            }\n        }\n        doAddFolders() {\n            const foldersToAdd = [];\n            this.pendingFoldersToAdd.forEach(folder => {\n                foldersToAdd.push(({ uri: folder }));\n            });\n            this.pendingFoldersToAdd = [];\n            this.workspaceEditingService.addFolders(foldersToAdd);\n        }\n        onOpenFiles(request) {\n            const inputs = [];\n            const diffMode = !!(request.filesToDiff && (request.filesToDiff.length === 2));\n            if (!diffMode && request.filesToOpen) {\n                inputs.push(...this.toInputs(request.filesToOpen, false));\n            }\n            if (!diffMode && request.filesToCreate) {\n                inputs.push(...this.toInputs(request.filesToCreate, true));\n            }\n            if (diffMode && request.filesToDiff) {\n                inputs.push(...this.toInputs(request.filesToDiff, false));\n            }\n            if (inputs.length) {\n                this.openResources(inputs, diffMode);\n            }\n            if (request.filesToWait && inputs.length) {\n                // In wait mode, listen to changes to the editors and wait until the files\n                // are closed that the user wants to wait for. When this happens we delete\n                // the wait marker file to signal to the outside that editing is done.\n                const resourcesToWaitFor = request.filesToWait.paths.map(p => uri_1.URI.revive(p.fileUri));\n                const waitMarkerFile = uri_1.URI.revive(request.filesToWait.waitMarkerFileUri);\n                const unbind = this.editorService.onDidCloseEditor(() => {\n                    if (resourcesToWaitFor.every(resource => !this.editorService.isOpen({ resource }))) {\n                        unbind.dispose();\n                        this.fileService.del(waitMarkerFile);\n                    }\n                });\n            }\n        }\n        openResources(resources, diffMode) {\n            this.lifecycleService.when(lifecycle_2.LifecyclePhase.Ready).then(() => {\n                // In diffMode we open 2 resources as diff\n                if (diffMode && resources.length === 2) {\n                    return this.editorService.openEditor({ leftResource: resources[0].resource, rightResource: resources[1].resource, options: { pinned: true } });\n                }\n                // For one file, just put it into the current active editor\n                if (resources.length === 1) {\n                    return this.editorService.openEditor(resources[0]);\n                }\n                // Otherwise open all\n                return this.editorService.openEditors(resources);\n            });\n        }\n        toInputs(paths, isNew) {\n            return paths.map(p => {\n                const resource = uri_1.URI.revive(p.fileUri);\n                let input;\n                if (isNew) {\n                    input = { filePath: resource.fsPath, options: { pinned: true } };\n                }\n                else {\n                    input = { resource, options: { pinned: true } };\n                }\n                if (!isNew && typeof p.lineNumber === 'number' && typeof p.columnNumber === 'number') {\n                    input.options.selection = {\n                        startLineNumber: p.lineNumber,\n                        startColumn: p.columnNumber\n                    };\n                }\n                return input;\n            });\n        }\n        dispose() {\n            this.touchBarDisposables = lifecycle_1.dispose(this.touchBarDisposables);\n            super.dispose();\n        }\n    };\n    ElectronWindow = __decorate([\n        __param(0, editorService_1.IEditorService),\n        __param(1, windows_1.IWindowsService),\n        __param(2, windows_1.IWindowService),\n        __param(3, configuration_1.IConfigurationService),\n        __param(4, titleService_1.ITitleService),\n        __param(5, workbenchThemeService_1.IWorkbenchThemeService),\n        __param(6, notification_1.INotificationService),\n        __param(7, commands_1.ICommandService),\n        __param(8, keybinding_1.IKeybindingService),\n        __param(9, contextView_1.IContextMenuService),\n        __param(10, telemetry_1.ITelemetryService),\n        __param(11, workspaceEditing_1.IWorkspaceEditingService),\n        __param(12, files_1.IFileService),\n        __param(13, actions_2.IMenuService),\n        __param(14, lifecycle_2.ILifecycleService),\n        __param(15, integrity_1.IIntegrityService),\n        __param(16, environment_1.IEnvironmentService),\n        __param(17, accessibility_1.IAccessibilityService),\n        __param(18, workspace_1.IWorkspaceContextService)\n    ], ElectronWindow);\n    exports.ElectronWindow = ElectronWindow;\n});\n",null]}