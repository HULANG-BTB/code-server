{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/viewModel/splitLinesCollection.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewModel/splitLinesCollection.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar position_1 = require(\"vs/editor/common/core/position\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar textModel_1 = require(\"vs/editor/common/model/textModel\");\nvar viewEvents = require(\"vs/editor/common/view/viewEvents\");\nvar prefixSumComputer_1 = require(\"vs/editor/common/viewModel/prefixSumComputer\");\nvar viewModel_1 = require(\"vs/editor/common/viewModel/viewModel\");\nvar OutputPosition = /** @class */ (function () {\n    function OutputPosition(outputLineIndex, outputOffset) {\n        this.outputLineIndex = outputLineIndex;\n        this.outputOffset = outputOffset;\n    }\n    return OutputPosition;\n}());\nexports.OutputPosition = OutputPosition;\nvar CoordinatesConverter = /** @class */ (function () {\n    function CoordinatesConverter(lines) {\n        this._lines = lines;\n    }\n    // View -> Model conversion and related methods\n    CoordinatesConverter.prototype.convertViewPositionToModelPosition = function (viewPosition) {\n        return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n    };\n    CoordinatesConverter.prototype.convertViewRangeToModelRange = function (viewRange) {\n        var start = this._lines.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n        var end = this._lines.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n        return new range_1.Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    };\n    CoordinatesConverter.prototype.validateViewPosition = function (viewPosition, expectedModelPosition) {\n        return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n    };\n    CoordinatesConverter.prototype.validateViewRange = function (viewRange, expectedModelRange) {\n        var validViewStart = this._lines.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n        var validViewEnd = this._lines.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n        return new range_1.Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n    };\n    // Model -> View conversion and related methods\n    CoordinatesConverter.prototype.convertModelPositionToViewPosition = function (modelPosition) {\n        return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);\n    };\n    CoordinatesConverter.prototype.convertModelRangeToViewRange = function (modelRange) {\n        var start = this._lines.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn);\n        var end = this._lines.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn);\n        return new range_1.Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    };\n    CoordinatesConverter.prototype.modelPositionIsVisible = function (modelPosition) {\n        return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n    };\n    return CoordinatesConverter;\n}());\nexports.CoordinatesConverter = CoordinatesConverter;\nvar IndentGuideRepeatOption;\n(function (IndentGuideRepeatOption) {\n    IndentGuideRepeatOption[IndentGuideRepeatOption[\"BlockNone\"] = 0] = \"BlockNone\";\n    IndentGuideRepeatOption[IndentGuideRepeatOption[\"BlockSubsequent\"] = 1] = \"BlockSubsequent\";\n    IndentGuideRepeatOption[IndentGuideRepeatOption[\"BlockAll\"] = 2] = \"BlockAll\";\n})(IndentGuideRepeatOption || (IndentGuideRepeatOption = {}));\nvar SplitLinesCollection = /** @class */ (function () {\n    function SplitLinesCollection(model, linePositionMapperFactory, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent) {\n        this.model = model;\n        this._validModelVersionId = -1;\n        this.tabSize = tabSize;\n        this.wrappingColumn = wrappingColumn;\n        this.columnsForFullWidthChar = columnsForFullWidthChar;\n        this.wrappingIndent = wrappingIndent;\n        this.linePositionMapperFactory = linePositionMapperFactory;\n        this._constructLines(true);\n    }\n    SplitLinesCollection.prototype.dispose = function () {\n        this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, []);\n    };\n    SplitLinesCollection.prototype.createCoordinatesConverter = function () {\n        return new CoordinatesConverter(this);\n    };\n    SplitLinesCollection.prototype._ensureValidState = function () {\n        var modelVersion = this.model.getVersionId();\n        if (modelVersion !== this._validModelVersionId) {\n            // This is pretty bad, it means we lost track of the model...\n            throw new Error(\"ViewModel is out of sync with Model!\");\n        }\n        if (this.lines.length !== this.model.getLineCount()) {\n            // This is pretty bad, it means we lost track of the model...\n            this._constructLines(false);\n        }\n    };\n    SplitLinesCollection.prototype._constructLines = function (resetHiddenAreas) {\n        var _this = this;\n        this.lines = [];\n        if (resetHiddenAreas) {\n            this.hiddenAreasIds = [];\n        }\n        var linesContent = this.model.getLinesContent();\n        var lineCount = linesContent.length;\n        var values = new Uint32Array(lineCount);\n        var hiddenAreas = this.hiddenAreasIds.map(function (areaId) { return _this.model.getDecorationRange(areaId); }).sort(range_1.Range.compareRangesUsingStarts);\n        var hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        var hiddenAreaIdx = -1;\n        var nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n        for (var i = 0; i < lineCount; i++) {\n            var lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n            }\n            var isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n            var line = createSplitLine(this.linePositionMapperFactory, linesContent[i], this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, !isInHiddenArea);\n            values[i] = line.getViewLineCount();\n            this.lines[i] = line;\n        }\n        this._validModelVersionId = this.model.getVersionId();\n        this.prefixSumComputer = new prefixSumComputer_1.PrefixSumComputerWithCache(values);\n    };\n    SplitLinesCollection.prototype.getHiddenAreas = function () {\n        var _this = this;\n        return this.hiddenAreasIds.map(function (decId) {\n            return _this.model.getDecorationRange(decId);\n        });\n    };\n    SplitLinesCollection.prototype._reduceRanges = function (_ranges) {\n        var _this = this;\n        if (_ranges.length === 0) {\n            return [];\n        }\n        var ranges = _ranges.map(function (r) { return _this.model.validateRange(r); }).sort(range_1.Range.compareRangesUsingStarts);\n        var result = [];\n        var currentRangeStart = ranges[0].startLineNumber;\n        var currentRangeEnd = ranges[0].endLineNumber;\n        for (var i = 1, len = ranges.length; i < len; i++) {\n            var range = ranges[i];\n            if (range.startLineNumber > currentRangeEnd + 1) {\n                result.push(new range_1.Range(currentRangeStart, 1, currentRangeEnd, 1));\n                currentRangeStart = range.startLineNumber;\n                currentRangeEnd = range.endLineNumber;\n            }\n            else if (range.endLineNumber > currentRangeEnd) {\n                currentRangeEnd = range.endLineNumber;\n            }\n        }\n        result.push(new range_1.Range(currentRangeStart, 1, currentRangeEnd, 1));\n        return result;\n    };\n    SplitLinesCollection.prototype.setHiddenAreas = function (_ranges) {\n        var _this = this;\n        var newRanges = this._reduceRanges(_ranges);\n        // BEGIN TODO@Martin: Please stop calling this method on each model change!\n        var oldRanges = this.hiddenAreasIds.map(function (areaId) { return _this.model.getDecorationRange(areaId); }).sort(range_1.Range.compareRangesUsingStarts);\n        if (newRanges.length === oldRanges.length) {\n            var hasDifference = false;\n            for (var i = 0; i < newRanges.length; i++) {\n                if (!newRanges[i].equalsRange(oldRanges[i])) {\n                    hasDifference = true;\n                    break;\n                }\n            }\n            if (!hasDifference) {\n                return false;\n            }\n        }\n        // END TODO@Martin: Please stop calling this method on each model change!\n        var newDecorations = [];\n        for (var _i = 0, newRanges_1 = newRanges; _i < newRanges_1.length; _i++) {\n            var newRange = newRanges_1[_i];\n            newDecorations.push({\n                range: newRange,\n                options: textModel_1.ModelDecorationOptions.EMPTY\n            });\n        }\n        this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, newDecorations);\n        var hiddenAreas = newRanges;\n        var hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        var hiddenAreaIdx = -1;\n        var nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;\n        var hasVisibleLine = false;\n        for (var i = 0; i < this.lines.length; i++) {\n            var lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;\n            }\n            var lineChanged = false;\n            if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n                // Line should be hidden\n                if (this.lines[i].isVisible()) {\n                    this.lines[i] = this.lines[i].setVisible(false);\n                    lineChanged = true;\n                }\n            }\n            else {\n                hasVisibleLine = true;\n                // Line should be visible\n                if (!this.lines[i].isVisible()) {\n                    this.lines[i] = this.lines[i].setVisible(true);\n                    lineChanged = true;\n                }\n            }\n            if (lineChanged) {\n                var newOutputLineCount = this.lines[i].getViewLineCount();\n                this.prefixSumComputer.changeValue(i, newOutputLineCount);\n            }\n        }\n        if (!hasVisibleLine) {\n            // Cannot have everything be hidden => reveal everything!\n            this.setHiddenAreas([]);\n        }\n        return true;\n    };\n    SplitLinesCollection.prototype.modelPositionIsVisible = function (modelLineNumber, _modelColumn) {\n        if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {\n            // invalid arguments\n            return false;\n        }\n        return this.lines[modelLineNumber - 1].isVisible();\n    };\n    SplitLinesCollection.prototype.setTabSize = function (newTabSize) {\n        if (this.tabSize === newTabSize) {\n            return false;\n        }\n        this.tabSize = newTabSize;\n        this._constructLines(false);\n        return true;\n    };\n    SplitLinesCollection.prototype.setWrappingSettings = function (wrappingIndent, wrappingColumn, columnsForFullWidthChar) {\n        if (this.wrappingIndent === wrappingIndent && this.wrappingColumn === wrappingColumn && this.columnsForFullWidthChar === columnsForFullWidthChar) {\n            return false;\n        }\n        this.wrappingIndent = wrappingIndent;\n        this.wrappingColumn = wrappingColumn;\n        this.columnsForFullWidthChar = columnsForFullWidthChar;\n        this._constructLines(false);\n        return true;\n    };\n    SplitLinesCollection.prototype.onModelFlushed = function () {\n        this._constructLines(true);\n    };\n    SplitLinesCollection.prototype.onModelLinesDeleted = function (versionId, fromLineNumber, toLineNumber) {\n        if (versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        var outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);\n        var outputToLineNumber = this.prefixSumComputer.getAccumulatedValue(toLineNumber - 1);\n        this.lines.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        this.prefixSumComputer.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n    };\n    SplitLinesCollection.prototype.onModelLinesInserted = function (versionId, fromLineNumber, _toLineNumber, text) {\n        if (versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        var hiddenAreas = this.getHiddenAreas();\n        var isInHiddenArea = false;\n        var testPosition = new position_1.Position(fromLineNumber, 1);\n        for (var _i = 0, hiddenAreas_1 = hiddenAreas; _i < hiddenAreas_1.length; _i++) {\n            var hiddenArea = hiddenAreas_1[_i];\n            if (hiddenArea.containsPosition(testPosition)) {\n                isInHiddenArea = true;\n                break;\n            }\n        }\n        var outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);\n        var totalOutputLineCount = 0;\n        var insertLines = [];\n        var insertPrefixSumValues = new Uint32Array(text.length);\n        for (var i = 0, len = text.length; i < len; i++) {\n            var line = createSplitLine(this.linePositionMapperFactory, text[i], this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, !isInHiddenArea);\n            insertLines.push(line);\n            var outputLineCount = line.getViewLineCount();\n            totalOutputLineCount += outputLineCount;\n            insertPrefixSumValues[i] = outputLineCount;\n        }\n        // TODO@Alex: use arrays.arrayInsert\n        this.lines = this.lines.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.lines.slice(fromLineNumber - 1));\n        this.prefixSumComputer.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n        return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n    };\n    SplitLinesCollection.prototype.onModelLineChanged = function (versionId, lineNumber, newText) {\n        if (versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return [false, null, null, null];\n        }\n        var lineIndex = lineNumber - 1;\n        var oldOutputLineCount = this.lines[lineIndex].getViewLineCount();\n        var isVisible = this.lines[lineIndex].isVisible();\n        var line = createSplitLine(this.linePositionMapperFactory, newText, this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, isVisible);\n        this.lines[lineIndex] = line;\n        var newOutputLineCount = this.lines[lineIndex].getViewLineCount();\n        var lineMappingChanged = false;\n        var changeFrom = 0;\n        var changeTo = -1;\n        var insertFrom = 0;\n        var insertTo = -1;\n        var deleteFrom = 0;\n        var deleteTo = -1;\n        if (oldOutputLineCount > newOutputLineCount) {\n            changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\n            changeTo = changeFrom + newOutputLineCount - 1;\n            deleteFrom = changeTo + 1;\n            deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else if (oldOutputLineCount < newOutputLineCount) {\n            changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\n            changeTo = changeFrom + oldOutputLineCount - 1;\n            insertFrom = changeTo + 1;\n            insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else {\n            changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\n            changeTo = changeFrom + newOutputLineCount - 1;\n        }\n        this.prefixSumComputer.changeValue(lineIndex, newOutputLineCount);\n        var viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo) : null);\n        var viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n        var viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n        return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n    };\n    SplitLinesCollection.prototype.acceptVersionId = function (versionId) {\n        this._validModelVersionId = versionId;\n        if (this.lines.length === 1 && !this.lines[0].isVisible()) {\n            // At least one line must be visible => reset hidden areas\n            this.setHiddenAreas([]);\n        }\n    };\n    SplitLinesCollection.prototype.getViewLineCount = function () {\n        this._ensureValidState();\n        return this.prefixSumComputer.getTotalValue();\n    };\n    SplitLinesCollection.prototype._toValidViewLineNumber = function (viewLineNumber) {\n        if (viewLineNumber < 1) {\n            return 1;\n        }\n        var viewLineCount = this.getViewLineCount();\n        if (viewLineNumber > viewLineCount) {\n            return viewLineCount;\n        }\n        return viewLineNumber;\n    };\n    /**\n     * Gives a hint that a lot of requests are about to come in for these line numbers.\n     */\n    SplitLinesCollection.prototype.warmUpLookupCache = function (viewStartLineNumber, viewEndLineNumber) {\n        this.prefixSumComputer.warmUpCache(viewStartLineNumber - 1, viewEndLineNumber - 1);\n    };\n    SplitLinesCollection.prototype.getActiveIndentGuide = function (viewLineNumber, minLineNumber, maxLineNumber) {\n        this._ensureValidState();\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        minLineNumber = this._toValidViewLineNumber(minLineNumber);\n        maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n        var modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n        var modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n        var modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n        var result = this.model.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n        var viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n        var viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n        return {\n            startLineNumber: viewStartPosition.lineNumber,\n            endLineNumber: viewEndPosition.lineNumber,\n            indent: result.indent\n        };\n    };\n    SplitLinesCollection.prototype.getViewLinesIndentGuides = function (viewStartLineNumber, viewEndLineNumber) {\n        this._ensureValidState();\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        var modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n        var modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n        var result = [];\n        var resultRepeatCount = [];\n        var resultRepeatOption = [];\n        var modelStartLineIndex = modelStart.lineNumber - 1;\n        var modelEndLineIndex = modelEnd.lineNumber - 1;\n        var reqStart = null;\n        for (var modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            var line = this.lines[modelLineIndex];\n            if (line.isVisible()) {\n                var viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                var viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n                var count = viewLineEndIndex - viewLineStartIndex + 1;\n                var option = IndentGuideRepeatOption.BlockNone;\n                if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n                    // wrapped lines should block indent guides\n                    option = (viewLineStartIndex === 0 ? IndentGuideRepeatOption.BlockSubsequent : IndentGuideRepeatOption.BlockAll);\n                }\n                resultRepeatCount.push(count);\n                resultRepeatOption.push(option);\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new position_1.Position(modelLineIndex + 1, 0);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n            reqStart = null;\n        }\n        var viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        var viewIndents = new Array(viewLineCount);\n        var currIndex = 0;\n        for (var i = 0, len = result.length; i < len; i++) {\n            var value = result[i];\n            var count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n            var option = resultRepeatOption[i];\n            var blockAtIndex = void 0;\n            if (option === IndentGuideRepeatOption.BlockAll) {\n                blockAtIndex = 0;\n            }\n            else if (option === IndentGuideRepeatOption.BlockSubsequent) {\n                blockAtIndex = 1;\n            }\n            else {\n                blockAtIndex = count;\n            }\n            for (var j = 0; j < count; j++) {\n                if (j === blockAtIndex) {\n                    value = 0;\n                }\n                viewIndents[currIndex++] = value;\n            }\n        }\n        return viewIndents;\n    };\n    SplitLinesCollection.prototype.getViewLineContent = function (viewLineNumber) {\n        this._ensureValidState();\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        var lineIndex = r.index;\n        var remainder = r.remainder;\n        return this.lines[lineIndex].getViewLineContent(this.model, lineIndex + 1, remainder);\n    };\n    SplitLinesCollection.prototype.getViewLineLength = function (viewLineNumber) {\n        this._ensureValidState();\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        var lineIndex = r.index;\n        var remainder = r.remainder;\n        return this.lines[lineIndex].getViewLineLength(this.model, lineIndex + 1, remainder);\n    };\n    SplitLinesCollection.prototype.getViewLineMinColumn = function (viewLineNumber) {\n        this._ensureValidState();\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        var lineIndex = r.index;\n        var remainder = r.remainder;\n        return this.lines[lineIndex].getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n    };\n    SplitLinesCollection.prototype.getViewLineMaxColumn = function (viewLineNumber) {\n        this._ensureValidState();\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        var lineIndex = r.index;\n        var remainder = r.remainder;\n        return this.lines[lineIndex].getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n    };\n    SplitLinesCollection.prototype.getViewLineData = function (viewLineNumber) {\n        this._ensureValidState();\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        var lineIndex = r.index;\n        var remainder = r.remainder;\n        return this.lines[lineIndex].getViewLineData(this.model, lineIndex + 1, remainder);\n    };\n    SplitLinesCollection.prototype.getViewLinesData = function (viewStartLineNumber, viewEndLineNumber, needed) {\n        this._ensureValidState();\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        var start = this.prefixSumComputer.getIndexOf(viewStartLineNumber - 1);\n        var viewLineNumber = viewStartLineNumber;\n        var startModelLineIndex = start.index;\n        var startRemainder = start.remainder;\n        var result = [];\n        for (var modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n            var line = this.lines[modelLineIndex];\n            if (!line.isVisible()) {\n                continue;\n            }\n            var fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n            var remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n            var lastLine = false;\n            if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n                lastLine = true;\n                remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n            }\n            var toViewLineIndex = fromViewLineIndex + remainingViewLineCount;\n            line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, toViewLineIndex, viewLineNumber - viewStartLineNumber, needed, result);\n            viewLineNumber += remainingViewLineCount;\n            if (lastLine) {\n                break;\n            }\n        }\n        return result;\n    };\n    SplitLinesCollection.prototype.validateViewPosition = function (viewLineNumber, viewColumn, expectedModelPosition) {\n        this._ensureValidState();\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        var lineIndex = r.index;\n        var remainder = r.remainder;\n        var line = this.lines[lineIndex];\n        var minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n        var maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n        if (viewColumn < minColumn) {\n            viewColumn = minColumn;\n        }\n        if (viewColumn > maxColumn) {\n            viewColumn = maxColumn;\n        }\n        var computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n        var computedModelPosition = this.model.validatePosition(new position_1.Position(lineIndex + 1, computedModelColumn));\n        if (computedModelPosition.equals(expectedModelPosition)) {\n            return new position_1.Position(viewLineNumber, viewColumn);\n        }\n        return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n    };\n    SplitLinesCollection.prototype.convertViewPositionToModelPosition = function (viewLineNumber, viewColumn) {\n        this._ensureValidState();\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n        var lineIndex = r.index;\n        var remainder = r.remainder;\n        var inputColumn = this.lines[lineIndex].getModelColumnOfViewPosition(remainder, viewColumn);\n        // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n        return this.model.validatePosition(new position_1.Position(lineIndex + 1, inputColumn));\n    };\n    SplitLinesCollection.prototype.convertModelPositionToViewPosition = function (_modelLineNumber, _modelColumn) {\n        this._ensureValidState();\n        var validPosition = this.model.validatePosition(new position_1.Position(_modelLineNumber, _modelColumn));\n        var inputLineNumber = validPosition.lineNumber;\n        var inputColumn = validPosition.column;\n        var lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n        while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\n            lineIndex--;\n            lineIndexChanged = true;\n        }\n        if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\n            // Could not reach a real line\n            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n            return new position_1.Position(1, 1);\n        }\n        var deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n        var r;\n        if (lineIndexChanged) {\n            r = this.lines[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n        }\n        else {\n            r = this.lines[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn);\n        }\n        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n        return r;\n    };\n    SplitLinesCollection.prototype._getViewLineNumberForModelPosition = function (inputLineNumber, inputColumn) {\n        var lineIndex = inputLineNumber - 1;\n        if (this.lines[lineIndex].isVisible()) {\n            // this model line is visible\n            var deltaLineNumber_1 = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n            return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber_1, inputColumn);\n        }\n        // this model line is not visible\n        while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\n            lineIndex--;\n        }\n        if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\n            // Could not reach a real line\n            return 1;\n        }\n        var deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n        return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n    };\n    SplitLinesCollection.prototype.getAllOverviewRulerDecorations = function (ownerId, filterOutValidation, theme) {\n        var decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);\n        var result = new OverviewRulerDecorations();\n        for (var _i = 0, decorations_1 = decorations; _i < decorations_1.length; _i++) {\n            var decoration = decorations_1[_i];\n            var opts = decoration.options.overviewRuler;\n            var lane = opts ? opts.position : 0;\n            if (lane === 0) {\n                continue;\n            }\n            var color = opts.getColor(theme);\n            var viewStartLineNumber = this._getViewLineNumberForModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n            var viewEndLineNumber = this._getViewLineNumberForModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n            result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n        return result.result;\n    };\n    SplitLinesCollection.prototype.getDecorationsInRange = function (range, ownerId, filterOutValidation) {\n        var modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n        var modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n        if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n            // most likely there are no hidden lines => fast path\n            // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n            return this.model.getDecorationsInRange(new range_1.Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);\n        }\n        var result = [];\n        var modelStartLineIndex = modelStart.lineNumber - 1;\n        var modelEndLineIndex = modelEnd.lineNumber - 1;\n        var reqStart = null;\n        for (var modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            var line = this.lines[modelLineIndex];\n            if (line.isVisible()) {\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new position_1.Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    var maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n                    result = result.concat(this.model.getDecorationsInRange(new range_1.Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.getDecorationsInRange(new range_1.Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));\n            reqStart = null;\n        }\n        result.sort(function (a, b) {\n            var res = range_1.Range.compareRangesUsingStarts(a.range, b.range);\n            if (res === 0) {\n                if (a.id < b.id) {\n                    return -1;\n                }\n                if (a.id > b.id) {\n                    return 1;\n                }\n                return 0;\n            }\n            return res;\n        });\n        // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n        var finalResult = [], finalResultLen = 0;\n        var prevDecId = null;\n        for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {\n            var dec = result_1[_i];\n            var decId = dec.id;\n            if (prevDecId === decId) {\n                // skip\n                continue;\n            }\n            prevDecId = decId;\n            finalResult[finalResultLen++] = dec;\n        }\n        return finalResult;\n    };\n    return SplitLinesCollection;\n}());\nexports.SplitLinesCollection = SplitLinesCollection;\nvar VisibleIdentitySplitLine = /** @class */ (function () {\n    function VisibleIdentitySplitLine() {\n    }\n    VisibleIdentitySplitLine.prototype.isVisible = function () {\n        return true;\n    };\n    VisibleIdentitySplitLine.prototype.setVisible = function (isVisible) {\n        if (isVisible) {\n            return this;\n        }\n        return InvisibleIdentitySplitLine.INSTANCE;\n    };\n    VisibleIdentitySplitLine.prototype.getViewLineCount = function () {\n        return 1;\n    };\n    VisibleIdentitySplitLine.prototype.getViewLineContent = function (model, modelLineNumber, _outputLineIndex) {\n        return model.getLineContent(modelLineNumber);\n    };\n    VisibleIdentitySplitLine.prototype.getViewLineLength = function (model, modelLineNumber, _outputLineIndex) {\n        return model.getLineLength(modelLineNumber);\n    };\n    VisibleIdentitySplitLine.prototype.getViewLineMinColumn = function (model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMinColumn(modelLineNumber);\n    };\n    VisibleIdentitySplitLine.prototype.getViewLineMaxColumn = function (model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMaxColumn(modelLineNumber);\n    };\n    VisibleIdentitySplitLine.prototype.getViewLineData = function (model, modelLineNumber, _outputLineIndex) {\n        var lineTokens = model.getLineTokens(modelLineNumber);\n        var lineContent = lineTokens.getLineContent();\n        return new viewModel_1.ViewLineData(lineContent, false, 1, lineContent.length + 1, lineTokens.inflate());\n    };\n    VisibleIdentitySplitLine.prototype.getViewLinesData = function (model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n        if (!needed[globalStartIndex]) {\n            result[globalStartIndex] = null;\n            return;\n        }\n        result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n    };\n    VisibleIdentitySplitLine.prototype.getModelColumnOfViewPosition = function (_outputLineIndex, outputColumn) {\n        return outputColumn;\n    };\n    VisibleIdentitySplitLine.prototype.getViewPositionOfModelPosition = function (deltaLineNumber, inputColumn) {\n        return new position_1.Position(deltaLineNumber, inputColumn);\n    };\n    VisibleIdentitySplitLine.prototype.getViewLineNumberOfModelPosition = function (deltaLineNumber, _inputColumn) {\n        return deltaLineNumber;\n    };\n    VisibleIdentitySplitLine.INSTANCE = new VisibleIdentitySplitLine();\n    return VisibleIdentitySplitLine;\n}());\nvar InvisibleIdentitySplitLine = /** @class */ (function () {\n    function InvisibleIdentitySplitLine() {\n    }\n    InvisibleIdentitySplitLine.prototype.isVisible = function () {\n        return false;\n    };\n    InvisibleIdentitySplitLine.prototype.setVisible = function (isVisible) {\n        if (!isVisible) {\n            return this;\n        }\n        return VisibleIdentitySplitLine.INSTANCE;\n    };\n    InvisibleIdentitySplitLine.prototype.getViewLineCount = function () {\n        return 0;\n    };\n    InvisibleIdentitySplitLine.prototype.getViewLineContent = function (_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    };\n    InvisibleIdentitySplitLine.prototype.getViewLineLength = function (_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    };\n    InvisibleIdentitySplitLine.prototype.getViewLineMinColumn = function (_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    };\n    InvisibleIdentitySplitLine.prototype.getViewLineMaxColumn = function (_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    };\n    InvisibleIdentitySplitLine.prototype.getViewLineData = function (_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    };\n    InvisibleIdentitySplitLine.prototype.getViewLinesData = function (_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n        throw new Error('Not supported');\n    };\n    InvisibleIdentitySplitLine.prototype.getModelColumnOfViewPosition = function (_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    };\n    InvisibleIdentitySplitLine.prototype.getViewPositionOfModelPosition = function (_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    };\n    InvisibleIdentitySplitLine.prototype.getViewLineNumberOfModelPosition = function (_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    };\n    InvisibleIdentitySplitLine.INSTANCE = new InvisibleIdentitySplitLine();\n    return InvisibleIdentitySplitLine;\n}());\nvar SplitLine = /** @class */ (function () {\n    function SplitLine(positionMapper, isVisible) {\n        this.positionMapper = positionMapper;\n        this.wrappedIndent = this.positionMapper.getWrappedLinesIndent();\n        this.wrappedIndentLength = this.wrappedIndent.length;\n        this.outputLineCount = this.positionMapper.getOutputLineCount();\n        this._isVisible = isVisible;\n    }\n    SplitLine.prototype.isVisible = function () {\n        return this._isVisible;\n    };\n    SplitLine.prototype.setVisible = function (isVisible) {\n        this._isVisible = isVisible;\n        return this;\n    };\n    SplitLine.prototype.getViewLineCount = function () {\n        if (!this._isVisible) {\n            return 0;\n        }\n        return this.outputLineCount;\n    };\n    SplitLine.prototype.getInputStartOffsetOfOutputLineIndex = function (outputLineIndex) {\n        return this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex, 0);\n    };\n    SplitLine.prototype.getInputEndOffsetOfOutputLineIndex = function (model, modelLineNumber, outputLineIndex) {\n        if (outputLineIndex + 1 === this.outputLineCount) {\n            return model.getLineMaxColumn(modelLineNumber) - 1;\n        }\n        return this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex + 1, 0);\n    };\n    SplitLine.prototype.getViewLineContent = function (model, modelLineNumber, outputLineIndex) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        var startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n        var endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n        var r = model.getValueInRange({\n            startLineNumber: modelLineNumber,\n            startColumn: startOffset + 1,\n            endLineNumber: modelLineNumber,\n            endColumn: endOffset + 1\n        });\n        if (outputLineIndex > 0) {\n            r = this.wrappedIndent + r;\n        }\n        return r;\n    };\n    SplitLine.prototype.getViewLineLength = function (model, modelLineNumber, outputLineIndex) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        var startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n        var endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n        var r = endOffset - startOffset;\n        if (outputLineIndex > 0) {\n            r = this.wrappedIndent.length + r;\n        }\n        return r;\n    };\n    SplitLine.prototype.getViewLineMinColumn = function (_model, _modelLineNumber, outputLineIndex) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        if (outputLineIndex > 0) {\n            return this.wrappedIndentLength + 1;\n        }\n        return 1;\n    };\n    SplitLine.prototype.getViewLineMaxColumn = function (model, modelLineNumber, outputLineIndex) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        return this.getViewLineContent(model, modelLineNumber, outputLineIndex).length + 1;\n    };\n    SplitLine.prototype.getViewLineData = function (model, modelLineNumber, outputLineIndex) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        var startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n        var endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n        var lineContent = model.getValueInRange({\n            startLineNumber: modelLineNumber,\n            startColumn: startOffset + 1,\n            endLineNumber: modelLineNumber,\n            endColumn: endOffset + 1\n        });\n        if (outputLineIndex > 0) {\n            lineContent = this.wrappedIndent + lineContent;\n        }\n        var minColumn = (outputLineIndex > 0 ? this.wrappedIndentLength + 1 : 1);\n        var maxColumn = lineContent.length + 1;\n        var continuesWithWrappedLine = (outputLineIndex + 1 < this.getViewLineCount());\n        var deltaStartIndex = 0;\n        if (outputLineIndex > 0) {\n            deltaStartIndex = this.wrappedIndentLength;\n        }\n        var lineTokens = model.getLineTokens(modelLineNumber);\n        return new viewModel_1.ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, lineTokens.sliceAndInflate(startOffset, endOffset, deltaStartIndex));\n    };\n    SplitLine.prototype.getViewLinesData = function (model, modelLineNumber, fromOuputLineIndex, toOutputLineIndex, globalStartIndex, needed, result) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        for (var outputLineIndex = fromOuputLineIndex; outputLineIndex < toOutputLineIndex; outputLineIndex++) {\n            var globalIndex = globalStartIndex + outputLineIndex - fromOuputLineIndex;\n            if (!needed[globalIndex]) {\n                result[globalIndex] = null;\n                continue;\n            }\n            result[globalIndex] = this.getViewLineData(model, modelLineNumber, outputLineIndex);\n        }\n    };\n    SplitLine.prototype.getModelColumnOfViewPosition = function (outputLineIndex, outputColumn) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        var adjustedColumn = outputColumn - 1;\n        if (outputLineIndex > 0) {\n            if (adjustedColumn < this.wrappedIndentLength) {\n                adjustedColumn = 0;\n            }\n            else {\n                adjustedColumn -= this.wrappedIndentLength;\n            }\n        }\n        return this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex, adjustedColumn) + 1;\n    };\n    SplitLine.prototype.getViewPositionOfModelPosition = function (deltaLineNumber, inputColumn) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        var r = this.positionMapper.getOutputPositionOfInputOffset(inputColumn - 1);\n        var outputLineIndex = r.outputLineIndex;\n        var outputColumn = r.outputOffset + 1;\n        if (outputLineIndex > 0) {\n            outputColumn += this.wrappedIndentLength;\n        }\n        //\t\tconsole.log('in -> out ' + deltaLineNumber + ',' + inputColumn + ' ===> ' + (deltaLineNumber+outputLineIndex) + ',' + outputColumn);\n        return new position_1.Position(deltaLineNumber + outputLineIndex, outputColumn);\n    };\n    SplitLine.prototype.getViewLineNumberOfModelPosition = function (deltaLineNumber, inputColumn) {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n        var r = this.positionMapper.getOutputPositionOfInputOffset(inputColumn - 1);\n        return (deltaLineNumber + r.outputLineIndex);\n    };\n    return SplitLine;\n}());\nexports.SplitLine = SplitLine;\nfunction createSplitLine(linePositionMapperFactory, text, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, isVisible) {\n    var positionMapper = linePositionMapperFactory.createLineMapping(text, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n    if (positionMapper === null) {\n        // No mapping needed\n        if (isVisible) {\n            return VisibleIdentitySplitLine.INSTANCE;\n        }\n        return InvisibleIdentitySplitLine.INSTANCE;\n    }\n    else {\n        return new SplitLine(positionMapper, isVisible);\n    }\n}\nvar IdentityCoordinatesConverter = /** @class */ (function () {\n    function IdentityCoordinatesConverter(lines) {\n        this._lines = lines;\n    }\n    IdentityCoordinatesConverter.prototype._validPosition = function (pos) {\n        return this._lines.model.validatePosition(pos);\n    };\n    IdentityCoordinatesConverter.prototype._validRange = function (range) {\n        return this._lines.model.validateRange(range);\n    };\n    // View -> Model conversion and related methods\n    IdentityCoordinatesConverter.prototype.convertViewPositionToModelPosition = function (viewPosition) {\n        return this._validPosition(viewPosition);\n    };\n    IdentityCoordinatesConverter.prototype.convertViewRangeToModelRange = function (viewRange) {\n        return this._validRange(viewRange);\n    };\n    IdentityCoordinatesConverter.prototype.validateViewPosition = function (_viewPosition, expectedModelPosition) {\n        return this._validPosition(expectedModelPosition);\n    };\n    IdentityCoordinatesConverter.prototype.validateViewRange = function (_viewRange, expectedModelRange) {\n        return this._validRange(expectedModelRange);\n    };\n    // Model -> View conversion and related methods\n    IdentityCoordinatesConverter.prototype.convertModelPositionToViewPosition = function (modelPosition) {\n        return this._validPosition(modelPosition);\n    };\n    IdentityCoordinatesConverter.prototype.convertModelRangeToViewRange = function (modelRange) {\n        return this._validRange(modelRange);\n    };\n    IdentityCoordinatesConverter.prototype.modelPositionIsVisible = function (modelPosition) {\n        var lineCount = this._lines.model.getLineCount();\n        if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n            // invalid arguments\n            return false;\n        }\n        return true;\n    };\n    return IdentityCoordinatesConverter;\n}());\nexports.IdentityCoordinatesConverter = IdentityCoordinatesConverter;\nvar IdentityLinesCollection = /** @class */ (function () {\n    function IdentityLinesCollection(model) {\n        this.model = model;\n    }\n    IdentityLinesCollection.prototype.dispose = function () {\n    };\n    IdentityLinesCollection.prototype.createCoordinatesConverter = function () {\n        return new IdentityCoordinatesConverter(this);\n    };\n    IdentityLinesCollection.prototype.getHiddenAreas = function () {\n        return [];\n    };\n    IdentityLinesCollection.prototype.setHiddenAreas = function (_ranges) {\n        return false;\n    };\n    IdentityLinesCollection.prototype.setTabSize = function (_newTabSize) {\n        return false;\n    };\n    IdentityLinesCollection.prototype.setWrappingSettings = function (_wrappingIndent, _wrappingColumn, _columnsForFullWidthChar) {\n        return false;\n    };\n    IdentityLinesCollection.prototype.onModelFlushed = function () {\n    };\n    IdentityLinesCollection.prototype.onModelLinesDeleted = function (_versionId, fromLineNumber, toLineNumber) {\n        return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n    };\n    IdentityLinesCollection.prototype.onModelLinesInserted = function (_versionId, fromLineNumber, toLineNumber, _text) {\n        return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n    };\n    IdentityLinesCollection.prototype.onModelLineChanged = function (_versionId, lineNumber, _newText) {\n        return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, lineNumber), null, null];\n    };\n    IdentityLinesCollection.prototype.acceptVersionId = function (_versionId) {\n    };\n    IdentityLinesCollection.prototype.getViewLineCount = function () {\n        return this.model.getLineCount();\n    };\n    IdentityLinesCollection.prototype.warmUpLookupCache = function (_viewStartLineNumber, _viewEndLineNumber) {\n    };\n    IdentityLinesCollection.prototype.getActiveIndentGuide = function (viewLineNumber, _minLineNumber, _maxLineNumber) {\n        return {\n            startLineNumber: viewLineNumber,\n            endLineNumber: viewLineNumber,\n            indent: 0\n        };\n    };\n    IdentityLinesCollection.prototype.getViewLinesIndentGuides = function (viewStartLineNumber, viewEndLineNumber) {\n        var viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        var result = new Array(viewLineCount);\n        for (var i = 0; i < viewLineCount; i++) {\n            result[i] = 0;\n        }\n        return result;\n    };\n    IdentityLinesCollection.prototype.getViewLineContent = function (viewLineNumber) {\n        return this.model.getLineContent(viewLineNumber);\n    };\n    IdentityLinesCollection.prototype.getViewLineLength = function (viewLineNumber) {\n        return this.model.getLineLength(viewLineNumber);\n    };\n    IdentityLinesCollection.prototype.getViewLineMinColumn = function (viewLineNumber) {\n        return this.model.getLineMinColumn(viewLineNumber);\n    };\n    IdentityLinesCollection.prototype.getViewLineMaxColumn = function (viewLineNumber) {\n        return this.model.getLineMaxColumn(viewLineNumber);\n    };\n    IdentityLinesCollection.prototype.getViewLineData = function (viewLineNumber) {\n        var lineTokens = this.model.getLineTokens(viewLineNumber);\n        var lineContent = lineTokens.getLineContent();\n        return new viewModel_1.ViewLineData(lineContent, false, 1, lineContent.length + 1, lineTokens.inflate());\n    };\n    IdentityLinesCollection.prototype.getViewLinesData = function (viewStartLineNumber, viewEndLineNumber, needed) {\n        var lineCount = this.model.getLineCount();\n        viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n        viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n        var result = [];\n        for (var lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n            var idx = lineNumber - viewStartLineNumber;\n            if (!needed[idx]) {\n                result[idx] = null;\n            }\n            result[idx] = this.getViewLineData(lineNumber);\n        }\n        return result;\n    };\n    IdentityLinesCollection.prototype.getAllOverviewRulerDecorations = function (ownerId, filterOutValidation, theme) {\n        var decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);\n        var result = new OverviewRulerDecorations();\n        for (var _i = 0, decorations_2 = decorations; _i < decorations_2.length; _i++) {\n            var decoration = decorations_2[_i];\n            var opts = decoration.options.overviewRuler;\n            var lane = opts ? opts.position : 0;\n            if (lane === 0) {\n                continue;\n            }\n            var color = opts.getColor(theme);\n            var viewStartLineNumber = decoration.range.startLineNumber;\n            var viewEndLineNumber = decoration.range.endLineNumber;\n            result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n        return result.result;\n    };\n    IdentityLinesCollection.prototype.getDecorationsInRange = function (range, ownerId, filterOutValidation) {\n        return this.model.getDecorationsInRange(range, ownerId, filterOutValidation);\n    };\n    return IdentityLinesCollection;\n}());\nexports.IdentityLinesCollection = IdentityLinesCollection;\nvar OverviewRulerDecorations = /** @class */ (function () {\n    function OverviewRulerDecorations() {\n        this.result = Object.create(null);\n    }\n    OverviewRulerDecorations.prototype.accept = function (color, startLineNumber, endLineNumber, lane) {\n        var prev = this.result[color];\n        if (prev) {\n            var prevLane = prev[prev.length - 3];\n            var prevEndLineNumber = prev[prev.length - 1];\n            if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n                // merge into prev\n                if (endLineNumber > prevEndLineNumber) {\n                    prev[prev.length - 1] = endLineNumber;\n                }\n                return;\n            }\n            // push\n            prev.push(lane, startLineNumber, endLineNumber);\n        }\n        else {\n            this.result[color] = [lane, startLineNumber, endLineNumber];\n        }\n    };\n    return OverviewRulerDecorations;\n}());\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewModel/splitLinesCollection.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/viewModel/splitLinesCollection.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { WrappingIndent } from 'vs/editor/common/config/editorOptions';\nimport { LineTokens } from 'vs/editor/common/core/lineTokens';\nimport { Position } from 'vs/editor/common/core/position';\nimport { IRange, Range } from 'vs/editor/common/core/range';\nimport { EndOfLinePreference, IActiveIndentGuideInfo, IModelDecoration, IModelDeltaDecoration, ITextModel } from 'vs/editor/common/model';\nimport { ModelDecorationOptions, ModelDecorationOverviewRulerOptions } from 'vs/editor/common/model/textModel';\nimport * as viewEvents from 'vs/editor/common/view/viewEvents';\nimport { PrefixSumComputerWithCache } from 'vs/editor/common/viewModel/prefixSumComputer';\nimport { ICoordinatesConverter, IOverviewRulerDecorations, ViewLineData } from 'vs/editor/common/viewModel/viewModel';\nimport { ITheme } from 'vs/platform/theme/common/themeService';\n\nexport class OutputPosition {\n\t_outputPositionBrand: void;\n\toutputLineIndex: number;\n\toutputOffset: number;\n\n\tconstructor(outputLineIndex: number, outputOffset: number) {\n\t\tthis.outputLineIndex = outputLineIndex;\n\t\tthis.outputOffset = outputOffset;\n\t}\n}\n\nexport interface ILineMapping {\n\tgetOutputLineCount(): number;\n\tgetWrappedLinesIndent(): string;\n\tgetInputOffsetOfOutputPosition(outputLineIndex: number, outputOffset: number): number;\n\tgetOutputPositionOfInputOffset(inputOffset: number): OutputPosition;\n}\n\nexport interface ILineMapperFactory {\n\tcreateLineMapping(lineText: string, tabSize: number, wrappingColumn: number, columnsForFullWidthChar: number, wrappingIndent: WrappingIndent): ILineMapping | null;\n}\n\nexport interface ISimpleModel {\n\tgetLineTokens(lineNumber: number): LineTokens;\n\tgetLineContent(lineNumber: number): string;\n\tgetLineLength(lineNumber: number): number;\n\tgetLineMinColumn(lineNumber: number): number;\n\tgetLineMaxColumn(lineNumber: number): number;\n\tgetValueInRange(range: IRange, eol?: EndOfLinePreference): string;\n}\n\nexport interface ISplitLine {\n\tisVisible(): boolean;\n\tsetVisible(isVisible: boolean): ISplitLine;\n\n\tgetViewLineCount(): number;\n\tgetViewLineContent(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): string;\n\tgetViewLineLength(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): number;\n\tgetViewLineMinColumn(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): number;\n\tgetViewLineMaxColumn(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): number;\n\tgetViewLineData(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): ViewLineData;\n\tgetViewLinesData(model: ISimpleModel, modelLineNumber: number, fromOuputLineIndex: number, toOutputLineIndex: number, globalStartIndex: number, needed: boolean[], result: Array<ViewLineData | null>): void;\n\n\tgetModelColumnOfViewPosition(outputLineIndex: number, outputColumn: number): number;\n\tgetViewPositionOfModelPosition(deltaLineNumber: number, inputColumn: number): Position;\n\tgetViewLineNumberOfModelPosition(deltaLineNumber: number, inputColumn: number): number;\n}\n\nexport interface IViewModelLinesCollection {\n\tcreateCoordinatesConverter(): ICoordinatesConverter;\n\n\tdispose(): void;\n\n\tsetWrappingSettings(wrappingIndent: WrappingIndent, wrappingColumn: number, columnsForFullWidthChar: number): boolean;\n\tsetTabSize(newTabSize: number): boolean;\n\tgetHiddenAreas(): Range[];\n\tsetHiddenAreas(_ranges: Range[]): boolean;\n\n\tonModelFlushed(): void;\n\tonModelLinesDeleted(versionId: number, fromLineNumber: number, toLineNumber: number): viewEvents.ViewLinesDeletedEvent | null;\n\tonModelLinesInserted(versionId: number, fromLineNumber: number, toLineNumber: number, text: string[]): viewEvents.ViewLinesInsertedEvent | null;\n\tonModelLineChanged(versionId: number, lineNumber: number, newText: string): [boolean, viewEvents.ViewLinesChangedEvent | null, viewEvents.ViewLinesInsertedEvent | null, viewEvents.ViewLinesDeletedEvent | null];\n\tacceptVersionId(versionId: number): void;\n\n\tgetViewLineCount(): number;\n\twarmUpLookupCache(viewStartLineNumber: number, viewEndLineNumber: number): void;\n\tgetActiveIndentGuide(viewLineNumber: number, minLineNumber: number, maxLineNumber: number): IActiveIndentGuideInfo;\n\tgetViewLinesIndentGuides(viewStartLineNumber: number, viewEndLineNumber: number): number[];\n\tgetViewLineContent(viewLineNumber: number): string;\n\tgetViewLineLength(viewLineNumber: number): number;\n\tgetViewLineMinColumn(viewLineNumber: number): number;\n\tgetViewLineMaxColumn(viewLineNumber: number): number;\n\tgetViewLineData(viewLineNumber: number): ViewLineData;\n\tgetViewLinesData(viewStartLineNumber: number, viewEndLineNumber: number, needed: boolean[]): Array<ViewLineData | null>;\n\n\tgetAllOverviewRulerDecorations(ownerId: number, filterOutValidation: boolean, theme: ITheme): IOverviewRulerDecorations;\n\tgetDecorationsInRange(range: Range, ownerId: number, filterOutValidation: boolean): IModelDecoration[];\n}\n\nexport class CoordinatesConverter implements ICoordinatesConverter {\n\n\tprivate readonly _lines: SplitLinesCollection;\n\n\tconstructor(lines: SplitLinesCollection) {\n\t\tthis._lines = lines;\n\t}\n\n\t// View -> Model conversion and related methods\n\n\tpublic convertViewPositionToModelPosition(viewPosition: Position): Position {\n\t\treturn this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n\t}\n\n\tpublic convertViewRangeToModelRange(viewRange: Range): Range {\n\t\tlet start = this._lines.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n\t\tlet end = this._lines.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n\t\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n\t}\n\n\tpublic validateViewPosition(viewPosition: Position, expectedModelPosition: Position): Position {\n\t\treturn this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n\t}\n\n\tpublic validateViewRange(viewRange: Range, expectedModelRange: Range): Range {\n\t\tconst validViewStart = this._lines.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n\t\tconst validViewEnd = this._lines.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n\t\treturn new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n\t}\n\n\t// Model -> View conversion and related methods\n\n\tpublic convertModelPositionToViewPosition(modelPosition: Position): Position {\n\t\treturn this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);\n\t}\n\n\tpublic convertModelRangeToViewRange(modelRange: Range): Range {\n\t\tlet start = this._lines.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn);\n\t\tlet end = this._lines.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn);\n\t\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n\t}\n\n\tpublic modelPositionIsVisible(modelPosition: Position): boolean {\n\t\treturn this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n\t}\n\n}\n\nconst enum IndentGuideRepeatOption {\n\tBlockNone = 0,\n\tBlockSubsequent = 1,\n\tBlockAll = 2\n}\n\nexport class SplitLinesCollection implements IViewModelLinesCollection {\n\n\tprivate readonly model: ITextModel;\n\tprivate _validModelVersionId: number;\n\n\tprivate wrappingColumn: number;\n\tprivate columnsForFullWidthChar: number;\n\tprivate wrappingIndent: WrappingIndent;\n\tprivate tabSize: number;\n\tprivate lines: ISplitLine[];\n\n\tprivate prefixSumComputer: PrefixSumComputerWithCache;\n\n\tprivate readonly linePositionMapperFactory: ILineMapperFactory;\n\n\tprivate hiddenAreasIds: string[];\n\n\tconstructor(model: ITextModel, linePositionMapperFactory: ILineMapperFactory, tabSize: number, wrappingColumn: number, columnsForFullWidthChar: number, wrappingIndent: WrappingIndent) {\n\t\tthis.model = model;\n\t\tthis._validModelVersionId = -1;\n\t\tthis.tabSize = tabSize;\n\t\tthis.wrappingColumn = wrappingColumn;\n\t\tthis.columnsForFullWidthChar = columnsForFullWidthChar;\n\t\tthis.wrappingIndent = wrappingIndent;\n\t\tthis.linePositionMapperFactory = linePositionMapperFactory;\n\n\t\tthis._constructLines(true);\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, []);\n\t}\n\n\tpublic createCoordinatesConverter(): ICoordinatesConverter {\n\t\treturn new CoordinatesConverter(this);\n\t}\n\n\tprivate _ensureValidState(): void {\n\t\tlet modelVersion = this.model.getVersionId();\n\t\tif (modelVersion !== this._validModelVersionId) {\n\t\t\t// This is pretty bad, it means we lost track of the model...\n\t\t\tthrow new Error(`ViewModel is out of sync with Model!`);\n\t\t}\n\t\tif (this.lines.length !== this.model.getLineCount()) {\n\t\t\t// This is pretty bad, it means we lost track of the model...\n\t\t\tthis._constructLines(false);\n\t\t}\n\t}\n\n\tprivate _constructLines(resetHiddenAreas: boolean): void {\n\t\tthis.lines = [];\n\n\t\tif (resetHiddenAreas) {\n\t\t\tthis.hiddenAreasIds = [];\n\t\t}\n\n\t\tlet linesContent = this.model.getLinesContent();\n\t\tlet lineCount = linesContent.length;\n\t\tlet values = new Uint32Array(lineCount);\n\n\t\tlet hiddenAreas = this.hiddenAreasIds.map((areaId) => this.model.getDecorationRange(areaId)!).sort(Range.compareRangesUsingStarts);\n\t\tlet hiddenAreaStart = 1, hiddenAreaEnd = 0;\n\t\tlet hiddenAreaIdx = -1;\n\t\tlet nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n\n\t\tfor (let i = 0; i < lineCount; i++) {\n\t\t\tlet lineNumber = i + 1;\n\n\t\t\tif (lineNumber === nextLineNumberToUpdateHiddenArea) {\n\t\t\t\thiddenAreaIdx++;\n\t\t\t\thiddenAreaStart = hiddenAreas[hiddenAreaIdx]!.startLineNumber;\n\t\t\t\thiddenAreaEnd = hiddenAreas[hiddenAreaIdx]!.endLineNumber;\n\t\t\t\tnextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n\t\t\t}\n\n\t\t\tlet isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n\t\t\tlet line = createSplitLine(this.linePositionMapperFactory, linesContent[i], this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, !isInHiddenArea);\n\t\t\tvalues[i] = line.getViewLineCount();\n\t\t\tthis.lines[i] = line;\n\t\t}\n\n\t\tthis._validModelVersionId = this.model.getVersionId();\n\n\t\tthis.prefixSumComputer = new PrefixSumComputerWithCache(values);\n\t}\n\n\tpublic getHiddenAreas(): Range[] {\n\t\treturn this.hiddenAreasIds.map((decId) => {\n\t\t\treturn this.model.getDecorationRange(decId)!;\n\t\t});\n\t}\n\n\tprivate _reduceRanges(_ranges: Range[]): Range[] {\n\t\tif (_ranges.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\tlet ranges = _ranges.map(r => this.model.validateRange(r)).sort(Range.compareRangesUsingStarts);\n\n\t\tlet result: Range[] = [];\n\t\tlet currentRangeStart = ranges[0].startLineNumber;\n\t\tlet currentRangeEnd = ranges[0].endLineNumber;\n\n\t\tfor (let i = 1, len = ranges.length; i < len; i++) {\n\t\t\tlet range = ranges[i];\n\n\t\t\tif (range.startLineNumber > currentRangeEnd + 1) {\n\t\t\t\tresult.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n\t\t\t\tcurrentRangeStart = range.startLineNumber;\n\t\t\t\tcurrentRangeEnd = range.endLineNumber;\n\t\t\t} else if (range.endLineNumber > currentRangeEnd) {\n\t\t\t\tcurrentRangeEnd = range.endLineNumber;\n\t\t\t}\n\t\t}\n\t\tresult.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n\t\treturn result;\n\t}\n\n\tpublic setHiddenAreas(_ranges: Range[]): boolean {\n\n\t\tlet newRanges = this._reduceRanges(_ranges);\n\n\t\t// BEGIN TODO@Martin: Please stop calling this method on each model change!\n\t\tlet oldRanges = this.hiddenAreasIds.map((areaId) => this.model.getDecorationRange(areaId)!).sort(Range.compareRangesUsingStarts);\n\n\t\tif (newRanges.length === oldRanges.length) {\n\t\t\tlet hasDifference = false;\n\t\t\tfor (let i = 0; i < newRanges.length; i++) {\n\t\t\t\tif (!newRanges[i].equalsRange(oldRanges[i])) {\n\t\t\t\t\thasDifference = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!hasDifference) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t// END TODO@Martin: Please stop calling this method on each model change!\n\n\t\tlet newDecorations: IModelDeltaDecoration[] = [];\n\t\tfor (const newRange of newRanges) {\n\t\t\tnewDecorations.push({\n\t\t\t\trange: newRange,\n\t\t\t\toptions: ModelDecorationOptions.EMPTY\n\t\t\t});\n\t\t}\n\n\t\tthis.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, newDecorations);\n\n\t\tlet hiddenAreas = newRanges;\n\t\tlet hiddenAreaStart = 1, hiddenAreaEnd = 0;\n\t\tlet hiddenAreaIdx = -1;\n\t\tlet nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;\n\n\t\tlet hasVisibleLine = false;\n\t\tfor (let i = 0; i < this.lines.length; i++) {\n\t\t\tlet lineNumber = i + 1;\n\n\t\t\tif (lineNumber === nextLineNumberToUpdateHiddenArea) {\n\t\t\t\thiddenAreaIdx++;\n\t\t\t\thiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n\t\t\t\thiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n\t\t\t\tnextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;\n\t\t\t}\n\n\t\t\tlet lineChanged = false;\n\t\t\tif (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n\t\t\t\t// Line should be hidden\n\t\t\t\tif (this.lines[i].isVisible()) {\n\t\t\t\t\tthis.lines[i] = this.lines[i].setVisible(false);\n\t\t\t\t\tlineChanged = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thasVisibleLine = true;\n\t\t\t\t// Line should be visible\n\t\t\t\tif (!this.lines[i].isVisible()) {\n\t\t\t\t\tthis.lines[i] = this.lines[i].setVisible(true);\n\t\t\t\t\tlineChanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lineChanged) {\n\t\t\t\tlet newOutputLineCount = this.lines[i].getViewLineCount();\n\t\t\t\tthis.prefixSumComputer.changeValue(i, newOutputLineCount);\n\t\t\t}\n\t\t}\n\n\t\tif (!hasVisibleLine) {\n\t\t\t// Cannot have everything be hidden => reveal everything!\n\t\t\tthis.setHiddenAreas([]);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic modelPositionIsVisible(modelLineNumber: number, _modelColumn: number): boolean {\n\t\tif (modelLineNumber < 1 || modelLineNumber > this.lines.length) {\n\t\t\t// invalid arguments\n\t\t\treturn false;\n\t\t}\n\t\treturn this.lines[modelLineNumber - 1].isVisible();\n\t}\n\n\tpublic setTabSize(newTabSize: number): boolean {\n\t\tif (this.tabSize === newTabSize) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.tabSize = newTabSize;\n\n\t\tthis._constructLines(false);\n\n\t\treturn true;\n\t}\n\n\tpublic setWrappingSettings(wrappingIndent: WrappingIndent, wrappingColumn: number, columnsForFullWidthChar: number): boolean {\n\t\tif (this.wrappingIndent === wrappingIndent && this.wrappingColumn === wrappingColumn && this.columnsForFullWidthChar === columnsForFullWidthChar) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.wrappingIndent = wrappingIndent;\n\t\tthis.wrappingColumn = wrappingColumn;\n\t\tthis.columnsForFullWidthChar = columnsForFullWidthChar;\n\n\t\tthis._constructLines(false);\n\n\t\treturn true;\n\t}\n\n\tpublic onModelFlushed(): void {\n\t\tthis._constructLines(true);\n\t}\n\n\tpublic onModelLinesDeleted(versionId: number, fromLineNumber: number, toLineNumber: number): viewEvents.ViewLinesDeletedEvent | null {\n\t\tif (versionId <= this._validModelVersionId) {\n\t\t\t// Here we check for versionId in case the lines were reconstructed in the meantime.\n\t\t\t// We don't want to apply stale change events on top of a newer read model state.\n\t\t\treturn null;\n\t\t}\n\n\t\tlet outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);\n\t\tlet outputToLineNumber = this.prefixSumComputer.getAccumulatedValue(toLineNumber - 1);\n\n\t\tthis.lines.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n\t\tthis.prefixSumComputer.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n\n\t\treturn new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n\t}\n\n\tpublic onModelLinesInserted(versionId: number, fromLineNumber: number, _toLineNumber: number, text: string[]): viewEvents.ViewLinesInsertedEvent | null {\n\t\tif (versionId <= this._validModelVersionId) {\n\t\t\t// Here we check for versionId in case the lines were reconstructed in the meantime.\n\t\t\t// We don't want to apply stale change events on top of a newer read model state.\n\t\t\treturn null;\n\t\t}\n\n\t\tlet hiddenAreas = this.getHiddenAreas();\n\t\tlet isInHiddenArea = false;\n\t\tlet testPosition = new Position(fromLineNumber, 1);\n\t\tfor (const hiddenArea of hiddenAreas) {\n\t\t\tif (hiddenArea.containsPosition(testPosition)) {\n\t\t\t\tisInHiddenArea = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tlet outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);\n\n\t\tlet totalOutputLineCount = 0;\n\t\tlet insertLines: ISplitLine[] = [];\n\t\tlet insertPrefixSumValues = new Uint32Array(text.length);\n\n\t\tfor (let i = 0, len = text.length; i < len; i++) {\n\t\t\tlet line = createSplitLine(this.linePositionMapperFactory, text[i], this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, !isInHiddenArea);\n\t\t\tinsertLines.push(line);\n\n\t\t\tlet outputLineCount = line.getViewLineCount();\n\t\t\ttotalOutputLineCount += outputLineCount;\n\t\t\tinsertPrefixSumValues[i] = outputLineCount;\n\t\t}\n\n\t\t// TODO@Alex: use arrays.arrayInsert\n\t\tthis.lines = this.lines.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.lines.slice(fromLineNumber - 1));\n\n\t\tthis.prefixSumComputer.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n\n\t\treturn new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n\t}\n\n\tpublic onModelLineChanged(versionId: number, lineNumber: number, newText: string): [boolean, viewEvents.ViewLinesChangedEvent | null, viewEvents.ViewLinesInsertedEvent | null, viewEvents.ViewLinesDeletedEvent | null] {\n\t\tif (versionId <= this._validModelVersionId) {\n\t\t\t// Here we check for versionId in case the lines were reconstructed in the meantime.\n\t\t\t// We don't want to apply stale change events on top of a newer read model state.\n\t\t\treturn [false, null, null, null];\n\t\t}\n\n\t\tlet lineIndex = lineNumber - 1;\n\n\t\tlet oldOutputLineCount = this.lines[lineIndex].getViewLineCount();\n\t\tlet isVisible = this.lines[lineIndex].isVisible();\n\t\tlet line = createSplitLine(this.linePositionMapperFactory, newText, this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, isVisible);\n\t\tthis.lines[lineIndex] = line;\n\t\tlet newOutputLineCount = this.lines[lineIndex].getViewLineCount();\n\n\t\tlet lineMappingChanged = false;\n\t\tlet changeFrom = 0;\n\t\tlet changeTo = -1;\n\t\tlet insertFrom = 0;\n\t\tlet insertTo = -1;\n\t\tlet deleteFrom = 0;\n\t\tlet deleteTo = -1;\n\n\t\tif (oldOutputLineCount > newOutputLineCount) {\n\t\t\tchangeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\n\t\t\tchangeTo = changeFrom + newOutputLineCount - 1;\n\t\t\tdeleteFrom = changeTo + 1;\n\t\t\tdeleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n\t\t\tlineMappingChanged = true;\n\t\t} else if (oldOutputLineCount < newOutputLineCount) {\n\t\t\tchangeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\n\t\t\tchangeTo = changeFrom + oldOutputLineCount - 1;\n\t\t\tinsertFrom = changeTo + 1;\n\t\t\tinsertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n\t\t\tlineMappingChanged = true;\n\t\t} else {\n\t\t\tchangeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\n\t\t\tchangeTo = changeFrom + newOutputLineCount - 1;\n\t\t}\n\n\t\tthis.prefixSumComputer.changeValue(lineIndex, newOutputLineCount);\n\n\t\tconst viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo) : null);\n\t\tconst viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n\t\tconst viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n\n\t\treturn [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n\t}\n\n\tpublic acceptVersionId(versionId: number): void {\n\t\tthis._validModelVersionId = versionId;\n\t\tif (this.lines.length === 1 && !this.lines[0].isVisible()) {\n\t\t\t// At least one line must be visible => reset hidden areas\n\t\t\tthis.setHiddenAreas([]);\n\t\t}\n\t}\n\n\tpublic getViewLineCount(): number {\n\t\tthis._ensureValidState();\n\t\treturn this.prefixSumComputer.getTotalValue();\n\t}\n\n\tprivate _toValidViewLineNumber(viewLineNumber: number): number {\n\t\tif (viewLineNumber < 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tlet viewLineCount = this.getViewLineCount();\n\t\tif (viewLineNumber > viewLineCount) {\n\t\t\treturn viewLineCount;\n\t\t}\n\t\treturn viewLineNumber;\n\t}\n\n\t/**\n\t * Gives a hint that a lot of requests are about to come in for these line numbers.\n\t */\n\tpublic warmUpLookupCache(viewStartLineNumber: number, viewEndLineNumber: number): void {\n\t\tthis.prefixSumComputer.warmUpCache(viewStartLineNumber - 1, viewEndLineNumber - 1);\n\t}\n\n\tpublic getActiveIndentGuide(viewLineNumber: number, minLineNumber: number, maxLineNumber: number): IActiveIndentGuideInfo {\n\t\tthis._ensureValidState();\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\t\tminLineNumber = this._toValidViewLineNumber(minLineNumber);\n\t\tmaxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n\n\t\tconst modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n\t\tconst modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n\t\tconst modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n\t\tconst result = this.model.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n\n\t\tconst viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n\t\tconst viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n\t\treturn {\n\t\t\tstartLineNumber: viewStartPosition.lineNumber,\n\t\t\tendLineNumber: viewEndPosition.lineNumber,\n\t\t\tindent: result.indent\n\t\t};\n\t}\n\n\tpublic getViewLinesIndentGuides(viewStartLineNumber: number, viewEndLineNumber: number): number[] {\n\t\tthis._ensureValidState();\n\t\tviewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n\t\tviewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n\n\t\tconst modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n\t\tconst modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n\n\t\tlet result: number[] = [];\n\t\tlet resultRepeatCount: number[] = [];\n\t\tlet resultRepeatOption: IndentGuideRepeatOption[] = [];\n\t\tconst modelStartLineIndex = modelStart.lineNumber - 1;\n\t\tconst modelEndLineIndex = modelEnd.lineNumber - 1;\n\n\t\tlet reqStart: Position | null = null;\n\t\tfor (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n\t\t\tconst line = this.lines[modelLineIndex];\n\t\t\tif (line.isVisible()) {\n\t\t\t\tlet viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n\t\t\t\tlet viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n\t\t\t\tlet count = viewLineEndIndex - viewLineStartIndex + 1;\n\t\t\t\tlet option = IndentGuideRepeatOption.BlockNone;\n\t\t\t\tif (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n\t\t\t\t\t// wrapped lines should block indent guides\n\t\t\t\t\toption = (viewLineStartIndex === 0 ? IndentGuideRepeatOption.BlockSubsequent : IndentGuideRepeatOption.BlockAll);\n\t\t\t\t}\n\t\t\t\tresultRepeatCount.push(count);\n\t\t\t\tresultRepeatOption.push(option);\n\t\t\t\t// merge into previous request\n\t\t\t\tif (reqStart === null) {\n\t\t\t\t\treqStart = new Position(modelLineIndex + 1, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// hit invisible line => flush request\n\t\t\t\tif (reqStart !== null) {\n\t\t\t\t\tresult = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n\t\t\t\t\treqStart = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (reqStart !== null) {\n\t\t\tresult = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n\t\t\treqStart = null;\n\t\t}\n\n\t\tconst viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n\t\tlet viewIndents = new Array<number>(viewLineCount);\n\t\tlet currIndex = 0;\n\t\tfor (let i = 0, len = result.length; i < len; i++) {\n\t\t\tlet value = result[i];\n\t\t\tlet count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n\t\t\tlet option = resultRepeatOption[i];\n\t\t\tlet blockAtIndex: number;\n\t\t\tif (option === IndentGuideRepeatOption.BlockAll) {\n\t\t\t\tblockAtIndex = 0;\n\t\t\t} else if (option === IndentGuideRepeatOption.BlockSubsequent) {\n\t\t\t\tblockAtIndex = 1;\n\t\t\t} else {\n\t\t\t\tblockAtIndex = count;\n\t\t\t}\n\t\t\tfor (let j = 0; j < count; j++) {\n\t\t\t\tif (j === blockAtIndex) {\n\t\t\t\t\tvalue = 0;\n\t\t\t\t}\n\t\t\t\tviewIndents[currIndex++] = value;\n\t\t\t}\n\t\t}\n\t\treturn viewIndents;\n\t}\n\n\tpublic getViewLineContent(viewLineNumber: number): string {\n\t\tthis._ensureValidState();\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\t\tlet r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n\t\tlet lineIndex = r.index;\n\t\tlet remainder = r.remainder;\n\n\t\treturn this.lines[lineIndex].getViewLineContent(this.model, lineIndex + 1, remainder);\n\t}\n\n\tpublic getViewLineLength(viewLineNumber: number): number {\n\t\tthis._ensureValidState();\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\t\tlet r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n\t\tlet lineIndex = r.index;\n\t\tlet remainder = r.remainder;\n\n\t\treturn this.lines[lineIndex].getViewLineLength(this.model, lineIndex + 1, remainder);\n\t}\n\n\tpublic getViewLineMinColumn(viewLineNumber: number): number {\n\t\tthis._ensureValidState();\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\t\tlet r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n\t\tlet lineIndex = r.index;\n\t\tlet remainder = r.remainder;\n\n\t\treturn this.lines[lineIndex].getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n\t}\n\n\tpublic getViewLineMaxColumn(viewLineNumber: number): number {\n\t\tthis._ensureValidState();\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\t\tlet r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n\t\tlet lineIndex = r.index;\n\t\tlet remainder = r.remainder;\n\n\t\treturn this.lines[lineIndex].getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n\t}\n\n\tpublic getViewLineData(viewLineNumber: number): ViewLineData {\n\t\tthis._ensureValidState();\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\t\tlet r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n\t\tlet lineIndex = r.index;\n\t\tlet remainder = r.remainder;\n\n\t\treturn this.lines[lineIndex].getViewLineData(this.model, lineIndex + 1, remainder);\n\t}\n\n\tpublic getViewLinesData(viewStartLineNumber: number, viewEndLineNumber: number, needed: boolean[]): ViewLineData[] {\n\t\tthis._ensureValidState();\n\n\t\tviewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n\t\tviewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n\n\t\tlet start = this.prefixSumComputer.getIndexOf(viewStartLineNumber - 1);\n\t\tlet viewLineNumber = viewStartLineNumber;\n\t\tlet startModelLineIndex = start.index;\n\t\tlet startRemainder = start.remainder;\n\n\t\tlet result: ViewLineData[] = [];\n\t\tfor (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n\t\t\tlet line = this.lines[modelLineIndex];\n\t\t\tif (!line.isVisible()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n\t\t\tlet remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n\n\t\t\tlet lastLine = false;\n\t\t\tif (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n\t\t\t\tlastLine = true;\n\t\t\t\tremainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n\t\t\t}\n\t\t\tlet toViewLineIndex = fromViewLineIndex + remainingViewLineCount;\n\n\t\t\tline.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, toViewLineIndex, viewLineNumber - viewStartLineNumber, needed, result);\n\n\t\t\tviewLineNumber += remainingViewLineCount;\n\n\t\t\tif (lastLine) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic validateViewPosition(viewLineNumber: number, viewColumn: number, expectedModelPosition: Position): Position {\n\t\tthis._ensureValidState();\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\n\t\tlet r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n\t\tlet lineIndex = r.index;\n\t\tlet remainder = r.remainder;\n\n\t\tlet line = this.lines[lineIndex];\n\n\t\tlet minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n\t\tlet maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n\t\tif (viewColumn < minColumn) {\n\t\t\tviewColumn = minColumn;\n\t\t}\n\t\tif (viewColumn > maxColumn) {\n\t\t\tviewColumn = maxColumn;\n\t\t}\n\n\t\tlet computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n\t\tlet computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n\n\t\tif (computedModelPosition.equals(expectedModelPosition)) {\n\t\t\treturn new Position(viewLineNumber, viewColumn);\n\t\t}\n\n\t\treturn this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n\t}\n\n\tpublic convertViewPositionToModelPosition(viewLineNumber: number, viewColumn: number): Position {\n\t\tthis._ensureValidState();\n\t\tviewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n\n\t\tlet r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n\t\tlet lineIndex = r.index;\n\t\tlet remainder = r.remainder;\n\n\t\tlet inputColumn = this.lines[lineIndex].getModelColumnOfViewPosition(remainder, viewColumn);\n\t\t// console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n\t\treturn this.model.validatePosition(new Position(lineIndex + 1, inputColumn));\n\t}\n\n\tpublic convertModelPositionToViewPosition(_modelLineNumber: number, _modelColumn: number): Position {\n\t\tthis._ensureValidState();\n\n\t\tlet validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n\t\tlet inputLineNumber = validPosition.lineNumber;\n\t\tlet inputColumn = validPosition.column;\n\n\t\tlet lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n\t\twhile (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\n\t\t\tlineIndex--;\n\t\t\tlineIndexChanged = true;\n\t\t}\n\t\tif (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\n\t\t\t// Could not reach a real line\n\t\t\t// console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n\t\t\treturn new Position(1, 1);\n\t\t}\n\t\tlet deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n\n\t\tlet r: Position;\n\t\tif (lineIndexChanged) {\n\t\t\tr = this.lines[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n\t\t} else {\n\t\t\tr = this.lines[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn);\n\t\t}\n\n\t\t// console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n\t\treturn r;\n\t}\n\n\tprivate _getViewLineNumberForModelPosition(inputLineNumber: number, inputColumn: number): number {\n\t\tlet lineIndex = inputLineNumber - 1;\n\t\tif (this.lines[lineIndex].isVisible()) {\n\t\t\t// this model line is visible\n\t\t\tconst deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n\t\t\treturn this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn);\n\t\t}\n\n\t\t// this model line is not visible\n\t\twhile (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\n\t\t\tlineIndex--;\n\t\t}\n\t\tif (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\n\t\t\t// Could not reach a real line\n\t\t\treturn 1;\n\t\t}\n\t\tconst deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n\t\treturn this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n\t}\n\n\tpublic getAllOverviewRulerDecorations(ownerId: number, filterOutValidation: boolean, theme: ITheme): IOverviewRulerDecorations {\n\t\tconst decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);\n\t\tconst result = new OverviewRulerDecorations();\n\t\tfor (const decoration of decorations) {\n\t\t\tconst opts = <ModelDecorationOverviewRulerOptions>decoration.options.overviewRuler;\n\t\t\tconst lane = opts ? opts.position : 0;\n\t\t\tif (lane === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst color = opts.getColor(theme);\n\t\t\tconst viewStartLineNumber = this._getViewLineNumberForModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n\t\t\tconst viewEndLineNumber = this._getViewLineNumberForModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n\n\t\t\tresult.accept(color, viewStartLineNumber, viewEndLineNumber, lane);\n\t\t}\n\t\treturn result.result;\n\t}\n\n\tpublic getDecorationsInRange(range: Range, ownerId: number, filterOutValidation: boolean): IModelDecoration[] {\n\t\tconst modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n\t\tconst modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n\n\t\tif (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n\t\t\t// most likely there are no hidden lines => fast path\n\t\t\t// fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n\t\t\treturn this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);\n\t\t}\n\n\t\tlet result: IModelDecoration[] = [];\n\t\tconst modelStartLineIndex = modelStart.lineNumber - 1;\n\t\tconst modelEndLineIndex = modelEnd.lineNumber - 1;\n\n\t\tlet reqStart: Position | null = null;\n\t\tfor (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n\t\t\tconst line = this.lines[modelLineIndex];\n\t\t\tif (line.isVisible()) {\n\t\t\t\t// merge into previous request\n\t\t\t\tif (reqStart === null) {\n\t\t\t\t\treqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// hit invisible line => flush request\n\t\t\t\tif (reqStart !== null) {\n\t\t\t\t\tconst maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n\t\t\t\t\tresult = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));\n\t\t\t\t\treqStart = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (reqStart !== null) {\n\t\t\tresult = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));\n\t\t\treqStart = null;\n\t\t}\n\n\t\tresult.sort((a, b) => {\n\t\t\tconst res = Range.compareRangesUsingStarts(a.range, b.range);\n\t\t\tif (res === 0) {\n\t\t\t\tif (a.id < b.id) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (a.id > b.id) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn res;\n\t\t});\n\n\t\t// Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n\t\tlet finalResult: IModelDecoration[] = [], finalResultLen = 0;\n\t\tlet prevDecId: string | null = null;\n\t\tfor (const dec of result) {\n\t\t\tconst decId = dec.id;\n\t\t\tif (prevDecId === decId) {\n\t\t\t\t// skip\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprevDecId = decId;\n\t\t\tfinalResult[finalResultLen++] = dec;\n\t\t}\n\n\t\treturn finalResult;\n\t}\n}\n\nclass VisibleIdentitySplitLine implements ISplitLine {\n\n\tpublic static readonly INSTANCE = new VisibleIdentitySplitLine();\n\n\tprivate constructor() { }\n\n\tpublic isVisible(): boolean {\n\t\treturn true;\n\t}\n\n\tpublic setVisible(isVisible: boolean): ISplitLine {\n\t\tif (isVisible) {\n\t\t\treturn this;\n\t\t}\n\t\treturn InvisibleIdentitySplitLine.INSTANCE;\n\t}\n\n\tpublic getViewLineCount(): number {\n\t\treturn 1;\n\t}\n\n\tpublic getViewLineContent(model: ISimpleModel, modelLineNumber: number, _outputLineIndex: number): string {\n\t\treturn model.getLineContent(modelLineNumber);\n\t}\n\n\tpublic getViewLineLength(model: ISimpleModel, modelLineNumber: number, _outputLineIndex: number): number {\n\t\treturn model.getLineLength(modelLineNumber);\n\t}\n\n\tpublic getViewLineMinColumn(model: ISimpleModel, modelLineNumber: number, _outputLineIndex: number): number {\n\t\treturn model.getLineMinColumn(modelLineNumber);\n\t}\n\n\tpublic getViewLineMaxColumn(model: ISimpleModel, modelLineNumber: number, _outputLineIndex: number): number {\n\t\treturn model.getLineMaxColumn(modelLineNumber);\n\t}\n\n\tpublic getViewLineData(model: ISimpleModel, modelLineNumber: number, _outputLineIndex: number): ViewLineData {\n\t\tlet lineTokens = model.getLineTokens(modelLineNumber);\n\t\tlet lineContent = lineTokens.getLineContent();\n\t\treturn new ViewLineData(\n\t\t\tlineContent,\n\t\t\tfalse,\n\t\t\t1,\n\t\t\tlineContent.length + 1,\n\t\t\tlineTokens.inflate()\n\t\t);\n\t}\n\n\tpublic getViewLinesData(model: ISimpleModel, modelLineNumber: number, _fromOuputLineIndex: number, _toOutputLineIndex: number, globalStartIndex: number, needed: boolean[], result: Array<ViewLineData | null>): void {\n\t\tif (!needed[globalStartIndex]) {\n\t\t\tresult[globalStartIndex] = null;\n\t\t\treturn;\n\t\t}\n\t\tresult[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n\t}\n\n\tpublic getModelColumnOfViewPosition(_outputLineIndex: number, outputColumn: number): number {\n\t\treturn outputColumn;\n\t}\n\n\tpublic getViewPositionOfModelPosition(deltaLineNumber: number, inputColumn: number): Position {\n\t\treturn new Position(deltaLineNumber, inputColumn);\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(deltaLineNumber: number, _inputColumn: number): number {\n\t\treturn deltaLineNumber;\n\t}\n}\n\nclass InvisibleIdentitySplitLine implements ISplitLine {\n\n\tpublic static readonly INSTANCE = new InvisibleIdentitySplitLine();\n\n\tprivate constructor() { }\n\n\tpublic isVisible(): boolean {\n\t\treturn false;\n\t}\n\n\tpublic setVisible(isVisible: boolean): ISplitLine {\n\t\tif (!isVisible) {\n\t\t\treturn this;\n\t\t}\n\t\treturn VisibleIdentitySplitLine.INSTANCE;\n\t}\n\n\tpublic getViewLineCount(): number {\n\t\treturn 0;\n\t}\n\n\tpublic getViewLineContent(_model: ISimpleModel, _modelLineNumber: number, _outputLineIndex: number): string {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic getViewLineLength(_model: ISimpleModel, _modelLineNumber: number, _outputLineIndex: number): number {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic getViewLineMinColumn(_model: ISimpleModel, _modelLineNumber: number, _outputLineIndex: number): number {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic getViewLineMaxColumn(_model: ISimpleModel, _modelLineNumber: number, _outputLineIndex: number): number {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic getViewLineData(_model: ISimpleModel, _modelLineNumber: number, _outputLineIndex: number): ViewLineData {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic getViewLinesData(_model: ISimpleModel, _modelLineNumber: number, _fromOuputLineIndex: number, _toOutputLineIndex: number, _globalStartIndex: number, _needed: boolean[], _result: ViewLineData[]): void {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic getModelColumnOfViewPosition(_outputLineIndex: number, _outputColumn: number): number {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic getViewPositionOfModelPosition(_deltaLineNumber: number, _inputColumn: number): Position {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(_deltaLineNumber: number, _inputColumn: number): number {\n\t\tthrow new Error('Not supported');\n\t}\n}\n\nexport class SplitLine implements ISplitLine {\n\n\tprivate readonly positionMapper: ILineMapping;\n\tprivate readonly outputLineCount: number;\n\n\tprivate readonly wrappedIndent: string;\n\tprivate readonly wrappedIndentLength: number;\n\tprivate _isVisible: boolean;\n\n\tconstructor(positionMapper: ILineMapping, isVisible: boolean) {\n\t\tthis.positionMapper = positionMapper;\n\t\tthis.wrappedIndent = this.positionMapper.getWrappedLinesIndent();\n\t\tthis.wrappedIndentLength = this.wrappedIndent.length;\n\t\tthis.outputLineCount = this.positionMapper.getOutputLineCount();\n\t\tthis._isVisible = isVisible;\n\t}\n\n\tpublic isVisible(): boolean {\n\t\treturn this._isVisible;\n\t}\n\n\tpublic setVisible(isVisible: boolean): ISplitLine {\n\t\tthis._isVisible = isVisible;\n\t\treturn this;\n\t}\n\n\tpublic getViewLineCount(): number {\n\t\tif (!this._isVisible) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.outputLineCount;\n\t}\n\n\tprivate getInputStartOffsetOfOutputLineIndex(outputLineIndex: number): number {\n\t\treturn this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex, 0);\n\t}\n\n\tprivate getInputEndOffsetOfOutputLineIndex(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): number {\n\t\tif (outputLineIndex + 1 === this.outputLineCount) {\n\t\t\treturn model.getLineMaxColumn(modelLineNumber) - 1;\n\t\t}\n\t\treturn this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex + 1, 0);\n\t}\n\n\tpublic getViewLineContent(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): string {\n\t\tif (!this._isVisible) {\n\t\t\tthrow new Error('Not supported');\n\t\t}\n\t\tlet startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n\t\tlet endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n\t\tlet r = model.getValueInRange({\n\t\t\tstartLineNumber: modelLineNumber,\n\t\t\tstartColumn: startOffset + 1,\n\t\t\tendLineNumber: modelLineNumber,\n\t\t\tendColumn: endOffset + 1\n\t\t});\n\n\t\tif (outputLineIndex > 0) {\n\t\t\tr = this.wrappedIndent + r;\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tpublic getViewLineLength(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): number {\n\t\tif (!this._isVisible) {\n\t\t\tthrow new Error('Not supported');\n\t\t}\n\t\tlet startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n\t\tlet endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n\t\tlet r = endOffset - startOffset;\n\n\t\tif (outputLineIndex > 0) {\n\t\t\tr = this.wrappedIndent.length + r;\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tpublic getViewLineMinColumn(_model: ITextModel, _modelLineNumber: number, outputLineIndex: number): number {\n\t\tif (!this._isVisible) {\n\t\t\tthrow new Error('Not supported');\n\t\t}\n\t\tif (outputLineIndex > 0) {\n\t\t\treturn this.wrappedIndentLength + 1;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tpublic getViewLineMaxColumn(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): number {\n\t\tif (!this._isVisible) {\n\t\t\tthrow new Error('Not supported');\n\t\t}\n\t\treturn this.getViewLineContent(model, modelLineNumber, outputLineIndex).length + 1;\n\t}\n\n\tpublic getViewLineData(model: ISimpleModel, modelLineNumber: number, outputLineIndex: number): ViewLineData {\n\t\tif (!this._isVisible) {\n\t\t\tthrow new Error('Not supported');\n\t\t}\n\n\t\tlet startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n\t\tlet endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n\n\t\tlet lineContent = model.getValueInRange({\n\t\t\tstartLineNumber: modelLineNumber,\n\t\t\tstartColumn: startOffset + 1,\n\t\t\tendLineNumber: modelLineNumber,\n\t\t\tendColumn: endOffset + 1\n\t\t});\n\n\t\tif (outputLineIndex > 0) {\n\t\t\tlineContent = this.wrappedIndent + lineContent;\n\t\t}\n\n\t\tlet minColumn = (outputLineIndex > 0 ? this.wrappedIndentLength + 1 : 1);\n\t\tlet maxColumn = lineContent.length + 1;\n\n\t\tlet continuesWithWrappedLine = (outputLineIndex + 1 < this.getViewLineCount());\n\n\t\tlet deltaStartIndex = 0;\n\t\tif (outputLineIndex > 0) {\n\t\t\tdeltaStartIndex = this.wrappedIndentLength;\n\t\t}\n\t\tlet lineTokens = model.getLineTokens(modelLineNumber);\n\n\t\treturn new ViewLineData(\n\t\t\tlineContent,\n\t\t\tcontinuesWithWrappedLine,\n\t\t\tminColumn,\n\t\t\tmaxColumn,\n\t\t\tlineTokens.sliceAndInflate(startOffset, endOffset, deltaStartIndex)\n\t\t);\n\t}\n\n\tpublic getViewLinesData(model: ITextModel, modelLineNumber: number, fromOuputLineIndex: number, toOutputLineIndex: number, globalStartIndex: number, needed: boolean[], result: Array<ViewLineData | null>): void {\n\t\tif (!this._isVisible) {\n\t\t\tthrow new Error('Not supported');\n\t\t}\n\n\t\tfor (let outputLineIndex = fromOuputLineIndex; outputLineIndex < toOutputLineIndex; outputLineIndex++) {\n\t\t\tlet globalIndex = globalStartIndex + outputLineIndex - fromOuputLineIndex;\n\t\t\tif (!needed[globalIndex]) {\n\t\t\t\tresult[globalIndex] = null;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult[globalIndex] = this.getViewLineData(model, modelLineNumber, outputLineIndex);\n\t\t}\n\t}\n\n\tpublic getModelColumnOfViewPosition(outputLineIndex: number, outputColumn: number): number {\n\t\tif (!this._isVisible) {\n\t\t\tthrow new Error('Not supported');\n\t\t}\n\t\tlet adjustedColumn = outputColumn - 1;\n\t\tif (outputLineIndex > 0) {\n\t\t\tif (adjustedColumn < this.wrappedIndentLength) {\n\t\t\t\tadjustedColumn = 0;\n\t\t\t} else {\n\t\t\t\tadjustedColumn -= this.wrappedIndentLength;\n\t\t\t}\n\t\t}\n\t\treturn this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex, adjustedColumn) + 1;\n\t}\n\n\tpublic getViewPositionOfModelPosition(deltaLineNumber: number, inputColumn: number): Position {\n\t\tif (!this._isVisible) {\n\t\t\tthrow new Error('Not supported');\n\t\t}\n\t\tlet r = this.positionMapper.getOutputPositionOfInputOffset(inputColumn - 1);\n\t\tlet outputLineIndex = r.outputLineIndex;\n\t\tlet outputColumn = r.outputOffset + 1;\n\n\t\tif (outputLineIndex > 0) {\n\t\t\toutputColumn += this.wrappedIndentLength;\n\t\t}\n\n\t\t//\t\tconsole.log('in -> out ' + deltaLineNumber + ',' + inputColumn + ' ===> ' + (deltaLineNumber+outputLineIndex) + ',' + outputColumn);\n\t\treturn new Position(deltaLineNumber + outputLineIndex, outputColumn);\n\t}\n\n\tpublic getViewLineNumberOfModelPosition(deltaLineNumber: number, inputColumn: number): number {\n\t\tif (!this._isVisible) {\n\t\t\tthrow new Error('Not supported');\n\t\t}\n\t\tconst r = this.positionMapper.getOutputPositionOfInputOffset(inputColumn - 1);\n\t\treturn (deltaLineNumber + r.outputLineIndex);\n\t}\n}\n\nfunction createSplitLine(linePositionMapperFactory: ILineMapperFactory, text: string, tabSize: number, wrappingColumn: number, columnsForFullWidthChar: number, wrappingIndent: WrappingIndent, isVisible: boolean): ISplitLine {\n\tlet positionMapper = linePositionMapperFactory.createLineMapping(text, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n\tif (positionMapper === null) {\n\t\t// No mapping needed\n\t\tif (isVisible) {\n\t\t\treturn VisibleIdentitySplitLine.INSTANCE;\n\t\t}\n\t\treturn InvisibleIdentitySplitLine.INSTANCE;\n\t} else {\n\t\treturn new SplitLine(positionMapper, isVisible);\n\t}\n}\n\nexport class IdentityCoordinatesConverter implements ICoordinatesConverter {\n\n\tprivate readonly _lines: IdentityLinesCollection;\n\n\tconstructor(lines: IdentityLinesCollection) {\n\t\tthis._lines = lines;\n\t}\n\n\tprivate _validPosition(pos: Position): Position {\n\t\treturn this._lines.model.validatePosition(pos);\n\t}\n\n\tprivate _validRange(range: Range): Range {\n\t\treturn this._lines.model.validateRange(range);\n\t}\n\n\t// View -> Model conversion and related methods\n\n\tpublic convertViewPositionToModelPosition(viewPosition: Position): Position {\n\t\treturn this._validPosition(viewPosition);\n\t}\n\n\tpublic convertViewRangeToModelRange(viewRange: Range): Range {\n\t\treturn this._validRange(viewRange);\n\t}\n\n\tpublic validateViewPosition(_viewPosition: Position, expectedModelPosition: Position): Position {\n\t\treturn this._validPosition(expectedModelPosition);\n\t}\n\n\tpublic validateViewRange(_viewRange: Range, expectedModelRange: Range): Range {\n\t\treturn this._validRange(expectedModelRange);\n\t}\n\n\t// Model -> View conversion and related methods\n\n\tpublic convertModelPositionToViewPosition(modelPosition: Position): Position {\n\t\treturn this._validPosition(modelPosition);\n\t}\n\n\tpublic convertModelRangeToViewRange(modelRange: Range): Range {\n\t\treturn this._validRange(modelRange);\n\t}\n\n\tpublic modelPositionIsVisible(modelPosition: Position): boolean {\n\t\tconst lineCount = this._lines.model.getLineCount();\n\t\tif (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n\t\t\t// invalid arguments\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n}\n\nexport class IdentityLinesCollection implements IViewModelLinesCollection {\n\n\tpublic readonly model: ITextModel;\n\n\tconstructor(model: ITextModel) {\n\t\tthis.model = model;\n\t}\n\n\tpublic dispose(): void {\n\t}\n\n\tpublic createCoordinatesConverter(): ICoordinatesConverter {\n\t\treturn new IdentityCoordinatesConverter(this);\n\t}\n\n\tpublic getHiddenAreas(): Range[] {\n\t\treturn [];\n\t}\n\n\tpublic setHiddenAreas(_ranges: Range[]): boolean {\n\t\treturn false;\n\t}\n\n\tpublic setTabSize(_newTabSize: number): boolean {\n\t\treturn false;\n\t}\n\n\tpublic setWrappingSettings(_wrappingIndent: WrappingIndent, _wrappingColumn: number, _columnsForFullWidthChar: number): boolean {\n\t\treturn false;\n\t}\n\n\tpublic onModelFlushed(): void {\n\t}\n\n\tpublic onModelLinesDeleted(_versionId: number, fromLineNumber: number, toLineNumber: number): viewEvents.ViewLinesDeletedEvent | null {\n\t\treturn new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n\t}\n\n\tpublic onModelLinesInserted(_versionId: number, fromLineNumber: number, toLineNumber: number, _text: string[]): viewEvents.ViewLinesInsertedEvent | null {\n\t\treturn new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n\t}\n\n\tpublic onModelLineChanged(_versionId: number, lineNumber: number, _newText: string): [boolean, viewEvents.ViewLinesChangedEvent | null, viewEvents.ViewLinesInsertedEvent | null, viewEvents.ViewLinesDeletedEvent | null] {\n\t\treturn [false, new viewEvents.ViewLinesChangedEvent(lineNumber, lineNumber), null, null];\n\t}\n\n\tpublic acceptVersionId(_versionId: number): void {\n\t}\n\n\tpublic getViewLineCount(): number {\n\t\treturn this.model.getLineCount();\n\t}\n\n\tpublic warmUpLookupCache(_viewStartLineNumber: number, _viewEndLineNumber: number): void {\n\t}\n\n\tpublic getActiveIndentGuide(viewLineNumber: number, _minLineNumber: number, _maxLineNumber: number): IActiveIndentGuideInfo {\n\t\treturn {\n\t\t\tstartLineNumber: viewLineNumber,\n\t\t\tendLineNumber: viewLineNumber,\n\t\t\tindent: 0\n\t\t};\n\t}\n\n\tpublic getViewLinesIndentGuides(viewStartLineNumber: number, viewEndLineNumber: number): number[] {\n\t\tconst viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n\t\tlet result = new Array<number>(viewLineCount);\n\t\tfor (let i = 0; i < viewLineCount; i++) {\n\t\t\tresult[i] = 0;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic getViewLineContent(viewLineNumber: number): string {\n\t\treturn this.model.getLineContent(viewLineNumber);\n\t}\n\n\tpublic getViewLineLength(viewLineNumber: number): number {\n\t\treturn this.model.getLineLength(viewLineNumber);\n\t}\n\n\tpublic getViewLineMinColumn(viewLineNumber: number): number {\n\t\treturn this.model.getLineMinColumn(viewLineNumber);\n\t}\n\n\tpublic getViewLineMaxColumn(viewLineNumber: number): number {\n\t\treturn this.model.getLineMaxColumn(viewLineNumber);\n\t}\n\n\tpublic getViewLineData(viewLineNumber: number): ViewLineData {\n\t\tlet lineTokens = this.model.getLineTokens(viewLineNumber);\n\t\tlet lineContent = lineTokens.getLineContent();\n\t\treturn new ViewLineData(\n\t\t\tlineContent,\n\t\t\tfalse,\n\t\t\t1,\n\t\t\tlineContent.length + 1,\n\t\t\tlineTokens.inflate()\n\t\t);\n\t}\n\n\tpublic getViewLinesData(viewStartLineNumber: number, viewEndLineNumber: number, needed: boolean[]): Array<ViewLineData | null> {\n\t\tconst lineCount = this.model.getLineCount();\n\t\tviewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n\t\tviewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n\n\t\tlet result: Array<ViewLineData | null> = [];\n\t\tfor (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n\t\t\tlet idx = lineNumber - viewStartLineNumber;\n\t\t\tif (!needed[idx]) {\n\t\t\t\tresult[idx] = null;\n\t\t\t}\n\t\t\tresult[idx] = this.getViewLineData(lineNumber);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic getAllOverviewRulerDecorations(ownerId: number, filterOutValidation: boolean, theme: ITheme): IOverviewRulerDecorations {\n\t\tconst decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);\n\t\tconst result = new OverviewRulerDecorations();\n\t\tfor (const decoration of decorations) {\n\t\t\tconst opts = <ModelDecorationOverviewRulerOptions>decoration.options.overviewRuler;\n\t\t\tconst lane = opts ? opts.position : 0;\n\t\t\tif (lane === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst color = opts.getColor(theme);\n\t\t\tconst viewStartLineNumber = decoration.range.startLineNumber;\n\t\t\tconst viewEndLineNumber = decoration.range.endLineNumber;\n\n\t\t\tresult.accept(color, viewStartLineNumber, viewEndLineNumber, lane);\n\t\t}\n\t\treturn result.result;\n\t}\n\n\tpublic getDecorationsInRange(range: Range, ownerId: number, filterOutValidation: boolean): IModelDecoration[] {\n\t\treturn this.model.getDecorationsInRange(range, ownerId, filterOutValidation);\n\t}\n}\n\nclass OverviewRulerDecorations {\n\n\treadonly result: IOverviewRulerDecorations = Object.create(null);\n\n\tconstructor() {\n\t}\n\n\tpublic accept(color: string, startLineNumber: number, endLineNumber: number, lane: number): void {\n\t\tlet prev = this.result[color];\n\n\t\tif (prev) {\n\t\t\tconst prevLane = prev[prev.length - 3];\n\t\t\tconst prevEndLineNumber = prev[prev.length - 1];\n\t\t\tif (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n\t\t\t\t// merge into prev\n\t\t\t\tif (endLineNumber > prevEndLineNumber) {\n\t\t\t\t\tprev[prev.length - 1] = endLineNumber;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// push\n\t\t\tprev.push(lane, startLineNumber, endLineNumber);\n\t\t} else {\n\t\t\tthis.result[color] = [lane, startLineNumber, endLineNumber];\n\t\t}\n\t}\n}\n"]}]}