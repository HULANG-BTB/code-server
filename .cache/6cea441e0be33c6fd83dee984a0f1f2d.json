{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/output/node/outputChannelModelService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/output/node/outputChannelModelService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/platform/instantiation/common/instantiation\", \"vs/base/node/extfs\", \"vs/base/common/path\", \"vs/base/common/resources\", \"vs/base/common/uri\", \"vs/base/common/async\", \"vs/platform/files/common/files\", \"vs/editor/common/services/modelService\", \"vs/editor/common/services/modeService\", \"vs/base/common/lifecycle\", \"vs/platform/log/common/log\", \"vs/workbench/services/output/common/outputChannelModel\", \"vs/workbench/services/output/node/outputAppender\", \"vs/platform/environment/common/environment\", \"vs/platform/windows/common/windows\", \"vs/base/common/date\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/instantiation/common/extensions\", \"vs/base/common/event\"], function (require, exports, instantiation_1, extfs, path_1, resources, uri_1, async_1, files_1, modelService_1, modeService_1, lifecycle_1, log_1, outputChannelModel_1, outputAppender_1, environment_1, windows_1, date_1, telemetry_1, extensions_1, event_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let watchingOutputDir = false;\n    let callbacks = [];\n    function watchOutputDirectory(outputDir, logService, onChange) {\n        callbacks.push(onChange);\n        if (!watchingOutputDir) {\n            const watcherDisposable = extfs.watch(outputDir, (eventType, fileName) => {\n                for (const callback of callbacks) {\n                    callback(eventType, fileName);\n                }\n            }, (error) => {\n                logService.error(error);\n            });\n            watchingOutputDir = true;\n            return lifecycle_1.toDisposable(() => {\n                callbacks = [];\n                watcherDisposable.dispose();\n            });\n        }\n        return lifecycle_1.toDisposable(() => { });\n    }\n    let OutputChannelBackedByFile = class OutputChannelBackedByFile extends outputChannelModel_1.AbstractFileOutputChannelModel {\n        constructor(id, modelUri, mimeType, file, fileService, modelService, modeService, logService) {\n            super(modelUri, mimeType, file, fileService, modelService, modeService);\n            this.appendedMessage = '';\n            this.loadingFromFileInProgress = false;\n            // Use one rotating file to check for main file reset\n            this.appender = new outputAppender_1.OutputAppender(id, this.file.fsPath);\n            this.rotatingFilePath = `${id}.1.log`;\n            this._register(watchOutputDirectory(path_1.dirname(this.file.fsPath), logService, (eventType, file) => this.onFileChangedInOutputDirector(eventType, file)));\n            this.resettingDelayer = new async_1.ThrottledDelayer(50);\n        }\n        append(message) {\n            // update end offset always as message is read\n            this.endOffset = this.endOffset + Buffer.from(message).byteLength;\n            if (this.loadingFromFileInProgress) {\n                this.appendedMessage += message;\n            }\n            else {\n                this.write(message);\n                if (this.model) {\n                    this.appendedMessage += message;\n                    if (!this.modelUpdater.isScheduled()) {\n                        this.modelUpdater.schedule();\n                    }\n                }\n            }\n        }\n        clear(till) {\n            super.clear(till);\n            this.appendedMessage = '';\n        }\n        loadModel() {\n            this.loadingFromFileInProgress = true;\n            if (this.modelUpdater.isScheduled()) {\n                this.modelUpdater.cancel();\n            }\n            this.appendedMessage = '';\n            return this.loadFile()\n                .then(content => {\n                if (this.endOffset !== this.startOffset + Buffer.from(content).byteLength) {\n                    // Queue content is not written into the file\n                    // Flush it and load file again\n                    this.flush();\n                    return this.loadFile();\n                }\n                return content;\n            })\n                .then(content => {\n                if (this.appendedMessage) {\n                    this.write(this.appendedMessage);\n                    this.appendedMessage = '';\n                }\n                this.loadingFromFileInProgress = false;\n                return this.createModel(content);\n            });\n        }\n        resetModel() {\n            this.startOffset = 0;\n            this.endOffset = 0;\n            if (this.model) {\n                return this.loadModel().then(() => undefined);\n            }\n            return Promise.resolve(undefined);\n        }\n        loadFile() {\n            return this.fileService.resolveContent(this.file, { position: this.startOffset, encoding: 'utf8' })\n                .then(content => this.appendedMessage ? content.value + this.appendedMessage : content.value);\n        }\n        updateModel() {\n            if (this.model && this.appendedMessage) {\n                this.appendToModel(this.appendedMessage);\n                this.appendedMessage = '';\n            }\n        }\n        onFileChangedInOutputDirector(eventType, fileName) {\n            // Check if rotating file has changed. It changes only when the main file exceeds its limit.\n            if (this.rotatingFilePath === fileName) {\n                this.resettingDelayer.trigger(() => this.resetModel());\n            }\n        }\n        write(content) {\n            this.appender.append(content);\n        }\n        flush() {\n            this.appender.flush();\n        }\n    };\n    OutputChannelBackedByFile = __decorate([\n        __param(4, files_1.IFileService),\n        __param(5, modelService_1.IModelService),\n        __param(6, modeService_1.IModeService),\n        __param(7, log_1.ILogService)\n    ], OutputChannelBackedByFile);\n    let DelegatedOutputChannelModel = class DelegatedOutputChannelModel extends lifecycle_1.Disposable {\n        constructor(id, modelUri, mimeType, outputDir, instantiationService, logService, telemetryService) {\n            super();\n            this.instantiationService = instantiationService;\n            this.logService = logService;\n            this.telemetryService = telemetryService;\n            this._onDidAppendedContent = this._register(new event_1.Emitter());\n            this.onDidAppendedContent = this._onDidAppendedContent.event;\n            this._onDispose = this._register(new event_1.Emitter());\n            this.onDispose = this._onDispose.event;\n            this.outputChannelModel = this.createOutputChannelModel(id, modelUri, mimeType, outputDir);\n        }\n        createOutputChannelModel(id, modelUri, mimeType, outputDirPromise) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let outputChannelModel;\n                try {\n                    const outputDir = yield outputDirPromise;\n                    const file = resources.joinPath(outputDir, `${id}.log`);\n                    outputChannelModel = this.instantiationService.createInstance(OutputChannelBackedByFile, id, modelUri, mimeType, file);\n                }\n                catch (e) {\n                    // Do not crash if spdlog rotating logger cannot be loaded (workaround for https://github.com/Microsoft/vscode/issues/47883)\n                    this.logService.error(e);\n                    /* __GDPR__\n                        \"output.channel.creation.error\" : {}\n                    */\n                    this.telemetryService.publicLog('output.channel.creation.error');\n                    outputChannelModel = this.instantiationService.createInstance(outputChannelModel_1.BufferredOutputChannel, modelUri, mimeType);\n                }\n                this._register(outputChannelModel);\n                this._register(outputChannelModel.onDidAppendedContent(() => this._onDidAppendedContent.fire()));\n                this._register(outputChannelModel.onDispose(() => this._onDispose.fire()));\n                return outputChannelModel;\n            });\n        }\n        append(output) {\n            this.outputChannelModel.then(outputChannelModel => outputChannelModel.append(output));\n        }\n        update() {\n            this.outputChannelModel.then(outputChannelModel => outputChannelModel.update());\n        }\n        loadModel() {\n            return this.outputChannelModel.then(outputChannelModel => outputChannelModel.loadModel());\n        }\n        clear(till) {\n            this.outputChannelModel.then(outputChannelModel => outputChannelModel.clear(till));\n        }\n    };\n    DelegatedOutputChannelModel = __decorate([\n        __param(4, instantiation_1.IInstantiationService),\n        __param(5, log_1.ILogService),\n        __param(6, telemetry_1.ITelemetryService)\n    ], DelegatedOutputChannelModel);\n    let OutputChannelModelService = class OutputChannelModelService extends outputChannelModel_1.AsbtractOutputChannelModelService {\n        constructor(instantiationService, environmentService, windowService, fileService) {\n            super(instantiationService);\n            this.environmentService = environmentService;\n            this.windowService = windowService;\n            this.fileService = fileService;\n        }\n        createOutputChannelModel(id, modelUri, mimeType, file) {\n            return file ? super.createOutputChannelModel(id, modelUri, mimeType, file) :\n                this.instantiationService.createInstance(DelegatedOutputChannelModel, id, modelUri, mimeType, this.outputDir);\n        }\n        get outputDir() {\n            if (!this._outputDir) {\n                const outputDir = uri_1.URI.file(path_1.join(this.environmentService.logsPath, `output_${this.windowService.getCurrentWindowId()}_${date_1.toLocalISOString(new Date()).replace(/-|:|\\.\\d+Z$/g, '')}`));\n                this._outputDir = this.fileService.createFolder(outputDir).then(() => outputDir);\n            }\n            return this._outputDir;\n        }\n    };\n    OutputChannelModelService = __decorate([\n        __param(0, instantiation_1.IInstantiationService),\n        __param(1, environment_1.IEnvironmentService),\n        __param(2, windows_1.IWindowService),\n        __param(3, files_1.IFileService)\n    ], OutputChannelModelService);\n    exports.OutputChannelModelService = OutputChannelModelService;\n    extensions_1.registerSingleton(outputChannelModel_1.IOutputChannelModelService, OutputChannelModelService);\n});\n",null]}