{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/format/format.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/format/format.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar aria_1 = require(\"vs/base/browser/ui/aria/aria\");\nvar arrays_1 = require(\"vs/base/common/arrays\");\nvar cancellation_1 = require(\"vs/base/common/cancellation\");\nvar errors_1 = require(\"vs/base/common/errors\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar editorState_1 = require(\"vs/editor/browser/core/editorState\");\nvar editorBrowser_1 = require(\"vs/editor/browser/editorBrowser\");\nvar editorExtensions_1 = require(\"vs/editor/browser/editorExtensions\");\nvar position_1 = require(\"vs/editor/common/core/position\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar selection_1 = require(\"vs/editor/common/core/selection\");\nvar editorCommon = require(\"vs/editor/common/editorCommon\");\nvar modes_1 = require(\"vs/editor/common/modes\");\nvar editorWorkerService_1 = require(\"vs/editor/common/services/editorWorkerService\");\nvar modelService_1 = require(\"vs/editor/common/services/modelService\");\nvar formattingEdit_1 = require(\"vs/editor/contrib/format/formattingEdit\");\nvar nls = require(\"vs/nls\");\nvar extensions_1 = require(\"vs/platform/extensions/common/extensions\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar linkedList_1 = require(\"vs/base/common/linkedList\");\nfunction alertFormattingEdits(edits) {\n    edits = edits.filter(function (edit) { return edit.range; });\n    if (!edits.length) {\n        return;\n    }\n    var range = edits[0].range;\n    for (var i = 1; i < edits.length; i++) {\n        range = range_1.Range.plusRange(range, edits[i].range);\n    }\n    var startLineNumber = range.startLineNumber, endLineNumber = range.endLineNumber;\n    if (startLineNumber === endLineNumber) {\n        if (edits.length === 1) {\n            aria_1.alert(nls.localize('hint11', \"Made 1 formatting edit on line {0}\", startLineNumber));\n        }\n        else {\n            aria_1.alert(nls.localize('hintn1', \"Made {0} formatting edits on line {1}\", edits.length, startLineNumber));\n        }\n    }\n    else {\n        if (edits.length === 1) {\n            aria_1.alert(nls.localize('hint1n', \"Made 1 formatting edit between lines {0} and {1}\", startLineNumber, endLineNumber));\n        }\n        else {\n            aria_1.alert(nls.localize('hintnn', \"Made {0} formatting edits between lines {1} and {2}\", edits.length, startLineNumber, endLineNumber));\n        }\n    }\n}\nexports.alertFormattingEdits = alertFormattingEdits;\nfunction getRealAndSyntheticDocumentFormattersOrdered(model) {\n    var result = [];\n    var seen = new Set();\n    // (1) add all document formatter\n    var docFormatter = modes_1.DocumentFormattingEditProviderRegistry.ordered(model);\n    for (var _i = 0, docFormatter_1 = docFormatter; _i < docFormatter_1.length; _i++) {\n        var formatter = docFormatter_1[_i];\n        result.push(formatter);\n        if (formatter.extensionId) {\n            seen.add(extensions_1.ExtensionIdentifier.toKey(formatter.extensionId));\n        }\n    }\n    // (2) add all range formatter as document formatter (unless the same extension already did that)\n    var rangeFormatter = modes_1.DocumentRangeFormattingEditProviderRegistry.ordered(model);\n    var _loop_1 = function (formatter) {\n        if (formatter.extensionId) {\n            if (seen.has(extensions_1.ExtensionIdentifier.toKey(formatter.extensionId))) {\n                return \"continue\";\n            }\n            seen.add(extensions_1.ExtensionIdentifier.toKey(formatter.extensionId));\n        }\n        result.push({\n            displayName: formatter.displayName,\n            extensionId: formatter.extensionId,\n            provideDocumentFormattingEdits: function (model, options, token) {\n                return formatter.provideDocumentRangeFormattingEdits(model, model.getFullModelRange(), options, token);\n            }\n        });\n    };\n    for (var _a = 0, rangeFormatter_1 = rangeFormatter; _a < rangeFormatter_1.length; _a++) {\n        var formatter = rangeFormatter_1[_a];\n        _loop_1(formatter);\n    }\n    return result;\n}\nexports.getRealAndSyntheticDocumentFormattersOrdered = getRealAndSyntheticDocumentFormattersOrdered;\nvar FormattingMode;\n(function (FormattingMode) {\n    FormattingMode[FormattingMode[\"Explicit\"] = 1] = \"Explicit\";\n    FormattingMode[FormattingMode[\"Silent\"] = 2] = \"Silent\";\n})(FormattingMode = exports.FormattingMode || (exports.FormattingMode = {}));\nvar FormattingConflicts = /** @class */ (function () {\n    function FormattingConflicts() {\n    }\n    FormattingConflicts.setFormatterSelector = function (selector) {\n        var remove = FormattingConflicts._selectors.unshift(selector);\n        return { dispose: remove };\n    };\n    FormattingConflicts.select = function (formatter, document, mode) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var selector;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (formatter.length === 0) {\n                            return [2 /*return*/, undefined];\n                        }\n                        selector = FormattingConflicts._selectors.iterator().next().value;\n                        if (!selector) return [3 /*break*/, 2];\n                        return [4 /*yield*/, selector(formatter, document, mode)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2: return [2 /*return*/, formatter[0]];\n                }\n            });\n        });\n    };\n    FormattingConflicts._selectors = new linkedList_1.LinkedList();\n    return FormattingConflicts;\n}());\nexports.FormattingConflicts = FormattingConflicts;\nfunction formatDocumentRangeWithSelectedProvider(accessor, editorOrModel, range, mode, token) {\n    return tslib_1.__awaiter(this, void 0, Promise, function () {\n        var instaService, model, provider, selected;\n        return tslib_1.__generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    instaService = accessor.get(instantiation_1.IInstantiationService);\n                    model = editorBrowser_1.isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n                    provider = modes_1.DocumentRangeFormattingEditProviderRegistry.ordered(model);\n                    return [4 /*yield*/, FormattingConflicts.select(provider, model, mode)];\n                case 1:\n                    selected = _a.sent();\n                    if (!selected) return [3 /*break*/, 3];\n                    return [4 /*yield*/, instaService.invokeFunction(formatDocumentRangeWithProvider, selected, editorOrModel, range, token)];\n                case 2:\n                    _a.sent();\n                    _a.label = 3;\n                case 3: return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.formatDocumentRangeWithSelectedProvider = formatDocumentRangeWithSelectedProvider;\nfunction formatDocumentRangeWithProvider(accessor, provider, editorOrModel, range, token) {\n    return tslib_1.__awaiter(this, void 0, Promise, function () {\n        var workerService, model, validate, state_1, versionNow_1, rawEdits, edits, range_2, initialSelection_1;\n        return tslib_1.__generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    workerService = accessor.get(editorWorkerService_1.IEditorWorkerService);\n                    if (editorBrowser_1.isCodeEditor(editorOrModel)) {\n                        model = editorOrModel.getModel();\n                        state_1 = new editorState_1.EditorState(editorOrModel, editorState_1.CodeEditorStateFlag.Value | editorState_1.CodeEditorStateFlag.Position);\n                        validate = function () { return state_1.validate(editorOrModel); };\n                    }\n                    else {\n                        model = editorOrModel;\n                        versionNow_1 = editorOrModel.getVersionId();\n                        validate = function () { return versionNow_1 === editorOrModel.getVersionId(); };\n                    }\n                    return [4 /*yield*/, provider.provideDocumentRangeFormattingEdits(model, range, model.getFormattingOptions(), token)];\n                case 1:\n                    rawEdits = _a.sent();\n                    return [4 /*yield*/, workerService.computeMoreMinimalEdits(model.uri, rawEdits)];\n                case 2:\n                    edits = _a.sent();\n                    if (!validate()) {\n                        return [2 /*return*/, true];\n                    }\n                    if (!edits || edits.length === 0) {\n                        return [2 /*return*/, false];\n                    }\n                    if (editorBrowser_1.isCodeEditor(editorOrModel)) {\n                        // use editor to apply edits\n                        formattingEdit_1.FormattingEdit.execute(editorOrModel, edits);\n                        alertFormattingEdits(edits);\n                        editorOrModel.pushUndoStop();\n                        editorOrModel.focus();\n                        editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), editorCommon.ScrollType.Immediate);\n                    }\n                    else {\n                        range_2 = edits[0].range;\n                        initialSelection_1 = new selection_1.Selection(range_2.startLineNumber, range_2.startColumn, range_2.endLineNumber, range_2.endColumn);\n                        model.pushEditOperations([initialSelection_1], edits.map(function (edit) {\n                            return {\n                                text: edit.text,\n                                range: range_1.Range.lift(edit.range),\n                                forceMoveMarkers: true\n                            };\n                        }), function (undoEdits) {\n                            for (var _i = 0, undoEdits_1 = undoEdits; _i < undoEdits_1.length; _i++) {\n                                var range_3 = undoEdits_1[_i].range;\n                                if (range_1.Range.areIntersectingOrTouching(range_3, initialSelection_1)) {\n                                    return [new selection_1.Selection(range_3.startLineNumber, range_3.startColumn, range_3.endLineNumber, range_3.endColumn)];\n                                }\n                            }\n                            return null;\n                        });\n                    }\n                    return [2 /*return*/, true];\n            }\n        });\n    });\n}\nexports.formatDocumentRangeWithProvider = formatDocumentRangeWithProvider;\nfunction formatDocumentWithSelectedProvider(accessor, editorOrModel, mode, token) {\n    return tslib_1.__awaiter(this, void 0, Promise, function () {\n        var instaService, model, provider, selected;\n        return tslib_1.__generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    instaService = accessor.get(instantiation_1.IInstantiationService);\n                    model = editorBrowser_1.isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n                    provider = getRealAndSyntheticDocumentFormattersOrdered(model);\n                    return [4 /*yield*/, FormattingConflicts.select(provider, model, mode)];\n                case 1:\n                    selected = _a.sent();\n                    if (!selected) return [3 /*break*/, 3];\n                    return [4 /*yield*/, instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token)];\n                case 2:\n                    _a.sent();\n                    _a.label = 3;\n                case 3: return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.formatDocumentWithSelectedProvider = formatDocumentWithSelectedProvider;\nfunction formatDocumentWithProvider(accessor, provider, editorOrModel, mode, token) {\n    return tslib_1.__awaiter(this, void 0, Promise, function () {\n        var workerService, model, validate, state_2, versionNow_2, rawEdits, edits, range, initialSelection_2;\n        return tslib_1.__generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    workerService = accessor.get(editorWorkerService_1.IEditorWorkerService);\n                    if (editorBrowser_1.isCodeEditor(editorOrModel)) {\n                        model = editorOrModel.getModel();\n                        state_2 = new editorState_1.EditorState(editorOrModel, editorState_1.CodeEditorStateFlag.Value | editorState_1.CodeEditorStateFlag.Position);\n                        validate = function () { return state_2.validate(editorOrModel); };\n                    }\n                    else {\n                        model = editorOrModel;\n                        versionNow_2 = editorOrModel.getVersionId();\n                        validate = function () { return versionNow_2 === editorOrModel.getVersionId(); };\n                    }\n                    return [4 /*yield*/, provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), token)];\n                case 1:\n                    rawEdits = _a.sent();\n                    return [4 /*yield*/, workerService.computeMoreMinimalEdits(model.uri, rawEdits)];\n                case 2:\n                    edits = _a.sent();\n                    if (!validate()) {\n                        return [2 /*return*/, true];\n                    }\n                    if (!edits || edits.length === 0) {\n                        return [2 /*return*/, false];\n                    }\n                    if (editorBrowser_1.isCodeEditor(editorOrModel)) {\n                        // use editor to apply edits\n                        formattingEdit_1.FormattingEdit.execute(editorOrModel, edits);\n                        if (mode !== FormattingMode.Silent) {\n                            alertFormattingEdits(edits);\n                            editorOrModel.pushUndoStop();\n                            editorOrModel.focus();\n                            editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), editorCommon.ScrollType.Immediate);\n                        }\n                    }\n                    else {\n                        range = edits[0].range;\n                        initialSelection_2 = new selection_1.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                        model.pushEditOperations([initialSelection_2], edits.map(function (edit) {\n                            return {\n                                text: edit.text,\n                                range: range_1.Range.lift(edit.range),\n                                forceMoveMarkers: true\n                            };\n                        }), function (undoEdits) {\n                            for (var _i = 0, undoEdits_2 = undoEdits; _i < undoEdits_2.length; _i++) {\n                                var range_4 = undoEdits_2[_i].range;\n                                if (range_1.Range.areIntersectingOrTouching(range_4, initialSelection_2)) {\n                                    return [new selection_1.Selection(range_4.startLineNumber, range_4.startColumn, range_4.endLineNumber, range_4.endColumn)];\n                                }\n                            }\n                            return null;\n                        });\n                    }\n                    return [2 /*return*/, true];\n            }\n        });\n    });\n}\nexports.formatDocumentWithProvider = formatDocumentWithProvider;\nfunction getDocumentRangeFormattingEditsUntilResult(workerService, model, range, options, token) {\n    return tslib_1.__awaiter(this, void 0, Promise, function () {\n        var providers, _i, providers_1, provider, rawEdits;\n        return tslib_1.__generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    providers = modes_1.DocumentRangeFormattingEditProviderRegistry.ordered(model);\n                    _i = 0, providers_1 = providers;\n                    _a.label = 1;\n                case 1:\n                    if (!(_i < providers_1.length)) return [3 /*break*/, 5];\n                    provider = providers_1[_i];\n                    return [4 /*yield*/, Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(errors_1.onUnexpectedExternalError)];\n                case 2:\n                    rawEdits = _a.sent();\n                    if (!arrays_1.isNonEmptyArray(rawEdits)) return [3 /*break*/, 4];\n                    return [4 /*yield*/, workerService.computeMoreMinimalEdits(model.uri, rawEdits)];\n                case 3: return [2 /*return*/, _a.sent()];\n                case 4:\n                    _i++;\n                    return [3 /*break*/, 1];\n                case 5: return [2 /*return*/, undefined];\n            }\n        });\n    });\n}\nexports.getDocumentRangeFormattingEditsUntilResult = getDocumentRangeFormattingEditsUntilResult;\nfunction getDocumentFormattingEditsUntilResult(workerService, model, options, token) {\n    return tslib_1.__awaiter(this, void 0, Promise, function () {\n        var providers, _i, providers_2, provider, rawEdits;\n        return tslib_1.__generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    providers = getRealAndSyntheticDocumentFormattersOrdered(model);\n                    _i = 0, providers_2 = providers;\n                    _a.label = 1;\n                case 1:\n                    if (!(_i < providers_2.length)) return [3 /*break*/, 5];\n                    provider = providers_2[_i];\n                    return [4 /*yield*/, Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(errors_1.onUnexpectedExternalError)];\n                case 2:\n                    rawEdits = _a.sent();\n                    if (!arrays_1.isNonEmptyArray(rawEdits)) return [3 /*break*/, 4];\n                    return [4 /*yield*/, workerService.computeMoreMinimalEdits(model.uri, rawEdits)];\n                case 3: return [2 /*return*/, _a.sent()];\n                case 4:\n                    _i++;\n                    return [3 /*break*/, 1];\n                case 5: return [2 /*return*/, undefined];\n            }\n        });\n    });\n}\nexports.getDocumentFormattingEditsUntilResult = getDocumentFormattingEditsUntilResult;\nfunction getOnTypeFormattingEdits(workerService, model, position, ch, options) {\n    var providers = modes_1.OnTypeFormattingEditProviderRegistry.ordered(model);\n    if (providers.length === 0) {\n        return Promise.resolve(undefined);\n    }\n    if (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {\n        return Promise.resolve(undefined);\n    }\n    return Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, cancellation_1.CancellationToken.None)).catch(errors_1.onUnexpectedExternalError).then(function (edits) {\n        return workerService.computeMoreMinimalEdits(model.uri, edits);\n    });\n}\nexports.getOnTypeFormattingEdits = getOnTypeFormattingEdits;\neditorExtensions_1.registerLanguageCommand('_executeFormatRangeProvider', function (accessor, args) {\n    var resource = args.resource, range = args.range, options = args.options;\n    if (!(resource instanceof uri_1.URI) || !range_1.Range.isIRange(range)) {\n        throw errors_1.illegalArgument();\n    }\n    var model = accessor.get(modelService_1.IModelService).getModel(resource);\n    if (!model) {\n        throw errors_1.illegalArgument('resource');\n    }\n    return getDocumentRangeFormattingEditsUntilResult(accessor.get(editorWorkerService_1.IEditorWorkerService), model, range_1.Range.lift(range), options, cancellation_1.CancellationToken.None);\n});\neditorExtensions_1.registerLanguageCommand('_executeFormatDocumentProvider', function (accessor, args) {\n    var resource = args.resource, options = args.options;\n    if (!(resource instanceof uri_1.URI)) {\n        throw errors_1.illegalArgument('resource');\n    }\n    var model = accessor.get(modelService_1.IModelService).getModel(resource);\n    if (!model) {\n        throw errors_1.illegalArgument('resource');\n    }\n    return getDocumentFormattingEditsUntilResult(accessor.get(editorWorkerService_1.IEditorWorkerService), model, options, cancellation_1.CancellationToken.None);\n});\neditorExtensions_1.registerLanguageCommand('_executeFormatOnTypeProvider', function (accessor, args) {\n    var resource = args.resource, position = args.position, ch = args.ch, options = args.options;\n    if (!(resource instanceof uri_1.URI) || !position_1.Position.isIPosition(position) || typeof ch !== 'string') {\n        throw errors_1.illegalArgument();\n    }\n    var model = accessor.get(modelService_1.IModelService).getModel(resource);\n    if (!model) {\n        throw errors_1.illegalArgument('resource');\n    }\n    return getOnTypeFormattingEdits(accessor.get(editorWorkerService_1.IEditorWorkerService), model, position_1.Position.lift(position), ch, options);\n});\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/format/format.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/contrib/format/format.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { alert } from 'vs/base/browser/ui/aria/aria';\nimport { isNonEmptyArray } from 'vs/base/common/arrays';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { illegalArgument, onUnexpectedExternalError } from 'vs/base/common/errors';\nimport { URI } from 'vs/base/common/uri';\nimport { CodeEditorStateFlag, EditorState } from 'vs/editor/browser/core/editorState';\nimport { IActiveCodeEditor, isCodeEditor } from 'vs/editor/browser/editorBrowser';\nimport { registerLanguageCommand, ServicesAccessor } from 'vs/editor/browser/editorExtensions';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { Selection } from 'vs/editor/common/core/selection';\nimport * as editorCommon from 'vs/editor/common/editorCommon';\nimport { ISingleEditOperation, ITextModel } from 'vs/editor/common/model';\nimport { DocumentFormattingEditProvider, DocumentFormattingEditProviderRegistry, DocumentRangeFormattingEditProvider, DocumentRangeFormattingEditProviderRegistry, FormattingOptions, OnTypeFormattingEditProviderRegistry, TextEdit } from 'vs/editor/common/modes';\nimport { IEditorWorkerService } from 'vs/editor/common/services/editorWorkerService';\nimport { IModelService } from 'vs/editor/common/services/modelService';\nimport { FormattingEdit } from 'vs/editor/contrib/format/formattingEdit';\nimport * as nls from 'vs/nls';\nimport { ExtensionIdentifier } from 'vs/platform/extensions/common/extensions';\nimport { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { LinkedList } from 'vs/base/common/linkedList';\n\nexport function alertFormattingEdits(edits: ISingleEditOperation[]): void {\n\n\tedits = edits.filter(edit => edit.range);\n\tif (!edits.length) {\n\t\treturn;\n\t}\n\n\tlet { range } = edits[0];\n\tfor (let i = 1; i < edits.length; i++) {\n\t\trange = Range.plusRange(range, edits[i].range);\n\t}\n\tconst { startLineNumber, endLineNumber } = range;\n\tif (startLineNumber === endLineNumber) {\n\t\tif (edits.length === 1) {\n\t\t\talert(nls.localize('hint11', \"Made 1 formatting edit on line {0}\", startLineNumber));\n\t\t} else {\n\t\t\talert(nls.localize('hintn1', \"Made {0} formatting edits on line {1}\", edits.length, startLineNumber));\n\t\t}\n\t} else {\n\t\tif (edits.length === 1) {\n\t\t\talert(nls.localize('hint1n', \"Made 1 formatting edit between lines {0} and {1}\", startLineNumber, endLineNumber));\n\t\t} else {\n\t\t\talert(nls.localize('hintnn', \"Made {0} formatting edits between lines {1} and {2}\", edits.length, startLineNumber, endLineNumber));\n\t\t}\n\t}\n}\n\nexport function getRealAndSyntheticDocumentFormattersOrdered(model: ITextModel): DocumentFormattingEditProvider[] {\n\tconst result: DocumentFormattingEditProvider[] = [];\n\tconst seen = new Set<string>();\n\n\t// (1) add all document formatter\n\tconst docFormatter = DocumentFormattingEditProviderRegistry.ordered(model);\n\tfor (const formatter of docFormatter) {\n\t\tresult.push(formatter);\n\t\tif (formatter.extensionId) {\n\t\t\tseen.add(ExtensionIdentifier.toKey(formatter.extensionId));\n\t\t}\n\t}\n\n\t// (2) add all range formatter as document formatter (unless the same extension already did that)\n\tconst rangeFormatter = DocumentRangeFormattingEditProviderRegistry.ordered(model);\n\tfor (const formatter of rangeFormatter) {\n\t\tif (formatter.extensionId) {\n\t\t\tif (seen.has(ExtensionIdentifier.toKey(formatter.extensionId))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tseen.add(ExtensionIdentifier.toKey(formatter.extensionId));\n\t\t}\n\t\tresult.push({\n\t\t\tdisplayName: formatter.displayName,\n\t\t\textensionId: formatter.extensionId,\n\t\t\tprovideDocumentFormattingEdits(model, options, token) {\n\t\t\t\treturn formatter.provideDocumentRangeFormattingEdits(model, model.getFullModelRange(), options, token);\n\t\t\t}\n\t\t});\n\t}\n\treturn result;\n}\n\nexport const enum FormattingMode {\n\tExplicit = 1,\n\tSilent = 2\n}\n\nexport interface IFormattingEditProviderSelector {\n\t<T extends (DocumentFormattingEditProvider | DocumentRangeFormattingEditProvider)>(formatter: T[], document: ITextModel, mode: FormattingMode): Promise<T | undefined>;\n}\n\nexport abstract class FormattingConflicts {\n\n\tprivate static readonly _selectors = new LinkedList<IFormattingEditProviderSelector>();\n\n\tstatic setFormatterSelector(selector: IFormattingEditProviderSelector): IDisposable {\n\t\tconst remove = FormattingConflicts._selectors.unshift(selector);\n\t\treturn { dispose: remove };\n\t}\n\n\tstatic async select<T extends (DocumentFormattingEditProvider | DocumentRangeFormattingEditProvider)>(formatter: T[], document: ITextModel, mode: FormattingMode): Promise<T | undefined> {\n\t\tif (formatter.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst { value: selector } = FormattingConflicts._selectors.iterator().next();\n\t\tif (selector) {\n\t\t\treturn await selector(formatter, document, mode);\n\t\t}\n\t\treturn formatter[0];\n\t}\n}\n\nexport async function formatDocumentRangeWithSelectedProvider(\n\taccessor: ServicesAccessor,\n\teditorOrModel: ITextModel | IActiveCodeEditor,\n\trange: Range,\n\tmode: FormattingMode,\n\ttoken: CancellationToken\n): Promise<void> {\n\n\tconst instaService = accessor.get(IInstantiationService);\n\tconst model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n\tconst provider = DocumentRangeFormattingEditProviderRegistry.ordered(model);\n\tconst selected = await FormattingConflicts.select(provider, model, mode);\n\tif (selected) {\n\t\tawait instaService.invokeFunction(formatDocumentRangeWithProvider, selected, editorOrModel, range, token);\n\t}\n}\n\nexport async function formatDocumentRangeWithProvider(\n\taccessor: ServicesAccessor,\n\tprovider: DocumentRangeFormattingEditProvider,\n\teditorOrModel: ITextModel | IActiveCodeEditor,\n\trange: Range,\n\ttoken: CancellationToken\n): Promise<boolean> {\n\tconst workerService = accessor.get(IEditorWorkerService);\n\n\tlet model: ITextModel;\n\tlet validate: () => boolean;\n\tif (isCodeEditor(editorOrModel)) {\n\t\tmodel = editorOrModel.getModel();\n\t\tconst state = new EditorState(editorOrModel, CodeEditorStateFlag.Value | CodeEditorStateFlag.Position);\n\t\tvalidate = () => state.validate(editorOrModel);\n\t} else {\n\t\tmodel = editorOrModel;\n\t\tconst versionNow = editorOrModel.getVersionId();\n\t\tvalidate = () => versionNow === editorOrModel.getVersionId();\n\t}\n\n\tconst rawEdits = await provider.provideDocumentRangeFormattingEdits(\n\t\tmodel,\n\t\trange,\n\t\tmodel.getFormattingOptions(),\n\t\ttoken\n\t);\n\n\tconst edits = await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n\n\tif (!validate()) {\n\t\treturn true;\n\t}\n\n\tif (!edits || edits.length === 0) {\n\t\treturn false;\n\t}\n\n\tif (isCodeEditor(editorOrModel)) {\n\t\t// use editor to apply edits\n\t\tFormattingEdit.execute(editorOrModel, edits);\n\t\talertFormattingEdits(edits);\n\t\teditorOrModel.pushUndoStop();\n\t\teditorOrModel.focus();\n\t\teditorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), editorCommon.ScrollType.Immediate);\n\n\t} else {\n\t\t// use model to apply edits\n\t\tconst [{ range }] = edits;\n\t\tconst initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t\tmodel.pushEditOperations([initialSelection], edits.map(edit => {\n\t\t\treturn {\n\t\t\t\ttext: edit.text,\n\t\t\t\trange: Range.lift(edit.range),\n\t\t\t\tforceMoveMarkers: true\n\t\t\t};\n\t\t}), undoEdits => {\n\t\t\tfor (const { range } of undoEdits) {\n\t\t\t\tif (Range.areIntersectingOrTouching(range, initialSelection)) {\n\t\t\t\t\treturn [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}\n\n\treturn true;\n}\n\nexport async function formatDocumentWithSelectedProvider(\n\taccessor: ServicesAccessor,\n\teditorOrModel: ITextModel | IActiveCodeEditor,\n\tmode: FormattingMode,\n\ttoken: CancellationToken\n): Promise<void> {\n\n\tconst instaService = accessor.get(IInstantiationService);\n\tconst model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n\tconst provider = getRealAndSyntheticDocumentFormattersOrdered(model);\n\tconst selected = await FormattingConflicts.select(provider, model, mode);\n\tif (selected) {\n\t\tawait instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token);\n\t}\n}\n\nexport async function formatDocumentWithProvider(\n\taccessor: ServicesAccessor,\n\tprovider: DocumentFormattingEditProvider,\n\teditorOrModel: ITextModel | IActiveCodeEditor,\n\tmode: FormattingMode,\n\ttoken: CancellationToken\n): Promise<boolean> {\n\tconst workerService = accessor.get(IEditorWorkerService);\n\n\tlet model: ITextModel;\n\tlet validate: () => boolean;\n\tif (isCodeEditor(editorOrModel)) {\n\t\tmodel = editorOrModel.getModel();\n\t\tconst state = new EditorState(editorOrModel, CodeEditorStateFlag.Value | CodeEditorStateFlag.Position);\n\t\tvalidate = () => state.validate(editorOrModel);\n\t} else {\n\t\tmodel = editorOrModel;\n\t\tconst versionNow = editorOrModel.getVersionId();\n\t\tvalidate = () => versionNow === editorOrModel.getVersionId();\n\t}\n\n\tconst rawEdits = await provider.provideDocumentFormattingEdits(\n\t\tmodel,\n\t\tmodel.getFormattingOptions(),\n\t\ttoken\n\t);\n\n\tconst edits = await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n\n\tif (!validate()) {\n\t\treturn true;\n\t}\n\n\tif (!edits || edits.length === 0) {\n\t\treturn false;\n\t}\n\n\tif (isCodeEditor(editorOrModel)) {\n\t\t// use editor to apply edits\n\t\tFormattingEdit.execute(editorOrModel, edits);\n\n\t\tif (mode !== FormattingMode.Silent) {\n\t\t\talertFormattingEdits(edits);\n\t\t\teditorOrModel.pushUndoStop();\n\t\t\teditorOrModel.focus();\n\t\t\teditorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), editorCommon.ScrollType.Immediate);\n\t\t}\n\n\t} else {\n\t\t// use model to apply edits\n\t\tconst [{ range }] = edits;\n\t\tconst initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t\tmodel.pushEditOperations([initialSelection], edits.map(edit => {\n\t\t\treturn {\n\t\t\t\ttext: edit.text,\n\t\t\t\trange: Range.lift(edit.range),\n\t\t\t\tforceMoveMarkers: true\n\t\t\t};\n\t\t}), undoEdits => {\n\t\t\tfor (const { range } of undoEdits) {\n\t\t\t\tif (Range.areIntersectingOrTouching(range, initialSelection)) {\n\t\t\t\t\treturn [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}\n\n\treturn true;\n}\n\nexport async function getDocumentRangeFormattingEditsUntilResult(\n\tworkerService: IEditorWorkerService,\n\tmodel: ITextModel,\n\trange: Range,\n\toptions: FormattingOptions,\n\ttoken: CancellationToken\n): Promise<TextEdit[] | undefined> {\n\n\tconst providers = DocumentRangeFormattingEditProviderRegistry.ordered(model);\n\tfor (const provider of providers) {\n\t\tlet rawEdits = await Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(onUnexpectedExternalError);\n\t\tif (isNonEmptyArray(rawEdits)) {\n\t\t\treturn await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n\t\t}\n\t}\n\treturn undefined;\n}\n\nexport async function getDocumentFormattingEditsUntilResult(\n\tworkerService: IEditorWorkerService,\n\tmodel: ITextModel,\n\toptions: FormattingOptions,\n\ttoken: CancellationToken\n): Promise<TextEdit[] | undefined> {\n\n\tconst providers = getRealAndSyntheticDocumentFormattersOrdered(model);\n\tfor (const provider of providers) {\n\t\tlet rawEdits = await Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError);\n\t\tif (isNonEmptyArray(rawEdits)) {\n\t\t\treturn await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n\t\t}\n\t}\n\treturn undefined;\n}\n\nexport function getOnTypeFormattingEdits(\n\tworkerService: IEditorWorkerService,\n\tmodel: ITextModel,\n\tposition: Position,\n\tch: string,\n\toptions: FormattingOptions\n): Promise<TextEdit[] | null | undefined> {\n\n\tconst providers = OnTypeFormattingEditProviderRegistry.ordered(model);\n\n\tif (providers.length === 0) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\tif (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\treturn Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, CancellationToken.None)).catch(onUnexpectedExternalError).then(edits => {\n\t\treturn workerService.computeMoreMinimalEdits(model.uri, edits);\n\t});\n}\n\nregisterLanguageCommand('_executeFormatRangeProvider', function (accessor, args) {\n\tconst { resource, range, options } = args;\n\tif (!(resource instanceof URI) || !Range.isIRange(range)) {\n\t\tthrow illegalArgument();\n\t}\n\tconst model = accessor.get(IModelService).getModel(resource);\n\tif (!model) {\n\t\tthrow illegalArgument('resource');\n\t}\n\treturn getDocumentRangeFormattingEditsUntilResult(accessor.get(IEditorWorkerService), model, Range.lift(range), options, CancellationToken.None);\n});\n\nregisterLanguageCommand('_executeFormatDocumentProvider', function (accessor, args) {\n\tconst { resource, options } = args;\n\tif (!(resource instanceof URI)) {\n\t\tthrow illegalArgument('resource');\n\t}\n\tconst model = accessor.get(IModelService).getModel(resource);\n\tif (!model) {\n\t\tthrow illegalArgument('resource');\n\t}\n\n\treturn getDocumentFormattingEditsUntilResult(accessor.get(IEditorWorkerService), model, options, CancellationToken.None);\n});\n\nregisterLanguageCommand('_executeFormatOnTypeProvider', function (accessor, args) {\n\tconst { resource, position, ch, options } = args;\n\tif (!(resource instanceof URI) || !Position.isIPosition(position) || typeof ch !== 'string') {\n\t\tthrow illegalArgument();\n\t}\n\tconst model = accessor.get(IModelService).getModel(resource);\n\tif (!model) {\n\t\tthrow illegalArgument('resource');\n\t}\n\n\treturn getOnTypeFormattingEdits(accessor.get(IEditorWorkerService), model, Position.lift(position), ch, options);\n});\n"]}]}