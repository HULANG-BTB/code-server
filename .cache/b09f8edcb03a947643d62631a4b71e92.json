{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/platform/lifecycle/common/lifecycle.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/lifecycle/common/lifecycle.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar event_1 = require(\"vs/base/common/event\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar async_1 = require(\"vs/base/common/async\");\nexports.ILifecycleService = instantiation_1.createDecorator('lifecycleService');\nvar ShutdownReason;\n(function (ShutdownReason) {\n    /** Window is closed */\n    ShutdownReason[ShutdownReason[\"CLOSE\"] = 1] = \"CLOSE\";\n    /** Application is quit */\n    ShutdownReason[ShutdownReason[\"QUIT\"] = 2] = \"QUIT\";\n    /** Window is reloaded */\n    ShutdownReason[ShutdownReason[\"RELOAD\"] = 3] = \"RELOAD\";\n    /** Other configuration loaded into window */\n    ShutdownReason[ShutdownReason[\"LOAD\"] = 4] = \"LOAD\";\n})(ShutdownReason = exports.ShutdownReason || (exports.ShutdownReason = {}));\nvar StartupKind;\n(function (StartupKind) {\n    StartupKind[StartupKind[\"NewWindow\"] = 1] = \"NewWindow\";\n    StartupKind[StartupKind[\"ReloadedWindow\"] = 3] = \"ReloadedWindow\";\n    StartupKind[StartupKind[\"ReopenedWindow\"] = 4] = \"ReopenedWindow\";\n})(StartupKind = exports.StartupKind || (exports.StartupKind = {}));\nfunction StartupKindToString(startupKind) {\n    switch (startupKind) {\n        case StartupKind.NewWindow: return 'NewWindow';\n        case StartupKind.ReloadedWindow: return 'ReloadedWindow';\n        case StartupKind.ReopenedWindow: return 'ReopenedWindow';\n    }\n}\nexports.StartupKindToString = StartupKindToString;\nvar LifecyclePhase;\n(function (LifecyclePhase) {\n    /**\n     * The first phase signals that we are about to startup getting ready.\n     */\n    LifecyclePhase[LifecyclePhase[\"Starting\"] = 1] = \"Starting\";\n    /**\n     * Services are ready and the view is about to restore its state.\n     */\n    LifecyclePhase[LifecyclePhase[\"Ready\"] = 2] = \"Ready\";\n    /**\n     * Views, panels and editors have restored. For editors this means, that\n     * they show their contents fully.\n     */\n    LifecyclePhase[LifecyclePhase[\"Restored\"] = 3] = \"Restored\";\n    /**\n     * The last phase after views, panels and editors have restored and\n     * some time has passed (few seconds).\n     */\n    LifecyclePhase[LifecyclePhase[\"Eventually\"] = 4] = \"Eventually\";\n})(LifecyclePhase = exports.LifecyclePhase || (exports.LifecyclePhase = {}));\nfunction LifecyclePhaseToString(phase) {\n    switch (phase) {\n        case LifecyclePhase.Starting: return 'Starting';\n        case LifecyclePhase.Ready: return 'Ready';\n        case LifecyclePhase.Restored: return 'Restored';\n        case LifecyclePhase.Eventually: return 'Eventually';\n    }\n}\nexports.LifecyclePhaseToString = LifecyclePhaseToString;\nexports.NullLifecycleService = {\n    _serviceBrand: null,\n    onBeforeShutdown: event_1.Event.None,\n    onWillShutdown: event_1.Event.None,\n    onShutdown: event_1.Event.None,\n    phase: LifecyclePhase.Restored,\n    startupKind: StartupKind.NewWindow,\n    when: function () { return Promise.resolve(); }\n};\n// Shared veto handling across main and renderer\nfunction handleVetos(vetos, onError) {\n    if (vetos.length === 0) {\n        return Promise.resolve(false);\n    }\n    var promises = [];\n    var lazyValue = false;\n    for (var _i = 0, vetos_1 = vetos; _i < vetos_1.length; _i++) {\n        var valueOrPromise = vetos_1[_i];\n        // veto, done\n        if (valueOrPromise === true) {\n            return Promise.resolve(true);\n        }\n        if (async_1.isThenable(valueOrPromise)) {\n            promises.push(valueOrPromise.then(function (value) {\n                if (value) {\n                    lazyValue = true; // veto, done\n                }\n            }, function (err) {\n                onError(err); // error, treated like a veto, done\n                lazyValue = true;\n            }));\n        }\n    }\n    return Promise.all(promises).then(function () { return lazyValue; });\n}\nexports.handleVetos = handleVetos;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/platform/lifecycle/common/lifecycle.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/platform/lifecycle/common/lifecycle.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { isThenable } from 'vs/base/common/async';\n\nexport const ILifecycleService = createDecorator<ILifecycleService>('lifecycleService');\n\n/**\n * An event that is send out when the window is about to close. Clients have a chance to veto\n * the closing by either calling veto with a boolean \"true\" directly or with a promise that\n * resolves to a boolean. Returning a promise is useful in cases of long running operations\n * on shutdown.\n *\n * Note: It is absolutely important to avoid long running promises if possible. Please try hard\n * to return a boolean directly. Returning a promise has quite an impact on the shutdown sequence!\n */\nexport interface BeforeShutdownEvent {\n\n\t/**\n\t * Allows to veto the shutdown. The veto can be a long running operation but it\n\t * will block the application from closing.\n\t */\n\tveto(value: boolean | Promise<boolean>): void;\n\n\t/**\n\t * The reason why the application will be shutting down.\n\t */\n\treason: ShutdownReason;\n}\n\n/**\n * An event that is send out when the window closes. Clients have a chance to join the closing\n * by providing a promise from the join method. Returning a promise is useful in cases of long\n * running operations on shutdown.\n *\n * Note: It is absolutely important to avoid long running promises if possible. Please try hard\n * to return a boolean directly. Returning a promise has quite an impact on the shutdown sequence!\n */\nexport interface WillShutdownEvent {\n\n\t/**\n\t * Allows to join the shutdown. The promise can be a long running operation but it\n\t * will block the application from closing.\n\t */\n\tjoin(promise: Promise<void>): void;\n\n\t/**\n\t * The reason why the application is shutting down.\n\t */\n\treason: ShutdownReason;\n}\n\nexport const enum ShutdownReason {\n\n\t/** Window is closed */\n\tCLOSE = 1,\n\n\t/** Application is quit */\n\tQUIT = 2,\n\n\t/** Window is reloaded */\n\tRELOAD = 3,\n\n\t/** Other configuration loaded into window */\n\tLOAD = 4\n}\n\nexport const enum StartupKind {\n\tNewWindow = 1,\n\tReloadedWindow = 3,\n\tReopenedWindow = 4,\n}\n\nexport function StartupKindToString(startupKind: StartupKind): string {\n\tswitch (startupKind) {\n\t\tcase StartupKind.NewWindow: return 'NewWindow';\n\t\tcase StartupKind.ReloadedWindow: return 'ReloadedWindow';\n\t\tcase StartupKind.ReopenedWindow: return 'ReopenedWindow';\n\t}\n}\n\nexport const enum LifecyclePhase {\n\n\t/**\n\t * The first phase signals that we are about to startup getting ready.\n\t */\n\tStarting = 1,\n\n\t/**\n\t * Services are ready and the view is about to restore its state.\n\t */\n\tReady = 2,\n\n\t/**\n\t * Views, panels and editors have restored. For editors this means, that\n\t * they show their contents fully.\n\t */\n\tRestored = 3,\n\n\t/**\n\t * The last phase after views, panels and editors have restored and\n\t * some time has passed (few seconds).\n\t */\n\tEventually = 4\n}\n\nexport function LifecyclePhaseToString(phase: LifecyclePhase) {\n\tswitch (phase) {\n\t\tcase LifecyclePhase.Starting: return 'Starting';\n\t\tcase LifecyclePhase.Ready: return 'Ready';\n\t\tcase LifecyclePhase.Restored: return 'Restored';\n\t\tcase LifecyclePhase.Eventually: return 'Eventually';\n\t}\n}\n\n/**\n * A lifecycle service informs about lifecycle events of the\n * application, such as shutdown.\n */\nexport interface ILifecycleService {\n\n\t_serviceBrand: any;\n\n\t/**\n\t * Value indicates how this window got loaded.\n\t */\n\treadonly startupKind: StartupKind;\n\n\t/**\n\t * A flag indicating in what phase of the lifecycle we currently are.\n\t */\n\tphase: LifecyclePhase;\n\n\t/**\n\t * Fired before shutdown happens. Allows listeners to veto against the\n\t * shutdown to prevent it from happening.\n\t *\n\t * The event carries a shutdown reason that indicates how the shutdown was triggered.\n\t */\n\treadonly onBeforeShutdown: Event<BeforeShutdownEvent>;\n\n\t/**\n\t * Fired when no client is preventing the shutdown from happening (from onBeforeShutdown).\n\t * Can be used to save UI state even if that is long running through the WillShutdownEvent#join()\n\t * method.\n\t *\n\t * The event carries a shutdown reason that indicates how the shutdown was triggered.\n\t */\n\treadonly onWillShutdown: Event<WillShutdownEvent>;\n\n\t/**\n\t * Fired when the shutdown is about to happen after long running shutdown operations\n\t * have finished (from onWillShutdown). This is the right place to dispose resources.\n\t */\n\treadonly onShutdown: Event<void>;\n\n\t/**\n\t * Returns a promise that resolves when a certain lifecycle phase\n\t * has started.\n\t */\n\twhen(phase: LifecyclePhase): Promise<void>;\n}\n\nexport const NullLifecycleService: ILifecycleService = {\n\t_serviceBrand: null,\n\tonBeforeShutdown: Event.None,\n\tonWillShutdown: Event.None,\n\tonShutdown: Event.None,\n\tphase: LifecyclePhase.Restored,\n\tstartupKind: StartupKind.NewWindow,\n\twhen() { return Promise.resolve(); }\n};\n\n// Shared veto handling across main and renderer\nexport function handleVetos(vetos: (boolean | Promise<boolean>)[], onError: (error: Error) => void): Promise<boolean /* veto */> {\n\tif (vetos.length === 0) {\n\t\treturn Promise.resolve(false);\n\t}\n\n\tconst promises: Promise<void>[] = [];\n\tlet lazyValue = false;\n\n\tfor (let valueOrPromise of vetos) {\n\n\t\t// veto, done\n\t\tif (valueOrPromise === true) {\n\t\t\treturn Promise.resolve(true);\n\t\t}\n\n\t\tif (isThenable(valueOrPromise)) {\n\t\t\tpromises.push(valueOrPromise.then(value => {\n\t\t\t\tif (value) {\n\t\t\t\t\tlazyValue = true; // veto, done\n\t\t\t\t}\n\t\t\t}, err => {\n\t\t\t\tonError(err); // error, treated like a veto, done\n\t\t\t\tlazyValue = true;\n\t\t\t}));\n\t\t}\n\t}\n\n\treturn Promise.all(promises).then(() => lazyValue);\n}\n"]}]}