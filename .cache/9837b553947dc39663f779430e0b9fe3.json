{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/suggest/suggestModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/suggest/suggestModel.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/arrays\", \"vs/base/common/async\", \"vs/base/common/errors\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/editor/common/controller/cursorEvents\", \"vs/editor/common/core/selection\", \"vs/editor/common/modes\", \"./completionModel\", \"./suggest\", \"vs/editor/contrib/snippet/snippetController2\", \"vs/base/common/cancellation\", \"vs/editor/contrib/suggest/wordDistance\"], function (require, exports, arrays_1, async_1, errors_1, event_1, lifecycle_1, cursorEvents_1, selection_1, modes_1, completionModel_1, suggest_1, snippetController2_1, cancellation_1, wordDistance_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class LineContext {\n        static shouldAutoTrigger(editor) {\n            if (!editor.hasModel()) {\n                return false;\n            }\n            const model = editor.getModel();\n            const pos = editor.getPosition();\n            model.tokenizeIfCheap(pos.lineNumber);\n            const word = model.getWordAtPosition(pos);\n            if (!word) {\n                return false;\n            }\n            if (word.endColumn !== pos.column) {\n                return false;\n            }\n            if (!isNaN(Number(word.word))) {\n                return false;\n            }\n            return true;\n        }\n        constructor(model, position, auto, shy) {\n            this.leadingLineContent = model.getLineContent(position.lineNumber).substr(0, position.column - 1);\n            this.leadingWord = model.getWordUntilPosition(position);\n            this.lineNumber = position.lineNumber;\n            this.column = position.column;\n            this.auto = auto;\n            this.shy = shy;\n        }\n    }\n    exports.LineContext = LineContext;\n    var State;\n    (function (State) {\n        State[State[\"Idle\"] = 0] = \"Idle\";\n        State[State[\"Manual\"] = 1] = \"Manual\";\n        State[State[\"Auto\"] = 2] = \"Auto\";\n    })(State = exports.State || (exports.State = {}));\n    class SuggestModel {\n        constructor(_editor, _editorWorker) {\n            this._editor = _editor;\n            this._editorWorker = _editorWorker;\n            this._toDispose = [];\n            this._triggerQuickSuggest = new async_1.TimeoutTimer();\n            this._triggerRefilter = new async_1.TimeoutTimer();\n            this._state = State.Idle;\n            this._onDidCancel = new event_1.Emitter();\n            this._onDidTrigger = new event_1.Emitter();\n            this._onDidSuggest = new event_1.Emitter();\n            this.onDidCancel = this._onDidCancel.event;\n            this.onDidTrigger = this._onDidTrigger.event;\n            this.onDidSuggest = this._onDidSuggest.event;\n            this._currentSelection = this._editor.getSelection() || new selection_1.Selection(1, 1, 1, 1);\n            // wire up various listeners\n            this._toDispose.push(this._editor.onDidChangeModel(() => {\n                this._updateTriggerCharacters();\n                this.cancel();\n            }));\n            this._toDispose.push(this._editor.onDidChangeModelLanguage(() => {\n                this._updateTriggerCharacters();\n                this.cancel();\n            }));\n            this._toDispose.push(this._editor.onDidChangeConfiguration(() => {\n                this._updateTriggerCharacters();\n                this._updateQuickSuggest();\n            }));\n            this._toDispose.push(modes_1.CompletionProviderRegistry.onDidChange(() => {\n                this._updateTriggerCharacters();\n                this._updateActiveSuggestSession();\n            }));\n            this._toDispose.push(this._editor.onDidChangeCursorSelection(e => {\n                this._onCursorChange(e);\n            }));\n            let editorIsComposing = false;\n            this._toDispose.push(this._editor.onCompositionStart(() => {\n                editorIsComposing = true;\n            }));\n            this._toDispose.push(this._editor.onCompositionEnd(() => {\n                // refilter when composition ends\n                editorIsComposing = false;\n                this._refilterCompletionItems();\n            }));\n            this._toDispose.push(this._editor.onDidChangeModelContent(() => {\n                // only filter completions when the editor isn't\n                // composing a character, e.g. ¨ + u makes ü but just\n                // ¨ cannot be used for filtering\n                if (!editorIsComposing) {\n                    this._refilterCompletionItems();\n                }\n            }));\n            this._updateTriggerCharacters();\n            this._updateQuickSuggest();\n        }\n        dispose() {\n            lifecycle_1.dispose([this._onDidCancel, this._onDidSuggest, this._onDidTrigger, this._triggerCharacterListener, this._triggerQuickSuggest, this._triggerRefilter]);\n            this._toDispose = lifecycle_1.dispose(this._toDispose);\n            lifecycle_1.dispose(this._completionModel);\n            this.cancel();\n        }\n        // --- handle configuration & precondition changes\n        _updateQuickSuggest() {\n            this._quickSuggestDelay = this._editor.getConfiguration().contribInfo.quickSuggestionsDelay;\n            if (isNaN(this._quickSuggestDelay) || (!this._quickSuggestDelay && this._quickSuggestDelay !== 0) || this._quickSuggestDelay < 0) {\n                this._quickSuggestDelay = 10;\n            }\n        }\n        _updateTriggerCharacters() {\n            lifecycle_1.dispose(this._triggerCharacterListener);\n            if (this._editor.getConfiguration().readOnly\n                || !this._editor.hasModel()\n                || !this._editor.getConfiguration().contribInfo.suggestOnTriggerCharacters) {\n                return;\n            }\n            const supportsByTriggerCharacter = Object.create(null);\n            for (const support of modes_1.CompletionProviderRegistry.all(this._editor.getModel())) {\n                for (const ch of support.triggerCharacters || []) {\n                    let set = supportsByTriggerCharacter[ch];\n                    if (!set) {\n                        set = supportsByTriggerCharacter[ch] = new Set();\n                        set.add(suggest_1.getSnippetSuggestSupport());\n                    }\n                    set.add(support);\n                }\n            }\n            this._triggerCharacterListener = this._editor.onDidType(text => {\n                const lastChar = text.charAt(text.length - 1);\n                const supports = supportsByTriggerCharacter[lastChar];\n                if (supports) {\n                    // keep existing items that where not computed by the\n                    // supports/providers that want to trigger now\n                    const items = this._completionModel ? this._completionModel.adopt(supports) : undefined;\n                    this.trigger({ auto: true, shy: false, triggerCharacter: lastChar }, Boolean(this._completionModel), supports, items);\n                }\n            });\n        }\n        // --- trigger/retrigger/cancel suggest\n        get state() {\n            return this._state;\n        }\n        cancel(retrigger = false) {\n            if (this._state !== State.Idle) {\n                this._triggerRefilter.cancel();\n                this._triggerQuickSuggest.cancel();\n                if (this._requestToken) {\n                    this._requestToken.cancel();\n                    this._requestToken = undefined;\n                }\n                this._state = State.Idle;\n                lifecycle_1.dispose(this._completionModel);\n                this._completionModel = undefined;\n                this._context = undefined;\n                this._onDidCancel.fire({ retrigger });\n            }\n        }\n        _updateActiveSuggestSession() {\n            if (this._state !== State.Idle) {\n                if (!this._editor.hasModel() || !modes_1.CompletionProviderRegistry.has(this._editor.getModel())) {\n                    this.cancel();\n                }\n                else {\n                    this.trigger({ auto: this._state === State.Auto, shy: false }, true);\n                }\n            }\n        }\n        _onCursorChange(e) {\n            if (!this._editor.hasModel()) {\n                return;\n            }\n            const model = this._editor.getModel();\n            const prevSelection = this._currentSelection;\n            this._currentSelection = this._editor.getSelection();\n            if (!e.selection.isEmpty()\n                || e.reason !== cursorEvents_1.CursorChangeReason.NotSet\n                || (e.source !== 'keyboard' && e.source !== 'deleteLeft')) {\n                // Early exit if nothing needs to be done!\n                // Leave some form of early exit check here if you wish to continue being a cursor position change listener ;)\n                if (this._state !== State.Idle) {\n                    this.cancel();\n                }\n                return;\n            }\n            if (!modes_1.CompletionProviderRegistry.has(model)) {\n                return;\n            }\n            if (this._state === State.Idle) {\n                if (this._editor.getConfiguration().contribInfo.quickSuggestions === false) {\n                    // not enabled\n                    return;\n                }\n                if (!prevSelection.containsRange(this._currentSelection) && !prevSelection.getEndPosition().isBeforeOrEqual(this._currentSelection.getPosition())) {\n                    // cursor didn't move RIGHT\n                    return;\n                }\n                if (this._editor.getConfiguration().contribInfo.suggest.snippetsPreventQuickSuggestions && snippetController2_1.SnippetController2.get(this._editor).isInSnippet()) {\n                    // no quick suggestion when in snippet mode\n                    return;\n                }\n                this.cancel();\n                this._triggerQuickSuggest.cancelAndSet(() => {\n                    if (!LineContext.shouldAutoTrigger(this._editor)) {\n                        return;\n                    }\n                    if (!this._editor.hasModel()) {\n                        return;\n                    }\n                    const model = this._editor.getModel();\n                    const pos = this._editor.getPosition();\n                    // validate enabled now\n                    const { quickSuggestions } = this._editor.getConfiguration().contribInfo;\n                    if (quickSuggestions === false) {\n                        return;\n                    }\n                    else if (quickSuggestions === true) {\n                        // all good\n                    }\n                    else {\n                        // Check the type of the token that triggered this\n                        model.tokenizeIfCheap(pos.lineNumber);\n                        const lineTokens = model.getLineTokens(pos.lineNumber);\n                        const tokenType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(Math.max(pos.column - 1 - 1, 0)));\n                        const inValidScope = quickSuggestions.other && tokenType === modes_1.StandardTokenType.Other\n                            || quickSuggestions.comments && tokenType === modes_1.StandardTokenType.Comment\n                            || quickSuggestions.strings && tokenType === modes_1.StandardTokenType.String;\n                        if (!inValidScope) {\n                            return;\n                        }\n                    }\n                    // we made it till here -> trigger now\n                    this.trigger({ auto: true, shy: false });\n                }, this._quickSuggestDelay);\n            }\n        }\n        _refilterCompletionItems() {\n            if (this._state === State.Idle) {\n                return;\n            }\n            if (!this._editor.hasModel()) {\n                return;\n            }\n            // refine active suggestion\n            this._triggerRefilter.cancelAndSet(() => {\n                if (!this._editor.hasModel()) {\n                    return;\n                }\n                const model = this._editor.getModel();\n                const position = this._editor.getPosition();\n                const ctx = new LineContext(model, position, this._state === State.Auto, false);\n                this._onNewContext(ctx);\n            }, 25);\n        }\n        trigger(context, retrigger = false, onlyFrom, existingItems) {\n            if (!this._editor.hasModel()) {\n                return;\n            }\n            const model = this._editor.getModel();\n            const auto = context.auto;\n            const ctx = new LineContext(model, this._editor.getPosition(), auto, context.shy);\n            // Cancel previous requests, change state & update UI\n            this.cancel(retrigger);\n            this._state = auto ? State.Auto : State.Manual;\n            this._onDidTrigger.fire({ auto, shy: context.shy });\n            // Capture context when request was sent\n            this._context = ctx;\n            // Build context for request\n            let suggestCtx;\n            if (context.triggerCharacter) {\n                suggestCtx = {\n                    triggerKind: modes_1.CompletionTriggerKind.TriggerCharacter,\n                    triggerCharacter: context.triggerCharacter\n                };\n            }\n            else if (onlyFrom && onlyFrom.size > 0) {\n                suggestCtx = { triggerKind: modes_1.CompletionTriggerKind.TriggerForIncompleteCompletions };\n            }\n            else {\n                suggestCtx = { triggerKind: modes_1.CompletionTriggerKind.Invoke };\n            }\n            this._requestToken = new cancellation_1.CancellationTokenSource();\n            // kind filter and snippet sort rules\n            const { contribInfo } = this._editor.getConfiguration();\n            let itemKindFilter = new Set();\n            let snippetSortOrder = suggest_1.SnippetSortOrder.Inline;\n            switch (contribInfo.suggest.snippets) {\n                case 'top':\n                    snippetSortOrder = suggest_1.SnippetSortOrder.Top;\n                    break;\n                // \t↓ that's the default anyways...\n                // case 'inline':\n                // \tsnippetSortOrder = SnippetSortOrder.Inline;\n                // \tbreak;\n                case 'bottom':\n                    snippetSortOrder = suggest_1.SnippetSortOrder.Bottom;\n                    break;\n                case 'none':\n                    itemKindFilter.add(modes_1.CompletionItemKind.Snippet);\n                    break;\n            }\n            // kind filter\n            for (const key in contribInfo.suggest.filteredTypes) {\n                const kind = modes_1.completionKindFromString(key, true);\n                if (typeof kind !== 'undefined' && contribInfo.suggest.filteredTypes[key] === false) {\n                    itemKindFilter.add(kind);\n                }\n            }\n            let wordDistance = wordDistance_1.WordDistance.create(this._editorWorker, this._editor);\n            let items = suggest_1.provideSuggestionItems(model, this._editor.getPosition(), new suggest_1.CompletionOptions(snippetSortOrder, itemKindFilter, onlyFrom), suggestCtx, this._requestToken.token);\n            Promise.all([items, wordDistance]).then(([items, wordDistance]) => {\n                lifecycle_1.dispose(this._requestToken);\n                if (this._state === State.Idle) {\n                    return;\n                }\n                if (!this._editor.hasModel()) {\n                    return;\n                }\n                const model = this._editor.getModel();\n                if (arrays_1.isNonEmptyArray(existingItems)) {\n                    const cmpFn = suggest_1.getSuggestionComparator(snippetSortOrder);\n                    items = items.concat(existingItems).sort(cmpFn);\n                }\n                const ctx = new LineContext(model, this._editor.getPosition(), auto, context.shy);\n                lifecycle_1.dispose(this._completionModel);\n                this._completionModel = new completionModel_1.CompletionModel(items, this._context.column, {\n                    leadingLineContent: ctx.leadingLineContent,\n                    characterCountDelta: ctx.column - this._context.column\n                }, wordDistance, this._editor.getConfiguration().contribInfo.suggest);\n                this._onNewContext(ctx);\n            }).catch(errors_1.onUnexpectedError);\n        }\n        _onNewContext(ctx) {\n            if (!this._context) {\n                // happens when 24x7 IntelliSense is enabled and still in its delay\n                return;\n            }\n            if (ctx.lineNumber !== this._context.lineNumber) {\n                // e.g. happens when pressing Enter while IntelliSense is computed\n                this.cancel();\n                return;\n            }\n            if (ctx.leadingWord.startColumn < this._context.leadingWord.startColumn) {\n                // happens when the current word gets outdented\n                this.cancel();\n                return;\n            }\n            if (ctx.column < this._context.column) {\n                // typed -> moved cursor LEFT -> retrigger if still on a word\n                if (ctx.leadingWord.word) {\n                    this.trigger({ auto: this._context.auto, shy: false }, true);\n                }\n                else {\n                    this.cancel();\n                }\n                return;\n            }\n            if (!this._completionModel) {\n                // happens when IntelliSense is not yet computed\n                return;\n            }\n            if (ctx.column > this._context.column && this._completionModel.incomplete.size > 0 && ctx.leadingWord.word.length !== 0) {\n                // typed -> moved cursor RIGHT & incomple model & still on a word -> retrigger\n                const { incomplete } = this._completionModel;\n                const adopted = this._completionModel.adopt(incomplete);\n                this.trigger({ auto: this._state === State.Auto, shy: false }, true, incomplete, adopted);\n            }\n            else {\n                // typed -> moved cursor RIGHT -> update UI\n                let oldLineContext = this._completionModel.lineContext;\n                let isFrozen = false;\n                this._completionModel.lineContext = {\n                    leadingLineContent: ctx.leadingLineContent,\n                    characterCountDelta: ctx.column - this._context.column\n                };\n                if (this._completionModel.items.length === 0) {\n                    if (LineContext.shouldAutoTrigger(this._editor) && this._context.leadingWord.endColumn < ctx.leadingWord.startColumn) {\n                        // retrigger when heading into a new word\n                        this.trigger({ auto: this._context.auto, shy: false }, true);\n                        return;\n                    }\n                    if (!this._context.auto) {\n                        // freeze when IntelliSense was manually requested\n                        this._completionModel.lineContext = oldLineContext;\n                        isFrozen = this._completionModel.items.length > 0;\n                        if (isFrozen && ctx.leadingWord.word.length === 0) {\n                            // there were results before but now there aren't\n                            // and also we are not on a word anymore -> cancel\n                            this.cancel();\n                            return;\n                        }\n                    }\n                    else {\n                        // nothing left\n                        this.cancel();\n                        return;\n                    }\n                }\n                this._onDidSuggest.fire({\n                    completionModel: this._completionModel,\n                    auto: this._context.auto,\n                    shy: this._context.shy,\n                    isFrozen,\n                });\n            }\n        }\n    }\n    exports.SuggestModel = SuggestModel;\n});\n",null]}