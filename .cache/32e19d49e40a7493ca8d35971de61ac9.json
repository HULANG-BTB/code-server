{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/files/browser/editors/fileEditorTracker.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/files/browser/editors/fileEditorTracker.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar resources = require(\"vs/base/common/resources\");\nvar editor_1 = require(\"vs/workbench/common/editor\");\nvar textfiles_1 = require(\"vs/workbench/services/textfile/common/textfiles\");\nvar files_1 = require(\"vs/platform/files/common/files\");\nvar fileEditorInput_1 = require(\"vs/workbench/contrib/files/common/editors/fileEditorInput\");\nvar lifecycle_1 = require(\"vs/platform/lifecycle/common/lifecycle\");\nvar lifecycle_2 = require(\"vs/base/common/lifecycle\");\nvar arrays_1 = require(\"vs/base/common/arrays\");\nvar environment_1 = require(\"vs/platform/environment/common/environment\");\nvar configuration_1 = require(\"vs/platform/configuration/common/configuration\");\nvar platform_1 = require(\"vs/base/common/platform\");\nvar map_1 = require(\"vs/base/common/map\");\nvar workspace_1 = require(\"vs/platform/workspace/common/workspace\");\nvar editorBrowser_1 = require(\"vs/editor/browser/editorBrowser\");\nvar sideBySideEditor_1 = require(\"vs/workbench/browser/parts/editor/sideBySideEditor\");\nvar windows_1 = require(\"vs/platform/windows/common/windows\");\nvar files_2 = require(\"vs/workbench/contrib/files/common/files\");\nvar editorService_1 = require(\"vs/workbench/services/editor/common/editorService\");\nvar editorGroupsService_1 = require(\"vs/workbench/services/editor/common/editorGroupsService\");\nvar async_1 = require(\"vs/base/common/async\");\nvar errors_1 = require(\"vs/base/common/errors\");\nvar types_1 = require(\"vs/base/common/types\");\nvar FileEditorTracker = /** @class */ (function (_super) {\n    tslib_1.__extends(FileEditorTracker, _super);\n    function FileEditorTracker(editorService, textFileService, lifecycleService, editorGroupService, fileService, environmentService, configurationService, contextService, windowService) {\n        var _this = _super.call(this) || this;\n        _this.editorService = editorService;\n        _this.textFileService = textFileService;\n        _this.lifecycleService = lifecycleService;\n        _this.editorGroupService = editorGroupService;\n        _this.fileService = fileService;\n        _this.environmentService = environmentService;\n        _this.configurationService = configurationService;\n        _this.contextService = contextService;\n        _this.windowService = windowService;\n        _this.modelLoadQueue = new async_1.ResourceQueue();\n        _this.activeOutOfWorkspaceWatchers = new map_1.ResourceMap();\n        _this.onConfigurationUpdated(configurationService.getValue());\n        _this.registerListeners();\n        return _this;\n    }\n    FileEditorTracker.prototype.registerListeners = function () {\n        var _this = this;\n        // Update editors from operation changes\n        this._register(this.fileService.onAfterOperation(function (e) { return _this.onFileOperation(e); }));\n        // Update editors from disk changes\n        this._register(this.fileService.onFileChanges(function (e) { return _this.onFileChanges(e); }));\n        // Editor changing\n        this._register(this.editorService.onDidVisibleEditorsChange(function () { return _this.handleOutOfWorkspaceWatchers(); }));\n        // Update visible editors when focus is gained\n        this._register(this.windowService.onDidChangeFocus(function (e) { return _this.onWindowFocusChange(e); }));\n        // Lifecycle\n        this.lifecycleService.onShutdown(this.dispose, this);\n        // Configuration\n        this._register(this.configurationService.onDidChangeConfiguration(function (e) { return _this.onConfigurationUpdated(_this.configurationService.getValue()); }));\n    };\n    FileEditorTracker.prototype.onConfigurationUpdated = function (configuration) {\n        if (configuration.workbench && configuration.workbench.editor && typeof configuration.workbench.editor.closeOnFileDelete === 'boolean') {\n            this.closeOnFileDelete = configuration.workbench.editor.closeOnFileDelete;\n        }\n        else {\n            this.closeOnFileDelete = false; // default\n        }\n    };\n    FileEditorTracker.prototype.onWindowFocusChange = function (focused) {\n        var _this = this;\n        if (focused) {\n            // the window got focus and we use this as a hint that files might have been changed outside\n            // of this window. since file events can be unreliable, we queue a load for models that\n            // are visible in any editor. since this is a fast operation in the case nothing has changed,\n            // we tolerate the additional work.\n            arrays_1.distinct(arrays_1.coalesce(this.editorService.visibleEditors\n                .map(function (editorInput) {\n                var resource = editor_1.toResource(editorInput, { supportSideBySide: true });\n                return resource ? _this.textFileService.models.get(resource) : undefined;\n            }))\n                .filter(function (model) { return !model.isDirty(); }), function (m) { return m.getResource().toString(); }).forEach(function (model) { return _this.queueModelLoad(model); });\n        }\n    };\n    // Note: there is some duplication with the other file event handler below. Since we cannot always rely on the disk events\n    // carrying all necessary data in all environments, we also use the file operation events to make sure operations are handled.\n    // In any case there is no guarantee if the local event is fired first or the disk one. Thus, code must handle the case\n    // that the event ordering is random as well as might not carry all information needed.\n    FileEditorTracker.prototype.onFileOperation = function (e) {\n        // Handle moves specially when file is opened\n        if (e.operation === files_1.FileOperation.MOVE && e.target) {\n            this.handleMovedFileInOpenedEditors(e.resource, e.target.resource);\n        }\n        // Handle deletes\n        if (e.operation === files_1.FileOperation.DELETE || e.operation === files_1.FileOperation.MOVE) {\n            this.handleDeletes(e.resource, false, e.target ? e.target.resource : undefined);\n        }\n    };\n    FileEditorTracker.prototype.onFileChanges = function (e) {\n        // Handle updates\n        if (e.gotAdded() || e.gotUpdated()) {\n            this.handleUpdates(e);\n        }\n        // Handle deletes\n        if (e.gotDeleted()) {\n            this.handleDeletes(e, true);\n        }\n    };\n    FileEditorTracker.prototype.handleDeletes = function (arg1, isExternal, movedTo) {\n        var _this = this;\n        var nonDirtyFileEditors = this.getOpenedFileEditors(false /* non-dirty only */);\n        nonDirtyFileEditors.forEach(function (editor) {\n            var resource = editor.getResource();\n            // Handle deletes in opened editors depending on:\n            // - the user has not disabled the setting closeOnFileDelete\n            // - the file change is local or external\n            // - the input is not resolved (we need to dispose because we cannot restore otherwise since we do not have the contents)\n            if (_this.closeOnFileDelete || !isExternal || !editor.isResolved()) {\n                // Do NOT close any opened editor that matches the resource path (either equal or being parent) of the\n                // resource we move to (movedTo). Otherwise we would close a resource that has been renamed to the same\n                // path but different casing.\n                if (movedTo && resources.isEqualOrParent(resource, movedTo)) {\n                    return;\n                }\n                var matches = false;\n                if (arg1 instanceof files_1.FileChangesEvent) {\n                    matches = arg1.contains(resource, files_1.FileChangeType.DELETED);\n                }\n                else {\n                    matches = resources.isEqualOrParent(resource, arg1);\n                }\n                if (!matches) {\n                    return;\n                }\n                // We have received reports of users seeing delete events even though the file still\n                // exists (network shares issue: https://github.com/Microsoft/vscode/issues/13665).\n                // Since we do not want to close an editor without reason, we have to check if the\n                // file is really gone and not just a faulty file event.\n                // This only applies to external file events, so we need to check for the isExternal\n                // flag.\n                var checkExists = void 0;\n                if (isExternal) {\n                    checkExists = async_1.timeout(100).then(function () { return _this.fileService.existsFile(resource); });\n                }\n                else {\n                    checkExists = Promise.resolve(false);\n                }\n                checkExists.then(function (exists) {\n                    if (!exists && !editor.isDisposed()) {\n                        editor.dispose();\n                    }\n                    else if (_this.environmentService.verbose) {\n                        console.warn(\"File exists even though we received a delete event: \" + resource.toString());\n                    }\n                });\n            }\n        });\n    };\n    FileEditorTracker.prototype.getOpenedFileEditors = function (dirtyState) {\n        var editors = [];\n        this.editorService.editors.forEach(function (editor) {\n            if (editor instanceof fileEditorInput_1.FileEditorInput) {\n                if (!!editor.isDirty() === dirtyState) {\n                    editors.push(editor);\n                }\n            }\n            else if (editor instanceof editor_1.SideBySideEditorInput) {\n                var master = editor.master;\n                var details = editor.details;\n                if (master instanceof fileEditorInput_1.FileEditorInput) {\n                    if (!!master.isDirty() === dirtyState) {\n                        editors.push(master);\n                    }\n                }\n                if (details instanceof fileEditorInput_1.FileEditorInput) {\n                    if (!!details.isDirty() === dirtyState) {\n                        editors.push(details);\n                    }\n                }\n            }\n        });\n        return editors;\n    };\n    FileEditorTracker.prototype.handleMovedFileInOpenedEditors = function (oldResource, newResource) {\n        var _this = this;\n        this.editorGroupService.groups.forEach(function (group) {\n            group.editors.forEach(function (editor) {\n                if (editor instanceof fileEditorInput_1.FileEditorInput) {\n                    var resource = editor.getResource();\n                    // Update Editor if file (or any parent of the input) got renamed or moved\n                    if (resources.isEqualOrParent(resource, oldResource)) {\n                        var reopenFileResource = void 0;\n                        if (oldResource.toString() === resource.toString()) {\n                            reopenFileResource = newResource; // file got moved\n                        }\n                        else {\n                            var index = _this.getIndexOfPath(resource.path, oldResource.path);\n                            reopenFileResource = resources.joinPath(newResource, resource.path.substr(index + oldResource.path.length + 1)); // parent folder got moved\n                        }\n                        _this.editorService.replaceEditors([{\n                                editor: { resource: resource },\n                                replacement: {\n                                    resource: reopenFileResource,\n                                    options: {\n                                        preserveFocus: true,\n                                        pinned: group.isPinned(editor),\n                                        index: group.getIndexOfEditor(editor),\n                                        inactive: !group.isActive(editor),\n                                        viewState: _this.getViewStateFor(oldResource, group)\n                                    }\n                                },\n                            }], group);\n                    }\n                }\n            });\n        });\n    };\n    FileEditorTracker.prototype.getIndexOfPath = function (path, candidate) {\n        if (candidate.length > path.length) {\n            return -1;\n        }\n        if (path === candidate) {\n            return 0;\n        }\n        if (!platform_1.isLinux /* ignore case */) {\n            path = path.toLowerCase();\n            candidate = candidate.toLowerCase();\n        }\n        return path.indexOf(candidate);\n    };\n    FileEditorTracker.prototype.getViewStateFor = function (resource, group) {\n        var editors = this.editorService.visibleControls;\n        for (var _i = 0, editors_1 = editors; _i < editors_1.length; _i++) {\n            var editor = editors_1[_i];\n            if (editor && editor.input && editor.group === group) {\n                var editorResource = editor.input.getResource();\n                if (editorResource && resource.toString() === editorResource.toString()) {\n                    var control = editor.getControl();\n                    if (editorBrowser_1.isCodeEditor(control)) {\n                        return types_1.withNullAsUndefined(control.saveViewState());\n                    }\n                }\n            }\n        }\n        return undefined;\n    };\n    FileEditorTracker.prototype.handleUpdates = function (e) {\n        // Handle updates to text models\n        this.handleUpdatesToTextModels(e);\n        // Handle updates to visible binary editors\n        this.handleUpdatesToVisibleBinaryEditors(e);\n    };\n    FileEditorTracker.prototype.handleUpdatesToTextModels = function (e) {\n        var _this = this;\n        // Collect distinct (saved) models to update.\n        //\n        // Note: we also consider the added event because it could be that a file was added\n        // and updated right after.\n        arrays_1.distinct(arrays_1.coalesce(e.getUpdated().concat(e.getAdded()).map(function (u) { return _this.textFileService.models.get(u.resource); }))\n            .filter(function (model) { return model && !model.isDirty(); }), function (m) { return m.getResource().toString(); })\n            .forEach(function (model) { return _this.queueModelLoad(model); });\n    };\n    FileEditorTracker.prototype.queueModelLoad = function (model) {\n        // Load model to update (use a queue to prevent accumulation of loads\n        // when the load actually takes long. At most we only want the queue\n        // to have a size of 2 (1 running load and 1 queued load).\n        var queue = this.modelLoadQueue.queueFor(model.getResource());\n        if (queue.size <= 1) {\n            queue.queue(function () { return model.load().then(undefined, errors_1.onUnexpectedError); });\n        }\n    };\n    FileEditorTracker.prototype.handleUpdatesToVisibleBinaryEditors = function (e) {\n        var _this = this;\n        var editors = this.editorService.visibleControls;\n        editors.forEach(function (editor) {\n            var resource = editor.input ? editor_1.toResource(editor.input, { supportSideBySide: true }) : undefined;\n            // Support side-by-side binary editors too\n            var isBinaryEditor = false;\n            if (editor instanceof sideBySideEditor_1.SideBySideEditor) {\n                var masterEditor = editor.getMasterEditor();\n                isBinaryEditor = !!masterEditor && masterEditor.getId() === files_2.BINARY_FILE_EDITOR_ID;\n            }\n            else {\n                isBinaryEditor = editor.getId() === files_2.BINARY_FILE_EDITOR_ID;\n            }\n            // Binary editor that should reload from event\n            if (resource && editor.input && isBinaryEditor && (e.contains(resource, files_1.FileChangeType.UPDATED) || e.contains(resource, files_1.FileChangeType.ADDED))) {\n                _this.editorService.openEditor(editor.input, { forceReload: true, preserveFocus: true }, editor.group);\n            }\n        });\n    };\n    FileEditorTracker.prototype.handleOutOfWorkspaceWatchers = function () {\n        var _this = this;\n        var visibleOutOfWorkspacePaths = new map_1.ResourceMap();\n        arrays_1.coalesce(this.editorService.visibleEditors.map(function (editorInput) {\n            return editor_1.toResource(editorInput, { supportSideBySide: true });\n        })).filter(function (resource) {\n            return _this.fileService.canHandleResource(resource) && !_this.contextService.isInsideWorkspace(resource);\n        }).forEach(function (resource) {\n            visibleOutOfWorkspacePaths.set(resource, resource);\n        });\n        // Handle no longer visible out of workspace resources\n        this.activeOutOfWorkspaceWatchers.forEach(function (resource) {\n            if (!visibleOutOfWorkspacePaths.get(resource)) {\n                _this.fileService.unwatchFileChanges(resource);\n                _this.activeOutOfWorkspaceWatchers.delete(resource);\n            }\n        });\n        // Handle newly visible out of workspace resources\n        visibleOutOfWorkspacePaths.forEach(function (resource) {\n            if (!_this.activeOutOfWorkspaceWatchers.get(resource)) {\n                _this.fileService.watchFileChanges(resource);\n                _this.activeOutOfWorkspaceWatchers.set(resource, resource);\n            }\n        });\n    };\n    FileEditorTracker.prototype.dispose = function () {\n        var _this = this;\n        _super.prototype.dispose.call(this);\n        // Dispose watchers if any\n        this.activeOutOfWorkspaceWatchers.forEach(function (resource) { return _this.fileService.unwatchFileChanges(resource); });\n        this.activeOutOfWorkspaceWatchers.clear();\n    };\n    FileEditorTracker = tslib_1.__decorate([\n        tslib_1.__param(0, editorService_1.IEditorService),\n        tslib_1.__param(1, textfiles_1.ITextFileService),\n        tslib_1.__param(2, lifecycle_1.ILifecycleService),\n        tslib_1.__param(3, editorGroupsService_1.IEditorGroupsService),\n        tslib_1.__param(4, files_1.IFileService),\n        tslib_1.__param(5, environment_1.IEnvironmentService),\n        tslib_1.__param(6, configuration_1.IConfigurationService),\n        tslib_1.__param(7, workspace_1.IWorkspaceContextService),\n        tslib_1.__param(8, windows_1.IWindowService)\n    ], FileEditorTracker);\n    return FileEditorTracker;\n}(lifecycle_2.Disposable));\nexports.FileEditorTracker = FileEditorTracker;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/files/browser/editors/fileEditorTracker.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/files/browser/editors/fileEditorTracker.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IWorkbenchContribution } from 'vs/workbench/common/contributions';\nimport { URI } from 'vs/base/common/uri';\nimport * as resources from 'vs/base/common/resources';\nimport { IEditorViewState } from 'vs/editor/common/editorCommon';\nimport { toResource, SideBySideEditorInput, IWorkbenchEditorConfiguration } from 'vs/workbench/common/editor';\nimport { ITextFileService, ITextFileEditorModel } from 'vs/workbench/services/textfile/common/textfiles';\nimport { FileOperationEvent, FileOperation, IFileService, FileChangeType, FileChangesEvent } from 'vs/platform/files/common/files';\nimport { FileEditorInput } from 'vs/workbench/contrib/files/common/editors/fileEditorInput';\nimport { ILifecycleService } from 'vs/platform/lifecycle/common/lifecycle';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { distinct, coalesce } from 'vs/base/common/arrays';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { isLinux } from 'vs/base/common/platform';\nimport { ResourceMap } from 'vs/base/common/map';\nimport { IWorkspaceContextService } from 'vs/platform/workspace/common/workspace';\nimport { isCodeEditor } from 'vs/editor/browser/editorBrowser';\nimport { SideBySideEditor } from 'vs/workbench/browser/parts/editor/sideBySideEditor';\nimport { IWindowService } from 'vs/platform/windows/common/windows';\nimport { BINARY_FILE_EDITOR_ID } from 'vs/workbench/contrib/files/common/files';\nimport { IEditorService } from 'vs/workbench/services/editor/common/editorService';\nimport { IEditorGroupsService, IEditorGroup } from 'vs/workbench/services/editor/common/editorGroupsService';\nimport { ResourceQueue, timeout } from 'vs/base/common/async';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { withNullAsUndefined } from 'vs/base/common/types';\n\nexport class FileEditorTracker extends Disposable implements IWorkbenchContribution {\n\n\tprotected closeOnFileDelete: boolean;\n\n\tprivate modelLoadQueue: ResourceQueue;\n\tprivate activeOutOfWorkspaceWatchers: ResourceMap<URI>;\n\n\tconstructor(\n\t\t@IEditorService private readonly editorService: IEditorService,\n\t\t@ITextFileService private readonly textFileService: ITextFileService,\n\t\t@ILifecycleService private readonly lifecycleService: ILifecycleService,\n\t\t@IEditorGroupsService private readonly editorGroupService: IEditorGroupsService,\n\t\t@IFileService private readonly fileService: IFileService,\n\t\t@IEnvironmentService private readonly environmentService: IEnvironmentService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IWorkspaceContextService private readonly contextService: IWorkspaceContextService,\n\t\t@IWindowService private readonly windowService: IWindowService\n\t) {\n\t\tsuper();\n\n\t\tthis.modelLoadQueue = new ResourceQueue();\n\t\tthis.activeOutOfWorkspaceWatchers = new ResourceMap<URI>();\n\n\t\tthis.onConfigurationUpdated(configurationService.getValue<IWorkbenchEditorConfiguration>());\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Update editors from operation changes\n\t\tthis._register(this.fileService.onAfterOperation(e => this.onFileOperation(e)));\n\n\t\t// Update editors from disk changes\n\t\tthis._register(this.fileService.onFileChanges(e => this.onFileChanges(e)));\n\n\t\t// Editor changing\n\t\tthis._register(this.editorService.onDidVisibleEditorsChange(() => this.handleOutOfWorkspaceWatchers()));\n\n\t\t// Update visible editors when focus is gained\n\t\tthis._register(this.windowService.onDidChangeFocus(e => this.onWindowFocusChange(e)));\n\n\t\t// Lifecycle\n\t\tthis.lifecycleService.onShutdown(this.dispose, this);\n\n\t\t// Configuration\n\t\tthis._register(this.configurationService.onDidChangeConfiguration(e => this.onConfigurationUpdated(this.configurationService.getValue<IWorkbenchEditorConfiguration>())));\n\t}\n\n\tprivate onConfigurationUpdated(configuration: IWorkbenchEditorConfiguration): void {\n\t\tif (configuration.workbench && configuration.workbench.editor && typeof configuration.workbench.editor.closeOnFileDelete === 'boolean') {\n\t\t\tthis.closeOnFileDelete = configuration.workbench.editor.closeOnFileDelete;\n\t\t} else {\n\t\t\tthis.closeOnFileDelete = false; // default\n\t\t}\n\t}\n\n\tprivate onWindowFocusChange(focused: boolean): void {\n\t\tif (focused) {\n\t\t\t// the window got focus and we use this as a hint that files might have been changed outside\n\t\t\t// of this window. since file events can be unreliable, we queue a load for models that\n\t\t\t// are visible in any editor. since this is a fast operation in the case nothing has changed,\n\t\t\t// we tolerate the additional work.\n\t\t\tdistinct(\n\t\t\t\tcoalesce(this.editorService.visibleEditors\n\t\t\t\t\t.map(editorInput => {\n\t\t\t\t\t\tconst resource = toResource(editorInput, { supportSideBySide: true });\n\t\t\t\t\t\treturn resource ? this.textFileService.models.get(resource) : undefined;\n\t\t\t\t\t}))\n\t\t\t\t\t.filter(model => !model.isDirty()),\n\t\t\t\tm => m.getResource().toString()\n\t\t\t).forEach(model => this.queueModelLoad(model));\n\t\t}\n\t}\n\n\t// Note: there is some duplication with the other file event handler below. Since we cannot always rely on the disk events\n\t// carrying all necessary data in all environments, we also use the file operation events to make sure operations are handled.\n\t// In any case there is no guarantee if the local event is fired first or the disk one. Thus, code must handle the case\n\t// that the event ordering is random as well as might not carry all information needed.\n\tprivate onFileOperation(e: FileOperationEvent): void {\n\n\t\t// Handle moves specially when file is opened\n\t\tif (e.operation === FileOperation.MOVE && e.target) {\n\t\t\tthis.handleMovedFileInOpenedEditors(e.resource, e.target.resource);\n\t\t}\n\n\t\t// Handle deletes\n\t\tif (e.operation === FileOperation.DELETE || e.operation === FileOperation.MOVE) {\n\t\t\tthis.handleDeletes(e.resource, false, e.target ? e.target.resource : undefined);\n\t\t}\n\t}\n\n\tprivate onFileChanges(e: FileChangesEvent): void {\n\n\t\t// Handle updates\n\t\tif (e.gotAdded() || e.gotUpdated()) {\n\t\t\tthis.handleUpdates(e);\n\t\t}\n\n\t\t// Handle deletes\n\t\tif (e.gotDeleted()) {\n\t\t\tthis.handleDeletes(e, true);\n\t\t}\n\t}\n\n\tprivate handleDeletes(arg1: URI | FileChangesEvent, isExternal: boolean, movedTo?: URI): void {\n\t\tconst nonDirtyFileEditors = this.getOpenedFileEditors(false /* non-dirty only */);\n\t\tnonDirtyFileEditors.forEach(editor => {\n\t\t\tconst resource = editor.getResource();\n\n\t\t\t// Handle deletes in opened editors depending on:\n\t\t\t// - the user has not disabled the setting closeOnFileDelete\n\t\t\t// - the file change is local or external\n\t\t\t// - the input is not resolved (we need to dispose because we cannot restore otherwise since we do not have the contents)\n\t\t\tif (this.closeOnFileDelete || !isExternal || !editor.isResolved()) {\n\n\t\t\t\t// Do NOT close any opened editor that matches the resource path (either equal or being parent) of the\n\t\t\t\t// resource we move to (movedTo). Otherwise we would close a resource that has been renamed to the same\n\t\t\t\t// path but different casing.\n\t\t\t\tif (movedTo && resources.isEqualOrParent(resource, movedTo)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet matches = false;\n\t\t\t\tif (arg1 instanceof FileChangesEvent) {\n\t\t\t\t\tmatches = arg1.contains(resource, FileChangeType.DELETED);\n\t\t\t\t} else {\n\t\t\t\t\tmatches = resources.isEqualOrParent(resource, arg1);\n\t\t\t\t}\n\n\t\t\t\tif (!matches) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// We have received reports of users seeing delete events even though the file still\n\t\t\t\t// exists (network shares issue: https://github.com/Microsoft/vscode/issues/13665).\n\t\t\t\t// Since we do not want to close an editor without reason, we have to check if the\n\t\t\t\t// file is really gone and not just a faulty file event.\n\t\t\t\t// This only applies to external file events, so we need to check for the isExternal\n\t\t\t\t// flag.\n\t\t\t\tlet checkExists: Promise<boolean>;\n\t\t\t\tif (isExternal) {\n\t\t\t\t\tcheckExists = timeout(100).then(() => this.fileService.existsFile(resource));\n\t\t\t\t} else {\n\t\t\t\t\tcheckExists = Promise.resolve(false);\n\t\t\t\t}\n\n\t\t\t\tcheckExists.then(exists => {\n\t\t\t\t\tif (!exists && !editor.isDisposed()) {\n\t\t\t\t\t\teditor.dispose();\n\t\t\t\t\t} else if (this.environmentService.verbose) {\n\t\t\t\t\t\tconsole.warn(`File exists even though we received a delete event: ${resource.toString()}`);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate getOpenedFileEditors(dirtyState: boolean): FileEditorInput[] {\n\t\tconst editors: FileEditorInput[] = [];\n\n\t\tthis.editorService.editors.forEach(editor => {\n\t\t\tif (editor instanceof FileEditorInput) {\n\t\t\t\tif (!!editor.isDirty() === dirtyState) {\n\t\t\t\t\teditors.push(editor);\n\t\t\t\t}\n\t\t\t} else if (editor instanceof SideBySideEditorInput) {\n\t\t\t\tconst master = editor.master;\n\t\t\t\tconst details = editor.details;\n\n\t\t\t\tif (master instanceof FileEditorInput) {\n\t\t\t\t\tif (!!master.isDirty() === dirtyState) {\n\t\t\t\t\t\teditors.push(master);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (details instanceof FileEditorInput) {\n\t\t\t\t\tif (!!details.isDirty() === dirtyState) {\n\t\t\t\t\t\teditors.push(details);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn editors;\n\t}\n\n\tprivate handleMovedFileInOpenedEditors(oldResource: URI, newResource: URI): void {\n\t\tthis.editorGroupService.groups.forEach(group => {\n\t\t\tgroup.editors.forEach(editor => {\n\t\t\t\tif (editor instanceof FileEditorInput) {\n\t\t\t\t\tconst resource = editor.getResource();\n\n\t\t\t\t\t// Update Editor if file (or any parent of the input) got renamed or moved\n\t\t\t\t\tif (resources.isEqualOrParent(resource, oldResource)) {\n\t\t\t\t\t\tlet reopenFileResource: URI;\n\t\t\t\t\t\tif (oldResource.toString() === resource.toString()) {\n\t\t\t\t\t\t\treopenFileResource = newResource; // file got moved\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst index = this.getIndexOfPath(resource.path, oldResource.path);\n\t\t\t\t\t\t\treopenFileResource = resources.joinPath(newResource, resource.path.substr(index + oldResource.path.length + 1)); // parent folder got moved\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.editorService.replaceEditors([{\n\t\t\t\t\t\t\teditor: { resource },\n\t\t\t\t\t\t\treplacement: {\n\t\t\t\t\t\t\t\tresource: reopenFileResource,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tpreserveFocus: true,\n\t\t\t\t\t\t\t\t\tpinned: group.isPinned(editor),\n\t\t\t\t\t\t\t\t\tindex: group.getIndexOfEditor(editor),\n\t\t\t\t\t\t\t\t\tinactive: !group.isActive(editor),\n\t\t\t\t\t\t\t\t\tviewState: this.getViewStateFor(oldResource, group)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}], group);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate getIndexOfPath(path: string, candidate: string): number {\n\t\tif (candidate.length > path.length) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (path === candidate) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!isLinux /* ignore case */) {\n\t\t\tpath = path.toLowerCase();\n\t\t\tcandidate = candidate.toLowerCase();\n\t\t}\n\n\t\treturn path.indexOf(candidate);\n\t}\n\n\tprivate getViewStateFor(resource: URI, group: IEditorGroup): IEditorViewState | undefined {\n\t\tconst editors = this.editorService.visibleControls;\n\n\t\tfor (const editor of editors) {\n\t\t\tif (editor && editor.input && editor.group === group) {\n\t\t\t\tconst editorResource = editor.input.getResource();\n\t\t\t\tif (editorResource && resource.toString() === editorResource.toString()) {\n\t\t\t\t\tconst control = editor.getControl();\n\t\t\t\t\tif (isCodeEditor(control)) {\n\t\t\t\t\t\treturn withNullAsUndefined(control.saveViewState());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate handleUpdates(e: FileChangesEvent): void {\n\n\t\t// Handle updates to text models\n\t\tthis.handleUpdatesToTextModels(e);\n\n\t\t// Handle updates to visible binary editors\n\t\tthis.handleUpdatesToVisibleBinaryEditors(e);\n\t}\n\n\tprivate handleUpdatesToTextModels(e: FileChangesEvent): void {\n\n\t\t// Collect distinct (saved) models to update.\n\t\t//\n\t\t// Note: we also consider the added event because it could be that a file was added\n\t\t// and updated right after.\n\t\tdistinct(coalesce([...e.getUpdated(), ...e.getAdded()]\n\t\t\t.map(u => this.textFileService.models.get(u.resource)))\n\t\t\t.filter(model => model && !model.isDirty()), m => m.getResource().toString())\n\t\t\t.forEach(model => this.queueModelLoad(model));\n\t}\n\n\tprivate queueModelLoad(model: ITextFileEditorModel): void {\n\n\t\t// Load model to update (use a queue to prevent accumulation of loads\n\t\t// when the load actually takes long. At most we only want the queue\n\t\t// to have a size of 2 (1 running load and 1 queued load).\n\t\tconst queue = this.modelLoadQueue.queueFor(model.getResource());\n\t\tif (queue.size <= 1) {\n\t\t\tqueue.queue(() => model.load().then<void>(undefined, onUnexpectedError));\n\t\t}\n\t}\n\n\tprivate handleUpdatesToVisibleBinaryEditors(e: FileChangesEvent): void {\n\t\tconst editors = this.editorService.visibleControls;\n\t\teditors.forEach(editor => {\n\t\t\tconst resource = editor.input ? toResource(editor.input, { supportSideBySide: true }) : undefined;\n\n\t\t\t// Support side-by-side binary editors too\n\t\t\tlet isBinaryEditor = false;\n\t\t\tif (editor instanceof SideBySideEditor) {\n\t\t\t\tconst masterEditor = editor.getMasterEditor();\n\t\t\t\tisBinaryEditor = !!masterEditor && masterEditor.getId() === BINARY_FILE_EDITOR_ID;\n\t\t\t} else {\n\t\t\t\tisBinaryEditor = editor.getId() === BINARY_FILE_EDITOR_ID;\n\t\t\t}\n\n\t\t\t// Binary editor that should reload from event\n\t\t\tif (resource && editor.input && isBinaryEditor && (e.contains(resource, FileChangeType.UPDATED) || e.contains(resource, FileChangeType.ADDED))) {\n\t\t\t\tthis.editorService.openEditor(editor.input, { forceReload: true, preserveFocus: true }, editor.group);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate handleOutOfWorkspaceWatchers(): void {\n\t\tconst visibleOutOfWorkspacePaths = new ResourceMap<URI>();\n\t\tcoalesce(this.editorService.visibleEditors.map(editorInput => {\n\t\t\treturn toResource(editorInput, { supportSideBySide: true });\n\t\t})).filter(resource => {\n\t\t\treturn this.fileService.canHandleResource(resource) && !this.contextService.isInsideWorkspace(resource);\n\t\t}).forEach(resource => {\n\t\t\tvisibleOutOfWorkspacePaths.set(resource, resource);\n\t\t});\n\n\t\t// Handle no longer visible out of workspace resources\n\t\tthis.activeOutOfWorkspaceWatchers.forEach(resource => {\n\t\t\tif (!visibleOutOfWorkspacePaths.get(resource)) {\n\t\t\t\tthis.fileService.unwatchFileChanges(resource);\n\t\t\t\tthis.activeOutOfWorkspaceWatchers.delete(resource);\n\t\t\t}\n\t\t});\n\n\t\t// Handle newly visible out of workspace resources\n\t\tvisibleOutOfWorkspacePaths.forEach(resource => {\n\t\t\tif (!this.activeOutOfWorkspaceWatchers.get(resource)) {\n\t\t\t\tthis.fileService.watchFileChanges(resource);\n\t\t\t\tthis.activeOutOfWorkspaceWatchers.set(resource, resource);\n\t\t\t}\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tsuper.dispose();\n\n\t\t// Dispose watchers if any\n\t\tthis.activeOutOfWorkspaceWatchers.forEach(resource => this.fileService.unwatchFileChanges(resource));\n\t\tthis.activeOutOfWorkspaceWatchers.clear();\n\t}\n}\n"]}]}