{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/common/menusExtensionPoint.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/common/menusExtensionPoint.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/strings\", \"vs/base/common/resources\", \"vs/base/common/collections\", \"vs/workbench/services/extensions/common/extensionsRegistry\", \"vs/platform/contextkey/common/contextkey\", \"vs/platform/actions/common/actions\", \"vs/base/common/lifecycle\"], function (require, exports, nls_1, strings_1, resources, collections_1, extensionsRegistry_1, contextkey_1, actions_1, lifecycle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var schema;\n    (function (schema) {\n        // --- menus contribution point\n        function parseMenuId(value) {\n            switch (value) {\n                case 'commandPalette': return actions_1.MenuId.CommandPalette;\n                case 'touchBar': return actions_1.MenuId.TouchBarContext;\n                case 'editor/title': return actions_1.MenuId.EditorTitle;\n                case 'editor/context': return actions_1.MenuId.EditorContext;\n                case 'explorer/context': return actions_1.MenuId.ExplorerContext;\n                case 'editor/title/context': return actions_1.MenuId.EditorTitleContext;\n                case 'debug/callstack/context': return actions_1.MenuId.DebugCallStackContext;\n                case 'debug/toolbar': return actions_1.MenuId.DebugToolBar;\n                case 'debug/toolBar': return actions_1.MenuId.DebugToolBar;\n                case 'menuBar/file': return actions_1.MenuId.MenubarFileMenu;\n                case 'scm/title': return actions_1.MenuId.SCMTitle;\n                case 'scm/sourceControl': return actions_1.MenuId.SCMSourceControl;\n                case 'scm/resourceGroup/context': return actions_1.MenuId.SCMResourceGroupContext;\n                case 'scm/resourceState/context': return actions_1.MenuId.SCMResourceContext;\n                case 'scm/change/title': return actions_1.MenuId.SCMChangeContext;\n                case 'statusBar/windowIndicator': return actions_1.MenuId.StatusBarWindowIndicatorMenu;\n                case 'view/title': return actions_1.MenuId.ViewTitle;\n                case 'view/item/context': return actions_1.MenuId.ViewItemContext;\n            }\n            return undefined;\n        }\n        schema.parseMenuId = parseMenuId;\n        function isProposedAPI(menuId) {\n            switch (menuId) {\n                case actions_1.MenuId.StatusBarWindowIndicatorMenu:\n                case actions_1.MenuId.MenubarFileMenu:\n                    return true;\n            }\n            return false;\n        }\n        schema.isProposedAPI = isProposedAPI;\n        function isValidMenuItems(menu, collector) {\n            if (!Array.isArray(menu)) {\n                collector.error(nls_1.localize('requirearray', \"menu items must be an array\"));\n                return false;\n            }\n            for (let item of menu) {\n                if (typeof item.command !== 'string') {\n                    collector.error(nls_1.localize('requirestring', \"property `{0}` is mandatory and must be of type `string`\", 'command'));\n                    return false;\n                }\n                if (item.alt && typeof item.alt !== 'string') {\n                    collector.error(nls_1.localize('optstring', \"property `{0}` can be omitted or must be of type `string`\", 'alt'));\n                    return false;\n                }\n                if (item.when && typeof item.when !== 'string') {\n                    collector.error(nls_1.localize('optstring', \"property `{0}` can be omitted or must be of type `string`\", 'when'));\n                    return false;\n                }\n                if (item.group && typeof item.group !== 'string') {\n                    collector.error(nls_1.localize('optstring', \"property `{0}` can be omitted or must be of type `string`\", 'group'));\n                    return false;\n                }\n            }\n            return true;\n        }\n        schema.isValidMenuItems = isValidMenuItems;\n        const menuItem = {\n            type: 'object',\n            properties: {\n                command: {\n                    description: nls_1.localize('vscode.extension.contributes.menuItem.command', 'Identifier of the command to execute. The command must be declared in the \\'commands\\'-section'),\n                    type: 'string'\n                },\n                alt: {\n                    description: nls_1.localize('vscode.extension.contributes.menuItem.alt', 'Identifier of an alternative command to execute. The command must be declared in the \\'commands\\'-section'),\n                    type: 'string'\n                },\n                when: {\n                    description: nls_1.localize('vscode.extension.contributes.menuItem.when', 'Condition which must be true to show this item'),\n                    type: 'string'\n                },\n                group: {\n                    description: nls_1.localize('vscode.extension.contributes.menuItem.group', 'Group into which this command belongs'),\n                    type: 'string'\n                }\n            }\n        };\n        schema.menusContribtion = {\n            description: nls_1.localize('vscode.extension.contributes.menus', \"Contributes menu items to the editor\"),\n            type: 'object',\n            properties: {\n                'commandPalette': {\n                    description: nls_1.localize('menus.commandPalette', \"The Command Palette\"),\n                    type: 'array',\n                    items: menuItem\n                },\n                'touchBar': {\n                    description: nls_1.localize('menus.touchBar', \"The touch bar (macOS only)\"),\n                    type: 'array',\n                    items: menuItem\n                },\n                'editor/title': {\n                    description: nls_1.localize('menus.editorTitle', \"The editor title menu\"),\n                    type: 'array',\n                    items: menuItem\n                },\n                'editor/context': {\n                    description: nls_1.localize('menus.editorContext', \"The editor context menu\"),\n                    type: 'array',\n                    items: menuItem\n                },\n                'explorer/context': {\n                    description: nls_1.localize('menus.explorerContext', \"The file explorer context menu\"),\n                    type: 'array',\n                    items: menuItem\n                },\n                'editor/title/context': {\n                    description: nls_1.localize('menus.editorTabContext', \"The editor tabs context menu\"),\n                    type: 'array',\n                    items: menuItem\n                },\n                'debug/callstack/context': {\n                    description: nls_1.localize('menus.debugCallstackContext', \"The debug callstack context menu\"),\n                    type: 'array',\n                    items: menuItem\n                },\n                'debug/toolBar': {\n                    description: nls_1.localize('menus.debugToolBar', \"The debug toolbar menu\"),\n                    type: 'array',\n                    items: menuItem\n                },\n                'scm/title': {\n                    description: nls_1.localize('menus.scmTitle', \"The Source Control title menu\"),\n                    type: 'array',\n                    items: menuItem\n                },\n                'scm/sourceControl': {\n                    description: nls_1.localize('menus.scmSourceControl', \"The Source Control menu\"),\n                    type: 'array',\n                    items: menuItem\n                },\n                'scm/resourceGroup/context': {\n                    description: nls_1.localize('menus.resourceGroupContext', \"The Source Control resource group context menu\"),\n                    type: 'array',\n                    items: menuItem\n                },\n                'scm/resourceState/context': {\n                    description: nls_1.localize('menus.resourceStateContext', \"The Source Control resource state context menu\"),\n                    type: 'array',\n                    items: menuItem\n                },\n                'view/title': {\n                    description: nls_1.localize('view.viewTitle', \"The contributed view title menu\"),\n                    type: 'array',\n                    items: menuItem\n                },\n                'view/item/context': {\n                    description: nls_1.localize('view.itemContext', \"The contributed view item context menu\"),\n                    type: 'array',\n                    items: menuItem\n                }\n            }\n        };\n        function isValidCommand(command, collector) {\n            if (!command) {\n                collector.error(nls_1.localize('nonempty', \"expected non-empty value.\"));\n                return false;\n            }\n            if (strings_1.isFalsyOrWhitespace(command.command)) {\n                collector.error(nls_1.localize('requirestring', \"property `{0}` is mandatory and must be of type `string`\", 'command'));\n                return false;\n            }\n            if (!isValidLocalizedString(command.title, collector, 'title')) {\n                return false;\n            }\n            if (command.category && !isValidLocalizedString(command.category, collector, 'category')) {\n                return false;\n            }\n            if (!isValidIcon(command.icon, collector)) {\n                return false;\n            }\n            return true;\n        }\n        schema.isValidCommand = isValidCommand;\n        function isValidIcon(icon, collector) {\n            if (typeof icon === 'undefined') {\n                return true;\n            }\n            if (typeof icon === 'string') {\n                return true;\n            }\n            else if (typeof icon.dark === 'string' && typeof icon.light === 'string') {\n                return true;\n            }\n            collector.error(nls_1.localize('opticon', \"property `icon` can be omitted or must be either a string or a literal like `{dark, light}`\"));\n            return false;\n        }\n        function isValidLocalizedString(localized, collector, propertyName) {\n            if (typeof localized === 'undefined') {\n                collector.error(nls_1.localize('requireStringOrObject', \"property `{0}` is mandatory and must be of type `string` or `object`\", propertyName));\n                return false;\n            }\n            else if (typeof localized === 'string' && strings_1.isFalsyOrWhitespace(localized)) {\n                collector.error(nls_1.localize('requirestring', \"property `{0}` is mandatory and must be of type `string`\", propertyName));\n                return false;\n            }\n            else if (typeof localized !== 'string' && (strings_1.isFalsyOrWhitespace(localized.original) || strings_1.isFalsyOrWhitespace(localized.value))) {\n                collector.error(nls_1.localize('requirestrings', \"properties `{0}` and `{1}` are mandatory and must be of type `string`\", `${propertyName}.value`, `${propertyName}.original`));\n                return false;\n            }\n            return true;\n        }\n        const commandType = {\n            type: 'object',\n            required: ['command', 'title'],\n            properties: {\n                command: {\n                    description: nls_1.localize('vscode.extension.contributes.commandType.command', 'Identifier of the command to execute'),\n                    type: 'string'\n                },\n                title: {\n                    description: nls_1.localize('vscode.extension.contributes.commandType.title', 'Title by which the command is represented in the UI'),\n                    type: 'string'\n                },\n                category: {\n                    description: nls_1.localize('vscode.extension.contributes.commandType.category', '(Optional) Category string by the command is grouped in the UI'),\n                    type: 'string'\n                },\n                icon: {\n                    description: nls_1.localize('vscode.extension.contributes.commandType.icon', '(Optional) Icon which is used to represent the command in the UI. Either a file path or a themable configuration'),\n                    anyOf: [{\n                            type: 'string'\n                        },\n                        {\n                            type: 'object',\n                            properties: {\n                                light: {\n                                    description: nls_1.localize('vscode.extension.contributes.commandType.icon.light', 'Icon path when a light theme is used'),\n                                    type: 'string'\n                                },\n                                dark: {\n                                    description: nls_1.localize('vscode.extension.contributes.commandType.icon.dark', 'Icon path when a dark theme is used'),\n                                    type: 'string'\n                                }\n                            }\n                        }]\n                }\n            }\n        };\n        schema.commandsContribution = {\n            description: nls_1.localize('vscode.extension.contributes.commands', \"Contributes commands to the command palette.\"),\n            oneOf: [\n                commandType,\n                {\n                    type: 'array',\n                    items: commandType\n                }\n            ]\n        };\n    })(schema || (schema = {}));\n    let _commandRegistrations = [];\n    extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint({\n        extensionPoint: 'commands',\n        jsonSchema: schema.commandsContribution\n    }).setHandler(extensions => {\n        function handleCommand(userFriendlyCommand, extension, disposables) {\n            if (!schema.isValidCommand(userFriendlyCommand, extension.collector)) {\n                return;\n            }\n            const { icon, category, title, command } = userFriendlyCommand;\n            let absoluteIcon;\n            if (icon) {\n                if (typeof icon === 'string') {\n                    absoluteIcon = { dark: resources.joinPath(extension.description.extensionLocation, icon) };\n                }\n                else {\n                    absoluteIcon = {\n                        dark: resources.joinPath(extension.description.extensionLocation, icon.dark),\n                        light: resources.joinPath(extension.description.extensionLocation, icon.light)\n                    };\n                }\n            }\n            if (actions_1.MenuRegistry.getCommand(command)) {\n                extension.collector.info(nls_1.localize('dup', \"Command `{0}` appears multiple times in the `commands` section.\", userFriendlyCommand.command));\n            }\n            const registration = actions_1.MenuRegistry.addCommand({ id: command, title, category, iconLocation: absoluteIcon });\n            disposables.push(registration);\n        }\n        // remove all previous command registrations\n        _commandRegistrations = lifecycle_1.dispose(_commandRegistrations);\n        for (let extension of extensions) {\n            const { value } = extension;\n            if (Array.isArray(value)) {\n                for (let command of value) {\n                    handleCommand(command, extension, _commandRegistrations);\n                }\n            }\n            else {\n                handleCommand(value, extension, _commandRegistrations);\n            }\n        }\n    });\n    let _menuRegistrations = [];\n    extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint({\n        extensionPoint: 'menus',\n        jsonSchema: schema.menusContribtion\n    }).setHandler(extensions => {\n        // remove all previous menu registrations\n        _menuRegistrations = lifecycle_1.dispose(_menuRegistrations);\n        for (let extension of extensions) {\n            const { value, collector } = extension;\n            collections_1.forEach(value, entry => {\n                if (!schema.isValidMenuItems(entry.value, collector)) {\n                    return;\n                }\n                const menu = schema.parseMenuId(entry.key);\n                if (typeof menu !== 'number') {\n                    collector.warn(nls_1.localize('menuId.invalid', \"`{0}` is not a valid menu identifier\", entry.key));\n                    return;\n                }\n                if (schema.isProposedAPI(menu) && !extension.description.enableProposedApi) {\n                    collector.error(nls_1.localize('proposedAPI.invalid', \"{0} is a proposed menu identifier and is only available when running out of dev or with the following command line switch: --enable-proposed-api {1}\", entry.key, extension.description.identifier.value));\n                    return;\n                }\n                for (let item of entry.value) {\n                    let command = actions_1.MenuRegistry.getCommand(item.command);\n                    let alt = item.alt && actions_1.MenuRegistry.getCommand(item.alt);\n                    if (!command) {\n                        collector.error(nls_1.localize('missing.command', \"Menu item references a command `{0}` which is not defined in the 'commands' section.\", item.command));\n                        continue;\n                    }\n                    if (item.alt && !alt) {\n                        collector.warn(nls_1.localize('missing.altCommand', \"Menu item references an alt-command `{0}` which is not defined in the 'commands' section.\", item.alt));\n                    }\n                    if (item.command === item.alt) {\n                        collector.info(nls_1.localize('dupe.command', \"Menu item references the same command as default and alt-command\"));\n                    }\n                    let group;\n                    let order;\n                    if (item.group) {\n                        const idx = item.group.lastIndexOf('@');\n                        if (idx > 0) {\n                            group = item.group.substr(0, idx);\n                            order = Number(item.group.substr(idx + 1)) || undefined;\n                        }\n                        else {\n                            group = item.group;\n                        }\n                    }\n                    const registration = actions_1.MenuRegistry.appendMenuItem(menu, {\n                        command,\n                        alt,\n                        group,\n                        order,\n                        when: contextkey_1.ContextKeyExpr.deserialize(item.when)\n                    });\n                    _menuRegistrations.push(registration);\n                }\n            });\n        }\n    });\n});\n",null]}