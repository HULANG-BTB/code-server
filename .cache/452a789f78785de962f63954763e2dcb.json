{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/common/lifecycle.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/lifecycle.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar functional_1 = require(\"vs/base/common/functional\");\nfunction isDisposable(thing) {\n    return typeof thing.dispose === 'function'\n        && thing.dispose.length === 0;\n}\nexports.isDisposable = isDisposable;\nfunction dispose(first) {\n    var rest = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        rest[_i - 1] = arguments[_i];\n    }\n    if (Array.isArray(first)) {\n        first.forEach(function (d) { return d && d.dispose(); });\n        return [];\n    }\n    else if (rest.length === 0) {\n        if (first) {\n            first.dispose();\n            return first;\n        }\n        return undefined;\n    }\n    else {\n        dispose(first);\n        dispose(rest);\n        return [];\n    }\n}\nexports.dispose = dispose;\nfunction combinedDisposable(disposables) {\n    return { dispose: function () { return dispose(disposables); } };\n}\nexports.combinedDisposable = combinedDisposable;\nfunction toDisposable(fn) {\n    return { dispose: function () { fn(); } };\n}\nexports.toDisposable = toDisposable;\nvar Disposable = /** @class */ (function () {\n    function Disposable() {\n        this._toDispose = [];\n        this._lifecycle_disposable_isDisposed = false;\n    }\n    Object.defineProperty(Disposable.prototype, \"toDispose\", {\n        get: function () { return this._toDispose; },\n        enumerable: true,\n        configurable: true\n    });\n    Disposable.prototype.dispose = function () {\n        this._lifecycle_disposable_isDisposed = true;\n        this._toDispose = dispose(this._toDispose);\n    };\n    Disposable.prototype._register = function (t) {\n        if (this._lifecycle_disposable_isDisposed) {\n            console.warn('Registering disposable on object that has already been disposed.');\n            t.dispose();\n        }\n        else {\n            this._toDispose.push(t);\n        }\n        return t;\n    };\n    Disposable.None = Object.freeze({ dispose: function () { } });\n    return Disposable;\n}());\nexports.Disposable = Disposable;\nvar ReferenceCollection = /** @class */ (function () {\n    function ReferenceCollection() {\n        this.references = Object.create(null);\n    }\n    ReferenceCollection.prototype.acquire = function (key) {\n        var _this = this;\n        var reference = this.references[key];\n        if (!reference) {\n            reference = this.references[key] = { counter: 0, object: this.createReferencedObject(key) };\n        }\n        var object = reference.object;\n        var dispose = functional_1.once(function () {\n            if (--reference.counter === 0) {\n                _this.destroyReferencedObject(key, reference.object);\n                delete _this.references[key];\n            }\n        });\n        reference.counter++;\n        return { object: object, dispose: dispose };\n    };\n    return ReferenceCollection;\n}());\nexports.ReferenceCollection = ReferenceCollection;\nvar ImmortalReference = /** @class */ (function () {\n    function ImmortalReference(object) {\n        this.object = object;\n    }\n    ImmortalReference.prototype.dispose = function () { };\n    return ImmortalReference;\n}());\nexports.ImmortalReference = ImmortalReference;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/common/lifecycle.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/common/lifecycle.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { once } from 'vs/base/common/functional';\n\nexport interface IDisposable {\n\tdispose(): void;\n}\n\nexport function isDisposable<E extends object>(thing: E): thing is E & IDisposable {\n\treturn typeof (<IDisposable><any>thing).dispose === 'function'\n\t\t&& (<IDisposable><any>thing).dispose.length === 0;\n}\n\nexport function dispose<T extends IDisposable>(disposable: T): T;\nexport function dispose<T extends IDisposable>(...disposables: Array<T | undefined>): T[];\nexport function dispose<T extends IDisposable>(disposables: T[]): T[];\nexport function dispose<T extends IDisposable>(first: T | T[], ...rest: T[]): T | T[] | undefined {\n\tif (Array.isArray(first)) {\n\t\tfirst.forEach(d => d && d.dispose());\n\t\treturn [];\n\t} else if (rest.length === 0) {\n\t\tif (first) {\n\t\t\tfirst.dispose();\n\t\t\treturn first;\n\t\t}\n\t\treturn undefined;\n\t} else {\n\t\tdispose(first);\n\t\tdispose(rest);\n\t\treturn [];\n\t}\n}\n\nexport function combinedDisposable(disposables: IDisposable[]): IDisposable {\n\treturn { dispose: () => dispose(disposables) };\n}\n\nexport function toDisposable(fn: () => void): IDisposable {\n\treturn { dispose() { fn(); } };\n}\n\nexport abstract class Disposable implements IDisposable {\n\n\tstatic None = Object.freeze<IDisposable>({ dispose() { } });\n\n\tprotected _toDispose: IDisposable[] = [];\n\tprotected get toDispose(): IDisposable[] { return this._toDispose; }\n\n\tprivate _lifecycle_disposable_isDisposed = false;\n\n\tpublic dispose(): void {\n\t\tthis._lifecycle_disposable_isDisposed = true;\n\t\tthis._toDispose = dispose(this._toDispose);\n\t}\n\n\tprotected _register<T extends IDisposable>(t: T): T {\n\t\tif (this._lifecycle_disposable_isDisposed) {\n\t\t\tconsole.warn('Registering disposable on object that has already been disposed.');\n\t\t\tt.dispose();\n\t\t} else {\n\t\t\tthis._toDispose.push(t);\n\t\t}\n\n\t\treturn t;\n\t}\n}\n\nexport interface IReference<T> extends IDisposable {\n\treadonly object: T;\n}\n\nexport abstract class ReferenceCollection<T> {\n\n\tprivate references: { [key: string]: { readonly object: T; counter: number; } } = Object.create(null);\n\n\tconstructor() { }\n\n\tacquire(key: string): IReference<T> {\n\t\tlet reference = this.references[key];\n\n\t\tif (!reference) {\n\t\t\treference = this.references[key] = { counter: 0, object: this.createReferencedObject(key) };\n\t\t}\n\n\t\tconst { object } = reference;\n\t\tconst dispose = once(() => {\n\t\t\tif (--reference.counter === 0) {\n\t\t\t\tthis.destroyReferencedObject(key, reference.object);\n\t\t\t\tdelete this.references[key];\n\t\t\t}\n\t\t});\n\n\t\treference.counter++;\n\n\t\treturn { object, dispose };\n\t}\n\n\tprotected abstract createReferencedObject(key: string): T;\n\tprotected abstract destroyReferencedObject(key: string, object: T): void;\n}\n\nexport class ImmortalReference<T> implements IReference<T> {\n\tconstructor(public object: T) { }\n\tdispose(): void { /* noop */ }\n}\n"]}]}