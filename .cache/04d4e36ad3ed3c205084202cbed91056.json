{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/folding.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/folding.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/types\", \"vs/base/common/strings\", \"vs/base/common/async\", \"vs/base/common/keyCodes\", \"vs/base/common/lifecycle\", \"vs/editor/common/editorCommon\", \"vs/editor/browser/editorExtensions\", \"vs/editor/browser/editorBrowser\", \"vs/editor/contrib/folding/foldingModel\", \"./foldingDecorations\", \"vs/editor/common/editorContextKeys\", \"vs/editor/contrib/folding/hiddenRangeModel\", \"vs/editor/common/modes/languageConfigurationRegistry\", \"vs/editor/contrib/folding/indentRangeProvider\", \"vs/editor/common/modes\", \"./syntaxRangeProvider\", \"vs/editor/contrib/folding/intializingRangeProvider\", \"vs/platform/keybinding/common/keybindingsRegistry\", \"vs/base/common/errors\", \"vs/css!./folding\"], function (require, exports, nls, types, strings_1, async_1, keyCodes_1, lifecycle_1, editorCommon_1, editorExtensions_1, editorBrowser_1, foldingModel_1, foldingDecorations_1, editorContextKeys_1, hiddenRangeModel_1, languageConfigurationRegistry_1, indentRangeProvider_1, modes_1, syntaxRangeProvider_1, intializingRangeProvider_1, keybindingsRegistry_1, errors_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.ID = 'editor.contrib.folding';\n    class FoldingController {\n        constructor(editor) {\n            this.editor = editor;\n            this._isEnabled = this.editor.getConfiguration().contribInfo.folding;\n            this._autoHideFoldingControls = this.editor.getConfiguration().contribInfo.showFoldingControls === 'mouseover';\n            this._useFoldingProviders = this.editor.getConfiguration().contribInfo.foldingStrategy !== 'indentation';\n            this.globalToDispose = [];\n            this.localToDispose = [];\n            this.foldingDecorationProvider = new foldingDecorations_1.FoldingDecorationProvider(editor);\n            this.foldingDecorationProvider.autoHideFoldingControls = this._autoHideFoldingControls;\n            this.globalToDispose.push(this.editor.onDidChangeModel(() => this.onModelChanged()));\n            this.globalToDispose.push(this.editor.onDidChangeConfiguration((e) => {\n                if (e.contribInfo) {\n                    let oldIsEnabled = this._isEnabled;\n                    this._isEnabled = this.editor.getConfiguration().contribInfo.folding;\n                    if (oldIsEnabled !== this._isEnabled) {\n                        this.onModelChanged();\n                    }\n                    let oldShowFoldingControls = this._autoHideFoldingControls;\n                    this._autoHideFoldingControls = this.editor.getConfiguration().contribInfo.showFoldingControls === 'mouseover';\n                    if (oldShowFoldingControls !== this._autoHideFoldingControls) {\n                        this.foldingDecorationProvider.autoHideFoldingControls = this._autoHideFoldingControls;\n                        this.onModelContentChanged();\n                    }\n                    let oldUseFoldingProviders = this._useFoldingProviders;\n                    this._useFoldingProviders = this.editor.getConfiguration().contribInfo.foldingStrategy !== 'indentation';\n                    if (oldUseFoldingProviders !== this._useFoldingProviders) {\n                        this.onFoldingStrategyChanged();\n                    }\n                }\n            }));\n            this.globalToDispose.push({ dispose: () => lifecycle_1.dispose(this.localToDispose) });\n            this.onModelChanged();\n        }\n        static get(editor) {\n            return editor.getContribution(exports.ID);\n        }\n        getId() {\n            return exports.ID;\n        }\n        dispose() {\n            this.globalToDispose = lifecycle_1.dispose(this.globalToDispose);\n        }\n        /**\n         * Store view state.\n         */\n        saveViewState() {\n            let model = this.editor.getModel();\n            if (!model || !this._isEnabled || model.isTooLargeForTokenization()) {\n                return {};\n            }\n            if (this.foldingModel) { // disposed ?\n                let collapsedRegions = this.foldingModel.isInitialized ? this.foldingModel.getMemento() : this.hiddenRangeModel.getMemento();\n                let provider = this.rangeProvider ? this.rangeProvider.id : undefined;\n                return { collapsedRegions, lineCount: model.getLineCount(), provider };\n            }\n            return undefined;\n        }\n        /**\n         * Restore view state.\n         */\n        restoreViewState(state) {\n            let model = this.editor.getModel();\n            if (!model || !this._isEnabled || model.isTooLargeForTokenization() || !this.hiddenRangeModel) {\n                return;\n            }\n            if (!state || !state.collapsedRegions || state.lineCount !== model.getLineCount()) {\n                return;\n            }\n            if (state.provider === syntaxRangeProvider_1.ID_SYNTAX_PROVIDER || state.provider === intializingRangeProvider_1.ID_INIT_PROVIDER) {\n                this.foldingStateMemento = state;\n            }\n            const collapsedRegions = state.collapsedRegions;\n            // set the hidden ranges right away, before waiting for the folding model.\n            if (this.hiddenRangeModel.applyMemento(collapsedRegions)) {\n                const foldingModel = this.getFoldingModel();\n                if (foldingModel) {\n                    foldingModel.then(foldingModel => {\n                        if (foldingModel) {\n                            foldingModel.applyMemento(collapsedRegions);\n                        }\n                    }).then(undefined, errors_1.onUnexpectedError);\n                }\n            }\n        }\n        onModelChanged() {\n            this.localToDispose = lifecycle_1.dispose(this.localToDispose);\n            let model = this.editor.getModel();\n            if (!this._isEnabled || !model || model.isTooLargeForTokenization()) {\n                // huge files get no view model, so they cannot support hidden areas\n                return;\n            }\n            this.foldingModel = new foldingModel_1.FoldingModel(model, this.foldingDecorationProvider);\n            this.localToDispose.push(this.foldingModel);\n            this.hiddenRangeModel = new hiddenRangeModel_1.HiddenRangeModel(this.foldingModel);\n            this.localToDispose.push(this.hiddenRangeModel);\n            this.localToDispose.push(this.hiddenRangeModel.onDidChange(hr => this.onHiddenRangesChanges(hr)));\n            this.updateScheduler = new async_1.Delayer(200);\n            this.cursorChangedScheduler = new async_1.RunOnceScheduler(() => this.revealCursor(), 200);\n            this.localToDispose.push(this.cursorChangedScheduler);\n            this.localToDispose.push(modes_1.FoldingRangeProviderRegistry.onDidChange(() => this.onFoldingStrategyChanged()));\n            this.localToDispose.push(this.editor.onDidChangeModelLanguageConfiguration(() => this.onFoldingStrategyChanged())); // covers model language changes as well\n            this.localToDispose.push(this.editor.onDidChangeModelContent(() => this.onModelContentChanged()));\n            this.localToDispose.push(this.editor.onDidChangeCursorPosition(() => this.onCursorPositionChanged()));\n            this.localToDispose.push(this.editor.onMouseDown(e => this.onEditorMouseDown(e)));\n            this.localToDispose.push(this.editor.onMouseUp(e => this.onEditorMouseUp(e)));\n            this.localToDispose.push({\n                dispose: () => {\n                    if (this.foldingRegionPromise) {\n                        this.foldingRegionPromise.cancel();\n                        this.foldingRegionPromise = null;\n                    }\n                    if (this.updateScheduler) {\n                        this.updateScheduler.cancel();\n                    }\n                    this.updateScheduler = null;\n                    this.foldingModel = null;\n                    this.foldingModelPromise = null;\n                    this.hiddenRangeModel = null;\n                    this.cursorChangedScheduler = null;\n                    this.foldingStateMemento = null;\n                    if (this.rangeProvider) {\n                        this.rangeProvider.dispose();\n                    }\n                    this.rangeProvider = null;\n                }\n            });\n            this.onModelContentChanged();\n        }\n        onFoldingStrategyChanged() {\n            if (this.rangeProvider) {\n                this.rangeProvider.dispose();\n            }\n            this.rangeProvider = null;\n            this.onModelContentChanged();\n        }\n        getRangeProvider(editorModel) {\n            if (this.rangeProvider) {\n                return this.rangeProvider;\n            }\n            this.rangeProvider = new indentRangeProvider_1.IndentRangeProvider(editorModel); // fallback\n            if (this._useFoldingProviders && this.foldingModel) {\n                let foldingProviders = modes_1.FoldingRangeProviderRegistry.ordered(this.foldingModel.textModel);\n                if (foldingProviders.length === 0 && this.foldingStateMemento && this.foldingStateMemento.collapsedRegions) {\n                    const rangeProvider = this.rangeProvider = new intializingRangeProvider_1.InitializingRangeProvider(editorModel, this.foldingStateMemento.collapsedRegions, () => {\n                        // if after 30 the InitializingRangeProvider is still not replaced, force a refresh\n                        this.foldingStateMemento = null;\n                        this.onFoldingStrategyChanged();\n                    }, 30000);\n                    return rangeProvider; // keep memento in case there are still no foldingProviders on the next request.\n                }\n                else if (foldingProviders.length > 0) {\n                    this.rangeProvider = new syntaxRangeProvider_1.SyntaxRangeProvider(editorModel, foldingProviders);\n                }\n            }\n            this.foldingStateMemento = null;\n            return this.rangeProvider;\n        }\n        getFoldingModel() {\n            return this.foldingModelPromise;\n        }\n        onModelContentChanged() {\n            if (this.updateScheduler) {\n                if (this.foldingRegionPromise) {\n                    this.foldingRegionPromise.cancel();\n                    this.foldingRegionPromise = null;\n                }\n                this.foldingModelPromise = this.updateScheduler.trigger(() => {\n                    const foldingModel = this.foldingModel;\n                    if (!foldingModel) { // null if editor has been disposed, or folding turned off\n                        return null;\n                    }\n                    let foldingRegionPromise = this.foldingRegionPromise = async_1.createCancelablePromise(token => this.getRangeProvider(foldingModel.textModel).compute(token));\n                    return foldingRegionPromise.then(foldingRanges => {\n                        if (foldingRanges && foldingRegionPromise === this.foldingRegionPromise) { // new request or cancelled in the meantime?\n                            // some cursors might have moved into hidden regions, make sure they are in expanded regions\n                            let selections = this.editor.getSelections();\n                            let selectionLineNumbers = selections ? selections.map(s => s.startLineNumber) : [];\n                            foldingModel.update(foldingRanges, selectionLineNumbers);\n                        }\n                        return foldingModel;\n                    });\n                }).then(undefined, (err) => {\n                    errors_1.onUnexpectedError(err);\n                    return null;\n                });\n            }\n        }\n        onHiddenRangesChanges(hiddenRanges) {\n            if (this.hiddenRangeModel && hiddenRanges.length) {\n                let selections = this.editor.getSelections();\n                if (selections) {\n                    if (this.hiddenRangeModel.adjustSelections(selections)) {\n                        this.editor.setSelections(selections);\n                    }\n                }\n            }\n            this.editor.setHiddenAreas(hiddenRanges);\n        }\n        onCursorPositionChanged() {\n            if (this.hiddenRangeModel && this.hiddenRangeModel.hasRanges()) {\n                this.cursorChangedScheduler.schedule();\n            }\n        }\n        revealCursor() {\n            const foldingModel = this.getFoldingModel();\n            if (!foldingModel) {\n                return;\n            }\n            foldingModel.then(foldingModel => {\n                if (foldingModel) {\n                    let selections = this.editor.getSelections();\n                    if (selections && selections.length > 0) {\n                        let toToggle = [];\n                        for (let selection of selections) {\n                            let lineNumber = selection.selectionStartLineNumber;\n                            if (this.hiddenRangeModel && this.hiddenRangeModel.isHidden(lineNumber)) {\n                                toToggle.push(...foldingModel.getAllRegionsAtLine(lineNumber, r => r.isCollapsed && lineNumber > r.startLineNumber));\n                            }\n                        }\n                        if (toToggle.length) {\n                            foldingModel.toggleCollapseState(toToggle);\n                            this.reveal(selections[0].getPosition());\n                        }\n                    }\n                }\n            }).then(undefined, errors_1.onUnexpectedError);\n        }\n        onEditorMouseDown(e) {\n            this.mouseDownInfo = null;\n            if (!this.hiddenRangeModel || !e.target || !e.target.range) {\n                return;\n            }\n            if (!e.event.leftButton && !e.event.middleButton) {\n                return;\n            }\n            const range = e.target.range;\n            let iconClicked = false;\n            switch (e.target.type) {\n                case editorBrowser_1.MouseTargetType.GUTTER_LINE_DECORATIONS:\n                    const data = e.target.detail;\n                    const offsetLeftInGutter = e.target.element.offsetLeft;\n                    const gutterOffsetX = data.offsetX - offsetLeftInGutter;\n                    // const gutterOffsetX = data.offsetX - data.glyphMarginWidth - data.lineNumbersWidth - data.glyphMarginLeft;\n                    // TODO@joao TODO@alex TODO@martin this is such that we don't collide with dirty diff\n                    if (gutterOffsetX < 5) { // the whitespace between the border and the real folding icon border is 5px\n                        return;\n                    }\n                    iconClicked = true;\n                    break;\n                case editorBrowser_1.MouseTargetType.CONTENT_EMPTY: {\n                    if (this.hiddenRangeModel.hasRanges()) {\n                        const data = e.target.detail;\n                        if (!data.isAfterLines) {\n                            break;\n                        }\n                    }\n                    return;\n                }\n                case editorBrowser_1.MouseTargetType.CONTENT_TEXT: {\n                    if (this.hiddenRangeModel.hasRanges()) {\n                        let model = this.editor.getModel();\n                        if (model && range.startColumn === model.getLineMaxColumn(range.startLineNumber)) {\n                            break;\n                        }\n                    }\n                    return;\n                }\n                default:\n                    return;\n            }\n            this.mouseDownInfo = { lineNumber: range.startLineNumber, iconClicked };\n        }\n        onEditorMouseUp(e) {\n            const foldingModel = this.getFoldingModel();\n            if (!foldingModel || !this.mouseDownInfo || !e.target) {\n                return;\n            }\n            let lineNumber = this.mouseDownInfo.lineNumber;\n            let iconClicked = this.mouseDownInfo.iconClicked;\n            let range = e.target.range;\n            if (!range || range.startLineNumber !== lineNumber) {\n                return;\n            }\n            if (iconClicked) {\n                if (e.target.type !== editorBrowser_1.MouseTargetType.GUTTER_LINE_DECORATIONS) {\n                    return;\n                }\n            }\n            else {\n                let model = this.editor.getModel();\n                if (!model || range.startColumn !== model.getLineMaxColumn(lineNumber)) {\n                    return;\n                }\n            }\n            foldingModel.then(foldingModel => {\n                if (foldingModel) {\n                    let region = foldingModel.getRegionAtLine(lineNumber);\n                    if (region && region.startLineNumber === lineNumber) {\n                        let isCollapsed = region.isCollapsed;\n                        if (iconClicked || isCollapsed) {\n                            let toToggle = [region];\n                            if (e.event.middleButton || e.event.shiftKey) {\n                                toToggle.push(...foldingModel.getRegionsInside(region, r => r.isCollapsed === isCollapsed));\n                            }\n                            foldingModel.toggleCollapseState(toToggle);\n                            this.reveal({ lineNumber, column: 1 });\n                        }\n                    }\n                }\n            }).then(undefined, errors_1.onUnexpectedError);\n        }\n        reveal(position) {\n            this.editor.revealPositionInCenterIfOutsideViewport(position, editorCommon_1.ScrollType.Smooth);\n        }\n    }\n    FoldingController.MAX_FOLDING_REGIONS = 5000;\n    exports.FoldingController = FoldingController;\n    class FoldingAction extends editorExtensions_1.EditorAction {\n        runEditorCommand(accessor, editor, args) {\n            let foldingController = FoldingController.get(editor);\n            if (!foldingController) {\n                return;\n            }\n            let foldingModelPromise = foldingController.getFoldingModel();\n            if (foldingModelPromise) {\n                this.reportTelemetry(accessor, editor);\n                return foldingModelPromise.then(foldingModel => {\n                    if (foldingModel) {\n                        this.invoke(foldingController, foldingModel, editor, args);\n                        const selection = editor.getSelection();\n                        if (selection) {\n                            foldingController.reveal(selection.getStartPosition());\n                        }\n                    }\n                });\n            }\n        }\n        getSelectedLines(editor) {\n            let selections = editor.getSelections();\n            return selections ? selections.map(s => s.startLineNumber) : [];\n        }\n        getLineNumbers(args, editor) {\n            if (args && args.selectionLines) {\n                return args.selectionLines.map(l => l + 1); // to 0-bases line numbers\n            }\n            return this.getSelectedLines(editor);\n        }\n        run(_accessor, _editor) {\n        }\n    }\n    function foldingArgumentsConstraint(args) {\n        if (!types.isUndefined(args)) {\n            if (!types.isObject(args)) {\n                return false;\n            }\n            const foldingArgs = args;\n            if (!types.isUndefined(foldingArgs.levels) && !types.isNumber(foldingArgs.levels)) {\n                return false;\n            }\n            if (!types.isUndefined(foldingArgs.direction) && !types.isString(foldingArgs.direction)) {\n                return false;\n            }\n            if (!types.isUndefined(foldingArgs.selectionLines) && (!types.isArray(foldingArgs.selectionLines) || !foldingArgs.selectionLines.every(types.isNumber))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    class UnfoldAction extends FoldingAction {\n        constructor() {\n            super({\n                id: 'editor.unfold',\n                label: nls.localize('unfoldAction.label', \"Unfold\"),\n                alias: 'Unfold',\n                precondition: null,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.US_CLOSE_SQUARE_BRACKET,\n                    mac: {\n                        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.US_CLOSE_SQUARE_BRACKET\n                    },\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                description: {\n                    description: 'Unfold the content in the editor',\n                    args: [\n                        {\n                            name: 'Unfold editor argument',\n                            description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t\t* 'levels': Number of levels to unfold. If not set, defaults to 1.\n\t\t\t\t\t\t* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.\n\t\t\t\t\t\t* 'selectionLines': The start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.\n\t\t\t\t\t\t`,\n                            constraint: foldingArgumentsConstraint,\n                            schema: {\n                                'type': 'object',\n                                'properties': {\n                                    'levels': {\n                                        'type': 'number',\n                                        'default': 1\n                                    },\n                                    'direction': {\n                                        'type': 'string',\n                                        'enum': ['up', 'down'],\n                                        'default': 'down'\n                                    },\n                                    'selectionLines': {\n                                        'type': 'array',\n                                        'items': {\n                                            'type': 'number'\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    ]\n                }\n            });\n        }\n        invoke(_foldingController, foldingModel, editor, args) {\n            let levels = args && args.levels || 1;\n            let lineNumbers = this.getLineNumbers(args, editor);\n            if (args && args.direction === 'up') {\n                foldingModel_1.setCollapseStateLevelsUp(foldingModel, false, levels, lineNumbers);\n            }\n            else {\n                foldingModel_1.setCollapseStateLevelsDown(foldingModel, false, levels, lineNumbers);\n            }\n        }\n    }\n    class UnFoldRecursivelyAction extends FoldingAction {\n        constructor() {\n            super({\n                id: 'editor.unfoldRecursively',\n                label: nls.localize('unFoldRecursivelyAction.label', \"Unfold Recursively\"),\n                alias: 'Unfold Recursively',\n                precondition: null,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyChord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.US_CLOSE_SQUARE_BRACKET),\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        invoke(_foldingController, foldingModel, editor, _args) {\n            foldingModel_1.setCollapseStateLevelsDown(foldingModel, false, Number.MAX_VALUE, this.getSelectedLines(editor));\n        }\n    }\n    class FoldAction extends FoldingAction {\n        constructor() {\n            super({\n                id: 'editor.fold',\n                label: nls.localize('foldAction.label', \"Fold\"),\n                alias: 'Fold',\n                precondition: null,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.US_OPEN_SQUARE_BRACKET,\n                    mac: {\n                        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.US_OPEN_SQUARE_BRACKET\n                    },\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                description: {\n                    description: 'Fold the content in the editor',\n                    args: [\n                        {\n                            name: 'Fold editor argument',\n                            description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t\t\t* 'levels': Number of levels to fold. Defaults to 1.\n\t\t\t\t\t\t\t* 'direction': If 'up', folds given number of levels up otherwise folds down.\n\t\t\t\t\t\t\t* 'selectionLines': The start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.\n\t\t\t\t\t\t`,\n                            constraint: foldingArgumentsConstraint,\n                            schema: {\n                                'type': 'object',\n                                'properties': {\n                                    'levels': {\n                                        'type': 'number',\n                                        'default': 1\n                                    },\n                                    'direction': {\n                                        'type': 'string',\n                                        'enum': ['up', 'down'],\n                                        'default': 'down'\n                                    },\n                                    'selectionLines': {\n                                        'type': 'array',\n                                        'items': {\n                                            'type': 'number'\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    ]\n                }\n            });\n        }\n        invoke(_foldingController, foldingModel, editor, args) {\n            let levels = args && args.levels || 1;\n            let lineNumbers = this.getLineNumbers(args, editor);\n            if (args && args.direction === 'up') {\n                foldingModel_1.setCollapseStateLevelsUp(foldingModel, true, levels, lineNumbers);\n            }\n            else {\n                foldingModel_1.setCollapseStateLevelsDown(foldingModel, true, levels, lineNumbers);\n            }\n        }\n    }\n    class FoldRecursivelyAction extends FoldingAction {\n        constructor() {\n            super({\n                id: 'editor.foldRecursively',\n                label: nls.localize('foldRecursivelyAction.label', \"Fold Recursively\"),\n                alias: 'Fold Recursively',\n                precondition: null,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyChord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.US_OPEN_SQUARE_BRACKET),\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        invoke(_foldingController, foldingModel, editor) {\n            let selectedLines = this.getSelectedLines(editor);\n            foldingModel_1.setCollapseStateLevelsDown(foldingModel, true, Number.MAX_VALUE, selectedLines);\n        }\n    }\n    class FoldAllBlockCommentsAction extends FoldingAction {\n        constructor() {\n            super({\n                id: 'editor.foldAllBlockComments',\n                label: nls.localize('foldAllBlockComments.label', \"Fold All Block Comments\"),\n                alias: 'Fold All Block Comments',\n                precondition: null,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyChord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.US_SLASH),\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        invoke(_foldingController, foldingModel, editor) {\n            if (foldingModel.regions.hasTypes()) {\n                foldingModel_1.setCollapseStateForType(foldingModel, modes_1.FoldingRangeKind.Comment.value, true);\n            }\n            else {\n                const editorModel = editor.getModel();\n                if (!editorModel) {\n                    return;\n                }\n                let comments = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getComments(editorModel.getLanguageIdentifier().id);\n                if (comments && comments.blockCommentStartToken) {\n                    let regExp = new RegExp('^\\\\s*' + strings_1.escapeRegExpCharacters(comments.blockCommentStartToken));\n                    foldingModel_1.setCollapseStateForMatchingLines(foldingModel, regExp, true);\n                }\n            }\n        }\n    }\n    class FoldAllRegionsAction extends FoldingAction {\n        constructor() {\n            super({\n                id: 'editor.foldAllMarkerRegions',\n                label: nls.localize('foldAllMarkerRegions.label', \"Fold All Regions\"),\n                alias: 'Fold All Regions',\n                precondition: null,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyChord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_8),\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        invoke(_foldingController, foldingModel, editor) {\n            if (foldingModel.regions.hasTypes()) {\n                foldingModel_1.setCollapseStateForType(foldingModel, modes_1.FoldingRangeKind.Region.value, true);\n            }\n            else {\n                const editorModel = editor.getModel();\n                if (!editorModel) {\n                    return;\n                }\n                let foldingRules = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getFoldingRules(editorModel.getLanguageIdentifier().id);\n                if (foldingRules && foldingRules.markers && foldingRules.markers.start) {\n                    let regExp = new RegExp(foldingRules.markers.start);\n                    foldingModel_1.setCollapseStateForMatchingLines(foldingModel, regExp, true);\n                }\n            }\n        }\n    }\n    class UnfoldAllRegionsAction extends FoldingAction {\n        constructor() {\n            super({\n                id: 'editor.unfoldAllMarkerRegions',\n                label: nls.localize('unfoldAllMarkerRegions.label', \"Unfold All Regions\"),\n                alias: 'Unfold All Regions',\n                precondition: null,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyChord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_9),\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        invoke(_foldingController, foldingModel, editor) {\n            if (foldingModel.regions.hasTypes()) {\n                foldingModel_1.setCollapseStateForType(foldingModel, modes_1.FoldingRangeKind.Region.value, false);\n            }\n            else {\n                const editorModel = editor.getModel();\n                if (!editorModel) {\n                    return;\n                }\n                let foldingRules = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getFoldingRules(editorModel.getLanguageIdentifier().id);\n                if (foldingRules && foldingRules.markers && foldingRules.markers.start) {\n                    let regExp = new RegExp(foldingRules.markers.start);\n                    foldingModel_1.setCollapseStateForMatchingLines(foldingModel, regExp, false);\n                }\n            }\n        }\n    }\n    class FoldAllAction extends FoldingAction {\n        constructor() {\n            super({\n                id: 'editor.foldAll',\n                label: nls.localize('foldAllAction.label', \"Fold All\"),\n                alias: 'Fold All',\n                precondition: null,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyChord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_0),\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        invoke(_foldingController, foldingModel, _editor) {\n            foldingModel_1.setCollapseStateLevelsDown(foldingModel, true);\n        }\n    }\n    class UnfoldAllAction extends FoldingAction {\n        constructor() {\n            super({\n                id: 'editor.unfoldAll',\n                label: nls.localize('unfoldAllAction.label', \"Unfold All\"),\n                alias: 'Unfold All',\n                precondition: null,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyChord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_J),\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        invoke(_foldingController, foldingModel, _editor) {\n            foldingModel_1.setCollapseStateLevelsDown(foldingModel, false);\n        }\n    }\n    class FoldLevelAction extends FoldingAction {\n        getFoldingLevel() {\n            return parseInt(this.id.substr(FoldLevelAction.ID_PREFIX.length));\n        }\n        invoke(_foldingController, foldingModel, editor) {\n            foldingModel_1.setCollapseStateAtLevel(foldingModel, this.getFoldingLevel(), true, this.getSelectedLines(editor));\n        }\n    }\n    FoldLevelAction.ID_PREFIX = 'editor.foldLevel';\n    FoldLevelAction.ID = (level) => FoldLevelAction.ID_PREFIX + level;\n    editorExtensions_1.registerEditorContribution(FoldingController);\n    editorExtensions_1.registerEditorAction(UnfoldAction);\n    editorExtensions_1.registerEditorAction(UnFoldRecursivelyAction);\n    editorExtensions_1.registerEditorAction(FoldAction);\n    editorExtensions_1.registerEditorAction(FoldRecursivelyAction);\n    editorExtensions_1.registerEditorAction(FoldAllAction);\n    editorExtensions_1.registerEditorAction(UnfoldAllAction);\n    editorExtensions_1.registerEditorAction(FoldAllBlockCommentsAction);\n    editorExtensions_1.registerEditorAction(FoldAllRegionsAction);\n    editorExtensions_1.registerEditorAction(UnfoldAllRegionsAction);\n    for (let i = 1; i <= 7; i++) {\n        editorExtensions_1.registerInstantiatedEditorAction(new FoldLevelAction({\n            id: FoldLevelAction.ID(i),\n            label: nls.localize('foldLevelAction.label', \"Fold Level {0}\", i),\n            alias: `Fold Level ${i}`,\n            precondition: null,\n            kbOpts: {\n                kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                primary: keyCodes_1.KeyChord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | (keyCodes_1.KeyCode.KEY_0 + i)),\n                weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n            }\n        }));\n    }\n});\n",null]}