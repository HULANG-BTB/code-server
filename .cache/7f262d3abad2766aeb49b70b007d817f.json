{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/arrays.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/arrays.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/errors\"], function (require, exports, errors_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns the last element of an array.\n     * @param array The array.\n     * @param n Which element from the end (default is zero).\n     */\n    function tail(array, n = 0) {\n        return array[array.length - (1 + n)];\n    }\n    exports.tail = tail;\n    function tail2(arr) {\n        if (arr.length === 0) {\n            throw new Error('Invalid tail call');\n        }\n        return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n    }\n    exports.tail2 = tail2;\n    function equals(one, other, itemEquals = (a, b) => a === b) {\n        if (one === other) {\n            return true;\n        }\n        if (!one || !other) {\n            return false;\n        }\n        if (one.length !== other.length) {\n            return false;\n        }\n        for (let i = 0, len = one.length; i < len; i++) {\n            if (!itemEquals(one[i], other[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    exports.equals = equals;\n    function binarySearch(array, key, comparator) {\n        let low = 0, high = array.length - 1;\n        while (low <= high) {\n            const mid = ((low + high) / 2) | 0;\n            const comp = comparator(array[mid], key);\n            if (comp < 0) {\n                low = mid + 1;\n            }\n            else if (comp > 0) {\n                high = mid - 1;\n            }\n            else {\n                return mid;\n            }\n        }\n        return -(low + 1);\n    }\n    exports.binarySearch = binarySearch;\n    /**\n     * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false\n     * are located before all elements where p(x) is true.\n     * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.\n     */\n    function findFirstInSorted(array, p) {\n        let low = 0, high = array.length;\n        if (high === 0) {\n            return 0; // no children\n        }\n        while (low < high) {\n            const mid = Math.floor((low + high) / 2);\n            if (p(array[mid])) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n    exports.findFirstInSorted = findFirstInSorted;\n    /**\n     * Like `Array#sort` but always stable. Usually runs a little slower `than Array#sort`\n     * so only use this when actually needing stable sort.\n     */\n    function mergeSort(data, compare) {\n        _sort(data, compare, 0, data.length - 1, []);\n        return data;\n    }\n    exports.mergeSort = mergeSort;\n    function _merge(a, compare, lo, mid, hi, aux) {\n        let leftIdx = lo, rightIdx = mid + 1;\n        for (let i = lo; i <= hi; i++) {\n            aux[i] = a[i];\n        }\n        for (let i = lo; i <= hi; i++) {\n            if (leftIdx > mid) {\n                // left side consumed\n                a[i] = aux[rightIdx++];\n            }\n            else if (rightIdx > hi) {\n                // right side consumed\n                a[i] = aux[leftIdx++];\n            }\n            else if (compare(aux[rightIdx], aux[leftIdx]) < 0) {\n                // right element is less -> comes first\n                a[i] = aux[rightIdx++];\n            }\n            else {\n                // left element comes first (less or equal)\n                a[i] = aux[leftIdx++];\n            }\n        }\n    }\n    function _sort(a, compare, lo, hi, aux) {\n        if (hi <= lo) {\n            return;\n        }\n        const mid = lo + ((hi - lo) / 2) | 0;\n        _sort(a, compare, lo, mid, aux);\n        _sort(a, compare, mid + 1, hi, aux);\n        if (compare(a[mid], a[mid + 1]) <= 0) {\n            // left and right are sorted and if the last-left element is less\n            // or equals than the first-right element there is nothing else\n            // to do\n            return;\n        }\n        _merge(a, compare, lo, mid, hi, aux);\n    }\n    function groupBy(data, compare) {\n        const result = [];\n        let currentGroup = undefined;\n        for (const element of mergeSort(data.slice(0), compare)) {\n            if (!currentGroup || compare(currentGroup[0], element) !== 0) {\n                currentGroup = [element];\n                result.push(currentGroup);\n            }\n            else {\n                currentGroup.push(element);\n            }\n        }\n        return result;\n    }\n    exports.groupBy = groupBy;\n    /**\n     * Diffs two *sorted* arrays and computes the splices which apply the diff.\n     */\n    function sortedDiff(before, after, compare) {\n        const result = [];\n        function pushSplice(start, deleteCount, toInsert) {\n            if (deleteCount === 0 && toInsert.length === 0) {\n                return;\n            }\n            const latest = result[result.length - 1];\n            if (latest && latest.start + latest.deleteCount === start) {\n                latest.deleteCount += deleteCount;\n                latest.toInsert.push(...toInsert);\n            }\n            else {\n                result.push({ start, deleteCount, toInsert });\n            }\n        }\n        let beforeIdx = 0;\n        let afterIdx = 0;\n        while (true) {\n            if (beforeIdx === before.length) {\n                pushSplice(beforeIdx, 0, after.slice(afterIdx));\n                break;\n            }\n            if (afterIdx === after.length) {\n                pushSplice(beforeIdx, before.length - beforeIdx, []);\n                break;\n            }\n            const beforeElement = before[beforeIdx];\n            const afterElement = after[afterIdx];\n            const n = compare(beforeElement, afterElement);\n            if (n === 0) {\n                // equal\n                beforeIdx += 1;\n                afterIdx += 1;\n            }\n            else if (n < 0) {\n                // beforeElement is smaller -> before element removed\n                pushSplice(beforeIdx, 1, []);\n                beforeIdx += 1;\n            }\n            else if (n > 0) {\n                // beforeElement is greater -> after element added\n                pushSplice(beforeIdx, 0, [afterElement]);\n                afterIdx += 1;\n            }\n        }\n        return result;\n    }\n    exports.sortedDiff = sortedDiff;\n    /**\n     * Takes two *sorted* arrays and computes their delta (removed, added elements).\n     * Finishes in `Math.min(before.length, after.length)` steps.\n     */\n    function delta(before, after, compare) {\n        const splices = sortedDiff(before, after, compare);\n        const removed = [];\n        const added = [];\n        for (const splice of splices) {\n            removed.push(...before.slice(splice.start, splice.start + splice.deleteCount));\n            added.push(...splice.toInsert);\n        }\n        return { removed, added };\n    }\n    exports.delta = delta;\n    /**\n     * Returns the top N elements from the array.\n     *\n     * Faster than sorting the entire array when the array is a lot larger than N.\n     *\n     * @param array The unsorted array.\n     * @param compare A sort function for the elements.\n     * @param n The number of elements to return.\n     * @return The first n elemnts from array when sorted with compare.\n     */\n    function top(array, compare, n) {\n        if (n === 0) {\n            return [];\n        }\n        const result = array.slice(0, n).sort(compare);\n        topStep(array, compare, result, n, array.length);\n        return result;\n    }\n    exports.top = top;\n    /**\n     * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.\n     *\n     * Returns the top N elements from the array.\n     *\n     * Faster than sorting the entire array when the array is a lot larger than N.\n     *\n     * @param array The unsorted array.\n     * @param compare A sort function for the elements.\n     * @param n The number of elements to return.\n     * @param batch The number of elements to examine before yielding to the event loop.\n     * @return The first n elemnts from array when sorted with compare.\n     */\n    function topAsync(array, compare, n, batch, token) {\n        if (n === 0) {\n            return Promise.resolve([]);\n        }\n        return new Promise((resolve, reject) => {\n            (() => __awaiter(this, void 0, void 0, function* () {\n                const o = array.length;\n                const result = array.slice(0, n).sort(compare);\n                for (let i = n, m = Math.min(n + batch, o); i < o; i = m, m = Math.min(m + batch, o)) {\n                    if (i > n) {\n                        yield new Promise(resolve => setTimeout(resolve)); // nextTick() would starve I/O.\n                    }\n                    if (token && token.isCancellationRequested) {\n                        throw errors_1.canceled();\n                    }\n                    topStep(array, compare, result, i, m);\n                }\n                return result;\n            }))()\n                .then(resolve, reject);\n        });\n    }\n    exports.topAsync = topAsync;\n    function topStep(array, compare, result, i, m) {\n        for (const n = result.length; i < m; i++) {\n            const element = array[i];\n            if (compare(element, result[n - 1]) < 0) {\n                result.pop();\n                const j = findFirstInSorted(result, e => compare(element, e) < 0);\n                result.splice(j, 0, element);\n            }\n        }\n    }\n    /**\n     * @returns a new array with all falsy values removed. The original array IS NOT modified.\n     */\n    function coalesce(array) {\n        if (!array) {\n            return array;\n        }\n        return array.filter(e => !!e);\n    }\n    exports.coalesce = coalesce;\n    /**\n     * Remove all falsey values from `array`. The original array IS modified.\n     */\n    function coalesceInPlace(array) {\n        if (!array) {\n            return;\n        }\n        let to = 0;\n        for (let i = 0; i < array.length; i++) {\n            if (!!array[i]) {\n                array[to] = array[i];\n                to += 1;\n            }\n        }\n        array.length = to;\n    }\n    exports.coalesceInPlace = coalesceInPlace;\n    /**\n     * Moves the element in the array for the provided positions.\n     */\n    function move(array, from, to) {\n        array.splice(to, 0, array.splice(from, 1)[0]);\n    }\n    exports.move = move;\n    /**\n     * @returns false if the provided object is an array and not empty.\n     */\n    function isFalsyOrEmpty(obj) {\n        return !Array.isArray(obj) || obj.length === 0;\n    }\n    exports.isFalsyOrEmpty = isFalsyOrEmpty;\n    /**\n     * @returns True if the provided object is an array and has at least one element.\n     */\n    function isNonEmptyArray(obj) {\n        return Array.isArray(obj) && obj.length > 0;\n    }\n    exports.isNonEmptyArray = isNonEmptyArray;\n    /**\n     * Removes duplicates from the given array. The optional keyFn allows to specify\n     * how elements are checked for equalness by returning a unique string for each.\n     */\n    function distinct(array, keyFn) {\n        if (!keyFn) {\n            return array.filter((element, position) => {\n                return array.indexOf(element) === position;\n            });\n        }\n        const seen = Object.create(null);\n        return array.filter((elem) => {\n            const key = keyFn(elem);\n            if (seen[key]) {\n                return false;\n            }\n            seen[key] = true;\n            return true;\n        });\n    }\n    exports.distinct = distinct;\n    function distinctES6(array) {\n        const seen = new Set();\n        return array.filter(element => {\n            if (seen.has(element)) {\n                return false;\n            }\n            seen.add(element);\n            return true;\n        });\n    }\n    exports.distinctES6 = distinctES6;\n    function uniqueFilter(keyFn) {\n        const seen = Object.create(null);\n        return element => {\n            const key = keyFn(element);\n            if (seen[key]) {\n                return false;\n            }\n            seen[key] = true;\n            return true;\n        };\n    }\n    exports.uniqueFilter = uniqueFilter;\n    function lastIndex(array, fn) {\n        for (let i = array.length - 1; i >= 0; i--) {\n            const element = array[i];\n            if (fn(element)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    exports.lastIndex = lastIndex;\n    function firstIndex(array, fn) {\n        for (let i = 0; i < array.length; i++) {\n            const element = array[i];\n            if (fn(element)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    exports.firstIndex = firstIndex;\n    function first(array, fn, notFoundValue = undefined) {\n        const index = firstIndex(array, fn);\n        return index < 0 ? notFoundValue : array[index];\n    }\n    exports.first = first;\n    function commonPrefixLength(one, other, equals = (a, b) => a === b) {\n        let result = 0;\n        for (let i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {\n            result++;\n        }\n        return result;\n    }\n    exports.commonPrefixLength = commonPrefixLength;\n    function flatten(arr) {\n        return [].concat(...arr);\n    }\n    exports.flatten = flatten;\n    function range(arg, to) {\n        let from = typeof to === 'number' ? arg : 0;\n        if (typeof to === 'number') {\n            from = arg;\n        }\n        else {\n            from = 0;\n            to = arg;\n        }\n        const result = [];\n        if (from <= to) {\n            for (let i = from; i < to; i++) {\n                result.push(i);\n            }\n        }\n        else {\n            for (let i = from; i > to; i--) {\n                result.push(i);\n            }\n        }\n        return result;\n    }\n    exports.range = range;\n    function fill(num, value, arr = []) {\n        for (let i = 0; i < num; i++) {\n            arr[i] = value;\n        }\n        return arr;\n    }\n    exports.fill = fill;\n    function index(array, indexer, merger = t => t) {\n        return array.reduce((r, t) => {\n            const key = indexer(t);\n            r[key] = merger(t, r[key]);\n            return r;\n        }, Object.create(null));\n    }\n    exports.index = index;\n    /**\n     * Inserts an element into an array. Returns a function which, when\n     * called, will remove that element from the array.\n     */\n    function insert(array, element) {\n        array.push(element);\n        return () => {\n            const index = array.indexOf(element);\n            if (index > -1) {\n                array.splice(index, 1);\n            }\n        };\n    }\n    exports.insert = insert;\n    /**\n     * Insert `insertArr` inside `target` at `insertIndex`.\n     * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n     */\n    function arrayInsert(target, insertIndex, insertArr) {\n        const before = target.slice(0, insertIndex);\n        const after = target.slice(insertIndex);\n        return before.concat(insertArr, after);\n    }\n    exports.arrayInsert = arrayInsert;\n    /**\n     * Uses Fisher-Yates shuffle to shuffle the given array\n     */\n    function shuffle(array, _seed) {\n        let rand;\n        if (typeof _seed === 'number') {\n            let seed = _seed;\n            // Seeded random number generator in JS. Modified from:\n            // https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\n            rand = () => {\n                const x = Math.sin(seed++) * 179426549; // throw away most significant digits and reduce any potential bias\n                return x - Math.floor(x);\n            };\n        }\n        else {\n            rand = Math.random;\n        }\n        for (let i = array.length - 1; i > 0; i -= 1) {\n            const j = Math.floor(rand() * (i + 1));\n            const temp = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n        }\n    }\n    exports.shuffle = shuffle;\n    /**\n     * Pushes an element to the start of the array, if found.\n     */\n    function pushToStart(arr, value) {\n        const index = arr.indexOf(value);\n        if (index > -1) {\n            arr.splice(index, 1);\n            arr.unshift(value);\n        }\n    }\n    exports.pushToStart = pushToStart;\n    /**\n     * Pushes an element to the end of the array, if found.\n     */\n    function pushToEnd(arr, value) {\n        const index = arr.indexOf(value);\n        if (index > -1) {\n            arr.splice(index, 1);\n            arr.push(value);\n        }\n    }\n    exports.pushToEnd = pushToEnd;\n    function find(arr, predicate) {\n        for (let i = 0; i < arr.length; i++) {\n            const element = arr[i];\n            if (predicate(element, i, arr)) {\n                return element;\n            }\n        }\n        return undefined;\n    }\n    exports.find = find;\n    function mapArrayOrNot(items, fn) {\n        return Array.isArray(items) ?\n            items.map(fn) :\n            fn(items);\n    }\n    exports.mapArrayOrNot = mapArrayOrNot;\n    function asArray(x) {\n        return Array.isArray(x) ? x : [x];\n    }\n    exports.asArray = asArray;\n});\n",null]}