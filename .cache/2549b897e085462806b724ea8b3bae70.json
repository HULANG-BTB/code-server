{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/hover/hoverOperation.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/hover/hoverOperation.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/async\", \"vs/base/common/errors\"], function (require, exports, async_1, errors_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var ComputeHoverOperationState;\n    (function (ComputeHoverOperationState) {\n        ComputeHoverOperationState[ComputeHoverOperationState[\"IDLE\"] = 0] = \"IDLE\";\n        ComputeHoverOperationState[ComputeHoverOperationState[\"FIRST_WAIT\"] = 1] = \"FIRST_WAIT\";\n        ComputeHoverOperationState[ComputeHoverOperationState[\"SECOND_WAIT\"] = 2] = \"SECOND_WAIT\";\n        ComputeHoverOperationState[ComputeHoverOperationState[\"WAITING_FOR_ASYNC_COMPUTATION\"] = 3] = \"WAITING_FOR_ASYNC_COMPUTATION\";\n    })(ComputeHoverOperationState || (ComputeHoverOperationState = {}));\n    var HoverStartMode;\n    (function (HoverStartMode) {\n        HoverStartMode[HoverStartMode[\"Delayed\"] = 0] = \"Delayed\";\n        HoverStartMode[HoverStartMode[\"Immediate\"] = 1] = \"Immediate\";\n    })(HoverStartMode = exports.HoverStartMode || (exports.HoverStartMode = {}));\n    class HoverOperation {\n        constructor(computer, success, error, progress, hoverTime) {\n            this._computer = computer;\n            this._state = ComputeHoverOperationState.IDLE;\n            this._hoverTime = hoverTime;\n            this._firstWaitScheduler = new async_1.RunOnceScheduler(() => this._triggerAsyncComputation(), 0);\n            this._secondWaitScheduler = new async_1.RunOnceScheduler(() => this._triggerSyncComputation(), 0);\n            this._loadingMessageScheduler = new async_1.RunOnceScheduler(() => this._showLoadingMessage(), 0);\n            this._asyncComputationPromise = null;\n            this._asyncComputationPromiseDone = false;\n            this._completeCallback = success;\n            this._errorCallback = error;\n            this._progressCallback = progress;\n        }\n        setHoverTime(hoverTime) {\n            this._hoverTime = hoverTime;\n        }\n        _firstWaitTime() {\n            return this._hoverTime / 2;\n        }\n        _secondWaitTime() {\n            return this._hoverTime / 2;\n        }\n        _loadingMessageTime() {\n            return 3 * this._hoverTime;\n        }\n        _triggerAsyncComputation() {\n            this._state = ComputeHoverOperationState.SECOND_WAIT;\n            this._secondWaitScheduler.schedule(this._secondWaitTime());\n            if (this._computer.computeAsync) {\n                this._asyncComputationPromiseDone = false;\n                this._asyncComputationPromise = async_1.createCancelablePromise(token => this._computer.computeAsync(token));\n                this._asyncComputationPromise.then((asyncResult) => {\n                    this._asyncComputationPromiseDone = true;\n                    this._withAsyncResult(asyncResult);\n                }, (e) => this._onError(e));\n            }\n            else {\n                this._asyncComputationPromiseDone = true;\n            }\n        }\n        _triggerSyncComputation() {\n            if (this._computer.computeSync) {\n                this._computer.onResult(this._computer.computeSync(), true);\n            }\n            if (this._asyncComputationPromiseDone) {\n                this._state = ComputeHoverOperationState.IDLE;\n                this._onComplete(this._computer.getResult());\n            }\n            else {\n                this._state = ComputeHoverOperationState.WAITING_FOR_ASYNC_COMPUTATION;\n                this._onProgress(this._computer.getResult());\n            }\n        }\n        _showLoadingMessage() {\n            if (this._state === ComputeHoverOperationState.WAITING_FOR_ASYNC_COMPUTATION) {\n                this._onProgress(this._computer.getResultWithLoadingMessage());\n            }\n        }\n        _withAsyncResult(asyncResult) {\n            if (asyncResult) {\n                this._computer.onResult(asyncResult, false);\n            }\n            if (this._state === ComputeHoverOperationState.WAITING_FOR_ASYNC_COMPUTATION) {\n                this._state = ComputeHoverOperationState.IDLE;\n                this._onComplete(this._computer.getResult());\n            }\n        }\n        _onComplete(value) {\n            if (this._completeCallback) {\n                this._completeCallback(value);\n            }\n        }\n        _onError(error) {\n            if (this._errorCallback) {\n                this._errorCallback(error);\n            }\n            else {\n                errors_1.onUnexpectedError(error);\n            }\n        }\n        _onProgress(value) {\n            if (this._progressCallback) {\n                this._progressCallback(value);\n            }\n        }\n        start(mode) {\n            if (mode === HoverStartMode.Delayed) {\n                if (this._state === ComputeHoverOperationState.IDLE) {\n                    this._state = ComputeHoverOperationState.FIRST_WAIT;\n                    this._firstWaitScheduler.schedule(this._firstWaitTime());\n                    this._loadingMessageScheduler.schedule(this._loadingMessageTime());\n                }\n            }\n            else {\n                switch (this._state) {\n                    case ComputeHoverOperationState.IDLE:\n                        this._triggerAsyncComputation();\n                        this._secondWaitScheduler.cancel();\n                        this._triggerSyncComputation();\n                        break;\n                    case ComputeHoverOperationState.SECOND_WAIT:\n                        this._secondWaitScheduler.cancel();\n                        this._triggerSyncComputation();\n                        break;\n                }\n            }\n        }\n        cancel() {\n            this._loadingMessageScheduler.cancel();\n            if (this._state === ComputeHoverOperationState.FIRST_WAIT) {\n                this._firstWaitScheduler.cancel();\n            }\n            if (this._state === ComputeHoverOperationState.SECOND_WAIT) {\n                this._secondWaitScheduler.cancel();\n                if (this._asyncComputationPromise) {\n                    this._asyncComputationPromise.cancel();\n                    this._asyncComputationPromise = null;\n                }\n            }\n            if (this._state === ComputeHoverOperationState.WAITING_FOR_ASYNC_COMPUTATION) {\n                if (this._asyncComputationPromise) {\n                    this._asyncComputationPromise.cancel();\n                    this._asyncComputationPromise = null;\n                }\n            }\n            this._state = ComputeHoverOperationState.IDLE;\n        }\n    }\n    exports.HoverOperation = HoverOperation;\n});\n",null]}