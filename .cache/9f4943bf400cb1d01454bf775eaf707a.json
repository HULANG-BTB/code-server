{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/extensions/electron-browser/extensionsViews.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/extensions/electron-browser/extensionsViews.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/lifecycle\", \"vs/base/common/objects\", \"vs/base/common/event\", \"vs/base/common/errors\", \"vs/base/common/paging\", \"vs/platform/extensionManagement/common/extensionManagement\", \"vs/platform/extensionManagement/common/extensionManagementUtil\", \"vs/platform/keybinding/common/keybinding\", \"vs/platform/contextview/browser/contextView\", \"vs/base/browser/dom\", \"vs/platform/instantiation/common/instantiation\", \"vs/workbench/contrib/extensions/electron-browser/extensionsList\", \"../common/extensions\", \"../common/extensionQuery\", \"vs/workbench/services/extensions/common/extensions\", \"vs/platform/theme/common/themeService\", \"vs/platform/theme/common/styler\", \"vs/workbench/contrib/preferences/browser/preferencesActions\", \"vs/workbench/services/editor/common/editorService\", \"vs/editor/common/services/modeService\", \"vs/platform/telemetry/common/telemetry\", \"vs/base/browser/ui/countBadge/countBadge\", \"vs/base/browser/ui/actionbar/actionbar\", \"vs/workbench/contrib/extensions/electron-browser/extensionsActions\", \"vs/platform/list/browser/listService\", \"vs/platform/configuration/common/configuration\", \"vs/platform/notification/common/notification\", \"vs/workbench/browser/parts/views/panelViewlet\", \"vs/platform/workspace/common/workspace\", \"vs/base/common/arrays\", \"vs/workbench/contrib/experiments/node/experimentService\", \"vs/base/browser/ui/aria/aria\", \"vs/base/common/errorsWithActions\", \"vs/platform/extensions/common/extensions\", \"vs/workbench/services/themes/common/workbenchThemeService\", \"vs/platform/product/node/product\", \"vs/base/common/async\"], function (require, exports, nls_1, lifecycle_1, objects_1, event_1, errors_1, paging_1, extensionManagement_1, extensionManagementUtil_1, keybinding_1, contextView_1, dom_1, instantiation_1, extensionsList_1, extensions_1, extensionQuery_1, extensions_2, themeService_1, styler_1, preferencesActions_1, editorService_1, modeService_1, telemetry_1, countBadge_1, actionbar_1, extensionsActions_1, listService_1, configuration_1, notification_1, panelViewlet_1, workspace_1, arrays_1, experimentService_1, aria_1, errorsWithActions_1, extensions_3, workbenchThemeService_1, product_1, async_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class ExtensionsViewState extends lifecycle_1.Disposable {\n        constructor() {\n            super(...arguments);\n            this._onFocus = this._register(new event_1.Emitter());\n            this.onFocus = this._onFocus.event;\n            this._onBlur = this._register(new event_1.Emitter());\n            this.onBlur = this._onBlur.event;\n            this.currentlyFocusedItems = [];\n        }\n        onFocusChange(extensions) {\n            this.currentlyFocusedItems.forEach(extension => this._onBlur.fire(extension));\n            this.currentlyFocusedItems = extensions;\n            this.currentlyFocusedItems.forEach(extension => this._onFocus.fire(extension));\n        }\n    }\n    let ExtensionsListView = class ExtensionsListView extends panelViewlet_1.ViewletPanel {\n        constructor(options, notificationService, keybindingService, contextMenuService, instantiationService, themeService, extensionService, extensionsWorkbenchService, editorService, tipsService, modeService, telemetryService, configurationService, contextService, experimentService, workbenchThemeService) {\n            super(Object.assign({}, options, { ariaHeaderLabel: options.title }), keybindingService, contextMenuService, configurationService);\n            this.options = options;\n            this.notificationService = notificationService;\n            this.instantiationService = instantiationService;\n            this.themeService = themeService;\n            this.extensionService = extensionService;\n            this.extensionsWorkbenchService = extensionsWorkbenchService;\n            this.editorService = editorService;\n            this.tipsService = tipsService;\n            this.modeService = modeService;\n            this.telemetryService = telemetryService;\n            this.contextService = contextService;\n            this.experimentService = experimentService;\n            this.workbenchThemeService = workbenchThemeService;\n        }\n        renderHeader(container) {\n            this.renderHeaderTitle(container);\n        }\n        renderHeaderTitle(container) {\n            super.renderHeaderTitle(container, this.options.title);\n            this.badgeContainer = dom_1.append(container, dom_1.$('.count-badge-wrapper'));\n            this.badge = new countBadge_1.CountBadge(this.badgeContainer);\n            this.disposables.push(styler_1.attachBadgeStyler(this.badge, this.themeService));\n        }\n        renderBody(container) {\n            this.extensionsList = dom_1.append(container, dom_1.$('.extensions-list'));\n            this.messageBox = dom_1.append(container, dom_1.$('.message'));\n            const delegate = new extensionsList_1.Delegate();\n            const extensionsViewState = new ExtensionsViewState();\n            const renderer = this.instantiationService.createInstance(extensionsList_1.Renderer, extensionsViewState);\n            this.list = this.instantiationService.createInstance(listService_1.WorkbenchPagedList, this.extensionsList, delegate, [renderer], {\n                ariaLabel: nls_1.localize('extensions', \"Extensions\"),\n                multipleSelectionSupport: false,\n                setRowLineHeight: false,\n                horizontalScrolling: false\n            });\n            this.list.onContextMenu(e => this.onContextMenu(e), this, this.disposables);\n            this.list.onFocusChange(e => extensionsViewState.onFocusChange(arrays_1.coalesce(e.elements)), this, this.disposables);\n            this.disposables.push(this.list);\n            this.disposables.push(extensionsViewState);\n            event_1.Event.chain(this.list.onOpen)\n                .map(e => e.elements[0])\n                .filter(e => !!e)\n                .on(this.openExtension, this, this.disposables);\n            event_1.Event.chain(this.list.onPin)\n                .map(e => e.elements[0])\n                .filter(e => !!e)\n                .on(this.pin, this, this.disposables);\n        }\n        layoutBody(height, width) {\n            this.extensionsList.style.height = height + 'px';\n            if (this.list) {\n                this.list.layout(height, width);\n            }\n        }\n        show(query) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (this.queryRequest) {\n                    if (this.queryRequest.query === query) {\n                        return this.queryRequest.request;\n                    }\n                    this.queryRequest.request.cancel();\n                    this.queryRequest = null;\n                }\n                const parsedQuery = extensionQuery_1.Query.parse(query);\n                let options = {\n                    sortOrder: extensionManagement_1.SortOrder.Default\n                };\n                switch (parsedQuery.sortBy) {\n                    case 'installs':\n                        options = objects_1.assign(options, { sortBy: extensionManagement_1.SortBy.InstallCount });\n                        break;\n                    case 'rating':\n                        options = objects_1.assign(options, { sortBy: extensionManagement_1.SortBy.WeightedRating });\n                        break;\n                    case 'name':\n                        options = objects_1.assign(options, { sortBy: extensionManagement_1.SortBy.Title });\n                        break;\n                }\n                const successCallback = (model) => {\n                    this.queryRequest = null;\n                    this.setModel(model);\n                    return model;\n                };\n                const errorCallback = (e) => {\n                    const model = new paging_1.PagedModel([]);\n                    if (!errors_1.isPromiseCanceledError(e)) {\n                        this.queryRequest = null;\n                        console.warn('Error querying extensions gallery', e);\n                        this.setModel(model, true);\n                    }\n                    return this.list ? this.list.model : model;\n                };\n                const request = async_1.createCancelablePromise(token => this.query(parsedQuery, options, token).then(successCallback).catch(errorCallback));\n                this.queryRequest = { query, request };\n                return request;\n            });\n        }\n        count() {\n            return this.list ? this.list.length : 0;\n        }\n        showEmptyModel() {\n            const emptyModel = new paging_1.PagedModel([]);\n            this.setModel(emptyModel);\n            return Promise.resolve(emptyModel);\n        }\n        onContextMenu(e) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (e.element) {\n                    const runningExtensions = yield this.extensionService.getExtensions();\n                    const colorThemes = yield this.workbenchThemeService.getColorThemes();\n                    const fileIconThemes = yield this.workbenchThemeService.getFileIconThemes();\n                    const manageExtensionAction = this.instantiationService.createInstance(extensionsActions_1.ManageExtensionAction);\n                    manageExtensionAction.extension = e.element;\n                    const groups = manageExtensionAction.getActionGroups(runningExtensions, colorThemes, fileIconThemes);\n                    let actions = [];\n                    for (const menuActions of groups) {\n                        actions = [...actions, ...menuActions, new actionbar_1.Separator()];\n                    }\n                    if (manageExtensionAction.enabled) {\n                        this.contextMenuService.showContextMenu({\n                            getAnchor: () => e.anchor,\n                            getActions: () => actions.slice(0, actions.length - 1)\n                        });\n                    }\n                }\n            });\n        }\n        query(query, options, token) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const idRegex = /@id:(([a-z0-9A-Z][a-z0-9\\-A-Z]*)\\.([a-z0-9A-Z][a-z0-9\\-A-Z]*))/g;\n                const ids = [];\n                let idMatch;\n                while ((idMatch = idRegex.exec(query.value)) !== null) {\n                    const name = idMatch[1];\n                    ids.push(name);\n                }\n                if (ids.length) {\n                    return this.queryByIds(ids, options, token);\n                }\n                if (ExtensionsListView.isInstalledExtensionsQuery(query.value) || /@builtin/.test(query.value)) {\n                    return this.queryLocal(query, options);\n                }\n                return this.queryGallery(query, options, token);\n            });\n        }\n        queryByIds(ids, options, token) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const idsSet = ids.reduce((result, id) => { result.add(id.toLowerCase()); return result; }, new Set());\n                const result = (yield this.extensionsWorkbenchService.queryLocal())\n                    .filter(e => idsSet.has(e.identifier.id.toLowerCase()));\n                if (result.length) {\n                    return this.getPagedModel(this.sortExtensions(result, options));\n                }\n                return this.extensionsWorkbenchService.queryGallery({ names: ids, source: 'queryById' }, token)\n                    .then(pager => this.getPagedModel(pager));\n            });\n        }\n        queryLocal(query, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let value = query.value;\n                if (/@builtin/i.test(value)) {\n                    const showThemesOnly = /@builtin:themes/i.test(value);\n                    if (showThemesOnly) {\n                        value = value.replace(/@builtin:themes/g, '');\n                    }\n                    const showBasicsOnly = /@builtin:basics/i.test(value);\n                    if (showBasicsOnly) {\n                        value = value.replace(/@builtin:basics/g, '');\n                    }\n                    const showFeaturesOnly = /@builtin:features/i.test(value);\n                    if (showFeaturesOnly) {\n                        value = value.replace(/@builtin:features/g, '');\n                    }\n                    value = value.replace(/@builtin/g, '').replace(/@sort:(\\w+)(-\\w*)?/g, '').trim().toLowerCase();\n                    let result = yield this.extensionsWorkbenchService.queryLocal();\n                    result = result\n                        .filter(e => e.type === extensions_3.ExtensionType.System && (e.name.toLowerCase().indexOf(value) > -1 || e.displayName.toLowerCase().indexOf(value) > -1));\n                    if (showThemesOnly) {\n                        const themesExtensions = result.filter(e => {\n                            return e.local\n                                && e.local.manifest\n                                && e.local.manifest.contributes\n                                && Array.isArray(e.local.manifest.contributes.themes)\n                                && e.local.manifest.contributes.themes.length;\n                        });\n                        return this.getPagedModel(this.sortExtensions(themesExtensions, options));\n                    }\n                    if (showBasicsOnly) {\n                        const basics = result.filter(e => {\n                            return e.local && e.local.manifest\n                                && e.local.manifest.contributes\n                                && Array.isArray(e.local.manifest.contributes.grammars)\n                                && e.local.manifest.contributes.grammars.length\n                                && e.local.identifier.id !== 'vscode.git';\n                        });\n                        return this.getPagedModel(this.sortExtensions(basics, options));\n                    }\n                    if (showFeaturesOnly) {\n                        const others = result.filter(e => {\n                            return e.local\n                                && e.local.manifest\n                                && e.local.manifest.contributes\n                                && (!Array.isArray(e.local.manifest.contributes.grammars) || e.local.identifier.id === 'vscode.git')\n                                && !Array.isArray(e.local.manifest.contributes.themes);\n                        });\n                        return this.getPagedModel(this.sortExtensions(others, options));\n                    }\n                    return this.getPagedModel(this.sortExtensions(result, options));\n                }\n                const categories = [];\n                value = value.replace(/\\bcategory:(\"([^\"]*)\"|([^\"]\\S*))(\\s+|\\b|$)/g, (_, quotedCategory, category) => {\n                    const entry = (category || quotedCategory || '').toLowerCase();\n                    if (categories.indexOf(entry) === -1) {\n                        categories.push(entry);\n                    }\n                    return '';\n                });\n                if (/@installed/i.test(value)) {\n                    // Show installed extensions\n                    value = value.replace(/@installed/g, '').replace(/@sort:(\\w+)(-\\w*)?/g, '').trim().toLowerCase();\n                    let result = yield this.extensionsWorkbenchService.queryLocal();\n                    result = result\n                        .filter(e => e.type === extensions_3.ExtensionType.User\n                        && (e.name.toLowerCase().indexOf(value) > -1 || e.displayName.toLowerCase().indexOf(value) > -1)\n                        && (!categories.length || categories.some(category => (e.local && e.local.manifest.categories || []).some(c => c.toLowerCase() === category))));\n                    return this.getPagedModel(this.sortExtensions(result, options));\n                }\n                if (/@outdated/i.test(value)) {\n                    value = value.replace(/@outdated/g, '').replace(/@sort:(\\w+)(-\\w*)?/g, '').trim().toLowerCase();\n                    const local = yield this.extensionsWorkbenchService.queryLocal();\n                    const result = local\n                        .sort((e1, e2) => e1.displayName.localeCompare(e2.displayName))\n                        .filter(extension => extension.outdated\n                        && (extension.name.toLowerCase().indexOf(value) > -1 || extension.displayName.toLowerCase().indexOf(value) > -1)\n                        && (!categories.length || categories.some(category => !!extension.local && extension.local.manifest.categories.some(c => c.toLowerCase() === category))));\n                    return this.getPagedModel(this.sortExtensions(result, options));\n                }\n                if (/@disabled/i.test(value)) {\n                    value = value.replace(/@disabled/g, '').replace(/@sort:(\\w+)(-\\w*)?/g, '').trim().toLowerCase();\n                    const local = yield this.extensionsWorkbenchService.queryLocal();\n                    const runningExtensions = yield this.extensionService.getExtensions();\n                    const result = local\n                        .sort((e1, e2) => e1.displayName.localeCompare(e2.displayName))\n                        .filter(e => runningExtensions.every(r => !extensionManagementUtil_1.areSameExtensions({ id: r.identifier.value }, e.identifier))\n                        && (e.name.toLowerCase().indexOf(value) > -1 || e.displayName.toLowerCase().indexOf(value) > -1)\n                        && (!categories.length || categories.some(category => (e.local && e.local.manifest.categories || []).some(c => c.toLowerCase() === category))));\n                    return this.getPagedModel(this.sortExtensions(result, options));\n                }\n                if (/@enabled/i.test(value)) {\n                    value = value ? value.replace(/@enabled/g, '').replace(/@sort:(\\w+)(-\\w*)?/g, '').trim().toLowerCase() : '';\n                    const local = (yield this.extensionsWorkbenchService.queryLocal()).filter(e => e.type === extensions_3.ExtensionType.User);\n                    const runningExtensions = yield this.extensionService.getExtensions();\n                    const result = local\n                        .sort((e1, e2) => e1.displayName.localeCompare(e2.displayName))\n                        .filter(e => runningExtensions.some(r => extensionManagementUtil_1.areSameExtensions({ id: r.identifier.value }, e.identifier))\n                        && (e.name.toLowerCase().indexOf(value) > -1 || e.displayName.toLowerCase().indexOf(value) > -1)\n                        && (!categories.length || categories.some(category => (e.local && e.local.manifest.categories || []).some(c => c.toLowerCase() === category))));\n                    return this.getPagedModel(this.sortExtensions(result, options));\n                }\n                return new paging_1.PagedModel([]);\n            });\n        }\n        queryGallery(query, options, token) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const hasUserDefinedSortOrder = options.sortBy !== undefined;\n                if (!hasUserDefinedSortOrder && !query.value.trim()) {\n                    options.sortBy = extensionManagement_1.SortBy.InstallCount;\n                }\n                if (ExtensionsListView.isWorkspaceRecommendedExtensionsQuery(query.value)) {\n                    return this.getWorkspaceRecommendationsModel(query, options, token);\n                }\n                else if (ExtensionsListView.isKeymapsRecommendedExtensionsQuery(query.value)) {\n                    return this.getKeymapRecommendationsModel(query, options, token);\n                }\n                else if (/@recommended:all/i.test(query.value) || ExtensionsListView.isSearchRecommendedExtensionsQuery(query.value)) {\n                    return this.getAllRecommendationsModel(query, options, token);\n                }\n                else if (ExtensionsListView.isRecommendedExtensionsQuery(query.value)) {\n                    return this.getRecommendationsModel(query, options, token);\n                }\n                if (/\\bcurated:([^\\s]+)\\b/.test(query.value)) {\n                    return this.getCuratedModel(query, options, token);\n                }\n                let text = query.value;\n                const extensionRegex = /\\bext:([^\\s]+)\\b/g;\n                if (extensionRegex.test(query.value)) {\n                    text = query.value.replace(extensionRegex, (m, ext) => {\n                        // Get curated keywords\n                        const lookup = product_1.default.extensionKeywords || {};\n                        const keywords = lookup[ext] || [];\n                        // Get mode name\n                        const modeId = this.modeService.getModeIdByFilepathOrFirstLine(`.${ext}`);\n                        const languageName = modeId && this.modeService.getLanguageName(modeId);\n                        const languageTag = languageName ? ` tag:\"${languageName}\"` : '';\n                        // Construct a rich query\n                        return `tag:\"__ext_${ext}\" tag:\"__ext_.${ext}\" ${keywords.map(tag => `tag:\"${tag}\"`).join(' ')}${languageTag} tag:\"${ext}\"`;\n                    });\n                    if (text !== query.value) {\n                        options = objects_1.assign(options, { text: text.substr(0, 350), source: 'file-extension-tags' });\n                        return this.extensionsWorkbenchService.queryGallery(options, token).then(pager => this.getPagedModel(pager));\n                    }\n                }\n                let preferredResults = [];\n                if (text) {\n                    options = objects_1.assign(options, { text: text.substr(0, 350), source: 'searchText' });\n                    if (!hasUserDefinedSortOrder) {\n                        const searchExperiments = yield this.getSearchExperiments();\n                        for (const experiment of searchExperiments) {\n                            if (experiment.action && text.toLowerCase() === experiment.action.properties['searchText'] && Array.isArray(experiment.action.properties['preferredResults'])) {\n                                preferredResults = experiment.action.properties['preferredResults'];\n                                options.source += `-experiment-${experiment.id}`;\n                                break;\n                            }\n                        }\n                    }\n                }\n                else {\n                    options.source = 'viewlet';\n                }\n                const pager = yield this.extensionsWorkbenchService.queryGallery(options, token);\n                let positionToUpdate = 0;\n                for (const preferredResult of preferredResults) {\n                    for (let j = positionToUpdate; j < pager.firstPage.length; j++) {\n                        if (extensionManagementUtil_1.areSameExtensions(pager.firstPage[j].identifier, { id: preferredResult })) {\n                            if (positionToUpdate !== j) {\n                                const preferredExtension = pager.firstPage.splice(j, 1)[0];\n                                pager.firstPage.splice(positionToUpdate, 0, preferredExtension);\n                                positionToUpdate++;\n                            }\n                            break;\n                        }\n                    }\n                }\n                return this.getPagedModel(pager);\n            });\n        }\n        getSearchExperiments() {\n            if (!this._searchExperiments) {\n                this._searchExperiments = this.experimentService.getExperimentsByType(experimentService_1.ExperimentActionType.ExtensionSearchResults);\n            }\n            return this._searchExperiments;\n        }\n        sortExtensions(extensions, options) {\n            switch (options.sortBy) {\n                case extensionManagement_1.SortBy.InstallCount:\n                    extensions = extensions.sort((e1, e2) => typeof e2.installCount === 'number' && typeof e1.installCount === 'number' ? e2.installCount - e1.installCount : NaN);\n                    break;\n                case extensionManagement_1.SortBy.AverageRating:\n                case extensionManagement_1.SortBy.WeightedRating:\n                    extensions = extensions.sort((e1, e2) => typeof e2.rating === 'number' && typeof e1.rating === 'number' ? e2.rating - e1.rating : NaN);\n                    break;\n                default:\n                    extensions = extensions.sort((e1, e2) => e1.displayName.localeCompare(e2.displayName));\n                    break;\n            }\n            if (options.sortOrder === extensionManagement_1.SortOrder.Descending) {\n                extensions = extensions.reverse();\n            }\n            return extensions;\n        }\n        // Get All types of recommendations, trimmed to show a max of 8 at any given time\n        getAllRecommendationsModel(query, options, token) {\n            const value = query.value.replace(/@recommended:all/g, '').replace(/@recommended/g, '').trim().toLowerCase();\n            return this.extensionsWorkbenchService.queryLocal()\n                .then(result => result.filter(e => e.type === extensions_3.ExtensionType.User))\n                .then(local => {\n                const fileBasedRecommendations = this.tipsService.getFileBasedRecommendations();\n                const othersPromise = this.tipsService.getOtherRecommendations();\n                const workspacePromise = this.tipsService.getWorkspaceRecommendations();\n                return Promise.all([othersPromise, workspacePromise])\n                    .then(([others, workspaceRecommendations]) => {\n                    const names = this.getTrimmedRecommendations(local, value, fileBasedRecommendations, others, workspaceRecommendations);\n                    const recommendationsWithReason = this.tipsService.getAllRecommendationsWithReason();\n                    /* __GDPR__\n                        \"extensionAllRecommendations:open\" : {\n                            \"count\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                            \"recommendations\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                        }\n                    */\n                    this.telemetryService.publicLog('extensionAllRecommendations:open', {\n                        count: names.length,\n                        recommendations: names.map(id => {\n                            return {\n                                id,\n                                recommendationReason: recommendationsWithReason[id.toLowerCase()].reasonId\n                            };\n                        })\n                    });\n                    if (!names.length) {\n                        return Promise.resolve(new paging_1.PagedModel([]));\n                    }\n                    options.source = 'recommendations-all';\n                    return this.extensionsWorkbenchService.queryGallery(objects_1.assign(options, { names, pageSize: names.length }), token)\n                        .then(pager => {\n                        this.sortFirstPage(pager, names);\n                        return this.getPagedModel(pager || []);\n                    });\n                });\n            });\n        }\n        getCuratedModel(query, options, token) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const value = query.value.replace(/curated:/g, '').trim();\n                const names = yield this.experimentService.getCuratedExtensionsList(value);\n                if (Array.isArray(names) && names.length) {\n                    options.source = `curated:${value}`;\n                    const pager = yield this.extensionsWorkbenchService.queryGallery(objects_1.assign(options, { names, pageSize: names.length }), token);\n                    this.sortFirstPage(pager, names);\n                    return this.getPagedModel(pager || []);\n                }\n                return new paging_1.PagedModel([]);\n            });\n        }\n        // Get All types of recommendations other than Workspace recommendations, trimmed to show a max of 8 at any given time\n        getRecommendationsModel(query, options, token) {\n            const value = query.value.replace(/@recommended/g, '').trim().toLowerCase();\n            return this.extensionsWorkbenchService.queryLocal()\n                .then(result => result.filter(e => e.type === extensions_3.ExtensionType.User))\n                .then(local => {\n                let fileBasedRecommendations = this.tipsService.getFileBasedRecommendations();\n                const othersPromise = this.tipsService.getOtherRecommendations();\n                const workspacePromise = this.tipsService.getWorkspaceRecommendations();\n                return Promise.all([othersPromise, workspacePromise])\n                    .then(([others, workspaceRecommendations]) => {\n                    fileBasedRecommendations = fileBasedRecommendations.filter(x => workspaceRecommendations.every(({ extensionId }) => x.extensionId !== extensionId));\n                    others = others.filter(x => workspaceRecommendations.every(({ extensionId }) => x.extensionId !== extensionId));\n                    const names = this.getTrimmedRecommendations(local, value, fileBasedRecommendations, others, []);\n                    const recommendationsWithReason = this.tipsService.getAllRecommendationsWithReason();\n                    /* __GDPR__\n                        \"extensionRecommendations:open\" : {\n                            \"count\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                            \"recommendations\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                        }\n                    */\n                    this.telemetryService.publicLog('extensionRecommendations:open', {\n                        count: names.length,\n                        recommendations: names.map(id => {\n                            return {\n                                id,\n                                recommendationReason: recommendationsWithReason[id.toLowerCase()].reasonId\n                            };\n                        })\n                    });\n                    if (!names.length) {\n                        return Promise.resolve(new paging_1.PagedModel([]));\n                    }\n                    options.source = 'recommendations';\n                    return this.extensionsWorkbenchService.queryGallery(objects_1.assign(options, { names, pageSize: names.length }), token)\n                        .then(pager => {\n                        this.sortFirstPage(pager, names);\n                        return this.getPagedModel(pager || []);\n                    });\n                });\n            });\n        }\n        // Given all recommendations, trims and returns recommendations in the relevant order after filtering out installed extensions\n        getTrimmedRecommendations(installedExtensions, value, fileBasedRecommendations, otherRecommendations, workpsaceRecommendations) {\n            const totalCount = 8;\n            workpsaceRecommendations = workpsaceRecommendations\n                .filter(recommendation => {\n                return !this.isRecommendationInstalled(recommendation, installedExtensions)\n                    && recommendation.extensionId.toLowerCase().indexOf(value) > -1;\n            });\n            fileBasedRecommendations = fileBasedRecommendations.filter(recommendation => {\n                return !this.isRecommendationInstalled(recommendation, installedExtensions)\n                    && workpsaceRecommendations.every(workspaceRecommendation => workspaceRecommendation.extensionId !== recommendation.extensionId)\n                    && recommendation.extensionId.toLowerCase().indexOf(value) > -1;\n            });\n            otherRecommendations = otherRecommendations.filter(recommendation => {\n                return !this.isRecommendationInstalled(recommendation, installedExtensions)\n                    && fileBasedRecommendations.every(fileBasedRecommendation => fileBasedRecommendation.extensionId !== recommendation.extensionId)\n                    && workpsaceRecommendations.every(workspaceRecommendation => workspaceRecommendation.extensionId !== recommendation.extensionId)\n                    && recommendation.extensionId.toLowerCase().indexOf(value) > -1;\n            });\n            const otherCount = Math.min(2, otherRecommendations.length);\n            const fileBasedCount = Math.min(fileBasedRecommendations.length, totalCount - workpsaceRecommendations.length - otherCount);\n            const recommendations = workpsaceRecommendations;\n            recommendations.push(...fileBasedRecommendations.splice(0, fileBasedCount));\n            recommendations.push(...otherRecommendations.splice(0, otherCount));\n            return arrays_1.distinct(recommendations.map(({ extensionId }) => extensionId));\n        }\n        isRecommendationInstalled(recommendation, installed) {\n            return installed.some(i => extensionManagementUtil_1.areSameExtensions(i.identifier, { id: recommendation.extensionId }));\n        }\n        getWorkspaceRecommendationsModel(query, options, token) {\n            const value = query.value.replace(/@recommended:workspace/g, '').trim().toLowerCase();\n            return this.tipsService.getWorkspaceRecommendations()\n                .then(recommendations => {\n                const names = recommendations.map(({ extensionId }) => extensionId).filter(name => name.toLowerCase().indexOf(value) > -1);\n                /* __GDPR__\n                    \"extensionWorkspaceRecommendations:open\" : {\n                        \"count\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n                    }\n                */\n                this.telemetryService.publicLog('extensionWorkspaceRecommendations:open', { count: names.length });\n                if (!names.length) {\n                    return Promise.resolve(new paging_1.PagedModel([]));\n                }\n                options.source = 'recommendations-workspace';\n                return this.extensionsWorkbenchService.queryGallery(objects_1.assign(options, { names, pageSize: names.length }), token)\n                    .then(pager => this.getPagedModel(pager || []));\n            });\n        }\n        getKeymapRecommendationsModel(query, options, token) {\n            const value = query.value.replace(/@recommended:keymaps/g, '').trim().toLowerCase();\n            const names = this.tipsService.getKeymapRecommendations().map(({ extensionId }) => extensionId)\n                .filter(extensionId => extensionId.toLowerCase().indexOf(value) > -1);\n            if (!names.length) {\n                return Promise.resolve(new paging_1.PagedModel([]));\n            }\n            options.source = 'recommendations-keymaps';\n            return this.extensionsWorkbenchService.queryGallery(objects_1.assign(options, { names, pageSize: names.length }), token)\n                .then(result => this.getPagedModel(result));\n        }\n        // Sorts the firstPage of the pager in the same order as given array of extension ids\n        sortFirstPage(pager, ids) {\n            ids = ids.map(x => x.toLowerCase());\n            pager.firstPage.sort((a, b) => {\n                return ids.indexOf(a.identifier.id.toLowerCase()) < ids.indexOf(b.identifier.id.toLowerCase()) ? -1 : 1;\n            });\n        }\n        setModel(model, isGalleryError) {\n            if (this.list) {\n                this.list.model = new paging_1.DelayedPagedModel(model);\n                this.list.scrollTop = 0;\n                const count = this.count();\n                dom_1.toggleClass(this.extensionsList, 'hidden', count === 0);\n                dom_1.toggleClass(this.messageBox, 'hidden', count > 0);\n                this.badge.setCount(count);\n                if (count === 0 && this.isBodyVisible()) {\n                    this.messageBox.textContent = isGalleryError ? nls_1.localize('galleryError', \"We cannot connect to the Extensions Marketplace at this time, please try again later.\") : nls_1.localize('no extensions found', \"No extensions found.\");\n                    if (isGalleryError) {\n                        aria_1.alert(this.messageBox.textContent);\n                    }\n                }\n                else {\n                    this.messageBox.textContent = '';\n                }\n            }\n        }\n        openExtension(extension) {\n            this.extensionsWorkbenchService.open(extension).then(undefined, err => this.onError(err));\n        }\n        pin() {\n            const activeControl = this.editorService.activeControl;\n            if (activeControl) {\n                activeControl.group.pinEditor(activeControl.input);\n                activeControl.focus();\n            }\n        }\n        onError(err) {\n            if (errors_1.isPromiseCanceledError(err)) {\n                return;\n            }\n            const message = err && err.message || '';\n            if (/ECONNREFUSED/.test(message)) {\n                const error = errorsWithActions_1.createErrorWithActions(nls_1.localize('suggestProxyError', \"Marketplace returned 'ECONNREFUSED'. Please check the 'http.proxy' setting.\"), {\n                    actions: [\n                        this.instantiationService.createInstance(preferencesActions_1.OpenGlobalSettingsAction, preferencesActions_1.OpenGlobalSettingsAction.ID, preferencesActions_1.OpenGlobalSettingsAction.LABEL)\n                    ]\n                });\n                this.notificationService.error(error);\n                return;\n            }\n            this.notificationService.error(err);\n        }\n        getPagedModel(arg) {\n            if (Array.isArray(arg)) {\n                return new paging_1.PagedModel(arg);\n            }\n            const pager = {\n                total: arg.total,\n                pageSize: arg.pageSize,\n                firstPage: arg.firstPage,\n                getPage: (pageIndex, cancellationToken) => arg.getPage(pageIndex, cancellationToken)\n            };\n            return new paging_1.PagedModel(pager);\n        }\n        dispose() {\n            super.dispose();\n            if (this.queryRequest) {\n                this.queryRequest.request.cancel();\n                this.queryRequest = null;\n            }\n            this.disposables = lifecycle_1.dispose(this.disposables);\n            this.list = null;\n        }\n        static isBuiltInExtensionsQuery(query) {\n            return /^\\s*@builtin\\s*$/i.test(query);\n        }\n        static isInstalledExtensionsQuery(query) {\n            return /@installed|@outdated|@enabled|@disabled/i.test(query);\n        }\n        static isGroupByServersExtensionsQuery(query) {\n            return !!extensionQuery_1.Query.parse(query).groupBy;\n        }\n        static isRecommendedExtensionsQuery(query) {\n            return /^@recommended$/i.test(query.trim());\n        }\n        static isSearchRecommendedExtensionsQuery(query) {\n            return /@recommended/i.test(query) && !ExtensionsListView.isRecommendedExtensionsQuery(query);\n        }\n        static isWorkspaceRecommendedExtensionsQuery(query) {\n            return /@recommended:workspace/i.test(query);\n        }\n        static isKeymapsRecommendedExtensionsQuery(query) {\n            return /@recommended:keymaps/i.test(query);\n        }\n        focus() {\n            super.focus();\n            if (!this.list) {\n                return;\n            }\n            if (!(this.list.getFocus().length || this.list.getSelection().length)) {\n                this.list.focusNext();\n            }\n            this.list.domFocus();\n        }\n    };\n    ExtensionsListView = __decorate([\n        __param(1, notification_1.INotificationService),\n        __param(2, keybinding_1.IKeybindingService),\n        __param(3, contextView_1.IContextMenuService),\n        __param(4, instantiation_1.IInstantiationService),\n        __param(5, themeService_1.IThemeService),\n        __param(6, extensions_2.IExtensionService),\n        __param(7, extensions_1.IExtensionsWorkbenchService),\n        __param(8, editorService_1.IEditorService),\n        __param(9, extensionManagement_1.IExtensionTipsService),\n        __param(10, modeService_1.IModeService),\n        __param(11, telemetry_1.ITelemetryService),\n        __param(12, configuration_1.IConfigurationService),\n        __param(13, workspace_1.IWorkspaceContextService),\n        __param(14, experimentService_1.IExperimentService),\n        __param(15, workbenchThemeService_1.IWorkbenchThemeService)\n    ], ExtensionsListView);\n    exports.ExtensionsListView = ExtensionsListView;\n    class GroupByServerExtensionsView extends ExtensionsListView {\n        show(query) {\n            const _super = Object.create(null, {\n                show: { get: () => super.show }\n            });\n            return __awaiter(this, void 0, void 0, function* () {\n                query = query.replace(/@group:server/g, '').trim();\n                query = query ? query : '@installed';\n                if (!ExtensionsListView.isInstalledExtensionsQuery(query) && !ExtensionsListView.isBuiltInExtensionsQuery(query)) {\n                    query = query += ' @installed';\n                }\n                return _super.show.call(this, query.trim());\n            });\n        }\n    }\n    exports.GroupByServerExtensionsView = GroupByServerExtensionsView;\n    class EnabledExtensionsView extends ExtensionsListView {\n        constructor() {\n            super(...arguments);\n            this.enabledExtensionsQuery = '@enabled';\n        }\n        show(query) {\n            const _super = Object.create(null, {\n                show: { get: () => super.show }\n            });\n            return __awaiter(this, void 0, void 0, function* () {\n                return (query && query.trim() !== this.enabledExtensionsQuery) ? this.showEmptyModel() : _super.show.call(this, this.enabledExtensionsQuery);\n            });\n        }\n    }\n    exports.EnabledExtensionsView = EnabledExtensionsView;\n    class DisabledExtensionsView extends ExtensionsListView {\n        constructor() {\n            super(...arguments);\n            this.disabledExtensionsQuery = '@disabled';\n        }\n        show(query) {\n            const _super = Object.create(null, {\n                show: { get: () => super.show }\n            });\n            return __awaiter(this, void 0, void 0, function* () {\n                return (query && query.trim() !== this.disabledExtensionsQuery) ? this.showEmptyModel() : _super.show.call(this, this.disabledExtensionsQuery);\n            });\n        }\n    }\n    exports.DisabledExtensionsView = DisabledExtensionsView;\n    class BuiltInExtensionsView extends ExtensionsListView {\n        show(query) {\n            const _super = Object.create(null, {\n                show: { get: () => super.show }\n            });\n            return __awaiter(this, void 0, void 0, function* () {\n                return (query && query.trim() !== '@builtin') ? this.showEmptyModel() : _super.show.call(this, '@builtin:features');\n            });\n        }\n    }\n    exports.BuiltInExtensionsView = BuiltInExtensionsView;\n    class BuiltInThemesExtensionsView extends ExtensionsListView {\n        show(query) {\n            const _super = Object.create(null, {\n                show: { get: () => super.show }\n            });\n            return __awaiter(this, void 0, void 0, function* () {\n                return (query && query.trim() !== '@builtin') ? this.showEmptyModel() : _super.show.call(this, '@builtin:themes');\n            });\n        }\n    }\n    exports.BuiltInThemesExtensionsView = BuiltInThemesExtensionsView;\n    class BuiltInBasicsExtensionsView extends ExtensionsListView {\n        show(query) {\n            const _super = Object.create(null, {\n                show: { get: () => super.show }\n            });\n            return __awaiter(this, void 0, void 0, function* () {\n                return (query && query.trim() !== '@builtin') ? this.showEmptyModel() : _super.show.call(this, '@builtin:basics');\n            });\n        }\n    }\n    exports.BuiltInBasicsExtensionsView = BuiltInBasicsExtensionsView;\n    class DefaultRecommendedExtensionsView extends ExtensionsListView {\n        constructor() {\n            super(...arguments);\n            this.recommendedExtensionsQuery = '@recommended:all';\n        }\n        renderBody(container) {\n            super.renderBody(container);\n            this.disposables.push(this.tipsService.onRecommendationChange(() => {\n                this.show('');\n            }));\n        }\n        show(query) {\n            const _super = Object.create(null, {\n                show: { get: () => super.show }\n            });\n            return __awaiter(this, void 0, void 0, function* () {\n                if (query && query.trim() !== this.recommendedExtensionsQuery) {\n                    return this.showEmptyModel();\n                }\n                const model = yield _super.show.call(this, this.recommendedExtensionsQuery);\n                if (!this.extensionsWorkbenchService.local.some(e => e.type === extensions_3.ExtensionType.User)) {\n                    // This is part of popular extensions view. Collapse if no installed extensions.\n                    this.setExpanded(model.length > 0);\n                }\n                return model;\n            });\n        }\n    }\n    exports.DefaultRecommendedExtensionsView = DefaultRecommendedExtensionsView;\n    class RecommendedExtensionsView extends ExtensionsListView {\n        constructor() {\n            super(...arguments);\n            this.recommendedExtensionsQuery = '@recommended';\n        }\n        renderBody(container) {\n            super.renderBody(container);\n            this.disposables.push(this.tipsService.onRecommendationChange(() => {\n                this.show('');\n            }));\n        }\n        show(query) {\n            const _super = Object.create(null, {\n                show: { get: () => super.show }\n            });\n            return __awaiter(this, void 0, void 0, function* () {\n                return (query && query.trim() !== this.recommendedExtensionsQuery) ? this.showEmptyModel() : _super.show.call(this, this.recommendedExtensionsQuery);\n            });\n        }\n    }\n    exports.RecommendedExtensionsView = RecommendedExtensionsView;\n    class WorkspaceRecommendedExtensionsView extends ExtensionsListView {\n        constructor() {\n            super(...arguments);\n            this.recommendedExtensionsQuery = '@recommended:workspace';\n        }\n        renderBody(container) {\n            super.renderBody(container);\n            this.disposables.push(this.tipsService.onRecommendationChange(() => this.update()));\n            this.disposables.push(this.extensionsWorkbenchService.onChange(() => this.setRecommendationsToInstall()));\n            this.disposables.push(this.contextService.onDidChangeWorkbenchState(() => this.update()));\n        }\n        renderHeader(container) {\n            super.renderHeader(container);\n            const listActionBar = dom_1.$('.list-actionbar-container');\n            container.insertBefore(listActionBar, this.badgeContainer);\n            const actionbar = new actionbar_1.ActionBar(listActionBar, {\n                animated: false\n            });\n            actionbar.onDidRun(({ error }) => error && this.notificationService.error(error));\n            this.installAllAction = this.instantiationService.createInstance(extensionsActions_1.InstallWorkspaceRecommendedExtensionsAction, extensionsActions_1.InstallWorkspaceRecommendedExtensionsAction.ID, extensionsActions_1.InstallWorkspaceRecommendedExtensionsAction.LABEL, []);\n            const configureWorkspaceFolderAction = this.instantiationService.createInstance(extensionsActions_1.ConfigureWorkspaceFolderRecommendedExtensionsAction, extensionsActions_1.ConfigureWorkspaceFolderRecommendedExtensionsAction.ID, extensionsActions_1.ConfigureWorkspaceFolderRecommendedExtensionsAction.LABEL);\n            this.installAllAction.class = 'octicon octicon-cloud-download';\n            configureWorkspaceFolderAction.class = 'octicon octicon-pencil';\n            actionbar.push([this.installAllAction], { icon: true, label: false });\n            actionbar.push([configureWorkspaceFolderAction], { icon: true, label: false });\n            this.disposables.push(...[this.installAllAction, configureWorkspaceFolderAction, actionbar]);\n        }\n        show(query) {\n            const _super = Object.create(null, {\n                show: { get: () => super.show }\n            });\n            return __awaiter(this, void 0, void 0, function* () {\n                let shouldShowEmptyView = query && query.trim() !== '@recommended' && query.trim() !== '@recommended:workspace';\n                let model = yield (shouldShowEmptyView ? this.showEmptyModel() : _super.show.call(this, this.recommendedExtensionsQuery));\n                this.setExpanded(model.length > 0);\n                return model;\n            });\n        }\n        update() {\n            this.show(this.recommendedExtensionsQuery);\n            this.setRecommendationsToInstall();\n        }\n        setRecommendationsToInstall() {\n            return this.getRecommendationsToInstall()\n                .then(recommendations => { this.installAllAction.recommendations = recommendations; });\n        }\n        getRecommendationsToInstall() {\n            return this.tipsService.getWorkspaceRecommendations()\n                .then(recommendations => recommendations.filter(({ extensionId }) => !this.extensionsWorkbenchService.local.some(i => extensionManagementUtil_1.areSameExtensions({ id: extensionId }, i.identifier))));\n        }\n    }\n    exports.WorkspaceRecommendedExtensionsView = WorkspaceRecommendedExtensionsView;\n});\n",null]}