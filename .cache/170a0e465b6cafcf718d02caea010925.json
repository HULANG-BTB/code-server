{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostLanguageFeatures.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostLanguageFeatures.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/uri\", \"vs/base/common/objects\", \"vs/workbench/api/node/extHostTypeConverters\", \"vs/workbench/api/node/extHostTypes\", \"vs/editor/common/modes\", \"vs/base/common/async\", \"../common/extHost.protocol\", \"vs/base/common/strings\", \"vs/editor/common/core/range\", \"vs/base/common/arrays\", \"vs/base/common/types\", \"vs/editor/common/core/selection\", \"vs/workbench/api/node/extHostWebview\", \"vs/base/common/uuid\", \"vs/base/common/map\"], function (require, exports, uri_1, objects_1, typeConvert, extHostTypes_1, modes, async_1, extHost_protocol_1, strings_1, range_1, arrays_1, types_1, selection_1, extHostWebview_1, uuid_1, map_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // --- adapter\n    class DocumentSymbolAdapter {\n        constructor(documents, provider) {\n            this._documents = documents;\n            this._provider = provider;\n        }\n        provideDocumentSymbols(resource, token) {\n            const doc = this._documents.getDocument(resource);\n            return async_1.asPromise(() => this._provider.provideDocumentSymbols(doc, token)).then(value => {\n                if (arrays_1.isFalsyOrEmpty(value)) {\n                    return undefined;\n                }\n                else if (value[0] instanceof extHostTypes_1.DocumentSymbol) {\n                    return value.map(typeConvert.DocumentSymbol.from);\n                }\n                else {\n                    return DocumentSymbolAdapter._asDocumentSymbolTree(value);\n                }\n            });\n        }\n        static _asDocumentSymbolTree(infos) {\n            // first sort by start (and end) and then loop over all elements\n            // and build a tree based on containment.\n            infos = infos.slice(0).sort((a, b) => {\n                let res = a.location.range.start.compareTo(b.location.range.start);\n                if (res === 0) {\n                    res = b.location.range.end.compareTo(a.location.range.end);\n                }\n                return res;\n            });\n            const res = [];\n            const parentStack = [];\n            for (const info of infos) {\n                const element = {\n                    name: info.name || '!!MISSING: name!!',\n                    kind: typeConvert.SymbolKind.from(info.kind),\n                    detail: undefined,\n                    containerName: info.containerName,\n                    range: typeConvert.Range.from(info.location.range),\n                    selectionRange: typeConvert.Range.from(info.location.range),\n                    children: []\n                };\n                while (true) {\n                    if (parentStack.length === 0) {\n                        parentStack.push(element);\n                        res.push(element);\n                        break;\n                    }\n                    const parent = parentStack[parentStack.length - 1];\n                    if (range_1.Range.containsRange(parent.range, element.range) && !range_1.Range.equalsRange(parent.range, element.range)) {\n                        if (parent.children) {\n                            parent.children.push(element);\n                        }\n                        parentStack.push(element);\n                        break;\n                    }\n                    parentStack.pop();\n                }\n            }\n            return res;\n        }\n    }\n    class CodeLensAdapter {\n        constructor(_documents, _commands, _heapService, _provider) {\n            this._documents = _documents;\n            this._commands = _commands;\n            this._heapService = _heapService;\n            this._provider = _provider;\n        }\n        provideCodeLenses(resource, token) {\n            const doc = this._documents.getDocument(resource);\n            return async_1.asPromise(() => this._provider.provideCodeLenses(doc, token)).then(lenses => {\n                const result = [];\n                if (arrays_1.isNonEmptyArray(lenses)) {\n                    for (const lens of lenses) {\n                        const id = this._heapService.keep(lens);\n                        result.push(extHost_protocol_1.ObjectIdentifier.mixin({\n                            range: typeConvert.Range.from(lens.range),\n                            command: this._commands.toInternal(lens.command)\n                        }, id));\n                    }\n                }\n                return result;\n            });\n        }\n        resolveCodeLens(resource, symbol, token) {\n            const lens = this._heapService.get(extHost_protocol_1.ObjectIdentifier.of(symbol));\n            if (!lens) {\n                return Promise.resolve(undefined);\n            }\n            let resolve;\n            if (typeof this._provider.resolveCodeLens !== 'function' || lens.isResolved) {\n                resolve = Promise.resolve(lens);\n            }\n            else {\n                resolve = async_1.asPromise(() => this._provider.resolveCodeLens(lens, token));\n            }\n            return resolve.then(newLens => {\n                newLens = newLens || lens;\n                symbol.command = this._commands.toInternal(newLens.command || CodeLensAdapter._badCmd);\n                return symbol;\n            });\n        }\n    }\n    CodeLensAdapter._badCmd = { command: 'missing', title: '!!MISSING: command!!' };\n    class CodeInsetAdapter {\n        constructor(_documents, _heapService, _provider) {\n            this._documents = _documents;\n            this._heapService = _heapService;\n            this._provider = _provider;\n        }\n        provideCodeInsets(resource, token) {\n            const doc = this._documents.getDocument(resource);\n            return async_1.asPromise(() => this._provider.provideCodeInsets(doc, token)).then(insets => {\n                if (Array.isArray(insets)) {\n                    return insets.map(inset => {\n                        const $ident = this._heapService.keep(inset);\n                        const id = uuid_1.generateUuid();\n                        return {\n                            $ident,\n                            id,\n                            range: typeConvert.Range.from(inset.range),\n                            height: inset.height\n                        };\n                    });\n                }\n                return undefined;\n            });\n        }\n        resolveCodeInset(symbol, webview, token) {\n            const inset = this._heapService.get(extHost_protocol_1.ObjectIdentifier.of(symbol));\n            if (!inset) {\n                return Promise.resolve(symbol);\n            }\n            return async_1.asPromise(() => this._provider.resolveCodeInset(inset, webview, token)).then(newInset => {\n                newInset = newInset || inset;\n                return symbol;\n            });\n        }\n    }\n    function convertToLocationLinks(value) {\n        return value ? arrays_1.asArray(value).map(typeConvert.DefinitionLink.from) : [];\n    }\n    class DefinitionAdapter {\n        constructor(_documents, _provider) {\n            this._documents = _documents;\n            this._provider = _provider;\n        }\n        provideDefinition(resource, position, token) {\n            const doc = this._documents.getDocument(resource);\n            const pos = typeConvert.Position.to(position);\n            return async_1.asPromise(() => this._provider.provideDefinition(doc, pos, token)).then(convertToLocationLinks);\n        }\n    }\n    class DeclarationAdapter {\n        constructor(_documents, _provider) {\n            this._documents = _documents;\n            this._provider = _provider;\n        }\n        provideDeclaration(resource, position, token) {\n            const doc = this._documents.getDocument(resource);\n            const pos = typeConvert.Position.to(position);\n            return async_1.asPromise(() => this._provider.provideDeclaration(doc, pos, token)).then(convertToLocationLinks);\n        }\n    }\n    class ImplementationAdapter {\n        constructor(_documents, _provider) {\n            this._documents = _documents;\n            this._provider = _provider;\n        }\n        provideImplementation(resource, position, token) {\n            const doc = this._documents.getDocument(resource);\n            const pos = typeConvert.Position.to(position);\n            return async_1.asPromise(() => this._provider.provideImplementation(doc, pos, token)).then(convertToLocationLinks);\n        }\n    }\n    class TypeDefinitionAdapter {\n        constructor(_documents, _provider) {\n            this._documents = _documents;\n            this._provider = _provider;\n        }\n        provideTypeDefinition(resource, position, token) {\n            const doc = this._documents.getDocument(resource);\n            const pos = typeConvert.Position.to(position);\n            return async_1.asPromise(() => this._provider.provideTypeDefinition(doc, pos, token)).then(convertToLocationLinks);\n        }\n    }\n    class HoverAdapter {\n        constructor(_documents, _provider) {\n            this._documents = _documents;\n            this._provider = _provider;\n        }\n        provideHover(resource, position, token) {\n            const doc = this._documents.getDocument(resource);\n            const pos = typeConvert.Position.to(position);\n            return async_1.asPromise(() => this._provider.provideHover(doc, pos, token)).then(value => {\n                if (!value || arrays_1.isFalsyOrEmpty(value.contents)) {\n                    return undefined;\n                }\n                if (!value.range) {\n                    value.range = doc.getWordRangeAtPosition(pos);\n                }\n                if (!value.range) {\n                    value.range = new extHostTypes_1.Range(pos, pos);\n                }\n                return typeConvert.Hover.from(value);\n            });\n        }\n    }\n    class DocumentHighlightAdapter {\n        constructor(_documents, _provider) {\n            this._documents = _documents;\n            this._provider = _provider;\n        }\n        provideDocumentHighlights(resource, position, token) {\n            const doc = this._documents.getDocument(resource);\n            const pos = typeConvert.Position.to(position);\n            return async_1.asPromise(() => this._provider.provideDocumentHighlights(doc, pos, token)).then(value => {\n                if (Array.isArray(value)) {\n                    return value.map(typeConvert.DocumentHighlight.from);\n                }\n                return undefined;\n            });\n        }\n    }\n    class ReferenceAdapter {\n        constructor(_documents, _provider) {\n            this._documents = _documents;\n            this._provider = _provider;\n        }\n        provideReferences(resource, position, context, token) {\n            const doc = this._documents.getDocument(resource);\n            const pos = typeConvert.Position.to(position);\n            return async_1.asPromise(() => this._provider.provideReferences(doc, pos, context, token)).then(value => {\n                if (Array.isArray(value)) {\n                    return value.map(typeConvert.location.from);\n                }\n                return undefined;\n            });\n        }\n    }\n    class CodeActionAdapter {\n        constructor(_documents, _commands, _diagnostics, _provider, _logService, _extensionId) {\n            this._documents = _documents;\n            this._commands = _commands;\n            this._diagnostics = _diagnostics;\n            this._provider = _provider;\n            this._logService = _logService;\n            this._extensionId = _extensionId;\n        }\n        provideCodeActions(resource, rangeOrSelection, context, token) {\n            const doc = this._documents.getDocument(resource);\n            const ran = selection_1.Selection.isISelection(rangeOrSelection)\n                ? typeConvert.Selection.to(rangeOrSelection)\n                : typeConvert.Range.to(rangeOrSelection);\n            const allDiagnostics = [];\n            for (const diagnostic of this._diagnostics.getDiagnostics(resource)) {\n                if (ran.intersection(diagnostic.range)) {\n                    const newLen = allDiagnostics.push(diagnostic);\n                    if (newLen > CodeActionAdapter._maxCodeActionsPerFile) {\n                        break;\n                    }\n                }\n            }\n            const codeActionContext = {\n                diagnostics: allDiagnostics,\n                only: context.only ? new extHostTypes_1.CodeActionKind(context.only) : undefined\n            };\n            return async_1.asPromise(() => this._provider.provideCodeActions(doc, ran, codeActionContext, token)).then(commandsOrActions => {\n                if (!arrays_1.isNonEmptyArray(commandsOrActions)) {\n                    return undefined;\n                }\n                const result = [];\n                for (const candidate of commandsOrActions) {\n                    if (!candidate) {\n                        continue;\n                    }\n                    if (CodeActionAdapter._isCommand(candidate)) {\n                        // old school: synthetic code action\n                        result.push({\n                            _isSynthetic: true,\n                            title: candidate.title,\n                            command: this._commands.toInternal(candidate),\n                        });\n                    }\n                    else {\n                        if (codeActionContext.only) {\n                            if (!candidate.kind) {\n                                this._logService.warn(`${this._extensionId.value} - Code actions of kind '${codeActionContext.only.value} 'requested but returned code action does not have a 'kind'. Code action will be dropped. Please set 'CodeAction.kind'.`);\n                            }\n                            else if (!codeActionContext.only.contains(candidate.kind)) {\n                                this._logService.warn(`${this._extensionId.value} -Code actions of kind '${codeActionContext.only.value} 'requested but returned code action is of kind '${candidate.kind.value}'. Code action will be dropped. Please check 'CodeActionContext.only' to only return requested code actions.`);\n                            }\n                        }\n                        // new school: convert code action\n                        result.push({\n                            title: candidate.title,\n                            command: candidate.command && this._commands.toInternal(candidate.command),\n                            diagnostics: candidate.diagnostics && candidate.diagnostics.map(typeConvert.Diagnostic.from),\n                            edit: candidate.edit && typeConvert.WorkspaceEdit.from(candidate.edit),\n                            kind: candidate.kind && candidate.kind.value,\n                            isPreferred: candidate.isPreferred,\n                        });\n                    }\n                }\n                return result;\n            });\n        }\n        static _isCommand(thing) {\n            return typeof thing.command === 'string' && typeof thing.title === 'string';\n        }\n    }\n    CodeActionAdapter._maxCodeActionsPerFile = 1000;\n    class DocumentFormattingAdapter {\n        constructor(_documents, _provider) {\n            this._documents = _documents;\n            this._provider = _provider;\n        }\n        provideDocumentFormattingEdits(resource, options, token) {\n            const document = this._documents.getDocument(resource);\n            return async_1.asPromise(() => this._provider.provideDocumentFormattingEdits(document, options, token)).then(value => {\n                if (Array.isArray(value)) {\n                    return value.map(typeConvert.TextEdit.from);\n                }\n                return undefined;\n            });\n        }\n    }\n    class RangeFormattingAdapter {\n        constructor(_documents, _provider) {\n            this._documents = _documents;\n            this._provider = _provider;\n        }\n        provideDocumentRangeFormattingEdits(resource, range, options, token) {\n            const document = this._documents.getDocument(resource);\n            const ran = typeConvert.Range.to(range);\n            return async_1.asPromise(() => this._provider.provideDocumentRangeFormattingEdits(document, ran, options, token)).then(value => {\n                if (Array.isArray(value)) {\n                    return value.map(typeConvert.TextEdit.from);\n                }\n                return undefined;\n            });\n        }\n    }\n    class OnTypeFormattingAdapter {\n        constructor(_documents, _provider) {\n            this._documents = _documents;\n            this._provider = _provider;\n            this.autoFormatTriggerCharacters = []; // not here\n        }\n        provideOnTypeFormattingEdits(resource, position, ch, options, token) {\n            const document = this._documents.getDocument(resource);\n            const pos = typeConvert.Position.to(position);\n            return async_1.asPromise(() => this._provider.provideOnTypeFormattingEdits(document, pos, ch, options, token)).then(value => {\n                if (Array.isArray(value)) {\n                    return value.map(typeConvert.TextEdit.from);\n                }\n                return undefined;\n            });\n        }\n    }\n    class NavigateTypeAdapter {\n        constructor(provider) {\n            this._symbolCache = Object.create(null);\n            this._resultCache = Object.create(null);\n            this._provider = provider;\n        }\n        provideWorkspaceSymbols(search, token) {\n            const result = extHost_protocol_1.IdObject.mixin({ symbols: [] });\n            return async_1.asPromise(() => this._provider.provideWorkspaceSymbols(search, token)).then(value => {\n                if (arrays_1.isNonEmptyArray(value)) {\n                    for (const item of value) {\n                        if (!item) {\n                            // drop\n                            continue;\n                        }\n                        if (!item.name) {\n                            console.warn('INVALID SymbolInformation, lacks name', item);\n                            continue;\n                        }\n                        const symbol = extHost_protocol_1.IdObject.mixin(typeConvert.WorkspaceSymbol.from(item));\n                        this._symbolCache[symbol._id] = item;\n                        result.symbols.push(symbol);\n                    }\n                }\n            }).then(() => {\n                if (result.symbols.length > 0) {\n                    this._resultCache[result._id] = [result.symbols[0]._id, result.symbols[result.symbols.length - 1]._id];\n                }\n                return result;\n            });\n        }\n        resolveWorkspaceSymbol(symbol, token) {\n            if (typeof this._provider.resolveWorkspaceSymbol !== 'function') {\n                return Promise.resolve(symbol);\n            }\n            const item = this._symbolCache[symbol._id];\n            if (item) {\n                return async_1.asPromise(() => this._provider.resolveWorkspaceSymbol(item, token)).then(value => {\n                    return value && objects_1.mixin(symbol, typeConvert.WorkspaceSymbol.from(value), true);\n                });\n            }\n            return Promise.resolve(undefined);\n        }\n        releaseWorkspaceSymbols(id) {\n            const range = this._resultCache[id];\n            if (range) {\n                for (let [from, to] = range; from <= to; from++) {\n                    delete this._symbolCache[from];\n                }\n                delete this._resultCache[id];\n            }\n        }\n    }\n    class RenameAdapter {\n        constructor(_documents, _provider) {\n            this._documents = _documents;\n            this._provider = _provider;\n        }\n        static supportsResolving(provider) {\n            return typeof provider.prepareRename === 'function';\n        }\n        provideRenameEdits(resource, position, newName, token) {\n            const doc = this._documents.getDocument(resource);\n            const pos = typeConvert.Position.to(position);\n            return async_1.asPromise(() => this._provider.provideRenameEdits(doc, pos, newName, token)).then(value => {\n                if (!value) {\n                    return undefined;\n                }\n                return typeConvert.WorkspaceEdit.from(value);\n            }, err => {\n                const rejectReason = RenameAdapter._asMessage(err);\n                if (rejectReason) {\n                    return { rejectReason, edits: undefined };\n                }\n                else {\n                    // generic error\n                    return Promise.reject(err);\n                }\n            });\n        }\n        resolveRenameLocation(resource, position, token) {\n            if (typeof this._provider.prepareRename !== 'function') {\n                return Promise.resolve(undefined);\n            }\n            const doc = this._documents.getDocument(resource);\n            const pos = typeConvert.Position.to(position);\n            return async_1.asPromise(() => this._provider.prepareRename(doc, pos, token)).then(rangeOrLocation => {\n                let range;\n                let text;\n                if (extHostTypes_1.Range.isRange(rangeOrLocation)) {\n                    range = rangeOrLocation;\n                    text = doc.getText(rangeOrLocation);\n                }\n                else if (types_1.isObject(rangeOrLocation)) {\n                    range = rangeOrLocation.range;\n                    text = rangeOrLocation.placeholder;\n                }\n                if (!range) {\n                    return undefined;\n                }\n                if (range.start.line > pos.line || range.end.line < pos.line) {\n                    console.warn('INVALID rename location: position line must be within range start/end lines');\n                    return undefined;\n                }\n                return { range: typeConvert.Range.from(range), text };\n            }, err => {\n                const rejectReason = RenameAdapter._asMessage(err);\n                if (rejectReason) {\n                    return { rejectReason, range: undefined, text: undefined };\n                }\n                else {\n                    return Promise.reject(err);\n                }\n            });\n        }\n        static _asMessage(err) {\n            if (typeof err === 'string') {\n                return err;\n            }\n            else if (err instanceof Error && typeof err.message === 'string') {\n                return err.message;\n            }\n            else {\n                return undefined;\n            }\n        }\n    }\n    class SuggestAdapter {\n        constructor(documents, commands, provider) {\n            this._cache = new Map();\n            this._idPool = 0;\n            this._documents = documents;\n            this._commands = commands;\n            this._provider = provider;\n        }\n        static supportsResolving(provider) {\n            return typeof provider.resolveCompletionItem === 'function';\n        }\n        provideCompletionItems(resource, position, context, token) {\n            const doc = this._documents.getDocument(resource);\n            const pos = typeConvert.Position.to(position);\n            return async_1.asPromise(() => this._provider.provideCompletionItems(doc, pos, token, typeConvert.CompletionContext.to(context))).then(value => {\n                const _id = this._idPool++;\n                const result = {\n                    _id,\n                    suggestions: [],\n                };\n                let list;\n                if (!value) {\n                    // undefined and null are valid results\n                    return undefined;\n                }\n                else if (Array.isArray(value)) {\n                    list = new extHostTypes_1.CompletionList(value);\n                }\n                else {\n                    list = value;\n                    result.incomplete = list.isIncomplete;\n                }\n                // the default text edit range\n                const wordRangeBeforePos = (doc.getWordRangeAtPosition(pos) || new extHostTypes_1.Range(pos, pos))\n                    .with({ end: pos });\n                for (let i = 0; i < list.items.length; i++) {\n                    const suggestion = this._convertCompletionItem(list.items[i], pos, wordRangeBeforePos, i, _id);\n                    // check for bad completion item\n                    // for the converter did warn\n                    if (suggestion) {\n                        result.suggestions.push(suggestion);\n                    }\n                }\n                this._cache.set(_id, list.items);\n                return result;\n            });\n        }\n        resolveCompletionItem(resource, position, suggestion, token) {\n            if (typeof this._provider.resolveCompletionItem !== 'function') {\n                return Promise.resolve(suggestion);\n            }\n            const { _parentId, _id } = suggestion;\n            const item = this._cache.has(_parentId) ? this._cache.get(_parentId)[_id] : undefined;\n            if (!item) {\n                return Promise.resolve(suggestion);\n            }\n            return async_1.asPromise(() => this._provider.resolveCompletionItem(item, token)).then(resolvedItem => {\n                if (!resolvedItem) {\n                    return suggestion;\n                }\n                const doc = this._documents.getDocument(resource);\n                const pos = typeConvert.Position.to(position);\n                const wordRangeBeforePos = (doc.getWordRangeAtPosition(pos) || new extHostTypes_1.Range(pos, pos)).with({ end: pos });\n                const newSuggestion = this._convertCompletionItem(resolvedItem, pos, wordRangeBeforePos, _id, _parentId);\n                if (newSuggestion) {\n                    objects_1.mixin(suggestion, newSuggestion, true);\n                }\n                return suggestion;\n            });\n        }\n        releaseCompletionItems(id) {\n            this._cache.delete(id);\n        }\n        _convertCompletionItem(item, position, defaultRange, _id, _parentId) {\n            if (typeof item.label !== 'string' || item.label.length === 0) {\n                console.warn('INVALID text edit -> must have at least a label');\n                return undefined;\n            }\n            const result = {\n                //\n                _id,\n                _parentId,\n                //\n                label: item.label,\n                kind: typeConvert.CompletionItemKind.from(item.kind),\n                detail: item.detail,\n                documentation: typeof item.documentation === 'undefined' ? undefined : typeConvert.MarkdownString.fromStrict(item.documentation),\n                filterText: item.filterText,\n                sortText: item.sortText,\n                preselect: item.preselect,\n                //\n                range: undefined,\n                insertText: undefined,\n                insertTextRules: item.keepWhitespace ? modes.CompletionItemInsertTextRule.KeepWhitespace : 0,\n                additionalTextEdits: item.additionalTextEdits && item.additionalTextEdits.map(typeConvert.TextEdit.from),\n                command: this._commands.toInternal(item.command),\n                commitCharacters: item.commitCharacters\n            };\n            // 'insertText'-logic\n            if (item.textEdit) {\n                result.insertText = item.textEdit.newText;\n            }\n            else if (typeof item.insertText === 'string') {\n                result.insertText = item.insertText;\n            }\n            else if (item.insertText instanceof extHostTypes_1.SnippetString) {\n                result.insertText = item.insertText.value;\n                result.insertTextRules |= modes.CompletionItemInsertTextRule.InsertAsSnippet;\n            }\n            else {\n                result.insertText = item.label;\n            }\n            // 'overwrite[Before|After]'-logic\n            let range;\n            if (item.textEdit) {\n                range = item.textEdit.range;\n            }\n            else if (item.range) {\n                range = item.range;\n            }\n            else {\n                range = defaultRange;\n            }\n            result.range = typeConvert.Range.from(range);\n            if (!range.isSingleLine || range.start.line !== position.line) {\n                console.warn('INVALID text edit -> must be single line and on the same line');\n                return undefined;\n            }\n            return result;\n        }\n    }\n    class SignatureHelpAdapter {\n        constructor(_documents, _provider, _heap) {\n            this._documents = _documents;\n            this._provider = _provider;\n            this._heap = _heap;\n        }\n        provideSignatureHelp(resource, position, context, token) {\n            const doc = this._documents.getDocument(resource);\n            const pos = typeConvert.Position.to(position);\n            const vscodeContext = this.reviveContext(context);\n            return async_1.asPromise(() => this._provider.provideSignatureHelp(doc, pos, token, vscodeContext)).then(value => {\n                if (value) {\n                    const id = this._heap.keep(value);\n                    return extHost_protocol_1.ObjectIdentifier.mixin(typeConvert.SignatureHelp.from(value), id);\n                }\n                return undefined;\n            });\n        }\n        reviveContext(context) {\n            let activeSignatureHelp = undefined;\n            if (context.activeSignatureHelp) {\n                const revivedSignatureHelp = typeConvert.SignatureHelp.to(context.activeSignatureHelp);\n                const saved = this._heap.get(extHost_protocol_1.ObjectIdentifier.of(context.activeSignatureHelp));\n                if (saved) {\n                    activeSignatureHelp = saved;\n                    activeSignatureHelp.activeSignature = revivedSignatureHelp.activeSignature;\n                    activeSignatureHelp.activeParameter = revivedSignatureHelp.activeParameter;\n                }\n                else {\n                    activeSignatureHelp = revivedSignatureHelp;\n                }\n            }\n            return Object.assign({}, context, { activeSignatureHelp });\n        }\n    }\n    class LinkProviderAdapter {\n        constructor(_documents, _heapService, _provider) {\n            this._documents = _documents;\n            this._heapService = _heapService;\n            this._provider = _provider;\n        }\n        provideLinks(resource, token) {\n            const doc = this._documents.getDocument(resource);\n            return async_1.asPromise(() => this._provider.provideDocumentLinks(doc, token)).then(links => {\n                if (!Array.isArray(links)) {\n                    return undefined;\n                }\n                const result = [];\n                for (const link of links) {\n                    const data = typeConvert.DocumentLink.from(link);\n                    const id = this._heapService.keep(link);\n                    result.push(extHost_protocol_1.ObjectIdentifier.mixin(data, id));\n                }\n                return result;\n            });\n        }\n        resolveLink(link, token) {\n            if (typeof this._provider.resolveDocumentLink !== 'function') {\n                return Promise.resolve(undefined);\n            }\n            const id = extHost_protocol_1.ObjectIdentifier.of(link);\n            const item = this._heapService.get(id);\n            if (!item) {\n                return Promise.resolve(undefined);\n            }\n            return async_1.asPromise(() => this._provider.resolveDocumentLink(item, token)).then(value => {\n                if (value) {\n                    return typeConvert.DocumentLink.from(value);\n                }\n                return undefined;\n            });\n        }\n    }\n    class ColorProviderAdapter {\n        constructor(_documents, _provider) {\n            this._documents = _documents;\n            this._provider = _provider;\n        }\n        provideColors(resource, token) {\n            const doc = this._documents.getDocument(resource);\n            return async_1.asPromise(() => this._provider.provideDocumentColors(doc, token)).then(colors => {\n                if (!Array.isArray(colors)) {\n                    return [];\n                }\n                const colorInfos = colors.map(ci => {\n                    return {\n                        color: typeConvert.Color.from(ci.color),\n                        range: typeConvert.Range.from(ci.range)\n                    };\n                });\n                return colorInfos;\n            });\n        }\n        provideColorPresentations(resource, raw, token) {\n            const document = this._documents.getDocument(resource);\n            const range = typeConvert.Range.to(raw.range);\n            const color = typeConvert.Color.to(raw.color);\n            return async_1.asPromise(() => this._provider.provideColorPresentations(color, { document, range }, token)).then(value => {\n                if (!Array.isArray(value)) {\n                    return undefined;\n                }\n                return value.map(typeConvert.ColorPresentation.from);\n            });\n        }\n    }\n    class FoldingProviderAdapter {\n        constructor(_documents, _provider) {\n            this._documents = _documents;\n            this._provider = _provider;\n        }\n        provideFoldingRanges(resource, context, token) {\n            const doc = this._documents.getDocument(resource);\n            return async_1.asPromise(() => this._provider.provideFoldingRanges(doc, context, token)).then(ranges => {\n                if (!Array.isArray(ranges)) {\n                    return undefined;\n                }\n                return ranges.map(typeConvert.FoldingRange.from);\n            });\n        }\n    }\n    class SelectionRangeAdapter {\n        constructor(_documents, _provider) {\n            this._documents = _documents;\n            this._provider = _provider;\n        }\n        provideSelectionRanges(resource, pos, token) {\n            const document = this._documents.getDocument(resource);\n            const positions = pos.map(typeConvert.Position.to);\n            return async_1.asPromise(() => this._provider.provideSelectionRanges(document, positions, token)).then(allProviderRanges => {\n                if (!arrays_1.isNonEmptyArray(allProviderRanges)) {\n                    return [];\n                }\n                if (allProviderRanges.length !== positions.length) {\n                    console.warn('BAD selection ranges, provider must return ranges for each position');\n                    return [];\n                }\n                const allResults = [];\n                for (let i = 0; i < positions.length; i++) {\n                    const oneResult = [];\n                    allResults.push(oneResult);\n                    let last = positions[i];\n                    let selectionRange = allProviderRanges[i];\n                    while (true) {\n                        if (!selectionRange.range.contains(last)) {\n                            throw new Error('INVALID selection range, must contain the previous range');\n                        }\n                        oneResult.push(typeConvert.SelectionRange.from(selectionRange));\n                        if (!selectionRange.parent) {\n                            break;\n                        }\n                        last = selectionRange.range;\n                        selectionRange = selectionRange.parent;\n                    }\n                }\n                return allResults;\n            });\n        }\n    }\n    class CallHierarchyAdapter {\n        constructor(_documents, _provider) {\n            this._documents = _documents;\n            this._provider = _provider;\n            // todo@joh keep object (heap service, lifecycle)\n            this._cache = new map_1.LRUCache(1000, 0.8);\n            this._idPool = 0;\n        }\n        provideCallHierarchyItem(resource, pos, token) {\n            const document = this._documents.getDocument(resource);\n            const position = typeConvert.Position.to(pos);\n            return async_1.asPromise(() => this._provider.provideCallHierarchyItem(document, position, token)).then(item => {\n                if (!item) {\n                    return undefined;\n                }\n                return this._fromItem(item);\n            });\n        }\n        resolveCallHierarchyItem(item, direction, token) {\n            return async_1.asPromise(() => this._provider.resolveCallHierarchyItem(this._cache.get(item._id), direction, token) // todo@joh proper convert\n            ).then(data => {\n                if (!data) {\n                    return [];\n                }\n                return data.map(tuple => {\n                    return [\n                        this._fromItem(tuple[0]),\n                        tuple[1].map(typeConvert.location.from)\n                    ];\n                });\n            });\n        }\n        _fromItem(item, _id = this._idPool++) {\n            const res = {\n                _id,\n                name: item.name,\n                detail: item.detail,\n                kind: typeConvert.SymbolKind.from(item.kind),\n                uri: item.uri,\n                range: typeConvert.Range.from(item.range),\n                selectionRange: typeConvert.Range.from(item.selectionRange),\n            };\n            this._cache.set(_id, item);\n            return res;\n        }\n    }\n    class AdapterData {\n        constructor(adapter, extension) {\n            this.adapter = adapter;\n            this.extension = extension;\n        }\n    }\n    class ExtHostLanguageFeatures {\n        constructor(mainContext, schemeTransformer, documents, commands, heapMonitor, diagnostics, logService) {\n            this._adapter = new Map();\n            this._schemeTransformer = schemeTransformer;\n            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadLanguageFeatures);\n            this._documents = documents;\n            this._commands = commands;\n            this._heapService = heapMonitor;\n            this._diagnostics = diagnostics;\n            this._logService = logService;\n            this._webviewProxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadWebviews);\n        }\n        _transformDocumentSelector(selector) {\n            return arrays_1.coalesce(arrays_1.asArray(selector).map(sel => this._doTransformDocumentSelector(sel)));\n        }\n        _doTransformDocumentSelector(selector) {\n            if (typeof selector === 'string') {\n                return {\n                    $serialized: true,\n                    language: selector\n                };\n            }\n            if (selector) {\n                return {\n                    $serialized: true,\n                    language: selector.language,\n                    scheme: this._transformScheme(selector.scheme),\n                    pattern: typeof selector.pattern === 'undefined' ? undefined : typeConvert.GlobPattern.from(selector.pattern),\n                    exclusive: selector.exclusive\n                };\n            }\n            return undefined;\n        }\n        _transformScheme(scheme) {\n            if (this._schemeTransformer && typeof scheme === 'string') {\n                return this._schemeTransformer.transformOutgoing(scheme);\n            }\n            return scheme;\n        }\n        _createDisposable(handle) {\n            return new extHostTypes_1.Disposable(() => {\n                this._adapter.delete(handle);\n                this._proxy.$unregister(handle);\n            });\n        }\n        _nextHandle() {\n            return ExtHostLanguageFeatures._handlePool++;\n        }\n        _withAdapter(handle, ctor, callback, fallbackValue) {\n            const data = this._adapter.get(handle);\n            if (!data) {\n                return Promise.resolve(fallbackValue);\n            }\n            if (data.adapter instanceof ctor) {\n                let t1;\n                if (data.extension) {\n                    t1 = Date.now();\n                    this._logService.trace(`[${data.extension.identifier.value}] INVOKE provider '${ctor.name}'`);\n                }\n                const p = callback(data.adapter, data.extension);\n                const extension = data.extension;\n                if (extension) {\n                    Promise.resolve(p).then(() => this._logService.trace(`[${extension.identifier.value}] provider DONE after ${Date.now() - t1}ms`), err => {\n                        this._logService.error(`[${extension.identifier.value}] provider FAILED`);\n                        this._logService.error(err);\n                    });\n                }\n                return p;\n            }\n            return Promise.reject(new Error('no adapter found'));\n        }\n        _addNewAdapter(adapter, extension) {\n            const handle = this._nextHandle();\n            this._adapter.set(handle, new AdapterData(adapter, extension));\n            return handle;\n        }\n        static _extLabel(ext) {\n            return ext.displayName || ext.name;\n        }\n        // --- outline\n        registerDocumentSymbolProvider(extension, selector, provider, metadata) {\n            const handle = this._addNewAdapter(new DocumentSymbolAdapter(this._documents, provider), extension);\n            const displayName = (metadata && metadata.label) || ExtHostLanguageFeatures._extLabel(extension);\n            this._proxy.$registerDocumentSymbolProvider(handle, this._transformDocumentSelector(selector), displayName);\n            return this._createDisposable(handle);\n        }\n        $provideDocumentSymbols(handle, resource, token) {\n            return this._withAdapter(handle, DocumentSymbolAdapter, adapter => adapter.provideDocumentSymbols(uri_1.URI.revive(resource), token), undefined);\n        }\n        // --- code lens\n        registerCodeLensProvider(extension, selector, provider) {\n            const handle = this._nextHandle();\n            const eventHandle = typeof provider.onDidChangeCodeLenses === 'function' ? this._nextHandle() : undefined;\n            this._adapter.set(handle, new AdapterData(new CodeLensAdapter(this._documents, this._commands.converter, this._heapService, provider), extension));\n            this._proxy.$registerCodeLensSupport(handle, this._transformDocumentSelector(selector), eventHandle);\n            let result = this._createDisposable(handle);\n            if (eventHandle !== undefined) {\n                const subscription = provider.onDidChangeCodeLenses(_ => this._proxy.$emitCodeLensEvent(eventHandle));\n                result = extHostTypes_1.Disposable.from(result, subscription);\n            }\n            return result;\n        }\n        $provideCodeLenses(handle, resource, token) {\n            return this._withAdapter(handle, CodeLensAdapter, adapter => adapter.provideCodeLenses(uri_1.URI.revive(resource), token), []);\n        }\n        $resolveCodeLens(handle, resource, symbol, token) {\n            return this._withAdapter(handle, CodeLensAdapter, adapter => adapter.resolveCodeLens(uri_1.URI.revive(resource), symbol, token), undefined);\n        }\n        // --- code insets\n        registerCodeInsetProvider(extension, selector, provider) {\n            const handle = this._nextHandle();\n            const eventHandle = typeof provider.onDidChangeCodeInsets === 'function' ? this._nextHandle() : undefined;\n            this._adapter.set(handle, new AdapterData(new CodeInsetAdapter(this._documents, this._heapService, provider), extension));\n            this._proxy.$registerCodeInsetSupport(handle, this._transformDocumentSelector(selector), eventHandle);\n            let result = this._createDisposable(handle);\n            if (eventHandle !== undefined && provider.onDidChangeCodeInsets) {\n                const subscription = provider.onDidChangeCodeInsets(_ => this._proxy.$emitCodeLensEvent(eventHandle));\n                result = extHostTypes_1.Disposable.from(result, subscription);\n            }\n            return result;\n        }\n        $provideCodeInsets(handle, resource, token) {\n            return this._withAdapter(handle, CodeInsetAdapter, adapter => adapter.provideCodeInsets(uri_1.URI.revive(resource), token), undefined);\n        }\n        $resolveCodeInset(handle, _resource, symbol, token) {\n            const webviewHandle = Math.random();\n            const webview = new extHostWebview_1.ExtHostWebview(webviewHandle, this._webviewProxy, { enableScripts: true });\n            return this._withAdapter(handle, CodeInsetAdapter, (adapter, extension) => __awaiter(this, void 0, void 0, function* () {\n                yield this._webviewProxy.$createWebviewCodeInset(webviewHandle, symbol.id, { enableCommandUris: true, enableScripts: true }, extension ? extension.identifier : undefined, extension ? extension.extensionLocation : undefined);\n                return adapter.resolveCodeInset(symbol, webview, token);\n            }), symbol);\n        }\n        // --- declaration\n        registerDefinitionProvider(extension, selector, provider) {\n            const handle = this._addNewAdapter(new DefinitionAdapter(this._documents, provider), extension);\n            this._proxy.$registerDefinitionSupport(handle, this._transformDocumentSelector(selector));\n            return this._createDisposable(handle);\n        }\n        $provideDefinition(handle, resource, position, token) {\n            return this._withAdapter(handle, DefinitionAdapter, adapter => adapter.provideDefinition(uri_1.URI.revive(resource), position, token), []);\n        }\n        registerDeclarationProvider(extension, selector, provider) {\n            const handle = this._addNewAdapter(new DeclarationAdapter(this._documents, provider), extension);\n            this._proxy.$registerDeclarationSupport(handle, this._transformDocumentSelector(selector));\n            return this._createDisposable(handle);\n        }\n        $provideDeclaration(handle, resource, position, token) {\n            return this._withAdapter(handle, DeclarationAdapter, adapter => adapter.provideDeclaration(uri_1.URI.revive(resource), position, token), []);\n        }\n        registerImplementationProvider(extension, selector, provider) {\n            const handle = this._addNewAdapter(new ImplementationAdapter(this._documents, provider), extension);\n            this._proxy.$registerImplementationSupport(handle, this._transformDocumentSelector(selector));\n            return this._createDisposable(handle);\n        }\n        $provideImplementation(handle, resource, position, token) {\n            return this._withAdapter(handle, ImplementationAdapter, adapter => adapter.provideImplementation(uri_1.URI.revive(resource), position, token), []);\n        }\n        registerTypeDefinitionProvider(extension, selector, provider) {\n            const handle = this._addNewAdapter(new TypeDefinitionAdapter(this._documents, provider), extension);\n            this._proxy.$registerTypeDefinitionSupport(handle, this._transformDocumentSelector(selector));\n            return this._createDisposable(handle);\n        }\n        $provideTypeDefinition(handle, resource, position, token) {\n            return this._withAdapter(handle, TypeDefinitionAdapter, adapter => adapter.provideTypeDefinition(uri_1.URI.revive(resource), position, token), []);\n        }\n        // --- extra info\n        registerHoverProvider(extension, selector, provider, extensionId) {\n            const handle = this._addNewAdapter(new HoverAdapter(this._documents, provider), extension);\n            this._proxy.$registerHoverProvider(handle, this._transformDocumentSelector(selector));\n            return this._createDisposable(handle);\n        }\n        $provideHover(handle, resource, position, token) {\n            return this._withAdapter(handle, HoverAdapter, adapter => adapter.provideHover(uri_1.URI.revive(resource), position, token), undefined);\n        }\n        // --- occurrences\n        registerDocumentHighlightProvider(extension, selector, provider) {\n            const handle = this._addNewAdapter(new DocumentHighlightAdapter(this._documents, provider), extension);\n            this._proxy.$registerDocumentHighlightProvider(handle, this._transformDocumentSelector(selector));\n            return this._createDisposable(handle);\n        }\n        $provideDocumentHighlights(handle, resource, position, token) {\n            return this._withAdapter(handle, DocumentHighlightAdapter, adapter => adapter.provideDocumentHighlights(uri_1.URI.revive(resource), position, token), undefined);\n        }\n        // --- references\n        registerReferenceProvider(extension, selector, provider) {\n            const handle = this._addNewAdapter(new ReferenceAdapter(this._documents, provider), extension);\n            this._proxy.$registerReferenceSupport(handle, this._transformDocumentSelector(selector));\n            return this._createDisposable(handle);\n        }\n        $provideReferences(handle, resource, position, context, token) {\n            return this._withAdapter(handle, ReferenceAdapter, adapter => adapter.provideReferences(uri_1.URI.revive(resource), position, context, token), undefined);\n        }\n        // --- quick fix\n        registerCodeActionProvider(extension, selector, provider, metadata) {\n            const handle = this._addNewAdapter(new CodeActionAdapter(this._documents, this._commands.converter, this._diagnostics, provider, this._logService, extension.identifier), extension);\n            this._proxy.$registerQuickFixSupport(handle, this._transformDocumentSelector(selector), (metadata && metadata.providedCodeActionKinds) ? metadata.providedCodeActionKinds.map(kind => kind.value) : undefined);\n            return this._createDisposable(handle);\n        }\n        $provideCodeActions(handle, resource, rangeOrSelection, context, token) {\n            return this._withAdapter(handle, CodeActionAdapter, adapter => adapter.provideCodeActions(uri_1.URI.revive(resource), rangeOrSelection, context, token), undefined);\n        }\n        // --- formatting\n        registerDocumentFormattingEditProvider(extension, selector, provider) {\n            const handle = this._addNewAdapter(new DocumentFormattingAdapter(this._documents, provider), extension);\n            this._proxy.$registerDocumentFormattingSupport(handle, this._transformDocumentSelector(selector), extension.identifier, extension.displayName || extension.name);\n            return this._createDisposable(handle);\n        }\n        $provideDocumentFormattingEdits(handle, resource, options, token) {\n            return this._withAdapter(handle, DocumentFormattingAdapter, adapter => adapter.provideDocumentFormattingEdits(uri_1.URI.revive(resource), options, token), undefined);\n        }\n        registerDocumentRangeFormattingEditProvider(extension, selector, provider) {\n            const handle = this._addNewAdapter(new RangeFormattingAdapter(this._documents, provider), extension);\n            this._proxy.$registerRangeFormattingSupport(handle, this._transformDocumentSelector(selector), extension.identifier, extension.displayName || extension.name);\n            return this._createDisposable(handle);\n        }\n        $provideDocumentRangeFormattingEdits(handle, resource, range, options, token) {\n            return this._withAdapter(handle, RangeFormattingAdapter, adapter => adapter.provideDocumentRangeFormattingEdits(uri_1.URI.revive(resource), range, options, token), undefined);\n        }\n        registerOnTypeFormattingEditProvider(extension, selector, provider, triggerCharacters) {\n            const handle = this._addNewAdapter(new OnTypeFormattingAdapter(this._documents, provider), extension);\n            this._proxy.$registerOnTypeFormattingSupport(handle, this._transformDocumentSelector(selector), triggerCharacters, extension.identifier);\n            return this._createDisposable(handle);\n        }\n        $provideOnTypeFormattingEdits(handle, resource, position, ch, options, token) {\n            return this._withAdapter(handle, OnTypeFormattingAdapter, adapter => adapter.provideOnTypeFormattingEdits(uri_1.URI.revive(resource), position, ch, options, token), undefined);\n        }\n        // --- navigate types\n        registerWorkspaceSymbolProvider(extension, provider) {\n            const handle = this._addNewAdapter(new NavigateTypeAdapter(provider), extension);\n            this._proxy.$registerNavigateTypeSupport(handle);\n            return this._createDisposable(handle);\n        }\n        $provideWorkspaceSymbols(handle, search, token) {\n            return this._withAdapter(handle, NavigateTypeAdapter, adapter => adapter.provideWorkspaceSymbols(search, token), { symbols: [] });\n        }\n        $resolveWorkspaceSymbol(handle, symbol, token) {\n            return this._withAdapter(handle, NavigateTypeAdapter, adapter => adapter.resolveWorkspaceSymbol(symbol, token), undefined);\n        }\n        $releaseWorkspaceSymbols(handle, id) {\n            this._withAdapter(handle, NavigateTypeAdapter, adapter => adapter.releaseWorkspaceSymbols(id), undefined);\n        }\n        // --- rename\n        registerRenameProvider(extension, selector, provider) {\n            const handle = this._addNewAdapter(new RenameAdapter(this._documents, provider), extension);\n            this._proxy.$registerRenameSupport(handle, this._transformDocumentSelector(selector), RenameAdapter.supportsResolving(provider));\n            return this._createDisposable(handle);\n        }\n        $provideRenameEdits(handle, resource, position, newName, token) {\n            return this._withAdapter(handle, RenameAdapter, adapter => adapter.provideRenameEdits(uri_1.URI.revive(resource), position, newName, token), undefined);\n        }\n        $resolveRenameLocation(handle, resource, position, token) {\n            return this._withAdapter(handle, RenameAdapter, adapter => adapter.resolveRenameLocation(uri_1.URI.revive(resource), position, token), undefined);\n        }\n        // --- suggestion\n        registerCompletionItemProvider(extension, selector, provider, triggerCharacters) {\n            const handle = this._addNewAdapter(new SuggestAdapter(this._documents, this._commands.converter, provider), extension);\n            this._proxy.$registerSuggestSupport(handle, this._transformDocumentSelector(selector), triggerCharacters, SuggestAdapter.supportsResolving(provider));\n            return this._createDisposable(handle);\n        }\n        $provideCompletionItems(handle, resource, position, context, token) {\n            return this._withAdapter(handle, SuggestAdapter, adapter => adapter.provideCompletionItems(uri_1.URI.revive(resource), position, context, token), undefined);\n        }\n        $resolveCompletionItem(handle, resource, position, suggestion, token) {\n            return this._withAdapter(handle, SuggestAdapter, adapter => adapter.resolveCompletionItem(uri_1.URI.revive(resource), position, suggestion, token), suggestion);\n        }\n        $releaseCompletionItems(handle, id) {\n            this._withAdapter(handle, SuggestAdapter, adapter => adapter.releaseCompletionItems(id), undefined);\n        }\n        // --- parameter hints\n        registerSignatureHelpProvider(extension, selector, provider, metadataOrTriggerChars) {\n            const metadata = Array.isArray(metadataOrTriggerChars)\n                ? { triggerCharacters: metadataOrTriggerChars, retriggerCharacters: [] }\n                : metadataOrTriggerChars;\n            const handle = this._addNewAdapter(new SignatureHelpAdapter(this._documents, provider, this._heapService), extension);\n            this._proxy.$registerSignatureHelpProvider(handle, this._transformDocumentSelector(selector), metadata);\n            return this._createDisposable(handle);\n        }\n        $provideSignatureHelp(handle, resource, position, context, token) {\n            return this._withAdapter(handle, SignatureHelpAdapter, adapter => adapter.provideSignatureHelp(uri_1.URI.revive(resource), position, context, token), undefined);\n        }\n        // --- links\n        registerDocumentLinkProvider(extension, selector, provider) {\n            const handle = this._addNewAdapter(new LinkProviderAdapter(this._documents, this._heapService, provider), extension);\n            this._proxy.$registerDocumentLinkProvider(handle, this._transformDocumentSelector(selector));\n            return this._createDisposable(handle);\n        }\n        $provideDocumentLinks(handle, resource, token) {\n            return this._withAdapter(handle, LinkProviderAdapter, adapter => adapter.provideLinks(uri_1.URI.revive(resource), token), undefined);\n        }\n        $resolveDocumentLink(handle, link, token) {\n            return this._withAdapter(handle, LinkProviderAdapter, adapter => adapter.resolveLink(link, token), undefined);\n        }\n        registerColorProvider(extension, selector, provider) {\n            const handle = this._addNewAdapter(new ColorProviderAdapter(this._documents, provider), extension);\n            this._proxy.$registerDocumentColorProvider(handle, this._transformDocumentSelector(selector));\n            return this._createDisposable(handle);\n        }\n        $provideDocumentColors(handle, resource, token) {\n            return this._withAdapter(handle, ColorProviderAdapter, adapter => adapter.provideColors(uri_1.URI.revive(resource), token), []);\n        }\n        $provideColorPresentations(handle, resource, colorInfo, token) {\n            return this._withAdapter(handle, ColorProviderAdapter, adapter => adapter.provideColorPresentations(uri_1.URI.revive(resource), colorInfo, token), undefined);\n        }\n        registerFoldingRangeProvider(extension, selector, provider) {\n            const handle = this._addNewAdapter(new FoldingProviderAdapter(this._documents, provider), extension);\n            this._proxy.$registerFoldingRangeProvider(handle, this._transformDocumentSelector(selector));\n            return this._createDisposable(handle);\n        }\n        $provideFoldingRanges(handle, resource, context, token) {\n            return this._withAdapter(handle, FoldingProviderAdapter, adapter => adapter.provideFoldingRanges(uri_1.URI.revive(resource), context, token), undefined);\n        }\n        // --- smart select\n        registerSelectionRangeProvider(extension, selector, provider) {\n            const handle = this._addNewAdapter(new SelectionRangeAdapter(this._documents, provider), extension);\n            this._proxy.$registerSelectionRangeProvider(handle, this._transformDocumentSelector(selector));\n            return this._createDisposable(handle);\n        }\n        $provideSelectionRanges(handle, resource, positions, token) {\n            return this._withAdapter(handle, SelectionRangeAdapter, adapter => adapter.provideSelectionRanges(uri_1.URI.revive(resource), positions, token), []);\n        }\n        // --- call hierarchy\n        registerCallHierarchyProvider(extension, selector, provider) {\n            const handle = this._addNewAdapter(new CallHierarchyAdapter(this._documents, provider), extension);\n            this._proxy.$registerCallHierarchyProvider(handle, this._transformDocumentSelector(selector));\n            return this._createDisposable(handle);\n        }\n        $provideCallHierarchyItem(handle, resource, position, token) {\n            return this._withAdapter(handle, CallHierarchyAdapter, adapter => adapter.provideCallHierarchyItem(uri_1.URI.revive(resource), position, token), undefined);\n        }\n        $resolveCallHierarchyItem(handle, item, direction, token) {\n            return this._withAdapter(handle, CallHierarchyAdapter, adapter => adapter.resolveCallHierarchyItem(item, direction, token), []);\n        }\n        // --- configuration\n        static _serializeRegExp(regExp) {\n            return {\n                pattern: regExp.source,\n                flags: strings_1.regExpFlags(regExp),\n            };\n        }\n        static _serializeIndentationRule(indentationRule) {\n            return {\n                decreaseIndentPattern: ExtHostLanguageFeatures._serializeRegExp(indentationRule.decreaseIndentPattern),\n                increaseIndentPattern: ExtHostLanguageFeatures._serializeRegExp(indentationRule.increaseIndentPattern),\n                indentNextLinePattern: indentationRule.indentNextLinePattern ? ExtHostLanguageFeatures._serializeRegExp(indentationRule.indentNextLinePattern) : undefined,\n                unIndentedLinePattern: indentationRule.unIndentedLinePattern ? ExtHostLanguageFeatures._serializeRegExp(indentationRule.unIndentedLinePattern) : undefined,\n            };\n        }\n        static _serializeOnEnterRule(onEnterRule) {\n            return {\n                beforeText: ExtHostLanguageFeatures._serializeRegExp(onEnterRule.beforeText),\n                afterText: onEnterRule.afterText ? ExtHostLanguageFeatures._serializeRegExp(onEnterRule.afterText) : undefined,\n                oneLineAboveText: onEnterRule.oneLineAboveText ? ExtHostLanguageFeatures._serializeRegExp(onEnterRule.oneLineAboveText) : undefined,\n                action: onEnterRule.action\n            };\n        }\n        static _serializeOnEnterRules(onEnterRules) {\n            return onEnterRules.map(ExtHostLanguageFeatures._serializeOnEnterRule);\n        }\n        setLanguageConfiguration(languageId, configuration) {\n            let { wordPattern } = configuration;\n            // check for a valid word pattern\n            if (wordPattern && strings_1.regExpLeadsToEndlessLoop(wordPattern)) {\n                throw new Error(`Invalid language configuration: wordPattern '${wordPattern}' is not allowed to match the empty string.`);\n            }\n            // word definition\n            if (wordPattern) {\n                this._documents.setWordDefinitionFor(languageId, wordPattern);\n            }\n            else {\n                this._documents.setWordDefinitionFor(languageId, undefined);\n            }\n            const handle = this._nextHandle();\n            const serializedConfiguration = {\n                comments: configuration.comments,\n                brackets: configuration.brackets,\n                wordPattern: configuration.wordPattern ? ExtHostLanguageFeatures._serializeRegExp(configuration.wordPattern) : undefined,\n                indentationRules: configuration.indentationRules ? ExtHostLanguageFeatures._serializeIndentationRule(configuration.indentationRules) : undefined,\n                onEnterRules: configuration.onEnterRules ? ExtHostLanguageFeatures._serializeOnEnterRules(configuration.onEnterRules) : undefined,\n                __electricCharacterSupport: configuration.__electricCharacterSupport,\n                __characterPairSupport: configuration.__characterPairSupport,\n            };\n            this._proxy.$setLanguageConfiguration(handle, languageId, serializedConfiguration);\n            return this._createDisposable(handle);\n        }\n    }\n    ExtHostLanguageFeatures._handlePool = 0;\n    exports.ExtHostLanguageFeatures = ExtHostLanguageFeatures;\n});\n",null]}