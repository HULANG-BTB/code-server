{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/textfile/common/textFileEditorModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/textfile/common/textFileEditorModel.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/path\", \"vs/nls\", \"vs/base/common/event\", \"vs/base/common/mime\", \"vs/base/common/errorMessage\", \"vs/base/common/uri\", \"vs/base/common/types\", \"vs/platform/workspace/common/workspace\", \"vs/platform/environment/common/environment\", \"vs/workbench/services/textfile/common/textfiles\", \"vs/workbench/common/editor\", \"vs/workbench/common/editor/textEditorModel\", \"vs/workbench/services/backup/common/backup\", \"vs/platform/files/common/files\", \"vs/platform/instantiation/common/instantiation\", \"vs/editor/common/services/modeService\", \"vs/editor/common/services/modelService\", \"vs/platform/telemetry/common/telemetry\", \"vs/base/common/async\", \"vs/workbench/services/hash/common/hashService\", \"vs/editor/common/model/textModel\", \"vs/platform/notification/common/notification\", \"vs/base/common/platform\", \"vs/base/common/lifecycle\", \"vs/platform/log/common/log\", \"vs/base/common/resources\", \"vs/base/common/errors\"], function (require, exports, path_1, nls, event_1, mime_1, errorMessage_1, uri_1, types_1, workspace_1, environment_1, textfiles_1, editor_1, textEditorModel_1, backup_1, files_1, instantiation_1, modeService_1, modelService_1, telemetry_1, async_1, hashService_1, textModel_1, notification_1, platform_1, lifecycle_1, log_1, resources_1, errors_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * The text file editor model listens to changes to its underlying code editor model and saves these changes through the file service back to the disk.\n     */\n    let TextFileEditorModel = class TextFileEditorModel extends textEditorModel_1.BaseTextEditorModel {\n        constructor(resource, preferredEncoding, notificationService, modeService, modelService, fileService, instantiationService, telemetryService, textFileService, backupFileService, environmentService, contextService, hashService, logService) {\n            super(modelService, modeService);\n            this.notificationService = notificationService;\n            this.fileService = fileService;\n            this.instantiationService = instantiationService;\n            this.telemetryService = telemetryService;\n            this.textFileService = textFileService;\n            this.backupFileService = backupFileService;\n            this.environmentService = environmentService;\n            this.contextService = contextService;\n            this.hashService = hashService;\n            this.logService = logService;\n            this._onDidContentChange = this._register(new event_1.Emitter());\n            this._onDidStateChange = this._register(new event_1.Emitter());\n            this.resource = resource;\n            this.preferredEncoding = preferredEncoding;\n            this.inOrphanMode = false;\n            this.dirty = false;\n            this.versionId = 0;\n            this.lastSaveAttemptTime = 0;\n            this.saveSequentializer = new SaveSequentializer();\n            this.contentChangeEventScheduler = this._register(new async_1.RunOnceScheduler(() => this._onDidContentChange.fire(textfiles_1.StateChange.CONTENT_CHANGE), TextFileEditorModel.DEFAULT_CONTENT_CHANGE_BUFFER_DELAY));\n            this.orphanedChangeEventScheduler = this._register(new async_1.RunOnceScheduler(() => this._onDidStateChange.fire(textfiles_1.StateChange.ORPHANED_CHANGE), TextFileEditorModel.DEFAULT_ORPHANED_CHANGE_BUFFER_DELAY));\n            this.updateAutoSaveConfiguration(textFileService.getAutoSaveConfiguration());\n            this.registerListeners();\n        }\n        static setSaveErrorHandler(handler) { TextFileEditorModel.saveErrorHandler = handler; }\n        static setSaveParticipant(handler) { TextFileEditorModel.saveParticipant = handler; }\n        get onDidContentChange() { return this._onDidContentChange.event; }\n        get onDidStateChange() { return this._onDidStateChange.event; }\n        registerListeners() {\n            this._register(this.fileService.onFileChanges(e => this.onFileChanges(e)));\n            this._register(this.textFileService.onAutoSaveConfigurationChange(config => this.updateAutoSaveConfiguration(config)));\n            this._register(this.textFileService.onFilesAssociationChange(e => this.onFilesAssociationChange()));\n            this._register(this.onDidStateChange(e => this.onStateChange(e)));\n        }\n        onStateChange(e) {\n            if (e === textfiles_1.StateChange.REVERTED) {\n                // Cancel any content change event promises as they are no longer valid.\n                this.contentChangeEventScheduler.cancel();\n                // Refire state change reverted events as content change events\n                this._onDidContentChange.fire(textfiles_1.StateChange.REVERTED);\n            }\n        }\n        onFileChanges(e) {\n            let fileEventImpactsModel = false;\n            let newInOrphanModeGuess;\n            // If we are currently orphaned, we check if the model file was added back\n            if (this.inOrphanMode) {\n                const modelFileAdded = e.contains(this.resource, files_1.FileChangeType.ADDED);\n                if (modelFileAdded) {\n                    newInOrphanModeGuess = false;\n                    fileEventImpactsModel = true;\n                }\n            }\n            // Otherwise we check if the model file was deleted\n            else {\n                const modelFileDeleted = e.contains(this.resource, files_1.FileChangeType.DELETED);\n                if (modelFileDeleted) {\n                    newInOrphanModeGuess = true;\n                    fileEventImpactsModel = true;\n                }\n            }\n            if (fileEventImpactsModel && this.inOrphanMode !== newInOrphanModeGuess) {\n                let checkOrphanedPromise;\n                if (newInOrphanModeGuess) {\n                    // We have received reports of users seeing delete events even though the file still\n                    // exists (network shares issue: https://github.com/Microsoft/vscode/issues/13665).\n                    // Since we do not want to mark the model as orphaned, we have to check if the\n                    // file is really gone and not just a faulty file event.\n                    checkOrphanedPromise = async_1.timeout(100).then(() => {\n                        if (this.disposed) {\n                            return true;\n                        }\n                        return this.fileService.existsFile(this.resource).then(exists => !exists);\n                    });\n                }\n                else {\n                    checkOrphanedPromise = Promise.resolve(false);\n                }\n                checkOrphanedPromise.then(newInOrphanModeValidated => {\n                    if (this.inOrphanMode !== newInOrphanModeValidated && !this.disposed) {\n                        this.setOrphaned(newInOrphanModeValidated);\n                    }\n                });\n            }\n        }\n        setOrphaned(orphaned) {\n            if (this.inOrphanMode !== orphaned) {\n                this.inOrphanMode = orphaned;\n                this.orphanedChangeEventScheduler.schedule();\n            }\n        }\n        updateAutoSaveConfiguration(config) {\n            const autoSaveAfterMilliesEnabled = (typeof config.autoSaveDelay === 'number') && config.autoSaveDelay > 0;\n            this.autoSaveAfterMilliesEnabled = autoSaveAfterMilliesEnabled;\n            this.autoSaveAfterMillies = autoSaveAfterMilliesEnabled ? config.autoSaveDelay : undefined;\n        }\n        onFilesAssociationChange() {\n            if (!this.textEditorModel) {\n                return;\n            }\n            const firstLineText = this.getFirstLineText(this.textEditorModel);\n            const languageSelection = this.getOrCreateMode(this.modeService, undefined, firstLineText);\n            this.modelService.setMode(this.textEditorModel, languageSelection);\n        }\n        getVersionId() {\n            return this.versionId;\n        }\n        revert(soft) {\n            if (!this.isResolved()) {\n                return Promise.resolve(undefined);\n            }\n            // Cancel any running auto-save\n            this.cancelPendingAutoSave();\n            // Unset flags\n            const undo = this.setDirty(false);\n            let loadPromise;\n            if (soft) {\n                loadPromise = Promise.resolve();\n            }\n            else {\n                loadPromise = this.load({ forceReadFromDisk: true });\n            }\n            return loadPromise.then(() => {\n                // Emit file change event\n                this._onDidStateChange.fire(textfiles_1.StateChange.REVERTED);\n            }, error => {\n                // Set flags back to previous values, we are still dirty if revert failed\n                undo();\n                return Promise.reject(error);\n            });\n        }\n        load(options) {\n            this.logService.trace('load() - enter', this.resource);\n            // It is very important to not reload the model when the model is dirty.\n            // We also only want to reload the model from the disk if no save is pending\n            // to avoid data loss.\n            if (this.dirty || this.saveSequentializer.hasPendingSave()) {\n                this.logService.trace('load() - exit - without loading because model is dirty or being saved', this.resource);\n                return Promise.resolve(this);\n            }\n            // Only for new models we support to load from backup\n            if (!this.textEditorModel && !this.createTextEditorModelPromise) {\n                return this.loadFromBackup(options);\n            }\n            // Otherwise load from file resource\n            return this.loadFromFile(options);\n        }\n        loadFromBackup(options) {\n            return this.backupFileService.loadBackupResource(this.resource).then(backup => {\n                // Make sure meanwhile someone else did not suceed or start loading\n                if (this.createTextEditorModelPromise || this.textEditorModel) {\n                    return this.createTextEditorModelPromise || this;\n                }\n                // If we have a backup, continue loading with it\n                if (!!backup) {\n                    const content = {\n                        resource: this.resource,\n                        name: resources_1.basename(this.resource),\n                        mtime: Date.now(),\n                        size: 0,\n                        etag: files_1.etag(Date.now(), 0),\n                        value: textModel_1.createTextBufferFactory(''),\n                        encoding: this.fileService.encoding.getWriteEncoding(this.resource, this.preferredEncoding).encoding,\n                        isReadonly: false\n                    };\n                    return this.loadWithContent(content, options, backup);\n                }\n                // Otherwise load from file\n                return this.loadFromFile(options);\n            });\n        }\n        loadFromFile(options) {\n            const forceReadFromDisk = options && options.forceReadFromDisk;\n            const allowBinary = this.isResolved() /* always allow if we resolved previously */ || (options && options.allowBinary);\n            // Decide on etag\n            let etag;\n            if (forceReadFromDisk) {\n                etag = undefined; // reset ETag if we enforce to read from disk\n            }\n            else if (this.lastResolvedDiskStat) {\n                etag = this.lastResolvedDiskStat.etag; // otherwise respect etag to support caching\n            }\n            // Ensure to track the versionId before doing a long running operation\n            // to make sure the model was not changed in the meantime which would\n            // indicate that the user or program has made edits. If we would ignore\n            // this, we could potentially loose the changes that were made because\n            // after resolving the content we update the model and reset the dirty\n            // flag.\n            const currentVersionId = this.versionId;\n            // Resolve Content\n            return this.textFileService\n                .resolveTextContent(this.resource, { acceptTextOnly: !allowBinary, etag, encoding: this.preferredEncoding })\n                .then(content => {\n                // Clear orphaned state when loading was successful\n                this.setOrphaned(false);\n                // Guard against the model having changed in the meantime\n                if (currentVersionId === this.versionId) {\n                    return this.loadWithContent(content, options);\n                }\n                return this;\n            }, error => {\n                const result = error.fileOperationResult;\n                // Apply orphaned state based on error code\n                this.setOrphaned(result === files_1.FileOperationResult.FILE_NOT_FOUND);\n                // NotModified status is expected and can be handled gracefully\n                if (result === files_1.FileOperationResult.FILE_NOT_MODIFIED_SINCE) {\n                    // Guard against the model having changed in the meantime\n                    if (currentVersionId === this.versionId) {\n                        this.setDirty(false); // Ensure we are not tracking a stale state\n                    }\n                    return this;\n                }\n                // Ignore when a model has been resolved once and the file was deleted meanwhile. Since\n                // we already have the model loaded, we can return to this state and update the orphaned\n                // flag to indicate that this model has no version on disk anymore.\n                if (this.isResolved() && result === files_1.FileOperationResult.FILE_NOT_FOUND) {\n                    return this;\n                }\n                // Otherwise bubble up the error\n                return Promise.reject(error);\n            });\n        }\n        loadWithContent(content, options, backup) {\n            return this.doLoadWithContent(content, backup).then(model => {\n                // Telemetry: We log the fileGet telemetry event after the model has been loaded to ensure a good mimetype\n                const settingsType = this.getTypeIfSettings();\n                if (settingsType) {\n                    /* __GDPR__\n                        \"settingsRead\" : {\n                            \"settingsType\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                        }\n                    */\n                    this.telemetryService.publicLog('settingsRead', { settingsType }); // Do not log read to user settings.json and .vscode folder as a fileGet event as it ruins our JSON usage data\n                }\n                else {\n                    /* __GDPR__\n                        \"fileGet\" : {\n                            \"${include}\": [\n                                \"${FileTelemetryData}\"\n                            ]\n                        }\n                    */\n                    this.telemetryService.publicLog('fileGet', this.getTelemetryData(options && options.reason ? options.reason : textfiles_1.LoadReason.OTHER));\n                }\n                return model;\n            });\n        }\n        doLoadWithContent(content, backup) {\n            this.logService.trace('load() - resolved content', this.resource);\n            // Update our resolved disk stat model\n            this.updateLastResolvedDiskStat({\n                resource: this.resource,\n                name: content.name,\n                mtime: content.mtime,\n                size: content.size,\n                etag: content.etag,\n                isDirectory: false,\n                isSymbolicLink: false,\n                isReadonly: content.isReadonly\n            });\n            // Keep the original encoding to not loose it when saving\n            const oldEncoding = this.contentEncoding;\n            this.contentEncoding = content.encoding;\n            // Handle events if encoding changed\n            if (this.preferredEncoding) {\n                this.updatePreferredEncoding(this.contentEncoding); // make sure to reflect the real encoding of the file (never out of sync)\n            }\n            else if (oldEncoding !== this.contentEncoding) {\n                this._onDidStateChange.fire(textfiles_1.StateChange.ENCODING);\n            }\n            // Update Existing Model\n            if (this.textEditorModel) {\n                this.doUpdateTextModel(content.value);\n                return Promise.resolve(this);\n            }\n            // Join an existing request to create the editor model to avoid race conditions\n            else if (this.createTextEditorModelPromise) {\n                this.logService.trace('load() - join existing text editor model promise', this.resource);\n                return this.createTextEditorModelPromise;\n            }\n            // Create New Model\n            return this.doCreateTextModel(content.resource, content.value, backup);\n        }\n        doUpdateTextModel(value) {\n            this.logService.trace('load() - updated text editor model', this.resource);\n            // Ensure we are not tracking a stale state\n            this.setDirty(false);\n            // Update model value in a block that ignores model content change events\n            this.blockModelContentChange = true;\n            try {\n                this.updateTextEditorModel(value);\n            }\n            finally {\n                this.blockModelContentChange = false;\n            }\n            // Ensure we track the latest saved version ID given that the contents changed\n            this.updateSavedVersionId();\n        }\n        doCreateTextModel(resource, value, backup) {\n            this.logService.trace('load() - created text editor model', this.resource);\n            this.createTextEditorModelPromise = this.doLoadBackup(backup).then(backupContent => {\n                this.createTextEditorModelPromise = null;\n                // Create model\n                const hasBackupContent = !!backupContent;\n                this.createTextEditorModel(backupContent ? backupContent : value, resource);\n                // We restored a backup so we have to set the model as being dirty\n                // We also want to trigger auto save if it is enabled to simulate the exact same behaviour\n                // you would get if manually making the model dirty (fixes https://github.com/Microsoft/vscode/issues/16977)\n                if (hasBackupContent) {\n                    this.makeDirty();\n                    if (this.autoSaveAfterMilliesEnabled) {\n                        this.doAutoSave(this.versionId);\n                    }\n                }\n                // Ensure we are not tracking a stale state\n                else {\n                    this.setDirty(false);\n                }\n                // Model Listeners\n                this.installModelListeners();\n                return this;\n            }, error => {\n                this.createTextEditorModelPromise = null;\n                return Promise.reject(error);\n            });\n            return this.createTextEditorModelPromise;\n        }\n        installModelListeners() {\n            // See https://github.com/Microsoft/vscode/issues/30189\n            // This code has been extracted to a different method because it caused a memory leak\n            // where `value` was captured in the content change listener closure scope.\n            // Content Change\n            if (this.textEditorModel) {\n                this._register(this.textEditorModel.onDidChangeContent(() => this.onModelContentChanged()));\n            }\n        }\n        doLoadBackup(backup) {\n            if (!backup) {\n                return Promise.resolve(null);\n            }\n            return this.backupFileService.resolveBackupContent(backup).then(types_1.withUndefinedAsNull, error => null /* ignore errors */);\n        }\n        getOrCreateMode(modeService, preferredModeIds, firstLineText) {\n            return modeService.createByFilepathOrFirstLine(this.resource.fsPath, firstLineText);\n        }\n        onModelContentChanged() {\n            this.logService.trace(`onModelContentChanged() - enter`, this.resource);\n            // In any case increment the version id because it tracks the textual content state of the model at all times\n            this.versionId++;\n            this.logService.trace(`onModelContentChanged() - new versionId ${this.versionId}`, this.resource);\n            // Ignore if blocking model changes\n            if (this.blockModelContentChange) {\n                return;\n            }\n            // The contents changed as a matter of Undo and the version reached matches the saved one\n            // In this case we clear the dirty flag and emit a SAVED event to indicate this state.\n            // Note: we currently only do this check when auto-save is turned off because there you see\n            // a dirty indicator that you want to get rid of when undoing to the saved version.\n            if (!this.autoSaveAfterMilliesEnabled && this.textEditorModel && this.textEditorModel.getAlternativeVersionId() === this.bufferSavedVersionId) {\n                this.logService.trace('onModelContentChanged() - model content changed back to last saved version', this.resource);\n                // Clear flags\n                const wasDirty = this.dirty;\n                this.setDirty(false);\n                // Emit event\n                if (wasDirty) {\n                    this._onDidStateChange.fire(textfiles_1.StateChange.REVERTED);\n                }\n                return;\n            }\n            this.logService.trace('onModelContentChanged() - model content changed and marked as dirty', this.resource);\n            // Mark as dirty\n            this.makeDirty();\n            // Start auto save process unless we are in conflict resolution mode and unless it is disabled\n            if (this.autoSaveAfterMilliesEnabled) {\n                if (!this.inConflictMode) {\n                    this.doAutoSave(this.versionId);\n                }\n                else {\n                    this.logService.trace('makeDirty() - prevented save because we are in conflict resolution mode', this.resource);\n                }\n            }\n            // Handle content change events\n            this.contentChangeEventScheduler.schedule();\n        }\n        makeDirty() {\n            // Track dirty state and version id\n            const wasDirty = this.dirty;\n            this.setDirty(true);\n            // Emit as Event if we turned dirty\n            if (!wasDirty) {\n                this._onDidStateChange.fire(textfiles_1.StateChange.DIRTY);\n            }\n        }\n        doAutoSave(versionId) {\n            this.logService.trace(`doAutoSave() - enter for versionId ${versionId}`, this.resource);\n            // Cancel any currently running auto saves to make this the one that succeeds\n            this.cancelPendingAutoSave();\n            // Create new save timer and store it for disposal as needed\n            const handle = setTimeout(() => {\n                // Only trigger save if the version id has not changed meanwhile\n                if (versionId === this.versionId) {\n                    this.doSave(versionId, { reason: textfiles_1.SaveReason.AUTO }); // Very important here to not return the promise because if the timeout promise is canceled it will bubble up the error otherwise - do not change\n                }\n            }, this.autoSaveAfterMillies);\n            this.autoSaveDisposable = lifecycle_1.toDisposable(() => clearTimeout(handle));\n        }\n        cancelPendingAutoSave() {\n            if (this.autoSaveDisposable) {\n                this.autoSaveDisposable.dispose();\n                this.autoSaveDisposable = undefined;\n            }\n        }\n        save(options = Object.create(null)) {\n            if (!this.isResolved()) {\n                return Promise.resolve(undefined);\n            }\n            this.logService.trace('save() - enter', this.resource);\n            // Cancel any currently running auto saves to make this the one that succeeds\n            this.cancelPendingAutoSave();\n            return this.doSave(this.versionId, options);\n        }\n        doSave(versionId, options) {\n            if (types_1.isUndefinedOrNull(options.reason)) {\n                options.reason = textfiles_1.SaveReason.EXPLICIT;\n            }\n            this.logService.trace(`doSave(${versionId}) - enter with versionId ' + versionId`, this.resource);\n            // Lookup any running pending save for this versionId and return it if found\n            //\n            // Scenario: user invoked the save action multiple times quickly for the same contents\n            //           while the save was not yet finished to disk\n            //\n            if (this.saveSequentializer.hasPendingSave(versionId)) {\n                this.logService.trace(`doSave(${versionId}) - exit - found a pending save for versionId ${versionId}`, this.resource);\n                return this.saveSequentializer.pendingSave || Promise.resolve(undefined);\n            }\n            // Return early if not dirty (unless forced) or version changed meanwhile\n            //\n            // Scenario A: user invoked save action even though the model is not dirty\n            // Scenario B: auto save was triggered for a certain change by the user but meanwhile the user changed\n            //             the contents and the version for which auto save was started is no longer the latest.\n            //             Thus we avoid spawning multiple auto saves and only take the latest.\n            //\n            if ((!options.force && !this.dirty) || versionId !== this.versionId) {\n                this.logService.trace(`doSave(${versionId}) - exit - because not dirty and/or versionId is different (this.isDirty: ${this.dirty}, this.versionId: ${this.versionId})`, this.resource);\n                return Promise.resolve(undefined);\n            }\n            // Return if currently saving by storing this save request as the next save that should happen.\n            // Never ever must 2 saves execute at the same time because this can lead to dirty writes and race conditions.\n            //\n            // Scenario A: auto save was triggered and is currently busy saving to disk. this takes long enough that another auto save\n            //             kicks in.\n            // Scenario B: save is very slow (e.g. network share) and the user manages to change the buffer and trigger another save\n            //             while the first save has not returned yet.\n            //\n            if (this.saveSequentializer.hasPendingSave()) {\n                this.logService.trace(`doSave(${versionId}) - exit - because busy saving`, this.resource);\n                // Register this as the next upcoming save and return\n                return this.saveSequentializer.setNext(() => this.doSave(this.versionId /* make sure to use latest version id here */, options));\n            }\n            // Push all edit operations to the undo stack so that the user has a chance to\n            // Ctrl+Z back to the saved version. We only do this when auto-save is turned off\n            if (!this.autoSaveAfterMilliesEnabled && this.textEditorModel) {\n                this.textEditorModel.pushStackElement();\n            }\n            // A save participant can still change the model now and since we are so close to saving\n            // we do not want to trigger another auto save or similar, so we block this\n            // In addition we update our version right after in case it changed because of a model change\n            // Save participants can also be skipped through API.\n            let saveParticipantPromise = Promise.resolve(versionId);\n            if (TextFileEditorModel.saveParticipant && !options.skipSaveParticipants) {\n                const onCompleteOrError = () => {\n                    this.blockModelContentChange = false;\n                    return this.versionId;\n                };\n                this.blockModelContentChange = true;\n                saveParticipantPromise = TextFileEditorModel.saveParticipant.participate(this, { reason: options.reason }).then(onCompleteOrError, onCompleteOrError);\n            }\n            // mark the save participant as current pending save operation\n            return this.saveSequentializer.setPending(versionId, saveParticipantPromise.then(newVersionId => {\n                // We have to protect against being disposed at this point. It could be that the save() operation\n                // was triggerd followed by a dispose() operation right after without waiting. Typically we cannot\n                // be disposed if we are dirty, but if we are not dirty, save() and dispose() can still be triggered\n                // one after the other without waiting for the save() to complete. If we are disposed(), we risk\n                // saving contents to disk that are stale (see https://github.com/Microsoft/vscode/issues/50942).\n                // To fix this issue, we will not store the contents to disk when we got disposed.\n                if (this.disposed) {\n                    return undefined;\n                }\n                // Under certain conditions we do a short-cut of flushing contents to disk when we can assume that\n                // the file has not changed and as such was not dirty before.\n                // The conditions are all of:\n                // - a forced, explicit save (Ctrl+S)\n                // - the model is not dirty (otherwise we know there are changed which needs to go to the file)\n                // - the model is not in orphan mode (because in that case we know the file does not exist on disk)\n                // - the model version did not change due to save participants running\n                if (options.force && !this.dirty && !this.inOrphanMode && options.reason === textfiles_1.SaveReason.EXPLICIT && versionId === newVersionId) {\n                    return this.doTouch(newVersionId);\n                }\n                // update versionId with its new value (if pre-save changes happened)\n                versionId = newVersionId;\n                // Clear error flag since we are trying to save again\n                this.inErrorMode = false;\n                // Remember when this model was saved last\n                this.lastSaveAttemptTime = Date.now();\n                // Save to Disk\n                // mark the save operation as currently pending with the versionId (it might have changed from a save participant triggering)\n                this.logService.trace(`doSave(${versionId}) - before updateContent()`, this.resource);\n                const snapshot = this.createSnapshot();\n                if (!snapshot) {\n                    throw new Error('Invalid snapshot');\n                }\n                return this.saveSequentializer.setPending(newVersionId, this.fileService.updateContent(this.lastResolvedDiskStat.resource, snapshot, {\n                    overwriteReadonly: options.overwriteReadonly,\n                    overwriteEncoding: options.overwriteEncoding,\n                    mtime: this.lastResolvedDiskStat.mtime,\n                    encoding: this.getEncoding(),\n                    etag: this.lastResolvedDiskStat.etag,\n                    writeElevated: options.writeElevated\n                }).then(stat => {\n                    this.logService.trace(`doSave(${versionId}) - after updateContent()`, this.resource);\n                    // Update dirty state unless model has changed meanwhile\n                    if (versionId === this.versionId) {\n                        this.logService.trace(`doSave(${versionId}) - setting dirty to false because versionId did not change`, this.resource);\n                        this.setDirty(false);\n                    }\n                    else {\n                        this.logService.trace(`doSave(${versionId}) - not setting dirty to false because versionId did change meanwhile`, this.resource);\n                    }\n                    // Updated resolved stat with updated stat\n                    this.updateLastResolvedDiskStat(stat);\n                    // Cancel any content change event promises as they are no longer valid\n                    this.contentChangeEventScheduler.cancel();\n                    // Emit File Saved Event\n                    this._onDidStateChange.fire(textfiles_1.StateChange.SAVED);\n                    // Telemetry\n                    let telemetryPromise;\n                    const settingsType = this.getTypeIfSettings();\n                    if (settingsType) {\n                        /* __GDPR__\n                            \"settingsWritten\" : {\n                                \"settingsType\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                            }\n                        */\n                        this.telemetryService.publicLog('settingsWritten', { settingsType }); // Do not log write to user settings.json and .vscode folder as a filePUT event as it ruins our JSON usage data\n                        telemetryPromise = Promise.resolve();\n                    }\n                    else {\n                        telemetryPromise = this.getTelemetryData(options.reason).then(data => {\n                            /* __GDPR__\n                                \"filePUT\" : {\n                                    \"${include}\": [\n                                        \"${FileTelemetryData}\"\n                                    ]\n                                }\n                            */\n                            this.telemetryService.publicLog('filePUT', data);\n                        });\n                    }\n                    return telemetryPromise;\n                }, error => {\n                    if (!error) {\n                        error = new Error('Unknown Save Error'); // TODO@remote we should never get null as error (https://github.com/Microsoft/vscode/issues/55051)\n                    }\n                    this.logService.error(`doSave(${versionId}) - exit - resulted in a save error: ${error.toString()}`, this.resource);\n                    // Flag as error state in the model\n                    this.inErrorMode = true;\n                    // Look out for a save conflict\n                    if (error.fileOperationResult === files_1.FileOperationResult.FILE_MODIFIED_SINCE) {\n                        this.inConflictMode = true;\n                    }\n                    // Show to user\n                    this.onSaveError(error);\n                    // Emit as event\n                    this._onDidStateChange.fire(textfiles_1.StateChange.SAVE_ERROR);\n                }));\n            }));\n        }\n        getTypeIfSettings() {\n            if (resources_1.extname(this.resource) !== '.json') {\n                return '';\n            }\n            // Check for global settings file\n            if (resources_1.isEqual(this.resource, uri_1.URI.file(this.environmentService.appSettingsPath), !platform_1.isLinux)) {\n                return 'global-settings';\n            }\n            // Check for keybindings file\n            if (resources_1.isEqual(this.resource, uri_1.URI.file(this.environmentService.appKeybindingsPath), !platform_1.isLinux)) {\n                return 'keybindings';\n            }\n            // Check for locale file\n            if (resources_1.isEqual(this.resource, uri_1.URI.file(path_1.join(this.environmentService.appSettingsHome, 'locale.json')), !platform_1.isLinux)) {\n                return 'locale';\n            }\n            // Check for snippets\n            if (resources_1.isEqualOrParent(this.resource, uri_1.URI.file(path_1.join(this.environmentService.appSettingsHome, 'snippets')))) {\n                return 'snippets';\n            }\n            // Check for workspace settings file\n            const folders = this.contextService.getWorkspace().folders;\n            for (const folder of folders) {\n                if (resources_1.isEqualOrParent(this.resource, folder.toResource('.vscode'))) {\n                    const filename = resources_1.basename(this.resource);\n                    if (TextFileEditorModel.WHITELIST_WORKSPACE_JSON.indexOf(filename) > -1) {\n                        return `.vscode/${filename}`;\n                    }\n                }\n            }\n            return '';\n        }\n        getTelemetryData(reason) {\n            return this.hashService.createSHA1(this.resource.fsPath).then(hashedPath => {\n                const ext = resources_1.extname(this.resource);\n                const fileName = resources_1.basename(this.resource);\n                const telemetryData = {\n                    mimeType: mime_1.guessMimeTypes(this.resource.fsPath).join(', '),\n                    ext,\n                    path: hashedPath,\n                    reason\n                };\n                if (ext === '.json' && TextFileEditorModel.WHITELIST_JSON.indexOf(fileName) > -1) {\n                    telemetryData['whitelistedjson'] = fileName;\n                }\n                /* __GDPR__FRAGMENT__\n                    \"FileTelemetryData\" : {\n                        \"mimeType\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                        \"ext\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                        \"path\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                        \"reason\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                        \"whitelistedjson\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                    }\n                */\n                return telemetryData;\n            });\n        }\n        doTouch(versionId) {\n            const snapshot = this.createSnapshot();\n            if (!snapshot) {\n                throw new Error('invalid snapshot');\n            }\n            return this.saveSequentializer.setPending(versionId, this.fileService.updateContent(this.lastResolvedDiskStat.resource, snapshot, {\n                mtime: this.lastResolvedDiskStat.mtime,\n                encoding: this.getEncoding(),\n                etag: this.lastResolvedDiskStat.etag\n            }).then(stat => {\n                // Updated resolved stat with updated stat since touching it might have changed mtime\n                this.updateLastResolvedDiskStat(stat);\n            }, error => errors_1.onUnexpectedError(error) /* just log any error but do not notify the user since the file was not dirty */));\n        }\n        setDirty(dirty) {\n            const wasDirty = this.dirty;\n            const wasInConflictMode = this.inConflictMode;\n            const wasInErrorMode = this.inErrorMode;\n            const oldBufferSavedVersionId = this.bufferSavedVersionId;\n            if (!dirty) {\n                this.dirty = false;\n                this.inConflictMode = false;\n                this.inErrorMode = false;\n                this.updateSavedVersionId();\n            }\n            else {\n                this.dirty = true;\n            }\n            // Return function to revert this call\n            return () => {\n                this.dirty = wasDirty;\n                this.inConflictMode = wasInConflictMode;\n                this.inErrorMode = wasInErrorMode;\n                this.bufferSavedVersionId = oldBufferSavedVersionId;\n            };\n        }\n        updateSavedVersionId() {\n            // we remember the models alternate version id to remember when the version\n            // of the model matches with the saved version on disk. we need to keep this\n            // in order to find out if the model changed back to a saved version (e.g.\n            // when undoing long enough to reach to a version that is saved and then to\n            // clear the dirty flag)\n            if (this.textEditorModel) {\n                this.bufferSavedVersionId = this.textEditorModel.getAlternativeVersionId();\n            }\n        }\n        updateLastResolvedDiskStat(newVersionOnDiskStat) {\n            // First resolve - just take\n            if (!this.lastResolvedDiskStat) {\n                this.lastResolvedDiskStat = newVersionOnDiskStat;\n            }\n            // Subsequent resolve - make sure that we only assign it if the mtime is equal or has advanced.\n            // This prevents race conditions from loading and saving. If a save comes in late after a revert\n            // was called, the mtime could be out of sync.\n            else if (this.lastResolvedDiskStat.mtime <= newVersionOnDiskStat.mtime) {\n                this.lastResolvedDiskStat = newVersionOnDiskStat;\n            }\n        }\n        onSaveError(error) {\n            // Prepare handler\n            if (!TextFileEditorModel.saveErrorHandler) {\n                TextFileEditorModel.setSaveErrorHandler(this.instantiationService.createInstance(DefaultSaveErrorHandler));\n            }\n            // Handle\n            TextFileEditorModel.saveErrorHandler.onSaveError(error, this);\n        }\n        isDirty() {\n            return this.dirty;\n        }\n        getLastSaveAttemptTime() {\n            return this.lastSaveAttemptTime;\n        }\n        getETag() {\n            return this.lastResolvedDiskStat ? this.lastResolvedDiskStat.etag || null : null;\n        }\n        hasState(state) {\n            switch (state) {\n                case textfiles_1.ModelState.CONFLICT:\n                    return this.inConflictMode;\n                case textfiles_1.ModelState.DIRTY:\n                    return this.dirty;\n                case textfiles_1.ModelState.ERROR:\n                    return this.inErrorMode;\n                case textfiles_1.ModelState.ORPHAN:\n                    return this.inOrphanMode;\n                case textfiles_1.ModelState.PENDING_SAVE:\n                    return this.saveSequentializer.hasPendingSave();\n                case textfiles_1.ModelState.SAVED:\n                    return !this.dirty;\n            }\n        }\n        getEncoding() {\n            return this.preferredEncoding || this.contentEncoding;\n        }\n        setEncoding(encoding, mode) {\n            if (!this.isNewEncoding(encoding)) {\n                return; // return early if the encoding is already the same\n            }\n            // Encode: Save with encoding\n            if (mode === editor_1.EncodingMode.Encode) {\n                this.updatePreferredEncoding(encoding);\n                // Save\n                if (!this.isDirty()) {\n                    this.versionId++; // needs to increment because we change the model potentially\n                    this.makeDirty();\n                }\n                if (!this.inConflictMode) {\n                    this.save({ overwriteEncoding: true });\n                }\n            }\n            // Decode: Load with encoding\n            else {\n                if (this.isDirty()) {\n                    this.notificationService.info(nls.localize('saveFileFirst', \"The file is dirty. Please save it first before reopening it with another encoding.\"));\n                    return;\n                }\n                this.updatePreferredEncoding(encoding);\n                // Load\n                this.load({\n                    forceReadFromDisk: true // because encoding has changed\n                });\n            }\n        }\n        updatePreferredEncoding(encoding) {\n            if (!this.isNewEncoding(encoding)) {\n                return;\n            }\n            this.preferredEncoding = encoding;\n            // Emit\n            this._onDidStateChange.fire(textfiles_1.StateChange.ENCODING);\n        }\n        isNewEncoding(encoding) {\n            if (this.preferredEncoding === encoding) {\n                return false; // return early if the encoding is already the same\n            }\n            if (!this.preferredEncoding && this.contentEncoding === encoding) {\n                return false; // also return if we don't have a preferred encoding but the content encoding is already the same\n            }\n            return true;\n        }\n        isResolved() {\n            return !types_1.isUndefinedOrNull(this.lastResolvedDiskStat);\n        }\n        isReadonly() {\n            return !!(this.lastResolvedDiskStat && this.lastResolvedDiskStat.isReadonly);\n        }\n        isDisposed() {\n            return this.disposed;\n        }\n        getResource() {\n            return this.resource;\n        }\n        getStat() {\n            return this.lastResolvedDiskStat;\n        }\n        dispose() {\n            this.disposed = true;\n            this.inConflictMode = false;\n            this.inOrphanMode = false;\n            this.inErrorMode = false;\n            this.createTextEditorModelPromise = null;\n            this.cancelPendingAutoSave();\n            super.dispose();\n        }\n    };\n    TextFileEditorModel.DEFAULT_CONTENT_CHANGE_BUFFER_DELAY = files_1.CONTENT_CHANGE_EVENT_BUFFER_DELAY;\n    TextFileEditorModel.DEFAULT_ORPHANED_CHANGE_BUFFER_DELAY = 100;\n    TextFileEditorModel.WHITELIST_JSON = ['package.json', 'package-lock.json', 'tsconfig.json', 'jsconfig.json', 'bower.json', '.eslintrc.json', 'tslint.json', 'composer.json'];\n    TextFileEditorModel.WHITELIST_WORKSPACE_JSON = ['settings.json', 'extensions.json', 'tasks.json', 'launch.json'];\n    TextFileEditorModel = __decorate([\n        __param(2, notification_1.INotificationService),\n        __param(3, modeService_1.IModeService),\n        __param(4, modelService_1.IModelService),\n        __param(5, files_1.IFileService),\n        __param(6, instantiation_1.IInstantiationService),\n        __param(7, telemetry_1.ITelemetryService),\n        __param(8, textfiles_1.ITextFileService),\n        __param(9, backup_1.IBackupFileService),\n        __param(10, environment_1.IEnvironmentService),\n        __param(11, workspace_1.IWorkspaceContextService),\n        __param(12, hashService_1.IHashService),\n        __param(13, log_1.ILogService)\n    ], TextFileEditorModel);\n    exports.TextFileEditorModel = TextFileEditorModel;\n    class SaveSequentializer {\n        hasPendingSave(versionId) {\n            if (!this._pendingSave) {\n                return false;\n            }\n            if (typeof versionId === 'number') {\n                return this._pendingSave.versionId === versionId;\n            }\n            return !!this._pendingSave;\n        }\n        get pendingSave() {\n            return this._pendingSave ? this._pendingSave.promise : undefined;\n        }\n        setPending(versionId, promise) {\n            this._pendingSave = { versionId, promise };\n            promise.then(() => this.donePending(versionId), () => this.donePending(versionId));\n            return promise;\n        }\n        donePending(versionId) {\n            if (this._pendingSave && versionId === this._pendingSave.versionId) {\n                // only set pending to done if the promise finished that is associated with that versionId\n                this._pendingSave = undefined;\n                // schedule the next save now that we are free if we have any\n                this.triggerNextSave();\n            }\n        }\n        triggerNextSave() {\n            if (this._nextSave) {\n                const saveOperation = this._nextSave;\n                this._nextSave = undefined;\n                // Run next save and complete on the associated promise\n                saveOperation.run().then(saveOperation.promiseResolve, saveOperation.promiseReject);\n            }\n        }\n        setNext(run) {\n            // this is our first next save, so we create associated promise with it\n            // so that we can return a promise that completes when the save operation\n            // has completed.\n            if (!this._nextSave) {\n                let promiseResolve;\n                let promiseReject;\n                const promise = new Promise((resolve, reject) => {\n                    promiseResolve = resolve;\n                    promiseReject = reject;\n                });\n                this._nextSave = {\n                    run,\n                    promise,\n                    promiseResolve: promiseResolve,\n                    promiseReject: promiseReject\n                };\n            }\n            // we have a previous next save, just overwrite it\n            else {\n                this._nextSave.run = run;\n            }\n            return this._nextSave.promise;\n        }\n    }\n    exports.SaveSequentializer = SaveSequentializer;\n    let DefaultSaveErrorHandler = class DefaultSaveErrorHandler {\n        constructor(notificationService) {\n            this.notificationService = notificationService;\n        }\n        onSaveError(error, model) {\n            this.notificationService.error(nls.localize('genericSaveError', \"Failed to save '{0}': {1}\", resources_1.basename(model.getResource()), errorMessage_1.toErrorMessage(error, false)));\n        }\n    };\n    DefaultSaveErrorHandler = __decorate([\n        __param(0, notification_1.INotificationService)\n    ], DefaultSaveErrorHandler);\n});\n",null]}