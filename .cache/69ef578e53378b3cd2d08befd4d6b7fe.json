{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/platform/storage/common/storage.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/storage/common/storage.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar event_1 = require(\"vs/base/common/event\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar types_1 = require(\"vs/base/common/types\");\nexports.IStorageService = instantiation_1.createDecorator('storageService');\nvar WillSaveStateReason;\n(function (WillSaveStateReason) {\n    WillSaveStateReason[WillSaveStateReason[\"NONE\"] = 0] = \"NONE\";\n    WillSaveStateReason[WillSaveStateReason[\"SHUTDOWN\"] = 1] = \"SHUTDOWN\";\n})(WillSaveStateReason = exports.WillSaveStateReason || (exports.WillSaveStateReason = {}));\nvar StorageScope;\n(function (StorageScope) {\n    /**\n     * The stored data will be scoped to all workspaces.\n     */\n    StorageScope[StorageScope[\"GLOBAL\"] = 0] = \"GLOBAL\";\n    /**\n     * The stored data will be scoped to the current workspace.\n     */\n    StorageScope[StorageScope[\"WORKSPACE\"] = 1] = \"WORKSPACE\";\n})(StorageScope = exports.StorageScope || (exports.StorageScope = {}));\nvar InMemoryStorageService = /** @class */ (function (_super) {\n    tslib_1.__extends(InMemoryStorageService, _super);\n    function InMemoryStorageService() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._serviceBrand = undefined;\n        _this._onDidChangeStorage = _this._register(new event_1.Emitter());\n        _this.onWillSaveState = event_1.Event.None;\n        _this.globalCache = new Map();\n        _this.workspaceCache = new Map();\n        return _this;\n    }\n    Object.defineProperty(InMemoryStorageService.prototype, \"onDidChangeStorage\", {\n        get: function () { return this._onDidChangeStorage.event; },\n        enumerable: true,\n        configurable: true\n    });\n    InMemoryStorageService.prototype.getCache = function (scope) {\n        return scope === StorageScope.GLOBAL ? this.globalCache : this.workspaceCache;\n    };\n    InMemoryStorageService.prototype.get = function (key, scope, fallbackValue) {\n        var value = this.getCache(scope).get(key);\n        if (types_1.isUndefinedOrNull(value)) {\n            return fallbackValue;\n        }\n        return value;\n    };\n    InMemoryStorageService.prototype.getBoolean = function (key, scope, fallbackValue) {\n        var value = this.getCache(scope).get(key);\n        if (types_1.isUndefinedOrNull(value)) {\n            return fallbackValue;\n        }\n        return value === 'true';\n    };\n    InMemoryStorageService.prototype.getNumber = function (key, scope, fallbackValue) {\n        var value = this.getCache(scope).get(key);\n        if (types_1.isUndefinedOrNull(value)) {\n            return fallbackValue;\n        }\n        return parseInt(value, 10);\n    };\n    InMemoryStorageService.prototype.store = function (key, value, scope) {\n        // We remove the key for undefined/null values\n        if (types_1.isUndefinedOrNull(value)) {\n            return this.remove(key, scope);\n        }\n        // Otherwise, convert to String and store\n        var valueStr = String(value);\n        // Return early if value already set\n        var currentValue = this.getCache(scope).get(key);\n        if (currentValue === valueStr) {\n            return Promise.resolve();\n        }\n        // Update in cache\n        this.getCache(scope).set(key, valueStr);\n        // Events\n        this._onDidChangeStorage.fire({ scope: scope, key: key });\n        return Promise.resolve();\n    };\n    InMemoryStorageService.prototype.remove = function (key, scope) {\n        var wasDeleted = this.getCache(scope).delete(key);\n        if (!wasDeleted) {\n            return Promise.resolve(); // Return early if value already deleted\n        }\n        // Events\n        this._onDidChangeStorage.fire({ scope: scope, key: key });\n        return Promise.resolve();\n    };\n    return InMemoryStorageService;\n}(lifecycle_1.Disposable));\nexports.InMemoryStorageService = InMemoryStorageService;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/platform/storage/common/storage.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/platform/storage/common/storage.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;;AAEhG,gFAAiF;AACjF,8CAAsD;AACtD,sDAAsD;AACtD,8CAAyD;AAE5C,QAAA,eAAe,GAAG,+BAAe,CAAkB,gBAAgB,CAAC,CAAC;AAElF,IAAY,mBAGX;AAHD,WAAY,mBAAmB;IAC9B,6DAAQ,CAAA;IACR,qEAAY,CAAA;AACb,CAAC,EAHW,mBAAmB,GAAnB,2BAAmB,KAAnB,2BAAmB,QAG9B;AA0ED,IAAkB,YAWjB;AAXD,WAAkB,YAAY;IAE7B;;OAEG;IACH,mDAAM,CAAA;IAEN;;OAEG;IACH,yDAAS,CAAA;AACV,CAAC,EAXiB,YAAY,GAAZ,oBAAY,KAAZ,oBAAY,QAW7B;AAOD;IAA4C,kDAAU;IAAtD;QAAA,qEAoFC;QAnFA,mBAAa,GAAG,SAAS,CAAC;QAET,yBAAmB,GAA0C,KAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAAgC,CAAC,CAAC;QAGjI,qBAAe,GAAG,aAAK,CAAC,IAAI,CAAC;QAE9B,iBAAW,GAAwB,IAAI,GAAG,EAAkB,CAAC;QAC7D,oBAAc,GAAwB,IAAI,GAAG,EAAkB,CAAC;;IA2EzE,CAAC;IAhFA,sBAAI,sDAAkB;aAAtB,cAAgE,OAAO,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC,CAAC;;;OAAA;IAOhG,yCAAQ,GAAhB,UAAiB,KAAmB;QACnC,OAAO,KAAK,KAAK,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC;IAC/E,CAAC;IAGD,oCAAG,GAAH,UAAI,GAAW,EAAE,KAAmB,EAAE,aAAsB;QAC3D,IAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAE5C,IAAI,yBAAiB,CAAC,KAAK,CAAC,EAAE;YAC7B,OAAO,aAAa,CAAC;SACrB;QAED,OAAO,KAAK,CAAC;IACd,CAAC;IAGD,2CAAU,GAAV,UAAW,GAAW,EAAE,KAAmB,EAAE,aAAuB;QACnE,IAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAE5C,IAAI,yBAAiB,CAAC,KAAK,CAAC,EAAE;YAC7B,OAAO,aAAa,CAAC;SACrB;QAED,OAAO,KAAK,KAAK,MAAM,CAAC;IACzB,CAAC;IAGD,0CAAS,GAAT,UAAU,GAAW,EAAE,KAAmB,EAAE,aAAsB;QACjE,IAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAE5C,IAAI,yBAAiB,CAAC,KAAK,CAAC,EAAE;YAC7B,OAAO,aAAa,CAAC;SACrB;QAED,OAAO,QAAQ,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;IAC5B,CAAC;IAED,sCAAK,GAAL,UAAM,GAAW,EAAE,KAAgC,EAAE,KAAmB;QAEvE,8CAA8C;QAC9C,IAAI,yBAAiB,CAAC,KAAK,CAAC,EAAE;YAC7B,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;SAC/B;QAED,yCAAyC;QACzC,IAAM,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;QAE/B,oCAAoC;QACpC,IAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QACnD,IAAI,YAAY,KAAK,QAAQ,EAAE;YAC9B,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;SACzB;QAED,kBAAkB;QAClB,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;QAExC,SAAS;QACT,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,EAAE,KAAK,OAAA,EAAE,GAAG,KAAA,EAAE,CAAC,CAAC;QAE9C,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;IAC1B,CAAC;IAED,uCAAM,GAAN,UAAO,GAAW,EAAE,KAAmB;QACtC,IAAM,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QACpD,IAAI,CAAC,UAAU,EAAE;YAChB,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC,wCAAwC;SAClE;QAED,SAAS;QACT,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,EAAE,KAAK,OAAA,EAAE,GAAG,KAAA,EAAE,CAAC,CAAC;QAE9C,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;IAC1B,CAAC;IACF,6BAAC;AAAD,CAAC,AApFD,CAA4C,sBAAU,GAoFrD;AApFY,wDAAsB","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { isUndefinedOrNull } from 'vs/base/common/types';\n\nexport const IStorageService = createDecorator<IStorageService>('storageService');\n\nexport enum WillSaveStateReason {\n\tNONE = 0,\n\tSHUTDOWN = 1\n}\n\nexport interface IWillSaveStateEvent {\n\treason: WillSaveStateReason;\n}\n\nexport interface IStorageService {\n\t_serviceBrand: any;\n\n\t/**\n\t * Emitted whenever data is updated or deleted.\n\t */\n\treadonly onDidChangeStorage: Event<IWorkspaceStorageChangeEvent>;\n\n\t/**\n\t * Emitted when the storage is about to persist. This is the right time\n\t * to persist data to ensure it is stored before the application shuts\n\t * down.\n\t *\n\t * The will save state event allows to optionally ask for the reason of\n\t * saving the state, e.g. to find out if the state is saved due to a\n\t * shutdown.\n\t */\n\treadonly onWillSaveState: Event<IWillSaveStateEvent>;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided defaultValue if the element is null or undefined.\n\t *\n\t * The scope argument allows to define the scope of the storage\n\t * operation to either the current workspace only or all workspaces.\n\t */\n\tget(key: string, scope: StorageScope, fallbackValue: string): string;\n\tget(key: string, scope: StorageScope, fallbackValue?: string): string | undefined;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided defaultValue if the element is null or undefined. The element\n\t * will be converted to a boolean.\n\t *\n\t * The scope argument allows to define the scope of the storage\n\t * operation to either the current workspace only or all workspaces.\n\t */\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue?: boolean): boolean | undefined;\n\n\t/**\n\t * Retrieve an element stored with the given key from storage. Use\n\t * the provided defaultValue if the element is null or undefined. The element\n\t * will be converted to a number using parseInt with a base of 10.\n\t *\n\t * The scope argument allows to define the scope of the storage\n\t * operation to either the current workspace only or all workspaces.\n\t */\n\tgetNumber(key: string, scope: StorageScope, fallbackValue: number): number;\n\tgetNumber(key: string, scope: StorageScope, fallbackValue?: number): number | undefined;\n\n\t/**\n\t * Store a value under the given key to storage. The value will be converted to a string.\n\t *\n\t * The scope argument allows to define the scope of the storage\n\t * operation to either the current workspace only or all workspaces.\n\t */\n\tstore(key: string, value: string | boolean | number, scope: StorageScope): void;\n\n\t/**\n\t * Delete an element stored under the provided key from storage.\n\t *\n\t * The scope argument allows to define the scope of the storage\n\t * operation to either the current workspace only or all workspaces.\n\t */\n\tremove(key: string, scope: StorageScope): void;\n}\n\nexport const enum StorageScope {\n\n\t/**\n\t * The stored data will be scoped to all workspaces.\n\t */\n\tGLOBAL,\n\n\t/**\n\t * The stored data will be scoped to the current workspace.\n\t */\n\tWORKSPACE\n}\n\nexport interface IWorkspaceStorageChangeEvent {\n\tkey: string;\n\tscope: StorageScope;\n}\n\nexport class InMemoryStorageService extends Disposable implements IStorageService {\n\t_serviceBrand = undefined;\n\n\tprivate readonly _onDidChangeStorage: Emitter<IWorkspaceStorageChangeEvent> = this._register(new Emitter<IWorkspaceStorageChangeEvent>());\n\tget onDidChangeStorage(): Event<IWorkspaceStorageChangeEvent> { return this._onDidChangeStorage.event; }\n\n\treadonly onWillSaveState = Event.None;\n\n\tprivate globalCache: Map<string, string> = new Map<string, string>();\n\tprivate workspaceCache: Map<string, string> = new Map<string, string>();\n\n\tprivate getCache(scope: StorageScope): Map<string, string> {\n\t\treturn scope === StorageScope.GLOBAL ? this.globalCache : this.workspaceCache;\n\t}\n\n\tget(key: string, scope: StorageScope, fallbackValue: string): string;\n\tget(key: string, scope: StorageScope, fallbackValue?: string): string | undefined {\n\t\tconst value = this.getCache(scope).get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue: boolean): boolean;\n\tgetBoolean(key: string, scope: StorageScope, fallbackValue?: boolean): boolean | undefined {\n\t\tconst value = this.getCache(scope).get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn value === 'true';\n\t}\n\n\tgetNumber(key: string, scope: StorageScope, fallbackValue: number): number;\n\tgetNumber(key: string, scope: StorageScope, fallbackValue?: number): number | undefined {\n\t\tconst value = this.getCache(scope).get(key);\n\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn fallbackValue;\n\t\t}\n\n\t\treturn parseInt(value, 10);\n\t}\n\n\tstore(key: string, value: string | boolean | number, scope: StorageScope): Promise<void> {\n\n\t\t// We remove the key for undefined/null values\n\t\tif (isUndefinedOrNull(value)) {\n\t\t\treturn this.remove(key, scope);\n\t\t}\n\n\t\t// Otherwise, convert to String and store\n\t\tconst valueStr = String(value);\n\n\t\t// Return early if value already set\n\t\tconst currentValue = this.getCache(scope).get(key);\n\t\tif (currentValue === valueStr) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\t// Update in cache\n\t\tthis.getCache(scope).set(key, valueStr);\n\n\t\t// Events\n\t\tthis._onDidChangeStorage.fire({ scope, key });\n\n\t\treturn Promise.resolve();\n\t}\n\n\tremove(key: string, scope: StorageScope): Promise<void> {\n\t\tconst wasDeleted = this.getCache(scope).delete(key);\n\t\tif (!wasDeleted) {\n\t\t\treturn Promise.resolve(); // Return early if value already deleted\n\t\t}\n\n\t\t// Events\n\t\tthis._onDidChangeStorage.fire({ scope, key });\n\n\t\treturn Promise.resolve();\n\t}\n}"]}]}