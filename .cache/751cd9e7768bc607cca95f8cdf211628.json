{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostDebugService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostDebugService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/path\", \"vs/base/common/network\", \"vs/base/common/uri\", \"vs/base/common/event\", \"vs/base/common/async\", \"vs/nls\", \"vs/workbench/api/common/extHost.protocol\", \"vs/workbench/api/node/extHostTypes\", \"vs/workbench/contrib/debug/node/debugAdapter\", \"vs/workbench/contrib/debug/common/abstractDebugAdapter\", \"vs/workbench/contrib/debug/node/terminals\", \"vs/workbench/services/configurationResolver/common/variableResolver\", \"vs/workbench/contrib/debug/common/debugUtils\", \"vs/base/common/cancellation\"], function (require, exports, path, network_1, uri_1, event_1, async_1, nls, extHost_protocol_1, extHostTypes_1, debugAdapter_1, abstractDebugAdapter_1, terminals_1, variableResolver_1, debugUtils_1, cancellation_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class ExtHostDebugService {\n        constructor(mainContext, _workspaceService, _extensionService, _editorsService, _configurationService, _terminalService, _commandService) {\n            this._workspaceService = _workspaceService;\n            this._extensionService = _extensionService;\n            this._editorsService = _editorsService;\n            this._configurationService = _configurationService;\n            this._terminalService = _terminalService;\n            this._commandService = _commandService;\n            this._debugSessions = new Map();\n            this._configProviderHandleCounter = 0;\n            this._configProviders = [];\n            this._adapterFactoryHandleCounter = 0;\n            this._adapterFactories = [];\n            this._trackerFactoryHandleCounter = 0;\n            this._trackerFactories = [];\n            this._aexCommands = new Map();\n            this._debugAdapters = new Map();\n            this._debugAdaptersTrackers = new Map();\n            this._onDidStartDebugSession = new event_1.Emitter();\n            this._onDidTerminateDebugSession = new event_1.Emitter();\n            this._onDidChangeActiveDebugSession = new event_1.Emitter();\n            this._onDidReceiveDebugSessionCustomEvent = new event_1.Emitter();\n            this._debugServiceProxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadDebugService);\n            this._onDidChangeBreakpoints = new event_1.Emitter({\n                onFirstListenerAdd: () => {\n                    this.startBreakpoints();\n                }\n            });\n            this._activeDebugConsole = new ExtHostDebugConsole(this._debugServiceProxy);\n            this._breakpoints = new Map();\n            this._breakpointEventsActive = false;\n            this._extensionService.getExtensionRegistry().then((extensionRegistry) => {\n                extensionRegistry.onDidChange(_ => {\n                    this.registerAllDebugTypes(extensionRegistry);\n                });\n                this.registerAllDebugTypes(extensionRegistry);\n            });\n        }\n        get onDidStartDebugSession() { return this._onDidStartDebugSession.event; }\n        get onDidTerminateDebugSession() { return this._onDidTerminateDebugSession.event; }\n        get onDidChangeActiveDebugSession() { return this._onDidChangeActiveDebugSession.event; }\n        get activeDebugSession() { return this._activeDebugSession; }\n        get onDidReceiveDebugSessionCustomEvent() { return this._onDidReceiveDebugSessionCustomEvent.event; }\n        get activeDebugConsole() { return this._activeDebugConsole; }\n        registerAllDebugTypes(extensionRegistry) {\n            const debugTypes = [];\n            this._aexCommands.clear();\n            for (const ed of extensionRegistry.getAllExtensionDescriptions()) {\n                if (ed.contributes) {\n                    const debuggers = ed.contributes['debuggers'];\n                    if (debuggers && debuggers.length > 0) {\n                        for (const dbg of debuggers) {\n                            if (debugUtils_1.isDebuggerMainContribution(dbg)) {\n                                debugTypes.push(dbg.type);\n                                if (dbg.adapterExecutableCommand) {\n                                    this._aexCommands.set(dbg.type, dbg.adapterExecutableCommand);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            this._debugServiceProxy.$registerDebugTypes(debugTypes);\n        }\n        // extension debug API\n        get onDidChangeBreakpoints() {\n            return this._onDidChangeBreakpoints.event;\n        }\n        get breakpoints() {\n            this.startBreakpoints();\n            const result = [];\n            this._breakpoints.forEach(bp => result.push(bp));\n            return result;\n        }\n        addBreakpoints(breakpoints0) {\n            this.startBreakpoints();\n            // filter only new breakpoints\n            const breakpoints = breakpoints0.filter(bp => {\n                const id = bp.id;\n                if (!this._breakpoints.has(id)) {\n                    this._breakpoints.set(id, bp);\n                    return true;\n                }\n                return false;\n            });\n            // send notification for added breakpoints\n            this.fireBreakpointChanges(breakpoints, [], []);\n            // convert added breakpoints to DTOs\n            const dtos = [];\n            const map = new Map();\n            for (const bp of breakpoints) {\n                if (bp instanceof extHostTypes_1.SourceBreakpoint) {\n                    let dto = map.get(bp.location.uri.toString());\n                    if (!dto) {\n                        dto = {\n                            type: 'sourceMulti',\n                            uri: bp.location.uri,\n                            lines: []\n                        };\n                        map.set(bp.location.uri.toString(), dto);\n                        dtos.push(dto);\n                    }\n                    dto.lines.push({\n                        id: bp.id,\n                        enabled: bp.enabled,\n                        condition: bp.condition,\n                        hitCondition: bp.hitCondition,\n                        logMessage: bp.logMessage,\n                        line: bp.location.range.start.line,\n                        character: bp.location.range.start.character\n                    });\n                }\n                else if (bp instanceof extHostTypes_1.FunctionBreakpoint) {\n                    dtos.push({\n                        type: 'function',\n                        id: bp.id,\n                        enabled: bp.enabled,\n                        hitCondition: bp.hitCondition,\n                        logMessage: bp.logMessage,\n                        condition: bp.condition,\n                        functionName: bp.functionName\n                    });\n                }\n            }\n            // send DTOs to VS Code\n            return this._debugServiceProxy.$registerBreakpoints(dtos);\n        }\n        removeBreakpoints(breakpoints0) {\n            this.startBreakpoints();\n            // remove from array\n            const breakpoints = breakpoints0.filter(b => this._breakpoints.delete(b.id));\n            // send notification\n            this.fireBreakpointChanges([], breakpoints, []);\n            // unregister with VS Code\n            const ids = breakpoints.filter(bp => bp instanceof extHostTypes_1.SourceBreakpoint).map(bp => bp.id);\n            const fids = breakpoints.filter(bp => bp instanceof extHostTypes_1.FunctionBreakpoint).map(bp => bp.id);\n            return this._debugServiceProxy.$unregisterBreakpoints(ids, fids);\n        }\n        startDebugging(folder, nameOrConfig, parentSession) {\n            return this._debugServiceProxy.$startDebugging(folder ? folder.uri : undefined, nameOrConfig, parentSession ? parentSession.id : undefined);\n        }\n        registerDebugConfigurationProvider(type, provider) {\n            if (!provider) {\n                return new extHostTypes_1.Disposable(() => { });\n            }\n            if (provider.debugAdapterExecutable) {\n                console.error('DebugConfigurationProvider.debugAdapterExecutable is deprecated and will be removed soon; please use DebugAdapterDescriptorFactory.createDebugAdapterDescriptor instead.');\n            }\n            const handle = this._configProviderHandleCounter++;\n            this._configProviders.push({ type, handle, provider });\n            this._debugServiceProxy.$registerDebugConfigurationProvider(type, !!provider.provideDebugConfigurations, !!provider.resolveDebugConfiguration, !!provider.debugAdapterExecutable, // TODO@AW: deprecated\n            handle);\n            return new extHostTypes_1.Disposable(() => {\n                this._configProviders = this._configProviders.filter(p => p.provider !== provider); // remove\n                this._debugServiceProxy.$unregisterDebugConfigurationProvider(handle);\n            });\n        }\n        registerDebugAdapterDescriptorFactory(extension, type, factory) {\n            if (!factory) {\n                return new extHostTypes_1.Disposable(() => { });\n            }\n            // a DebugAdapterDescriptorFactory can only be registered in the extension that contributes the debugger\n            if (!this.definesDebugType(extension, type)) {\n                throw new Error(`a DebugAdapterDescriptorFactory can only be registered from the extension that defines the '${type}' debugger.`);\n            }\n            // make sure that only one factory for this type is registered\n            if (this.getAdapterFactoryByType(type)) {\n                throw new Error(`a DebugAdapterDescriptorFactory can only be registered once per a type.`);\n            }\n            const handle = this._adapterFactoryHandleCounter++;\n            this._adapterFactories.push({ type, handle, factory });\n            this._debugServiceProxy.$registerDebugAdapterDescriptorFactory(type, handle);\n            return new extHostTypes_1.Disposable(() => {\n                this._adapterFactories = this._adapterFactories.filter(p => p.factory !== factory); // remove\n                this._debugServiceProxy.$unregisterDebugAdapterDescriptorFactory(handle);\n            });\n        }\n        registerDebugAdapterTrackerFactory(type, factory) {\n            if (!factory) {\n                return new extHostTypes_1.Disposable(() => { });\n            }\n            const handle = this._trackerFactoryHandleCounter++;\n            this._trackerFactories.push({ type, handle, factory });\n            this._debugServiceProxy.$registerDebugAdapterTrackerFactory(type, handle);\n            return new extHostTypes_1.Disposable(() => {\n                this._trackerFactories = this._trackerFactories.filter(p => p.factory !== factory); // remove\n                this._debugServiceProxy.$unregisterDebugAdapterTrackerFactory(handle);\n            });\n        }\n        // RPC methods (ExtHostDebugServiceShape)\n        $runInTerminal(args, config) {\n            if (args.kind === 'integrated') {\n                if (!this._terminalDisposedListener) {\n                    // React on terminal disposed and check if that is the debug terminal #12956\n                    this._terminalDisposedListener = this._terminalService.onDidCloseTerminal(terminal => {\n                        if (this._integratedTerminalInstance && this._integratedTerminalInstance === terminal) {\n                            this._integratedTerminalInstance = undefined;\n                        }\n                    });\n                }\n                return new Promise(resolve => {\n                    if (this._integratedTerminalInstance) {\n                        this._integratedTerminalInstance.processId.then(pid => {\n                            resolve(terminals_1.hasChildProcesses(pid));\n                        }, err => {\n                            resolve(true);\n                        });\n                    }\n                    else {\n                        resolve(true);\n                    }\n                }).then(needNewTerminal => {\n                    if (needNewTerminal || !this._integratedTerminalInstance) {\n                        this._integratedTerminalInstance = this._terminalService.createTerminal(args.title || nls.localize('debug.terminal.title', \"debuggee\"));\n                    }\n                    const terminal = this._integratedTerminalInstance;\n                    terminal.show();\n                    return this._integratedTerminalInstance.processId.then(shellProcessId => {\n                        const command = terminals_1.prepareCommand(args, config);\n                        terminal.sendText(command, true);\n                        return shellProcessId;\n                    });\n                });\n            }\n            else if (args.kind === 'external') {\n                const terminalLauncher = terminals_1.getTerminalLauncher();\n                if (terminalLauncher) {\n                    return terminalLauncher.runInTerminal(args, config);\n                }\n            }\n            return Promise.resolve(undefined);\n        }\n        $substituteVariables(folderUri, config) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!this._variableResolver) {\n                    const [workspaceFolders, configProvider] = yield Promise.all([this._workspaceService.getWorkspaceFolders2(), this._configurationService.getConfigProvider()]);\n                    this._variableResolver = new ExtHostVariableResolverService(workspaceFolders || [], this._editorsService, configProvider);\n                }\n                let ws;\n                const folder = yield this.getFolder(folderUri);\n                if (folder) {\n                    ws = {\n                        uri: folder.uri,\n                        name: folder.name,\n                        index: folder.index,\n                        toResource: () => {\n                            throw new Error('Not implemented');\n                        }\n                    };\n                }\n                return this._variableResolver.resolveAny(ws, config);\n            });\n        }\n        $startDASession(debugAdapterHandle, sessionDto) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const mythis = this;\n                const session = yield this.getSession(sessionDto);\n                return this.getAdapterDescriptor(this.getAdapterFactoryByType(session.type), session).then(daDescriptor => {\n                    const adapter = this.convertToDto(daDescriptor);\n                    let da = undefined;\n                    switch (adapter.type) {\n                        case 'server':\n                            da = new debugAdapter_1.SocketDebugAdapter(adapter);\n                            break;\n                        case 'executable':\n                            da = new debugAdapter_1.ExecutableDebugAdapter(adapter, session.type);\n                            break;\n                        case 'implementation':\n                            da = new DirectDebugAdapter(adapter.implementation);\n                            break;\n                        default:\n                            break;\n                    }\n                    const debugAdapter = da;\n                    if (debugAdapter) {\n                        this._debugAdapters.set(debugAdapterHandle, debugAdapter);\n                        return this.getDebugAdapterTrackers(session).then(tracker => {\n                            if (tracker) {\n                                this._debugAdaptersTrackers.set(debugAdapterHandle, tracker);\n                            }\n                            debugAdapter.onMessage(message => {\n                                if (tracker && tracker.onDidSendMessage) {\n                                    tracker.onDidSendMessage(message);\n                                }\n                                // DA -> VS Code\n                                message = debugUtils_1.convertToVSCPaths(message, true);\n                                mythis._debugServiceProxy.$acceptDAMessage(debugAdapterHandle, message);\n                            });\n                            debugAdapter.onError(err => {\n                                if (tracker && tracker.onError) {\n                                    tracker.onError(err);\n                                }\n                                this._debugServiceProxy.$acceptDAError(debugAdapterHandle, err.name, err.message, err.stack);\n                            });\n                            debugAdapter.onExit((code) => {\n                                if (tracker && tracker.onExit) {\n                                    tracker.onExit(code, undefined);\n                                }\n                                this._debugServiceProxy.$acceptDAExit(debugAdapterHandle, code, undefined);\n                            });\n                            if (tracker && tracker.onWillStartSession) {\n                                tracker.onWillStartSession();\n                            }\n                            return debugAdapter.startSession();\n                        });\n                    }\n                    return undefined;\n                });\n            });\n        }\n        $sendDAMessage(debugAdapterHandle, message) {\n            // VS Code -> DA\n            message = debugUtils_1.convertToDAPaths(message, false);\n            const tracker = this._debugAdaptersTrackers.get(debugAdapterHandle); // TODO@AW: same handle?\n            if (tracker && tracker.onWillReceiveMessage) {\n                tracker.onWillReceiveMessage(message);\n            }\n            const da = this._debugAdapters.get(debugAdapterHandle);\n            if (da) {\n                da.sendMessage(message);\n            }\n        }\n        $stopDASession(debugAdapterHandle) {\n            const tracker = this._debugAdaptersTrackers.get(debugAdapterHandle);\n            this._debugAdaptersTrackers.delete(debugAdapterHandle);\n            if (tracker && tracker.onWillStopSession) {\n                tracker.onWillStopSession();\n            }\n            const da = this._debugAdapters.get(debugAdapterHandle);\n            this._debugAdapters.delete(debugAdapterHandle);\n            if (da) {\n                return da.stopSession();\n            }\n            else {\n                return Promise.resolve(void 0);\n            }\n        }\n        $acceptBreakpointsDelta(delta) {\n            const a = [];\n            const r = [];\n            const c = [];\n            if (delta.added) {\n                for (const bpd of delta.added) {\n                    const id = bpd.id;\n                    if (id && !this._breakpoints.has(id)) {\n                        let bp;\n                        if (bpd.type === 'function') {\n                            bp = new extHostTypes_1.FunctionBreakpoint(bpd.functionName, bpd.enabled, bpd.condition, bpd.hitCondition, bpd.logMessage);\n                        }\n                        else {\n                            const uri = uri_1.URI.revive(bpd.uri);\n                            bp = new extHostTypes_1.SourceBreakpoint(new extHostTypes_1.Location(uri, new extHostTypes_1.Position(bpd.line, bpd.character)), bpd.enabled, bpd.condition, bpd.hitCondition, bpd.logMessage);\n                        }\n                        bp._id = id;\n                        this._breakpoints.set(id, bp);\n                        a.push(bp);\n                    }\n                }\n            }\n            if (delta.removed) {\n                for (const id of delta.removed) {\n                    const bp = this._breakpoints.get(id);\n                    if (bp) {\n                        this._breakpoints.delete(id);\n                        r.push(bp);\n                    }\n                }\n            }\n            if (delta.changed) {\n                for (const bpd of delta.changed) {\n                    if (bpd.id) {\n                        const bp = this._breakpoints.get(bpd.id);\n                        if (bp) {\n                            if (bp instanceof extHostTypes_1.FunctionBreakpoint && bpd.type === 'function') {\n                                const fbp = bp;\n                                fbp.enabled = bpd.enabled;\n                                fbp.condition = bpd.condition;\n                                fbp.hitCondition = bpd.hitCondition;\n                                fbp.logMessage = bpd.logMessage;\n                                fbp.functionName = bpd.functionName;\n                            }\n                            else if (bp instanceof extHostTypes_1.SourceBreakpoint && bpd.type === 'source') {\n                                const sbp = bp;\n                                sbp.enabled = bpd.enabled;\n                                sbp.condition = bpd.condition;\n                                sbp.hitCondition = bpd.hitCondition;\n                                sbp.logMessage = bpd.logMessage;\n                                sbp.location = new extHostTypes_1.Location(uri_1.URI.revive(bpd.uri), new extHostTypes_1.Position(bpd.line, bpd.character));\n                            }\n                            c.push(bp);\n                        }\n                    }\n                }\n            }\n            this.fireBreakpointChanges(a, r, c);\n        }\n        $provideDebugConfigurations(configProviderHandle, folderUri) {\n            return async_1.asPromise(() => __awaiter(this, void 0, void 0, function* () {\n                const provider = this.getConfigProviderByHandle(configProviderHandle);\n                if (!provider) {\n                    throw new Error('no DebugConfigurationProvider found');\n                }\n                if (!provider.provideDebugConfigurations) {\n                    throw new Error('DebugConfigurationProvider has no method provideDebugConfigurations');\n                }\n                const folder = yield this.getFolder(folderUri);\n                return provider.provideDebugConfigurations(folder, cancellation_1.CancellationToken.None);\n            })).then(debugConfigurations => {\n                if (!debugConfigurations) {\n                    throw new Error('nothing returned from DebugConfigurationProvider.provideDebugConfigurations');\n                }\n                return debugConfigurations;\n            });\n        }\n        $resolveDebugConfiguration(configProviderHandle, folderUri, debugConfiguration) {\n            return async_1.asPromise(() => __awaiter(this, void 0, void 0, function* () {\n                const provider = this.getConfigProviderByHandle(configProviderHandle);\n                if (!provider) {\n                    throw new Error('no DebugConfigurationProvider found');\n                }\n                if (!provider.resolveDebugConfiguration) {\n                    throw new Error('DebugConfigurationProvider has no method resolveDebugConfiguration');\n                }\n                const folder = yield this.getFolder(folderUri);\n                return provider.resolveDebugConfiguration(folder, debugConfiguration, cancellation_1.CancellationToken.None);\n            }));\n        }\n        // TODO@AW deprecated and legacy\n        $legacyDebugAdapterExecutable(configProviderHandle, folderUri) {\n            return async_1.asPromise(() => __awaiter(this, void 0, void 0, function* () {\n                const provider = this.getConfigProviderByHandle(configProviderHandle);\n                if (!provider) {\n                    throw new Error('no DebugConfigurationProvider found');\n                }\n                if (!provider.debugAdapterExecutable) {\n                    throw new Error('DebugConfigurationProvider has no method debugAdapterExecutable');\n                }\n                const folder = yield this.getFolder(folderUri);\n                return provider.debugAdapterExecutable(folder, cancellation_1.CancellationToken.None);\n            })).then(executable => {\n                if (!executable) {\n                    throw new Error('nothing returned from DebugConfigurationProvider.debugAdapterExecutable');\n                }\n                return this.convertToDto(executable);\n            });\n        }\n        $provideDebugAdapter(adapterProviderHandle, sessionDto) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const adapterProvider = this.getAdapterProviderByHandle(adapterProviderHandle);\n                if (!adapterProvider) {\n                    return Promise.reject(new Error('no handler found'));\n                }\n                const session = yield this.getSession(sessionDto);\n                return this.getAdapterDescriptor(adapterProvider, session).then(x => this.convertToDto(x));\n            });\n        }\n        $acceptDebugSessionStarted(sessionDto) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const session = yield this.getSession(sessionDto);\n                this._onDidStartDebugSession.fire(session);\n            });\n        }\n        $acceptDebugSessionTerminated(sessionDto) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const session = yield this.getSession(sessionDto);\n                if (session) {\n                    this._onDidTerminateDebugSession.fire(session);\n                    this._debugSessions.delete(session.id);\n                }\n            });\n        }\n        $acceptDebugSessionActiveChanged(sessionDto) {\n            return __awaiter(this, void 0, void 0, function* () {\n                this._activeDebugSession = sessionDto ? yield this.getSession(sessionDto) : undefined;\n                this._onDidChangeActiveDebugSession.fire(this._activeDebugSession);\n            });\n        }\n        $acceptDebugSessionCustomEvent(sessionDto, event) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const session = yield this.getSession(sessionDto);\n                const ee = {\n                    session: session,\n                    event: event.event,\n                    body: event.body\n                };\n                this._onDidReceiveDebugSessionCustomEvent.fire(ee);\n            });\n        }\n        // private & dto helpers\n        convertToDto(x) {\n            if (x instanceof extHostTypes_1.DebugAdapterExecutable) {\n                return {\n                    type: 'executable',\n                    command: x.command,\n                    args: x.args,\n                    options: x.options\n                };\n            }\n            else if (x instanceof extHostTypes_1.DebugAdapterServer) {\n                return {\n                    type: 'server',\n                    port: x.port,\n                    host: x.host\n                };\n            }\n            else /* if (x instanceof DebugAdapterImplementation) {\n                return <IDebugAdapterImplementation>{\n                    type: 'implementation',\n                    implementation: x.implementation\n                };\n            } else */ {\n                throw new Error('convertToDto unexpected type');\n            }\n        }\n        getAdapterFactoryByType(type) {\n            const results = this._adapterFactories.filter(p => p.type === type);\n            if (results.length > 0) {\n                return results[0].factory;\n            }\n            return undefined;\n        }\n        getAdapterProviderByHandle(handle) {\n            const results = this._adapterFactories.filter(p => p.handle === handle);\n            if (results.length > 0) {\n                return results[0].factory;\n            }\n            return undefined;\n        }\n        getConfigProviderByHandle(handle) {\n            const results = this._configProviders.filter(p => p.handle === handle);\n            if (results.length > 0) {\n                return results[0].provider;\n            }\n            return undefined;\n        }\n        definesDebugType(ed, type) {\n            if (ed.contributes) {\n                const debuggers = ed.contributes['debuggers'];\n                if (debuggers && debuggers.length > 0) {\n                    for (const dbg of debuggers) {\n                        // only debugger contributions with a \"label\" are considered a \"defining\" debugger contribution\n                        if (dbg.label && dbg.type) {\n                            if (dbg.type === type) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n        getDebugAdapterTrackers(session) {\n            const config = session.configuration;\n            const type = config.type;\n            const promises = this._trackerFactories\n                .filter(tuple => tuple.type === type || tuple.type === '*')\n                .map(tuple => async_1.asPromise(() => tuple.factory.createDebugAdapterTracker(session)).then(p => p, err => null));\n            return Promise.race([\n                Promise.all(promises).then(result => {\n                    const trackers = result.filter(t => !!t); // filter null\n                    if (trackers.length > 0) {\n                        return new MultiTracker(trackers);\n                    }\n                    return undefined;\n                }),\n                new Promise((resolve, reject) => {\n                    const timeout = setTimeout(() => {\n                        clearTimeout(timeout);\n                        reject(new Error('timeout'));\n                    }, 1000);\n                })\n            ]).catch(err => {\n                // ignore errors\n                return undefined;\n            });\n        }\n        getAdapterDescriptor(adapterProvider, session) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // a \"debugServer\" attribute in the launch config takes precedence\n                const serverPort = session.configuration.debugServer;\n                if (typeof serverPort === 'number') {\n                    return Promise.resolve(new extHostTypes_1.DebugAdapterServer(serverPort));\n                }\n                // TODO@AW legacy\n                const pair = this._configProviders.filter(p => p.type === session.type).pop();\n                if (pair && pair.provider.debugAdapterExecutable) {\n                    const func = pair.provider.debugAdapterExecutable;\n                    return async_1.asPromise(() => func(session.workspaceFolder, cancellation_1.CancellationToken.None)).then(executable => {\n                        if (executable) {\n                            return executable;\n                        }\n                        return undefined;\n                    });\n                }\n                if (adapterProvider) {\n                    const extensionRegistry = yield this._extensionService.getExtensionRegistry();\n                    return async_1.asPromise(() => adapterProvider.createDebugAdapterDescriptor(session, this.daExecutableFromPackage(session, extensionRegistry))).then(daDescriptor => {\n                        if (daDescriptor) {\n                            return daDescriptor;\n                        }\n                        return undefined;\n                    });\n                }\n                // try deprecated command based extension API \"adapterExecutableCommand\" to determine the executable\n                // TODO@AW legacy\n                const aex = this._aexCommands.get(session.type);\n                if (aex) {\n                    const folder = session.workspaceFolder;\n                    const rootFolder = folder ? folder.uri.toString() : undefined;\n                    return this._commandService.executeCommand(aex, rootFolder).then((ae) => {\n                        return new extHostTypes_1.DebugAdapterExecutable(ae.command, ae.args || []);\n                    });\n                }\n                // fallback: use executable information from package.json\n                const extensionRegistry = yield this._extensionService.getExtensionRegistry();\n                return Promise.resolve(this.daExecutableFromPackage(session, extensionRegistry));\n            });\n        }\n        daExecutableFromPackage(session, extensionRegistry) {\n            const dae = debugAdapter_1.ExecutableDebugAdapter.platformAdapterExecutable(extensionRegistry.getAllExtensionDescriptions(), session.type);\n            if (dae) {\n                return new extHostTypes_1.DebugAdapterExecutable(dae.command, dae.args, dae.options);\n            }\n            return undefined;\n        }\n        startBreakpoints() {\n            if (!this._breakpointEventsActive) {\n                this._breakpointEventsActive = true;\n                this._debugServiceProxy.$startBreakpointEvents();\n            }\n        }\n        fireBreakpointChanges(added, removed, changed) {\n            if (added.length > 0 || removed.length > 0 || changed.length > 0) {\n                this._onDidChangeBreakpoints.fire(Object.freeze({\n                    added,\n                    removed,\n                    changed,\n                }));\n            }\n        }\n        getSession(dto) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (dto) {\n                    if (typeof dto === 'string') {\n                        const ds = this._debugSessions.get(dto);\n                        if (ds) {\n                            return ds;\n                        }\n                    }\n                    else {\n                        let ds = this._debugSessions.get(dto.id);\n                        if (!ds) {\n                            const folder = yield this.getFolder(dto.folderUri);\n                            ds = new ExtHostDebugSession(this._debugServiceProxy, dto.id, dto.type, dto.name, folder, dto.configuration);\n                            this._debugSessions.set(ds.id, ds);\n                            this._debugServiceProxy.$sessionCached(ds.id);\n                        }\n                        return ds;\n                    }\n                }\n                throw new Error('cannot find session');\n            });\n        }\n        getFolder(_folderUri) {\n            if (_folderUri) {\n                const folderURI = uri_1.URI.revive(_folderUri);\n                return this._workspaceService.resolveWorkspaceFolder(folderURI);\n            }\n            return Promise.resolve(undefined);\n        }\n    }\n    exports.ExtHostDebugService = ExtHostDebugService;\n    class ExtHostDebugSession {\n        constructor(_debugServiceProxy, _id, _type, _name, _workspaceFolder, _configuration) {\n            this._debugServiceProxy = _debugServiceProxy;\n            this._id = _id;\n            this._type = _type;\n            this._name = _name;\n            this._workspaceFolder = _workspaceFolder;\n            this._configuration = _configuration;\n        }\n        get id() {\n            return this._id;\n        }\n        get type() {\n            return this._type;\n        }\n        get name() {\n            return this._name;\n        }\n        get workspaceFolder() {\n            return this._workspaceFolder;\n        }\n        get configuration() {\n            return this._configuration;\n        }\n        customRequest(command, args) {\n            return this._debugServiceProxy.$customDebugAdapterRequest(this._id, command, args);\n        }\n    }\n    exports.ExtHostDebugSession = ExtHostDebugSession;\n    class ExtHostDebugConsole {\n        constructor(proxy) {\n            this._debugServiceProxy = proxy;\n        }\n        append(value) {\n            this._debugServiceProxy.$appendDebugConsole(value);\n        }\n        appendLine(value) {\n            this.append(value + '\\n');\n        }\n    }\n    exports.ExtHostDebugConsole = ExtHostDebugConsole;\n    class ExtHostVariableResolverService extends variableResolver_1.AbstractVariableResolverService {\n        constructor(folders, editorService, configurationService) {\n            super({\n                getFolderUri: (folderName) => {\n                    const found = folders.filter(f => f.name === folderName);\n                    if (found && found.length > 0) {\n                        return found[0].uri;\n                    }\n                    return undefined;\n                },\n                getWorkspaceFolderCount: () => {\n                    return folders.length;\n                },\n                getConfigurationValue: (folderUri, section) => {\n                    return configurationService.getConfiguration(undefined, folderUri).get(section);\n                },\n                getExecPath: () => {\n                    return process.env['VSCODE_EXEC_PATH'];\n                },\n                getFilePath: () => {\n                    const activeEditor = editorService.activeEditor();\n                    if (activeEditor) {\n                        const resource = activeEditor.document.uri;\n                        if (resource.scheme === network_1.Schemas.file) {\n                            return path.normalize(resource.fsPath);\n                        }\n                    }\n                    return undefined;\n                },\n                getSelectedText: () => {\n                    const activeEditor = editorService.activeEditor();\n                    if (activeEditor && !activeEditor.selection.isEmpty) {\n                        return activeEditor.document.getText(activeEditor.selection);\n                    }\n                    return undefined;\n                },\n                getLineNumber: () => {\n                    const activeEditor = editorService.activeEditor();\n                    if (activeEditor) {\n                        return String(activeEditor.selection.end.line + 1);\n                    }\n                    return undefined;\n                }\n            }, process.env);\n        }\n    }\n    exports.ExtHostVariableResolverService = ExtHostVariableResolverService;\n    class MultiTracker {\n        constructor(trackers) {\n            this.trackers = trackers;\n        }\n        onWillStartSession() {\n            this.trackers.forEach(t => t.onWillStartSession ? t.onWillStartSession() : undefined);\n        }\n        onWillReceiveMessage(message) {\n            this.trackers.forEach(t => t.onWillReceiveMessage ? t.onWillReceiveMessage(message) : undefined);\n        }\n        onDidSendMessage(message) {\n            this.trackers.forEach(t => t.onDidSendMessage ? t.onDidSendMessage(message) : undefined);\n        }\n        onWillStopSession() {\n            this.trackers.forEach(t => t.onWillStopSession ? t.onWillStopSession() : undefined);\n        }\n        onError(error) {\n            this.trackers.forEach(t => t.onError ? t.onError(error) : undefined);\n        }\n        onExit(code, signal) {\n            this.trackers.forEach(t => t.onExit ? t.onExit(code, signal) : undefined);\n        }\n    }\n    class DirectDebugAdapter extends abstractDebugAdapter_1.AbstractDebugAdapter {\n        constructor(implementation) {\n            super();\n            if (implementation.__setTransport) {\n                implementation.__setTransport(this);\n            }\n        }\n        // IDapTransport\n        start(cb, errorcb) {\n            this._sendUp = cb;\n        }\n        // AbstractDebugAdapter\n        startSession() {\n            return Promise.resolve(undefined);\n        }\n        // AbstractDebugAdapter\n        // VSCode -> DA\n        sendMessage(message) {\n            this._sendUp(message);\n        }\n        // AbstractDebugAdapter\n        stopSession() {\n            this.stop();\n            return Promise.resolve(undefined);\n        }\n        // IDapTransport\n        // DA -> VSCode\n        send(message) {\n            this.acceptMessage(message);\n        }\n        // IDapTransport\n        stop() {\n            throw new Error('Method not implemented.');\n        }\n    }\n});\n",null]}