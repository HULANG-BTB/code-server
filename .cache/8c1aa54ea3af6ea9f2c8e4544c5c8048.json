{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/keybinding/common/macLinuxKeyboardMapper.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/keybinding/common/macLinuxKeyboardMapper.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/charCode\", \"vs/base/common/keyCodes\", \"vs/base/common/platform\", \"vs/base/common/scanCode\", \"vs/platform/keybinding/common/baseResolvedKeybinding\"], function (require, exports, charCode_1, keyCodes_1, platform_1, scanCode_1, baseResolvedKeybinding_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function macLinuxKeyMappingEquals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        return (a.value === b.value\n            && a.withShift === b.withShift\n            && a.withAltGr === b.withAltGr\n            && a.withShiftAltGr === b.withShiftAltGr);\n    }\n    function macLinuxKeyboardMappingEquals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        for (let scanCode = 0; scanCode < scanCode_1.ScanCode.MAX_VALUE; scanCode++) {\n            const strScanCode = scanCode_1.ScanCodeUtils.toString(scanCode);\n            const aEntry = a[strScanCode];\n            const bEntry = b[strScanCode];\n            if (!macLinuxKeyMappingEquals(aEntry, bEntry)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    exports.macLinuxKeyboardMappingEquals = macLinuxKeyboardMappingEquals;\n    /**\n     * A map from character to key codes.\n     * e.g. Contains entries such as:\n     *  - '/' => { keyCode: KeyCode.US_SLASH, shiftKey: false }\n     *  - '?' => { keyCode: KeyCode.US_SLASH, shiftKey: true }\n     */\n    const CHAR_CODE_TO_KEY_CODE = [];\n    class NativeResolvedKeybinding extends baseResolvedKeybinding_1.BaseResolvedKeybinding {\n        constructor(mapper, os, parts) {\n            super(os, parts);\n            this._mapper = mapper;\n        }\n        _getLabel(keybinding) {\n            return this._mapper.getUILabelForScanCodeBinding(keybinding);\n        }\n        _getAriaLabel(keybinding) {\n            return this._mapper.getAriaLabelForScanCodeBinding(keybinding);\n        }\n        _getElectronAccelerator(keybinding) {\n            return this._mapper.getElectronAcceleratorLabelForScanCodeBinding(keybinding);\n        }\n        _getUserSettingsLabel(keybinding) {\n            return this._mapper.getUserSettingsLabelForScanCodeBinding(keybinding);\n        }\n        _isWYSIWYG(binding) {\n            if (!binding) {\n                return true;\n            }\n            if (scanCode_1.IMMUTABLE_CODE_TO_KEY_CODE[binding.scanCode] !== -1) {\n                return true;\n            }\n            let a = this._mapper.getAriaLabelForScanCodeBinding(binding);\n            let b = this._mapper.getUserSettingsLabelForScanCodeBinding(binding);\n            if (!a && !b) {\n                return true;\n            }\n            if (!a || !b) {\n                return false;\n            }\n            return (a.toLowerCase() === b.toLowerCase());\n        }\n        _getDispatchPart(keybinding) {\n            return this._mapper.getDispatchStrForScanCodeBinding(keybinding);\n        }\n    }\n    exports.NativeResolvedKeybinding = NativeResolvedKeybinding;\n    class ScanCodeCombo {\n        constructor(ctrlKey, shiftKey, altKey, scanCode) {\n            this.ctrlKey = ctrlKey;\n            this.shiftKey = shiftKey;\n            this.altKey = altKey;\n            this.scanCode = scanCode;\n        }\n        toString() {\n            return `${this.ctrlKey ? 'Ctrl+' : ''}${this.shiftKey ? 'Shift+' : ''}${this.altKey ? 'Alt+' : ''}${scanCode_1.ScanCodeUtils.toString(this.scanCode)}`;\n        }\n        equals(other) {\n            return (this.ctrlKey === other.ctrlKey\n                && this.shiftKey === other.shiftKey\n                && this.altKey === other.altKey\n                && this.scanCode === other.scanCode);\n        }\n        getProducedCharCode(mapping) {\n            if (!mapping) {\n                return '';\n            }\n            if (this.ctrlKey && this.shiftKey && this.altKey) {\n                return mapping.withShiftAltGr;\n            }\n            if (this.ctrlKey && this.altKey) {\n                return mapping.withAltGr;\n            }\n            if (this.shiftKey) {\n                return mapping.withShift;\n            }\n            return mapping.value;\n        }\n        getProducedChar(mapping) {\n            const charCode = MacLinuxKeyboardMapper.getCharCode(this.getProducedCharCode(mapping));\n            if (charCode === 0) {\n                return ' --- ';\n            }\n            if (charCode >= charCode_1.CharCode.U_Combining_Grave_Accent && charCode <= charCode_1.CharCode.U_Combining_Latin_Small_Letter_X) {\n                // combining\n                return 'U+' + charCode.toString(16);\n            }\n            return '  ' + String.fromCharCode(charCode) + '  ';\n        }\n    }\n    class KeyCodeCombo {\n        constructor(ctrlKey, shiftKey, altKey, keyCode) {\n            this.ctrlKey = ctrlKey;\n            this.shiftKey = shiftKey;\n            this.altKey = altKey;\n            this.keyCode = keyCode;\n        }\n        toString() {\n            return `${this.ctrlKey ? 'Ctrl+' : ''}${this.shiftKey ? 'Shift+' : ''}${this.altKey ? 'Alt+' : ''}${keyCodes_1.KeyCodeUtils.toString(this.keyCode)}`;\n        }\n    }\n    class ScanCodeKeyCodeMapper {\n        constructor() {\n            /**\n             * ScanCode combination => KeyCode combination.\n             * Only covers relevant modifiers ctrl, shift, alt (since meta does not influence the mappings).\n             */\n            this._scanCodeToKeyCode = [];\n            /**\n             * inverse of `_scanCodeToKeyCode`.\n             * KeyCode combination => ScanCode combination.\n             * Only covers relevant modifiers ctrl, shift, alt (since meta does not influence the mappings).\n             */\n            this._keyCodeToScanCode = [];\n            this._scanCodeToKeyCode = [];\n            this._keyCodeToScanCode = [];\n        }\n        registrationComplete() {\n            // IntlHash and IntlBackslash are rare keys, so ensure they don't end up being the preferred...\n            this._moveToEnd(scanCode_1.ScanCode.IntlHash);\n            this._moveToEnd(scanCode_1.ScanCode.IntlBackslash);\n        }\n        _moveToEnd(scanCode) {\n            for (let mod = 0; mod < 8; mod++) {\n                const encodedKeyCodeCombos = this._scanCodeToKeyCode[(scanCode << 3) + mod];\n                if (!encodedKeyCodeCombos) {\n                    continue;\n                }\n                for (let i = 0, len = encodedKeyCodeCombos.length; i < len; i++) {\n                    const encodedScanCodeCombos = this._keyCodeToScanCode[encodedKeyCodeCombos[i]];\n                    if (encodedScanCodeCombos.length === 1) {\n                        continue;\n                    }\n                    for (let j = 0, len = encodedScanCodeCombos.length; j < len; j++) {\n                        const entry = encodedScanCodeCombos[j];\n                        const entryScanCode = (entry >>> 3);\n                        if (entryScanCode === scanCode) {\n                            // Move this entry to the end\n                            for (let k = j + 1; k < len; k++) {\n                                encodedScanCodeCombos[k - 1] = encodedScanCodeCombos[k];\n                            }\n                            encodedScanCodeCombos[len - 1] = entry;\n                        }\n                    }\n                }\n            }\n        }\n        registerIfUnknown(scanCodeCombo, keyCodeCombo) {\n            if (keyCodeCombo.keyCode === keyCodes_1.KeyCode.Unknown) {\n                return;\n            }\n            const scanCodeComboEncoded = this._encodeScanCodeCombo(scanCodeCombo);\n            const keyCodeComboEncoded = this._encodeKeyCodeCombo(keyCodeCombo);\n            const keyCodeIsDigit = (keyCodeCombo.keyCode >= keyCodes_1.KeyCode.KEY_0 && keyCodeCombo.keyCode <= keyCodes_1.KeyCode.KEY_9);\n            const keyCodeIsLetter = (keyCodeCombo.keyCode >= keyCodes_1.KeyCode.KEY_A && keyCodeCombo.keyCode <= keyCodes_1.KeyCode.KEY_Z);\n            const existingKeyCodeCombos = this._scanCodeToKeyCode[scanCodeComboEncoded];\n            // Allow a scan code to map to multiple key codes if it is a digit or a letter key code\n            if (keyCodeIsDigit || keyCodeIsLetter) {\n                // Only check that we don't insert the same entry twice\n                if (existingKeyCodeCombos) {\n                    for (let i = 0, len = existingKeyCodeCombos.length; i < len; i++) {\n                        if (existingKeyCodeCombos[i] === keyCodeComboEncoded) {\n                            // avoid duplicates\n                            return;\n                        }\n                    }\n                }\n            }\n            else {\n                // Don't allow multiples\n                if (existingKeyCodeCombos && existingKeyCodeCombos.length !== 0) {\n                    return;\n                }\n            }\n            this._scanCodeToKeyCode[scanCodeComboEncoded] = this._scanCodeToKeyCode[scanCodeComboEncoded] || [];\n            this._scanCodeToKeyCode[scanCodeComboEncoded].unshift(keyCodeComboEncoded);\n            this._keyCodeToScanCode[keyCodeComboEncoded] = this._keyCodeToScanCode[keyCodeComboEncoded] || [];\n            this._keyCodeToScanCode[keyCodeComboEncoded].unshift(scanCodeComboEncoded);\n        }\n        lookupKeyCodeCombo(keyCodeCombo) {\n            const keyCodeComboEncoded = this._encodeKeyCodeCombo(keyCodeCombo);\n            const scanCodeCombosEncoded = this._keyCodeToScanCode[keyCodeComboEncoded];\n            if (!scanCodeCombosEncoded || scanCodeCombosEncoded.length === 0) {\n                return [];\n            }\n            let result = [];\n            for (let i = 0, len = scanCodeCombosEncoded.length; i < len; i++) {\n                const scanCodeComboEncoded = scanCodeCombosEncoded[i];\n                const ctrlKey = (scanCodeComboEncoded & 0b001) ? true : false;\n                const shiftKey = (scanCodeComboEncoded & 0b010) ? true : false;\n                const altKey = (scanCodeComboEncoded & 0b100) ? true : false;\n                const scanCode = (scanCodeComboEncoded >>> 3);\n                result[i] = new ScanCodeCombo(ctrlKey, shiftKey, altKey, scanCode);\n            }\n            return result;\n        }\n        lookupScanCodeCombo(scanCodeCombo) {\n            const scanCodeComboEncoded = this._encodeScanCodeCombo(scanCodeCombo);\n            const keyCodeCombosEncoded = this._scanCodeToKeyCode[scanCodeComboEncoded];\n            if (!keyCodeCombosEncoded || keyCodeCombosEncoded.length === 0) {\n                return [];\n            }\n            let result = [];\n            for (let i = 0, len = keyCodeCombosEncoded.length; i < len; i++) {\n                const keyCodeComboEncoded = keyCodeCombosEncoded[i];\n                const ctrlKey = (keyCodeComboEncoded & 0b001) ? true : false;\n                const shiftKey = (keyCodeComboEncoded & 0b010) ? true : false;\n                const altKey = (keyCodeComboEncoded & 0b100) ? true : false;\n                const keyCode = (keyCodeComboEncoded >>> 3);\n                result[i] = new KeyCodeCombo(ctrlKey, shiftKey, altKey, keyCode);\n            }\n            return result;\n        }\n        guessStableKeyCode(scanCode) {\n            if (scanCode >= scanCode_1.ScanCode.Digit1 && scanCode <= scanCode_1.ScanCode.Digit0) {\n                // digits are ok\n                switch (scanCode) {\n                    case scanCode_1.ScanCode.Digit1: return keyCodes_1.KeyCode.KEY_1;\n                    case scanCode_1.ScanCode.Digit2: return keyCodes_1.KeyCode.KEY_2;\n                    case scanCode_1.ScanCode.Digit3: return keyCodes_1.KeyCode.KEY_3;\n                    case scanCode_1.ScanCode.Digit4: return keyCodes_1.KeyCode.KEY_4;\n                    case scanCode_1.ScanCode.Digit5: return keyCodes_1.KeyCode.KEY_5;\n                    case scanCode_1.ScanCode.Digit6: return keyCodes_1.KeyCode.KEY_6;\n                    case scanCode_1.ScanCode.Digit7: return keyCodes_1.KeyCode.KEY_7;\n                    case scanCode_1.ScanCode.Digit8: return keyCodes_1.KeyCode.KEY_8;\n                    case scanCode_1.ScanCode.Digit9: return keyCodes_1.KeyCode.KEY_9;\n                    case scanCode_1.ScanCode.Digit0: return keyCodes_1.KeyCode.KEY_0;\n                }\n            }\n            // Lookup the scanCode with and without shift and see if the keyCode is stable\n            const keyCodeCombos1 = this.lookupScanCodeCombo(new ScanCodeCombo(false, false, false, scanCode));\n            const keyCodeCombos2 = this.lookupScanCodeCombo(new ScanCodeCombo(false, true, false, scanCode));\n            if (keyCodeCombos1.length === 1 && keyCodeCombos2.length === 1) {\n                const shiftKey1 = keyCodeCombos1[0].shiftKey;\n                const keyCode1 = keyCodeCombos1[0].keyCode;\n                const shiftKey2 = keyCodeCombos2[0].shiftKey;\n                const keyCode2 = keyCodeCombos2[0].keyCode;\n                if (keyCode1 === keyCode2 && shiftKey1 !== shiftKey2) {\n                    // This looks like a stable mapping\n                    return keyCode1;\n                }\n            }\n            return -1;\n        }\n        _encodeScanCodeCombo(scanCodeCombo) {\n            return this._encode(scanCodeCombo.ctrlKey, scanCodeCombo.shiftKey, scanCodeCombo.altKey, scanCodeCombo.scanCode);\n        }\n        _encodeKeyCodeCombo(keyCodeCombo) {\n            return this._encode(keyCodeCombo.ctrlKey, keyCodeCombo.shiftKey, keyCodeCombo.altKey, keyCodeCombo.keyCode);\n        }\n        _encode(ctrlKey, shiftKey, altKey, principal) {\n            return (((ctrlKey ? 1 : 0) << 0)\n                | ((shiftKey ? 1 : 0) << 1)\n                | ((altKey ? 1 : 0) << 2)\n                | principal << 3) >>> 0;\n        }\n    }\n    class MacLinuxKeyboardMapper {\n        constructor(isUSStandard, rawMappings, OS) {\n            /**\n             * UI label for a ScanCode.\n             */\n            this._scanCodeToLabel = [];\n            /**\n             * Dispatching string for a ScanCode.\n             */\n            this._scanCodeToDispatch = [];\n            this._isUSStandard = isUSStandard;\n            this._OS = OS;\n            this._codeInfo = [];\n            this._scanCodeKeyCodeMapper = new ScanCodeKeyCodeMapper();\n            this._scanCodeToLabel = [];\n            this._scanCodeToDispatch = [];\n            const _registerIfUnknown = (hwCtrlKey, hwShiftKey, hwAltKey, scanCode, kbCtrlKey, kbShiftKey, kbAltKey, keyCode) => {\n                this._scanCodeKeyCodeMapper.registerIfUnknown(new ScanCodeCombo(hwCtrlKey ? true : false, hwShiftKey ? true : false, hwAltKey ? true : false, scanCode), new KeyCodeCombo(kbCtrlKey ? true : false, kbShiftKey ? true : false, kbAltKey ? true : false, keyCode));\n            };\n            const _registerAllCombos = (_ctrlKey, _shiftKey, _altKey, scanCode, keyCode) => {\n                for (let ctrlKey = _ctrlKey; ctrlKey <= 1; ctrlKey++) {\n                    for (let shiftKey = _shiftKey; shiftKey <= 1; shiftKey++) {\n                        for (let altKey = _altKey; altKey <= 1; altKey++) {\n                            _registerIfUnknown(ctrlKey, shiftKey, altKey, scanCode, ctrlKey, shiftKey, altKey, keyCode);\n                        }\n                    }\n                }\n            };\n            // Initialize `_scanCodeToLabel`\n            for (let scanCode = scanCode_1.ScanCode.None; scanCode < scanCode_1.ScanCode.MAX_VALUE; scanCode++) {\n                this._scanCodeToLabel[scanCode] = null;\n            }\n            // Initialize `_scanCodeToDispatch`\n            for (let scanCode = scanCode_1.ScanCode.None; scanCode < scanCode_1.ScanCode.MAX_VALUE; scanCode++) {\n                this._scanCodeToDispatch[scanCode] = null;\n            }\n            // Handle immutable mappings\n            for (let scanCode = scanCode_1.ScanCode.None; scanCode < scanCode_1.ScanCode.MAX_VALUE; scanCode++) {\n                const keyCode = scanCode_1.IMMUTABLE_CODE_TO_KEY_CODE[scanCode];\n                if (keyCode !== -1) {\n                    _registerAllCombos(0, 0, 0, scanCode, keyCode);\n                    this._scanCodeToLabel[scanCode] = keyCodes_1.KeyCodeUtils.toString(keyCode);\n                    if (keyCode === keyCodes_1.KeyCode.Unknown || keyCode === keyCodes_1.KeyCode.Ctrl || keyCode === keyCodes_1.KeyCode.Meta || keyCode === keyCodes_1.KeyCode.Alt || keyCode === keyCodes_1.KeyCode.Shift) {\n                        this._scanCodeToDispatch[scanCode] = null; // cannot dispatch on this ScanCode\n                    }\n                    else {\n                        this._scanCodeToDispatch[scanCode] = `[${scanCode_1.ScanCodeUtils.toString(scanCode)}]`;\n                    }\n                }\n            }\n            // Try to identify keyboard layouts where characters A-Z are missing\n            // and forcefully map them to their corresponding scan codes if that is the case\n            const missingLatinLettersOverride = {};\n            {\n                let producesLatinLetter = [];\n                for (let strScanCode in rawMappings) {\n                    if (rawMappings.hasOwnProperty(strScanCode)) {\n                        const scanCode = scanCode_1.ScanCodeUtils.toEnum(strScanCode);\n                        if (scanCode === scanCode_1.ScanCode.None) {\n                            continue;\n                        }\n                        if (scanCode_1.IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== -1) {\n                            continue;\n                        }\n                        const rawMapping = rawMappings[strScanCode];\n                        const value = MacLinuxKeyboardMapper.getCharCode(rawMapping.value);\n                        if (value >= charCode_1.CharCode.a && value <= charCode_1.CharCode.z) {\n                            const upperCaseValue = charCode_1.CharCode.A + (value - charCode_1.CharCode.a);\n                            producesLatinLetter[upperCaseValue] = true;\n                        }\n                    }\n                }\n                const _registerLetterIfMissing = (charCode, scanCode, value, withShift) => {\n                    if (!producesLatinLetter[charCode]) {\n                        missingLatinLettersOverride[scanCode_1.ScanCodeUtils.toString(scanCode)] = {\n                            value: value,\n                            withShift: withShift,\n                            withAltGr: '',\n                            withShiftAltGr: ''\n                        };\n                    }\n                };\n                // Ensure letters are mapped\n                _registerLetterIfMissing(charCode_1.CharCode.A, scanCode_1.ScanCode.KeyA, 'a', 'A');\n                _registerLetterIfMissing(charCode_1.CharCode.B, scanCode_1.ScanCode.KeyB, 'b', 'B');\n                _registerLetterIfMissing(charCode_1.CharCode.C, scanCode_1.ScanCode.KeyC, 'c', 'C');\n                _registerLetterIfMissing(charCode_1.CharCode.D, scanCode_1.ScanCode.KeyD, 'd', 'D');\n                _registerLetterIfMissing(charCode_1.CharCode.E, scanCode_1.ScanCode.KeyE, 'e', 'E');\n                _registerLetterIfMissing(charCode_1.CharCode.F, scanCode_1.ScanCode.KeyF, 'f', 'F');\n                _registerLetterIfMissing(charCode_1.CharCode.G, scanCode_1.ScanCode.KeyG, 'g', 'G');\n                _registerLetterIfMissing(charCode_1.CharCode.H, scanCode_1.ScanCode.KeyH, 'h', 'H');\n                _registerLetterIfMissing(charCode_1.CharCode.I, scanCode_1.ScanCode.KeyI, 'i', 'I');\n                _registerLetterIfMissing(charCode_1.CharCode.J, scanCode_1.ScanCode.KeyJ, 'j', 'J');\n                _registerLetterIfMissing(charCode_1.CharCode.K, scanCode_1.ScanCode.KeyK, 'k', 'K');\n                _registerLetterIfMissing(charCode_1.CharCode.L, scanCode_1.ScanCode.KeyL, 'l', 'L');\n                _registerLetterIfMissing(charCode_1.CharCode.M, scanCode_1.ScanCode.KeyM, 'm', 'M');\n                _registerLetterIfMissing(charCode_1.CharCode.N, scanCode_1.ScanCode.KeyN, 'n', 'N');\n                _registerLetterIfMissing(charCode_1.CharCode.O, scanCode_1.ScanCode.KeyO, 'o', 'O');\n                _registerLetterIfMissing(charCode_1.CharCode.P, scanCode_1.ScanCode.KeyP, 'p', 'P');\n                _registerLetterIfMissing(charCode_1.CharCode.Q, scanCode_1.ScanCode.KeyQ, 'q', 'Q');\n                _registerLetterIfMissing(charCode_1.CharCode.R, scanCode_1.ScanCode.KeyR, 'r', 'R');\n                _registerLetterIfMissing(charCode_1.CharCode.S, scanCode_1.ScanCode.KeyS, 's', 'S');\n                _registerLetterIfMissing(charCode_1.CharCode.T, scanCode_1.ScanCode.KeyT, 't', 'T');\n                _registerLetterIfMissing(charCode_1.CharCode.U, scanCode_1.ScanCode.KeyU, 'u', 'U');\n                _registerLetterIfMissing(charCode_1.CharCode.V, scanCode_1.ScanCode.KeyV, 'v', 'V');\n                _registerLetterIfMissing(charCode_1.CharCode.W, scanCode_1.ScanCode.KeyW, 'w', 'W');\n                _registerLetterIfMissing(charCode_1.CharCode.X, scanCode_1.ScanCode.KeyX, 'x', 'X');\n                _registerLetterIfMissing(charCode_1.CharCode.Y, scanCode_1.ScanCode.KeyY, 'y', 'Y');\n                _registerLetterIfMissing(charCode_1.CharCode.Z, scanCode_1.ScanCode.KeyZ, 'z', 'Z');\n            }\n            let mappings = [], mappingsLen = 0;\n            for (let strScanCode in rawMappings) {\n                if (rawMappings.hasOwnProperty(strScanCode)) {\n                    const scanCode = scanCode_1.ScanCodeUtils.toEnum(strScanCode);\n                    if (scanCode === scanCode_1.ScanCode.None) {\n                        continue;\n                    }\n                    if (scanCode_1.IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== -1) {\n                        continue;\n                    }\n                    this._codeInfo[scanCode] = rawMappings[strScanCode];\n                    const rawMapping = missingLatinLettersOverride[strScanCode] || rawMappings[strScanCode];\n                    const value = MacLinuxKeyboardMapper.getCharCode(rawMapping.value);\n                    const withShift = MacLinuxKeyboardMapper.getCharCode(rawMapping.withShift);\n                    const withAltGr = MacLinuxKeyboardMapper.getCharCode(rawMapping.withAltGr);\n                    const withShiftAltGr = MacLinuxKeyboardMapper.getCharCode(rawMapping.withShiftAltGr);\n                    const mapping = {\n                        scanCode: scanCode,\n                        value: value,\n                        withShift: withShift,\n                        withAltGr: withAltGr,\n                        withShiftAltGr: withShiftAltGr,\n                    };\n                    mappings[mappingsLen++] = mapping;\n                    this._scanCodeToDispatch[scanCode] = `[${scanCode_1.ScanCodeUtils.toString(scanCode)}]`;\n                    if (value >= charCode_1.CharCode.a && value <= charCode_1.CharCode.z) {\n                        const upperCaseValue = charCode_1.CharCode.A + (value - charCode_1.CharCode.a);\n                        this._scanCodeToLabel[scanCode] = String.fromCharCode(upperCaseValue);\n                    }\n                    else if (value >= charCode_1.CharCode.A && value <= charCode_1.CharCode.Z) {\n                        this._scanCodeToLabel[scanCode] = String.fromCharCode(value);\n                    }\n                    else if (value) {\n                        this._scanCodeToLabel[scanCode] = String.fromCharCode(value);\n                    }\n                    else {\n                        this._scanCodeToLabel[scanCode] = null;\n                    }\n                }\n            }\n            // Handle all `withShiftAltGr` entries\n            for (let i = mappings.length - 1; i >= 0; i--) {\n                const mapping = mappings[i];\n                const scanCode = mapping.scanCode;\n                const withShiftAltGr = mapping.withShiftAltGr;\n                if (withShiftAltGr === mapping.withAltGr || withShiftAltGr === mapping.withShift || withShiftAltGr === mapping.value) {\n                    // handled below\n                    continue;\n                }\n                const kb = MacLinuxKeyboardMapper._charCodeToKb(withShiftAltGr);\n                if (!kb) {\n                    continue;\n                }\n                const kbShiftKey = kb.shiftKey;\n                const keyCode = kb.keyCode;\n                if (kbShiftKey) {\n                    // Ctrl+Shift+Alt+ScanCode => Shift+KeyCode\n                    _registerIfUnknown(1, 1, 1, scanCode, 0, 1, 0, keyCode); //       Ctrl+Alt+ScanCode =>          Shift+KeyCode\n                }\n                else {\n                    // Ctrl+Shift+Alt+ScanCode => KeyCode\n                    _registerIfUnknown(1, 1, 1, scanCode, 0, 0, 0, keyCode); //       Ctrl+Alt+ScanCode =>                KeyCode\n                }\n            }\n            // Handle all `withAltGr` entries\n            for (let i = mappings.length - 1; i >= 0; i--) {\n                const mapping = mappings[i];\n                const scanCode = mapping.scanCode;\n                const withAltGr = mapping.withAltGr;\n                if (withAltGr === mapping.withShift || withAltGr === mapping.value) {\n                    // handled below\n                    continue;\n                }\n                const kb = MacLinuxKeyboardMapper._charCodeToKb(withAltGr);\n                if (!kb) {\n                    continue;\n                }\n                const kbShiftKey = kb.shiftKey;\n                const keyCode = kb.keyCode;\n                if (kbShiftKey) {\n                    // Ctrl+Alt+ScanCode => Shift+KeyCode\n                    _registerIfUnknown(1, 0, 1, scanCode, 0, 1, 0, keyCode); //       Ctrl+Alt+ScanCode =>          Shift+KeyCode\n                }\n                else {\n                    // Ctrl+Alt+ScanCode => KeyCode\n                    _registerIfUnknown(1, 0, 1, scanCode, 0, 0, 0, keyCode); //       Ctrl+Alt+ScanCode =>                KeyCode\n                }\n            }\n            // Handle all `withShift` entries\n            for (let i = mappings.length - 1; i >= 0; i--) {\n                const mapping = mappings[i];\n                const scanCode = mapping.scanCode;\n                const withShift = mapping.withShift;\n                if (withShift === mapping.value) {\n                    // handled below\n                    continue;\n                }\n                const kb = MacLinuxKeyboardMapper._charCodeToKb(withShift);\n                if (!kb) {\n                    continue;\n                }\n                const kbShiftKey = kb.shiftKey;\n                const keyCode = kb.keyCode;\n                if (kbShiftKey) {\n                    // Shift+ScanCode => Shift+KeyCode\n                    _registerIfUnknown(0, 1, 0, scanCode, 0, 1, 0, keyCode); //          Shift+ScanCode =>          Shift+KeyCode\n                    _registerIfUnknown(0, 1, 1, scanCode, 0, 1, 1, keyCode); //      Shift+Alt+ScanCode =>      Shift+Alt+KeyCode\n                    _registerIfUnknown(1, 1, 0, scanCode, 1, 1, 0, keyCode); //     Ctrl+Shift+ScanCode =>     Ctrl+Shift+KeyCode\n                    _registerIfUnknown(1, 1, 1, scanCode, 1, 1, 1, keyCode); // Ctrl+Shift+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n                }\n                else {\n                    // Shift+ScanCode => KeyCode\n                    _registerIfUnknown(0, 1, 0, scanCode, 0, 0, 0, keyCode); //          Shift+ScanCode =>                KeyCode\n                    _registerIfUnknown(0, 1, 0, scanCode, 0, 1, 0, keyCode); //          Shift+ScanCode =>          Shift+KeyCode\n                    _registerIfUnknown(0, 1, 1, scanCode, 0, 0, 1, keyCode); //      Shift+Alt+ScanCode =>            Alt+KeyCode\n                    _registerIfUnknown(0, 1, 1, scanCode, 0, 1, 1, keyCode); //      Shift+Alt+ScanCode =>      Shift+Alt+KeyCode\n                    _registerIfUnknown(1, 1, 0, scanCode, 1, 0, 0, keyCode); //     Ctrl+Shift+ScanCode =>           Ctrl+KeyCode\n                    _registerIfUnknown(1, 1, 0, scanCode, 1, 1, 0, keyCode); //     Ctrl+Shift+ScanCode =>     Ctrl+Shift+KeyCode\n                    _registerIfUnknown(1, 1, 1, scanCode, 1, 0, 1, keyCode); // Ctrl+Shift+Alt+ScanCode =>       Ctrl+Alt+KeyCode\n                    _registerIfUnknown(1, 1, 1, scanCode, 1, 1, 1, keyCode); // Ctrl+Shift+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n                }\n            }\n            // Handle all `value` entries\n            for (let i = mappings.length - 1; i >= 0; i--) {\n                const mapping = mappings[i];\n                const scanCode = mapping.scanCode;\n                const kb = MacLinuxKeyboardMapper._charCodeToKb(mapping.value);\n                if (!kb) {\n                    continue;\n                }\n                const kbShiftKey = kb.shiftKey;\n                const keyCode = kb.keyCode;\n                if (kbShiftKey) {\n                    // ScanCode => Shift+KeyCode\n                    _registerIfUnknown(0, 0, 0, scanCode, 0, 1, 0, keyCode); //                ScanCode =>          Shift+KeyCode\n                    _registerIfUnknown(0, 0, 1, scanCode, 0, 1, 1, keyCode); //            Alt+ScanCode =>      Shift+Alt+KeyCode\n                    _registerIfUnknown(1, 0, 0, scanCode, 1, 1, 0, keyCode); //           Ctrl+ScanCode =>     Ctrl+Shift+KeyCode\n                    _registerIfUnknown(1, 0, 1, scanCode, 1, 1, 1, keyCode); //       Ctrl+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n                }\n                else {\n                    // ScanCode => KeyCode\n                    _registerIfUnknown(0, 0, 0, scanCode, 0, 0, 0, keyCode); //                ScanCode =>                KeyCode\n                    _registerIfUnknown(0, 0, 1, scanCode, 0, 0, 1, keyCode); //            Alt+ScanCode =>            Alt+KeyCode\n                    _registerIfUnknown(0, 1, 0, scanCode, 0, 1, 0, keyCode); //          Shift+ScanCode =>          Shift+KeyCode\n                    _registerIfUnknown(0, 1, 1, scanCode, 0, 1, 1, keyCode); //      Shift+Alt+ScanCode =>      Shift+Alt+KeyCode\n                    _registerIfUnknown(1, 0, 0, scanCode, 1, 0, 0, keyCode); //           Ctrl+ScanCode =>           Ctrl+KeyCode\n                    _registerIfUnknown(1, 0, 1, scanCode, 1, 0, 1, keyCode); //       Ctrl+Alt+ScanCode =>       Ctrl+Alt+KeyCode\n                    _registerIfUnknown(1, 1, 0, scanCode, 1, 1, 0, keyCode); //     Ctrl+Shift+ScanCode =>     Ctrl+Shift+KeyCode\n                    _registerIfUnknown(1, 1, 1, scanCode, 1, 1, 1, keyCode); // Ctrl+Shift+Alt+ScanCode => Ctrl+Shift+Alt+KeyCode\n                }\n            }\n            // Handle all left-over available digits\n            _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit1, keyCodes_1.KeyCode.KEY_1);\n            _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit2, keyCodes_1.KeyCode.KEY_2);\n            _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit3, keyCodes_1.KeyCode.KEY_3);\n            _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit4, keyCodes_1.KeyCode.KEY_4);\n            _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit5, keyCodes_1.KeyCode.KEY_5);\n            _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit6, keyCodes_1.KeyCode.KEY_6);\n            _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit7, keyCodes_1.KeyCode.KEY_7);\n            _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit8, keyCodes_1.KeyCode.KEY_8);\n            _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit9, keyCodes_1.KeyCode.KEY_9);\n            _registerAllCombos(0, 0, 0, scanCode_1.ScanCode.Digit0, keyCodes_1.KeyCode.KEY_0);\n            this._scanCodeKeyCodeMapper.registrationComplete();\n        }\n        dumpDebugInfo() {\n            let result = [];\n            let immutableSamples = [\n                scanCode_1.ScanCode.ArrowUp,\n                scanCode_1.ScanCode.Numpad0\n            ];\n            let cnt = 0;\n            result.push(`isUSStandard: ${this._isUSStandard}`);\n            result.push(`----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------`);\n            for (let scanCode = scanCode_1.ScanCode.None; scanCode < scanCode_1.ScanCode.MAX_VALUE; scanCode++) {\n                if (scanCode_1.IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== -1) {\n                    if (immutableSamples.indexOf(scanCode) === -1) {\n                        continue;\n                    }\n                }\n                if (cnt % 4 === 0) {\n                    result.push(`|       HW Code combination      |  Key  |    KeyCode combination    | Pri |          UI label         |         User settings          |    Electron accelerator   |       Dispatching string       | WYSIWYG |`);\n                    result.push(`----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------`);\n                }\n                cnt++;\n                const mapping = this._codeInfo[scanCode];\n                for (let mod = 0; mod < 8; mod++) {\n                    const hwCtrlKey = (mod & 0b001) ? true : false;\n                    const hwShiftKey = (mod & 0b010) ? true : false;\n                    const hwAltKey = (mod & 0b100) ? true : false;\n                    const scanCodeCombo = new ScanCodeCombo(hwCtrlKey, hwShiftKey, hwAltKey, scanCode);\n                    const resolvedKb = this.resolveKeyboardEvent({\n                        _standardKeyboardEventBrand: true,\n                        ctrlKey: scanCodeCombo.ctrlKey,\n                        shiftKey: scanCodeCombo.shiftKey,\n                        altKey: scanCodeCombo.altKey,\n                        metaKey: false,\n                        keyCode: -1,\n                        code: scanCode_1.ScanCodeUtils.toString(scanCode)\n                    });\n                    const outScanCodeCombo = scanCodeCombo.toString();\n                    const outKey = scanCodeCombo.getProducedChar(mapping);\n                    const ariaLabel = resolvedKb.getAriaLabel();\n                    const outUILabel = (ariaLabel ? ariaLabel.replace(/Control\\+/, 'Ctrl+') : null);\n                    const outUserSettings = resolvedKb.getUserSettingsLabel();\n                    const outElectronAccelerator = resolvedKb.getElectronAccelerator();\n                    const outDispatchStr = resolvedKb.getDispatchParts()[0];\n                    const isWYSIWYG = (resolvedKb ? resolvedKb.isWYSIWYG() : false);\n                    const outWYSIWYG = (isWYSIWYG ? '       ' : '   NO  ');\n                    const kbCombos = this._scanCodeKeyCodeMapper.lookupScanCodeCombo(scanCodeCombo);\n                    if (kbCombos.length === 0) {\n                        result.push(`| ${this._leftPad(outScanCodeCombo, 30)} | ${outKey} | ${this._leftPad('', 25)} | ${this._leftPad('', 3)} | ${this._leftPad(outUILabel, 25)} | ${this._leftPad(outUserSettings, 30)} | ${this._leftPad(outElectronAccelerator, 25)} | ${this._leftPad(outDispatchStr, 30)} | ${outWYSIWYG} |`);\n                    }\n                    else {\n                        for (let i = 0, len = kbCombos.length; i < len; i++) {\n                            const kbCombo = kbCombos[i];\n                            // find out the priority of this scan code for this key code\n                            let colPriority;\n                            const scanCodeCombos = this._scanCodeKeyCodeMapper.lookupKeyCodeCombo(kbCombo);\n                            if (scanCodeCombos.length === 1) {\n                                // no need for priority, this key code combo maps to precisely this scan code combo\n                                colPriority = '';\n                            }\n                            else {\n                                let priority = -1;\n                                for (let j = 0; j < scanCodeCombos.length; j++) {\n                                    if (scanCodeCombos[j].equals(scanCodeCombo)) {\n                                        priority = j + 1;\n                                        break;\n                                    }\n                                }\n                                colPriority = String(priority);\n                            }\n                            const outKeybinding = kbCombo.toString();\n                            if (i === 0) {\n                                result.push(`| ${this._leftPad(outScanCodeCombo, 30)} | ${outKey} | ${this._leftPad(outKeybinding, 25)} | ${this._leftPad(colPriority, 3)} | ${this._leftPad(outUILabel, 25)} | ${this._leftPad(outUserSettings, 30)} | ${this._leftPad(outElectronAccelerator, 25)} | ${this._leftPad(outDispatchStr, 30)} | ${outWYSIWYG} |`);\n                            }\n                            else {\n                                // secondary keybindings\n                                result.push(`| ${this._leftPad('', 30)} |       | ${this._leftPad(outKeybinding, 25)} | ${this._leftPad(colPriority, 3)} | ${this._leftPad('', 25)} | ${this._leftPad('', 30)} | ${this._leftPad('', 25)} | ${this._leftPad('', 30)} |         |`);\n                            }\n                        }\n                    }\n                }\n                result.push(`----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------`);\n            }\n            return result.join('\\n');\n        }\n        _leftPad(str, cnt) {\n            if (str === null) {\n                str = 'null';\n            }\n            while (str.length < cnt) {\n                str = ' ' + str;\n            }\n            return str;\n        }\n        simpleKeybindingToScanCodeBinding(keybinding) {\n            // Avoid double Enter bindings (both ScanCode.NumpadEnter and ScanCode.Enter point to KeyCode.Enter)\n            if (keybinding.keyCode === keyCodes_1.KeyCode.Enter) {\n                return [new scanCode_1.ScanCodeBinding(keybinding.ctrlKey, keybinding.shiftKey, keybinding.altKey, keybinding.metaKey, scanCode_1.ScanCode.Enter)];\n            }\n            const scanCodeCombos = this._scanCodeKeyCodeMapper.lookupKeyCodeCombo(new KeyCodeCombo(keybinding.ctrlKey, keybinding.shiftKey, keybinding.altKey, keybinding.keyCode));\n            let result = [];\n            for (let i = 0, len = scanCodeCombos.length; i < len; i++) {\n                const scanCodeCombo = scanCodeCombos[i];\n                result[i] = new scanCode_1.ScanCodeBinding(scanCodeCombo.ctrlKey, scanCodeCombo.shiftKey, scanCodeCombo.altKey, keybinding.metaKey, scanCodeCombo.scanCode);\n            }\n            return result;\n        }\n        getUILabelForScanCodeBinding(binding) {\n            if (!binding) {\n                return null;\n            }\n            if (binding.isDuplicateModifierCase()) {\n                return '';\n            }\n            if (this._OS === platform_1.OperatingSystem.Macintosh) {\n                switch (binding.scanCode) {\n                    case scanCode_1.ScanCode.ArrowLeft:\n                        return '←';\n                    case scanCode_1.ScanCode.ArrowUp:\n                        return '↑';\n                    case scanCode_1.ScanCode.ArrowRight:\n                        return '→';\n                    case scanCode_1.ScanCode.ArrowDown:\n                        return '↓';\n                }\n            }\n            return this._scanCodeToLabel[binding.scanCode];\n        }\n        getAriaLabelForScanCodeBinding(binding) {\n            if (!binding) {\n                return null;\n            }\n            if (binding.isDuplicateModifierCase()) {\n                return '';\n            }\n            return this._scanCodeToLabel[binding.scanCode];\n        }\n        getDispatchStrForScanCodeBinding(keypress) {\n            const codeDispatch = this._scanCodeToDispatch[keypress.scanCode];\n            if (!codeDispatch) {\n                return null;\n            }\n            let result = '';\n            if (keypress.ctrlKey) {\n                result += 'ctrl+';\n            }\n            if (keypress.shiftKey) {\n                result += 'shift+';\n            }\n            if (keypress.altKey) {\n                result += 'alt+';\n            }\n            if (keypress.metaKey) {\n                result += 'meta+';\n            }\n            result += codeDispatch;\n            return result;\n        }\n        getUserSettingsLabelForScanCodeBinding(binding) {\n            if (!binding) {\n                return null;\n            }\n            if (binding.isDuplicateModifierCase()) {\n                return '';\n            }\n            const immutableKeyCode = scanCode_1.IMMUTABLE_CODE_TO_KEY_CODE[binding.scanCode];\n            if (immutableKeyCode !== -1) {\n                return keyCodes_1.KeyCodeUtils.toUserSettingsUS(immutableKeyCode).toLowerCase();\n            }\n            // Check if this scanCode always maps to the same keyCode and back\n            let constantKeyCode = this._scanCodeKeyCodeMapper.guessStableKeyCode(binding.scanCode);\n            if (constantKeyCode !== -1) {\n                // Verify that this is a good key code that can be mapped back to the same scan code\n                let reverseBindings = this.simpleKeybindingToScanCodeBinding(new keyCodes_1.SimpleKeybinding(binding.ctrlKey, binding.shiftKey, binding.altKey, binding.metaKey, constantKeyCode));\n                for (let i = 0, len = reverseBindings.length; i < len; i++) {\n                    const reverseBinding = reverseBindings[i];\n                    if (reverseBinding.scanCode === binding.scanCode) {\n                        return keyCodes_1.KeyCodeUtils.toUserSettingsUS(constantKeyCode).toLowerCase();\n                    }\n                }\n            }\n            return this._scanCodeToDispatch[binding.scanCode];\n        }\n        _getElectronLabelForKeyCode(keyCode) {\n            if (keyCode >= keyCodes_1.KeyCode.NUMPAD_0 && keyCode <= keyCodes_1.KeyCode.NUMPAD_DIVIDE) {\n                // Electron cannot handle numpad keys\n                return null;\n            }\n            switch (keyCode) {\n                case keyCodes_1.KeyCode.UpArrow:\n                    return 'Up';\n                case keyCodes_1.KeyCode.DownArrow:\n                    return 'Down';\n                case keyCodes_1.KeyCode.LeftArrow:\n                    return 'Left';\n                case keyCodes_1.KeyCode.RightArrow:\n                    return 'Right';\n            }\n            // electron menus always do the correct rendering on Windows\n            return keyCodes_1.KeyCodeUtils.toString(keyCode);\n        }\n        getElectronAcceleratorLabelForScanCodeBinding(binding) {\n            if (!binding) {\n                return null;\n            }\n            if (binding.isDuplicateModifierCase()) {\n                return null;\n            }\n            const immutableKeyCode = scanCode_1.IMMUTABLE_CODE_TO_KEY_CODE[binding.scanCode];\n            if (immutableKeyCode !== -1) {\n                return this._getElectronLabelForKeyCode(immutableKeyCode);\n            }\n            // Check if this scanCode always maps to the same keyCode and back\n            const constantKeyCode = this._scanCodeKeyCodeMapper.guessStableKeyCode(binding.scanCode);\n            if (!this._isUSStandard) {\n                // Electron cannot handle these key codes on anything else than standard US\n                const isOEMKey = (constantKeyCode === keyCodes_1.KeyCode.US_SEMICOLON\n                    || constantKeyCode === keyCodes_1.KeyCode.US_EQUAL\n                    || constantKeyCode === keyCodes_1.KeyCode.US_COMMA\n                    || constantKeyCode === keyCodes_1.KeyCode.US_MINUS\n                    || constantKeyCode === keyCodes_1.KeyCode.US_DOT\n                    || constantKeyCode === keyCodes_1.KeyCode.US_SLASH\n                    || constantKeyCode === keyCodes_1.KeyCode.US_BACKTICK\n                    || constantKeyCode === keyCodes_1.KeyCode.US_OPEN_SQUARE_BRACKET\n                    || constantKeyCode === keyCodes_1.KeyCode.US_BACKSLASH\n                    || constantKeyCode === keyCodes_1.KeyCode.US_CLOSE_SQUARE_BRACKET);\n                if (isOEMKey) {\n                    return null;\n                }\n            }\n            if (constantKeyCode !== -1) {\n                return this._getElectronLabelForKeyCode(constantKeyCode);\n            }\n            return null;\n        }\n        resolveKeybinding(keybinding) {\n            let chordParts = [];\n            for (let part of keybinding.parts) {\n                chordParts.push(this.simpleKeybindingToScanCodeBinding(part));\n            }\n            return this._toResolvedKeybinding(chordParts);\n        }\n        _toResolvedKeybinding(chordParts) {\n            if (chordParts.length === 0) {\n                return [];\n            }\n            let result = [];\n            this._generateResolvedKeybindings(chordParts, 0, [], result);\n            return result;\n        }\n        _generateResolvedKeybindings(chordParts, currentIndex, previousParts, result) {\n            const chordPart = chordParts[currentIndex];\n            const isFinalIndex = currentIndex === chordParts.length - 1;\n            for (let i = 0, len = chordPart.length; i < len; i++) {\n                let chords = [...previousParts, chordPart[i]];\n                if (isFinalIndex) {\n                    result.push(new NativeResolvedKeybinding(this, this._OS, chords));\n                }\n                else {\n                    this._generateResolvedKeybindings(chordParts, currentIndex + 1, chords, result);\n                }\n            }\n        }\n        resolveKeyboardEvent(keyboardEvent) {\n            let code = scanCode_1.ScanCodeUtils.toEnum(keyboardEvent.code);\n            // Treat NumpadEnter as Enter\n            if (code === scanCode_1.ScanCode.NumpadEnter) {\n                code = scanCode_1.ScanCode.Enter;\n            }\n            const keyCode = keyboardEvent.keyCode;\n            if ((keyCode === keyCodes_1.KeyCode.LeftArrow)\n                || (keyCode === keyCodes_1.KeyCode.UpArrow)\n                || (keyCode === keyCodes_1.KeyCode.RightArrow)\n                || (keyCode === keyCodes_1.KeyCode.DownArrow)\n                || (keyCode === keyCodes_1.KeyCode.Delete)\n                || (keyCode === keyCodes_1.KeyCode.Insert)\n                || (keyCode === keyCodes_1.KeyCode.Home)\n                || (keyCode === keyCodes_1.KeyCode.End)\n                || (keyCode === keyCodes_1.KeyCode.PageDown)\n                || (keyCode === keyCodes_1.KeyCode.PageUp)) {\n                // \"Dispatch\" on keyCode for these key codes to workaround issues with remote desktoping software\n                // where the scan codes appear to be incorrect (see https://github.com/Microsoft/vscode/issues/24107)\n                const immutableScanCode = scanCode_1.IMMUTABLE_KEY_CODE_TO_CODE[keyCode];\n                if (immutableScanCode !== -1) {\n                    code = immutableScanCode;\n                }\n            }\n            else {\n                if ((code === scanCode_1.ScanCode.Numpad1)\n                    || (code === scanCode_1.ScanCode.Numpad2)\n                    || (code === scanCode_1.ScanCode.Numpad3)\n                    || (code === scanCode_1.ScanCode.Numpad4)\n                    || (code === scanCode_1.ScanCode.Numpad5)\n                    || (code === scanCode_1.ScanCode.Numpad6)\n                    || (code === scanCode_1.ScanCode.Numpad7)\n                    || (code === scanCode_1.ScanCode.Numpad8)\n                    || (code === scanCode_1.ScanCode.Numpad9)\n                    || (code === scanCode_1.ScanCode.Numpad0)\n                    || (code === scanCode_1.ScanCode.NumpadDecimal)) {\n                    // \"Dispatch\" on keyCode for all numpad keys in order for NumLock to work correctly\n                    if (keyCode >= 0) {\n                        const immutableScanCode = scanCode_1.IMMUTABLE_KEY_CODE_TO_CODE[keyCode];\n                        if (immutableScanCode !== -1) {\n                            code = immutableScanCode;\n                        }\n                    }\n                }\n            }\n            const keypress = new scanCode_1.ScanCodeBinding(keyboardEvent.ctrlKey, keyboardEvent.shiftKey, keyboardEvent.altKey, keyboardEvent.metaKey, code);\n            return new NativeResolvedKeybinding(this, this._OS, [keypress]);\n        }\n        _resolveSimpleUserBinding(binding) {\n            if (!binding) {\n                return [];\n            }\n            if (binding instanceof scanCode_1.ScanCodeBinding) {\n                return [binding];\n            }\n            return this.simpleKeybindingToScanCodeBinding(binding);\n        }\n        resolveUserBinding(input) {\n            const parts = input.map(keybinding => this._resolveSimpleUserBinding(keybinding));\n            return this._toResolvedKeybinding(parts);\n        }\n        static _charCodeToKb(charCode) {\n            if (charCode < CHAR_CODE_TO_KEY_CODE.length) {\n                return CHAR_CODE_TO_KEY_CODE[charCode];\n            }\n            return null;\n        }\n        /**\n         * Attempt to map a combining character to a regular one that renders the same way.\n         *\n         * To the brave person following me: Good Luck!\n         * https://www.compart.com/en/unicode/bidiclass/NSM\n         */\n        static getCharCode(char) {\n            if (char.length === 0) {\n                return 0;\n            }\n            const charCode = char.charCodeAt(0);\n            switch (charCode) {\n                case charCode_1.CharCode.U_Combining_Grave_Accent: return charCode_1.CharCode.U_GRAVE_ACCENT;\n                case charCode_1.CharCode.U_Combining_Acute_Accent: return charCode_1.CharCode.U_ACUTE_ACCENT;\n                case charCode_1.CharCode.U_Combining_Circumflex_Accent: return charCode_1.CharCode.U_CIRCUMFLEX;\n                case charCode_1.CharCode.U_Combining_Tilde: return charCode_1.CharCode.U_SMALL_TILDE;\n                case charCode_1.CharCode.U_Combining_Macron: return charCode_1.CharCode.U_MACRON;\n                case charCode_1.CharCode.U_Combining_Overline: return charCode_1.CharCode.U_OVERLINE;\n                case charCode_1.CharCode.U_Combining_Breve: return charCode_1.CharCode.U_BREVE;\n                case charCode_1.CharCode.U_Combining_Dot_Above: return charCode_1.CharCode.U_DOT_ABOVE;\n                case charCode_1.CharCode.U_Combining_Diaeresis: return charCode_1.CharCode.U_DIAERESIS;\n                case charCode_1.CharCode.U_Combining_Ring_Above: return charCode_1.CharCode.U_RING_ABOVE;\n                case charCode_1.CharCode.U_Combining_Double_Acute_Accent: return charCode_1.CharCode.U_DOUBLE_ACUTE_ACCENT;\n            }\n            return charCode;\n        }\n    }\n    exports.MacLinuxKeyboardMapper = MacLinuxKeyboardMapper;\n    (function () {\n        function define(charCode, keyCode, shiftKey) {\n            for (let i = CHAR_CODE_TO_KEY_CODE.length; i < charCode; i++) {\n                CHAR_CODE_TO_KEY_CODE[i] = null;\n            }\n            CHAR_CODE_TO_KEY_CODE[charCode] = { keyCode: keyCode, shiftKey: shiftKey };\n        }\n        for (let chCode = charCode_1.CharCode.A; chCode <= charCode_1.CharCode.Z; chCode++) {\n            define(chCode, keyCodes_1.KeyCode.KEY_A + (chCode - charCode_1.CharCode.A), true);\n        }\n        for (let chCode = charCode_1.CharCode.a; chCode <= charCode_1.CharCode.z; chCode++) {\n            define(chCode, keyCodes_1.KeyCode.KEY_A + (chCode - charCode_1.CharCode.a), false);\n        }\n        define(charCode_1.CharCode.Semicolon, keyCodes_1.KeyCode.US_SEMICOLON, false);\n        define(charCode_1.CharCode.Colon, keyCodes_1.KeyCode.US_SEMICOLON, true);\n        define(charCode_1.CharCode.Equals, keyCodes_1.KeyCode.US_EQUAL, false);\n        define(charCode_1.CharCode.Plus, keyCodes_1.KeyCode.US_EQUAL, true);\n        define(charCode_1.CharCode.Comma, keyCodes_1.KeyCode.US_COMMA, false);\n        define(charCode_1.CharCode.LessThan, keyCodes_1.KeyCode.US_COMMA, true);\n        define(charCode_1.CharCode.Dash, keyCodes_1.KeyCode.US_MINUS, false);\n        define(charCode_1.CharCode.Underline, keyCodes_1.KeyCode.US_MINUS, true);\n        define(charCode_1.CharCode.Period, keyCodes_1.KeyCode.US_DOT, false);\n        define(charCode_1.CharCode.GreaterThan, keyCodes_1.KeyCode.US_DOT, true);\n        define(charCode_1.CharCode.Slash, keyCodes_1.KeyCode.US_SLASH, false);\n        define(charCode_1.CharCode.QuestionMark, keyCodes_1.KeyCode.US_SLASH, true);\n        define(charCode_1.CharCode.BackTick, keyCodes_1.KeyCode.US_BACKTICK, false);\n        define(charCode_1.CharCode.Tilde, keyCodes_1.KeyCode.US_BACKTICK, true);\n        define(charCode_1.CharCode.OpenSquareBracket, keyCodes_1.KeyCode.US_OPEN_SQUARE_BRACKET, false);\n        define(charCode_1.CharCode.OpenCurlyBrace, keyCodes_1.KeyCode.US_OPEN_SQUARE_BRACKET, true);\n        define(charCode_1.CharCode.Backslash, keyCodes_1.KeyCode.US_BACKSLASH, false);\n        define(charCode_1.CharCode.Pipe, keyCodes_1.KeyCode.US_BACKSLASH, true);\n        define(charCode_1.CharCode.CloseSquareBracket, keyCodes_1.KeyCode.US_CLOSE_SQUARE_BRACKET, false);\n        define(charCode_1.CharCode.CloseCurlyBrace, keyCodes_1.KeyCode.US_CLOSE_SQUARE_BRACKET, true);\n        define(charCode_1.CharCode.SingleQuote, keyCodes_1.KeyCode.US_QUOTE, false);\n        define(charCode_1.CharCode.DoubleQuote, keyCodes_1.KeyCode.US_QUOTE, true);\n    })();\n});\n",null]}