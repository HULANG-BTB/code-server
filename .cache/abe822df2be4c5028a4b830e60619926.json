{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/gotoError/gotoError.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/gotoError/gotoError.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/event\", \"vs/base/common/keyCodes\", \"vs/base/common/lifecycle\", \"vs/platform/contextkey/common/contextkey\", \"vs/platform/markers/common/markers\", \"vs/editor/common/core/range\", \"vs/editor/browser/editorExtensions\", \"vs/platform/theme/common/themeService\", \"vs/editor/common/editorContextKeys\", \"vs/platform/keybinding/common/keybindingsRegistry\", \"./gotoErrorWidget\", \"vs/base/common/strings\", \"vs/base/common/arrays\", \"vs/editor/browser/services/codeEditorService\", \"vs/base/common/errors\", \"vs/platform/actions/common/actions\", \"vs/base/common/actions\", \"vs/platform/keybinding/common/keybinding\"], function (require, exports, nls, event_1, keyCodes_1, lifecycle_1, contextkey_1, markers_1, range_1, editorExtensions_1, themeService_1, editorContextKeys_1, keybindingsRegistry_1, gotoErrorWidget_1, strings_1, arrays_1, codeEditorService_1, errors_1, actions_1, actions_2, keybinding_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class MarkerModel {\n        constructor(editor, markers) {\n            this._editor = editor;\n            this._markers = [];\n            this._nextIdx = -1;\n            this._toUnbind = [];\n            this._ignoreSelectionChange = false;\n            this._onCurrentMarkerChanged = new event_1.Emitter();\n            this._onMarkerSetChanged = new event_1.Emitter();\n            this.setMarkers(markers);\n            // listen on editor\n            this._toUnbind.push(this._editor.onDidDispose(() => this.dispose()));\n            this._toUnbind.push(this._editor.onDidChangeCursorPosition(() => {\n                if (this._ignoreSelectionChange) {\n                    return;\n                }\n                if (this.currentMarker && this._editor.getPosition() && range_1.Range.containsPosition(this.currentMarker, this._editor.getPosition())) {\n                    return;\n                }\n                this._nextIdx = -1;\n            }));\n        }\n        get onCurrentMarkerChanged() {\n            return this._onCurrentMarkerChanged.event;\n        }\n        get onMarkerSetChanged() {\n            return this._onMarkerSetChanged.event;\n        }\n        setMarkers(markers) {\n            let oldMarker = this._nextIdx >= 0 ? this._markers[this._nextIdx] : undefined;\n            this._markers = markers || [];\n            this._markers.sort(MarkerNavigationAction.compareMarker);\n            if (!oldMarker) {\n                this._nextIdx = -1;\n            }\n            else {\n                this._nextIdx = Math.max(-1, arrays_1.binarySearch(this._markers, oldMarker, MarkerNavigationAction.compareMarker));\n            }\n            this._onMarkerSetChanged.fire(this);\n        }\n        withoutWatchingEditorPosition(callback) {\n            this._ignoreSelectionChange = true;\n            try {\n                callback();\n            }\n            finally {\n                this._ignoreSelectionChange = false;\n            }\n        }\n        _initIdx(fwd) {\n            let found = false;\n            const position = this._editor.getPosition();\n            for (let i = 0; i < this._markers.length; i++) {\n                let range = range_1.Range.lift(this._markers[i]);\n                if (range.isEmpty() && this._editor.getModel()) {\n                    const word = this._editor.getModel().getWordAtPosition(range.getStartPosition());\n                    if (word) {\n                        range = new range_1.Range(range.startLineNumber, word.startColumn, range.startLineNumber, word.endColumn);\n                    }\n                }\n                if (position && (range.containsPosition(position) || position.isBeforeOrEqual(range.getStartPosition()))) {\n                    this._nextIdx = i;\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                // after the last change\n                this._nextIdx = fwd ? 0 : this._markers.length - 1;\n            }\n            if (this._nextIdx < 0) {\n                this._nextIdx = this._markers.length - 1;\n            }\n        }\n        get currentMarker() {\n            return this.canNavigate() ? this._markers[this._nextIdx] : undefined;\n        }\n        set currentMarker(marker) {\n            const idx = this._nextIdx;\n            this._nextIdx = -1;\n            if (marker) {\n                this._nextIdx = this.indexOf(marker);\n            }\n            if (this._nextIdx !== idx) {\n                this._onCurrentMarkerChanged.fire(marker);\n            }\n        }\n        move(fwd, inCircles) {\n            if (!this.canNavigate()) {\n                this._onCurrentMarkerChanged.fire(undefined);\n                return !inCircles;\n            }\n            let oldIdx = this._nextIdx;\n            let atEdge = false;\n            if (this._nextIdx === -1) {\n                this._initIdx(fwd);\n            }\n            else if (fwd) {\n                if (inCircles || this._nextIdx + 1 < this._markers.length) {\n                    this._nextIdx = (this._nextIdx + 1) % this._markers.length;\n                }\n                else {\n                    atEdge = true;\n                }\n            }\n            else if (!fwd) {\n                if (inCircles || this._nextIdx > 0) {\n                    this._nextIdx = (this._nextIdx - 1 + this._markers.length) % this._markers.length;\n                }\n                else {\n                    atEdge = true;\n                }\n            }\n            if (oldIdx !== this._nextIdx) {\n                const marker = this._markers[this._nextIdx];\n                this._onCurrentMarkerChanged.fire(marker);\n            }\n            return atEdge;\n        }\n        canNavigate() {\n            return this._markers.length > 0;\n        }\n        findMarkerAtPosition(pos) {\n            for (const marker of this._markers) {\n                if (range_1.Range.containsPosition(marker, pos)) {\n                    return marker;\n                }\n            }\n            return undefined;\n        }\n        get total() {\n            return this._markers.length;\n        }\n        indexOf(marker) {\n            return 1 + this._markers.indexOf(marker);\n        }\n        dispose() {\n            this._toUnbind = lifecycle_1.dispose(this._toUnbind);\n        }\n    }\n    let MarkerController = class MarkerController {\n        constructor(editor, _markerService, _contextKeyService, _themeService, _editorService, _keybindingService) {\n            this._markerService = _markerService;\n            this._contextKeyService = _contextKeyService;\n            this._themeService = _themeService;\n            this._editorService = _editorService;\n            this._keybindingService = _keybindingService;\n            this._model = null;\n            this._widget = null;\n            this._disposeOnClose = [];\n            this._editor = editor;\n            this._widgetVisible = CONTEXT_MARKERS_NAVIGATION_VISIBLE.bindTo(this._contextKeyService);\n        }\n        static get(editor) {\n            return editor.getContribution(MarkerController.ID);\n        }\n        getId() {\n            return MarkerController.ID;\n        }\n        dispose() {\n            this._cleanUp();\n        }\n        _cleanUp() {\n            this._widgetVisible.reset();\n            this._disposeOnClose = lifecycle_1.dispose(this._disposeOnClose);\n            this._widget = null;\n            this._model = null;\n        }\n        getOrCreateModel() {\n            if (this._model) {\n                return this._model;\n            }\n            const markers = this._getMarkers();\n            this._model = new MarkerModel(this._editor, markers);\n            this._markerService.onMarkerChanged(this._onMarkerChanged, this, this._disposeOnClose);\n            const prevMarkerKeybinding = this._keybindingService.lookupKeybinding(PrevMarkerAction.ID);\n            const nextMarkerKeybinding = this._keybindingService.lookupKeybinding(NextMarkerAction.ID);\n            const actions = [\n                new actions_2.Action(PrevMarkerAction.ID, PrevMarkerAction.LABEL + (prevMarkerKeybinding ? ` (${prevMarkerKeybinding.getLabel()})` : ''), 'show-previous-problem chevron-up', this._model.canNavigate(), () => __awaiter(this, void 0, void 0, function* () { if (this._model) {\n                    this._model.move(false, true);\n                } })),\n                new actions_2.Action(NextMarkerAction.ID, NextMarkerAction.LABEL + (nextMarkerKeybinding ? ` (${nextMarkerKeybinding.getLabel()})` : ''), 'show-next-problem chevron-down', this._model.canNavigate(), () => __awaiter(this, void 0, void 0, function* () { if (this._model) {\n                    this._model.move(true, true);\n                } }))\n            ];\n            this._widget = new gotoErrorWidget_1.MarkerNavigationWidget(this._editor, actions, this._themeService);\n            this._widgetVisible.set(true);\n            this._widget.onDidClose(() => this._cleanUp(), this, this._disposeOnClose);\n            this._disposeOnClose.push(this._model);\n            this._disposeOnClose.push(this._widget);\n            this._disposeOnClose.push(...actions);\n            this._disposeOnClose.push(this._widget.onDidSelectRelatedInformation(related => {\n                this._editorService.openCodeEditor({\n                    resource: related.resource,\n                    options: { pinned: true, revealIfOpened: true, selection: range_1.Range.lift(related).collapseToStart() }\n                }, this._editor).then(undefined, errors_1.onUnexpectedError);\n                this.closeMarkersNavigation(false);\n            }));\n            this._disposeOnClose.push(this._editor.onDidChangeModel(() => this._cleanUp()));\n            this._disposeOnClose.push(this._model.onCurrentMarkerChanged(marker => {\n                if (!marker || !this._model) {\n                    this._cleanUp();\n                }\n                else {\n                    this._model.withoutWatchingEditorPosition(() => {\n                        if (!this._widget || !this._model) {\n                            return;\n                        }\n                        this._widget.showAtMarker(marker, this._model.indexOf(marker), this._model.total);\n                    });\n                }\n            }));\n            this._disposeOnClose.push(this._model.onMarkerSetChanged(() => {\n                if (!this._widget || !this._widget.position || !this._model) {\n                    return;\n                }\n                const marker = this._model.findMarkerAtPosition(this._widget.position);\n                if (marker) {\n                    this._widget.updateMarker(marker);\n                }\n                else {\n                    this._widget.showStale();\n                }\n            }));\n            return this._model;\n        }\n        closeMarkersNavigation(focusEditor = true) {\n            this._cleanUp();\n            if (focusEditor) {\n                this._editor.focus();\n            }\n        }\n        show(marker) {\n            const model = this.getOrCreateModel();\n            model.currentMarker = marker;\n        }\n        _onMarkerChanged(changedResources) {\n            let editorModel = this._editor.getModel();\n            if (!editorModel) {\n                return;\n            }\n            if (!this._model) {\n                return;\n            }\n            if (!changedResources.some(r => editorModel.uri.toString() === r.toString())) {\n                return;\n            }\n            this._model.setMarkers(this._getMarkers());\n        }\n        _getMarkers() {\n            let model = this._editor.getModel();\n            if (!model) {\n                return [];\n            }\n            return this._markerService.read({\n                resource: model.uri,\n                severities: markers_1.MarkerSeverity.Error | markers_1.MarkerSeverity.Warning | markers_1.MarkerSeverity.Info\n            });\n        }\n    };\n    MarkerController.ID = 'editor.contrib.markerController';\n    MarkerController = __decorate([\n        __param(1, markers_1.IMarkerService),\n        __param(2, contextkey_1.IContextKeyService),\n        __param(3, themeService_1.IThemeService),\n        __param(4, codeEditorService_1.ICodeEditorService),\n        __param(5, keybinding_1.IKeybindingService)\n    ], MarkerController);\n    exports.MarkerController = MarkerController;\n    class MarkerNavigationAction extends editorExtensions_1.EditorAction {\n        constructor(next, multiFile, opts) {\n            super(opts);\n            this._isNext = next;\n            this._multiFile = multiFile;\n        }\n        run(accessor, editor) {\n            const markerService = accessor.get(markers_1.IMarkerService);\n            const editorService = accessor.get(codeEditorService_1.ICodeEditorService);\n            const controller = MarkerController.get(editor);\n            if (!controller) {\n                return Promise.resolve(undefined);\n            }\n            const model = controller.getOrCreateModel();\n            const atEdge = model.move(this._isNext, !this._multiFile);\n            if (!atEdge || !this._multiFile) {\n                return Promise.resolve(undefined);\n            }\n            // try with the next/prev file\n            let markers = markerService.read({ severities: markers_1.MarkerSeverity.Error | markers_1.MarkerSeverity.Warning | markers_1.MarkerSeverity.Info }).sort(MarkerNavigationAction.compareMarker);\n            if (markers.length === 0) {\n                return Promise.resolve(undefined);\n            }\n            let editorModel = editor.getModel();\n            if (!editorModel) {\n                return Promise.resolve(undefined);\n            }\n            let oldMarker = model.currentMarker || { resource: editorModel.uri, severity: markers_1.MarkerSeverity.Error, startLineNumber: 1, startColumn: 1, endLineNumber: 1, endColumn: 1 };\n            let idx = arrays_1.binarySearch(markers, oldMarker, MarkerNavigationAction.compareMarker);\n            if (idx < 0) {\n                // find best match...\n                idx = ~idx;\n                idx %= markers.length;\n            }\n            else if (this._isNext) {\n                idx = (idx + 1) % markers.length;\n            }\n            else {\n                idx = (idx + markers.length - 1) % markers.length;\n            }\n            let newMarker = markers[idx];\n            if (newMarker.resource.toString() === editorModel.uri.toString()) {\n                // the next `resource` is this resource which\n                // means we cycle within this file\n                model.move(this._isNext, true);\n                return Promise.resolve(undefined);\n            }\n            // close the widget for this editor-instance, open the resource\n            // for the next marker and re-start marker navigation in there\n            controller.closeMarkersNavigation();\n            return editorService.openCodeEditor({\n                resource: newMarker.resource,\n                options: { pinned: false, revealIfOpened: true, revealInCenterIfOutsideViewport: true, selection: newMarker }\n            }, editor).then(editor => {\n                if (!editor) {\n                    return undefined;\n                }\n                return editor.getAction(this.id).run();\n            });\n        }\n        static compareMarker(a, b) {\n            let res = strings_1.compare(a.resource.toString(), b.resource.toString());\n            if (res === 0) {\n                res = markers_1.MarkerSeverity.compare(a.severity, b.severity);\n            }\n            if (res === 0) {\n                res = range_1.Range.compareRangesUsingStarts(a, b);\n            }\n            return res;\n        }\n    }\n    class NextMarkerAction extends MarkerNavigationAction {\n        constructor() {\n            super(true, false, {\n                id: NextMarkerAction.ID,\n                label: NextMarkerAction.LABEL,\n                alias: 'Go to Next Error or Warning',\n                precondition: editorContextKeys_1.EditorContextKeys.writable,\n                kbOpts: { kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus, primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.F8, weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib }\n            });\n        }\n    }\n    NextMarkerAction.ID = 'editor.action.marker.next';\n    NextMarkerAction.LABEL = nls.localize('markerAction.next.label', \"Go to Next Problem (Error, Warning, Info)\");\n    exports.NextMarkerAction = NextMarkerAction;\n    class PrevMarkerAction extends MarkerNavigationAction {\n        constructor() {\n            super(false, false, {\n                id: PrevMarkerAction.ID,\n                label: PrevMarkerAction.LABEL,\n                alias: 'Go to Previous Error or Warning',\n                precondition: editorContextKeys_1.EditorContextKeys.writable,\n                kbOpts: { kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus, primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.F8, weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib }\n            });\n        }\n    }\n    PrevMarkerAction.ID = 'editor.action.marker.prev';\n    PrevMarkerAction.LABEL = nls.localize('markerAction.previous.label', \"Go to Previous Problem (Error, Warning, Info)\");\n    class NextMarkerInFilesAction extends MarkerNavigationAction {\n        constructor() {\n            super(true, true, {\n                id: 'editor.action.marker.nextInFiles',\n                label: nls.localize('markerAction.nextInFiles.label', \"Go to Next Problem in Files (Error, Warning, Info)\"),\n                alias: 'Go to Next Error or Warning in Files',\n                precondition: editorContextKeys_1.EditorContextKeys.writable,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.focus,\n                    primary: keyCodes_1.KeyCode.F8,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n    }\n    class PrevMarkerInFilesAction extends MarkerNavigationAction {\n        constructor() {\n            super(false, true, {\n                id: 'editor.action.marker.prevInFiles',\n                label: nls.localize('markerAction.previousInFiles.label', \"Go to Previous Problem in Files (Error, Warning, Info)\"),\n                alias: 'Go to Previous Error or Warning in Files',\n                precondition: editorContextKeys_1.EditorContextKeys.writable,\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.focus,\n                    primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.F8,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n    }\n    editorExtensions_1.registerEditorContribution(MarkerController);\n    editorExtensions_1.registerEditorAction(NextMarkerAction);\n    editorExtensions_1.registerEditorAction(PrevMarkerAction);\n    editorExtensions_1.registerEditorAction(NextMarkerInFilesAction);\n    editorExtensions_1.registerEditorAction(PrevMarkerInFilesAction);\n    const CONTEXT_MARKERS_NAVIGATION_VISIBLE = new contextkey_1.RawContextKey('markersNavigationVisible', false);\n    const MarkerCommand = editorExtensions_1.EditorCommand.bindToContribution(MarkerController.get);\n    editorExtensions_1.registerEditorCommand(new MarkerCommand({\n        id: 'closeMarkersNavigation',\n        precondition: CONTEXT_MARKERS_NAVIGATION_VISIBLE,\n        handler: x => x.closeMarkersNavigation(),\n        kbOpts: {\n            weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib + 50,\n            kbExpr: editorContextKeys_1.EditorContextKeys.focus,\n            primary: keyCodes_1.KeyCode.Escape,\n            secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape]\n        }\n    }));\n    // Go to menu\n    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.MenubarGoMenu, {\n        group: '6_problem_nav',\n        command: {\n            id: 'editor.action.marker.nextInFiles',\n            title: nls.localize({ key: 'miGotoNextProblem', comment: ['&& denotes a mnemonic'] }, \"Next &&Problem\")\n        },\n        order: 1\n    });\n    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.MenubarGoMenu, {\n        group: '6_problem_nav',\n        command: {\n            id: 'editor.action.marker.prevInFiles',\n            title: nls.localize({ key: 'miGotoPreviousProblem', comment: ['&& denotes a mnemonic'] }, \"Previous &&Problem\")\n        },\n        order: 2\n    });\n});\n",null]}