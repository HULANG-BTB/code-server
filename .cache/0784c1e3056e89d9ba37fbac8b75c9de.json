{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/hiddenRangeModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/hiddenRangeModel.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar event_1 = require(\"vs/base/common/event\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar arrays_1 = require(\"vs/base/common/arrays\");\nvar HiddenRangeModel = /** @class */ (function () {\n    function HiddenRangeModel(model) {\n        var _this = this;\n        this._updateEventEmitter = new event_1.Emitter();\n        this._foldingModel = model;\n        this._foldingModelListener = model.onDidChange(function (_) { return _this.updateHiddenRanges(); });\n        this._hiddenRanges = [];\n        if (model.regions.length) {\n            this.updateHiddenRanges();\n        }\n    }\n    Object.defineProperty(HiddenRangeModel.prototype, \"onDidChange\", {\n        get: function () { return this._updateEventEmitter.event; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HiddenRangeModel.prototype, \"hiddenRanges\", {\n        get: function () { return this._hiddenRanges; },\n        enumerable: true,\n        configurable: true\n    });\n    HiddenRangeModel.prototype.updateHiddenRanges = function () {\n        var updateHiddenAreas = false;\n        var newHiddenAreas = [];\n        var i = 0; // index into hidden\n        var k = 0;\n        var lastCollapsedStart = Number.MAX_VALUE;\n        var lastCollapsedEnd = -1;\n        var ranges = this._foldingModel.regions;\n        for (; i < ranges.length; i++) {\n            if (!ranges.isCollapsed(i)) {\n                continue;\n            }\n            var startLineNumber = ranges.getStartLineNumber(i) + 1; // the first line is not hidden\n            var endLineNumber = ranges.getEndLineNumber(i);\n            if (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) {\n                // ignore ranges contained in collapsed regions\n                continue;\n            }\n            if (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {\n                // reuse the old ranges\n                newHiddenAreas.push(this._hiddenRanges[k]);\n                k++;\n            }\n            else {\n                updateHiddenAreas = true;\n                newHiddenAreas.push(new range_1.Range(startLineNumber, 1, endLineNumber, 1));\n            }\n            lastCollapsedStart = startLineNumber;\n            lastCollapsedEnd = endLineNumber;\n        }\n        if (updateHiddenAreas || k < this._hiddenRanges.length) {\n            this.applyHiddenRanges(newHiddenAreas);\n        }\n    };\n    HiddenRangeModel.prototype.applyMemento = function (state) {\n        if (!Array.isArray(state) || state.length === 0) {\n            return false;\n        }\n        var hiddenRanges = [];\n        for (var _i = 0, state_1 = state; _i < state_1.length; _i++) {\n            var r = state_1[_i];\n            if (!r.startLineNumber || !r.endLineNumber) {\n                return false;\n            }\n            hiddenRanges.push(new range_1.Range(r.startLineNumber + 1, 1, r.endLineNumber, 1));\n        }\n        this.applyHiddenRanges(hiddenRanges);\n        return true;\n    };\n    /**\n     * Collapse state memento, for persistence only, only used if folding model is not yet initialized\n     */\n    HiddenRangeModel.prototype.getMemento = function () {\n        return this._hiddenRanges.map(function (r) { return ({ startLineNumber: r.startLineNumber - 1, endLineNumber: r.endLineNumber }); });\n    };\n    HiddenRangeModel.prototype.applyHiddenRanges = function (newHiddenAreas) {\n        this._hiddenRanges = newHiddenAreas;\n        this._updateEventEmitter.fire(newHiddenAreas);\n    };\n    HiddenRangeModel.prototype.hasRanges = function () {\n        return this._hiddenRanges.length > 0;\n    };\n    HiddenRangeModel.prototype.isHidden = function (line) {\n        return findRange(this._hiddenRanges, line) !== null;\n    };\n    HiddenRangeModel.prototype.adjustSelections = function (selections) {\n        var _this = this;\n        var hasChanges = false;\n        var editorModel = this._foldingModel.textModel;\n        var lastRange = null;\n        var adjustLine = function (line) {\n            if (!lastRange || !isInside(line, lastRange)) {\n                lastRange = findRange(_this._hiddenRanges, line);\n            }\n            if (lastRange) {\n                return lastRange.startLineNumber - 1;\n            }\n            return null;\n        };\n        for (var i = 0, len = selections.length; i < len; i++) {\n            var selection = selections[i];\n            var adjustedStartLine = adjustLine(selection.startLineNumber);\n            if (adjustedStartLine) {\n                selection = selection.setStartPosition(adjustedStartLine, editorModel.getLineMaxColumn(adjustedStartLine));\n                hasChanges = true;\n            }\n            var adjustedEndLine = adjustLine(selection.endLineNumber);\n            if (adjustedEndLine) {\n                selection = selection.setEndPosition(adjustedEndLine, editorModel.getLineMaxColumn(adjustedEndLine));\n                hasChanges = true;\n            }\n            selections[i] = selection;\n        }\n        return hasChanges;\n    };\n    HiddenRangeModel.prototype.dispose = function () {\n        if (this.hiddenRanges.length > 0) {\n            this._hiddenRanges = [];\n            this._updateEventEmitter.fire(this._hiddenRanges);\n        }\n        if (this._foldingModelListener) {\n            this._foldingModelListener.dispose();\n            this._foldingModelListener = null;\n        }\n    };\n    return HiddenRangeModel;\n}());\nexports.HiddenRangeModel = HiddenRangeModel;\nfunction isInside(line, range) {\n    return line >= range.startLineNumber && line <= range.endLineNumber;\n}\nfunction findRange(ranges, line) {\n    var i = arrays_1.findFirstInSorted(ranges, function (r) { return line < r.startLineNumber; }) - 1;\n    if (i >= 0 && ranges[i].endLineNumber >= line) {\n        return ranges[i];\n    }\n    return null;\n}\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/hiddenRangeModel.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/hiddenRangeModel.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { Range, IRange } from 'vs/editor/common/core/range';\nimport { FoldingModel, CollapseMemento } from 'vs/editor/contrib/folding/foldingModel';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { Selection } from 'vs/editor/common/core/selection';\nimport { findFirstInSorted } from 'vs/base/common/arrays';\n\nexport class HiddenRangeModel {\n\tprivate readonly _foldingModel: FoldingModel;\n\tprivate _hiddenRanges: IRange[];\n\tprivate _foldingModelListener: IDisposable | null;\n\tprivate _updateEventEmitter = new Emitter<IRange[]>();\n\n\tpublic get onDidChange(): Event<IRange[]> { return this._updateEventEmitter.event; }\n\tpublic get hiddenRanges() { return this._hiddenRanges; }\n\n\tpublic constructor(model: FoldingModel) {\n\t\tthis._foldingModel = model;\n\t\tthis._foldingModelListener = model.onDidChange(_ => this.updateHiddenRanges());\n\t\tthis._hiddenRanges = [];\n\t\tif (model.regions.length) {\n\t\t\tthis.updateHiddenRanges();\n\t\t}\n\t}\n\n\tprivate updateHiddenRanges(): void {\n\t\tlet updateHiddenAreas = false;\n\t\tlet newHiddenAreas: IRange[] = [];\n\t\tlet i = 0; // index into hidden\n\t\tlet k = 0;\n\n\t\tlet lastCollapsedStart = Number.MAX_VALUE;\n\t\tlet lastCollapsedEnd = -1;\n\n\t\tlet ranges = this._foldingModel.regions;\n\t\tfor (; i < ranges.length; i++) {\n\t\t\tif (!ranges.isCollapsed(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet startLineNumber = ranges.getStartLineNumber(i) + 1; // the first line is not hidden\n\t\t\tlet endLineNumber = ranges.getEndLineNumber(i);\n\t\t\tif (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) {\n\t\t\t\t// ignore ranges contained in collapsed regions\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {\n\t\t\t\t// reuse the old ranges\n\t\t\t\tnewHiddenAreas.push(this._hiddenRanges[k]);\n\t\t\t\tk++;\n\t\t\t} else {\n\t\t\t\tupdateHiddenAreas = true;\n\t\t\t\tnewHiddenAreas.push(new Range(startLineNumber, 1, endLineNumber, 1));\n\t\t\t}\n\t\t\tlastCollapsedStart = startLineNumber;\n\t\t\tlastCollapsedEnd = endLineNumber;\n\t\t}\n\t\tif (updateHiddenAreas || k < this._hiddenRanges.length) {\n\t\t\tthis.applyHiddenRanges(newHiddenAreas);\n\t\t}\n\t}\n\n\tpublic applyMemento(state: CollapseMemento): boolean {\n\t\tif (!Array.isArray(state) || state.length === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tlet hiddenRanges: IRange[] = [];\n\t\tfor (let r of state) {\n\t\t\tif (!r.startLineNumber || !r.endLineNumber) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\thiddenRanges.push(new Range(r.startLineNumber + 1, 1, r.endLineNumber, 1));\n\t\t}\n\t\tthis.applyHiddenRanges(hiddenRanges);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Collapse state memento, for persistence only, only used if folding model is not yet initialized\n\t */\n\tpublic getMemento(): CollapseMemento {\n\t\treturn this._hiddenRanges.map(r => ({ startLineNumber: r.startLineNumber - 1, endLineNumber: r.endLineNumber }));\n\t}\n\n\tprivate applyHiddenRanges(newHiddenAreas: IRange[]) {\n\t\tthis._hiddenRanges = newHiddenAreas;\n\t\tthis._updateEventEmitter.fire(newHiddenAreas);\n\t}\n\n\tpublic hasRanges() {\n\t\treturn this._hiddenRanges.length > 0;\n\t}\n\n\tpublic isHidden(line: number): boolean {\n\t\treturn findRange(this._hiddenRanges, line) !== null;\n\t}\n\n\tpublic adjustSelections(selections: Selection[]): boolean {\n\t\tlet hasChanges = false;\n\t\tlet editorModel = this._foldingModel.textModel;\n\t\tlet lastRange: IRange | null = null;\n\n\t\tlet adjustLine = (line: number) => {\n\t\t\tif (!lastRange || !isInside(line, lastRange)) {\n\t\t\t\tlastRange = findRange(this._hiddenRanges, line);\n\t\t\t}\n\t\t\tif (lastRange) {\n\t\t\t\treturn lastRange.startLineNumber - 1;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tlet selection = selections[i];\n\t\t\tlet adjustedStartLine = adjustLine(selection.startLineNumber);\n\t\t\tif (adjustedStartLine) {\n\t\t\t\tselection = selection.setStartPosition(adjustedStartLine, editorModel.getLineMaxColumn(adjustedStartLine));\n\t\t\t\thasChanges = true;\n\t\t\t}\n\t\t\tlet adjustedEndLine = adjustLine(selection.endLineNumber);\n\t\t\tif (adjustedEndLine) {\n\t\t\t\tselection = selection.setEndPosition(adjustedEndLine, editorModel.getLineMaxColumn(adjustedEndLine));\n\t\t\t\thasChanges = true;\n\t\t\t}\n\t\t\tselections[i] = selection;\n\t\t}\n\t\treturn hasChanges;\n\t}\n\n\n\tpublic dispose() {\n\t\tif (this.hiddenRanges.length > 0) {\n\t\t\tthis._hiddenRanges = [];\n\t\t\tthis._updateEventEmitter.fire(this._hiddenRanges);\n\t\t}\n\t\tif (this._foldingModelListener) {\n\t\t\tthis._foldingModelListener.dispose();\n\t\t\tthis._foldingModelListener = null;\n\t\t}\n\t}\n}\n\nfunction isInside(line: number, range: IRange) {\n\treturn line >= range.startLineNumber && line <= range.endLineNumber;\n}\nfunction findRange(ranges: IRange[], line: number): IRange | null {\n\tlet i = findFirstInSorted(ranges, r => line < r.startLineNumber) - 1;\n\tif (i >= 0 && ranges[i].endLineNumber >= line) {\n\t\treturn ranges[i];\n\t}\n\treturn null;\n}"]}]}