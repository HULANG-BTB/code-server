{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/comment/blockCommentCommand.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/comment/blockCommentCommand.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar editOperation_1 = require(\"vs/editor/common/core/editOperation\");\nvar position_1 = require(\"vs/editor/common/core/position\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar selection_1 = require(\"vs/editor/common/core/selection\");\nvar languageConfigurationRegistry_1 = require(\"vs/editor/common/modes/languageConfigurationRegistry\");\nvar BlockCommentCommand = /** @class */ (function () {\n    function BlockCommentCommand(selection) {\n        this._selection = selection;\n        this._usedEndToken = null;\n    }\n    BlockCommentCommand._haystackHasNeedleAtOffset = function (haystack, needle, offset) {\n        if (offset < 0) {\n            return false;\n        }\n        var needleLength = needle.length;\n        var haystackLength = haystack.length;\n        if (offset + needleLength > haystackLength) {\n            return false;\n        }\n        for (var i = 0; i < needleLength; i++) {\n            var codeA = haystack.charCodeAt(offset + i);\n            var codeB = needle.charCodeAt(i);\n            if (codeA === codeB) {\n                continue;\n            }\n            if (codeA >= charCode_1.CharCode.A && codeA <= charCode_1.CharCode.Z && codeA + 32 === codeB) {\n                // codeA is upper-case variant of codeB\n                continue;\n            }\n            if (codeB >= charCode_1.CharCode.A && codeB <= charCode_1.CharCode.Z && codeB + 32 === codeA) {\n                // codeB is upper-case variant of codeA\n                continue;\n            }\n            return false;\n        }\n        return true;\n    };\n    BlockCommentCommand.prototype._createOperationsForBlockComment = function (selection, startToken, endToken, model, builder) {\n        var startLineNumber = selection.startLineNumber;\n        var startColumn = selection.startColumn;\n        var endLineNumber = selection.endLineNumber;\n        var endColumn = selection.endColumn;\n        var startLineText = model.getLineContent(startLineNumber);\n        var endLineText = model.getLineContent(endLineNumber);\n        var startTokenIndex = startLineText.lastIndexOf(startToken, startColumn - 1 + startToken.length);\n        var endTokenIndex = endLineText.indexOf(endToken, endColumn - 1 - endToken.length);\n        if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n            if (startLineNumber === endLineNumber) {\n                var lineBetweenTokens = startLineText.substring(startTokenIndex + startToken.length, endTokenIndex);\n                if (lineBetweenTokens.indexOf(endToken) >= 0) {\n                    // force to add a block comment\n                    startTokenIndex = -1;\n                    endTokenIndex = -1;\n                }\n            }\n            else {\n                var startLineAfterStartToken = startLineText.substring(startTokenIndex + startToken.length);\n                var endLineBeforeEndToken = endLineText.substring(0, endTokenIndex);\n                if (startLineAfterStartToken.indexOf(endToken) >= 0 || endLineBeforeEndToken.indexOf(endToken) >= 0) {\n                    // force to add a block comment\n                    startTokenIndex = -1;\n                    endTokenIndex = -1;\n                }\n            }\n        }\n        var ops;\n        if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n            // Consider spaces as part of the comment tokens\n            if (startTokenIndex + startToken.length < startLineText.length) {\n                if (startLineText.charCodeAt(startTokenIndex + startToken.length) === charCode_1.CharCode.Space) {\n                    // Pretend the start token contains a trailing space\n                    startToken = startToken + ' ';\n                }\n            }\n            if (endTokenIndex > 0) {\n                if (endLineText.charCodeAt(endTokenIndex - 1) === charCode_1.CharCode.Space) {\n                    // Pretend the end token contains a leading space\n                    endToken = ' ' + endToken;\n                    endTokenIndex -= 1;\n                }\n            }\n            ops = BlockCommentCommand._createRemoveBlockCommentOperations(new range_1.Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n        }\n        else {\n            ops = BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken);\n            this._usedEndToken = ops.length === 1 ? endToken : null;\n        }\n        for (var _i = 0, ops_1 = ops; _i < ops_1.length; _i++) {\n            var op = ops_1[_i];\n            builder.addTrackedEditOperation(op.range, op.text);\n        }\n    };\n    BlockCommentCommand._createRemoveBlockCommentOperations = function (r, startToken, endToken) {\n        var res = [];\n        if (!range_1.Range.isEmpty(r)) {\n            // Remove block comment start\n            res.push(editOperation_1.EditOperation.delete(new range_1.Range(r.startLineNumber, r.startColumn - startToken.length, r.startLineNumber, r.startColumn)));\n            // Remove block comment end\n            res.push(editOperation_1.EditOperation.delete(new range_1.Range(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn + endToken.length)));\n        }\n        else {\n            // Remove both continuously\n            res.push(editOperation_1.EditOperation.delete(new range_1.Range(r.startLineNumber, r.startColumn - startToken.length, r.endLineNumber, r.endColumn + endToken.length)));\n        }\n        return res;\n    };\n    BlockCommentCommand._createAddBlockCommentOperations = function (r, startToken, endToken) {\n        var res = [];\n        if (!range_1.Range.isEmpty(r)) {\n            // Insert block comment start\n            res.push(editOperation_1.EditOperation.insert(new position_1.Position(r.startLineNumber, r.startColumn), startToken + ' '));\n            // Insert block comment end\n            res.push(editOperation_1.EditOperation.insert(new position_1.Position(r.endLineNumber, r.endColumn), ' ' + endToken));\n        }\n        else {\n            // Insert both continuously\n            res.push(editOperation_1.EditOperation.replace(new range_1.Range(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn), startToken + '  ' + endToken));\n        }\n        return res;\n    };\n    BlockCommentCommand.prototype.getEditOperations = function (model, builder) {\n        var startLineNumber = this._selection.startLineNumber;\n        var startColumn = this._selection.startColumn;\n        model.tokenizeIfCheap(startLineNumber);\n        var languageId = model.getLanguageIdAtPosition(startLineNumber, startColumn);\n        var config = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getComments(languageId);\n        if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n            // Mode does not support block comments\n            return;\n        }\n        this._createOperationsForBlockComment(this._selection, config.blockCommentStartToken, config.blockCommentEndToken, model, builder);\n    };\n    BlockCommentCommand.prototype.computeCursorState = function (model, helper) {\n        var inverseEditOperations = helper.getInverseEditOperations();\n        if (inverseEditOperations.length === 2) {\n            var startTokenEditOperation = inverseEditOperations[0];\n            var endTokenEditOperation = inverseEditOperations[1];\n            return new selection_1.Selection(startTokenEditOperation.range.endLineNumber, startTokenEditOperation.range.endColumn, endTokenEditOperation.range.startLineNumber, endTokenEditOperation.range.startColumn);\n        }\n        else {\n            var srcRange = inverseEditOperations[0].range;\n            var deltaColumn = this._usedEndToken ? -this._usedEndToken.length - 1 : 0; // minus 1 space before endToken\n            return new selection_1.Selection(srcRange.endLineNumber, srcRange.endColumn + deltaColumn, srcRange.endLineNumber, srcRange.endColumn + deltaColumn);\n        }\n    };\n    return BlockCommentCommand;\n}());\nexports.BlockCommentCommand = BlockCommentCommand;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/comment/blockCommentCommand.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/contrib/comment/blockCommentCommand.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { EditOperation } from 'vs/editor/common/core/editOperation';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { Selection } from 'vs/editor/common/core/selection';\nimport * as editorCommon from 'vs/editor/common/editorCommon';\nimport { IIdentifiedSingleEditOperation, ITextModel } from 'vs/editor/common/model';\nimport { LanguageConfigurationRegistry } from 'vs/editor/common/modes/languageConfigurationRegistry';\n\nexport class BlockCommentCommand implements editorCommon.ICommand {\n\n\tprivate readonly _selection: Selection;\n\tprivate _usedEndToken: string | null;\n\n\tconstructor(selection: Selection) {\n\t\tthis._selection = selection;\n\t\tthis._usedEndToken = null;\n\t}\n\n\tpublic static _haystackHasNeedleAtOffset(haystack: string, needle: string, offset: number): boolean {\n\t\tif (offset < 0) {\n\t\t\treturn false;\n\t\t}\n\t\tconst needleLength = needle.length;\n\t\tconst haystackLength = haystack.length;\n\t\tif (offset + needleLength > haystackLength) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = 0; i < needleLength; i++) {\n\t\t\tconst codeA = haystack.charCodeAt(offset + i);\n\t\t\tconst codeB = needle.charCodeAt(i);\n\n\t\t\tif (codeA === codeB) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (codeA >= CharCode.A && codeA <= CharCode.Z && codeA + 32 === codeB) {\n\t\t\t\t// codeA is upper-case variant of codeB\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (codeB >= CharCode.A && codeB <= CharCode.Z && codeB + 32 === codeA) {\n\t\t\t\t// codeB is upper-case variant of codeA\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate _createOperationsForBlockComment(selection: Range, startToken: string, endToken: string, model: ITextModel, builder: editorCommon.IEditOperationBuilder): void {\n\t\tconst startLineNumber = selection.startLineNumber;\n\t\tconst startColumn = selection.startColumn;\n\t\tconst endLineNumber = selection.endLineNumber;\n\t\tconst endColumn = selection.endColumn;\n\n\t\tconst startLineText = model.getLineContent(startLineNumber);\n\t\tconst endLineText = model.getLineContent(endLineNumber);\n\n\t\tlet startTokenIndex = startLineText.lastIndexOf(startToken, startColumn - 1 + startToken.length);\n\t\tlet endTokenIndex = endLineText.indexOf(endToken, endColumn - 1 - endToken.length);\n\n\t\tif (startTokenIndex !== -1 && endTokenIndex !== -1) {\n\n\t\t\tif (startLineNumber === endLineNumber) {\n\t\t\t\tconst lineBetweenTokens = startLineText.substring(startTokenIndex + startToken.length, endTokenIndex);\n\n\t\t\t\tif (lineBetweenTokens.indexOf(endToken) >= 0) {\n\t\t\t\t\t// force to add a block comment\n\t\t\t\t\tstartTokenIndex = -1;\n\t\t\t\t\tendTokenIndex = -1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst startLineAfterStartToken = startLineText.substring(startTokenIndex + startToken.length);\n\t\t\t\tconst endLineBeforeEndToken = endLineText.substring(0, endTokenIndex);\n\n\t\t\t\tif (startLineAfterStartToken.indexOf(endToken) >= 0 || endLineBeforeEndToken.indexOf(endToken) >= 0) {\n\t\t\t\t\t// force to add a block comment\n\t\t\t\t\tstartTokenIndex = -1;\n\t\t\t\t\tendTokenIndex = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet ops: IIdentifiedSingleEditOperation[];\n\n\t\tif (startTokenIndex !== -1 && endTokenIndex !== -1) {\n\t\t\t// Consider spaces as part of the comment tokens\n\t\t\tif (startTokenIndex + startToken.length < startLineText.length) {\n\t\t\t\tif (startLineText.charCodeAt(startTokenIndex + startToken.length) === CharCode.Space) {\n\t\t\t\t\t// Pretend the start token contains a trailing space\n\t\t\t\t\tstartToken = startToken + ' ';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (endTokenIndex > 0) {\n\t\t\t\tif (endLineText.charCodeAt(endTokenIndex - 1) === CharCode.Space) {\n\t\t\t\t\t// Pretend the end token contains a leading space\n\t\t\t\t\tendToken = ' ' + endToken;\n\t\t\t\t\tendTokenIndex -= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tops = BlockCommentCommand._createRemoveBlockCommentOperations(\n\t\t\t\tnew Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken\n\t\t\t);\n\t\t} else {\n\t\t\tops = BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken);\n\t\t\tthis._usedEndToken = ops.length === 1 ? endToken : null;\n\t\t}\n\n\t\tfor (const op of ops) {\n\t\t\tbuilder.addTrackedEditOperation(op.range, op.text);\n\t\t}\n\t}\n\n\tpublic static _createRemoveBlockCommentOperations(r: Range, startToken: string, endToken: string): IIdentifiedSingleEditOperation[] {\n\t\tlet res: IIdentifiedSingleEditOperation[] = [];\n\n\t\tif (!Range.isEmpty(r)) {\n\t\t\t// Remove block comment start\n\t\t\tres.push(EditOperation.delete(new Range(\n\t\t\t\tr.startLineNumber, r.startColumn - startToken.length,\n\t\t\t\tr.startLineNumber, r.startColumn\n\t\t\t)));\n\n\t\t\t// Remove block comment end\n\t\t\tres.push(EditOperation.delete(new Range(\n\t\t\t\tr.endLineNumber, r.endColumn,\n\t\t\t\tr.endLineNumber, r.endColumn + endToken.length\n\t\t\t)));\n\t\t} else {\n\t\t\t// Remove both continuously\n\t\t\tres.push(EditOperation.delete(new Range(\n\t\t\t\tr.startLineNumber, r.startColumn - startToken.length,\n\t\t\t\tr.endLineNumber, r.endColumn + endToken.length\n\t\t\t)));\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tpublic static _createAddBlockCommentOperations(r: Range, startToken: string, endToken: string): IIdentifiedSingleEditOperation[] {\n\t\tlet res: IIdentifiedSingleEditOperation[] = [];\n\n\t\tif (!Range.isEmpty(r)) {\n\t\t\t// Insert block comment start\n\t\t\tres.push(EditOperation.insert(new Position(r.startLineNumber, r.startColumn), startToken + ' '));\n\n\t\t\t// Insert block comment end\n\t\t\tres.push(EditOperation.insert(new Position(r.endLineNumber, r.endColumn), ' ' + endToken));\n\t\t} else {\n\t\t\t// Insert both continuously\n\t\t\tres.push(EditOperation.replace(new Range(\n\t\t\t\tr.startLineNumber, r.startColumn,\n\t\t\t\tr.endLineNumber, r.endColumn\n\t\t\t), startToken + '  ' + endToken));\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tpublic getEditOperations(model: ITextModel, builder: editorCommon.IEditOperationBuilder): void {\n\t\tconst startLineNumber = this._selection.startLineNumber;\n\t\tconst startColumn = this._selection.startColumn;\n\n\t\tmodel.tokenizeIfCheap(startLineNumber);\n\t\tconst languageId = model.getLanguageIdAtPosition(startLineNumber, startColumn);\n\t\tconst config = LanguageConfigurationRegistry.getComments(languageId);\n\t\tif (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n\t\t\t// Mode does not support block comments\n\t\t\treturn;\n\t\t}\n\n\t\tthis._createOperationsForBlockComment(this._selection, config.blockCommentStartToken, config.blockCommentEndToken, model, builder);\n\t}\n\n\tpublic computeCursorState(model: ITextModel, helper: editorCommon.ICursorStateComputerData): Selection {\n\t\tconst inverseEditOperations = helper.getInverseEditOperations();\n\t\tif (inverseEditOperations.length === 2) {\n\t\t\tconst startTokenEditOperation = inverseEditOperations[0];\n\t\t\tconst endTokenEditOperation = inverseEditOperations[1];\n\n\t\t\treturn new Selection(\n\t\t\t\tstartTokenEditOperation.range.endLineNumber,\n\t\t\t\tstartTokenEditOperation.range.endColumn,\n\t\t\t\tendTokenEditOperation.range.startLineNumber,\n\t\t\t\tendTokenEditOperation.range.startColumn\n\t\t\t);\n\t\t} else {\n\t\t\tconst srcRange = inverseEditOperations[0].range;\n\t\t\tconst deltaColumn = this._usedEndToken ? -this._usedEndToken.length - 1 : 0; // minus 1 space before endToken\n\t\t\treturn new Selection(\n\t\t\t\tsrcRange.endLineNumber,\n\t\t\t\tsrcRange.endColumn + deltaColumn,\n\t\t\t\tsrcRange.endLineNumber,\n\t\t\t\tsrcRange.endColumn + deltaColumn\n\t\t\t);\n\t\t}\n\t}\n}\n"]}]}