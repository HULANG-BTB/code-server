{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/supports/tokenization.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/modes/supports/tokenization.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/color\", \"vs/editor/common/modes\"], function (require, exports, color_1, modes_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class ParsedTokenThemeRule {\n        constructor(token, index, fontStyle, foreground, background) {\n            this.token = token;\n            this.index = index;\n            this.fontStyle = fontStyle;\n            this.foreground = foreground;\n            this.background = background;\n        }\n    }\n    exports.ParsedTokenThemeRule = ParsedTokenThemeRule;\n    /**\n     * Parse a raw theme into rules.\n     */\n    function parseTokenTheme(source) {\n        if (!source || !Array.isArray(source)) {\n            return [];\n        }\n        let result = [], resultLen = 0;\n        for (let i = 0, len = source.length; i < len; i++) {\n            let entry = source[i];\n            let fontStyle = modes_1.FontStyle.NotSet;\n            if (typeof entry.fontStyle === 'string') {\n                fontStyle = modes_1.FontStyle.None;\n                let segments = entry.fontStyle.split(' ');\n                for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n                    let segment = segments[j];\n                    switch (segment) {\n                        case 'italic':\n                            fontStyle = fontStyle | modes_1.FontStyle.Italic;\n                            break;\n                        case 'bold':\n                            fontStyle = fontStyle | modes_1.FontStyle.Bold;\n                            break;\n                        case 'underline':\n                            fontStyle = fontStyle | modes_1.FontStyle.Underline;\n                            break;\n                    }\n                }\n            }\n            let foreground = null;\n            if (typeof entry.foreground === 'string') {\n                foreground = entry.foreground;\n            }\n            let background = null;\n            if (typeof entry.background === 'string') {\n                background = entry.background;\n            }\n            result[resultLen++] = new ParsedTokenThemeRule(entry.token || '', i, fontStyle, foreground, background);\n        }\n        return result;\n    }\n    exports.parseTokenTheme = parseTokenTheme;\n    /**\n     * Resolve rules (i.e. inheritance).\n     */\n    function resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {\n        // Sort rules lexicographically, and then by index if necessary\n        parsedThemeRules.sort((a, b) => {\n            let r = strcmp(a.token, b.token);\n            if (r !== 0) {\n                return r;\n            }\n            return a.index - b.index;\n        });\n        // Determine defaults\n        let defaultFontStyle = modes_1.FontStyle.None;\n        let defaultForeground = '000000';\n        let defaultBackground = 'ffffff';\n        while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {\n            let incomingDefaults = parsedThemeRules.shift();\n            if (incomingDefaults.fontStyle !== modes_1.FontStyle.NotSet) {\n                defaultFontStyle = incomingDefaults.fontStyle;\n            }\n            if (incomingDefaults.foreground !== null) {\n                defaultForeground = incomingDefaults.foreground;\n            }\n            if (incomingDefaults.background !== null) {\n                defaultBackground = incomingDefaults.background;\n            }\n        }\n        let colorMap = new ColorMap();\n        // start with token colors from custom token themes\n        for (let color of customTokenColors) {\n            colorMap.getId(color);\n        }\n        let foregroundColorId = colorMap.getId(defaultForeground);\n        let backgroundColorId = colorMap.getId(defaultBackground);\n        let defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);\n        let root = new ThemeTrieElement(defaults);\n        for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n            let rule = parsedThemeRules[i];\n            root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n        }\n        return new TokenTheme(colorMap, root);\n    }\n    const colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;\n    class ColorMap {\n        constructor() {\n            this._lastColorId = 0;\n            this._id2color = [];\n            this._color2id = new Map();\n        }\n        getId(color) {\n            if (color === null) {\n                return 0;\n            }\n            const match = color.match(colorRegExp);\n            if (!match) {\n                throw new Error('Illegal value for token color: ' + color);\n            }\n            color = match[1].toUpperCase();\n            let value = this._color2id.get(color);\n            if (value) {\n                return value;\n            }\n            value = ++this._lastColorId;\n            this._color2id.set(color, value);\n            this._id2color[value] = color_1.Color.fromHex('#' + color);\n            return value;\n        }\n        getColorMap() {\n            return this._id2color.slice(0);\n        }\n    }\n    exports.ColorMap = ColorMap;\n    class TokenTheme {\n        static createFromRawTokenTheme(source, customTokenColors) {\n            return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);\n        }\n        static createFromParsedTokenTheme(source, customTokenColors) {\n            return resolveParsedTokenThemeRules(source, customTokenColors);\n        }\n        constructor(colorMap, root) {\n            this._colorMap = colorMap;\n            this._root = root;\n            this._cache = new Map();\n        }\n        getColorMap() {\n            return this._colorMap.getColorMap();\n        }\n        /**\n         * used for testing purposes\n         */\n        getThemeTrieElement() {\n            return this._root.toExternalThemeTrieElement();\n        }\n        _match(token) {\n            return this._root.match(token);\n        }\n        match(languageId, token) {\n            // The cache contains the metadata without the language bits set.\n            let result = this._cache.get(token);\n            if (typeof result === 'undefined') {\n                let rule = this._match(token);\n                let standardToken = toStandardTokenType(token);\n                result = (rule.metadata\n                    | (standardToken << modes_1.MetadataConsts.TOKEN_TYPE_OFFSET)) >>> 0;\n                this._cache.set(token, result);\n            }\n            return (result\n                | (languageId << modes_1.MetadataConsts.LANGUAGEID_OFFSET)) >>> 0;\n        }\n    }\n    exports.TokenTheme = TokenTheme;\n    const STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|regexp)\\b/;\n    function toStandardTokenType(tokenType) {\n        let m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);\n        if (!m) {\n            return modes_1.StandardTokenType.Other;\n        }\n        switch (m[1]) {\n            case 'comment':\n                return modes_1.StandardTokenType.Comment;\n            case 'string':\n                return modes_1.StandardTokenType.String;\n            case 'regex':\n                return modes_1.StandardTokenType.RegEx;\n            case 'regexp':\n                return modes_1.StandardTokenType.RegEx;\n        }\n        throw new Error('Unexpected match for standard token type!');\n    }\n    exports.toStandardTokenType = toStandardTokenType;\n    function strcmp(a, b) {\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n    exports.strcmp = strcmp;\n    class ThemeTrieElementRule {\n        constructor(fontStyle, foreground, background) {\n            this._fontStyle = fontStyle;\n            this._foreground = foreground;\n            this._background = background;\n            this.metadata = ((this._fontStyle << modes_1.MetadataConsts.FONT_STYLE_OFFSET)\n                | (this._foreground << modes_1.MetadataConsts.FOREGROUND_OFFSET)\n                | (this._background << modes_1.MetadataConsts.BACKGROUND_OFFSET)) >>> 0;\n        }\n        clone() {\n            return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);\n        }\n        acceptOverwrite(fontStyle, foreground, background) {\n            if (fontStyle !== modes_1.FontStyle.NotSet) {\n                this._fontStyle = fontStyle;\n            }\n            if (foreground !== modes_1.ColorId.None) {\n                this._foreground = foreground;\n            }\n            if (background !== modes_1.ColorId.None) {\n                this._background = background;\n            }\n            this.metadata = ((this._fontStyle << modes_1.MetadataConsts.FONT_STYLE_OFFSET)\n                | (this._foreground << modes_1.MetadataConsts.FOREGROUND_OFFSET)\n                | (this._background << modes_1.MetadataConsts.BACKGROUND_OFFSET)) >>> 0;\n        }\n    }\n    exports.ThemeTrieElementRule = ThemeTrieElementRule;\n    class ExternalThemeTrieElement {\n        constructor(mainRule, children) {\n            this.mainRule = mainRule;\n            this.children = children || Object.create(null);\n        }\n    }\n    exports.ExternalThemeTrieElement = ExternalThemeTrieElement;\n    class ThemeTrieElement {\n        constructor(mainRule) {\n            this._mainRule = mainRule;\n            this._children = new Map();\n        }\n        /**\n         * used for testing purposes\n         */\n        toExternalThemeTrieElement() {\n            let children = Object.create(null);\n            this._children.forEach((element, index) => {\n                children[index] = element.toExternalThemeTrieElement();\n            });\n            return new ExternalThemeTrieElement(this._mainRule, children);\n        }\n        match(token) {\n            if (token === '') {\n                return this._mainRule;\n            }\n            let dotIndex = token.indexOf('.');\n            let head;\n            let tail;\n            if (dotIndex === -1) {\n                head = token;\n                tail = '';\n            }\n            else {\n                head = token.substring(0, dotIndex);\n                tail = token.substring(dotIndex + 1);\n            }\n            let child = this._children.get(head);\n            if (typeof child !== 'undefined') {\n                return child.match(tail);\n            }\n            return this._mainRule;\n        }\n        insert(token, fontStyle, foreground, background) {\n            if (token === '') {\n                // Merge into the main rule\n                this._mainRule.acceptOverwrite(fontStyle, foreground, background);\n                return;\n            }\n            let dotIndex = token.indexOf('.');\n            let head;\n            let tail;\n            if (dotIndex === -1) {\n                head = token;\n                tail = '';\n            }\n            else {\n                head = token.substring(0, dotIndex);\n                tail = token.substring(dotIndex + 1);\n            }\n            let child = this._children.get(head);\n            if (typeof child === 'undefined') {\n                child = new ThemeTrieElement(this._mainRule.clone());\n                this._children.set(head, child);\n            }\n            child.insert(tail, fontStyle, foreground, background);\n        }\n    }\n    exports.ThemeTrieElement = ThemeTrieElement;\n    function generateTokensCSSForColorMap(colorMap) {\n        let rules = [];\n        for (let i = 1, len = colorMap.length; i < len; i++) {\n            let color = colorMap[i];\n            rules[i] = `.mtk${i} { color: ${color}; }`;\n        }\n        rules.push('.mtki { font-style: italic; }');\n        rules.push('.mtkb { font-weight: bold; }');\n        rules.push('.mtku { text-decoration: underline; text-underline-position: under; }');\n        return rules.join('\\n');\n    }\n    exports.generateTokensCSSForColorMap = generateTokensCSSForColorMap;\n});\n",null]}