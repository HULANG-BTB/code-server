{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/textfile/common/textFileService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/textfile/common/textFileService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/uri\", \"vs/base/common/errors\", \"vs/base/common/objects\", \"vs/base/common/event\", \"vs/base/common/platform\", \"vs/platform/windows/common/windows\", \"vs/workbench/services/backup/common/backup\", \"vs/workbench/services/textfile/common/textfiles\", \"vs/workbench/common/editor\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/platform/workspace/common/workspace\", \"vs/platform/files/common/files\", \"vs/platform/configuration/common/configuration\", \"vs/base/common/lifecycle\", \"vs/platform/environment/common/environment\", \"vs/workbench/services/untitled/common/untitledEditorService\", \"vs/workbench/common/editor/untitledEditorModel\", \"vs/workbench/services/textfile/common/textFileEditorModelManager\", \"vs/platform/instantiation/common/instantiation\", \"vs/base/common/map\", \"vs/base/common/network\", \"vs/workbench/services/history/common/history\", \"vs/platform/contextkey/common/contextkey\", \"vs/editor/common/model/textModel\", \"vs/editor/common/services/modelService\", \"vs/platform/notification/common/notification\", \"vs/base/common/resources\", \"vs/platform/remote/common/remoteHosts\", \"vs/platform/dialogs/common/dialogs\", \"vs/editor/common/services/modeService\", \"vs/workbench/services/editor/common/editorService\", \"vs/base/common/arrays\", \"vs/base/common/strings\", \"vs/platform/instantiation/common/extensions\"], function (require, exports, nls, uri_1, errors, objects, event_1, platform, windows_1, backup_1, textfiles_1, editor_1, lifecycle_1, workspace_1, files_1, configuration_1, lifecycle_2, environment_1, untitledEditorService_1, untitledEditorModel_1, textFileEditorModelManager_1, instantiation_1, map_1, network_1, history_1, contextkey_1, textModel_1, modelService_1, notification_1, resources_1, remoteHosts_1, dialogs_1, modeService_1, editorService_1, arrays_1, strings_1, extensions_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * The workbench file service implementation implements the raw file service spec and adds additional methods on top.\n     *\n     * It also adds diagnostics and logging around file system operations.\n     */\n    let TextFileService = class TextFileService extends lifecycle_2.Disposable {\n        constructor(contextService, fileService, untitledEditorService, lifecycleService, instantiationService, configurationService, modeService, modelService, windowService, environmentService, notificationService, backupFileService, windowsService, historyService, contextKeyService, dialogService, fileDialogService, editorService) {\n            super();\n            this.contextService = contextService;\n            this.fileService = fileService;\n            this.untitledEditorService = untitledEditorService;\n            this.lifecycleService = lifecycleService;\n            this.configurationService = configurationService;\n            this.modeService = modeService;\n            this.modelService = modelService;\n            this.windowService = windowService;\n            this.environmentService = environmentService;\n            this.notificationService = notificationService;\n            this.backupFileService = backupFileService;\n            this.windowsService = windowsService;\n            this.historyService = historyService;\n            this.dialogService = dialogService;\n            this.fileDialogService = fileDialogService;\n            this.editorService = editorService;\n            this._onAutoSaveConfigurationChange = this._register(new event_1.Emitter());\n            this._onFilesAssociationChange = this._register(new event_1.Emitter());\n            this._onWillMove = this._register(new event_1.Emitter());\n            this._models = instantiationService.createInstance(textFileEditorModelManager_1.TextFileEditorModelManager);\n            this.autoSaveContext = textfiles_1.AutoSaveContext.bindTo(contextKeyService);\n            const configuration = configurationService.getValue();\n            this.currentFilesAssociationConfig = configuration && configuration.files && configuration.files.associations;\n            this.onFilesConfigurationChange(configuration);\n            this.registerListeners();\n        }\n        get onAutoSaveConfigurationChange() { return this._onAutoSaveConfigurationChange.event; }\n        get onFilesAssociationChange() { return this._onFilesAssociationChange.event; }\n        get onWillMove() { return this._onWillMove.event; }\n        get models() {\n            return this._models;\n        }\n        resolveTextContent(resource, options) {\n            return this.fileService.resolveStreamContent(resource, options).then(streamContent => {\n                return textModel_1.createTextBufferFactoryFromStream(streamContent.value).then(res => {\n                    return {\n                        resource: streamContent.resource,\n                        name: streamContent.name,\n                        mtime: streamContent.mtime,\n                        etag: streamContent.etag,\n                        encoding: streamContent.encoding,\n                        isReadonly: streamContent.isReadonly,\n                        size: streamContent.size,\n                        value: res\n                    };\n                });\n            });\n        }\n        promptForPath(resource, defaultUri) {\n            // Help user to find a name for the file by opening it first\n            return this.editorService.openEditor({ resource, options: { revealIfOpened: true, preserveFocus: true, } }).then(() => {\n                return this.fileDialogService.showSaveDialog(this.getSaveDialogOptions(defaultUri));\n            });\n        }\n        getSaveDialogOptions(defaultUri) {\n            const options = {\n                defaultUri,\n                title: nls.localize('saveAsTitle', \"Save As\")\n            };\n            // Filters are only enabled on Windows where they work properly\n            if (!platform.isWindows) {\n                return options;\n            }\n            // Build the file filter by using our known languages\n            const ext = defaultUri ? resources_1.extname(defaultUri) : undefined;\n            let matchingFilter;\n            const filters = arrays_1.coalesce(this.modeService.getRegisteredLanguageNames().map(languageName => {\n                const extensions = this.modeService.getExtensions(languageName);\n                if (!extensions || !extensions.length) {\n                    return null;\n                }\n                const filter = { name: languageName, extensions: extensions.slice(0, 10).map(e => strings_1.trim(e, '.')) };\n                if (ext && extensions.indexOf(ext) >= 0) {\n                    matchingFilter = filter;\n                    return null; // matching filter will be added last to the top\n                }\n                return filter;\n            }));\n            // Filters are a bit weird on Windows, based on having a match or not:\n            // Match: we put the matching filter first so that it shows up selected and the all files last\n            // No match: we put the all files filter first\n            const allFilesFilter = { name: nls.localize('allFiles', \"All Files\"), extensions: ['*'] };\n            if (matchingFilter) {\n                filters.unshift(matchingFilter);\n                filters.unshift(allFilesFilter);\n            }\n            else {\n                filters.unshift(allFilesFilter);\n            }\n            // Allow to save file without extension\n            filters.push({ name: nls.localize('noExt', \"No Extension\"), extensions: [''] });\n            options.filters = filters;\n            return options;\n        }\n        confirmSave(resources) {\n            if (this.environmentService.isExtensionDevelopment) {\n                return Promise.resolve(editor_1.ConfirmResult.DONT_SAVE); // no veto when we are in extension dev mode because we cannot assum we run interactive (e.g. tests)\n            }\n            const resourcesToConfirm = this.getDirty(resources);\n            if (resourcesToConfirm.length === 0) {\n                return Promise.resolve(editor_1.ConfirmResult.DONT_SAVE);\n            }\n            const message = resourcesToConfirm.length === 1 ? nls.localize('saveChangesMessage', \"Do you want to save the changes you made to {0}?\", resources_1.basename(resourcesToConfirm[0]))\n                : dialogs_1.getConfirmMessage(nls.localize('saveChangesMessages', \"Do you want to save the changes to the following {0} files?\", resourcesToConfirm.length), resourcesToConfirm);\n            const buttons = [\n                resourcesToConfirm.length > 1 ? nls.localize({ key: 'saveAll', comment: ['&& denotes a mnemonic'] }, \"&&Save All\") : nls.localize({ key: 'save', comment: ['&& denotes a mnemonic'] }, \"&&Save\"),\n                nls.localize({ key: 'dontSave', comment: ['&& denotes a mnemonic'] }, \"Do&&n't Save\"),\n                nls.localize('cancel', \"Cancel\")\n            ];\n            return this.dialogService.show(notification_1.Severity.Warning, message, buttons, {\n                cancelId: 2,\n                detail: nls.localize('saveChangesDetail', \"Your changes will be lost if you don't save them.\")\n            }).then(index => {\n                switch (index) {\n                    case 0: return editor_1.ConfirmResult.SAVE;\n                    case 1: return editor_1.ConfirmResult.DONT_SAVE;\n                    default: return editor_1.ConfirmResult.CANCEL;\n                }\n            });\n        }\n        confirmOverwrite(resource) {\n            const confirm = {\n                message: nls.localize('confirmOverwrite', \"'{0}' already exists. Do you want to replace it?\", resources_1.basename(resource)),\n                detail: nls.localize('irreversible', \"A file or folder with the same name already exists in the folder {0}. Replacing it will overwrite its current contents.\", resources_1.basename(resources_1.dirname(resource))),\n                primaryButton: nls.localize({ key: 'replaceButtonLabel', comment: ['&& denotes a mnemonic'] }, \"&&Replace\"),\n                type: 'warning'\n            };\n            return this.dialogService.confirm(confirm).then(result => result.confirmed);\n        }\n        registerListeners() {\n            // Lifecycle\n            this.lifecycleService.onBeforeShutdown(event => event.veto(this.beforeShutdown(event.reason)));\n            this.lifecycleService.onShutdown(this.dispose, this);\n            // Files configuration changes\n            this._register(this.configurationService.onDidChangeConfiguration(e => {\n                if (e.affectsConfiguration('files')) {\n                    this.onFilesConfigurationChange(this.configurationService.getValue());\n                }\n            }));\n        }\n        beforeShutdown(reason) {\n            // Dirty files need treatment on shutdown\n            const dirty = this.getDirty();\n            if (dirty.length) {\n                // If auto save is enabled, save all files and then check again for dirty files\n                // We DO NOT run any save participant if we are in the shutdown phase for performance reasons\n                if (this.getAutoSaveMode() !== textfiles_1.AutoSaveMode.OFF) {\n                    return this.saveAll(false /* files only */, { skipSaveParticipants: true }).then(() => {\n                        // If we still have dirty files, we either have untitled ones or files that cannot be saved\n                        const remainingDirty = this.getDirty();\n                        if (remainingDirty.length) {\n                            return this.handleDirtyBeforeShutdown(remainingDirty, reason);\n                        }\n                        return false;\n                    });\n                }\n                // Auto save is not enabled\n                return this.handleDirtyBeforeShutdown(dirty, reason);\n            }\n            // No dirty files: no veto\n            return this.noVeto({ cleanUpBackups: true });\n        }\n        handleDirtyBeforeShutdown(dirty, reason) {\n            // If hot exit is enabled, backup dirty files and allow to exit without confirmation\n            if (this.isHotExitEnabled) {\n                return this.backupBeforeShutdown(dirty, this.models, reason).then(result => {\n                    if (result.didBackup) {\n                        return this.noVeto({ cleanUpBackups: false }); // no veto and no backup cleanup (since backup was successful)\n                    }\n                    // since a backup did not happen, we have to confirm for the dirty files now\n                    return this.confirmBeforeShutdown();\n                }, errors => {\n                    const firstError = errors[0];\n                    this.notificationService.error(nls.localize('files.backup.failSave', \"Files that are dirty could not be written to the backup location (Error: {0}). Try saving your files first and then exit.\", firstError.message));\n                    return true; // veto, the backups failed\n                });\n            }\n            // Otherwise just confirm from the user what to do with the dirty files\n            return this.confirmBeforeShutdown();\n        }\n        backupBeforeShutdown(dirtyToBackup, textFileEditorModelManager, reason) {\n            return this.windowsService.getWindowCount().then(windowCount => {\n                // When quit is requested skip the confirm callback and attempt to backup all workspaces.\n                // When quit is not requested the confirm callback should be shown when the window being\n                // closed is the only VS Code window open, except for on Mac where hot exit is only\n                // ever activated when quit is requested.\n                let doBackup;\n                switch (reason) {\n                    case lifecycle_1.ShutdownReason.CLOSE:\n                        if (this.contextService.getWorkbenchState() !== workspace_1.WorkbenchState.EMPTY && this.configuredHotExit === files_1.HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {\n                            doBackup = true; // backup if a folder is open and onExitAndWindowClose is configured\n                        }\n                        else if (windowCount > 1 || platform.isMacintosh) {\n                            doBackup = false; // do not backup if a window is closed that does not cause quitting of the application\n                        }\n                        else {\n                            doBackup = true; // backup if last window is closed on win/linux where the application quits right after\n                        }\n                        break;\n                    case lifecycle_1.ShutdownReason.QUIT:\n                        doBackup = true; // backup because next start we restore all backups\n                        break;\n                    case lifecycle_1.ShutdownReason.RELOAD:\n                        doBackup = true; // backup because after window reload, backups restore\n                        break;\n                    case lifecycle_1.ShutdownReason.LOAD:\n                        if (this.contextService.getWorkbenchState() !== workspace_1.WorkbenchState.EMPTY && this.configuredHotExit === files_1.HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {\n                            doBackup = true; // backup if a folder is open and onExitAndWindowClose is configured\n                        }\n                        else {\n                            doBackup = false; // do not backup because we are switching contexts\n                        }\n                        break;\n                }\n                if (!doBackup) {\n                    return { didBackup: false };\n                }\n                // Backup\n                return this.backupAll(dirtyToBackup, textFileEditorModelManager).then(() => { return { didBackup: true }; });\n            });\n        }\n        backupAll(dirtyToBackup, textFileEditorModelManager) {\n            // split up between files and untitled\n            const filesToBackup = [];\n            const untitledToBackup = [];\n            dirtyToBackup.forEach(s => {\n                if (this.fileService.canHandleResource(s)) {\n                    const model = textFileEditorModelManager.get(s);\n                    if (model) {\n                        filesToBackup.push(model);\n                    }\n                }\n                else if (s.scheme === network_1.Schemas.untitled) {\n                    untitledToBackup.push(s);\n                }\n            });\n            return this.doBackupAll(filesToBackup, untitledToBackup);\n        }\n        doBackupAll(dirtyFileModels, untitledResources) {\n            const promises = dirtyFileModels.map(model => {\n                const snapshot = model.createSnapshot();\n                if (snapshot) {\n                    return this.backupFileService.backupResource(model.getResource(), snapshot, model.getVersionId());\n                }\n                return Promise.resolve();\n            });\n            // Handle file resources first\n            return Promise.all(promises).then(results => {\n                // Handle untitled resources\n                const untitledModelPromises = untitledResources\n                    .filter(untitled => this.untitledEditorService.exists(untitled))\n                    .map(untitled => this.untitledEditorService.loadOrCreate({ resource: untitled }));\n                return Promise.all(untitledModelPromises).then(untitledModels => {\n                    const untitledBackupPromises = untitledModels.map(model => {\n                        const snapshot = model.createSnapshot();\n                        if (snapshot) {\n                            return this.backupFileService.backupResource(model.getResource(), snapshot, model.getVersionId());\n                        }\n                        return Promise.resolve();\n                    });\n                    return Promise.all(untitledBackupPromises).then(() => undefined);\n                });\n            });\n        }\n        confirmBeforeShutdown() {\n            return this.confirmSave().then(confirm => {\n                // Save\n                if (confirm === editor_1.ConfirmResult.SAVE) {\n                    return this.saveAll(true /* includeUntitled */, { skipSaveParticipants: true }).then(result => {\n                        if (result.results.some(r => !r.success)) {\n                            return true; // veto if some saves failed\n                        }\n                        return this.noVeto({ cleanUpBackups: true });\n                    });\n                }\n                // Don't Save\n                else if (confirm === editor_1.ConfirmResult.DONT_SAVE) {\n                    // Make sure to revert untitled so that they do not restore\n                    // see https://github.com/Microsoft/vscode/issues/29572\n                    this.untitledEditorService.revertAll();\n                    return this.noVeto({ cleanUpBackups: true });\n                }\n                // Cancel\n                else if (confirm === editor_1.ConfirmResult.CANCEL) {\n                    return true; // veto\n                }\n                return false;\n            });\n        }\n        noVeto(options) {\n            if (!options.cleanUpBackups) {\n                return false;\n            }\n            if (this.lifecycleService.phase < lifecycle_1.LifecyclePhase.Restored) {\n                return false; // if editors have not restored, we are not up to speed with backups and thus should not clean them\n            }\n            return this.cleanupBackupsBeforeShutdown().then(() => false, () => false);\n        }\n        cleanupBackupsBeforeShutdown() {\n            if (this.environmentService.isExtensionDevelopment) {\n                return Promise.resolve(undefined);\n            }\n            return this.backupFileService.discardAllWorkspaceBackups();\n        }\n        onFilesConfigurationChange(configuration) {\n            const wasAutoSaveEnabled = (this.getAutoSaveMode() !== textfiles_1.AutoSaveMode.OFF);\n            const autoSaveMode = (configuration && configuration.files && configuration.files.autoSave) || files_1.AutoSaveConfiguration.OFF;\n            this.autoSaveContext.set(autoSaveMode);\n            switch (autoSaveMode) {\n                case files_1.AutoSaveConfiguration.AFTER_DELAY:\n                    this.configuredAutoSaveDelay = configuration && configuration.files && configuration.files.autoSaveDelay;\n                    this.configuredAutoSaveOnFocusChange = false;\n                    this.configuredAutoSaveOnWindowChange = false;\n                    break;\n                case files_1.AutoSaveConfiguration.ON_FOCUS_CHANGE:\n                    this.configuredAutoSaveDelay = undefined;\n                    this.configuredAutoSaveOnFocusChange = true;\n                    this.configuredAutoSaveOnWindowChange = false;\n                    break;\n                case files_1.AutoSaveConfiguration.ON_WINDOW_CHANGE:\n                    this.configuredAutoSaveDelay = undefined;\n                    this.configuredAutoSaveOnFocusChange = false;\n                    this.configuredAutoSaveOnWindowChange = true;\n                    break;\n                default:\n                    this.configuredAutoSaveDelay = undefined;\n                    this.configuredAutoSaveOnFocusChange = false;\n                    this.configuredAutoSaveOnWindowChange = false;\n                    break;\n            }\n            // Emit as event\n            this._onAutoSaveConfigurationChange.fire(this.getAutoSaveConfiguration());\n            // save all dirty when enabling auto save\n            if (!wasAutoSaveEnabled && this.getAutoSaveMode() !== textfiles_1.AutoSaveMode.OFF) {\n                this.saveAll();\n            }\n            // Check for change in files associations\n            const filesAssociation = configuration && configuration.files && configuration.files.associations;\n            if (!objects.equals(this.currentFilesAssociationConfig, filesAssociation)) {\n                this.currentFilesAssociationConfig = filesAssociation;\n                this._onFilesAssociationChange.fire();\n            }\n            // Hot exit\n            const hotExitMode = configuration && configuration.files && configuration.files.hotExit;\n            if (hotExitMode === files_1.HotExitConfiguration.OFF || hotExitMode === files_1.HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {\n                this.configuredHotExit = hotExitMode;\n            }\n            else {\n                this.configuredHotExit = files_1.HotExitConfiguration.ON_EXIT;\n            }\n        }\n        getDirty(resources) {\n            // Collect files\n            const dirty = this.getDirtyFileModels(resources).map(m => m.getResource());\n            // Add untitled ones\n            dirty.push(...this.untitledEditorService.getDirty(resources));\n            return dirty;\n        }\n        isDirty(resource) {\n            // Check for dirty file\n            if (this._models.getAll(resource).some(model => model.isDirty())) {\n                return true;\n            }\n            // Check for dirty untitled\n            return this.untitledEditorService.getDirty().some(dirty => !resource || dirty.toString() === resource.toString());\n        }\n        save(resource, options) {\n            // Run a forced save if we detect the file is not dirty so that save participants can still run\n            if (options && options.force && this.fileService.canHandleResource(resource) && !this.isDirty(resource)) {\n                const model = this._models.get(resource);\n                if (model) {\n                    options.reason = textfiles_1.SaveReason.EXPLICIT;\n                    return model.save(options).then(() => !model.isDirty());\n                }\n            }\n            return this.saveAll([resource], options).then(result => result.results.length === 1 && !!result.results[0].success);\n        }\n        saveAll(arg1, options) {\n            // get all dirty\n            let toSave = [];\n            if (Array.isArray(arg1)) {\n                toSave = this.getDirty(arg1);\n            }\n            else {\n                toSave = this.getDirty();\n            }\n            // split up between files and untitled\n            const filesToSave = [];\n            const untitledToSave = [];\n            toSave.forEach(s => {\n                if ((Array.isArray(arg1) || arg1 === true /* includeUntitled */) && s.scheme === network_1.Schemas.untitled) {\n                    untitledToSave.push(s);\n                }\n                else {\n                    filesToSave.push(s);\n                }\n            });\n            return this.doSaveAll(filesToSave, untitledToSave, options);\n        }\n        doSaveAll(fileResources, untitledResources, options) {\n            // Handle files first that can just be saved\n            return this.doSaveAllFiles(fileResources, options).then((result) => __awaiter(this, void 0, void 0, function* () {\n                // Preflight for untitled to handle cancellation from the dialog\n                const targetsForUntitled = [];\n                for (const untitled of untitledResources) {\n                    if (this.untitledEditorService.exists(untitled)) {\n                        let targetUri;\n                        // Untitled with associated file path don't need to prompt\n                        if (this.untitledEditorService.hasAssociatedFilePath(untitled)) {\n                            targetUri = this.untitledToAssociatedFileResource(untitled);\n                        }\n                        // Otherwise ask user\n                        else {\n                            const targetPath = yield this.promptForPath(untitled, this.suggestFileName(untitled));\n                            if (!targetPath) {\n                                return Promise.resolve({\n                                    results: [...fileResources, ...untitledResources].map(r => ({ source: r }))\n                                });\n                            }\n                            targetUri = targetPath;\n                        }\n                        targetsForUntitled.push(targetUri);\n                    }\n                }\n                // Handle untitled\n                const untitledSaveAsPromises = [];\n                targetsForUntitled.forEach((target, index) => {\n                    const untitledSaveAsPromise = this.saveAs(untitledResources[index], target).then(uri => {\n                        result.results.push({\n                            source: untitledResources[index],\n                            target: uri,\n                            success: !!uri\n                        });\n                    });\n                    untitledSaveAsPromises.push(untitledSaveAsPromise);\n                });\n                return Promise.all(untitledSaveAsPromises).then(() => result);\n            }));\n        }\n        untitledToAssociatedFileResource(untitled) {\n            const authority = this.windowService.getConfiguration().remoteAuthority;\n            if (authority) {\n                let path = untitled.path;\n                if (path && path[0] !== '/') {\n                    path = '/' + path;\n                }\n                return untitled.with({ scheme: remoteHosts_1.REMOTE_HOST_SCHEME, authority, path });\n            }\n            return untitled.with({ scheme: network_1.Schemas.file });\n        }\n        doSaveAllFiles(resources, options = Object.create(null)) {\n            const dirtyFileModels = this.getDirtyFileModels(Array.isArray(resources) ? resources : undefined /* Save All */)\n                .filter(model => {\n                if ((model.hasState(textfiles_1.ModelState.CONFLICT) || model.hasState(textfiles_1.ModelState.ERROR)) && (options.reason === textfiles_1.SaveReason.AUTO || options.reason === textfiles_1.SaveReason.FOCUS_CHANGE || options.reason === textfiles_1.SaveReason.WINDOW_CHANGE)) {\n                    return false; // if model is in save conflict or error, do not save unless save reason is explicit or not provided at all\n                }\n                return true;\n            });\n            const mapResourceToResult = new map_1.ResourceMap();\n            dirtyFileModels.forEach(m => {\n                mapResourceToResult.set(m.getResource(), {\n                    source: m.getResource()\n                });\n            });\n            return Promise.all(dirtyFileModels.map(model => {\n                return model.save(options).then(() => {\n                    if (!model.isDirty()) {\n                        const result = mapResourceToResult.get(model.getResource());\n                        if (result) {\n                            result.success = true;\n                        }\n                    }\n                });\n            })).then(r => ({ results: mapResourceToResult.values() }));\n        }\n        getFileModels(arg1) {\n            if (Array.isArray(arg1)) {\n                const models = [];\n                arg1.forEach(resource => {\n                    models.push(...this.getFileModels(resource));\n                });\n                return models;\n            }\n            return this._models.getAll(arg1);\n        }\n        getDirtyFileModels(arg1) {\n            return this.getFileModels(arg1).filter(model => model.isDirty());\n        }\n        saveAs(resource, target, options) {\n            // Get to target resource\n            let targetPromise;\n            if (target) {\n                targetPromise = Promise.resolve(target);\n            }\n            else {\n                let dialogPath = resource;\n                if (resource.scheme === network_1.Schemas.untitled) {\n                    dialogPath = this.suggestFileName(resource);\n                }\n                targetPromise = this.promptForPath(resource, dialogPath);\n            }\n            return targetPromise.then(target => {\n                if (!target) {\n                    return undefined; // user canceled\n                }\n                // Just save if target is same as models own resource\n                if (resource.toString() === target.toString()) {\n                    return this.save(resource, options).then(() => resource);\n                }\n                // Do it\n                return this.doSaveAs(resource, target, options);\n            });\n        }\n        doSaveAs(resource, target, options) {\n            // Retrieve text model from provided resource if any\n            let modelPromise = Promise.resolve(undefined);\n            if (this.fileService.canHandleResource(resource)) {\n                modelPromise = Promise.resolve(this._models.get(resource));\n            }\n            else if (resource.scheme === network_1.Schemas.untitled && this.untitledEditorService.exists(resource)) {\n                modelPromise = this.untitledEditorService.loadOrCreate({ resource });\n            }\n            return modelPromise.then(model => {\n                // We have a model: Use it (can be null e.g. if this file is binary and not a text file or was never opened before)\n                if (model) {\n                    return this.doSaveTextFileAs(model, resource, target, options);\n                }\n                // Otherwise we can only copy\n                return this.fileService.copyFile(resource, target).then(() => true);\n            }).then(result => {\n                // Return early if the operation was not running\n                if (!result) {\n                    return target;\n                }\n                // Revert the source\n                return this.revert(resource).then(() => {\n                    // Done: return target\n                    return target;\n                });\n            });\n        }\n        doSaveTextFileAs(sourceModel, resource, target, options) {\n            let targetModelResolver;\n            let targetExists = false;\n            // Prefer an existing model if it is already loaded for the given target resource\n            const targetModel = this.models.get(target);\n            if (targetModel && targetModel.isResolved()) {\n                targetModelResolver = Promise.resolve(targetModel);\n                targetExists = true;\n            }\n            // Otherwise create the target file empty if it does not exist already and resolve it from there\n            else {\n                targetModelResolver = this.fileService.existsFile(target).then(exists => {\n                    targetExists = exists;\n                    // create target model adhoc if file does not exist yet\n                    if (!targetExists) {\n                        return this.fileService.updateContent(target, '');\n                    }\n                    return undefined;\n                }).then(() => this.models.loadOrCreate(target));\n            }\n            return targetModelResolver.then(targetModel => {\n                // Confirm to overwrite if we have an untitled file with associated file where\n                // the file actually exists on disk and we are instructed to save to that file\n                // path. This can happen if the file was created after the untitled file was opened.\n                // See https://github.com/Microsoft/vscode/issues/67946\n                let confirmWrite;\n                if (sourceModel instanceof untitledEditorModel_1.UntitledEditorModel && sourceModel.hasAssociatedFilePath && targetExists && resources_1.isEqual(target, this.untitledToAssociatedFileResource(sourceModel.getResource()))) {\n                    confirmWrite = this.confirmOverwrite(target);\n                }\n                else {\n                    confirmWrite = Promise.resolve(true);\n                }\n                return confirmWrite.then(write => {\n                    if (!write) {\n                        return false;\n                    }\n                    // take over encoding and model value from source model\n                    targetModel.updatePreferredEncoding(sourceModel.getEncoding());\n                    if (targetModel.textEditorModel) {\n                        const snapshot = sourceModel.createSnapshot();\n                        if (snapshot) {\n                            this.modelService.updateModel(targetModel.textEditorModel, textModel_1.createTextBufferFactoryFromSnapshot(snapshot));\n                        }\n                    }\n                    // save model\n                    return targetModel.save(options).then(() => true);\n                });\n            }, error => {\n                // binary model: delete the file and run the operation again\n                if (error.fileOperationResult === files_1.FileOperationResult.FILE_IS_BINARY || error.fileOperationResult === files_1.FileOperationResult.FILE_TOO_LARGE) {\n                    return this.fileService.del(target).then(() => this.doSaveTextFileAs(sourceModel, resource, target, options));\n                }\n                return Promise.reject(error);\n            });\n        }\n        suggestFileName(untitledResource) {\n            const untitledFileName = this.untitledEditorService.suggestFileName(untitledResource);\n            const remoteAuthority = this.windowService.getConfiguration().remoteAuthority;\n            const schemeFilter = remoteAuthority ? remoteHosts_1.REMOTE_HOST_SCHEME : network_1.Schemas.file;\n            const lastActiveFile = this.historyService.getLastActiveFile(schemeFilter);\n            if (lastActiveFile) {\n                const lastDir = resources_1.dirname(lastActiveFile);\n                return resources_1.joinPath(lastDir, untitledFileName);\n            }\n            const lastActiveFolder = this.historyService.getLastActiveWorkspaceRoot(schemeFilter);\n            if (lastActiveFolder) {\n                return resources_1.joinPath(lastActiveFolder, untitledFileName);\n            }\n            return schemeFilter === network_1.Schemas.file ? uri_1.URI.file(untitledFileName) : uri_1.URI.from({ scheme: schemeFilter, authority: remoteAuthority, path: '/' + untitledFileName });\n        }\n        revert(resource, options) {\n            return this.revertAll([resource], options).then(result => result.results.length === 1 && !!result.results[0].success);\n        }\n        revertAll(resources, options) {\n            // Revert files first\n            return this.doRevertAllFiles(resources, options).then(operation => {\n                // Revert untitled\n                const reverted = this.untitledEditorService.revertAll(resources);\n                reverted.forEach(res => operation.results.push({ source: res, success: true }));\n                return operation;\n            });\n        }\n        doRevertAllFiles(resources, options) {\n            const fileModels = options && options.force ? this.getFileModels(resources) : this.getDirtyFileModels(resources);\n            const mapResourceToResult = new map_1.ResourceMap();\n            fileModels.forEach(m => {\n                mapResourceToResult.set(m.getResource(), {\n                    source: m.getResource()\n                });\n            });\n            return Promise.all(fileModels.map(model => {\n                return model.revert(options && options.soft).then(() => {\n                    if (!model.isDirty()) {\n                        const result = mapResourceToResult.get(model.getResource());\n                        if (result) {\n                            result.success = true;\n                        }\n                    }\n                }, error => {\n                    // FileNotFound means the file got deleted meanwhile, so still record as successful revert\n                    if (error.fileOperationResult === files_1.FileOperationResult.FILE_NOT_FOUND) {\n                        const result = mapResourceToResult.get(model.getResource());\n                        if (result) {\n                            result.success = true;\n                        }\n                    }\n                    // Otherwise bubble up the error\n                    else {\n                        return Promise.reject(error);\n                    }\n                    return undefined;\n                });\n            })).then(r => ({ results: mapResourceToResult.values() }));\n        }\n        create(resource, contents, options) {\n            const existingModel = this.models.get(resource);\n            return this.fileService.createFile(resource, contents, options).then(() => {\n                // If we had an existing model for the given resource, load\n                // it again to make sure it is up to date with the contents\n                // we just wrote into the underlying resource by calling\n                // revert()\n                if (existingModel && !existingModel.isDisposed()) {\n                    return existingModel.revert();\n                }\n                return undefined;\n            });\n        }\n        delete(resource, options) {\n            const dirtyFiles = this.getDirty().filter(dirty => resources_1.isEqualOrParent(dirty, resource, !platform.isLinux /* ignorecase */));\n            return this.revertAll(dirtyFiles, { soft: true }).then(() => this.fileService.del(resource, options));\n        }\n        move(source, target, overwrite) {\n            const waitForPromises = [];\n            // Event\n            this._onWillMove.fire({\n                oldResource: source,\n                newResource: target,\n                waitUntil(promise) {\n                    waitForPromises.push(promise.then(undefined, errors.onUnexpectedError));\n                }\n            });\n            // prevent async waitUntil-calls\n            Object.freeze(waitForPromises);\n            return Promise.all(waitForPromises).then(() => {\n                // Handle target models if existing (if target URI is a folder, this can be multiple)\n                let handleTargetModelPromise = Promise.resolve();\n                const dirtyTargetModels = this.getDirtyFileModels().filter(model => resources_1.isEqualOrParent(model.getResource(), target, false /* do not ignorecase, see https://github.com/Microsoft/vscode/issues/56384 */));\n                if (dirtyTargetModels.length) {\n                    handleTargetModelPromise = this.revertAll(dirtyTargetModels.map(targetModel => targetModel.getResource()), { soft: true });\n                }\n                return handleTargetModelPromise.then(() => {\n                    // Handle dirty source models if existing (if source URI is a folder, this can be multiple)\n                    let handleDirtySourceModels;\n                    const dirtySourceModels = this.getDirtyFileModels().filter(model => resources_1.isEqualOrParent(model.getResource(), source, !platform.isLinux /* ignorecase */));\n                    const dirtyTargetModels = [];\n                    if (dirtySourceModels.length) {\n                        handleDirtySourceModels = Promise.all(dirtySourceModels.map(sourceModel => {\n                            const sourceModelResource = sourceModel.getResource();\n                            let targetModelResource;\n                            // If the source is the actual model, just use target as new resource\n                            if (resources_1.isEqual(sourceModelResource, source, !platform.isLinux /* ignorecase */)) {\n                                targetModelResource = target;\n                            }\n                            // Otherwise a parent folder of the source is being moved, so we need\n                            // to compute the target resource based on that\n                            else {\n                                targetModelResource = sourceModelResource.with({ path: resources_1.joinPath(target, sourceModelResource.path.substr(source.path.length + 1)).path });\n                            }\n                            // Remember as dirty target model to load after the operation\n                            dirtyTargetModels.push(targetModelResource);\n                            // Backup dirty source model to the target resource it will become later\n                            const snapshot = sourceModel.createSnapshot();\n                            if (snapshot) {\n                                return this.backupFileService.backupResource(targetModelResource, snapshot, sourceModel.getVersionId());\n                            }\n                            return Promise.resolve();\n                        }));\n                    }\n                    else {\n                        handleDirtySourceModels = Promise.resolve();\n                    }\n                    return handleDirtySourceModels.then(() => {\n                        // Soft revert the dirty source files if any\n                        return this.revertAll(dirtySourceModels.map(dirtySourceModel => dirtySourceModel.getResource()), { soft: true }).then(() => {\n                            // Rename to target\n                            return this.fileService.moveFile(source, target, overwrite).then(() => {\n                                // Load models that were dirty before\n                                return Promise.all(dirtyTargetModels.map(dirtyTargetModel => this.models.loadOrCreate(dirtyTargetModel))).then(() => undefined);\n                            }, error => {\n                                // In case of an error, discard any dirty target backups that were made\n                                return Promise.all(dirtyTargetModels.map(dirtyTargetModel => this.backupFileService.discardResourceBackup(dirtyTargetModel)))\n                                    .then(() => Promise.reject(error));\n                            });\n                        });\n                    });\n                });\n            });\n        }\n        getAutoSaveMode() {\n            if (this.configuredAutoSaveOnFocusChange) {\n                return textfiles_1.AutoSaveMode.ON_FOCUS_CHANGE;\n            }\n            if (this.configuredAutoSaveOnWindowChange) {\n                return textfiles_1.AutoSaveMode.ON_WINDOW_CHANGE;\n            }\n            if (this.configuredAutoSaveDelay && this.configuredAutoSaveDelay > 0) {\n                return this.configuredAutoSaveDelay <= 1000 ? textfiles_1.AutoSaveMode.AFTER_SHORT_DELAY : textfiles_1.AutoSaveMode.AFTER_LONG_DELAY;\n            }\n            return textfiles_1.AutoSaveMode.OFF;\n        }\n        getAutoSaveConfiguration() {\n            return {\n                autoSaveDelay: this.configuredAutoSaveDelay && this.configuredAutoSaveDelay > 0 ? this.configuredAutoSaveDelay : undefined,\n                autoSaveFocusChange: this.configuredAutoSaveOnFocusChange,\n                autoSaveApplicationChange: this.configuredAutoSaveOnWindowChange\n            };\n        }\n        get isHotExitEnabled() {\n            return !this.environmentService.isExtensionDevelopment && this.configuredHotExit !== files_1.HotExitConfiguration.OFF;\n        }\n        dispose() {\n            // Clear all caches\n            this._models.clear();\n            super.dispose();\n        }\n    };\n    TextFileService = __decorate([\n        __param(0, workspace_1.IWorkspaceContextService),\n        __param(1, files_1.IFileService),\n        __param(2, untitledEditorService_1.IUntitledEditorService),\n        __param(3, lifecycle_1.ILifecycleService),\n        __param(4, instantiation_1.IInstantiationService),\n        __param(5, configuration_1.IConfigurationService),\n        __param(6, modeService_1.IModeService),\n        __param(7, modelService_1.IModelService),\n        __param(8, windows_1.IWindowService),\n        __param(9, environment_1.IEnvironmentService),\n        __param(10, notification_1.INotificationService),\n        __param(11, backup_1.IBackupFileService),\n        __param(12, windows_1.IWindowsService),\n        __param(13, history_1.IHistoryService),\n        __param(14, contextkey_1.IContextKeyService),\n        __param(15, dialogs_1.IDialogService),\n        __param(16, dialogs_1.IFileDialogService),\n        __param(17, editorService_1.IEditorService)\n    ], TextFileService);\n    exports.TextFileService = TextFileService;\n    extensions_1.registerSingleton(textfiles_1.ITextFileService, TextFileService);\n});\n",null]}