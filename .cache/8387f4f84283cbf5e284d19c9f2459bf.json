{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/browser/editor.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/browser/editor.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar platform_1 = require(\"vs/platform/registry/common/platform\");\nvar baseEditor_1 = require(\"vs/workbench/browser/parts/editor/baseEditor\");\nvar types_1 = require(\"vs/base/common/types\");\n/**\n * A lightweight descriptor of an editor. The descriptor is deferred so that heavy editors\n * can load lazily in the workbench.\n */\nvar EditorDescriptor = /** @class */ (function () {\n    function EditorDescriptor(ctor, id, name) {\n        this.ctor = ctor;\n        this.id = id;\n        this.name = name;\n    }\n    EditorDescriptor.prototype.instantiate = function (instantiationService) {\n        return instantiationService.createInstance(this.ctor);\n    };\n    EditorDescriptor.prototype.getId = function () {\n        return this.id;\n    };\n    EditorDescriptor.prototype.getName = function () {\n        return this.name;\n    };\n    EditorDescriptor.prototype.describes = function (obj) {\n        return obj instanceof baseEditor_1.BaseEditor && obj.getId() === this.id;\n    };\n    return EditorDescriptor;\n}());\nexports.EditorDescriptor = EditorDescriptor;\nvar INPUT_DESCRIPTORS_PROPERTY = '__$inputDescriptors';\nvar EditorRegistry = /** @class */ (function () {\n    function EditorRegistry() {\n        this.editors = [];\n    }\n    EditorRegistry.prototype.registerEditor = function (descriptor, editorInputDescriptor) {\n        // Support both non-array and array parameter\n        var inputDescriptors = [];\n        if (!types_1.isArray(editorInputDescriptor)) {\n            inputDescriptors.push(editorInputDescriptor);\n        }\n        else {\n            inputDescriptors = editorInputDescriptor;\n        }\n        // Register (Support multiple Editors per Input)\n        descriptor[INPUT_DESCRIPTORS_PROPERTY] = inputDescriptors;\n        this.editors.push(descriptor);\n    };\n    EditorRegistry.prototype.getEditor = function (input) {\n        var _this = this;\n        var findEditorDescriptors = function (input, byInstanceOf) {\n            var matchingDescriptors = [];\n            for (var _i = 0, _a = _this.editors; _i < _a.length; _i++) {\n                var editor = _a[_i];\n                var inputDescriptors = editor[INPUT_DESCRIPTORS_PROPERTY];\n                for (var _b = 0, inputDescriptors_1 = inputDescriptors; _b < inputDescriptors_1.length; _b++) {\n                    var inputDescriptor = inputDescriptors_1[_b];\n                    var inputClass = inputDescriptor.ctor;\n                    // Direct check on constructor type (ignores prototype chain)\n                    if (!byInstanceOf && input.constructor === inputClass) {\n                        matchingDescriptors.push(editor);\n                        break;\n                    }\n                    // Normal instanceof check\n                    else if (byInstanceOf && input instanceof inputClass) {\n                        matchingDescriptors.push(editor);\n                        break;\n                    }\n                }\n            }\n            // If no descriptors found, continue search using instanceof and prototype chain\n            if (!byInstanceOf && matchingDescriptors.length === 0) {\n                return findEditorDescriptors(input, true);\n            }\n            if (byInstanceOf) {\n                return matchingDescriptors;\n            }\n            return matchingDescriptors;\n        };\n        var descriptors = findEditorDescriptors(input);\n        if (descriptors && descriptors.length > 0) {\n            // Ask the input for its preferred Editor\n            var preferredEditorId = input.getPreferredEditorId(descriptors.map(function (d) { return d.getId(); }));\n            if (preferredEditorId) {\n                return this.getEditorById(preferredEditorId);\n            }\n            // Otherwise, first come first serve\n            return descriptors[0];\n        }\n        return null;\n    };\n    EditorRegistry.prototype.getEditorById = function (editorId) {\n        for (var _i = 0, _a = this.editors; _i < _a.length; _i++) {\n            var editor = _a[_i];\n            if (editor.getId() === editorId) {\n                return editor;\n            }\n        }\n        return null;\n    };\n    EditorRegistry.prototype.getEditors = function () {\n        return this.editors.slice(0);\n    };\n    EditorRegistry.prototype.setEditors = function (editorsToSet) {\n        this.editors = editorsToSet;\n    };\n    EditorRegistry.prototype.getEditorInputs = function () {\n        var inputClasses = [];\n        for (var _i = 0, _a = this.editors; _i < _a.length; _i++) {\n            var editor = _a[_i];\n            var editorInputDescriptors = editor[INPUT_DESCRIPTORS_PROPERTY];\n            inputClasses.push.apply(inputClasses, editorInputDescriptors.map(function (descriptor) { return descriptor.ctor; }));\n        }\n        return inputClasses;\n    };\n    return EditorRegistry;\n}());\nexports.Extensions = {\n    Editors: 'workbench.contributions.editors'\n};\nplatform_1.Registry.add(exports.Extensions.Editors, new EditorRegistry());\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/browser/editor.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/browser/editor.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;AAIhG,iEAAgE;AAChE,2EAA0E;AAE1E,8CAA+C;AAyC/C;;;GAGG;AACH;IAKC,0BAAY,IAAwC,EAAE,EAAU,EAAE,IAAY;QAC7E,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;QACb,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;IAClB,CAAC;IAED,sCAAW,GAAX,UAAY,oBAA2C;QACtD,OAAO,oBAAoB,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACvD,CAAC;IAED,gCAAK,GAAL;QACC,OAAO,IAAI,CAAC,EAAE,CAAC;IAChB,CAAC;IAED,kCAAO,GAAP;QACC,OAAO,IAAI,CAAC,IAAI,CAAC;IAClB,CAAC;IAED,oCAAS,GAAT,UAAU,GAAQ;QACjB,OAAO,GAAG,YAAY,uBAAU,IAAiB,GAAI,CAAC,KAAK,EAAE,KAAK,IAAI,CAAC,EAAE,CAAC;IAC3E,CAAC;IACF,uBAAC;AAAD,CAAC,AA1BD,IA0BC;AA1BY,4CAAgB;AA4B7B,IAAM,0BAA0B,GAAG,qBAAqB,CAAC;AAEzD;IAAA;QACS,YAAO,GAAuB,EAAE,CAAC;IAiG1C,CAAC;IA7FA,uCAAc,GAAd,UAAe,UAA4B,EAAE,qBAA0B;QAEtE,6CAA6C;QAC7C,IAAI,gBAAgB,GAAkC,EAAE,CAAC;QACzD,IAAI,CAAC,eAAO,CAAC,qBAAqB,CAAC,EAAE;YACpC,gBAAgB,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC;SAC7C;aAAM;YACN,gBAAgB,GAAG,qBAAqB,CAAC;SACzC;QAED,gDAAgD;QAChD,UAAU,CAAC,0BAA0B,CAAC,GAAG,gBAAgB,CAAC;QAC1D,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IAC/B,CAAC;IAED,kCAAS,GAAT,UAAU,KAAkB;QAA5B,iBAiDC;QAhDA,IAAM,qBAAqB,GAAG,UAAC,KAAkB,EAAE,YAAsB;YACxE,IAAM,mBAAmB,GAAuB,EAAE,CAAC;YAEnD,KAAqB,UAAY,EAAZ,KAAA,KAAI,CAAC,OAAO,EAAZ,cAAY,EAAZ,IAAY,EAAE;gBAA9B,IAAM,MAAM,SAAA;gBAChB,IAAM,gBAAgB,GAAkC,MAAM,CAAC,0BAA0B,CAAC,CAAC;gBAC3F,KAA8B,UAAgB,EAAhB,qCAAgB,EAAhB,8BAAgB,EAAhB,IAAgB,EAAE;oBAA3C,IAAM,eAAe,yBAAA;oBACzB,IAAM,UAAU,GAAG,eAAe,CAAC,IAAI,CAAC;oBAExC,6DAA6D;oBAC7D,IAAI,CAAC,YAAY,IAAI,KAAK,CAAC,WAAW,KAAK,UAAU,EAAE;wBACtD,mBAAmB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;wBACjC,MAAM;qBACN;oBAED,0BAA0B;yBACrB,IAAI,YAAY,IAAI,KAAK,YAAY,UAAU,EAAE;wBACrD,mBAAmB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;wBACjC,MAAM;qBACN;iBACD;aACD;YAED,gFAAgF;YAChF,IAAI,CAAC,YAAY,IAAI,mBAAmB,CAAC,MAAM,KAAK,CAAC,EAAE;gBACtD,OAAO,qBAAqB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;aAC1C;YAED,IAAI,YAAY,EAAE;gBACjB,OAAO,mBAAmB,CAAC;aAC3B;YAED,OAAO,mBAAmB,CAAC;QAC5B,CAAC,CAAC;QAEF,IAAM,WAAW,GAAG,qBAAqB,CAAC,KAAK,CAAC,CAAC;QACjD,IAAI,WAAW,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE;YAE1C,yCAAyC;YACzC,IAAM,iBAAiB,GAAG,KAAK,CAAC,oBAAoB,CAAC,WAAW,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,KAAK,EAAE,EAAT,CAAS,CAAC,CAAC,CAAC;YACtF,IAAI,iBAAiB,EAAE;gBACtB,OAAO,IAAI,CAAC,aAAa,CAAC,iBAAiB,CAAC,CAAC;aAC7C;YAED,oCAAoC;YACpC,OAAO,WAAW,CAAC,CAAC,CAAC,CAAC;SACtB;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IAED,sCAAa,GAAb,UAAc,QAAgB;QAC7B,KAAqB,UAAY,EAAZ,KAAA,IAAI,CAAC,OAAO,EAAZ,cAAY,EAAZ,IAAY,EAAE;YAA9B,IAAM,MAAM,SAAA;YAChB,IAAI,MAAM,CAAC,KAAK,EAAE,KAAK,QAAQ,EAAE;gBAChC,OAAO,MAAM,CAAC;aACd;SACD;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IAED,mCAAU,GAAV;QACC,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC9B,CAAC;IAED,mCAAU,GAAV,UAAW,YAAgC;QAC1C,IAAI,CAAC,OAAO,GAAG,YAAY,CAAC;IAC7B,CAAC;IAED,wCAAe,GAAf;QACC,IAAM,YAAY,GAAkC,EAAE,CAAC;QACvD,KAAqB,UAAY,EAAZ,KAAA,IAAI,CAAC,OAAO,EAAZ,cAAY,EAAZ,IAAY,EAAE;YAA9B,IAAM,MAAM,SAAA;YAChB,IAAM,sBAAsB,GAAkC,MAAM,CAAC,0BAA0B,CAAC,CAAC;YACjG,YAAY,CAAC,IAAI,OAAjB,YAAY,EAAS,sBAAsB,CAAC,GAAG,CAAC,UAAA,UAAU,IAAI,OAAA,UAAU,CAAC,IAAI,EAAf,CAAe,CAAC,EAAE;SAChF;QAED,OAAO,YAAY,CAAC;IACrB,CAAC;IACF,qBAAC;AAAD,CAAC,AAlGD,IAkGC;AAEY,QAAA,UAAU,GAAG;IACzB,OAAO,EAAE,iCAAiC;CAC1C,CAAC;AAEF,mBAAQ,CAAC,GAAG,CAAC,kBAAU,CAAC,OAAO,EAAE,IAAI,cAAc,EAAE,CAAC,CAAC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { EditorInput } from 'vs/workbench/common/editor';\nimport { SyncDescriptor } from 'vs/platform/instantiation/common/descriptors';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport { BaseEditor } from 'vs/workbench/browser/parts/editor/baseEditor';\nimport { IConstructorSignature0, IInstantiationService } from 'vs/platform/instantiation/common/instantiation';\nimport { isArray } from 'vs/base/common/types';\n\nexport interface IEditorDescriptor {\n\tinstantiate(instantiationService: IInstantiationService): BaseEditor;\n\n\tgetId(): string;\n\tgetName(): string;\n\n\tdescribes(obj: any): boolean;\n}\n\nexport interface IEditorRegistry {\n\n\t/**\n\t * Registers an editor to the platform for the given input type. The second parameter also supports an\n\t * array of input classes to be passed in. If the more than one editor is registered for the same editor\n\t * input, the input itself will be asked which editor it prefers if this method is provided. Otherwise\n\t * the first editor in the list will be returned.\n\t *\n\t * @param editorInputDescriptor a constructor function that returns an instance of EditorInput for which the\n\t * registered editor should be used for.\n\t */\n\tregisterEditor(descriptor: IEditorDescriptor, editorInputDescriptor: SyncDescriptor<EditorInput>): void;\n\tregisterEditor(descriptor: IEditorDescriptor, editorInputDescriptor: SyncDescriptor<EditorInput>[]): void;\n\n\t/**\n\t * Returns the editor descriptor for the given input or null if none.\n\t */\n\tgetEditor(input: EditorInput): IEditorDescriptor | null;\n\n\t/**\n\t * Returns the editor descriptor for the given identifier or null if none.\n\t */\n\tgetEditorById(editorId: string): IEditorDescriptor | null;\n\n\t/**\n\t * Returns an array of registered editors known to the platform.\n\t */\n\tgetEditors(): IEditorDescriptor[];\n}\n\n/**\n * A lightweight descriptor of an editor. The descriptor is deferred so that heavy editors\n * can load lazily in the workbench.\n */\nexport class EditorDescriptor implements IEditorDescriptor {\n\tprivate ctor: IConstructorSignature0<BaseEditor>;\n\tprivate id: string;\n\tprivate name: string;\n\n\tconstructor(ctor: IConstructorSignature0<BaseEditor>, id: string, name: string) {\n\t\tthis.ctor = ctor;\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\n\tinstantiate(instantiationService: IInstantiationService): BaseEditor {\n\t\treturn instantiationService.createInstance(this.ctor);\n\t}\n\n\tgetId(): string {\n\t\treturn this.id;\n\t}\n\n\tgetName(): string {\n\t\treturn this.name;\n\t}\n\n\tdescribes(obj: any): boolean {\n\t\treturn obj instanceof BaseEditor && (<BaseEditor>obj).getId() === this.id;\n\t}\n}\n\nconst INPUT_DESCRIPTORS_PROPERTY = '__$inputDescriptors';\n\nclass EditorRegistry implements IEditorRegistry {\n\tprivate editors: EditorDescriptor[] = [];\n\n\tregisterEditor(descriptor: EditorDescriptor, editorInputDescriptor: SyncDescriptor<EditorInput>): void;\n\tregisterEditor(descriptor: EditorDescriptor, editorInputDescriptor: SyncDescriptor<EditorInput>[]): void;\n\tregisterEditor(descriptor: EditorDescriptor, editorInputDescriptor: any): void {\n\n\t\t// Support both non-array and array parameter\n\t\tlet inputDescriptors: SyncDescriptor<EditorInput>[] = [];\n\t\tif (!isArray(editorInputDescriptor)) {\n\t\t\tinputDescriptors.push(editorInputDescriptor);\n\t\t} else {\n\t\t\tinputDescriptors = editorInputDescriptor;\n\t\t}\n\n\t\t// Register (Support multiple Editors per Input)\n\t\tdescriptor[INPUT_DESCRIPTORS_PROPERTY] = inputDescriptors;\n\t\tthis.editors.push(descriptor);\n\t}\n\n\tgetEditor(input: EditorInput): EditorDescriptor | null {\n\t\tconst findEditorDescriptors = (input: EditorInput, byInstanceOf?: boolean): EditorDescriptor[] => {\n\t\t\tconst matchingDescriptors: EditorDescriptor[] = [];\n\n\t\t\tfor (const editor of this.editors) {\n\t\t\t\tconst inputDescriptors = <SyncDescriptor<EditorInput>[]>editor[INPUT_DESCRIPTORS_PROPERTY];\n\t\t\t\tfor (const inputDescriptor of inputDescriptors) {\n\t\t\t\t\tconst inputClass = inputDescriptor.ctor;\n\n\t\t\t\t\t// Direct check on constructor type (ignores prototype chain)\n\t\t\t\t\tif (!byInstanceOf && input.constructor === inputClass) {\n\t\t\t\t\t\tmatchingDescriptors.push(editor);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Normal instanceof check\n\t\t\t\t\telse if (byInstanceOf && input instanceof inputClass) {\n\t\t\t\t\t\tmatchingDescriptors.push(editor);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If no descriptors found, continue search using instanceof and prototype chain\n\t\t\tif (!byInstanceOf && matchingDescriptors.length === 0) {\n\t\t\t\treturn findEditorDescriptors(input, true);\n\t\t\t}\n\n\t\t\tif (byInstanceOf) {\n\t\t\t\treturn matchingDescriptors;\n\t\t\t}\n\n\t\t\treturn matchingDescriptors;\n\t\t};\n\n\t\tconst descriptors = findEditorDescriptors(input);\n\t\tif (descriptors && descriptors.length > 0) {\n\n\t\t\t// Ask the input for its preferred Editor\n\t\t\tconst preferredEditorId = input.getPreferredEditorId(descriptors.map(d => d.getId()));\n\t\t\tif (preferredEditorId) {\n\t\t\t\treturn this.getEditorById(preferredEditorId);\n\t\t\t}\n\n\t\t\t// Otherwise, first come first serve\n\t\t\treturn descriptors[0];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tgetEditorById(editorId: string): EditorDescriptor | null {\n\t\tfor (const editor of this.editors) {\n\t\t\tif (editor.getId() === editorId) {\n\t\t\t\treturn editor;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tgetEditors(): EditorDescriptor[] {\n\t\treturn this.editors.slice(0);\n\t}\n\n\tsetEditors(editorsToSet: EditorDescriptor[]): void {\n\t\tthis.editors = editorsToSet;\n\t}\n\n\tgetEditorInputs(): SyncDescriptor<EditorInput>[] {\n\t\tconst inputClasses: SyncDescriptor<EditorInput>[] = [];\n\t\tfor (const editor of this.editors) {\n\t\t\tconst editorInputDescriptors: SyncDescriptor<EditorInput>[] = editor[INPUT_DESCRIPTORS_PROPERTY];\n\t\t\tinputClasses.push(...editorInputDescriptors.map(descriptor => descriptor.ctor));\n\t\t}\n\n\t\treturn inputClasses;\n\t}\n}\n\nexport const Extensions = {\n\tEditors: 'workbench.contributions.editors'\n};\n\nRegistry.add(Extensions.Editors, new EditorRegistry());"]}]}