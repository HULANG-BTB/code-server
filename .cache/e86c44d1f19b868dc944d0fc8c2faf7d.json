{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/zoneWidget/zoneWidget.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/zoneWidget/zoneWidget.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/browser/dom\", \"vs/base/browser/ui/sash/sash\", \"vs/base/common/color\", \"vs/base/common/idGenerator\", \"vs/base/common/lifecycle\", \"vs/base/common/objects\", \"vs/editor/common/core/range\", \"vs/editor/common/editorCommon\", \"vs/editor/common/model\", \"vs/editor/common/model/textModel\", \"vs/css!./zoneWidget\"], function (require, exports, dom, sash_1, color_1, idGenerator_1, lifecycle_1, objects, range_1, editorCommon_1, model_1, textModel_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const defaultColor = new color_1.Color(new color_1.RGBA(0, 122, 204));\n    const defaultOptions = {\n        showArrow: true,\n        showFrame: true,\n        className: '',\n        frameColor: defaultColor,\n        arrowColor: defaultColor,\n        keepEditorSelection: false\n    };\n    const WIDGET_ID = 'vs.editor.contrib.zoneWidget';\n    class ViewZoneDelegate {\n        constructor(domNode, afterLineNumber, afterColumn, heightInLines, onDomNodeTop, onComputedHeight) {\n            this.domNode = domNode;\n            this.afterLineNumber = afterLineNumber;\n            this.afterColumn = afterColumn;\n            this.heightInLines = heightInLines;\n            this._onDomNodeTop = onDomNodeTop;\n            this._onComputedHeight = onComputedHeight;\n        }\n        onDomNodeTop(top) {\n            this._onDomNodeTop(top);\n        }\n        onComputedHeight(height) {\n            this._onComputedHeight(height);\n        }\n    }\n    exports.ViewZoneDelegate = ViewZoneDelegate;\n    class OverlayWidgetDelegate {\n        constructor(id, domNode) {\n            this._id = id;\n            this._domNode = domNode;\n        }\n        getId() {\n            return this._id;\n        }\n        getDomNode() {\n            return this._domNode;\n        }\n        getPosition() {\n            return null;\n        }\n    }\n    exports.OverlayWidgetDelegate = OverlayWidgetDelegate;\n    class Arrow {\n        constructor(_editor) {\n            this._editor = _editor;\n            this._ruleName = Arrow._IdGenerator.nextId();\n            this._decorations = [];\n            //\n        }\n        dispose() {\n            this.hide();\n            dom.removeCSSRulesContainingSelector(this._ruleName);\n        }\n        set color(value) {\n            if (this._color !== value) {\n                this._color = value;\n                this._updateStyle();\n            }\n        }\n        set height(value) {\n            if (this._height !== value) {\n                this._height = value;\n                this._updateStyle();\n            }\n        }\n        _updateStyle() {\n            dom.removeCSSRulesContainingSelector(this._ruleName);\n            dom.createCSSRule(`.monaco-editor ${this._ruleName}`, `border-style: solid; border-color: transparent; border-bottom-color: ${this._color}; border-width: ${this._height}px; bottom: -${this._height}px; margin-left: -${this._height}px; `);\n        }\n        show(where) {\n            this._decorations = this._editor.deltaDecorations(this._decorations, [{ range: range_1.Range.fromPositions(where), options: { className: this._ruleName, stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges } }]);\n        }\n        hide() {\n            this._editor.deltaDecorations(this._decorations, []);\n        }\n    }\n    Arrow._IdGenerator = new idGenerator_1.IdGenerator('.arrow-decoration-');\n    class ZoneWidget {\n        constructor(editor, options = {}) {\n            this._positionMarkerId = [];\n            this._disposables = [];\n            this._isShowing = false;\n            this.editor = editor;\n            this.options = objects.deepClone(options);\n            objects.mixin(this.options, defaultOptions, false);\n            this.domNode = document.createElement('div');\n            if (!this.options.isAccessible) {\n                this.domNode.setAttribute('aria-hidden', 'true');\n                this.domNode.setAttribute('role', 'presentation');\n            }\n            this._disposables.push(this.editor.onDidLayoutChange((info) => {\n                const width = this._getWidth(info);\n                this.domNode.style.width = width + 'px';\n                this.domNode.style.left = this._getLeft(info) + 'px';\n                this._onWidth(width);\n            }));\n        }\n        dispose() {\n            lifecycle_1.dispose(this._disposables);\n            if (this._overlayWidget) {\n                this.editor.removeOverlayWidget(this._overlayWidget);\n                this._overlayWidget = null;\n            }\n            if (this._viewZone) {\n                this.editor.changeViewZones(accessor => {\n                    if (this._viewZone) {\n                        accessor.removeZone(this._viewZone.id);\n                    }\n                    this._viewZone = null;\n                });\n            }\n            this.editor.deltaDecorations(this._positionMarkerId, []);\n            this._positionMarkerId = [];\n        }\n        create() {\n            dom.addClass(this.domNode, 'zone-widget');\n            if (this.options.className) {\n                dom.addClass(this.domNode, this.options.className);\n            }\n            this.container = document.createElement('div');\n            dom.addClass(this.container, 'zone-widget-container');\n            this.domNode.appendChild(this.container);\n            if (this.options.showArrow) {\n                this._arrow = new Arrow(this.editor);\n                this._disposables.push(this._arrow);\n            }\n            this._fillContainer(this.container);\n            this._initSash();\n            this._applyStyles();\n        }\n        style(styles) {\n            if (styles.frameColor) {\n                this.options.frameColor = styles.frameColor;\n            }\n            if (styles.arrowColor) {\n                this.options.arrowColor = styles.arrowColor;\n            }\n            this._applyStyles();\n        }\n        _applyStyles() {\n            if (this.container && this.options.frameColor) {\n                let frameColor = this.options.frameColor.toString();\n                this.container.style.borderTopColor = frameColor;\n                this.container.style.borderBottomColor = frameColor;\n            }\n            if (this._arrow && this.options.arrowColor) {\n                let arrowColor = this.options.arrowColor.toString();\n                this._arrow.color = arrowColor;\n            }\n        }\n        _getWidth(info) {\n            return info.width - info.minimapWidth - info.verticalScrollbarWidth;\n        }\n        _getLeft(info) {\n            // If minimap is to the left, we move beyond it\n            if (info.minimapWidth > 0 && info.minimapLeft === 0) {\n                return info.minimapWidth;\n            }\n            return 0;\n        }\n        _onViewZoneTop(top) {\n            this.domNode.style.top = top + 'px';\n        }\n        _onViewZoneHeight(height) {\n            this.domNode.style.height = `${height}px`;\n            let containerHeight = height - this._decoratingElementsHeight();\n            this.container.style.height = `${containerHeight}px`;\n            const layoutInfo = this.editor.getLayoutInfo();\n            this._doLayout(containerHeight, this._getWidth(layoutInfo));\n            this._resizeSash.layout();\n        }\n        get position() {\n            const [id] = this._positionMarkerId;\n            if (!id) {\n                return undefined;\n            }\n            const model = this.editor.getModel();\n            if (!model) {\n                return undefined;\n            }\n            const range = model.getDecorationRange(id);\n            if (!range) {\n                return undefined;\n            }\n            return range.getStartPosition();\n        }\n        show(rangeOrPos, heightInLines) {\n            const range = range_1.Range.isIRange(rangeOrPos)\n                ? rangeOrPos\n                : new range_1.Range(rangeOrPos.lineNumber, rangeOrPos.column, rangeOrPos.lineNumber, rangeOrPos.column);\n            this._isShowing = true;\n            this._showImpl(range, heightInLines);\n            this._isShowing = false;\n            this._positionMarkerId = this.editor.deltaDecorations(this._positionMarkerId, [{ range, options: textModel_1.ModelDecorationOptions.EMPTY }]);\n        }\n        hide() {\n            if (this._viewZone) {\n                this.editor.changeViewZones(accessor => {\n                    if (this._viewZone) {\n                        accessor.removeZone(this._viewZone.id);\n                    }\n                });\n                this._viewZone = null;\n            }\n            if (this._overlayWidget) {\n                this.editor.removeOverlayWidget(this._overlayWidget);\n                this._overlayWidget = null;\n            }\n            if (this._arrow) {\n                this._arrow.hide();\n            }\n        }\n        _decoratingElementsHeight() {\n            let lineHeight = this.editor.getConfiguration().lineHeight;\n            let result = 0;\n            if (this.options.showArrow) {\n                let arrowHeight = Math.round(lineHeight / 3);\n                result += 2 * arrowHeight;\n            }\n            if (this.options.showFrame) {\n                let frameThickness = Math.round(lineHeight / 9);\n                result += 2 * frameThickness;\n            }\n            return result;\n        }\n        _showImpl(where, heightInLines) {\n            const position = {\n                lineNumber: where.startLineNumber,\n                column: where.startColumn\n            };\n            const layoutInfo = this.editor.getLayoutInfo();\n            const width = this._getWidth(layoutInfo);\n            this.domNode.style.width = `${width}px`;\n            this.domNode.style.left = this._getLeft(layoutInfo) + 'px';\n            // Render the widget as zone (rendering) and widget (lifecycle)\n            const viewZoneDomNode = document.createElement('div');\n            viewZoneDomNode.style.overflow = 'hidden';\n            const lineHeight = this.editor.getConfiguration().lineHeight;\n            // adjust heightInLines to viewport\n            const maxHeightInLines = (this.editor.getLayoutInfo().height / lineHeight) * 0.8;\n            if (heightInLines >= maxHeightInLines) {\n                heightInLines = maxHeightInLines;\n            }\n            let arrowHeight = 0;\n            let frameThickness = 0;\n            // Render the arrow one 1/3 of an editor line height\n            if (this.options.showArrow) {\n                arrowHeight = Math.round(lineHeight / 3);\n                this._arrow.height = arrowHeight;\n                this._arrow.show(position);\n            }\n            // Render the frame as 1/9 of an editor line height\n            if (this.options.showFrame) {\n                frameThickness = Math.round(lineHeight / 9);\n            }\n            // insert zone widget\n            this.editor.changeViewZones((accessor) => {\n                if (this._viewZone) {\n                    accessor.removeZone(this._viewZone.id);\n                }\n                if (this._overlayWidget) {\n                    this.editor.removeOverlayWidget(this._overlayWidget);\n                    this._overlayWidget = null;\n                }\n                this.domNode.style.top = '-1000px';\n                this._viewZone = new ViewZoneDelegate(viewZoneDomNode, position.lineNumber, position.column, heightInLines, (top) => this._onViewZoneTop(top), (height) => this._onViewZoneHeight(height));\n                this._viewZone.id = accessor.addZone(this._viewZone);\n                this._overlayWidget = new OverlayWidgetDelegate(WIDGET_ID + this._viewZone.id, this.domNode);\n                this.editor.addOverlayWidget(this._overlayWidget);\n            });\n            if (this.options.showFrame) {\n                const width = this.options.frameWidth ? this.options.frameWidth : frameThickness;\n                this.container.style.borderTopWidth = width + 'px';\n                this.container.style.borderBottomWidth = width + 'px';\n            }\n            let containerHeight = heightInLines * lineHeight - this._decoratingElementsHeight();\n            this.container.style.top = arrowHeight + 'px';\n            this.container.style.height = containerHeight + 'px';\n            this.container.style.overflow = 'hidden';\n            this._doLayout(containerHeight, width);\n            if (!this.options.keepEditorSelection) {\n                this.editor.setSelection(where);\n            }\n            const model = this.editor.getModel();\n            if (model) {\n                // Reveal the line above or below the zone widget, to get the zone widget in the viewport\n                const revealLineNumber = Math.min(model.getLineCount(), Math.max(1, where.endLineNumber + 1));\n                this.revealLine(revealLineNumber);\n            }\n        }\n        revealLine(lineNumber) {\n            this.editor.revealLine(lineNumber, editorCommon_1.ScrollType.Smooth);\n        }\n        setCssClass(className, classToReplace) {\n            if (classToReplace) {\n                this.container.classList.remove(classToReplace);\n            }\n            dom.addClass(this.container, className);\n        }\n        _onWidth(widthInPixel) {\n            // implement in subclass\n        }\n        _doLayout(heightInPixel, widthInPixel) {\n            // implement in subclass\n        }\n        _relayout(newHeightInLines) {\n            if (this._viewZone && this._viewZone.heightInLines !== newHeightInLines) {\n                this.editor.changeViewZones(accessor => {\n                    if (this._viewZone) {\n                        this._viewZone.heightInLines = newHeightInLines;\n                        accessor.layoutZone(this._viewZone.id);\n                    }\n                });\n            }\n        }\n        // --- sash\n        _initSash() {\n            this._resizeSash = new sash_1.Sash(this.domNode, this, { orientation: sash_1.Orientation.HORIZONTAL });\n            if (!this.options.isResizeable) {\n                this._resizeSash.hide();\n                this._resizeSash.state = sash_1.SashState.Disabled;\n            }\n            let data;\n            this._disposables.push(this._resizeSash.onDidStart((e) => {\n                if (this._viewZone) {\n                    data = {\n                        startY: e.startY,\n                        heightInLines: this._viewZone.heightInLines,\n                    };\n                }\n            }));\n            this._disposables.push(this._resizeSash.onDidEnd(() => {\n                data = undefined;\n            }));\n            this._disposables.push(this._resizeSash.onDidChange((evt) => {\n                if (data) {\n                    let lineDelta = (evt.currentY - data.startY) / this.editor.getConfiguration().lineHeight;\n                    let roundedLineDelta = lineDelta < 0 ? Math.ceil(lineDelta) : Math.floor(lineDelta);\n                    let newHeightInLines = data.heightInLines + roundedLineDelta;\n                    if (newHeightInLines > 5 && newHeightInLines < 35) {\n                        this._relayout(newHeightInLines);\n                    }\n                }\n            }));\n        }\n        getHorizontalSashLeft() {\n            return 0;\n        }\n        getHorizontalSashTop() {\n            return (this.domNode.style.height === null ? 0 : parseInt(this.domNode.style.height)) - (this._decoratingElementsHeight() / 2);\n        }\n        getHorizontalSashWidth() {\n            const layoutInfo = this.editor.getLayoutInfo();\n            return layoutInfo.width - layoutInfo.minimapWidth;\n        }\n    }\n    exports.ZoneWidget = ZoneWidget;\n});\n",null]}