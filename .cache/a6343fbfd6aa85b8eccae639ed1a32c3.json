{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/suggest/suggestMemory.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/suggest/suggestMemory.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/map\", \"vs/platform/storage/common/storage\", \"vs/editor/common/modes\", \"vs/base/common/lifecycle\", \"vs/base/common/async\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/configuration/common/configuration\", \"vs/platform/instantiation/common/extensions\"], function (require, exports, map_1, storage_1, modes_1, lifecycle_1, async_1, instantiation_1, configuration_1, extensions_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class Memory {\n        select(model, pos, items) {\n            if (items.length === 0) {\n                return 0;\n            }\n            let topScore = items[0].score;\n            for (let i = 1; i < items.length; i++) {\n                const { score, completion: suggestion } = items[i];\n                if (score !== topScore) {\n                    // stop when leaving the group of top matches\n                    break;\n                }\n                if (suggestion.preselect) {\n                    // stop when seeing an auto-select-item\n                    return i;\n                }\n            }\n            return 0;\n        }\n    }\n    exports.Memory = Memory;\n    class NoMemory extends Memory {\n        memorize(model, pos, item) {\n            // no-op\n        }\n        toJSON() {\n            return undefined;\n        }\n        fromJSON() {\n            //\n        }\n    }\n    exports.NoMemory = NoMemory;\n    class LRUMemory extends Memory {\n        constructor() {\n            super(...arguments);\n            this._cache = new map_1.LRUCache(300, 0.66);\n            this._seq = 0;\n        }\n        memorize(model, pos, item) {\n            const { label } = item.completion;\n            const key = `${model.getLanguageIdentifier().language}/${label}`;\n            this._cache.set(key, {\n                touch: this._seq++,\n                type: item.completion.kind,\n                insertText: item.completion.insertText\n            });\n        }\n        select(model, pos, items) {\n            // in order of completions, select the first\n            // that has been used in the past\n            let { word } = model.getWordUntilPosition(pos);\n            if (word.length !== 0) {\n                return super.select(model, pos, items);\n            }\n            let lineSuffix = model.getLineContent(pos.lineNumber).substr(pos.column - 10, pos.column - 1);\n            if (/\\s$/.test(lineSuffix)) {\n                return super.select(model, pos, items);\n            }\n            let res = -1;\n            let seq = -1;\n            for (let i = 0; i < items.length; i++) {\n                const { completion: suggestion } = items[i];\n                const key = `${model.getLanguageIdentifier().language}/${suggestion.label}`;\n                const item = this._cache.get(key);\n                if (item && item.touch > seq && item.type === suggestion.kind && item.insertText === suggestion.insertText) {\n                    seq = item.touch;\n                    res = i;\n                }\n            }\n            if (res === -1) {\n                return super.select(model, pos, items);\n            }\n            else {\n                return res;\n            }\n        }\n        toJSON() {\n            let data = [];\n            this._cache.forEach((value, key) => {\n                data.push([key, value]);\n            });\n            return data;\n        }\n        fromJSON(data) {\n            this._cache.clear();\n            let seq = 0;\n            for (const [key, value] of data) {\n                value.touch = seq;\n                value.type = typeof value.type === 'number' ? value.type : modes_1.completionKindFromString(value.type);\n                this._cache.set(key, value);\n            }\n            this._seq = this._cache.size;\n        }\n    }\n    exports.LRUMemory = LRUMemory;\n    class PrefixMemory extends Memory {\n        constructor() {\n            super(...arguments);\n            this._trie = map_1.TernarySearchTree.forStrings();\n            this._seq = 0;\n        }\n        memorize(model, pos, item) {\n            const { word } = model.getWordUntilPosition(pos);\n            const key = `${model.getLanguageIdentifier().language}/${word}`;\n            this._trie.set(key, {\n                type: item.completion.kind,\n                insertText: item.completion.insertText,\n                touch: this._seq++\n            });\n        }\n        select(model, pos, items) {\n            let { word } = model.getWordUntilPosition(pos);\n            if (!word) {\n                return super.select(model, pos, items);\n            }\n            let key = `${model.getLanguageIdentifier().language}/${word}`;\n            let item = this._trie.get(key);\n            if (!item) {\n                item = this._trie.findSubstr(key);\n            }\n            if (item) {\n                for (let i = 0; i < items.length; i++) {\n                    let { kind, insertText } = items[i].completion;\n                    if (kind === item.type && insertText === item.insertText) {\n                        return i;\n                    }\n                }\n            }\n            return super.select(model, pos, items);\n        }\n        toJSON() {\n            let entries = [];\n            this._trie.forEach((value, key) => entries.push([key, value]));\n            // sort by last recently used (touch), then\n            // take the top 200 item and normalize their\n            // touch\n            entries\n                .sort((a, b) => -(a[1].touch - b[1].touch))\n                .forEach((value, i) => value[1].touch = i);\n            return entries.slice(0, 200);\n        }\n        fromJSON(data) {\n            this._trie.clear();\n            if (data.length > 0) {\n                this._seq = data[0][1].touch + 1;\n                for (const [key, value] of data) {\n                    value.type = typeof value.type === 'number' ? value.type : modes_1.completionKindFromString(value.type);\n                    this._trie.set(key, value);\n                }\n            }\n        }\n    }\n    exports.PrefixMemory = PrefixMemory;\n    let SuggestMemoryService = class SuggestMemoryService extends lifecycle_1.Disposable {\n        constructor(_storageService, _configService) {\n            super();\n            this._storageService = _storageService;\n            this._configService = _configService;\n            this._storagePrefix = 'suggest/memories';\n            const update = () => {\n                const mode = this._configService.getValue('editor.suggestSelection');\n                const share = this._configService.getValue('editor.suggest.shareSuggestSelections');\n                this._update(mode, share, false);\n            };\n            this._persistSoon = this._register(new async_1.RunOnceScheduler(() => this._saveState(), 500));\n            this._register(_storageService.onWillSaveState(() => this._saveState()));\n            this._register(this._configService.onDidChangeConfiguration(e => {\n                if (e.affectsConfiguration('editor.suggestSelection') || e.affectsConfiguration('editor.suggest.shareSuggestSelections')) {\n                    update();\n                }\n            }));\n            this._register(this._storageService.onDidChangeStorage(e => {\n                if (e.scope === storage_1.StorageScope.GLOBAL && e.key.indexOf(this._storagePrefix) === 0) {\n                    if (!document.hasFocus()) {\n                        // windows that aren't focused have to drop their current\n                        // storage value and accept what's stored now\n                        this._update(this._mode, this._shareMem, true);\n                    }\n                }\n            }));\n            update();\n        }\n        _update(mode, shareMem, force) {\n            if (!force && this._mode === mode && this._shareMem === shareMem) {\n                return;\n            }\n            this._shareMem = shareMem;\n            this._mode = mode;\n            this._strategy = mode === 'recentlyUsedByPrefix' ? new PrefixMemory() : mode === 'recentlyUsed' ? new LRUMemory() : new NoMemory();\n            try {\n                const scope = shareMem ? storage_1.StorageScope.GLOBAL : storage_1.StorageScope.WORKSPACE;\n                const raw = this._storageService.get(`${this._storagePrefix}/${this._mode}`, scope);\n                if (raw) {\n                    this._strategy.fromJSON(JSON.parse(raw));\n                }\n            }\n            catch (e) {\n                // things can go wrong with JSON...\n            }\n        }\n        memorize(model, pos, item) {\n            this._strategy.memorize(model, pos, item);\n            this._persistSoon.schedule();\n        }\n        select(model, pos, items) {\n            return this._strategy.select(model, pos, items);\n        }\n        _saveState() {\n            const raw = JSON.stringify(this._strategy);\n            const scope = this._shareMem ? storage_1.StorageScope.GLOBAL : storage_1.StorageScope.WORKSPACE;\n            this._storageService.store(`${this._storagePrefix}/${this._mode}`, raw, scope);\n        }\n    };\n    SuggestMemoryService = __decorate([\n        __param(0, storage_1.IStorageService),\n        __param(1, configuration_1.IConfigurationService)\n    ], SuggestMemoryService);\n    exports.SuggestMemoryService = SuggestMemoryService;\n    exports.ISuggestMemoryService = instantiation_1.createDecorator('ISuggestMemories');\n    extensions_1.registerSingleton(exports.ISuggestMemoryService, SuggestMemoryService, true);\n});\n",null]}