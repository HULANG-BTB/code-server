{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/packages/vscode/src/dialog.ts","dependencies":[{"path":"/home/coding/workspace/packages/vscode/src/dialog.ts","mtime":1555841535694},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"fs\", \"path\", \"util\", \"@coder/events\", \"vs/base/browser/dom\", \"vs/base/browser/ui/highlightedlabel/highlightedLabel\", \"vs/base/browser/ui/tree/objectTree\", \"vs/base/browser/ui/tree/tree\", \"vs/base/common/keyCodes\", \"vs/base/common/uri\", \"vs/editor/common/services/getIconClasses\", \"vs/editor/common/services/modelService\", \"vs/editor/common/services/modeService\", \"vs/platform/files/common/files\", \"vs/platform/theme/common/themeService\", \"./workbench\", \"./dialog.scss\"], function (require, exports, fs, path, util, events_1, dom_1, highlightedLabel_1, objectTree_1, tree_1, keyCodes_1, uri_1, getIconClasses_1, modelService_1, modeService_1, files_1, themeService_1, workbench_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Describes the type of dialog to show.\n     */\n    var DialogType;\n    (function (DialogType) {\n        DialogType[DialogType[\"NewFolder\"] = 0] = \"NewFolder\";\n        DialogType[DialogType[\"Save\"] = 1] = \"Save\";\n        DialogType[DialogType[\"Open\"] = 2] = \"Open\";\n    })(DialogType = exports.DialogType || (exports.DialogType = {}));\n    exports.showOpenDialog = (options) => {\n        return new Promise((resolve, reject) => {\n            const dialog = new Dialog(DialogType.Open, options);\n            dialog.onSelect((e) => {\n                dialog.dispose();\n                resolve(e);\n            });\n            dialog.onError((e) => {\n                dialog.dispose();\n                reject(e);\n            });\n        });\n    };\n    /**\n     * Open and save dialogs.\n     */\n    class Dialog {\n        constructor(type, options) {\n            this.type = type;\n            this.options = options;\n            this.selectEmitter = new events_1.Emitter();\n            this.errorEmitter = new events_1.Emitter();\n            this.background = document.createElement(\"div\");\n            this.background.style.position = \"absolute\";\n            this.background.style.top = \"0\";\n            this.background.style.left = \"0\";\n            this.background.style.bottom = \"0\";\n            this.background.style.right = \"0\";\n            this.background.style.zIndex = \"5\";\n            this.background.style.display = \"flex\";\n            this.background.style.alignItems = \"center\";\n            this.background.style.justifyContent = \"center\";\n            this.background.style.background = \"rgba(0, 0, 0, 0.25)\";\n            this.root = document.createElement(\"div\");\n            this.root.style.width = \"850px\";\n            this.root.style.height = \"600px\";\n            this.background.appendChild(this.root);\n            (document.querySelector(\".monaco-workbench\") || document.body).appendChild(this.background);\n            this.root.classList.add(\"dialog\");\n            const setProperty = (vari, id) => {\n                const getColor = (id) => {\n                    const ts = workbench_1.workbench.serviceCollection.get(themeService_1.IThemeService);\n                    const c = ts.getTheme().getColor(id);\n                    if (!c) {\n                        return;\n                    }\n                    return c.toString();\n                };\n                const c = getColor(id);\n                if (c) {\n                    this.root.style.setProperty(vari, c);\n                }\n            };\n            setProperty(\"--primary\", \"sideBar.background\");\n            setProperty(\"--list-active-selection-background\", \"list.activeSelectionBackground\");\n            setProperty(\"--list-active-selection-foreground\", \"list.activeSelectionForeground\");\n            setProperty(\"--list-hover-background\", \"list.hoverBackground\");\n            setProperty(\"--header-background\", \"sideBarSectionHeader.background\");\n            setProperty(\"--header-foreground\", \"sideBarSectionHeader.foreground\");\n            setProperty(\"--border\", \"panel.border\");\n            this.background.addEventListener(\"contextmenu\", (event) => {\n                event.preventDefault();\n            });\n            const titleNode = document.createElement(\"div\");\n            titleNode.classList.add(\"title\");\n            let title;\n            switch (this.type) {\n                // case DialogType.NewFolder:\n                // \ttitle = \"New Folder\";\n                // \tbreak;\n                case DialogType.Open:\n                    title = \"Open File\";\n                    break;\n                case DialogType.Save:\n                    title = \"Save File\";\n                    break;\n                default:\n                    throw new Error(\"Uncased type\");\n            }\n            titleNode.innerText = options.title || title;\n            this.root.appendChild(titleNode);\n            const navItems = document.createElement(\"div\");\n            navItems.classList.add(\"nav\");\n            this.pathNode = document.createElement(\"div\");\n            this.pathNode.classList.add(\"path\");\n            navItems.appendChild(this.pathNode);\n            this.root.appendChild(navItems);\n            const headingsNode = document.createElement(\"div\");\n            headingsNode.className = \"headings dialog-grid\";\n            [\"Name\", \"Size\", \"Last Modified\"].forEach(e => {\n                const header = document.createElement(\"div\");\n                header.innerText = e;\n                headingsNode.appendChild(header);\n            });\n            this.root.appendChild(headingsNode);\n            const fileAreaNode = document.createElement(\"div\");\n            fileAreaNode.classList.add(\"file-area\");\n            fileAreaNode.classList.add(\"show-file-icons\");\n            this.filesNode = document.createElement(\"div\");\n            this.filesNode.className = \"files-list\";\n            this.entryList = new objectTree_1.ObjectTree(this.filesNode, {\n                getHeight: (_entry) => {\n                    return 20;\n                },\n                getTemplateId: (_entry) => {\n                    return \"dialog-entry\";\n                },\n            }, [new DialogEntryRenderer()], {\n                openController: {\n                    shouldOpen: (_event) => {\n                        return true;\n                    },\n                },\n                keyboardNavigationLabelProvider: {\n                    getKeyboardNavigationLabel: (element) => {\n                        return element.name;\n                    },\n                    mightProducePrintableCharacter: (event) => {\n                        if (event.ctrlKey || event.metaKey) {\n                            // ignore ctrl/cmd-combination but not shift/alt-combinatios\n                            return false;\n                        }\n                        // weak check for certain ranges. this is properly implemented in a subclass\n                        // with access to the KeyboardMapperFactory.\n                        if ((event.keyCode >= keyCodes_1.KeyCode.KEY_A && event.keyCode <= keyCodes_1.KeyCode.KEY_Z)\n                            || (event.keyCode >= keyCodes_1.KeyCode.KEY_0 && event.keyCode <= keyCodes_1.KeyCode.KEY_9)\n                            || event.keyCode === keyCodes_1.KeyCode.US_DOT || event.keyCode === keyCodes_1.KeyCode.US_SLASH || event.keyCode === keyCodes_1.KeyCode.US_MINUS) {\n                            return true;\n                        }\n                        return false;\n                    },\n                },\n                automaticKeyboardNavigation: true,\n                enableKeyboardNavigation: true,\n                multipleSelectionSupport: false,\n                openOnSingleClick: false,\n                filter: {\n                    filter: () => {\n                        // tslint:disable-next-line:no-any\n                        this.entryList._options.simpleKeyboardNavigation = true;\n                        // tslint:disable-next-line:no-any\n                        const pat = this.entryList.typeFilterController.filter._pattern;\n                        return {\n                            data: pat,\n                            visibility: tree_1.TreeVisibility.Visible,\n                        };\n                    },\n                },\n                filterOnType: true,\n            });\n            // tslint:disable-next-line:no-any\n            this.entryList.focusNavigationFilter = (node) => {\n                if (node.filterData) {\n                    return node.element.name.toLowerCase().startsWith(node.filterData.toLowerCase());\n                }\n                return false;\n            };\n            this.entryList.onDidOpen((event) => {\n                const element = event.elements[0];\n                if (!element) {\n                    const fv = this.filterValue;\n                    if (fv === Dialog.UpperDirId) {\n                        this.path = path.dirname(this._path);\n                    }\n                    if (fv.startsWith(\"/\")) {\n                        fs.stat(fv, (err, stats) => {\n                            if (err) {\n                                return;\n                            }\n                            if (stats.isDirectory()) {\n                                this.path = fv;\n                            }\n                        });\n                    }\n                    return;\n                }\n                // If it's a directory, we want to navigate to it. If it's a file, then we\n                // only want to open it if opening files is supported.\n                if (element.isDirectory) {\n                    this.path = element.fullPath;\n                }\n                else if (this.options.properties.openFile) {\n                    this.selectEmitter.emit(element.fullPath);\n                }\n            });\n            fileAreaNode.appendChild(this.entryList.getHTMLElement());\n            this.root.appendChild(fileAreaNode);\n            const buttonsNode = document.createElement(\"div\");\n            buttonsNode.className = \"buttons\";\n            const cancelBtn = document.createElement(\"button\");\n            cancelBtn.innerText = \"Cancel\";\n            cancelBtn.addEventListener(\"click\", () => {\n                this.errorEmitter.emit(new Error(\"Cancelled\"));\n            });\n            buttonsNode.appendChild(cancelBtn);\n            const confirmBtn = document.createElement(\"button\");\n            const openDirectory = this.options.properties.openDirectory;\n            confirmBtn.innerText = this.options.buttonLabel || \"Confirm\";\n            confirmBtn.addEventListener(\"click\", () => {\n                if (this._path && openDirectory) {\n                    this.selectEmitter.emit(this._path);\n                }\n            });\n            // Disable if we can't open directories, otherwise you can open a directory\n            // as a file which won't work. This is because our button currently just\n            // always opens whatever directory is opened and will not open selected\n            // files. (A single click on a file is used to open it instead.)\n            if (!openDirectory) {\n                confirmBtn.disabled = true;\n            }\n            buttonsNode.appendChild(confirmBtn);\n            this.root.appendChild(buttonsNode);\n            this.entryList.layout();\n            this.path = options.defaultPath || \"/\";\n        }\n        get onSelect() {\n            return this.selectEmitter.event;\n        }\n        get onError() {\n            return this.errorEmitter.event;\n        }\n        /**\n         * Remove the dialog.\n         */\n        dispose() {\n            this.selectEmitter.dispose();\n            this.errorEmitter.dispose();\n            this.entryList.dispose();\n            this.background.remove();\n        }\n        /**\n         * Build and insert the path shown at the top of the dialog.\n         */\n        buildPath() {\n            while (this.pathNode.lastChild) {\n                this.pathNode.removeChild(this.pathNode.lastChild);\n            }\n            if (!this._path) {\n                throw new Error(\"cannot build path node without valid path\");\n            }\n            const pathParts = [\"\", ...this._path.split(\"/\").filter((p) => p.length > 0)];\n            for (let i = 0; i < pathParts.length; i++) {\n                const pathPartNode = document.createElement(\"div\");\n                pathPartNode.classList.add(\"path-part\");\n                pathPartNode.innerText = pathParts[i].length > 0 ? pathParts[i] : \"/\";\n                if (i === pathParts.length - 1) {\n                    pathPartNode.classList.add(\"active\");\n                }\n                pathPartNode.addEventListener(\"click\", () => {\n                    this.path = \"/\" + pathParts.slice(0, i + 1).join(\"/\");\n                });\n                this.pathNode.appendChild(pathPartNode);\n            }\n        }\n        set path(directory) {\n            this.list(directory).then((value) => {\n                this._path = directory;\n                this.buildPath();\n                while (this.filesNode.lastChild) {\n                    this.filesNode.removeChild(this.filesNode.lastChild);\n                }\n                const items = value.filter((v) => {\n                    if (v.name.startsWith(\".\")) {\n                        const props = this.options.properties;\n                        if (props && props.showHiddenFiles) {\n                            return true;\n                        }\n                        return false;\n                    }\n                    return true;\n                });\n                this.entryList.setChildren(null, items.map((i) => ({ element: i })));\n                this.entryList.domFocus();\n                this.entryList.setFocus([null]);\n                // Clears the input on refresh\n                // tslint:disable-next-line:no-any\n                this.entryList.typeFilterController.onInput(\"\");\n            }).catch((ex) => {\n                this.errorEmitter.emit(ex);\n            });\n        }\n        get filterValue() {\n            // tslint:disable-next-line:no-any\n            return this.entryList.typeFilterController.filter._pattern;\n        }\n        /**\n         * List the files and return dialog entries.\n         */\n        list(directory) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const paths = (yield util.promisify(fs.readdir)(directory)).sort();\n                const stats = yield Promise.all(paths.map(p => util.promisify(fs.stat)(path.join(directory, p))));\n                return stats.map((stat, index) => ({\n                    fullPath: path.join(directory, paths[index]),\n                    name: paths[index],\n                    isDirectory: stat.isDirectory(),\n                    lastModified: stat.mtime.toDateString(),\n                    size: stat.size,\n                    // If we can't open files, show them as disabled.\n                    isDisabled: !stat.isDirectory()\n                        && !this.options.properties.openFile,\n                }));\n            });\n        }\n    }\n    Dialog.UpperDirId = \"..\";\n    /**\n     * Rendering for the different parts of a dialog entry.\n     */\n    class DialogEntryRenderer {\n        get templateId() {\n            return \"dialog-entry\";\n        }\n        /**\n         * Append and return containers for each part of the dialog entry.\n         */\n        renderTemplate(container) {\n            dom_1.addClass(container, \"dialog-entry\");\n            dom_1.addClass(container, \"dialog-grid\");\n            const wrapper = dom_1.append(container, dom_1.$(\".dialog-entry-info\"));\n            const icon = dom_1.append(wrapper, dom_1.$(\"div\"));\n            const name = dom_1.append(wrapper, dom_1.$(\".dialog-entry-name\"));\n            const label = new highlightedLabel_1.HighlightedLabel(name, false);\n            dom_1.append(container, wrapper);\n            const size = dom_1.append(container, dom_1.$(\".dialog-entry-size\"));\n            const mtime = dom_1.append(container, dom_1.$(\".dialog-entry-mtime\"));\n            return {\n                icon,\n                size,\n                lastModified: mtime,\n                label,\n            };\n        }\n        /**\n         * Render a dialog entry.\n         */\n        renderElement(node, _index, templateData) {\n            templateData.icon.className = \"dialog-entry-icon monaco-icon-label\";\n            const classes = getIconClasses_1.getIconClasses(workbench_1.workbench.serviceCollection.get(modelService_1.IModelService), workbench_1.workbench.serviceCollection.get(modeService_1.IModeService), uri_1.URI.file(node.element.name), node.element.isDirectory ? files_1.FileKind.FOLDER : files_1.FileKind.FILE);\n            templateData.icon.hidden = classes.length === 0;\n            classes.forEach((c) => {\n                try {\n                    templateData.icon.classList.add(c);\n                }\n                catch (ex) {\n                    // Nothin needed. Sometimes bad classes are given\n                }\n            });\n            templateData.label.set(node.element.name, typeof node.filterData === \"string\" && node.element.name.toLowerCase().startsWith(node.filterData.toLowerCase()) ? [{\n                    start: 0,\n                    end: node.filterData.length,\n                }] : []);\n            templateData.size.innerText = node.element.size.toString();\n            templateData.lastModified.innerText = node.element.lastModified;\n            // We know this exists because we created the template.\n            const entryContainer = templateData.label.element.parentElement.parentElement.parentElement;\n            if (node.element.isDisabled) {\n                entryContainer.classList.add(\"disabled\");\n            }\n            else {\n                entryContainer.classList.remove(\"disabled\");\n            }\n        }\n        /**\n         * Does nothing (not implemented).\n         */\n        disposeTemplate(_templateData) {\n            // throw new Error(\"Method not implemented.\");\n        }\n    }\n});\n",null]}