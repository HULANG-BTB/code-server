{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/node/extfs.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/extfs.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"fs\", \"vs/base/common/path\", \"vs/base/common/async\", \"vs/base/common/normalization\", \"vs/base/common/platform\", \"vs/base/common/strings\", \"vs/base/common/uuid\", \"vs/base/node/encoding\", \"vs/base/node/flow\", \"vs/base/common/lifecycle\"], function (require, exports, fs, paths, async_1, normalization_1, platform, strings, uuid, encoding_1, flow, lifecycle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const loop = flow.loop;\n    function readdirSync(path) {\n        // Mac: uses NFD unicode form on disk, but we want NFC\n        // See also https://github.com/nodejs/node/issues/2165\n        if (platform.isMacintosh) {\n            return fs.readdirSync(path).map(c => normalization_1.normalizeNFC(c));\n        }\n        return fs.readdirSync(path);\n    }\n    exports.readdirSync = readdirSync;\n    function readdir(path, callback) {\n        // Mac: uses NFD unicode form on disk, but we want NFC\n        // See also https://github.com/nodejs/node/issues/2165\n        if (platform.isMacintosh) {\n            return fs.readdir(path, (error, children) => {\n                if (error) {\n                    return callback(error, []);\n                }\n                return callback(null, children.map(c => normalization_1.normalizeNFC(c)));\n            });\n        }\n        return fs.readdir(path, callback);\n    }\n    exports.readdir = readdir;\n    function statLink(path, callback) {\n        fs.lstat(path, (error, lstat) => {\n            if (error || lstat.isSymbolicLink()) {\n                fs.stat(path, (error, stat) => {\n                    if (error) {\n                        return callback(error, null);\n                    }\n                    callback(null, { stat, isSymbolicLink: lstat && lstat.isSymbolicLink() });\n                });\n            }\n            else {\n                callback(null, { stat: lstat, isSymbolicLink: false });\n            }\n        });\n    }\n    exports.statLink = statLink;\n    function copy(source, target, callback, copiedSourcesIn) {\n        const copiedSources = copiedSourcesIn ? copiedSourcesIn : Object.create(null);\n        fs.stat(source, (error, stat) => {\n            if (error) {\n                return callback(error);\n            }\n            if (!stat.isDirectory()) {\n                return doCopyFile(source, target, stat.mode & 511, callback);\n            }\n            if (copiedSources[source]) {\n                return callback(null); // escape when there are cycles (can happen with symlinks)\n            }\n            copiedSources[source] = true; // remember as copied\n            const proceed = function () {\n                readdir(source, (err, files) => {\n                    loop(files, (file, clb) => {\n                        copy(paths.join(source, file), paths.join(target, file), (error) => clb(error, []), copiedSources);\n                    }, callback);\n                });\n            };\n            mkdirp(target, stat.mode & 511).then(proceed, proceed);\n        });\n    }\n    exports.copy = copy;\n    function doCopyFile(source, target, mode, callback) {\n        const reader = fs.createReadStream(source);\n        const writer = fs.createWriteStream(target, { mode });\n        let finished = false;\n        const finish = (error) => {\n            if (!finished) {\n                finished = true;\n                // in error cases, pass to callback\n                if (error) {\n                    callback(error);\n                }\n                // we need to explicitly chmod because of https://github.com/nodejs/node/issues/1104\n                else {\n                    fs.chmod(target, mode, callback);\n                }\n            }\n        };\n        // handle errors properly\n        reader.once('error', error => finish(error));\n        writer.once('error', error => finish(error));\n        // we are done (underlying fd has been closed)\n        writer.once('close', () => finish());\n        // start piping\n        reader.pipe(writer);\n    }\n    function mkdirp(path, mode, token) {\n        const mkdir = () => {\n            return async_1.nfcall(fs.mkdir, path, mode).then(undefined, (mkdirErr) => {\n                // ENOENT: a parent folder does not exist yet\n                if (mkdirErr.code === 'ENOENT') {\n                    return Promise.reject(mkdirErr);\n                }\n                // Any other error: check if folder exists and\n                // return normally in that case if its a folder\n                return async_1.nfcall(fs.stat, path).then((stat) => {\n                    if (!stat.isDirectory()) {\n                        return Promise.reject(new Error(`'${path}' exists and is not a directory.`));\n                    }\n                    return null;\n                }, statErr => {\n                    return Promise.reject(mkdirErr); // bubble up original mkdir error\n                });\n            });\n        };\n        // stop at root\n        if (path === paths.dirname(path)) {\n            return Promise.resolve(true);\n        }\n        // recursively mkdir\n        return mkdir().then(undefined, (err) => {\n            // Respect cancellation\n            if (token && token.isCancellationRequested) {\n                return Promise.resolve(false);\n            }\n            // ENOENT: a parent folder does not exist yet, continue\n            // to create the parent folder and then try again.\n            if (err.code === 'ENOENT') {\n                return mkdirp(paths.dirname(path), mode).then(mkdir);\n            }\n            // Any other error\n            return Promise.reject(err);\n        });\n    }\n    exports.mkdirp = mkdirp;\n    // Deletes the given path by first moving it out of the workspace. This has two benefits. For one, the operation can return fast because\n    // after the rename, the contents are out of the workspace although not yet deleted. The greater benefit however is that this operation\n    // will fail in case any file is used by another process. fs.unlink() in node will not bail if a file unlinked is used by another process.\n    // However, the consequences are bad as outlined in all the related bugs from https://github.com/joyent/node/issues/7164\n    function del(path, tmpFolder, callback, done) {\n        fs.exists(path, exists => {\n            if (!exists) {\n                return callback(null);\n            }\n            fs.stat(path, (err, stat) => {\n                if (err || !stat) {\n                    return callback(err);\n                }\n                // Special windows workaround: A file or folder that ends with a \".\" cannot be moved to another place\n                // because it is not a valid file name. In this case, we really have to do the deletion without prior move.\n                if (path[path.length - 1] === '.' || strings.endsWith(path, './') || strings.endsWith(path, '.\\\\')) {\n                    return rmRecursive(path, callback);\n                }\n                const pathInTemp = paths.join(tmpFolder, uuid.generateUuid());\n                fs.rename(path, pathInTemp, (error) => {\n                    if (error) {\n                        return rmRecursive(path, callback); // if rename fails, delete without tmp dir\n                    }\n                    // Return early since the move succeeded\n                    callback(null);\n                    // do the heavy deletion outside the callers callback\n                    rmRecursive(pathInTemp, error => {\n                        if (done) {\n                            done(error);\n                        }\n                    });\n                });\n            });\n        });\n    }\n    exports.del = del;\n    function rmRecursive(path, callback) {\n        if (path === paths.win32.sep || path === paths.posix.sep) {\n            return callback(new Error('Will not delete root!'));\n        }\n        fs.exists(path, exists => {\n            if (!exists) {\n                callback(null);\n            }\n            else {\n                fs.lstat(path, (err, stat) => {\n                    if (err || !stat) {\n                        callback(err);\n                    }\n                    else if (!stat.isDirectory() || stat.isSymbolicLink() /* !!! never recurse into links when deleting !!! */) {\n                        const mode = stat.mode;\n                        if (!(mode & 128)) { // 128 === 0200\n                            fs.chmod(path, mode | 128, (err) => {\n                                if (err) {\n                                    callback(err);\n                                }\n                                else {\n                                    fs.unlink(path, callback);\n                                }\n                            });\n                        }\n                        else {\n                            fs.unlink(path, callback);\n                        }\n                    }\n                    else {\n                        readdir(path, (err, children) => {\n                            if (err || !children) {\n                                callback(err);\n                            }\n                            else if (children.length === 0) {\n                                fs.rmdir(path, callback);\n                            }\n                            else {\n                                let firstError = null;\n                                let childrenLeft = children.length;\n                                children.forEach(child => {\n                                    rmRecursive(paths.join(path, child), (err) => {\n                                        childrenLeft--;\n                                        if (err) {\n                                            firstError = firstError || err;\n                                        }\n                                        if (childrenLeft === 0) {\n                                            if (firstError) {\n                                                callback(firstError);\n                                            }\n                                            else {\n                                                fs.rmdir(path, callback);\n                                            }\n                                        }\n                                    });\n                                });\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    }\n    function delSync(path) {\n        if (path === paths.win32.sep || path === paths.posix.sep) {\n            throw new Error('Will not delete root!');\n        }\n        try {\n            const stat = fs.lstatSync(path);\n            if (stat.isDirectory() && !stat.isSymbolicLink()) {\n                readdirSync(path).forEach(child => delSync(paths.join(path, child)));\n                fs.rmdirSync(path);\n            }\n            else {\n                fs.unlinkSync(path);\n            }\n        }\n        catch (err) {\n            if (err.code === 'ENOENT') {\n                return; // not found\n            }\n            throw err;\n        }\n    }\n    exports.delSync = delSync;\n    function mv(source, target, callback) {\n        if (source === target) {\n            return callback(null);\n        }\n        function updateMtime(err) {\n            if (err) {\n                return callback(err);\n            }\n            fs.lstat(target, (error, stat) => {\n                if (error) {\n                    return callback(error);\n                }\n                if (stat.isDirectory() || stat.isSymbolicLink()) {\n                    return callback(null);\n                }\n                fs.open(target, 'a', null, (err, fd) => {\n                    if (err) {\n                        return callback(err);\n                    }\n                    fs.futimes(fd, stat.atime, new Date(), (err) => {\n                        if (err) {\n                            return callback(err);\n                        }\n                        fs.close(fd, callback);\n                    });\n                });\n            });\n        }\n        // Try native rename()\n        fs.rename(source, target, (err) => {\n            if (!err) {\n                return updateMtime(null);\n            }\n            // In two cases we fallback to classic copy and delete:\n            //\n            // 1.) The EXDEV error indicates that source and target are on different devices\n            // In this case, fallback to using a copy() operation as there is no way to\n            // rename() between different devices.\n            //\n            // 2.) The user tries to rename a file/folder that ends with a dot. This is not\n            // really possible to move then, at least on UNC devices.\n            if (err && source.toLowerCase() !== target.toLowerCase() && (err.code === 'EXDEV') || strings.endsWith(source, '.')) {\n                return copy(source, target, (err) => {\n                    if (err) {\n                        return callback(err);\n                    }\n                    rmRecursive(source, updateMtime);\n                });\n            }\n            return callback(err);\n        });\n    }\n    exports.mv = mv;\n    let canFlush = true;\n    function writeFileAndFlush(path, data, options, callback) {\n        options = ensureOptions(options);\n        if (typeof data === 'string' || Buffer.isBuffer(data) || data instanceof Uint8Array) {\n            doWriteFileAndFlush(path, data, options, callback);\n        }\n        else {\n            doWriteFileStreamAndFlush(path, data, options, callback);\n        }\n    }\n    exports.writeFileAndFlush = writeFileAndFlush;\n    function doWriteFileStreamAndFlush(path, reader, options, callback) {\n        // finish only once\n        let finished = false;\n        const finish = (error) => {\n            if (!finished) {\n                finished = true;\n                // in error cases we need to manually close streams\n                // if the write stream was successfully opened\n                if (error) {\n                    if (isOpen) {\n                        writer.once('close', () => callback(error));\n                        writer.destroy();\n                    }\n                    else {\n                        callback(error);\n                    }\n                }\n                // otherwise just return without error\n                else {\n                    callback();\n                }\n            }\n        };\n        // create writer to target. we set autoClose: false because we want to use the streams\n        // file descriptor to call fs.fdatasync to ensure the data is flushed to disk\n        const writer = fs.createWriteStream(path, { mode: options.mode, flags: options.flag, autoClose: false });\n        // Event: 'open'\n        // Purpose: save the fd for later use and start piping\n        // Notes: will not be called when there is an error opening the file descriptor!\n        let fd;\n        let isOpen;\n        writer.once('open', descriptor => {\n            fd = descriptor;\n            isOpen = true;\n            // if an encoding is provided, we need to pipe the stream through\n            // an encoder stream and forward the encoding related options\n            if (options.encoding) {\n                reader = reader.pipe(encoding_1.encodeStream(options.encoding.charset, { addBOM: options.encoding.addBOM }));\n            }\n            // start data piping only when we got a successful open. this ensures that we do\n            // not consume the stream when an error happens and helps to fix this issue:\n            // https://github.com/Microsoft/vscode/issues/42542\n            reader.pipe(writer);\n        });\n        // Event: 'error'\n        // Purpose: to return the error to the outside and to close the write stream (does not happen automatically)\n        reader.once('error', error => finish(error));\n        writer.once('error', error => finish(error));\n        // Event: 'finish'\n        // Purpose: use fs.fdatasync to flush the contents to disk\n        // Notes: event is called when the writer has finished writing to the underlying resource. we must call writer.close()\n        // because we have created the WriteStream with autoClose: false\n        writer.once('finish', () => {\n            // flush to disk\n            if (canFlush && isOpen) {\n                fs.fdatasync(fd, (syncError) => {\n                    // In some exotic setups it is well possible that node fails to sync\n                    // In that case we disable flushing and warn to the console\n                    if (syncError) {\n                        console.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n                        canFlush = false;\n                    }\n                    writer.destroy();\n                });\n            }\n            else {\n                writer.destroy();\n            }\n        });\n        // Event: 'close'\n        // Purpose: signal we are done to the outside\n        // Notes: event is called when the writer's filedescriptor is closed\n        writer.once('close', () => finish());\n    }\n    // Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk\n    // We do this in cases where we want to make sure the data is really on disk and\n    // not in some cache.\n    //\n    // See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194\n    function doWriteFileAndFlush(path, data, options, callback) {\n        if (options.encoding) {\n            data = encoding_1.encode(data instanceof Uint8Array ? Buffer.from(data) : data, options.encoding.charset, { addBOM: options.encoding.addBOM });\n        }\n        if (!canFlush) {\n            return fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);\n        }\n        // Open the file with same flags and mode as fs.writeFile()\n        fs.open(path, typeof options.flag === 'string' ? options.flag : 'r', options.mode, (openError, fd) => {\n            if (openError) {\n                return callback(openError);\n            }\n            // It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n            fs.writeFile(fd, data, writeError => {\n                if (writeError) {\n                    return fs.close(fd, () => callback(writeError)); // still need to close the handle on error!\n                }\n                // Flush contents (not metadata) of the file to disk\n                fs.fdatasync(fd, (syncError) => {\n                    // In some exotic setups it is well possible that node fails to sync\n                    // In that case we disable flushing and warn to the console\n                    if (syncError) {\n                        console.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n                        canFlush = false;\n                    }\n                    return fs.close(fd, closeError => callback(closeError));\n                });\n            });\n        });\n    }\n    function writeFileAndFlushSync(path, data, options) {\n        options = ensureOptions(options);\n        if (options.encoding) {\n            data = encoding_1.encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });\n        }\n        if (!canFlush) {\n            return fs.writeFileSync(path, data, { mode: options.mode, flag: options.flag });\n        }\n        // Open the file with same flags and mode as fs.writeFile()\n        const fd = fs.openSync(path, typeof options.flag === 'string' ? options.flag : 'r', options.mode);\n        try {\n            // It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n            fs.writeFileSync(fd, data);\n            // Flush contents (not metadata) of the file to disk\n            try {\n                fs.fdatasyncSync(fd);\n            }\n            catch (syncError) {\n                console.warn('[node.js fs] fdatasyncSync is now disabled for this session because it failed: ', syncError);\n                canFlush = false;\n            }\n        }\n        finally {\n            fs.closeSync(fd);\n        }\n    }\n    exports.writeFileAndFlushSync = writeFileAndFlushSync;\n    function ensureOptions(options) {\n        if (!options) {\n            return { mode: 0o666, flag: 'w' };\n        }\n        const ensuredOptions = { mode: options.mode, flag: options.flag, encoding: options.encoding };\n        if (typeof ensuredOptions.mode !== 'number') {\n            ensuredOptions.mode = 0o666;\n        }\n        if (typeof ensuredOptions.flag !== 'string') {\n            ensuredOptions.flag = 'w';\n        }\n        return ensuredOptions;\n    }\n    /**\n     * Copied from: https://github.com/Microsoft/vscode-node-debug/blob/master/src/node/pathUtilities.ts#L83\n     *\n     * Given an absolute, normalized, and existing file path 'realcase' returns the exact path that the file has on disk.\n     * On a case insensitive file system, the returned path might differ from the original path by character casing.\n     * On a case sensitive file system, the returned path will always be identical to the original path.\n     * In case of errors, null is returned. But you cannot use this function to verify that a path exists.\n     * realcaseSync does not handle '..' or '.' path segments and it does not take the locale into account.\n     */\n    function realcaseSync(path) {\n        const dir = paths.dirname(path);\n        if (path === dir) { // end recursion\n            return path;\n        }\n        const name = (paths.basename(path) /* can be '' for windows drive letters */ || path).toLowerCase();\n        try {\n            const entries = readdirSync(dir);\n            const found = entries.filter(e => e.toLowerCase() === name); // use a case insensitive search\n            if (found.length === 1) {\n                // on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition\n                const prefix = realcaseSync(dir); // recurse\n                if (prefix) {\n                    return paths.join(prefix, found[0]);\n                }\n            }\n            else if (found.length > 1) {\n                // must be a case sensitive $filesystem\n                const ix = found.indexOf(name);\n                if (ix >= 0) { // case sensitive\n                    const prefix = realcaseSync(dir); // recurse\n                    if (prefix) {\n                        return paths.join(prefix, found[ix]);\n                    }\n                }\n            }\n        }\n        catch (error) {\n            // silently ignore error\n        }\n        return null;\n    }\n    exports.realcaseSync = realcaseSync;\n    function realpathSync(path) {\n        try {\n            return fs.realpathSync(path);\n        }\n        catch (error) {\n            // We hit an error calling fs.realpathSync(). Since fs.realpathSync() is doing some path normalization\n            // we now do a similar normalization and then try again if we can access the path with read\n            // permissions at least. If that succeeds, we return that path.\n            // fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n            // to not resolve links but to simply see if the path is read accessible or not.\n            const normalizedPath = normalizePath(path);\n            fs.accessSync(normalizedPath, fs.constants.R_OK); // throws in case of an error\n            return normalizedPath;\n        }\n    }\n    exports.realpathSync = realpathSync;\n    function realpath(path, callback) {\n        return fs.realpath(path, (error, realpath) => {\n            if (!error) {\n                return callback(null, realpath);\n            }\n            // We hit an error calling fs.realpath(). Since fs.realpath() is doing some path normalization\n            // we now do a similar normalization and then try again if we can access the path with read\n            // permissions at least. If that succeeds, we return that path.\n            // fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n            // to not resolve links but to simply see if the path is read accessible or not.\n            const normalizedPath = normalizePath(path);\n            return fs.access(normalizedPath, fs.constants.R_OK, error => {\n                return callback(error, normalizedPath);\n            });\n        });\n    }\n    exports.realpath = realpath;\n    function normalizePath(path) {\n        return strings.rtrim(paths.normalize(path), paths.sep);\n    }\n    function watch(path, onChange, onError) {\n        try {\n            const watcher = fs.watch(path);\n            watcher.on('change', (type, raw) => {\n                let file;\n                if (raw) { // https://github.com/Microsoft/vscode/issues/38191\n                    file = raw.toString();\n                    if (platform.isMacintosh) {\n                        // Mac: uses NFD unicode form on disk, but we want NFC\n                        // See also https://github.com/nodejs/node/issues/2165\n                        file = normalization_1.normalizeNFC(file);\n                    }\n                }\n                onChange(type, file);\n            });\n            watcher.on('error', (code, signal) => onError(`Failed to watch ${path} for changes (${code}, ${signal})`));\n            return lifecycle_1.toDisposable(() => {\n                watcher.removeAllListeners();\n                watcher.close();\n            });\n        }\n        catch (error) {\n            fs.exists(path, exists => {\n                if (exists) {\n                    onError(`Failed to watch ${path} for changes (${error.toString()})`);\n                }\n            });\n        }\n        return lifecycle_1.Disposable.None;\n    }\n    exports.watch = watch;\n    function sanitizeFilePath(candidate, cwd) {\n        // Special case: allow to open a drive letter without trailing backslash\n        if (platform.isWindows && strings.endsWith(candidate, ':')) {\n            candidate += paths.sep;\n        }\n        // Ensure absolute\n        if (!paths.isAbsolute(candidate)) {\n            candidate = paths.join(cwd, candidate);\n        }\n        // Ensure normalized\n        candidate = paths.normalize(candidate);\n        // Ensure no trailing slash/backslash\n        if (platform.isWindows) {\n            candidate = strings.rtrim(candidate, paths.sep);\n            // Special case: allow to open drive root ('C:\\')\n            if (strings.endsWith(candidate, ':')) {\n                candidate += paths.sep;\n            }\n        }\n        else {\n            candidate = strings.rtrim(candidate, paths.sep);\n            // Special case: allow to open root ('/')\n            if (!candidate) {\n                candidate = paths.sep;\n            }\n        }\n        return candidate;\n    }\n    exports.sanitizeFilePath = sanitizeFilePath;\n});\n",null]}