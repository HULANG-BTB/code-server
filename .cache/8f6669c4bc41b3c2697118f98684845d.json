{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/worker/defaultWorkerFactory.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/worker/defaultWorkerFactory.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/platform\", \"vs/base/common/worker/simpleWorker\"], function (require, exports, platform_1, simpleWorker_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function getWorker(workerId, label) {\n        // Option for hosts to overwrite the worker script (used in the standalone editor)\n        if (platform_1.globals.MonacoEnvironment) {\n            if (typeof platform_1.globals.MonacoEnvironment.getWorker === 'function') {\n                return platform_1.globals.MonacoEnvironment.getWorker(workerId, label);\n            }\n            if (typeof platform_1.globals.MonacoEnvironment.getWorkerUrl === 'function') {\n                return new Worker(platform_1.globals.MonacoEnvironment.getWorkerUrl(workerId, label));\n            }\n        }\n        // ESM-comment-begin\n        if (typeof require === 'function') {\n            // check if the JS lives on a different origin\n            const workerMain = require.toUrl('./' + workerId);\n            if (/^(http:)|(https:)|(file:)/.test(workerMain)) {\n                const currentUrl = String(window.location);\n                const currentOrigin = currentUrl.substr(0, currentUrl.length - window.location.hash.length - window.location.search.length - window.location.pathname.length);\n                if (workerMain.substring(0, currentOrigin.length) !== currentOrigin) {\n                    // this is the cross-origin case\n                    // i.e. the webpage is running at a different origin than where the scripts are loaded from\n                    const workerBaseUrl = workerMain.substr(0, workerMain.length - 'vs/base/worker/workerMain.js'.length);\n                    const js = `/*${label}*/self.MonacoEnvironment={baseUrl: '${workerBaseUrl}'};importScripts('${workerMain}');/*${label}*/`;\n                    const url = `data:text/javascript;charset=utf-8,${encodeURIComponent(js)}`;\n                    return new Worker(url);\n                }\n            }\n            return new Worker(workerMain + '#' + label);\n        }\n        // ESM-comment-end\n        throw new Error(`You must define a function MonacoEnvironment.getWorkerUrl or MonacoEnvironment.getWorker`);\n    }\n    function isPromiseLike(obj) {\n        if (typeof obj.then === 'function') {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * A worker that uses HTML5 web workers so that is has\n     * its own global scope and its own thread.\n     */\n    class WebWorker {\n        constructor(moduleId, id, label, onMessageCallback, onErrorCallback) {\n            this.id = id;\n            const workerOrPromise = getWorker('workerMain.js', label);\n            if (isPromiseLike(workerOrPromise)) {\n                this.worker = workerOrPromise;\n            }\n            else {\n                this.worker = Promise.resolve(workerOrPromise);\n            }\n            this.postMessage(moduleId);\n            this.worker.then((w) => {\n                w.onmessage = function (ev) {\n                    onMessageCallback(ev.data);\n                };\n                w.onmessageerror = onErrorCallback;\n                if (typeof w.addEventListener === 'function') {\n                    w.addEventListener('error', onErrorCallback);\n                }\n            });\n        }\n        getId() {\n            return this.id;\n        }\n        postMessage(msg) {\n            if (this.worker) {\n                this.worker.then(w => w.postMessage(msg));\n            }\n        }\n        dispose() {\n            if (this.worker) {\n                this.worker.then(w => w.terminate());\n            }\n            this.worker = null;\n        }\n    }\n    class DefaultWorkerFactory {\n        constructor(label) {\n            this._label = label;\n            this._webWorkerFailedBeforeError = false;\n        }\n        create(moduleId, onMessageCallback, onErrorCallback) {\n            let workerId = (++DefaultWorkerFactory.LAST_WORKER_ID);\n            if (this._webWorkerFailedBeforeError) {\n                throw this._webWorkerFailedBeforeError;\n            }\n            return new WebWorker(moduleId, workerId, this._label || 'anonymous' + workerId, onMessageCallback, (err) => {\n                simpleWorker_1.logOnceWebWorkerWarning(err);\n                this._webWorkerFailedBeforeError = err;\n                onErrorCallback(err);\n            });\n        }\n    }\n    DefaultWorkerFactory.LAST_WORKER_ID = 0;\n    exports.DefaultWorkerFactory = DefaultWorkerFactory;\n});\n",null]}