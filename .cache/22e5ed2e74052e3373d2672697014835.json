{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/model/textModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/textModel.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar errors_1 = require(\"vs/base/common/errors\");\nvar event_1 = require(\"vs/base/common/event\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar stopwatch_1 = require(\"vs/base/common/stopwatch\");\nvar strings = require(\"vs/base/common/strings\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar editorOptions_1 = require(\"vs/editor/common/config/editorOptions\");\nvar position_1 = require(\"vs/editor/common/core/position\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar selection_1 = require(\"vs/editor/common/core/selection\");\nvar model = require(\"vs/editor/common/model\");\nvar editStack_1 = require(\"vs/editor/common/model/editStack\");\nvar indentationGuesser_1 = require(\"vs/editor/common/model/indentationGuesser\");\nvar intervalTree_1 = require(\"vs/editor/common/model/intervalTree\");\nvar pieceTreeTextBufferBuilder_1 = require(\"vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder\");\nvar textModelEvents_1 = require(\"vs/editor/common/model/textModelEvents\");\nvar textModelSearch_1 = require(\"vs/editor/common/model/textModelSearch\");\nvar textModelTokens_1 = require(\"vs/editor/common/model/textModelTokens\");\nvar wordHelper_1 = require(\"vs/editor/common/model/wordHelper\");\nvar modes_1 = require(\"vs/editor/common/modes\");\nvar languageConfigurationRegistry_1 = require(\"vs/editor/common/modes/languageConfigurationRegistry\");\nvar nullMode_1 = require(\"vs/editor/common/modes/nullMode\");\nvar supports_1 = require(\"vs/editor/common/modes/supports\");\nvar richEditBrackets_1 = require(\"vs/editor/common/modes/supports/richEditBrackets\");\nvar types_1 = require(\"vs/base/common/types\");\nvar CHEAP_TOKENIZATION_LENGTH_LIMIT = 2048;\nfunction createTextBufferBuilder() {\n    return new pieceTreeTextBufferBuilder_1.PieceTreeTextBufferBuilder();\n}\nfunction createTextBufferFactory(text) {\n    var builder = createTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexports.createTextBufferFactory = createTextBufferFactory;\nfunction createTextBufferFactoryFromStream(stream, filter) {\n    return new Promise(function (c, e) {\n        var done = false;\n        var builder = createTextBufferBuilder();\n        stream.on('data', function (chunk) {\n            if (filter) {\n                chunk = filter(chunk);\n            }\n            builder.acceptChunk(chunk);\n        });\n        stream.on('error', function (error) {\n            if (!done) {\n                done = true;\n                e(error);\n            }\n        });\n        stream.on('end', function () {\n            if (!done) {\n                done = true;\n                c(builder.finish());\n            }\n        });\n    });\n}\nexports.createTextBufferFactoryFromStream = createTextBufferFactoryFromStream;\nfunction createTextBufferFactoryFromSnapshot(snapshot) {\n    var builder = createTextBufferBuilder();\n    var chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexports.createTextBufferFactoryFromSnapshot = createTextBufferFactoryFromSnapshot;\nfunction createTextBuffer(value, defaultEOL) {\n    var factory = (typeof value === 'string' ? createTextBufferFactory(value) : value);\n    return factory.create(defaultEOL);\n}\nexports.createTextBuffer = createTextBuffer;\nvar MODEL_ID = 0;\n/**\n * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.\n */\nfunction singleLetter(result) {\n    var LETTERS_CNT = (charCode_1.CharCode.Z - charCode_1.CharCode.A + 1);\n    result = result % (2 * LETTERS_CNT);\n    if (result < LETTERS_CNT) {\n        return String.fromCharCode(charCode_1.CharCode.a + result);\n    }\n    return String.fromCharCode(charCode_1.CharCode.A + result - LETTERS_CNT);\n}\nvar LIMIT_FIND_COUNT = 999;\nexports.LONG_LINE_BOUNDARY = 10000;\nvar TextModelSnapshot = /** @class */ (function () {\n    function TextModelSnapshot(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    TextModelSnapshot.prototype.read = function () {\n        if (this._eos) {\n            return null;\n        }\n        var result = [], resultCnt = 0, resultLength = 0;\n        do {\n            var tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    };\n    return TextModelSnapshot;\n}());\nvar invalidFunc = function () { throw new Error(\"Invalid change accessor\"); };\nvar TextModel = /** @class */ (function (_super) {\n    tslib_1.__extends(TextModel, _super);\n    //#endregion\n    function TextModel(source, creationOptions, languageIdentifier, associatedResource) {\n        if (associatedResource === void 0) { associatedResource = null; }\n        var _this = _super.call(this) || this;\n        //#region Events\n        _this._onWillDispose = _this._register(new event_1.Emitter());\n        _this.onWillDispose = _this._onWillDispose.event;\n        _this._onDidChangeDecorations = _this._register(new DidChangeDecorationsEmitter());\n        _this.onDidChangeDecorations = _this._onDidChangeDecorations.event;\n        _this._onDidChangeLanguage = _this._register(new event_1.Emitter());\n        _this.onDidChangeLanguage = _this._onDidChangeLanguage.event;\n        _this._onDidChangeLanguageConfiguration = _this._register(new event_1.Emitter());\n        _this.onDidChangeLanguageConfiguration = _this._onDidChangeLanguageConfiguration.event;\n        _this._onDidChangeTokens = _this._register(new event_1.Emitter());\n        _this.onDidChangeTokens = _this._onDidChangeTokens.event;\n        _this._onDidChangeOptions = _this._register(new event_1.Emitter());\n        _this.onDidChangeOptions = _this._onDidChangeOptions.event;\n        _this._eventEmitter = _this._register(new DidChangeContentEmitter());\n        // Generate a new unique model id\n        MODEL_ID++;\n        _this.id = '$model' + MODEL_ID;\n        _this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            _this._associatedResource = uri_1.URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            _this._associatedResource = associatedResource;\n        }\n        _this._attachedEditorCount = 0;\n        _this._buffer = createTextBuffer(source, creationOptions.defaultEOL);\n        _this._options = TextModel.resolveOptions(_this._buffer, creationOptions);\n        var bufferLineCount = _this._buffer.getLineCount();\n        var bufferTextLength = _this._buffer.getValueLengthInRange(new range_1.Range(1, 1, bufferLineCount, _this._buffer.getLineLength(bufferLineCount) + 1), model.EndOfLinePreference.TextDefined);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            _this._isTooLargeForTokenization = ((bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD));\n        }\n        else {\n            _this._isTooLargeForTokenization = false;\n        }\n        _this._isTooLargeForSyncing = (bufferTextLength > TextModel.MODEL_SYNC_LIMIT);\n        _this._setVersionId(1);\n        _this._isDisposed = false;\n        _this._isDisposing = false;\n        _this._languageIdentifier = languageIdentifier || nullMode_1.NULL_LANGUAGE_IDENTIFIER;\n        _this._tokenizationListener = modes_1.TokenizationRegistry.onDidChange(function (e) {\n            if (e.changedLanguages.indexOf(_this._languageIdentifier.language) === -1) {\n                return;\n            }\n            _this._resetTokenizationState();\n            _this.emitModelTokensChangedEvent({\n                tokenizationSupportChanged: true,\n                ranges: [{\n                        fromLineNumber: 1,\n                        toLineNumber: _this.getLineCount()\n                    }]\n            });\n            if (_this._shouldAutoTokenize()) {\n                _this._warmUpTokens();\n            }\n        });\n        _this._revalidateTokensTimeout = -1;\n        _this._languageRegistryListener = languageConfigurationRegistry_1.LanguageConfigurationRegistry.onDidChange(function (e) {\n            if (e.languageIdentifier.id === _this._languageIdentifier.id) {\n                _this._onDidChangeLanguageConfiguration.fire({});\n            }\n        });\n        _this._resetTokenizationState();\n        _this._instanceId = singleLetter(MODEL_ID);\n        _this._lastDecorationId = 0;\n        _this._decorations = Object.create(null);\n        _this._decorationsTree = new DecorationsTrees();\n        _this._commandManager = new editStack_1.EditStack(_this);\n        _this._isUndoing = false;\n        _this._isRedoing = false;\n        _this._trimAutoWhitespaceLines = null;\n        return _this;\n    }\n    TextModel.createFromString = function (text, options, languageIdentifier, uri) {\n        if (options === void 0) { options = TextModel.DEFAULT_CREATION_OPTIONS; }\n        if (languageIdentifier === void 0) { languageIdentifier = null; }\n        if (uri === void 0) { uri = null; }\n        return new TextModel(text, options, languageIdentifier, uri);\n    };\n    TextModel.resolveOptions = function (textBuffer, options) {\n        if (options.detectIndentation) {\n            var guessedIndentation = indentationGuesser_1.guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: guessedIndentation.tabSize,\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL\n            });\n        }\n        return new model.TextModelResolvedOptions({\n            tabSize: options.tabSize,\n            indentSize: options.indentSize,\n            insertSpaces: options.insertSpaces,\n            trimAutoWhitespace: options.trimAutoWhitespace,\n            defaultEOL: options.defaultEOL\n        });\n    };\n    TextModel.prototype.onDidChangeRawContentFast = function (listener) {\n        return this._eventEmitter.fastEvent(function (e) { return listener(e.rawContentChangedEvent); });\n    };\n    TextModel.prototype.onDidChangeRawContent = function (listener) {\n        return this._eventEmitter.slowEvent(function (e) { return listener(e.rawContentChangedEvent); });\n    };\n    TextModel.prototype.onDidChangeContent = function (listener) {\n        return this._eventEmitter.slowEvent(function (e) { return listener(e.contentChangedEvent); });\n    };\n    TextModel.prototype.dispose = function () {\n        this._isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationListener.dispose();\n        this._languageRegistryListener.dispose();\n        this._clearTimers();\n        this._isDisposed = true;\n        // Null out members, such that any use of a disposed model will throw exceptions sooner rather than later\n        _super.prototype.dispose.call(this);\n        this._isDisposing = false;\n    };\n    TextModel.prototype._assertNotDisposed = function () {\n        if (this._isDisposed) {\n            throw new Error('Model is disposed!');\n        }\n    };\n    TextModel.prototype.equalsTextBuffer = function (other) {\n        this._assertNotDisposed();\n        return this._buffer.equals(other);\n    };\n    TextModel.prototype._emitContentChangedEvent = function (rawChange, change) {\n        if (this._isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._eventEmitter.fire(new textModelEvents_1.InternalModelContentChangeEvent(rawChange, change));\n    };\n    TextModel.prototype.setValue = function (value) {\n        this._assertNotDisposed();\n        if (value === null) {\n            // There's nothing to do\n            return;\n        }\n        var textBuffer = createTextBuffer(value, this._options.defaultEOL);\n        this.setValueFromTextBuffer(textBuffer);\n    };\n    TextModel.prototype._createContentChanged2 = function (range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    };\n    TextModel.prototype.setValueFromTextBuffer = function (textBuffer) {\n        this._assertNotDisposed();\n        if (textBuffer === null) {\n            // There's nothing to do\n            return;\n        }\n        var oldFullModelRange = this.getFullModelRange();\n        var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        var endLineNumber = this.getLineCount();\n        var endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._increaseVersionId();\n        // Cancel tokenization, clear all tokens and begin tokenizing\n        this._resetTokenizationState();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager = new editStack_1.EditStack(this);\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new textModelEvents_1.ModelRawContentChangedEvent([\n            new textModelEvents_1.ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new range_1.Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));\n    };\n    TextModel.prototype.setEOL = function (eol) {\n        this._assertNotDisposed();\n        var newEOL = (eol === model.EndOfLineSequence.CRLF ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        var oldFullModelRange = this.getFullModelRange();\n        var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        var endLineNumber = this.getLineCount();\n        var endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new textModelEvents_1.ModelRawContentChangedEvent([\n            new textModelEvents_1.ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new range_1.Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));\n    };\n    TextModel.prototype._onBeforeEOLChange = function () {\n        // Ensure all decorations get their `range` set.\n        var versionId = this.getVersionId();\n        var allDecorations = this._decorationsTree.search(0, false, false, versionId);\n        this._ensureNodesHaveRanges(allDecorations);\n    };\n    TextModel.prototype._onAfterEOLChange = function () {\n        // Transform back `range` to offsets\n        var versionId = this.getVersionId();\n        var allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (var i = 0, len = allDecorations.length; i < len; i++) {\n            var node = allDecorations[i];\n            var delta = node.cachedAbsoluteStart - node.start;\n            var startOffset = this._buffer.getOffsetAt(node.range.startLineNumber, node.range.startColumn);\n            var endOffset = this._buffer.getOffsetAt(node.range.endLineNumber, node.range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            intervalTree_1.recomputeMaxEnd(node);\n        }\n    };\n    TextModel.prototype._resetTokenizationState = function () {\n        this._clearTimers();\n        var tokenizationSupport = (this._isTooLargeForTokenization\n            ? null\n            : modes_1.TokenizationRegistry.get(this._languageIdentifier.language));\n        this._tokens = new textModelTokens_1.ModelLinesTokens(this._languageIdentifier, tokenizationSupport);\n        this._beginBackgroundTokenization();\n    };\n    TextModel.prototype._clearTimers = function () {\n        if (this._revalidateTokensTimeout !== -1) {\n            clearTimeout(this._revalidateTokensTimeout);\n            this._revalidateTokensTimeout = -1;\n        }\n    };\n    TextModel.prototype.onBeforeAttached = function () {\n        this._attachedEditorCount++;\n        // Warm up tokens for the editor\n        this._warmUpTokens();\n    };\n    TextModel.prototype.onBeforeDetached = function () {\n        this._attachedEditorCount--;\n    };\n    TextModel.prototype._shouldAutoTokenize = function () {\n        return this.isAttachedToEditor();\n    };\n    TextModel.prototype.isAttachedToEditor = function () {\n        return this._attachedEditorCount > 0;\n    };\n    TextModel.prototype.getAttachedEditorCount = function () {\n        return this._attachedEditorCount;\n    };\n    TextModel.prototype.isTooLargeForSyncing = function () {\n        return this._isTooLargeForSyncing;\n    };\n    TextModel.prototype.isTooLargeForTokenization = function () {\n        return this._isTooLargeForTokenization;\n    };\n    TextModel.prototype.isDisposed = function () {\n        return this._isDisposed;\n    };\n    TextModel.prototype.isDominatedByLongLines = function () {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        var smallLineCharCount = 0;\n        var longLineCharCount = 0;\n        var lineCount = this._buffer.getLineCount();\n        for (var lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            var lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= exports.LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    };\n    Object.defineProperty(TextModel.prototype, \"uri\", {\n        get: function () {\n            return this._associatedResource;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    //#region Options\n    TextModel.prototype.getOptions = function () {\n        this._assertNotDisposed();\n        return this._options;\n    };\n    TextModel.prototype.getFormattingOptions = function () {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    };\n    TextModel.prototype.updateOptions = function (_newOpts) {\n        this._assertNotDisposed();\n        var tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        var indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.indentSize;\n        var insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        var trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        var newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        var e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._onDidChangeOptions.fire(e);\n    };\n    TextModel.prototype.detectIndentation = function (defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        var guessedIndentation = indentationGuesser_1.guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize,\n        });\n    };\n    TextModel._normalizeIndentationFromWhitespace = function (str, indentSize, insertSpaces) {\n        var spacesCnt = 0;\n        for (var i = 0; i < str.length; i++) {\n            if (str.charAt(i) === '\\t') {\n                spacesCnt += indentSize;\n            }\n            else {\n                spacesCnt++;\n            }\n        }\n        var result = '';\n        if (!insertSpaces) {\n            var tabsCnt = Math.floor(spacesCnt / indentSize);\n            spacesCnt = spacesCnt % indentSize;\n            for (var i = 0; i < tabsCnt; i++) {\n                result += '\\t';\n            }\n        }\n        for (var i = 0; i < spacesCnt; i++) {\n            result += ' ';\n        }\n        return result;\n    };\n    TextModel.normalizeIndentation = function (str, indentSize, insertSpaces) {\n        var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n        if (firstNonWhitespaceIndex === -1) {\n            firstNonWhitespaceIndex = str.length;\n        }\n        return TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n    };\n    TextModel.prototype.normalizeIndentation = function (str) {\n        this._assertNotDisposed();\n        return TextModel.normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    };\n    //#endregion\n    //#region Reading\n    TextModel.prototype.getVersionId = function () {\n        this._assertNotDisposed();\n        return this._versionId;\n    };\n    TextModel.prototype.mightContainRTL = function () {\n        return this._buffer.mightContainRTL();\n    };\n    TextModel.prototype.mightContainNonBasicASCII = function () {\n        return this._buffer.mightContainNonBasicASCII();\n    };\n    TextModel.prototype.getAlternativeVersionId = function () {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    };\n    TextModel.prototype.getOffsetAt = function (rawPosition) {\n        this._assertNotDisposed();\n        var position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, false);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    };\n    TextModel.prototype.getPositionAt = function (rawOffset) {\n        this._assertNotDisposed();\n        var offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    };\n    TextModel.prototype._increaseVersionId = function () {\n        this._setVersionId(this._versionId + 1);\n    };\n    TextModel.prototype._setVersionId = function (newVersionId) {\n        this._versionId = newVersionId;\n        this._alternativeVersionId = this._versionId;\n    };\n    TextModel.prototype._overwriteAlternativeVersionId = function (newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    };\n    TextModel.prototype.getValue = function (eol, preserveBOM) {\n        if (preserveBOM === void 0) { preserveBOM = false; }\n        this._assertNotDisposed();\n        var fullModelRange = this.getFullModelRange();\n        var fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    };\n    TextModel.prototype.createSnapshot = function (preserveBOM) {\n        if (preserveBOM === void 0) { preserveBOM = false; }\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    };\n    TextModel.prototype.getValueLength = function (eol, preserveBOM) {\n        if (preserveBOM === void 0) { preserveBOM = false; }\n        this._assertNotDisposed();\n        var fullModelRange = this.getFullModelRange();\n        var fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    };\n    TextModel.prototype.getValueInRange = function (rawRange, eol) {\n        if (eol === void 0) { eol = model.EndOfLinePreference.TextDefined; }\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    };\n    TextModel.prototype.getValueLengthInRange = function (rawRange, eol) {\n        if (eol === void 0) { eol = model.EndOfLinePreference.TextDefined; }\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    };\n    TextModel.prototype.getLineCount = function () {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    };\n    TextModel.prototype.getLineContent = function (lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    };\n    TextModel.prototype.getLineLength = function (lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    };\n    TextModel.prototype.getLinesContent = function () {\n        this._assertNotDisposed();\n        return this._buffer.getLinesContent();\n    };\n    TextModel.prototype.getEOL = function () {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    };\n    TextModel.prototype.getLineMinColumn = function (lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    };\n    TextModel.prototype.getLineMaxColumn = function (lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    };\n    TextModel.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    };\n    TextModel.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    };\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    TextModel.prototype._validateRangeRelaxedNoAllocations = function (range) {\n        var linesCount = this._buffer.getLineCount();\n        var initialStartLineNumber = range.startLineNumber;\n        var initialStartColumn = range.startColumn;\n        var startLineNumber;\n        var startColumn;\n        if (initialStartLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (initialStartLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            startLineNumber = initialStartLineNumber | 0;\n            if (initialStartColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                var maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (initialStartColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n                else {\n                    startColumn = initialStartColumn | 0;\n                }\n            }\n        }\n        var initialEndLineNumber = range.endLineNumber;\n        var initialEndColumn = range.endColumn;\n        var endLineNumber;\n        var endColumn;\n        if (initialEndLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (initialEndLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            endLineNumber = initialEndLineNumber | 0;\n            if (initialEndColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                var maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (initialEndColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n                else {\n                    endColumn = initialEndColumn | 0;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof range_1.Range\n            && !(range instanceof selection_1.Selection)) {\n            return range;\n        }\n        return new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    };\n    /**\n     * @param strict Do NOT allow a position inside a high-low surrogate pair\n     */\n    TextModel.prototype._isValidPosition = function (lineNumber, column, strict) {\n        if (isNaN(lineNumber)) {\n            return false;\n        }\n        if (lineNumber < 1) {\n            return false;\n        }\n        var lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (isNaN(column)) {\n            return false;\n        }\n        if (column < 1) {\n            return false;\n        }\n        var maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (strict) {\n            if (column > 1) {\n                var charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n    /**\n     * @param strict Do NOT allow a position inside a high-low surrogate pair\n     */\n    TextModel.prototype._validatePosition = function (_lineNumber, _column, strict) {\n        var lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        var column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        var lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new position_1.Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new position_1.Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new position_1.Position(lineNumber, 1);\n        }\n        var maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new position_1.Position(lineNumber, maxColumn);\n        }\n        if (strict) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            var charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new position_1.Position(lineNumber, column - 1);\n            }\n        }\n        return new position_1.Position(lineNumber, column);\n    };\n    TextModel.prototype.validatePosition = function (position) {\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof position_1.Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, true)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, true);\n    };\n    /**\n     * @param strict Do NOT allow a range to have its boundaries inside a high-low surrogate pair\n     */\n    TextModel.prototype._isValidRange = function (range, strict) {\n        var startLineNumber = range.startLineNumber;\n        var startColumn = range.startColumn;\n        var endLineNumber = range.endLineNumber;\n        var endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, false)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, false)) {\n            return false;\n        }\n        if (strict) {\n            var charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            var charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            var startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            var endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    };\n    TextModel.prototype.validateRange = function (_range) {\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof range_1.Range) && !(_range instanceof selection_1.Selection)) {\n            if (this._isValidRange(_range, true)) {\n                return _range;\n            }\n        }\n        var start = this._validatePosition(_range.startLineNumber, _range.startColumn, false);\n        var end = this._validatePosition(_range.endLineNumber, _range.endColumn, false);\n        var startLineNumber = start.lineNumber;\n        var startColumn = start.column;\n        var endLineNumber = end.lineNumber;\n        var endColumn = end.column;\n        var charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n        var charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n        var startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n        var endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n        if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n            return new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        if (startLineNumber === endLineNumber && startColumn === endColumn) {\n            // do not expand a collapsed range, simply move it to a valid location\n            return new range_1.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n        }\n        if (startInsideSurrogatePair && endInsideSurrogatePair) {\n            // expand range at both ends\n            return new range_1.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n        }\n        if (startInsideSurrogatePair) {\n            // only expand range at the start\n            return new range_1.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n        }\n        // only expand range at the end\n        return new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n    };\n    TextModel.prototype.modifyPosition = function (rawPosition, offset) {\n        this._assertNotDisposed();\n        var candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    };\n    TextModel.prototype.getFullModelRange = function () {\n        this._assertNotDisposed();\n        var lineCount = this.getLineCount();\n        return new range_1.Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    };\n    TextModel.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    };\n    TextModel.prototype.findMatches = function (searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount) {\n        if (limitResultCount === void 0) { limitResultCount = LIMIT_FIND_COUNT; }\n        this._assertNotDisposed();\n        var searchRange;\n        if (range_1.Range.isIRange(rawSearchScope)) {\n            searchRange = this.validateRange(rawSearchScope);\n        }\n        else {\n            searchRange = this.getFullModelRange();\n        }\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            var searchParams = new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            var searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            return this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        return textModelSearch_1.TextModelSearch.findMatches(this, new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n    };\n    TextModel.prototype.findNextMatch = function (searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        var searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            var searchParams = new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            var searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            var lineCount = this.getLineCount();\n            var searchRange = new range_1.Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            var ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            textModelSearch_1.TextModelSearch.findNextMatch(this, new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new range_1.Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return textModelSearch_1.TextModelSearch.findNextMatch(this, new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    };\n    TextModel.prototype.findPreviousMatch = function (searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        var searchStart = this.validatePosition(rawSearchStart);\n        return textModelSearch_1.TextModelSearch.findPreviousMatch(this, new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    };\n    //#endregion\n    //#region Editing\n    TextModel.prototype.pushStackElement = function () {\n        this._commandManager.pushStackElement();\n    };\n    TextModel.prototype.pushEOL = function (eol) {\n        var currentEOL = (this.getEOL() === '\\n' ? model.EndOfLineSequence.LF : model.EndOfLineSequence.CRLF);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    };\n    TextModel.prototype.pushEditOperations = function (beforeCursorState, editOperations, cursorStateComputer) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, editOperations, cursorStateComputer);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    };\n    TextModel.prototype._pushEditOperations = function (beforeCursorState, editOperations, cursorStateComputer) {\n        var _this = this;\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            var incomingEdits = editOperations.map(function (op) {\n                return {\n                    range: _this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            var editsAreNearCursors = true;\n            for (var i = 0, len = beforeCursorState.length; i < len; i++) {\n                var sel = beforeCursorState[i];\n                var foundEditNearSel = false;\n                for (var j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                    var editRange = incomingEdits[j].range;\n                    var selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                    var selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                    if (!selIsAbove && !selIsBelow) {\n                        foundEditNearSel = true;\n                        break;\n                    }\n                }\n                if (!foundEditNearSel) {\n                    editsAreNearCursors = false;\n                    break;\n                }\n            }\n            if (editsAreNearCursors) {\n                for (var i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    var trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    var maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    var allowTrimLine = true;\n                    for (var j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        var editRange = incomingEdits[j].range;\n                        var editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        editOperations.push({\n                            range: new range_1.Range(trimLineNumber, 1, trimLineNumber, maxLineColumn),\n                            text: null\n                        });\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\n    };\n    TextModel.prototype.applyEdits = function (rawOperations) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._applyEdits(rawOperations);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    };\n    TextModel._eolCount = function (text) {\n        var eolCount = 0;\n        var firstLineLength = 0;\n        for (var i = 0, len = text.length; i < len; i++) {\n            var chr = text.charCodeAt(i);\n            if (chr === charCode_1.CharCode.CarriageReturn) {\n                if (eolCount === 0) {\n                    firstLineLength = i;\n                }\n                eolCount++;\n                if (i + 1 < len && text.charCodeAt(i + 1) === charCode_1.CharCode.LineFeed) {\n                    // \\r\\n... case\n                    i++; // skip \\n\n                }\n                else {\n                    // \\r... case\n                }\n            }\n            else if (chr === charCode_1.CharCode.LineFeed) {\n                if (eolCount === 0) {\n                    firstLineLength = i;\n                }\n                eolCount++;\n            }\n        }\n        if (eolCount === 0) {\n            firstLineLength = text.length;\n        }\n        return [eolCount, firstLineLength];\n    };\n    TextModel.prototype._applyEdits = function (rawOperations) {\n        for (var i = 0, len = rawOperations.length; i < len; i++) {\n            rawOperations[i].range = this.validateRange(rawOperations[i].range);\n        }\n        var oldLineCount = this._buffer.getLineCount();\n        var result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace);\n        var newLineCount = this._buffer.getLineCount();\n        var contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            var rawContentChanges = [];\n            var lineCount = oldLineCount;\n            for (var i = 0, len = contentChanges.length; i < len; i++) {\n                var change = contentChanges[i];\n                var _a = TextModel._eolCount(change.text), eolCount = _a[0], firstLineLength = _a[1];\n                try {\n                    this._tokens.applyEdits(change.range, eolCount, firstLineLength);\n                }\n                catch (err) {\n                    // emergency recovery => reset tokens\n                    this._tokens = new textModelTokens_1.ModelLinesTokens(this._tokens.languageIdentifier, this._tokens.tokenizationSupport);\n                }\n                this._onDidChangeDecorations.fire();\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n                var startLineNumber = change.range.startLineNumber;\n                var endLineNumber = change.range.endLineNumber;\n                var deletingLinesCnt = endLineNumber - startLineNumber;\n                var insertingLinesCnt = eolCount;\n                var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                var changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                for (var j = editingLinesCnt; j >= 0; j--) {\n                    var editLineNumber = startLineNumber + j;\n                    var currentEditLineNumber = newLineCount - lineCount - changeLineCountDelta + editLineNumber;\n                    rawContentChanges.push(new textModelEvents_1.ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber)));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    var spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new textModelEvents_1.ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    // Must insert some lines\n                    var spliceLineNumber = startLineNumber + editingLinesCnt;\n                    var cnt = insertingLinesCnt - editingLinesCnt;\n                    var fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    var newLines = [];\n                    for (var i_1 = 0; i_1 < cnt; i_1++) {\n                        var lineNumber = fromLineNumber + i_1;\n                        newLines[lineNumber - fromLineNumber] = this.getLineContent(lineNumber);\n                    }\n                    rawContentChanges.push(new textModelEvents_1.ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._increaseVersionId();\n            this._emitContentChangedEvent(new textModelEvents_1.ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        if (this._tokens.hasLinesToTokenize(this._buffer)) {\n            this._beginBackgroundTokenization();\n        }\n        return result.reverseEdits;\n    };\n    TextModel.prototype._undo = function () {\n        this._isUndoing = true;\n        var r = this._commandManager.undo();\n        this._isUndoing = false;\n        if (!r) {\n            return null;\n        }\n        this._overwriteAlternativeVersionId(r.recordedVersionId);\n        return r.selections;\n    };\n    TextModel.prototype.undo = function () {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._undo();\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    };\n    TextModel.prototype.canUndo = function () {\n        return this._commandManager.canUndo();\n    };\n    TextModel.prototype._redo = function () {\n        this._isRedoing = true;\n        var r = this._commandManager.redo();\n        this._isRedoing = false;\n        if (!r) {\n            return null;\n        }\n        this._overwriteAlternativeVersionId(r.recordedVersionId);\n        return r.selections;\n    };\n    TextModel.prototype.redo = function () {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._redo();\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    };\n    TextModel.prototype.canRedo = function () {\n        return this._commandManager.canRedo();\n    };\n    //#endregion\n    //#region Decorations\n    TextModel.prototype.changeDecorations = function (callback, ownerId) {\n        if (ownerId === void 0) { ownerId = 0; }\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    };\n    TextModel.prototype._changeDecorations = function (ownerId, callback) {\n        var _this = this;\n        var changeAccessor = {\n            addDecoration: function (range, options) {\n                _this._onDidChangeDecorations.fire();\n                return _this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: function (id, newRange) {\n                _this._onDidChangeDecorations.fire();\n                _this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: function (id, options) {\n                _this._onDidChangeDecorations.fire();\n                _this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: function (id) {\n                _this._onDidChangeDecorations.fire();\n                _this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: function (oldDecorations, newDecorations) {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                _this._onDidChangeDecorations.fire();\n                return _this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        var result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            errors_1.onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    };\n    TextModel.prototype.deltaDecorations = function (oldDecorations, newDecorations, ownerId) {\n        if (ownerId === void 0) { ownerId = 0; }\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    };\n    TextModel.prototype._getTrackedRange = function (id) {\n        return this.getDecorationRange(id);\n    };\n    TextModel.prototype._setTrackedRange = function (id, newRange, newStickiness) {\n        var node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }])[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        var range = this._validateRangeRelaxedNoAllocations(newRange);\n        var startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        var endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    };\n    TextModel.prototype.removeAllDecorationsWithOwnerId = function (ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        var nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (var i = 0, len = nodes.length; i < len; i++) {\n            var node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    };\n    TextModel.prototype.getDecorationOptions = function (decorationId) {\n        var node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    };\n    TextModel.prototype.getDecorationRange = function (decorationId) {\n        var node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        var versionId = this.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._decorationsTree.resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    };\n    TextModel.prototype.getLineDecorations = function (lineNumber, ownerId, filterOutValidation) {\n        if (ownerId === void 0) { ownerId = 0; }\n        if (filterOutValidation === void 0) { filterOutValidation = false; }\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    };\n    TextModel.prototype.getLinesDecorations = function (_startLineNumber, _endLineNumber, ownerId, filterOutValidation) {\n        if (ownerId === void 0) { ownerId = 0; }\n        if (filterOutValidation === void 0) { filterOutValidation = false; }\n        var lineCount = this.getLineCount();\n        var startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        var endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        var endColumn = this.getLineMaxColumn(endLineNumber);\n        return this._getDecorationsInRange(new range_1.Range(startLineNumber, 1, endLineNumber, endColumn), ownerId, filterOutValidation);\n    };\n    TextModel.prototype.getDecorationsInRange = function (range, ownerId, filterOutValidation) {\n        if (ownerId === void 0) { ownerId = 0; }\n        if (filterOutValidation === void 0) { filterOutValidation = false; }\n        var validatedRange = this.validateRange(range);\n        return this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\n    };\n    TextModel.prototype.getOverviewRulerDecorations = function (ownerId, filterOutValidation) {\n        if (ownerId === void 0) { ownerId = 0; }\n        if (filterOutValidation === void 0) { filterOutValidation = false; }\n        var versionId = this.getVersionId();\n        var result = this._decorationsTree.search(ownerId, filterOutValidation, true, versionId);\n        return this._ensureNodesHaveRanges(result);\n    };\n    TextModel.prototype.getAllDecorations = function (ownerId, filterOutValidation) {\n        if (ownerId === void 0) { ownerId = 0; }\n        if (filterOutValidation === void 0) { filterOutValidation = false; }\n        var versionId = this.getVersionId();\n        var result = this._decorationsTree.search(ownerId, filterOutValidation, false, versionId);\n        return this._ensureNodesHaveRanges(result);\n    };\n    TextModel.prototype._getDecorationsInRange = function (filterRange, filterOwnerId, filterOutValidation) {\n        var startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        var endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        var versionId = this.getVersionId();\n        var result = this._decorationsTree.intervalSearch(startOffset, endOffset, filterOwnerId, filterOutValidation, versionId);\n        return this._ensureNodesHaveRanges(result);\n    };\n    TextModel.prototype._ensureNodesHaveRanges = function (nodes) {\n        for (var i = 0, len = nodes.length; i < len; i++) {\n            var node = nodes[i];\n            if (node.range === null) {\n                node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    };\n    TextModel.prototype._getRangeAt = function (start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    };\n    TextModel.prototype._changeDecorationImpl = function (decorationId, _range) {\n        var node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        var range = this._validateRangeRelaxedNoAllocations(_range);\n        var startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        var endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n    };\n    TextModel.prototype._changeDecorationOptionsImpl = function (decorationId, options) {\n        var node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        var nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        var nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n            // Delete + Insert due to an overview ruler status change\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    };\n    TextModel.prototype._deltaDecorationsImpl = function (ownerId, oldDecorationsIds, newDecorations) {\n        var versionId = this.getVersionId();\n        var oldDecorationsLen = oldDecorationsIds.length;\n        var oldDecorationIndex = 0;\n        var newDecorationsLen = newDecorations.length;\n        var newDecorationIndex = 0;\n        var result = new Array(newDecorationsLen);\n        while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n            var node = null;\n            if (oldDecorationIndex < oldDecorationsLen) {\n                // (1) get ourselves an old node\n                do {\n                    node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                } while (!node && oldDecorationIndex < oldDecorationsLen);\n                // (2) remove the node from the tree (if it exists)\n                if (node) {\n                    this._decorationsTree.delete(node);\n                }\n            }\n            if (newDecorationIndex < newDecorationsLen) {\n                // (3) create a new node if necessary\n                if (!node) {\n                    var internalDecorationId = (++this._lastDecorationId);\n                    var decorationId = this._instanceId + \";\" + internalDecorationId;\n                    node = new intervalTree_1.IntervalNode(decorationId, 0, 0);\n                    this._decorations[decorationId] = node;\n                }\n                // (4) initialize node\n                var newDecoration = newDecorations[newDecorationIndex];\n                var range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                var options = _normalizeOptions(newDecoration.options);\n                var startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                var endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                node.ownerId = ownerId;\n                node.reset(versionId, startOffset, endOffset, range);\n                node.setOptions(options);\n                this._decorationsTree.insert(node);\n                result[newDecorationIndex] = node.id;\n                newDecorationIndex++;\n            }\n            else {\n                if (node) {\n                    delete this._decorations[node.id];\n                }\n            }\n        }\n        return result;\n    };\n    //#endregion\n    //#region Tokenization\n    TextModel.prototype.tokenizeViewport = function (startLineNumber, endLineNumber) {\n        if (!this._tokens.tokenizationSupport) {\n            // nothing to do\n            return;\n        }\n        startLineNumber = Math.max(1, startLineNumber);\n        endLineNumber = Math.min(this.getLineCount(), endLineNumber);\n        if (endLineNumber <= this._tokens.inValidLineStartIndex) {\n            // nothing to do\n            return;\n        }\n        if (startLineNumber <= this._tokens.inValidLineStartIndex) {\n            // tokenization has reached the viewport start...\n            this.forceTokenization(endLineNumber);\n            return;\n        }\n        var nonWhitespaceColumn = this.getLineFirstNonWhitespaceColumn(startLineNumber);\n        var fakeLines = [];\n        var initialState = null;\n        for (var i = startLineNumber - 1; nonWhitespaceColumn > 0 && i >= 1; i--) {\n            var newNonWhitespaceIndex = this.getLineFirstNonWhitespaceColumn(i);\n            if (newNonWhitespaceIndex === 0) {\n                continue;\n            }\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n                initialState = this._tokens._getState(i - 1);\n                if (initialState) {\n                    break;\n                }\n                fakeLines.push(this.getLineContent(i));\n                nonWhitespaceColumn = newNonWhitespaceIndex;\n            }\n        }\n        if (!initialState) {\n            initialState = this._tokens.tokenizationSupport.getInitialState();\n        }\n        var state = initialState.clone();\n        for (var i = fakeLines.length - 1; i >= 0; i--) {\n            var r = this._tokens._tokenizeText(this._buffer, fakeLines[i], state);\n            if (r) {\n                state = r.endState.clone();\n            }\n            else {\n                state = initialState.clone();\n            }\n        }\n        var eventBuilder = new textModelTokens_1.ModelTokensChangedEventBuilder();\n        for (var i = startLineNumber; i <= endLineNumber; i++) {\n            var text = this.getLineContent(i);\n            var r = this._tokens._tokenizeText(this._buffer, text, state);\n            if (r) {\n                this._tokens._setTokens(this._tokens.languageIdentifier.id, i - 1, text.length, r.tokens);\n                // We cannot trust these states/tokens to be valid!\n                // (see https://github.com/Microsoft/vscode/issues/67607)\n                this._tokens._setIsInvalid(i - 1, true);\n                this._tokens._setState(i - 1, state);\n                state = r.endState.clone();\n                eventBuilder.registerChangedTokens(i);\n            }\n            else {\n                state = initialState.clone();\n            }\n        }\n        var e = eventBuilder.build();\n        if (e) {\n            this._onDidChangeTokens.fire(e);\n        }\n    };\n    TextModel.prototype.flushTokens = function () {\n        this._resetTokenizationState();\n        this.emitModelTokensChangedEvent({\n            tokenizationSupportChanged: false,\n            ranges: [{\n                    fromLineNumber: 1,\n                    toLineNumber: this.getLineCount()\n                }]\n        });\n    };\n    TextModel.prototype.forceTokenization = function (lineNumber) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        var eventBuilder = new textModelTokens_1.ModelTokensChangedEventBuilder();\n        this._tokens._updateTokensUntilLine(this._buffer, eventBuilder, lineNumber);\n        var e = eventBuilder.build();\n        if (e) {\n            this._onDidChangeTokens.fire(e);\n        }\n    };\n    TextModel.prototype.isCheapToTokenize = function (lineNumber) {\n        if (!this._tokens.isCheapToTokenize(lineNumber)) {\n            return false;\n        }\n        if (lineNumber < this._tokens.inValidLineStartIndex + 1) {\n            return true;\n        }\n        if (this.getLineLength(lineNumber) < CHEAP_TOKENIZATION_LENGTH_LIMIT) {\n            return true;\n        }\n        return false;\n    };\n    TextModel.prototype.tokenizeIfCheap = function (lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    };\n    TextModel.prototype.getLineTokens = function (lineNumber) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._getLineTokens(lineNumber);\n    };\n    TextModel.prototype._getLineTokens = function (lineNumber) {\n        var lineText = this._buffer.getLineContent(lineNumber);\n        return this._tokens.getTokens(this._languageIdentifier.id, lineNumber - 1, lineText);\n    };\n    TextModel.prototype.getLanguageIdentifier = function () {\n        return this._languageIdentifier;\n    };\n    TextModel.prototype.getModeId = function () {\n        return this._languageIdentifier.language;\n    };\n    TextModel.prototype.setMode = function (languageIdentifier) {\n        if (this._languageIdentifier.id === languageIdentifier.id) {\n            // There's nothing to do\n            return;\n        }\n        var e = {\n            oldLanguage: this._languageIdentifier.language,\n            newLanguage: languageIdentifier.language\n        };\n        this._languageIdentifier = languageIdentifier;\n        // Cancel tokenization, clear all tokens and begin tokenizing\n        this._resetTokenizationState();\n        this.emitModelTokensChangedEvent({\n            tokenizationSupportChanged: true,\n            ranges: [{\n                    fromLineNumber: 1,\n                    toLineNumber: this.getLineCount()\n                }]\n        });\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    };\n    TextModel.prototype.getLanguageIdAtPosition = function (_lineNumber, _column) {\n        if (!this._tokens.tokenizationSupport) {\n            return this._languageIdentifier.id;\n        }\n        var _a = this.validatePosition({ lineNumber: _lineNumber, column: _column }), lineNumber = _a.lineNumber, column = _a.column;\n        var lineTokens = this._getLineTokens(lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(column - 1));\n    };\n    TextModel.prototype._beginBackgroundTokenization = function () {\n        var _this = this;\n        if (this._shouldAutoTokenize() && this._revalidateTokensTimeout === -1) {\n            this._revalidateTokensTimeout = setTimeout(function () {\n                _this._revalidateTokensTimeout = -1;\n                _this._revalidateTokensNow();\n            }, 0);\n        }\n    };\n    TextModel.prototype._warmUpTokens = function () {\n        // Warm up first 100 lines (if it takes less than 50ms)\n        var maxLineNumber = Math.min(100, this.getLineCount());\n        this._revalidateTokensNow(maxLineNumber);\n        if (this._tokens.hasLinesToTokenize(this._buffer)) {\n            this._beginBackgroundTokenization();\n        }\n    };\n    TextModel.prototype._revalidateTokensNow = function (toLineNumber) {\n        if (toLineNumber === void 0) { toLineNumber = this._buffer.getLineCount(); }\n        var MAX_ALLOWED_TIME = 20;\n        var eventBuilder = new textModelTokens_1.ModelTokensChangedEventBuilder();\n        var sw = stopwatch_1.StopWatch.create(false);\n        while (this._tokens.hasLinesToTokenize(this._buffer)) {\n            if (sw.elapsed() > MAX_ALLOWED_TIME) {\n                // Stop if MAX_ALLOWED_TIME is reached\n                break;\n            }\n            var tokenizedLineNumber = this._tokens._tokenizeOneLine(this._buffer, eventBuilder);\n            if (tokenizedLineNumber >= toLineNumber) {\n                break;\n            }\n        }\n        if (this._tokens.hasLinesToTokenize(this._buffer)) {\n            this._beginBackgroundTokenization();\n        }\n        var e = eventBuilder.build();\n        if (e) {\n            this._onDidChangeTokens.fire(e);\n        }\n    };\n    TextModel.prototype.emitModelTokensChangedEvent = function (e) {\n        if (!this._isDisposing) {\n            this._onDidChangeTokens.fire(e);\n        }\n    };\n    // Having tokens allows implementing additional helper methods\n    TextModel.prototype.getWordAtPosition = function (_position) {\n        this._assertNotDisposed();\n        var position = this.validatePosition(_position);\n        var lineContent = this.getLineContent(position.lineNumber);\n        var lineTokens = this._getLineTokens(position.lineNumber);\n        var tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        var _a = TextModel._findLanguageBoundaries(lineTokens, tokenIndex), rbStartOffset = _a[0], rbEndOffset = _a[1];\n        var rightBiasedWord = wordHelper_1.getWordAtText(position.column, languageConfigurationRegistry_1.LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex)), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            var _b = TextModel._findLanguageBoundaries(lineTokens, tokenIndex - 1), lbStartOffset = _b[0], lbEndOffset = _b[1];\n            var leftBiasedWord = wordHelper_1.getWordAtText(position.column, languageConfigurationRegistry_1.LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex - 1)), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    };\n    TextModel._findLanguageBoundaries = function (lineTokens, tokenIndex) {\n        var languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        var startOffset = 0;\n        for (var i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        var endOffset = lineTokens.getLineContent().length;\n        for (var i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    };\n    TextModel.prototype.getWordUntilPosition = function (position) {\n        var wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return {\n                word: '',\n                startColumn: position.column,\n                endColumn: position.column\n            };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column\n        };\n    };\n    TextModel.prototype.findMatchingBracketUp = function (_bracket, _position) {\n        var bracket = _bracket.toLowerCase();\n        var position = this.validatePosition(_position);\n        var lineTokens = this._getLineTokens(position.lineNumber);\n        var languageId = lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n        var bracketsSupport = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(languageId);\n        if (!bracketsSupport) {\n            return null;\n        }\n        var data = bracketsSupport.textIsBracket[bracket];\n        if (!data) {\n            return null;\n        }\n        return this._findMatchingBracketUp(data, position);\n    };\n    TextModel.prototype.matchBracket = function (position) {\n        return this._matchBracket(this.validatePosition(position));\n    };\n    TextModel.prototype._matchBracket = function (position) {\n        var lineNumber = position.lineNumber;\n        var lineTokens = this._getLineTokens(lineNumber);\n        var lineText = this._buffer.getLineContent(lineNumber);\n        var tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        var currentModeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex));\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !supports_1.ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            // limit search to not go before `maxBracketLength`\n            var searchStartOffset = Math.max(lineTokens.getStartOffset(tokenIndex), position.column - 1 - currentModeBrackets.maxBracketLength);\n            // limit search to not go after `maxBracketLength`\n            var searchEndOffset = Math.min(lineTokens.getEndOffset(tokenIndex), position.column - 1 + currentModeBrackets.maxBracketLength);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            var bestResult = null;\n            while (true) {\n                var foundBracket = richEditBrackets_1.BracketsUtils.findNextBracketInToken(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);\n                    foundBracketText = foundBracketText.toLowerCase();\n                    var r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText]);\n                    // check that we can actually match this bracket\n                    if (r) {\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            var searchEndOffset = lineTokens.getStartOffset(tokenIndex);\n            tokenIndex--;\n            var prevModeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex));\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !supports_1.ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n                // limit search in case previous token is very large, there's no need to go beyond `maxBracketLength`\n                var searchStartOffset = Math.max(lineTokens.getStartOffset(tokenIndex), position.column - 1 - prevModeBrackets.maxBracketLength);\n                var foundBracket = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);\n                    foundBracketText = foundBracketText.toLowerCase();\n                    var r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText]);\n                    // check that we can actually match this bracket\n                    if (r) {\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    };\n    TextModel.prototype._matchFoundBracket = function (foundBracket, data, isOpen) {\n        if (!data) {\n            return null;\n        }\n        if (isOpen) {\n            var matched = this._findMatchingBracketDown(data, foundBracket.getEndPosition());\n            if (matched) {\n                return [foundBracket, matched];\n            }\n        }\n        else {\n            var matched = this._findMatchingBracketUp(data, foundBracket.getStartPosition());\n            if (matched) {\n                return [foundBracket, matched];\n            }\n        }\n        return null;\n    };\n    TextModel.prototype._findMatchingBracketUp = function (bracket, position) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        var languageId = bracket.languageIdentifier.id;\n        var reversedBracketRegex = bracket.reversedRegex;\n        var count = -1;\n        for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            var lineTokens = this._getLineTokens(lineNumber);\n            var tokenCount = lineTokens.getCount();\n            var lineText = this._buffer.getLineContent(lineNumber);\n            var tokenIndex = tokenCount - 1;\n            var searchStopOffset = -1;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStopOffset = position.column - 1;\n            }\n            for (; tokenIndex >= 0; tokenIndex--) {\n                var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                var tokenType = lineTokens.getStandardTokenType(tokenIndex);\n                var tokenStartOffset = lineTokens.getStartOffset(tokenIndex);\n                var tokenEndOffset = lineTokens.getEndOffset(tokenIndex);\n                if (searchStopOffset === -1) {\n                    searchStopOffset = tokenEndOffset;\n                }\n                if (tokenLanguageId === languageId && !supports_1.ignoreBracketsInToken(tokenType)) {\n                    while (true) {\n                        var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(reversedBracketRegex, lineNumber, lineText, tokenStartOffset, searchStopOffset);\n                        if (!r) {\n                            break;\n                        }\n                        var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);\n                        hitText = hitText.toLowerCase();\n                        if (hitText === bracket.open) {\n                            count++;\n                        }\n                        else if (hitText === bracket.close) {\n                            count--;\n                        }\n                        if (count === 0) {\n                            return r;\n                        }\n                        searchStopOffset = r.startColumn - 1;\n                    }\n                }\n                searchStopOffset = -1;\n            }\n        }\n        return null;\n    };\n    TextModel.prototype._findMatchingBracketDown = function (bracket, position) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        var languageId = bracket.languageIdentifier.id;\n        var bracketRegex = bracket.forwardRegex;\n        var count = 1;\n        for (var lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n            var lineTokens = this._getLineTokens(lineNumber);\n            var tokenCount = lineTokens.getCount();\n            var lineText = this._buffer.getLineContent(lineNumber);\n            var tokenIndex = 0;\n            var searchStartOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n            }\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                var tokenType = lineTokens.getStandardTokenType(tokenIndex);\n                var tokenStartOffset = lineTokens.getStartOffset(tokenIndex);\n                var tokenEndOffset = lineTokens.getEndOffset(tokenIndex);\n                if (searchStartOffset === 0) {\n                    searchStartOffset = tokenStartOffset;\n                }\n                if (tokenLanguageId === languageId && !supports_1.ignoreBracketsInToken(tokenType)) {\n                    while (true) {\n                        var r = richEditBrackets_1.BracketsUtils.findNextBracketInToken(bracketRegex, lineNumber, lineText, searchStartOffset, tokenEndOffset);\n                        if (!r) {\n                            break;\n                        }\n                        var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);\n                        hitText = hitText.toLowerCase();\n                        if (hitText === bracket.open) {\n                            count++;\n                        }\n                        else if (hitText === bracket.close) {\n                            count--;\n                        }\n                        if (count === 0) {\n                            return r;\n                        }\n                        searchStartOffset = r.endColumn - 1;\n                    }\n                }\n                searchStartOffset = 0;\n            }\n        }\n        return null;\n    };\n    TextModel.prototype.findPrevBracket = function (_position) {\n        var position = this.validatePosition(_position);\n        var languageId = -1;\n        var modeBrackets = null;\n        for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            var lineTokens = this._getLineTokens(lineNumber);\n            var tokenCount = lineTokens.getCount();\n            var lineText = this._buffer.getLineContent(lineNumber);\n            var tokenIndex = tokenCount - 1;\n            var searchStopOffset = -1;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStopOffset = position.column - 1;\n            }\n            for (; tokenIndex >= 0; tokenIndex--) {\n                var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                var tokenType = lineTokens.getStandardTokenType(tokenIndex);\n                var tokenStartOffset = lineTokens.getStartOffset(tokenIndex);\n                var tokenEndOffset = lineTokens.getEndOffset(tokenIndex);\n                if (searchStopOffset === -1) {\n                    searchStopOffset = tokenEndOffset;\n                }\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(languageId);\n                }\n                if (modeBrackets && !supports_1.ignoreBracketsInToken(tokenType)) {\n                    var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(modeBrackets.reversedRegex, lineNumber, lineText, tokenStartOffset, searchStopOffset);\n                    if (r) {\n                        return this._toFoundBracket(modeBrackets, r);\n                    }\n                }\n                searchStopOffset = -1;\n            }\n        }\n        return null;\n    };\n    TextModel.prototype.findNextBracket = function (_position) {\n        var position = this.validatePosition(_position);\n        var languageId = -1;\n        var modeBrackets = null;\n        for (var lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n            var lineTokens = this._getLineTokens(lineNumber);\n            var tokenCount = lineTokens.getCount();\n            var lineText = this._buffer.getLineContent(lineNumber);\n            var tokenIndex = 0;\n            var searchStartOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n            }\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                var tokenType = lineTokens.getStandardTokenType(tokenIndex);\n                var tokenStartOffset = lineTokens.getStartOffset(tokenIndex);\n                var tokenEndOffset = lineTokens.getEndOffset(tokenIndex);\n                if (searchStartOffset === 0) {\n                    searchStartOffset = tokenStartOffset;\n                }\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(languageId);\n                }\n                if (modeBrackets && !supports_1.ignoreBracketsInToken(tokenType)) {\n                    var r = richEditBrackets_1.BracketsUtils.findNextBracketInToken(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, tokenEndOffset);\n                    if (r) {\n                        return this._toFoundBracket(modeBrackets, r);\n                    }\n                }\n                searchStartOffset = 0;\n            }\n        }\n        return null;\n    };\n    TextModel.prototype._toFoundBracket = function (modeBrackets, r) {\n        if (!r) {\n            return null;\n        }\n        var text = this.getValueInRange(r);\n        text = text.toLowerCase();\n        var data = modeBrackets.textIsBracket[text];\n        if (!data) {\n            return null;\n        }\n        return {\n            range: r,\n            open: data.open,\n            close: data.close,\n            isOpen: modeBrackets.textIsOpenBracket[text]\n        };\n    };\n    /**\n     * Returns:\n     *  - -1 => the line consists of whitespace\n     *  - otherwise => the indent level is returned value\n     */\n    TextModel.computeIndentLevel = function (line, tabSize) {\n        var indent = 0;\n        var i = 0;\n        var len = line.length;\n        while (i < len) {\n            var chCode = line.charCodeAt(i);\n            if (chCode === charCode_1.CharCode.Space) {\n                indent++;\n            }\n            else if (chCode === charCode_1.CharCode.Tab) {\n                indent = indent - indent % tabSize + tabSize;\n            }\n            else {\n                break;\n            }\n            i++;\n        }\n        if (i === len) {\n            return -1; // line only consists of whitespace\n        }\n        return indent;\n    };\n    TextModel.prototype._computeIndentLevel = function (lineIndex) {\n        return TextModel.computeIndentLevel(this._buffer.getLineContent(lineIndex + 1), this._options.tabSize);\n    };\n    TextModel.prototype.getActiveIndentGuide = function (lineNumber, minLineNumber, maxLineNumber) {\n        var _this = this;\n        this._assertNotDisposed();\n        var lineCount = this.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        var foldingRules = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\n        var offSide = Boolean(foldingRules && foldingRules.offSide);\n        var up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        var up_aboveContentLineIndent = -1;\n        var up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        var up_belowContentLineIndent = -1;\n        var up_resolveIndents = function (lineNumber) {\n            if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    var indent_1 = _this._computeIndentLevel(lineIndex);\n                    if (indent_1 >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent_1;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (var lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    var indent_2 = _this._computeIndentLevel(lineIndex);\n                    if (indent_2 >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent_2;\n                        break;\n                    }\n                }\n            }\n        };\n        var down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        var down_aboveContentLineIndent = -1;\n        var down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        var down_belowContentLineIndent = -1;\n        var down_resolveIndents = function (lineNumber) {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    var indent_3 = _this._computeIndentLevel(lineIndex);\n                    if (indent_3 >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent_3;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (var lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    var indent_4 = _this._computeIndentLevel(lineIndex);\n                    if (indent_4 >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent_4;\n                        break;\n                    }\n                }\n            }\n        };\n        var startLineNumber = 0;\n        var goUp = true;\n        var endLineNumber = 0;\n        var goDown = true;\n        var indent = 0;\n        for (var distance = 0; goUp || goDown; distance++) {\n            var upLineNumber = lineNumber - distance;\n            var downLineNumber = lineNumber + distance;\n            if (distance !== 0 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance !== 0 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            if (goUp) {\n                // compute indent level going up\n                var upLineIndentLevel = void 0;\n                var currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n                if (distance === 0) {\n                    // This is the initial line number\n                    startLineNumber = upLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = upLineIndentLevel;\n                    if (indent === 0) {\n                        // No need to continue\n                        return { startLineNumber: startLineNumber, endLineNumber: endLineNumber, indent: indent };\n                    }\n                    continue;\n                }\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                // compute indent level going down\n                var downLineIndentLevel = void 0;\n                var currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber: startLineNumber, endLineNumber: endLineNumber, indent: indent };\n    };\n    TextModel.prototype.getLinesIndentGuides = function (startLineNumber, endLineNumber) {\n        this._assertNotDisposed();\n        var lineCount = this.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        var foldingRules = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\n        var offSide = Boolean(foldingRules && foldingRules.offSide);\n        var result = new Array(endLineNumber - startLineNumber + 1);\n        var aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        var aboveContentLineIndent = -1;\n        var belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        var belowContentLineIndent = -1;\n        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            var resultIndex = lineNumber - startLineNumber;\n            var currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / this._options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    var indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (var lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    var indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    };\n    TextModel.prototype._getIndentLevelForWhitespaceLine = function (offSide, aboveContentLineIndent, belowContentLineIndent) {\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return (1 + Math.floor(aboveContentLineIndent / this._options.indentSize));\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / this._options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / this._options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return (1 + Math.floor(belowContentLineIndent / this._options.indentSize));\n            }\n        }\n    };\n    TextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\n    TextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\n    TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\n    TextModel.DEFAULT_CREATION_OPTIONS = {\n        isForSimpleWidget: false,\n        tabSize: editorOptions_1.EDITOR_MODEL_DEFAULTS.tabSize,\n        indentSize: editorOptions_1.EDITOR_MODEL_DEFAULTS.indentSize,\n        insertSpaces: editorOptions_1.EDITOR_MODEL_DEFAULTS.insertSpaces,\n        detectIndentation: false,\n        defaultEOL: model.DefaultEndOfLine.LF,\n        trimAutoWhitespace: editorOptions_1.EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n        largeFileOptimizations: editorOptions_1.EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n    };\n    return TextModel;\n}(lifecycle_1.Disposable));\nexports.TextModel = TextModel;\n//#region Decorations\nvar DecorationsTrees = /** @class */ (function () {\n    function DecorationsTrees() {\n        this._decorationsTree0 = new intervalTree_1.IntervalTree();\n        this._decorationsTree1 = new intervalTree_1.IntervalTree();\n    }\n    DecorationsTrees.prototype.intervalSearch = function (start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n        var r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        var r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        return r0.concat(r1);\n    };\n    DecorationsTrees.prototype.search = function (filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n        }\n        else {\n            var r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            var r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            return r0.concat(r1);\n        }\n    };\n    DecorationsTrees.prototype.collectNodesFromOwner = function (ownerId) {\n        var r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        var r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        return r0.concat(r1);\n    };\n    DecorationsTrees.prototype.collectNodesPostOrder = function () {\n        var r0 = this._decorationsTree0.collectNodesPostOrder();\n        var r1 = this._decorationsTree1.collectNodesPostOrder();\n        return r0.concat(r1);\n    };\n    DecorationsTrees.prototype.insert = function (node) {\n        if (intervalTree_1.getNodeIsInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    };\n    DecorationsTrees.prototype.delete = function (node) {\n        if (intervalTree_1.getNodeIsInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    };\n    DecorationsTrees.prototype.resolveNode = function (node, cachedVersionId) {\n        if (intervalTree_1.getNodeIsInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    };\n    DecorationsTrees.prototype.acceptReplace = function (offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    };\n    return DecorationsTrees;\n}());\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nvar ModelDecorationOverviewRulerOptions = /** @class */ (function () {\n    function ModelDecorationOverviewRulerOptions(options) {\n        this.color = options.color || strings.empty;\n        this.darkColor = options.darkColor || strings.empty;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n        this._resolvedColor = null;\n    }\n    ModelDecorationOverviewRulerOptions.prototype.getColor = function (theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    };\n    ModelDecorationOverviewRulerOptions.prototype.invalidateCachedColor = function () {\n        this._resolvedColor = null;\n    };\n    ModelDecorationOverviewRulerOptions.prototype._resolveColor = function (color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        var c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return strings.empty;\n        }\n        return c.toString();\n    };\n    return ModelDecorationOverviewRulerOptions;\n}());\nexports.ModelDecorationOverviewRulerOptions = ModelDecorationOverviewRulerOptions;\nvar ModelDecorationOptions = /** @class */ (function () {\n    function ModelDecorationOptions(options) {\n        this.stickiness = options.stickiness || model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.hoverMessage = types_1.withUndefinedAsNull(options.hoverMessage);\n        this.glyphMarginHoverMessage = types_1.withUndefinedAsNull(options.glyphMarginHoverMessage);\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n    }\n    ModelDecorationOptions.register = function (options) {\n        return new ModelDecorationOptions(options);\n    };\n    ModelDecorationOptions.createDynamic = function (options) {\n        return new ModelDecorationOptions(options);\n    };\n    return ModelDecorationOptions;\n}());\nexports.ModelDecorationOptions = ModelDecorationOptions;\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({});\n/**\n * The order carefully matches the values of the enum.\n */\nvar TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ stickiness: model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges }),\n    ModelDecorationOptions.register({ stickiness: model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges }),\n    ModelDecorationOptions.register({ stickiness: model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore }),\n    ModelDecorationOptions.register({ stickiness: model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nvar DidChangeDecorationsEmitter = /** @class */ (function (_super) {\n    tslib_1.__extends(DidChangeDecorationsEmitter, _super);\n    function DidChangeDecorationsEmitter() {\n        var _this = _super.call(this) || this;\n        _this._actual = _this._register(new event_1.Emitter());\n        _this.event = _this._actual.event;\n        _this._deferredCnt = 0;\n        _this._shouldFire = false;\n        return _this;\n    }\n    DidChangeDecorationsEmitter.prototype.beginDeferredEmit = function () {\n        this._deferredCnt++;\n    };\n    DidChangeDecorationsEmitter.prototype.endDeferredEmit = function () {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFire) {\n                this._shouldFire = false;\n                this._actual.fire({});\n            }\n        }\n    };\n    DidChangeDecorationsEmitter.prototype.fire = function () {\n        this._shouldFire = true;\n    };\n    return DidChangeDecorationsEmitter;\n}(lifecycle_1.Disposable));\nexports.DidChangeDecorationsEmitter = DidChangeDecorationsEmitter;\n//#endregion\nvar DidChangeContentEmitter = /** @class */ (function (_super) {\n    tslib_1.__extends(DidChangeContentEmitter, _super);\n    function DidChangeContentEmitter() {\n        var _this = _super.call(this) || this;\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        _this._fastEmitter = _this._register(new event_1.Emitter());\n        _this.fastEvent = _this._fastEmitter.event;\n        _this._slowEmitter = _this._register(new event_1.Emitter());\n        _this.slowEvent = _this._slowEmitter.event;\n        _this._deferredCnt = 0;\n        _this._deferredEvent = null;\n        return _this;\n    }\n    DidChangeContentEmitter.prototype.beginDeferredEmit = function () {\n        this._deferredCnt++;\n    };\n    DidChangeContentEmitter.prototype.endDeferredEmit = function () {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                var e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    };\n    DidChangeContentEmitter.prototype.fire = function (e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    };\n    return DidChangeContentEmitter;\n}(lifecycle_1.Disposable));\nexports.DidChangeContentEmitter = DidChangeContentEmitter;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/textModel.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/model/textModel.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;;AAEhG,oDAAmD;AACnD,gDAA0D;AAC1D,8CAAsD;AAEtD,sDAAmE;AACnE,sDAAqD;AACrD,gDAAkD;AAClD,0CAAyC;AACzC,uEAA8E;AAE9E,2DAAqE;AACrE,qDAA4D;AAC5D,6DAA4D;AAC5D,8CAAgD;AAChD,8DAA6D;AAC7D,gFAA6E;AAC7E,oEAA4H;AAC5H,oHAAmH;AACnH,0EAA+Z;AAC/Z,0EAAmG;AACnG,0EAA0G;AAC1G,gEAAkE;AAClE,gDAAyH;AACzH,sGAAqG;AACrG,4DAA2E;AAC3E,4DAAwE;AACxE,qFAAoH;AAGpH,8CAA2D;AAE3D,IAAM,+BAA+B,GAAG,IAAI,CAAC;AAE7C,SAAS,uBAAuB;IAC/B,OAAO,IAAI,uDAA0B,EAAE,CAAC;AACzC,CAAC;AAED,SAAgB,uBAAuB,CAAC,IAAY;IACnD,IAAM,OAAO,GAAG,uBAAuB,EAAE,CAAC;IAC1C,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;IAC1B,OAAO,OAAO,CAAC,MAAM,EAAE,CAAC;AACzB,CAAC;AAJD,0DAIC;AAED,SAAgB,iCAAiC,CAAC,MAAqB,EAAE,MAAkC;IAC1G,OAAO,IAAI,OAAO,CAA2B,UAAC,CAAC,EAAE,CAAC;QACjD,IAAI,IAAI,GAAG,KAAK,CAAC;QACjB,IAAI,OAAO,GAAG,uBAAuB,EAAE,CAAC;QAExC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,UAAC,KAAK;YACvB,IAAI,MAAM,EAAE;gBACX,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;aACtB;YAED,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAC5B,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,UAAC,KAAK;YACxB,IAAI,CAAC,IAAI,EAAE;gBACV,IAAI,GAAG,IAAI,CAAC;gBACZ,CAAC,CAAC,KAAK,CAAC,CAAC;aACT;QACF,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE;YAChB,IAAI,CAAC,IAAI,EAAE;gBACV,IAAI,GAAG,IAAI,CAAC;gBACZ,CAAC,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,CAAC;aACpB;QACF,CAAC,CAAC,CAAC;IACJ,CAAC,CAAC,CAAC;AACJ,CAAC;AA3BD,8EA2BC;AAED,SAAgB,mCAAmC,CAAC,QAAuB;IAC1E,IAAI,OAAO,GAAG,uBAAuB,EAAE,CAAC;IAExC,IAAI,KAAoB,CAAC;IACzB,OAAO,OAAO,CAAC,KAAK,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC,KAAK,QAAQ,EAAE;QACrD,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;KAC3B;IAED,OAAO,OAAO,CAAC,MAAM,EAAE,CAAC;AACzB,CAAC;AATD,kFASC;AAED,SAAgB,gBAAgB,CAAC,KAAwC,EAAE,UAAkC;IAC5G,IAAM,OAAO,GAAG,CAAC,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,uBAAuB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;IACrF,OAAO,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;AACnC,CAAC;AAHD,4CAGC;AAED,IAAI,QAAQ,GAAG,CAAC,CAAC;AAEjB;;GAEG;AACH,SAAS,YAAY,CAAC,MAAc;IACnC,IAAM,WAAW,GAAG,CAAC,mBAAQ,CAAC,CAAC,GAAG,mBAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IAElD,MAAM,GAAG,MAAM,GAAG,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC;IAEpC,IAAI,MAAM,GAAG,WAAW,EAAE;QACzB,OAAO,MAAM,CAAC,YAAY,CAAC,mBAAQ,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC;KAChD;IAED,OAAO,MAAM,CAAC,YAAY,CAAC,mBAAQ,CAAC,CAAC,GAAG,MAAM,GAAG,WAAW,CAAC,CAAC;AAC/D,CAAC;AAED,IAAM,gBAAgB,GAAG,GAAG,CAAC;AAChB,QAAA,kBAAkB,GAAG,KAAK,CAAC;AAExC;IAKC,2BAAY,MAAqB;QAChC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;IACnB,CAAC;IAEM,gCAAI,GAAX;QACC,IAAI,IAAI,CAAC,IAAI,EAAE;YACd,OAAO,IAAI,CAAC;SACZ;QAED,IAAI,MAAM,GAAa,EAAE,EAAE,SAAS,GAAG,CAAC,EAAE,YAAY,GAAG,CAAC,CAAC;QAE3D,GAAG;YACF,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;YAE9B,IAAI,GAAG,KAAK,IAAI,EAAE;gBACjB,gBAAgB;gBAChB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;gBACjB,IAAI,SAAS,KAAK,CAAC,EAAE;oBACpB,OAAO,IAAI,CAAC;iBACZ;qBAAM;oBACN,OAAO,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;iBACvB;aACD;YAED,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE;gBACnB,MAAM,CAAC,SAAS,EAAE,CAAC,GAAG,GAAG,CAAC;gBAC1B,YAAY,IAAI,GAAG,CAAC,MAAM,CAAC;aAC3B;YAED,IAAI,YAAY,IAAI,EAAE,GAAG,IAAI,EAAE;gBAC9B,OAAO,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;aACvB;SACD,QAAQ,IAAI,EAAE;IAChB,CAAC;IACF,wBAAC;AAAD,CAAC,AAxCD,IAwCC;AAED,IAAM,WAAW,GAAG,cAAQ,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC,CAAC,CAAC,CAAC;AAE1E;IAA+B,qCAAU;IAmHxC,YAAY;IAEZ,mBAAY,MAAyC,EAAE,eAAgD,EAAE,kBAA6C,EAAE,kBAAqC;QAArC,mCAAA,EAAA,yBAAqC;QAA7L,YACC,iBAAO,SA0EP;QArJD,gBAAgB;QACC,oBAAc,GAAkB,KAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAAQ,CAAC,CAAC;QACrE,mBAAa,GAAgB,KAAI,CAAC,cAAc,CAAC,KAAK,CAAC;QAEtD,6BAAuB,GAAgC,KAAI,CAAC,SAAS,CAAC,IAAI,2BAA2B,EAAE,CAAC,CAAC;QAC1G,4BAAsB,GAAyC,KAAI,CAAC,uBAAuB,CAAC,KAAK,CAAC;QAEjG,0BAAoB,GAAwC,KAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAA8B,CAAC,CAAC;QACvH,yBAAmB,GAAsC,KAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC;QAExF,uCAAiC,GAAqD,KAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAA2C,CAAC,CAAC;QAC9J,sCAAgC,GAAmD,KAAI,CAAC,iCAAiC,CAAC,KAAK,CAAC;QAE/H,wBAAkB,GAAsC,KAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAA4B,CAAC,CAAC;QACjH,uBAAiB,GAAoC,KAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC;QAElF,yBAAmB,GAAuC,KAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAA6B,CAAC,CAAC;QACpH,wBAAkB,GAAqC,KAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC;QAErF,mBAAa,GAA4B,KAAI,CAAC,SAAS,CAAC,IAAI,uBAAuB,EAAE,CAAC,CAAC;QA0DvG,iCAAiC;QACjC,QAAQ,EAAE,CAAC;QACX,KAAI,CAAC,EAAE,GAAG,QAAQ,GAAG,QAAQ,CAAC;QAC9B,KAAI,CAAC,iBAAiB,GAAG,eAAe,CAAC,iBAAiB,CAAC;QAC3D,IAAI,OAAO,kBAAkB,KAAK,WAAW,IAAI,kBAAkB,KAAK,IAAI,EAAE;YAC7E,KAAI,CAAC,mBAAmB,GAAG,SAAG,CAAC,KAAK,CAAC,mBAAmB,GAAG,QAAQ,CAAC,CAAC;SACrE;aAAM;YACN,KAAI,CAAC,mBAAmB,GAAG,kBAAkB,CAAC;SAC9C;QACD,KAAI,CAAC,oBAAoB,GAAG,CAAC,CAAC;QAE9B,KAAI,CAAC,OAAO,GAAG,gBAAgB,CAAC,MAAM,EAAE,eAAe,CAAC,UAAU,CAAC,CAAC;QAEpE,KAAI,CAAC,QAAQ,GAAG,SAAS,CAAC,cAAc,CAAC,KAAI,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC;QAExE,IAAM,eAAe,GAAG,KAAI,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC;QACpD,IAAM,gBAAgB,GAAG,KAAI,CAAC,OAAO,CAAC,qBAAqB,CAAC,IAAI,aAAK,CAAC,CAAC,EAAE,CAAC,EAAE,eAAe,EAAE,KAAI,CAAC,OAAO,CAAC,aAAa,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC,mBAAmB,CAAC,WAAW,CAAC,CAAC;QAEtL,4EAA4E;QAC5E,6EAA6E;QAC7E,0BAA0B;QAC1B,IAAI,eAAe,CAAC,sBAAsB,EAAE;YAC3C,KAAI,CAAC,0BAA0B,GAAG,CACjC,CAAC,gBAAgB,GAAG,SAAS,CAAC,yBAAyB,CAAC;mBACrD,CAAC,eAAe,GAAG,SAAS,CAAC,+BAA+B,CAAC,CAChE,CAAC;SACF;aAAM;YACN,KAAI,CAAC,0BAA0B,GAAG,KAAK,CAAC;SACxC;QAED,KAAI,CAAC,qBAAqB,GAAG,CAAC,gBAAgB,GAAG,SAAS,CAAC,gBAAgB,CAAC,CAAC;QAE7E,KAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;QACtB,KAAI,CAAC,WAAW,GAAG,KAAK,CAAC;QACzB,KAAI,CAAC,YAAY,GAAG,KAAK,CAAC;QAE1B,KAAI,CAAC,mBAAmB,GAAG,kBAAkB,IAAI,mCAAwB,CAAC;QAC1E,KAAI,CAAC,qBAAqB,GAAG,4BAAoB,CAAC,WAAW,CAAC,UAAC,CAAC;YAC/D,IAAI,CAAC,CAAC,gBAAgB,CAAC,OAAO,CAAC,KAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE;gBACzE,OAAO;aACP;YAED,KAAI,CAAC,uBAAuB,EAAE,CAAC;YAC/B,KAAI,CAAC,2BAA2B,CAAC;gBAChC,0BAA0B,EAAE,IAAI;gBAChC,MAAM,EAAE,CAAC;wBACR,cAAc,EAAE,CAAC;wBACjB,YAAY,EAAE,KAAI,CAAC,YAAY,EAAE;qBACjC,CAAC;aACF,CAAC,CAAC;YAEH,IAAI,KAAI,CAAC,mBAAmB,EAAE,EAAE;gBAC/B,KAAI,CAAC,aAAa,EAAE,CAAC;aACrB;QACF,CAAC,CAAC,CAAC;QACH,KAAI,CAAC,wBAAwB,GAAG,CAAC,CAAC,CAAC;QACnC,KAAI,CAAC,yBAAyB,GAAG,6DAA6B,CAAC,WAAW,CAAC,UAAC,CAAC;YAC5E,IAAI,CAAC,CAAC,kBAAkB,CAAC,EAAE,KAAK,KAAI,CAAC,mBAAmB,CAAC,EAAE,EAAE;gBAC5D,KAAI,CAAC,iCAAiC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;aAChD;QACF,CAAC,CAAC,CAAC;QACH,KAAI,CAAC,uBAAuB,EAAE,CAAC;QAE/B,KAAI,CAAC,WAAW,GAAG,YAAY,CAAC,QAAQ,CAAC,CAAC;QAC1C,KAAI,CAAC,iBAAiB,GAAG,CAAC,CAAC;QAC3B,KAAI,CAAC,YAAY,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACxC,KAAI,CAAC,gBAAgB,GAAG,IAAI,gBAAgB,EAAE,CAAC;QAE/C,KAAI,CAAC,eAAe,GAAG,IAAI,qBAAS,CAAC,KAAI,CAAC,CAAC;QAC3C,KAAI,CAAC,UAAU,GAAG,KAAK,CAAC;QACxB,KAAI,CAAC,UAAU,GAAG,KAAK,CAAC;QACxB,KAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC;;IACtC,CAAC;IA/Ka,0BAAgB,GAA9B,UAA+B,IAAY,EAAE,OAA6E,EAAE,kBAAoD,EAAE,GAAsB;QAA3J,wBAAA,EAAA,UAA2C,SAAS,CAAC,wBAAwB;QAAE,mCAAA,EAAA,yBAAoD;QAAE,oBAAA,EAAA,UAAsB;QACvM,OAAO,IAAI,SAAS,CAAC,IAAI,EAAE,OAAO,EAAE,kBAAkB,EAAE,GAAG,CAAC,CAAC;IAC9D,CAAC;IAEa,wBAAc,GAA5B,UAA6B,UAA6B,EAAE,OAAwC;QACnG,IAAI,OAAO,CAAC,iBAAiB,EAAE;YAC9B,IAAM,kBAAkB,GAAG,qCAAgB,CAAC,UAAU,EAAE,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,YAAY,CAAC,CAAC;YAC/F,OAAO,IAAI,KAAK,CAAC,wBAAwB,CAAC;gBACzC,OAAO,EAAE,kBAAkB,CAAC,OAAO;gBACnC,UAAU,EAAE,kBAAkB,CAAC,OAAO;gBACtC,YAAY,EAAE,kBAAkB,CAAC,YAAY;gBAC7C,kBAAkB,EAAE,OAAO,CAAC,kBAAkB;gBAC9C,UAAU,EAAE,OAAO,CAAC,UAAU;aAC9B,CAAC,CAAC;SACH;QAED,OAAO,IAAI,KAAK,CAAC,wBAAwB,CAAC;YACzC,OAAO,EAAE,OAAO,CAAC,OAAO;YACxB,UAAU,EAAE,OAAO,CAAC,UAAU;YAC9B,YAAY,EAAE,OAAO,CAAC,YAAY;YAClC,kBAAkB,EAAE,OAAO,CAAC,kBAAkB;YAC9C,UAAU,EAAE,OAAO,CAAC,UAAU;SAC9B,CAAC,CAAC;IAEJ,CAAC;IAsBM,6CAAyB,GAAhC,UAAiC,QAAkD;QAClF,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,UAAC,CAAkC,IAAK,OAAA,QAAQ,CAAC,CAAC,CAAC,sBAAsB,CAAC,EAAlC,CAAkC,CAAC,CAAC;IACjH,CAAC;IACM,yCAAqB,GAA5B,UAA6B,QAAkD;QAC9E,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,UAAC,CAAkC,IAAK,OAAA,QAAQ,CAAC,CAAC,CAAC,sBAAsB,CAAC,EAAlC,CAAkC,CAAC,CAAC;IACjH,CAAC;IACM,sCAAkB,GAAzB,UAA0B,QAAgD;QACzE,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,UAAC,CAAkC,IAAK,OAAA,QAAQ,CAAC,CAAC,CAAC,mBAAmB,CAAC,EAA/B,CAA+B,CAAC,CAAC;IAC9G,CAAC;IA2HM,2BAAO,GAAd;QACC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QACzB,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC;QAC3B,IAAI,CAAC,qBAAqB,CAAC,OAAO,EAAE,CAAC;QACrC,IAAI,CAAC,yBAAyB,CAAC,OAAO,EAAE,CAAC;QACzC,IAAI,CAAC,YAAY,EAAE,CAAC;QACpB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;QACxB,yGAAyG;QACzG,iBAAM,OAAO,WAAE,CAAC;QAChB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;IAC3B,CAAC;IAEO,sCAAkB,GAA1B;QACC,IAAI,IAAI,CAAC,WAAW,EAAE;YACrB,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;SACtC;IACF,CAAC;IAEM,oCAAgB,GAAvB,UAAwB,KAAwB;QAC/C,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IACnC,CAAC;IAEO,4CAAwB,GAAhC,UAAiC,SAAsC,EAAE,MAAiC;QACzG,IAAI,IAAI,CAAC,YAAY,EAAE;YACtB,iEAAiE;YACjE,OAAO;SACP;QACD,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,iDAA+B,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC,CAAC;IACjF,CAAC;IAEM,4BAAQ,GAAf,UAAgB,KAAa;QAC5B,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,KAAK,KAAK,IAAI,EAAE;YACnB,wBAAwB;YACxB,OAAO;SACP;QAED,IAAM,UAAU,GAAG,gBAAgB,CAAC,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QACrE,IAAI,CAAC,sBAAsB,CAAC,UAAU,CAAC,CAAC;IACzC,CAAC;IAEO,0CAAsB,GAA9B,UAA+B,KAAY,EAAE,WAAmB,EAAE,WAAmB,EAAE,IAAY,EAAE,SAAkB,EAAE,SAAkB,EAAE,OAAgB;QAC5J,OAAO;YACN,OAAO,EAAE,CAAC;oBACT,KAAK,EAAE,KAAK;oBACZ,WAAW,EAAE,WAAW;oBACxB,WAAW,EAAE,WAAW;oBACxB,IAAI,EAAE,IAAI;iBACV,CAAC;YACF,GAAG,EAAE,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;YAC1B,SAAS,EAAE,IAAI,CAAC,YAAY,EAAE;YAC9B,SAAS,EAAE,SAAS;YACpB,SAAS,EAAE,SAAS;YACpB,OAAO,EAAE,OAAO;SAChB,CAAC;IACH,CAAC;IAEM,0CAAsB,GAA7B,UAA8B,UAA6B;QAC1D,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,UAAU,KAAK,IAAI,EAAE;YACxB,wBAAwB;YACxB,OAAO;SACP;QACD,IAAM,iBAAiB,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;QACnD,IAAM,mBAAmB,GAAG,IAAI,CAAC,qBAAqB,CAAC,iBAAiB,CAAC,CAAC;QAC1E,IAAM,aAAa,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QAC1C,IAAM,SAAS,GAAG,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,CAAC;QAEvD,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC;QAC1B,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAE1B,6DAA6D;QAC7D,IAAI,CAAC,uBAAuB,EAAE,CAAC;QAE/B,6BAA6B;QAC7B,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACxC,IAAI,CAAC,gBAAgB,GAAG,IAAI,gBAAgB,EAAE,CAAC;QAE/C,uCAAuC;QACvC,IAAI,CAAC,eAAe,GAAG,IAAI,qBAAS,CAAC,IAAI,CAAC,CAAC;QAC3C,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC;QAErC,IAAI,CAAC,wBAAwB,CAC5B,IAAI,6CAA2B,CAC9B;YACC,IAAI,+BAAa,EAAE;SACnB,EACD,IAAI,CAAC,UAAU,EACf,KAAK,EACL,KAAK,CACL,EACD,IAAI,CAAC,sBAAsB,CAAC,IAAI,aAAK,CAAC,CAAC,EAAE,CAAC,EAAE,aAAa,EAAE,SAAS,CAAC,EAAE,CAAC,EAAE,mBAAmB,EAAE,IAAI,CAAC,QAAQ,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CACnI,CAAC;IACH,CAAC;IAEM,0BAAM,GAAb,UAAc,GAA4B;QACzC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAM,MAAM,GAAG,CAAC,GAAG,KAAK,KAAK,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QACtE,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,KAAK,MAAM,EAAE;YACrC,gBAAgB;YAChB,OAAO;SACP;QAED,IAAM,iBAAiB,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;QACnD,IAAM,mBAAmB,GAAG,IAAI,CAAC,qBAAqB,CAAC,iBAAiB,CAAC,CAAC;QAC1E,IAAM,aAAa,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QAC1C,IAAM,SAAS,GAAG,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,CAAC;QAEvD,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAC5B,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAEzB,IAAI,CAAC,wBAAwB,CAC5B,IAAI,6CAA2B,CAC9B;YACC,IAAI,oCAAkB,EAAE;SACxB,EACD,IAAI,CAAC,UAAU,EACf,KAAK,EACL,KAAK,CACL,EACD,IAAI,CAAC,sBAAsB,CAAC,IAAI,aAAK,CAAC,CAAC,EAAE,CAAC,EAAE,aAAa,EAAE,SAAS,CAAC,EAAE,CAAC,EAAE,mBAAmB,EAAE,IAAI,CAAC,QAAQ,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CACpI,CAAC;IACH,CAAC;IAEO,sCAAkB,GAA1B;QACC,gDAAgD;QAChD,IAAM,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QACtC,IAAM,cAAc,GAAG,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,SAAS,CAAC,CAAC;QAChF,IAAI,CAAC,sBAAsB,CAAC,cAAc,CAAC,CAAC;IAC7C,CAAC;IAEO,qCAAiB,GAAzB;QACC,oCAAoC;QACpC,IAAM,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QACtC,IAAM,cAAc,GAAG,IAAI,CAAC,gBAAgB,CAAC,qBAAqB,EAAE,CAAC;QACrE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YAC1D,IAAM,IAAI,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;YAE/B,IAAM,KAAK,GAAG,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,KAAK,CAAC;YAEpD,IAAM,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;YACjG,IAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,aAAa,EAAE,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;YAE3F,IAAI,CAAC,mBAAmB,GAAG,WAAW,CAAC;YACvC,IAAI,CAAC,iBAAiB,GAAG,SAAS,CAAC;YACnC,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC;YAEjC,IAAI,CAAC,KAAK,GAAG,WAAW,GAAG,KAAK,CAAC;YACjC,IAAI,CAAC,GAAG,GAAG,SAAS,GAAG,KAAK,CAAC;YAE7B,8BAAe,CAAC,IAAI,CAAC,CAAC;SACtB;IACF,CAAC;IAEO,2CAAuB,GAA/B;QACC,IAAI,CAAC,YAAY,EAAE,CAAC;QACpB,IAAI,mBAAmB,GAAG,CACzB,IAAI,CAAC,0BAA0B;YAC9B,CAAC,CAAC,IAAI;YACN,CAAC,CAAC,4BAAoB,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAC9D,CAAC;QACF,IAAI,CAAC,OAAO,GAAG,IAAI,kCAAgB,CAAC,IAAI,CAAC,mBAAmB,EAAE,mBAAmB,CAAC,CAAC;QACnF,IAAI,CAAC,4BAA4B,EAAE,CAAC;IACrC,CAAC;IAEO,gCAAY,GAApB;QACC,IAAI,IAAI,CAAC,wBAAwB,KAAK,CAAC,CAAC,EAAE;YACzC,YAAY,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;YAC5C,IAAI,CAAC,wBAAwB,GAAG,CAAC,CAAC,CAAC;SACnC;IACF,CAAC;IAEM,oCAAgB,GAAvB;QACC,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC5B,gCAAgC;QAChC,IAAI,CAAC,aAAa,EAAE,CAAC;IACtB,CAAC;IAEM,oCAAgB,GAAvB;QACC,IAAI,CAAC,oBAAoB,EAAE,CAAC;IAC7B,CAAC;IAEO,uCAAmB,GAA3B;QACC,OAAO,IAAI,CAAC,kBAAkB,EAAE,CAAC;IAClC,CAAC;IAEM,sCAAkB,GAAzB;QACC,OAAO,IAAI,CAAC,oBAAoB,GAAG,CAAC,CAAC;IACtC,CAAC;IAEM,0CAAsB,GAA7B;QACC,OAAO,IAAI,CAAC,oBAAoB,CAAC;IAClC,CAAC;IAEM,wCAAoB,GAA3B;QACC,OAAO,IAAI,CAAC,qBAAqB,CAAC;IACnC,CAAC;IAEM,6CAAyB,GAAhC;QACC,OAAO,IAAI,CAAC,0BAA0B,CAAC;IACxC,CAAC;IAEM,8BAAU,GAAjB;QACC,OAAO,IAAI,CAAC,WAAW,CAAC;IACzB,CAAC;IAEM,0CAAsB,GAA7B;QACC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,IAAI,CAAC,yBAAyB,EAAE,EAAE;YACrC,mEAAmE;YACnE,OAAO,KAAK,CAAC;SACb;QACD,IAAI,kBAAkB,GAAG,CAAC,CAAC;QAC3B,IAAI,iBAAiB,GAAG,CAAC,CAAC;QAE1B,IAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC;QAC9C,KAAK,IAAI,UAAU,GAAG,CAAC,EAAE,UAAU,IAAI,SAAS,EAAE,UAAU,EAAE,EAAE;YAC/D,IAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;YAC1D,IAAI,UAAU,IAAI,0BAAkB,EAAE;gBACrC,iBAAiB,IAAI,UAAU,CAAC;aAChC;iBAAM;gBACN,kBAAkB,IAAI,UAAU,CAAC;aACjC;SACD;QAED,OAAO,CAAC,iBAAiB,GAAG,kBAAkB,CAAC,CAAC;IACjD,CAAC;IAED,sBAAW,0BAAG;aAAd;YACC,OAAO,IAAI,CAAC,mBAAmB,CAAC;QACjC,CAAC;;;OAAA;IAED,iBAAiB;IAEV,8BAAU,GAAjB;QACC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,OAAO,IAAI,CAAC,QAAQ,CAAC;IACtB,CAAC;IAEM,wCAAoB,GAA3B;QACC,OAAO;YACN,OAAO,EAAE,IAAI,CAAC,QAAQ,CAAC,UAAU;YACjC,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;SACxC,CAAC;IACH,CAAC;IAEM,iCAAa,GAApB,UAAqB,QAAuC;QAC3D,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,OAAO,GAAG,CAAC,OAAO,QAAQ,CAAC,OAAO,KAAK,WAAW,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC;QACnG,IAAI,UAAU,GAAG,CAAC,OAAO,QAAQ,CAAC,UAAU,KAAK,WAAW,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC;QAC/G,IAAI,YAAY,GAAG,CAAC,OAAO,QAAQ,CAAC,YAAY,KAAK,WAAW,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC;QACvH,IAAI,kBAAkB,GAAG,CAAC,OAAO,QAAQ,CAAC,kBAAkB,KAAK,WAAW,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,kBAAkB,CAAC;QAE/I,IAAI,OAAO,GAAG,IAAI,KAAK,CAAC,wBAAwB,CAAC;YAChD,OAAO,EAAE,OAAO;YAChB,UAAU,EAAE,UAAU;YACtB,YAAY,EAAE,YAAY;YAC1B,UAAU,EAAE,IAAI,CAAC,QAAQ,CAAC,UAAU;YACpC,kBAAkB,EAAE,kBAAkB;SACtC,CAAC,CAAC;QAEH,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE;YAClC,OAAO;SACP;QAED,IAAI,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;QACjD,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QAExB,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAClC,CAAC;IAEM,qCAAiB,GAAxB,UAAyB,mBAA4B,EAAE,cAAsB;QAC5E,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,kBAAkB,GAAG,qCAAgB,CAAC,IAAI,CAAC,OAAO,EAAE,cAAc,EAAE,mBAAmB,CAAC,CAAC;QAC7F,IAAI,CAAC,aAAa,CAAC;YAClB,YAAY,EAAE,kBAAkB,CAAC,YAAY;YAC7C,OAAO,EAAE,kBAAkB,CAAC,OAAO;YACnC,UAAU,EAAE,kBAAkB,CAAC,OAAO;SACtC,CAAC,CAAC;IACJ,CAAC;IAEc,6CAAmC,GAAlD,UAAmD,GAAW,EAAE,UAAkB,EAAE,YAAqB;QACxG,IAAI,SAAS,GAAG,CAAC,CAAC;QAClB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACpC,IAAI,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;gBAC3B,SAAS,IAAI,UAAU,CAAC;aACxB;iBAAM;gBACN,SAAS,EAAE,CAAC;aACZ;SACD;QAED,IAAI,MAAM,GAAG,EAAE,CAAC;QAChB,IAAI,CAAC,YAAY,EAAE;YAClB,IAAI,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,UAAU,CAAC,CAAC;YACjD,SAAS,GAAG,SAAS,GAAG,UAAU,CAAC;YACnC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,EAAE,CAAC,EAAE,EAAE;gBACjC,MAAM,IAAI,IAAI,CAAC;aACf;SACD;QAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE;YACnC,MAAM,IAAI,GAAG,CAAC;SACd;QAED,OAAO,MAAM,CAAC;IACf,CAAC;IAEa,8BAAoB,GAAlC,UAAmC,GAAW,EAAE,UAAkB,EAAE,YAAqB;QACxF,IAAI,uBAAuB,GAAG,OAAO,CAAC,uBAAuB,CAAC,GAAG,CAAC,CAAC;QACnE,IAAI,uBAAuB,KAAK,CAAC,CAAC,EAAE;YACnC,uBAAuB,GAAG,GAAG,CAAC,MAAM,CAAC;SACrC;QACD,OAAO,SAAS,CAAC,mCAAmC,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,EAAE,uBAAuB,CAAC,EAAE,UAAU,EAAE,YAAY,CAAC,GAAG,GAAG,CAAC,SAAS,CAAC,uBAAuB,CAAC,CAAC;IACpK,CAAC;IAEM,wCAAoB,GAA3B,UAA4B,GAAW;QACtC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,OAAO,SAAS,CAAC,oBAAoB,CAAC,GAAG,EAAE,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;IAClG,CAAC;IAED,YAAY;IAEZ,iBAAiB;IAEV,gCAAY,GAAnB;QACC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,OAAO,IAAI,CAAC,UAAU,CAAC;IACxB,CAAC;IAEM,mCAAe,GAAtB;QACC,OAAO,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE,CAAC;IACvC,CAAC;IAEM,6CAAyB,GAAhC;QACC,OAAO,IAAI,CAAC,OAAO,CAAC,yBAAyB,EAAE,CAAC;IACjD,CAAC;IAEM,2CAAuB,GAA9B;QACC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,OAAO,IAAI,CAAC,qBAAqB,CAAC;IACnC,CAAC;IAEM,+BAAW,GAAlB,UAAmB,WAAsB;QACxC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC,WAAW,CAAC,UAAU,EAAE,WAAW,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QACzF,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,UAAU,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC;IACvE,CAAC;IAEM,iCAAa,GAApB,UAAqB,SAAiB;QACrC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,MAAM,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;QAC1E,OAAO,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;IAC3C,CAAC;IAEO,sCAAkB,GAA1B;QACC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;IACzC,CAAC;IAEO,iCAAa,GAArB,UAAsB,YAAoB;QACzC,IAAI,CAAC,UAAU,GAAG,YAAY,CAAC;QAC/B,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC,UAAU,CAAC;IAC9C,CAAC;IAEO,kDAA8B,GAAtC,UAAuC,uBAA+B;QACrE,IAAI,CAAC,qBAAqB,GAAG,uBAAuB,CAAC;IACtD,CAAC;IAEM,4BAAQ,GAAf,UAAgB,GAA+B,EAAE,WAA4B;QAA5B,4BAAA,EAAA,mBAA4B;QAC5E,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAChD,IAAM,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,GAAG,CAAC,CAAC;QAEjE,IAAI,WAAW,EAAE;YAChB,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,GAAG,cAAc,CAAC;SAC9C;QAED,OAAO,cAAc,CAAC;IACvB,CAAC;IAEM,kCAAc,GAArB,UAAsB,WAA4B;QAA5B,4BAAA,EAAA,mBAA4B;QACjD,OAAO,IAAI,iBAAiB,CAAC,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC,CAAC;IACxE,CAAC;IAEM,kCAAc,GAArB,UAAsB,GAA+B,EAAE,WAA4B;QAA5B,4BAAA,EAAA,mBAA4B;QAClF,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAChD,IAAM,cAAc,GAAG,IAAI,CAAC,qBAAqB,CAAC,cAAc,EAAE,GAAG,CAAC,CAAC;QAEvE,IAAI,WAAW,EAAE;YAChB,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,MAAM,GAAG,cAAc,CAAC;SACrD;QAED,OAAO,cAAc,CAAC;IACvB,CAAC;IAEM,mCAAe,GAAtB,UAAuB,QAAgB,EAAE,GAAsE;QAAtE,oBAAA,EAAA,MAAiC,KAAK,CAAC,mBAAmB,CAAC,WAAW;QAC9G,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,OAAO,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE,GAAG,CAAC,CAAC;IACxE,CAAC;IAEM,yCAAqB,GAA5B,UAA6B,QAAgB,EAAE,GAAsE;QAAtE,oBAAA,EAAA,MAAiC,KAAK,CAAC,mBAAmB,CAAC,WAAW;QACpH,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,OAAO,IAAI,CAAC,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE,GAAG,CAAC,CAAC;IAC9E,CAAC;IAEM,gCAAY,GAAnB;QACC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,OAAO,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC;IACpC,CAAC;IAEM,kCAAc,GAArB,UAAsB,UAAkB;QACvC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,UAAU,GAAG,CAAC,IAAI,UAAU,GAAG,IAAI,CAAC,YAAY,EAAE,EAAE;YACvD,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;SAChD;QAED,OAAO,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;IAChD,CAAC;IAEM,iCAAa,GAApB,UAAqB,UAAkB;QACtC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,UAAU,GAAG,CAAC,IAAI,UAAU,GAAG,IAAI,CAAC,YAAY,EAAE,EAAE;YACvD,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;SAChD;QAED,OAAO,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;IAC/C,CAAC;IAEM,mCAAe,GAAtB;QACC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,OAAO,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE,CAAC;IACvC,CAAC;IAEM,0BAAM,GAAb;QACC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;IAC9B,CAAC;IAEM,oCAAgB,GAAvB,UAAwB,UAAkB;QACzC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,OAAO,CAAC,CAAC;IACV,CAAC;IAEM,oCAAgB,GAAvB,UAAwB,UAAkB;QACzC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,UAAU,GAAG,CAAC,IAAI,UAAU,GAAG,IAAI,CAAC,YAAY,EAAE,EAAE;YACvD,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;SAChD;QACD,OAAO,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;IACnD,CAAC;IAEM,mDAA+B,GAAtC,UAAuC,UAAkB;QACxD,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,UAAU,GAAG,CAAC,IAAI,UAAU,GAAG,IAAI,CAAC,YAAY,EAAE,EAAE;YACvD,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;SAChD;QACD,OAAO,IAAI,CAAC,OAAO,CAAC,+BAA+B,CAAC,UAAU,CAAC,CAAC;IACjE,CAAC;IAEM,kDAA8B,GAArC,UAAsC,UAAkB;QACvD,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,UAAU,GAAG,CAAC,IAAI,UAAU,GAAG,IAAI,CAAC,YAAY,EAAE,EAAE;YACvD,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;SAChD;QACD,OAAO,IAAI,CAAC,OAAO,CAAC,8BAA8B,CAAC,UAAU,CAAC,CAAC;IAChE,CAAC;IAED;;;OAGG;IACK,sDAAkC,GAA1C,UAA2C,KAAa;QACvD,IAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC;QAE/C,IAAM,sBAAsB,GAAG,KAAK,CAAC,eAAe,CAAC;QACrD,IAAM,kBAAkB,GAAG,KAAK,CAAC,WAAW,CAAC;QAC7C,IAAI,eAAuB,CAAC;QAC5B,IAAI,WAAmB,CAAC;QAExB,IAAI,sBAAsB,GAAG,CAAC,EAAE;YAC/B,eAAe,GAAG,CAAC,CAAC;YACpB,WAAW,GAAG,CAAC,CAAC;SAChB;aAAM,IAAI,sBAAsB,GAAG,UAAU,EAAE;YAC/C,eAAe,GAAG,UAAU,CAAC;YAC7B,WAAW,GAAG,IAAI,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC;SACrD;aAAM;YACN,eAAe,GAAG,sBAAsB,GAAG,CAAC,CAAC;YAC7C,IAAI,kBAAkB,IAAI,CAAC,EAAE;gBAC5B,WAAW,GAAG,CAAC,CAAC;aAChB;iBAAM;gBACN,IAAM,SAAS,GAAG,IAAI,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC;gBACzD,IAAI,kBAAkB,IAAI,SAAS,EAAE;oBACpC,WAAW,GAAG,SAAS,CAAC;iBACxB;qBAAM;oBACN,WAAW,GAAG,kBAAkB,GAAG,CAAC,CAAC;iBACrC;aACD;SACD;QAED,IAAM,oBAAoB,GAAG,KAAK,CAAC,aAAa,CAAC;QACjD,IAAM,gBAAgB,GAAG,KAAK,CAAC,SAAS,CAAC;QACzC,IAAI,aAAqB,CAAC;QAC1B,IAAI,SAAiB,CAAC;QAEtB,IAAI,oBAAoB,GAAG,CAAC,EAAE;YAC7B,aAAa,GAAG,CAAC,CAAC;YAClB,SAAS,GAAG,CAAC,CAAC;SACd;aAAM,IAAI,oBAAoB,GAAG,UAAU,EAAE;YAC7C,aAAa,GAAG,UAAU,CAAC;YAC3B,SAAS,GAAG,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,CAAC;SACjD;aAAM;YACN,aAAa,GAAG,oBAAoB,GAAG,CAAC,CAAC;YACzC,IAAI,gBAAgB,IAAI,CAAC,EAAE;gBAC1B,SAAS,GAAG,CAAC,CAAC;aACd;iBAAM;gBACN,IAAM,SAAS,GAAG,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,CAAC;gBACvD,IAAI,gBAAgB,IAAI,SAAS,EAAE;oBAClC,SAAS,GAAG,SAAS,CAAC;iBACtB;qBAAM;oBACN,SAAS,GAAG,gBAAgB,GAAG,CAAC,CAAC;iBACjC;aACD;SACD;QAED,IACC,sBAAsB,KAAK,eAAe;eACvC,kBAAkB,KAAK,WAAW;eAClC,oBAAoB,KAAK,aAAa;eACtC,gBAAgB,KAAK,SAAS;eAC9B,KAAK,YAAY,aAAK;eACtB,CAAC,CAAC,KAAK,YAAY,qBAAS,CAAC,EAC/B;YACD,OAAO,KAAK,CAAC;SACb;QAED,OAAO,IAAI,aAAK,CAAC,eAAe,EAAE,WAAW,EAAE,aAAa,EAAE,SAAS,CAAC,CAAC;IAC1E,CAAC;IAED;;OAEG;IACK,oCAAgB,GAAxB,UAAyB,UAAkB,EAAE,MAAc,EAAE,MAAe;QAC3E,IAAI,KAAK,CAAC,UAAU,CAAC,EAAE;YACtB,OAAO,KAAK,CAAC;SACb;QAED,IAAI,UAAU,GAAG,CAAC,EAAE;YACnB,OAAO,KAAK,CAAC;SACb;QAED,IAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC;QAC9C,IAAI,UAAU,GAAG,SAAS,EAAE;YAC3B,OAAO,KAAK,CAAC;SACb;QAED,IAAI,KAAK,CAAC,MAAM,CAAC,EAAE;YAClB,OAAO,KAAK,CAAC;SACb;QAED,IAAI,MAAM,GAAG,CAAC,EAAE;YACf,OAAO,KAAK,CAAC;SACb;QAED,IAAM,SAAS,GAAG,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;QACpD,IAAI,MAAM,GAAG,SAAS,EAAE;YACvB,OAAO,KAAK,CAAC;SACb;QAED,IAAI,MAAM,EAAE;YACX,IAAI,MAAM,GAAG,CAAC,EAAE;gBACf,IAAM,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,UAAU,EAAE,MAAM,GAAG,CAAC,CAAC,CAAC;gBAC5E,IAAI,OAAO,CAAC,eAAe,CAAC,cAAc,CAAC,EAAE;oBAC5C,OAAO,KAAK,CAAC;iBACb;aACD;SACD;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IAED;;OAEG;IACK,qCAAiB,GAAzB,UAA0B,WAAmB,EAAE,OAAe,EAAE,MAAe;QAC9E,IAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,OAAO,WAAW,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1G,IAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,OAAO,OAAO,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1F,IAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC;QAE9C,IAAI,UAAU,GAAG,CAAC,EAAE;YACnB,OAAO,IAAI,mBAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;SAC1B;QAED,IAAI,UAAU,GAAG,SAAS,EAAE;YAC3B,OAAO,IAAI,mBAAQ,CAAC,SAAS,EAAE,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC,CAAC;SACjE;QAED,IAAI,MAAM,IAAI,CAAC,EAAE;YAChB,OAAO,IAAI,mBAAQ,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC;SACnC;QAED,IAAM,SAAS,GAAG,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;QACpD,IAAI,MAAM,IAAI,SAAS,EAAE;YACxB,OAAO,IAAI,mBAAQ,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;SAC3C;QAED,IAAI,MAAM,EAAE;YACX,2EAA2E;YAC3E,gCAAgC;YAChC,8BAA8B;YAC9B,IAAM,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,UAAU,EAAE,MAAM,GAAG,CAAC,CAAC,CAAC;YAC5E,IAAI,OAAO,CAAC,eAAe,CAAC,cAAc,CAAC,EAAE;gBAC5C,OAAO,IAAI,mBAAQ,CAAC,UAAU,EAAE,MAAM,GAAG,CAAC,CAAC,CAAC;aAC5C;SACD;QAED,OAAO,IAAI,mBAAQ,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;IACzC,CAAC;IAEM,oCAAgB,GAAvB,UAAwB,QAAmB;QAC1C,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAE1B,qDAAqD;QACrD,IAAI,QAAQ,YAAY,mBAAQ,EAAE;YACjC,IAAI,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,UAAU,EAAE,QAAQ,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE;gBACtE,OAAO,QAAQ,CAAC;aAChB;SACD;QAED,OAAO,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,UAAU,EAAE,QAAQ,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;IAC3E,CAAC;IAED;;OAEG;IACK,iCAAa,GAArB,UAAsB,KAAY,EAAE,MAAe;QAClD,IAAM,eAAe,GAAG,KAAK,CAAC,eAAe,CAAC;QAC9C,IAAM,WAAW,GAAG,KAAK,CAAC,WAAW,CAAC;QACtC,IAAM,aAAa,GAAG,KAAK,CAAC,aAAa,CAAC;QAC1C,IAAM,SAAS,GAAG,KAAK,CAAC,SAAS,CAAC;QAElC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,eAAe,EAAE,WAAW,EAAE,KAAK,CAAC,EAAE;YAChE,OAAO,KAAK,CAAC;SACb;QACD,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,aAAa,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE;YAC5D,OAAO,KAAK,CAAC;SACb;QAED,IAAI,MAAM,EAAE;YACX,IAAM,mBAAmB,GAAG,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,eAAe,EAAE,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACnH,IAAM,iBAAiB,GAAG,CAAC,SAAS,GAAG,CAAC,IAAI,SAAS,IAAI,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,aAAa,EAAE,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAErK,IAAM,wBAAwB,GAAG,OAAO,CAAC,eAAe,CAAC,mBAAmB,CAAC,CAAC;YAC9E,IAAM,sBAAsB,GAAG,OAAO,CAAC,eAAe,CAAC,iBAAiB,CAAC,CAAC;YAE1E,IAAI,CAAC,wBAAwB,IAAI,CAAC,sBAAsB,EAAE;gBACzD,OAAO,IAAI,CAAC;aACZ;YAED,OAAO,KAAK,CAAC;SACb;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IAEM,iCAAa,GAApB,UAAqB,MAAc;QAClC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAE1B,qDAAqD;QACrD,IAAI,CAAC,MAAM,YAAY,aAAK,CAAC,IAAI,CAAC,CAAC,MAAM,YAAY,qBAAS,CAAC,EAAE;YAChE,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE;gBACrC,OAAO,MAAM,CAAC;aACd;SACD;QAED,IAAM,KAAK,GAAG,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,eAAe,EAAE,MAAM,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;QACxF,IAAM,GAAG,GAAG,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,aAAa,EAAE,MAAM,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;QAElF,IAAM,eAAe,GAAG,KAAK,CAAC,UAAU,CAAC;QACzC,IAAM,WAAW,GAAG,KAAK,CAAC,MAAM,CAAC;QACjC,IAAM,aAAa,GAAG,GAAG,CAAC,UAAU,CAAC;QACrC,IAAM,SAAS,GAAG,GAAG,CAAC,MAAM,CAAC;QAE7B,IAAM,mBAAmB,GAAG,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,eAAe,EAAE,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACnH,IAAM,iBAAiB,GAAG,CAAC,SAAS,GAAG,CAAC,IAAI,SAAS,IAAI,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,aAAa,EAAE,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAErK,IAAM,wBAAwB,GAAG,OAAO,CAAC,eAAe,CAAC,mBAAmB,CAAC,CAAC;QAC9E,IAAM,sBAAsB,GAAG,OAAO,CAAC,eAAe,CAAC,iBAAiB,CAAC,CAAC;QAE1E,IAAI,CAAC,wBAAwB,IAAI,CAAC,sBAAsB,EAAE;YACzD,OAAO,IAAI,aAAK,CAAC,eAAe,EAAE,WAAW,EAAE,aAAa,EAAE,SAAS,CAAC,CAAC;SACzE;QAED,IAAI,eAAe,KAAK,aAAa,IAAI,WAAW,KAAK,SAAS,EAAE;YACnE,sEAAsE;YACtE,OAAO,IAAI,aAAK,CAAC,eAAe,EAAE,WAAW,GAAG,CAAC,EAAE,aAAa,EAAE,SAAS,GAAG,CAAC,CAAC,CAAC;SACjF;QAED,IAAI,wBAAwB,IAAI,sBAAsB,EAAE;YACvD,4BAA4B;YAC5B,OAAO,IAAI,aAAK,CAAC,eAAe,EAAE,WAAW,GAAG,CAAC,EAAE,aAAa,EAAE,SAAS,GAAG,CAAC,CAAC,CAAC;SACjF;QAED,IAAI,wBAAwB,EAAE;YAC7B,iCAAiC;YACjC,OAAO,IAAI,aAAK,CAAC,eAAe,EAAE,WAAW,GAAG,CAAC,EAAE,aAAa,EAAE,SAAS,CAAC,CAAC;SAC7E;QAED,+BAA+B;QAC/B,OAAO,IAAI,aAAK,CAAC,eAAe,EAAE,WAAW,EAAE,aAAa,EAAE,SAAS,GAAG,CAAC,CAAC,CAAC;IAC9E,CAAC;IAEM,kCAAc,GAArB,UAAsB,WAAsB,EAAE,MAAc;QAC3D,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,GAAG,MAAM,CAAC;QACvD,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;IACvF,CAAC;IAEM,qCAAiB,GAAxB;QACC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAM,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QACtC,OAAO,IAAI,aAAK,CAAC,CAAC,EAAE,CAAC,EAAE,SAAS,EAAE,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC,CAAC;IACrE,CAAC;IAEO,yCAAqB,GAA7B,UAA8B,WAAkB,EAAE,UAAsB,EAAE,cAAuB,EAAE,gBAAwB;QAC1H,OAAO,IAAI,CAAC,OAAO,CAAC,qBAAqB,CAAC,WAAW,EAAE,UAAU,EAAE,cAAc,EAAE,gBAAgB,CAAC,CAAC;IACtG,CAAC;IAEM,+BAAW,GAAlB,UAAmB,YAAoB,EAAE,cAAmB,EAAE,OAAgB,EAAE,SAAkB,EAAE,cAAsB,EAAE,cAAuB,EAAE,gBAA2C;QAA3C,iCAAA,EAAA,mCAA2C;QAC/L,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAE1B,IAAI,WAAkB,CAAC;QACvB,IAAI,aAAK,CAAC,QAAQ,CAAC,cAAc,CAAC,EAAE;YACnC,WAAW,GAAG,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,CAAC;SACjD;aAAM;YACN,WAAW,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;SACvC;QAED,IAAI,CAAC,OAAO,IAAI,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;YAC/C,4BAA4B;YAC5B,IAAM,YAAY,GAAG,IAAI,8BAAY,CAAC,YAAY,EAAE,OAAO,EAAE,SAAS,EAAE,cAAc,CAAC,CAAC;YACxF,IAAM,UAAU,GAAG,YAAY,CAAC,kBAAkB,EAAE,CAAC;YAErD,IAAI,CAAC,UAAU,EAAE;gBAChB,OAAO,EAAE,CAAC;aACV;YAED,OAAO,IAAI,CAAC,qBAAqB,CAAC,WAAW,EAAE,UAAU,EAAE,cAAc,EAAE,gBAAgB,CAAC,CAAC;SAC7F;QAED,OAAO,iCAAe,CAAC,WAAW,CAAC,IAAI,EAAE,IAAI,8BAAY,CAAC,YAAY,EAAE,OAAO,EAAE,SAAS,EAAE,cAAc,CAAC,EAAE,WAAW,EAAE,cAAc,EAAE,gBAAgB,CAAC,CAAC;IAC7J,CAAC;IAEM,iCAAa,GAApB,UAAqB,YAAoB,EAAE,cAAyB,EAAE,OAAgB,EAAE,SAAkB,EAAE,cAAsB,EAAE,cAAuB;QAC1J,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAM,WAAW,GAAG,IAAI,CAAC,gBAAgB,CAAC,cAAc,CAAC,CAAC;QAE1D,IAAI,CAAC,OAAO,IAAI,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;YAC/C,IAAM,YAAY,GAAG,IAAI,8BAAY,CAAC,YAAY,EAAE,OAAO,EAAE,SAAS,EAAE,cAAc,CAAC,CAAC;YACxF,IAAM,UAAU,GAAG,YAAY,CAAC,kBAAkB,EAAE,CAAC;YACrD,IAAI,CAAC,UAAU,EAAE;gBAChB,OAAO,IAAI,CAAC;aACZ;YAED,IAAM,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;YACtC,IAAI,WAAW,GAAG,IAAI,aAAK,CAAC,WAAW,CAAC,UAAU,EAAE,WAAW,CAAC,MAAM,EAAE,SAAS,EAAE,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC,CAAC;YACrH,IAAI,GAAG,GAAG,IAAI,CAAC,qBAAqB,CAAC,WAAW,EAAE,UAAU,EAAE,cAAc,EAAE,CAAC,CAAC,CAAC;YACjF,iCAAe,CAAC,aAAa,CAAC,IAAI,EAAE,IAAI,8BAAY,CAAC,YAAY,EAAE,OAAO,EAAE,SAAS,EAAE,cAAc,CAAC,EAAE,WAAW,EAAE,cAAc,CAAC,CAAC;YACrI,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE;gBACnB,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;aACd;YAED,WAAW,GAAG,IAAI,aAAK,CAAC,CAAC,EAAE,CAAC,EAAE,WAAW,CAAC,UAAU,EAAE,IAAI,CAAC,gBAAgB,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC,CAAC;YACrG,GAAG,GAAG,IAAI,CAAC,qBAAqB,CAAC,WAAW,EAAE,UAAU,EAAE,cAAc,EAAE,CAAC,CAAC,CAAC;YAE7E,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE;gBACnB,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;aACd;YAED,OAAO,IAAI,CAAC;SACZ;QAED,OAAO,iCAAe,CAAC,aAAa,CAAC,IAAI,EAAE,IAAI,8BAAY,CAAC,YAAY,EAAE,OAAO,EAAE,SAAS,EAAE,cAAc,CAAC,EAAE,WAAW,EAAE,cAAc,CAAC,CAAC;IAC7I,CAAC;IAEM,qCAAiB,GAAxB,UAAyB,YAAoB,EAAE,cAAyB,EAAE,OAAgB,EAAE,SAAkB,EAAE,cAAsB,EAAE,cAAuB;QAC9J,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAM,WAAW,GAAG,IAAI,CAAC,gBAAgB,CAAC,cAAc,CAAC,CAAC;QAC1D,OAAO,iCAAe,CAAC,iBAAiB,CAAC,IAAI,EAAE,IAAI,8BAAY,CAAC,YAAY,EAAE,OAAO,EAAE,SAAS,EAAE,cAAc,CAAC,EAAE,WAAW,EAAE,cAAc,CAAC,CAAC;IACjJ,CAAC;IAED,YAAY;IAEZ,iBAAiB;IAEV,oCAAgB,GAAvB;QACC,IAAI,CAAC,eAAe,CAAC,gBAAgB,EAAE,CAAC;IACzC,CAAC;IAEM,2BAAO,GAAd,UAAe,GAA4B;QAC1C,IAAM,UAAU,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,iBAAiB,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;QACxG,IAAI,UAAU,KAAK,GAAG,EAAE;YACvB,OAAO;SACP;QACD,IAAI;YACH,IAAI,CAAC,uBAAuB,CAAC,iBAAiB,EAAE,CAAC;YACjD,IAAI,CAAC,aAAa,CAAC,iBAAiB,EAAE,CAAC;YACvC,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;SAClC;gBAAS;YACT,IAAI,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC;YACrC,IAAI,CAAC,uBAAuB,CAAC,eAAe,EAAE,CAAC;SAC/C;IACF,CAAC;IAEM,sCAAkB,GAAzB,UAA0B,iBAA8B,EAAE,cAAsD,EAAE,mBAAsD;QACvK,IAAI;YACH,IAAI,CAAC,uBAAuB,CAAC,iBAAiB,EAAE,CAAC;YACjD,IAAI,CAAC,aAAa,CAAC,iBAAiB,EAAE,CAAC;YACvC,OAAO,IAAI,CAAC,mBAAmB,CAAC,iBAAiB,EAAE,cAAc,EAAE,mBAAmB,CAAC,CAAC;SACxF;gBAAS;YACT,IAAI,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC;YACrC,IAAI,CAAC,uBAAuB,CAAC,eAAe,EAAE,CAAC;SAC/C;IACF,CAAC;IAEO,uCAAmB,GAA3B,UAA4B,iBAA8B,EAAE,cAAsD,EAAE,mBAAsD;QAA1K,iBAqFC;QApFA,IAAI,IAAI,CAAC,QAAQ,CAAC,kBAAkB,IAAI,IAAI,CAAC,wBAAwB,EAAE;YACtE,sEAAsE;YACtE,0DAA0D;YAE1D,IAAI,aAAa,GAAG,cAAc,CAAC,GAAG,CAAC,UAAC,EAAE;gBACzC,OAAO;oBACN,KAAK,EAAE,KAAI,CAAC,aAAa,CAAC,EAAE,CAAC,KAAK,CAAC;oBACnC,IAAI,EAAE,EAAE,CAAC,IAAI;iBACb,CAAC;YACH,CAAC,CAAC,CAAC;YAEH,4HAA4H;YAC5H,8GAA8G;YAC9G,IAAI,mBAAmB,GAAG,IAAI,CAAC;YAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,iBAAiB,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;gBAC7D,IAAI,GAAG,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC;gBAC/B,IAAI,gBAAgB,GAAG,KAAK,CAAC;gBAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,IAAI,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE;oBAC3D,IAAI,SAAS,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;oBACvC,IAAI,UAAU,GAAG,SAAS,CAAC,eAAe,GAAG,GAAG,CAAC,aAAa,CAAC;oBAC/D,IAAI,UAAU,GAAG,GAAG,CAAC,eAAe,GAAG,SAAS,CAAC,aAAa,CAAC;oBAC/D,IAAI,CAAC,UAAU,IAAI,CAAC,UAAU,EAAE;wBAC/B,gBAAgB,GAAG,IAAI,CAAC;wBACxB,MAAM;qBACN;iBACD;gBACD,IAAI,CAAC,gBAAgB,EAAE;oBACtB,mBAAmB,GAAG,KAAK,CAAC;oBAC5B,MAAM;iBACN;aACD;YAED,IAAI,mBAAmB,EAAE;gBACxB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,wBAAwB,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;oBACzE,IAAI,cAAc,GAAG,IAAI,CAAC,wBAAwB,CAAC,CAAC,CAAC,CAAC;oBACtD,IAAI,aAAa,GAAG,IAAI,CAAC,gBAAgB,CAAC,cAAc,CAAC,CAAC;oBAE1D,IAAI,aAAa,GAAG,IAAI,CAAC;oBACzB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,IAAI,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE;wBAC3D,IAAI,SAAS,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;wBACvC,IAAI,QAAQ,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;wBAErC,IAAI,cAAc,GAAG,SAAS,CAAC,eAAe,IAAI,cAAc,GAAG,SAAS,CAAC,aAAa,EAAE;4BAC3F,6CAA6C;4BAC7C,SAAS;yBACT;wBAED,iBAAiB;wBACjB,qEAAqE;wBAErE,IACC,cAAc,KAAK,SAAS,CAAC,eAAe,IAAI,SAAS,CAAC,WAAW,KAAK,aAAa;+BACpF,SAAS,CAAC,OAAO,EAAE,IAAI,QAAQ,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,IAAI,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,EACvF;4BACD,uEAAuE;4BACvE,SAAS;yBACT;wBAED,IACC,cAAc,KAAK,SAAS,CAAC,eAAe,IAAI,SAAS,CAAC,WAAW,KAAK,CAAC;+BACxE,SAAS,CAAC,OAAO,EAAE,IAAI,QAAQ,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,IAAI,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,IAAI,EACzG;4BACD,wEAAwE;4BACxE,SAAS;yBACT;wBAED,iFAAiF;wBACjF,aAAa,GAAG,KAAK,CAAC;wBACtB,MAAM;qBACN;oBAED,IAAI,aAAa,EAAE;wBAClB,cAAc,CAAC,IAAI,CAAC;4BACnB,KAAK,EAAE,IAAI,aAAK,CAAC,cAAc,EAAE,CAAC,EAAE,cAAc,EAAE,aAAa,CAAC;4BAClE,IAAI,EAAE,IAAI;yBACV,CAAC,CAAC;qBACH;iBAED;aACD;YAED,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC;SACrC;QACD,OAAO,IAAI,CAAC,eAAe,CAAC,iBAAiB,CAAC,iBAAiB,EAAE,cAAc,EAAE,mBAAmB,CAAC,CAAC;IACvG,CAAC;IAEM,8BAAU,GAAjB,UAAkB,aAAqD;QACtE,IAAI;YACH,IAAI,CAAC,uBAAuB,CAAC,iBAAiB,EAAE,CAAC;YACjD,IAAI,CAAC,aAAa,CAAC,iBAAiB,EAAE,CAAC;YACvC,OAAO,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,CAAC;SACvC;gBAAS;YACT,IAAI,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC;YACrC,IAAI,CAAC,uBAAuB,CAAC,eAAe,EAAE,CAAC;SAC/C;IACF,CAAC;IAEc,mBAAS,GAAxB,UAAyB,IAAY;QACpC,IAAI,QAAQ,GAAG,CAAC,CAAC;QACjB,IAAI,eAAe,GAAG,CAAC,CAAC;QACxB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YAChD,IAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAE/B,IAAI,GAAG,KAAK,mBAAQ,CAAC,cAAc,EAAE;gBACpC,IAAI,QAAQ,KAAK,CAAC,EAAE;oBACnB,eAAe,GAAG,CAAC,CAAC;iBACpB;gBACD,QAAQ,EAAE,CAAC;gBACX,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,IAAI,IAAI,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,mBAAQ,CAAC,QAAQ,EAAE;oBAChE,eAAe;oBACf,CAAC,EAAE,CAAC,CAAC,UAAU;iBACf;qBAAM;oBACN,aAAa;iBACb;aACD;iBAAM,IAAI,GAAG,KAAK,mBAAQ,CAAC,QAAQ,EAAE;gBACrC,IAAI,QAAQ,KAAK,CAAC,EAAE;oBACnB,eAAe,GAAG,CAAC,CAAC;iBACpB;gBACD,QAAQ,EAAE,CAAC;aACX;SACD;QACD,IAAI,QAAQ,KAAK,CAAC,EAAE;YACnB,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC;SAC9B;QACD,OAAO,CAAC,QAAQ,EAAE,eAAe,CAAC,CAAC;IACpC,CAAC;IAEO,+BAAW,GAAnB,UAAoB,aAAqD;QACxE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YACzD,aAAa,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;SACpE;QAED,IAAM,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC;QACjD,IAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,aAAa,EAAE,IAAI,CAAC,QAAQ,CAAC,kBAAkB,CAAC,CAAC;QACxF,IAAM,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC;QAEjD,IAAM,cAAc,GAAG,MAAM,CAAC,OAAO,CAAC;QACtC,IAAI,CAAC,wBAAwB,GAAG,MAAM,CAAC,6BAA6B,CAAC;QAErE,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE;YAChC,IAAI,iBAAiB,GAAqB,EAAE,CAAC;YAE7C,IAAI,SAAS,GAAG,YAAY,CAAC;YAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;gBAC1D,IAAM,MAAM,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;gBAC3B,IAAA,qCAA8D,EAA7D,gBAAQ,EAAE,uBAAmD,CAAC;gBACrE,IAAI;oBACH,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,EAAE,QAAQ,EAAE,eAAe,CAAC,CAAC;iBACjE;gBAAC,OAAO,GAAG,EAAE;oBACb,qCAAqC;oBACrC,IAAI,CAAC,OAAO,GAAG,IAAI,kCAAgB,CAAC,IAAI,CAAC,OAAO,CAAC,kBAAkB,EAAE,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,CAAC;iBACvG;gBACD,IAAI,CAAC,uBAAuB,CAAC,IAAI,EAAE,CAAC;gBACpC,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,MAAM,CAAC,WAAW,EAAE,MAAM,CAAC,WAAW,EAAE,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,gBAAgB,CAAC,CAAC;gBAEzH,IAAM,eAAe,GAAG,MAAM,CAAC,KAAK,CAAC,eAAe,CAAC;gBACrD,IAAM,aAAa,GAAG,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC;gBAEjD,IAAM,gBAAgB,GAAG,aAAa,GAAG,eAAe,CAAC;gBACzD,IAAM,iBAAiB,GAAG,QAAQ,CAAC;gBACnC,IAAM,eAAe,GAAG,IAAI,CAAC,GAAG,CAAC,gBAAgB,EAAE,iBAAiB,CAAC,CAAC;gBAEtE,IAAM,oBAAoB,GAAG,CAAC,iBAAiB,GAAG,gBAAgB,CAAC,CAAC;gBAEpE,KAAK,IAAI,CAAC,GAAG,eAAe,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;oBAC1C,IAAM,cAAc,GAAG,eAAe,GAAG,CAAC,CAAC;oBAC3C,IAAM,qBAAqB,GAAG,YAAY,GAAG,SAAS,GAAG,oBAAoB,GAAG,cAAc,CAAC;oBAC/F,iBAAiB,CAAC,IAAI,CAAC,IAAI,qCAAmB,CAAC,cAAc,EAAE,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,CAAC,CAAC,CAAC;iBAC5G;gBAED,IAAI,eAAe,GAAG,gBAAgB,EAAE;oBACvC,yBAAyB;oBACzB,IAAM,qBAAqB,GAAG,eAAe,GAAG,eAAe,CAAC;oBAChE,iBAAiB,CAAC,IAAI,CAAC,IAAI,sCAAoB,CAAC,qBAAqB,GAAG,CAAC,EAAE,aAAa,CAAC,CAAC,CAAC;iBAC3F;gBAED,IAAI,eAAe,GAAG,iBAAiB,EAAE;oBACxC,yBAAyB;oBACzB,IAAM,gBAAgB,GAAG,eAAe,GAAG,eAAe,CAAC;oBAC3D,IAAM,GAAG,GAAG,iBAAiB,GAAG,eAAe,CAAC;oBAChD,IAAM,cAAc,GAAG,YAAY,GAAG,SAAS,GAAG,GAAG,GAAG,gBAAgB,GAAG,CAAC,CAAC;oBAC7E,IAAI,QAAQ,GAAa,EAAE,CAAC;oBAC5B,KAAK,IAAI,GAAC,GAAG,CAAC,EAAE,GAAC,GAAG,GAAG,EAAE,GAAC,EAAE,EAAE;wBAC7B,IAAI,UAAU,GAAG,cAAc,GAAG,GAAC,CAAC;wBACpC,QAAQ,CAAC,UAAU,GAAG,cAAc,CAAC,GAAG,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;qBACxE;oBACD,iBAAiB,CAAC,IAAI,CAAC,IAAI,uCAAqB,CAAC,gBAAgB,GAAG,CAAC,EAAE,eAAe,GAAG,iBAAiB,EAAE,QAAQ,CAAC,CAAC,CAAC;iBACvH;gBAED,SAAS,IAAI,oBAAoB,CAAC;aAClC;YAED,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAE1B,IAAI,CAAC,wBAAwB,CAC5B,IAAI,6CAA2B,CAC9B,iBAAiB,EACjB,IAAI,CAAC,YAAY,EAAE,EACnB,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,UAAU,CACf,EACD;gBACC,OAAO,EAAE,cAAc;gBACvB,GAAG,EAAE,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;gBAC1B,SAAS,EAAE,IAAI,CAAC,YAAY,EAAE;gBAC9B,SAAS,EAAE,IAAI,CAAC,UAAU;gBAC1B,SAAS,EAAE,IAAI,CAAC,UAAU;gBAC1B,OAAO,EAAE,KAAK;aACd,CACD,CAAC;SACF;QAED,IAAI,IAAI,CAAC,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;YAClD,IAAI,CAAC,4BAA4B,EAAE,CAAC;SACpC;QAED,OAAO,MAAM,CAAC,YAAY,CAAC;IAC5B,CAAC;IAEO,yBAAK,GAAb;QACC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACvB,IAAI,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC;QACpC,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;QAExB,IAAI,CAAC,CAAC,EAAE;YACP,OAAO,IAAI,CAAC;SACZ;QAED,IAAI,CAAC,8BAA8B,CAAC,CAAC,CAAC,iBAAiB,CAAC,CAAC;QAEzD,OAAO,CAAC,CAAC,UAAU,CAAC;IACrB,CAAC;IAEM,wBAAI,GAAX;QACC,IAAI;YACH,IAAI,CAAC,uBAAuB,CAAC,iBAAiB,EAAE,CAAC;YACjD,IAAI,CAAC,aAAa,CAAC,iBAAiB,EAAE,CAAC;YACvC,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;SACpB;gBAAS;YACT,IAAI,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC;YACrC,IAAI,CAAC,uBAAuB,CAAC,eAAe,EAAE,CAAC;SAC/C;IACF,CAAC;IAEM,2BAAO,GAAd;QACC,OAAO,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,CAAC;IACvC,CAAC;IAEO,yBAAK,GAAb;QACC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACvB,IAAI,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC;QACpC,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;QAExB,IAAI,CAAC,CAAC,EAAE;YACP,OAAO,IAAI,CAAC;SACZ;QAED,IAAI,CAAC,8BAA8B,CAAC,CAAC,CAAC,iBAAiB,CAAC,CAAC;QAEzD,OAAO,CAAC,CAAC,UAAU,CAAC;IACrB,CAAC;IAEM,wBAAI,GAAX;QACC,IAAI;YACH,IAAI,CAAC,uBAAuB,CAAC,iBAAiB,EAAE,CAAC;YACjD,IAAI,CAAC,aAAa,CAAC,iBAAiB,EAAE,CAAC;YACvC,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;SACpB;gBAAS;YACT,IAAI,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC;YACrC,IAAI,CAAC,uBAAuB,CAAC,eAAe,EAAE,CAAC;SAC/C;IACF,CAAC;IAEM,2BAAO,GAAd;QACC,OAAO,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,CAAC;IACvC,CAAC;IAED,YAAY;IAEZ,qBAAqB;IAEd,qCAAiB,GAAxB,UAA4B,QAAsE,EAAE,OAAmB;QAAnB,wBAAA,EAAA,WAAmB;QACtH,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAE1B,IAAI;YACH,IAAI,CAAC,uBAAuB,CAAC,iBAAiB,EAAE,CAAC;YACjD,OAAO,IAAI,CAAC,kBAAkB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;SAClD;gBAAS;YACT,IAAI,CAAC,uBAAuB,CAAC,eAAe,EAAE,CAAC;SAC/C;IACF,CAAC;IAEO,sCAAkB,GAA1B,UAA8B,OAAe,EAAE,QAAsE;QAArH,iBAwCC;QAvCA,IAAI,cAAc,GAA0C;YAC3D,aAAa,EAAE,UAAC,KAAa,EAAE,OAAsC;gBACpE,KAAI,CAAC,uBAAuB,CAAC,IAAI,EAAE,CAAC;gBACpC,OAAO,KAAI,CAAC,qBAAqB,CAAC,OAAO,EAAE,EAAE,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACzF,CAAC;YACD,gBAAgB,EAAE,UAAC,EAAU,EAAE,QAAgB;gBAC9C,KAAI,CAAC,uBAAuB,CAAC,IAAI,EAAE,CAAC;gBACpC,KAAI,CAAC,qBAAqB,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC;YAC1C,CAAC;YACD,uBAAuB,EAAE,UAAC,EAAU,EAAE,OAAsC;gBAC3E,KAAI,CAAC,uBAAuB,CAAC,IAAI,EAAE,CAAC;gBACpC,KAAI,CAAC,4BAA4B,CAAC,EAAE,EAAE,iBAAiB,CAAC,OAAO,CAAC,CAAC,CAAC;YACnE,CAAC;YACD,gBAAgB,EAAE,UAAC,EAAU;gBAC5B,KAAI,CAAC,uBAAuB,CAAC,IAAI,EAAE,CAAC;gBACpC,KAAI,CAAC,qBAAqB,CAAC,OAAO,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;YAC/C,CAAC;YACD,gBAAgB,EAAE,UAAC,cAAwB,EAAE,cAA6C;gBACzF,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE;oBAC/D,gBAAgB;oBAChB,OAAO,EAAE,CAAC;iBACV;gBACD,KAAI,CAAC,uBAAuB,CAAC,IAAI,EAAE,CAAC;gBACpC,OAAO,KAAI,CAAC,qBAAqB,CAAC,OAAO,EAAE,cAAc,EAAE,cAAc,CAAC,CAAC;YAC5E,CAAC;SACD,CAAC;QACF,IAAI,MAAM,GAAa,IAAI,CAAC;QAC5B,IAAI;YACH,MAAM,GAAG,QAAQ,CAAC,cAAc,CAAC,CAAC;SAClC;QAAC,OAAO,CAAC,EAAE;YACX,0BAAiB,CAAC,CAAC,CAAC,CAAC;SACrB;QACD,6BAA6B;QAC7B,cAAc,CAAC,aAAa,GAAG,WAAW,CAAC;QAC3C,cAAc,CAAC,gBAAgB,GAAG,WAAW,CAAC;QAC9C,cAAc,CAAC,uBAAuB,GAAG,WAAW,CAAC;QACrD,cAAc,CAAC,gBAAgB,GAAG,WAAW,CAAC;QAC9C,cAAc,CAAC,gBAAgB,GAAG,WAAW,CAAC;QAC9C,OAAO,MAAM,CAAC;IACf,CAAC;IAEM,oCAAgB,GAAvB,UAAwB,cAAwB,EAAE,cAA6C,EAAE,OAAmB;QAAnB,wBAAA,EAAA,WAAmB;QACnH,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAI,CAAC,cAAc,EAAE;YACpB,cAAc,GAAG,EAAE,CAAC;SACpB;QACD,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE;YAC/D,gBAAgB;YAChB,OAAO,EAAE,CAAC;SACV;QAED,IAAI;YACH,IAAI,CAAC,uBAAuB,CAAC,iBAAiB,EAAE,CAAC;YACjD,IAAI,CAAC,uBAAuB,CAAC,IAAI,EAAE,CAAC;YACpC,OAAO,IAAI,CAAC,qBAAqB,CAAC,OAAO,EAAE,cAAc,EAAE,cAAc,CAAC,CAAC;SAC3E;gBAAS;YACT,IAAI,CAAC,uBAAuB,CAAC,eAAe,EAAE,CAAC;SAC/C;IACF,CAAC;IAED,oCAAgB,GAAhB,UAAiB,EAAU;QAC1B,OAAO,IAAI,CAAC,kBAAkB,CAAC,EAAE,CAAC,CAAC;IACpC,CAAC;IAID,oCAAgB,GAAhB,UAAiB,EAAiB,EAAE,QAAsB,EAAE,aAA2C;QACtG,IAAM,IAAI,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QAEjD,IAAI,CAAC,IAAI,EAAE;YACV,IAAI,CAAC,QAAQ,EAAE;gBACd,gEAAgE;gBAChE,OAAO,IAAI,CAAC;aACZ;YACD,qEAAqE;YACrE,OAAO,IAAI,CAAC,qBAAqB,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,EAAE,qBAAqB,CAAC,aAAa,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;SAClH;QAED,IAAI,CAAC,QAAQ,EAAE;YACd,uDAAuD;YACvD,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YACnC,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YAClC,OAAO,IAAI,CAAC;SACZ;QAED,iFAAiF;QACjF,IAAM,KAAK,GAAG,IAAI,CAAC,kCAAkC,CAAC,QAAQ,CAAC,CAAC;QAChE,IAAM,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,eAAe,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC;QACvF,IAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,aAAa,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC;QACjF,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,YAAY,EAAE,EAAE,WAAW,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;QAC/D,IAAI,CAAC,UAAU,CAAC,qBAAqB,CAAC,aAAa,CAAC,CAAC,CAAC;QACtD,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACnC,OAAO,IAAI,CAAC,EAAE,CAAC;IAChB,CAAC;IAEM,mDAA+B,GAAtC,UAAuC,OAAe;QACrD,IAAI,IAAI,CAAC,WAAW,EAAE;YACrB,OAAO;SACP;QACD,IAAM,KAAK,GAAG,IAAI,CAAC,gBAAgB,CAAC,qBAAqB,CAAC,OAAO,CAAC,CAAC;QACnE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YACjD,IAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YAEtB,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YACnC,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;SAClC;IACF,CAAC;IAEM,wCAAoB,GAA3B,UAA4B,YAAoB;QAC/C,IAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC,CAAC;QAC7C,IAAI,CAAC,IAAI,EAAE;YACV,OAAO,IAAI,CAAC;SACZ;QACD,OAAO,IAAI,CAAC,OAAO,CAAC;IACrB,CAAC;IAEM,sCAAkB,GAAzB,UAA0B,YAAoB;QAC7C,IAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC,CAAC;QAC7C,IAAI,CAAC,IAAI,EAAE;YACV,OAAO,IAAI,CAAC;SACZ;QACD,IAAM,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QACtC,IAAI,IAAI,CAAC,eAAe,KAAK,SAAS,EAAE;YACvC,IAAI,CAAC,gBAAgB,CAAC,WAAW,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;SACnD;QACD,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,EAAE;YACxB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,mBAAmB,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC;SAChF;QACD,OAAO,IAAI,CAAC,KAAK,CAAC;IACnB,CAAC;IAEM,sCAAkB,GAAzB,UAA0B,UAAkB,EAAE,OAAmB,EAAE,mBAAoC;QAAzD,wBAAA,EAAA,WAAmB;QAAE,oCAAA,EAAA,2BAAoC;QACtG,IAAI,UAAU,GAAG,CAAC,IAAI,UAAU,GAAG,IAAI,CAAC,YAAY,EAAE,EAAE;YACvD,OAAO,EAAE,CAAC;SACV;QAED,OAAO,IAAI,CAAC,mBAAmB,CAAC,UAAU,EAAE,UAAU,EAAE,OAAO,EAAE,mBAAmB,CAAC,CAAC;IACvF,CAAC;IAEM,uCAAmB,GAA1B,UAA2B,gBAAwB,EAAE,cAAsB,EAAE,OAAmB,EAAE,mBAAoC;QAAzD,wBAAA,EAAA,WAAmB;QAAE,oCAAA,EAAA,2BAAoC;QACrI,IAAI,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QACpC,IAAI,eAAe,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,gBAAgB,CAAC,CAAC,CAAC;QACzE,IAAI,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC,CAAC;QACrE,IAAI,SAAS,GAAG,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,CAAC;QACrD,OAAO,IAAI,CAAC,sBAAsB,CAAC,IAAI,aAAK,CAAC,eAAe,EAAE,CAAC,EAAE,aAAa,EAAE,SAAS,CAAC,EAAE,OAAO,EAAE,mBAAmB,CAAC,CAAC;IAC3H,CAAC;IAEM,yCAAqB,GAA5B,UAA6B,KAAa,EAAE,OAAmB,EAAE,mBAAoC;QAAzD,wBAAA,EAAA,WAAmB;QAAE,oCAAA,EAAA,2BAAoC;QACpG,IAAI,cAAc,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;QAC/C,OAAO,IAAI,CAAC,sBAAsB,CAAC,cAAc,EAAE,OAAO,EAAE,mBAAmB,CAAC,CAAC;IAClF,CAAC;IAEM,+CAA2B,GAAlC,UAAmC,OAAmB,EAAE,mBAAoC;QAAzD,wBAAA,EAAA,WAAmB;QAAE,oCAAA,EAAA,2BAAoC;QAC3F,IAAM,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QACtC,IAAM,MAAM,GAAG,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,OAAO,EAAE,mBAAmB,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;QAC3F,OAAO,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;IAC5C,CAAC;IAEM,qCAAiB,GAAxB,UAAyB,OAAmB,EAAE,mBAAoC;QAAzD,wBAAA,EAAA,WAAmB;QAAE,oCAAA,EAAA,2BAAoC;QACjF,IAAM,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QACtC,IAAM,MAAM,GAAG,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,OAAO,EAAE,mBAAmB,EAAE,KAAK,EAAE,SAAS,CAAC,CAAC;QAC5F,OAAO,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;IAC5C,CAAC;IAEO,0CAAsB,GAA9B,UAA+B,WAAkB,EAAE,aAAqB,EAAE,mBAA4B;QACrG,IAAM,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,eAAe,EAAE,WAAW,CAAC,WAAW,CAAC,CAAC;QACnG,IAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,aAAa,EAAE,WAAW,CAAC,SAAS,CAAC,CAAC;QAE7F,IAAM,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QACtC,IAAM,MAAM,GAAG,IAAI,CAAC,gBAAgB,CAAC,cAAc,CAAC,WAAW,EAAE,SAAS,EAAE,aAAa,EAAE,mBAAmB,EAAE,SAAS,CAAC,CAAC;QAE3H,OAAO,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;IAC5C,CAAC;IAEO,0CAAsB,GAA9B,UAA+B,KAAqB;QACnD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YACjD,IAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACtB,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,EAAE;gBACxB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,mBAAmB,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC;aAChF;SACD;QACD,OAAO,KAAK,CAAC;IACd,CAAC;IAEO,+BAAW,GAAnB,UAAoB,KAAa,EAAE,GAAW;QAC7C,OAAO,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,KAAK,EAAE,GAAG,GAAG,KAAK,CAAC,CAAC;IACpD,CAAC;IAEO,yCAAqB,GAA7B,UAA8B,YAAoB,EAAE,MAAc;QACjE,IAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC,CAAC;QAC7C,IAAI,CAAC,IAAI,EAAE;YACV,OAAO;SACP;QACD,IAAM,KAAK,GAAG,IAAI,CAAC,kCAAkC,CAAC,MAAM,CAAC,CAAC;QAC9D,IAAM,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,eAAe,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC;QACvF,IAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,aAAa,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC;QAEjF,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,YAAY,EAAE,EAAE,WAAW,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;QAC/D,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IACpC,CAAC;IAEO,gDAA4B,GAApC,UAAqC,YAAoB,EAAE,OAA+B;QACzF,IAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC,CAAC;QAC7C,IAAI,CAAC,IAAI,EAAE;YACV,OAAO;SACP;QAED,IAAM,sBAAsB,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,aAAa,IAAI,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;QAC/G,IAAM,qBAAqB,GAAG,CAAC,OAAO,CAAC,aAAa,IAAI,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;QAEpG,IAAI,sBAAsB,KAAK,qBAAqB,EAAE;YACrD,yDAAyD;YACzD,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YACnC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;YACzB,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SACnC;aAAM;YACN,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;SACzB;IACF,CAAC;IAEO,yCAAqB,GAA7B,UAA8B,OAAe,EAAE,iBAA2B,EAAE,cAA6C;QACxH,IAAM,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QAEtC,IAAM,iBAAiB,GAAG,iBAAiB,CAAC,MAAM,CAAC;QACnD,IAAI,kBAAkB,GAAG,CAAC,CAAC;QAE3B,IAAM,iBAAiB,GAAG,cAAc,CAAC,MAAM,CAAC;QAChD,IAAI,kBAAkB,GAAG,CAAC,CAAC;QAE3B,IAAI,MAAM,GAAG,IAAI,KAAK,CAAS,iBAAiB,CAAC,CAAC;QAClD,OAAO,kBAAkB,GAAG,iBAAiB,IAAI,kBAAkB,GAAG,iBAAiB,EAAE;YAExF,IAAI,IAAI,GAAwB,IAAI,CAAC;YAErC,IAAI,kBAAkB,GAAG,iBAAiB,EAAE;gBAC3C,gCAAgC;gBAChC,GAAG;oBACF,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,iBAAiB,CAAC,kBAAkB,EAAE,CAAC,CAAC,CAAC;iBAClE,QAAQ,CAAC,IAAI,IAAI,kBAAkB,GAAG,iBAAiB,EAAE;gBAE1D,mDAAmD;gBACnD,IAAI,IAAI,EAAE;oBACT,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;iBACnC;aACD;YAED,IAAI,kBAAkB,GAAG,iBAAiB,EAAE;gBAC3C,qCAAqC;gBACrC,IAAI,CAAC,IAAI,EAAE;oBACV,IAAM,oBAAoB,GAAG,CAAC,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC;oBACxD,IAAM,YAAY,GAAM,IAAI,CAAC,WAAW,SAAI,oBAAsB,CAAC;oBACnE,IAAI,GAAG,IAAI,2BAAY,CAAC,YAAY,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC5C,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC;iBACvC;gBAED,sBAAsB;gBACtB,IAAM,aAAa,GAAG,cAAc,CAAC,kBAAkB,CAAC,CAAC;gBACzD,IAAM,KAAK,GAAG,IAAI,CAAC,kCAAkC,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;gBAC3E,IAAM,OAAO,GAAG,iBAAiB,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;gBACzD,IAAM,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,eAAe,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC;gBACvF,IAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,aAAa,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC;gBAEjF,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;gBACvB,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE,WAAW,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;gBACrD,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;gBAEzB,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;gBAEnC,MAAM,CAAC,kBAAkB,CAAC,GAAG,IAAI,CAAC,EAAE,CAAC;gBAErC,kBAAkB,EAAE,CAAC;aACrB;iBAAM;gBACN,IAAI,IAAI,EAAE;oBACT,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;iBAClC;aACD;SACD;QAED,OAAO,MAAM,CAAC;IACf,CAAC;IAED,YAAY;IAEZ,sBAAsB;IAEf,oCAAgB,GAAvB,UAAwB,eAAuB,EAAE,aAAqB;QACrE,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,mBAAmB,EAAE;YACtC,gBAAgB;YAChB,OAAO;SACP;QAED,eAAe,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,eAAe,CAAC,CAAC;QAC/C,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,YAAY,EAAE,EAAE,aAAa,CAAC,CAAC;QAE7D,IAAI,aAAa,IAAI,IAAI,CAAC,OAAO,CAAC,qBAAqB,EAAE;YACxD,gBAAgB;YAChB,OAAO;SACP;QAED,IAAI,eAAe,IAAI,IAAI,CAAC,OAAO,CAAC,qBAAqB,EAAE;YAC1D,iDAAiD;YACjD,IAAI,CAAC,iBAAiB,CAAC,aAAa,CAAC,CAAC;YACtC,OAAO;SACP;QAED,IAAI,mBAAmB,GAAG,IAAI,CAAC,+BAA+B,CAAC,eAAe,CAAC,CAAC;QAChF,IAAI,SAAS,GAAa,EAAE,CAAC;QAC7B,IAAI,YAAY,GAAkB,IAAI,CAAC;QACvC,KAAK,IAAI,CAAC,GAAG,eAAe,GAAG,CAAC,EAAE,mBAAmB,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;YACzE,IAAI,qBAAqB,GAAG,IAAI,CAAC,+BAA+B,CAAC,CAAC,CAAC,CAAC;YAEpE,IAAI,qBAAqB,KAAK,CAAC,EAAE;gBAChC,SAAS;aACT;YAED,IAAI,qBAAqB,GAAG,mBAAmB,EAAE;gBAChD,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBAC7C,IAAI,YAAY,EAAE;oBACjB,MAAM;iBACN;gBACD,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;gBACvC,mBAAmB,GAAG,qBAAqB,CAAC;aAC5C;SACD;QAED,IAAI,CAAC,YAAY,EAAE;YAClB,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,eAAe,EAAE,CAAC;SAClE;QAED,IAAI,KAAK,GAAG,YAAY,CAAC,KAAK,EAAE,CAAC;QACjC,KAAK,IAAI,CAAC,GAAG,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;YAC/C,IAAI,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;YACtE,IAAI,CAAC,EAAE;gBACN,KAAK,GAAG,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;aAC3B;iBAAM;gBACN,KAAK,GAAG,YAAY,CAAC,KAAK,EAAE,CAAC;aAC7B;SACD;QAED,IAAM,YAAY,GAAG,IAAI,gDAA8B,EAAE,CAAC;QAC1D,KAAK,IAAI,CAAC,GAAG,eAAe,EAAE,CAAC,IAAI,aAAa,EAAE,CAAC,EAAE,EAAE;YACtD,IAAI,IAAI,GAAG,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;YAClC,IAAI,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;YAC9D,IAAI,CAAC,EAAE;gBACN,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,kBAAkB,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC;gBAE1F,mDAAmD;gBACnD,yDAAyD;gBACzD,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,CAAC;gBACxC,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC;gBACrC,KAAK,GAAG,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;gBAC3B,YAAY,CAAC,qBAAqB,CAAC,CAAC,CAAC,CAAC;aACtC;iBAAM;gBACN,KAAK,GAAG,YAAY,CAAC,KAAK,EAAE,CAAC;aAC7B;SACD;QAED,IAAM,CAAC,GAAG,YAAY,CAAC,KAAK,EAAE,CAAC;QAC/B,IAAI,CAAC,EAAE;YACN,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;SAChC;IACF,CAAC;IAEM,+BAAW,GAAlB;QACC,IAAI,CAAC,uBAAuB,EAAE,CAAC;QAC/B,IAAI,CAAC,2BAA2B,CAAC;YAChC,0BAA0B,EAAE,KAAK;YACjC,MAAM,EAAE,CAAC;oBACR,cAAc,EAAE,CAAC;oBACjB,YAAY,EAAE,IAAI,CAAC,YAAY,EAAE;iBACjC,CAAC;SACF,CAAC,CAAC;IACJ,CAAC;IAEM,qCAAiB,GAAxB,UAAyB,UAAkB;QAC1C,IAAI,UAAU,GAAG,CAAC,IAAI,UAAU,GAAG,IAAI,CAAC,YAAY,EAAE,EAAE;YACvD,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;SAChD;QAED,IAAM,YAAY,GAAG,IAAI,gDAA8B,EAAE,CAAC;QAE1D,IAAI,CAAC,OAAO,CAAC,sBAAsB,CAAC,IAAI,CAAC,OAAO,EAAE,YAAY,EAAE,UAAU,CAAC,CAAC;QAE5E,IAAM,CAAC,GAAG,YAAY,CAAC,KAAK,EAAE,CAAC;QAC/B,IAAI,CAAC,EAAE;YACN,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;SAChC;IACF,CAAC;IAEM,qCAAiB,GAAxB,UAAyB,UAAkB;QAC1C,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC,UAAU,CAAC,EAAE;YAChD,OAAO,KAAK,CAAC;SACb;QAED,IAAI,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,qBAAqB,GAAG,CAAC,EAAE;YACxD,OAAO,IAAI,CAAC;SACZ;QAED,IAAI,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,GAAG,+BAA+B,EAAE;YACrE,OAAO,IAAI,CAAC;SACZ;QAED,OAAO,KAAK,CAAC;IACd,CAAC;IAEM,mCAAe,GAAtB,UAAuB,UAAkB;QACxC,IAAI,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,EAAE;YACvC,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;SACnC;IACF,CAAC;IAEM,iCAAa,GAApB,UAAqB,UAAkB;QACtC,IAAI,UAAU,GAAG,CAAC,IAAI,UAAU,GAAG,IAAI,CAAC,YAAY,EAAE,EAAE;YACvD,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;SAChD;QAED,OAAO,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;IACxC,CAAC;IAEO,kCAAc,GAAtB,UAAuB,UAAkB;QACxC,IAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;QACzD,OAAO,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,mBAAmB,CAAC,EAAE,EAAE,UAAU,GAAG,CAAC,EAAE,QAAQ,CAAC,CAAC;IACtF,CAAC;IAEM,yCAAqB,GAA5B;QACC,OAAO,IAAI,CAAC,mBAAmB,CAAC;IACjC,CAAC;IAEM,6BAAS,GAAhB;QACC,OAAO,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC;IAC1C,CAAC;IAEM,2BAAO,GAAd,UAAe,kBAAsC;QACpD,IAAI,IAAI,CAAC,mBAAmB,CAAC,EAAE,KAAK,kBAAkB,CAAC,EAAE,EAAE;YAC1D,wBAAwB;YACxB,OAAO;SACP;QAED,IAAI,CAAC,GAA+B;YACnC,WAAW,EAAE,IAAI,CAAC,mBAAmB,CAAC,QAAQ;YAC9C,WAAW,EAAE,kBAAkB,CAAC,QAAQ;SACxC,CAAC;QAEF,IAAI,CAAC,mBAAmB,GAAG,kBAAkB,CAAC;QAE9C,6DAA6D;QAC7D,IAAI,CAAC,uBAAuB,EAAE,CAAC;QAE/B,IAAI,CAAC,2BAA2B,CAAC;YAChC,0BAA0B,EAAE,IAAI;YAChC,MAAM,EAAE,CAAC;oBACR,cAAc,EAAE,CAAC;oBACjB,YAAY,EAAE,IAAI,CAAC,YAAY,EAAE;iBACjC,CAAC;SACF,CAAC,CAAC;QACH,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAClC,IAAI,CAAC,iCAAiC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACjD,CAAC;IAEM,2CAAuB,GAA9B,UAA+B,WAAmB,EAAE,OAAe;QAClE,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,mBAAmB,EAAE;YACtC,OAAO,IAAI,CAAC,mBAAmB,CAAC,EAAE,CAAC;SACnC;QACG,IAAA,wEAA4F,EAA1F,0BAAU,EAAE,kBAA8E,CAAC;QAEjG,IAAI,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;QACjD,OAAO,UAAU,CAAC,aAAa,CAAC,UAAU,CAAC,sBAAsB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;IAChF,CAAC;IAEO,gDAA4B,GAApC;QAAA,iBAOC;QANA,IAAI,IAAI,CAAC,mBAAmB,EAAE,IAAI,IAAI,CAAC,wBAAwB,KAAK,CAAC,CAAC,EAAE;YACvE,IAAI,CAAC,wBAAwB,GAAG,UAAU,CAAC;gBAC1C,KAAI,CAAC,wBAAwB,GAAG,CAAC,CAAC,CAAC;gBACnC,KAAI,CAAC,oBAAoB,EAAE,CAAC;YAC7B,CAAC,EAAE,CAAC,CAAC,CAAC;SACN;IACF,CAAC;IAED,iCAAa,GAAb;QACC,uDAAuD;QACvD,IAAM,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC;QACzD,IAAI,CAAC,oBAAoB,CAAC,aAAa,CAAC,CAAC;QAEzC,IAAI,IAAI,CAAC,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;YAClD,IAAI,CAAC,4BAA4B,EAAE,CAAC;SACpC;IACF,CAAC;IAEO,wCAAoB,GAA5B,UAA6B,YAAkD;QAAlD,6BAAA,EAAA,eAAuB,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE;QAC9E,IAAM,gBAAgB,GAAG,EAAE,CAAC;QAC5B,IAAM,YAAY,GAAG,IAAI,gDAA8B,EAAE,CAAC;QAC1D,IAAM,EAAE,GAAG,qBAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAEnC,OAAO,IAAI,CAAC,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;YACrD,IAAI,EAAE,CAAC,OAAO,EAAE,GAAG,gBAAgB,EAAE;gBACpC,sCAAsC;gBACtC,MAAM;aACN;YAED,IAAM,mBAAmB,GAAG,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;YAEtF,IAAI,mBAAmB,IAAI,YAAY,EAAE;gBACxC,MAAM;aACN;SACD;QAED,IAAI,IAAI,CAAC,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;YAClD,IAAI,CAAC,4BAA4B,EAAE,CAAC;SACpC;QAED,IAAM,CAAC,GAAG,YAAY,CAAC,KAAK,EAAE,CAAC;QAC/B,IAAI,CAAC,EAAE;YACN,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;SAChC;IACF,CAAC;IAEO,+CAA2B,GAAnC,UAAoC,CAA2B;QAC9D,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;YACvB,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;SAChC;IACF,CAAC;IAED,8DAA8D;IAEvD,qCAAiB,GAAxB,UAAyB,SAAoB;QAC5C,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC;QAClD,IAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QAC7D,IAAM,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QAC5D,IAAM,UAAU,GAAG,UAAU,CAAC,sBAAsB,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAE1E,4CAA4C;QACtC,IAAA,8DAAwF,EAAvF,qBAAa,EAAE,mBAAwE,CAAC;QAC/F,IAAM,eAAe,GAAG,0BAAa,CACpC,QAAQ,CAAC,MAAM,EACf,6DAA6B,CAAC,iBAAiB,CAAC,UAAU,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC,EACrF,WAAW,CAAC,SAAS,CAAC,aAAa,EAAE,WAAW,CAAC,EACjD,aAAa,CACb,CAAC;QACF,+DAA+D;QAC/D,IAAI,eAAe,IAAI,eAAe,CAAC,WAAW,IAAI,SAAS,CAAC,MAAM,IAAI,SAAS,CAAC,MAAM,IAAI,eAAe,CAAC,SAAS,EAAE;YACxH,OAAO,eAAe,CAAC;SACvB;QAED,2EAA2E;QAC3E,IAAI,UAAU,GAAG,CAAC,IAAI,aAAa,KAAK,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;YAC5D,2FAA2F;YACrF,IAAA,kEAA4F,EAA3F,qBAAa,EAAE,mBAA4E,CAAC;YACnG,IAAM,cAAc,GAAG,0BAAa,CACnC,QAAQ,CAAC,MAAM,EACf,6DAA6B,CAAC,iBAAiB,CAAC,UAAU,CAAC,aAAa,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,EACzF,WAAW,CAAC,SAAS,CAAC,aAAa,EAAE,WAAW,CAAC,EACjD,aAAa,CACb,CAAC;YACF,+DAA+D;YAC/D,IAAI,cAAc,IAAI,cAAc,CAAC,WAAW,IAAI,SAAS,CAAC,MAAM,IAAI,SAAS,CAAC,MAAM,IAAI,cAAc,CAAC,SAAS,EAAE;gBACrH,OAAO,cAAc,CAAC;aACtB;SACD;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IAEc,iCAAuB,GAAtC,UAAuC,UAAsB,EAAE,UAAkB;QAChF,IAAM,UAAU,GAAG,UAAU,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;QAExD,4CAA4C;QAC5C,IAAI,WAAW,GAAG,CAAC,CAAC;QACpB,KAAK,IAAI,CAAC,GAAG,UAAU,EAAE,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE,CAAC,EAAE,EAAE;YACnF,WAAW,GAAG,UAAU,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;SAC3C;QAED,6CAA6C;QAC7C,IAAI,SAAS,GAAG,UAAU,CAAC,cAAc,EAAE,CAAC,MAAM,CAAC;QACnD,KAAK,IAAI,CAAC,GAAG,UAAU,EAAE,UAAU,GAAG,UAAU,CAAC,QAAQ,EAAE,EAAE,CAAC,GAAG,UAAU,IAAI,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE,CAAC,EAAE,EAAE;YAC/H,SAAS,GAAG,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;SACvC;QAED,OAAO,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;IACjC,CAAC;IAEM,wCAAoB,GAA3B,UAA4B,QAAmB;QAC9C,IAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QACxD,IAAI,CAAC,cAAc,EAAE;YACpB,OAAO;gBACN,IAAI,EAAE,EAAE;gBACR,WAAW,EAAE,QAAQ,CAAC,MAAM;gBAC5B,SAAS,EAAE,QAAQ,CAAC,MAAM;aAC1B,CAAC;SACF;QACD,OAAO;YACN,IAAI,EAAE,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,QAAQ,CAAC,MAAM,GAAG,cAAc,CAAC,WAAW,CAAC;YACjF,WAAW,EAAE,cAAc,CAAC,WAAW;YACvC,SAAS,EAAE,QAAQ,CAAC,MAAM;SAC1B,CAAC;IACH,CAAC;IAEM,yCAAqB,GAA5B,UAA6B,QAAgB,EAAE,SAAoB;QAClE,IAAI,OAAO,GAAG,QAAQ,CAAC,WAAW,EAAE,CAAC;QACrC,IAAI,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC;QAEhD,IAAI,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QAC1D,IAAI,UAAU,GAAG,UAAU,CAAC,aAAa,CAAC,UAAU,CAAC,sBAAsB,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QAClG,IAAI,eAAe,GAAG,6DAA6B,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC;QAEnF,IAAI,CAAC,eAAe,EAAE;YACrB,OAAO,IAAI,CAAC;SACZ;QAED,IAAI,IAAI,GAAG,eAAe,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QAElD,IAAI,CAAC,IAAI,EAAE;YACV,OAAO,IAAI,CAAC;SACZ;QAED,OAAO,IAAI,CAAC,sBAAsB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IACpD,CAAC;IAEM,gCAAY,GAAnB,UAAoB,QAAmB;QACtC,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC,CAAC;IAC5D,CAAC;IAEO,iCAAa,GAArB,UAAsB,QAAkB;QACvC,IAAM,UAAU,GAAG,QAAQ,CAAC,UAAU,CAAC;QACvC,IAAM,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;QACnD,IAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;QAEzD,IAAI,UAAU,GAAG,UAAU,CAAC,sBAAsB,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACxE,IAAI,UAAU,GAAG,CAAC,EAAE;YACnB,OAAO,IAAI,CAAC;SACZ;QACD,IAAM,mBAAmB,GAAG,6DAA6B,CAAC,kBAAkB,CAAC,UAAU,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC,CAAC;QAEnH,4CAA4C;QAC5C,IAAI,mBAAmB,IAAI,CAAC,gCAAqB,CAAC,UAAU,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC,EAAE;YAC/F,mDAAmD;YACnD,IAAI,iBAAiB,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,cAAc,CAAC,UAAU,CAAC,EAAE,QAAQ,CAAC,MAAM,GAAG,CAAC,GAAG,mBAAmB,CAAC,gBAAgB,CAAC,CAAC;YACpI,kDAAkD;YAClD,IAAM,eAAe,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,YAAY,CAAC,UAAU,CAAC,EAAE,QAAQ,CAAC,MAAM,GAAG,CAAC,GAAG,mBAAmB,CAAC,gBAAgB,CAAC,CAAC;YAElI,8FAA8F;YAC9F,uDAAuD;YACvD,IAAI,UAAU,GAA0B,IAAI,CAAC;YAC7C,OAAO,IAAI,EAAE;gBACZ,IAAI,YAAY,GAAG,gCAAa,CAAC,sBAAsB,CAAC,mBAAmB,CAAC,YAAY,EAAE,UAAU,EAAE,QAAQ,EAAE,iBAAiB,EAAE,eAAe,CAAC,CAAC;gBACpJ,IAAI,CAAC,YAAY,EAAE;oBAClB,0CAA0C;oBAC1C,MAAM;iBACN;gBAED,gEAAgE;gBAChE,IAAI,YAAY,CAAC,WAAW,IAAI,QAAQ,CAAC,MAAM,IAAI,QAAQ,CAAC,MAAM,IAAI,YAAY,CAAC,SAAS,EAAE;oBAC7F,IAAI,gBAAgB,GAAG,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC,WAAW,GAAG,CAAC,EAAE,YAAY,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;oBACpG,gBAAgB,GAAG,gBAAgB,CAAC,WAAW,EAAE,CAAC;oBAElD,IAAI,CAAC,GAAG,IAAI,CAAC,kBAAkB,CAAC,YAAY,EAAE,mBAAmB,CAAC,aAAa,CAAC,gBAAgB,CAAC,EAAE,mBAAmB,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,CAAC,CAAC;oBAE5J,gDAAgD;oBAChD,IAAI,CAAC,EAAE;wBACN,UAAU,GAAG,CAAC,CAAC;qBACf;iBACD;gBAED,iBAAiB,GAAG,YAAY,CAAC,SAAS,GAAG,CAAC,CAAC;aAC/C;YAED,IAAI,UAAU,EAAE;gBACf,OAAO,UAAU,CAAC;aAClB;SACD;QAED,+EAA+E;QAC/E,IAAI,UAAU,GAAG,CAAC,IAAI,UAAU,CAAC,cAAc,CAAC,UAAU,CAAC,KAAK,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;YACpF,IAAM,eAAe,GAAG,UAAU,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;YAC9D,UAAU,EAAE,CAAC;YACb,IAAM,gBAAgB,GAAG,6DAA6B,CAAC,kBAAkB,CAAC,UAAU,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC,CAAC;YAEhH,iDAAiD;YACjD,IAAI,gBAAgB,IAAI,CAAC,gCAAqB,CAAC,UAAU,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC,EAAE;gBAC5F,qGAAqG;gBACrG,IAAM,iBAAiB,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,cAAc,CAAC,UAAU,CAAC,EAAE,QAAQ,CAAC,MAAM,GAAG,CAAC,GAAG,gBAAgB,CAAC,gBAAgB,CAAC,CAAC;gBACnI,IAAM,YAAY,GAAG,gCAAa,CAAC,sBAAsB,CAAC,gBAAgB,CAAC,aAAa,EAAE,UAAU,EAAE,QAAQ,EAAE,iBAAiB,EAAE,eAAe,CAAC,CAAC;gBAEpJ,gEAAgE;gBAChE,IAAI,YAAY,IAAI,YAAY,CAAC,WAAW,IAAI,QAAQ,CAAC,MAAM,IAAI,QAAQ,CAAC,MAAM,IAAI,YAAY,CAAC,SAAS,EAAE;oBAC7G,IAAI,gBAAgB,GAAG,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC,WAAW,GAAG,CAAC,EAAE,YAAY,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;oBACpG,gBAAgB,GAAG,gBAAgB,CAAC,WAAW,EAAE,CAAC;oBAElD,IAAI,CAAC,GAAG,IAAI,CAAC,kBAAkB,CAAC,YAAY,EAAE,gBAAgB,CAAC,aAAa,CAAC,gBAAgB,CAAC,EAAE,gBAAgB,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,CAAC,CAAC;oBAEtJ,gDAAgD;oBAChD,IAAI,CAAC,EAAE;wBACN,OAAO,CAAC,CAAC;qBACT;iBACD;aACD;SACD;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IAEO,sCAAkB,GAA1B,UAA2B,YAAmB,EAAE,IAAqB,EAAE,MAAe;QACrF,IAAI,CAAC,IAAI,EAAE;YACV,OAAO,IAAI,CAAC;SACZ;QAED,IAAI,MAAM,EAAE;YACX,IAAI,OAAO,GAAG,IAAI,CAAC,wBAAwB,CAAC,IAAI,EAAE,YAAY,CAAC,cAAc,EAAE,CAAC,CAAC;YACjF,IAAI,OAAO,EAAE;gBACZ,OAAO,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;aAC/B;SACD;aAAM;YACN,IAAI,OAAO,GAAG,IAAI,CAAC,sBAAsB,CAAC,IAAI,EAAE,YAAY,CAAC,gBAAgB,EAAE,CAAC,CAAC;YACjF,IAAI,OAAO,EAAE;gBACZ,OAAO,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;aAC/B;SACD;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IAEO,0CAAsB,GAA9B,UAA+B,OAAwB,EAAE,QAAkB;QAC1E,sHAAsH;QAEtH,IAAM,UAAU,GAAG,OAAO,CAAC,kBAAkB,CAAC,EAAE,CAAC;QACjD,IAAM,oBAAoB,GAAG,OAAO,CAAC,aAAa,CAAC;QACnD,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC;QAEf,KAAK,IAAI,UAAU,GAAG,QAAQ,CAAC,UAAU,EAAE,UAAU,IAAI,CAAC,EAAE,UAAU,EAAE,EAAE;YACzE,IAAM,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;YACnD,IAAM,UAAU,GAAG,UAAU,CAAC,QAAQ,EAAE,CAAC;YACzC,IAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;YAEzD,IAAI,UAAU,GAAG,UAAU,GAAG,CAAC,CAAC;YAChC,IAAI,gBAAgB,GAAG,CAAC,CAAC,CAAC;YAC1B,IAAI,UAAU,KAAK,QAAQ,CAAC,UAAU,EAAE;gBACvC,UAAU,GAAG,UAAU,CAAC,sBAAsB,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;gBACpE,gBAAgB,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;aACvC;YAED,OAAO,UAAU,IAAI,CAAC,EAAE,UAAU,EAAE,EAAE;gBACrC,IAAM,eAAe,GAAG,UAAU,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;gBAC7D,IAAM,SAAS,GAAG,UAAU,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC;gBAC9D,IAAM,gBAAgB,GAAG,UAAU,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;gBAC/D,IAAM,cAAc,GAAG,UAAU,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;gBAE3D,IAAI,gBAAgB,KAAK,CAAC,CAAC,EAAE;oBAC5B,gBAAgB,GAAG,cAAc,CAAC;iBAClC;gBAED,IAAI,eAAe,KAAK,UAAU,IAAI,CAAC,gCAAqB,CAAC,SAAS,CAAC,EAAE;oBAExE,OAAO,IAAI,EAAE;wBACZ,IAAI,CAAC,GAAG,gCAAa,CAAC,sBAAsB,CAAC,oBAAoB,EAAE,UAAU,EAAE,QAAQ,EAAE,gBAAgB,EAAE,gBAAgB,CAAC,CAAC;wBAC7H,IAAI,CAAC,CAAC,EAAE;4BACP,MAAM;yBACN;wBAED,IAAI,OAAO,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,WAAW,GAAG,CAAC,EAAE,CAAC,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;wBACrE,OAAO,GAAG,OAAO,CAAC,WAAW,EAAE,CAAC;wBAEhC,IAAI,OAAO,KAAK,OAAO,CAAC,IAAI,EAAE;4BAC7B,KAAK,EAAE,CAAC;yBACR;6BAAM,IAAI,OAAO,KAAK,OAAO,CAAC,KAAK,EAAE;4BACrC,KAAK,EAAE,CAAC;yBACR;wBAED,IAAI,KAAK,KAAK,CAAC,EAAE;4BAChB,OAAO,CAAC,CAAC;yBACT;wBAED,gBAAgB,GAAG,CAAC,CAAC,WAAW,GAAG,CAAC,CAAC;qBACrC;iBACD;gBAED,gBAAgB,GAAG,CAAC,CAAC,CAAC;aACtB;SACD;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IAEO,4CAAwB,GAAhC,UAAiC,OAAwB,EAAE,QAAkB;QAC5E,wHAAwH;QAExH,IAAM,UAAU,GAAG,OAAO,CAAC,kBAAkB,CAAC,EAAE,CAAC;QACjD,IAAM,YAAY,GAAG,OAAO,CAAC,YAAY,CAAC;QAC1C,IAAI,KAAK,GAAG,CAAC,CAAC;QAEd,KAAK,IAAI,UAAU,GAAG,QAAQ,CAAC,UAAU,EAAE,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,EAAE,UAAU,IAAI,SAAS,EAAE,UAAU,EAAE,EAAE;YAClH,IAAM,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;YACnD,IAAM,UAAU,GAAG,UAAU,CAAC,QAAQ,EAAE,CAAC;YACzC,IAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;YAEzD,IAAI,UAAU,GAAG,CAAC,CAAC;YACnB,IAAI,iBAAiB,GAAG,CAAC,CAAC;YAC1B,IAAI,UAAU,KAAK,QAAQ,CAAC,UAAU,EAAE;gBACvC,UAAU,GAAG,UAAU,CAAC,sBAAsB,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;gBACpE,iBAAiB,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;aACxC;YAED,OAAO,UAAU,GAAG,UAAU,EAAE,UAAU,EAAE,EAAE;gBAC7C,IAAM,eAAe,GAAG,UAAU,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;gBAC7D,IAAM,SAAS,GAAG,UAAU,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC;gBAC9D,IAAM,gBAAgB,GAAG,UAAU,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;gBAC/D,IAAM,cAAc,GAAG,UAAU,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;gBAE3D,IAAI,iBAAiB,KAAK,CAAC,EAAE;oBAC5B,iBAAiB,GAAG,gBAAgB,CAAC;iBACrC;gBAED,IAAI,eAAe,KAAK,UAAU,IAAI,CAAC,gCAAqB,CAAC,SAAS,CAAC,EAAE;oBACxE,OAAO,IAAI,EAAE;wBACZ,IAAI,CAAC,GAAG,gCAAa,CAAC,sBAAsB,CAAC,YAAY,EAAE,UAAU,EAAE,QAAQ,EAAE,iBAAiB,EAAE,cAAc,CAAC,CAAC;wBACpH,IAAI,CAAC,CAAC,EAAE;4BACP,MAAM;yBACN;wBAED,IAAI,OAAO,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,WAAW,GAAG,CAAC,EAAE,CAAC,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;wBACrE,OAAO,GAAG,OAAO,CAAC,WAAW,EAAE,CAAC;wBAEhC,IAAI,OAAO,KAAK,OAAO,CAAC,IAAI,EAAE;4BAC7B,KAAK,EAAE,CAAC;yBACR;6BAAM,IAAI,OAAO,KAAK,OAAO,CAAC,KAAK,EAAE;4BACrC,KAAK,EAAE,CAAC;yBACR;wBAED,IAAI,KAAK,KAAK,CAAC,EAAE;4BAChB,OAAO,CAAC,CAAC;yBACT;wBAED,iBAAiB,GAAG,CAAC,CAAC,SAAS,GAAG,CAAC,CAAC;qBACpC;iBACD;gBAED,iBAAiB,GAAG,CAAC,CAAC;aACtB;SACD;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IAEM,mCAAe,GAAtB,UAAuB,SAAoB;QAC1C,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC;QAElD,IAAI,UAAU,GAAe,CAAC,CAAC,CAAC;QAChC,IAAI,YAAY,GAA4B,IAAI,CAAC;QACjD,KAAK,IAAI,UAAU,GAAG,QAAQ,CAAC,UAAU,EAAE,UAAU,IAAI,CAAC,EAAE,UAAU,EAAE,EAAE;YACzE,IAAM,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;YACnD,IAAM,UAAU,GAAG,UAAU,CAAC,QAAQ,EAAE,CAAC;YACzC,IAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;YAEzD,IAAI,UAAU,GAAG,UAAU,GAAG,CAAC,CAAC;YAChC,IAAI,gBAAgB,GAAG,CAAC,CAAC,CAAC;YAC1B,IAAI,UAAU,KAAK,QAAQ,CAAC,UAAU,EAAE;gBACvC,UAAU,GAAG,UAAU,CAAC,sBAAsB,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;gBACpE,gBAAgB,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;aACvC;YAED,OAAO,UAAU,IAAI,CAAC,EAAE,UAAU,EAAE,EAAE;gBACrC,IAAM,eAAe,GAAG,UAAU,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;gBAC7D,IAAM,SAAS,GAAG,UAAU,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC;gBAC9D,IAAM,gBAAgB,GAAG,UAAU,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;gBAC/D,IAAM,cAAc,GAAG,UAAU,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;gBAE3D,IAAI,gBAAgB,KAAK,CAAC,CAAC,EAAE;oBAC5B,gBAAgB,GAAG,cAAc,CAAC;iBAClC;gBACD,IAAI,UAAU,KAAK,eAAe,EAAE;oBACnC,UAAU,GAAG,eAAe,CAAC;oBAC7B,YAAY,GAAG,6DAA6B,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC;iBAC5E;gBACD,IAAI,YAAY,IAAI,CAAC,gCAAqB,CAAC,SAAS,CAAC,EAAE;oBACtD,IAAI,CAAC,GAAG,gCAAa,CAAC,sBAAsB,CAAC,YAAY,CAAC,aAAa,EAAE,UAAU,EAAE,QAAQ,EAAE,gBAAgB,EAAE,gBAAgB,CAAC,CAAC;oBACnI,IAAI,CAAC,EAAE;wBACN,OAAO,IAAI,CAAC,eAAe,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC;qBAC7C;iBACD;gBAED,gBAAgB,GAAG,CAAC,CAAC,CAAC;aACtB;SACD;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IAEM,mCAAe,GAAtB,UAAuB,SAAoB;QAC1C,IAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC;QAElD,IAAI,UAAU,GAAe,CAAC,CAAC,CAAC;QAChC,IAAI,YAAY,GAA4B,IAAI,CAAC;QACjD,KAAK,IAAI,UAAU,GAAG,QAAQ,CAAC,UAAU,EAAE,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,EAAE,UAAU,IAAI,SAAS,EAAE,UAAU,EAAE,EAAE;YAClH,IAAM,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;YACnD,IAAM,UAAU,GAAG,UAAU,CAAC,QAAQ,EAAE,CAAC;YACzC,IAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;YAEzD,IAAI,UAAU,GAAG,CAAC,CAAC;YACnB,IAAI,iBAAiB,GAAG,CAAC,CAAC;YAC1B,IAAI,UAAU,KAAK,QAAQ,CAAC,UAAU,EAAE;gBACvC,UAAU,GAAG,UAAU,CAAC,sBAAsB,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;gBACpE,iBAAiB,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;aACxC;YAED,OAAO,UAAU,GAAG,UAAU,EAAE,UAAU,EAAE,EAAE;gBAC7C,IAAM,eAAe,GAAG,UAAU,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;gBAC7D,IAAM,SAAS,GAAG,UAAU,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC;gBAC9D,IAAM,gBAAgB,GAAG,UAAU,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;gBAC/D,IAAM,cAAc,GAAG,UAAU,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;gBAE3D,IAAI,iBAAiB,KAAK,CAAC,EAAE;oBAC5B,iBAAiB,GAAG,gBAAgB,CAAC;iBACrC;gBAED,IAAI,UAAU,KAAK,eAAe,EAAE;oBACnC,UAAU,GAAG,eAAe,CAAC;oBAC7B,YAAY,GAAG,6DAA6B,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC;iBAC5E;gBACD,IAAI,YAAY,IAAI,CAAC,gCAAqB,CAAC,SAAS,CAAC,EAAE;oBACtD,IAAI,CAAC,GAAG,gCAAa,CAAC,sBAAsB,CAAC,YAAY,CAAC,YAAY,EAAE,UAAU,EAAE,QAAQ,EAAE,iBAAiB,EAAE,cAAc,CAAC,CAAC;oBACjI,IAAI,CAAC,EAAE;wBACN,OAAO,IAAI,CAAC,eAAe,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC;qBAC7C;iBACD;gBAED,iBAAiB,GAAG,CAAC,CAAC;aACtB;SACD;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IAEO,mCAAe,GAAvB,UAAwB,YAA8B,EAAE,CAAQ;QAC/D,IAAI,CAAC,CAAC,EAAE;YACP,OAAO,IAAI,CAAC;SACZ;QAED,IAAI,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;QACnC,IAAI,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;QAE1B,IAAI,IAAI,GAAG,YAAY,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAC5C,IAAI,CAAC,IAAI,EAAE;YACV,OAAO,IAAI,CAAC;SACZ;QAED,OAAO;YACN,KAAK,EAAE,CAAC;YACR,IAAI,EAAE,IAAI,CAAC,IAAI;YACf,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,MAAM,EAAE,YAAY,CAAC,iBAAiB,CAAC,IAAI,CAAC;SAC5C,CAAC;IACH,CAAC;IAED;;;;OAIG;IACW,4BAAkB,GAAhC,UAAiC,IAAY,EAAE,OAAe;QAC7D,IAAI,MAAM,GAAG,CAAC,CAAC;QACf,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,IAAI,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;QAEtB,OAAO,CAAC,GAAG,GAAG,EAAE;YACf,IAAI,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAChC,IAAI,MAAM,KAAK,mBAAQ,CAAC,KAAK,EAAE;gBAC9B,MAAM,EAAE,CAAC;aACT;iBAAM,IAAI,MAAM,KAAK,mBAAQ,CAAC,GAAG,EAAE;gBACnC,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,OAAO,GAAG,OAAO,CAAC;aAC7C;iBAAM;gBACN,MAAM;aACN;YACD,CAAC,EAAE,CAAC;SACJ;QAED,IAAI,CAAC,KAAK,GAAG,EAAE;YACd,OAAO,CAAC,CAAC,CAAC,CAAC,mCAAmC;SAC9C;QAED,OAAO,MAAM,CAAC;IACf,CAAC;IAEO,uCAAmB,GAA3B,UAA4B,SAAiB;QAC5C,OAAO,SAAS,CAAC,kBAAkB,CAAC,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,SAAS,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;IACxG,CAAC;IAEM,wCAAoB,GAA3B,UAA4B,UAAkB,EAAE,aAAqB,EAAE,aAAqB;QAA5F,iBAqKC;QApKA,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAM,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QAEtC,IAAI,UAAU,GAAG,CAAC,IAAI,UAAU,GAAG,SAAS,EAAE;YAC7C,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;SAChD;QAED,IAAM,YAAY,GAAG,6DAA6B,CAAC,eAAe,CAAC,IAAI,CAAC,mBAAmB,CAAC,EAAE,CAAC,CAAC;QAChG,IAAM,OAAO,GAAG,OAAO,CAAC,YAAY,IAAI,YAAY,CAAC,OAAO,CAAC,CAAC;QAE9D,IAAI,wBAAwB,GAAG,CAAC,CAAC,CAAC,CAAC,+CAA+C;QAClF,IAAI,yBAAyB,GAAG,CAAC,CAAC,CAAC;QACnC,IAAI,wBAAwB,GAAG,CAAC,CAAC,CAAC,CAAC,+CAA+C;QAClF,IAAI,yBAAyB,GAAG,CAAC,CAAC,CAAC;QACnC,IAAM,iBAAiB,GAAG,UAAC,UAAkB;YAC5C,IAAI,wBAAwB,KAAK,CAAC,CAAC,IAAI,CAAC,wBAAwB,KAAK,CAAC,CAAC,IAAI,wBAAwB,GAAG,UAAU,GAAG,CAAC,CAAC,EAAE;gBACtH,wBAAwB,GAAG,CAAC,CAAC,CAAC;gBAC9B,yBAAyB,GAAG,CAAC,CAAC,CAAC;gBAE/B,uCAAuC;gBACvC,KAAK,IAAI,SAAS,GAAG,UAAU,GAAG,CAAC,EAAE,SAAS,IAAI,CAAC,EAAE,SAAS,EAAE,EAAE;oBACjE,IAAI,QAAM,GAAG,KAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;oBACjD,IAAI,QAAM,IAAI,CAAC,EAAE;wBAChB,wBAAwB,GAAG,SAAS,CAAC;wBACrC,yBAAyB,GAAG,QAAM,CAAC;wBACnC,MAAM;qBACN;iBACD;aACD;YAED,IAAI,wBAAwB,KAAK,CAAC,CAAC,EAAE;gBACpC,wBAAwB,GAAG,CAAC,CAAC,CAAC;gBAC9B,yBAAyB,GAAG,CAAC,CAAC,CAAC;gBAE/B,mCAAmC;gBACnC,KAAK,IAAI,SAAS,GAAG,UAAU,EAAE,SAAS,GAAG,SAAS,EAAE,SAAS,EAAE,EAAE;oBACpE,IAAI,QAAM,GAAG,KAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;oBACjD,IAAI,QAAM,IAAI,CAAC,EAAE;wBAChB,wBAAwB,GAAG,SAAS,CAAC;wBACrC,yBAAyB,GAAG,QAAM,CAAC;wBACnC,MAAM;qBACN;iBACD;aACD;QACF,CAAC,CAAC;QAEF,IAAI,0BAA0B,GAAG,CAAC,CAAC,CAAC,CAAC,+CAA+C;QACpF,IAAI,2BAA2B,GAAG,CAAC,CAAC,CAAC;QACrC,IAAI,0BAA0B,GAAG,CAAC,CAAC,CAAC,CAAC,+CAA+C;QACpF,IAAI,2BAA2B,GAAG,CAAC,CAAC,CAAC;QACrC,IAAM,mBAAmB,GAAG,UAAC,UAAkB;YAC9C,IAAI,0BAA0B,KAAK,CAAC,CAAC,EAAE;gBACtC,0BAA0B,GAAG,CAAC,CAAC,CAAC;gBAChC,2BAA2B,GAAG,CAAC,CAAC,CAAC;gBAEjC,uCAAuC;gBACvC,KAAK,IAAI,SAAS,GAAG,UAAU,GAAG,CAAC,EAAE,SAAS,IAAI,CAAC,EAAE,SAAS,EAAE,EAAE;oBACjE,IAAI,QAAM,GAAG,KAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;oBACjD,IAAI,QAAM,IAAI,CAAC,EAAE;wBAChB,0BAA0B,GAAG,SAAS,CAAC;wBACvC,2BAA2B,GAAG,QAAM,CAAC;wBACrC,MAAM;qBACN;iBACD;aACD;YAED,IAAI,0BAA0B,KAAK,CAAC,CAAC,IAAI,CAAC,0BAA0B,KAAK,CAAC,CAAC,IAAI,0BAA0B,GAAG,UAAU,GAAG,CAAC,CAAC,EAAE;gBAC5H,0BAA0B,GAAG,CAAC,CAAC,CAAC;gBAChC,2BAA2B,GAAG,CAAC,CAAC,CAAC;gBAEjC,mCAAmC;gBACnC,KAAK,IAAI,SAAS,GAAG,UAAU,EAAE,SAAS,GAAG,SAAS,EAAE,SAAS,EAAE,EAAE;oBACpE,IAAI,QAAM,GAAG,KAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;oBACjD,IAAI,QAAM,IAAI,CAAC,EAAE;wBAChB,0BAA0B,GAAG,SAAS,CAAC;wBACvC,2BAA2B,GAAG,QAAM,CAAC;wBACrC,MAAM;qBACN;iBACD;aACD;QACF,CAAC,CAAC;QAEF,IAAI,eAAe,GAAG,CAAC,CAAC;QACxB,IAAI,IAAI,GAAG,IAAI,CAAC;QAChB,IAAI,aAAa,GAAG,CAAC,CAAC;QACtB,IAAI,MAAM,GAAG,IAAI,CAAC;QAClB,IAAI,MAAM,GAAG,CAAC,CAAC;QAEf,KAAK,IAAI,QAAQ,GAAG,CAAC,EAAE,IAAI,IAAI,MAAM,EAAE,QAAQ,EAAE,EAAE;YAClD,IAAM,YAAY,GAAG,UAAU,GAAG,QAAQ,CAAC;YAC3C,IAAM,cAAc,GAAG,UAAU,GAAG,QAAQ,CAAC;YAE7C,IAAI,QAAQ,KAAK,CAAC,IAAI,CAAC,YAAY,GAAG,CAAC,IAAI,YAAY,GAAG,aAAa,CAAC,EAAE;gBACzE,IAAI,GAAG,KAAK,CAAC;aACb;YACD,IAAI,QAAQ,KAAK,CAAC,IAAI,CAAC,cAAc,GAAG,SAAS,IAAI,cAAc,GAAG,aAAa,CAAC,EAAE;gBACrF,MAAM,GAAG,KAAK,CAAC;aACf;YACD,IAAI,QAAQ,GAAG,KAAK,EAAE;gBACrB,kBAAkB;gBAClB,IAAI,GAAG,KAAK,CAAC;gBACb,MAAM,GAAG,KAAK,CAAC;aACf;YAED,IAAI,IAAI,EAAE;gBACT,gCAAgC;gBAChC,IAAI,iBAAiB,SAAQ,CAAC;gBAE9B,IAAM,aAAa,GAAG,IAAI,CAAC,mBAAmB,CAAC,YAAY,GAAG,CAAC,CAAC,CAAC;gBACjE,IAAI,aAAa,IAAI,CAAC,EAAE;oBACvB,6CAA6C;oBAC7C,wBAAwB;oBACxB,wBAAwB,GAAG,YAAY,GAAG,CAAC,CAAC;oBAC5C,yBAAyB,GAAG,aAAa,CAAC;oBAC1C,iBAAiB,GAAG,IAAI,CAAC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;iBACxE;qBAAM;oBACN,iBAAiB,CAAC,YAAY,CAAC,CAAC;oBAChC,iBAAiB,GAAG,IAAI,CAAC,gCAAgC,CAAC,OAAO,EAAE,yBAAyB,EAAE,yBAAyB,CAAC,CAAC;iBACzH;gBAED,IAAI,QAAQ,KAAK,CAAC,EAAE;oBACnB,kCAAkC;oBAClC,eAAe,GAAG,YAAY,CAAC;oBAC/B,aAAa,GAAG,cAAc,CAAC;oBAC/B,MAAM,GAAG,iBAAiB,CAAC;oBAC3B,IAAI,MAAM,KAAK,CAAC,EAAE;wBACjB,sBAAsB;wBACtB,OAAO,EAAE,eAAe,iBAAA,EAAE,aAAa,eAAA,EAAE,MAAM,QAAA,EAAE,CAAC;qBAClD;oBACD,SAAS;iBACT;gBAED,IAAI,iBAAiB,IAAI,MAAM,EAAE;oBAChC,eAAe,GAAG,YAAY,CAAC;iBAC/B;qBAAM;oBACN,IAAI,GAAG,KAAK,CAAC;iBACb;aACD;YAED,IAAI,MAAM,EAAE;gBACX,kCAAkC;gBAClC,IAAI,mBAAmB,SAAQ,CAAC;gBAEhC,IAAM,aAAa,GAAG,IAAI,CAAC,mBAAmB,CAAC,cAAc,GAAG,CAAC,CAAC,CAAC;gBACnE,IAAI,aAAa,IAAI,CAAC,EAAE;oBACvB,6CAA6C;oBAC7C,wBAAwB;oBACxB,0BAA0B,GAAG,cAAc,GAAG,CAAC,CAAC;oBAChD,2BAA2B,GAAG,aAAa,CAAC;oBAC5C,mBAAmB,GAAG,IAAI,CAAC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;iBAC1E;qBAAM;oBACN,mBAAmB,CAAC,cAAc,CAAC,CAAC;oBACpC,mBAAmB,GAAG,IAAI,CAAC,gCAAgC,CAAC,OAAO,EAAE,2BAA2B,EAAE,2BAA2B,CAAC,CAAC;iBAC/H;gBAED,IAAI,mBAAmB,IAAI,MAAM,EAAE;oBAClC,aAAa,GAAG,cAAc,CAAC;iBAC/B;qBAAM;oBACN,MAAM,GAAG,KAAK,CAAC;iBACf;aACD;SACD;QAED,OAAO,EAAE,eAAe,iBAAA,EAAE,aAAa,eAAA,EAAE,MAAM,QAAA,EAAE,CAAC;IACnD,CAAC;IAEM,wCAAoB,GAA3B,UAA4B,eAAuB,EAAE,aAAqB;QACzE,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC1B,IAAM,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QAEtC,IAAI,eAAe,GAAG,CAAC,IAAI,eAAe,GAAG,SAAS,EAAE;YACvD,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;SACrD;QACD,IAAI,aAAa,GAAG,CAAC,IAAI,aAAa,GAAG,SAAS,EAAE;YACnD,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;SACnD;QAED,IAAM,YAAY,GAAG,6DAA6B,CAAC,eAAe,CAAC,IAAI,CAAC,mBAAmB,CAAC,EAAE,CAAC,CAAC;QAChG,IAAM,OAAO,GAAG,OAAO,CAAC,YAAY,IAAI,YAAY,CAAC,OAAO,CAAC,CAAC;QAE9D,IAAI,MAAM,GAAa,IAAI,KAAK,CAAS,aAAa,GAAG,eAAe,GAAG,CAAC,CAAC,CAAC;QAE9E,IAAI,qBAAqB,GAAG,CAAC,CAAC,CAAC,CAAC,+CAA+C;QAC/E,IAAI,sBAAsB,GAAG,CAAC,CAAC,CAAC;QAEhC,IAAI,qBAAqB,GAAG,CAAC,CAAC,CAAC,CAAC,+CAA+C;QAC/E,IAAI,sBAAsB,GAAG,CAAC,CAAC,CAAC;QAEhC,KAAK,IAAI,UAAU,GAAG,eAAe,EAAE,UAAU,IAAI,aAAa,EAAE,UAAU,EAAE,EAAE;YACjF,IAAI,WAAW,GAAG,UAAU,GAAG,eAAe,CAAC;YAE/C,IAAM,aAAa,GAAG,IAAI,CAAC,mBAAmB,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;YAC/D,IAAI,aAAa,IAAI,CAAC,EAAE;gBACvB,6CAA6C;gBAC7C,wBAAwB;gBACxB,qBAAqB,GAAG,UAAU,GAAG,CAAC,CAAC;gBACvC,sBAAsB,GAAG,aAAa,CAAC;gBACvC,MAAM,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;gBAC1E,SAAS;aACT;YAED,IAAI,qBAAqB,KAAK,CAAC,CAAC,EAAE;gBACjC,qBAAqB,GAAG,CAAC,CAAC,CAAC;gBAC3B,sBAAsB,GAAG,CAAC,CAAC,CAAC;gBAE5B,uCAAuC;gBACvC,KAAK,IAAI,SAAS,GAAG,UAAU,GAAG,CAAC,EAAE,SAAS,IAAI,CAAC,EAAE,SAAS,EAAE,EAAE;oBACjE,IAAI,MAAM,GAAG,IAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;oBACjD,IAAI,MAAM,IAAI,CAAC,EAAE;wBAChB,qBAAqB,GAAG,SAAS,CAAC;wBAClC,sBAAsB,GAAG,MAAM,CAAC;wBAChC,MAAM;qBACN;iBACD;aACD;YAED,IAAI,qBAAqB,KAAK,CAAC,CAAC,IAAI,CAAC,qBAAqB,KAAK,CAAC,CAAC,IAAI,qBAAqB,GAAG,UAAU,GAAG,CAAC,CAAC,EAAE;gBAC7G,qBAAqB,GAAG,CAAC,CAAC,CAAC;gBAC3B,sBAAsB,GAAG,CAAC,CAAC,CAAC;gBAE5B,mCAAmC;gBACnC,KAAK,IAAI,SAAS,GAAG,UAAU,EAAE,SAAS,GAAG,SAAS,EAAE,SAAS,EAAE,EAAE;oBACpE,IAAI,MAAM,GAAG,IAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;oBACjD,IAAI,MAAM,IAAI,CAAC,EAAE;wBAChB,qBAAqB,GAAG,SAAS,CAAC;wBAClC,sBAAsB,GAAG,MAAM,CAAC;wBAChC,MAAM;qBACN;iBACD;aACD;YAED,MAAM,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC,gCAAgC,CAAC,OAAO,EAAE,sBAAsB,EAAE,sBAAsB,CAAC,CAAC;SAErH;QACD,OAAO,MAAM,CAAC;IACf,CAAC;IAEO,oDAAgC,GAAxC,UAAyC,OAAgB,EAAE,sBAA8B,EAAE,sBAA8B;QACxH,IAAI,sBAAsB,KAAK,CAAC,CAAC,IAAI,sBAAsB,KAAK,CAAC,CAAC,EAAE;YACnE,mCAAmC;YACnC,OAAO,CAAC,CAAC;SAET;aAAM,IAAI,sBAAsB,GAAG,sBAAsB,EAAE;YAC3D,iCAAiC;YACjC,OAAO,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,sBAAsB,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC;SAE3E;aAAM,IAAI,sBAAsB,KAAK,sBAAsB,EAAE;YAC7D,gCAAgC;YAChC,OAAO,IAAI,CAAC,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;SAEpE;aAAM;YAEN,IAAI,OAAO,EAAE;gBACZ,6BAA6B;gBAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;aACpE;iBAAM;gBACN,2CAA2C;gBAC3C,OAAO,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,sBAAsB,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC;aAC3E;SAED;IACF,CAAC;IAlgFuB,0BAAgB,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,CAAC,CAAC,QAAQ;IAC7C,mCAAyB,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,CAAC,CAAC,SAAS;IACvD,yCAA+B,GAAG,GAAG,GAAG,IAAI,CAAC,CAAC,aAAa;IAErE,kCAAwB,GAAoC;QACzE,iBAAiB,EAAE,KAAK;QACxB,OAAO,EAAE,qCAAqB,CAAC,OAAO;QACtC,UAAU,EAAE,qCAAqB,CAAC,UAAU;QAC5C,YAAY,EAAE,qCAAqB,CAAC,YAAY;QAChD,iBAAiB,EAAE,KAAK;QACxB,UAAU,EAAE,KAAK,CAAC,gBAAgB,CAAC,EAAE;QACrC,kBAAkB,EAAE,qCAAqB,CAAC,kBAAkB;QAC5D,sBAAsB,EAAE,qCAAqB,CAAC,sBAAsB;KACpE,CAAC;IAw/EH,gBAAC;CAAA,AAvgFD,CAA+B,sBAAU,GAugFxC;AAvgFY,8BAAS;AAygFtB,qBAAqB;AAErB;IAYC;QACC,IAAI,CAAC,iBAAiB,GAAG,IAAI,2BAAY,EAAE,CAAC;QAC5C,IAAI,CAAC,iBAAiB,GAAG,IAAI,2BAAY,EAAE,CAAC;IAC7C,CAAC;IAEM,yCAAc,GAArB,UAAsB,KAAa,EAAE,GAAW,EAAE,aAAqB,EAAE,mBAA4B,EAAE,eAAuB;QAC7H,IAAM,EAAE,GAAG,IAAI,CAAC,iBAAiB,CAAC,cAAc,CAAC,KAAK,EAAE,GAAG,EAAE,aAAa,EAAE,mBAAmB,EAAE,eAAe,CAAC,CAAC;QAClH,IAAM,EAAE,GAAG,IAAI,CAAC,iBAAiB,CAAC,cAAc,CAAC,KAAK,EAAE,GAAG,EAAE,aAAa,EAAE,mBAAmB,EAAE,eAAe,CAAC,CAAC;QAClH,OAAO,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACtB,CAAC;IAEM,iCAAM,GAAb,UAAc,aAAqB,EAAE,mBAA4B,EAAE,iBAA0B,EAAE,eAAuB;QACrH,IAAI,iBAAiB,EAAE;YACtB,OAAO,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,aAAa,EAAE,mBAAmB,EAAE,eAAe,CAAC,CAAC;SAC1F;aAAM;YACN,IAAM,EAAE,GAAG,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,aAAa,EAAE,mBAAmB,EAAE,eAAe,CAAC,CAAC;YAC9F,IAAM,EAAE,GAAG,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,aAAa,EAAE,mBAAmB,EAAE,eAAe,CAAC,CAAC;YAC9F,OAAO,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;SACrB;IACF,CAAC;IAEM,gDAAqB,GAA5B,UAA6B,OAAe;QAC3C,IAAM,EAAE,GAAG,IAAI,CAAC,iBAAiB,CAAC,qBAAqB,CAAC,OAAO,CAAC,CAAC;QACjE,IAAM,EAAE,GAAG,IAAI,CAAC,iBAAiB,CAAC,qBAAqB,CAAC,OAAO,CAAC,CAAC;QACjE,OAAO,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACtB,CAAC;IAEM,gDAAqB,GAA5B;QACC,IAAM,EAAE,GAAG,IAAI,CAAC,iBAAiB,CAAC,qBAAqB,EAAE,CAAC;QAC1D,IAAM,EAAE,GAAG,IAAI,CAAC,iBAAiB,CAAC,qBAAqB,EAAE,CAAC;QAC1D,OAAO,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACtB,CAAC;IAEM,iCAAM,GAAb,UAAc,IAAkB;QAC/B,IAAI,uCAAwB,CAAC,IAAI,CAAC,EAAE;YACnC,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SACpC;aAAM;YACN,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SACpC;IACF,CAAC;IAEM,iCAAM,GAAb,UAAc,IAAkB;QAC/B,IAAI,uCAAwB,CAAC,IAAI,CAAC,EAAE;YACnC,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SACpC;aAAM;YACN,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SACpC;IACF,CAAC;IAEM,sCAAW,GAAlB,UAAmB,IAAkB,EAAE,eAAuB;QAC7D,IAAI,uCAAwB,CAAC,IAAI,CAAC,EAAE;YACnC,IAAI,CAAC,iBAAiB,CAAC,WAAW,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;SAC1D;aAAM;YACN,IAAI,CAAC,iBAAiB,CAAC,WAAW,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;SAC1D;IACF,CAAC;IAEM,wCAAa,GAApB,UAAqB,MAAc,EAAE,MAAc,EAAE,UAAkB,EAAE,gBAAyB;QACjG,IAAI,CAAC,iBAAiB,CAAC,aAAa,CAAC,MAAM,EAAE,MAAM,EAAE,UAAU,EAAE,gBAAgB,CAAC,CAAC;QACnF,IAAI,CAAC,iBAAiB,CAAC,aAAa,CAAC,MAAM,EAAE,MAAM,EAAE,UAAU,EAAE,gBAAgB,CAAC,CAAC;IACpF,CAAC;IACF,uBAAC;AAAD,CAAC,AAzED,IAyEC;AAED,SAAS,cAAc,CAAC,SAAiB;IACxC,OAAO,SAAS,CAAC,OAAO,CAAC,gBAAgB,EAAE,GAAG,CAAC,CAAC;AACjD,CAAC;AAED;IAMC,6CAAY,OAAmD;QAC9D,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,IAAI,OAAO,CAAC,KAAK,CAAC;QAC5C,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,IAAI,OAAO,CAAC,KAAK,CAAC;QACpD,IAAI,CAAC,QAAQ,GAAG,CAAC,OAAO,OAAO,CAAC,QAAQ,KAAK,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC;QAC3G,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;IAC5B,CAAC;IAEM,sDAAQ,GAAf,UAAgB,KAAa;QAC5B,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE;YACzB,IAAI,KAAK,CAAC,IAAI,KAAK,OAAO,IAAI,IAAI,CAAC,SAAS,EAAE;gBAC7C,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;aAChE;iBAAM;gBACN,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;aAC5D;SACD;QACD,OAAO,IAAI,CAAC,cAAc,CAAC;IAC5B,CAAC;IAEM,mEAAqB,GAA5B;QACC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;IAC5B,CAAC;IAEO,2DAAa,GAArB,UAAsB,KAA0B,EAAE,KAAa;QAC9D,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;YAC9B,OAAO,KAAK,CAAC;SACb;QACD,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAChD,IAAI,CAAC,CAAC,EAAE;YACP,OAAO,OAAO,CAAC,KAAK,CAAC;SACrB;QACD,OAAO,CAAC,CAAC,QAAQ,EAAE,CAAC;IACrB,CAAC;IACF,0CAAC;AAAD,CAAC,AAtCD,IAsCC;AAtCY,kFAAmC;AAwChD;IA6BC,gCAAoB,OAAsC;QACzD,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,IAAI,KAAK,CAAC,sBAAsB,CAAC,4BAA4B,CAAC;QAClG,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,IAAI,CAAC,CAAC;QAClC,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,cAAc,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAC9E,IAAI,CAAC,YAAY,GAAG,2BAAmB,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;QAC9D,IAAI,CAAC,uBAAuB,GAAG,2BAAmB,CAAC,OAAO,CAAC,uBAAuB,CAAC,CAAC;QACpF,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,WAAW,IAAI,KAAK,CAAC;QAChD,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,IAAI,KAAK,CAAC;QACxD,IAAI,CAAC,qBAAqB,GAAG,OAAO,CAAC,qBAAqB,IAAI,KAAK,CAAC;QACpE,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC,IAAI,mCAAmC,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QACnH,IAAI,CAAC,oBAAoB,GAAG,OAAO,CAAC,oBAAoB,CAAC,CAAC,CAAC,cAAc,CAAC,OAAO,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAC/G,IAAI,CAAC,yBAAyB,GAAG,OAAO,CAAC,yBAAyB,CAAC,CAAC,CAAC,cAAc,CAAC,OAAO,CAAC,yBAAyB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAC9H,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC,CAAC,CAAC,cAAc,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAChG,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC,CAAC,CAAC,cAAc,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAChG,IAAI,CAAC,mCAAmC,GAAG,OAAO,CAAC,mCAAmC,IAAI,KAAK,CAAC;QAChG,IAAI,CAAC,sBAAsB,GAAG,OAAO,CAAC,sBAAsB,CAAC,CAAC,CAAC,cAAc,CAAC,OAAO,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QACrH,IAAI,CAAC,qBAAqB,GAAG,OAAO,CAAC,qBAAqB,CAAC,CAAC,CAAC,cAAc,CAAC,OAAO,CAAC,qBAAqB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;IACnH,CAAC;IA1Ca,+BAAQ,GAAtB,UAAuB,OAAsC;QAC5D,OAAO,IAAI,sBAAsB,CAAC,OAAO,CAAC,CAAC;IAC5C,CAAC;IAEa,oCAAa,GAA3B,UAA4B,OAAsC;QACjE,OAAO,IAAI,sBAAsB,CAAC,OAAO,CAAC,CAAC;IAC5C,CAAC;IAqCF,6BAAC;AAAD,CAAC,AA/CD,IA+CC;AA/CY,wDAAsB;AAgDnC,sBAAsB,CAAC,KAAK,GAAG,sBAAsB,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;AAEnE;;GAEG;AACH,IAAM,qBAAqB,GAAG;IAC7B,sBAAsB,CAAC,QAAQ,CAAC,EAAE,UAAU,EAAE,KAAK,CAAC,sBAAsB,CAAC,4BAA4B,EAAE,CAAC;IAC1G,sBAAsB,CAAC,QAAQ,CAAC,EAAE,UAAU,EAAE,KAAK,CAAC,sBAAsB,CAAC,2BAA2B,EAAE,CAAC;IACzG,sBAAsB,CAAC,QAAQ,CAAC,EAAE,UAAU,EAAE,KAAK,CAAC,sBAAsB,CAAC,yBAAyB,EAAE,CAAC;IACvG,sBAAsB,CAAC,QAAQ,CAAC,EAAE,UAAU,EAAE,KAAK,CAAC,sBAAsB,CAAC,wBAAwB,EAAE,CAAC;CACtG,CAAC;AAEF,SAAS,iBAAiB,CAAC,OAAsC;IAChE,IAAI,OAAO,YAAY,sBAAsB,EAAE;QAC9C,OAAO,OAAO,CAAC;KACf;IACD,OAAO,sBAAsB,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;AACtD,CAAC;AAED;IAAiD,uDAAU;IAQ1D;QAAA,YACC,iBAAO,SAGP;QAVgB,aAAO,GAA2C,KAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAAiC,CAAC,CAAC;QAChH,WAAK,GAAyC,KAAI,CAAC,OAAO,CAAC,KAAK,CAAC;QAOhF,KAAI,CAAC,YAAY,GAAG,CAAC,CAAC;QACtB,KAAI,CAAC,WAAW,GAAG,KAAK,CAAC;;IAC1B,CAAC;IAEM,uDAAiB,GAAxB;QACC,IAAI,CAAC,YAAY,EAAE,CAAC;IACrB,CAAC;IAEM,qDAAe,GAAtB;QACC,IAAI,CAAC,YAAY,EAAE,CAAC;QACpB,IAAI,IAAI,CAAC,YAAY,KAAK,CAAC,EAAE;YAC5B,IAAI,IAAI,CAAC,WAAW,EAAE;gBACrB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;gBACzB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;aACtB;SACD;IACF,CAAC;IAEM,0CAAI,GAAX;QACC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;IACzB,CAAC;IACF,kCAAC;AAAD,CAAC,AA/BD,CAAiD,sBAAU,GA+B1D;AA/BY,kEAA2B;AAiCxC,YAAY;AAEZ;IAA6C,mDAAU;IAatD;QAAA,YACC,iBAAO,SAGP;QAfD;;WAEG;QACc,kBAAY,GAA6C,KAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAAmC,CAAC,CAAC;QACzH,eAAS,GAA2C,KAAI,CAAC,YAAY,CAAC,KAAK,CAAC;QAC3E,kBAAY,GAA6C,KAAI,CAAC,SAAS,CAAC,IAAI,eAAO,EAAmC,CAAC,CAAC;QACzH,eAAS,GAA2C,KAAI,CAAC,YAAY,CAAC,KAAK,CAAC;QAO3F,KAAI,CAAC,YAAY,GAAG,CAAC,CAAC;QACtB,KAAI,CAAC,cAAc,GAAG,IAAI,CAAC;;IAC5B,CAAC;IAEM,mDAAiB,GAAxB;QACC,IAAI,CAAC,YAAY,EAAE,CAAC;IACrB,CAAC;IAEM,iDAAe,GAAtB;QACC,IAAI,CAAC,YAAY,EAAE,CAAC;QACpB,IAAI,IAAI,CAAC,YAAY,KAAK,CAAC,EAAE;YAC5B,IAAI,IAAI,CAAC,cAAc,KAAK,IAAI,EAAE;gBACjC,IAAM,CAAC,GAAG,IAAI,CAAC,cAAc,CAAC;gBAC9B,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;gBAC3B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBAC1B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;aAC1B;SACD;IACF,CAAC;IAEM,sCAAI,GAAX,UAAY,CAAkC;QAC7C,IAAI,IAAI,CAAC,YAAY,GAAG,CAAC,EAAE;YAC1B,IAAI,IAAI,CAAC,cAAc,EAAE;gBACxB,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;aACnD;iBAAM;gBACN,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;aACxB;YACD,OAAO;SACP;QACD,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAC1B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAC3B,CAAC;IACF,8BAAC;AAAD,CAAC,AA/CD,CAA6C,sBAAU,GA+CtD;AA/CY,0DAAuB","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IMarkdownString } from 'vs/base/common/htmlContent';\nimport { Disposable, IDisposable } from 'vs/base/common/lifecycle';\nimport { StopWatch } from 'vs/base/common/stopwatch';\nimport * as strings from 'vs/base/common/strings';\nimport { URI } from 'vs/base/common/uri';\nimport { EDITOR_MODEL_DEFAULTS } from 'vs/editor/common/config/editorOptions';\nimport { LineTokens } from 'vs/editor/common/core/lineTokens';\nimport { IPosition, Position } from 'vs/editor/common/core/position';\nimport { IRange, Range } from 'vs/editor/common/core/range';\nimport { Selection } from 'vs/editor/common/core/selection';\nimport * as model from 'vs/editor/common/model';\nimport { EditStack } from 'vs/editor/common/model/editStack';\nimport { guessIndentation } from 'vs/editor/common/model/indentationGuesser';\nimport { IntervalNode, IntervalTree, getNodeIsInOverviewRuler, recomputeMaxEnd } from 'vs/editor/common/model/intervalTree';\nimport { PieceTreeTextBufferBuilder } from 'vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder';\nimport { IModelContentChangedEvent, IModelDecorationsChangedEvent, IModelLanguageChangedEvent, IModelLanguageConfigurationChangedEvent, IModelOptionsChangedEvent, IModelTokensChangedEvent, InternalModelContentChangeEvent, ModelRawChange, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from 'vs/editor/common/model/textModelEvents';\nimport { SearchData, SearchParams, TextModelSearch } from 'vs/editor/common/model/textModelSearch';\nimport { ModelLinesTokens, ModelTokensChangedEventBuilder } from 'vs/editor/common/model/textModelTokens';\nimport { getWordAtText } from 'vs/editor/common/model/wordHelper';\nimport { IState, LanguageId, LanguageIdentifier, TokenizationRegistry, FormattingOptions } from 'vs/editor/common/modes';\nimport { LanguageConfigurationRegistry } from 'vs/editor/common/modes/languageConfigurationRegistry';\nimport { NULL_LANGUAGE_IDENTIFIER } from 'vs/editor/common/modes/nullMode';\nimport { ignoreBracketsInToken } from 'vs/editor/common/modes/supports';\nimport { BracketsUtils, RichEditBracket, RichEditBrackets } from 'vs/editor/common/modes/supports/richEditBrackets';\nimport { IStringStream, ITextSnapshot } from 'vs/platform/files/common/files';\nimport { ITheme, ThemeColor } from 'vs/platform/theme/common/themeService';\nimport { withUndefinedAsNull } from 'vs/base/common/types';\n\nconst CHEAP_TOKENIZATION_LENGTH_LIMIT = 2048;\n\nfunction createTextBufferBuilder() {\n\treturn new PieceTreeTextBufferBuilder();\n}\n\nexport function createTextBufferFactory(text: string): model.ITextBufferFactory {\n\tconst builder = createTextBufferBuilder();\n\tbuilder.acceptChunk(text);\n\treturn builder.finish();\n}\n\nexport function createTextBufferFactoryFromStream(stream: IStringStream, filter?: (chunk: string) => string): Promise<model.ITextBufferFactory> {\n\treturn new Promise<model.ITextBufferFactory>((c, e) => {\n\t\tlet done = false;\n\t\tlet builder = createTextBufferBuilder();\n\n\t\tstream.on('data', (chunk) => {\n\t\t\tif (filter) {\n\t\t\t\tchunk = filter(chunk);\n\t\t\t}\n\n\t\t\tbuilder.acceptChunk(chunk);\n\t\t});\n\n\t\tstream.on('error', (error) => {\n\t\t\tif (!done) {\n\t\t\t\tdone = true;\n\t\t\t\te(error);\n\t\t\t}\n\t\t});\n\n\t\tstream.on('end', () => {\n\t\t\tif (!done) {\n\t\t\t\tdone = true;\n\t\t\t\tc(builder.finish());\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport function createTextBufferFactoryFromSnapshot(snapshot: ITextSnapshot): model.ITextBufferFactory {\n\tlet builder = createTextBufferBuilder();\n\n\tlet chunk: string | null;\n\twhile (typeof (chunk = snapshot.read()) === 'string') {\n\t\tbuilder.acceptChunk(chunk);\n\t}\n\n\treturn builder.finish();\n}\n\nexport function createTextBuffer(value: string | model.ITextBufferFactory, defaultEOL: model.DefaultEndOfLine): model.ITextBuffer {\n\tconst factory = (typeof value === 'string' ? createTextBufferFactory(value) : value);\n\treturn factory.create(defaultEOL);\n}\n\nlet MODEL_ID = 0;\n\n/**\n * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.\n */\nfunction singleLetter(result: number): string {\n\tconst LETTERS_CNT = (CharCode.Z - CharCode.A + 1);\n\n\tresult = result % (2 * LETTERS_CNT);\n\n\tif (result < LETTERS_CNT) {\n\t\treturn String.fromCharCode(CharCode.a + result);\n\t}\n\n\treturn String.fromCharCode(CharCode.A + result - LETTERS_CNT);\n}\n\nconst LIMIT_FIND_COUNT = 999;\nexport const LONG_LINE_BOUNDARY = 10000;\n\nclass TextModelSnapshot implements ITextSnapshot {\n\n\tprivate readonly _source: ITextSnapshot;\n\tprivate _eos: boolean;\n\n\tconstructor(source: ITextSnapshot) {\n\t\tthis._source = source;\n\t\tthis._eos = false;\n\t}\n\n\tpublic read(): string | null {\n\t\tif (this._eos) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet result: string[] = [], resultCnt = 0, resultLength = 0;\n\n\t\tdo {\n\t\t\tlet tmp = this._source.read();\n\n\t\t\tif (tmp === null) {\n\t\t\t\t// end-of-stream\n\t\t\t\tthis._eos = true;\n\t\t\t\tif (resultCnt === 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\treturn result.join('');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tmp.length > 0) {\n\t\t\t\tresult[resultCnt++] = tmp;\n\t\t\t\tresultLength += tmp.length;\n\t\t\t}\n\n\t\t\tif (resultLength >= 64 * 1024) {\n\t\t\t\treturn result.join('');\n\t\t\t}\n\t\t} while (true);\n\t}\n}\n\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\n\nexport class TextModel extends Disposable implements model.ITextModel {\n\n\tprivate static readonly MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\n\tprivate static readonly LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\n\tprivate static readonly LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\n\n\tpublic static DEFAULT_CREATION_OPTIONS: model.ITextModelCreationOptions = {\n\t\tisForSimpleWidget: false,\n\t\ttabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n\t\tindentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n\t\tinsertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n\t\tdetectIndentation: false,\n\t\tdefaultEOL: model.DefaultEndOfLine.LF,\n\t\ttrimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n\t\tlargeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n\t};\n\n\tpublic static createFromString(text: string, options: model.ITextModelCreationOptions = TextModel.DEFAULT_CREATION_OPTIONS, languageIdentifier: LanguageIdentifier | null = null, uri: URI | null = null): TextModel {\n\t\treturn new TextModel(text, options, languageIdentifier, uri);\n\t}\n\n\tpublic static resolveOptions(textBuffer: model.ITextBuffer, options: model.ITextModelCreationOptions): model.TextModelResolvedOptions {\n\t\tif (options.detectIndentation) {\n\t\t\tconst guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n\t\t\treturn new model.TextModelResolvedOptions({\n\t\t\t\ttabSize: guessedIndentation.tabSize,\n\t\t\t\tindentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n\t\t\t\tinsertSpaces: guessedIndentation.insertSpaces,\n\t\t\t\ttrimAutoWhitespace: options.trimAutoWhitespace,\n\t\t\t\tdefaultEOL: options.defaultEOL\n\t\t\t});\n\t\t}\n\n\t\treturn new model.TextModelResolvedOptions({\n\t\t\ttabSize: options.tabSize,\n\t\t\tindentSize: options.indentSize,\n\t\t\tinsertSpaces: options.insertSpaces,\n\t\t\ttrimAutoWhitespace: options.trimAutoWhitespace,\n\t\t\tdefaultEOL: options.defaultEOL\n\t\t});\n\n\t}\n\n\t//#region Events\n\tprivate readonly _onWillDispose: Emitter<void> = this._register(new Emitter<void>());\n\tpublic readonly onWillDispose: Event<void> = this._onWillDispose.event;\n\n\tprivate readonly _onDidChangeDecorations: DidChangeDecorationsEmitter = this._register(new DidChangeDecorationsEmitter());\n\tpublic readonly onDidChangeDecorations: Event<IModelDecorationsChangedEvent> = this._onDidChangeDecorations.event;\n\n\tprivate readonly _onDidChangeLanguage: Emitter<IModelLanguageChangedEvent> = this._register(new Emitter<IModelLanguageChangedEvent>());\n\tpublic readonly onDidChangeLanguage: Event<IModelLanguageChangedEvent> = this._onDidChangeLanguage.event;\n\n\tprivate readonly _onDidChangeLanguageConfiguration: Emitter<IModelLanguageConfigurationChangedEvent> = this._register(new Emitter<IModelLanguageConfigurationChangedEvent>());\n\tpublic readonly onDidChangeLanguageConfiguration: Event<IModelLanguageConfigurationChangedEvent> = this._onDidChangeLanguageConfiguration.event;\n\n\tprivate readonly _onDidChangeTokens: Emitter<IModelTokensChangedEvent> = this._register(new Emitter<IModelTokensChangedEvent>());\n\tpublic readonly onDidChangeTokens: Event<IModelTokensChangedEvent> = this._onDidChangeTokens.event;\n\n\tprivate readonly _onDidChangeOptions: Emitter<IModelOptionsChangedEvent> = this._register(new Emitter<IModelOptionsChangedEvent>());\n\tpublic readonly onDidChangeOptions: Event<IModelOptionsChangedEvent> = this._onDidChangeOptions.event;\n\n\tprivate readonly _eventEmitter: DidChangeContentEmitter = this._register(new DidChangeContentEmitter());\n\tpublic onDidChangeRawContentFast(listener: (e: ModelRawContentChangedEvent) => void): IDisposable {\n\t\treturn this._eventEmitter.fastEvent((e: InternalModelContentChangeEvent) => listener(e.rawContentChangedEvent));\n\t}\n\tpublic onDidChangeRawContent(listener: (e: ModelRawContentChangedEvent) => void): IDisposable {\n\t\treturn this._eventEmitter.slowEvent((e: InternalModelContentChangeEvent) => listener(e.rawContentChangedEvent));\n\t}\n\tpublic onDidChangeContent(listener: (e: IModelContentChangedEvent) => void): IDisposable {\n\t\treturn this._eventEmitter.slowEvent((e: InternalModelContentChangeEvent) => listener(e.contentChangedEvent));\n\t}\n\t//#endregion\n\n\tpublic readonly id: string;\n\tpublic readonly isForSimpleWidget: boolean;\n\tprivate readonly _associatedResource: URI;\n\tprivate _attachedEditorCount: number;\n\tprivate _buffer: model.ITextBuffer;\n\tprivate _options: model.TextModelResolvedOptions;\n\n\tprivate _isDisposed: boolean;\n\tprivate _isDisposing: boolean;\n\tprivate _versionId: number;\n\t/**\n\t * Unlike, versionId, this can go down (via undo) or go to previous values (via redo)\n\t */\n\tprivate _alternativeVersionId: number;\n\tprivate readonly _isTooLargeForSyncing: boolean;\n\tprivate readonly _isTooLargeForTokenization: boolean;\n\n\t//#region Editing\n\tprivate _commandManager: EditStack;\n\tprivate _isUndoing: boolean;\n\tprivate _isRedoing: boolean;\n\tprivate _trimAutoWhitespaceLines: number[] | null;\n\t//#endregion\n\n\t//#region Decorations\n\t/**\n\t * Used to workaround broken clients that might attempt using a decoration id generated by a different model.\n\t * It is not globally unique in order to limit it to one character.\n\t */\n\tprivate readonly _instanceId: string;\n\tprivate _lastDecorationId: number;\n\tprivate _decorations: { [decorationId: string]: IntervalNode; };\n\tprivate _decorationsTree: DecorationsTrees;\n\t//#endregion\n\n\t//#region Tokenization\n\tprivate _languageIdentifier: LanguageIdentifier;\n\tprivate readonly _tokenizationListener: IDisposable;\n\tprivate readonly _languageRegistryListener: IDisposable;\n\tprivate _revalidateTokensTimeout: any;\n\t/*private*/_tokens: ModelLinesTokens;\n\t//#endregion\n\n\tconstructor(source: string | model.ITextBufferFactory, creationOptions: model.ITextModelCreationOptions, languageIdentifier: LanguageIdentifier | null, associatedResource: URI | null = null) {\n\t\tsuper();\n\n\t\t// Generate a new unique model id\n\t\tMODEL_ID++;\n\t\tthis.id = '$model' + MODEL_ID;\n\t\tthis.isForSimpleWidget = creationOptions.isForSimpleWidget;\n\t\tif (typeof associatedResource === 'undefined' || associatedResource === null) {\n\t\t\tthis._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n\t\t} else {\n\t\t\tthis._associatedResource = associatedResource;\n\t\t}\n\t\tthis._attachedEditorCount = 0;\n\n\t\tthis._buffer = createTextBuffer(source, creationOptions.defaultEOL);\n\n\t\tthis._options = TextModel.resolveOptions(this._buffer, creationOptions);\n\n\t\tconst bufferLineCount = this._buffer.getLineCount();\n\t\tconst bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), model.EndOfLinePreference.TextDefined);\n\n\t\t// !!! Make a decision in the ctor and permanently respect this decision !!!\n\t\t// If a model is too large at construction time, it will never get tokenized,\n\t\t// under no circumstances.\n\t\tif (creationOptions.largeFileOptimizations) {\n\t\t\tthis._isTooLargeForTokenization = (\n\t\t\t\t(bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD)\n\t\t\t\t|| (bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD)\n\t\t\t);\n\t\t} else {\n\t\t\tthis._isTooLargeForTokenization = false;\n\t\t}\n\n\t\tthis._isTooLargeForSyncing = (bufferTextLength > TextModel.MODEL_SYNC_LIMIT);\n\n\t\tthis._setVersionId(1);\n\t\tthis._isDisposed = false;\n\t\tthis._isDisposing = false;\n\n\t\tthis._languageIdentifier = languageIdentifier || NULL_LANGUAGE_IDENTIFIER;\n\t\tthis._tokenizationListener = TokenizationRegistry.onDidChange((e) => {\n\t\t\tif (e.changedLanguages.indexOf(this._languageIdentifier.language) === -1) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._resetTokenizationState();\n\t\t\tthis.emitModelTokensChangedEvent({\n\t\t\t\ttokenizationSupportChanged: true,\n\t\t\t\tranges: [{\n\t\t\t\t\tfromLineNumber: 1,\n\t\t\t\t\ttoLineNumber: this.getLineCount()\n\t\t\t\t}]\n\t\t\t});\n\n\t\t\tif (this._shouldAutoTokenize()) {\n\t\t\t\tthis._warmUpTokens();\n\t\t\t}\n\t\t});\n\t\tthis._revalidateTokensTimeout = -1;\n\t\tthis._languageRegistryListener = LanguageConfigurationRegistry.onDidChange((e) => {\n\t\t\tif (e.languageIdentifier.id === this._languageIdentifier.id) {\n\t\t\t\tthis._onDidChangeLanguageConfiguration.fire({});\n\t\t\t}\n\t\t});\n\t\tthis._resetTokenizationState();\n\n\t\tthis._instanceId = singleLetter(MODEL_ID);\n\t\tthis._lastDecorationId = 0;\n\t\tthis._decorations = Object.create(null);\n\t\tthis._decorationsTree = new DecorationsTrees();\n\n\t\tthis._commandManager = new EditStack(this);\n\t\tthis._isUndoing = false;\n\t\tthis._isRedoing = false;\n\t\tthis._trimAutoWhitespaceLines = null;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._isDisposing = true;\n\t\tthis._onWillDispose.fire();\n\t\tthis._tokenizationListener.dispose();\n\t\tthis._languageRegistryListener.dispose();\n\t\tthis._clearTimers();\n\t\tthis._isDisposed = true;\n\t\t// Null out members, such that any use of a disposed model will throw exceptions sooner rather than later\n\t\tsuper.dispose();\n\t\tthis._isDisposing = false;\n\t}\n\n\tprivate _assertNotDisposed(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Model is disposed!');\n\t\t}\n\t}\n\n\tpublic equalsTextBuffer(other: model.ITextBuffer): boolean {\n\t\tthis._assertNotDisposed();\n\t\treturn this._buffer.equals(other);\n\t}\n\n\tprivate _emitContentChangedEvent(rawChange: ModelRawContentChangedEvent, change: IModelContentChangedEvent): void {\n\t\tif (this._isDisposing) {\n\t\t\t// Do not confuse listeners by emitting any event after disposing\n\t\t\treturn;\n\t\t}\n\t\tthis._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n\t}\n\n\tpublic setValue(value: string): void {\n\t\tthis._assertNotDisposed();\n\t\tif (value === null) {\n\t\t\t// There's nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tconst textBuffer = createTextBuffer(value, this._options.defaultEOL);\n\t\tthis.setValueFromTextBuffer(textBuffer);\n\t}\n\n\tprivate _createContentChanged2(range: Range, rangeOffset: number, rangeLength: number, text: string, isUndoing: boolean, isRedoing: boolean, isFlush: boolean): IModelContentChangedEvent {\n\t\treturn {\n\t\t\tchanges: [{\n\t\t\t\trange: range,\n\t\t\t\trangeOffset: rangeOffset,\n\t\t\t\trangeLength: rangeLength,\n\t\t\t\ttext: text,\n\t\t\t}],\n\t\t\teol: this._buffer.getEOL(),\n\t\t\tversionId: this.getVersionId(),\n\t\t\tisUndoing: isUndoing,\n\t\t\tisRedoing: isRedoing,\n\t\t\tisFlush: isFlush\n\t\t};\n\t}\n\n\tpublic setValueFromTextBuffer(textBuffer: model.ITextBuffer): void {\n\t\tthis._assertNotDisposed();\n\t\tif (textBuffer === null) {\n\t\t\t// There's nothing to do\n\t\t\treturn;\n\t\t}\n\t\tconst oldFullModelRange = this.getFullModelRange();\n\t\tconst oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n\t\tconst endLineNumber = this.getLineCount();\n\t\tconst endColumn = this.getLineMaxColumn(endLineNumber);\n\n\t\tthis._buffer = textBuffer;\n\t\tthis._increaseVersionId();\n\n\t\t// Cancel tokenization, clear all tokens and begin tokenizing\n\t\tthis._resetTokenizationState();\n\n\t\t// Destroy all my decorations\n\t\tthis._decorations = Object.create(null);\n\t\tthis._decorationsTree = new DecorationsTrees();\n\n\t\t// Destroy my edit history and settings\n\t\tthis._commandManager = new EditStack(this);\n\t\tthis._trimAutoWhitespaceLines = null;\n\n\t\tthis._emitContentChangedEvent(\n\t\t\tnew ModelRawContentChangedEvent(\n\t\t\t\t[\n\t\t\t\t\tnew ModelRawFlush()\n\t\t\t\t],\n\t\t\t\tthis._versionId,\n\t\t\t\tfalse,\n\t\t\t\tfalse\n\t\t\t),\n\t\t\tthis._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true)\n\t\t);\n\t}\n\n\tpublic setEOL(eol: model.EndOfLineSequence): void {\n\t\tthis._assertNotDisposed();\n\t\tconst newEOL = (eol === model.EndOfLineSequence.CRLF ? '\\r\\n' : '\\n');\n\t\tif (this._buffer.getEOL() === newEOL) {\n\t\t\t// Nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldFullModelRange = this.getFullModelRange();\n\t\tconst oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n\t\tconst endLineNumber = this.getLineCount();\n\t\tconst endColumn = this.getLineMaxColumn(endLineNumber);\n\n\t\tthis._onBeforeEOLChange();\n\t\tthis._buffer.setEOL(newEOL);\n\t\tthis._increaseVersionId();\n\t\tthis._onAfterEOLChange();\n\n\t\tthis._emitContentChangedEvent(\n\t\t\tnew ModelRawContentChangedEvent(\n\t\t\t\t[\n\t\t\t\t\tnew ModelRawEOLChanged()\n\t\t\t\t],\n\t\t\t\tthis._versionId,\n\t\t\t\tfalse,\n\t\t\t\tfalse\n\t\t\t),\n\t\t\tthis._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false)\n\t\t);\n\t}\n\n\tprivate _onBeforeEOLChange(): void {\n\t\t// Ensure all decorations get their `range` set.\n\t\tconst versionId = this.getVersionId();\n\t\tconst allDecorations = this._decorationsTree.search(0, false, false, versionId);\n\t\tthis._ensureNodesHaveRanges(allDecorations);\n\t}\n\n\tprivate _onAfterEOLChange(): void {\n\t\t// Transform back `range` to offsets\n\t\tconst versionId = this.getVersionId();\n\t\tconst allDecorations = this._decorationsTree.collectNodesPostOrder();\n\t\tfor (let i = 0, len = allDecorations.length; i < len; i++) {\n\t\t\tconst node = allDecorations[i];\n\n\t\t\tconst delta = node.cachedAbsoluteStart - node.start;\n\n\t\t\tconst startOffset = this._buffer.getOffsetAt(node.range.startLineNumber, node.range.startColumn);\n\t\t\tconst endOffset = this._buffer.getOffsetAt(node.range.endLineNumber, node.range.endColumn);\n\n\t\t\tnode.cachedAbsoluteStart = startOffset;\n\t\t\tnode.cachedAbsoluteEnd = endOffset;\n\t\t\tnode.cachedVersionId = versionId;\n\n\t\t\tnode.start = startOffset - delta;\n\t\t\tnode.end = endOffset - delta;\n\n\t\t\trecomputeMaxEnd(node);\n\t\t}\n\t}\n\n\tprivate _resetTokenizationState(): void {\n\t\tthis._clearTimers();\n\t\tlet tokenizationSupport = (\n\t\t\tthis._isTooLargeForTokenization\n\t\t\t\t? null\n\t\t\t\t: TokenizationRegistry.get(this._languageIdentifier.language)\n\t\t);\n\t\tthis._tokens = new ModelLinesTokens(this._languageIdentifier, tokenizationSupport);\n\t\tthis._beginBackgroundTokenization();\n\t}\n\n\tprivate _clearTimers(): void {\n\t\tif (this._revalidateTokensTimeout !== -1) {\n\t\t\tclearTimeout(this._revalidateTokensTimeout);\n\t\t\tthis._revalidateTokensTimeout = -1;\n\t\t}\n\t}\n\n\tpublic onBeforeAttached(): void {\n\t\tthis._attachedEditorCount++;\n\t\t// Warm up tokens for the editor\n\t\tthis._warmUpTokens();\n\t}\n\n\tpublic onBeforeDetached(): void {\n\t\tthis._attachedEditorCount--;\n\t}\n\n\tprivate _shouldAutoTokenize(): boolean {\n\t\treturn this.isAttachedToEditor();\n\t}\n\n\tpublic isAttachedToEditor(): boolean {\n\t\treturn this._attachedEditorCount > 0;\n\t}\n\n\tpublic getAttachedEditorCount(): number {\n\t\treturn this._attachedEditorCount;\n\t}\n\n\tpublic isTooLargeForSyncing(): boolean {\n\t\treturn this._isTooLargeForSyncing;\n\t}\n\n\tpublic isTooLargeForTokenization(): boolean {\n\t\treturn this._isTooLargeForTokenization;\n\t}\n\n\tpublic isDisposed(): boolean {\n\t\treturn this._isDisposed;\n\t}\n\n\tpublic isDominatedByLongLines(): boolean {\n\t\tthis._assertNotDisposed();\n\t\tif (this.isTooLargeForTokenization()) {\n\t\t\t// Cannot word wrap huge files anyways, so it doesn't really matter\n\t\t\treturn false;\n\t\t}\n\t\tlet smallLineCharCount = 0;\n\t\tlet longLineCharCount = 0;\n\n\t\tconst lineCount = this._buffer.getLineCount();\n\t\tfor (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n\t\t\tconst lineLength = this._buffer.getLineLength(lineNumber);\n\t\t\tif (lineLength >= LONG_LINE_BOUNDARY) {\n\t\t\t\tlongLineCharCount += lineLength;\n\t\t\t} else {\n\t\t\t\tsmallLineCharCount += lineLength;\n\t\t\t}\n\t\t}\n\n\t\treturn (longLineCharCount > smallLineCharCount);\n\t}\n\n\tpublic get uri(): URI {\n\t\treturn this._associatedResource;\n\t}\n\n\t//#region Options\n\n\tpublic getOptions(): model.TextModelResolvedOptions {\n\t\tthis._assertNotDisposed();\n\t\treturn this._options;\n\t}\n\n\tpublic getFormattingOptions(): FormattingOptions {\n\t\treturn {\n\t\t\ttabSize: this._options.indentSize,\n\t\t\tinsertSpaces: this._options.insertSpaces\n\t\t};\n\t}\n\n\tpublic updateOptions(_newOpts: model.ITextModelUpdateOptions): void {\n\t\tthis._assertNotDisposed();\n\t\tlet tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n\t\tlet indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.indentSize;\n\t\tlet insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n\t\tlet trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n\n\t\tlet newOpts = new model.TextModelResolvedOptions({\n\t\t\ttabSize: tabSize,\n\t\t\tindentSize: indentSize,\n\t\t\tinsertSpaces: insertSpaces,\n\t\t\tdefaultEOL: this._options.defaultEOL,\n\t\t\ttrimAutoWhitespace: trimAutoWhitespace\n\t\t});\n\n\t\tif (this._options.equals(newOpts)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet e = this._options.createChangeEvent(newOpts);\n\t\tthis._options = newOpts;\n\n\t\tthis._onDidChangeOptions.fire(e);\n\t}\n\n\tpublic detectIndentation(defaultInsertSpaces: boolean, defaultTabSize: number): void {\n\t\tthis._assertNotDisposed();\n\t\tlet guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n\t\tthis.updateOptions({\n\t\t\tinsertSpaces: guessedIndentation.insertSpaces,\n\t\t\ttabSize: guessedIndentation.tabSize,\n\t\t\tindentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n\t\t});\n\t}\n\n\tprivate static _normalizeIndentationFromWhitespace(str: string, indentSize: number, insertSpaces: boolean): string {\n\t\tlet spacesCnt = 0;\n\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\tif (str.charAt(i) === '\\t') {\n\t\t\t\tspacesCnt += indentSize;\n\t\t\t} else {\n\t\t\t\tspacesCnt++;\n\t\t\t}\n\t\t}\n\n\t\tlet result = '';\n\t\tif (!insertSpaces) {\n\t\t\tlet tabsCnt = Math.floor(spacesCnt / indentSize);\n\t\t\tspacesCnt = spacesCnt % indentSize;\n\t\t\tfor (let i = 0; i < tabsCnt; i++) {\n\t\t\t\tresult += '\\t';\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < spacesCnt; i++) {\n\t\t\tresult += ' ';\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic static normalizeIndentation(str: string, indentSize: number, insertSpaces: boolean): string {\n\t\tlet firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n\t\tif (firstNonWhitespaceIndex === -1) {\n\t\t\tfirstNonWhitespaceIndex = str.length;\n\t\t}\n\t\treturn TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n\t}\n\n\tpublic normalizeIndentation(str: string): string {\n\t\tthis._assertNotDisposed();\n\t\treturn TextModel.normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n\t}\n\n\t//#endregion\n\n\t//#region Reading\n\n\tpublic getVersionId(): number {\n\t\tthis._assertNotDisposed();\n\t\treturn this._versionId;\n\t}\n\n\tpublic mightContainRTL(): boolean {\n\t\treturn this._buffer.mightContainRTL();\n\t}\n\n\tpublic mightContainNonBasicASCII(): boolean {\n\t\treturn this._buffer.mightContainNonBasicASCII();\n\t}\n\n\tpublic getAlternativeVersionId(): number {\n\t\tthis._assertNotDisposed();\n\t\treturn this._alternativeVersionId;\n\t}\n\n\tpublic getOffsetAt(rawPosition: IPosition): number {\n\t\tthis._assertNotDisposed();\n\t\tlet position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, false);\n\t\treturn this._buffer.getOffsetAt(position.lineNumber, position.column);\n\t}\n\n\tpublic getPositionAt(rawOffset: number): Position {\n\t\tthis._assertNotDisposed();\n\t\tlet offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n\t\treturn this._buffer.getPositionAt(offset);\n\t}\n\n\tprivate _increaseVersionId(): void {\n\t\tthis._setVersionId(this._versionId + 1);\n\t}\n\n\tprivate _setVersionId(newVersionId: number): void {\n\t\tthis._versionId = newVersionId;\n\t\tthis._alternativeVersionId = this._versionId;\n\t}\n\n\tprivate _overwriteAlternativeVersionId(newAlternativeVersionId: number): void {\n\t\tthis._alternativeVersionId = newAlternativeVersionId;\n\t}\n\n\tpublic getValue(eol?: model.EndOfLinePreference, preserveBOM: boolean = false): string {\n\t\tthis._assertNotDisposed();\n\t\tconst fullModelRange = this.getFullModelRange();\n\t\tconst fullModelValue = this.getValueInRange(fullModelRange, eol);\n\n\t\tif (preserveBOM) {\n\t\t\treturn this._buffer.getBOM() + fullModelValue;\n\t\t}\n\n\t\treturn fullModelValue;\n\t}\n\n\tpublic createSnapshot(preserveBOM: boolean = false): ITextSnapshot {\n\t\treturn new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n\t}\n\n\tpublic getValueLength(eol?: model.EndOfLinePreference, preserveBOM: boolean = false): number {\n\t\tthis._assertNotDisposed();\n\t\tconst fullModelRange = this.getFullModelRange();\n\t\tconst fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n\n\t\tif (preserveBOM) {\n\t\t\treturn this._buffer.getBOM().length + fullModelValue;\n\t\t}\n\n\t\treturn fullModelValue;\n\t}\n\n\tpublic getValueInRange(rawRange: IRange, eol: model.EndOfLinePreference = model.EndOfLinePreference.TextDefined): string {\n\t\tthis._assertNotDisposed();\n\t\treturn this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n\t}\n\n\tpublic getValueLengthInRange(rawRange: IRange, eol: model.EndOfLinePreference = model.EndOfLinePreference.TextDefined): number {\n\t\tthis._assertNotDisposed();\n\t\treturn this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n\t}\n\n\tpublic getLineCount(): number {\n\t\tthis._assertNotDisposed();\n\t\treturn this._buffer.getLineCount();\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\tthis._assertNotDisposed();\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\tthrow new Error('Illegal value for lineNumber');\n\t\t}\n\n\t\treturn this._buffer.getLineContent(lineNumber);\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\tthis._assertNotDisposed();\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\tthrow new Error('Illegal value for lineNumber');\n\t\t}\n\n\t\treturn this._buffer.getLineLength(lineNumber);\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\tthis._assertNotDisposed();\n\t\treturn this._buffer.getLinesContent();\n\t}\n\n\tpublic getEOL(): string {\n\t\tthis._assertNotDisposed();\n\t\treturn this._buffer.getEOL();\n\t}\n\n\tpublic getLineMinColumn(lineNumber: number): number {\n\t\tthis._assertNotDisposed();\n\t\treturn 1;\n\t}\n\n\tpublic getLineMaxColumn(lineNumber: number): number {\n\t\tthis._assertNotDisposed();\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\tthrow new Error('Illegal value for lineNumber');\n\t\t}\n\t\treturn this._buffer.getLineLength(lineNumber) + 1;\n\t}\n\n\tpublic getLineFirstNonWhitespaceColumn(lineNumber: number): number {\n\t\tthis._assertNotDisposed();\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\tthrow new Error('Illegal value for lineNumber');\n\t\t}\n\t\treturn this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n\t}\n\n\tpublic getLineLastNonWhitespaceColumn(lineNumber: number): number {\n\t\tthis._assertNotDisposed();\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\tthrow new Error('Illegal value for lineNumber');\n\t\t}\n\t\treturn this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n\t}\n\n\t/**\n\t * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n\t * Will try to not allocate if possible.\n\t */\n\tprivate _validateRangeRelaxedNoAllocations(range: IRange): Range {\n\t\tconst linesCount = this._buffer.getLineCount();\n\n\t\tconst initialStartLineNumber = range.startLineNumber;\n\t\tconst initialStartColumn = range.startColumn;\n\t\tlet startLineNumber: number;\n\t\tlet startColumn: number;\n\n\t\tif (initialStartLineNumber < 1) {\n\t\t\tstartLineNumber = 1;\n\t\t\tstartColumn = 1;\n\t\t} else if (initialStartLineNumber > linesCount) {\n\t\t\tstartLineNumber = linesCount;\n\t\t\tstartColumn = this.getLineMaxColumn(startLineNumber);\n\t\t} else {\n\t\t\tstartLineNumber = initialStartLineNumber | 0;\n\t\t\tif (initialStartColumn <= 1) {\n\t\t\t\tstartColumn = 1;\n\t\t\t} else {\n\t\t\t\tconst maxColumn = this.getLineMaxColumn(startLineNumber);\n\t\t\t\tif (initialStartColumn >= maxColumn) {\n\t\t\t\t\tstartColumn = maxColumn;\n\t\t\t\t} else {\n\t\t\t\t\tstartColumn = initialStartColumn | 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst initialEndLineNumber = range.endLineNumber;\n\t\tconst initialEndColumn = range.endColumn;\n\t\tlet endLineNumber: number;\n\t\tlet endColumn: number;\n\n\t\tif (initialEndLineNumber < 1) {\n\t\t\tendLineNumber = 1;\n\t\t\tendColumn = 1;\n\t\t} else if (initialEndLineNumber > linesCount) {\n\t\t\tendLineNumber = linesCount;\n\t\t\tendColumn = this.getLineMaxColumn(endLineNumber);\n\t\t} else {\n\t\t\tendLineNumber = initialEndLineNumber | 0;\n\t\t\tif (initialEndColumn <= 1) {\n\t\t\t\tendColumn = 1;\n\t\t\t} else {\n\t\t\t\tconst maxColumn = this.getLineMaxColumn(endLineNumber);\n\t\t\t\tif (initialEndColumn >= maxColumn) {\n\t\t\t\t\tendColumn = maxColumn;\n\t\t\t\t} else {\n\t\t\t\t\tendColumn = initialEndColumn | 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tinitialStartLineNumber === startLineNumber\n\t\t\t&& initialStartColumn === startColumn\n\t\t\t&& initialEndLineNumber === endLineNumber\n\t\t\t&& initialEndColumn === endColumn\n\t\t\t&& range instanceof Range\n\t\t\t&& !(range instanceof Selection)\n\t\t) {\n\t\t\treturn range;\n\t\t}\n\n\t\treturn new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t}\n\n\t/**\n\t * @param strict Do NOT allow a position inside a high-low surrogate pair\n\t */\n\tprivate _isValidPosition(lineNumber: number, column: number, strict: boolean): boolean {\n\t\tif (isNaN(lineNumber)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (lineNumber < 1) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst lineCount = this._buffer.getLineCount();\n\t\tif (lineNumber > lineCount) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (isNaN(column)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (column < 1) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst maxColumn = this.getLineMaxColumn(lineNumber);\n\t\tif (column > maxColumn) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (strict) {\n\t\t\tif (column > 1) {\n\t\t\t\tconst charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n\t\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param strict Do NOT allow a position inside a high-low surrogate pair\n\t */\n\tprivate _validatePosition(_lineNumber: number, _column: number, strict: boolean): Position {\n\t\tconst lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n\t\tconst column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n\t\tconst lineCount = this._buffer.getLineCount();\n\n\t\tif (lineNumber < 1) {\n\t\t\treturn new Position(1, 1);\n\t\t}\n\n\t\tif (lineNumber > lineCount) {\n\t\t\treturn new Position(lineCount, this.getLineMaxColumn(lineCount));\n\t\t}\n\n\t\tif (column <= 1) {\n\t\t\treturn new Position(lineNumber, 1);\n\t\t}\n\n\t\tconst maxColumn = this.getLineMaxColumn(lineNumber);\n\t\tif (column >= maxColumn) {\n\t\t\treturn new Position(lineNumber, maxColumn);\n\t\t}\n\n\t\tif (strict) {\n\t\t\t// If the position would end up in the middle of a high-low surrogate pair,\n\t\t\t// we move it to before the pair\n\t\t\t// !!At this point, column > 1\n\t\t\tconst charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\treturn new Position(lineNumber, column - 1);\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, column);\n\t}\n\n\tpublic validatePosition(position: IPosition): Position {\n\t\tthis._assertNotDisposed();\n\n\t\t// Avoid object allocation and cover most likely case\n\t\tif (position instanceof Position) {\n\t\t\tif (this._isValidPosition(position.lineNumber, position.column, true)) {\n\t\t\t\treturn position;\n\t\t\t}\n\t\t}\n\n\t\treturn this._validatePosition(position.lineNumber, position.column, true);\n\t}\n\n\t/**\n\t * @param strict Do NOT allow a range to have its boundaries inside a high-low surrogate pair\n\t */\n\tprivate _isValidRange(range: Range, strict: boolean): boolean {\n\t\tconst startLineNumber = range.startLineNumber;\n\t\tconst startColumn = range.startColumn;\n\t\tconst endLineNumber = range.endLineNumber;\n\t\tconst endColumn = range.endColumn;\n\n\t\tif (!this._isValidPosition(startLineNumber, startColumn, false)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this._isValidPosition(endLineNumber, endColumn, false)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (strict) {\n\t\t\tconst charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n\t\t\tconst charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n\n\t\t\tconst startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n\t\t\tconst endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n\n\t\t\tif (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic validateRange(_range: IRange): Range {\n\t\tthis._assertNotDisposed();\n\n\t\t// Avoid object allocation and cover most likely case\n\t\tif ((_range instanceof Range) && !(_range instanceof Selection)) {\n\t\t\tif (this._isValidRange(_range, true)) {\n\t\t\t\treturn _range;\n\t\t\t}\n\t\t}\n\n\t\tconst start = this._validatePosition(_range.startLineNumber, _range.startColumn, false);\n\t\tconst end = this._validatePosition(_range.endLineNumber, _range.endColumn, false);\n\n\t\tconst startLineNumber = start.lineNumber;\n\t\tconst startColumn = start.column;\n\t\tconst endLineNumber = end.lineNumber;\n\t\tconst endColumn = end.column;\n\n\t\tconst charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n\t\tconst charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n\n\t\tconst startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n\t\tconst endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n\n\t\tif (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n\t\t\treturn new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t\t}\n\n\t\tif (startLineNumber === endLineNumber && startColumn === endColumn) {\n\t\t\t// do not expand a collapsed range, simply move it to a valid location\n\t\t\treturn new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n\t\t}\n\n\t\tif (startInsideSurrogatePair && endInsideSurrogatePair) {\n\t\t\t// expand range at both ends\n\t\t\treturn new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n\t\t}\n\n\t\tif (startInsideSurrogatePair) {\n\t\t\t// only expand range at the start\n\t\t\treturn new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n\t\t}\n\n\t\t// only expand range at the end\n\t\treturn new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n\t}\n\n\tpublic modifyPosition(rawPosition: IPosition, offset: number): Position {\n\t\tthis._assertNotDisposed();\n\t\tlet candidate = this.getOffsetAt(rawPosition) + offset;\n\t\treturn this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n\t}\n\n\tpublic getFullModelRange(): Range {\n\t\tthis._assertNotDisposed();\n\t\tconst lineCount = this.getLineCount();\n\t\treturn new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n\t}\n\n\tprivate findMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): model.FindMatch[] {\n\t\treturn this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n\t}\n\n\tpublic findMatches(searchString: string, rawSearchScope: any, isRegex: boolean, matchCase: boolean, wordSeparators: string, captureMatches: boolean, limitResultCount: number = LIMIT_FIND_COUNT): model.FindMatch[] {\n\t\tthis._assertNotDisposed();\n\n\t\tlet searchRange: Range;\n\t\tif (Range.isIRange(rawSearchScope)) {\n\t\t\tsearchRange = this.validateRange(rawSearchScope);\n\t\t} else {\n\t\t\tsearchRange = this.getFullModelRange();\n\t\t}\n\n\t\tif (!isRegex && searchString.indexOf('\\n') < 0) {\n\t\t\t// not regex, not multi line\n\t\t\tconst searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n\t\t\tconst searchData = searchParams.parseSearchRequest();\n\n\t\t\tif (!searchData) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\treturn this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n\t\t}\n\n\t\treturn TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n\t}\n\n\tpublic findNextMatch(searchString: string, rawSearchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string, captureMatches: boolean): model.FindMatch | null {\n\t\tthis._assertNotDisposed();\n\t\tconst searchStart = this.validatePosition(rawSearchStart);\n\n\t\tif (!isRegex && searchString.indexOf('\\n') < 0) {\n\t\t\tconst searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n\t\t\tconst searchData = searchParams.parseSearchRequest();\n\t\t\tif (!searchData) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst lineCount = this.getLineCount();\n\t\t\tlet searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n\t\t\tlet ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n\t\t\tTextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n\t\t\tif (ret.length > 0) {\n\t\t\t\treturn ret[0];\n\t\t\t}\n\n\t\t\tsearchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n\t\t\tret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n\n\t\t\tif (ret.length > 0) {\n\t\t\t\treturn ret[0];\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n\t}\n\n\tpublic findPreviousMatch(searchString: string, rawSearchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string, captureMatches: boolean): model.FindMatch | null {\n\t\tthis._assertNotDisposed();\n\t\tconst searchStart = this.validatePosition(rawSearchStart);\n\t\treturn TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n\t}\n\n\t//#endregion\n\n\t//#region Editing\n\n\tpublic pushStackElement(): void {\n\t\tthis._commandManager.pushStackElement();\n\t}\n\n\tpublic pushEOL(eol: model.EndOfLineSequence): void {\n\t\tconst currentEOL = (this.getEOL() === '\\n' ? model.EndOfLineSequence.LF : model.EndOfLineSequence.CRLF);\n\t\tif (currentEOL === eol) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\tthis._eventEmitter.beginDeferredEmit();\n\t\t\tthis._commandManager.pushEOL(eol);\n\t\t} finally {\n\t\t\tthis._eventEmitter.endDeferredEmit();\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\tpublic pushEditOperations(beforeCursorState: Selection[], editOperations: model.IIdentifiedSingleEditOperation[], cursorStateComputer: model.ICursorStateComputer | null): Selection[] | null {\n\t\ttry {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\tthis._eventEmitter.beginDeferredEmit();\n\t\t\treturn this._pushEditOperations(beforeCursorState, editOperations, cursorStateComputer);\n\t\t} finally {\n\t\t\tthis._eventEmitter.endDeferredEmit();\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\tprivate _pushEditOperations(beforeCursorState: Selection[], editOperations: model.IIdentifiedSingleEditOperation[], cursorStateComputer: model.ICursorStateComputer | null): Selection[] | null {\n\t\tif (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n\t\t\t// Go through each saved line number and insert a trim whitespace edit\n\t\t\t// if it is safe to do so (no conflicts with other edits).\n\n\t\t\tlet incomingEdits = editOperations.map((op) => {\n\t\t\t\treturn {\n\t\t\t\t\trange: this.validateRange(op.range),\n\t\t\t\t\ttext: op.text\n\t\t\t\t};\n\t\t\t});\n\n\t\t\t// Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n\t\t\t// We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n\t\t\tlet editsAreNearCursors = true;\n\t\t\tfor (let i = 0, len = beforeCursorState.length; i < len; i++) {\n\t\t\t\tlet sel = beforeCursorState[i];\n\t\t\t\tlet foundEditNearSel = false;\n\t\t\t\tfor (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n\t\t\t\t\tlet editRange = incomingEdits[j].range;\n\t\t\t\t\tlet selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n\t\t\t\t\tlet selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n\t\t\t\t\tif (!selIsAbove && !selIsBelow) {\n\t\t\t\t\t\tfoundEditNearSel = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!foundEditNearSel) {\n\t\t\t\t\teditsAreNearCursors = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (editsAreNearCursors) {\n\t\t\t\tfor (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n\t\t\t\t\tlet trimLineNumber = this._trimAutoWhitespaceLines[i];\n\t\t\t\t\tlet maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n\n\t\t\t\t\tlet allowTrimLine = true;\n\t\t\t\t\tfor (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n\t\t\t\t\t\tlet editRange = incomingEdits[j].range;\n\t\t\t\t\t\tlet editText = incomingEdits[j].text;\n\n\t\t\t\t\t\tif (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n\t\t\t\t\t\t\t// `trimLine` is completely outside this edit\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// At this point:\n\t\t\t\t\t\t//   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttrimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n\t\t\t\t\t\t\t&& editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n'\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// This edit inserts a new line (and maybe other text) after `trimLine`\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttrimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n\t\t\t\t\t\t\t&& editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n'\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// This edit inserts a new line (and maybe other text) before `trimLine`\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Looks like we can't trim this line as it would interfere with an incoming edit\n\t\t\t\t\t\tallowTrimLine = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (allowTrimLine) {\n\t\t\t\t\t\teditOperations.push({\n\t\t\t\t\t\t\trange: new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn),\n\t\t\t\t\t\t\ttext: null\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._trimAutoWhitespaceLines = null;\n\t\t}\n\t\treturn this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\n\t}\n\n\tpublic applyEdits(rawOperations: model.IIdentifiedSingleEditOperation[]): model.IIdentifiedSingleEditOperation[] {\n\t\ttry {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\tthis._eventEmitter.beginDeferredEmit();\n\t\t\treturn this._applyEdits(rawOperations);\n\t\t} finally {\n\t\t\tthis._eventEmitter.endDeferredEmit();\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\tprivate static _eolCount(text: string): [number, number] {\n\t\tlet eolCount = 0;\n\t\tlet firstLineLength = 0;\n\t\tfor (let i = 0, len = text.length; i < len; i++) {\n\t\t\tconst chr = text.charCodeAt(i);\n\n\t\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\t\tif (eolCount === 0) {\n\t\t\t\t\tfirstLineLength = i;\n\t\t\t\t}\n\t\t\t\teolCount++;\n\t\t\t\tif (i + 1 < len && text.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t\t// \\r\\n... case\n\t\t\t\t\ti++; // skip \\n\n\t\t\t\t} else {\n\t\t\t\t\t// \\r... case\n\t\t\t\t}\n\t\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\t\tif (eolCount === 0) {\n\t\t\t\t\tfirstLineLength = i;\n\t\t\t\t}\n\t\t\t\teolCount++;\n\t\t\t}\n\t\t}\n\t\tif (eolCount === 0) {\n\t\t\tfirstLineLength = text.length;\n\t\t}\n\t\treturn [eolCount, firstLineLength];\n\t}\n\n\tprivate _applyEdits(rawOperations: model.IIdentifiedSingleEditOperation[]): model.IIdentifiedSingleEditOperation[] {\n\t\tfor (let i = 0, len = rawOperations.length; i < len; i++) {\n\t\t\trawOperations[i].range = this.validateRange(rawOperations[i].range);\n\t\t}\n\n\t\tconst oldLineCount = this._buffer.getLineCount();\n\t\tconst result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace);\n\t\tconst newLineCount = this._buffer.getLineCount();\n\n\t\tconst contentChanges = result.changes;\n\t\tthis._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n\n\t\tif (contentChanges.length !== 0) {\n\t\t\tlet rawContentChanges: ModelRawChange[] = [];\n\n\t\t\tlet lineCount = oldLineCount;\n\t\t\tfor (let i = 0, len = contentChanges.length; i < len; i++) {\n\t\t\t\tconst change = contentChanges[i];\n\t\t\t\tconst [eolCount, firstLineLength] = TextModel._eolCount(change.text);\n\t\t\t\ttry {\n\t\t\t\t\tthis._tokens.applyEdits(change.range, eolCount, firstLineLength);\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// emergency recovery => reset tokens\n\t\t\t\t\tthis._tokens = new ModelLinesTokens(this._tokens.languageIdentifier, this._tokens.tokenizationSupport);\n\t\t\t\t}\n\t\t\t\tthis._onDidChangeDecorations.fire();\n\t\t\t\tthis._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n\n\t\t\t\tconst startLineNumber = change.range.startLineNumber;\n\t\t\t\tconst endLineNumber = change.range.endLineNumber;\n\n\t\t\t\tconst deletingLinesCnt = endLineNumber - startLineNumber;\n\t\t\t\tconst insertingLinesCnt = eolCount;\n\t\t\t\tconst editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n\n\t\t\t\tconst changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n\n\t\t\t\tfor (let j = editingLinesCnt; j >= 0; j--) {\n\t\t\t\t\tconst editLineNumber = startLineNumber + j;\n\t\t\t\t\tconst currentEditLineNumber = newLineCount - lineCount - changeLineCountDelta + editLineNumber;\n\t\t\t\t\trawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber)));\n\t\t\t\t}\n\n\t\t\t\tif (editingLinesCnt < deletingLinesCnt) {\n\t\t\t\t\t// Must delete some lines\n\t\t\t\t\tconst spliceStartLineNumber = startLineNumber + editingLinesCnt;\n\t\t\t\t\trawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n\t\t\t\t}\n\n\t\t\t\tif (editingLinesCnt < insertingLinesCnt) {\n\t\t\t\t\t// Must insert some lines\n\t\t\t\t\tconst spliceLineNumber = startLineNumber + editingLinesCnt;\n\t\t\t\t\tconst cnt = insertingLinesCnt - editingLinesCnt;\n\t\t\t\t\tconst fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n\t\t\t\t\tlet newLines: string[] = [];\n\t\t\t\t\tfor (let i = 0; i < cnt; i++) {\n\t\t\t\t\t\tlet lineNumber = fromLineNumber + i;\n\t\t\t\t\t\tnewLines[lineNumber - fromLineNumber] = this.getLineContent(lineNumber);\n\t\t\t\t\t}\n\t\t\t\t\trawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines));\n\t\t\t\t}\n\n\t\t\t\tlineCount += changeLineCountDelta;\n\t\t\t}\n\n\t\t\tthis._increaseVersionId();\n\n\t\t\tthis._emitContentChangedEvent(\n\t\t\t\tnew ModelRawContentChangedEvent(\n\t\t\t\t\trawContentChanges,\n\t\t\t\t\tthis.getVersionId(),\n\t\t\t\t\tthis._isUndoing,\n\t\t\t\t\tthis._isRedoing\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tchanges: contentChanges,\n\t\t\t\t\teol: this._buffer.getEOL(),\n\t\t\t\t\tversionId: this.getVersionId(),\n\t\t\t\t\tisUndoing: this._isUndoing,\n\t\t\t\t\tisRedoing: this._isRedoing,\n\t\t\t\t\tisFlush: false\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (this._tokens.hasLinesToTokenize(this._buffer)) {\n\t\t\tthis._beginBackgroundTokenization();\n\t\t}\n\n\t\treturn result.reverseEdits;\n\t}\n\n\tprivate _undo(): Selection[] | null {\n\t\tthis._isUndoing = true;\n\t\tlet r = this._commandManager.undo();\n\t\tthis._isUndoing = false;\n\n\t\tif (!r) {\n\t\t\treturn null;\n\t\t}\n\n\t\tthis._overwriteAlternativeVersionId(r.recordedVersionId);\n\n\t\treturn r.selections;\n\t}\n\n\tpublic undo(): Selection[] | null {\n\t\ttry {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\tthis._eventEmitter.beginDeferredEmit();\n\t\t\treturn this._undo();\n\t\t} finally {\n\t\t\tthis._eventEmitter.endDeferredEmit();\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\tpublic canUndo(): boolean {\n\t\treturn this._commandManager.canUndo();\n\t}\n\n\tprivate _redo(): Selection[] | null {\n\t\tthis._isRedoing = true;\n\t\tlet r = this._commandManager.redo();\n\t\tthis._isRedoing = false;\n\n\t\tif (!r) {\n\t\t\treturn null;\n\t\t}\n\n\t\tthis._overwriteAlternativeVersionId(r.recordedVersionId);\n\n\t\treturn r.selections;\n\t}\n\n\tpublic redo(): Selection[] | null {\n\t\ttry {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\tthis._eventEmitter.beginDeferredEmit();\n\t\t\treturn this._redo();\n\t\t} finally {\n\t\t\tthis._eventEmitter.endDeferredEmit();\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\tpublic canRedo(): boolean {\n\t\treturn this._commandManager.canRedo();\n\t}\n\n\t//#endregion\n\n\t//#region Decorations\n\n\tpublic changeDecorations<T>(callback: (changeAccessor: model.IModelDecorationsChangeAccessor) => T, ownerId: number = 0): T | null {\n\t\tthis._assertNotDisposed();\n\n\t\ttry {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\treturn this._changeDecorations(ownerId, callback);\n\t\t} finally {\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\tprivate _changeDecorations<T>(ownerId: number, callback: (changeAccessor: model.IModelDecorationsChangeAccessor) => T): T | null {\n\t\tlet changeAccessor: model.IModelDecorationsChangeAccessor = {\n\t\t\taddDecoration: (range: IRange, options: model.IModelDecorationOptions): string => {\n\t\t\t\tthis._onDidChangeDecorations.fire();\n\t\t\t\treturn this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n\t\t\t},\n\t\t\tchangeDecoration: (id: string, newRange: IRange): void => {\n\t\t\t\tthis._onDidChangeDecorations.fire();\n\t\t\t\tthis._changeDecorationImpl(id, newRange);\n\t\t\t},\n\t\t\tchangeDecorationOptions: (id: string, options: model.IModelDecorationOptions) => {\n\t\t\t\tthis._onDidChangeDecorations.fire();\n\t\t\t\tthis._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n\t\t\t},\n\t\t\tremoveDecoration: (id: string): void => {\n\t\t\t\tthis._onDidChangeDecorations.fire();\n\t\t\t\tthis._deltaDecorationsImpl(ownerId, [id], []);\n\t\t\t},\n\t\t\tdeltaDecorations: (oldDecorations: string[], newDecorations: model.IModelDeltaDecoration[]): string[] => {\n\t\t\t\tif (oldDecorations.length === 0 && newDecorations.length === 0) {\n\t\t\t\t\t// nothing to do\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t\tthis._onDidChangeDecorations.fire();\n\t\t\t\treturn this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n\t\t\t}\n\t\t};\n\t\tlet result: T | null = null;\n\t\ttry {\n\t\t\tresult = callback(changeAccessor);\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t}\n\t\t// Invalidate change accessor\n\t\tchangeAccessor.addDecoration = invalidFunc;\n\t\tchangeAccessor.changeDecoration = invalidFunc;\n\t\tchangeAccessor.changeDecorationOptions = invalidFunc;\n\t\tchangeAccessor.removeDecoration = invalidFunc;\n\t\tchangeAccessor.deltaDecorations = invalidFunc;\n\t\treturn result;\n\t}\n\n\tpublic deltaDecorations(oldDecorations: string[], newDecorations: model.IModelDeltaDecoration[], ownerId: number = 0): string[] {\n\t\tthis._assertNotDisposed();\n\t\tif (!oldDecorations) {\n\t\t\toldDecorations = [];\n\t\t}\n\t\tif (oldDecorations.length === 0 && newDecorations.length === 0) {\n\t\t\t// nothing to do\n\t\t\treturn [];\n\t\t}\n\n\t\ttry {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\tthis._onDidChangeDecorations.fire();\n\t\t\treturn this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n\t\t} finally {\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\t_getTrackedRange(id: string): Range | null {\n\t\treturn this.getDecorationRange(id);\n\t}\n\n\t_setTrackedRange(id: string | null, newRange: null, newStickiness: model.TrackedRangeStickiness): null;\n\t_setTrackedRange(id: string | null, newRange: Range, newStickiness: model.TrackedRangeStickiness): string;\n\t_setTrackedRange(id: string | null, newRange: Range | null, newStickiness: model.TrackedRangeStickiness): string | null {\n\t\tconst node = (id ? this._decorations[id] : null);\n\n\t\tif (!node) {\n\t\t\tif (!newRange) {\n\t\t\t\t// node doesn't exist, the request is to delete => nothing to do\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// node doesn't exist, the request is to set => add the tracked range\n\t\t\treturn this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }])[0];\n\t\t}\n\n\t\tif (!newRange) {\n\t\t\t// node exists, the request is to delete => delete node\n\t\t\tthis._decorationsTree.delete(node);\n\t\t\tdelete this._decorations[node.id];\n\t\t\treturn null;\n\t\t}\n\n\t\t// node exists, the request is to set => change the tracked range and its options\n\t\tconst range = this._validateRangeRelaxedNoAllocations(newRange);\n\t\tconst startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\tconst endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\t\tthis._decorationsTree.delete(node);\n\t\tnode.reset(this.getVersionId(), startOffset, endOffset, range);\n\t\tnode.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n\t\tthis._decorationsTree.insert(node);\n\t\treturn node.id;\n\t}\n\n\tpublic removeAllDecorationsWithOwnerId(ownerId: number): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tconst nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n\t\tfor (let i = 0, len = nodes.length; i < len; i++) {\n\t\t\tconst node = nodes[i];\n\n\t\t\tthis._decorationsTree.delete(node);\n\t\t\tdelete this._decorations[node.id];\n\t\t}\n\t}\n\n\tpublic getDecorationOptions(decorationId: string): model.IModelDecorationOptions | null {\n\t\tconst node = this._decorations[decorationId];\n\t\tif (!node) {\n\t\t\treturn null;\n\t\t}\n\t\treturn node.options;\n\t}\n\n\tpublic getDecorationRange(decorationId: string): Range | null {\n\t\tconst node = this._decorations[decorationId];\n\t\tif (!node) {\n\t\t\treturn null;\n\t\t}\n\t\tconst versionId = this.getVersionId();\n\t\tif (node.cachedVersionId !== versionId) {\n\t\t\tthis._decorationsTree.resolveNode(node, versionId);\n\t\t}\n\t\tif (node.range === null) {\n\t\t\tnode.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n\t\t}\n\t\treturn node.range;\n\t}\n\n\tpublic getLineDecorations(lineNumber: number, ownerId: number = 0, filterOutValidation: boolean = false): model.IModelDecoration[] {\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n\t}\n\n\tpublic getLinesDecorations(_startLineNumber: number, _endLineNumber: number, ownerId: number = 0, filterOutValidation: boolean = false): model.IModelDecoration[] {\n\t\tlet lineCount = this.getLineCount();\n\t\tlet startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n\t\tlet endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n\t\tlet endColumn = this.getLineMaxColumn(endLineNumber);\n\t\treturn this._getDecorationsInRange(new Range(startLineNumber, 1, endLineNumber, endColumn), ownerId, filterOutValidation);\n\t}\n\n\tpublic getDecorationsInRange(range: IRange, ownerId: number = 0, filterOutValidation: boolean = false): model.IModelDecoration[] {\n\t\tlet validatedRange = this.validateRange(range);\n\t\treturn this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\n\t}\n\n\tpublic getOverviewRulerDecorations(ownerId: number = 0, filterOutValidation: boolean = false): model.IModelDecoration[] {\n\t\tconst versionId = this.getVersionId();\n\t\tconst result = this._decorationsTree.search(ownerId, filterOutValidation, true, versionId);\n\t\treturn this._ensureNodesHaveRanges(result);\n\t}\n\n\tpublic getAllDecorations(ownerId: number = 0, filterOutValidation: boolean = false): model.IModelDecoration[] {\n\t\tconst versionId = this.getVersionId();\n\t\tconst result = this._decorationsTree.search(ownerId, filterOutValidation, false, versionId);\n\t\treturn this._ensureNodesHaveRanges(result);\n\t}\n\n\tprivate _getDecorationsInRange(filterRange: Range, filterOwnerId: number, filterOutValidation: boolean): IntervalNode[] {\n\t\tconst startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n\t\tconst endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n\n\t\tconst versionId = this.getVersionId();\n\t\tconst result = this._decorationsTree.intervalSearch(startOffset, endOffset, filterOwnerId, filterOutValidation, versionId);\n\n\t\treturn this._ensureNodesHaveRanges(result);\n\t}\n\n\tprivate _ensureNodesHaveRanges(nodes: IntervalNode[]): IntervalNode[] {\n\t\tfor (let i = 0, len = nodes.length; i < len; i++) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (node.range === null) {\n\t\t\t\tnode.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n\t\t\t}\n\t\t}\n\t\treturn nodes;\n\t}\n\n\tprivate _getRangeAt(start: number, end: number): Range {\n\t\treturn this._buffer.getRangeAt(start, end - start);\n\t}\n\n\tprivate _changeDecorationImpl(decorationId: string, _range: IRange): void {\n\t\tconst node = this._decorations[decorationId];\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\t\tconst range = this._validateRangeRelaxedNoAllocations(_range);\n\t\tconst startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\tconst endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n\t\tthis._decorationsTree.delete(node);\n\t\tnode.reset(this.getVersionId(), startOffset, endOffset, range);\n\t\tthis._decorationsTree.insert(node);\n\t}\n\n\tprivate _changeDecorationOptionsImpl(decorationId: string, options: ModelDecorationOptions): void {\n\t\tconst node = this._decorations[decorationId];\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n\t\tconst nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n\n\t\tif (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n\t\t\t// Delete + Insert due to an overview ruler status change\n\t\t\tthis._decorationsTree.delete(node);\n\t\t\tnode.setOptions(options);\n\t\t\tthis._decorationsTree.insert(node);\n\t\t} else {\n\t\t\tnode.setOptions(options);\n\t\t}\n\t}\n\n\tprivate _deltaDecorationsImpl(ownerId: number, oldDecorationsIds: string[], newDecorations: model.IModelDeltaDecoration[]): string[] {\n\t\tconst versionId = this.getVersionId();\n\n\t\tconst oldDecorationsLen = oldDecorationsIds.length;\n\t\tlet oldDecorationIndex = 0;\n\n\t\tconst newDecorationsLen = newDecorations.length;\n\t\tlet newDecorationIndex = 0;\n\n\t\tlet result = new Array<string>(newDecorationsLen);\n\t\twhile (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n\n\t\t\tlet node: IntervalNode | null = null;\n\n\t\t\tif (oldDecorationIndex < oldDecorationsLen) {\n\t\t\t\t// (1) get ourselves an old node\n\t\t\t\tdo {\n\t\t\t\t\tnode = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n\t\t\t\t} while (!node && oldDecorationIndex < oldDecorationsLen);\n\n\t\t\t\t// (2) remove the node from the tree (if it exists)\n\t\t\t\tif (node) {\n\t\t\t\t\tthis._decorationsTree.delete(node);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newDecorationIndex < newDecorationsLen) {\n\t\t\t\t// (3) create a new node if necessary\n\t\t\t\tif (!node) {\n\t\t\t\t\tconst internalDecorationId = (++this._lastDecorationId);\n\t\t\t\t\tconst decorationId = `${this._instanceId};${internalDecorationId}`;\n\t\t\t\t\tnode = new IntervalNode(decorationId, 0, 0);\n\t\t\t\t\tthis._decorations[decorationId] = node;\n\t\t\t\t}\n\n\t\t\t\t// (4) initialize node\n\t\t\t\tconst newDecoration = newDecorations[newDecorationIndex];\n\t\t\t\tconst range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n\t\t\t\tconst options = _normalizeOptions(newDecoration.options);\n\t\t\t\tconst startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\t\t\tconst endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n\t\t\t\tnode.ownerId = ownerId;\n\t\t\t\tnode.reset(versionId, startOffset, endOffset, range);\n\t\t\t\tnode.setOptions(options);\n\n\t\t\t\tthis._decorationsTree.insert(node);\n\n\t\t\t\tresult[newDecorationIndex] = node.id;\n\n\t\t\t\tnewDecorationIndex++;\n\t\t\t} else {\n\t\t\t\tif (node) {\n\t\t\t\t\tdelete this._decorations[node.id];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t//#endregion\n\n\t//#region Tokenization\n\n\tpublic tokenizeViewport(startLineNumber: number, endLineNumber: number): void {\n\t\tif (!this._tokens.tokenizationSupport) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tstartLineNumber = Math.max(1, startLineNumber);\n\t\tendLineNumber = Math.min(this.getLineCount(), endLineNumber);\n\n\t\tif (endLineNumber <= this._tokens.inValidLineStartIndex) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (startLineNumber <= this._tokens.inValidLineStartIndex) {\n\t\t\t// tokenization has reached the viewport start...\n\t\t\tthis.forceTokenization(endLineNumber);\n\t\t\treturn;\n\t\t}\n\n\t\tlet nonWhitespaceColumn = this.getLineFirstNonWhitespaceColumn(startLineNumber);\n\t\tlet fakeLines: string[] = [];\n\t\tlet initialState: IState | null = null;\n\t\tfor (let i = startLineNumber - 1; nonWhitespaceColumn > 0 && i >= 1; i--) {\n\t\t\tlet newNonWhitespaceIndex = this.getLineFirstNonWhitespaceColumn(i);\n\n\t\t\tif (newNonWhitespaceIndex === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (newNonWhitespaceIndex < nonWhitespaceColumn) {\n\t\t\t\tinitialState = this._tokens._getState(i - 1);\n\t\t\t\tif (initialState) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfakeLines.push(this.getLineContent(i));\n\t\t\t\tnonWhitespaceColumn = newNonWhitespaceIndex;\n\t\t\t}\n\t\t}\n\n\t\tif (!initialState) {\n\t\t\tinitialState = this._tokens.tokenizationSupport.getInitialState();\n\t\t}\n\n\t\tlet state = initialState.clone();\n\t\tfor (let i = fakeLines.length - 1; i >= 0; i--) {\n\t\t\tlet r = this._tokens._tokenizeText(this._buffer, fakeLines[i], state);\n\t\t\tif (r) {\n\t\t\t\tstate = r.endState.clone();\n\t\t\t} else {\n\t\t\t\tstate = initialState.clone();\n\t\t\t}\n\t\t}\n\n\t\tconst eventBuilder = new ModelTokensChangedEventBuilder();\n\t\tfor (let i = startLineNumber; i <= endLineNumber; i++) {\n\t\t\tlet text = this.getLineContent(i);\n\t\t\tlet r = this._tokens._tokenizeText(this._buffer, text, state);\n\t\t\tif (r) {\n\t\t\t\tthis._tokens._setTokens(this._tokens.languageIdentifier.id, i - 1, text.length, r.tokens);\n\n\t\t\t\t// We cannot trust these states/tokens to be valid!\n\t\t\t\t// (see https://github.com/Microsoft/vscode/issues/67607)\n\t\t\t\tthis._tokens._setIsInvalid(i - 1, true);\n\t\t\t\tthis._tokens._setState(i - 1, state);\n\t\t\t\tstate = r.endState.clone();\n\t\t\t\teventBuilder.registerChangedTokens(i);\n\t\t\t} else {\n\t\t\t\tstate = initialState.clone();\n\t\t\t}\n\t\t}\n\n\t\tconst e = eventBuilder.build();\n\t\tif (e) {\n\t\t\tthis._onDidChangeTokens.fire(e);\n\t\t}\n\t}\n\n\tpublic flushTokens(): void {\n\t\tthis._resetTokenizationState();\n\t\tthis.emitModelTokensChangedEvent({\n\t\t\ttokenizationSupportChanged: false,\n\t\t\tranges: [{\n\t\t\t\tfromLineNumber: 1,\n\t\t\t\ttoLineNumber: this.getLineCount()\n\t\t\t}]\n\t\t});\n\t}\n\n\tpublic forceTokenization(lineNumber: number): void {\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\tthrow new Error('Illegal value for lineNumber');\n\t\t}\n\n\t\tconst eventBuilder = new ModelTokensChangedEventBuilder();\n\n\t\tthis._tokens._updateTokensUntilLine(this._buffer, eventBuilder, lineNumber);\n\n\t\tconst e = eventBuilder.build();\n\t\tif (e) {\n\t\t\tthis._onDidChangeTokens.fire(e);\n\t\t}\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tif (!this._tokens.isCheapToTokenize(lineNumber)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (lineNumber < this._tokens.inValidLineStartIndex + 1) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this.getLineLength(lineNumber) < CHEAP_TOKENIZATION_LENGTH_LIMIT) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic tokenizeIfCheap(lineNumber: number): void {\n\t\tif (this.isCheapToTokenize(lineNumber)) {\n\t\t\tthis.forceTokenization(lineNumber);\n\t\t}\n\t}\n\n\tpublic getLineTokens(lineNumber: number): LineTokens {\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\tthrow new Error('Illegal value for lineNumber');\n\t\t}\n\n\t\treturn this._getLineTokens(lineNumber);\n\t}\n\n\tprivate _getLineTokens(lineNumber: number): LineTokens {\n\t\tconst lineText = this._buffer.getLineContent(lineNumber);\n\t\treturn this._tokens.getTokens(this._languageIdentifier.id, lineNumber - 1, lineText);\n\t}\n\n\tpublic getLanguageIdentifier(): LanguageIdentifier {\n\t\treturn this._languageIdentifier;\n\t}\n\n\tpublic getModeId(): string {\n\t\treturn this._languageIdentifier.language;\n\t}\n\n\tpublic setMode(languageIdentifier: LanguageIdentifier): void {\n\t\tif (this._languageIdentifier.id === languageIdentifier.id) {\n\t\t\t// There's nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tlet e: IModelLanguageChangedEvent = {\n\t\t\toldLanguage: this._languageIdentifier.language,\n\t\t\tnewLanguage: languageIdentifier.language\n\t\t};\n\n\t\tthis._languageIdentifier = languageIdentifier;\n\n\t\t// Cancel tokenization, clear all tokens and begin tokenizing\n\t\tthis._resetTokenizationState();\n\n\t\tthis.emitModelTokensChangedEvent({\n\t\t\ttokenizationSupportChanged: true,\n\t\t\tranges: [{\n\t\t\t\tfromLineNumber: 1,\n\t\t\t\ttoLineNumber: this.getLineCount()\n\t\t\t}]\n\t\t});\n\t\tthis._onDidChangeLanguage.fire(e);\n\t\tthis._onDidChangeLanguageConfiguration.fire({});\n\t}\n\n\tpublic getLanguageIdAtPosition(_lineNumber: number, _column: number): LanguageId {\n\t\tif (!this._tokens.tokenizationSupport) {\n\t\t\treturn this._languageIdentifier.id;\n\t\t}\n\t\tlet { lineNumber, column } = this.validatePosition({ lineNumber: _lineNumber, column: _column });\n\n\t\tlet lineTokens = this._getLineTokens(lineNumber);\n\t\treturn lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(column - 1));\n\t}\n\n\tprivate _beginBackgroundTokenization(): void {\n\t\tif (this._shouldAutoTokenize() && this._revalidateTokensTimeout === -1) {\n\t\t\tthis._revalidateTokensTimeout = setTimeout(() => {\n\t\t\t\tthis._revalidateTokensTimeout = -1;\n\t\t\t\tthis._revalidateTokensNow();\n\t\t\t}, 0);\n\t\t}\n\t}\n\n\t_warmUpTokens(): void {\n\t\t// Warm up first 100 lines (if it takes less than 50ms)\n\t\tconst maxLineNumber = Math.min(100, this.getLineCount());\n\t\tthis._revalidateTokensNow(maxLineNumber);\n\n\t\tif (this._tokens.hasLinesToTokenize(this._buffer)) {\n\t\t\tthis._beginBackgroundTokenization();\n\t\t}\n\t}\n\n\tprivate _revalidateTokensNow(toLineNumber: number = this._buffer.getLineCount()): void {\n\t\tconst MAX_ALLOWED_TIME = 20;\n\t\tconst eventBuilder = new ModelTokensChangedEventBuilder();\n\t\tconst sw = StopWatch.create(false);\n\n\t\twhile (this._tokens.hasLinesToTokenize(this._buffer)) {\n\t\t\tif (sw.elapsed() > MAX_ALLOWED_TIME) {\n\t\t\t\t// Stop if MAX_ALLOWED_TIME is reached\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst tokenizedLineNumber = this._tokens._tokenizeOneLine(this._buffer, eventBuilder);\n\n\t\t\tif (tokenizedLineNumber >= toLineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (this._tokens.hasLinesToTokenize(this._buffer)) {\n\t\t\tthis._beginBackgroundTokenization();\n\t\t}\n\n\t\tconst e = eventBuilder.build();\n\t\tif (e) {\n\t\t\tthis._onDidChangeTokens.fire(e);\n\t\t}\n\t}\n\n\tprivate emitModelTokensChangedEvent(e: IModelTokensChangedEvent): void {\n\t\tif (!this._isDisposing) {\n\t\t\tthis._onDidChangeTokens.fire(e);\n\t\t}\n\t}\n\n\t// Having tokens allows implementing additional helper methods\n\n\tpublic getWordAtPosition(_position: IPosition): model.IWordAtPosition | null {\n\t\tthis._assertNotDisposed();\n\t\tconst position = this.validatePosition(_position);\n\t\tconst lineContent = this.getLineContent(position.lineNumber);\n\t\tconst lineTokens = this._getLineTokens(position.lineNumber);\n\t\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\n\t\t// (1). First try checking right biased word\n\t\tconst [rbStartOffset, rbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex);\n\t\tconst rightBiasedWord = getWordAtText(\n\t\t\tposition.column,\n\t\t\tLanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex)),\n\t\t\tlineContent.substring(rbStartOffset, rbEndOffset),\n\t\t\trbStartOffset\n\t\t);\n\t\t// Make sure the result touches the original passed in position\n\t\tif (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\n\t\t\treturn rightBiasedWord;\n\t\t}\n\n\t\t// (2). Else, if we were at a language boundary, check the left biased word\n\t\tif (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n\t\t\t// edge case, where `position` sits between two tokens belonging to two different languages\n\t\t\tconst [lbStartOffset, lbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n\t\t\tconst leftBiasedWord = getWordAtText(\n\t\t\t\tposition.column,\n\t\t\t\tLanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex - 1)),\n\t\t\t\tlineContent.substring(lbStartOffset, lbEndOffset),\n\t\t\t\tlbStartOffset\n\t\t\t);\n\t\t\t// Make sure the result touches the original passed in position\n\t\t\tif (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\n\t\t\t\treturn leftBiasedWord;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findLanguageBoundaries(lineTokens: LineTokens, tokenIndex: number): [number, number] {\n\t\tconst languageId = lineTokens.getLanguageId(tokenIndex);\n\n\t\t// go left until a different language is hit\n\t\tlet startOffset = 0;\n\t\tfor (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n\t\t\tstartOffset = lineTokens.getStartOffset(i);\n\t\t}\n\n\t\t// go right until a different language is hit\n\t\tlet endOffset = lineTokens.getLineContent().length;\n\t\tfor (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n\t\t\tendOffset = lineTokens.getEndOffset(i);\n\t\t}\n\n\t\treturn [startOffset, endOffset];\n\t}\n\n\tpublic getWordUntilPosition(position: IPosition): model.IWordAtPosition {\n\t\tconst wordAtPosition = this.getWordAtPosition(position);\n\t\tif (!wordAtPosition) {\n\t\t\treturn {\n\t\t\t\tword: '',\n\t\t\t\tstartColumn: position.column,\n\t\t\t\tendColumn: position.column\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tword: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n\t\t\tstartColumn: wordAtPosition.startColumn,\n\t\t\tendColumn: position.column\n\t\t};\n\t}\n\n\tpublic findMatchingBracketUp(_bracket: string, _position: IPosition): Range | null {\n\t\tlet bracket = _bracket.toLowerCase();\n\t\tlet position = this.validatePosition(_position);\n\n\t\tlet lineTokens = this._getLineTokens(position.lineNumber);\n\t\tlet languageId = lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n\t\tlet bracketsSupport = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n\n\t\tif (!bracketsSupport) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet data = bracketsSupport.textIsBracket[bracket];\n\n\t\tif (!data) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this._findMatchingBracketUp(data, position);\n\t}\n\n\tpublic matchBracket(position: IPosition): [Range, Range] | null {\n\t\treturn this._matchBracket(this.validatePosition(position));\n\t}\n\n\tprivate _matchBracket(position: Position): [Range, Range] | null {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst lineTokens = this._getLineTokens(lineNumber);\n\t\tconst lineText = this._buffer.getLineContent(lineNumber);\n\n\t\tlet tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\tif (tokenIndex < 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst currentModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex));\n\n\t\t// check that the token is not to be ignored\n\t\tif (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n\t\t\t// limit search to not go before `maxBracketLength`\n\t\t\tlet searchStartOffset = Math.max(lineTokens.getStartOffset(tokenIndex), position.column - 1 - currentModeBrackets.maxBracketLength);\n\t\t\t// limit search to not go after `maxBracketLength`\n\t\t\tconst searchEndOffset = Math.min(lineTokens.getEndOffset(tokenIndex), position.column - 1 + currentModeBrackets.maxBracketLength);\n\n\t\t\t// it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n\t\t\t// `bestResult` will contain the most right-side result\n\t\t\tlet bestResult: [Range, Range] | null = null;\n\t\t\twhile (true) {\n\t\t\t\tlet foundBracket = BracketsUtils.findNextBracketInToken(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (!foundBracket) {\n\t\t\t\t\t// there are no more brackets in this text\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// check that we didn't hit a bracket too far away from position\n\t\t\t\tif (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n\t\t\t\t\tlet foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);\n\t\t\t\t\tfoundBracketText = foundBracketText.toLowerCase();\n\n\t\t\t\t\tlet r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText]);\n\n\t\t\t\t\t// check that we can actually match this bracket\n\t\t\t\t\tif (r) {\n\t\t\t\t\t\tbestResult = r;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsearchStartOffset = foundBracket.endColumn - 1;\n\t\t\t}\n\n\t\t\tif (bestResult) {\n\t\t\t\treturn bestResult;\n\t\t\t}\n\t\t}\n\n\t\t// If position is in between two tokens, try also looking in the previous token\n\t\tif (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n\t\t\tconst searchEndOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\ttokenIndex--;\n\t\t\tconst prevModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex));\n\n\t\t\t// check that previous token is not to be ignored\n\t\t\tif (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n\t\t\t\t// limit search in case previous token is very large, there's no need to go beyond `maxBracketLength`\n\t\t\t\tconst searchStartOffset = Math.max(lineTokens.getStartOffset(tokenIndex), position.column - 1 - prevModeBrackets.maxBracketLength);\n\t\t\t\tconst foundBracket = BracketsUtils.findPrevBracketInToken(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n\t\t\t\t// check that we didn't hit a bracket too far away from position\n\t\t\t\tif (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n\t\t\t\t\tlet foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);\n\t\t\t\t\tfoundBracketText = foundBracketText.toLowerCase();\n\n\t\t\t\t\tlet r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText]);\n\n\t\t\t\t\t// check that we can actually match this bracket\n\t\t\t\t\tif (r) {\n\t\t\t\t\t\treturn r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate _matchFoundBracket(foundBracket: Range, data: RichEditBracket, isOpen: boolean): [Range, Range] | null {\n\t\tif (!data) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (isOpen) {\n\t\t\tlet matched = this._findMatchingBracketDown(data, foundBracket.getEndPosition());\n\t\t\tif (matched) {\n\t\t\t\treturn [foundBracket, matched];\n\t\t\t}\n\t\t} else {\n\t\t\tlet matched = this._findMatchingBracketUp(data, foundBracket.getStartPosition());\n\t\t\tif (matched) {\n\t\t\t\treturn [foundBracket, matched];\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate _findMatchingBracketUp(bracket: RichEditBracket, position: Position): Range | null {\n\t\t// console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n\n\t\tconst languageId = bracket.languageIdentifier.id;\n\t\tconst reversedBracketRegex = bracket.reversedRegex;\n\t\tlet count = -1;\n\n\t\tfor (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n\t\t\tconst lineTokens = this._getLineTokens(lineNumber);\n\t\t\tconst tokenCount = lineTokens.getCount();\n\t\t\tconst lineText = this._buffer.getLineContent(lineNumber);\n\n\t\t\tlet tokenIndex = tokenCount - 1;\n\t\t\tlet searchStopOffset = -1;\n\t\t\tif (lineNumber === position.lineNumber) {\n\t\t\t\ttokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\t\t\tsearchStopOffset = position.column - 1;\n\t\t\t}\n\n\t\t\tfor (; tokenIndex >= 0; tokenIndex--) {\n\t\t\t\tconst tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\t\t\t\tconst tokenType = lineTokens.getStandardTokenType(tokenIndex);\n\t\t\t\tconst tokenStartOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\t\tconst tokenEndOffset = lineTokens.getEndOffset(tokenIndex);\n\n\t\t\t\tif (searchStopOffset === -1) {\n\t\t\t\t\tsearchStopOffset = tokenEndOffset;\n\t\t\t\t}\n\n\t\t\t\tif (tokenLanguageId === languageId && !ignoreBracketsInToken(tokenType)) {\n\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tlet r = BracketsUtils.findPrevBracketInToken(reversedBracketRegex, lineNumber, lineText, tokenStartOffset, searchStopOffset);\n\t\t\t\t\t\tif (!r) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);\n\t\t\t\t\t\thitText = hitText.toLowerCase();\n\n\t\t\t\t\t\tif (hitText === bracket.open) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t} else if (hitText === bracket.close) {\n\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (count === 0) {\n\t\t\t\t\t\t\treturn r;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsearchStopOffset = r.startColumn - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsearchStopOffset = -1;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate _findMatchingBracketDown(bracket: RichEditBracket, position: Position): Range | null {\n\t\t// console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n\n\t\tconst languageId = bracket.languageIdentifier.id;\n\t\tconst bracketRegex = bracket.forwardRegex;\n\t\tlet count = 1;\n\n\t\tfor (let lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n\t\t\tconst lineTokens = this._getLineTokens(lineNumber);\n\t\t\tconst tokenCount = lineTokens.getCount();\n\t\t\tconst lineText = this._buffer.getLineContent(lineNumber);\n\n\t\t\tlet tokenIndex = 0;\n\t\t\tlet searchStartOffset = 0;\n\t\t\tif (lineNumber === position.lineNumber) {\n\t\t\t\ttokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\t\t\tsearchStartOffset = position.column - 1;\n\t\t\t}\n\n\t\t\tfor (; tokenIndex < tokenCount; tokenIndex++) {\n\t\t\t\tconst tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\t\t\t\tconst tokenType = lineTokens.getStandardTokenType(tokenIndex);\n\t\t\t\tconst tokenStartOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\t\tconst tokenEndOffset = lineTokens.getEndOffset(tokenIndex);\n\n\t\t\t\tif (searchStartOffset === 0) {\n\t\t\t\t\tsearchStartOffset = tokenStartOffset;\n\t\t\t\t}\n\n\t\t\t\tif (tokenLanguageId === languageId && !ignoreBracketsInToken(tokenType)) {\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tlet r = BracketsUtils.findNextBracketInToken(bracketRegex, lineNumber, lineText, searchStartOffset, tokenEndOffset);\n\t\t\t\t\t\tif (!r) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);\n\t\t\t\t\t\thitText = hitText.toLowerCase();\n\n\t\t\t\t\t\tif (hitText === bracket.open) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t} else if (hitText === bracket.close) {\n\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (count === 0) {\n\t\t\t\t\t\t\treturn r;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsearchStartOffset = r.endColumn - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsearchStartOffset = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic findPrevBracket(_position: IPosition): model.IFoundBracket | null {\n\t\tconst position = this.validatePosition(_position);\n\n\t\tlet languageId: LanguageId = -1;\n\t\tlet modeBrackets: RichEditBrackets | null = null;\n\t\tfor (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n\t\t\tconst lineTokens = this._getLineTokens(lineNumber);\n\t\t\tconst tokenCount = lineTokens.getCount();\n\t\t\tconst lineText = this._buffer.getLineContent(lineNumber);\n\n\t\t\tlet tokenIndex = tokenCount - 1;\n\t\t\tlet searchStopOffset = -1;\n\t\t\tif (lineNumber === position.lineNumber) {\n\t\t\t\ttokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\t\t\tsearchStopOffset = position.column - 1;\n\t\t\t}\n\n\t\t\tfor (; tokenIndex >= 0; tokenIndex--) {\n\t\t\t\tconst tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\t\t\t\tconst tokenType = lineTokens.getStandardTokenType(tokenIndex);\n\t\t\t\tconst tokenStartOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\t\tconst tokenEndOffset = lineTokens.getEndOffset(tokenIndex);\n\n\t\t\t\tif (searchStopOffset === -1) {\n\t\t\t\t\tsearchStopOffset = tokenEndOffset;\n\t\t\t\t}\n\t\t\t\tif (languageId !== tokenLanguageId) {\n\t\t\t\t\tlanguageId = tokenLanguageId;\n\t\t\t\t\tmodeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n\t\t\t\t}\n\t\t\t\tif (modeBrackets && !ignoreBracketsInToken(tokenType)) {\n\t\t\t\t\tlet r = BracketsUtils.findPrevBracketInToken(modeBrackets.reversedRegex, lineNumber, lineText, tokenStartOffset, searchStopOffset);\n\t\t\t\t\tif (r) {\n\t\t\t\t\t\treturn this._toFoundBracket(modeBrackets, r);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsearchStopOffset = -1;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic findNextBracket(_position: IPosition): model.IFoundBracket | null {\n\t\tconst position = this.validatePosition(_position);\n\n\t\tlet languageId: LanguageId = -1;\n\t\tlet modeBrackets: RichEditBrackets | null = null;\n\t\tfor (let lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n\t\t\tconst lineTokens = this._getLineTokens(lineNumber);\n\t\t\tconst tokenCount = lineTokens.getCount();\n\t\t\tconst lineText = this._buffer.getLineContent(lineNumber);\n\n\t\t\tlet tokenIndex = 0;\n\t\t\tlet searchStartOffset = 0;\n\t\t\tif (lineNumber === position.lineNumber) {\n\t\t\t\ttokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\t\t\tsearchStartOffset = position.column - 1;\n\t\t\t}\n\n\t\t\tfor (; tokenIndex < tokenCount; tokenIndex++) {\n\t\t\t\tconst tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\t\t\t\tconst tokenType = lineTokens.getStandardTokenType(tokenIndex);\n\t\t\t\tconst tokenStartOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\t\tconst tokenEndOffset = lineTokens.getEndOffset(tokenIndex);\n\n\t\t\t\tif (searchStartOffset === 0) {\n\t\t\t\t\tsearchStartOffset = tokenStartOffset;\n\t\t\t\t}\n\n\t\t\t\tif (languageId !== tokenLanguageId) {\n\t\t\t\t\tlanguageId = tokenLanguageId;\n\t\t\t\t\tmodeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n\t\t\t\t}\n\t\t\t\tif (modeBrackets && !ignoreBracketsInToken(tokenType)) {\n\t\t\t\t\tlet r = BracketsUtils.findNextBracketInToken(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, tokenEndOffset);\n\t\t\t\t\tif (r) {\n\t\t\t\t\t\treturn this._toFoundBracket(modeBrackets, r);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsearchStartOffset = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate _toFoundBracket(modeBrackets: RichEditBrackets, r: Range): model.IFoundBracket | null {\n\t\tif (!r) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet text = this.getValueInRange(r);\n\t\ttext = text.toLowerCase();\n\n\t\tlet data = modeBrackets.textIsBracket[text];\n\t\tif (!data) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\trange: r,\n\t\t\topen: data.open,\n\t\t\tclose: data.close,\n\t\t\tisOpen: modeBrackets.textIsOpenBracket[text]\n\t\t};\n\t}\n\n\t/**\n\t * Returns:\n\t *  - -1 => the line consists of whitespace\n\t *  - otherwise => the indent level is returned value\n\t */\n\tpublic static computeIndentLevel(line: string, tabSize: number): number {\n\t\tlet indent = 0;\n\t\tlet i = 0;\n\t\tlet len = line.length;\n\n\t\twhile (i < len) {\n\t\t\tlet chCode = line.charCodeAt(i);\n\t\t\tif (chCode === CharCode.Space) {\n\t\t\t\tindent++;\n\t\t\t} else if (chCode === CharCode.Tab) {\n\t\t\t\tindent = indent - indent % tabSize + tabSize;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tif (i === len) {\n\t\t\treturn -1; // line only consists of whitespace\n\t\t}\n\n\t\treturn indent;\n\t}\n\n\tprivate _computeIndentLevel(lineIndex: number): number {\n\t\treturn TextModel.computeIndentLevel(this._buffer.getLineContent(lineIndex + 1), this._options.tabSize);\n\t}\n\n\tpublic getActiveIndentGuide(lineNumber: number, minLineNumber: number, maxLineNumber: number): model.IActiveIndentGuideInfo {\n\t\tthis._assertNotDisposed();\n\t\tconst lineCount = this.getLineCount();\n\n\t\tif (lineNumber < 1 || lineNumber > lineCount) {\n\t\t\tthrow new Error('Illegal value for lineNumber');\n\t\t}\n\n\t\tconst foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\n\t\tconst offSide = Boolean(foldingRules && foldingRules.offSide);\n\n\t\tlet up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n\t\tlet up_aboveContentLineIndent = -1;\n\t\tlet up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n\t\tlet up_belowContentLineIndent = -1;\n\t\tconst up_resolveIndents = (lineNumber: number) => {\n\t\t\tif (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber - 1)) {\n\t\t\t\tup_aboveContentLineIndex = -1;\n\t\t\t\tup_aboveContentLineIndent = -1;\n\n\t\t\t\t// must find previous line with content\n\t\t\t\tfor (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n\t\t\t\t\tlet indent = this._computeIndentLevel(lineIndex);\n\t\t\t\t\tif (indent >= 0) {\n\t\t\t\t\t\tup_aboveContentLineIndex = lineIndex;\n\t\t\t\t\t\tup_aboveContentLineIndent = indent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (up_belowContentLineIndex === -2) {\n\t\t\t\tup_belowContentLineIndex = -1;\n\t\t\t\tup_belowContentLineIndent = -1;\n\n\t\t\t\t// must find next line with content\n\t\t\t\tfor (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n\t\t\t\t\tlet indent = this._computeIndentLevel(lineIndex);\n\t\t\t\t\tif (indent >= 0) {\n\t\t\t\t\t\tup_belowContentLineIndex = lineIndex;\n\t\t\t\t\t\tup_belowContentLineIndent = indent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n\t\tlet down_aboveContentLineIndent = -1;\n\t\tlet down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n\t\tlet down_belowContentLineIndent = -1;\n\t\tconst down_resolveIndents = (lineNumber: number) => {\n\t\t\tif (down_aboveContentLineIndex === -2) {\n\t\t\t\tdown_aboveContentLineIndex = -1;\n\t\t\t\tdown_aboveContentLineIndent = -1;\n\n\t\t\t\t// must find previous line with content\n\t\t\t\tfor (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n\t\t\t\t\tlet indent = this._computeIndentLevel(lineIndex);\n\t\t\t\t\tif (indent >= 0) {\n\t\t\t\t\t\tdown_aboveContentLineIndex = lineIndex;\n\t\t\t\t\t\tdown_aboveContentLineIndent = indent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber - 1)) {\n\t\t\t\tdown_belowContentLineIndex = -1;\n\t\t\t\tdown_belowContentLineIndent = -1;\n\n\t\t\t\t// must find next line with content\n\t\t\t\tfor (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n\t\t\t\t\tlet indent = this._computeIndentLevel(lineIndex);\n\t\t\t\t\tif (indent >= 0) {\n\t\t\t\t\t\tdown_belowContentLineIndex = lineIndex;\n\t\t\t\t\t\tdown_belowContentLineIndent = indent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet startLineNumber = 0;\n\t\tlet goUp = true;\n\t\tlet endLineNumber = 0;\n\t\tlet goDown = true;\n\t\tlet indent = 0;\n\n\t\tfor (let distance = 0; goUp || goDown; distance++) {\n\t\t\tconst upLineNumber = lineNumber - distance;\n\t\t\tconst downLineNumber = lineNumber + distance;\n\n\t\t\tif (distance !== 0 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n\t\t\t\tgoUp = false;\n\t\t\t}\n\t\t\tif (distance !== 0 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n\t\t\t\tgoDown = false;\n\t\t\t}\n\t\t\tif (distance > 50000) {\n\t\t\t\t// stop processing\n\t\t\t\tgoUp = false;\n\t\t\t\tgoDown = false;\n\t\t\t}\n\n\t\t\tif (goUp) {\n\t\t\t\t// compute indent level going up\n\t\t\t\tlet upLineIndentLevel: number;\n\n\t\t\t\tconst currentIndent = this._computeIndentLevel(upLineNumber - 1);\n\t\t\t\tif (currentIndent >= 0) {\n\t\t\t\t\t// This line has content (besides whitespace)\n\t\t\t\t\t// Use the line's indent\n\t\t\t\t\tup_belowContentLineIndex = upLineNumber - 1;\n\t\t\t\t\tup_belowContentLineIndent = currentIndent;\n\t\t\t\t\tupLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\n\t\t\t\t} else {\n\t\t\t\t\tup_resolveIndents(upLineNumber);\n\t\t\t\t\tupLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n\t\t\t\t}\n\n\t\t\t\tif (distance === 0) {\n\t\t\t\t\t// This is the initial line number\n\t\t\t\t\tstartLineNumber = upLineNumber;\n\t\t\t\t\tendLineNumber = downLineNumber;\n\t\t\t\t\tindent = upLineIndentLevel;\n\t\t\t\t\tif (indent === 0) {\n\t\t\t\t\t\t// No need to continue\n\t\t\t\t\t\treturn { startLineNumber, endLineNumber, indent };\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (upLineIndentLevel >= indent) {\n\t\t\t\t\tstartLineNumber = upLineNumber;\n\t\t\t\t} else {\n\t\t\t\t\tgoUp = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (goDown) {\n\t\t\t\t// compute indent level going down\n\t\t\t\tlet downLineIndentLevel: number;\n\n\t\t\t\tconst currentIndent = this._computeIndentLevel(downLineNumber - 1);\n\t\t\t\tif (currentIndent >= 0) {\n\t\t\t\t\t// This line has content (besides whitespace)\n\t\t\t\t\t// Use the line's indent\n\t\t\t\t\tdown_aboveContentLineIndex = downLineNumber - 1;\n\t\t\t\t\tdown_aboveContentLineIndent = currentIndent;\n\t\t\t\t\tdownLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\n\t\t\t\t} else {\n\t\t\t\t\tdown_resolveIndents(downLineNumber);\n\t\t\t\t\tdownLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n\t\t\t\t}\n\n\t\t\t\tif (downLineIndentLevel >= indent) {\n\t\t\t\t\tendLineNumber = downLineNumber;\n\t\t\t\t} else {\n\t\t\t\t\tgoDown = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { startLineNumber, endLineNumber, indent };\n\t}\n\n\tpublic getLinesIndentGuides(startLineNumber: number, endLineNumber: number): number[] {\n\t\tthis._assertNotDisposed();\n\t\tconst lineCount = this.getLineCount();\n\n\t\tif (startLineNumber < 1 || startLineNumber > lineCount) {\n\t\t\tthrow new Error('Illegal value for startLineNumber');\n\t\t}\n\t\tif (endLineNumber < 1 || endLineNumber > lineCount) {\n\t\t\tthrow new Error('Illegal value for endLineNumber');\n\t\t}\n\n\t\tconst foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\n\t\tconst offSide = Boolean(foldingRules && foldingRules.offSide);\n\n\t\tlet result: number[] = new Array<number>(endLineNumber - startLineNumber + 1);\n\n\t\tlet aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n\t\tlet aboveContentLineIndent = -1;\n\n\t\tlet belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n\t\tlet belowContentLineIndent = -1;\n\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tlet resultIndex = lineNumber - startLineNumber;\n\n\t\t\tconst currentIndent = this._computeIndentLevel(lineNumber - 1);\n\t\t\tif (currentIndent >= 0) {\n\t\t\t\t// This line has content (besides whitespace)\n\t\t\t\t// Use the line's indent\n\t\t\t\taboveContentLineIndex = lineNumber - 1;\n\t\t\t\taboveContentLineIndent = currentIndent;\n\t\t\t\tresult[resultIndex] = Math.ceil(currentIndent / this._options.indentSize);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (aboveContentLineIndex === -2) {\n\t\t\t\taboveContentLineIndex = -1;\n\t\t\t\taboveContentLineIndent = -1;\n\n\t\t\t\t// must find previous line with content\n\t\t\t\tfor (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n\t\t\t\t\tlet indent = this._computeIndentLevel(lineIndex);\n\t\t\t\t\tif (indent >= 0) {\n\t\t\t\t\t\taboveContentLineIndex = lineIndex;\n\t\t\t\t\t\taboveContentLineIndent = indent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n\t\t\t\tbelowContentLineIndex = -1;\n\t\t\t\tbelowContentLineIndent = -1;\n\n\t\t\t\t// must find next line with content\n\t\t\t\tfor (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n\t\t\t\t\tlet indent = this._computeIndentLevel(lineIndex);\n\t\t\t\t\tif (indent >= 0) {\n\t\t\t\t\t\tbelowContentLineIndex = lineIndex;\n\t\t\t\t\t\tbelowContentLineIndent = indent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _getIndentLevelForWhitespaceLine(offSide: boolean, aboveContentLineIndent: number, belowContentLineIndent: number): number {\n\t\tif (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n\t\t\t// At the top or bottom of the file\n\t\t\treturn 0;\n\n\t\t} else if (aboveContentLineIndent < belowContentLineIndent) {\n\t\t\t// we are inside the region above\n\t\t\treturn (1 + Math.floor(aboveContentLineIndent / this._options.indentSize));\n\n\t\t} else if (aboveContentLineIndent === belowContentLineIndent) {\n\t\t\t// we are in between two regions\n\t\t\treturn Math.ceil(belowContentLineIndent / this._options.indentSize);\n\n\t\t} else {\n\n\t\t\tif (offSide) {\n\t\t\t\t// same level as region below\n\t\t\t\treturn Math.ceil(belowContentLineIndent / this._options.indentSize);\n\t\t\t} else {\n\t\t\t\t// we are inside the region that ends below\n\t\t\t\treturn (1 + Math.floor(belowContentLineIndent / this._options.indentSize));\n\t\t\t}\n\n\t\t}\n\t}\n\n\t//#endregion\n}\n\n//#region Decorations\n\nclass DecorationsTrees {\n\n\t/**\n\t * This tree holds decorations that do not show up in the overview ruler.\n\t */\n\tprivate readonly _decorationsTree0: IntervalTree;\n\n\t/**\n\t * This tree holds decorations that show up in the overview ruler.\n\t */\n\tprivate readonly _decorationsTree1: IntervalTree;\n\n\tconstructor() {\n\t\tthis._decorationsTree0 = new IntervalTree();\n\t\tthis._decorationsTree1 = new IntervalTree();\n\t}\n\n\tpublic intervalSearch(start: number, end: number, filterOwnerId: number, filterOutValidation: boolean, cachedVersionId: number): IntervalNode[] {\n\t\tconst r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n\t\tconst r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n\t\treturn r0.concat(r1);\n\t}\n\n\tpublic search(filterOwnerId: number, filterOutValidation: boolean, overviewRulerOnly: boolean, cachedVersionId: number): IntervalNode[] {\n\t\tif (overviewRulerOnly) {\n\t\t\treturn this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n\t\t} else {\n\t\t\tconst r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\n\t\t\tconst r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n\t\t\treturn r0.concat(r1);\n\t\t}\n\t}\n\n\tpublic collectNodesFromOwner(ownerId: number): IntervalNode[] {\n\t\tconst r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n\t\tconst r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n\t\treturn r0.concat(r1);\n\t}\n\n\tpublic collectNodesPostOrder(): IntervalNode[] {\n\t\tconst r0 = this._decorationsTree0.collectNodesPostOrder();\n\t\tconst r1 = this._decorationsTree1.collectNodesPostOrder();\n\t\treturn r0.concat(r1);\n\t}\n\n\tpublic insert(node: IntervalNode): void {\n\t\tif (getNodeIsInOverviewRuler(node)) {\n\t\t\tthis._decorationsTree1.insert(node);\n\t\t} else {\n\t\t\tthis._decorationsTree0.insert(node);\n\t\t}\n\t}\n\n\tpublic delete(node: IntervalNode): void {\n\t\tif (getNodeIsInOverviewRuler(node)) {\n\t\t\tthis._decorationsTree1.delete(node);\n\t\t} else {\n\t\t\tthis._decorationsTree0.delete(node);\n\t\t}\n\t}\n\n\tpublic resolveNode(node: IntervalNode, cachedVersionId: number): void {\n\t\tif (getNodeIsInOverviewRuler(node)) {\n\t\t\tthis._decorationsTree1.resolveNode(node, cachedVersionId);\n\t\t} else {\n\t\t\tthis._decorationsTree0.resolveNode(node, cachedVersionId);\n\t\t}\n\t}\n\n\tpublic acceptReplace(offset: number, length: number, textLength: number, forceMoveMarkers: boolean): void {\n\t\tthis._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n\t\tthis._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n\t}\n}\n\nfunction cleanClassName(className: string): string {\n\treturn className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\n\nexport class ModelDecorationOverviewRulerOptions implements model.IModelDecorationOverviewRulerOptions {\n\treadonly color: string | ThemeColor;\n\treadonly darkColor: string | ThemeColor;\n\treadonly position: model.OverviewRulerLane;\n\tprivate _resolvedColor: string | null;\n\n\tconstructor(options: model.IModelDecorationOverviewRulerOptions) {\n\t\tthis.color = options.color || strings.empty;\n\t\tthis.darkColor = options.darkColor || strings.empty;\n\t\tthis.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n\t\tthis._resolvedColor = null;\n\t}\n\n\tpublic getColor(theme: ITheme): string {\n\t\tif (!this._resolvedColor) {\n\t\t\tif (theme.type !== 'light' && this.darkColor) {\n\t\t\t\tthis._resolvedColor = this._resolveColor(this.darkColor, theme);\n\t\t\t} else {\n\t\t\t\tthis._resolvedColor = this._resolveColor(this.color, theme);\n\t\t\t}\n\t\t}\n\t\treturn this._resolvedColor;\n\t}\n\n\tpublic invalidateCachedColor(): void {\n\t\tthis._resolvedColor = null;\n\t}\n\n\tprivate _resolveColor(color: string | ThemeColor, theme: ITheme): string {\n\t\tif (typeof color === 'string') {\n\t\t\treturn color;\n\t\t}\n\t\tlet c = color ? theme.getColor(color.id) : null;\n\t\tif (!c) {\n\t\t\treturn strings.empty;\n\t\t}\n\t\treturn c.toString();\n\t}\n}\n\nexport class ModelDecorationOptions implements model.IModelDecorationOptions {\n\n\tpublic static EMPTY: ModelDecorationOptions;\n\n\tpublic static register(options: model.IModelDecorationOptions): ModelDecorationOptions {\n\t\treturn new ModelDecorationOptions(options);\n\t}\n\n\tpublic static createDynamic(options: model.IModelDecorationOptions): ModelDecorationOptions {\n\t\treturn new ModelDecorationOptions(options);\n\t}\n\n\treadonly stickiness: model.TrackedRangeStickiness;\n\treadonly zIndex: number;\n\treadonly className: string | null;\n\treadonly hoverMessage: IMarkdownString | IMarkdownString[] | null;\n\treadonly glyphMarginHoverMessage: IMarkdownString | IMarkdownString[] | null;\n\treadonly isWholeLine: boolean;\n\treadonly showIfCollapsed: boolean;\n\treadonly collapseOnReplaceEdit: boolean;\n\treadonly overviewRuler: ModelDecorationOverviewRulerOptions | null;\n\treadonly glyphMarginClassName: string | null;\n\treadonly linesDecorationsClassName: string | null;\n\treadonly marginClassName: string | null;\n\treadonly inlineClassName: string | null;\n\treadonly inlineClassNameAffectsLetterSpacing: boolean;\n\treadonly beforeContentClassName: string | null;\n\treadonly afterContentClassName: string | null;\n\n\tprivate constructor(options: model.IModelDecorationOptions) {\n\t\tthis.stickiness = options.stickiness || model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges;\n\t\tthis.zIndex = options.zIndex || 0;\n\t\tthis.className = options.className ? cleanClassName(options.className) : null;\n\t\tthis.hoverMessage = withUndefinedAsNull(options.hoverMessage);\n\t\tthis.glyphMarginHoverMessage = withUndefinedAsNull(options.glyphMarginHoverMessage);\n\t\tthis.isWholeLine = options.isWholeLine || false;\n\t\tthis.showIfCollapsed = options.showIfCollapsed || false;\n\t\tthis.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n\t\tthis.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n\t\tthis.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n\t\tthis.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n\t\tthis.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n\t\tthis.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n\t\tthis.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n\t\tthis.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n\t\tthis.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n\t}\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({});\n\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n\tModelDecorationOptions.register({ stickiness: model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges }),\n\tModelDecorationOptions.register({ stickiness: model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges }),\n\tModelDecorationOptions.register({ stickiness: model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore }),\n\tModelDecorationOptions.register({ stickiness: model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter }),\n];\n\nfunction _normalizeOptions(options: model.IModelDecorationOptions): ModelDecorationOptions {\n\tif (options instanceof ModelDecorationOptions) {\n\t\treturn options;\n\t}\n\treturn ModelDecorationOptions.createDynamic(options);\n}\n\nexport class DidChangeDecorationsEmitter extends Disposable {\n\n\tprivate readonly _actual: Emitter<IModelDecorationsChangedEvent> = this._register(new Emitter<IModelDecorationsChangedEvent>());\n\tpublic readonly event: Event<IModelDecorationsChangedEvent> = this._actual.event;\n\n\tprivate _deferredCnt: number;\n\tprivate _shouldFire: boolean;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._deferredCnt = 0;\n\t\tthis._shouldFire = false;\n\t}\n\n\tpublic beginDeferredEmit(): void {\n\t\tthis._deferredCnt++;\n\t}\n\n\tpublic endDeferredEmit(): void {\n\t\tthis._deferredCnt--;\n\t\tif (this._deferredCnt === 0) {\n\t\t\tif (this._shouldFire) {\n\t\t\t\tthis._shouldFire = false;\n\t\t\t\tthis._actual.fire({});\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic fire(): void {\n\t\tthis._shouldFire = true;\n\t}\n}\n\n//#endregion\n\nexport class DidChangeContentEmitter extends Disposable {\n\n\t/**\n\t * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n\t */\n\tprivate readonly _fastEmitter: Emitter<InternalModelContentChangeEvent> = this._register(new Emitter<InternalModelContentChangeEvent>());\n\tpublic readonly fastEvent: Event<InternalModelContentChangeEvent> = this._fastEmitter.event;\n\tprivate readonly _slowEmitter: Emitter<InternalModelContentChangeEvent> = this._register(new Emitter<InternalModelContentChangeEvent>());\n\tpublic readonly slowEvent: Event<InternalModelContentChangeEvent> = this._slowEmitter.event;\n\n\tprivate _deferredCnt: number;\n\tprivate _deferredEvent: InternalModelContentChangeEvent | null;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._deferredCnt = 0;\n\t\tthis._deferredEvent = null;\n\t}\n\n\tpublic beginDeferredEmit(): void {\n\t\tthis._deferredCnt++;\n\t}\n\n\tpublic endDeferredEmit(): void {\n\t\tthis._deferredCnt--;\n\t\tif (this._deferredCnt === 0) {\n\t\t\tif (this._deferredEvent !== null) {\n\t\t\t\tconst e = this._deferredEvent;\n\t\t\t\tthis._deferredEvent = null;\n\t\t\t\tthis._fastEmitter.fire(e);\n\t\t\t\tthis._slowEmitter.fire(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic fire(e: InternalModelContentChangeEvent): void {\n\t\tif (this._deferredCnt > 0) {\n\t\t\tif (this._deferredEvent) {\n\t\t\t\tthis._deferredEvent = this._deferredEvent.merge(e);\n\t\t\t} else {\n\t\t\t\tthis._deferredEvent = e;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis._fastEmitter.fire(e);\n\t\tthis._slowEmitter.fire(e);\n\t}\n}\n"]}]}