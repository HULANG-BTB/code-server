{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/suggest/completionModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/suggest/completionModel.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/filters\", \"vs/base/common/lifecycle\", \"vs/editor/common/modes\", \"vs/editor/common/config/editorOptions\", \"vs/base/common/charCode\"], function (require, exports, filters_1, lifecycle_1, modes_1, editorOptions_1, charCode_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class LineContext {\n    }\n    exports.LineContext = LineContext;\n    var Refilter;\n    (function (Refilter) {\n        Refilter[Refilter[\"Nothing\"] = 0] = \"Nothing\";\n        Refilter[Refilter[\"All\"] = 1] = \"All\";\n        Refilter[Refilter[\"Incr\"] = 2] = \"Incr\";\n    })(Refilter || (Refilter = {}));\n    class CompletionModel {\n        constructor(items, column, lineContext, wordDistance, options = editorOptions_1.EDITOR_DEFAULTS.contribInfo.suggest) {\n            this._snippetCompareFn = CompletionModel._compareCompletionItems;\n            this._items = items;\n            this._column = column;\n            this._wordDistance = wordDistance;\n            this._options = options;\n            this._refilterKind = Refilter.All;\n            this._lineContext = lineContext;\n            if (options.snippets === 'top') {\n                this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsUp;\n            }\n            else if (options.snippets === 'bottom') {\n                this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsDown;\n            }\n        }\n        dispose() {\n            const seen = new Set();\n            for (const { container } of this._items) {\n                if (!seen.has(container)) {\n                    seen.add(container);\n                    if (lifecycle_1.isDisposable(container)) {\n                        container.dispose();\n                    }\n                }\n            }\n        }\n        get lineContext() {\n            return this._lineContext;\n        }\n        set lineContext(value) {\n            if (this._lineContext.leadingLineContent !== value.leadingLineContent\n                || this._lineContext.characterCountDelta !== value.characterCountDelta) {\n                this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? Refilter.Incr : Refilter.All;\n                this._lineContext = value;\n            }\n        }\n        get items() {\n            this._ensureCachedState();\n            return this._filteredItems;\n        }\n        get incomplete() {\n            this._ensureCachedState();\n            return this._isIncomplete;\n        }\n        adopt(except) {\n            let res = new Array();\n            for (let i = 0; i < this._items.length;) {\n                if (!except.has(this._items[i].provider)) {\n                    res.push(this._items[i]);\n                    // unordered removed\n                    this._items[i] = this._items[this._items.length - 1];\n                    this._items.pop();\n                }\n                else {\n                    // continue with next item\n                    i++;\n                }\n            }\n            this._refilterKind = Refilter.All;\n            return res;\n        }\n        get stats() {\n            this._ensureCachedState();\n            return this._stats;\n        }\n        _ensureCachedState() {\n            if (this._refilterKind !== Refilter.Nothing) {\n                this._createCachedState();\n            }\n        }\n        _createCachedState() {\n            this._isIncomplete = new Set();\n            this._stats = { suggestionCount: 0, snippetCount: 0, textCount: 0 };\n            const { leadingLineContent, characterCountDelta } = this._lineContext;\n            let word = '';\n            let wordLow = '';\n            // incrementally filter less\n            const source = this._refilterKind === Refilter.All ? this._items : this._filteredItems;\n            const target = [];\n            // picks a score function based on the number of\n            // items that we have to score/filter and based on the\n            // user-configuration\n            const scoreFn = (!this._options.filterGraceful || source.length > 2000) ? filters_1.fuzzyScore : filters_1.fuzzyScoreGracefulAggressive;\n            for (let i = 0; i < source.length; i++) {\n                const item = source[i];\n                // collect those supports that signaled having\n                // an incomplete result\n                if (item.container.incomplete) {\n                    this._isIncomplete.add(item.provider);\n                }\n                // 'word' is that remainder of the current line that we\n                // filter and score against. In theory each suggestion uses a\n                // different word, but in practice not - that's why we cache\n                const overwriteBefore = item.position.column - item.completion.range.startColumn;\n                const wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);\n                if (word.length !== wordLen) {\n                    word = wordLen === 0 ? '' : leadingLineContent.slice(-wordLen);\n                    wordLow = word.toLowerCase();\n                }\n                // remember the word against which this item was\n                // scored\n                item.word = word;\n                if (wordLen === 0) {\n                    // when there is nothing to score against, don't\n                    // event try to do. Use a const rank and rely on\n                    // the fallback-sort using the initial sort order.\n                    // use a score of `-100` because that is out of the\n                    // bound of values `fuzzyScore` will return\n                    item.score = filters_1.FuzzyScore.Default;\n                }\n                else {\n                    // skip word characters that are whitespace until\n                    // we have hit the replace range (overwriteBefore)\n                    let wordPos = 0;\n                    while (wordPos < overwriteBefore) {\n                        const ch = word.charCodeAt(wordPos);\n                        if (ch === charCode_1.CharCode.Space || ch === charCode_1.CharCode.Tab) {\n                            wordPos += 1;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    if (wordPos >= wordLen) {\n                        // the wordPos at which scoring starts is the whole word\n                        // and therefore the same rules as not having a word apply\n                        item.score = filters_1.FuzzyScore.Default;\n                    }\n                    else if (typeof item.completion.filterText === 'string') {\n                        // when there is a `filterText` it must match the `word`.\n                        // if it matches we check with the label to compute highlights\n                        // and if that doesn't yield a result we have no highlights,\n                        // despite having the match\n                        let match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow, 0, false);\n                        if (!match) {\n                            continue; // NO match\n                        }\n                        item.score = filters_1.anyScore(word, wordLow, 0, item.completion.label, item.labelLow, 0);\n                        item.score[0] = match[0]; // use score from filterText\n                    }\n                    else {\n                        // by default match `word` against the `label`\n                        let match = scoreFn(word, wordLow, wordPos, item.completion.label, item.labelLow, 0, false);\n                        if (!match) {\n                            continue; // NO match\n                        }\n                        item.score = match;\n                    }\n                }\n                item.idx = i;\n                item.distance = this._wordDistance.distance(item.position, item.completion);\n                target.push(item);\n                // update stats\n                this._stats.suggestionCount++;\n                switch (item.completion.kind) {\n                    case modes_1.CompletionItemKind.Snippet:\n                        this._stats.snippetCount++;\n                        break;\n                    case modes_1.CompletionItemKind.Text:\n                        this._stats.textCount++;\n                        break;\n                }\n            }\n            this._filteredItems = target.sort(this._snippetCompareFn);\n            this._refilterKind = Refilter.Nothing;\n        }\n        static _compareCompletionItems(a, b) {\n            if (a.score[0] > b.score[0]) {\n                return -1;\n            }\n            else if (a.score[0] < b.score[0]) {\n                return 1;\n            }\n            else if (a.distance < b.distance) {\n                return -1;\n            }\n            else if (a.distance > b.distance) {\n                return 1;\n            }\n            else if (a.idx < b.idx) {\n                return -1;\n            }\n            else if (a.idx > b.idx) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        }\n        static _compareCompletionItemsSnippetsDown(a, b) {\n            if (a.completion.kind !== b.completion.kind) {\n                if (a.completion.kind === modes_1.CompletionItemKind.Snippet) {\n                    return 1;\n                }\n                else if (b.completion.kind === modes_1.CompletionItemKind.Snippet) {\n                    return -1;\n                }\n            }\n            return CompletionModel._compareCompletionItems(a, b);\n        }\n        static _compareCompletionItemsSnippetsUp(a, b) {\n            if (a.completion.kind !== b.completion.kind) {\n                if (a.completion.kind === modes_1.CompletionItemKind.Snippet) {\n                    return -1;\n                }\n                else if (b.completion.kind === modes_1.CompletionItemKind.Snippet) {\n                    return 1;\n                }\n            }\n            return CompletionModel._compareCompletionItems(a, b);\n        }\n    }\n    exports.CompletionModel = CompletionModel;\n});\n",null]}