{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/node/debugAdapter.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/node/debugAdapter.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar pfs_1 = require(\"vs/base/node/pfs\");\nvar cp = require(\"child_process\");\nvar nls = require(\"vs/nls\");\nvar net = require(\"net\");\nvar path = require(\"vs/base/common/path\");\nvar strings = require(\"vs/base/common/strings\");\nvar objects = require(\"vs/base/common/objects\");\nvar platform = require(\"vs/base/common/platform\");\nvar extensionManagement_1 = require(\"vs/platform/extensionManagement/common/extensionManagement\");\nvar abstractDebugAdapter_1 = require(\"../common/abstractDebugAdapter\");\n/**\n * An implementation that communicates via two streams with the debug adapter.\n */\nvar StreamDebugAdapter = /** @class */ (function (_super) {\n    tslib_1.__extends(StreamDebugAdapter, _super);\n    function StreamDebugAdapter() {\n        return _super.call(this) || this;\n    }\n    StreamDebugAdapter.prototype.connect = function (readable, writable) {\n        var _this = this;\n        this.outputStream = writable;\n        this.rawData = Buffer.allocUnsafe(0);\n        this.contentLength = -1;\n        readable.on('data', function (data) { return _this.handleData(data); });\n    };\n    StreamDebugAdapter.prototype.sendMessage = function (message) {\n        if (this.outputStream) {\n            var json = JSON.stringify(message);\n            this.outputStream.write(\"Content-Length: \" + Buffer.byteLength(json, 'utf8') + StreamDebugAdapter.TWO_CRLF + json, 'utf8');\n        }\n    };\n    StreamDebugAdapter.prototype.handleData = function (data) {\n        this.rawData = Buffer.concat([this.rawData, data]);\n        while (true) {\n            if (this.contentLength >= 0) {\n                if (this.rawData.length >= this.contentLength) {\n                    var message = this.rawData.toString('utf8', 0, this.contentLength);\n                    this.rawData = this.rawData.slice(this.contentLength);\n                    this.contentLength = -1;\n                    if (message.length > 0) {\n                        try {\n                            this.acceptMessage(JSON.parse(message));\n                        }\n                        catch (e) {\n                            this._onError.fire(new Error((e.message || e) + '\\n' + message));\n                        }\n                    }\n                    continue; // there may be more complete messages to process\n                }\n            }\n            else {\n                var idx = this.rawData.indexOf(StreamDebugAdapter.TWO_CRLF);\n                if (idx !== -1) {\n                    var header = this.rawData.toString('utf8', 0, idx);\n                    var lines = header.split(StreamDebugAdapter.HEADER_LINESEPARATOR);\n                    for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\n                        var h = lines_1[_i];\n                        var kvPair = h.split(StreamDebugAdapter.HEADER_FIELDSEPARATOR);\n                        if (kvPair[0] === 'Content-Length') {\n                            this.contentLength = Number(kvPair[1]);\n                        }\n                    }\n                    this.rawData = this.rawData.slice(idx + StreamDebugAdapter.TWO_CRLF.length);\n                    continue;\n                }\n            }\n            break;\n        }\n    };\n    StreamDebugAdapter.TWO_CRLF = '\\r\\n\\r\\n';\n    StreamDebugAdapter.HEADER_LINESEPARATOR = /\\r?\\n/; // allow for non-RFC 2822 conforming line separators\n    StreamDebugAdapter.HEADER_FIELDSEPARATOR = /: */;\n    return StreamDebugAdapter;\n}(abstractDebugAdapter_1.AbstractDebugAdapter));\nexports.StreamDebugAdapter = StreamDebugAdapter;\n/**\n * An implementation that connects to a debug adapter via a socket.\n*/\nvar SocketDebugAdapter = /** @class */ (function (_super) {\n    tslib_1.__extends(SocketDebugAdapter, _super);\n    function SocketDebugAdapter(adapterServer) {\n        var _this = _super.call(this) || this;\n        _this.adapterServer = adapterServer;\n        return _this;\n    }\n    SocketDebugAdapter.prototype.startSession = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            var connected = false;\n            _this.socket = net.createConnection(_this.adapterServer.port, _this.adapterServer.host || '127.0.0.1', function () {\n                _this.connect(_this.socket, _this.socket);\n                resolve();\n                connected = true;\n            });\n            _this.socket.on('close', function () {\n                if (connected) {\n                    _this._onError.fire(new Error('connection closed'));\n                }\n                else {\n                    reject(new Error('connection closed'));\n                }\n            });\n            _this.socket.on('error', function (error) {\n                if (connected) {\n                    _this._onError.fire(error);\n                }\n                else {\n                    reject(error);\n                }\n            });\n        });\n    };\n    SocketDebugAdapter.prototype.stopSession = function () {\n        // Cancel all sent promises on disconnect so debug trees are not left in a broken state #3666.\n        this.cancelPending();\n        if (this.socket) {\n            this.socket.end();\n            this.socket = undefined;\n        }\n        return Promise.resolve(undefined);\n    };\n    return SocketDebugAdapter;\n}(StreamDebugAdapter));\nexports.SocketDebugAdapter = SocketDebugAdapter;\n/**\n * An implementation that launches the debug adapter as a separate process and communicates via stdin/stdout.\n*/\nvar ExecutableDebugAdapter = /** @class */ (function (_super) {\n    tslib_1.__extends(ExecutableDebugAdapter, _super);\n    function ExecutableDebugAdapter(adapterExecutable, debugType, outputService) {\n        var _this = _super.call(this) || this;\n        _this.adapterExecutable = adapterExecutable;\n        _this.debugType = debugType;\n        _this.outputService = outputService;\n        return _this;\n    }\n    ExecutableDebugAdapter.prototype.startSession = function () {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var command, args, options, commandExists, env, isElectron, forkOptions, child, spawnOptions, outputService_1, sanitize_1, err_1;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        command = this.adapterExecutable.command;\n                        args = this.adapterExecutable.args;\n                        options = this.adapterExecutable.options || {};\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 7, , 8]);\n                        if (!command) return [3 /*break*/, 5];\n                        if (!path.isAbsolute(command)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, pfs_1.exists(command)];\n                    case 2:\n                        commandExists = _a.sent();\n                        if (!commandExists) {\n                            throw new Error(nls.localize('debugAdapterBinNotFound', \"Debug adapter executable '{0}' does not exist.\", command));\n                        }\n                        return [3 /*break*/, 4];\n                    case 3:\n                        // relative path\n                        if (command.indexOf('/') < 0 && command.indexOf('\\\\') < 0) {\n                            // no separators: command looks like a runtime name like 'node' or 'mono'\n                            // TODO: check that the runtime is available on PATH\n                        }\n                        _a.label = 4;\n                    case 4: return [3 /*break*/, 6];\n                    case 5: throw new Error(nls.localize({ key: 'debugAdapterCannotDetermineExecutable', comment: ['Adapter executable file not found'] }, \"Cannot determine executable for debug adapter '{0}'.\", this.debugType));\n                    case 6:\n                        env = objects.mixin({}, process.env);\n                        if (options.env) {\n                            env = objects.mixin(env, options.env);\n                        }\n                        delete env.VSCODE_PREVENT_FOREIGN_INSPECT;\n                        if (command === 'node') {\n                            if (Array.isArray(args) && args.length > 0) {\n                                isElectron = !!process.env['ELECTRON_RUN_AS_NODE'] || !!process.versions['electron'];\n                                forkOptions = {\n                                    env: env,\n                                    execArgv: isElectron ? ['-e', 'delete process.env.ELECTRON_RUN_AS_NODE;require(process.argv[1])'] : [],\n                                    silent: true\n                                };\n                                if (options.cwd) {\n                                    forkOptions.cwd = options.cwd;\n                                }\n                                child = cp.fork(args[0], args.slice(1), forkOptions);\n                                if (!child.pid) {\n                                    throw new Error(nls.localize('unableToLaunchDebugAdapter', \"Unable to launch debug adapter from '{0}'.\", args[0]));\n                                }\n                                this.serverProcess = child;\n                            }\n                            else {\n                                throw new Error(nls.localize('unableToLaunchDebugAdapterNoArgs', \"Unable to launch debug adapter.\"));\n                            }\n                        }\n                        else {\n                            spawnOptions = {\n                                env: env\n                            };\n                            if (options.cwd) {\n                                spawnOptions.cwd = options.cwd;\n                            }\n                            this.serverProcess = cp.spawn(command, args, spawnOptions);\n                        }\n                        this.serverProcess.on('error', function (err) {\n                            _this._onError.fire(err);\n                        });\n                        this.serverProcess.on('exit', function (code, signal) {\n                            _this._onExit.fire(code);\n                        });\n                        this.serverProcess.stdout.on('close', function () {\n                            _this._onError.fire(new Error('read error'));\n                        });\n                        this.serverProcess.stdout.on('error', function (error) {\n                            _this._onError.fire(error);\n                        });\n                        this.serverProcess.stdin.on('error', function (error) {\n                            _this._onError.fire(error);\n                        });\n                        outputService_1 = this.outputService;\n                        if (outputService_1) {\n                            sanitize_1 = function (s) { return s.toString().replace(/\\r?\\n$/mg, ''); };\n                            // this.serverProcess.stdout.on('data', (data: string) => {\n                            // \tconsole.log('%c' + sanitize(data), 'background: #ddd; font-style: italic;');\n                            // });\n                            this.serverProcess.stderr.on('data', function (data) {\n                                var channel = outputService_1.getChannel(extensionManagement_1.ExtensionsChannelId);\n                                if (channel) {\n                                    channel.append(sanitize_1(data));\n                                }\n                            });\n                        }\n                        // finally connect to the DA\n                        this.connect(this.serverProcess.stdout, this.serverProcess.stdin);\n                        return [3 /*break*/, 8];\n                    case 7:\n                        err_1 = _a.sent();\n                        this._onError.fire(err_1);\n                        return [3 /*break*/, 8];\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    ExecutableDebugAdapter.prototype.stopSession = function () {\n        var _this = this;\n        // Cancel all sent promises on disconnect so debug trees are not left in a broken state #3666.\n        this.cancelPending();\n        if (!this.serverProcess) {\n            return Promise.resolve(undefined);\n        }\n        // when killing a process in windows its child\n        // processes are *not* killed but become root\n        // processes. Therefore we use TASKKILL.EXE\n        if (platform.isWindows) {\n            return new Promise(function (c, e) {\n                var killer = cp.exec(\"taskkill /F /T /PID \" + _this.serverProcess.pid, function (err, stdout, stderr) {\n                    if (err) {\n                        return e(err);\n                    }\n                });\n                killer.on('exit', c);\n                killer.on('error', e);\n            });\n        }\n        else {\n            this.serverProcess.kill('SIGTERM');\n            return Promise.resolve(undefined);\n        }\n    };\n    ExecutableDebugAdapter.extract = function (platformContribution, extensionFolderPath) {\n        if (!platformContribution) {\n            return undefined;\n        }\n        var result = Object.create(null);\n        if (platformContribution.runtime) {\n            if (platformContribution.runtime.indexOf('./') === 0) { // TODO\n                result.runtime = path.join(extensionFolderPath, platformContribution.runtime);\n            }\n            else {\n                result.runtime = platformContribution.runtime;\n            }\n        }\n        if (platformContribution.runtimeArgs) {\n            result.runtimeArgs = platformContribution.runtimeArgs;\n        }\n        if (platformContribution.program) {\n            if (!path.isAbsolute(platformContribution.program)) {\n                result.program = path.join(extensionFolderPath, platformContribution.program);\n            }\n            else {\n                result.program = platformContribution.program;\n            }\n        }\n        if (platformContribution.args) {\n            result.args = platformContribution.args;\n        }\n        var contribution = platformContribution;\n        if (contribution.win) {\n            result.win = ExecutableDebugAdapter.extract(contribution.win, extensionFolderPath);\n        }\n        if (contribution.winx86) {\n            result.winx86 = ExecutableDebugAdapter.extract(contribution.winx86, extensionFolderPath);\n        }\n        if (contribution.windows) {\n            result.windows = ExecutableDebugAdapter.extract(contribution.windows, extensionFolderPath);\n        }\n        if (contribution.osx) {\n            result.osx = ExecutableDebugAdapter.extract(contribution.osx, extensionFolderPath);\n        }\n        if (contribution.linux) {\n            result.linux = ExecutableDebugAdapter.extract(contribution.linux, extensionFolderPath);\n        }\n        return result;\n    };\n    ExecutableDebugAdapter.platformAdapterExecutable = function (extensionDescriptions, debugType) {\n        var result = Object.create(null);\n        debugType = debugType.toLowerCase();\n        var _loop_1 = function (ed) {\n            if (ed.contributes) {\n                var debuggers = ed.contributes['debuggers'];\n                if (debuggers && debuggers.length > 0) {\n                    debuggers.filter(function (dbg) { return typeof dbg.type === 'string' && strings.equalsIgnoreCase(dbg.type, debugType); }).forEach(function (dbg) {\n                        // extract relevant attributes and make them absolute where needed\n                        var extractedDbg = ExecutableDebugAdapter.extract(dbg, ed.extensionLocation.fsPath);\n                        // merge\n                        result = objects.mixin(result, extractedDbg, ed.isBuiltin);\n                    });\n                }\n            }\n        };\n        // merge all contributions into one\n        for (var _i = 0, extensionDescriptions_1 = extensionDescriptions; _i < extensionDescriptions_1.length; _i++) {\n            var ed = extensionDescriptions_1[_i];\n            _loop_1(ed);\n        }\n        // select the right platform\n        var platformInfo;\n        if (platform.isWindows && !process.env.hasOwnProperty('PROCESSOR_ARCHITEW6432')) {\n            platformInfo = result.winx86 || result.win || result.windows;\n        }\n        else if (platform.isWindows) {\n            platformInfo = result.win || result.windows;\n        }\n        else if (platform.isMacintosh) {\n            platformInfo = result.osx;\n        }\n        else if (platform.isLinux) {\n            platformInfo = result.linux;\n        }\n        platformInfo = platformInfo || result;\n        // these are the relevant attributes\n        var program = platformInfo.program || result.program;\n        var args = platformInfo.args || result.args;\n        var runtime = platformInfo.runtime || result.runtime;\n        var runtimeArgs = platformInfo.runtimeArgs || result.runtimeArgs;\n        if (runtime) {\n            return {\n                type: 'executable',\n                command: runtime,\n                args: (runtimeArgs || []).concat(typeof program === 'string' ? [program] : []).concat(args || [])\n            };\n        }\n        else if (program) {\n            return {\n                type: 'executable',\n                command: program,\n                args: args || []\n            };\n        }\n        // nothing found\n        return undefined;\n    };\n    return ExecutableDebugAdapter;\n}(StreamDebugAdapter));\nexports.ExecutableDebugAdapter = ExecutableDebugAdapter;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/node/debugAdapter.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/node/debugAdapter.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { exists } from 'vs/base/node/pfs';\nimport * as cp from 'child_process';\nimport * as stream from 'stream';\nimport * as nls from 'vs/nls';\nimport * as net from 'net';\nimport * as path from 'vs/base/common/path';\nimport * as strings from 'vs/base/common/strings';\nimport * as objects from 'vs/base/common/objects';\nimport * as platform from 'vs/base/common/platform';\nimport { ExtensionsChannelId } from 'vs/platform/extensionManagement/common/extensionManagement';\nimport { IOutputService } from 'vs/workbench/contrib/output/common/output';\nimport { IDebugAdapterExecutable, IDebuggerContribution, IPlatformSpecificAdapterContribution, IDebugAdapterServer } from 'vs/workbench/contrib/debug/common/debug';\nimport { IExtensionDescription } from 'vs/platform/extensions/common/extensions';\nimport { AbstractDebugAdapter } from '../common/abstractDebugAdapter';\n\n/**\n * An implementation that communicates via two streams with the debug adapter.\n */\nexport abstract class StreamDebugAdapter extends AbstractDebugAdapter {\n\n\tprivate static readonly TWO_CRLF = '\\r\\n\\r\\n';\n\tprivate static readonly HEADER_LINESEPARATOR = /\\r?\\n/;\t// allow for non-RFC 2822 conforming line separators\n\tprivate static readonly HEADER_FIELDSEPARATOR = /: */;\n\n\tprivate outputStream: stream.Writable;\n\tprivate rawData: Buffer;\n\tprivate contentLength: number;\n\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\tprotected connect(readable: stream.Readable, writable: stream.Writable): void {\n\n\t\tthis.outputStream = writable;\n\t\tthis.rawData = Buffer.allocUnsafe(0);\n\t\tthis.contentLength = -1;\n\n\t\treadable.on('data', (data: Buffer) => this.handleData(data));\n\t}\n\n\tsendMessage(message: DebugProtocol.ProtocolMessage): void {\n\n\t\tif (this.outputStream) {\n\t\t\tconst json = JSON.stringify(message);\n\t\t\tthis.outputStream.write(`Content-Length: ${Buffer.byteLength(json, 'utf8')}${StreamDebugAdapter.TWO_CRLF}${json}`, 'utf8');\n\t\t}\n\t}\n\n\tprivate handleData(data: Buffer): void {\n\n\t\tthis.rawData = Buffer.concat([this.rawData, data]);\n\n\t\twhile (true) {\n\t\t\tif (this.contentLength >= 0) {\n\t\t\t\tif (this.rawData.length >= this.contentLength) {\n\t\t\t\t\tconst message = this.rawData.toString('utf8', 0, this.contentLength);\n\t\t\t\t\tthis.rawData = this.rawData.slice(this.contentLength);\n\t\t\t\t\tthis.contentLength = -1;\n\t\t\t\t\tif (message.length > 0) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tthis.acceptMessage(<DebugProtocol.ProtocolMessage>JSON.parse(message));\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tthis._onError.fire(new Error((e.message || e) + '\\n' + message));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\t// there may be more complete messages to process\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst idx = this.rawData.indexOf(StreamDebugAdapter.TWO_CRLF);\n\t\t\t\tif (idx !== -1) {\n\t\t\t\t\tconst header = this.rawData.toString('utf8', 0, idx);\n\t\t\t\t\tconst lines = header.split(StreamDebugAdapter.HEADER_LINESEPARATOR);\n\t\t\t\t\tfor (const h of lines) {\n\t\t\t\t\t\tconst kvPair = h.split(StreamDebugAdapter.HEADER_FIELDSEPARATOR);\n\t\t\t\t\t\tif (kvPair[0] === 'Content-Length') {\n\t\t\t\t\t\t\tthis.contentLength = Number(kvPair[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.rawData = this.rawData.slice(idx + StreamDebugAdapter.TWO_CRLF.length);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * An implementation that connects to a debug adapter via a socket.\n*/\nexport class SocketDebugAdapter extends StreamDebugAdapter {\n\n\tprivate socket?: net.Socket;\n\n\tconstructor(private adapterServer: IDebugAdapterServer) {\n\t\tsuper();\n\t}\n\n\tstartSession(): Promise<void> {\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tlet connected = false;\n\t\t\tthis.socket = net.createConnection(this.adapterServer.port, this.adapterServer.host || '127.0.0.1', () => {\n\t\t\t\tthis.connect(this.socket!, this.socket!);\n\t\t\t\tresolve();\n\t\t\t\tconnected = true;\n\t\t\t});\n\t\t\tthis.socket.on('close', () => {\n\t\t\t\tif (connected) {\n\t\t\t\t\tthis._onError.fire(new Error('connection closed'));\n\t\t\t\t} else {\n\t\t\t\t\treject(new Error('connection closed'));\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.socket.on('error', error => {\n\t\t\t\tif (connected) {\n\t\t\t\t\tthis._onError.fire(error);\n\t\t\t\t} else {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tstopSession(): Promise<void> {\n\n\t\t// Cancel all sent promises on disconnect so debug trees are not left in a broken state #3666.\n\t\tthis.cancelPending();\n\n\t\tif (this.socket) {\n\t\t\tthis.socket.end();\n\t\t\tthis.socket = undefined;\n\t\t}\n\t\treturn Promise.resolve(undefined);\n\t}\n}\n\n/**\n * An implementation that launches the debug adapter as a separate process and communicates via stdin/stdout.\n*/\nexport class ExecutableDebugAdapter extends StreamDebugAdapter {\n\n\tprivate serverProcess: cp.ChildProcess;\n\n\tconstructor(private adapterExecutable: IDebugAdapterExecutable, private debugType: string, private readonly outputService?: IOutputService) {\n\t\tsuper();\n\t}\n\n\tasync startSession(): Promise<void> {\n\n\t\tconst command = this.adapterExecutable.command;\n\t\tconst args = this.adapterExecutable.args;\n\t\tconst options = this.adapterExecutable.options || {};\n\n\t\ttry {\n\t\t\t// verify executables asynchronously\n\t\t\tif (command) {\n\t\t\t\tif (path.isAbsolute(command)) {\n\t\t\t\t\tconst commandExists = await exists(command);\n\t\t\t\t\tif (!commandExists) {\n\t\t\t\t\t\tthrow new Error(nls.localize('debugAdapterBinNotFound', \"Debug adapter executable '{0}' does not exist.\", command));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// relative path\n\t\t\t\t\tif (command.indexOf('/') < 0 && command.indexOf('\\\\') < 0) {\n\t\t\t\t\t\t// no separators: command looks like a runtime name like 'node' or 'mono'\n\t\t\t\t\t\t// TODO: check that the runtime is available on PATH\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error(nls.localize({ key: 'debugAdapterCannotDetermineExecutable', comment: ['Adapter executable file not found'] },\n\t\t\t\t\t\"Cannot determine executable for debug adapter '{0}'.\", this.debugType));\n\t\t\t}\n\n\t\t\tlet env = objects.mixin({}, process.env);\n\t\t\tif (options.env) {\n\t\t\t\tenv = objects.mixin(env, options.env);\n\t\t\t}\n\t\t\tdelete env.VSCODE_PREVENT_FOREIGN_INSPECT;\n\n\t\t\tif (command === 'node') {\n\t\t\t\tif (Array.isArray(args) && args.length > 0) {\n\t\t\t\t\tconst isElectron = !!process.env['ELECTRON_RUN_AS_NODE'] || !!process.versions['electron'];\n\t\t\t\t\tconst forkOptions: cp.ForkOptions = {\n\t\t\t\t\t\tenv: env,\n\t\t\t\t\t\texecArgv: isElectron ? ['-e', 'delete process.env.ELECTRON_RUN_AS_NODE;require(process.argv[1])'] : [],\n\t\t\t\t\t\tsilent: true\n\t\t\t\t\t};\n\t\t\t\t\tif (options.cwd) {\n\t\t\t\t\t\tforkOptions.cwd = options.cwd;\n\t\t\t\t\t}\n\t\t\t\t\tconst child = cp.fork(args[0], args.slice(1), forkOptions);\n\t\t\t\t\tif (!child.pid) {\n\t\t\t\t\t\tthrow new Error(nls.localize('unableToLaunchDebugAdapter', \"Unable to launch debug adapter from '{0}'.\", args[0]));\n\t\t\t\t\t}\n\t\t\t\t\tthis.serverProcess = child;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(nls.localize('unableToLaunchDebugAdapterNoArgs', \"Unable to launch debug adapter.\"));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst spawnOptions: cp.SpawnOptions = {\n\t\t\t\t\tenv: env\n\t\t\t\t};\n\t\t\t\tif (options.cwd) {\n\t\t\t\t\tspawnOptions.cwd = options.cwd;\n\t\t\t\t}\n\t\t\t\tthis.serverProcess = cp.spawn(command, args, spawnOptions);\n\t\t\t}\n\n\t\t\tthis.serverProcess.on('error', err => {\n\t\t\t\tthis._onError.fire(err);\n\t\t\t});\n\t\t\tthis.serverProcess.on('exit', (code, signal) => {\n\t\t\t\tthis._onExit.fire(code);\n\t\t\t});\n\n\t\t\tthis.serverProcess.stdout.on('close', () => {\n\t\t\t\tthis._onError.fire(new Error('read error'));\n\t\t\t});\n\t\t\tthis.serverProcess.stdout.on('error', error => {\n\t\t\t\tthis._onError.fire(error);\n\t\t\t});\n\n\t\t\tthis.serverProcess.stdin.on('error', error => {\n\t\t\t\tthis._onError.fire(error);\n\t\t\t});\n\n\t\t\tconst outputService = this.outputService;\n\t\t\tif (outputService) {\n\t\t\t\tconst sanitize = (s: string) => s.toString().replace(/\\r?\\n$/mg, '');\n\t\t\t\t// this.serverProcess.stdout.on('data', (data: string) => {\n\t\t\t\t// \tconsole.log('%c' + sanitize(data), 'background: #ddd; font-style: italic;');\n\t\t\t\t// });\n\t\t\t\tthis.serverProcess.stderr.on('data', (data: string) => {\n\t\t\t\t\tconst channel = outputService.getChannel(ExtensionsChannelId);\n\t\t\t\t\tif (channel) {\n\t\t\t\t\t\tchannel.append(sanitize(data));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// finally connect to the DA\n\t\t\tthis.connect(this.serverProcess.stdout, this.serverProcess.stdin);\n\n\t\t} catch (err) {\n\t\t\tthis._onError.fire(err);\n\t\t}\n\t}\n\n\tstopSession(): Promise<void> {\n\n\t\t// Cancel all sent promises on disconnect so debug trees are not left in a broken state #3666.\n\t\tthis.cancelPending();\n\n\t\tif (!this.serverProcess) {\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\n\t\t// when killing a process in windows its child\n\t\t// processes are *not* killed but become root\n\t\t// processes. Therefore we use TASKKILL.EXE\n\t\tif (platform.isWindows) {\n\t\t\treturn new Promise<void>((c, e) => {\n\t\t\t\tconst killer = cp.exec(`taskkill /F /T /PID ${this.serverProcess.pid}`, function (err, stdout, stderr) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn e(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tkiller.on('exit', c);\n\t\t\t\tkiller.on('error', e);\n\t\t\t});\n\t\t} else {\n\t\t\tthis.serverProcess.kill('SIGTERM');\n\t\t\treturn Promise.resolve(undefined);\n\t\t}\n\t}\n\n\tprivate static extract(platformContribution: IPlatformSpecificAdapterContribution, extensionFolderPath: string): IDebuggerContribution | undefined {\n\t\tif (!platformContribution) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst result: IDebuggerContribution = Object.create(null);\n\t\tif (platformContribution.runtime) {\n\t\t\tif (platformContribution.runtime.indexOf('./') === 0) {\t// TODO\n\t\t\t\tresult.runtime = path.join(extensionFolderPath, platformContribution.runtime);\n\t\t\t} else {\n\t\t\t\tresult.runtime = platformContribution.runtime;\n\t\t\t}\n\t\t}\n\t\tif (platformContribution.runtimeArgs) {\n\t\t\tresult.runtimeArgs = platformContribution.runtimeArgs;\n\t\t}\n\t\tif (platformContribution.program) {\n\t\t\tif (!path.isAbsolute(platformContribution.program)) {\n\t\t\t\tresult.program = path.join(extensionFolderPath, platformContribution.program);\n\t\t\t} else {\n\t\t\t\tresult.program = platformContribution.program;\n\t\t\t}\n\t\t}\n\t\tif (platformContribution.args) {\n\t\t\tresult.args = platformContribution.args;\n\t\t}\n\n\t\tconst contribution = platformContribution as IDebuggerContribution;\n\n\t\tif (contribution.win) {\n\t\t\tresult.win = ExecutableDebugAdapter.extract(contribution.win, extensionFolderPath);\n\t\t}\n\t\tif (contribution.winx86) {\n\t\t\tresult.winx86 = ExecutableDebugAdapter.extract(contribution.winx86, extensionFolderPath);\n\t\t}\n\t\tif (contribution.windows) {\n\t\t\tresult.windows = ExecutableDebugAdapter.extract(contribution.windows, extensionFolderPath);\n\t\t}\n\t\tif (contribution.osx) {\n\t\t\tresult.osx = ExecutableDebugAdapter.extract(contribution.osx, extensionFolderPath);\n\t\t}\n\t\tif (contribution.linux) {\n\t\t\tresult.linux = ExecutableDebugAdapter.extract(contribution.linux, extensionFolderPath);\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic platformAdapterExecutable(extensionDescriptions: IExtensionDescription[], debugType: string): IDebugAdapterExecutable | undefined {\n\t\tlet result: IDebuggerContribution = Object.create(null);\n\t\tdebugType = debugType.toLowerCase();\n\n\t\t// merge all contributions into one\n\t\tfor (const ed of extensionDescriptions) {\n\t\t\tif (ed.contributes) {\n\t\t\t\tconst debuggers = <IDebuggerContribution[]>ed.contributes['debuggers'];\n\t\t\t\tif (debuggers && debuggers.length > 0) {\n\t\t\t\t\tdebuggers.filter(dbg => typeof dbg.type === 'string' && strings.equalsIgnoreCase(dbg.type, debugType)).forEach(dbg => {\n\t\t\t\t\t\t// extract relevant attributes and make them absolute where needed\n\t\t\t\t\t\tconst extractedDbg = ExecutableDebugAdapter.extract(dbg, ed.extensionLocation.fsPath);\n\n\t\t\t\t\t\t// merge\n\t\t\t\t\t\tresult = objects.mixin(result, extractedDbg, ed.isBuiltin);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// select the right platform\n\t\tlet platformInfo: IPlatformSpecificAdapterContribution | undefined;\n\t\tif (platform.isWindows && !process.env.hasOwnProperty('PROCESSOR_ARCHITEW6432')) {\n\t\t\tplatformInfo = result.winx86 || result.win || result.windows;\n\t\t} else if (platform.isWindows) {\n\t\t\tplatformInfo = result.win || result.windows;\n\t\t} else if (platform.isMacintosh) {\n\t\t\tplatformInfo = result.osx;\n\t\t} else if (platform.isLinux) {\n\t\t\tplatformInfo = result.linux;\n\t\t}\n\t\tplatformInfo = platformInfo || result;\n\n\t\t// these are the relevant attributes\n\t\tlet program = platformInfo.program || result.program;\n\t\tconst args = platformInfo.args || result.args;\n\t\tlet runtime = platformInfo.runtime || result.runtime;\n\t\tconst runtimeArgs = platformInfo.runtimeArgs || result.runtimeArgs;\n\n\t\tif (runtime) {\n\t\t\treturn {\n\t\t\t\ttype: 'executable',\n\t\t\t\tcommand: runtime,\n\t\t\t\targs: (runtimeArgs || []).concat(typeof program === 'string' ? [program] : []).concat(args || [])\n\t\t\t};\n\t\t} else if (program) {\n\t\t\treturn {\n\t\t\t\ttype: 'executable',\n\t\t\t\tcommand: program,\n\t\t\t\targs: args || []\n\t\t\t};\n\t\t}\n\n\t\t// nothing found\n\t\treturn undefined;\n\t}\n}\n"]}]}