{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/parts/quickopen/common/quickOpenScorer.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/parts/quickopen/common/quickOpenScorer.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/comparers\", \"vs/base/common/filters\", \"vs/base/common/path\", \"vs/base/common/platform\", \"vs/base/common/strings\", \"vs/base/common/charCode\"], function (require, exports, comparers_1, filters_1, path_1, platform_1, strings_1, charCode_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const NO_MATCH = 0;\n    const NO_SCORE = [NO_MATCH, []];\n    // const DEBUG = false;\n    // const DEBUG_MATRIX = false;\n    function score(target, query, queryLower, fuzzy) {\n        if (!target || !query) {\n            return NO_SCORE; // return early if target or query are undefined\n        }\n        const targetLength = target.length;\n        const queryLength = query.length;\n        if (targetLength < queryLength) {\n            return NO_SCORE; // impossible for query to be contained in target\n        }\n        // if (DEBUG) {\n        // \tconsole.group(`Target: ${target}, Query: ${query}`);\n        // }\n        const targetLower = target.toLowerCase();\n        // When not searching fuzzy, we require the query to be contained fully\n        // in the target string contiguously.\n        if (!fuzzy) {\n            const indexOfQueryInTarget = targetLower.indexOf(queryLower);\n            if (indexOfQueryInTarget === -1) {\n                // if (DEBUG) {\n                // \tconsole.log(`Characters not matching consecutively ${queryLower} within ${targetLower}`);\n                // }\n                return NO_SCORE;\n            }\n        }\n        const res = doScore(query, queryLower, queryLength, target, targetLower, targetLength);\n        // if (DEBUG) {\n        // \tconsole.log(`%cFinal Score: ${res[0]}`, 'font-weight: bold');\n        // \tconsole.groupEnd();\n        // }\n        return res;\n    }\n    exports.score = score;\n    function doScore(query, queryLower, queryLength, target, targetLower, targetLength) {\n        const scores = [];\n        const matches = [];\n        //\n        // Build Scorer Matrix:\n        //\n        // The matrix is composed of query q and target t. For each index we score\n        // q[i] with t[i] and compare that with the previous score. If the score is\n        // equal or larger, we keep the match. In addition to the score, we also keep\n        // the length of the consecutive matches to use as boost for the score.\n        //\n        //      t   a   r   g   e   t\n        //  q\n        //  u\n        //  e\n        //  r\n        //  y\n        //\n        for (let queryIndex = 0; queryIndex < queryLength; queryIndex++) {\n            const queryIndexOffset = queryIndex * targetLength;\n            const queryIndexPreviousOffset = queryIndexOffset - targetLength;\n            const queryIndexGtNull = queryIndex > 0;\n            const queryCharAtIndex = query[queryIndex];\n            const queryLowerCharAtIndex = queryLower[queryIndex];\n            for (let targetIndex = 0; targetIndex < targetLength; targetIndex++) {\n                const targetIndexGtNull = targetIndex > 0;\n                const currentIndex = queryIndexOffset + targetIndex;\n                const leftIndex = currentIndex - 1;\n                const diagIndex = queryIndexPreviousOffset + targetIndex - 1;\n                const leftScore = targetIndexGtNull ? scores[leftIndex] : 0;\n                const diagScore = queryIndexGtNull && targetIndexGtNull ? scores[diagIndex] : 0;\n                const matchesSequenceLength = queryIndexGtNull && targetIndexGtNull ? matches[diagIndex] : 0;\n                // If we are not matching on the first query character any more, we only produce a\n                // score if we had a score previously for the last query index (by looking at the diagScore).\n                // This makes sure that the query always matches in sequence on the target. For example\n                // given a target of \"ede\" and a query of \"de\", we would otherwise produce a wrong high score\n                // for query[1] (\"e\") matching on target[0] (\"e\") because of the \"beginning of word\" boost.\n                let score;\n                if (!diagScore && queryIndexGtNull) {\n                    score = 0;\n                }\n                else {\n                    score = computeCharScore(queryCharAtIndex, queryLowerCharAtIndex, target, targetLower, targetIndex, matchesSequenceLength);\n                }\n                // We have a score and its equal or larger than the left score\n                // Match: sequence continues growing from previous diag value\n                // Score: increases by diag score value\n                if (score && diagScore + score >= leftScore) {\n                    matches[currentIndex] = matchesSequenceLength + 1;\n                    scores[currentIndex] = diagScore + score;\n                }\n                // We either have no score or the score is lower than the left score\n                // Match: reset to 0\n                // Score: pick up from left hand side\n                else {\n                    matches[currentIndex] = NO_MATCH;\n                    scores[currentIndex] = leftScore;\n                }\n            }\n        }\n        // Restore Positions (starting from bottom right of matrix)\n        const positions = [];\n        let queryIndex = queryLength - 1;\n        let targetIndex = targetLength - 1;\n        while (queryIndex >= 0 && targetIndex >= 0) {\n            const currentIndex = queryIndex * targetLength + targetIndex;\n            const match = matches[currentIndex];\n            if (match === NO_MATCH) {\n                targetIndex--; // go left\n            }\n            else {\n                positions.push(targetIndex);\n                // go up and left\n                queryIndex--;\n                targetIndex--;\n            }\n        }\n        // Print matrix\n        // if (DEBUG_MATRIX) {\n        // printMatrix(query, target, matches, scores);\n        // }\n        return [scores[queryLength * targetLength - 1], positions.reverse()];\n    }\n    function computeCharScore(queryCharAtIndex, queryLowerCharAtIndex, target, targetLower, targetIndex, matchesSequenceLength) {\n        let score = 0;\n        if (queryLowerCharAtIndex !== targetLower[targetIndex]) {\n            return score; // no match of characters\n        }\n        // Character match bonus\n        score += 1;\n        // if (DEBUG) {\n        // \tconsole.groupCollapsed(`%cCharacter match bonus: +1 (char: ${queryLower[queryIndex]} at index ${targetIndex}, total score: ${score})`, 'font-weight: normal');\n        // }\n        // Consecutive match bonus\n        if (matchesSequenceLength > 0) {\n            score += (matchesSequenceLength * 5);\n            // if (DEBUG) {\n            // \tconsole.log('Consecutive match bonus: ' + (matchesSequenceLength * 5));\n            // }\n        }\n        // Same case bonus\n        if (queryCharAtIndex === target[targetIndex]) {\n            score += 1;\n            // if (DEBUG) {\n            // \tconsole.log('Same case bonus: +1');\n            // }\n        }\n        // Start of word bonus\n        if (targetIndex === 0) {\n            score += 8;\n            // if (DEBUG) {\n            // \tconsole.log('Start of word bonus: +8');\n            // }\n        }\n        else {\n            // After separator bonus\n            const separatorBonus = scoreSeparatorAtPos(target.charCodeAt(targetIndex - 1));\n            if (separatorBonus) {\n                score += separatorBonus;\n                // if (DEBUG) {\n                // \tconsole.log('After separtor bonus: +4');\n                // }\n            }\n            // Inside word upper case bonus (camel case)\n            else if (filters_1.isUpper(target.charCodeAt(targetIndex))) {\n                score += 1;\n                // if (DEBUG) {\n                // \tconsole.log('Inside word upper case bonus: +1');\n                // }\n            }\n        }\n        // if (DEBUG) {\n        // \tconsole.groupEnd();\n        // }\n        return score;\n    }\n    function scoreSeparatorAtPos(charCode) {\n        switch (charCode) {\n            case charCode_1.CharCode.Slash:\n            case charCode_1.CharCode.Backslash:\n                return 5; // prefer path separators...\n            case charCode_1.CharCode.Underline:\n            case charCode_1.CharCode.Dash:\n            case charCode_1.CharCode.Period:\n            case charCode_1.CharCode.Space:\n            case charCode_1.CharCode.SingleQuote:\n            case charCode_1.CharCode.DoubleQuote:\n            case charCode_1.CharCode.Colon:\n                return 4; // ...over other separators\n            default:\n                return 0;\n        }\n    }\n    const NO_ITEM_SCORE = Object.freeze({ score: 0 });\n    const PATH_IDENTITY_SCORE = 1 << 18;\n    const LABEL_PREFIX_SCORE = 1 << 17;\n    const LABEL_CAMELCASE_SCORE = 1 << 16;\n    const LABEL_SCORE_THRESHOLD = 1 << 15;\n    /**\n     * Helper function to prepare a search value for scoring in quick open by removing unwanted characters.\n     */\n    function prepareQuery(original) {\n        if (!original) {\n            original = '';\n        }\n        let value = strings_1.stripWildcards(original).replace(/\\s/g, ''); // get rid of all wildcards and whitespace\n        if (platform_1.isWindows) {\n            value = value.replace(/\\//g, path_1.sep); // Help Windows users to search for paths when using slash\n        }\n        const lowercase = value.toLowerCase();\n        const containsPathSeparator = value.indexOf(path_1.sep) >= 0;\n        return { original, value, lowercase, containsPathSeparator };\n    }\n    exports.prepareQuery = prepareQuery;\n    function scoreItem(item, query, fuzzy, accessor, cache) {\n        if (!item || !query.value) {\n            return NO_ITEM_SCORE; // we need an item and query to score on at least\n        }\n        const label = accessor.getItemLabel(item);\n        if (!label) {\n            return NO_ITEM_SCORE; // we need a label at least\n        }\n        const description = accessor.getItemDescription(item);\n        let cacheHash;\n        if (description) {\n            cacheHash = `${label}${description}${query.value}${fuzzy}`;\n        }\n        else {\n            cacheHash = `${label}${query.value}${fuzzy}`;\n        }\n        const cached = cache[cacheHash];\n        if (cached) {\n            return cached;\n        }\n        const itemScore = doScoreItem(label, description, accessor.getItemPath(item), query, fuzzy);\n        cache[cacheHash] = itemScore;\n        return itemScore;\n    }\n    exports.scoreItem = scoreItem;\n    function createMatches(offsets) {\n        let ret = [];\n        if (!offsets) {\n            return ret;\n        }\n        let last;\n        for (const pos of offsets) {\n            if (last && last.end === pos) {\n                last.end += 1;\n            }\n            else {\n                last = { start: pos, end: pos + 1 };\n                ret.push(last);\n            }\n        }\n        return ret;\n    }\n    function doScoreItem(label, description, path, query, fuzzy) {\n        // 1.) treat identity matches on full path highest\n        if (path && (platform_1.isLinux ? query.original === path : strings_1.equalsIgnoreCase(query.original, path))) {\n            return { score: PATH_IDENTITY_SCORE, labelMatch: [{ start: 0, end: label.length }], descriptionMatch: description ? [{ start: 0, end: description.length }] : undefined };\n        }\n        // We only consider label matches if the query is not including file path separators\n        const preferLabelMatches = !path || !query.containsPathSeparator;\n        if (preferLabelMatches) {\n            // 2.) treat prefix matches on the label second highest\n            const prefixLabelMatch = filters_1.matchesPrefix(query.value, label);\n            if (prefixLabelMatch) {\n                return { score: LABEL_PREFIX_SCORE, labelMatch: prefixLabelMatch };\n            }\n            // 3.) treat camelcase matches on the label third highest\n            const camelcaseLabelMatch = filters_1.matchesCamelCase(query.value, label);\n            if (camelcaseLabelMatch) {\n                return { score: LABEL_CAMELCASE_SCORE, labelMatch: camelcaseLabelMatch };\n            }\n            // 4.) prefer scores on the label if any\n            const [labelScore, labelPositions] = score(label, query.value, query.lowercase, fuzzy);\n            if (labelScore) {\n                return { score: labelScore + LABEL_SCORE_THRESHOLD, labelMatch: createMatches(labelPositions) };\n            }\n        }\n        // 5.) finally compute description + label scores if we have a description\n        if (description) {\n            let descriptionPrefix = description;\n            if (!!path) {\n                descriptionPrefix = `${description}${path_1.sep}`; // assume this is a file path\n            }\n            const descriptionPrefixLength = descriptionPrefix.length;\n            const descriptionAndLabel = `${descriptionPrefix}${label}`;\n            const [labelDescriptionScore, labelDescriptionPositions] = score(descriptionAndLabel, query.value, query.lowercase, fuzzy);\n            if (labelDescriptionScore) {\n                const labelDescriptionMatches = createMatches(labelDescriptionPositions);\n                const labelMatch = [];\n                const descriptionMatch = [];\n                // We have to split the matches back onto the label and description portions\n                labelDescriptionMatches.forEach(h => {\n                    // Match overlaps label and description part, we need to split it up\n                    if (h.start < descriptionPrefixLength && h.end > descriptionPrefixLength) {\n                        labelMatch.push({ start: 0, end: h.end - descriptionPrefixLength });\n                        descriptionMatch.push({ start: h.start, end: descriptionPrefixLength });\n                    }\n                    // Match on label part\n                    else if (h.start >= descriptionPrefixLength) {\n                        labelMatch.push({ start: h.start - descriptionPrefixLength, end: h.end - descriptionPrefixLength });\n                    }\n                    // Match on description part\n                    else {\n                        descriptionMatch.push(h);\n                    }\n                });\n                return { score: labelDescriptionScore, labelMatch, descriptionMatch };\n            }\n        }\n        return NO_ITEM_SCORE;\n    }\n    function compareItemsByScore(itemA, itemB, query, fuzzy, accessor, cache, fallbackComparer = fallbackCompare) {\n        const itemScoreA = scoreItem(itemA, query, fuzzy, accessor, cache);\n        const itemScoreB = scoreItem(itemB, query, fuzzy, accessor, cache);\n        const scoreA = itemScoreA.score;\n        const scoreB = itemScoreB.score;\n        // 1.) prefer identity matches\n        if (scoreA === PATH_IDENTITY_SCORE || scoreB === PATH_IDENTITY_SCORE) {\n            if (scoreA !== scoreB) {\n                return scoreA === PATH_IDENTITY_SCORE ? -1 : 1;\n            }\n        }\n        // 2.) prefer label prefix matches\n        if (scoreA === LABEL_PREFIX_SCORE || scoreB === LABEL_PREFIX_SCORE) {\n            if (scoreA !== scoreB) {\n                return scoreA === LABEL_PREFIX_SCORE ? -1 : 1;\n            }\n            const labelA = accessor.getItemLabel(itemA) || '';\n            const labelB = accessor.getItemLabel(itemB) || '';\n            // prefer shorter names when both match on label prefix\n            if (labelA.length !== labelB.length) {\n                return labelA.length - labelB.length;\n            }\n        }\n        // 3.) prefer camelcase matches\n        if (scoreA === LABEL_CAMELCASE_SCORE || scoreB === LABEL_CAMELCASE_SCORE) {\n            if (scoreA !== scoreB) {\n                return scoreA === LABEL_CAMELCASE_SCORE ? -1 : 1;\n            }\n            const labelA = accessor.getItemLabel(itemA) || '';\n            const labelB = accessor.getItemLabel(itemB) || '';\n            // prefer more compact camel case matches over longer\n            const comparedByMatchLength = compareByMatchLength(itemScoreA.labelMatch, itemScoreB.labelMatch);\n            if (comparedByMatchLength !== 0) {\n                return comparedByMatchLength;\n            }\n            // prefer shorter names when both match on label camelcase\n            if (labelA.length !== labelB.length) {\n                return labelA.length - labelB.length;\n            }\n        }\n        // 4.) prefer label scores\n        if (scoreA > LABEL_SCORE_THRESHOLD || scoreB > LABEL_SCORE_THRESHOLD) {\n            if (scoreB < LABEL_SCORE_THRESHOLD) {\n                return -1;\n            }\n            if (scoreA < LABEL_SCORE_THRESHOLD) {\n                return 1;\n            }\n        }\n        // 5.) compare by score\n        if (scoreA !== scoreB) {\n            return scoreA > scoreB ? -1 : 1;\n        }\n        // 6.) scores are identical, prefer more compact matches (label and description)\n        const itemAMatchDistance = computeLabelAndDescriptionMatchDistance(itemA, itemScoreA, accessor);\n        const itemBMatchDistance = computeLabelAndDescriptionMatchDistance(itemB, itemScoreB, accessor);\n        if (itemAMatchDistance && itemBMatchDistance && itemAMatchDistance !== itemBMatchDistance) {\n            return itemBMatchDistance > itemAMatchDistance ? -1 : 1;\n        }\n        // 7.) at this point, scores are identical and match compactness as well\n        // for both items so we start to use the fallback compare\n        return fallbackComparer(itemA, itemB, query, accessor);\n    }\n    exports.compareItemsByScore = compareItemsByScore;\n    function computeLabelAndDescriptionMatchDistance(item, score, accessor) {\n        let matchStart = -1;\n        let matchEnd = -1;\n        // If we have description matches, the start is first of description match\n        if (score.descriptionMatch && score.descriptionMatch.length) {\n            matchStart = score.descriptionMatch[0].start;\n        }\n        // Otherwise, the start is the first label match\n        else if (score.labelMatch && score.labelMatch.length) {\n            matchStart = score.labelMatch[0].start;\n        }\n        // If we have label match, the end is the last label match\n        // If we had a description match, we add the length of the description\n        // as offset to the end to indicate this.\n        if (score.labelMatch && score.labelMatch.length) {\n            matchEnd = score.labelMatch[score.labelMatch.length - 1].end;\n            if (score.descriptionMatch && score.descriptionMatch.length) {\n                const itemDescription = accessor.getItemDescription(item);\n                if (itemDescription) {\n                    matchEnd += itemDescription.length;\n                }\n            }\n        }\n        // If we have just a description match, the end is the last description match\n        else if (score.descriptionMatch && score.descriptionMatch.length) {\n            matchEnd = score.descriptionMatch[score.descriptionMatch.length - 1].end;\n        }\n        return matchEnd - matchStart;\n    }\n    function compareByMatchLength(matchesA, matchesB) {\n        if ((!matchesA && !matchesB) || ((!matchesA || !matchesA.length) && (!matchesB || !matchesB.length))) {\n            return 0; // make sure to not cause bad comparing when matches are not provided\n        }\n        if (!matchesB || !matchesB.length) {\n            return -1;\n        }\n        if (!matchesA || !matchesA.length) {\n            return 1;\n        }\n        // Compute match length of A (first to last match)\n        const matchStartA = matchesA[0].start;\n        const matchEndA = matchesA[matchesA.length - 1].end;\n        const matchLengthA = matchEndA - matchStartA;\n        // Compute match length of B (first to last match)\n        const matchStartB = matchesB[0].start;\n        const matchEndB = matchesB[matchesB.length - 1].end;\n        const matchLengthB = matchEndB - matchStartB;\n        // Prefer shorter match length\n        return matchLengthA === matchLengthB ? 0 : matchLengthB < matchLengthA ? 1 : -1;\n    }\n    function fallbackCompare(itemA, itemB, query, accessor) {\n        // check for label + description length and prefer shorter\n        const labelA = accessor.getItemLabel(itemA) || '';\n        const labelB = accessor.getItemLabel(itemB) || '';\n        const descriptionA = accessor.getItemDescription(itemA);\n        const descriptionB = accessor.getItemDescription(itemB);\n        const labelDescriptionALength = labelA.length + (descriptionA ? descriptionA.length : 0);\n        const labelDescriptionBLength = labelB.length + (descriptionB ? descriptionB.length : 0);\n        if (labelDescriptionALength !== labelDescriptionBLength) {\n            return labelDescriptionALength - labelDescriptionBLength;\n        }\n        // check for path length and prefer shorter\n        const pathA = accessor.getItemPath(itemA);\n        const pathB = accessor.getItemPath(itemB);\n        if (pathA && pathB && pathA.length !== pathB.length) {\n            return pathA.length - pathB.length;\n        }\n        // 7.) finally we have equal scores and equal length, we fallback to comparer\n        // compare by label\n        if (labelA !== labelB) {\n            return comparers_1.compareAnything(labelA, labelB, query.value);\n        }\n        // compare by description\n        if (descriptionA && descriptionB && descriptionA !== descriptionB) {\n            return comparers_1.compareAnything(descriptionA, descriptionB, query.value);\n        }\n        // compare by path\n        if (pathA && pathB && pathA !== pathB) {\n            return comparers_1.compareAnything(pathA, pathB, query.value);\n        }\n        // equal\n        return 0;\n    }\n    exports.fallbackCompare = fallbackCompare;\n});\n",null]}