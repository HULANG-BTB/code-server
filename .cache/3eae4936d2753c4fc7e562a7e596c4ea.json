{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/debugContentProvider.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/debugContentProvider.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/mime\", \"vs/editor/common/services/modelService\", \"vs/editor/common/services/modeService\", \"vs/editor/common/services/resolverService\", \"vs/workbench/contrib/debug/common/debug\", \"vs/workbench/contrib/debug/common/debugSource\", \"vs/editor/common/services/editorWorkerService\", \"vs/editor/common/core/editOperation\", \"vs/editor/common/core/range\", \"vs/base/common/cancellation\"], function (require, exports, nls_1, mime_1, modelService_1, modeService_1, resolverService_1, debug_1, debugSource_1, editorWorkerService_1, editOperation_1, range_1, cancellation_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Debug URI format\n     *\n     * a debug URI represents a Source object and the debug session where the Source comes from.\n     *\n     *       debug:arbitrary_path?session=123e4567-e89b-12d3-a456-426655440000&ref=1016\n     *       \\___/ \\____________/ \\__________________________________________/ \\______/\n     *         |          |                             |                          |\n     *      scheme   source.path                    session id            source.reference\n     *\n     * the arbitrary_path and the session id are encoded with 'encodeURIComponent'\n     *\n     */\n    let DebugContentProvider = class DebugContentProvider {\n        constructor(textModelResolverService, debugService, modelService, modeService, editorWorkerService) {\n            this.debugService = debugService;\n            this.modelService = modelService;\n            this.modeService = modeService;\n            this.editorWorkerService = editorWorkerService;\n            this.pendingUpdates = new Map();\n            textModelResolverService.registerTextModelContentProvider(debug_1.DEBUG_SCHEME, this);\n            DebugContentProvider.INSTANCE = this;\n        }\n        dispose() {\n            this.pendingUpdates.forEach(cancellationSource => cancellationSource.dispose());\n        }\n        provideTextContent(resource) {\n            return this.createOrUpdateContentModel(resource, true);\n        }\n        /**\n         * Reload the model content of the given resource.\n         * If there is no model for the given resource, this method does nothing.\n         */\n        static refreshDebugContent(resource) {\n            if (DebugContentProvider.INSTANCE) {\n                DebugContentProvider.INSTANCE.createOrUpdateContentModel(resource, false);\n            }\n        }\n        /**\n         * Create or reload the model content of the given resource.\n         */\n        createOrUpdateContentModel(resource, createIfNotExists) {\n            const model = this.modelService.getModel(resource);\n            if (!model && !createIfNotExists) {\n                // nothing to do\n                return null;\n            }\n            let session;\n            if (resource.query) {\n                const data = debugSource_1.Source.getEncodedDebugData(resource);\n                session = this.debugService.getModel().getSession(data.sessionId);\n            }\n            if (!session) {\n                // fallback: use focused session\n                session = this.debugService.getViewModel().focusedSession;\n            }\n            if (!session) {\n                return Promise.reject(new Error(nls_1.localize('unable', \"Unable to resolve the resource without a debug session\")));\n            }\n            const createErrModel = (errMsg) => {\n                this.debugService.sourceIsNotAvailable(resource);\n                const languageSelection = this.modeService.create(mime_1.MIME_TEXT);\n                const message = errMsg\n                    ? nls_1.localize('canNotResolveSourceWithError', \"Could not load source '{0}': {1}.\", resource.path, errMsg)\n                    : nls_1.localize('canNotResolveSource', \"Could not load source '{0}'.\", resource.path);\n                return this.modelService.createModel(message, languageSelection, resource);\n            };\n            return session.loadSource(resource).then(response => {\n                if (response && response.body) {\n                    if (model) {\n                        const newContent = response.body.content;\n                        // cancel and dispose an existing update\n                        const cancellationSource = this.pendingUpdates.get(model.id);\n                        if (cancellationSource) {\n                            cancellationSource.cancel();\n                        }\n                        // create and keep update token\n                        const myToken = new cancellation_1.CancellationTokenSource();\n                        this.pendingUpdates.set(model.id, myToken);\n                        // update text model\n                        return this.editorWorkerService.computeMoreMinimalEdits(model.uri, [{ text: newContent, range: model.getFullModelRange() }]).then(edits => {\n                            // remove token\n                            this.pendingUpdates.delete(model.id);\n                            if (!myToken.token.isCancellationRequested && edits && edits.length > 0) {\n                                // use the evil-edit as these models show in readonly-editor only\n                                model.applyEdits(edits.map(edit => editOperation_1.EditOperation.replace(range_1.Range.lift(edit.range), edit.text)));\n                            }\n                            return model;\n                        });\n                    }\n                    else {\n                        // create text model\n                        const mime = response.body.mimeType || mime_1.guessMimeTypes(resource.path)[0];\n                        const languageSelection = this.modeService.create(mime);\n                        return this.modelService.createModel(response.body.content, languageSelection, resource);\n                    }\n                }\n                return createErrModel();\n            }, (err) => createErrModel(err.message));\n        }\n    };\n    DebugContentProvider = __decorate([\n        __param(0, resolverService_1.ITextModelService),\n        __param(1, debug_1.IDebugService),\n        __param(2, modelService_1.IModelService),\n        __param(3, modeService_1.IModeService),\n        __param(4, editorWorkerService_1.IEditorWorkerService)\n    ], DebugContentProvider);\n    exports.DebugContentProvider = DebugContentProvider;\n});\n",null]}