{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/node/ipc.net.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/node/ipc.net.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"net\", \"vs/base/common/event\", \"vs/base/parts/ipc/common/ipc\", \"vs/base/common/path\", \"os\", \"vs/base/common/uuid\", \"vs/base/common/buffer\", \"vs/base/parts/ipc/common/ipc.net\"], function (require, exports, net_1, event_1, ipc_1, path_1, os_1, uuid_1, buffer_1, ipc_net_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class NodeSocket {\n        constructor(socket) {\n            this.socket = socket;\n        }\n        onData(_listener) {\n            const listener = (buff) => _listener(buffer_1.VSBuffer.wrap(buff));\n            this.socket.on('data', listener);\n            return {\n                dispose: () => this.socket.off('data', listener)\n            };\n        }\n        onClose(listener) {\n            this.socket.on('close', listener);\n            return {\n                dispose: () => this.socket.off('close', listener)\n            };\n        }\n        onEnd(listener) {\n            this.socket.on('end', listener);\n            return {\n                dispose: () => this.socket.off('end', listener)\n            };\n        }\n        write(buffer) {\n            // return early if socket has been destroyed in the meantime\n            if (this.socket.destroyed) {\n                return;\n            }\n            // we ignore the returned value from `write` because we would have to cached the data\n            // anyways and nodejs is already doing that for us:\n            // > https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback\n            // > However, the false return value is only advisory and the writable stream will unconditionally\n            // > accept and buffer chunk even if it has not not been allowed to drain.\n            this.socket.write(buffer.buffer);\n        }\n        end() {\n            this.socket.end();\n        }\n    }\n    exports.NodeSocket = NodeSocket;\n    function generateRandomPipeName() {\n        const randomSuffix = uuid_1.generateUuid();\n        if (process.platform === 'win32') {\n            return `\\\\\\\\.\\\\pipe\\\\vscode-ipc-${randomSuffix}-sock`;\n        }\n        else {\n            // Mac/Unix: use socket file\n            return path_1.join(os_1.tmpdir(), `vscode-ipc-${randomSuffix}.sock`);\n        }\n    }\n    exports.generateRandomPipeName = generateRandomPipeName;\n    class Server extends ipc_1.IPCServer {\n        static toClientConnectionEvent(server) {\n            const onConnection = event_1.Event.fromNodeEventEmitter(server, 'connection');\n            return event_1.Event.map(onConnection, socket => ({\n                protocol: new ipc_net_1.Protocol(new NodeSocket(socket)),\n                onDidClientDisconnect: event_1.Event.once(event_1.Event.fromNodeEventEmitter(socket, 'close'))\n            }));\n        }\n        constructor(server) {\n            super(Server.toClientConnectionEvent(server));\n            this.server = server;\n        }\n        dispose() {\n            super.dispose();\n            if (this.server) {\n                this.server.close();\n                this.server = null;\n            }\n        }\n    }\n    exports.Server = Server;\n    function serve(hook) {\n        return new Promise((c, e) => {\n            const server = net_1.createServer();\n            server.on('error', e);\n            server.listen(hook, () => {\n                server.removeListener('error', e);\n                c(new Server(server));\n            });\n        });\n    }\n    exports.serve = serve;\n    function connect(hook, clientId) {\n        return new Promise((c, e) => {\n            const socket = net_1.createConnection(hook, () => {\n                socket.removeListener('error', e);\n                c(ipc_net_1.Client.fromSocket(new NodeSocket(socket), clientId));\n            });\n            socket.once('error', e);\n        });\n    }\n    exports.connect = connect;\n});\n",null]}