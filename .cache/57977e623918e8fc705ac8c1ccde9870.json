{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/common/octicon.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/octicon.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar filters_1 = require(\"vs/base/common/filters\");\nvar strings_1 = require(\"vs/base/common/strings\");\nvar octiconStartMarker = '$(';\nfunction parseOcticons(text) {\n    var firstOcticonIndex = text.indexOf(octiconStartMarker);\n    if (firstOcticonIndex === -1) {\n        return { text: text }; // return early if the word does not include an octicon\n    }\n    return doParseOcticons(text, firstOcticonIndex);\n}\nexports.parseOcticons = parseOcticons;\nfunction doParseOcticons(text, firstOcticonIndex) {\n    var octiconOffsets = [];\n    var textWithoutOcticons = '';\n    function appendChars(chars) {\n        if (chars) {\n            textWithoutOcticons += chars;\n            for (var _i = 0, chars_1 = chars; _i < chars_1.length; _i++) {\n                var _ = chars_1[_i];\n                octiconOffsets.push(octiconsOffset); // make sure to fill in octicon offsets\n            }\n        }\n    }\n    var currentOcticonStart = -1;\n    var currentOcticonValue = '';\n    var octiconsOffset = 0;\n    var char;\n    var nextChar;\n    var offset = firstOcticonIndex;\n    var length = text.length;\n    // Append all characters until the first octicon\n    appendChars(text.substr(0, firstOcticonIndex));\n    // example: $(file-symlink-file) my cool $(other-octicon) entry\n    while (offset < length) {\n        char = text[offset];\n        nextChar = text[offset + 1];\n        // beginning of octicon: some value $( <--\n        if (char === octiconStartMarker[0] && nextChar === octiconStartMarker[1]) {\n            currentOcticonStart = offset;\n            // if we had a previous potential octicon value without\n            // the closing ')', it was actually not an octicon and\n            // so we have to add it to the actual value\n            appendChars(currentOcticonValue);\n            currentOcticonValue = octiconStartMarker;\n            offset++; // jump over '('\n        }\n        // end of octicon: some value $(some-octicon) <--\n        else if (char === ')' && currentOcticonStart !== -1) {\n            var currentOcticonLength = offset - currentOcticonStart + 1; // +1 to include the closing ')'\n            octiconsOffset += currentOcticonLength;\n            currentOcticonStart = -1;\n            currentOcticonValue = '';\n        }\n        // within octicon\n        else if (currentOcticonStart !== -1) {\n            currentOcticonValue += char;\n        }\n        // any value outside of octicons\n        else {\n            appendChars(char);\n        }\n        offset++;\n    }\n    // if we had a previous potential octicon value without\n    // the closing ')', it was actually not an octicon and\n    // so we have to add it to the actual value\n    appendChars(currentOcticonValue);\n    return { text: textWithoutOcticons, octiconOffsets: octiconOffsets };\n}\nfunction matchesFuzzyOcticonAware(query, target, enableSeparateSubstringMatching) {\n    if (enableSeparateSubstringMatching === void 0) { enableSeparateSubstringMatching = false; }\n    var text = target.text, octiconOffsets = target.octiconOffsets;\n    // Return early if there are no octicon markers in the word to match against\n    if (!octiconOffsets || octiconOffsets.length === 0) {\n        return filters_1.matchesFuzzy(query, text, enableSeparateSubstringMatching);\n    }\n    // Trim the word to match against because it could have leading\n    // whitespace now if the word started with an octicon\n    var wordToMatchAgainstWithoutOcticonsTrimmed = strings_1.ltrim(text, ' ');\n    var leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutOcticonsTrimmed.length;\n    // match on value without octicons\n    var matches = filters_1.matchesFuzzy(query, wordToMatchAgainstWithoutOcticonsTrimmed, enableSeparateSubstringMatching);\n    // Map matches back to offsets with octicons and trimming\n    if (matches) {\n        for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {\n            var match = matches_1[_i];\n            var octiconOffset = octiconOffsets[match.start + leadingWhitespaceOffset] /* octicon offsets at index */ + leadingWhitespaceOffset /* overall leading whitespace offset */;\n            match.start += octiconOffset;\n            match.end += octiconOffset;\n        }\n    }\n    return matches;\n}\nexports.matchesFuzzyOcticonAware = matchesFuzzyOcticonAware;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/common/octicon.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/common/octicon.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { matchesFuzzy, IMatch } from 'vs/base/common/filters';\nimport { ltrim } from 'vs/base/common/strings';\n\nconst octiconStartMarker = '$(';\n\nexport interface IParsedOcticons {\n\ttext: string;\n\tocticonOffsets?: number[];\n}\n\nexport function parseOcticons(text: string): IParsedOcticons {\n\tconst firstOcticonIndex = text.indexOf(octiconStartMarker);\n\tif (firstOcticonIndex === -1) {\n\t\treturn { text }; // return early if the word does not include an octicon\n\t}\n\n\treturn doParseOcticons(text, firstOcticonIndex);\n}\n\nfunction doParseOcticons(text: string, firstOcticonIndex: number): IParsedOcticons {\n\tconst octiconOffsets: number[] = [];\n\tlet textWithoutOcticons: string = '';\n\n\tfunction appendChars(chars: string) {\n\t\tif (chars) {\n\t\t\ttextWithoutOcticons += chars;\n\n\t\t\tfor (const _ of chars) {\n\t\t\t\tocticonOffsets.push(octiconsOffset); // make sure to fill in octicon offsets\n\t\t\t}\n\t\t}\n\t}\n\n\tlet currentOcticonStart = -1;\n\tlet currentOcticonValue: string = '';\n\tlet octiconsOffset = 0;\n\n\tlet char: string;\n\tlet nextChar: string;\n\n\tlet offset = firstOcticonIndex;\n\tconst length = text.length;\n\n\t// Append all characters until the first octicon\n\tappendChars(text.substr(0, firstOcticonIndex));\n\n\t// example: $(file-symlink-file) my cool $(other-octicon) entry\n\twhile (offset < length) {\n\t\tchar = text[offset];\n\t\tnextChar = text[offset + 1];\n\n\t\t// beginning of octicon: some value $( <--\n\t\tif (char === octiconStartMarker[0] && nextChar === octiconStartMarker[1]) {\n\t\t\tcurrentOcticonStart = offset;\n\n\t\t\t// if we had a previous potential octicon value without\n\t\t\t// the closing ')', it was actually not an octicon and\n\t\t\t// so we have to add it to the actual value\n\t\t\tappendChars(currentOcticonValue);\n\n\t\t\tcurrentOcticonValue = octiconStartMarker;\n\n\t\t\toffset++; // jump over '('\n\t\t}\n\n\t\t// end of octicon: some value $(some-octicon) <--\n\t\telse if (char === ')' && currentOcticonStart !== -1) {\n\t\t\tconst currentOcticonLength = offset - currentOcticonStart + 1; // +1 to include the closing ')'\n\t\t\tocticonsOffset += currentOcticonLength;\n\t\t\tcurrentOcticonStart = -1;\n\t\t\tcurrentOcticonValue = '';\n\t\t}\n\n\t\t// within octicon\n\t\telse if (currentOcticonStart !== -1) {\n\t\t\tcurrentOcticonValue += char;\n\t\t}\n\n\t\t// any value outside of octicons\n\t\telse {\n\t\t\tappendChars(char);\n\t\t}\n\n\t\toffset++;\n\t}\n\n\t// if we had a previous potential octicon value without\n\t// the closing ')', it was actually not an octicon and\n\t// so we have to add it to the actual value\n\tappendChars(currentOcticonValue);\n\n\treturn { text: textWithoutOcticons, octiconOffsets };\n}\n\nexport function matchesFuzzyOcticonAware(query: string, target: IParsedOcticons, enableSeparateSubstringMatching = false): IMatch[] | null {\n\tconst { text, octiconOffsets } = target;\n\n\t// Return early if there are no octicon markers in the word to match against\n\tif (!octiconOffsets || octiconOffsets.length === 0) {\n\t\treturn matchesFuzzy(query, text, enableSeparateSubstringMatching);\n\t}\n\n\t// Trim the word to match against because it could have leading\n\t// whitespace now if the word started with an octicon\n\tconst wordToMatchAgainstWithoutOcticonsTrimmed = ltrim(text, ' ');\n\tconst leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutOcticonsTrimmed.length;\n\n\t// match on value without octicons\n\tconst matches = matchesFuzzy(query, wordToMatchAgainstWithoutOcticonsTrimmed, enableSeparateSubstringMatching);\n\n\t// Map matches back to offsets with octicons and trimming\n\tif (matches) {\n\t\tfor (const match of matches) {\n\t\t\tconst octiconOffset = octiconOffsets[match.start + leadingWhitespaceOffset] /* octicon offsets at index */ + leadingWhitespaceOffset /* overall leading whitespace offset */;\n\t\t\tmatch.start += octiconOffset;\n\t\t\tmatch.end += octiconOffset;\n\t\t}\n\t}\n\n\treturn matches;\n}"]}]}