{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/common/editor.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/common/editor.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/event\", \"vs/base/common/objects\", \"vs/base/common/types\", \"vs/base/common/lifecycle\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/contextkey/common/contextkey\", \"vs/platform/registry/common/platform\", \"vs/base/common/network\", \"vs/base/common/actions\"], function (require, exports, event_1, objects, types, lifecycle_1, instantiation_1, contextkey_1, platform_1, network_1, actions_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.ActiveEditorContext = new contextkey_1.RawContextKey('activeEditor', null);\n    exports.EditorsVisibleContext = new contextkey_1.RawContextKey('editorIsOpen', false);\n    exports.EditorGroupActiveEditorDirtyContext = new contextkey_1.RawContextKey('groupActiveEditorDirty', false);\n    exports.NoEditorsVisibleContext = exports.EditorsVisibleContext.toNegated();\n    exports.TextCompareEditorVisibleContext = new contextkey_1.RawContextKey('textCompareEditorVisible', false);\n    exports.TextCompareEditorActiveContext = new contextkey_1.RawContextKey('textCompareEditorActive', false);\n    exports.ActiveEditorGroupEmptyContext = new contextkey_1.RawContextKey('activeEditorGroupEmpty', false);\n    exports.MultipleEditorGroupsContext = new contextkey_1.RawContextKey('multipleEditorGroups', false);\n    exports.SingleEditorGroupsContext = exports.MultipleEditorGroupsContext.toNegated();\n    exports.InEditorZenModeContext = new contextkey_1.RawContextKey('inZenMode', false);\n    exports.SplitEditorsVertically = new contextkey_1.RawContextKey('splitEditorsVertically', false);\n    /**\n     * Text diff editor id.\n     */\n    exports.TEXT_DIFF_EDITOR_ID = 'workbench.editors.textDiffEditor';\n    /**\n     * Binary diff editor id.\n     */\n    exports.BINARY_DIFF_EDITOR_ID = 'workbench.editors.binaryResourceDiffEditor';\n    var Verbosity;\n    (function (Verbosity) {\n        Verbosity[Verbosity[\"SHORT\"] = 0] = \"SHORT\";\n        Verbosity[Verbosity[\"MEDIUM\"] = 1] = \"MEDIUM\";\n        Verbosity[Verbosity[\"LONG\"] = 2] = \"LONG\";\n    })(Verbosity = exports.Verbosity || (exports.Verbosity = {}));\n    /**\n     * Editor inputs are lightweight objects that can be passed to the workbench API to open inside the editor part.\n     * Each editor input is mapped to an editor that is capable of opening it through the Platform facade.\n     */\n    class EditorInput extends lifecycle_1.Disposable {\n        constructor() {\n            super(...arguments);\n            this._onDidChangeDirty = this._register(new event_1.Emitter());\n            this._onDidChangeLabel = this._register(new event_1.Emitter());\n            this._onDispose = this._register(new event_1.Emitter());\n            this.disposed = false;\n        }\n        get onDidChangeDirty() { return this._onDidChangeDirty.event; }\n        get onDidChangeLabel() { return this._onDidChangeLabel.event; }\n        get onDispose() { return this._onDispose.event; }\n        /**\n         * Returns the associated resource of this input if any.\n         */\n        getResource() {\n            return null;\n        }\n        /**\n         * Returns the name of this input that can be shown to the user. Examples include showing the name of the input\n         * above the editor area when the input is shown.\n         */\n        getName() {\n            return null;\n        }\n        /**\n         * Returns the description of this input that can be shown to the user. Examples include showing the description of\n         * the input above the editor area to the side of the name of the input.\n         */\n        getDescription(verbosity) {\n            return null;\n        }\n        /**\n         * Returns the title of this input that can be shown to the user. Examples include showing the title of\n         * the input above the editor area as hover over the input label.\n         */\n        getTitle(verbosity) {\n            return this.getName();\n        }\n        /**\n         * Returns the preferred editor for this input. A list of candidate editors is passed in that whee registered\n         * for the input. This allows subclasses to decide late which editor to use for the input on a case by case basis.\n         */\n        getPreferredEditorId(candidates) {\n            if (candidates && candidates.length > 0) {\n                return candidates[0];\n            }\n            return null;\n        }\n        /**\n         * Returns a descriptor suitable for telemetry events.\n         *\n         * Subclasses should extend if they can contribute.\n         */\n        getTelemetryDescriptor() {\n            /* __GDPR__FRAGMENT__\n                \"EditorTelemetryDescriptor\" : {\n                    \"typeId\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                }\n            */\n            return { typeId: this.getTypeId() };\n        }\n        /**\n         * An editor that is dirty will be asked to be saved once it closes.\n         */\n        isDirty() {\n            return false;\n        }\n        /**\n         * Subclasses should bring up a proper dialog for the user if the editor is dirty and return the result.\n         */\n        confirmSave() {\n            return Promise.resolve(ConfirmResult.DONT_SAVE);\n        }\n        /**\n         * Saves the editor if it is dirty. Subclasses return a promise with a boolean indicating the success of the operation.\n         */\n        save() {\n            return Promise.resolve(true);\n        }\n        /**\n         * Reverts the editor if it is dirty. Subclasses return a promise with a boolean indicating the success of the operation.\n         */\n        revert(options) {\n            return Promise.resolve(true);\n        }\n        /**\n         * Called when this input is no longer opened in any editor. Subclasses can free resources as needed.\n         */\n        close() {\n            this.dispose();\n        }\n        /**\n         * Subclasses can set this to false if it does not make sense to split the editor input.\n         */\n        supportsSplitEditor() {\n            return true;\n        }\n        /**\n         * Returns true if this input is identical to the otherInput.\n         */\n        matches(otherInput) {\n            return this === otherInput;\n        }\n        /**\n         * Returns whether this input was disposed or not.\n         */\n        isDisposed() {\n            return this.disposed;\n        }\n        /**\n         * Called when an editor input is no longer needed. Allows to free up any resources taken by\n         * resolving the editor input.\n         */\n        dispose() {\n            this.disposed = true;\n            this._onDispose.fire();\n            super.dispose();\n        }\n    }\n    exports.EditorInput = EditorInput;\n    var ConfirmResult;\n    (function (ConfirmResult) {\n        ConfirmResult[ConfirmResult[\"SAVE\"] = 0] = \"SAVE\";\n        ConfirmResult[ConfirmResult[\"DONT_SAVE\"] = 1] = \"DONT_SAVE\";\n        ConfirmResult[ConfirmResult[\"CANCEL\"] = 2] = \"CANCEL\";\n    })(ConfirmResult = exports.ConfirmResult || (exports.ConfirmResult = {}));\n    var EncodingMode;\n    (function (EncodingMode) {\n        /**\n         * Instructs the encoding support to encode the current input with the provided encoding\n         */\n        EncodingMode[EncodingMode[\"Encode\"] = 0] = \"Encode\";\n        /**\n         * Instructs the encoding support to decode the current input with the provided encoding\n         */\n        EncodingMode[EncodingMode[\"Decode\"] = 1] = \"Decode\";\n    })(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));\n    /**\n     * Side by side editor inputs that have a master and details side.\n     */\n    class SideBySideEditorInput extends EditorInput {\n        constructor(name, description, _details, _master) {\n            super();\n            this.name = name;\n            this.description = description;\n            this._details = _details;\n            this._master = _master;\n            this.registerListeners();\n        }\n        get master() {\n            return this._master;\n        }\n        get details() {\n            return this._details;\n        }\n        isDirty() {\n            return this.master.isDirty();\n        }\n        confirmSave() {\n            return this.master.confirmSave();\n        }\n        save() {\n            return this.master.save();\n        }\n        revert() {\n            return this.master.revert();\n        }\n        getTelemetryDescriptor() {\n            const descriptor = this.master.getTelemetryDescriptor();\n            return objects.assign(descriptor, super.getTelemetryDescriptor());\n        }\n        registerListeners() {\n            // When the details or master input gets disposed, dispose this diff editor input\n            const onceDetailsDisposed = event_1.Event.once(this.details.onDispose);\n            this._register(onceDetailsDisposed(() => {\n                if (!this.isDisposed()) {\n                    this.dispose();\n                }\n            }));\n            const onceMasterDisposed = event_1.Event.once(this.master.onDispose);\n            this._register(onceMasterDisposed(() => {\n                if (!this.isDisposed()) {\n                    this.dispose();\n                }\n            }));\n            // Reemit some events from the master side to the outside\n            this._register(this.master.onDidChangeDirty(() => this._onDidChangeDirty.fire()));\n            this._register(this.master.onDidChangeLabel(() => this._onDidChangeLabel.fire()));\n        }\n        resolve() {\n            return Promise.resolve(null);\n        }\n        getTypeId() {\n            return SideBySideEditorInput.ID;\n        }\n        getName() {\n            return this.name;\n        }\n        getDescription() {\n            return this.description;\n        }\n        matches(otherInput) {\n            if (super.matches(otherInput) === true) {\n                return true;\n            }\n            if (otherInput) {\n                if (!(otherInput instanceof SideBySideEditorInput)) {\n                    return false;\n                }\n                const otherDiffInput = otherInput;\n                return this.details.matches(otherDiffInput.details) && this.master.matches(otherDiffInput.master);\n            }\n            return false;\n        }\n    }\n    SideBySideEditorInput.ID = 'workbench.editorinputs.sidebysideEditorInput';\n    exports.SideBySideEditorInput = SideBySideEditorInput;\n    /**\n     * The editor model is the heavyweight counterpart of editor input. Depending on the editor input, it\n     * connects to the disk to retrieve content and may allow for saving it back or reverting it. Editor models\n     * are typically cached for some while because they are expensive to construct.\n     */\n    class EditorModel extends lifecycle_1.Disposable {\n        constructor() {\n            super(...arguments);\n            this._onDispose = this._register(new event_1.Emitter());\n        }\n        get onDispose() { return this._onDispose.event; }\n        /**\n         * Causes this model to load returning a promise when loading is completed.\n         */\n        load() {\n            return Promise.resolve(this);\n        }\n        /**\n         * Returns whether this model was loaded or not.\n         */\n        isResolved() {\n            return true;\n        }\n        /**\n         * Subclasses should implement to free resources that have been claimed through loading.\n         */\n        dispose() {\n            this._onDispose.fire();\n            super.dispose();\n        }\n    }\n    exports.EditorModel = EditorModel;\n    function isEditorInputWithOptions(obj) {\n        const editorInputWithOptions = obj;\n        return !!editorInputWithOptions && !!editorInputWithOptions.editor;\n    }\n    exports.isEditorInputWithOptions = isEditorInputWithOptions;\n    /**\n     * The editor options is the base class of options that can be passed in when opening an editor.\n     */\n    class EditorOptions {\n        /**\n         * Helper to create EditorOptions inline.\n         */\n        static create(settings) {\n            const options = new EditorOptions();\n            options.preserveFocus = settings.preserveFocus;\n            options.forceReload = settings.forceReload;\n            options.revealIfVisible = settings.revealIfVisible;\n            options.revealIfOpened = settings.revealIfOpened;\n            options.pinned = settings.pinned;\n            options.index = settings.index;\n            options.inactive = settings.inactive;\n            options.ignoreError = settings.ignoreError;\n            return options;\n        }\n    }\n    exports.EditorOptions = EditorOptions;\n    /**\n     * Base Text Editor Options.\n     */\n    class TextEditorOptions extends EditorOptions {\n        static from(input) {\n            if (!input || !input.options) {\n                return undefined;\n            }\n            return TextEditorOptions.create(input.options);\n        }\n        /**\n         * Helper to convert options bag to real class\n         */\n        static create(options = Object.create(null)) {\n            const textEditorOptions = new TextEditorOptions();\n            if (options.selection) {\n                const selection = options.selection;\n                textEditorOptions.selection(selection.startLineNumber, selection.startColumn, selection.endLineNumber, selection.endColumn);\n            }\n            if (options.viewState) {\n                textEditorOptions.editorViewState = options.viewState;\n            }\n            if (options.forceReload) {\n                textEditorOptions.forceReload = true;\n            }\n            if (options.revealIfVisible) {\n                textEditorOptions.revealIfVisible = true;\n            }\n            if (options.revealIfOpened) {\n                textEditorOptions.revealIfOpened = true;\n            }\n            if (options.preserveFocus) {\n                textEditorOptions.preserveFocus = true;\n            }\n            if (options.revealInCenterIfOutsideViewport) {\n                textEditorOptions.revealInCenterIfOutsideViewport = true;\n            }\n            if (options.pinned) {\n                textEditorOptions.pinned = true;\n            }\n            if (options.inactive) {\n                textEditorOptions.inactive = true;\n            }\n            if (options.ignoreError) {\n                textEditorOptions.ignoreError = true;\n            }\n            if (typeof options.index === 'number') {\n                textEditorOptions.index = options.index;\n            }\n            return textEditorOptions;\n        }\n        /**\n         * Returns if this options object has objects defined for the editor.\n         */\n        hasOptionsDefined() {\n            return !!this.editorViewState || (!types.isUndefinedOrNull(this.startLineNumber) && !types.isUndefinedOrNull(this.startColumn));\n        }\n        /**\n         * Tells the editor to set show the given selection when the editor is being opened.\n         */\n        selection(startLineNumber, startColumn, endLineNumber = startLineNumber, endColumn = startColumn) {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n            return this;\n        }\n        /**\n         * Create a TextEditorOptions inline to be used when the editor is opening.\n         */\n        static fromEditor(editor, settings) {\n            const options = TextEditorOptions.create(settings);\n            // View state\n            options.editorViewState = editor.saveViewState();\n            return options;\n        }\n        /**\n         * Apply the view state or selection to the given editor.\n         *\n         * @return if something was applied\n         */\n        apply(editor, scrollType) {\n            // View state\n            return this.applyViewState(editor, scrollType);\n        }\n        applyViewState(editor, scrollType) {\n            let gotApplied = false;\n            // First try viewstate\n            if (this.editorViewState) {\n                editor.restoreViewState(this.editorViewState);\n                gotApplied = true;\n            }\n            // Otherwise check for selection\n            else if (!types.isUndefinedOrNull(this.startLineNumber) && !types.isUndefinedOrNull(this.startColumn)) {\n                // Select\n                if (!types.isUndefinedOrNull(this.endLineNumber) && !types.isUndefinedOrNull(this.endColumn)) {\n                    const range = {\n                        startLineNumber: this.startLineNumber,\n                        startColumn: this.startColumn,\n                        endLineNumber: this.endLineNumber,\n                        endColumn: this.endColumn\n                    };\n                    editor.setSelection(range);\n                    if (this.revealInCenterIfOutsideViewport) {\n                        editor.revealRangeInCenterIfOutsideViewport(range, scrollType);\n                    }\n                    else {\n                        editor.revealRangeInCenter(range, scrollType);\n                    }\n                }\n                // Reveal\n                else {\n                    const pos = {\n                        lineNumber: this.startLineNumber,\n                        column: this.startColumn\n                    };\n                    editor.setPosition(pos);\n                    if (this.revealInCenterIfOutsideViewport) {\n                        editor.revealPositionInCenterIfOutsideViewport(pos, scrollType);\n                    }\n                    else {\n                        editor.revealPositionInCenter(pos, scrollType);\n                    }\n                }\n                gotApplied = true;\n            }\n            return gotApplied;\n        }\n    }\n    exports.TextEditorOptions = TextEditorOptions;\n    class EditorCommandsContextActionRunner extends actions_1.ActionRunner {\n        constructor(context) {\n            super();\n            this.context = context;\n        }\n        run(action, context) {\n            return super.run(action, this.context);\n        }\n    }\n    exports.EditorCommandsContextActionRunner = EditorCommandsContextActionRunner;\n    function toResource(editor, options) {\n        if (!editor) {\n            return null;\n        }\n        // Check for side by side if we are asked to\n        if (options && options.supportSideBySide && editor instanceof SideBySideEditorInput) {\n            editor = editor.master;\n        }\n        const resource = editor.getResource();\n        if (!options || !options.filter) {\n            return resource; // return early if no filter is specified\n        }\n        if (!resource) {\n            return null;\n        }\n        let includeFiles;\n        let includeUntitled;\n        if (Array.isArray(options.filter)) {\n            includeFiles = (options.filter.indexOf(network_1.Schemas.file) >= 0);\n            includeUntitled = (options.filter.indexOf(network_1.Schemas.untitled) >= 0);\n        }\n        else {\n            includeFiles = (options.filter === network_1.Schemas.file);\n            includeUntitled = (options.filter === network_1.Schemas.untitled);\n        }\n        if (includeFiles && resource.scheme === network_1.Schemas.file) {\n            return resource;\n        }\n        if (includeUntitled && resource.scheme === network_1.Schemas.untitled) {\n            return resource;\n        }\n        return null;\n    }\n    exports.toResource = toResource;\n    var CloseDirection;\n    (function (CloseDirection) {\n        CloseDirection[CloseDirection[\"LEFT\"] = 0] = \"LEFT\";\n        CloseDirection[CloseDirection[\"RIGHT\"] = 1] = \"RIGHT\";\n    })(CloseDirection = exports.CloseDirection || (exports.CloseDirection = {}));\n    class EditorInputFactoryRegistry {\n        constructor() {\n            this.editorInputFactoryConstructors = Object.create(null);\n            this.editorInputFactoryInstances = Object.create(null);\n        }\n        start(accessor) {\n            this.instantiationService = accessor.get(instantiation_1.IInstantiationService);\n            for (let key in this.editorInputFactoryConstructors) {\n                const element = this.editorInputFactoryConstructors[key];\n                this.createEditorInputFactory(key, element);\n            }\n            this.editorInputFactoryConstructors = Object.create(null);\n        }\n        createEditorInputFactory(editorInputId, ctor) {\n            const instance = this.instantiationService.createInstance(ctor);\n            this.editorInputFactoryInstances[editorInputId] = instance;\n        }\n        registerFileInputFactory(factory) {\n            this.fileInputFactory = factory;\n        }\n        getFileInputFactory() {\n            return this.fileInputFactory;\n        }\n        registerEditorInputFactory(editorInputId, ctor) {\n            if (!this.instantiationService) {\n                this.editorInputFactoryConstructors[editorInputId] = ctor;\n            }\n            else {\n                this.createEditorInputFactory(editorInputId, ctor);\n            }\n        }\n        getEditorInputFactory(editorInputId) {\n            return this.editorInputFactoryInstances[editorInputId];\n        }\n    }\n    exports.Extensions = {\n        EditorInputFactories: 'workbench.contributions.editor.inputFactories'\n    };\n    platform_1.Registry.add(exports.Extensions.EditorInputFactories, new EditorInputFactoryRegistry());\n});\n",null]}