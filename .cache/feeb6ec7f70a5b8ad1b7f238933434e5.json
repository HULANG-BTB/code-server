{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/viewModel/splitLinesCollection.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewModel/splitLinesCollection.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\", \"vs/editor/common/model/textModel\", \"vs/editor/common/view/viewEvents\", \"vs/editor/common/viewModel/prefixSumComputer\", \"vs/editor/common/viewModel/viewModel\"], function (require, exports, position_1, range_1, textModel_1, viewEvents, prefixSumComputer_1, viewModel_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class OutputPosition {\n        constructor(outputLineIndex, outputOffset) {\n            this.outputLineIndex = outputLineIndex;\n            this.outputOffset = outputOffset;\n        }\n    }\n    exports.OutputPosition = OutputPosition;\n    class CoordinatesConverter {\n        constructor(lines) {\n            this._lines = lines;\n        }\n        // View -> Model conversion and related methods\n        convertViewPositionToModelPosition(viewPosition) {\n            return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n        }\n        convertViewRangeToModelRange(viewRange) {\n            let start = this._lines.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n            let end = this._lines.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n            return new range_1.Range(start.lineNumber, start.column, end.lineNumber, end.column);\n        }\n        validateViewPosition(viewPosition, expectedModelPosition) {\n            return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n        }\n        validateViewRange(viewRange, expectedModelRange) {\n            const validViewStart = this._lines.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n            const validViewEnd = this._lines.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n            return new range_1.Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n        }\n        // Model -> View conversion and related methods\n        convertModelPositionToViewPosition(modelPosition) {\n            return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);\n        }\n        convertModelRangeToViewRange(modelRange) {\n            let start = this._lines.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn);\n            let end = this._lines.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn);\n            return new range_1.Range(start.lineNumber, start.column, end.lineNumber, end.column);\n        }\n        modelPositionIsVisible(modelPosition) {\n            return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n        }\n    }\n    exports.CoordinatesConverter = CoordinatesConverter;\n    var IndentGuideRepeatOption;\n    (function (IndentGuideRepeatOption) {\n        IndentGuideRepeatOption[IndentGuideRepeatOption[\"BlockNone\"] = 0] = \"BlockNone\";\n        IndentGuideRepeatOption[IndentGuideRepeatOption[\"BlockSubsequent\"] = 1] = \"BlockSubsequent\";\n        IndentGuideRepeatOption[IndentGuideRepeatOption[\"BlockAll\"] = 2] = \"BlockAll\";\n    })(IndentGuideRepeatOption || (IndentGuideRepeatOption = {}));\n    class SplitLinesCollection {\n        constructor(model, linePositionMapperFactory, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent) {\n            this.model = model;\n            this._validModelVersionId = -1;\n            this.tabSize = tabSize;\n            this.wrappingColumn = wrappingColumn;\n            this.columnsForFullWidthChar = columnsForFullWidthChar;\n            this.wrappingIndent = wrappingIndent;\n            this.linePositionMapperFactory = linePositionMapperFactory;\n            this._constructLines(true);\n        }\n        dispose() {\n            this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, []);\n        }\n        createCoordinatesConverter() {\n            return new CoordinatesConverter(this);\n        }\n        _ensureValidState() {\n            let modelVersion = this.model.getVersionId();\n            if (modelVersion !== this._validModelVersionId) {\n                // This is pretty bad, it means we lost track of the model...\n                throw new Error(`ViewModel is out of sync with Model!`);\n            }\n            if (this.lines.length !== this.model.getLineCount()) {\n                // This is pretty bad, it means we lost track of the model...\n                this._constructLines(false);\n            }\n        }\n        _constructLines(resetHiddenAreas) {\n            this.lines = [];\n            if (resetHiddenAreas) {\n                this.hiddenAreasIds = [];\n            }\n            let linesContent = this.model.getLinesContent();\n            let lineCount = linesContent.length;\n            let values = new Uint32Array(lineCount);\n            let hiddenAreas = this.hiddenAreasIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(range_1.Range.compareRangesUsingStarts);\n            let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n            let hiddenAreaIdx = -1;\n            let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n            for (let i = 0; i < lineCount; i++) {\n                let lineNumber = i + 1;\n                if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                    hiddenAreaIdx++;\n                    hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                    hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                    nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n                }\n                let isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n                let line = createSplitLine(this.linePositionMapperFactory, linesContent[i], this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, !isInHiddenArea);\n                values[i] = line.getViewLineCount();\n                this.lines[i] = line;\n            }\n            this._validModelVersionId = this.model.getVersionId();\n            this.prefixSumComputer = new prefixSumComputer_1.PrefixSumComputerWithCache(values);\n        }\n        getHiddenAreas() {\n            return this.hiddenAreasIds.map((decId) => {\n                return this.model.getDecorationRange(decId);\n            });\n        }\n        _reduceRanges(_ranges) {\n            if (_ranges.length === 0) {\n                return [];\n            }\n            let ranges = _ranges.map(r => this.model.validateRange(r)).sort(range_1.Range.compareRangesUsingStarts);\n            let result = [];\n            let currentRangeStart = ranges[0].startLineNumber;\n            let currentRangeEnd = ranges[0].endLineNumber;\n            for (let i = 1, len = ranges.length; i < len; i++) {\n                let range = ranges[i];\n                if (range.startLineNumber > currentRangeEnd + 1) {\n                    result.push(new range_1.Range(currentRangeStart, 1, currentRangeEnd, 1));\n                    currentRangeStart = range.startLineNumber;\n                    currentRangeEnd = range.endLineNumber;\n                }\n                else if (range.endLineNumber > currentRangeEnd) {\n                    currentRangeEnd = range.endLineNumber;\n                }\n            }\n            result.push(new range_1.Range(currentRangeStart, 1, currentRangeEnd, 1));\n            return result;\n        }\n        setHiddenAreas(_ranges) {\n            let newRanges = this._reduceRanges(_ranges);\n            // BEGIN TODO@Martin: Please stop calling this method on each model change!\n            let oldRanges = this.hiddenAreasIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(range_1.Range.compareRangesUsingStarts);\n            if (newRanges.length === oldRanges.length) {\n                let hasDifference = false;\n                for (let i = 0; i < newRanges.length; i++) {\n                    if (!newRanges[i].equalsRange(oldRanges[i])) {\n                        hasDifference = true;\n                        break;\n                    }\n                }\n                if (!hasDifference) {\n                    return false;\n                }\n            }\n            // END TODO@Martin: Please stop calling this method on each model change!\n            let newDecorations = [];\n            for (const newRange of newRanges) {\n                newDecorations.push({\n                    range: newRange,\n                    options: textModel_1.ModelDecorationOptions.EMPTY\n                });\n            }\n            this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, newDecorations);\n            let hiddenAreas = newRanges;\n            let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n            let hiddenAreaIdx = -1;\n            let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;\n            let hasVisibleLine = false;\n            for (let i = 0; i < this.lines.length; i++) {\n                let lineNumber = i + 1;\n                if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                    hiddenAreaIdx++;\n                    hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                    hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                    nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;\n                }\n                let lineChanged = false;\n                if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n                    // Line should be hidden\n                    if (this.lines[i].isVisible()) {\n                        this.lines[i] = this.lines[i].setVisible(false);\n                        lineChanged = true;\n                    }\n                }\n                else {\n                    hasVisibleLine = true;\n                    // Line should be visible\n                    if (!this.lines[i].isVisible()) {\n                        this.lines[i] = this.lines[i].setVisible(true);\n                        lineChanged = true;\n                    }\n                }\n                if (lineChanged) {\n                    let newOutputLineCount = this.lines[i].getViewLineCount();\n                    this.prefixSumComputer.changeValue(i, newOutputLineCount);\n                }\n            }\n            if (!hasVisibleLine) {\n                // Cannot have everything be hidden => reveal everything!\n                this.setHiddenAreas([]);\n            }\n            return true;\n        }\n        modelPositionIsVisible(modelLineNumber, _modelColumn) {\n            if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {\n                // invalid arguments\n                return false;\n            }\n            return this.lines[modelLineNumber - 1].isVisible();\n        }\n        setTabSize(newTabSize) {\n            if (this.tabSize === newTabSize) {\n                return false;\n            }\n            this.tabSize = newTabSize;\n            this._constructLines(false);\n            return true;\n        }\n        setWrappingSettings(wrappingIndent, wrappingColumn, columnsForFullWidthChar) {\n            if (this.wrappingIndent === wrappingIndent && this.wrappingColumn === wrappingColumn && this.columnsForFullWidthChar === columnsForFullWidthChar) {\n                return false;\n            }\n            this.wrappingIndent = wrappingIndent;\n            this.wrappingColumn = wrappingColumn;\n            this.columnsForFullWidthChar = columnsForFullWidthChar;\n            this._constructLines(false);\n            return true;\n        }\n        onModelFlushed() {\n            this._constructLines(true);\n        }\n        onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n            if (versionId <= this._validModelVersionId) {\n                // Here we check for versionId in case the lines were reconstructed in the meantime.\n                // We don't want to apply stale change events on top of a newer read model state.\n                return null;\n            }\n            let outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);\n            let outputToLineNumber = this.prefixSumComputer.getAccumulatedValue(toLineNumber - 1);\n            this.lines.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n            this.prefixSumComputer.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n            return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n        }\n        onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, text) {\n            if (versionId <= this._validModelVersionId) {\n                // Here we check for versionId in case the lines were reconstructed in the meantime.\n                // We don't want to apply stale change events on top of a newer read model state.\n                return null;\n            }\n            let hiddenAreas = this.getHiddenAreas();\n            let isInHiddenArea = false;\n            let testPosition = new position_1.Position(fromLineNumber, 1);\n            for (const hiddenArea of hiddenAreas) {\n                if (hiddenArea.containsPosition(testPosition)) {\n                    isInHiddenArea = true;\n                    break;\n                }\n            }\n            let outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);\n            let totalOutputLineCount = 0;\n            let insertLines = [];\n            let insertPrefixSumValues = new Uint32Array(text.length);\n            for (let i = 0, len = text.length; i < len; i++) {\n                let line = createSplitLine(this.linePositionMapperFactory, text[i], this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, !isInHiddenArea);\n                insertLines.push(line);\n                let outputLineCount = line.getViewLineCount();\n                totalOutputLineCount += outputLineCount;\n                insertPrefixSumValues[i] = outputLineCount;\n            }\n            // TODO@Alex: use arrays.arrayInsert\n            this.lines = this.lines.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.lines.slice(fromLineNumber - 1));\n            this.prefixSumComputer.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n            return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n        }\n        onModelLineChanged(versionId, lineNumber, newText) {\n            if (versionId <= this._validModelVersionId) {\n                // Here we check for versionId in case the lines were reconstructed in the meantime.\n                // We don't want to apply stale change events on top of a newer read model state.\n                return [false, null, null, null];\n            }\n            let lineIndex = lineNumber - 1;\n            let oldOutputLineCount = this.lines[lineIndex].getViewLineCount();\n            let isVisible = this.lines[lineIndex].isVisible();\n            let line = createSplitLine(this.linePositionMapperFactory, newText, this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, isVisible);\n            this.lines[lineIndex] = line;\n            let newOutputLineCount = this.lines[lineIndex].getViewLineCount();\n            let lineMappingChanged = false;\n            let changeFrom = 0;\n            let changeTo = -1;\n            let insertFrom = 0;\n            let insertTo = -1;\n            let deleteFrom = 0;\n            let deleteTo = -1;\n            if (oldOutputLineCount > newOutputLineCount) {\n                changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\n                changeTo = changeFrom + newOutputLineCount - 1;\n                deleteFrom = changeTo + 1;\n                deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n                lineMappingChanged = true;\n            }\n            else if (oldOutputLineCount < newOutputLineCount) {\n                changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\n                changeTo = changeFrom + oldOutputLineCount - 1;\n                insertFrom = changeTo + 1;\n                insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n                lineMappingChanged = true;\n            }\n            else {\n                changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\n                changeTo = changeFrom + newOutputLineCount - 1;\n            }\n            this.prefixSumComputer.changeValue(lineIndex, newOutputLineCount);\n            const viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo) : null);\n            const viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n            const viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n            return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n        }\n        acceptVersionId(versionId) {\n            this._validModelVersionId = versionId;\n            if (this.lines.length === 1 && !this.lines[0].isVisible()) {\n                // At least one line must be visible => reset hidden areas\n                this.setHiddenAreas([]);\n            }\n        }\n        getViewLineCount() {\n            this._ensureValidState();\n            return this.prefixSumComputer.getTotalValue();\n        }\n        _toValidViewLineNumber(viewLineNumber) {\n            if (viewLineNumber < 1) {\n                return 1;\n            }\n            let viewLineCount = this.getViewLineCount();\n            if (viewLineNumber > viewLineCount) {\n                return viewLineCount;\n            }\n            return viewLineNumber;\n        }\n        /**\n         * Gives a hint that a lot of requests are about to come in for these line numbers.\n         */\n        warmUpLookupCache(viewStartLineNumber, viewEndLineNumber) {\n            this.prefixSumComputer.warmUpCache(viewStartLineNumber - 1, viewEndLineNumber - 1);\n        }\n        getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n            this._ensureValidState();\n            viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n            minLineNumber = this._toValidViewLineNumber(minLineNumber);\n            maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n            const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n            const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n            const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n            const result = this.model.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n            const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n            const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n            return {\n                startLineNumber: viewStartPosition.lineNumber,\n                endLineNumber: viewEndPosition.lineNumber,\n                indent: result.indent\n            };\n        }\n        getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n            this._ensureValidState();\n            viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n            viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n            const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n            const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n            let result = [];\n            let resultRepeatCount = [];\n            let resultRepeatOption = [];\n            const modelStartLineIndex = modelStart.lineNumber - 1;\n            const modelEndLineIndex = modelEnd.lineNumber - 1;\n            let reqStart = null;\n            for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n                const line = this.lines[modelLineIndex];\n                if (line.isVisible()) {\n                    let viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                    let viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n                    let count = viewLineEndIndex - viewLineStartIndex + 1;\n                    let option = IndentGuideRepeatOption.BlockNone;\n                    if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n                        // wrapped lines should block indent guides\n                        option = (viewLineStartIndex === 0 ? IndentGuideRepeatOption.BlockSubsequent : IndentGuideRepeatOption.BlockAll);\n                    }\n                    resultRepeatCount.push(count);\n                    resultRepeatOption.push(option);\n                    // merge into previous request\n                    if (reqStart === null) {\n                        reqStart = new position_1.Position(modelLineIndex + 1, 0);\n                    }\n                }\n                else {\n                    // hit invisible line => flush request\n                    if (reqStart !== null) {\n                        result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n                        reqStart = null;\n                    }\n                }\n            }\n            if (reqStart !== null) {\n                result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n                reqStart = null;\n            }\n            const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n            let viewIndents = new Array(viewLineCount);\n            let currIndex = 0;\n            for (let i = 0, len = result.length; i < len; i++) {\n                let value = result[i];\n                let count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n                let option = resultRepeatOption[i];\n                let blockAtIndex;\n                if (option === IndentGuideRepeatOption.BlockAll) {\n                    blockAtIndex = 0;\n                }\n                else if (option === IndentGuideRepeatOption.BlockSubsequent) {\n                    blockAtIndex = 1;\n                }\n                else {\n                    blockAtIndex = count;\n                }\n                for (let j = 0; j < count; j++) {\n                    if (j === blockAtIndex) {\n                        value = 0;\n                    }\n                    viewIndents[currIndex++] = value;\n                }\n            }\n            return viewIndents;\n        }\n        getViewLineContent(viewLineNumber) {\n            this._ensureValidState();\n            viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n            let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n            let lineIndex = r.index;\n            let remainder = r.remainder;\n            return this.lines[lineIndex].getViewLineContent(this.model, lineIndex + 1, remainder);\n        }\n        getViewLineLength(viewLineNumber) {\n            this._ensureValidState();\n            viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n            let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n            let lineIndex = r.index;\n            let remainder = r.remainder;\n            return this.lines[lineIndex].getViewLineLength(this.model, lineIndex + 1, remainder);\n        }\n        getViewLineMinColumn(viewLineNumber) {\n            this._ensureValidState();\n            viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n            let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n            let lineIndex = r.index;\n            let remainder = r.remainder;\n            return this.lines[lineIndex].getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n        }\n        getViewLineMaxColumn(viewLineNumber) {\n            this._ensureValidState();\n            viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n            let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n            let lineIndex = r.index;\n            let remainder = r.remainder;\n            return this.lines[lineIndex].getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n        }\n        getViewLineData(viewLineNumber) {\n            this._ensureValidState();\n            viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n            let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n            let lineIndex = r.index;\n            let remainder = r.remainder;\n            return this.lines[lineIndex].getViewLineData(this.model, lineIndex + 1, remainder);\n        }\n        getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n            this._ensureValidState();\n            viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n            viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n            let start = this.prefixSumComputer.getIndexOf(viewStartLineNumber - 1);\n            let viewLineNumber = viewStartLineNumber;\n            let startModelLineIndex = start.index;\n            let startRemainder = start.remainder;\n            let result = [];\n            for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n                let line = this.lines[modelLineIndex];\n                if (!line.isVisible()) {\n                    continue;\n                }\n                let fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n                let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n                let lastLine = false;\n                if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n                    lastLine = true;\n                    remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n                }\n                let toViewLineIndex = fromViewLineIndex + remainingViewLineCount;\n                line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, toViewLineIndex, viewLineNumber - viewStartLineNumber, needed, result);\n                viewLineNumber += remainingViewLineCount;\n                if (lastLine) {\n                    break;\n                }\n            }\n            return result;\n        }\n        validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n            this._ensureValidState();\n            viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n            let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n            let lineIndex = r.index;\n            let remainder = r.remainder;\n            let line = this.lines[lineIndex];\n            let minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n            let maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n            if (viewColumn < minColumn) {\n                viewColumn = minColumn;\n            }\n            if (viewColumn > maxColumn) {\n                viewColumn = maxColumn;\n            }\n            let computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n            let computedModelPosition = this.model.validatePosition(new position_1.Position(lineIndex + 1, computedModelColumn));\n            if (computedModelPosition.equals(expectedModelPosition)) {\n                return new position_1.Position(viewLineNumber, viewColumn);\n            }\n            return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n        }\n        convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n            this._ensureValidState();\n            viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n            let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n            let lineIndex = r.index;\n            let remainder = r.remainder;\n            let inputColumn = this.lines[lineIndex].getModelColumnOfViewPosition(remainder, viewColumn);\n            // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n            return this.model.validatePosition(new position_1.Position(lineIndex + 1, inputColumn));\n        }\n        convertModelPositionToViewPosition(_modelLineNumber, _modelColumn) {\n            this._ensureValidState();\n            let validPosition = this.model.validatePosition(new position_1.Position(_modelLineNumber, _modelColumn));\n            let inputLineNumber = validPosition.lineNumber;\n            let inputColumn = validPosition.column;\n            let lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n            while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\n                lineIndex--;\n                lineIndexChanged = true;\n            }\n            if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\n                // Could not reach a real line\n                // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n                return new position_1.Position(1, 1);\n            }\n            let deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n            let r;\n            if (lineIndexChanged) {\n                r = this.lines[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n            }\n            else {\n                r = this.lines[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn);\n            }\n            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n            return r;\n        }\n        _getViewLineNumberForModelPosition(inputLineNumber, inputColumn) {\n            let lineIndex = inputLineNumber - 1;\n            if (this.lines[lineIndex].isVisible()) {\n                // this model line is visible\n                const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n                return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn);\n            }\n            // this model line is not visible\n            while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\n                lineIndex--;\n            }\n            if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\n                // Could not reach a real line\n                return 1;\n            }\n            const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n            return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n        }\n        getAllOverviewRulerDecorations(ownerId, filterOutValidation, theme) {\n            const decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);\n            const result = new OverviewRulerDecorations();\n            for (const decoration of decorations) {\n                const opts = decoration.options.overviewRuler;\n                const lane = opts ? opts.position : 0;\n                if (lane === 0) {\n                    continue;\n                }\n                const color = opts.getColor(theme);\n                const viewStartLineNumber = this._getViewLineNumberForModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n                const viewEndLineNumber = this._getViewLineNumberForModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n                result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);\n            }\n            return result.result;\n        }\n        getDecorationsInRange(range, ownerId, filterOutValidation) {\n            const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n            const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n            if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n                // most likely there are no hidden lines => fast path\n                // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n                return this.model.getDecorationsInRange(new range_1.Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);\n            }\n            let result = [];\n            const modelStartLineIndex = modelStart.lineNumber - 1;\n            const modelEndLineIndex = modelEnd.lineNumber - 1;\n            let reqStart = null;\n            for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n                const line = this.lines[modelLineIndex];\n                if (line.isVisible()) {\n                    // merge into previous request\n                    if (reqStart === null) {\n                        reqStart = new position_1.Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                    }\n                }\n                else {\n                    // hit invisible line => flush request\n                    if (reqStart !== null) {\n                        const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n                        result = result.concat(this.model.getDecorationsInRange(new range_1.Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));\n                        reqStart = null;\n                    }\n                }\n            }\n            if (reqStart !== null) {\n                result = result.concat(this.model.getDecorationsInRange(new range_1.Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));\n                reqStart = null;\n            }\n            result.sort((a, b) => {\n                const res = range_1.Range.compareRangesUsingStarts(a.range, b.range);\n                if (res === 0) {\n                    if (a.id < b.id) {\n                        return -1;\n                    }\n                    if (a.id > b.id) {\n                        return 1;\n                    }\n                    return 0;\n                }\n                return res;\n            });\n            // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n            let finalResult = [], finalResultLen = 0;\n            let prevDecId = null;\n            for (const dec of result) {\n                const decId = dec.id;\n                if (prevDecId === decId) {\n                    // skip\n                    continue;\n                }\n                prevDecId = decId;\n                finalResult[finalResultLen++] = dec;\n            }\n            return finalResult;\n        }\n    }\n    exports.SplitLinesCollection = SplitLinesCollection;\n    class VisibleIdentitySplitLine {\n        constructor() { }\n        isVisible() {\n            return true;\n        }\n        setVisible(isVisible) {\n            if (isVisible) {\n                return this;\n            }\n            return InvisibleIdentitySplitLine.INSTANCE;\n        }\n        getViewLineCount() {\n            return 1;\n        }\n        getViewLineContent(model, modelLineNumber, _outputLineIndex) {\n            return model.getLineContent(modelLineNumber);\n        }\n        getViewLineLength(model, modelLineNumber, _outputLineIndex) {\n            return model.getLineLength(modelLineNumber);\n        }\n        getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\n            return model.getLineMinColumn(modelLineNumber);\n        }\n        getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\n            return model.getLineMaxColumn(modelLineNumber);\n        }\n        getViewLineData(model, modelLineNumber, _outputLineIndex) {\n            let lineTokens = model.getLineTokens(modelLineNumber);\n            let lineContent = lineTokens.getLineContent();\n            return new viewModel_1.ViewLineData(lineContent, false, 1, lineContent.length + 1, lineTokens.inflate());\n        }\n        getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n            if (!needed[globalStartIndex]) {\n                result[globalStartIndex] = null;\n                return;\n            }\n            result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n        }\n        getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\n            return outputColumn;\n        }\n        getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n            return new position_1.Position(deltaLineNumber, inputColumn);\n        }\n        getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\n            return deltaLineNumber;\n        }\n    }\n    VisibleIdentitySplitLine.INSTANCE = new VisibleIdentitySplitLine();\n    class InvisibleIdentitySplitLine {\n        constructor() { }\n        isVisible() {\n            return false;\n        }\n        setVisible(isVisible) {\n            if (!isVisible) {\n                return this;\n            }\n            return VisibleIdentitySplitLine.INSTANCE;\n        }\n        getViewLineCount() {\n            return 0;\n        }\n        getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\n            throw new Error('Not supported');\n        }\n        getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\n            throw new Error('Not supported');\n        }\n        getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\n            throw new Error('Not supported');\n        }\n        getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\n            throw new Error('Not supported');\n        }\n        getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\n            throw new Error('Not supported');\n        }\n        getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n            throw new Error('Not supported');\n        }\n        getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\n            throw new Error('Not supported');\n        }\n        getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\n            throw new Error('Not supported');\n        }\n        getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\n            throw new Error('Not supported');\n        }\n    }\n    InvisibleIdentitySplitLine.INSTANCE = new InvisibleIdentitySplitLine();\n    class SplitLine {\n        constructor(positionMapper, isVisible) {\n            this.positionMapper = positionMapper;\n            this.wrappedIndent = this.positionMapper.getWrappedLinesIndent();\n            this.wrappedIndentLength = this.wrappedIndent.length;\n            this.outputLineCount = this.positionMapper.getOutputLineCount();\n            this._isVisible = isVisible;\n        }\n        isVisible() {\n            return this._isVisible;\n        }\n        setVisible(isVisible) {\n            this._isVisible = isVisible;\n            return this;\n        }\n        getViewLineCount() {\n            if (!this._isVisible) {\n                return 0;\n            }\n            return this.outputLineCount;\n        }\n        getInputStartOffsetOfOutputLineIndex(outputLineIndex) {\n            return this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex, 0);\n        }\n        getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex) {\n            if (outputLineIndex + 1 === this.outputLineCount) {\n                return model.getLineMaxColumn(modelLineNumber) - 1;\n            }\n            return this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex + 1, 0);\n        }\n        getViewLineContent(model, modelLineNumber, outputLineIndex) {\n            if (!this._isVisible) {\n                throw new Error('Not supported');\n            }\n            let startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n            let endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n            let r = model.getValueInRange({\n                startLineNumber: modelLineNumber,\n                startColumn: startOffset + 1,\n                endLineNumber: modelLineNumber,\n                endColumn: endOffset + 1\n            });\n            if (outputLineIndex > 0) {\n                r = this.wrappedIndent + r;\n            }\n            return r;\n        }\n        getViewLineLength(model, modelLineNumber, outputLineIndex) {\n            if (!this._isVisible) {\n                throw new Error('Not supported');\n            }\n            let startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n            let endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n            let r = endOffset - startOffset;\n            if (outputLineIndex > 0) {\n                r = this.wrappedIndent.length + r;\n            }\n            return r;\n        }\n        getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\n            if (!this._isVisible) {\n                throw new Error('Not supported');\n            }\n            if (outputLineIndex > 0) {\n                return this.wrappedIndentLength + 1;\n            }\n            return 1;\n        }\n        getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\n            if (!this._isVisible) {\n                throw new Error('Not supported');\n            }\n            return this.getViewLineContent(model, modelLineNumber, outputLineIndex).length + 1;\n        }\n        getViewLineData(model, modelLineNumber, outputLineIndex) {\n            if (!this._isVisible) {\n                throw new Error('Not supported');\n            }\n            let startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n            let endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n            let lineContent = model.getValueInRange({\n                startLineNumber: modelLineNumber,\n                startColumn: startOffset + 1,\n                endLineNumber: modelLineNumber,\n                endColumn: endOffset + 1\n            });\n            if (outputLineIndex > 0) {\n                lineContent = this.wrappedIndent + lineContent;\n            }\n            let minColumn = (outputLineIndex > 0 ? this.wrappedIndentLength + 1 : 1);\n            let maxColumn = lineContent.length + 1;\n            let continuesWithWrappedLine = (outputLineIndex + 1 < this.getViewLineCount());\n            let deltaStartIndex = 0;\n            if (outputLineIndex > 0) {\n                deltaStartIndex = this.wrappedIndentLength;\n            }\n            let lineTokens = model.getLineTokens(modelLineNumber);\n            return new viewModel_1.ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, lineTokens.sliceAndInflate(startOffset, endOffset, deltaStartIndex));\n        }\n        getViewLinesData(model, modelLineNumber, fromOuputLineIndex, toOutputLineIndex, globalStartIndex, needed, result) {\n            if (!this._isVisible) {\n                throw new Error('Not supported');\n            }\n            for (let outputLineIndex = fromOuputLineIndex; outputLineIndex < toOutputLineIndex; outputLineIndex++) {\n                let globalIndex = globalStartIndex + outputLineIndex - fromOuputLineIndex;\n                if (!needed[globalIndex]) {\n                    result[globalIndex] = null;\n                    continue;\n                }\n                result[globalIndex] = this.getViewLineData(model, modelLineNumber, outputLineIndex);\n            }\n        }\n        getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\n            if (!this._isVisible) {\n                throw new Error('Not supported');\n            }\n            let adjustedColumn = outputColumn - 1;\n            if (outputLineIndex > 0) {\n                if (adjustedColumn < this.wrappedIndentLength) {\n                    adjustedColumn = 0;\n                }\n                else {\n                    adjustedColumn -= this.wrappedIndentLength;\n                }\n            }\n            return this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex, adjustedColumn) + 1;\n        }\n        getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n            if (!this._isVisible) {\n                throw new Error('Not supported');\n            }\n            let r = this.positionMapper.getOutputPositionOfInputOffset(inputColumn - 1);\n            let outputLineIndex = r.outputLineIndex;\n            let outputColumn = r.outputOffset + 1;\n            if (outputLineIndex > 0) {\n                outputColumn += this.wrappedIndentLength;\n            }\n            //\t\tconsole.log('in -> out ' + deltaLineNumber + ',' + inputColumn + ' ===> ' + (deltaLineNumber+outputLineIndex) + ',' + outputColumn);\n            return new position_1.Position(deltaLineNumber + outputLineIndex, outputColumn);\n        }\n        getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\n            if (!this._isVisible) {\n                throw new Error('Not supported');\n            }\n            const r = this.positionMapper.getOutputPositionOfInputOffset(inputColumn - 1);\n            return (deltaLineNumber + r.outputLineIndex);\n        }\n    }\n    exports.SplitLine = SplitLine;\n    function createSplitLine(linePositionMapperFactory, text, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, isVisible) {\n        let positionMapper = linePositionMapperFactory.createLineMapping(text, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n        if (positionMapper === null) {\n            // No mapping needed\n            if (isVisible) {\n                return VisibleIdentitySplitLine.INSTANCE;\n            }\n            return InvisibleIdentitySplitLine.INSTANCE;\n        }\n        else {\n            return new SplitLine(positionMapper, isVisible);\n        }\n    }\n    class IdentityCoordinatesConverter {\n        constructor(lines) {\n            this._lines = lines;\n        }\n        _validPosition(pos) {\n            return this._lines.model.validatePosition(pos);\n        }\n        _validRange(range) {\n            return this._lines.model.validateRange(range);\n        }\n        // View -> Model conversion and related methods\n        convertViewPositionToModelPosition(viewPosition) {\n            return this._validPosition(viewPosition);\n        }\n        convertViewRangeToModelRange(viewRange) {\n            return this._validRange(viewRange);\n        }\n        validateViewPosition(_viewPosition, expectedModelPosition) {\n            return this._validPosition(expectedModelPosition);\n        }\n        validateViewRange(_viewRange, expectedModelRange) {\n            return this._validRange(expectedModelRange);\n        }\n        // Model -> View conversion and related methods\n        convertModelPositionToViewPosition(modelPosition) {\n            return this._validPosition(modelPosition);\n        }\n        convertModelRangeToViewRange(modelRange) {\n            return this._validRange(modelRange);\n        }\n        modelPositionIsVisible(modelPosition) {\n            const lineCount = this._lines.model.getLineCount();\n            if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n                // invalid arguments\n                return false;\n            }\n            return true;\n        }\n    }\n    exports.IdentityCoordinatesConverter = IdentityCoordinatesConverter;\n    class IdentityLinesCollection {\n        constructor(model) {\n            this.model = model;\n        }\n        dispose() {\n        }\n        createCoordinatesConverter() {\n            return new IdentityCoordinatesConverter(this);\n        }\n        getHiddenAreas() {\n            return [];\n        }\n        setHiddenAreas(_ranges) {\n            return false;\n        }\n        setTabSize(_newTabSize) {\n            return false;\n        }\n        setWrappingSettings(_wrappingIndent, _wrappingColumn, _columnsForFullWidthChar) {\n            return false;\n        }\n        onModelFlushed() {\n        }\n        onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n            return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n        }\n        onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, _text) {\n            return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n        }\n        onModelLineChanged(_versionId, lineNumber, _newText) {\n            return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, lineNumber), null, null];\n        }\n        acceptVersionId(_versionId) {\n        }\n        getViewLineCount() {\n            return this.model.getLineCount();\n        }\n        warmUpLookupCache(_viewStartLineNumber, _viewEndLineNumber) {\n        }\n        getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n            return {\n                startLineNumber: viewLineNumber,\n                endLineNumber: viewLineNumber,\n                indent: 0\n            };\n        }\n        getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n            const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n            let result = new Array(viewLineCount);\n            for (let i = 0; i < viewLineCount; i++) {\n                result[i] = 0;\n            }\n            return result;\n        }\n        getViewLineContent(viewLineNumber) {\n            return this.model.getLineContent(viewLineNumber);\n        }\n        getViewLineLength(viewLineNumber) {\n            return this.model.getLineLength(viewLineNumber);\n        }\n        getViewLineMinColumn(viewLineNumber) {\n            return this.model.getLineMinColumn(viewLineNumber);\n        }\n        getViewLineMaxColumn(viewLineNumber) {\n            return this.model.getLineMaxColumn(viewLineNumber);\n        }\n        getViewLineData(viewLineNumber) {\n            let lineTokens = this.model.getLineTokens(viewLineNumber);\n            let lineContent = lineTokens.getLineContent();\n            return new viewModel_1.ViewLineData(lineContent, false, 1, lineContent.length + 1, lineTokens.inflate());\n        }\n        getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n            const lineCount = this.model.getLineCount();\n            viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n            viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n            let result = [];\n            for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n                let idx = lineNumber - viewStartLineNumber;\n                if (!needed[idx]) {\n                    result[idx] = null;\n                }\n                result[idx] = this.getViewLineData(lineNumber);\n            }\n            return result;\n        }\n        getAllOverviewRulerDecorations(ownerId, filterOutValidation, theme) {\n            const decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);\n            const result = new OverviewRulerDecorations();\n            for (const decoration of decorations) {\n                const opts = decoration.options.overviewRuler;\n                const lane = opts ? opts.position : 0;\n                if (lane === 0) {\n                    continue;\n                }\n                const color = opts.getColor(theme);\n                const viewStartLineNumber = decoration.range.startLineNumber;\n                const viewEndLineNumber = decoration.range.endLineNumber;\n                result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);\n            }\n            return result.result;\n        }\n        getDecorationsInRange(range, ownerId, filterOutValidation) {\n            return this.model.getDecorationsInRange(range, ownerId, filterOutValidation);\n        }\n    }\n    exports.IdentityLinesCollection = IdentityLinesCollection;\n    class OverviewRulerDecorations {\n        constructor() {\n            this.result = Object.create(null);\n        }\n        accept(color, startLineNumber, endLineNumber, lane) {\n            let prev = this.result[color];\n            if (prev) {\n                const prevLane = prev[prev.length - 3];\n                const prevEndLineNumber = prev[prev.length - 1];\n                if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n                    // merge into prev\n                    if (endLineNumber > prevEndLineNumber) {\n                        prev[prev.length - 1] = endLineNumber;\n                    }\n                    return;\n                }\n                // push\n                prev.push(lane, startLineNumber, endLineNumber);\n            }\n            else {\n                this.result[color] = [lane, startLineNumber, endLineNumber];\n            }\n        }\n    }\n});\n",null]}