{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/unix/chokidarWatcherService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/watcher/unix/chokidarWatcherService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vscode-chokidar\", \"fs\", \"graceful-fs\", \"vs/base/common/extpath\", \"vs/base/common/glob\", \"vs/platform/files/common/files\", \"vs/base/common/async\", \"vs/base/common/normalization\", \"vs/base/node/extfs\", \"vs/base/common/platform\", \"vs/workbench/services/files/node/watcher/common\", \"vs/base/common/event\"], function (require, exports, chokidar, fs, gracefulFs, extpath, glob, files_1, async_1, normalization_1, extfs_1, platform_1, watcherCommon, event_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    gracefulFs.gracefulify(fs);\n    class ChokidarWatcherService {\n        constructor() {\n            this._onWatchEvent = new event_1.Emitter();\n            this.onWatchEvent = this._onWatchEvent.event;\n        }\n        watch(options) {\n            this._verboseLogging = options.verboseLogging;\n            this._pollingInterval = options.pollingInterval;\n            this._watchers = Object.create(null);\n            this._watcherCount = 0;\n            return this.onWatchEvent;\n        }\n        setVerboseLogging(enabled) {\n            this._verboseLogging = enabled;\n            return Promise.resolve();\n        }\n        setRoots(requests) {\n            const watchers = Object.create(null);\n            const newRequests = [];\n            const requestsByBasePath = normalizeRoots(requests);\n            // evaluate new & remaining watchers\n            for (let basePath in requestsByBasePath) {\n                let watcher = this._watchers[basePath];\n                if (watcher && isEqualRequests(watcher.requests, requestsByBasePath[basePath])) {\n                    watchers[basePath] = watcher;\n                    delete this._watchers[basePath];\n                }\n                else {\n                    newRequests.push(basePath);\n                }\n            }\n            // stop all old watchers\n            for (let path in this._watchers) {\n                this._watchers[path].stop();\n            }\n            // start all new watchers\n            for (let basePath of newRequests) {\n                let requests = requestsByBasePath[basePath];\n                watchers[basePath] = this._watch(basePath, requests);\n            }\n            this._watchers = watchers;\n            return Promise.resolve();\n        }\n        // for test purposes\n        get wacherCount() {\n            return this._watcherCount;\n        }\n        _watch(basePath, requests) {\n            if (this._verboseLogging) {\n                console.log(`Start watching: ${basePath}]`);\n            }\n            const pollingInterval = this._pollingInterval || 1000;\n            const watcherOpts = {\n                ignoreInitial: true,\n                ignorePermissionErrors: true,\n                followSymlinks: true,\n                interval: pollingInterval,\n                binaryInterval: pollingInterval,\n                disableGlobbing: true // fix https://github.com/Microsoft/vscode/issues/4586\n            };\n            // if there's only one request, use the built-in ignore-filterering\n            const isSingleFolder = requests.length === 1;\n            if (isSingleFolder) {\n                watcherOpts.ignored = requests[0].ignored;\n            }\n            // Chokidar fails when the basePath does not match case-identical to the path on disk\n            // so we have to find the real casing of the path and do some path massaging to fix this\n            // see https://github.com/paulmillr/chokidar/issues/418\n            const realBasePath = platform_1.isMacintosh ? (extfs_1.realcaseSync(basePath) || basePath) : basePath;\n            const realBasePathLength = realBasePath.length;\n            const realBasePathDiffers = (basePath !== realBasePath);\n            if (realBasePathDiffers) {\n                console.warn(`Watcher basePath does not match version on disk and was corrected (original: ${basePath}, real: ${realBasePath})`);\n            }\n            let chokidarWatcher = chokidar.watch(realBasePath, watcherOpts);\n            this._watcherCount++;\n            // Detect if for some reason the native watcher library fails to load\n            if (platform_1.isMacintosh && !chokidarWatcher.options.useFsEvents) {\n                console.error('Watcher is not using native fsevents library and is falling back to unefficient polling.');\n            }\n            let undeliveredFileEvents = [];\n            let fileEventDelayer = new async_1.ThrottledDelayer(ChokidarWatcherService.FS_EVENT_DELAY);\n            const watcher = {\n                requests,\n                stop: () => {\n                    try {\n                        if (this._verboseLogging) {\n                            console.log(`Stop watching: ${basePath}]`);\n                        }\n                        if (chokidarWatcher) {\n                            chokidarWatcher.close();\n                            this._watcherCount--;\n                            chokidarWatcher = null;\n                        }\n                        if (fileEventDelayer) {\n                            fileEventDelayer.cancel();\n                            fileEventDelayer = null;\n                        }\n                    }\n                    catch (error) {\n                        console.error(error.toString());\n                    }\n                }\n            };\n            chokidarWatcher.on('all', (type, path) => {\n                if (platform_1.isMacintosh) {\n                    // Mac: uses NFD unicode form on disk, but we want NFC\n                    // See also https://github.com/nodejs/node/issues/2165\n                    path = normalization_1.normalizeNFC(path);\n                }\n                if (path.indexOf(realBasePath) < 0) {\n                    return; // we really only care about absolute paths here in our basepath context here\n                }\n                // Make sure to convert the path back to its original basePath form if the realpath is different\n                if (realBasePathDiffers) {\n                    path = basePath + path.substr(realBasePathLength);\n                }\n                let eventType;\n                switch (type) {\n                    case 'change':\n                        eventType = files_1.FileChangeType.UPDATED;\n                        break;\n                    case 'add':\n                    case 'addDir':\n                        eventType = files_1.FileChangeType.ADDED;\n                        break;\n                    case 'unlink':\n                    case 'unlinkDir':\n                        eventType = files_1.FileChangeType.DELETED;\n                        break;\n                    default:\n                        return;\n                }\n                // if there's more than one request we need to do\n                // extra filtering due to potentially overlapping roots\n                if (!isSingleFolder) {\n                    if (isIgnored(path, watcher.requests)) {\n                        return;\n                    }\n                }\n                let event = { type: eventType, path };\n                // Logging\n                if (this._verboseLogging) {\n                    console.log(`${eventType === files_1.FileChangeType.ADDED ? '[ADDED]' : eventType === files_1.FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${path}`);\n                }\n                // Check for spam\n                const now = Date.now();\n                if (undeliveredFileEvents.length === 0) {\n                    this.spamWarningLogged = false;\n                    this.spamCheckStartTime = now;\n                }\n                else if (!this.spamWarningLogged && this.spamCheckStartTime + ChokidarWatcherService.EVENT_SPAM_WARNING_THRESHOLD < now) {\n                    this.spamWarningLogged = true;\n                    console.warn(`Watcher is busy catching up with ${undeliveredFileEvents.length} file changes in 60 seconds. Latest changed path is \"${event.path}\"`);\n                }\n                // Add to buffer\n                undeliveredFileEvents.push(event);\n                if (fileEventDelayer) {\n                    // Delay and send buffer\n                    fileEventDelayer.trigger(() => {\n                        const events = undeliveredFileEvents;\n                        undeliveredFileEvents = [];\n                        // Broadcast to clients normalized\n                        const res = watcherCommon.normalize(events);\n                        this._onWatchEvent.fire(res);\n                        // Logging\n                        if (this._verboseLogging) {\n                            res.forEach(r => {\n                                console.log(` >> normalized  ${r.type === files_1.FileChangeType.ADDED ? '[ADDED]' : r.type === files_1.FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${r.path}`);\n                            });\n                        }\n                        return Promise.resolve(undefined);\n                    });\n                }\n            });\n            chokidarWatcher.on('error', (error) => {\n                if (error) {\n                    // Specially handle ENOSPC errors that can happen when\n                    // the watcher consumes so many file descriptors that\n                    // we are running into a limit. We only want to warn\n                    // once in this case to avoid log spam.\n                    // See https://github.com/Microsoft/vscode/issues/7950\n                    if (error.code === 'ENOSPC') {\n                        if (!this.enospcErrorLogged) {\n                            this.enospcErrorLogged = true;\n                            this.stop();\n                            this._onWatchEvent.fire({ message: 'Inotify limit reached (ENOSPC)' });\n                        }\n                    }\n                    else {\n                        console.error(error.toString());\n                    }\n                }\n            });\n            return watcher;\n        }\n        stop() {\n            for (let path in this._watchers) {\n                let watcher = this._watchers[path];\n                watcher.stop();\n            }\n            this._watchers = Object.create(null);\n            return Promise.resolve();\n        }\n    }\n    ChokidarWatcherService.FS_EVENT_DELAY = 50; // aggregate and only emit events when changes have stopped for this duration (in ms)\n    ChokidarWatcherService.EVENT_SPAM_WARNING_THRESHOLD = 60 * 1000; // warn after certain time span of event spam\n    exports.ChokidarWatcherService = ChokidarWatcherService;\n    function isIgnored(path, requests) {\n        for (let request of requests) {\n            if (request.basePath === path) {\n                return false;\n            }\n            if (extpath.isEqualOrParent(path, request.basePath)) {\n                if (!request.parsedPattern) {\n                    if (request.ignored && request.ignored.length > 0) {\n                        let pattern = `{${request.ignored.join(',')}}`;\n                        request.parsedPattern = glob.parse(pattern);\n                    }\n                    else {\n                        request.parsedPattern = () => false;\n                    }\n                }\n                const relPath = path.substr(request.basePath.length + 1);\n                if (!request.parsedPattern(relPath)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Normalizes a set of root paths by grouping by the most parent root path.\n     * equests with Sub paths are skipped if they have the same ignored set as the parent.\n     */\n    function normalizeRoots(requests) {\n        requests = requests.sort((r1, r2) => r1.basePath.localeCompare(r2.basePath));\n        let prevRequest = null;\n        let result = Object.create(null);\n        for (let request of requests) {\n            let basePath = request.basePath;\n            let ignored = (request.ignored || []).sort();\n            if (prevRequest && (extpath.isEqualOrParent(basePath, prevRequest.basePath))) {\n                if (!isEqualIgnore(ignored, prevRequest.ignored)) {\n                    result[prevRequest.basePath].push({ basePath, ignored });\n                }\n            }\n            else {\n                prevRequest = { basePath, ignored };\n                result[basePath] = [prevRequest];\n            }\n        }\n        return result;\n    }\n    exports.normalizeRoots = normalizeRoots;\n    function isEqualRequests(r1, r2) {\n        if (r1.length !== r2.length) {\n            return false;\n        }\n        for (let k = 0; k < r1.length; k++) {\n            if (r1[k].basePath !== r2[k].basePath || !isEqualIgnore(r1[k].ignored, r2[k].ignored)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function isEqualIgnore(i1, i2) {\n        if (i1.length !== i2.length) {\n            return false;\n        }\n        for (let k = 0; k < i1.length; k++) {\n            if (i1[k] !== i2[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n});\n",null]}