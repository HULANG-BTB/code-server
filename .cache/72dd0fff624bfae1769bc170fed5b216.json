{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/preferences/common/smartSnippetInserter.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/preferences/common/smartSnippetInserter.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar json_1 = require(\"vs/base/common/json\");\nvar position_1 = require(\"vs/editor/common/core/position\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar SmartSnippetInserter = /** @class */ (function () {\n    function SmartSnippetInserter() {\n    }\n    SmartSnippetInserter.hasOpenBrace = function (scanner) {\n        while (scanner.scan() !== json_1.SyntaxKind.EOF) {\n            var kind = scanner.getToken();\n            if (kind === json_1.SyntaxKind.OpenBraceToken) {\n                return true;\n            }\n        }\n        return false;\n    };\n    SmartSnippetInserter.offsetToPosition = function (model, offset) {\n        var offsetBeforeLine = 0;\n        var eolLength = model.getEOL().length;\n        var lineCount = model.getLineCount();\n        for (var lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            var lineTotalLength = model.getLineContent(lineNumber).length + eolLength;\n            var offsetAfterLine = offsetBeforeLine + lineTotalLength;\n            if (offsetAfterLine > offset) {\n                return new position_1.Position(lineNumber, offset - offsetBeforeLine + 1);\n            }\n            offsetBeforeLine = offsetAfterLine;\n        }\n        return new position_1.Position(lineCount, model.getLineMaxColumn(lineCount));\n    };\n    SmartSnippetInserter.insertSnippet = function (model, _position) {\n        var desiredPosition = model.getValueLengthInRange(new range_1.Range(1, 1, _position.lineNumber, _position.column));\n        // <INVALID> [ <BEFORE_OBJECT> { <INVALID> } <AFTER_OBJECT>, <BEFORE_OBJECT> { <INVALID> } <AFTER_OBJECT> ] <INVALID>\n        var State;\n        (function (State) {\n            State[State[\"INVALID\"] = 0] = \"INVALID\";\n            State[State[\"AFTER_OBJECT\"] = 1] = \"AFTER_OBJECT\";\n            State[State[\"BEFORE_OBJECT\"] = 2] = \"BEFORE_OBJECT\";\n        })(State || (State = {}));\n        var currentState = State.INVALID;\n        var lastValidPos = -1;\n        var lastValidState = State.INVALID;\n        var scanner = json_1.createScanner(model.getValue());\n        var arrayLevel = 0;\n        var objLevel = 0;\n        var checkRangeStatus = function (pos, state) {\n            if (state !== State.INVALID && arrayLevel === 1 && objLevel === 0) {\n                currentState = state;\n                lastValidPos = pos;\n                lastValidState = state;\n            }\n            else {\n                if (currentState !== State.INVALID) {\n                    currentState = State.INVALID;\n                    lastValidPos = scanner.getTokenOffset();\n                }\n            }\n        };\n        while (scanner.scan() !== json_1.SyntaxKind.EOF) {\n            var currentPos = scanner.getPosition();\n            var kind = scanner.getToken();\n            var goodKind = false;\n            switch (kind) {\n                case json_1.SyntaxKind.OpenBracketToken:\n                    goodKind = true;\n                    arrayLevel++;\n                    checkRangeStatus(currentPos, State.BEFORE_OBJECT);\n                    break;\n                case json_1.SyntaxKind.CloseBracketToken:\n                    goodKind = true;\n                    arrayLevel--;\n                    checkRangeStatus(currentPos, State.INVALID);\n                    break;\n                case json_1.SyntaxKind.CommaToken:\n                    goodKind = true;\n                    checkRangeStatus(currentPos, State.BEFORE_OBJECT);\n                    break;\n                case json_1.SyntaxKind.OpenBraceToken:\n                    goodKind = true;\n                    objLevel++;\n                    checkRangeStatus(currentPos, State.INVALID);\n                    break;\n                case json_1.SyntaxKind.CloseBraceToken:\n                    goodKind = true;\n                    objLevel--;\n                    checkRangeStatus(currentPos, State.AFTER_OBJECT);\n                    break;\n                case json_1.SyntaxKind.Trivia:\n                case json_1.SyntaxKind.LineBreakTrivia:\n                    goodKind = true;\n            }\n            if (currentPos >= desiredPosition && (currentState !== State.INVALID || lastValidPos !== -1)) {\n                var acceptPosition = void 0;\n                var acceptState = void 0;\n                if (currentState !== State.INVALID) {\n                    acceptPosition = (goodKind ? currentPos : scanner.getTokenOffset());\n                    acceptState = currentState;\n                }\n                else {\n                    acceptPosition = lastValidPos;\n                    acceptState = lastValidState;\n                }\n                if (acceptState === State.AFTER_OBJECT) {\n                    return {\n                        position: this.offsetToPosition(model, acceptPosition),\n                        prepend: ',',\n                        append: ''\n                    };\n                }\n                else {\n                    scanner.setPosition(acceptPosition);\n                    return {\n                        position: this.offsetToPosition(model, acceptPosition),\n                        prepend: '',\n                        append: this.hasOpenBrace(scanner) ? ',' : ''\n                    };\n                }\n            }\n        }\n        // no valid position found!\n        var modelLineCount = model.getLineCount();\n        return {\n            position: new position_1.Position(modelLineCount, model.getLineMaxColumn(modelLineCount)),\n            prepend: '\\n[',\n            append: ']'\n        };\n    };\n    return SmartSnippetInserter;\n}());\nexports.SmartSnippetInserter = SmartSnippetInserter;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/preferences/common/smartSnippetInserter.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/preferences/common/smartSnippetInserter.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { JSONScanner, createScanner as createJSONScanner, SyntaxKind as JSONSyntaxKind } from 'vs/base/common/json';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { ITextModel } from 'vs/editor/common/model';\n\nexport interface InsertSnippetResult {\n\tposition: Position;\n\tprepend: string;\n\tappend: string;\n}\n\nexport class SmartSnippetInserter {\n\n\tprivate static hasOpenBrace(scanner: JSONScanner): boolean {\n\n\t\twhile (scanner.scan() !== JSONSyntaxKind.EOF) {\n\t\t\tconst kind = scanner.getToken();\n\n\t\t\tif (kind === JSONSyntaxKind.OpenBraceToken) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate static offsetToPosition(model: ITextModel, offset: number): Position {\n\t\tlet offsetBeforeLine = 0;\n\t\tconst eolLength = model.getEOL().length;\n\t\tconst lineCount = model.getLineCount();\n\t\tfor (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n\t\t\tconst lineTotalLength = model.getLineContent(lineNumber).length + eolLength;\n\t\t\tconst offsetAfterLine = offsetBeforeLine + lineTotalLength;\n\n\t\t\tif (offsetAfterLine > offset) {\n\t\t\t\treturn new Position(\n\t\t\t\t\tlineNumber,\n\t\t\t\t\toffset - offsetBeforeLine + 1\n\t\t\t\t);\n\t\t\t}\n\t\t\toffsetBeforeLine = offsetAfterLine;\n\t\t}\n\t\treturn new Position(\n\t\t\tlineCount,\n\t\t\tmodel.getLineMaxColumn(lineCount)\n\t\t);\n\t}\n\n\tstatic insertSnippet(model: ITextModel, _position: Position): InsertSnippetResult {\n\n\t\tconst desiredPosition = model.getValueLengthInRange(new Range(1, 1, _position.lineNumber, _position.column));\n\n\t\t// <INVALID> [ <BEFORE_OBJECT> { <INVALID> } <AFTER_OBJECT>, <BEFORE_OBJECT> { <INVALID> } <AFTER_OBJECT> ] <INVALID>\n\t\tenum State {\n\t\t\tINVALID = 0,\n\t\t\tAFTER_OBJECT = 1,\n\t\t\tBEFORE_OBJECT = 2,\n\t\t}\n\t\tlet currentState = State.INVALID;\n\t\tlet lastValidPos = -1;\n\t\tlet lastValidState = State.INVALID;\n\n\t\tconst scanner = createJSONScanner(model.getValue());\n\t\tlet arrayLevel = 0;\n\t\tlet objLevel = 0;\n\n\t\tconst checkRangeStatus = (pos: number, state: State) => {\n\t\t\tif (state !== State.INVALID && arrayLevel === 1 && objLevel === 0) {\n\t\t\t\tcurrentState = state;\n\t\t\t\tlastValidPos = pos;\n\t\t\t\tlastValidState = state;\n\t\t\t} else {\n\t\t\t\tif (currentState !== State.INVALID) {\n\t\t\t\t\tcurrentState = State.INVALID;\n\t\t\t\t\tlastValidPos = scanner.getTokenOffset();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\twhile (scanner.scan() !== JSONSyntaxKind.EOF) {\n\t\t\tconst currentPos = scanner.getPosition();\n\t\t\tconst kind = scanner.getToken();\n\n\t\t\tlet goodKind = false;\n\t\t\tswitch (kind) {\n\t\t\t\tcase JSONSyntaxKind.OpenBracketToken:\n\t\t\t\t\tgoodKind = true;\n\t\t\t\t\tarrayLevel++;\n\t\t\t\t\tcheckRangeStatus(currentPos, State.BEFORE_OBJECT);\n\t\t\t\t\tbreak;\n\t\t\t\tcase JSONSyntaxKind.CloseBracketToken:\n\t\t\t\t\tgoodKind = true;\n\t\t\t\t\tarrayLevel--;\n\t\t\t\t\tcheckRangeStatus(currentPos, State.INVALID);\n\t\t\t\t\tbreak;\n\t\t\t\tcase JSONSyntaxKind.CommaToken:\n\t\t\t\t\tgoodKind = true;\n\t\t\t\t\tcheckRangeStatus(currentPos, State.BEFORE_OBJECT);\n\t\t\t\t\tbreak;\n\t\t\t\tcase JSONSyntaxKind.OpenBraceToken:\n\t\t\t\t\tgoodKind = true;\n\t\t\t\t\tobjLevel++;\n\t\t\t\t\tcheckRangeStatus(currentPos, State.INVALID);\n\t\t\t\t\tbreak;\n\t\t\t\tcase JSONSyntaxKind.CloseBraceToken:\n\t\t\t\t\tgoodKind = true;\n\t\t\t\t\tobjLevel--;\n\t\t\t\t\tcheckRangeStatus(currentPos, State.AFTER_OBJECT);\n\t\t\t\t\tbreak;\n\t\t\t\tcase JSONSyntaxKind.Trivia:\n\t\t\t\tcase JSONSyntaxKind.LineBreakTrivia:\n\t\t\t\t\tgoodKind = true;\n\t\t\t}\n\n\t\t\tif (currentPos >= desiredPosition && (currentState !== State.INVALID || lastValidPos !== -1)) {\n\t\t\t\tlet acceptPosition: number;\n\t\t\t\tlet acceptState: State;\n\n\t\t\t\tif (currentState !== State.INVALID) {\n\t\t\t\t\tacceptPosition = (goodKind ? currentPos : scanner.getTokenOffset());\n\t\t\t\t\tacceptState = currentState;\n\t\t\t\t} else {\n\t\t\t\t\tacceptPosition = lastValidPos;\n\t\t\t\t\tacceptState = lastValidState;\n\t\t\t\t}\n\n\t\t\t\tif (acceptState as State === State.AFTER_OBJECT) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tposition: this.offsetToPosition(model, acceptPosition),\n\t\t\t\t\t\tprepend: ',',\n\t\t\t\t\t\tappend: ''\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tscanner.setPosition(acceptPosition);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tposition: this.offsetToPosition(model, acceptPosition),\n\t\t\t\t\t\tprepend: '',\n\t\t\t\t\t\tappend: this.hasOpenBrace(scanner) ? ',' : ''\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// no valid position found!\n\t\tconst modelLineCount = model.getLineCount();\n\t\treturn {\n\t\t\tposition: new Position(modelLineCount, model.getLineMaxColumn(modelLineCount)),\n\t\t\tprepend: '\\n[',\n\t\t\tappend: ']'\n\t\t};\n\t}\n}\n"]}]}