{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/common/contributions.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/common/contributions.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar lifecycle_1 = require(\"vs/platform/lifecycle/common/lifecycle\");\nvar platform_1 = require(\"vs/platform/registry/common/platform\");\nvar async_1 = require(\"vs/base/common/async\");\nvar Extensions;\n(function (Extensions) {\n    Extensions.Workbench = 'workbench.contributions.kind';\n})(Extensions = exports.Extensions || (exports.Extensions = {}));\nvar WorkbenchContributionsRegistry = /** @class */ (function () {\n    function WorkbenchContributionsRegistry() {\n        this.toBeInstantiated = new Map();\n    }\n    WorkbenchContributionsRegistry.prototype.registerWorkbenchContribution = function (ctor, phase) {\n        if (phase === void 0) { phase = lifecycle_1.LifecyclePhase.Starting; }\n        // Instantiate directly if we are already matching the provided phase\n        if (this.instantiationService && this.lifecycleService && this.lifecycleService.phase >= phase) {\n            this.instantiationService.createInstance(ctor);\n        }\n        // Otherwise keep contributions by lifecycle phase\n        else {\n            var toBeInstantiated = this.toBeInstantiated.get(phase);\n            if (!toBeInstantiated) {\n                toBeInstantiated = [];\n                this.toBeInstantiated.set(phase, toBeInstantiated);\n            }\n            toBeInstantiated.push(ctor);\n        }\n    };\n    WorkbenchContributionsRegistry.prototype.start = function (accessor) {\n        var _this = this;\n        this.instantiationService = accessor.get(instantiation_1.IInstantiationService);\n        this.lifecycleService = accessor.get(lifecycle_1.ILifecycleService);\n        [lifecycle_1.LifecyclePhase.Starting, lifecycle_1.LifecyclePhase.Ready, lifecycle_1.LifecyclePhase.Restored, lifecycle_1.LifecyclePhase.Eventually].forEach(function (phase) {\n            _this.instantiateByPhase(_this.instantiationService, _this.lifecycleService, phase);\n        });\n    };\n    WorkbenchContributionsRegistry.prototype.instantiateByPhase = function (instantiationService, lifecycleService, phase) {\n        var _this = this;\n        // Instantiate contributions directly when phase is already reached\n        if (lifecycleService.phase >= phase) {\n            this.doInstantiateByPhase(instantiationService, phase);\n        }\n        // Otherwise wait for phase to be reached\n        else {\n            lifecycleService.when(phase).then(function () {\n                _this.doInstantiateByPhase(instantiationService, phase);\n            });\n        }\n    };\n    WorkbenchContributionsRegistry.prototype.doInstantiateByPhase = function (instantiationService, phase) {\n        var toBeInstantiated = this.toBeInstantiated.get(phase);\n        if (toBeInstantiated) {\n            this.toBeInstantiated.delete(phase);\n            if (phase !== lifecycle_1.LifecyclePhase.Eventually) {\n                // instantiate everything synchronously and blocking\n                for (var _i = 0, toBeInstantiated_1 = toBeInstantiated; _i < toBeInstantiated_1.length; _i++) {\n                    var ctor = toBeInstantiated_1[_i];\n                    instantiationService.createInstance(ctor);\n                }\n            }\n            else {\n                // for the Eventually-phase we instantiate contributions\n                // only when idle. this might take a few idle-busy-cycles\n                // but will finish within the timeouts\n                var forcedTimeout_1 = 3000;\n                var i_1 = 0;\n                var instantiateSome_1 = function (idle) {\n                    while (i_1 < toBeInstantiated.length) {\n                        var ctor = toBeInstantiated[i_1++];\n                        instantiationService.createInstance(ctor);\n                        if (idle.timeRemaining() < 1) {\n                            // time is up -> reschedule\n                            async_1.runWhenIdle(instantiateSome_1, forcedTimeout_1);\n                            break;\n                        }\n                    }\n                };\n                async_1.runWhenIdle(instantiateSome_1, forcedTimeout_1);\n            }\n        }\n    };\n    return WorkbenchContributionsRegistry;\n}());\nplatform_1.Registry.add(Extensions.Workbench, new WorkbenchContributionsRegistry());\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/common/contributions.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/common/contributions.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;AAEhG,gFAAiI;AACjI,oEAA2F;AAC3F,iEAAgE;AAChE,8CAAiE;AASjE,IAAiB,UAAU,CAE1B;AAFD,WAAiB,UAAU;IACb,oBAAS,GAAG,8BAA8B,CAAC;AACzD,CAAC,EAFgB,UAAU,GAAV,kBAAU,KAAV,kBAAU,QAE1B;AAoBD;IAAA;QAIkB,qBAAgB,GAA0E,IAAI,GAAG,EAAoE,CAAC;IA2ExL,CAAC;IAzEA,sEAA6B,GAA7B,UAA8B,IAAqC,EAAE,KAA+C;QAA/C,sBAAA,EAAA,QAAwB,0BAAc,CAAC,QAAQ;QAEnH,qEAAqE;QACrE,IAAI,IAAI,CAAC,oBAAoB,IAAI,IAAI,CAAC,gBAAgB,IAAI,IAAI,CAAC,gBAAgB,CAAC,KAAK,IAAI,KAAK,EAAE;YAC/F,IAAI,CAAC,oBAAoB,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;SAC/C;QAED,kDAAkD;aAC7C;YACJ,IAAI,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YACxD,IAAI,CAAC,gBAAgB,EAAE;gBACtB,gBAAgB,GAAG,EAAE,CAAC;gBACtB,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,KAAK,EAAE,gBAAgB,CAAC,CAAC;aACnD;YAED,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC5B;IACF,CAAC;IAED,8CAAK,GAAL,UAAM,QAA0B;QAAhC,iBAOC;QANA,IAAI,CAAC,oBAAoB,GAAG,QAAQ,CAAC,GAAG,CAAC,qCAAqB,CAAC,CAAC;QAChE,IAAI,CAAC,gBAAgB,GAAG,QAAQ,CAAC,GAAG,CAAC,6BAAiB,CAAC,CAAC;QAExD,CAAC,0BAAc,CAAC,QAAQ,EAAE,0BAAc,CAAC,KAAK,EAAE,0BAAc,CAAC,QAAQ,EAAE,0BAAc,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,UAAA,KAAK;YAChH,KAAI,CAAC,kBAAkB,CAAC,KAAI,CAAC,oBAAoB,EAAE,KAAI,CAAC,gBAAgB,EAAE,KAAK,CAAC,CAAC;QAClF,CAAC,CAAC,CAAC;IACJ,CAAC;IAEO,2DAAkB,GAA1B,UAA2B,oBAA2C,EAAE,gBAAmC,EAAE,KAAqB;QAAlI,iBAaC;QAXA,mEAAmE;QACnE,IAAI,gBAAgB,CAAC,KAAK,IAAI,KAAK,EAAE;YACpC,IAAI,CAAC,oBAAoB,CAAC,oBAAoB,EAAE,KAAK,CAAC,CAAC;SACvD;QAED,yCAAyC;aACpC;YACJ,gBAAgB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC;gBACjC,KAAI,CAAC,oBAAoB,CAAC,oBAAoB,EAAE,KAAK,CAAC,CAAC;YACxD,CAAC,CAAC,CAAC;SACH;IACF,CAAC;IAEO,6DAAoB,GAA5B,UAA6B,oBAA2C,EAAE,KAAqB;QAC9F,IAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAC1D,IAAI,gBAAgB,EAAE;YACrB,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACpC,IAAI,KAAK,KAAK,0BAAc,CAAC,UAAU,EAAE;gBACxC,oDAAoD;gBACpD,KAAmB,UAAgB,EAAhB,qCAAgB,EAAhB,8BAAgB,EAAhB,IAAgB,EAAE;oBAAhC,IAAM,IAAI,yBAAA;oBACd,oBAAoB,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;iBAC1C;aACD;iBAAM;gBACN,wDAAwD;gBACxD,yDAAyD;gBACzD,sCAAsC;gBACtC,IAAI,eAAa,GAAG,IAAI,CAAC;gBACzB,IAAI,GAAC,GAAG,CAAC,CAAC;gBACV,IAAI,iBAAe,GAAG,UAAC,IAAkB;oBACxC,OAAO,GAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE;wBACnC,IAAM,IAAI,GAAG,gBAAgB,CAAC,GAAC,EAAE,CAAC,CAAC;wBACnC,oBAAoB,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;wBAC1C,IAAI,IAAI,CAAC,aAAa,EAAE,GAAG,CAAC,EAAE;4BAC7B,2BAA2B;4BAC3B,mBAAW,CAAC,iBAAe,EAAE,eAAa,CAAC,CAAC;4BAC5C,MAAM;yBACN;qBACD;gBACF,CAAC,CAAC;gBACF,mBAAW,CAAC,iBAAe,EAAE,eAAa,CAAC,CAAC;aAC5C;SACD;IACF,CAAC;IACF,qCAAC;AAAD,CAAC,AA/ED,IA+EC;AAED,mBAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,SAAS,EAAE,IAAI,8BAA8B,EAAE,CAAC,CAAC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IInstantiationService, IConstructorSignature0, ServicesAccessor } from 'vs/platform/instantiation/common/instantiation';\nimport { ILifecycleService, LifecyclePhase } from 'vs/platform/lifecycle/common/lifecycle';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport { runWhenIdle, IdleDeadline } from 'vs/base/common/async';\n\n/**\n * A workbench contribution that will be loaded when the workbench starts and disposed when the workbench shuts down.\n */\nexport interface IWorkbenchContribution {\n\t// Marker Interface\n}\n\nexport namespace Extensions {\n\texport const Workbench = 'workbench.contributions.kind';\n}\n\nexport type IWorkbenchContributionSignature = IConstructorSignature0<IWorkbenchContribution>;\n\nexport interface IWorkbenchContributionsRegistry {\n\n\t/**\n\t * Registers a workbench contribution to the platform that will be loaded when the workbench starts and disposed when\n\t * the workbench shuts down.\n\t *\n\t * @param phase the lifecycle phase when to instantiate the contribution.\n\t */\n\tregisterWorkbenchContribution(contribution: IWorkbenchContributionSignature, phase: LifecyclePhase): void;\n\n\t/**\n\t * Starts the registry by providing the required services.\n\t */\n\tstart(accessor: ServicesAccessor): void;\n}\n\nclass WorkbenchContributionsRegistry implements IWorkbenchContributionsRegistry {\n\tprivate instantiationService: IInstantiationService;\n\tprivate lifecycleService: ILifecycleService;\n\n\tprivate readonly toBeInstantiated: Map<LifecyclePhase, IConstructorSignature0<IWorkbenchContribution>[]> = new Map<LifecyclePhase, IConstructorSignature0<IWorkbenchContribution>[]>();\n\n\tregisterWorkbenchContribution(ctor: IWorkbenchContributionSignature, phase: LifecyclePhase = LifecyclePhase.Starting): void {\n\n\t\t// Instantiate directly if we are already matching the provided phase\n\t\tif (this.instantiationService && this.lifecycleService && this.lifecycleService.phase >= phase) {\n\t\t\tthis.instantiationService.createInstance(ctor);\n\t\t}\n\n\t\t// Otherwise keep contributions by lifecycle phase\n\t\telse {\n\t\t\tlet toBeInstantiated = this.toBeInstantiated.get(phase);\n\t\t\tif (!toBeInstantiated) {\n\t\t\t\ttoBeInstantiated = [];\n\t\t\t\tthis.toBeInstantiated.set(phase, toBeInstantiated);\n\t\t\t}\n\n\t\t\ttoBeInstantiated.push(ctor);\n\t\t}\n\t}\n\n\tstart(accessor: ServicesAccessor): void {\n\t\tthis.instantiationService = accessor.get(IInstantiationService);\n\t\tthis.lifecycleService = accessor.get(ILifecycleService);\n\n\t\t[LifecyclePhase.Starting, LifecyclePhase.Ready, LifecyclePhase.Restored, LifecyclePhase.Eventually].forEach(phase => {\n\t\t\tthis.instantiateByPhase(this.instantiationService, this.lifecycleService, phase);\n\t\t});\n\t}\n\n\tprivate instantiateByPhase(instantiationService: IInstantiationService, lifecycleService: ILifecycleService, phase: LifecyclePhase): void {\n\n\t\t// Instantiate contributions directly when phase is already reached\n\t\tif (lifecycleService.phase >= phase) {\n\t\t\tthis.doInstantiateByPhase(instantiationService, phase);\n\t\t}\n\n\t\t// Otherwise wait for phase to be reached\n\t\telse {\n\t\t\tlifecycleService.when(phase).then(() => {\n\t\t\t\tthis.doInstantiateByPhase(instantiationService, phase);\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate doInstantiateByPhase(instantiationService: IInstantiationService, phase: LifecyclePhase): void {\n\t\tconst toBeInstantiated = this.toBeInstantiated.get(phase);\n\t\tif (toBeInstantiated) {\n\t\t\tthis.toBeInstantiated.delete(phase);\n\t\t\tif (phase !== LifecyclePhase.Eventually) {\n\t\t\t\t// instantiate everything synchronously and blocking\n\t\t\t\tfor (const ctor of toBeInstantiated) {\n\t\t\t\t\tinstantiationService.createInstance(ctor);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// for the Eventually-phase we instantiate contributions\n\t\t\t\t// only when idle. this might take a few idle-busy-cycles\n\t\t\t\t// but will finish within the timeouts\n\t\t\t\tlet forcedTimeout = 3000;\n\t\t\t\tlet i = 0;\n\t\t\t\tlet instantiateSome = (idle: IdleDeadline) => {\n\t\t\t\t\twhile (i < toBeInstantiated.length) {\n\t\t\t\t\t\tconst ctor = toBeInstantiated[i++];\n\t\t\t\t\t\tinstantiationService.createInstance(ctor);\n\t\t\t\t\t\tif (idle.timeRemaining() < 1) {\n\t\t\t\t\t\t\t// time is up -> reschedule\n\t\t\t\t\t\t\trunWhenIdle(instantiateSome, forcedTimeout);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\trunWhenIdle(instantiateSome, forcedTimeout);\n\t\t\t}\n\t\t}\n\t}\n}\n\nRegistry.add(Extensions.Workbench, new WorkbenchContributionsRegistry());\n"]}]}