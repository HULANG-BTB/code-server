{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/oneCursor.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/oneCursor.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/editor/common/controller/cursorCommon\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\", \"vs/editor/common/core/selection\", \"vs/editor/common/model\"], function (require, exports, cursorCommon_1, position_1, range_1, selection_1, model_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class OneCursor {\n        constructor(context) {\n            this._selTrackedRange = null;\n            this._trackSelection = true;\n            this._setState(context, new cursorCommon_1.SingleCursorState(new range_1.Range(1, 1, 1, 1), 0, new position_1.Position(1, 1), 0), new cursorCommon_1.SingleCursorState(new range_1.Range(1, 1, 1, 1), 0, new position_1.Position(1, 1), 0));\n        }\n        dispose(context) {\n            this._removeTrackedRange(context);\n        }\n        startTrackingSelection(context) {\n            this._trackSelection = true;\n            this._updateTrackedRange(context);\n        }\n        stopTrackingSelection(context) {\n            this._trackSelection = false;\n            this._removeTrackedRange(context);\n        }\n        _updateTrackedRange(context) {\n            if (!this._trackSelection) {\n                // don't track the selection\n                return;\n            }\n            this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, model_1.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);\n        }\n        _removeTrackedRange(context) {\n            this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, model_1.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);\n        }\n        asCursorState() {\n            return new cursorCommon_1.CursorState(this.modelState, this.viewState);\n        }\n        readSelectionFromMarkers(context) {\n            const range = context.model._getTrackedRange(this._selTrackedRange);\n            if (this.modelState.selection.getDirection() === selection_1.SelectionDirection.LTR) {\n                return new selection_1.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n            }\n            return new selection_1.Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n        }\n        ensureValidState(context) {\n            this._setState(context, this.modelState, this.viewState);\n        }\n        setState(context, modelState, viewState) {\n            this._setState(context, modelState, viewState);\n        }\n        _setState(context, modelState, viewState) {\n            if (!modelState) {\n                if (!viewState) {\n                    return;\n                }\n                // We only have the view state => compute the model state\n                const selectionStart = context.model.validateRange(context.convertViewRangeToModelRange(viewState.selectionStart));\n                const position = context.model.validatePosition(context.convertViewPositionToModelPosition(viewState.position.lineNumber, viewState.position.column));\n                modelState = new cursorCommon_1.SingleCursorState(selectionStart, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n            }\n            else {\n                // Validate new model state\n                const selectionStart = context.model.validateRange(modelState.selectionStart);\n                const selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n                const position = context.model.validatePosition(modelState.position);\n                const leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n                modelState = new cursorCommon_1.SingleCursorState(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n            }\n            if (!viewState) {\n                // We only have the model state => compute the view state\n                const viewSelectionStart1 = context.convertModelPositionToViewPosition(new position_1.Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n                const viewSelectionStart2 = context.convertModelPositionToViewPosition(new position_1.Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n                const viewSelectionStart = new range_1.Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n                const viewPosition = context.convertModelPositionToViewPosition(modelState.position);\n                viewState = new cursorCommon_1.SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n            }\n            else {\n                // Validate new view state\n                const viewSelectionStart = context.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n                const viewPosition = context.validateViewPosition(viewState.position, modelState.position);\n                viewState = new cursorCommon_1.SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n            }\n            this.modelState = modelState;\n            this.viewState = viewState;\n            this._updateTrackedRange(context);\n        }\n    }\n    exports.OneCursor = OneCursor;\n});\n",null]}