{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/node/ipc.cp.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/node/ipc.cp.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar child_process_1 = require(\"child_process\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar async_1 = require(\"vs/base/common/async\");\nvar objects_1 = require(\"vs/base/common/objects\");\nvar event_1 = require(\"vs/base/common/event\");\nvar processes_1 = require(\"vs/base/node/processes\");\nvar ipc_1 = require(\"vs/base/parts/ipc/common/ipc\");\nvar console_1 = require(\"vs/base/common/console\");\nvar cancellation_1 = require(\"vs/base/common/cancellation\");\nvar errors = require(\"vs/base/common/errors\");\nvar buffer_1 = require(\"vs/base/common/buffer\");\n/**\n * This implementation doesn't perform well since it uses base64 encoding for buffers.\n * We should move all implementations to use named ipc.net, so we stop depending on cp.fork.\n */\nvar Server = /** @class */ (function (_super) {\n    tslib_1.__extends(Server, _super);\n    function Server(ctx) {\n        var _this = _super.call(this, {\n            send: function (r) {\n                try {\n                    if (process.send) {\n                        process.send(r.buffer.toString('base64'));\n                    }\n                }\n                catch (e) { /* not much to do */ }\n            },\n            onMessage: event_1.Event.fromNodeEventEmitter(process, 'message', function (msg) { return buffer_1.VSBuffer.wrap(Buffer.from(msg, 'base64')); })\n        }, ctx) || this;\n        process.once('disconnect', function () { return _this.dispose(); });\n        return _this;\n    }\n    return Server;\n}(ipc_1.ChannelServer));\nexports.Server = Server;\nvar Client = /** @class */ (function () {\n    function Client(modulePath, options) {\n        this.modulePath = modulePath;\n        this.options = options;\n        this.activeRequests = new Set();\n        this.channels = new Map();\n        this._onDidProcessExit = new event_1.Emitter();\n        this.onDidProcessExit = this._onDidProcessExit.event;\n        var timeout = options && options.timeout ? options.timeout : 60000;\n        this.disposeDelayer = new async_1.Delayer(timeout);\n        this.child = null;\n        this._client = null;\n    }\n    Client.prototype.getChannel = function (channelName) {\n        var that = this;\n        return {\n            call: function (command, arg, cancellationToken) {\n                return that.requestPromise(channelName, command, arg, cancellationToken);\n            },\n            listen: function (event, arg) {\n                return that.requestEvent(channelName, event, arg);\n            }\n        };\n    };\n    Client.prototype.requestPromise = function (channelName, name, arg, cancellationToken) {\n        var _this = this;\n        if (cancellationToken === void 0) { cancellationToken = cancellation_1.CancellationToken.None; }\n        if (!this.disposeDelayer) {\n            return Promise.reject(new Error('disposed'));\n        }\n        if (cancellationToken.isCancellationRequested) {\n            return Promise.reject(errors.canceled());\n        }\n        this.disposeDelayer.cancel();\n        var channel = this.getCachedChannel(channelName);\n        var result = async_1.createCancelablePromise(function (token) { return channel.call(name, arg, token); });\n        var cancellationTokenListener = cancellationToken.onCancellationRequested(function () { return result.cancel(); });\n        var disposable = lifecycle_1.toDisposable(function () { return result.cancel(); });\n        this.activeRequests.add(disposable);\n        result.finally(function () {\n            cancellationTokenListener.dispose();\n            _this.activeRequests.delete(disposable);\n            if (_this.activeRequests.size === 0) {\n                _this.disposeDelayer.trigger(function () { return _this.disposeClient(); });\n            }\n        });\n        return result;\n    };\n    Client.prototype.requestEvent = function (channelName, name, arg) {\n        var _this = this;\n        if (!this.disposeDelayer) {\n            return event_1.Event.None;\n        }\n        this.disposeDelayer.cancel();\n        var listener;\n        var emitter = new event_1.Emitter({\n            onFirstListenerAdd: function () {\n                var channel = _this.getCachedChannel(channelName);\n                var event = channel.listen(name, arg);\n                listener = event(emitter.fire, emitter);\n                _this.activeRequests.add(listener);\n            },\n            onLastListenerRemove: function () {\n                _this.activeRequests.delete(listener);\n                listener.dispose();\n                if (_this.activeRequests.size === 0 && _this.disposeDelayer) {\n                    _this.disposeDelayer.trigger(function () { return _this.disposeClient(); });\n                }\n            }\n        });\n        return emitter.event;\n    };\n    Object.defineProperty(Client.prototype, \"client\", {\n        get: function () {\n            var _this = this;\n            if (!this._client) {\n                var args = this.options && this.options.args ? this.options.args : [];\n                var forkOpts = Object.create(null);\n                forkOpts.env = objects_1.assign(objects_1.deepClone(process.env), { 'VSCODE_PARENT_PID': String(process.pid) });\n                if (this.options && this.options.env) {\n                    forkOpts.env = objects_1.assign(forkOpts.env, this.options.env);\n                }\n                if (this.options && this.options.freshExecArgv) {\n                    forkOpts.execArgv = [];\n                }\n                if (this.options && typeof this.options.debug === 'number') {\n                    forkOpts.execArgv = ['--nolazy', '--inspect=' + this.options.debug];\n                }\n                if (this.options && typeof this.options.debugBrk === 'number') {\n                    forkOpts.execArgv = ['--nolazy', '--inspect-brk=' + this.options.debugBrk];\n                }\n                this.child = child_process_1.fork(this.modulePath, args, forkOpts);\n                var onMessageEmitter_1 = new event_1.Emitter();\n                var onRawMessage = event_1.Event.fromNodeEventEmitter(this.child, 'message', function (msg) { return msg; });\n                onRawMessage(function (msg) {\n                    // Handle remote console logs specially\n                    if (console_1.isRemoteConsoleLog(msg)) {\n                        console_1.log(msg, \"IPC Library: \" + _this.options.serverName);\n                        return;\n                    }\n                    // Anything else goes to the outside\n                    onMessageEmitter_1.fire(buffer_1.VSBuffer.wrap(Buffer.from(msg, 'base64')));\n                });\n                var sender_1 = this.options.useQueue ? processes_1.createQueuedSender(this.child) : this.child;\n                var send = function (r) { return _this.child && _this.child.connected && sender_1.send(r.buffer.toString('base64')); };\n                var onMessage = onMessageEmitter_1.event;\n                var protocol = { send: send, onMessage: onMessage };\n                this._client = new ipc_1.ChannelClient(protocol);\n                var onExit_1 = function () { return _this.disposeClient(); };\n                process.once('exit', onExit_1);\n                this.child.on('error', function (err) { return console.warn('IPC \"' + _this.options.serverName + '\" errored with ' + err); });\n                this.child.on('exit', function (code, signal) {\n                    process.removeListener('exit', onExit_1);\n                    _this.activeRequests.forEach(function (r) { return lifecycle_1.dispose(r); });\n                    _this.activeRequests.clear();\n                    if (code !== 0 && signal !== 'SIGTERM') {\n                        console.warn('IPC \"' + _this.options.serverName + '\" crashed with exit code ' + code + ' and signal ' + signal);\n                    }\n                    if (_this.disposeDelayer) {\n                        _this.disposeDelayer.cancel();\n                    }\n                    _this.disposeClient();\n                    _this._onDidProcessExit.fire({ code: code, signal: signal });\n                });\n            }\n            return this._client;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Client.prototype.getCachedChannel = function (name) {\n        var channel = this.channels.get(name);\n        if (!channel) {\n            channel = this.client.getChannel(name);\n            this.channels.set(name, channel);\n        }\n        return channel;\n    };\n    Client.prototype.disposeClient = function () {\n        if (this._client) {\n            if (this.child) {\n                this.child.kill();\n                this.child = null;\n            }\n            this._client = null;\n            this.channels.clear();\n        }\n    };\n    Client.prototype.dispose = function () {\n        this._onDidProcessExit.dispose();\n        this.disposeDelayer.cancel();\n        this.disposeDelayer = null; // StrictNullOverride: nulling out ok in dispose\n        this.disposeClient();\n        this.activeRequests.clear();\n    };\n    return Client;\n}());\nexports.Client = Client;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/node/ipc.cp.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/node/ipc.cp.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ChildProcess, fork, ForkOptions } from 'child_process';\nimport { IDisposable, toDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { Delayer, createCancelablePromise } from 'vs/base/common/async';\nimport { deepClone, assign } from 'vs/base/common/objects';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { createQueuedSender } from 'vs/base/node/processes';\nimport { IChannel, ChannelServer as IPCServer, ChannelClient as IPCClient, IChannelClient } from 'vs/base/parts/ipc/common/ipc';\nimport { isRemoteConsoleLog, log } from 'vs/base/common/console';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\nimport { VSBuffer } from 'vs/base/common/buffer';\n\n/**\n * This implementation doesn't perform well since it uses base64 encoding for buffers.\n * We should move all implementations to use named ipc.net, so we stop depending on cp.fork.\n */\n\nexport class Server<TContext extends string> extends IPCServer<TContext> {\n\tconstructor(ctx: TContext) {\n\t\tsuper({\n\t\t\tsend: r => {\n\t\t\t\ttry {\n\t\t\t\t\tif (process.send) {\n\t\t\t\t\t\tprocess.send((<Buffer>r.buffer).toString('base64'));\n\t\t\t\t\t}\n\t\t\t\t} catch (e) { /* not much to do */ }\n\t\t\t},\n\t\t\tonMessage: Event.fromNodeEventEmitter(process, 'message', msg => VSBuffer.wrap(Buffer.from(msg, 'base64')))\n\t\t}, ctx);\n\n\t\tprocess.once('disconnect', () => this.dispose());\n\t}\n}\n\nexport interface IIPCOptions {\n\n\t/**\n\t * A descriptive name for the server this connection is to. Used in logging.\n\t */\n\tserverName: string;\n\n\t/**\n\t * Time in millies before killing the ipc process. The next request after killing will start it again.\n\t */\n\ttimeout?: number;\n\n\t/**\n\t * Arguments to the module to execute.\n\t */\n\targs?: string[];\n\n\t/**\n\t * Environment key-value pairs to be passed to the process that gets spawned for the ipc.\n\t */\n\tenv?: any;\n\n\t/**\n\t * Allows to assign a debug port for debugging the application executed.\n\t */\n\tdebug?: number;\n\n\t/**\n\t * Allows to assign a debug port for debugging the application and breaking it on the first line.\n\t */\n\tdebugBrk?: number;\n\n\t/**\n\t * See https://github.com/Microsoft/vscode/issues/27665\n\t * Allows to pass in fresh execArgv to the forked process such that it doesn't inherit them from `process.execArgv`.\n\t * e.g. Launching the extension host process with `--inspect-brk=xxx` and then forking a process from the extension host\n\t * results in the forked process inheriting `--inspect-brk=xxx`.\n\t */\n\tfreshExecArgv?: boolean;\n\n\t/**\n\t * Enables our createQueuedSender helper for this Client. Uses a queue when the internal Node.js queue is\n\t * full of messages - see notes on that method.\n\t */\n\tuseQueue?: boolean;\n}\n\nexport class Client implements IChannelClient, IDisposable {\n\n\tprivate disposeDelayer: Delayer<void>;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate child: ChildProcess | null;\n\tprivate _client: IPCClient | null;\n\tprivate channels = new Map<string, IChannel>();\n\n\tprivate _onDidProcessExit = new Emitter<{ code: number, signal: string }>();\n\treadonly onDidProcessExit = this._onDidProcessExit.event;\n\n\tconstructor(private modulePath: string, private options: IIPCOptions) {\n\t\tconst timeout = options && options.timeout ? options.timeout : 60000;\n\t\tthis.disposeDelayer = new Delayer<void>(timeout);\n\t\tthis.child = null;\n\t\tthis._client = null;\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\t\treturn that.requestPromise<T>(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg?: any) {\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprotected requestPromise<T>(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<T> {\n\t\tif (!this.disposeDelayer) {\n\t\t\treturn Promise.reject(new Error('disposed'));\n\t\t}\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(errors.canceled());\n\t\t}\n\n\t\tthis.disposeDelayer.cancel();\n\n\t\tconst channel = this.getCachedChannel(channelName);\n\t\tconst result = createCancelablePromise(token => channel.call<T>(name, arg, token));\n\t\tconst cancellationTokenListener = cancellationToken.onCancellationRequested(() => result.cancel());\n\n\t\tconst disposable = toDisposable(() => result.cancel());\n\t\tthis.activeRequests.add(disposable);\n\n\t\tresult.finally(() => {\n\t\t\tcancellationTokenListener.dispose();\n\t\t\tthis.activeRequests.delete(disposable);\n\n\t\t\tif (this.activeRequests.size === 0) {\n\t\t\t\tthis.disposeDelayer.trigger(() => this.disposeClient());\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tprotected requestEvent<T>(channelName: string, name: string, arg?: any): Event<T> {\n\t\tif (!this.disposeDelayer) {\n\t\t\treturn Event.None;\n\t\t}\n\n\t\tthis.disposeDelayer.cancel();\n\n\t\tlet listener: IDisposable;\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tconst channel = this.getCachedChannel(channelName);\n\t\t\t\tconst event: Event<T> = channel.listen(name, arg);\n\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t\tthis.activeRequests.add(listener);\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tthis.activeRequests.delete(listener);\n\t\t\t\tlistener.dispose();\n\n\t\t\t\tif (this.activeRequests.size === 0 && this.disposeDelayer) {\n\t\t\t\t\tthis.disposeDelayer.trigger(() => this.disposeClient());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate get client(): IPCClient {\n\t\tif (!this._client) {\n\t\t\tconst args = this.options && this.options.args ? this.options.args : [];\n\t\t\tconst forkOpts: ForkOptions = Object.create(null);\n\n\t\t\tforkOpts.env = assign(deepClone(process.env), { 'VSCODE_PARENT_PID': String(process.pid) });\n\n\t\t\tif (this.options && this.options.env) {\n\t\t\t\tforkOpts.env = assign(forkOpts.env, this.options.env);\n\t\t\t}\n\n\t\t\tif (this.options && this.options.freshExecArgv) {\n\t\t\t\tforkOpts.execArgv = [];\n\t\t\t}\n\n\t\t\tif (this.options && typeof this.options.debug === 'number') {\n\t\t\t\tforkOpts.execArgv = ['--nolazy', '--inspect=' + this.options.debug];\n\t\t\t}\n\n\t\t\tif (this.options && typeof this.options.debugBrk === 'number') {\n\t\t\t\tforkOpts.execArgv = ['--nolazy', '--inspect-brk=' + this.options.debugBrk];\n\t\t\t}\n\n\t\t\tthis.child = fork(this.modulePath, args, forkOpts);\n\n\t\t\tconst onMessageEmitter = new Emitter<VSBuffer>();\n\t\t\tconst onRawMessage = Event.fromNodeEventEmitter(this.child, 'message', msg => msg);\n\n\t\t\tonRawMessage(msg => {\n\n\t\t\t\t// Handle remote console logs specially\n\t\t\t\tif (isRemoteConsoleLog(msg)) {\n\t\t\t\t\tlog(msg, `IPC Library: ${this.options.serverName}`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Anything else goes to the outside\n\t\t\t\tonMessageEmitter.fire(VSBuffer.wrap(Buffer.from(msg, 'base64')));\n\t\t\t});\n\n\t\t\tconst sender = this.options.useQueue ? createQueuedSender(this.child) : this.child;\n\t\t\tconst send = (r: VSBuffer) => this.child && this.child.connected && sender.send((<Buffer>r.buffer).toString('base64'));\n\t\t\tconst onMessage = onMessageEmitter.event;\n\t\t\tconst protocol = { send, onMessage };\n\n\t\t\tthis._client = new IPCClient(protocol);\n\n\t\t\tconst onExit = () => this.disposeClient();\n\t\t\tprocess.once('exit', onExit);\n\n\t\t\tthis.child.on('error', err => console.warn('IPC \"' + this.options.serverName + '\" errored with ' + err));\n\n\t\t\tthis.child.on('exit', (code: any, signal: any) => {\n\t\t\t\tprocess.removeListener('exit', onExit);\n\n\t\t\t\tthis.activeRequests.forEach(r => dispose(r));\n\t\t\t\tthis.activeRequests.clear();\n\n\t\t\t\tif (code !== 0 && signal !== 'SIGTERM') {\n\t\t\t\t\tconsole.warn('IPC \"' + this.options.serverName + '\" crashed with exit code ' + code + ' and signal ' + signal);\n\t\t\t\t}\n\n\t\t\t\tif (this.disposeDelayer) {\n\t\t\t\t\tthis.disposeDelayer.cancel();\n\t\t\t\t}\n\t\t\t\tthis.disposeClient();\n\t\t\t\tthis._onDidProcessExit.fire({ code, signal });\n\t\t\t});\n\t\t}\n\n\t\treturn this._client;\n\t}\n\n\tprivate getCachedChannel(name: string): IChannel {\n\t\tlet channel = this.channels.get(name);\n\n\t\tif (!channel) {\n\t\t\tchannel = this.client.getChannel(name);\n\t\t\tthis.channels.set(name, channel);\n\t\t}\n\n\t\treturn channel;\n\t}\n\n\tprivate disposeClient() {\n\t\tif (this._client) {\n\t\t\tif (this.child) {\n\t\t\t\tthis.child.kill();\n\t\t\t\tthis.child = null;\n\t\t\t}\n\t\t\tthis._client = null;\n\t\t\tthis.channels.clear();\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis._onDidProcessExit.dispose();\n\t\tthis.disposeDelayer.cancel();\n\t\tthis.disposeDelayer = null!; // StrictNullOverride: nulling out ok in dispose\n\t\tthis.disposeClient();\n\t\tthis.activeRequests.clear();\n\t}\n}\n"]}]}