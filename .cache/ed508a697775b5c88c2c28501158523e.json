{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/model/intervalTree.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/intervalTree.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/editor/common/model\"], function (require, exports, model_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    //\n    // The red-black tree is based on the \"Introduction to Algorithms\" by Cormen, Leiserson and Rivest.\n    //\n    var ClassName;\n    (function (ClassName) {\n        ClassName[\"EditorHintDecoration\"] = \"squiggly-hint\";\n        ClassName[\"EditorInfoDecoration\"] = \"squiggly-info\";\n        ClassName[\"EditorWarningDecoration\"] = \"squiggly-warning\";\n        ClassName[\"EditorErrorDecoration\"] = \"squiggly-error\";\n        ClassName[\"EditorUnnecessaryDecoration\"] = \"squiggly-unnecessary\";\n        ClassName[\"EditorUnnecessaryInlineDecoration\"] = \"squiggly-inline-unnecessary\";\n    })(ClassName = exports.ClassName || (exports.ClassName = {}));\n    var NodeColor;\n    (function (NodeColor) {\n        NodeColor[NodeColor[\"Black\"] = 0] = \"Black\";\n        NodeColor[NodeColor[\"Red\"] = 1] = \"Red\";\n    })(NodeColor = exports.NodeColor || (exports.NodeColor = {}));\n    var Constants;\n    (function (Constants) {\n        Constants[Constants[\"ColorMask\"] = 1] = \"ColorMask\";\n        Constants[Constants[\"ColorMaskInverse\"] = 254] = \"ColorMaskInverse\";\n        Constants[Constants[\"ColorOffset\"] = 0] = \"ColorOffset\";\n        Constants[Constants[\"IsVisitedMask\"] = 2] = \"IsVisitedMask\";\n        Constants[Constants[\"IsVisitedMaskInverse\"] = 253] = \"IsVisitedMaskInverse\";\n        Constants[Constants[\"IsVisitedOffset\"] = 1] = \"IsVisitedOffset\";\n        Constants[Constants[\"IsForValidationMask\"] = 4] = \"IsForValidationMask\";\n        Constants[Constants[\"IsForValidationMaskInverse\"] = 251] = \"IsForValidationMaskInverse\";\n        Constants[Constants[\"IsForValidationOffset\"] = 2] = \"IsForValidationOffset\";\n        Constants[Constants[\"IsInOverviewRulerMask\"] = 8] = \"IsInOverviewRulerMask\";\n        Constants[Constants[\"IsInOverviewRulerMaskInverse\"] = 247] = \"IsInOverviewRulerMaskInverse\";\n        Constants[Constants[\"IsInOverviewRulerOffset\"] = 3] = \"IsInOverviewRulerOffset\";\n        Constants[Constants[\"StickinessMask\"] = 48] = \"StickinessMask\";\n        Constants[Constants[\"StickinessMaskInverse\"] = 207] = \"StickinessMaskInverse\";\n        Constants[Constants[\"StickinessOffset\"] = 4] = \"StickinessOffset\";\n        Constants[Constants[\"CollapseOnReplaceEditMask\"] = 64] = \"CollapseOnReplaceEditMask\";\n        Constants[Constants[\"CollapseOnReplaceEditMaskInverse\"] = 191] = \"CollapseOnReplaceEditMaskInverse\";\n        Constants[Constants[\"CollapseOnReplaceEditOffset\"] = 6] = \"CollapseOnReplaceEditOffset\";\n        /**\n         * Due to how deletion works (in order to avoid always walking the right subtree of the deleted node),\n         * the deltas for nodes can grow and shrink dramatically. It has been observed, in practice, that unless\n         * the deltas are corrected, integer overflow will occur.\n         *\n         * The integer overflow occurs when 53 bits are used in the numbers, but we will try to avoid it as\n         * a node's delta gets below a negative 30 bits number.\n         *\n         * MIN SMI (SMall Integer) as defined in v8.\n         * one bit is lost for boxing/unboxing flag.\n         * one bit is lost for sign flag.\n         * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n         */\n        Constants[Constants[\"MIN_SAFE_DELTA\"] = -1073741824] = \"MIN_SAFE_DELTA\";\n        /**\n         * MAX SMI (SMall Integer) as defined in v8.\n         * one bit is lost for boxing/unboxing flag.\n         * one bit is lost for sign flag.\n         * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n         */\n        Constants[Constants[\"MAX_SAFE_DELTA\"] = 1073741824] = \"MAX_SAFE_DELTA\";\n    })(Constants || (Constants = {}));\n    function getNodeColor(node) {\n        return ((node.metadata & Constants.ColorMask) >>> Constants.ColorOffset);\n    }\n    exports.getNodeColor = getNodeColor;\n    function setNodeColor(node, color) {\n        node.metadata = ((node.metadata & Constants.ColorMaskInverse) | (color << Constants.ColorOffset));\n    }\n    function getNodeIsVisited(node) {\n        return ((node.metadata & Constants.IsVisitedMask) >>> Constants.IsVisitedOffset) === 1;\n    }\n    function setNodeIsVisited(node, value) {\n        node.metadata = ((node.metadata & Constants.IsVisitedMaskInverse) | ((value ? 1 : 0) << Constants.IsVisitedOffset));\n    }\n    function getNodeIsForValidation(node) {\n        return ((node.metadata & Constants.IsForValidationMask) >>> Constants.IsForValidationOffset) === 1;\n    }\n    function setNodeIsForValidation(node, value) {\n        node.metadata = ((node.metadata & Constants.IsForValidationMaskInverse) | ((value ? 1 : 0) << Constants.IsForValidationOffset));\n    }\n    function getNodeIsInOverviewRuler(node) {\n        return ((node.metadata & Constants.IsInOverviewRulerMask) >>> Constants.IsInOverviewRulerOffset) === 1;\n    }\n    exports.getNodeIsInOverviewRuler = getNodeIsInOverviewRuler;\n    function setNodeIsInOverviewRuler(node, value) {\n        node.metadata = ((node.metadata & Constants.IsInOverviewRulerMaskInverse) | ((value ? 1 : 0) << Constants.IsInOverviewRulerOffset));\n    }\n    function getNodeStickiness(node) {\n        return ((node.metadata & Constants.StickinessMask) >>> Constants.StickinessOffset);\n    }\n    function _setNodeStickiness(node, stickiness) {\n        node.metadata = ((node.metadata & Constants.StickinessMaskInverse) | (stickiness << Constants.StickinessOffset));\n    }\n    function getCollapseOnReplaceEdit(node) {\n        return ((node.metadata & Constants.CollapseOnReplaceEditMask) >>> Constants.CollapseOnReplaceEditOffset) === 1;\n    }\n    function setCollapseOnReplaceEdit(node, value) {\n        node.metadata = ((node.metadata & Constants.CollapseOnReplaceEditMaskInverse) | ((value ? 1 : 0) << Constants.CollapseOnReplaceEditOffset));\n    }\n    function setNodeStickiness(node, stickiness) {\n        _setNodeStickiness(node, stickiness);\n    }\n    exports.setNodeStickiness = setNodeStickiness;\n    class IntervalNode {\n        constructor(id, start, end) {\n            this.metadata = 0;\n            this.parent = this;\n            this.left = this;\n            this.right = this;\n            setNodeColor(this, NodeColor.Red);\n            this.start = start;\n            this.end = end;\n            // FORCE_OVERFLOWING_TEST: this.delta = start;\n            this.delta = 0;\n            this.maxEnd = end;\n            this.id = id;\n            this.ownerId = 0;\n            this.options = null;\n            setNodeIsForValidation(this, false);\n            _setNodeStickiness(this, model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges);\n            setNodeIsInOverviewRuler(this, false);\n            setCollapseOnReplaceEdit(this, false);\n            this.cachedVersionId = 0;\n            this.cachedAbsoluteStart = start;\n            this.cachedAbsoluteEnd = end;\n            this.range = null;\n            setNodeIsVisited(this, false);\n        }\n        reset(versionId, start, end, range) {\n            this.start = start;\n            this.end = end;\n            this.maxEnd = end;\n            this.cachedVersionId = versionId;\n            this.cachedAbsoluteStart = start;\n            this.cachedAbsoluteEnd = end;\n            this.range = range;\n        }\n        setOptions(options) {\n            this.options = options;\n            let className = this.options.className;\n            setNodeIsForValidation(this, (className === ClassName.EditorErrorDecoration\n                || className === ClassName.EditorWarningDecoration\n                || className === ClassName.EditorInfoDecoration));\n            _setNodeStickiness(this, this.options.stickiness);\n            setNodeIsInOverviewRuler(this, (this.options.overviewRuler && this.options.overviewRuler.color) ? true : false);\n            setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n        }\n        setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n            if (this.cachedVersionId !== cachedVersionId) {\n                this.range = null;\n            }\n            this.cachedVersionId = cachedVersionId;\n            this.cachedAbsoluteStart = absoluteStart;\n            this.cachedAbsoluteEnd = absoluteEnd;\n        }\n        detach() {\n            this.parent = null;\n            this.left = null;\n            this.right = null;\n        }\n    }\n    exports.IntervalNode = IntervalNode;\n    exports.SENTINEL = new IntervalNode(null, 0, 0);\n    exports.SENTINEL.parent = exports.SENTINEL;\n    exports.SENTINEL.left = exports.SENTINEL;\n    exports.SENTINEL.right = exports.SENTINEL;\n    setNodeColor(exports.SENTINEL, NodeColor.Black);\n    class IntervalTree {\n        constructor() {\n            this.root = exports.SENTINEL;\n            this.requestNormalizeDelta = false;\n        }\n        intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n            if (this.root === exports.SENTINEL) {\n                return [];\n            }\n            return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        }\n        search(filterOwnerId, filterOutValidation, cachedVersionId) {\n            if (this.root === exports.SENTINEL) {\n                return [];\n            }\n            return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\n        }\n        /**\n         * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n         */\n        collectNodesFromOwner(ownerId) {\n            return collectNodesFromOwner(this, ownerId);\n        }\n        /**\n         * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n         */\n        collectNodesPostOrder() {\n            return collectNodesPostOrder(this);\n        }\n        insert(node) {\n            rbTreeInsert(this, node);\n            this._normalizeDeltaIfNecessary();\n        }\n        delete(node) {\n            rbTreeDelete(this, node);\n            this._normalizeDeltaIfNecessary();\n        }\n        resolveNode(node, cachedVersionId) {\n            const initialNode = node;\n            let delta = 0;\n            while (node !== this.root) {\n                if (node === node.parent.right) {\n                    delta += node.parent.delta;\n                }\n                node = node.parent;\n            }\n            const nodeStart = initialNode.start + delta;\n            const nodeEnd = initialNode.end + delta;\n            initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        }\n        acceptReplace(offset, length, textLength, forceMoveMarkers) {\n            // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n            // (1) collect all nodes that are intersecting this edit as nodes of interest\n            const nodesOfInterest = searchForEditing(this, offset, offset + length);\n            // (2) remove all nodes that are intersecting this edit\n            for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n                const node = nodesOfInterest[i];\n                rbTreeDelete(this, node);\n            }\n            this._normalizeDeltaIfNecessary();\n            // (3) edit all tree nodes except the nodes of interest\n            noOverlapReplace(this, offset, offset + length, textLength);\n            this._normalizeDeltaIfNecessary();\n            // (4) edit the nodes of interest and insert them back in the tree\n            for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n                const node = nodesOfInterest[i];\n                node.start = node.cachedAbsoluteStart;\n                node.end = node.cachedAbsoluteEnd;\n                nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n                node.maxEnd = node.end;\n                rbTreeInsert(this, node);\n            }\n            this._normalizeDeltaIfNecessary();\n        }\n        getAllInOrder() {\n            return search(this, 0, false, 0);\n        }\n        _normalizeDeltaIfNecessary() {\n            if (!this.requestNormalizeDelta) {\n                return;\n            }\n            this.requestNormalizeDelta = false;\n            normalizeDelta(this);\n        }\n    }\n    exports.IntervalTree = IntervalTree;\n    //#region Delta Normalization\n    function normalizeDelta(T) {\n        let node = T.root;\n        let delta = 0;\n        while (node !== exports.SENTINEL) {\n            if (node.left !== exports.SENTINEL && !getNodeIsVisited(node.left)) {\n                // go left\n                node = node.left;\n                continue;\n            }\n            if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {\n                // go right\n                delta += node.delta;\n                node = node.right;\n                continue;\n            }\n            // handle current node\n            node.start = delta + node.start;\n            node.end = delta + node.end;\n            node.delta = 0;\n            recomputeMaxEnd(node);\n            setNodeIsVisited(node, true);\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n        }\n        setNodeIsVisited(T.root, false);\n    }\n    //#endregion\n    //#region Editing\n    var MarkerMoveSemantics;\n    (function (MarkerMoveSemantics) {\n        MarkerMoveSemantics[MarkerMoveSemantics[\"MarkerDefined\"] = 0] = \"MarkerDefined\";\n        MarkerMoveSemantics[MarkerMoveSemantics[\"ForceMove\"] = 1] = \"ForceMove\";\n        MarkerMoveSemantics[MarkerMoveSemantics[\"ForceStay\"] = 2] = \"ForceStay\";\n    })(MarkerMoveSemantics || (MarkerMoveSemantics = {}));\n    function adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n        if (markerOffset < checkOffset) {\n            return true;\n        }\n        if (markerOffset > checkOffset) {\n            return false;\n        }\n        if (moveSemantics === MarkerMoveSemantics.ForceMove) {\n            return false;\n        }\n        if (moveSemantics === MarkerMoveSemantics.ForceStay) {\n            return true;\n        }\n        return markerStickToPreviousCharacter;\n    }\n    /**\n     * This is a lot more complicated than strictly necessary to maintain the same behaviour\n     * as when decorations were implemented using two markers.\n     */\n    function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n        const nodeStickiness = getNodeStickiness(node);\n        const startStickToPreviousCharacter = (nodeStickiness === model_1.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges\n            || nodeStickiness === model_1.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore);\n        const endStickToPreviousCharacter = (nodeStickiness === model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges\n            || nodeStickiness === model_1.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore);\n        const deletingCnt = (end - start);\n        const insertingCnt = textLength;\n        const commonLength = Math.min(deletingCnt, insertingCnt);\n        const nodeStart = node.start;\n        let startDone = false;\n        const nodeEnd = node.end;\n        let endDone = false;\n        if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n            // This edit encompasses the entire decoration range\n            // and the decoration has asked to become collapsed\n            node.start = start;\n            startDone = true;\n            node.end = start;\n            endDone = true;\n        }\n        {\n            const moveSemantics = forceMoveMarkers ? MarkerMoveSemantics.ForceMove : (deletingCnt > 0 ? MarkerMoveSemantics.ForceStay : MarkerMoveSemantics.MarkerDefined);\n            if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n                startDone = true;\n            }\n            if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n                endDone = true;\n            }\n        }\n        if (commonLength > 0 && !forceMoveMarkers) {\n            const moveSemantics = (deletingCnt > insertingCnt ? MarkerMoveSemantics.ForceStay : MarkerMoveSemantics.MarkerDefined);\n            if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n                startDone = true;\n            }\n            if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n                endDone = true;\n            }\n        }\n        {\n            const moveSemantics = forceMoveMarkers ? MarkerMoveSemantics.ForceMove : MarkerMoveSemantics.MarkerDefined;\n            if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n                node.start = start + insertingCnt;\n                startDone = true;\n            }\n            if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n                node.end = start + insertingCnt;\n                endDone = true;\n            }\n        }\n        // Finish\n        const deltaColumn = (insertingCnt - deletingCnt);\n        if (!startDone) {\n            node.start = Math.max(0, nodeStart + deltaColumn);\n        }\n        if (!endDone) {\n            node.end = Math.max(0, nodeEnd + deltaColumn);\n        }\n        if (node.start > node.end) {\n            node.end = node.start;\n        }\n    }\n    exports.nodeAcceptEdit = nodeAcceptEdit;\n    function searchForEditing(T, start, end) {\n        // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n        // Now, it is known that two intervals A and B overlap only when both\n        // A.low <= B.high and A.high >= B.low. When searching the trees for\n        // nodes overlapping with a given interval, you can immediately skip:\n        //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n        //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n        let node = T.root;\n        let delta = 0;\n        let nodeMaxEnd = 0;\n        let nodeStart = 0;\n        let nodeEnd = 0;\n        let result = [];\n        let resultLen = 0;\n        while (node !== exports.SENTINEL) {\n            if (getNodeIsVisited(node)) {\n                // going up from this node\n                setNodeIsVisited(node.left, false);\n                setNodeIsVisited(node.right, false);\n                if (node === node.parent.right) {\n                    delta -= node.parent.delta;\n                }\n                node = node.parent;\n                continue;\n            }\n            if (!getNodeIsVisited(node.left)) {\n                // first time seeing this node\n                nodeMaxEnd = delta + node.maxEnd;\n                if (nodeMaxEnd < start) {\n                    // cover case b) from above\n                    // there is no need to search this node or its children\n                    setNodeIsVisited(node, true);\n                    continue;\n                }\n                if (node.left !== exports.SENTINEL) {\n                    // go left\n                    node = node.left;\n                    continue;\n                }\n            }\n            // handle current node\n            nodeStart = delta + node.start;\n            if (nodeStart > end) {\n                // cover case a) from above\n                // there is no need to search this node or its right subtree\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            nodeEnd = delta + node.end;\n            if (nodeEnd >= start) {\n                node.setCachedOffsets(nodeStart, nodeEnd, 0);\n                result[resultLen++] = node;\n            }\n            setNodeIsVisited(node, true);\n            if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {\n                // go right\n                delta += node.delta;\n                node = node.right;\n                continue;\n            }\n        }\n        setNodeIsVisited(T.root, false);\n        return result;\n    }\n    function noOverlapReplace(T, start, end, textLength) {\n        // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n        // Now, it is known that two intervals A and B overlap only when both\n        // A.low <= B.high and A.high >= B.low. When searching the trees for\n        // nodes overlapping with a given interval, you can immediately skip:\n        //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n        //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n        let node = T.root;\n        let delta = 0;\n        let nodeMaxEnd = 0;\n        let nodeStart = 0;\n        const editDelta = (textLength - (end - start));\n        while (node !== exports.SENTINEL) {\n            if (getNodeIsVisited(node)) {\n                // going up from this node\n                setNodeIsVisited(node.left, false);\n                setNodeIsVisited(node.right, false);\n                if (node === node.parent.right) {\n                    delta -= node.parent.delta;\n                }\n                recomputeMaxEnd(node);\n                node = node.parent;\n                continue;\n            }\n            if (!getNodeIsVisited(node.left)) {\n                // first time seeing this node\n                nodeMaxEnd = delta + node.maxEnd;\n                if (nodeMaxEnd < start) {\n                    // cover case b) from above\n                    // there is no need to search this node or its children\n                    setNodeIsVisited(node, true);\n                    continue;\n                }\n                if (node.left !== exports.SENTINEL) {\n                    // go left\n                    node = node.left;\n                    continue;\n                }\n            }\n            // handle current node\n            nodeStart = delta + node.start;\n            if (nodeStart > end) {\n                node.start += editDelta;\n                node.end += editDelta;\n                node.delta += editDelta;\n                if (node.delta < Constants.MIN_SAFE_DELTA || node.delta > Constants.MAX_SAFE_DELTA) {\n                    T.requestNormalizeDelta = true;\n                }\n                // cover case a) from above\n                // there is no need to search this node or its right subtree\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            setNodeIsVisited(node, true);\n            if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {\n                // go right\n                delta += node.delta;\n                node = node.right;\n                continue;\n            }\n        }\n        setNodeIsVisited(T.root, false);\n    }\n    //#endregion\n    //#region Searching\n    function collectNodesFromOwner(T, ownerId) {\n        let node = T.root;\n        let result = [];\n        let resultLen = 0;\n        while (node !== exports.SENTINEL) {\n            if (getNodeIsVisited(node)) {\n                // going up from this node\n                setNodeIsVisited(node.left, false);\n                setNodeIsVisited(node.right, false);\n                node = node.parent;\n                continue;\n            }\n            if (node.left !== exports.SENTINEL && !getNodeIsVisited(node.left)) {\n                // go left\n                node = node.left;\n                continue;\n            }\n            // handle current node\n            if (node.ownerId === ownerId) {\n                result[resultLen++] = node;\n            }\n            setNodeIsVisited(node, true);\n            if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {\n                // go right\n                node = node.right;\n                continue;\n            }\n        }\n        setNodeIsVisited(T.root, false);\n        return result;\n    }\n    function collectNodesPostOrder(T) {\n        let node = T.root;\n        let result = [];\n        let resultLen = 0;\n        while (node !== exports.SENTINEL) {\n            if (getNodeIsVisited(node)) {\n                // going up from this node\n                setNodeIsVisited(node.left, false);\n                setNodeIsVisited(node.right, false);\n                node = node.parent;\n                continue;\n            }\n            if (node.left !== exports.SENTINEL && !getNodeIsVisited(node.left)) {\n                // go left\n                node = node.left;\n                continue;\n            }\n            if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {\n                // go right\n                node = node.right;\n                continue;\n            }\n            // handle current node\n            result[resultLen++] = node;\n            setNodeIsVisited(node, true);\n        }\n        setNodeIsVisited(T.root, false);\n        return result;\n    }\n    function search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\n        let node = T.root;\n        let delta = 0;\n        let nodeStart = 0;\n        let nodeEnd = 0;\n        let result = [];\n        let resultLen = 0;\n        while (node !== exports.SENTINEL) {\n            if (getNodeIsVisited(node)) {\n                // going up from this node\n                setNodeIsVisited(node.left, false);\n                setNodeIsVisited(node.right, false);\n                if (node === node.parent.right) {\n                    delta -= node.parent.delta;\n                }\n                node = node.parent;\n                continue;\n            }\n            if (node.left !== exports.SENTINEL && !getNodeIsVisited(node.left)) {\n                // go left\n                node = node.left;\n                continue;\n            }\n            // handle current node\n            nodeStart = delta + node.start;\n            nodeEnd = delta + node.end;\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n            setNodeIsVisited(node, true);\n            if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {\n                // go right\n                delta += node.delta;\n                node = node.right;\n                continue;\n            }\n        }\n        setNodeIsVisited(T.root, false);\n        return result;\n    }\n    function intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\n        // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n        // Now, it is known that two intervals A and B overlap only when both\n        // A.low <= B.high and A.high >= B.low. When searching the trees for\n        // nodes overlapping with a given interval, you can immediately skip:\n        //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n        //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n        let node = T.root;\n        let delta = 0;\n        let nodeMaxEnd = 0;\n        let nodeStart = 0;\n        let nodeEnd = 0;\n        let result = [];\n        let resultLen = 0;\n        while (node !== exports.SENTINEL) {\n            if (getNodeIsVisited(node)) {\n                // going up from this node\n                setNodeIsVisited(node.left, false);\n                setNodeIsVisited(node.right, false);\n                if (node === node.parent.right) {\n                    delta -= node.parent.delta;\n                }\n                node = node.parent;\n                continue;\n            }\n            if (!getNodeIsVisited(node.left)) {\n                // first time seeing this node\n                nodeMaxEnd = delta + node.maxEnd;\n                if (nodeMaxEnd < intervalStart) {\n                    // cover case b) from above\n                    // there is no need to search this node or its children\n                    setNodeIsVisited(node, true);\n                    continue;\n                }\n                if (node.left !== exports.SENTINEL) {\n                    // go left\n                    node = node.left;\n                    continue;\n                }\n            }\n            // handle current node\n            nodeStart = delta + node.start;\n            if (nodeStart > intervalEnd) {\n                // cover case a) from above\n                // there is no need to search this node or its right subtree\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            nodeEnd = delta + node.end;\n            if (nodeEnd >= intervalStart) {\n                // There is overlap\n                node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n                let include = true;\n                if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                    include = false;\n                }\n                if (filterOutValidation && getNodeIsForValidation(node)) {\n                    include = false;\n                }\n                if (include) {\n                    result[resultLen++] = node;\n                }\n            }\n            setNodeIsVisited(node, true);\n            if (node.right !== exports.SENTINEL && !getNodeIsVisited(node.right)) {\n                // go right\n                delta += node.delta;\n                node = node.right;\n                continue;\n            }\n        }\n        setNodeIsVisited(T.root, false);\n        return result;\n    }\n    //#endregion\n    //#region Insertion\n    function rbTreeInsert(T, newNode) {\n        if (T.root === exports.SENTINEL) {\n            newNode.parent = exports.SENTINEL;\n            newNode.left = exports.SENTINEL;\n            newNode.right = exports.SENTINEL;\n            setNodeColor(newNode, NodeColor.Black);\n            T.root = newNode;\n            return T.root;\n        }\n        treeInsert(T, newNode);\n        recomputeMaxEndWalkToRoot(newNode.parent);\n        // repair tree\n        let x = newNode;\n        while (x !== T.root && getNodeColor(x.parent) === NodeColor.Red) {\n            if (x.parent === x.parent.parent.left) {\n                const y = x.parent.parent.right;\n                if (getNodeColor(y) === NodeColor.Red) {\n                    setNodeColor(x.parent, NodeColor.Black);\n                    setNodeColor(y, NodeColor.Black);\n                    setNodeColor(x.parent.parent, NodeColor.Red);\n                    x = x.parent.parent;\n                }\n                else {\n                    if (x === x.parent.right) {\n                        x = x.parent;\n                        leftRotate(T, x);\n                    }\n                    setNodeColor(x.parent, NodeColor.Black);\n                    setNodeColor(x.parent.parent, NodeColor.Red);\n                    rightRotate(T, x.parent.parent);\n                }\n            }\n            else {\n                const y = x.parent.parent.left;\n                if (getNodeColor(y) === NodeColor.Red) {\n                    setNodeColor(x.parent, NodeColor.Black);\n                    setNodeColor(y, NodeColor.Black);\n                    setNodeColor(x.parent.parent, NodeColor.Red);\n                    x = x.parent.parent;\n                }\n                else {\n                    if (x === x.parent.left) {\n                        x = x.parent;\n                        rightRotate(T, x);\n                    }\n                    setNodeColor(x.parent, NodeColor.Black);\n                    setNodeColor(x.parent.parent, NodeColor.Red);\n                    leftRotate(T, x.parent.parent);\n                }\n            }\n        }\n        setNodeColor(T.root, NodeColor.Black);\n        return newNode;\n    }\n    function treeInsert(T, z) {\n        let delta = 0;\n        let x = T.root;\n        const zAbsoluteStart = z.start;\n        const zAbsoluteEnd = z.end;\n        while (true) {\n            const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n            if (cmp < 0) {\n                // this node should be inserted to the left\n                // => it is not affected by the node's delta\n                if (x.left === exports.SENTINEL) {\n                    z.start -= delta;\n                    z.end -= delta;\n                    z.maxEnd -= delta;\n                    x.left = z;\n                    break;\n                }\n                else {\n                    x = x.left;\n                }\n            }\n            else {\n                // this node should be inserted to the right\n                // => it is not affected by the node's delta\n                if (x.right === exports.SENTINEL) {\n                    z.start -= (delta + x.delta);\n                    z.end -= (delta + x.delta);\n                    z.maxEnd -= (delta + x.delta);\n                    x.right = z;\n                    break;\n                }\n                else {\n                    delta += x.delta;\n                    x = x.right;\n                }\n            }\n        }\n        z.parent = x;\n        z.left = exports.SENTINEL;\n        z.right = exports.SENTINEL;\n        setNodeColor(z, NodeColor.Red);\n    }\n    //#endregion\n    //#region Deletion\n    function rbTreeDelete(T, z) {\n        let x;\n        let y;\n        // RB-DELETE except we don't swap z and y in case c)\n        // i.e. we always delete what's pointed at by z.\n        if (z.left === exports.SENTINEL) {\n            x = z.right;\n            y = z;\n            // x's delta is no longer influenced by z's delta\n            x.delta += z.delta;\n            if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {\n                T.requestNormalizeDelta = true;\n            }\n            x.start += z.delta;\n            x.end += z.delta;\n        }\n        else if (z.right === exports.SENTINEL) {\n            x = z.left;\n            y = z;\n        }\n        else {\n            y = leftest(z.right);\n            x = y.right;\n            // y's delta is no longer influenced by z's delta,\n            // but we don't want to walk the entire right-hand-side subtree of x.\n            // we therefore maintain z's delta in y, and adjust only x\n            x.start += y.delta;\n            x.end += y.delta;\n            x.delta += y.delta;\n            if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {\n                T.requestNormalizeDelta = true;\n            }\n            y.start += z.delta;\n            y.end += z.delta;\n            y.delta = z.delta;\n            if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {\n                T.requestNormalizeDelta = true;\n            }\n        }\n        if (y === T.root) {\n            T.root = x;\n            setNodeColor(x, NodeColor.Black);\n            z.detach();\n            resetSentinel();\n            recomputeMaxEnd(x);\n            T.root.parent = exports.SENTINEL;\n            return;\n        }\n        let yWasRed = (getNodeColor(y) === NodeColor.Red);\n        if (y === y.parent.left) {\n            y.parent.left = x;\n        }\n        else {\n            y.parent.right = x;\n        }\n        if (y === z) {\n            x.parent = y.parent;\n        }\n        else {\n            if (y.parent === z) {\n                x.parent = y;\n            }\n            else {\n                x.parent = y.parent;\n            }\n            y.left = z.left;\n            y.right = z.right;\n            y.parent = z.parent;\n            setNodeColor(y, getNodeColor(z));\n            if (z === T.root) {\n                T.root = y;\n            }\n            else {\n                if (z === z.parent.left) {\n                    z.parent.left = y;\n                }\n                else {\n                    z.parent.right = y;\n                }\n            }\n            if (y.left !== exports.SENTINEL) {\n                y.left.parent = y;\n            }\n            if (y.right !== exports.SENTINEL) {\n                y.right.parent = y;\n            }\n        }\n        z.detach();\n        if (yWasRed) {\n            recomputeMaxEndWalkToRoot(x.parent);\n            if (y !== z) {\n                recomputeMaxEndWalkToRoot(y);\n                recomputeMaxEndWalkToRoot(y.parent);\n            }\n            resetSentinel();\n            return;\n        }\n        recomputeMaxEndWalkToRoot(x);\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        // RB-DELETE-FIXUP\n        let w;\n        while (x !== T.root && getNodeColor(x) === NodeColor.Black) {\n            if (x === x.parent.left) {\n                w = x.parent.right;\n                if (getNodeColor(w) === NodeColor.Red) {\n                    setNodeColor(w, NodeColor.Black);\n                    setNodeColor(x.parent, NodeColor.Red);\n                    leftRotate(T, x.parent);\n                    w = x.parent.right;\n                }\n                if (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {\n                    setNodeColor(w, NodeColor.Red);\n                    x = x.parent;\n                }\n                else {\n                    if (getNodeColor(w.right) === NodeColor.Black) {\n                        setNodeColor(w.left, NodeColor.Black);\n                        setNodeColor(w, NodeColor.Red);\n                        rightRotate(T, w);\n                        w = x.parent.right;\n                    }\n                    setNodeColor(w, getNodeColor(x.parent));\n                    setNodeColor(x.parent, NodeColor.Black);\n                    setNodeColor(w.right, NodeColor.Black);\n                    leftRotate(T, x.parent);\n                    x = T.root;\n                }\n            }\n            else {\n                w = x.parent.left;\n                if (getNodeColor(w) === NodeColor.Red) {\n                    setNodeColor(w, NodeColor.Black);\n                    setNodeColor(x.parent, NodeColor.Red);\n                    rightRotate(T, x.parent);\n                    w = x.parent.left;\n                }\n                if (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {\n                    setNodeColor(w, NodeColor.Red);\n                    x = x.parent;\n                }\n                else {\n                    if (getNodeColor(w.left) === NodeColor.Black) {\n                        setNodeColor(w.right, NodeColor.Black);\n                        setNodeColor(w, NodeColor.Red);\n                        leftRotate(T, w);\n                        w = x.parent.left;\n                    }\n                    setNodeColor(w, getNodeColor(x.parent));\n                    setNodeColor(x.parent, NodeColor.Black);\n                    setNodeColor(w.left, NodeColor.Black);\n                    rightRotate(T, x.parent);\n                    x = T.root;\n                }\n            }\n        }\n        setNodeColor(x, NodeColor.Black);\n        resetSentinel();\n    }\n    function leftest(node) {\n        while (node.left !== exports.SENTINEL) {\n            node = node.left;\n        }\n        return node;\n    }\n    function resetSentinel() {\n        exports.SENTINEL.parent = exports.SENTINEL;\n        exports.SENTINEL.delta = 0; // optional\n        exports.SENTINEL.start = 0; // optional\n        exports.SENTINEL.end = 0; // optional\n    }\n    //#endregion\n    //#region Rotations\n    function leftRotate(T, x) {\n        const y = x.right; // set y.\n        y.delta += x.delta; // y's delta is no longer influenced by x's delta\n        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += x.delta;\n        y.end += x.delta;\n        x.right = y.left; // turn y's left subtree into x's right subtree.\n        if (y.left !== exports.SENTINEL) {\n            y.left.parent = x;\n        }\n        y.parent = x.parent; // link x's parent to y.\n        if (x.parent === exports.SENTINEL) {\n            T.root = y;\n        }\n        else if (x === x.parent.left) {\n            x.parent.left = y;\n        }\n        else {\n            x.parent.right = y;\n        }\n        y.left = x; // put x on y's left.\n        x.parent = y;\n        recomputeMaxEnd(x);\n        recomputeMaxEnd(y);\n    }\n    function rightRotate(T, y) {\n        const x = y.left;\n        y.delta -= x.delta;\n        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start -= x.delta;\n        y.end -= x.delta;\n        y.left = x.right;\n        if (x.right !== exports.SENTINEL) {\n            x.right.parent = y;\n        }\n        x.parent = y.parent;\n        if (y.parent === exports.SENTINEL) {\n            T.root = x;\n        }\n        else if (y === y.parent.right) {\n            y.parent.right = x;\n        }\n        else {\n            y.parent.left = x;\n        }\n        x.right = y;\n        y.parent = x;\n        recomputeMaxEnd(y);\n        recomputeMaxEnd(x);\n    }\n    //#endregion\n    //#region max end computation\n    function computeMaxEnd(node) {\n        let maxEnd = node.end;\n        if (node.left !== exports.SENTINEL) {\n            const leftMaxEnd = node.left.maxEnd;\n            if (leftMaxEnd > maxEnd) {\n                maxEnd = leftMaxEnd;\n            }\n        }\n        if (node.right !== exports.SENTINEL) {\n            const rightMaxEnd = node.right.maxEnd + node.delta;\n            if (rightMaxEnd > maxEnd) {\n                maxEnd = rightMaxEnd;\n            }\n        }\n        return maxEnd;\n    }\n    function recomputeMaxEnd(node) {\n        node.maxEnd = computeMaxEnd(node);\n    }\n    exports.recomputeMaxEnd = recomputeMaxEnd;\n    function recomputeMaxEndWalkToRoot(node) {\n        while (node !== exports.SENTINEL) {\n            const maxEnd = computeMaxEnd(node);\n            if (node.maxEnd === maxEnd) {\n                // no need to go further\n                return;\n            }\n            node.maxEnd = maxEnd;\n            node = node.parent;\n        }\n    }\n    //#endregion\n    //#region utils\n    function intervalCompare(aStart, aEnd, bStart, bEnd) {\n        if (aStart === bStart) {\n            return aEnd - bEnd;\n        }\n        return aStart - bStart;\n    }\n    exports.intervalCompare = intervalCompare;\n});\n//#endregion\n",null]}