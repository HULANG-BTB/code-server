{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/codeAction/codeActionCommands.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/codeAction/codeActionCommands.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/keyCodes\", \"vs/base/common/lifecycle\", \"vs/base/common/strings\", \"vs/editor/browser/editorExtensions\", \"vs/editor/browser/services/bulkEditService\", \"vs/editor/common/editorContextKeys\", \"vs/editor/contrib/message/messageController\", \"vs/nls\", \"vs/platform/commands/common/commands\", \"vs/platform/contextkey/common/contextkey\", \"vs/platform/contextview/browser/contextView\", \"vs/platform/keybinding/common/keybinding\", \"vs/platform/markers/common/markers\", \"vs/platform/progress/common/progress\", \"./codeActionModel\", \"./codeActionTrigger\", \"./codeActionWidget\", \"./lightBulbWidget\", \"vs/platform/keybinding/common/keybindingsRegistry\", \"vs/base/common/errors\"], function (require, exports, keyCodes_1, lifecycle_1, strings_1, editorExtensions_1, bulkEditService_1, editorContextKeys_1, messageController_1, nls, commands_1, contextkey_1, contextView_1, keybinding_1, markers_1, progress_1, codeActionModel_1, codeActionTrigger_1, codeActionWidget_1, lightBulbWidget_1, keybindingsRegistry_1, errors_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function contextKeyForSupportedActions(kind) {\n        return contextkey_1.ContextKeyExpr.regex(codeActionModel_1.SUPPORTED_CODE_ACTIONS.keys()[0], new RegExp('(\\\\s|^)' + strings_1.escapeRegExpCharacters(kind.value) + '\\\\b'));\n    }\n    let QuickFixController = class QuickFixController extends lifecycle_1.Disposable {\n        constructor(editor, markerService, contextKeyService, progressService, contextMenuService, _commandService, _keybindingService, _bulkEditService) {\n            super();\n            this._commandService = _commandService;\n            this._keybindingService = _keybindingService;\n            this._bulkEditService = _bulkEditService;\n            this._editor = editor;\n            this._model = new codeActionModel_1.CodeActionModel(this._editor, markerService, contextKeyService, progressService);\n            this._codeActionContextMenu = new codeActionWidget_1.CodeActionContextMenu(editor, contextMenuService, action => this._onApplyCodeAction(action));\n            this._lightBulbWidget = this._register(new lightBulbWidget_1.LightBulbWidget(editor));\n            this._updateLightBulbTitle();\n            this._register(this._codeActionContextMenu.onDidExecuteCodeAction(_ => this._model.trigger({ type: 'auto', filter: {} })));\n            this._register(this._lightBulbWidget.onClick(this._handleLightBulbSelect, this));\n            this._register(this._model.onDidChangeState(e => this._onDidChangeCodeActionsState(e)));\n            this._register(this._keybindingService.onDidUpdateKeybindings(this._updateLightBulbTitle, this));\n        }\n        static get(editor) {\n            return editor.getContribution(QuickFixController.ID);\n        }\n        dispose() {\n            super.dispose();\n            this._model.dispose();\n        }\n        _onDidChangeCodeActionsState(newState) {\n            if (this._activeRequest) {\n                this._activeRequest.cancel();\n                this._activeRequest = undefined;\n            }\n            if (newState.type === codeActionModel_1.CodeActionsState.Type.Triggered) {\n                this._activeRequest = newState.actions;\n                if (newState.trigger.filter && newState.trigger.filter.kind) {\n                    // Triggered for specific scope\n                    newState.actions.then(fixes => {\n                        if (fixes.actions.length > 0) {\n                            // Apply if we only have one action or requested autoApply\n                            if (newState.trigger.autoApply === codeActionTrigger_1.CodeActionAutoApply.First || (newState.trigger.autoApply === codeActionTrigger_1.CodeActionAutoApply.IfSingle && fixes.actions.length === 1)) {\n                                this._onApplyCodeAction(fixes.actions[0]);\n                                return;\n                            }\n                        }\n                        this._codeActionContextMenu.show(newState.actions, newState.position);\n                    }).catch(errors_1.onUnexpectedError);\n                }\n                else if (newState.trigger.type === 'manual') {\n                    this._codeActionContextMenu.show(newState.actions, newState.position);\n                }\n                else {\n                    // auto magically triggered\n                    // * update an existing list of code actions\n                    // * manage light bulb\n                    if (this._codeActionContextMenu.isVisible) {\n                        this._codeActionContextMenu.show(newState.actions, newState.position);\n                    }\n                    else {\n                        this._lightBulbWidget.tryShow(newState);\n                    }\n                }\n            }\n            else {\n                this._lightBulbWidget.hide();\n            }\n        }\n        getId() {\n            return QuickFixController.ID;\n        }\n        _handleLightBulbSelect(e) {\n            this._codeActionContextMenu.show(e.state.actions, e);\n        }\n        triggerFromEditorSelection(filter, autoApply) {\n            return this._model.trigger({ type: 'manual', filter, autoApply });\n        }\n        _updateLightBulbTitle() {\n            const kb = this._keybindingService.lookupKeybinding(QuickFixAction.Id);\n            let title;\n            if (kb) {\n                title = nls.localize('quickFixWithKb', \"Show Fixes ({0})\", kb.getLabel());\n            }\n            else {\n                title = nls.localize('quickFix', \"Show Fixes\");\n            }\n            this._lightBulbWidget.title = title;\n        }\n        _onApplyCodeAction(action) {\n            return applyCodeAction(action, this._bulkEditService, this._commandService, this._editor);\n        }\n    };\n    QuickFixController.ID = 'editor.contrib.quickFixController';\n    QuickFixController = __decorate([\n        __param(1, markers_1.IMarkerService),\n        __param(2, contextkey_1.IContextKeyService),\n        __param(3, progress_1.IProgressService),\n        __param(4, contextView_1.IContextMenuService),\n        __param(5, commands_1.ICommandService),\n        __param(6, keybinding_1.IKeybindingService),\n        __param(7, bulkEditService_1.IBulkEditService)\n    ], QuickFixController);\n    exports.QuickFixController = QuickFixController;\n    function applyCodeAction(action, bulkEditService, commandService, editor) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (action.edit) {\n                yield bulkEditService.apply(action.edit, { editor });\n            }\n            if (action.command) {\n                yield commandService.executeCommand(action.command.id, ...(action.command.arguments || []));\n            }\n        });\n    }\n    exports.applyCodeAction = applyCodeAction;\n    function showCodeActionsForEditorSelection(editor, notAvailableMessage, filter, autoApply) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        const controller = QuickFixController.get(editor);\n        if (!controller) {\n            return;\n        }\n        const pos = editor.getPosition();\n        controller.triggerFromEditorSelection(filter, autoApply).then(codeActions => {\n            if (!codeActions || !codeActions.actions.length) {\n                messageController_1.MessageController.get(editor).showMessage(notAvailableMessage, pos);\n            }\n        });\n    }\n    class QuickFixAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: QuickFixAction.Id,\n                label: nls.localize('quickfix.trigger.label', \"Quick Fix...\"),\n                alias: 'Quick Fix',\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, editorContextKeys_1.EditorContextKeys.hasCodeActionsProvider),\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.US_DOT,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        run(_accessor, editor) {\n            return showCodeActionsForEditorSelection(editor, nls.localize('editor.action.quickFix.noneMessage', \"No code actions available\"));\n        }\n    }\n    QuickFixAction.Id = 'editor.action.quickFix';\n    exports.QuickFixAction = QuickFixAction;\n    class CodeActionCommandArgs {\n        constructor(kind, apply, preferred) {\n            this.kind = kind;\n            this.apply = apply;\n            this.preferred = preferred;\n        }\n        static fromUser(arg, defaults) {\n            if (!arg || typeof arg !== 'object') {\n                return new CodeActionCommandArgs(defaults.kind, defaults.apply, false);\n            }\n            return new CodeActionCommandArgs(CodeActionCommandArgs.getKindFromUser(arg, defaults.kind), CodeActionCommandArgs.getApplyFromUser(arg, defaults.apply), CodeActionCommandArgs.getPreferredUser(arg));\n        }\n        static getApplyFromUser(arg, defaultAutoApply) {\n            switch (typeof arg.apply === 'string' ? arg.apply.toLowerCase() : '') {\n                case 'first': return codeActionTrigger_1.CodeActionAutoApply.First;\n                case 'never': return codeActionTrigger_1.CodeActionAutoApply.Never;\n                case 'ifsingle': return codeActionTrigger_1.CodeActionAutoApply.IfSingle;\n                default: return defaultAutoApply;\n            }\n        }\n        static getKindFromUser(arg, defaultKind) {\n            return typeof arg.kind === 'string'\n                ? new codeActionTrigger_1.CodeActionKind(arg.kind)\n                : defaultKind;\n        }\n        static getPreferredUser(arg) {\n            return typeof arg.preferred === 'boolean'\n                ? arg.preferred\n                : false;\n        }\n    }\n    class CodeActionCommand extends editorExtensions_1.EditorCommand {\n        constructor() {\n            super({\n                id: CodeActionCommand.Id,\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, editorContextKeys_1.EditorContextKeys.hasCodeActionsProvider),\n                description: {\n                    description: `Trigger a code action`,\n                    args: [{\n                            name: 'args',\n                            schema: {\n                                'type': 'object',\n                                'required': ['kind'],\n                                'properties': {\n                                    'kind': {\n                                        'type': 'string'\n                                    },\n                                    'apply': {\n                                        'type': 'string',\n                                        'default': 'ifSingle',\n                                        'enum': ['first', 'ifSingle', 'never']\n                                    }\n                                }\n                            }\n                        }]\n                }\n            });\n        }\n        runEditorCommand(_accessor, editor, userArg) {\n            const args = CodeActionCommandArgs.fromUser(userArg, {\n                kind: codeActionTrigger_1.CodeActionKind.Empty,\n                apply: codeActionTrigger_1.CodeActionAutoApply.IfSingle,\n            });\n            return showCodeActionsForEditorSelection(editor, nls.localize('editor.action.quickFix.noneMessage', \"No code actions available\"), {\n                kind: args.kind,\n                includeSourceActions: true,\n                onlyIncludePreferredActions: args.preferred,\n            }, args.apply);\n        }\n    }\n    CodeActionCommand.Id = 'editor.action.codeAction';\n    exports.CodeActionCommand = CodeActionCommand;\n    class RefactorAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: RefactorAction.Id,\n                label: nls.localize('refactor.label', \"Refactor...\"),\n                alias: 'Refactor',\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, editorContextKeys_1.EditorContextKeys.hasCodeActionsProvider),\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_R,\n                    mac: {\n                        primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_R\n                    },\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                menuOpts: {\n                    group: '1_modification',\n                    order: 2,\n                    when: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, contextKeyForSupportedActions(codeActionTrigger_1.CodeActionKind.Refactor)),\n                },\n                description: {\n                    description: 'Refactor...',\n                    args: [{\n                            name: 'args',\n                            schema: {\n                                'type': 'object',\n                                'properties': {\n                                    'kind': {\n                                        'type': 'string'\n                                    },\n                                    'apply': {\n                                        'type': 'string',\n                                        'default': 'never',\n                                        'enum': ['first', 'ifSingle', 'never']\n                                    }\n                                }\n                            }\n                        }]\n                }\n            });\n        }\n        run(_accessor, editor, userArg) {\n            const args = CodeActionCommandArgs.fromUser(userArg, {\n                kind: codeActionTrigger_1.CodeActionKind.Refactor,\n                apply: codeActionTrigger_1.CodeActionAutoApply.Never\n            });\n            return showCodeActionsForEditorSelection(editor, nls.localize('editor.action.refactor.noneMessage', \"No refactorings available\"), {\n                kind: codeActionTrigger_1.CodeActionKind.Refactor.contains(args.kind) ? args.kind : codeActionTrigger_1.CodeActionKind.Empty,\n                onlyIncludePreferredActions: args.preferred,\n            }, args.apply);\n        }\n    }\n    RefactorAction.Id = 'editor.action.refactor';\n    exports.RefactorAction = RefactorAction;\n    class SourceAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: SourceAction.Id,\n                label: nls.localize('source.label', \"Source Action...\"),\n                alias: 'Source Action',\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, editorContextKeys_1.EditorContextKeys.hasCodeActionsProvider),\n                menuOpts: {\n                    group: '1_modification',\n                    order: 2.1,\n                    when: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, contextKeyForSupportedActions(codeActionTrigger_1.CodeActionKind.Source)),\n                },\n                description: {\n                    description: 'Source Action...',\n                    args: [{\n                            name: 'args',\n                            schema: {\n                                'type': 'object',\n                                'properties': {\n                                    'kind': {\n                                        'type': 'string'\n                                    },\n                                    'apply': {\n                                        'type': 'string',\n                                        'default': 'never',\n                                        'enum': ['first', 'ifSingle', 'never']\n                                    }\n                                }\n                            }\n                        }]\n                }\n            });\n        }\n        run(_accessor, editor, userArg) {\n            const args = CodeActionCommandArgs.fromUser(userArg, {\n                kind: codeActionTrigger_1.CodeActionKind.Source,\n                apply: codeActionTrigger_1.CodeActionAutoApply.Never\n            });\n            return showCodeActionsForEditorSelection(editor, nls.localize('editor.action.source.noneMessage', \"No source actions available\"), {\n                kind: codeActionTrigger_1.CodeActionKind.Source.contains(args.kind) ? args.kind : codeActionTrigger_1.CodeActionKind.Empty,\n                includeSourceActions: true,\n                onlyIncludePreferredActions: args.preferred,\n            }, args.apply);\n        }\n    }\n    SourceAction.Id = 'editor.action.sourceAction';\n    exports.SourceAction = SourceAction;\n    class OrganizeImportsAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: OrganizeImportsAction.Id,\n                label: nls.localize('organizeImports.label', \"Organize Imports\"),\n                alias: 'Organize Imports',\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, contextKeyForSupportedActions(codeActionTrigger_1.CodeActionKind.SourceOrganizeImports)),\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_O,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        run(_accessor, editor) {\n            return showCodeActionsForEditorSelection(editor, nls.localize('editor.action.organize.noneMessage', \"No organize imports action available\"), { kind: codeActionTrigger_1.CodeActionKind.SourceOrganizeImports, includeSourceActions: true }, codeActionTrigger_1.CodeActionAutoApply.IfSingle);\n        }\n    }\n    OrganizeImportsAction.Id = 'editor.action.organizeImports';\n    exports.OrganizeImportsAction = OrganizeImportsAction;\n    class FixAllAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: FixAllAction.Id,\n                label: nls.localize('fixAll.label', \"Fix All\"),\n                alias: 'Fix All',\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, contextKeyForSupportedActions(codeActionTrigger_1.CodeActionKind.SourceFixAll))\n            });\n        }\n        run(_accessor, editor) {\n            return showCodeActionsForEditorSelection(editor, nls.localize('fixAll.noneMessage', \"No fix all action available\"), { kind: codeActionTrigger_1.CodeActionKind.SourceFixAll, includeSourceActions: true }, codeActionTrigger_1.CodeActionAutoApply.IfSingle);\n        }\n    }\n    FixAllAction.Id = 'editor.action.fixAll';\n    exports.FixAllAction = FixAllAction;\n    class AutoFixAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: AutoFixAction.Id,\n                label: nls.localize('autoFix.label', \"Auto Fix...\"),\n                alias: 'Auto Fix',\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, contextKeyForSupportedActions(codeActionTrigger_1.CodeActionKind.QuickFix)),\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.US_DOT,\n                    mac: {\n                        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.US_DOT\n                    },\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n        run(_accessor, editor) {\n            return showCodeActionsForEditorSelection(editor, nls.localize('editor.action.autoFix.noneMessage', \"No auto fixes available\"), {\n                kind: codeActionTrigger_1.CodeActionKind.QuickFix,\n                onlyIncludePreferredActions: true\n            }, codeActionTrigger_1.CodeActionAutoApply.IfSingle);\n        }\n    }\n    AutoFixAction.Id = 'editor.action.autoFix';\n    exports.AutoFixAction = AutoFixAction;\n});\n",null]}