{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/platform/keybinding/common/abstractKeybindingService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/keybinding/common/abstractKeybindingService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar nls = require(\"vs/nls\");\nvar arrays = require(\"vs/base/common/arrays\");\nvar async_1 = require(\"vs/base/common/async\");\nvar event_1 = require(\"vs/base/common/event\");\nvar keyCodes_1 = require(\"vs/base/common/keyCodes\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar types_1 = require(\"vs/base/common/types\");\nvar AbstractKeybindingService = /** @class */ (function (_super) {\n    tslib_1.__extends(AbstractKeybindingService, _super);\n    function AbstractKeybindingService(contextKeyService, commandService, telemetryService, notificationService, statusService) {\n        var _this = _super.call(this) || this;\n        _this._contextKeyService = contextKeyService;\n        _this._commandService = commandService;\n        _this._telemetryService = telemetryService;\n        _this._statusService = statusService;\n        _this._notificationService = notificationService;\n        _this._currentChord = null;\n        _this._currentChordChecker = new async_1.IntervalTimer();\n        _this._currentChordStatusMessage = null;\n        _this._onDidUpdateKeybindings = _this._register(new event_1.Emitter());\n        return _this;\n    }\n    AbstractKeybindingService.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n    };\n    Object.defineProperty(AbstractKeybindingService.prototype, \"onDidUpdateKeybindings\", {\n        get: function () {\n            return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : event_1.Event.None; // Sinon stubbing walks properties on prototype\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AbstractKeybindingService.prototype.getDefaultKeybindingsContent = function () {\n        return '';\n    };\n    AbstractKeybindingService.prototype.getDefaultKeybindings = function () {\n        return this._getResolver().getDefaultKeybindings();\n    };\n    AbstractKeybindingService.prototype.getKeybindings = function () {\n        return this._getResolver().getKeybindings();\n    };\n    AbstractKeybindingService.prototype.customKeybindingsCount = function () {\n        return 0;\n    };\n    AbstractKeybindingService.prototype.lookupKeybindings = function (commandId) {\n        return arrays.coalesce(this._getResolver().lookupKeybindings(commandId).map(function (item) { return item.resolvedKeybinding; }));\n    };\n    AbstractKeybindingService.prototype.lookupKeybinding = function (commandId) {\n        var result = this._getResolver().lookupPrimaryKeybinding(commandId);\n        if (!result) {\n            return undefined;\n        }\n        return types_1.withNullAsUndefined(result.resolvedKeybinding);\n    };\n    AbstractKeybindingService.prototype.dispatchEvent = function (e, target) {\n        return this._dispatch(e, target);\n    };\n    AbstractKeybindingService.prototype.softDispatch = function (e, target) {\n        var keybinding = this.resolveKeyboardEvent(e);\n        if (keybinding.isChord()) {\n            console.warn('Unexpected keyboard event mapped to a chord');\n            return null;\n        }\n        var firstPart = keybinding.getDispatchParts()[0];\n        if (firstPart === null) {\n            // cannot be dispatched, probably only modifier keys\n            return null;\n        }\n        var contextValue = this._contextKeyService.getContext(target);\n        var currentChord = this._currentChord ? this._currentChord.keypress : null;\n        return this._getResolver().resolve(contextValue, currentChord, firstPart);\n    };\n    AbstractKeybindingService.prototype._enterChordMode = function (firstPart, keypressLabel) {\n        var _this = this;\n        this._currentChord = {\n            keypress: firstPart,\n            label: keypressLabel\n        };\n        if (this._statusService) {\n            this._currentChordStatusMessage = this._statusService.setStatusMessage(nls.localize('first.chord', \"({0}) was pressed. Waiting for second key of chord...\", keypressLabel));\n        }\n        var chordEnterTime = Date.now();\n        this._currentChordChecker.cancelAndSet(function () {\n            if (!_this._documentHasFocus()) {\n                // Focus has been lost => leave chord mode\n                _this._leaveChordMode();\n                return;\n            }\n            if (Date.now() - chordEnterTime > 5000) {\n                // 5 seconds elapsed => leave chord mode\n                _this._leaveChordMode();\n            }\n        }, 500);\n    };\n    AbstractKeybindingService.prototype._leaveChordMode = function () {\n        if (this._currentChordStatusMessage) {\n            this._currentChordStatusMessage.dispose();\n            this._currentChordStatusMessage = null;\n        }\n        this._currentChordChecker.cancel();\n        this._currentChord = null;\n    };\n    AbstractKeybindingService.prototype.dispatchByUserSettingsLabel = function (userSettingsLabel, target) {\n        var keybindings = this.resolveUserBinding(userSettingsLabel);\n        if (keybindings.length >= 1) {\n            this._doDispatch(keybindings[0], target);\n        }\n    };\n    AbstractKeybindingService.prototype._dispatch = function (e, target) {\n        return this._doDispatch(this.resolveKeyboardEvent(e), target);\n    };\n    AbstractKeybindingService.prototype._doDispatch = function (keybinding, target) {\n        var _this = this;\n        var shouldPreventDefault = false;\n        if (keybinding.isChord()) {\n            console.warn('Unexpected keyboard event mapped to a chord');\n            return false;\n        }\n        var firstPart = keybinding.getDispatchParts()[0];\n        if (firstPart === null) {\n            // cannot be dispatched, probably only modifier keys\n            return shouldPreventDefault;\n        }\n        var contextValue = this._contextKeyService.getContext(target);\n        var currentChord = this._currentChord ? this._currentChord.keypress : null;\n        var keypressLabel = keybinding.getLabel();\n        var resolveResult = this._getResolver().resolve(contextValue, currentChord, firstPart);\n        if (resolveResult && resolveResult.enterChord) {\n            shouldPreventDefault = true;\n            this._enterChordMode(firstPart, keypressLabel);\n            return shouldPreventDefault;\n        }\n        if (this._statusService && this._currentChord) {\n            if (!resolveResult || !resolveResult.commandId) {\n                this._statusService.setStatusMessage(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", this._currentChord.label, keypressLabel), 10 * 1000 /* 10s */);\n                shouldPreventDefault = true;\n            }\n        }\n        this._leaveChordMode();\n        if (resolveResult && resolveResult.commandId) {\n            if (!resolveResult.bubble) {\n                shouldPreventDefault = true;\n            }\n            if (typeof resolveResult.commandArgs === 'undefined') {\n                this._commandService.executeCommand(resolveResult.commandId).then(undefined, function (err) { return _this._notificationService.warn(err); });\n            }\n            else {\n                this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, function (err) { return _this._notificationService.warn(err); });\n            }\n            /* __GDPR__\n                \"workbenchActionExecuted\" : {\n                    \"id\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                    \"from\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                }\n            */\n            this._telemetryService.publicLog('workbenchActionExecuted', { id: resolveResult.commandId, from: 'keybinding' });\n        }\n        return shouldPreventDefault;\n    };\n    AbstractKeybindingService.prototype.mightProducePrintableCharacter = function (event) {\n        if (event.ctrlKey || event.metaKey) {\n            // ignore ctrl/cmd-combination but not shift/alt-combinatios\n            return false;\n        }\n        // weak check for certain ranges. this is properly implemented in a subclass\n        // with access to the KeyboardMapperFactory.\n        if ((event.keyCode >= keyCodes_1.KeyCode.KEY_A && event.keyCode <= keyCodes_1.KeyCode.KEY_Z)\n            || (event.keyCode >= keyCodes_1.KeyCode.KEY_0 && event.keyCode <= keyCodes_1.KeyCode.KEY_9)) {\n            return true;\n        }\n        return false;\n    };\n    return AbstractKeybindingService;\n}(lifecycle_1.Disposable));\nexports.AbstractKeybindingService = AbstractKeybindingService;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/platform/keybinding/common/abstractKeybindingService.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/platform/keybinding/common/abstractKeybindingService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\nimport * as arrays from 'vs/base/common/arrays';\nimport { IntervalTimer } from 'vs/base/common/async';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { KeyCode, Keybinding, ResolvedKeybinding } from 'vs/base/common/keyCodes';\nimport { Disposable, IDisposable } from 'vs/base/common/lifecycle';\nimport { ICommandService } from 'vs/platform/commands/common/commands';\nimport { IContextKeyService, IContextKeyServiceTarget } from 'vs/platform/contextkey/common/contextkey';\nimport { IKeybindingEvent, IKeybindingService, IKeyboardEvent } from 'vs/platform/keybinding/common/keybinding';\nimport { IResolveResult, KeybindingResolver } from 'vs/platform/keybinding/common/keybindingResolver';\nimport { ResolvedKeybindingItem } from 'vs/platform/keybinding/common/resolvedKeybindingItem';\nimport { INotificationService } from 'vs/platform/notification/common/notification';\nimport { IStatusbarService } from 'vs/platform/statusbar/common/statusbar';\nimport { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';\nimport { withNullAsUndefined } from 'vs/base/common/types';\n\ninterface CurrentChord {\n\tkeypress: string;\n\tlabel: string | null;\n}\n\nexport abstract class AbstractKeybindingService extends Disposable implements IKeybindingService {\n\tpublic _serviceBrand: any;\n\n\tprivate _currentChord: CurrentChord | null;\n\tprivate _currentChordChecker: IntervalTimer;\n\tprivate _currentChordStatusMessage: IDisposable | null;\n\tprotected _onDidUpdateKeybindings: Emitter<IKeybindingEvent>;\n\n\tprivate _contextKeyService: IContextKeyService;\n\tprivate _statusService: IStatusbarService | undefined;\n\tprivate _notificationService: INotificationService;\n\tprotected _commandService: ICommandService;\n\tprotected _telemetryService: ITelemetryService;\n\n\tconstructor(\n\t\tcontextKeyService: IContextKeyService,\n\t\tcommandService: ICommandService,\n\t\ttelemetryService: ITelemetryService,\n\t\tnotificationService: INotificationService,\n\t\tstatusService?: IStatusbarService\n\t) {\n\t\tsuper();\n\t\tthis._contextKeyService = contextKeyService;\n\t\tthis._commandService = commandService;\n\t\tthis._telemetryService = telemetryService;\n\t\tthis._statusService = statusService;\n\t\tthis._notificationService = notificationService;\n\n\t\tthis._currentChord = null;\n\t\tthis._currentChordChecker = new IntervalTimer();\n\t\tthis._currentChordStatusMessage = null;\n\t\tthis._onDidUpdateKeybindings = this._register(new Emitter<IKeybindingEvent>());\n\t}\n\n\tpublic dispose(): void {\n\t\tsuper.dispose();\n\t}\n\n\tget onDidUpdateKeybindings(): Event<IKeybindingEvent> {\n\t\treturn this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None; // Sinon stubbing walks properties on prototype\n\t}\n\n\tprotected abstract _getResolver(): KeybindingResolver;\n\tprotected abstract _documentHasFocus(): boolean;\n\tpublic abstract resolveKeybinding(keybinding: Keybinding): ResolvedKeybinding[];\n\tpublic abstract resolveKeyboardEvent(keyboardEvent: IKeyboardEvent): ResolvedKeybinding;\n\tpublic abstract resolveUserBinding(userBinding: string): ResolvedKeybinding[];\n\tpublic abstract _dumpDebugInfo(): string;\n\n\tpublic getDefaultKeybindingsContent(): string {\n\t\treturn '';\n\t}\n\n\tpublic getDefaultKeybindings(): ResolvedKeybindingItem[] {\n\t\treturn this._getResolver().getDefaultKeybindings();\n\t}\n\n\tpublic getKeybindings(): ResolvedKeybindingItem[] {\n\t\treturn this._getResolver().getKeybindings();\n\t}\n\n\tpublic customKeybindingsCount(): number {\n\t\treturn 0;\n\t}\n\n\tpublic lookupKeybindings(commandId: string): ResolvedKeybinding[] {\n\t\treturn arrays.coalesce(\n\t\t\tthis._getResolver().lookupKeybindings(commandId).map(item => item.resolvedKeybinding)\n\t\t);\n\t}\n\n\tpublic lookupKeybinding(commandId: string): ResolvedKeybinding | undefined {\n\t\tlet result = this._getResolver().lookupPrimaryKeybinding(commandId);\n\t\tif (!result) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn withNullAsUndefined(result.resolvedKeybinding);\n\t}\n\n\tpublic dispatchEvent(e: IKeyboardEvent, target: IContextKeyServiceTarget): boolean {\n\t\treturn this._dispatch(e, target);\n\t}\n\n\tpublic softDispatch(e: IKeyboardEvent, target: IContextKeyServiceTarget): IResolveResult | null {\n\t\tconst keybinding = this.resolveKeyboardEvent(e);\n\t\tif (keybinding.isChord()) {\n\t\t\tconsole.warn('Unexpected keyboard event mapped to a chord');\n\t\t\treturn null;\n\t\t}\n\t\tconst [firstPart,] = keybinding.getDispatchParts();\n\t\tif (firstPart === null) {\n\t\t\t// cannot be dispatched, probably only modifier keys\n\t\t\treturn null;\n\t\t}\n\n\t\tconst contextValue = this._contextKeyService.getContext(target);\n\t\tconst currentChord = this._currentChord ? this._currentChord.keypress : null;\n\t\treturn this._getResolver().resolve(contextValue, currentChord, firstPart);\n\t}\n\n\tprivate _enterChordMode(firstPart: string, keypressLabel: string | null): void {\n\t\tthis._currentChord = {\n\t\t\tkeypress: firstPart,\n\t\t\tlabel: keypressLabel\n\t\t};\n\t\tif (this._statusService) {\n\t\t\tthis._currentChordStatusMessage = this._statusService.setStatusMessage(nls.localize('first.chord', \"({0}) was pressed. Waiting for second key of chord...\", keypressLabel));\n\t\t}\n\t\tconst chordEnterTime = Date.now();\n\t\tthis._currentChordChecker.cancelAndSet(() => {\n\n\t\t\tif (!this._documentHasFocus()) {\n\t\t\t\t// Focus has been lost => leave chord mode\n\t\t\t\tthis._leaveChordMode();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Date.now() - chordEnterTime > 5000) {\n\t\t\t\t// 5 seconds elapsed => leave chord mode\n\t\t\t\tthis._leaveChordMode();\n\t\t\t}\n\n\t\t}, 500);\n\t}\n\n\tprivate _leaveChordMode(): void {\n\t\tif (this._currentChordStatusMessage) {\n\t\t\tthis._currentChordStatusMessage.dispose();\n\t\t\tthis._currentChordStatusMessage = null;\n\t\t}\n\t\tthis._currentChordChecker.cancel();\n\t\tthis._currentChord = null;\n\t}\n\n\tpublic dispatchByUserSettingsLabel(userSettingsLabel: string, target: IContextKeyServiceTarget): void {\n\t\tconst keybindings = this.resolveUserBinding(userSettingsLabel);\n\t\tif (keybindings.length >= 1) {\n\t\t\tthis._doDispatch(keybindings[0], target);\n\t\t}\n\t}\n\n\tprotected _dispatch(e: IKeyboardEvent, target: IContextKeyServiceTarget): boolean {\n\t\treturn this._doDispatch(this.resolveKeyboardEvent(e), target);\n\t}\n\n\tprivate _doDispatch(keybinding: ResolvedKeybinding, target: IContextKeyServiceTarget): boolean {\n\t\tlet shouldPreventDefault = false;\n\n\t\tif (keybinding.isChord()) {\n\t\t\tconsole.warn('Unexpected keyboard event mapped to a chord');\n\t\t\treturn false;\n\t\t}\n\t\tconst [firstPart,] = keybinding.getDispatchParts();\n\t\tif (firstPart === null) {\n\t\t\t// cannot be dispatched, probably only modifier keys\n\t\t\treturn shouldPreventDefault;\n\t\t}\n\n\t\tconst contextValue = this._contextKeyService.getContext(target);\n\t\tconst currentChord = this._currentChord ? this._currentChord.keypress : null;\n\t\tconst keypressLabel = keybinding.getLabel();\n\t\tconst resolveResult = this._getResolver().resolve(contextValue, currentChord, firstPart);\n\n\t\tif (resolveResult && resolveResult.enterChord) {\n\t\t\tshouldPreventDefault = true;\n\t\t\tthis._enterChordMode(firstPart, keypressLabel);\n\t\t\treturn shouldPreventDefault;\n\t\t}\n\n\t\tif (this._statusService && this._currentChord) {\n\t\t\tif (!resolveResult || !resolveResult.commandId) {\n\t\t\t\tthis._statusService.setStatusMessage(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", this._currentChord.label, keypressLabel), 10 * 1000 /* 10s */);\n\t\t\t\tshouldPreventDefault = true;\n\t\t\t}\n\t\t}\n\n\t\tthis._leaveChordMode();\n\n\t\tif (resolveResult && resolveResult.commandId) {\n\t\t\tif (!resolveResult.bubble) {\n\t\t\t\tshouldPreventDefault = true;\n\t\t\t}\n\t\t\tif (typeof resolveResult.commandArgs === 'undefined') {\n\t\t\t\tthis._commandService.executeCommand(resolveResult.commandId).then(undefined, err => this._notificationService.warn(err));\n\t\t\t} else {\n\t\t\t\tthis._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, err => this._notificationService.warn(err));\n\t\t\t}\n\t\t\t/* __GDPR__\n\t\t\t\t\"workbenchActionExecuted\" : {\n\t\t\t\t\t\"id\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\t\t\t\"from\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t\t\t}\n\t\t\t*/\n\t\t\tthis._telemetryService.publicLog('workbenchActionExecuted', { id: resolveResult.commandId, from: 'keybinding' });\n\t\t}\n\n\t\treturn shouldPreventDefault;\n\t}\n\n\tmightProducePrintableCharacter(event: IKeyboardEvent): boolean {\n\t\tif (event.ctrlKey || event.metaKey) {\n\t\t\t// ignore ctrl/cmd-combination but not shift/alt-combinatios\n\t\t\treturn false;\n\t\t}\n\t\t// weak check for certain ranges. this is properly implemented in a subclass\n\t\t// with access to the KeyboardMapperFactory.\n\t\tif ((event.keyCode >= KeyCode.KEY_A && event.keyCode <= KeyCode.KEY_Z)\n\t\t\t|| (event.keyCode >= KeyCode.KEY_0 && event.keyCode <= KeyCode.KEY_9)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n"]}]}