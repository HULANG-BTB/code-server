{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostSearch.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostSearch.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/lifecycle\", \"vs/base/common/uri\", \"vs/base/node/extfs\", \"vs/workbench/services/search/common/search\", \"vs/workbench/services/search/node/fileSearchManager\", \"vs/workbench/services/search/node/rawSearchService\", \"vs/workbench/services/search/node/ripgrepSearchProvider\", \"vs/workbench/services/search/node/ripgrepSearchUtils\", \"vs/workbench/services/search/node/textSearchManager\", \"../common/extHost.protocol\"], function (require, exports, lifecycle_1, uri_1, extfs, search_1, fileSearchManager_1, rawSearchService_1, ripgrepSearchProvider_1, ripgrepSearchUtils_1, textSearchManager_1, extHost_protocol_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class ExtHostSearch {\n        constructor(mainContext, _schemeTransformer, _logService, _extfs = extfs) {\n            this._schemeTransformer = _schemeTransformer;\n            this._logService = _logService;\n            this._extfs = _extfs;\n            this._textSearchProvider = new Map();\n            this._textSearchUsedSchemes = new Set();\n            this._fileSearchProvider = new Map();\n            this._fileSearchUsedSchemes = new Set();\n            this._handlePool = 0;\n            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadSearch);\n            this._fileSearchManager = new fileSearchManager_1.FileSearchManager();\n        }\n        _transformScheme(scheme) {\n            if (this._schemeTransformer) {\n                return this._schemeTransformer.transformOutgoing(scheme);\n            }\n            return scheme;\n        }\n        registerTextSearchProvider(scheme, provider) {\n            if (this._textSearchUsedSchemes.has(scheme)) {\n                throw new Error(`a text search provider for the scheme '${scheme}' is already registered`);\n            }\n            this._textSearchUsedSchemes.add(scheme);\n            const handle = this._handlePool++;\n            this._textSearchProvider.set(handle, provider);\n            this._proxy.$registerTextSearchProvider(handle, this._transformScheme(scheme));\n            return lifecycle_1.toDisposable(() => {\n                this._textSearchUsedSchemes.delete(scheme);\n                this._textSearchProvider.delete(handle);\n                this._proxy.$unregisterProvider(handle);\n            });\n        }\n        registerFileSearchProvider(scheme, provider) {\n            if (this._fileSearchUsedSchemes.has(scheme)) {\n                throw new Error(`a file search provider for the scheme '${scheme}' is already registered`);\n            }\n            this._fileSearchUsedSchemes.add(scheme);\n            const handle = this._handlePool++;\n            this._fileSearchProvider.set(handle, provider);\n            this._proxy.$registerFileSearchProvider(handle, this._transformScheme(scheme));\n            return lifecycle_1.toDisposable(() => {\n                this._fileSearchUsedSchemes.delete(scheme);\n                this._fileSearchProvider.delete(handle);\n                this._proxy.$unregisterProvider(handle);\n            });\n        }\n        registerInternalFileSearchProvider(scheme, provider) {\n            const handle = this._handlePool++;\n            this._internalFileSearchProvider = provider;\n            this._internalFileSearchHandle = handle;\n            this._proxy.$registerFileSearchProvider(handle, this._transformScheme(scheme));\n            return lifecycle_1.toDisposable(() => {\n                this._internalFileSearchProvider = null;\n                this._proxy.$unregisterProvider(handle);\n            });\n        }\n        $provideFileSearchResults(handle, session, rawQuery, token) {\n            const query = reviveQuery(rawQuery);\n            if (handle === this._internalFileSearchHandle) {\n                return this.doInternalFileSearch(handle, session, query, token);\n            }\n            else {\n                const provider = this._fileSearchProvider.get(handle);\n                if (provider) {\n                    return this._fileSearchManager.fileSearch(query, provider, batch => {\n                        this._proxy.$handleFileMatch(handle, session, batch.map(p => p.resource));\n                    }, token);\n                }\n                else {\n                    throw new Error('unknown provider: ' + handle);\n                }\n            }\n        }\n        doInternalFileSearch(handle, session, rawQuery, token) {\n            const onResult = (ev) => {\n                if (search_1.isSerializedFileMatch(ev)) {\n                    ev = [ev];\n                }\n                if (Array.isArray(ev)) {\n                    this._proxy.$handleFileMatch(handle, session, ev.map(m => uri_1.URI.file(m.path)));\n                    return;\n                }\n                if (ev.message) {\n                    this._logService.debug('ExtHostSearch', ev.message);\n                }\n            };\n            if (!this._internalFileSearchProvider) {\n                throw new Error('No internal file search handler');\n            }\n            return this._internalFileSearchProvider.doFileSearch(rawQuery, onResult, token);\n        }\n        $clearCache(cacheKey) {\n            if (this._internalFileSearchProvider) {\n                this._internalFileSearchProvider.clearCache(cacheKey);\n            }\n            this._fileSearchManager.clearCache(cacheKey);\n            return Promise.resolve(undefined);\n        }\n        $provideTextSearchResults(handle, session, rawQuery, token) {\n            const provider = this._textSearchProvider.get(handle);\n            if (!provider || !provider.provideTextSearchResults) {\n                throw new Error(`Unknown provider ${handle}`);\n            }\n            const query = reviveQuery(rawQuery);\n            const engine = new textSearchManager_1.TextSearchManager(query, provider, this._extfs);\n            return engine.search(progress => this._proxy.$handleTextMatch(handle, session, progress), token);\n        }\n    }\n    exports.ExtHostSearch = ExtHostSearch;\n    function registerEHSearchProviders(extHostSearch, logService) {\n        const outputChannel = new ripgrepSearchUtils_1.OutputChannel(logService);\n        extHostSearch.registerTextSearchProvider('file', new ripgrepSearchProvider_1.RipgrepSearchProvider(outputChannel));\n        extHostSearch.registerInternalFileSearchProvider('file', new rawSearchService_1.SearchService());\n    }\n    exports.registerEHSearchProviders = registerEHSearchProviders;\n    function reviveQuery(rawQuery) {\n        return Object.assign({}, rawQuery, {\n            folderQueries: rawQuery.folderQueries && rawQuery.folderQueries.map(reviveFolderQuery),\n            extraFileResources: rawQuery.extraFileResources && rawQuery.extraFileResources.map(components => uri_1.URI.revive(components))\n        });\n    }\n    function reviveFolderQuery(rawFolderQuery) {\n        return Object.assign({}, rawFolderQuery, { folder: uri_1.URI.revive(rawFolderQuery.folder) });\n    }\n});\n",null]}