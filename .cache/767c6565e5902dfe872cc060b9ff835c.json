{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/node/encoding.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/encoding.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar stream = require(\"vs/base/node/stream\");\nvar iconv = require(\"iconv-lite\");\nvar platform_1 = require(\"vs/base/common/platform\");\nvar child_process_1 = require(\"child_process\");\nvar stream_1 = require(\"stream\");\nexports.UTF8 = 'utf8';\nexports.UTF8_with_bom = 'utf8bom';\nexports.UTF16be = 'utf16be';\nexports.UTF16le = 'utf16le';\nfunction toDecodeStream(readable, options) {\n    if (!options.minBytesRequiredForDetection) {\n        options.minBytesRequiredForDetection = options.guessEncoding ? AUTO_GUESS_BUFFER_MAX_LEN : NO_GUESS_BUFFER_MAX_LEN;\n    }\n    if (!options.overwriteEncoding) {\n        options.overwriteEncoding = function (detected) { return detected || exports.UTF8; };\n    }\n    return new Promise(function (resolve, reject) {\n        readable.on('error', reject);\n        readable.pipe(new /** @class */ (function (_super) {\n            tslib_1.__extends(class_1, _super);\n            function class_1() {\n                var _this = _super !== null && _super.apply(this, arguments) || this;\n                _this._buffer = [];\n                _this._bytesBuffered = 0;\n                return _this;\n            }\n            class_1.prototype._write = function (chunk, encoding, callback) {\n                if (!Buffer.isBuffer(chunk)) {\n                    callback(new Error('data must be a buffer'));\n                }\n                if (this._decodeStream) {\n                    // just a forwarder now\n                    this._decodeStream.write(chunk, callback);\n                    return;\n                }\n                this._buffer.push(chunk);\n                this._bytesBuffered += chunk.length;\n                if (this._decodeStreamConstruction) {\n                    // waiting for the decoder to be ready\n                    this._decodeStreamConstruction.then(function (_) { return callback(); }, function (err) { return callback(err); });\n                }\n                else if (typeof options.minBytesRequiredForDetection === 'number' && this._bytesBuffered >= options.minBytesRequiredForDetection) {\n                    // buffered enough data, create stream and forward data\n                    this._startDecodeStream(callback);\n                }\n                else {\n                    // only buffering\n                    callback();\n                }\n            };\n            class_1.prototype._startDecodeStream = function (callback) {\n                var _this = this;\n                this._decodeStreamConstruction = Promise.resolve(detectEncodingFromBuffer({\n                    buffer: Buffer.concat(this._buffer), bytesRead: this._bytesBuffered\n                }, options.guessEncoding)).then(function (detected) {\n                    if (options.overwriteEncoding) {\n                        detected.encoding = options.overwriteEncoding(detected.encoding);\n                    }\n                    _this._decodeStream = decodeStream(detected.encoding);\n                    for (var _i = 0, _a = _this._buffer; _i < _a.length; _i++) {\n                        var buffer = _a[_i];\n                        _this._decodeStream.write(buffer);\n                    }\n                    callback();\n                    resolve({ detected: detected, stream: _this._decodeStream });\n                }, function (err) {\n                    _this.emit('error', err);\n                    callback(err);\n                });\n            };\n            class_1.prototype._final = function (callback) {\n                var _this = this;\n                if (this._decodeStream) {\n                    // normal finish\n                    this._decodeStream.end(callback);\n                }\n                else {\n                    // we were still waiting for data...\n                    this._startDecodeStream(function () { return _this._decodeStream.end(callback); });\n                }\n            };\n            return class_1;\n        }(stream_1.Writable)));\n    });\n}\nexports.toDecodeStream = toDecodeStream;\nfunction bomLength(encoding) {\n    switch (encoding) {\n        case exports.UTF8:\n            return 3;\n        case exports.UTF16be:\n        case exports.UTF16le:\n            return 2;\n    }\n    return 0;\n}\nexports.bomLength = bomLength;\nfunction decode(buffer, encoding) {\n    return iconv.decode(buffer, toNodeEncoding(encoding));\n}\nexports.decode = decode;\nfunction encode(content, encoding, options) {\n    return iconv.encode(content, toNodeEncoding(encoding), options);\n}\nexports.encode = encode;\nfunction encodingExists(encoding) {\n    return iconv.encodingExists(toNodeEncoding(encoding));\n}\nexports.encodingExists = encodingExists;\nfunction decodeStream(encoding) {\n    return iconv.decodeStream(toNodeEncoding(encoding));\n}\nexports.decodeStream = decodeStream;\nfunction encodeStream(encoding, options) {\n    return iconv.encodeStream(toNodeEncoding(encoding), options);\n}\nexports.encodeStream = encodeStream;\nfunction toNodeEncoding(enc) {\n    if (enc === exports.UTF8_with_bom || enc === null) {\n        return exports.UTF8; // iconv does not distinguish UTF 8 with or without BOM, so we need to help it\n    }\n    return enc;\n}\nfunction detectEncodingByBOMFromBuffer(buffer, bytesRead) {\n    if (!buffer || bytesRead < 2) {\n        return null;\n    }\n    var b0 = buffer.readUInt8(0);\n    var b1 = buffer.readUInt8(1);\n    // UTF-16 BE\n    if (b0 === 0xFE && b1 === 0xFF) {\n        return exports.UTF16be;\n    }\n    // UTF-16 LE\n    if (b0 === 0xFF && b1 === 0xFE) {\n        return exports.UTF16le;\n    }\n    if (bytesRead < 3) {\n        return null;\n    }\n    var b2 = buffer.readUInt8(2);\n    // UTF-8\n    if (b0 === 0xEF && b1 === 0xBB && b2 === 0xBF) {\n        return exports.UTF8;\n    }\n    return null;\n}\nexports.detectEncodingByBOMFromBuffer = detectEncodingByBOMFromBuffer;\n/**\n * Detects the Byte Order Mark in a given file.\n * If no BOM is detected, null will be passed to callback.\n */\nfunction detectEncodingByBOM(file) {\n    return stream.readExactlyByFile(file, 3).then(function (_a) {\n        var buffer = _a.buffer, bytesRead = _a.bytesRead;\n        return detectEncodingByBOMFromBuffer(buffer, bytesRead);\n    });\n}\nexports.detectEncodingByBOM = detectEncodingByBOM;\nvar MINIMUM_THRESHOLD = 0.2;\nvar IGNORE_ENCODINGS = ['ascii', 'utf-8', 'utf-16', 'utf-32'];\n/**\n * Guesses the encoding from buffer.\n */\nfunction guessEncodingByBuffer(buffer) {\n    return Promise.resolve().then(function () { return require('jschardet'); }).then(function (jschardet) {\n        jschardet.Constants.MINIMUM_THRESHOLD = MINIMUM_THRESHOLD;\n        var guessed = jschardet.detect(buffer);\n        if (!guessed || !guessed.encoding) {\n            return null;\n        }\n        var enc = guessed.encoding.toLowerCase();\n        // Ignore encodings that cannot guess correctly\n        // (http://chardet.readthedocs.io/en/latest/supported-encodings.html)\n        if (0 <= IGNORE_ENCODINGS.indexOf(enc)) {\n            return null;\n        }\n        return toIconvLiteEncoding(guessed.encoding);\n    });\n}\nexports.guessEncodingByBuffer = guessEncodingByBuffer;\nvar JSCHARDET_TO_ICONV_ENCODINGS = {\n    'ibm866': 'cp866',\n    'big5': 'cp950'\n};\nfunction toIconvLiteEncoding(encodingName) {\n    var normalizedEncodingName = encodingName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n    var mapped = JSCHARDET_TO_ICONV_ENCODINGS[normalizedEncodingName];\n    return mapped || normalizedEncodingName;\n}\n/**\n * The encodings that are allowed in a settings file don't match the canonical encoding labels specified by WHATWG.\n * See https://encoding.spec.whatwg.org/#names-and-labels\n * Iconv-lite strips all non-alphanumeric characters, but ripgrep doesn't. For backcompat, allow these labels.\n */\nfunction toCanonicalName(enc) {\n    switch (enc) {\n        case 'shiftjis':\n            return 'shift-jis';\n        case 'utf16le':\n            return 'utf-16le';\n        case 'utf16be':\n            return 'utf-16be';\n        case 'big5hkscs':\n            return 'big5-hkscs';\n        case 'eucjp':\n            return 'euc-jp';\n        case 'euckr':\n            return 'euc-kr';\n        case 'koi8r':\n            return 'koi8-r';\n        case 'koi8u':\n            return 'koi8-u';\n        case 'macroman':\n            return 'x-mac-roman';\n        case 'utf8bom':\n            return 'utf8';\n        default:\n            var m = enc.match(/windows(\\d+)/);\n            if (m) {\n                return 'windows-' + m[1];\n            }\n            return enc;\n    }\n}\nexports.toCanonicalName = toCanonicalName;\nvar ZERO_BYTE_DETECTION_BUFFER_MAX_LEN = 512; // number of bytes to look at to decide about a file being binary or not\nvar NO_GUESS_BUFFER_MAX_LEN = 512; // when not auto guessing the encoding, small number of bytes are enough\nvar AUTO_GUESS_BUFFER_MAX_LEN = 512 * 8; // with auto guessing we want a lot more content to be read for guessing\nfunction detectEncodingFromBuffer(_a, autoGuessEncoding) {\n    var buffer = _a.buffer, bytesRead = _a.bytesRead;\n    // Always first check for BOM to find out about encoding\n    var encoding = detectEncodingByBOMFromBuffer(buffer, bytesRead);\n    // Detect 0 bytes to see if file is binary or UTF-16 LE/BE\n    // unless we already know that this file has a UTF-16 encoding\n    var seemsBinary = false;\n    if (encoding !== exports.UTF16be && encoding !== exports.UTF16le && buffer) {\n        var couldBeUTF16LE = true; // e.g. 0xAA 0x00\n        var couldBeUTF16BE = true; // e.g. 0x00 0xAA\n        var containsZeroByte = false;\n        // This is a simplified guess to detect UTF-16 BE or LE by just checking if\n        // the first 512 bytes have the 0-byte at a specific location. For UTF-16 LE\n        // this would be the odd byte index and for UTF-16 BE the even one.\n        // Note: this can produce false positives (a binary file that uses a 2-byte\n        // encoding of the same format as UTF-16) and false negatives (a UTF-16 file\n        // that is using 4 bytes to encode a character).\n        for (var i = 0; i < bytesRead && i < ZERO_BYTE_DETECTION_BUFFER_MAX_LEN; i++) {\n            var isEndian = (i % 2 === 1); // assume 2-byte sequences typical for UTF-16\n            var isZeroByte = (buffer.readInt8(i) === 0);\n            if (isZeroByte) {\n                containsZeroByte = true;\n            }\n            // UTF-16 LE: expect e.g. 0xAA 0x00\n            if (couldBeUTF16LE && (isEndian && !isZeroByte || !isEndian && isZeroByte)) {\n                couldBeUTF16LE = false;\n            }\n            // UTF-16 BE: expect e.g. 0x00 0xAA\n            if (couldBeUTF16BE && (isEndian && isZeroByte || !isEndian && !isZeroByte)) {\n                couldBeUTF16BE = false;\n            }\n            // Return if this is neither UTF16-LE nor UTF16-BE and thus treat as binary\n            if (isZeroByte && !couldBeUTF16LE && !couldBeUTF16BE) {\n                break;\n            }\n        }\n        // Handle case of 0-byte included\n        if (containsZeroByte) {\n            if (couldBeUTF16LE) {\n                encoding = exports.UTF16le;\n            }\n            else if (couldBeUTF16BE) {\n                encoding = exports.UTF16be;\n            }\n            else {\n                seemsBinary = true;\n            }\n        }\n    }\n    // Auto guess encoding if configured\n    if (autoGuessEncoding && !seemsBinary && !encoding && buffer) {\n        return guessEncodingByBuffer(buffer.slice(0, bytesRead)).then(function (guessedEncoding) {\n            return {\n                seemsBinary: false,\n                encoding: guessedEncoding\n            };\n        });\n    }\n    return { seemsBinary: seemsBinary, encoding: encoding };\n}\nexports.detectEncodingFromBuffer = detectEncodingFromBuffer;\n// https://ss64.com/nt/chcp.html\nvar windowsTerminalEncodings = {\n    '437': 'cp437',\n    '850': 'cp850',\n    '852': 'cp852',\n    '855': 'cp855',\n    '857': 'cp857',\n    '860': 'cp860',\n    '861': 'cp861',\n    '863': 'cp863',\n    '865': 'cp865',\n    '866': 'cp866',\n    '869': 'cp869',\n    '936': 'cp936',\n    '1252': 'cp1252' // West European Latin\n};\nfunction resolveTerminalEncoding(verbose) {\n    var rawEncodingPromise;\n    // Support a global environment variable to win over other mechanics\n    var cliEncodingEnv = process.env['VSCODE_CLI_ENCODING'];\n    if (cliEncodingEnv) {\n        if (verbose) {\n            console.log(\"Found VSCODE_CLI_ENCODING variable: \" + cliEncodingEnv);\n        }\n        rawEncodingPromise = Promise.resolve(cliEncodingEnv);\n    }\n    // Linux/Mac: use \"locale charmap\" command\n    else if (platform_1.isLinux || platform_1.isMacintosh) {\n        rawEncodingPromise = new Promise(function (resolve) {\n            if (verbose) {\n                console.log('Running \"locale charmap\" to detect terminal encoding...');\n            }\n            child_process_1.exec('locale charmap', function (err, stdout, stderr) { return resolve(stdout); });\n        });\n    }\n    // Windows: educated guess\n    else {\n        rawEncodingPromise = new Promise(function (resolve) {\n            if (verbose) {\n                console.log('Running \"chcp\" to detect terminal encoding...');\n            }\n            child_process_1.exec('chcp', function (err, stdout, stderr) {\n                if (stdout) {\n                    var windowsTerminalEncodingKeys = Object.keys(windowsTerminalEncodings);\n                    for (var _i = 0, windowsTerminalEncodingKeys_1 = windowsTerminalEncodingKeys; _i < windowsTerminalEncodingKeys_1.length; _i++) {\n                        var key = windowsTerminalEncodingKeys_1[_i];\n                        if (stdout.indexOf(key) >= 0) {\n                            return resolve(windowsTerminalEncodings[key]);\n                        }\n                    }\n                }\n                return resolve(undefined);\n            });\n        });\n    }\n    return rawEncodingPromise.then(function (rawEncoding) {\n        if (verbose) {\n            console.log(\"Detected raw terminal encoding: \" + rawEncoding);\n        }\n        if (!rawEncoding || rawEncoding.toLowerCase() === 'utf-8' || rawEncoding.toLowerCase() === exports.UTF8) {\n            return exports.UTF8;\n        }\n        var iconvEncoding = toIconvLiteEncoding(rawEncoding);\n        if (iconv.encodingExists(iconvEncoding)) {\n            return iconvEncoding;\n        }\n        if (verbose) {\n            console.log('Unsupported terminal encoding, falling back to UTF-8.');\n        }\n        return exports.UTF8;\n    });\n}\nexports.resolveTerminalEncoding = resolveTerminalEncoding;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/node/encoding.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/node/encoding.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as stream from 'vs/base/node/stream';\nimport * as iconv from 'iconv-lite';\nimport { isLinux, isMacintosh } from 'vs/base/common/platform';\nimport { exec } from 'child_process';\nimport { Readable, Writable } from 'stream';\n\nexport const UTF8 = 'utf8';\nexport const UTF8_with_bom = 'utf8bom';\nexport const UTF16be = 'utf16be';\nexport const UTF16le = 'utf16le';\n\nexport interface IDecodeStreamOptions {\n\tguessEncoding?: boolean;\n\tminBytesRequiredForDetection?: number;\n\toverwriteEncoding?(detectedEncoding: string | null): string;\n}\n\nexport function toDecodeStream(readable: Readable, options: IDecodeStreamOptions): Promise<{ detected: IDetectedEncodingResult, stream: NodeJS.ReadableStream }> {\n\tif (!options.minBytesRequiredForDetection) {\n\t\toptions.minBytesRequiredForDetection = options.guessEncoding ? AUTO_GUESS_BUFFER_MAX_LEN : NO_GUESS_BUFFER_MAX_LEN;\n\t}\n\n\tif (!options.overwriteEncoding) {\n\t\toptions.overwriteEncoding = detected => detected || UTF8;\n\t}\n\n\treturn new Promise<{ detected: IDetectedEncodingResult, stream: NodeJS.ReadableStream }>((resolve, reject) => {\n\n\t\treadable.on('error', reject);\n\n\t\treadable.pipe(new class extends Writable {\n\n\t\t\tprivate _decodeStream: NodeJS.ReadWriteStream;\n\t\t\tprivate _decodeStreamConstruction: Promise<any>;\n\t\t\tprivate _buffer: Buffer[] = [];\n\t\t\tprivate _bytesBuffered = 0;\n\n\t\t\t_write(chunk: any, encoding: string, callback: Function): void {\n\t\t\t\tif (!Buffer.isBuffer(chunk)) {\n\t\t\t\t\tcallback(new Error('data must be a buffer'));\n\t\t\t\t}\n\n\t\t\t\tif (this._decodeStream) {\n\t\t\t\t\t// just a forwarder now\n\t\t\t\t\tthis._decodeStream.write(chunk, callback);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._buffer.push(chunk);\n\t\t\t\tthis._bytesBuffered += chunk.length;\n\n\t\t\t\tif (this._decodeStreamConstruction) {\n\t\t\t\t\t// waiting for the decoder to be ready\n\t\t\t\t\tthis._decodeStreamConstruction.then(_ => callback(), err => callback(err));\n\n\t\t\t\t} else if (typeof options.minBytesRequiredForDetection === 'number' && this._bytesBuffered >= options.minBytesRequiredForDetection) {\n\t\t\t\t\t// buffered enough data, create stream and forward data\n\t\t\t\t\tthis._startDecodeStream(callback);\n\n\t\t\t\t} else {\n\t\t\t\t\t// only buffering\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_startDecodeStream(callback: Function): void {\n\n\t\t\t\tthis._decodeStreamConstruction = Promise.resolve(detectEncodingFromBuffer({\n\t\t\t\t\tbuffer: Buffer.concat(this._buffer), bytesRead: this._bytesBuffered\n\t\t\t\t}, options.guessEncoding)).then(detected => {\n\t\t\t\t\tif (options.overwriteEncoding) {\n\t\t\t\t\t\tdetected.encoding = options.overwriteEncoding(detected.encoding);\n\t\t\t\t\t}\n\t\t\t\t\tthis._decodeStream = decodeStream(detected.encoding);\n\t\t\t\t\tfor (const buffer of this._buffer) {\n\t\t\t\t\t\tthis._decodeStream.write(buffer);\n\t\t\t\t\t}\n\t\t\t\t\tcallback();\n\t\t\t\t\tresolve({ detected, stream: this._decodeStream });\n\n\t\t\t\t}, err => {\n\t\t\t\t\tthis.emit('error', err);\n\t\t\t\t\tcallback(err);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_final(callback: (err?: any) => any) {\n\t\t\t\tif (this._decodeStream) {\n\t\t\t\t\t// normal finish\n\t\t\t\t\tthis._decodeStream.end(callback);\n\t\t\t\t} else {\n\t\t\t\t\t// we were still waiting for data...\n\t\t\t\t\tthis._startDecodeStream(() => this._decodeStream.end(callback));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport function bomLength(encoding: string): number {\n\tswitch (encoding) {\n\t\tcase UTF8:\n\t\t\treturn 3;\n\t\tcase UTF16be:\n\t\tcase UTF16le:\n\t\t\treturn 2;\n\t}\n\n\treturn 0;\n}\n\nexport function decode(buffer: Buffer, encoding: string): string {\n\treturn iconv.decode(buffer, toNodeEncoding(encoding));\n}\n\nexport function encode(content: string | Buffer, encoding: string, options?: { addBOM?: boolean }): Buffer {\n\treturn iconv.encode(content, toNodeEncoding(encoding), options);\n}\n\nexport function encodingExists(encoding: string): boolean {\n\treturn iconv.encodingExists(toNodeEncoding(encoding));\n}\n\nexport function decodeStream(encoding: string | null): NodeJS.ReadWriteStream {\n\treturn iconv.decodeStream(toNodeEncoding(encoding));\n}\n\nexport function encodeStream(encoding: string, options?: { addBOM?: boolean }): NodeJS.ReadWriteStream {\n\treturn iconv.encodeStream(toNodeEncoding(encoding), options);\n}\n\nfunction toNodeEncoding(enc: string | null): string {\n\tif (enc === UTF8_with_bom || enc === null) {\n\t\treturn UTF8; // iconv does not distinguish UTF 8 with or without BOM, so we need to help it\n\t}\n\n\treturn enc;\n}\n\nexport function detectEncodingByBOMFromBuffer(buffer: Buffer | null, bytesRead: number): string | null {\n\tif (!buffer || bytesRead < 2) {\n\t\treturn null;\n\t}\n\n\tconst b0 = buffer.readUInt8(0);\n\tconst b1 = buffer.readUInt8(1);\n\n\t// UTF-16 BE\n\tif (b0 === 0xFE && b1 === 0xFF) {\n\t\treturn UTF16be;\n\t}\n\n\t// UTF-16 LE\n\tif (b0 === 0xFF && b1 === 0xFE) {\n\t\treturn UTF16le;\n\t}\n\n\tif (bytesRead < 3) {\n\t\treturn null;\n\t}\n\n\tconst b2 = buffer.readUInt8(2);\n\n\t// UTF-8\n\tif (b0 === 0xEF && b1 === 0xBB && b2 === 0xBF) {\n\t\treturn UTF8;\n\t}\n\n\treturn null;\n}\n\n/**\n * Detects the Byte Order Mark in a given file.\n * If no BOM is detected, null will be passed to callback.\n */\nexport function detectEncodingByBOM(file: string): Promise<string | null> {\n\treturn stream.readExactlyByFile(file, 3).then(({ buffer, bytesRead }) => detectEncodingByBOMFromBuffer(buffer, bytesRead));\n}\n\nconst MINIMUM_THRESHOLD = 0.2;\nconst IGNORE_ENCODINGS = ['ascii', 'utf-8', 'utf-16', 'utf-32'];\n\n/**\n * Guesses the encoding from buffer.\n */\nexport function guessEncodingByBuffer(buffer: Buffer): Promise<string | null> {\n\treturn import('jschardet').then(jschardet => {\n\t\tjschardet.Constants.MINIMUM_THRESHOLD = MINIMUM_THRESHOLD;\n\n\t\tconst guessed = jschardet.detect(buffer);\n\t\tif (!guessed || !guessed.encoding) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst enc = guessed.encoding.toLowerCase();\n\n\t\t// Ignore encodings that cannot guess correctly\n\t\t// (http://chardet.readthedocs.io/en/latest/supported-encodings.html)\n\t\tif (0 <= IGNORE_ENCODINGS.indexOf(enc)) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn toIconvLiteEncoding(guessed.encoding);\n\t});\n}\n\nconst JSCHARDET_TO_ICONV_ENCODINGS: { [name: string]: string } = {\n\t'ibm866': 'cp866',\n\t'big5': 'cp950'\n};\n\nfunction toIconvLiteEncoding(encodingName: string): string {\n\tconst normalizedEncodingName = encodingName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n\tconst mapped = JSCHARDET_TO_ICONV_ENCODINGS[normalizedEncodingName];\n\n\treturn mapped || normalizedEncodingName;\n}\n\n/**\n * The encodings that are allowed in a settings file don't match the canonical encoding labels specified by WHATWG.\n * See https://encoding.spec.whatwg.org/#names-and-labels\n * Iconv-lite strips all non-alphanumeric characters, but ripgrep doesn't. For backcompat, allow these labels.\n */\nexport function toCanonicalName(enc: string): string {\n\tswitch (enc) {\n\t\tcase 'shiftjis':\n\t\t\treturn 'shift-jis';\n\t\tcase 'utf16le':\n\t\t\treturn 'utf-16le';\n\t\tcase 'utf16be':\n\t\t\treturn 'utf-16be';\n\t\tcase 'big5hkscs':\n\t\t\treturn 'big5-hkscs';\n\t\tcase 'eucjp':\n\t\t\treturn 'euc-jp';\n\t\tcase 'euckr':\n\t\t\treturn 'euc-kr';\n\t\tcase 'koi8r':\n\t\t\treturn 'koi8-r';\n\t\tcase 'koi8u':\n\t\t\treturn 'koi8-u';\n\t\tcase 'macroman':\n\t\t\treturn 'x-mac-roman';\n\t\tcase 'utf8bom':\n\t\t\treturn 'utf8';\n\t\tdefault:\n\t\t\tconst m = enc.match(/windows(\\d+)/);\n\t\t\tif (m) {\n\t\t\t\treturn 'windows-' + m[1];\n\t\t\t}\n\n\t\t\treturn enc;\n\t}\n}\n\nconst ZERO_BYTE_DETECTION_BUFFER_MAX_LEN = 512; // number of bytes to look at to decide about a file being binary or not\nconst NO_GUESS_BUFFER_MAX_LEN = 512; \t\t\t// when not auto guessing the encoding, small number of bytes are enough\nconst AUTO_GUESS_BUFFER_MAX_LEN = 512 * 8; \t\t// with auto guessing we want a lot more content to be read for guessing\n\nexport interface IDetectedEncodingResult {\n\tencoding: string | null;\n\tseemsBinary: boolean;\n}\n\nexport function detectEncodingFromBuffer(readResult: stream.ReadResult, autoGuessEncoding?: false): IDetectedEncodingResult;\nexport function detectEncodingFromBuffer(readResult: stream.ReadResult, autoGuessEncoding?: boolean): Promise<IDetectedEncodingResult>;\nexport function detectEncodingFromBuffer({ buffer, bytesRead }: stream.ReadResult, autoGuessEncoding?: boolean): Promise<IDetectedEncodingResult> | IDetectedEncodingResult {\n\n\t// Always first check for BOM to find out about encoding\n\tlet encoding = detectEncodingByBOMFromBuffer(buffer, bytesRead);\n\n\t// Detect 0 bytes to see if file is binary or UTF-16 LE/BE\n\t// unless we already know that this file has a UTF-16 encoding\n\tlet seemsBinary = false;\n\tif (encoding !== UTF16be && encoding !== UTF16le && buffer) {\n\t\tlet couldBeUTF16LE = true; // e.g. 0xAA 0x00\n\t\tlet couldBeUTF16BE = true; // e.g. 0x00 0xAA\n\t\tlet containsZeroByte = false;\n\n\t\t// This is a simplified guess to detect UTF-16 BE or LE by just checking if\n\t\t// the first 512 bytes have the 0-byte at a specific location. For UTF-16 LE\n\t\t// this would be the odd byte index and for UTF-16 BE the even one.\n\t\t// Note: this can produce false positives (a binary file that uses a 2-byte\n\t\t// encoding of the same format as UTF-16) and false negatives (a UTF-16 file\n\t\t// that is using 4 bytes to encode a character).\n\t\tfor (let i = 0; i < bytesRead && i < ZERO_BYTE_DETECTION_BUFFER_MAX_LEN; i++) {\n\t\t\tconst isEndian = (i % 2 === 1); // assume 2-byte sequences typical for UTF-16\n\t\t\tconst isZeroByte = (buffer.readInt8(i) === 0);\n\n\t\t\tif (isZeroByte) {\n\t\t\t\tcontainsZeroByte = true;\n\t\t\t}\n\n\t\t\t// UTF-16 LE: expect e.g. 0xAA 0x00\n\t\t\tif (couldBeUTF16LE && (isEndian && !isZeroByte || !isEndian && isZeroByte)) {\n\t\t\t\tcouldBeUTF16LE = false;\n\t\t\t}\n\n\t\t\t// UTF-16 BE: expect e.g. 0x00 0xAA\n\t\t\tif (couldBeUTF16BE && (isEndian && isZeroByte || !isEndian && !isZeroByte)) {\n\t\t\t\tcouldBeUTF16BE = false;\n\t\t\t}\n\n\t\t\t// Return if this is neither UTF16-LE nor UTF16-BE and thus treat as binary\n\t\t\tif (isZeroByte && !couldBeUTF16LE && !couldBeUTF16BE) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Handle case of 0-byte included\n\t\tif (containsZeroByte) {\n\t\t\tif (couldBeUTF16LE) {\n\t\t\t\tencoding = UTF16le;\n\t\t\t} else if (couldBeUTF16BE) {\n\t\t\t\tencoding = UTF16be;\n\t\t\t} else {\n\t\t\t\tseemsBinary = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Auto guess encoding if configured\n\tif (autoGuessEncoding && !seemsBinary && !encoding && buffer) {\n\t\treturn guessEncodingByBuffer(buffer.slice(0, bytesRead)).then(guessedEncoding => {\n\t\t\treturn {\n\t\t\t\tseemsBinary: false,\n\t\t\t\tencoding: guessedEncoding\n\t\t\t};\n\t\t});\n\t}\n\n\treturn { seemsBinary, encoding };\n}\n\n// https://ss64.com/nt/chcp.html\nconst windowsTerminalEncodings = {\n\t'437': 'cp437', // United States\n\t'850': 'cp850', // Multilingual(Latin I)\n\t'852': 'cp852', // Slavic(Latin II)\n\t'855': 'cp855', // Cyrillic(Russian)\n\t'857': 'cp857', // Turkish\n\t'860': 'cp860', // Portuguese\n\t'861': 'cp861', // Icelandic\n\t'863': 'cp863', // Canadian - French\n\t'865': 'cp865', // Nordic\n\t'866': 'cp866', // Russian\n\t'869': 'cp869', // Modern Greek\n\t'936': 'cp936', // Simplified Chinese\n\t'1252': 'cp1252' // West European Latin\n};\n\nexport function resolveTerminalEncoding(verbose?: boolean): Promise<string> {\n\tlet rawEncodingPromise: Promise<string>;\n\n\t// Support a global environment variable to win over other mechanics\n\tconst cliEncodingEnv = process.env['VSCODE_CLI_ENCODING'];\n\tif (cliEncodingEnv) {\n\t\tif (verbose) {\n\t\t\tconsole.log(`Found VSCODE_CLI_ENCODING variable: ${cliEncodingEnv}`);\n\t\t}\n\n\t\trawEncodingPromise = Promise.resolve(cliEncodingEnv);\n\t}\n\n\t// Linux/Mac: use \"locale charmap\" command\n\telse if (isLinux || isMacintosh) {\n\t\trawEncodingPromise = new Promise<string>(resolve => {\n\t\t\tif (verbose) {\n\t\t\t\tconsole.log('Running \"locale charmap\" to detect terminal encoding...');\n\t\t\t}\n\n\t\t\texec('locale charmap', (err, stdout, stderr) => resolve(stdout));\n\t\t});\n\t}\n\n\t// Windows: educated guess\n\telse {\n\t\trawEncodingPromise = new Promise<string>(resolve => {\n\t\t\tif (verbose) {\n\t\t\t\tconsole.log('Running \"chcp\" to detect terminal encoding...');\n\t\t\t}\n\n\t\t\texec('chcp', (err, stdout, stderr) => {\n\t\t\t\tif (stdout) {\n\t\t\t\t\tconst windowsTerminalEncodingKeys = Object.keys(windowsTerminalEncodings);\n\t\t\t\t\tfor (const key of windowsTerminalEncodingKeys) {\n\t\t\t\t\t\tif (stdout.indexOf(key) >= 0) {\n\t\t\t\t\t\t\treturn resolve(windowsTerminalEncodings[key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn resolve(undefined);\n\t\t\t});\n\t\t});\n\t}\n\n\treturn rawEncodingPromise.then(rawEncoding => {\n\t\tif (verbose) {\n\t\t\tconsole.log(`Detected raw terminal encoding: ${rawEncoding}`);\n\t\t}\n\n\t\tif (!rawEncoding || rawEncoding.toLowerCase() === 'utf-8' || rawEncoding.toLowerCase() === UTF8) {\n\t\t\treturn UTF8;\n\t\t}\n\n\t\tconst iconvEncoding = toIconvLiteEncoding(rawEncoding);\n\t\tif (iconv.encodingExists(iconvEncoding)) {\n\t\t\treturn iconvEncoding;\n\t\t}\n\n\t\tif (verbose) {\n\t\t\tconsole.log('Unsupported terminal encoding, falling back to UTF-8.');\n\t\t}\n\n\t\treturn UTF8;\n\t});\n}\n"]}]}