{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/platform/workspaces/common/workspaces.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/workspaces/common/workspaces.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar nls_1 = require(\"vs/nls\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar platform_1 = require(\"vs/base/common/platform\");\nvar path_1 = require(\"vs/base/common/path\");\nvar resources_1 = require(\"vs/base/common/resources\");\nvar jsonEdit = require(\"vs/base/common/jsonEdit\");\nvar json = require(\"vs/base/common/json\");\nvar network_1 = require(\"vs/base/common/network\");\nvar labels_1 = require(\"vs/base/common/labels\");\nvar extpath_1 = require(\"vs/base/common/extpath\");\nexports.IWorkspacesMainService = instantiation_1.createDecorator('workspacesMainService');\nexports.IWorkspacesService = instantiation_1.createDecorator('workspacesService');\nexports.WORKSPACE_EXTENSION = 'code-workspace';\nexports.WORKSPACE_FILTER = [{ name: nls_1.localize('codeWorkspace', \"Code Workspace\"), extensions: [exports.WORKSPACE_EXTENSION] }];\nexports.UNTITLED_WORKSPACE_NAME = 'workspace.json';\nfunction reviveWorkspaceIdentifier(workspace) {\n    return { id: workspace.id, configPath: uri_1.URI.revive(workspace.configPath) };\n}\nexports.reviveWorkspaceIdentifier = reviveWorkspaceIdentifier;\nfunction isStoredWorkspaceFolder(thing) {\n    return isRawFileWorkspaceFolder(thing) || isRawUriWorkspaceFolder(thing);\n}\nexports.isStoredWorkspaceFolder = isStoredWorkspaceFolder;\nfunction isRawFileWorkspaceFolder(thing) {\n    return thing\n        && typeof thing === 'object'\n        && typeof thing.path === 'string'\n        && (!thing.name || typeof thing.name === 'string');\n}\nexports.isRawFileWorkspaceFolder = isRawFileWorkspaceFolder;\nfunction isRawUriWorkspaceFolder(thing) {\n    return thing\n        && typeof thing === 'object'\n        && typeof thing.uri === 'string'\n        && (!thing.name || typeof thing.name === 'string');\n}\nexports.isRawUriWorkspaceFolder = isRawUriWorkspaceFolder;\nfunction isSingleFolderWorkspaceIdentifier(obj) {\n    return obj instanceof uri_1.URI;\n}\nexports.isSingleFolderWorkspaceIdentifier = isSingleFolderWorkspaceIdentifier;\nfunction isWorkspaceIdentifier(obj) {\n    var workspaceIdentifier = obj;\n    return workspaceIdentifier && typeof workspaceIdentifier.id === 'string' && workspaceIdentifier.configPath instanceof uri_1.URI;\n}\nexports.isWorkspaceIdentifier = isWorkspaceIdentifier;\nfunction toWorkspaceIdentifier(workspace) {\n    if (workspace.configuration) {\n        return {\n            configPath: workspace.configuration,\n            id: workspace.id\n        };\n    }\n    if (workspace.folders.length === 1) {\n        return workspace.folders[0].uri;\n    }\n    // Empty workspace\n    return undefined;\n}\nexports.toWorkspaceIdentifier = toWorkspaceIdentifier;\nfunction isSingleFolderWorkspaceInitializationPayload(obj) {\n    return isSingleFolderWorkspaceIdentifier(obj.folder);\n}\nexports.isSingleFolderWorkspaceInitializationPayload = isSingleFolderWorkspaceInitializationPayload;\nvar WORKSPACE_SUFFIX = '.' + exports.WORKSPACE_EXTENSION;\nfunction hasWorkspaceFileExtension(path) {\n    return path_1.extname(path) === WORKSPACE_SUFFIX;\n}\nexports.hasWorkspaceFileExtension = hasWorkspaceFileExtension;\nvar SLASH = '/';\n/**\n * Given a folder URI and the workspace config folder, computes the IStoredWorkspaceFolder using\n* a relative or absolute path or a uri.\n * Undefined is returned if the folderURI and the targetConfigFolderURI don't have the same schema or authority\n *\n * @param folderURI a workspace folder\n * @param folderName a workspace name\n * @param targetConfigFolderURI the folder where the workspace is living in\n * @param useSlashForPath if set, use forward slashes for file paths on windows\n */\nfunction getStoredWorkspaceFolder(folderURI, folderName, targetConfigFolderURI, useSlashForPath) {\n    if (useSlashForPath === void 0) { useSlashForPath = !platform_1.isWindows; }\n    if (folderURI.scheme !== targetConfigFolderURI.scheme) {\n        return { name: folderName, uri: folderURI.toString(true) };\n    }\n    var folderPath;\n    if (resources_1.isEqualOrParent(folderURI, targetConfigFolderURI)) {\n        // use relative path\n        folderPath = resources_1.relativePath(targetConfigFolderURI, folderURI) || '.'; // always uses forward slashes\n        if (platform_1.isWindows && folderURI.scheme === network_1.Schemas.file && !useSlashForPath) {\n            // Windows gets special treatment:\n            // - use backslahes unless slash is used by other existing folders\n            folderPath = folderPath.replace(/\\//g, '\\\\');\n        }\n    }\n    else {\n        // use absolute path\n        if (folderURI.scheme === network_1.Schemas.file) {\n            folderPath = folderURI.fsPath;\n            if (platform_1.isWindows) {\n                // Windows gets special treatment:\n                // - normalize all paths to get nice casing of drive letters\n                // - use backslahes unless slash is used by other existing folders\n                folderPath = labels_1.normalizeDriveLetter(folderPath);\n                if (useSlashForPath) {\n                    folderPath = extpath_1.toSlashes(folderPath);\n                }\n            }\n        }\n        else {\n            if (!resources_1.isEqualAuthority(folderURI.authority, targetConfigFolderURI.authority)) {\n                return { name: folderName, uri: folderURI.toString(true) };\n            }\n            folderPath = folderURI.path;\n        }\n    }\n    return { name: folderName, path: folderPath };\n}\nexports.getStoredWorkspaceFolder = getStoredWorkspaceFolder;\n/**\n * Rewrites the content of a workspace file to be saved at a new location.\n * Throws an exception if file is not a valid workspace file\n */\nfunction rewriteWorkspaceFileForNewLocation(rawWorkspaceContents, configPathURI, targetConfigPathURI) {\n    var storedWorkspace = doParseStoredWorkspace(configPathURI, rawWorkspaceContents);\n    var sourceConfigFolder = resources_1.dirname(configPathURI);\n    var targetConfigFolder = resources_1.dirname(targetConfigPathURI);\n    var rewrittenFolders = [];\n    var slashForPath = useSlashForPath(storedWorkspace.folders);\n    // Rewrite absolute paths to relative paths if the target workspace folder\n    // is a parent of the location of the workspace file itself. Otherwise keep\n    // using absolute paths.\n    for (var _i = 0, _a = storedWorkspace.folders; _i < _a.length; _i++) {\n        var folder = _a[_i];\n        var folderURI = isRawFileWorkspaceFolder(folder) ? resources_1.resolvePath(sourceConfigFolder, folder.path) : uri_1.URI.parse(folder.uri);\n        rewrittenFolders.push(getStoredWorkspaceFolder(folderURI, folder.name, targetConfigFolder, slashForPath));\n    }\n    // Preserve as much of the existing workspace as possible by using jsonEdit\n    // and only changing the folders portion.\n    var newRawWorkspaceContents = rawWorkspaceContents;\n    var edits = jsonEdit.setProperty(rawWorkspaceContents, ['folders'], rewrittenFolders, { insertSpaces: false, tabSize: 4, eol: (platform_1.isLinux || platform_1.isMacintosh) ? '\\n' : '\\r\\n' });\n    edits.forEach(function (edit) {\n        newRawWorkspaceContents = jsonEdit.applyEdit(rawWorkspaceContents, edit);\n    });\n    return newRawWorkspaceContents;\n}\nexports.rewriteWorkspaceFileForNewLocation = rewriteWorkspaceFileForNewLocation;\nfunction doParseStoredWorkspace(path, contents) {\n    // Parse workspace file\n    var storedWorkspace = json.parse(contents); // use fault tolerant parser\n    // Filter out folders which do not have a path or uri set\n    if (Array.isArray(storedWorkspace.folders)) {\n        storedWorkspace.folders = storedWorkspace.folders.filter(function (folder) { return isStoredWorkspaceFolder(folder); });\n    }\n    // Validate\n    if (!Array.isArray(storedWorkspace.folders)) {\n        throw new Error(path + \" looks like an invalid workspace file.\");\n    }\n    return storedWorkspace;\n}\nfunction useSlashForPath(storedFolders) {\n    if (platform_1.isWindows) {\n        for (var _i = 0, storedFolders_1 = storedFolders; _i < storedFolders_1.length; _i++) {\n            var folder = storedFolders_1[_i];\n            if (isRawFileWorkspaceFolder(folder) && folder.path.indexOf(SLASH) >= 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return true;\n}\nexports.useSlashForPath = useSlashForPath;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/platform/workspaces/common/workspaces.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/platform/workspaces/common/workspaces.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { localize } from 'vs/nls';\nimport { Event } from 'vs/base/common/event';\nimport { IWorkspaceFolder, IWorkspace } from 'vs/platform/workspace/common/workspace';\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { isWindows, isLinux, isMacintosh } from 'vs/base/common/platform';\nimport { extname } from 'vs/base/common/path';\nimport { dirname, resolvePath, isEqualAuthority, isEqualOrParent, relativePath } from 'vs/base/common/resources';\nimport * as jsonEdit from 'vs/base/common/jsonEdit';\nimport * as json from 'vs/base/common/json';\nimport { Schemas } from 'vs/base/common/network';\nimport { normalizeDriveLetter } from 'vs/base/common/labels';\nimport { toSlashes } from 'vs/base/common/extpath';\n\nexport const IWorkspacesMainService = createDecorator<IWorkspacesMainService>('workspacesMainService');\nexport const IWorkspacesService = createDecorator<IWorkspacesService>('workspacesService');\n\nexport const WORKSPACE_EXTENSION = 'code-workspace';\nexport const WORKSPACE_FILTER = [{ name: localize('codeWorkspace', \"Code Workspace\"), extensions: [WORKSPACE_EXTENSION] }];\nexport const UNTITLED_WORKSPACE_NAME = 'workspace.json';\n\n/**\n * A single folder workspace identifier is just the path to the folder.\n */\nexport type ISingleFolderWorkspaceIdentifier = URI;\n\nexport interface IWorkspaceIdentifier {\n\tid: string;\n\tconfigPath: URI;\n}\n\nexport function reviveWorkspaceIdentifier(workspace: { id: string, configPath: UriComponents; }): IWorkspaceIdentifier {\n\treturn { id: workspace.id, configPath: URI.revive(workspace.configPath) };\n}\n\nexport function isStoredWorkspaceFolder(thing: any): thing is IStoredWorkspaceFolder {\n\treturn isRawFileWorkspaceFolder(thing) || isRawUriWorkspaceFolder(thing);\n}\n\nexport function isRawFileWorkspaceFolder(thing: any): thing is IRawFileWorkspaceFolder {\n\treturn thing\n\t\t&& typeof thing === 'object'\n\t\t&& typeof thing.path === 'string'\n\t\t&& (!thing.name || typeof thing.name === 'string');\n}\n\nexport function isRawUriWorkspaceFolder(thing: any): thing is IRawUriWorkspaceFolder {\n\treturn thing\n\t\t&& typeof thing === 'object'\n\t\t&& typeof thing.uri === 'string'\n\t\t&& (!thing.name || typeof thing.name === 'string');\n}\n\nexport interface IRawFileWorkspaceFolder {\n\tpath: string;\n\tname?: string;\n}\n\nexport interface IRawUriWorkspaceFolder {\n\turi: string;\n\tname?: string;\n}\n\nexport type IStoredWorkspaceFolder = IRawFileWorkspaceFolder | IRawUriWorkspaceFolder;\n\nexport interface IResolvedWorkspace extends IWorkspaceIdentifier {\n\tfolders: IWorkspaceFolder[];\n\tremoteAuthority?: string;\n}\n\nexport interface IStoredWorkspace {\n\tfolders: IStoredWorkspaceFolder[];\n}\n\nexport interface IWorkspaceSavedEvent {\n\tworkspace: IWorkspaceIdentifier;\n\toldConfigPath: string;\n}\n\nexport interface IWorkspaceFolderCreationData {\n\turi: URI;\n\tname?: string;\n}\n\nexport interface IUntitledWorkspaceInfo {\n\tworkspace: IWorkspaceIdentifier;\n\tremoteAuthority?: string;\n}\n\nexport interface IWorkspacesMainService extends IWorkspacesService {\n\t_serviceBrand: any;\n\n\tonUntitledWorkspaceDeleted: Event<IWorkspaceIdentifier>;\n\n\tcreateUntitledWorkspaceSync(folders?: IWorkspaceFolderCreationData[]): IWorkspaceIdentifier;\n\n\tresolveLocalWorkspaceSync(path: URI): IResolvedWorkspace | null;\n\n\tisUntitledWorkspace(workspace: IWorkspaceIdentifier): boolean;\n\n\tdeleteUntitledWorkspaceSync(workspace: IWorkspaceIdentifier): void;\n\n\tgetUntitledWorkspacesSync(): IUntitledWorkspaceInfo[];\n}\n\nexport interface IWorkspacesService {\n\t_serviceBrand: any;\n\n\tcreateUntitledWorkspace(folders?: IWorkspaceFolderCreationData[], remoteAuthority?: string): Promise<IWorkspaceIdentifier>;\n\n\tdeleteUntitledWorkspace(workspace: IWorkspaceIdentifier): Promise<void>;\n\n\tgetWorkspaceIdentifier(workspacePath: URI): Promise<IWorkspaceIdentifier>;\n}\n\nexport function isSingleFolderWorkspaceIdentifier(obj: any): obj is ISingleFolderWorkspaceIdentifier {\n\treturn obj instanceof URI;\n}\n\nexport function isWorkspaceIdentifier(obj: any): obj is IWorkspaceIdentifier {\n\tconst workspaceIdentifier = obj as IWorkspaceIdentifier;\n\n\treturn workspaceIdentifier && typeof workspaceIdentifier.id === 'string' && workspaceIdentifier.configPath instanceof URI;\n}\n\nexport function toWorkspaceIdentifier(workspace: IWorkspace): IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier | undefined {\n\tif (workspace.configuration) {\n\t\treturn {\n\t\t\tconfigPath: workspace.configuration,\n\t\t\tid: workspace.id\n\t\t};\n\t}\n\tif (workspace.folders.length === 1) {\n\t\treturn workspace.folders[0].uri;\n\t}\n\n\t// Empty workspace\n\treturn undefined;\n}\n\nexport type IMultiFolderWorkspaceInitializationPayload = IWorkspaceIdentifier;\nexport interface ISingleFolderWorkspaceInitializationPayload { id: string; folder: ISingleFolderWorkspaceIdentifier; }\nexport interface IEmptyWorkspaceInitializationPayload { id: string; }\n\nexport type IWorkspaceInitializationPayload = IMultiFolderWorkspaceInitializationPayload | ISingleFolderWorkspaceInitializationPayload | IEmptyWorkspaceInitializationPayload;\n\nexport function isSingleFolderWorkspaceInitializationPayload(obj: any): obj is ISingleFolderWorkspaceInitializationPayload {\n\treturn isSingleFolderWorkspaceIdentifier((obj.folder as ISingleFolderWorkspaceIdentifier));\n}\n\nconst WORKSPACE_SUFFIX = '.' + WORKSPACE_EXTENSION;\n\nexport function hasWorkspaceFileExtension(path: string) {\n\treturn extname(path) === WORKSPACE_SUFFIX;\n}\n\nconst SLASH = '/';\n\n/**\n * Given a folder URI and the workspace config folder, computes the IStoredWorkspaceFolder using\n* a relative or absolute path or a uri.\n * Undefined is returned if the folderURI and the targetConfigFolderURI don't have the same schema or authority\n *\n * @param folderURI a workspace folder\n * @param folderName a workspace name\n * @param targetConfigFolderURI the folder where the workspace is living in\n * @param useSlashForPath if set, use forward slashes for file paths on windows\n */\nexport function getStoredWorkspaceFolder(folderURI: URI, folderName: string | undefined, targetConfigFolderURI: URI, useSlashForPath = !isWindows): IStoredWorkspaceFolder {\n\n\tif (folderURI.scheme !== targetConfigFolderURI.scheme) {\n\t\treturn { name: folderName, uri: folderURI.toString(true) };\n\t}\n\n\tlet folderPath: string | undefined;\n\tif (isEqualOrParent(folderURI, targetConfigFolderURI)) {\n\t\t// use relative path\n\t\tfolderPath = relativePath(targetConfigFolderURI, folderURI) || '.'; // always uses forward slashes\n\t\tif (isWindows && folderURI.scheme === Schemas.file && !useSlashForPath) {\n\t\t\t// Windows gets special treatment:\n\t\t\t// - use backslahes unless slash is used by other existing folders\n\t\t\tfolderPath = folderPath.replace(/\\//g, '\\\\');\n\t\t}\n\t} else {\n\t\t// use absolute path\n\t\tif (folderURI.scheme === Schemas.file) {\n\t\t\tfolderPath = folderURI.fsPath;\n\t\t\tif (isWindows) {\n\t\t\t\t// Windows gets special treatment:\n\t\t\t\t// - normalize all paths to get nice casing of drive letters\n\t\t\t\t// - use backslahes unless slash is used by other existing folders\n\t\t\t\tfolderPath = normalizeDriveLetter(folderPath);\n\t\t\t\tif (useSlashForPath) {\n\t\t\t\t\tfolderPath = toSlashes(folderPath);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!isEqualAuthority(folderURI.authority, targetConfigFolderURI.authority)) {\n\t\t\t\treturn { name: folderName, uri: folderURI.toString(true) };\n\t\t\t}\n\t\t\tfolderPath = folderURI.path;\n\t\t}\n\t}\n\treturn { name: folderName, path: folderPath };\n}\n\n/**\n * Rewrites the content of a workspace file to be saved at a new location.\n * Throws an exception if file is not a valid workspace file\n */\nexport function rewriteWorkspaceFileForNewLocation(rawWorkspaceContents: string, configPathURI: URI, targetConfigPathURI: URI) {\n\tlet storedWorkspace = doParseStoredWorkspace(configPathURI, rawWorkspaceContents);\n\n\tconst sourceConfigFolder = dirname(configPathURI);\n\tconst targetConfigFolder = dirname(targetConfigPathURI);\n\n\tconst rewrittenFolders: IStoredWorkspaceFolder[] = [];\n\tconst slashForPath = useSlashForPath(storedWorkspace.folders);\n\n\t// Rewrite absolute paths to relative paths if the target workspace folder\n\t// is a parent of the location of the workspace file itself. Otherwise keep\n\t// using absolute paths.\n\tfor (const folder of storedWorkspace.folders) {\n\t\tlet folderURI = isRawFileWorkspaceFolder(folder) ? resolvePath(sourceConfigFolder, folder.path) : URI.parse(folder.uri);\n\t\trewrittenFolders.push(getStoredWorkspaceFolder(folderURI, folder.name, targetConfigFolder, slashForPath));\n\t}\n\n\t// Preserve as much of the existing workspace as possible by using jsonEdit\n\t// and only changing the folders portion.\n\tlet newRawWorkspaceContents = rawWorkspaceContents;\n\tconst edits = jsonEdit.setProperty(rawWorkspaceContents, ['folders'], rewrittenFolders, { insertSpaces: false, tabSize: 4, eol: (isLinux || isMacintosh) ? '\\n' : '\\r\\n' });\n\tedits.forEach(edit => {\n\t\tnewRawWorkspaceContents = jsonEdit.applyEdit(rawWorkspaceContents, edit);\n\t});\n\treturn newRawWorkspaceContents;\n}\n\nfunction doParseStoredWorkspace(path: URI, contents: string): IStoredWorkspace {\n\n\t// Parse workspace file\n\tlet storedWorkspace: IStoredWorkspace = json.parse(contents); // use fault tolerant parser\n\n\t// Filter out folders which do not have a path or uri set\n\tif (Array.isArray(storedWorkspace.folders)) {\n\t\tstoredWorkspace.folders = storedWorkspace.folders.filter(folder => isStoredWorkspaceFolder(folder));\n\t}\n\n\t// Validate\n\tif (!Array.isArray(storedWorkspace.folders)) {\n\t\tthrow new Error(`${path} looks like an invalid workspace file.`);\n\t}\n\n\treturn storedWorkspace;\n}\n\nexport function useSlashForPath(storedFolders: IStoredWorkspaceFolder[]): boolean {\n\tif (isWindows) {\n\t\tfor (const folder of storedFolders) {\n\t\t\tif (isRawFileWorkspaceFolder(folder) && folder.path.indexOf(SLASH) >= 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}"]}]}