{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/markers/common/markerService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/markers/common/markerService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/arrays\", \"vs/base/common/network\", \"vs/base/common/types\", \"vs/base/common/event\", \"./markers\"], function (require, exports, arrays_1, network_1, types_1, event_1, markers_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var MapMap;\n    (function (MapMap) {\n        function get(map, key1, key2) {\n            if (map[key1]) {\n                return map[key1][key2];\n            }\n            return undefined;\n        }\n        MapMap.get = get;\n        function set(map, key1, key2, value) {\n            if (!map[key1]) {\n                map[key1] = Object.create(null);\n            }\n            map[key1][key2] = value;\n        }\n        MapMap.set = set;\n        function remove(map, key1, key2) {\n            if (map[key1] && map[key1][key2]) {\n                delete map[key1][key2];\n                if (types_1.isEmptyObject(map[key1])) {\n                    delete map[key1];\n                }\n                return true;\n            }\n            return false;\n        }\n        MapMap.remove = remove;\n    })(MapMap || (MapMap = {}));\n    class MarkerStats {\n        constructor(service) {\n            this.errors = 0;\n            this.infos = 0;\n            this.warnings = 0;\n            this.unknowns = 0;\n            this._data = Object.create(null);\n            this._service = service;\n            this._subscription = service.onMarkerChanged(this._update, this);\n        }\n        dispose() {\n            this._subscription.dispose();\n            this._data = undefined;\n        }\n        _update(resources) {\n            if (!this._data) {\n                return;\n            }\n            for (const resource of resources) {\n                const key = resource.toString();\n                const oldStats = this._data[key];\n                if (oldStats) {\n                    this._substract(oldStats);\n                }\n                const newStats = this._resourceStats(resource);\n                this._add(newStats);\n                this._data[key] = newStats;\n            }\n        }\n        _resourceStats(resource) {\n            const result = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };\n            // TODO this is a hack\n            if (resource.scheme === network_1.Schemas.inMemory || resource.scheme === network_1.Schemas.walkThrough || resource.scheme === network_1.Schemas.walkThroughSnippet) {\n                return result;\n            }\n            for (const { severity } of this._service.read({ resource })) {\n                if (severity === markers_1.MarkerSeverity.Error) {\n                    result.errors += 1;\n                }\n                else if (severity === markers_1.MarkerSeverity.Warning) {\n                    result.warnings += 1;\n                }\n                else if (severity === markers_1.MarkerSeverity.Info) {\n                    result.infos += 1;\n                }\n                else {\n                    result.unknowns += 1;\n                }\n            }\n            return result;\n        }\n        _substract(op) {\n            this.errors -= op.errors;\n            this.warnings -= op.warnings;\n            this.infos -= op.infos;\n            this.unknowns -= op.unknowns;\n        }\n        _add(op) {\n            this.errors += op.errors;\n            this.warnings += op.warnings;\n            this.infos += op.infos;\n            this.unknowns += op.unknowns;\n        }\n    }\n    class MarkerService {\n        constructor() {\n            this._onMarkerChanged = new event_1.Emitter();\n            this._onMarkerChangedEvent = event_1.Event.debounce(this._onMarkerChanged.event, MarkerService._debouncer, 0);\n            this._byResource = Object.create(null);\n            this._byOwner = Object.create(null);\n            this._stats = new MarkerStats(this);\n        }\n        dispose() {\n            this._stats.dispose();\n        }\n        get onMarkerChanged() {\n            return this._onMarkerChangedEvent;\n        }\n        getStatistics() {\n            return this._stats;\n        }\n        remove(owner, resources) {\n            for (const resource of resources || []) {\n                this.changeOne(owner, resource, []);\n            }\n        }\n        changeOne(owner, resource, markerData) {\n            if (arrays_1.isFalsyOrEmpty(markerData)) {\n                // remove marker for this (owner,resource)-tuple\n                const a = MapMap.remove(this._byResource, resource.toString(), owner);\n                const b = MapMap.remove(this._byOwner, owner, resource.toString());\n                if (a !== b) {\n                    throw new Error('invalid marker service state');\n                }\n                if (a && b) {\n                    this._onMarkerChanged.fire([resource]);\n                }\n            }\n            else {\n                // insert marker for this (owner,resource)-tuple\n                const markers = [];\n                for (const data of markerData) {\n                    const marker = MarkerService._toMarker(owner, resource, data);\n                    if (marker) {\n                        markers.push(marker);\n                    }\n                }\n                MapMap.set(this._byResource, resource.toString(), owner, markers);\n                MapMap.set(this._byOwner, owner, resource.toString(), markers);\n                this._onMarkerChanged.fire([resource]);\n            }\n        }\n        static _toMarker(owner, resource, data) {\n            let { code, severity, message, source, startLineNumber, startColumn, endLineNumber, endColumn, relatedInformation, tags, } = data;\n            if (!message) {\n                return undefined;\n            }\n            // santize data\n            startLineNumber = startLineNumber > 0 ? startLineNumber : 1;\n            startColumn = startColumn > 0 ? startColumn : 1;\n            endLineNumber = endLineNumber >= startLineNumber ? endLineNumber : startLineNumber;\n            endColumn = endColumn > 0 ? endColumn : startColumn;\n            return {\n                resource,\n                owner,\n                code,\n                severity,\n                message,\n                source,\n                startLineNumber,\n                startColumn,\n                endLineNumber,\n                endColumn,\n                relatedInformation,\n                tags,\n            };\n        }\n        changeAll(owner, data) {\n            const changes = [];\n            const map = this._byOwner[owner];\n            // remove old marker\n            if (map) {\n                delete this._byOwner[owner];\n                for (const resource in map) {\n                    const entry = MapMap.get(this._byResource, resource, owner);\n                    if (entry) {\n                        // remeber what we remove\n                        const [first] = entry;\n                        if (first) {\n                            changes.push(first.resource);\n                        }\n                        // actual remove\n                        MapMap.remove(this._byResource, resource, owner);\n                    }\n                }\n            }\n            // add new markers\n            if (arrays_1.isNonEmptyArray(data)) {\n                // group by resource\n                const groups = Object.create(null);\n                for (const { resource, marker: markerData } of data) {\n                    const marker = MarkerService._toMarker(owner, resource, markerData);\n                    if (!marker) {\n                        // filter bad markers\n                        continue;\n                    }\n                    const array = groups[resource.toString()];\n                    if (!array) {\n                        groups[resource.toString()] = [marker];\n                        changes.push(resource);\n                    }\n                    else {\n                        array.push(marker);\n                    }\n                }\n                // insert all\n                for (const resource in groups) {\n                    MapMap.set(this._byResource, resource, owner, groups[resource]);\n                    MapMap.set(this._byOwner, owner, resource, groups[resource]);\n                }\n            }\n            if (changes.length > 0) {\n                this._onMarkerChanged.fire(changes);\n            }\n        }\n        read(filter = Object.create(null)) {\n            let { owner, resource, severities, take } = filter;\n            if (!take || take < 0) {\n                take = -1;\n            }\n            if (owner && resource) {\n                // exactly one owner AND resource\n                const data = MapMap.get(this._byResource, resource.toString(), owner);\n                if (!data) {\n                    return [];\n                }\n                else {\n                    const result = [];\n                    for (const marker of data) {\n                        if (MarkerService._accept(marker, severities)) {\n                            const newLen = result.push(marker);\n                            if (take > 0 && newLen === take) {\n                                break;\n                            }\n                        }\n                    }\n                    return result;\n                }\n            }\n            else if (!owner && !resource) {\n                // all\n                const result = [];\n                for (const key1 in this._byResource) {\n                    for (const key2 in this._byResource[key1]) {\n                        for (const data of this._byResource[key1][key2]) {\n                            if (MarkerService._accept(data, severities)) {\n                                const newLen = result.push(data);\n                                if (take > 0 && newLen === take) {\n                                    return result;\n                                }\n                            }\n                        }\n                    }\n                }\n                return result;\n            }\n            else {\n                // of one resource OR owner\n                const map = owner\n                    ? this._byOwner[owner]\n                    : resource ? this._byResource[resource.toString()] : undefined;\n                if (!map) {\n                    return [];\n                }\n                const result = [];\n                for (const key in map) {\n                    for (const data of map[key]) {\n                        if (MarkerService._accept(data, severities)) {\n                            const newLen = result.push(data);\n                            if (take > 0 && newLen === take) {\n                                return result;\n                            }\n                        }\n                    }\n                }\n                return result;\n            }\n        }\n        static _accept(marker, severities) {\n            return severities === undefined || (severities & marker.severity) === marker.severity;\n        }\n        static _debouncer(last, event) {\n            if (!last) {\n                MarkerService._dedupeMap = Object.create(null);\n                last = [];\n            }\n            for (const uri of event) {\n                if (MarkerService._dedupeMap[uri.toString()] === undefined) {\n                    MarkerService._dedupeMap[uri.toString()] = true;\n                    last.push(uri);\n                }\n            }\n            return last;\n        }\n    }\n    exports.MarkerService = MarkerService;\n});\n",null]}