{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/parts/tree/browser/tree.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/parts/tree/browser/tree.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar ContextMenuEvent = /** @class */ (function () {\n    function ContextMenuEvent(posx, posy, target) {\n        this._posx = posx;\n        this._posy = posy;\n        this._target = target;\n    }\n    ContextMenuEvent.prototype.preventDefault = function () {\n        // no-op\n    };\n    ContextMenuEvent.prototype.stopPropagation = function () {\n        // no-op\n    };\n    Object.defineProperty(ContextMenuEvent.prototype, \"posx\", {\n        get: function () {\n            return this._posx;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ContextMenuEvent.prototype, \"posy\", {\n        get: function () {\n            return this._posy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ContextMenuEvent.prototype, \"target\", {\n        get: function () {\n            return this._target;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return ContextMenuEvent;\n}());\nexports.ContextMenuEvent = ContextMenuEvent;\nvar MouseContextMenuEvent = /** @class */ (function (_super) {\n    tslib_1.__extends(MouseContextMenuEvent, _super);\n    function MouseContextMenuEvent(originalEvent) {\n        var _this = _super.call(this, originalEvent.posx, originalEvent.posy, originalEvent.target) || this;\n        _this.originalEvent = originalEvent;\n        return _this;\n    }\n    MouseContextMenuEvent.prototype.preventDefault = function () {\n        this.originalEvent.preventDefault();\n    };\n    MouseContextMenuEvent.prototype.stopPropagation = function () {\n        this.originalEvent.stopPropagation();\n    };\n    return MouseContextMenuEvent;\n}(ContextMenuEvent));\nexports.MouseContextMenuEvent = MouseContextMenuEvent;\nvar KeyboardContextMenuEvent = /** @class */ (function (_super) {\n    tslib_1.__extends(KeyboardContextMenuEvent, _super);\n    function KeyboardContextMenuEvent(posx, posy, originalEvent) {\n        var _this = _super.call(this, posx, posy, originalEvent.target) || this;\n        _this.originalEvent = originalEvent;\n        return _this;\n    }\n    KeyboardContextMenuEvent.prototype.preventDefault = function () {\n        this.originalEvent.preventDefault();\n    };\n    KeyboardContextMenuEvent.prototype.stopPropagation = function () {\n        this.originalEvent.stopPropagation();\n    };\n    return KeyboardContextMenuEvent;\n}(ContextMenuEvent));\nexports.KeyboardContextMenuEvent = KeyboardContextMenuEvent;\nvar DragOverEffect;\n(function (DragOverEffect) {\n    DragOverEffect[DragOverEffect[\"COPY\"] = 0] = \"COPY\";\n    DragOverEffect[DragOverEffect[\"MOVE\"] = 1] = \"MOVE\";\n})(DragOverEffect = exports.DragOverEffect || (exports.DragOverEffect = {}));\nvar DragOverBubble;\n(function (DragOverBubble) {\n    DragOverBubble[DragOverBubble[\"BUBBLE_DOWN\"] = 0] = \"BUBBLE_DOWN\";\n    DragOverBubble[DragOverBubble[\"BUBBLE_UP\"] = 1] = \"BUBBLE_UP\";\n})(DragOverBubble = exports.DragOverBubble || (exports.DragOverBubble = {}));\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/parts/tree/browser/tree.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/parts/tree/browser/tree.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;;AA+WhG;IAMC,0BAAY,IAAY,EAAE,IAAY,EAAE,MAAmB;QAC1D,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IACvB,CAAC;IAEM,yCAAc,GAArB;QACC,QAAQ;IACT,CAAC;IAEM,0CAAe,GAAtB;QACC,QAAQ;IACT,CAAC;IAED,sBAAW,kCAAI;aAAf;YACC,OAAO,IAAI,CAAC,KAAK,CAAC;QACnB,CAAC;;;OAAA;IAED,sBAAW,kCAAI;aAAf;YACC,OAAO,IAAI,CAAC,KAAK,CAAC;QACnB,CAAC;;;OAAA;IAED,sBAAW,oCAAM;aAAjB;YACC,OAAO,IAAI,CAAC,OAAO,CAAC;QACrB,CAAC;;;OAAA;IACF,uBAAC;AAAD,CAAC,AA/BD,IA+BC;AA/B2B,4CAAgB;AAiC5C;IAA2C,iDAAgB;IAI1D,+BAAY,aAAgC;QAA5C,YACC,kBAAM,aAAa,CAAC,IAAI,EAAE,aAAa,CAAC,IAAI,EAAE,aAAa,CAAC,MAAM,CAAC,SAEnE;QADA,KAAI,CAAC,aAAa,GAAG,aAAa,CAAC;;IACpC,CAAC;IAEM,8CAAc,GAArB;QACC,IAAI,CAAC,aAAa,CAAC,cAAc,EAAE,CAAC;IACrC,CAAC;IAEM,+CAAe,GAAtB;QACC,IAAI,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC;IACtC,CAAC;IACF,4BAAC;AAAD,CAAC,AAhBD,CAA2C,gBAAgB,GAgB1D;AAhBY,sDAAqB;AAkBlC;IAA8C,oDAAgB;IAI7D,kCAAY,IAAY,EAAE,IAAY,EAAE,aAAsC;QAA9E,YACC,kBAAM,IAAI,EAAE,IAAI,EAAE,aAAa,CAAC,MAAM,CAAC,SAEvC;QADA,KAAI,CAAC,aAAa,GAAG,aAAa,CAAC;;IACpC,CAAC;IAEM,iDAAc,GAArB;QACC,IAAI,CAAC,aAAa,CAAC,cAAc,EAAE,CAAC;IACrC,CAAC;IAEM,kDAAe,GAAtB;QACC,IAAI,CAAC,aAAa,CAAC,eAAe,EAAE,CAAC;IACtC,CAAC;IACF,+BAAC;AAAD,CAAC,AAhBD,CAA8C,gBAAgB,GAgB7D;AAhBY,4DAAwB;AA6DrC,IAAkB,cAGjB;AAHD,WAAkB,cAAc;IAC/B,mDAAI,CAAA;IACJ,mDAAI,CAAA;AACL,CAAC,EAHiB,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAG/B;AAED,IAAkB,cAGjB;AAHD,WAAkB,cAAc;IAC/B,iEAAW,CAAA;IACX,6DAAS,CAAA;AACV,CAAC,EAHiB,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAG/B","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as Touch from 'vs/base/browser/touch';\nimport * as Mouse from 'vs/base/browser/mouseEvent';\nimport * as Keyboard from 'vs/base/browser/keyboardEvent';\nimport { INavigator } from 'vs/base/common/iterator';\nimport { ScrollbarVisibility } from 'vs/base/common/scrollable';\nimport { Event } from 'vs/base/common/event';\nimport { IAction } from 'vs/base/common/actions';\nimport { Color } from 'vs/base/common/color';\nimport { IItemCollapseEvent, IItemExpandEvent } from 'vs/base/parts/tree/browser/treeModel';\nimport { IDragAndDropData } from 'vs/base/browser/dnd';\n\nexport interface ITree {\n\n\tonDidFocus: Event<void>;\n\tonDidBlur: Event<void>;\n\tonDidChangeFocus: Event<IFocusEvent>;\n\tonDidChangeSelection: Event<ISelectionEvent>;\n\tonDidChangeHighlight: Event<IHighlightEvent>;\n\tonDidExpandItem: Event<IItemExpandEvent>;\n\tonDidCollapseItem: Event<IItemCollapseEvent>;\n\tonDidDispose: Event<void>;\n\tonDidScroll: Event<void>;\n\n\t/**\n\t * Returns the tree's DOM element.\n\t */\n\tgetHTMLElement(): HTMLElement;\n\n\t/**\n\t * Lays out the tree.\n\t * Provide a specific height to save an (expensive) height computation.\n\t */\n\tlayout(height?: number): void;\n\n\t/**\n\t * Notifies the tree that is has become visible.\n\t */\n\tonVisible(): void;\n\n\t/**\n\t * Notifies the tree that is has become hidden.\n\t */\n\tonHidden(): void;\n\n\t/**\n\t * Sets the input of the tree.\n\t */\n\tsetInput(element: any): Promise<any>;\n\n\t/**\n\t * Returns the tree's input.\n\t */\n\tgetInput(): any;\n\n\t/**\n\t * Sets DOM focus on the tree.\n\t */\n\tdomFocus(): void;\n\n\t/**\n\t * Returns whether the tree has DOM focus.\n\t */\n\tisDOMFocused(): boolean;\n\n\t/**\n\t * Removes DOM focus from the tree.\n\t */\n\tdomBlur(): void;\n\n\t/**\n\t * Refreshes an element.\n\t * Provide no arguments and it will refresh the input element.\n\t */\n\trefresh(element?: any, recursive?: boolean): Promise<any>;\n\n\t/**\n\t * Expands an element.\n\t * The returned promise returns a boolean for whether the element was expanded or not.\n\t */\n\texpand(element: any): Promise<any>;\n\n\t/**\n\t * Expands several elements.\n\t * The returned promise returns a boolean array for whether the elements were expanded or not.\n\t */\n\texpandAll(elements?: any[]): Promise<any>;\n\n\t/**\n\t * Collapses an element.\n\t * The returned promise returns a boolean for whether the element was collapsed or not.\n\t */\n\tcollapse(element: any, recursive?: boolean): Promise<any>;\n\n\t/**\n\t * Collapses several elements.\n\t * Provide no arguments and it will recursively collapse all elements in the tree\n\t * The returned promise returns a boolean for whether the elements were collapsed or not.\n\t */\n\tcollapseAll(elements?: any[], recursive?: boolean): Promise<any>;\n\n\t/**\n\t * Toggles an element's expansion state.\n\t */\n\ttoggleExpansion(element: any, recursive?: boolean): Promise<any>;\n\n\t/**\n\t * Toggles several element's expansion state.\n\t */\n\ttoggleExpansionAll(elements: any[]): Promise<any>;\n\n\t/**\n\t * Returns whether an element is expanded or not.\n\t */\n\tisExpanded(element: any): boolean;\n\n\t/**\n\t * Returns a list of the currently expanded elements.\n\t */\n\tgetExpandedElements(): any[];\n\n\t/**\n\t * Reveals an element in the tree. The relativeTop is a value between 0 and 1. The closer to 0 the more the\n\t * element will scroll up to the top.\n\t */\n\treveal(element: any, relativeTop?: number): Promise<any>;\n\n\t/**\n\t * Returns the relative top position of any given element, if visible.\n\t * If not visible, returns a negative number or a number > 1.\n\t * Useful when calling `reveal(element, relativeTop)`.\n\t */\n\tgetRelativeTop(element: any): number;\n\n\t/**\n\t * Returns the top-most visible element.\n\t */\n\tgetFirstVisibleElement(): any;\n\n\t/**\n\t * Returns a number between 0 and 1 representing how much the tree is scroll down. 0 means all the way\n\t * to the top; 1 means all the way down.\n\t */\n\tgetScrollPosition(): number;\n\n\t/**\n\t * Sets the scroll position with a number between 0 and 1 representing how much the tree is scroll down. 0 means all the way\n\t * to the top; 1 means all the way down.\n\t */\n\tsetScrollPosition(pos: number): void;\n\n\t/**\n\t * Returns the total height of the tree's content.\n\t */\n\tgetContentHeight(): number;\n\n\t/**\n\t * Sets the tree's highlight to be the given element.\n\t * Provide no arguments and it clears the tree's highlight.\n\t */\n\tsetHighlight(element?: any, eventPayload?: any): void;\n\n\t/**\n\t * Returns the currently highlighted element.\n\t */\n\tgetHighlight(includeHidden?: boolean): any;\n\n\t/**\n\t * Clears the highlight.\n\t */\n\tclearHighlight(eventPayload?: any): void;\n\n\t/**\n\t * Replaces the current selection with the given elements.\n\t */\n\tsetSelection(elements: any[], eventPayload?: any): void;\n\n\t/**\n\t * Returns the currently selected elements.\n\t */\n\tgetSelection(includeHidden?: boolean): any[];\n\n\t/**\n\t * Clears the selection.\n\t */\n\tclearSelection(eventPayload?: any): void;\n\n\t/**\n\t * Sets the focused element.\n\t */\n\tsetFocus(element?: any, eventPayload?: any): void;\n\n\t/**\n\t * Returns focused element.\n\t */\n\tgetFocus(includeHidden?: boolean): any;\n\n\t/**\n\t * Focuses the next `count`-nth element, in visible order.\n\t */\n\tfocusNext(count?: number, eventPayload?: any): void;\n\n\t/**\n\t * Focuses the previous `count`-nth element, in visible order.\n\t */\n\tfocusPrevious(count?: number, eventPayload?: any): void;\n\n\t/**\n\t * Focuses the currently focused element's parent.\n\t */\n\tfocusParent(eventPayload?: any): void;\n\n\t/**\n\t * Focuses the first child of the currently focused element.\n\t */\n\tfocusFirstChild(eventPayload?: any): void;\n\n\t/**\n\t * Focuses the second element, in visible order. Will focus the first\n\t * child from the provided element's parent if any.\n\t */\n\tfocusFirst(eventPayload?: any, from?: any): void;\n\n\t/**\n\t * Focuses the nth element, in visible order.\n\t */\n\tfocusNth(index: number, eventPayload?: any): void;\n\n\t/**\n\t * Focuses the last element, in visible order. Will focus the last\n\t * child from the provided element's parent if any.\n\t */\n\tfocusLast(eventPayload?: any, from?: any): void;\n\n\t/**\n\t * Focuses the element at the end of the next page, in visible order.\n\t */\n\tfocusNextPage(eventPayload?: any): void;\n\n\t/**\n\t * Focuses the element at the beginning of the previous page, in visible order.\n\t */\n\tfocusPreviousPage(eventPayload?: any): void;\n\n\t/**\n\t * Clears the focus.\n\t */\n\tclearFocus(eventPayload?: any): void;\n\n\t/**\n\t * Returns a navigator which allows to discover the visible and\n\t * expanded elements in the tree.\n\t */\n\tgetNavigator(fromElement?: any, subTreeOnly?: boolean): INavigator<any>;\n\n\t/**\n\t * Apply styles to the tree.\n\t */\n\tstyle(styles: ITreeStyles): void;\n\n\t/**\n\t * Disposes the tree\n\t */\n\tdispose(): void;\n}\n\nexport interface IDataSource {\n\n\t/**\n\t * Returns the unique identifier of the given element.\n\t * No more than one element may use a given identifier.\n\t *\n\t * You should not attempt to \"move\" an element to a different\n\t * parent by keeping its ID. The idea here is to have tree location\n\t * related IDs (eg. full file path, in the Explorer example).\n\t */\n\tgetId(tree: ITree, element: any): string;\n\n\t/**\n\t * Returns a boolean value indicating whether the element has children.\n\t */\n\thasChildren(tree: ITree, element: any): boolean;\n\n\t/**\n\t * Returns the element's children as an array in a promise.\n\t */\n\tgetChildren(tree: ITree, element: any): Promise<any>;\n\n\t/**\n\t * Returns the element's parent in a promise.\n\t */\n\tgetParent(tree: ITree, element: any): Promise<any>;\n\n\t/**\n\t * Returns whether an element should be expanded when first added to the tree.\n\t */\n\tshouldAutoexpand?(tree: ITree, element: any): boolean;\n}\n\nexport interface IRenderer {\n\n\t/**\n\t * Returns the element's height in the tree, in pixels.\n\t */\n\tgetHeight(tree: ITree, element: any): number;\n\n\t/**\n\t * Returns a template ID for a given element. This will be used as an identifier\n\t * for the next 3 methods.\n\t */\n\tgetTemplateId(tree: ITree, element: any): string;\n\n\t/**\n\t * Renders the template in a DOM element. This method should render all the DOM\n\t * structure for an hypothetical element leaving its contents blank. It should\n\t * return an object bag which will be passed along to `renderElement` and used\n\t * to fill in those blanks.\n\t *\n\t * You should do all DOM creating and object allocation in this method. It\n\t * will be called only a few times.\n\t */\n\trenderTemplate(tree: ITree, templateId: string, container: HTMLElement): any;\n\n\t/**\n\t * Renders an element, given an object bag returned by `renderTemplate`.\n\t * This method should do as little as possible and ideally it should only fill\n\t * in the blanks left by `renderTemplate`.\n\t *\n\t * Try to make this method do as little possible, since it will be called very\n\t * often.\n\t */\n\trenderElement(tree: ITree, element: any, templateId: string, templateData: any): void;\n\n\t/**\n\t * Disposes a template that was once rendered.\n\t */\n\tdisposeTemplate(tree: ITree, templateId: string, templateData: any): void;\n}\n\nexport interface IAccessibilityProvider {\n\n\t/**\n\t * Given an element in the tree, return the ARIA label that should be associated with the\n\t * item. This helps screen readers to provide a meaningful label for the currently focused\n\t * tree element.\n\t *\n\t * Returning null will not disable ARIA for the element. Instead it is up to the screen reader\n\t * to compute a meaningful label based on the contents of the element in the DOM\n\t *\n\t * See also: https://www.w3.org/TR/wai-aria/states_and_properties#aria-label\n\t */\n\tgetAriaLabel(tree: ITree, element: any): string | null;\n\n\t/**\n\t * Given an element in the tree return its aria-posinset. Should be between 1 and aria-setsize\n\t * https://www.w3.org/TR/wai-aria/states_and_properties#aria-posinset\n\t */\n\tgetPosInSet?(tree: ITree, element: any): string;\n\n\t/**\n\t * Return the aria-setsize of the tree.\n\t * https://www.w3.org/TR/wai-aria/states_and_properties#aria-setsize\n\t */\n\tgetSetSize?(): string;\n}\n\nexport /* abstract */ class ContextMenuEvent {\n\n\tprivate _posx: number;\n\tprivate _posy: number;\n\tprivate _target: HTMLElement;\n\n\tconstructor(posx: number, posy: number, target: HTMLElement) {\n\t\tthis._posx = posx;\n\t\tthis._posy = posy;\n\t\tthis._target = target;\n\t}\n\n\tpublic preventDefault(): void {\n\t\t// no-op\n\t}\n\n\tpublic stopPropagation(): void {\n\t\t// no-op\n\t}\n\n\tpublic get posx(): number {\n\t\treturn this._posx;\n\t}\n\n\tpublic get posy(): number {\n\t\treturn this._posy;\n\t}\n\n\tpublic get target(): HTMLElement {\n\t\treturn this._target;\n\t}\n}\n\nexport class MouseContextMenuEvent extends ContextMenuEvent {\n\n\tprivate originalEvent: Mouse.IMouseEvent;\n\n\tconstructor(originalEvent: Mouse.IMouseEvent) {\n\t\tsuper(originalEvent.posx, originalEvent.posy, originalEvent.target);\n\t\tthis.originalEvent = originalEvent;\n\t}\n\n\tpublic preventDefault(): void {\n\t\tthis.originalEvent.preventDefault();\n\t}\n\n\tpublic stopPropagation(): void {\n\t\tthis.originalEvent.stopPropagation();\n\t}\n}\n\nexport class KeyboardContextMenuEvent extends ContextMenuEvent {\n\n\tprivate originalEvent: Keyboard.IKeyboardEvent;\n\n\tconstructor(posx: number, posy: number, originalEvent: Keyboard.IKeyboardEvent) {\n\t\tsuper(posx, posy, originalEvent.target);\n\t\tthis.originalEvent = originalEvent;\n\t}\n\n\tpublic preventDefault(): void {\n\t\tthis.originalEvent.preventDefault();\n\t}\n\n\tpublic stopPropagation(): void {\n\t\tthis.originalEvent.stopPropagation();\n\t}\n}\n\nexport interface IController {\n\n\t/**\n\t * Called when an element is clicked.\n\t */\n\tonClick(tree: ITree, element: any, event: Mouse.IMouseEvent): boolean;\n\n\t/**\n\t * Called when an element is requested for a context menu.\n\t */\n\tonContextMenu(tree: ITree, element: any, event: ContextMenuEvent): boolean;\n\n\t/**\n\t * Called when an element is tapped.\n\t */\n\tonTap(tree: ITree, element: any, event: Touch.GestureEvent): boolean;\n\n\t/**\n\t * Called when a key is pressed down while selecting elements.\n\t */\n\tonKeyDown(tree: ITree, event: Keyboard.IKeyboardEvent): boolean;\n\n\t/**\n\t * Called when a key is released while selecting elements.\n\t */\n\tonKeyUp(tree: ITree, event: Keyboard.IKeyboardEvent): boolean;\n\n\t/**\n\t * Called when a mouse middle button is pressed down on an element.\n\t */\n\tonMouseMiddleClick?(tree: ITree, element: any, event: Mouse.IMouseEvent): boolean;\n\n\t/**\n\t * Called when a mouse button is pressed down on an element.\n\t */\n\tonMouseDown?(tree: ITree, element: any, event: Mouse.IMouseEvent): boolean;\n\n\t/**\n\t * Called when a mouse button goes up on an element.\n\t */\n\tonMouseUp?(tree: ITree, element: any, event: Mouse.IMouseEvent): boolean;\n}\n\nexport const enum DragOverEffect {\n\tCOPY,\n\tMOVE\n}\n\nexport const enum DragOverBubble {\n\tBUBBLE_DOWN,\n\tBUBBLE_UP\n}\n\nexport interface IDragOverReaction {\n\taccept: boolean;\n\teffect?: DragOverEffect;\n\tbubble?: DragOverBubble;\n\tautoExpand?: boolean;\n}\n\nexport interface IDragAndDrop {\n\n\t/**\n\t * Returns a uri if the given element should be allowed to drag.\n\t * Returns null, otherwise.\n\t */\n\tgetDragURI(tree: ITree, element: any): string | null;\n\n\t/**\n\t * Returns a label to display when dragging the element.\n\t */\n\tgetDragLabel?(tree: ITree, elements: any[]): string;\n\n\t/**\n\t * Sent when the drag operation is starting.\n\t */\n\tonDragStart(tree: ITree, data: IDragAndDropData, originalEvent: Mouse.DragMouseEvent): void;\n\n\t/**\n\t * Returns a DragOverReaction indicating whether sources can be\n\t * dropped into target or some parent of the target.\n\t */\n\tonDragOver(tree: ITree, data: IDragAndDropData, targetElement: any, originalEvent: Mouse.DragMouseEvent): IDragOverReaction | null;\n\n\t/**\n\t * Handles the action of dropping sources into target.\n\t */\n\tdrop(tree: ITree, data: IDragAndDropData, targetElement: any, originalEvent: Mouse.DragMouseEvent): void;\n}\n\nexport interface IFilter {\n\n\t/**\n\t * Returns whether the given element should be visible.\n\t */\n\tisVisible(tree: ITree, element: any): boolean;\n}\n\nexport interface ISorter {\n\n\t/**\n\t * Compare two elements in the viewer to define the sorting order.\n\t */\n\tcompare(tree: ITree, element: any, otherElement: any): number;\n}\n\n// Events\n\nexport interface ISelectionEvent {\n\tselection: any[];\n\tpayload?: any;\n}\n\nexport interface IFocusEvent {\n\tfocus: any;\n\tpayload?: any;\n}\n\nexport interface IHighlightEvent {\n\thighlight: any;\n\tpayload?: any;\n}\n\n// Options\n\nexport interface ITreeConfiguration {\n\tdataSource: IDataSource;\n\trenderer?: IRenderer;\n\tcontroller?: IController;\n\tdnd?: IDragAndDrop;\n\tfilter?: IFilter;\n\tsorter?: ISorter;\n\taccessibilityProvider?: IAccessibilityProvider;\n\tstyler?: ITreeStyler;\n}\n\nexport interface ITreeOptions extends ITreeStyles {\n\ttwistiePixels?: number;\n\tshowTwistie?: boolean;\n\tindentPixels?: number;\n\tverticalScrollMode?: ScrollbarVisibility;\n\thorizontalScrollMode?: ScrollbarVisibility;\n\talwaysFocused?: boolean;\n\tautoExpandSingleChildren?: boolean;\n\tuseShadows?: boolean;\n\tpaddingOnRow?: boolean;\n\tariaLabel?: string;\n\tkeyboardSupport?: boolean;\n\tpreventRootFocus?: boolean;\n\tshowLoading?: boolean;\n}\n\nexport interface ITreeStyler {\n\tstyle(styles: ITreeStyles): void;\n}\n\nexport interface ITreeStyles {\n\tlistFocusBackground?: Color;\n\tlistFocusForeground?: Color;\n\tlistActiveSelectionBackground?: Color;\n\tlistActiveSelectionForeground?: Color;\n\tlistFocusAndSelectionBackground?: Color;\n\tlistFocusAndSelectionForeground?: Color;\n\tlistInactiveSelectionBackground?: Color;\n\tlistInactiveSelectionForeground?: Color;\n\tlistHoverBackground?: Color;\n\tlistHoverForeground?: Color;\n\tlistDropBackground?: Color;\n\tlistFocusOutline?: Color;\n}\n\nexport interface ITreeContext extends ITreeConfiguration {\n\ttree: ITree;\n\toptions: ITreeOptions;\n}\n\nexport interface IActionProvider {\n\n\t/**\n\t * Returns whether or not the element has actions. These show up in place right to the element in the tree.\n\t */\n\thasActions(tree: ITree | null, element: any): boolean;\n\n\t/**\n\t * Returns a promise of an array with the actions of the element that should show up in place right to the element in the tree.\n\t */\n\tgetActions(tree: ITree | null, element: any): IAction[] | null;\n}\n"]}]}