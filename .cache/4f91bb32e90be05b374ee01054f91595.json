{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/abstractDebugAdapter.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/abstractDebugAdapter.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar event_1 = require(\"vs/base/common/event\");\n/**\n * Abstract implementation of the low level API for a debug adapter.\n * Missing is how this API communicates with the debug adapter.\n */\nvar AbstractDebugAdapter = /** @class */ (function () {\n    function AbstractDebugAdapter() {\n        this.sequence = 1;\n        this.pendingRequests = new Map();\n        this._onError = new event_1.Emitter();\n        this._onExit = new event_1.Emitter();\n    }\n    Object.defineProperty(AbstractDebugAdapter.prototype, \"onError\", {\n        get: function () {\n            return this._onError.event;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AbstractDebugAdapter.prototype, \"onExit\", {\n        get: function () {\n            return this._onExit.event;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AbstractDebugAdapter.prototype.onMessage = function (callback) {\n        if (this.eventCallback) {\n            this._onError.fire(new Error(\"attempt to set more than one 'Message' callback\"));\n        }\n        this.messageCallback = callback;\n    };\n    AbstractDebugAdapter.prototype.onEvent = function (callback) {\n        if (this.eventCallback) {\n            this._onError.fire(new Error(\"attempt to set more than one 'Event' callback\"));\n        }\n        this.eventCallback = callback;\n    };\n    AbstractDebugAdapter.prototype.onRequest = function (callback) {\n        if (this.requestCallback) {\n            this._onError.fire(new Error(\"attempt to set more than one 'Request' callback\"));\n        }\n        this.requestCallback = callback;\n    };\n    AbstractDebugAdapter.prototype.sendResponse = function (response) {\n        if (response.seq > 0) {\n            this._onError.fire(new Error(\"attempt to send more than one response for command \" + response.command));\n        }\n        else {\n            this.internalSend('response', response);\n        }\n    };\n    AbstractDebugAdapter.prototype.sendRequest = function (command, args, clb, timeout) {\n        var _this = this;\n        var request = {\n            command: command\n        };\n        if (args && Object.keys(args).length > 0) {\n            request.arguments = args;\n        }\n        this.internalSend('request', request);\n        if (typeof timeout === 'number') {\n            var timer_1 = setTimeout(function () {\n                clearTimeout(timer_1);\n                var clb = _this.pendingRequests.get(request.seq);\n                if (clb) {\n                    _this.pendingRequests.delete(request.seq);\n                    var err = {\n                        type: 'response',\n                        seq: 0,\n                        request_seq: request.seq,\n                        success: false,\n                        command: command,\n                        message: \"timeout after \" + timeout + \" ms\"\n                    };\n                    clb(err);\n                }\n            }, timeout);\n        }\n        if (clb) {\n            // store callback for this request\n            this.pendingRequests.set(request.seq, clb);\n        }\n    };\n    AbstractDebugAdapter.prototype.acceptMessage = function (message) {\n        if (this.messageCallback) {\n            this.messageCallback(message);\n        }\n        else {\n            switch (message.type) {\n                case 'event':\n                    if (this.eventCallback) {\n                        this.eventCallback(message);\n                    }\n                    break;\n                case 'request':\n                    if (this.requestCallback) {\n                        this.requestCallback(message);\n                    }\n                    break;\n                case 'response':\n                    var response = message;\n                    var clb = this.pendingRequests.get(response.request_seq);\n                    if (clb) {\n                        this.pendingRequests.delete(response.request_seq);\n                        clb(response);\n                    }\n                    break;\n            }\n        }\n    };\n    AbstractDebugAdapter.prototype.internalSend = function (typ, message) {\n        message.type = typ;\n        message.seq = this.sequence++;\n        this.sendMessage(message);\n    };\n    AbstractDebugAdapter.prototype.cancelPending = function () {\n        var pending = this.pendingRequests;\n        this.pendingRequests = new Map();\n        setTimeout(function (_) {\n            pending.forEach(function (callback, request_seq) {\n                var err = {\n                    type: 'response',\n                    seq: 0,\n                    request_seq: request_seq,\n                    success: false,\n                    command: 'canceled',\n                    message: 'canceled'\n                };\n                callback(err);\n            });\n        }, 1000);\n    };\n    AbstractDebugAdapter.prototype.dispose = function () {\n        this.cancelPending();\n    };\n    return AbstractDebugAdapter;\n}());\nexports.AbstractDebugAdapter = AbstractDebugAdapter;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/abstractDebugAdapter.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/abstractDebugAdapter.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDebugAdapter } from 'vs/workbench/contrib/debug/common/debug';\n\n/**\n * Abstract implementation of the low level API for a debug adapter.\n * Missing is how this API communicates with the debug adapter.\n */\nexport abstract class AbstractDebugAdapter implements IDebugAdapter {\n\n\tprivate sequence: number;\n\tprivate pendingRequests: Map<number, (e: DebugProtocol.Response) => void>;\n\tprivate requestCallback: (request: DebugProtocol.Request) => void;\n\tprivate eventCallback: (request: DebugProtocol.Event) => void;\n\tprivate messageCallback: (message: DebugProtocol.ProtocolMessage) => void;\n\tprotected readonly _onError: Emitter<Error>;\n\tprotected readonly _onExit: Emitter<number | null>;\n\n\tconstructor() {\n\t\tthis.sequence = 1;\n\t\tthis.pendingRequests = new Map();\n\t\tthis._onError = new Emitter<Error>();\n\t\tthis._onExit = new Emitter<number>();\n\t}\n\n\tabstract startSession(): Promise<void>;\n\n\tabstract stopSession(): Promise<void>;\n\n\tabstract sendMessage(message: DebugProtocol.ProtocolMessage): void;\n\n\tget onError(): Event<Error> {\n\t\treturn this._onError.event;\n\t}\n\n\tget onExit(): Event<number | null> {\n\t\treturn this._onExit.event;\n\t}\n\n\tonMessage(callback: (message: DebugProtocol.ProtocolMessage) => void): void {\n\t\tif (this.eventCallback) {\n\t\t\tthis._onError.fire(new Error(`attempt to set more than one 'Message' callback`));\n\t\t}\n\t\tthis.messageCallback = callback;\n\t}\n\n\tonEvent(callback: (event: DebugProtocol.Event) => void): void {\n\t\tif (this.eventCallback) {\n\t\t\tthis._onError.fire(new Error(`attempt to set more than one 'Event' callback`));\n\t\t}\n\t\tthis.eventCallback = callback;\n\t}\n\n\tonRequest(callback: (request: DebugProtocol.Request) => void): void {\n\t\tif (this.requestCallback) {\n\t\t\tthis._onError.fire(new Error(`attempt to set more than one 'Request' callback`));\n\t\t}\n\t\tthis.requestCallback = callback;\n\t}\n\n\tsendResponse(response: DebugProtocol.Response): void {\n\t\tif (response.seq > 0) {\n\t\t\tthis._onError.fire(new Error(`attempt to send more than one response for command ${response.command}`));\n\t\t}\n\t\telse {\n\t\t\tthis.internalSend('response', response);\n\t\t}\n\t}\n\n\tsendRequest(command: string, args: any, clb: (result: DebugProtocol.Response) => void, timeout?: number): void {\n\t\tconst request: any = {\n\t\t\tcommand: command\n\t\t};\n\t\tif (args && Object.keys(args).length > 0) {\n\t\t\trequest.arguments = args;\n\t\t}\n\t\tthis.internalSend('request', request);\n\t\tif (typeof timeout === 'number') {\n\t\t\tconst timer = setTimeout(() => {\n\t\t\t\tclearTimeout(timer);\n\t\t\t\tconst clb = this.pendingRequests.get(request.seq);\n\t\t\t\tif (clb) {\n\t\t\t\t\tthis.pendingRequests.delete(request.seq);\n\t\t\t\t\tconst err: DebugProtocol.Response = {\n\t\t\t\t\t\ttype: 'response',\n\t\t\t\t\t\tseq: 0,\n\t\t\t\t\t\trequest_seq: request.seq,\n\t\t\t\t\t\tsuccess: false,\n\t\t\t\t\t\tcommand,\n\t\t\t\t\t\tmessage: `timeout after ${timeout} ms`\n\t\t\t\t\t};\n\t\t\t\t\tclb(err);\n\t\t\t\t}\n\t\t\t}, timeout);\n\t\t}\n\t\tif (clb) {\n\t\t\t// store callback for this request\n\t\t\tthis.pendingRequests.set(request.seq, clb);\n\t\t}\n\t}\n\n\tacceptMessage(message: DebugProtocol.ProtocolMessage): void {\n\t\tif (this.messageCallback) {\n\t\t\tthis.messageCallback(message);\n\t\t}\n\t\telse {\n\t\t\tswitch (message.type) {\n\t\t\t\tcase 'event':\n\t\t\t\t\tif (this.eventCallback) {\n\t\t\t\t\t\tthis.eventCallback(<DebugProtocol.Event>message);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'request':\n\t\t\t\t\tif (this.requestCallback) {\n\t\t\t\t\t\tthis.requestCallback(<DebugProtocol.Request>message);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'response':\n\t\t\t\t\tconst response = <DebugProtocol.Response>message;\n\t\t\t\t\tconst clb = this.pendingRequests.get(response.request_seq);\n\t\t\t\t\tif (clb) {\n\t\t\t\t\t\tthis.pendingRequests.delete(response.request_seq);\n\t\t\t\t\t\tclb(response);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate internalSend(typ: 'request' | 'response' | 'event', message: DebugProtocol.ProtocolMessage): void {\n\t\tmessage.type = typ;\n\t\tmessage.seq = this.sequence++;\n\t\tthis.sendMessage(message);\n\t}\n\n\tprotected cancelPending() {\n\t\tconst pending = this.pendingRequests;\n\t\tthis.pendingRequests = new Map();\n\t\tsetTimeout(_ => {\n\t\t\tpending.forEach((callback, request_seq) => {\n\t\t\t\tconst err: DebugProtocol.Response = {\n\t\t\t\t\ttype: 'response',\n\t\t\t\t\tseq: 0,\n\t\t\t\t\trequest_seq,\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tcommand: 'canceled',\n\t\t\t\t\tmessage: 'canceled'\n\t\t\t\t};\n\t\t\t\tcallback(err);\n\t\t\t});\n\t\t}, 1000);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancelPending();\n\t}\n}\n"]}]}