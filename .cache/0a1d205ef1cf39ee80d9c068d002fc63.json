{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/node/debugAdapter.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/node/debugAdapter.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/node/pfs\", \"child_process\", \"vs/nls\", \"net\", \"vs/base/common/path\", \"vs/base/common/strings\", \"vs/base/common/objects\", \"vs/base/common/platform\", \"vs/platform/extensionManagement/common/extensionManagement\", \"../common/abstractDebugAdapter\"], function (require, exports, pfs_1, cp, nls, net, path, strings, objects, platform, extensionManagement_1, abstractDebugAdapter_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * An implementation that communicates via two streams with the debug adapter.\n     */\n    class StreamDebugAdapter extends abstractDebugAdapter_1.AbstractDebugAdapter {\n        constructor() {\n            super();\n        }\n        connect(readable, writable) {\n            this.outputStream = writable;\n            this.rawData = Buffer.allocUnsafe(0);\n            this.contentLength = -1;\n            readable.on('data', (data) => this.handleData(data));\n        }\n        sendMessage(message) {\n            if (this.outputStream) {\n                const json = JSON.stringify(message);\n                this.outputStream.write(`Content-Length: ${Buffer.byteLength(json, 'utf8')}${StreamDebugAdapter.TWO_CRLF}${json}`, 'utf8');\n            }\n        }\n        handleData(data) {\n            this.rawData = Buffer.concat([this.rawData, data]);\n            while (true) {\n                if (this.contentLength >= 0) {\n                    if (this.rawData.length >= this.contentLength) {\n                        const message = this.rawData.toString('utf8', 0, this.contentLength);\n                        this.rawData = this.rawData.slice(this.contentLength);\n                        this.contentLength = -1;\n                        if (message.length > 0) {\n                            try {\n                                this.acceptMessage(JSON.parse(message));\n                            }\n                            catch (e) {\n                                this._onError.fire(new Error((e.message || e) + '\\n' + message));\n                            }\n                        }\n                        continue; // there may be more complete messages to process\n                    }\n                }\n                else {\n                    const idx = this.rawData.indexOf(StreamDebugAdapter.TWO_CRLF);\n                    if (idx !== -1) {\n                        const header = this.rawData.toString('utf8', 0, idx);\n                        const lines = header.split(StreamDebugAdapter.HEADER_LINESEPARATOR);\n                        for (const h of lines) {\n                            const kvPair = h.split(StreamDebugAdapter.HEADER_FIELDSEPARATOR);\n                            if (kvPair[0] === 'Content-Length') {\n                                this.contentLength = Number(kvPair[1]);\n                            }\n                        }\n                        this.rawData = this.rawData.slice(idx + StreamDebugAdapter.TWO_CRLF.length);\n                        continue;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    StreamDebugAdapter.TWO_CRLF = '\\r\\n\\r\\n';\n    StreamDebugAdapter.HEADER_LINESEPARATOR = /\\r?\\n/; // allow for non-RFC 2822 conforming line separators\n    StreamDebugAdapter.HEADER_FIELDSEPARATOR = /: */;\n    exports.StreamDebugAdapter = StreamDebugAdapter;\n    /**\n     * An implementation that connects to a debug adapter via a socket.\n    */\n    class SocketDebugAdapter extends StreamDebugAdapter {\n        constructor(adapterServer) {\n            super();\n            this.adapterServer = adapterServer;\n        }\n        startSession() {\n            return new Promise((resolve, reject) => {\n                let connected = false;\n                this.socket = net.createConnection(this.adapterServer.port, this.adapterServer.host || '127.0.0.1', () => {\n                    this.connect(this.socket, this.socket);\n                    resolve();\n                    connected = true;\n                });\n                this.socket.on('close', () => {\n                    if (connected) {\n                        this._onError.fire(new Error('connection closed'));\n                    }\n                    else {\n                        reject(new Error('connection closed'));\n                    }\n                });\n                this.socket.on('error', error => {\n                    if (connected) {\n                        this._onError.fire(error);\n                    }\n                    else {\n                        reject(error);\n                    }\n                });\n            });\n        }\n        stopSession() {\n            // Cancel all sent promises on disconnect so debug trees are not left in a broken state #3666.\n            this.cancelPending();\n            if (this.socket) {\n                this.socket.end();\n                this.socket = undefined;\n            }\n            return Promise.resolve(undefined);\n        }\n    }\n    exports.SocketDebugAdapter = SocketDebugAdapter;\n    /**\n     * An implementation that launches the debug adapter as a separate process and communicates via stdin/stdout.\n    */\n    class ExecutableDebugAdapter extends StreamDebugAdapter {\n        constructor(adapterExecutable, debugType, outputService) {\n            super();\n            this.adapterExecutable = adapterExecutable;\n            this.debugType = debugType;\n            this.outputService = outputService;\n        }\n        startSession() {\n            return __awaiter(this, void 0, void 0, function* () {\n                const command = this.adapterExecutable.command;\n                const args = this.adapterExecutable.args;\n                const options = this.adapterExecutable.options || {};\n                try {\n                    // verify executables asynchronously\n                    if (command) {\n                        if (path.isAbsolute(command)) {\n                            const commandExists = yield pfs_1.exists(command);\n                            if (!commandExists) {\n                                throw new Error(nls.localize('debugAdapterBinNotFound', \"Debug adapter executable '{0}' does not exist.\", command));\n                            }\n                        }\n                        else {\n                            // relative path\n                            if (command.indexOf('/') < 0 && command.indexOf('\\\\') < 0) {\n                                // no separators: command looks like a runtime name like 'node' or 'mono'\n                                // TODO: check that the runtime is available on PATH\n                            }\n                        }\n                    }\n                    else {\n                        throw new Error(nls.localize({ key: 'debugAdapterCannotDetermineExecutable', comment: ['Adapter executable file not found'] }, \"Cannot determine executable for debug adapter '{0}'.\", this.debugType));\n                    }\n                    let env = objects.mixin({}, process.env);\n                    if (options.env) {\n                        env = objects.mixin(env, options.env);\n                    }\n                    delete env.VSCODE_PREVENT_FOREIGN_INSPECT;\n                    if (command === 'node') {\n                        if (Array.isArray(args) && args.length > 0) {\n                            const isElectron = !!process.env['ELECTRON_RUN_AS_NODE'] || !!process.versions['electron'];\n                            const forkOptions = {\n                                env: env,\n                                execArgv: isElectron ? ['-e', 'delete process.env.ELECTRON_RUN_AS_NODE;require(process.argv[1])'] : [],\n                                silent: true\n                            };\n                            if (options.cwd) {\n                                forkOptions.cwd = options.cwd;\n                            }\n                            const child = cp.fork(args[0], args.slice(1), forkOptions);\n                            if (!child.pid) {\n                                throw new Error(nls.localize('unableToLaunchDebugAdapter', \"Unable to launch debug adapter from '{0}'.\", args[0]));\n                            }\n                            this.serverProcess = child;\n                        }\n                        else {\n                            throw new Error(nls.localize('unableToLaunchDebugAdapterNoArgs', \"Unable to launch debug adapter.\"));\n                        }\n                    }\n                    else {\n                        const spawnOptions = {\n                            env: env\n                        };\n                        if (options.cwd) {\n                            spawnOptions.cwd = options.cwd;\n                        }\n                        this.serverProcess = cp.spawn(command, args, spawnOptions);\n                    }\n                    this.serverProcess.on('error', err => {\n                        this._onError.fire(err);\n                    });\n                    this.serverProcess.on('exit', (code, signal) => {\n                        this._onExit.fire(code);\n                    });\n                    this.serverProcess.stdout.on('close', () => {\n                        this._onError.fire(new Error('read error'));\n                    });\n                    this.serverProcess.stdout.on('error', error => {\n                        this._onError.fire(error);\n                    });\n                    this.serverProcess.stdin.on('error', error => {\n                        this._onError.fire(error);\n                    });\n                    const outputService = this.outputService;\n                    if (outputService) {\n                        const sanitize = (s) => s.toString().replace(/\\r?\\n$/mg, '');\n                        // this.serverProcess.stdout.on('data', (data: string) => {\n                        // \tconsole.log('%c' + sanitize(data), 'background: #ddd; font-style: italic;');\n                        // });\n                        this.serverProcess.stderr.on('data', (data) => {\n                            const channel = outputService.getChannel(extensionManagement_1.ExtensionsChannelId);\n                            if (channel) {\n                                channel.append(sanitize(data));\n                            }\n                        });\n                    }\n                    // finally connect to the DA\n                    this.connect(this.serverProcess.stdout, this.serverProcess.stdin);\n                }\n                catch (err) {\n                    this._onError.fire(err);\n                }\n            });\n        }\n        stopSession() {\n            // Cancel all sent promises on disconnect so debug trees are not left in a broken state #3666.\n            this.cancelPending();\n            if (!this.serverProcess) {\n                return Promise.resolve(undefined);\n            }\n            // when killing a process in windows its child\n            // processes are *not* killed but become root\n            // processes. Therefore we use TASKKILL.EXE\n            if (platform.isWindows) {\n                return new Promise((c, e) => {\n                    const killer = cp.exec(`taskkill /F /T /PID ${this.serverProcess.pid}`, function (err, stdout, stderr) {\n                        if (err) {\n                            return e(err);\n                        }\n                    });\n                    killer.on('exit', c);\n                    killer.on('error', e);\n                });\n            }\n            else {\n                this.serverProcess.kill('SIGTERM');\n                return Promise.resolve(undefined);\n            }\n        }\n        static extract(platformContribution, extensionFolderPath) {\n            if (!platformContribution) {\n                return undefined;\n            }\n            const result = Object.create(null);\n            if (platformContribution.runtime) {\n                if (platformContribution.runtime.indexOf('./') === 0) { // TODO\n                    result.runtime = path.join(extensionFolderPath, platformContribution.runtime);\n                }\n                else {\n                    result.runtime = platformContribution.runtime;\n                }\n            }\n            if (platformContribution.runtimeArgs) {\n                result.runtimeArgs = platformContribution.runtimeArgs;\n            }\n            if (platformContribution.program) {\n                if (!path.isAbsolute(platformContribution.program)) {\n                    result.program = path.join(extensionFolderPath, platformContribution.program);\n                }\n                else {\n                    result.program = platformContribution.program;\n                }\n            }\n            if (platformContribution.args) {\n                result.args = platformContribution.args;\n            }\n            const contribution = platformContribution;\n            if (contribution.win) {\n                result.win = ExecutableDebugAdapter.extract(contribution.win, extensionFolderPath);\n            }\n            if (contribution.winx86) {\n                result.winx86 = ExecutableDebugAdapter.extract(contribution.winx86, extensionFolderPath);\n            }\n            if (contribution.windows) {\n                result.windows = ExecutableDebugAdapter.extract(contribution.windows, extensionFolderPath);\n            }\n            if (contribution.osx) {\n                result.osx = ExecutableDebugAdapter.extract(contribution.osx, extensionFolderPath);\n            }\n            if (contribution.linux) {\n                result.linux = ExecutableDebugAdapter.extract(contribution.linux, extensionFolderPath);\n            }\n            return result;\n        }\n        static platformAdapterExecutable(extensionDescriptions, debugType) {\n            let result = Object.create(null);\n            debugType = debugType.toLowerCase();\n            // merge all contributions into one\n            for (const ed of extensionDescriptions) {\n                if (ed.contributes) {\n                    const debuggers = ed.contributes['debuggers'];\n                    if (debuggers && debuggers.length > 0) {\n                        debuggers.filter(dbg => typeof dbg.type === 'string' && strings.equalsIgnoreCase(dbg.type, debugType)).forEach(dbg => {\n                            // extract relevant attributes and make them absolute where needed\n                            const extractedDbg = ExecutableDebugAdapter.extract(dbg, ed.extensionLocation.fsPath);\n                            // merge\n                            result = objects.mixin(result, extractedDbg, ed.isBuiltin);\n                        });\n                    }\n                }\n            }\n            // select the right platform\n            let platformInfo;\n            if (platform.isWindows && !process.env.hasOwnProperty('PROCESSOR_ARCHITEW6432')) {\n                platformInfo = result.winx86 || result.win || result.windows;\n            }\n            else if (platform.isWindows) {\n                platformInfo = result.win || result.windows;\n            }\n            else if (platform.isMacintosh) {\n                platformInfo = result.osx;\n            }\n            else if (platform.isLinux) {\n                platformInfo = result.linux;\n            }\n            platformInfo = platformInfo || result;\n            // these are the relevant attributes\n            let program = platformInfo.program || result.program;\n            const args = platformInfo.args || result.args;\n            let runtime = platformInfo.runtime || result.runtime;\n            const runtimeArgs = platformInfo.runtimeArgs || result.runtimeArgs;\n            if (runtime) {\n                return {\n                    type: 'executable',\n                    command: runtime,\n                    args: (runtimeArgs || []).concat(typeof program === 'string' ? [program] : []).concat(args || [])\n                };\n            }\n            else if (program) {\n                return {\n                    type: 'executable',\n                    command: program,\n                    args: args || []\n                };\n            }\n            // nothing found\n            return undefined;\n        }\n    }\n    exports.ExecutableDebugAdapter = ExecutableDebugAdapter;\n});\n",null]}