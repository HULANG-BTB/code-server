{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/extensions/electron-browser/extensionsAutoProfiler.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/extensions/electron-browser/extensionsAutoProfiler.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/workbench/services/extensions/common/extensions\", \"vs/platform/telemetry/common/telemetry\", \"vs/base/common/lifecycle\", \"vs/platform/log/common/log\", \"vs/base/common/cancellation\", \"vs/base/common/errors\", \"os\", \"vs/base/common/path\", \"vs/base/node/pfs\", \"vs/workbench/contrib/extensions/electron-browser/runtimeExtensionsEditor\", \"vs/platform/notification/common/notification\", \"vs/nls\", \"vs/workbench/services/editor/common/editorService\", \"vs/workbench/contrib/extensions/electron-browser/runtimeExtensionsInput\", \"vs/base/common/uuid\", \"vs/workbench/contrib/extensions/common/extensions\", \"vs/platform/extensions/common/extensions\"], function (require, exports, extensions_1, telemetry_1, lifecycle_1, log_1, cancellation_1, errors_1, os_1, path_1, pfs_1, runtimeExtensionsEditor_1, notification_1, nls_1, editorService_1, runtimeExtensionsInput_1, uuid_1, extensions_2, extensions_3) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let ExtensionsAutoProfiler = class ExtensionsAutoProfiler extends lifecycle_1.Disposable {\n        constructor(_extensionService, _extensionProfileService, _anotherExtensionService, _telemetryService, _logService, _notificationService, _editorService) {\n            super();\n            this._extensionService = _extensionService;\n            this._extensionProfileService = _extensionProfileService;\n            this._anotherExtensionService = _anotherExtensionService;\n            this._telemetryService = _telemetryService;\n            this._logService = _logService;\n            this._notificationService = _notificationService;\n            this._editorService = _editorService;\n            this._session = new Map();\n            this._blame = new Set();\n            this._register(_extensionService.onDidChangeResponsiveChange(this._onDidChangeResponsiveChange, this));\n        }\n        _onDidChangeResponsiveChange(event) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const { target } = event;\n                if (!target.canProfileExtensionHost()) {\n                    return;\n                }\n                if (event.isResponsive && this._session.has(target)) {\n                    // stop profiling when responsive again\n                    this._session.get(target).cancel();\n                }\n                else if (!event.isResponsive && !this._session.has(target)) {\n                    // start profiling if not yet profiling\n                    const token = new cancellation_1.CancellationTokenSource();\n                    this._session.set(target, token);\n                    let session;\n                    try {\n                        session = yield target.startExtensionHostProfile();\n                    }\n                    catch (err) {\n                        this._session.delete(target);\n                        // fail silent as this is often\n                        // caused by another party being\n                        // connected already\n                        return;\n                    }\n                    // wait 5 seconds or until responsive again\n                    yield new Promise(resolve => {\n                        token.token.onCancellationRequested(resolve);\n                        setTimeout(resolve, 5e3);\n                    });\n                    try {\n                        // stop profiling and analyse results\n                        this._processCpuProfile(yield session.stop());\n                    }\n                    catch (err) {\n                        errors_1.onUnexpectedError(err);\n                    }\n                    finally {\n                        this._session.delete(target);\n                    }\n                }\n            });\n        }\n        _processCpuProfile(profile) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let data = [];\n                for (let i = 0; i < profile.ids.length; i++) {\n                    let id = profile.ids[i];\n                    let total = profile.deltas[i];\n                    data.push({ id, total, percentage: 0 });\n                }\n                // merge data by identifier\n                let anchor = 0;\n                data.sort((a, b) => a.id.localeCompare(b.id));\n                for (let i = 1; i < data.length; i++) {\n                    if (data[anchor].id === data[i].id) {\n                        data[anchor].total += data[i].total;\n                    }\n                    else {\n                        anchor += 1;\n                        data[anchor] = data[i];\n                    }\n                }\n                data = data.slice(0, anchor + 1);\n                const duration = profile.endTime - profile.startTime;\n                const percentage = duration / 100;\n                let top;\n                for (const slice of data) {\n                    slice.percentage = Math.round(slice.total / percentage);\n                    if (!top || top.percentage < slice.percentage) {\n                        top = slice;\n                    }\n                }\n                if (!top) {\n                    return;\n                }\n                const extension = yield this._extensionService.getExtension(top.id);\n                if (!extension) {\n                    // not an extension => idle, gc, self?\n                    return;\n                }\n                // add to running extensions view\n                this._extensionProfileService.setUnresponsiveProfile(extension.identifier, profile);\n                // print message to log\n                const path = path_1.join(os_1.tmpdir(), `exthost-${Math.random().toString(16).slice(2, 8)}.cpuprofile`);\n                yield pfs_1.writeFile(path, JSON.stringify(profile.data));\n                this._logService.warn(`UNRESPONSIVE extension host, '${top.id}' took ${top.percentage}% of ${duration / 1e3}ms, saved PROFILE here: '${path}'`, data);\n                // send telemetry\n                const id = uuid_1.generateUuid();\n                /* __GDPR__\n                    \"exthostunresponsive\" : {\n                        \"id\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\n                        \"duration\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n                        \"data\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" }\n                    }\n                */\n                this._telemetryService.publicLog('exthostunresponsive', {\n                    id,\n                    duration,\n                    data,\n                });\n                // prompt: when really slow/greedy\n                if (!(top.percentage >= 99 && top.total >= 5e6)) {\n                    return;\n                }\n                // prompt: only when you can file an issue\n                const reportAction = new runtimeExtensionsEditor_1.ReportExtensionIssueAction({\n                    marketplaceInfo: this._anotherExtensionService.local.filter(value => extensions_3.ExtensionIdentifier.equals(value.identifier.id, extension.identifier))[0],\n                    description: extension,\n                    unresponsiveProfile: profile,\n                    status: undefined,\n                });\n                if (!reportAction.enabled) {\n                    return;\n                }\n                // only blame once per extension, don't blame too often\n                if (this._blame.has(extensions_3.ExtensionIdentifier.toKey(extension.identifier)) || this._blame.size >= 3) {\n                    return;\n                }\n                this._blame.add(extensions_3.ExtensionIdentifier.toKey(extension.identifier));\n                // user-facing message when very bad...\n                this._notificationService.prompt(notification_1.Severity.Warning, nls_1.localize('unresponsive-exthost', \"The extension '{0}' took a very long time to complete its last operation and it has prevented other extensions from running.\", extension.displayName || extension.name), [{\n                        label: nls_1.localize('show', 'Show Extensions'),\n                        run: () => this._editorService.openEditor(new runtimeExtensionsInput_1.RuntimeExtensionsInput())\n                    },\n                    {\n                        label: nls_1.localize('report', \"Report Issue\"),\n                        run: () => {\n                            /* __GDPR__\n                                \"exthostunresponsive/report\" : {\n                                    \"id\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" }\n                                }\n                            */\n                            this._telemetryService.publicLog('exthostunresponsive/report', { id });\n                            return reportAction.run();\n                        }\n                    }], { silent: true });\n            });\n        }\n    };\n    ExtensionsAutoProfiler = __decorate([\n        __param(0, extensions_1.IExtensionService),\n        __param(1, runtimeExtensionsEditor_1.IExtensionHostProfileService),\n        __param(2, extensions_2.IExtensionsWorkbenchService),\n        __param(3, telemetry_1.ITelemetryService),\n        __param(4, log_1.ILogService),\n        __param(5, notification_1.INotificationService),\n        __param(6, editorService_1.IEditorService)\n    ], ExtensionsAutoProfiler);\n    exports.ExtensionsAutoProfiler = ExtensionsAutoProfiler;\n});\n",null]}